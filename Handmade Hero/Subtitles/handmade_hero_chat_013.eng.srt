1
00:00:02,700 --> 00:00:04,800
Hello, everyone, and welcome to handmade hero.

2
00:00:04,800 --> 00:00:08,700
Show recode a complete game live on stream today.

3
00:00:08,700 --> 00:00:13,600
I actually decided because this has come up many, many times that I

4
00:00:13,600 --> 00:00:19,800
think today, we're going to do a handmade chat, not a handmade hero

5
00:00:21,200 --> 00:00:26,700
because I would like to really clarify this and it's the sort of thing

6
00:00:26,700 --> 00:00:29,000
that comes up really frequently.

7
00:00:29,700 --> 00:00:30,400
And

8
00:00:32,400 --> 00:00:37,200
Guess you know, if I had done a complete introduction to see series

9
00:00:37,200 --> 00:00:41,100
ever which I've never really done, which you know, someday would

10
00:00:41,100 --> 00:00:42,000
probably be nice.

11
00:00:42,500 --> 00:00:44,800
We would have covered all this sort of stuff but since handmade here

12
00:00:44,800 --> 00:00:48,500
is really only about how to do game programming and it kind of assumes

13
00:00:48,500 --> 00:00:52,000
that you already know how to do non-game programming of some kind.

14
00:00:52,500 --> 00:00:55,500
There's a lot of kind of gaps in the understanding potentially about

15
00:00:55,500 --> 00:00:56,400
what's going on.

16
00:00:56,600 --> 00:01:01,000
In terms of how see is doing things, how the CPU is doing things and

17
00:01:01,000 --> 00:01:01,300
so on.

18
00:01:01,300 --> 00:01:02,300
And we dive

19
00:01:02,400 --> 00:01:03,000
Into it.

20
00:01:04,000 --> 00:01:08,200
at appropriate times on handmade hero but we sort of leave it, you

21
00:01:08,200 --> 00:01:13,100
know, as just understood a lot of the times, if I'm not specifically

22
00:01:13,100 --> 00:01:13,800
addressing it,

23
00:01:15,400 --> 00:01:18,100
And so, what I want to do is just maybe take some time to kind of go

24
00:01:18,100 --> 00:01:22,900
over some things in a little more detail today and I do apologize for

25
00:01:22,900 --> 00:01:25,300
people who already know these, but I feel like once in a while, it's

26
00:01:25,300 --> 00:01:28,200
good to kind of just do a chat where we kind of address, some things

27
00:01:28,200 --> 00:01:33,000
in detail, that people who aren't familiar with sort of lower level

28
00:01:33,000 --> 00:01:35,900
programming, have a hard time wrapping their head around and we may

29
00:01:35,900 --> 00:01:38,900
have said them on and made here but we don't necessarily dedicate a

30
00:01:38,900 --> 00:01:42,400
whole lot of time into looking into them, other than just stating

31
00:01:42,400 --> 00:01:44,400
what's going on and you know moving on.

32
00:01:45,600 --> 00:01:49,000
So this was more to be motivated by yesterday.

33
00:01:51,200 --> 00:01:53,000
I'm going to go ahead and bring up this email here.

34
00:01:53,500 --> 00:01:56,600
I asked one of the people on the chat who had been asking some

35
00:01:56,600 --> 00:02:02,600
questions on the the chat to write in and sort of more completely

36
00:02:02,600 --> 00:02:03,100
describe.

37
00:02:03,100 --> 00:02:06,100
Sort of the problems of understanding they were having with pickle

38
00:02:06,100 --> 00:02:06,400
thing.

39
00:02:06,700 --> 00:02:08,900
They had been asking about on the chat and I was like, just send me a

40
00:02:08,900 --> 00:02:13,000
thing and we'll we'll kind of go over it because I get this

41
00:02:13,000 --> 00:02:14,700
specifically asked about this.

42
00:02:15,000 --> 00:02:19,100
Ticular thing actually, often, this is not in any way.

43
00:02:19,100 --> 00:02:22,500
The only time I've been asked about this and I think that for whatever

44
00:02:22,500 --> 00:02:29,300
reason, it's a uniquely confusing aspect of perhaps, C C++, or

45
00:02:29,300 --> 00:02:33,000
actually also just perhaps low level programming in general.

46
00:02:33,600 --> 00:02:35,100
So I just kind of want to go over it here.

47
00:02:35,100 --> 00:02:36,900
So I'm going to go ahead and read this.

48
00:02:37,200 --> 00:02:38,200
That's not very long.

49
00:02:39,100 --> 00:02:41,800
And then I'm going to sort of break it apart and start talking about

50
00:02:41,800 --> 00:02:46,400
how these things work, and try to really like cement how this stuff

51
00:02:46,400 --> 00:02:46,700
happens.

52
00:02:46,700 --> 00:02:49,300
So that when these questions are asking the future, we have an episode

53
00:02:49,300 --> 00:02:52,400
of point or like here is an episode that explains completely from

54
00:02:52,400 --> 00:02:54,700
start to finish, everything you need to know about this.

55
00:02:55,100 --> 00:02:59,700
So the email goes well, okay, see, I'm Nico 314 from your stream and

56
00:03:00,000 --> 00:03:03,000
Leave their on the stream today as well.

57
00:03:03,400 --> 00:03:05,100
Who asked question about type testing of functions.

58
00:03:05,100 --> 00:03:07,500
I'm trying to follow along with your file IO code.

59
00:03:07,500 --> 00:03:12,000
First establish, an episode 15 then completed in 24 and 25, not 100%

60
00:03:12,000 --> 00:03:12,200
sure.

61
00:03:12,200 --> 00:03:15,100
But you're far, Lyoko definitely changes from the 15th episode.

62
00:03:15,300 --> 00:03:18,500
You use the following lines of your platform layer and it has what we

63
00:03:18,500 --> 00:03:20,400
are all sort of familiar with.

64
00:03:20,400 --> 00:03:24,600
Now, is the way that I typically do function pointers if they're going

65
00:03:24,600 --> 00:03:27,800
to be defined in multiple places, which is I make a pound to find for

66
00:03:27,800 --> 00:03:29,900
the function signature that I make a typedef.

67
00:03:30,000 --> 00:03:34,300
If using that pounded fine, again, I'm going to go over these in a

68
00:03:34,300 --> 00:03:38,300
little more detail later, but that's not the real meat of the

69
00:03:38,300 --> 00:03:38,700
question.

70
00:03:39,300 --> 00:03:41,600
I think this creates a type called debug platform, read entire file,

71
00:03:41,600 --> 00:03:44,500
that returns a debug read file result and takes a thread context

72
00:03:44,500 --> 00:03:45,900
pointer and a care pointer.

73
00:03:46,500 --> 00:03:50,300
And that is a correct thing to think this will allow us to declare a

74
00:03:50,300 --> 00:03:51,800
function of this signature as a type.

75
00:03:51,800 --> 00:03:52,800
And that's a function pointer.

76
00:03:52,800 --> 00:03:55,900
Another place in Winter three-layer, you define a function that

77
00:03:55,900 --> 00:03:58,900
matches the signature of the typedef that will actually load a file in

78
00:03:58,900 --> 00:03:59,800
Windows as

79
00:04:00,000 --> 00:04:00,600
Here it is.

80
00:04:01,800 --> 00:04:03,200
I believe the macro changes mr.

81
00:04:03,200 --> 00:04:05,500
Reed, and then puts that there and he is again.

82
00:04:05,800 --> 00:04:08,300
Correct writing it.

83
00:04:11,000 --> 00:04:13,800
This means you can declare the following debug platform read entire

84
00:04:13,800 --> 00:04:14,700
file star, a equals.

85
00:04:14,700 --> 00:04:16,399
Debug that from the entire file.

86
00:04:17,000 --> 00:04:21,300
I inserted the star there because it seems it can only be used when we

87
00:04:21,300 --> 00:04:22,700
have a pointer correct.

88
00:04:22,800 --> 00:04:25,600
I tried to make it, not a pointer and test program and a function

89
00:04:25,600 --> 00:04:26,900
can't be initialized.

90
00:04:27,100 --> 00:04:29,700
The left hand side of the Declaration is what you're declaring in the

91
00:04:29,700 --> 00:04:29,900
game.

92
00:04:29,900 --> 00:04:32,800
Memory struct and assigning it to the same function in the winter to

93
00:04:32,800 --> 00:04:33,100
layer.

94
00:04:33,100 --> 00:04:35,500
When you initialize the gamer instructed assign members were going to

95
00:04:35,500 --> 00:04:35,800
use the term.

96
00:04:35,800 --> 00:04:36,400
I was wrong.

97
00:04:36,500 --> 00:04:37,800
I'm not from the Cs world.

98
00:04:38,200 --> 00:04:40,600
As of writing this, I'm getting the vibe that there is no way.

99
00:04:40,700 --> 00:04:43,800
For a CPP file to communicate with another CPP file.

100
00:04:44,800 --> 00:04:46,800
Without the use of function pointers.

101
00:04:46,800 --> 00:04:48,500
I think that's what a callback is.

102
00:04:48,800 --> 00:04:52,700
I have to think about this more before I say anything further, I also

103
00:04:52,700 --> 00:04:56,500
have some header file problems to where one is referenced in another

104
00:04:56,500 --> 00:04:57,300
that is causing further.

105
00:04:57,300 --> 00:05:01,400
Confusion on another note to me, understanding pointers doesn't really

106
00:05:01,400 --> 00:05:03,900
tell me about how to utilize a function pointer.

107
00:05:03,900 --> 00:05:05,800
I get that a pointer, isn't Addison memory.

108
00:05:06,100 --> 00:05:08,800
That stores another address in memory, that stores a value.

109
00:05:08,800 --> 00:05:11,200
Depending on the type, or more generally reads, a certain number of

110
00:05:11,200 --> 00:05:13,500
bytes starting at that memory address based on the type, it was

111
00:05:13,500 --> 00:05:14,100
declared

112
00:05:14,800 --> 00:05:15,600
Or cast it to.

113
00:05:15,900 --> 00:05:18,700
I made function pointers in a test program and it behaves slightly

114
00:05:18,700 --> 00:05:20,100
different from an integer pointer.

115
00:05:20,300 --> 00:05:24,100
If I have a function pointer called see and I watch see and star see,

116
00:05:24,300 --> 00:05:27,600
they reported the same, it gives me a memory address.

117
00:05:27,600 --> 00:05:30,700
Then saves the says, the signature of the function in parentheses, if

118
00:05:30,700 --> 00:05:33,100
C was an integer pointer, see would return the memory as to the

119
00:05:33,100 --> 00:05:36,000
integer and starseed return the integer value itself.

120
00:05:36,300 --> 00:05:38,400
None of this helps me, understand implementation.

121
00:05:38,400 --> 00:05:41,900
It's like saying, f equals the derivative of p with respect to time.

122
00:05:42,100 --> 00:05:44,400
Now, I should be able to solve every Newtonian mechanics.

123
00:05:44,500 --> 00:05:47,900
Oblem, I'm new to C++, C and C++ and I've learned everything.

124
00:05:47,900 --> 00:05:49,500
I know about it from watching your stream.

125
00:05:49,500 --> 00:05:52,800
My degree is in physics and I started coding with C sharp eight years

126
00:05:52,800 --> 00:05:53,600
ago for work purposes.

127
00:05:53,600 --> 00:05:56,600
So all my experience is based on what I'd call pattern recognition.

128
00:05:56,600 --> 00:05:59,900
I found out about handmade hero around two years after you started.

129
00:06:00,000 --> 00:06:02,900
I've been watching every episode, sometimes, more than once and

130
00:06:02,900 --> 00:06:04,400
chugging along on episode 52.

131
00:06:04,400 --> 00:06:06,300
Currently, I found them in Caskey different.

132
00:06:06,300 --> 00:06:08,900
Some fascinating as I've never seen an application of it.

133
00:06:08,900 --> 00:06:11,600
I only know Mankowski from space-time relativity, diagrams.

134
00:06:11,700 --> 00:06:14,400
I watch your my rocket video from 2006 on Mankowski.

135
00:06:14,400 --> 00:06:15,600
Jake albums as well.

136
00:06:15,800 --> 00:06:17,100
I can't thank you enough for the work.

137
00:06:17,100 --> 00:06:20,200
You put in a streaming and educating its best $15 ever spent sorry for

138
00:06:20,200 --> 00:06:20,700
the long scar.

139
00:06:20,700 --> 00:06:22,900
Me an email, I spent several hours running it and I'm really tired

140
00:06:22,900 --> 00:06:23,300
right now.

141
00:06:24,800 --> 00:06:26,500
First of all, thank you for writing in.

142
00:06:26,500 --> 00:06:28,400
This is very complete and gives me everything.

143
00:06:28,400 --> 00:06:32,700
I need to understand, sort of where your confusions, probably are with

144
00:06:32,700 --> 00:06:33,500
some of this stuff.

145
00:06:34,500 --> 00:06:38,800
And let me first finish my bubble tea here and I will kind of go into

146
00:06:38,800 --> 00:06:39,500
more detail here.

147
00:06:43,200 --> 00:06:43,600
Okay.

148
00:06:44,800 --> 00:06:47,800
Wait, there's still there's still some tapioca left in my bubble tea.

149
00:06:49,000 --> 00:06:50,900
I got to get those those out here.

150
00:06:53,500 --> 00:06:54,900
Never leave a boba behind.

151
00:06:55,100 --> 00:06:57,600
That's my my feeling ability, right?

152
00:06:59,200 --> 00:07:06,700
Okay, so first of all, let me say that I don't think you are alone in

153
00:07:06,700 --> 00:07:10,800
your feeling that function pointers and calling functions in general,

154
00:07:10,800 --> 00:07:14,600
is a little bit impenetrable in terms of understanding how it works.

155
00:07:14,600 --> 00:07:17,200
And see it's one of those things.

156
00:07:18,500 --> 00:07:22,800
That see kind of dances around a little bit and maybe doesn't end up

157
00:07:22,800 --> 00:07:27,900
doing a particularly good job at making be orthogonal and logical.

158
00:07:29,200 --> 00:07:32,500
You know, programming languages, all have things that they do well and

159
00:07:32,500 --> 00:07:36,000
things that they don't do so well and they're always edge cases stuff

160
00:07:36,000 --> 00:07:36,600
like that.

161
00:07:37,300 --> 00:07:41,800
See, I don't think really ever reached maturity with respect to the

162
00:07:42,300 --> 00:07:44,500
relationship between code and data.

163
00:07:45,000 --> 00:07:47,800
It's just not something that really happened in.

164
00:07:47,800 --> 00:07:48,000
See,

165
00:07:49,100 --> 00:07:54,600
It's a problem and it does carry forward to today and not only does it

166
00:07:54,600 --> 00:07:58,100
create problems with respect to what we can do in C and what we would

167
00:07:58,100 --> 00:07:59,400
like to be able to do and see.

168
00:08:00,400 --> 00:08:03,900
But it also creates problems of the form you're experiencing which is

169
00:08:03,900 --> 00:08:09,200
to say that and actually I would say that I actually disagree with

170
00:08:09,200 --> 00:08:12,700
your analogy of f equals DP over DT.

171
00:08:12,700 --> 00:08:15,300
Now she will solve every Newtonian mechanics from that's actually

172
00:08:15,300 --> 00:08:18,000
being more generous to see than it deserves because

173
00:08:18,100 --> 00:08:19,300
F equals DP over.

174
00:08:19,300 --> 00:08:23,800
DT is actually at least consistent with every Newtonian mechanics

175
00:08:23,800 --> 00:08:26,000
problem and there are no gotchas in there.

176
00:08:26,000 --> 00:08:29,500
As far as I'm aware sees function, pointer stuff actually is not at

177
00:08:29,500 --> 00:08:33,799
all consistent with the way, the other pointers to things work in a

178
00:08:33,799 --> 00:08:34,500
lot of ways.

179
00:08:34,500 --> 00:08:39,400
And so in some sense, it's not even as good as saying f equals the

180
00:08:39,400 --> 00:08:40,799
derivative of position over time.

181
00:08:40,900 --> 00:08:42,700
Go solve every Newtonian mechanics problem.

182
00:08:43,299 --> 00:08:47,600
You're actually at a more severe disadvantage if you will, in trying

183
00:08:47,600 --> 00:08:47,900
to come

184
00:08:48,100 --> 00:08:51,600
Matt sees use of functions and pointers and try to understand them.

185
00:08:51,600 --> 00:08:56,300
Just from understanding how regular pointers work and extrapolating

186
00:08:56,300 --> 00:08:56,900
from there.

187
00:08:57,600 --> 00:08:59,800
So let me start out with a few.

188
00:09:00,000 --> 00:09:03,000
Basic things that I think we should get straight.

189
00:09:03,000 --> 00:09:05,600
That have never really been addressed on handmade here, very much,

190
00:09:05,600 --> 00:09:09,900
because they're not really relevant to the way we do development on

191
00:09:09,900 --> 00:09:10,700
handmade hero.

192
00:09:10,700 --> 00:09:14,900
And that really has to do with translation units.

193
00:09:15,100 --> 00:09:18,500
What they are, how source code is linked and so on.

194
00:09:19,200 --> 00:09:23,300
I'd like to start with that and then build up to the function pointer

195
00:09:23,300 --> 00:09:26,000
part of things as we go.

196
00:09:26,100 --> 00:09:26,600
Okay?

197
00:09:27,200 --> 00:09:29,000
So let's let's do some of that.

198
00:09:29,600 --> 00:09:29,800
So

199
00:09:30,000 --> 00:09:33,700
so what I want to point out in a kind of go back and this should be

200
00:09:33,700 --> 00:09:38,800
probably more familiar to the the person who is writing in then,

201
00:09:38,800 --> 00:09:41,400
probably a lot of the other people are watching because the person is

202
00:09:41,400 --> 00:09:45,100
writing in started recently at the beginning of the series, everyone

203
00:09:45,100 --> 00:09:46,100
else maybe has forgotten.

204
00:09:46,100 --> 00:09:50,400
We did to be a serious but obviously, you know that we in our code we

205
00:09:50,400 --> 00:09:55,100
have a thing called build up, bat here and build up at is just a batch

206
00:09:55,100 --> 00:09:55,400
file.

207
00:09:55,400 --> 00:09:58,800
That does our build now, why do I use a batch file to do our build?

208
00:09:58,800 --> 00:09:59,800
Well, the reason I use a batch

209
00:10:00,000 --> 00:10:06,600
Of durability is because, you know, maybe five six years ago or so I

210
00:10:06,600 --> 00:10:12,700
found that build systems, took more time to maintain and use, then

211
00:10:12,700 --> 00:10:17,700
they actually saved in practice and that most code, even code.

212
00:10:17,700 --> 00:10:23,500
That's 200,000, 300,000 lines of worth of source which are the kinds

213
00:10:23,500 --> 00:10:28,700
of sized projects that I typically deal with are, are just not, it's

214
00:10:28,700 --> 00:10:29,800
not necessary to use.

215
00:10:29,900 --> 00:10:30,800
Use a build tool.

216
00:10:30,800 --> 00:10:34,500
Now, when you get into heinous monstrosities that are like, libraries

217
00:10:34,500 --> 00:10:37,700
on top of libraries, on top of libraries, on top of libraries, on top

218
00:10:37,700 --> 00:10:42,300
of Java, on top of emscripten and top of JavaScript and like, piles

219
00:10:42,300 --> 00:10:42,600
and piles.

220
00:10:42,600 --> 00:10:44,300
I guess that you couldn't really do that quite that.

221
00:10:44,600 --> 00:10:46,900
You can't put any script on top of JavaScript, but you know what?

222
00:10:46,900 --> 00:10:52,100
I mean, if you if you have these monstrosity is that are kind of the

223
00:10:52,100 --> 00:10:54,700
way that people build some of these modern projects, which I won't

224
00:10:54,700 --> 00:10:55,700
touch the 10-foot pole.

225
00:10:56,100 --> 00:10:58,800
Then you can understand why people may be still need to use build

226
00:10:58,800 --> 00:10:59,800
systems because these

227
00:11:00,000 --> 00:11:06,700
Things take hours potentially to build from scratch, but in our case

228
00:11:06,700 --> 00:11:10,400
we're talking about a game code base that's written by hand and is

229
00:11:10,400 --> 00:11:11,400
relatively clean.

230
00:11:11,500 --> 00:11:15,100
These things can be several hundreds of thousands of lines which is is

231
00:11:15,100 --> 00:11:18,200
sufficient for any game that I've ever seen.

232
00:11:19,300 --> 00:11:24,500
Really if you're actually being coherent about it, you just don't need

233
00:11:24,500 --> 00:11:24,700
them.

234
00:11:24,700 --> 00:11:27,900
So that's why I use a build up at to build it.

235
00:11:28,000 --> 00:11:29,800
And the way that I do that is I

236
00:11:29,900 --> 00:11:34,600
I call a single or in this case two different calls to the compiler

237
00:11:35,200 --> 00:11:40,000
and in those lines it implicitly invokes the Linker it's a compile and

238
00:11:40,000 --> 00:11:41,000
Link command.

239
00:11:42,700 --> 00:11:46,700
I only call it twice and I only produce to executable portions ones,

240
00:11:46,700 --> 00:11:48,200
an executable and ones that deal.

241
00:11:48,200 --> 00:11:51,700
L that is how we build handmade hero implicit in.

242
00:11:51,700 --> 00:11:56,400
That is a bunch of stuff that is relevant to the understanding of what

243
00:11:56,400 --> 00:11:58,800
a function pointer even is.

244
00:12:00,000 --> 00:12:04,800
How they come about and where you how you can start to understand

245
00:12:04,800 --> 00:12:11,900
things such as the question that was asked in the email about how one

246
00:12:11,900 --> 00:12:13,500
CPP file talks to another.

247
00:12:13,700 --> 00:12:18,800
So what I'd like to do is depart just briefly from the build bat that

248
00:12:18,800 --> 00:12:22,500
we were using so that we can talk about what the compiler actually

249
00:12:22,500 --> 00:12:24,700
does, what the Linker actually does.

250
00:12:24,800 --> 00:12:29,800
Look at both of those and start to talk about what a CPP file even.

251
00:12:30,000 --> 00:12:34,400
Is what an H file is, and all of those sorts of things, so that you

252
00:12:34,400 --> 00:12:38,000
can really get a coherent understanding of exactly what's going on

253
00:12:38,000 --> 00:12:38,400
here.

254
00:12:39,200 --> 00:12:42,800
And then we'll move up to the, to the code level.

255
00:12:42,800 --> 00:12:47,500
The assembly level itself and watch exactly how these things are

256
00:12:47,500 --> 00:12:49,600
working on a number of fronts, Okay?

257
00:12:50,200 --> 00:12:50,800
So,

258
00:12:53,100 --> 00:12:54,300
Let me start.

259
00:12:56,700 --> 00:13:02,300
By making something out here in the temp directory let's say and or

260
00:13:02,300 --> 00:13:04,300
not temp directory but I'm going to call this.

261
00:13:04,300 --> 00:13:06,600
What was the name that was on here?

262
00:13:07,200 --> 00:13:11,200
Okay so I'm going to call this nacre 314.

263
00:13:11,500 --> 00:13:12,300
It's a deadly.

264
00:13:12,300 --> 00:13:14,600
I should mention that that if those of you who are with me on the

265
00:13:14,600 --> 00:13:19,100
freestream, know that I was eating a meat pie for lunch and the place

266
00:13:19,100 --> 00:13:22,800
where I got the meat pie was actually is called 314 pie.

267
00:13:23,700 --> 00:13:25,800
So I feel like this is serendipitous and

268
00:13:26,000 --> 00:13:30,200
Anyway, so here I am in a clean directory.

269
00:13:31,000 --> 00:13:34,500
And what I'm going to do is, I'm just going to make a file in here.

270
00:13:34,800 --> 00:13:37,200
I don't know what it's going to be temp.

271
00:13:37,200 --> 00:13:43,500
Dot CPP, let's say, or maybe I'll call this main.cpp.

272
00:13:44,900 --> 00:13:47,000
And then I'm going to open it in for coder.

273
00:13:48,500 --> 00:13:49,000
Here it is.

274
00:13:49,100 --> 00:13:50,200
I don't actually need that there.

275
00:13:51,300 --> 00:13:55,100
But what we're going to do here, is I'm going to make something that

276
00:13:55,100 --> 00:13:57,200
the C compiler can compile, right?

277
00:13:57,200 --> 00:13:58,900
I'm just going to make a very, very simple thing.

278
00:13:58,900 --> 00:14:01,000
Like, you've seen many times before and I'm not going to decorate it

279
00:14:01,000 --> 00:14:01,700
in any way.

280
00:14:02,300 --> 00:14:05,200
I'm just going to have a void function here.

281
00:14:05,800 --> 00:14:11,200
I'm going to, you know, make something where I take an inch in and

282
00:14:11,200 --> 00:14:12,400
that's it, right?

283
00:14:13,200 --> 00:14:17,800
And maybe I'll make it a little bit more interesting here by saying

284
00:14:17,800 --> 00:14:18,200
that I

285
00:14:18,300 --> 00:14:19,400
I'm going to generate a result.

286
00:14:19,400 --> 00:14:23,400
I'm going to multiply whatever the input is that I receive.

287
00:14:23,500 --> 00:14:26,200
I'm going to multiply it by 2, right?

288
00:14:26,800 --> 00:14:31,500
So that's the the entirety of what I've what I've created, right.

289
00:14:34,800 --> 00:14:39,700
So we all know intuitively what this is now, right?

290
00:14:39,700 --> 00:14:42,900
We all know intuitively what we're looking at here, but how often do

291
00:14:42,900 --> 00:14:46,000
we really talked about, you know, in on handmade hero we don't.

292
00:14:46,200 --> 00:14:50,400
How often do we really talk about exactly what's going on in here,

293
00:14:50,400 --> 00:14:50,900
right?

294
00:14:51,100 --> 00:14:56,000
So this means that CBP is just a text file on a drive, right?

295
00:14:56,800 --> 00:14:59,800
And it's really crucial to emphasize this point.

296
00:15:00,500 --> 00:15:04,300
In certain sense because there are languages out there where files

297
00:15:04,300 --> 00:15:08,900
have more meaning but in C++ and C and C and C++.

298
00:15:09,400 --> 00:15:13,400
It's important to understand that files on a drive, literally have no

299
00:15:13,400 --> 00:15:15,500
meaning until we invoke the compiler.

300
00:15:15,500 --> 00:15:20,300
And it sort of is instructed as to how to interpret those files files.

301
00:15:20,300 --> 00:15:24,600
Don't have a one-to-one correspondence with anything in particular in

302
00:15:24,600 --> 00:15:25,000
C.

303
00:15:25,500 --> 00:15:28,100
And so it's important to stand all we have done now.

304
00:15:28,600 --> 00:15:29,900
Again, it may seem

305
00:15:30,000 --> 00:15:31,100
But just going to hammer it home.

306
00:15:31,200 --> 00:15:36,500
All we have done is type some text into a file and it has no meaning

307
00:15:36,500 --> 00:15:37,500
whatsoever, right?

308
00:15:38,100 --> 00:15:38,500
Not yet.

309
00:15:38,500 --> 00:15:39,000
Anyway.

310
00:15:40,000 --> 00:15:44,000
Okay, so now if I'm out here, I have the ability to invoke a compiler.

311
00:15:44,000 --> 00:15:46,800
In my case, it's Microsoft C compiler.

312
00:15:46,800 --> 00:15:47,800
So I type c l.

313
00:15:47,900 --> 00:15:51,900
If you were on another platform maybe you would be typing clang or Cc

314
00:15:51,900 --> 00:15:52,400
or something.

315
00:15:52,400 --> 00:15:56,500
If you run Linux or on Mac OS X or something like this, but point

316
00:15:56,500 --> 00:15:59,800
being I have some way to invoke a compiler and

317
00:16:00,000 --> 00:16:06,100
There's two different ways that I might ask the compiler to deal with

318
00:16:06,100 --> 00:16:06,800
this file.

319
00:16:07,600 --> 00:16:11,500
One is traditionally called compilation and the other is traditionally

320
00:16:11,500 --> 00:16:12,500
called linking.

321
00:16:12,500 --> 00:16:16,300
And we don't super distinguish, those two and handmade hero, but I

322
00:16:16,300 --> 00:16:17,500
want to distinguish them now.

323
00:16:18,100 --> 00:16:21,600
So, what I'm going to do first is I'm going to take this main.cpp

324
00:16:21,600 --> 00:16:22,400
file, right?

325
00:16:23,400 --> 00:16:25,600
And I'm just going to call CL on it.

326
00:16:25,600 --> 00:16:28,000
And I want you to see what happens, right?

327
00:16:28,200 --> 00:16:29,800
So when I just call CL

328
00:16:29,900 --> 00:16:31,100
With main.cpp.

329
00:16:31,100 --> 00:16:35,000
What you can see here is actually two steps have occurred.

330
00:16:35,200 --> 00:16:40,800
The first step is it is, if it is invoked the compiler, which you can

331
00:16:40,800 --> 00:16:44,700
see here on main.cpp and what you'll note is, there were no errors.

332
00:16:44,700 --> 00:16:46,000
Now I could have had an error.

333
00:16:46,000 --> 00:16:47,700
Like maybe I accidentally typed.

334
00:16:47,700 --> 00:16:48,300
Why here?

335
00:16:48,300 --> 00:16:52,000
Right then it would have stopped it would have invoked the compiler

336
00:16:52,000 --> 00:16:56,900
and stopped, okay, but instead if you take a look at what happens with

337
00:16:56,900 --> 00:16:59,800
what I have here, when there's no errors it, then progress.

338
00:17:00,000 --> 00:17:03,700
Is on to a second stage where it's actually invoking the Linker.

339
00:17:03,800 --> 00:17:08,000
Now the Linker is not CL, the Linker is actually a separate command

340
00:17:08,000 --> 00:17:11,099
called link which you can see if I actually type that separately.

341
00:17:11,200 --> 00:17:15,599
But what happens is that CL as a command will impact, will invoke both

342
00:17:15,599 --> 00:17:19,900
the compiler and the Linker if told to do nothing else and that is the

343
00:17:19,900 --> 00:17:23,599
way that it's currently working on handmade hero, right?

344
00:17:24,500 --> 00:17:27,900
So what you'll note here is that you'll see, it says entry point, must

345
00:17:27,900 --> 00:17:29,800
be defined now.

346
00:17:29,900 --> 00:17:30,700
What is happening?

347
00:17:31,400 --> 00:17:33,700
Okay, right, even just right now.

348
00:17:33,700 --> 00:17:35,600
I can already start discussing.

349
00:17:35,700 --> 00:17:39,300
What is going on in terms of functions and how they work and how text

350
00:17:39,300 --> 00:17:41,400
files are related to them and all this sort of stuff.

351
00:17:41,500 --> 00:17:43,600
So let's break down exactly what we're seeing here.

352
00:17:43,600 --> 00:17:47,500
Before we even go one step further and actually do Define an entry

353
00:17:47,500 --> 00:17:48,000
point.

354
00:17:50,200 --> 00:17:50,600
Okay.

355
00:17:52,100 --> 00:17:55,700
So what has happened here is actually a two-stage process.

356
00:17:55,900 --> 00:17:59,800
Where the first thing that happened is this main.cpp.

357
00:18:00,100 --> 00:18:03,900
I was fed to the compiler, it started interpreting it because of its

358
00:18:03,900 --> 00:18:07,400
extension, there's an automatic detection, right?

359
00:18:08,600 --> 00:18:11,500
That occurs here, where it's going to look at the extension.

360
00:18:11,500 --> 00:18:14,800
It's going to see a DOT CPP and Microsoft's compiler.

361
00:18:14,800 --> 00:18:17,900
Will just intuitively treat that as a C++ file.

362
00:18:18,300 --> 00:18:21,700
Meaning it will start to interpret the text that it sees as if it is

363
00:18:21,700 --> 00:18:24,300
C++ text, okay.

364
00:18:24,900 --> 00:18:27,300
That is not an absolute requirement.

365
00:18:27,300 --> 00:18:29,800
For example, let's suppose I did something.

366
00:18:30,000 --> 00:18:34,600
Here, that was exclusively the domain of C++, right?

367
00:18:34,600 --> 00:18:36,300
That does not exist in C.

368
00:18:46,600 --> 00:18:50,400
Here's a bunch of things which should not compiled in a c program, and

369
00:18:50,400 --> 00:18:53,700
when I hit CL main.cpp, you'll notice that it does not complain.

370
00:18:53,800 --> 00:19:00,000
However, if I look at the command line arguments to the compiler, what

371
00:19:00,000 --> 00:19:03,100
I can actually see and of course there's so many of them now that it's

372
00:19:03,100 --> 00:19:07,000
kind of hard to actually find, but if you find, if you can manage to

373
00:19:07,000 --> 00:19:11,200
find it, you can see that you get information in here that actually

374
00:19:11,200 --> 00:19:16,200
tells you what kind of of input file the compiler.

375
00:19:16,400 --> 00:19:18,900
going to expect and let me see if I can actually scroll back up to

376
00:19:18,900 --> 00:19:23,200
this here and see if I can and have some kind of a

377
00:19:25,900 --> 00:19:28,200
And understanding that it should be doing.

378
00:19:28,200 --> 00:19:33,300
See compilation and not C++ compilation which actually maybe I can use

379
00:19:33,300 --> 00:19:36,200
less here to help us find that.

380
00:19:36,300 --> 00:19:40,600
So here, we'll get the help type it to less and then see if I can get

381
00:19:40,600 --> 00:19:44,500
just see as opposed to C++ through here.

382
00:19:45,600 --> 00:19:46,500
Take a look at this.

383
00:19:47,000 --> 00:19:51,800
No, no, there we go.

384
00:19:52,300 --> 00:19:53,900
So you can see right here, this,

385
00:19:54,900 --> 00:19:57,900
You compile all files as dot C, right?

386
00:19:58,100 --> 00:20:02,200
And so what I'm going to do here is I'm going to say you know / TC and

387
00:20:02,200 --> 00:20:03,700
now I'm going to pass it mean, dot CPP.

388
00:20:03,900 --> 00:20:07,000
And what you can see is that now it immediately starts to complain

389
00:20:07,000 --> 00:20:09,700
about these constructs here because it doesn't understand what they

390
00:20:09,700 --> 00:20:10,100
are.

391
00:20:10,100 --> 00:20:12,200
It sees class and assumes, well that must be something.

392
00:20:12,200 --> 00:20:13,600
I don't know what it is yet.

393
00:20:13,600 --> 00:20:16,500
Then I see, this is my class in like, well I can't have an Undeclared,

394
00:20:16,500 --> 00:20:18,900
identifier, followed by another Undeclared identifier something's

395
00:20:18,900 --> 00:20:19,500
wrong.

396
00:20:19,900 --> 00:20:22,300
So you're going to have to, you're going to have to fix this for me,

397
00:20:22,300 --> 00:20:22,800
right?

398
00:20:24,300 --> 00:20:30,100
So again, just to be clear on this, there is no real understanding of

399
00:20:30,100 --> 00:20:34,000
what a file contains until we tell the compiler.

400
00:20:34,000 --> 00:20:38,200
What is looking at and the compiler in this case is operating very

401
00:20:38,200 --> 00:20:40,600
much like a stream processor.

402
00:20:40,700 --> 00:20:45,600
It is taking in the text, it expects that text to be compiled to a

403
00:20:45,600 --> 00:20:49,000
certain language specification by default.

404
00:20:49,000 --> 00:20:52,500
If that came from a CPP file it will assume that it is CPP.

405
00:20:52,500 --> 00:20:54,000
If we tell it otherwise it will not

406
00:20:54,100 --> 00:20:55,100
Not make that assumption.

407
00:20:55,200 --> 00:20:57,300
If it came from a C file, it would assume it.

408
00:20:57,300 --> 00:20:59,900
See again, we could override that if we

409
00:21:00,000 --> 00:21:06,500
To write, but it is acting entirely as a stream processor here and

410
00:21:06,500 --> 00:21:11,500
what that means is that I can just do whatever I want in here and just

411
00:21:11,800 --> 00:21:13,900
the text will just get money together.

412
00:21:14,000 --> 00:21:17,900
So for example, if I have another file as we often do in handmade

413
00:21:17,900 --> 00:21:21,500
hero, I'm going to copy this to like main to dot CPP.

414
00:21:21,500 --> 00:21:27,100
Let's say write what I can do here is I can load main to dot CPP and

415
00:21:27,100 --> 00:21:28,800
put something else in here, right?

416
00:21:28,800 --> 00:21:29,900
Something completely

417
00:21:30,000 --> 00:21:35,200
Other than that, where I say, you know, in bar, in y, and maybe this

418
00:21:35,200 --> 00:21:39,000
has a result, and it is y times y, so it's squared, and I'm going to

419
00:21:39,000 --> 00:21:43,000
return that result, you know, in here, if I were to call this.

420
00:21:43,000 --> 00:21:47,100
So I were to say, okay, the result is actually that I crawl bar of 2

421
00:21:47,100 --> 00:21:51,900
times x like so you can now see that I'm calling the main two dot CPP

422
00:21:51,900 --> 00:21:53,200
file from the main.c file.

423
00:21:53,400 --> 00:21:56,400
If I were to merely call the compilation step on this.

424
00:21:56,400 --> 00:21:59,900
Now what you will see is that the compiler is taking,

425
00:22:00,000 --> 00:22:03,000
A text file in, its doing the compilation on it.

426
00:22:03,000 --> 00:22:05,200
It does not see, right?

427
00:22:05,200 --> 00:22:09,000
It is not see bar anywhere.

428
00:22:09,800 --> 00:22:14,200
So when it gets to the, the request to call Bar, it's like I don't

429
00:22:14,200 --> 00:22:16,800
know what you're talking about right now.

430
00:22:16,800 --> 00:22:19,800
There's a number of ways that I can fix that problem.

431
00:22:19,800 --> 00:22:21,900
And problem is the wrong thing to say here, because what, I'm trying

432
00:22:21,900 --> 00:22:24,900
to adjust show how the stream processing works and start just to

433
00:22:24,900 --> 00:22:27,800
motivate our discussion of functions and how they work.

434
00:22:27,900 --> 00:22:29,800
So it's not really a problem, but there's multiple ways I can.

435
00:22:29,900 --> 00:22:33,800
Get bar into the visibility of the compiler in this step.

436
00:22:33,900 --> 00:22:36,900
One of them is I could just include the CPP file.

437
00:22:37,000 --> 00:22:40,600
Now, again, this may seem counterintuitive especially to people who

438
00:22:40,600 --> 00:22:43,800
are, you know, indoctrinated perhaps to think that, the only thing you

439
00:22:43,800 --> 00:22:44,900
include her dot h files.

440
00:22:45,100 --> 00:22:49,300
Not true C is compiler, is simply a stream processor.

441
00:22:49,300 --> 00:22:51,700
It does not care where the code comes from.

442
00:22:51,800 --> 00:22:55,400
It does not even look at what the files are or what they are called.

443
00:22:55,400 --> 00:22:59,200
Unless again, it's to do some kind of auto-detection to override.

444
00:23:00,800 --> 00:23:04,100
Detection Auto detection in the case where you have not specified what

445
00:23:04,100 --> 00:23:06,500
language are using so we'll assume C plus plus.

446
00:23:06,500 --> 00:23:10,700
And so on, it's only going to do that on the main file, right?

447
00:23:10,700 --> 00:23:12,500
It's only going to do that on the main file.

448
00:23:12,900 --> 00:23:16,300
So, let me go ahead and motivate this, a little further, for example,

449
00:23:17,800 --> 00:23:21,500
So let's say in this case actually I'm going to I'm going to change

450
00:23:21,500 --> 00:23:24,600
gears slightly here back away a little bit.

451
00:23:24,600 --> 00:23:28,800
From one of the things I just said I'm going to instead of Maine to

452
00:23:28,800 --> 00:23:32,000
.cp, I'm going to call it main 2.c, right?

453
00:23:34,400 --> 00:23:35,300
I would've done this initially.

454
00:23:35,300 --> 00:23:37,600
I thought of it didn't think of it, right?

455
00:23:37,900 --> 00:23:41,400
So I'm going to go ahead and include main 2.c, okay?

456
00:23:42,500 --> 00:23:44,400
And now I'm going to go ahead and do my build again.

457
00:23:45,700 --> 00:23:49,300
Right now you can see the compilation step works.

458
00:23:49,700 --> 00:23:50,200
Okay.

459
00:23:50,600 --> 00:23:52,000
Why does compilation step works?

460
00:23:52,000 --> 00:23:54,700
Is because this include all this directive does.

461
00:23:54,700 --> 00:23:58,300
Is it takes the contents of Maine to see and it sticks.

462
00:23:58,300 --> 00:23:59,800
Those contents in the place of

463
00:24:00,000 --> 00:24:04,100
Include it is literally required to do exactly that.

464
00:24:04,700 --> 00:24:09,000
So, this is not like telling the compiler to import something in the

465
00:24:09,000 --> 00:24:13,800
way that other languages might reference a package, or a file that has

466
00:24:13,800 --> 00:24:18,000
things in it and say, I am going to call Things From This understand

467
00:24:18,000 --> 00:24:19,300
that it's a separate file.

468
00:24:19,300 --> 00:24:21,200
But, you know, I'm going to call Things From it.

469
00:24:21,800 --> 00:24:23,500
C does not make that distinction.

470
00:24:23,700 --> 00:24:28,100
When you do a pound include, it is a direct textual include and so it

471
00:24:28,100 --> 00:24:29,500
has to be considered more like if you're

472
00:24:30,000 --> 00:24:30,700
In other languages.

473
00:24:30,900 --> 00:24:34,900
Things that literally import text directly into the stream of

474
00:24:34,900 --> 00:24:36,400
compilation, right?

475
00:24:36,700 --> 00:24:41,300
So what you'll notice here is that if I went over to main.c mean, 2.c

476
00:24:41,300 --> 00:24:41,800
ripe,

477
00:24:43,000 --> 00:24:46,200
Gun and load that here again just to hammer this home.

478
00:24:46,400 --> 00:24:48,200
Let's put that class thing in there.

479
00:24:55,100 --> 00:24:57,500
Right, let's put that class thing in there.

480
00:24:57,600 --> 00:24:58,100
I can pile.

481
00:24:58,200 --> 00:24:59,000
I don't get any errors.

482
00:24:59,000 --> 00:25:04,700
If I compile main.cpp, even though main to is a DOT C file, again, the

483
00:25:04,700 --> 00:25:09,100
only time that the compiler does Auto detection, is on the initial

484
00:25:09,100 --> 00:25:13,400
file that it is past the pound include is not considered a

485
00:25:13,400 --> 00:25:16,100
re-examination of any files.

486
00:25:16,300 --> 00:25:21,200
It's just taking the file and inserting it verbatim as if you had just

487
00:25:21,200 --> 00:25:22,300
cut and pasted it.

488
00:25:22,400 --> 00:25:24,800
So it is never going to look at what this name.

489
00:25:25,000 --> 00:25:27,600
The only thing that's going to do is use that to load it from the

490
00:25:27,600 --> 00:25:30,100
drive it's never going to think about what that name is.

491
00:25:30,100 --> 00:25:32,900
It's never going to ask if the .h r dot C is difficult to ask.

492
00:25:32,900 --> 00:25:34,300
If it's not C or a Dusty P.

493
00:25:34,300 --> 00:25:36,600
It is literally just a cut and paste.

494
00:25:36,700 --> 00:25:37,500
That's all it is.

495
00:25:38,100 --> 00:25:39,500
I can prove it prove it to you.

496
00:25:39,700 --> 00:25:44,000
If I were to try to compile main 2.c, it would Auto detect that it's a

497
00:25:44,000 --> 00:25:48,500
DOT C file and again, issue the error, because now it's compiling in

498
00:25:48,500 --> 00:25:52,900
see mode, because the time when that auto-detection happens is on the

499
00:25:52,900 --> 00:25:54,700
initial compile, right?

500
00:25:55,100 --> 00:25:59,000
When you initially pass that file, anything that is included in the

501
00:25:59,000 --> 00:26:00,000
file, right?

502
00:26:00,000 --> 00:26:01,200
Is just glommed in.

503
00:26:01,500 --> 00:26:04,900
Okay, we can take this a step further and say, well, I actually can

504
00:26:04,900 --> 00:26:08,700
pass multiple things on the command line, right?

505
00:26:08,800 --> 00:26:13,800
I can tell it in this case that I want to pass Maine and Maine to

506
00:26:13,900 --> 00:26:15,700
write, I can I can ask for both of them.

507
00:26:15,900 --> 00:26:19,700
Now, here's the part where we really depart from.

508
00:26:19,700 --> 00:26:21,300
A lot of the stuff we do in handmade hero.

509
00:26:21,500 --> 00:26:24,500
We're starting to consider multiple file compilation again.

510
00:26:25,000 --> 00:26:28,500
Made hero because it is much more optimal in terms of compile speed.

511
00:26:28,700 --> 00:26:33,700
We compile everything as one big file with just a main base file that

512
00:26:33,700 --> 00:26:37,700
impound includes all the other files because again like I said see

513
00:26:37,700 --> 00:26:43,400
doesn't care about files really in any specific sense, the C compiler.

514
00:26:43,400 --> 00:26:47,300
All its intending to do is to take a big ol stream of text that it

515
00:26:47,300 --> 00:26:51,400
assumes as in either C or C++ form which ever one you tell it and turn

516
00:26:51,400 --> 00:26:54,300
that into its output and we're going to talk a lot about the outputs.

517
00:26:54,300 --> 00:26:54,800
I'm

518
00:26:54,900 --> 00:26:57,600
potentially not going a deeper than that but that's all it's intending

519
00:26:57,600 --> 00:26:58,000
to do.

520
00:26:58,600 --> 00:26:59,800
It can do that.

521
00:27:00,000 --> 00:27:04,300
Times or it can do it one time so if I want to be most Optimum just

522
00:27:04,300 --> 00:27:07,500
going to invoke it once I'm going to have a main.cpp which pound

523
00:27:07,500 --> 00:27:10,800
includes everything else I want and like the actual code not H files

524
00:27:10,800 --> 00:27:15,700
but everything I want H is cpp's all the code into one giant textual

525
00:27:15,700 --> 00:27:19,500
glob that the compiler digest all at once and spits out a single

526
00:27:19,500 --> 00:27:20,600
result, right?

527
00:27:20,900 --> 00:27:22,500
That's for efficiency sake.

528
00:27:24,100 --> 00:27:27,500
But instead like you see here, I can choose to pass things

529
00:27:27,800 --> 00:27:32,300
independently on the command line, and it will compile them in turn

530
00:27:32,300 --> 00:27:33,600
and what you can see Happening.

531
00:27:33,600 --> 00:27:38,300
Here is specifically, it's actually invoking two separate compilation

532
00:27:38,300 --> 00:27:38,900
steps.

533
00:27:38,900 --> 00:27:45,200
One for main 2.c, 14 main.cpp and the main to see one has errors.

534
00:27:45,200 --> 00:27:46,300
The main.cpp.

535
00:27:46,300 --> 00:27:50,900
One does not have any errors other than it does not know what to make

536
00:27:50,900 --> 00:27:53,000
of this call to bar, right?

537
00:27:54,700 --> 00:27:55,200
Okay.

538
00:27:58,200 --> 00:28:00,700
So, I'm going to take a second just to let that sink in.

539
00:28:01,600 --> 00:28:02,000
Okay?

540
00:28:02,500 --> 00:28:05,000
Because again, we're departing from the way that handmade hero things

541
00:28:05,000 --> 00:28:05,600
are built.

542
00:28:06,900 --> 00:28:12,700
So let's dive into this sort of idea, of a multi file build so that we

543
00:28:12,700 --> 00:28:14,400
can start to understand what that means.

544
00:28:14,800 --> 00:28:15,300
Right?

545
00:28:15,600 --> 00:28:21,100
Now again I really want to emphasize a multi file build, really

546
00:28:21,100 --> 00:28:24,000
doesn't have anything to do with the concept that there are multiple

547
00:28:24,000 --> 00:28:24,600
files.

548
00:28:25,000 --> 00:28:26,600
What we're really talking about here.

549
00:28:26,700 --> 00:28:32,000
Is the fact that we're asking the compiler to consider multiple chunks

550
00:28:32,000 --> 00:28:36,600
of text independently, we have chosen to break that up.

551
00:28:36,900 --> 00:28:40,300
Such that one of them is one file and one of them is another but we

552
00:28:40,300 --> 00:28:41,900
could easily not do that.

553
00:28:42,000 --> 00:28:45,400
And so just to underscore that, I'm going to create one more file,

554
00:28:45,500 --> 00:28:47,100
main three dot CPP.

555
00:28:48,200 --> 00:28:48,600
Oops.

556
00:28:51,500 --> 00:28:54,100
All right, I'm going to load that file in.

557
00:28:58,200 --> 00:29:01,000
I'm going to have the definition of bar in there and I'm going to go

558
00:29:01,000 --> 00:29:02,000
to Maine to see.

559
00:29:02,000 --> 00:29:05,500
And the only thing that's going to be in Maine to dot C is my class

560
00:29:05,500 --> 00:29:06,200
declaration.

561
00:29:06,500 --> 00:29:11,100
Okay, now what will happen in this case if I try to compile them all

562
00:29:11,100 --> 00:29:12,100
together, right?

563
00:29:12,100 --> 00:29:16,900
Main 2.c main, three dot CPP main.cpp, what we will see

564
00:29:18,300 --> 00:29:22,800
Is that I get only the unknown, you know, I get the Uhn Uhn found

565
00:29:22,800 --> 00:29:23,100
bark.

566
00:29:23,100 --> 00:29:24,100
It doesn't know where to go.

567
00:29:24,100 --> 00:29:27,500
What to make a bar right in my main, still main three compiles, just

568
00:29:27,500 --> 00:29:31,700
fine because it's just the one definition of bar and Main to still has

569
00:29:31,700 --> 00:29:34,800
the problem because it's thinking of main 2.c as a C file.

570
00:29:34,900 --> 00:29:37,400
So now, what I'm going to do is I'm just going to say, okay, in my

571
00:29:37,400 --> 00:29:41,200
main.cpp I'm going to include main 2.c, right?

572
00:29:41,200 --> 00:29:43,900
I'm going to include that file and then I'm going to remove it from

573
00:29:43,900 --> 00:29:44,700
the command line.

574
00:29:45,400 --> 00:29:45,900
Right.

575
00:29:46,500 --> 00:29:49,300
So now I'm going to say let's compile these files.

576
00:29:50,500 --> 00:29:51,100
And here we go.

577
00:29:52,100 --> 00:29:55,400
So what I've done there again, I'm just trying to underscore the fact

578
00:29:55,800 --> 00:29:59,800
that the number of C or CPP files that you have has nothing

579
00:30:00,000 --> 00:30:02,900
To do with what the language will actually.

580
00:30:02,900 --> 00:30:07,300
Look at the language is going to look at what you eventually produce

581
00:30:07,500 --> 00:30:08,900
as streams to the compiler.

582
00:30:09,000 --> 00:30:13,400
These are called typically translation units and they're called that

583
00:30:13,400 --> 00:30:17,300
instead of file specifically because a single translation unit is

584
00:30:17,300 --> 00:30:20,900
actually made up of a file that you launched on the command line like

585
00:30:20,900 --> 00:30:25,100
CL main.cpp and all of the files it might include.

586
00:30:25,800 --> 00:30:29,200
It could include hundreds of files, it can include no files, include H

587
00:30:29,200 --> 00:30:29,900
file.

588
00:30:30,000 --> 00:30:31,700
I'll CBS does it matter?

589
00:30:31,900 --> 00:30:36,000
No one's going to look at what those files were called, where they are

590
00:30:36,700 --> 00:30:39,700
or anything other than just what their contents were.

591
00:30:39,700 --> 00:30:43,000
And those contents are going to be inserted directly into the stream.

592
00:30:43,100 --> 00:30:44,300
That is how it's going to work.

593
00:30:45,500 --> 00:30:49,000
So just what I've tried to get at here is just the step one which is

594
00:30:49,000 --> 00:30:54,300
to understand the fact that we are going to control and we are always

595
00:30:54,300 --> 00:30:58,300
in control of what our translation units are.

596
00:30:58,700 --> 00:31:05,200
And a translation unit is a set of text pass to the compiler, to be

597
00:31:05,200 --> 00:31:06,900
considered as a unit.

598
00:31:07,600 --> 00:31:11,700
And the way that we do that in most compilers is by specifying

599
00:31:11,700 --> 00:31:14,700
individual files on the command line, Each of which

600
00:31:14,900 --> 00:31:17,100
And comprises a translation unit.

601
00:31:18,200 --> 00:31:22,800
By aggregating, however many files it has included in it.

602
00:31:23,100 --> 00:31:27,700
So pound include will pull all sorts of other physical files in to

603
00:31:27,700 --> 00:31:29,700
this one translation unit.

604
00:31:30,300 --> 00:31:30,900
All right?

605
00:31:31,500 --> 00:31:35,900
So when we say CL main three dot CPP and main.cpp we are talking about

606
00:31:35,900 --> 00:31:38,400
two separate translation units.

607
00:31:39,700 --> 00:31:43,200
One of those translation units is strictly main three dot CPP.

608
00:31:43,200 --> 00:31:47,600
So in the main 32GB case, we have one translation unit corresponding

609
00:31:47,600 --> 00:31:52,400
with a single file in the other case of main.cpp, we have one

610
00:31:52,400 --> 00:31:57,200
translation unit that is consisting of two separate files, right?

611
00:31:57,300 --> 00:32:01,300
It's main.cpp but also main to dot C, which is pound included.

612
00:32:01,900 --> 00:32:05,800
So again, very important, understand translation, units have nothing

613
00:32:05,800 --> 00:32:09,100
to do with how many files you have, because you are

614
00:32:09,300 --> 00:32:14,400
Control of how many files will end up being pulled in to that

615
00:32:14,400 --> 00:32:17,300
translation unit via the pound include directive.

616
00:32:18,600 --> 00:32:21,100
So hopefully that's very clear and there's no mystery there.

617
00:32:21,100 --> 00:32:24,000
Again, we have not talked anything about how these functions are

618
00:32:24,000 --> 00:32:26,600
actually getting built, how they're getting linked, how they're

619
00:32:26,600 --> 00:32:28,200
finding each other any of that stuff.

620
00:32:28,200 --> 00:32:32,200
I'm only trying to establish the Baseline understanding of what is a

621
00:32:32,200 --> 00:32:35,300
translation unit and how do you control it, okay?

622
00:32:40,400 --> 00:32:41,000
All right.

623
00:32:42,600 --> 00:32:45,100
So now let's move on to step 2.

624
00:32:46,400 --> 00:32:49,600
When I hit return, you'll notice that I do not have a properly

625
00:32:49,600 --> 00:32:56,400
completing compilation step even here specifically for my main.cpp and

626
00:32:56,400 --> 00:32:59,200
the reason that that can't cause remember it's invoked twice.

627
00:32:59,300 --> 00:32:59,700
Here's my to

628
00:33:00,000 --> 00:33:01,200
Listen units, right?

629
00:33:01,200 --> 00:33:01,800
This one.

630
00:33:01,800 --> 00:33:07,500
Succeeded it was able to process this translation unit with no issues

631
00:33:07,900 --> 00:33:10,600
when it got to processing this translation unit main.cpp.

632
00:33:10,700 --> 00:33:14,500
It was unable to complete the processing of that translation unit

633
00:33:14,500 --> 00:33:17,600
because it could not find bar.

634
00:33:18,300 --> 00:33:20,900
Now, why couldn't find bar right?

635
00:33:21,600 --> 00:33:25,600
And furthermore, what would happen if I was to force this function to

636
00:33:25,600 --> 00:33:29,300
be compiled in C form, for example, right?

637
00:33:29,500 --> 00:33:29,800
Because I

638
00:33:30,000 --> 00:33:30,800
I think I don't know.

639
00:33:30,800 --> 00:33:32,200
Let me actually see if this is the case.

640
00:33:36,800 --> 00:33:38,600
Oh it's it's got this kind of Clips.

641
00:33:38,600 --> 00:33:41,400
I'm a turn this off temporarily just I can see ya.

642
00:33:42,600 --> 00:33:47,800
So I want to I want to show you what happens here.

643
00:33:48,200 --> 00:33:52,300
If I do this compilation again I had to unlearn include this because

644
00:33:52,300 --> 00:33:56,600
I'm not this is a C++ constructor we can't have an A/C program when I

645
00:33:56,600 --> 00:33:57,500
switch to see.

646
00:33:57,800 --> 00:33:58,300
I told it.

647
00:33:58,300 --> 00:34:02,900
Hey dumain, three dots, dot CPP and main.cpp I want you to treat them

648
00:34:02,900 --> 00:34:03,500
as C files.

649
00:34:03,500 --> 00:34:05,000
Not sleepy files, right?

650
00:34:05,400 --> 00:34:05,900
What you'll notice.

651
00:34:07,000 --> 00:34:11,800
Is the complaint about bar goes away, right?

652
00:34:12,199 --> 00:34:12,900
You'll notice.

653
00:34:13,000 --> 00:34:14,199
I am not getting an error.

654
00:34:14,199 --> 00:34:15,400
That's complaining about bar.

655
00:34:15,900 --> 00:34:21,699
However, when I switch back to complaint to compiling a CPP, I do get

656
00:34:21,699 --> 00:34:22,699
an error about bar.

657
00:34:23,699 --> 00:34:24,199
Right.

658
00:34:25,699 --> 00:34:26,800
So what's going on there?

659
00:34:27,400 --> 00:34:32,500
That takes us to the next stage of sort of, the understanding of how

660
00:34:32,500 --> 00:34:37,100
translation units work and how multi file stuff works right.

661
00:34:37,100 --> 00:34:39,699
Which we again have to understand before we can get to the

662
00:34:39,699 --> 00:34:41,900
understanding of linkage of functions and function pointers.

663
00:34:42,300 --> 00:34:42,699
Okay.

664
00:34:45,400 --> 00:34:45,800
So

665
00:34:47,600 --> 00:34:53,199
the problem here is that in see, in the original, see, the way that

666
00:34:53,199 --> 00:34:56,600
compilation worked was that when you called a function,

667
00:34:58,400 --> 00:35:01,100
Remember there's no such thing as operator overloading in.

668
00:35:01,100 --> 00:35:03,400
See that was not a thing that she had.

669
00:35:04,400 --> 00:35:05,000
I'm sorry operative.

670
00:35:05,000 --> 00:35:07,200
There was nothing is function overloading in C.

671
00:35:07,800 --> 00:35:13,600
There is also nothing like, you know, polymorphic types that had ways

672
00:35:13,600 --> 00:35:16,300
of like casting between them automatically, like, complicit

673
00:35:16,300 --> 00:35:19,000
Constructors, all these sorts of things that you see in C++.

674
00:35:20,400 --> 00:35:26,500
So the rule in original, see, was that if the compiler saw a call to a

675
00:35:26,500 --> 00:35:28,800
function that it did not recognize.

676
00:35:29,000 --> 00:35:33,000
So in this case, we have bar and I'm not even including main.c to,

677
00:35:33,000 --> 00:35:33,500
that's the anymore.

678
00:35:33,500 --> 00:35:35,800
So this is the entirety of the translation unit.

679
00:35:35,800 --> 00:35:36,900
Now is Justice in Foo.

680
00:35:37,100 --> 00:35:37,800
It sees a spider.

681
00:35:37,800 --> 00:35:39,500
It's like you've never told me what bar is

682
00:35:40,500 --> 00:35:41,800
The C compiler would just go.

683
00:35:41,800 --> 00:35:44,200
Well it looks like you're passing it into your.

684
00:35:44,200 --> 00:35:48,500
I'm going to assume that bar is a function that takes an integer.

685
00:35:51,000 --> 00:35:52,000
And we'll deal with it later.

686
00:35:52,300 --> 00:35:55,900
I'm just going to create the code that in this case, would call a

687
00:35:55,900 --> 00:35:57,400
function that looked like that.

688
00:35:57,900 --> 00:35:59,800
And I'm just going to assume that later on.

689
00:36:00,500 --> 00:36:02,900
During linking which we haven't talked about yet.

690
00:36:04,000 --> 00:36:06,100
We'll take care of this, right?

691
00:36:07,200 --> 00:36:10,100
C++ on the other hand tightened up.

692
00:36:10,100 --> 00:36:12,300
That requirement considerably.

693
00:36:12,600 --> 00:36:20,400
What C++ said was, I always need to know what a function is like what

694
00:36:20,400 --> 00:36:22,400
the definition of a function is before you call it.

695
00:36:23,300 --> 00:36:27,200
You know, if for no other reason than the fact that hey, there might

696
00:36:27,200 --> 00:36:29,800
be multiple overloaded version of this function, one that takes an

697
00:36:29,800 --> 00:36:30,000
input.

698
00:36:30,000 --> 00:36:31,500
One that takes a float, whatever.

699
00:36:31,600 --> 00:36:33,600
I don't necessarily know, even what

700
00:36:33,800 --> 00:36:37,900
Calling if I haven't been told what all the possible versions of this

701
00:36:37,900 --> 00:36:43,800
function are, so it always wants to see the function before it

702
00:36:43,800 --> 00:36:48,500
actually accepts the call to the function, right?

703
00:36:48,600 --> 00:36:52,000
So it's not like the C compiler going to allow me to call a function

704
00:36:52,000 --> 00:36:54,300
that I have never told it anything about.

705
00:36:55,400 --> 00:36:58,100
Now, one way to solve this, obviously, is to define the entire

706
00:36:58,100 --> 00:36:58,700
function.

707
00:36:59,500 --> 00:37:03,400
But as you might imagine, especially if the functions call each other.

708
00:37:03,500 --> 00:37:06,100
There may be, you know, if I have one function that calls, you know,

709
00:37:06,100 --> 00:37:10,500
if I if food calls bar, but bar calls Foo in some kind of circuitous

710
00:37:10,500 --> 00:37:15,000
way, I can't possibly structure it so that they both occur before each

711
00:37:15,000 --> 00:37:15,700
other, right?

712
00:37:15,700 --> 00:37:17,400
One of the function bodies has to happen.

713
00:37:17,400 --> 00:37:19,900
First one of the function B has to happen second.

714
00:37:20,400 --> 00:37:24,900
So obviously, one of the constructs that even see had

715
00:37:25,200 --> 00:37:27,700
Because you may want to do so just for your own era checking.

716
00:37:27,700 --> 00:37:35,400
But that C++ requires is that you define or I should say declare a

717
00:37:35,400 --> 00:37:39,300
function before you use it, you do not actually have to Define what

718
00:37:39,300 --> 00:37:40,300
the function does.

719
00:37:40,400 --> 00:37:44,900
You only have to provide what its signature is so that it's clear how

720
00:37:44,900 --> 00:37:46,100
it would be called.

721
00:37:46,200 --> 00:37:48,500
So in this case, it is sufficient for me to use.

722
00:37:48,500 --> 00:37:52,600
Just the Declaration of the function not its definition over here.

723
00:37:52,600 --> 00:37:55,000
That includes the body just the

724
00:37:55,100 --> 00:37:58,200
Declaration, which is the same as the the, you know, preamble to the

725
00:37:58,200 --> 00:37:59,000
definition.

726
00:37:59,300 --> 00:38:01,000
But that does not have to include the body.

727
00:38:01,400 --> 00:38:05,200
That is sufficient to tell the C++ compiler, what that function

728
00:38:05,200 --> 00:38:09,300
actually is and to allow it to call it, right, okay?

729
00:38:09,500 --> 00:38:12,400
So what I'm going to do is I'm going to include that in here.

730
00:38:12,500 --> 00:38:17,400
I'm going to include that function declaration and now I'm going to

731
00:38:17,400 --> 00:38:19,100
try compiling again, right?

732
00:38:19,400 --> 00:38:21,500
And now what you can see is, we're back to good.

733
00:38:21,700 --> 00:38:24,900
We are no longer getting a complaint that bar is not defined because

734
00:38:25,400 --> 00:38:29,400
I'm the bar is what did he call it Undeclared I believe.

735
00:38:31,500 --> 00:38:35,100
Or unrecognized identifier not found is all it said right?

736
00:38:35,100 --> 00:38:35,500
Which is true.

737
00:38:35,500 --> 00:38:37,900
It doesn't have any idea because it doesn't really even know what it

738
00:38:37,900 --> 00:38:38,900
is at that point, right?

739
00:38:40,000 --> 00:38:43,200
And so in this case now we have gotten ourselves back to, okay?

740
00:38:43,400 --> 00:38:47,600
We now have told the compiler when it is processing, the main.cpp

741
00:38:47,600 --> 00:38:51,200
translation unit, it now has the information it needs to do

742
00:38:51,200 --> 00:38:53,000
compilation, right?

743
00:38:53,900 --> 00:38:54,300
Okay.

744
00:38:58,000 --> 00:38:59,800
So, let's get a little bit more.

745
00:39:01,500 --> 00:39:06,000
Aggressive here and move on to the concept of linking, okay?

746
00:39:07,100 --> 00:39:10,400
And this starts to get at the central sort of thing.

747
00:39:10,400 --> 00:39:15,400
That one of the, the sort of phrases that the the person who wrote in

748
00:39:15,500 --> 00:39:20,800
asked about which was, how do CPP files talk to each other, right?

749
00:39:20,900 --> 00:39:23,700
Because this is kind of an interesting question in the abstract sense.

750
00:39:23,700 --> 00:39:26,400
I've got these files, how can they call each other?

751
00:39:26,400 --> 00:39:27,000
What's going on?

752
00:39:27,000 --> 00:39:28,100
I don't know, right.

753
00:39:30,200 --> 00:39:32,200
And then you got function pointers on top of this.

754
00:39:32,200 --> 00:39:35,400
And how do I take a function pointer between two files is what's going

755
00:39:35,400 --> 00:39:36,300
on etcetera, etcetera?

756
00:39:36,300 --> 00:39:36,700
Right?

757
00:39:37,800 --> 00:39:39,300
So taking a look at this.

758
00:39:39,300 --> 00:39:41,400
What the point that I kind of want to get across here?

759
00:39:42,300 --> 00:39:44,000
Is that nowhere at all?

760
00:39:44,000 --> 00:39:46,300
Is there any verification that?

761
00:39:46,300 --> 00:39:50,000
This bar function actually exists anywhere, right?

762
00:39:50,600 --> 00:39:55,600
And I can underscore that point by removing bar entirely from the

763
00:39:55,600 --> 00:39:57,400
compilers consider it consideration.

764
00:39:57,400 --> 00:40:02,200
Remember bar is defined in main three dot CPP, but I could choose to

765
00:40:02,200 --> 00:40:04,900
only compile name, right?

766
00:40:06,500 --> 00:40:09,600
Only compiling main.cpp at this point, right?

767
00:40:10,300 --> 00:40:13,300
So at that point, when I'm only compiling main, I end up in a

768
00:40:13,300 --> 00:40:18,100
situation where now things get pushed to the next step, which is the

769
00:40:18,100 --> 00:40:18,900
linking step.

770
00:40:18,900 --> 00:40:21,100
And that's the part that I want to look at now.

771
00:40:21,800 --> 00:40:25,700
So first of all, you know what's going on here, right?

772
00:40:26,900 --> 00:40:28,900
And we're kind of going to get to it.

773
00:40:29,100 --> 00:40:31,700
We're going to ping pong back and talk about object files in a second.

774
00:40:32,100 --> 00:40:33,600
You can actually see that they're getting created.

775
00:40:33,600 --> 00:40:36,000
He remained a Dobbs, main three that optional talk about what those

776
00:40:36,000 --> 00:40:38,900
are in a second but I want to talk about the Linker first and then

777
00:40:38,900 --> 00:40:41,100
sort of loop back around, all right.

778
00:40:41,400 --> 00:40:45,100
So implicit in everything that we just said and now we're going to

779
00:40:45,100 --> 00:40:46,000
have to actually address.

780
00:40:46,000 --> 00:40:46,900
It is.

781
00:40:46,900 --> 00:40:50,800
What does compilation mean versus linking, right?

782
00:40:50,800 --> 00:40:51,900
What is this mean?

783
00:40:52,000 --> 00:40:53,600
Why are these two things eat?

784
00:40:53,600 --> 00:40:55,700
What do they even have to do with each other?

785
00:40:56,500 --> 00:40:59,100
You know, maybe you have your more familiar with the language, it

786
00:40:59,100 --> 00:41:00,500
doesn't even have these things.

787
00:41:00,800 --> 00:41:05,400
There's no such thing as two distinct sets steps of processing your

788
00:41:05,400 --> 00:41:06,100
code.

789
00:41:08,900 --> 00:41:09,400
Right?

790
00:41:11,400 --> 00:41:16,400
Well, the way that c and C++ and I guess really this comes from see

791
00:41:16,900 --> 00:41:20,800
traditionally handled the concept that compilation.

792
00:41:21,900 --> 00:41:25,800
Or rather processing of your program, might take a long time.

793
00:41:26,400 --> 00:41:31,400
Is that it allowed that compilation to be done in sort of parts,

794
00:41:31,600 --> 00:41:32,100
right?

795
00:41:32,400 --> 00:41:36,600
So if you had a hundred thousand line program which, you know, let's

796
00:41:36,600 --> 00:41:41,300
say Back in 1970, would have been extraordinary perhaps in terms of

797
00:41:41,300 --> 00:41:45,500
its largeness, in terms of how long that it could be, it would take to

798
00:41:45,500 --> 00:41:49,000
process this or even if the compiler would even have enough memory to

799
00:41:49,000 --> 00:41:51,200
process it, who knows, you know, I don't

800
00:41:51,600 --> 00:41:54,100
Say that that's the correct size to be large in those days and

801
00:41:54,100 --> 00:41:55,800
obviously would depend on the machine.

802
00:41:55,800 --> 00:41:56,700
You were using it so on

803
00:41:58,100 --> 00:41:59,800
but one of the things that was introduced,

804
00:42:00,000 --> 00:42:05,200
As an optimization in that case, was the idea that if you were going

805
00:42:05,200 --> 00:42:09,400
to end introduced in C, this is by no means specific to see.

806
00:42:09,400 --> 00:42:10,700
It's not like, they invented, this idea.

807
00:42:10,700 --> 00:42:18,000
This is, this is a common idea is that there's two phases of work that

808
00:42:18,000 --> 00:42:23,100
have to be done in order to translate the textual content of your code

809
00:42:23,200 --> 00:42:27,400
into something that the computer can actually execute.

810
00:42:28,000 --> 00:42:29,900
The first pass is the

811
00:42:30,000 --> 00:42:34,000
Elation past traditionally come called the compiler, that is

812
00:42:34,000 --> 00:42:38,700
responsible for taking the actual code that you've written and turning

813
00:42:38,700 --> 00:42:41,600
it into, you know, essentially machine code, right?

814
00:42:41,600 --> 00:42:47,000
Assembly Language code, but a bunch of the things at that point that

815
00:42:47,000 --> 00:42:51,900
need to be known in order to finalize that code are left unfine

816
00:42:51,900 --> 00:42:52,500
alized.

817
00:42:53,000 --> 00:42:57,100
So for example, in this case here, where I have this function, I have

818
00:42:57,100 --> 00:42:59,900
all the information I need in order to produce the machine code.

819
00:43:00,000 --> 00:43:04,900
For this function self-contained, it's an NT, it returns an ENT, it

820
00:43:04,900 --> 00:43:08,400
takes an INT it computes to x value.

821
00:43:08,400 --> 00:43:12,000
It calls the function bar, it then takes that result and returns it.

822
00:43:12,100 --> 00:43:15,600
I have everything I need to reduce the machine code except for one

823
00:43:15,600 --> 00:43:21,300
thing, which is the address of the function bar, right?

824
00:43:22,300 --> 00:43:24,700
So if you imagine what this code is going to look like, it's going to

825
00:43:24,700 --> 00:43:26,900
look like, oh I'm going to have some machine code that sets up the

826
00:43:26,900 --> 00:43:29,800
stack and then we have a call instruction and that call

827
00:43:29,900 --> 00:43:33,400
all instruction is going to have to have an address of where to call

828
00:43:34,000 --> 00:43:38,400
and it is that address that the compiler does not have yet because all

829
00:43:38,400 --> 00:43:40,800
its got is a definition, right.

830
00:43:40,900 --> 00:43:45,400
I'm sorry declaration that says here is the signature here, is how you

831
00:43:45,400 --> 00:43:46,200
call bar.

832
00:43:46,400 --> 00:43:48,900
So I've given it enough information to know how to generate the

833
00:43:48,900 --> 00:43:52,100
machine code to call bar but I haven't told it.

834
00:43:52,100 --> 00:43:57,400
What bar is it has no idea what the address of bar might be right.

835
00:43:58,000 --> 00:43:58,800
None whatsoever.

836
00:44:00,000 --> 00:44:04,200
So that is where the Second Step the linkage step comes from.

837
00:44:04,800 --> 00:44:08,400
It is the job of the Linker and the Linker has grown to in Crete to

838
00:44:08,800 --> 00:44:12,700
Encompass other jobs, including code generation sometimes for

839
00:44:12,700 --> 00:44:13,800
optimization purposes.

840
00:44:14,100 --> 00:44:17,900
But traditionally it was more about compilation, pretty much generates

841
00:44:17,900 --> 00:44:19,400
the machine code linking.

842
00:44:19,400 --> 00:44:22,200
Just pulls that machine code together and replaces the addresses.

843
00:44:22,900 --> 00:44:25,700
But, you know, like I said, it's grown over time so that the Linker

844
00:44:25,700 --> 00:44:29,300
now Doug can do more cogent to do optimization and stuff like this but

845
00:44:30,400 --> 00:44:35,500
The linking phase its job is to take the output of the compiler, which

846
00:44:35,500 --> 00:44:38,900
may be many different sort of pieces if I especially if I have.

847
00:44:38,900 --> 00:44:43,000
You know, if I have 30 or 40 CPP files, all of which I'm compiling as

848
00:44:43,000 --> 00:44:44,500
separate translation units.

849
00:44:46,000 --> 00:44:47,000
So ever May translation notes.

850
00:44:47,000 --> 00:44:49,400
I have I have that many outputs.

851
00:44:50,200 --> 00:44:54,500
The Linker is going to take all of those and it's going to compile

852
00:44:54,500 --> 00:44:55,900
that, well, not good pilot.

853
00:44:55,900 --> 00:44:59,800
Its core to link them into the executable that I can actually run.

854
00:45:00,500 --> 00:45:04,100
And it's going to do that by looking at all of the names of all of the

855
00:45:04,100 --> 00:45:07,300
functions that have been defined as well as things like Global

856
00:45:07,300 --> 00:45:09,700
variables, which also have to have addresses associated with them.

857
00:45:10,200 --> 00:45:14,400
And it's now going to take that machine code and patch in all of the

858
00:45:14,400 --> 00:45:17,300
places where the addresses were previously missing because they

859
00:45:17,300 --> 00:45:20,400
weren't known with the actual resolved.

860
00:45:20,400 --> 00:45:25,300
Addresses that says where these things are in the final executable,

861
00:45:26,400 --> 00:45:26,800
Okay.

862
00:45:30,500 --> 00:45:32,500
So, that is what the Linker is doing.

863
00:45:33,700 --> 00:45:38,400
Now let's start with what we're seeing as Linker output here.

864
00:45:39,000 --> 00:45:41,000
I'm asking you to compile main.cpp.

865
00:45:41,000 --> 00:45:44,300
So I've removed one of my translation units, main three but let's say

866
00:45:44,300 --> 00:45:47,300
I left main three in there just for the sake of an argument and we can

867
00:45:47,300 --> 00:45:48,400
see what's going on here.

868
00:45:48,700 --> 00:45:49,600
So I call main three.

869
00:45:49,600 --> 00:45:53,500
That's the API call main.cpp, we're getting compilation, the

870
00:45:53,500 --> 00:45:56,000
compilation here has succeeded.

871
00:45:56,000 --> 00:45:57,700
There's been no errors in the compilation.

872
00:45:58,000 --> 00:45:58,800
What does that mean?

873
00:45:58,800 --> 00:46:01,900
It means that each of those two translation units, main three dot CPP

874
00:46:02,000 --> 00:46:03,400
main.cpp again,

875
00:46:03,600 --> 00:46:07,400
Not files translation units because one of them includes main 2.c.

876
00:46:07,600 --> 00:46:11,100
So we actually have three files that were involved in compilation, but

877
00:46:11,100 --> 00:46:13,800
two of them got funded to one translation unit, one of them into the

878
00:46:13,800 --> 00:46:14,700
other, right?

879
00:46:15,500 --> 00:46:19,700
The compiler did the work of analyzing the source code that was input.

880
00:46:19,700 --> 00:46:23,300
And it generated what is called object code?

881
00:46:23,300 --> 00:46:26,700
Which is compiled like, you know, machine instructions basically for

882
00:46:26,700 --> 00:46:31,400
doing the work of the source code implied but it left out the step of

883
00:46:31,400 --> 00:46:33,600
fixing up those addresses because they weren't known.

884
00:46:33,600 --> 00:46:37,400
Now, if we look at the actual Drive, even though we never asked the

885
00:46:37,400 --> 00:46:40,700
compiler to do this, it did it automatically because it needs to in

886
00:46:40,700 --> 00:46:44,100
order to support the multi-stage compilation, you can see that

887
00:46:44,100 --> 00:46:45,200
actually it out.

888
00:46:45,800 --> 00:46:49,100
For each translation unit and you see it pairs directly with the

889
00:46:49,100 --> 00:46:51,600
translation unit main to see did not get one.

890
00:46:51,700 --> 00:46:55,000
Why it is not a translation unit main three dot CPP was the

891
00:46:55,000 --> 00:46:58,800
translation unit and mean may not see through the translation unit and

892
00:46:58,800 --> 00:47:01,300
main.cpp included main to dot C.

893
00:47:01,500 --> 00:47:05,500
So all of the main two dot C code, if there was any went into Maine

894
00:47:05,500 --> 00:47:08,800
DOT obj, the result of that translation, right?

895
00:47:09,700 --> 00:47:14,900
So what we can see here is it wrote out that machine code, right?

896
00:47:14,900 --> 00:47:17,800
Main dot objects, and main three Dobbs.

897
00:47:17,900 --> 00:47:23,800
Actually are the results of the compilation step which did not fail.

898
00:47:24,200 --> 00:47:26,800
So, it's successfully output those to obj files.

899
00:47:26,800 --> 00:47:31,600
I didn't get an executable because the Linker failed, but I did get

900
00:47:31,600 --> 00:47:34,600
obj files because the compiler succeeded, right?

901
00:47:35,400 --> 00:47:37,800
So now let's take a look here.

902
00:47:39,100 --> 00:47:41,400
At these, I think I can.

903
00:47:44,500 --> 00:47:47,100
I don't know if I can look at these or not.

904
00:47:47,100 --> 00:47:47,500
Yes.

905
00:47:47,700 --> 00:47:48,100
Okay,

906
00:47:50,400 --> 00:47:53,100
It's been a long time since I've done any of these.

907
00:47:54,300 --> 00:47:55,800
Can I can I get

908
00:47:57,600 --> 00:47:58,800
I'm sorry, I'm just going to.

909
00:47:58,800 --> 00:47:59,200
Yeah.

910
00:47:59,200 --> 00:47:59,500
Okay.

911
00:48:01,400 --> 00:48:04,000
So I make sure it's been a long time since I've done this sort of

912
00:48:04,000 --> 00:48:09,300
stuff so bear with me here, but it turns out it is it is exactly as I

913
00:48:09,300 --> 00:48:14,000
remember, so what can we now?

914
00:48:14,000 --> 00:48:18,000
Do to verify that, that sort of, and, and cement, what I'm trying to

915
00:48:18,000 --> 00:48:18,900
tell you here.

916
00:48:19,200 --> 00:48:23,200
So that, you know that I'm not, you know, making this up in and sort

917
00:48:23,200 --> 00:48:26,800
of floating floating around in the the stratosphere, telling you,

918
00:48:26,800 --> 00:48:27,400
ridiculous things.

919
00:48:27,400 --> 00:48:30,900
Well, so let's actually take a second to

920
00:48:31,200 --> 00:48:31,700
By that.

921
00:48:31,700 --> 00:48:33,900
What I'm saying, is actually, what's going on here.

922
00:48:33,900 --> 00:48:37,100
And just to get you familiar with, actually, how these things work in

923
00:48:37,100 --> 00:48:39,700
practice, get your hands dirty, get under the car.

924
00:48:39,700 --> 00:48:42,800
So to speak and like, look, you know, I don't know how cars work so I

925
00:48:42,800 --> 00:48:44,700
have no idea under the hood, who knows?

926
00:48:44,700 --> 00:48:45,800
I don't know how to use cars.

927
00:48:45,800 --> 00:48:46,900
I don't even own a car.

928
00:48:46,900 --> 00:48:48,100
So what, who knows?

929
00:48:48,300 --> 00:48:51,200
But I imagine, this is the kind of thing that people who rebuild their

930
00:48:51,200 --> 00:48:52,700
engines know, in the car sense.

931
00:48:53,000 --> 00:48:53,600
So, here we go.

932
00:48:55,100 --> 00:49:00,200
There is a utility on the Microsoft compiler and there's, you know,

933
00:49:00,400 --> 00:49:02,700
equivalents for your platform as well.

934
00:49:02,700 --> 00:49:07,100
If you're not using Microsoft stuff, maybe someone can post in the

935
00:49:07,100 --> 00:49:11,300
forums at some point, some guides on how to do this if you're on Linux

936
00:49:11,300 --> 00:49:12,900
or Mac or so on.

937
00:49:13,900 --> 00:49:19,300
But there is a utility called dumped in that comes with the Microsoft

938
00:49:19,600 --> 00:49:22,000
Visual Studio compiler, which is what we use on handmade here.

939
00:49:22,400 --> 00:49:24,600
And it is a tool whose

940
00:49:24,800 --> 00:49:30,700
Job is to take the output of the compiler, or the Linker and sort of

941
00:49:30,700 --> 00:49:34,200
reverse engineer what its contents are, right?

942
00:49:34,200 --> 00:49:38,000
So it's supposed to take it and go, okay, here's an obj, here's an

943
00:49:38,000 --> 00:49:39,100
executable whatever.

944
00:49:39,500 --> 00:49:43,400
Tell me what you can about that by looking at the the way that the

945
00:49:43,400 --> 00:49:48,200
compiler wrote it out and and spit out something human-readable right.

946
00:49:48,200 --> 00:49:49,000
It's got a number of ways.

947
00:49:49,000 --> 00:49:50,900
I can analyze this sort of stuff.

948
00:49:51,100 --> 00:49:54,600
The one that I am using right now is called Des, azzam the dis ass

949
00:49:54,800 --> 00:49:58,100
Um, switch is basically saying, hey, you produce this obj file.

950
00:49:58,200 --> 00:50:01,900
I know that an obj file is the result of translating, some of my

951
00:50:01,900 --> 00:50:07,900
source code into machine code that the computer can execute, but with

952
00:50:07,900 --> 00:50:13,000
the addresses left on processed, right?

953
00:50:14,200 --> 00:50:18,600
So what I'd like you to do is give me the disassembly of that machine

954
00:50:18,600 --> 00:50:22,900
code, show me what it is and so here is that line dumped in / Des

955
00:50:22,900 --> 00:50:24,500
azzam Main obj

956
00:50:24,800 --> 00:50:25,600
And that obj.

957
00:50:25,600 --> 00:50:27,100
Is that translation unit?

958
00:50:27,300 --> 00:50:32,400
That includes write this in Foo and in fact, I'm going to go ahead and

959
00:50:32,500 --> 00:50:35,200
and load it up on this side so that we can see a little more clearly

960
00:50:35,500 --> 00:50:37,100
so you can look at them both the same time.

961
00:50:37,200 --> 00:50:41,500
So here it is in Foo index into result equals bar 2 times x and here

962
00:50:41,500 --> 00:50:42,300
is the result.

963
00:50:42,300 --> 00:50:42,700
Okay?

964
00:50:43,200 --> 00:50:45,700
Now here is what the compiler produced.

965
00:50:46,000 --> 00:50:48,500
It produced a label, right?

966
00:50:48,500 --> 00:50:49,600
That's what this is here.

967
00:50:50,800 --> 00:50:54,600
And again this is this obj file is essentially sort of a

968
00:50:54,700 --> 00:50:58,100
A pack file, kind of like the kind that we have in hand made here for

969
00:50:58,100 --> 00:50:59,800
art assets where it's taken.

970
00:51:00,200 --> 00:51:02,600
You know, if we have multiple functions and you know what, let me just

971
00:51:02,600 --> 00:51:03,500
throw on in here.

972
00:51:10,600 --> 00:51:11,700
It'll be distinct.

973
00:51:16,600 --> 00:51:21,900
The floating-point version of Foo right, there we go.

974
00:51:23,400 --> 00:51:27,300
So now let's compile so you can see two of two of them.

975
00:51:28,600 --> 00:51:29,500
Where's my dump bin?

976
00:51:30,200 --> 00:51:30,600
There it is.

977
00:51:31,200 --> 00:51:31,700
Okay.

978
00:51:33,800 --> 00:51:35,500
So, let's take a look at what we got.

979
00:51:35,800 --> 00:51:38,900
Right, again, it looks a lot like a Pac file.

980
00:51:38,900 --> 00:51:42,800
And what we're seeing here again, is a textual display, the actual

981
00:51:42,800 --> 00:51:44,600
binary format of this file.

982
00:51:44,600 --> 00:51:46,300
It's telling us right here.

983
00:51:46,300 --> 00:51:47,900
That it's a cough object cough.

984
00:51:47,900 --> 00:51:50,200
I think, is the common object, file format or something.

985
00:51:50,200 --> 00:51:51,700
Like, I don't even remember what it stands for.

986
00:51:51,900 --> 00:51:54,400
Let's find out what it stands for answer, something like that.

987
00:51:56,000 --> 00:51:57,500
Common object file format.

988
00:51:57,500 --> 00:51:58,000
Yep.

989
00:51:58,900 --> 00:52:02,300
It's basically a binary specification that says, here's how we produce

990
00:52:02,600 --> 00:52:04,500
packages that sort of list.

991
00:52:04,500 --> 00:52:08,100
Here's a bunch of functions and Global variable data, and so on, that

992
00:52:08,100 --> 00:52:09,300
does not quite yet.

993
00:52:09,300 --> 00:52:11,200
Have the addresses bound, right?

994
00:52:11,200 --> 00:52:12,700
That's what it specifies as well.

995
00:52:12,700 --> 00:52:16,200
As I think it provides maybe debug ways to include debug data.

996
00:52:16,200 --> 00:52:18,200
I don't really know fit a long time.

997
00:52:18,200 --> 00:52:20,400
So I looked at it but it's got a bunch of that stuff in it, right?

998
00:52:20,900 --> 00:52:22,400
So it is a binary file format.

999
00:52:22,400 --> 00:52:24,900
Here is a textual listing of what is

1000
00:52:25,100 --> 00:52:26,500
Chained in that file.

1001
00:52:26,800 --> 00:52:30,700
There's a label, which says, here is the function Foo, right?

1002
00:52:31,400 --> 00:52:33,300
And we'll talk about what this is in a second.

1003
00:52:33,900 --> 00:52:35,200
But here is the function Foo.

1004
00:52:35,300 --> 00:52:36,900
Here is the code for that function.

1005
00:52:36,900 --> 00:52:40,400
Foo, then here is a function called baz, and here is the code for that

1006
00:52:40,400 --> 00:52:41,700
function, right?

1007
00:52:42,200 --> 00:52:45,200
And so what you can see here, is this done, exactly what we would have

1008
00:52:45,200 --> 00:52:46,000
expected.

1009
00:52:46,000 --> 00:52:50,000
It's going to go ahead and have the preamble to the function, right?

1010
00:52:50,100 --> 00:52:54,800
You can see that it shows to implement the x 2 as a shift left by one.

1011
00:52:55,100 --> 00:52:56,300
Which is kind of amusing, right?

1012
00:52:56,300 --> 00:52:58,300
It's already doing some optimizations there.

1013
00:52:58,500 --> 00:53:02,200
Rather than issuing, an I'm all it just doesn't shl even though we

1014
00:53:02,200 --> 00:53:05,300
weren't asking for anything specific, but did that it's pushing that

1015
00:53:05,300 --> 00:53:08,500
in to a particular register, right?

1016
00:53:08,500 --> 00:53:11,400
Which is for the call, I believe that the convention probably says

1017
00:53:11,400 --> 00:53:12,700
that that should go in ECX.

1018
00:53:13,400 --> 00:53:15,900
So, what it's doing here is setting that up.

1019
00:53:17,100 --> 00:53:19,300
And I guess maybe I should be a little more clear.

1020
00:53:19,300 --> 00:53:19,900
What happens?

1021
00:53:20,300 --> 00:53:22,400
There just haven't talked about that yet but I just want to finish

1022
00:53:22,400 --> 00:53:24,600
this and we can talk a bit more about that in a second.

1023
00:53:25,000 --> 00:53:28,300
It's then calling again a function that it doesn't know.

1024
00:53:28,300 --> 00:53:31,000
So you notice there's no address here, you can see a lot of these

1025
00:53:31,000 --> 00:53:32,900
things have a dressy looking things on them.

1026
00:53:32,900 --> 00:53:35,800
They're hard coded to locations relative to registers.

1027
00:53:36,000 --> 00:53:39,000
You can see a lot of this stuff here, stock manipulation and that sort

1028
00:53:39,000 --> 00:53:39,500
of stuff.

1029
00:53:39,600 --> 00:53:40,800
This is not that way.

1030
00:53:40,800 --> 00:53:43,700
This is actually a symbol, the symbol is question.

1031
00:53:43,700 --> 00:53:46,500
Mark bar at y, EA H at Z

1032
00:53:46,600 --> 00:53:50,000
She will talk about why it's looks like that in a second but that's

1033
00:53:50,000 --> 00:53:53,800
the call with without a known address and then it's going to take that

1034
00:53:54,100 --> 00:53:54,500
value.

1035
00:53:54,500 --> 00:53:58,900
That comes back and put it into the return register, which is eax and

1036
00:53:58,900 --> 00:53:59,800
then it's going to fix.

1037
00:54:00,000 --> 00:54:01,400
The stock and return, right?

1038
00:54:01,500 --> 00:54:04,300
We then have a bunch of in threes in The Dead Zone which is just

1039
00:54:04,300 --> 00:54:04,500
there.

1040
00:54:04,500 --> 00:54:08,700
I believe to make sure that anyone who jumps to this area accidentally

1041
00:54:08,700 --> 00:54:09,600
issues a fault.

1042
00:54:09,600 --> 00:54:14,600
I think this is typically padded so that if this function grows you

1043
00:54:14,600 --> 00:54:17,700
have to understand, there's incremental stuff, I think it tends to

1044
00:54:17,700 --> 00:54:21,700
leave padding so that if, if it wants to expand a function that it

1045
00:54:21,700 --> 00:54:23,800
doesn't have to recompile things that's for incremental, things like

1046
00:54:23,800 --> 00:54:26,600
that, I believe that's typically what that's for, but I'm not entirely

1047
00:54:26,600 --> 00:54:26,900
sure.

1048
00:54:26,900 --> 00:54:27,700
You'd have to ask a pod.

1049
00:54:27,700 --> 00:54:29,800
Like these entities are not necessary, right?

1050
00:54:30,000 --> 00:54:33,000
Right in three is a thing that's that breaks into the bugger.

1051
00:54:33,000 --> 00:54:35,700
It's an interrupt and so it's basically just dead.

1052
00:54:35,700 --> 00:54:37,100
It's dead code, its code.

1053
00:54:37,100 --> 00:54:39,900
That's never supposed to be executed at all but it's there.

1054
00:54:39,900 --> 00:54:41,900
Presumably as padding, you can then see.

1055
00:54:41,900 --> 00:54:47,000
We have our other function, write this function here is about as

1056
00:54:47,000 --> 00:54:48,300
that's a second ones floating point.

1057
00:54:48,400 --> 00:54:51,600
You can see it does exactly the same stuff, it uses the xmm registers

1058
00:54:51,600 --> 00:54:54,500
because that's where you do floating Point math nowadays, it does a

1059
00:54:54,500 --> 00:54:59,500
mauve to load in whatever the input was it does a mul to to, you know,

1060
00:54:59,500 --> 00:54:59,700
basically

1061
00:55:00,000 --> 00:55:00,800
Apply two times.

1062
00:55:00,800 --> 00:55:01,300
The value.

1063
00:55:01,300 --> 00:55:01,900
In this case,

1064
00:55:04,400 --> 00:55:04,700
I guess.

1065
00:55:04,700 --> 00:55:06,300
Wait how exactly are we doing this here?

1066
00:55:06,800 --> 00:55:07,200
Move us.

1067
00:55:07,200 --> 00:55:11,900
Sx-70 Dura pointer as Fates say it's saving them register, which makes

1068
00:55:11,900 --> 00:55:12,200
sense.

1069
00:55:12,200 --> 00:55:15,200
Move us, sxm, 02, reporter real out of four.

1070
00:55:15,200 --> 00:55:16,700
So actually What's Happening Here?

1071
00:55:16,700 --> 00:55:20,200
It looks like here is the here is the mole that actually does the two

1072
00:55:20,200 --> 00:55:20,700
times.

1073
00:55:20,900 --> 00:55:28,100
This it must have put the constant 2 into this data segment here which

1074
00:55:28,100 --> 00:55:32,000
is going to have a 2.0 as a constant and that's what it's loading out

1075
00:55:32,000 --> 00:55:32,200
there.

1076
00:55:32,200 --> 00:55:32,800
Actually

1077
00:55:33,700 --> 00:55:36,900
Going to actually take this and move it into the return register and

1078
00:55:36,900 --> 00:55:38,000
return, right?

1079
00:55:38,800 --> 00:55:41,300
So again, I know this is all for a beginner.

1080
00:55:41,300 --> 00:55:43,700
This is going to be overwhelming to try and understand all the

1081
00:55:43,700 --> 00:55:44,300
Assembly Language.

1082
00:55:44,300 --> 00:55:46,800
I just briefly said what it was, you'd understand.

1083
00:55:47,300 --> 00:55:49,800
You don't have to quite get familiar with that just yet.

1084
00:55:49,800 --> 00:55:51,300
All I really want you to pay attention.

1085
00:55:51,300 --> 00:55:56,400
To again, is these things here, these are labels, which say, here's

1086
00:55:56,400 --> 00:55:57,300
some code.

1087
00:55:57,300 --> 00:56:00,200
Here, it is a call to a symbol that has been defined.

1088
00:56:00,300 --> 00:56:03,500
Here is some code and, you know, if there's any other calls

1089
00:56:03,700 --> 00:56:04,600
One doesn't have a call, right.

1090
00:56:04,600 --> 00:56:05,400
Only that one does

1091
00:56:07,000 --> 00:56:09,100
Okay, so hopefully you understand what's going on there.

1092
00:56:09,400 --> 00:56:15,000
Now what you can see, if we dump out main three dot object is we have

1093
00:56:15,000 --> 00:56:16,600
the corresponding symbol.

1094
00:56:16,800 --> 00:56:21,100
So this is the obj file produced in the main.cpp translation unit

1095
00:56:21,100 --> 00:56:23,400
which again includes Maine to see as well.

1096
00:56:23,400 --> 00:56:27,300
So against not file specific when it goes to call this function.

1097
00:56:27,500 --> 00:56:31,100
Now, imagine what the Linker has to do, the Linker is trying to

1098
00:56:31,100 --> 00:56:34,900
produce an executable whenever it goes through and pulls all these

1099
00:56:34,900 --> 00:56:35,700
things together.

1100
00:56:36,000 --> 00:56:36,600
It's going to look.

1101
00:56:36,700 --> 00:56:40,300
Look and see that it has an address here, it's looking for something

1102
00:56:40,300 --> 00:56:41,900
called question, mark bar at at.

1103
00:56:41,900 --> 00:56:44,500
Why a h at Z, right?

1104
00:56:44,500 --> 00:56:46,000
That's what it is looking for.

1105
00:56:46,600 --> 00:56:51,500
And you can see that in this other obj file here, it has that symbol

1106
00:56:51,600 --> 00:56:52,000
question.

1107
00:56:52,000 --> 00:56:56,500
Mark bar at at why a h at Z, right?

1108
00:56:58,300 --> 00:56:59,800
So that's how the Linker, no.

1109
00:57:00,000 --> 00:57:03,100
Was how to connect things up.

1110
00:57:03,100 --> 00:57:08,100
The code, the actual Assembly Language code or machine code.

1111
00:57:08,100 --> 00:57:14,500
I should say in the cough file that the compiler executes has names

1112
00:57:14,500 --> 00:57:18,900
which exactly match the names in other translation units and the

1113
00:57:18,900 --> 00:57:20,200
linkers job is to line.

1114
00:57:20,200 --> 00:57:24,500
All those up, assign everybody a position in the file the executable

1115
00:57:24,500 --> 00:57:28,100
file that's getting output and then you know make all those addresses

1116
00:57:28,100 --> 00:57:29,200
lineup.

1117
00:57:30,000 --> 00:57:34,100
Ace call, you know something let's just call and then some symbol that

1118
00:57:34,100 --> 00:57:36,900
we don't know what it is replace that with an actual call to an actual

1119
00:57:36,900 --> 00:57:37,500
address.

1120
00:57:38,000 --> 00:57:38,500
Right?

1121
00:57:40,100 --> 00:57:42,800
Okay, so let's go one step further.

1122
00:57:42,800 --> 00:57:46,400
Now let's let's let's really try to start to sort of tie all these

1123
00:57:46,400 --> 00:57:49,600
things together, what you'll notice and I think this is the part that

1124
00:57:49,600 --> 00:57:53,400
I was really trying to motivate is that if I call this in either way,

1125
00:57:53,500 --> 00:57:54,000
right?

1126
00:57:54,000 --> 00:57:56,400
I can call CL main.cpp or CL, mean 3.

1127
00:57:56,400 --> 00:58:02,600
Dot CP, n main.cpp in neither case, does it complain about bar?

1128
00:58:03,000 --> 00:58:04,100
Miss being missing.

1129
00:58:04,600 --> 00:58:07,100
Now that makes sense in this case because I gave it a translation unit

1130
00:58:07,100 --> 00:58:08,700
that actually has bar in it.

1131
00:58:08,900 --> 00:58:09,800
And in this case, I

1132
00:58:09,800 --> 00:58:11,900
I didn't, why is in this case?

1133
00:58:11,900 --> 00:58:13,200
It not complaining well,

1134
00:58:14,300 --> 00:58:18,000
What we need to understand is that the Linker is under no obligation

1135
00:58:18,000 --> 00:58:19,800
to complain about a missing symbol.

1136
00:58:20,200 --> 00:58:22,500
If it doesn't need the symbol.

1137
00:58:23,400 --> 00:58:26,700
So the way Microsoft's Linker works is it actually starts at What's

1138
00:58:26,700 --> 00:58:30,200
called the entry point and it crawls its way outward from there,

1139
00:58:30,400 --> 00:58:33,400
pulling in the symbols that it needs based on what the entry point

1140
00:58:33,400 --> 00:58:34,300
actually calls.

1141
00:58:34,400 --> 00:58:37,600
This is a good way to do dead code elimination because it means that

1142
00:58:37,600 --> 00:58:41,000
you're never going to link a function into executable that nobody ever

1143
00:58:41,000 --> 00:58:41,600
calls.

1144
00:58:41,700 --> 00:58:43,700
Because why would you want to link in a function that nobody ever

1145
00:58:43,700 --> 00:58:43,900
calls?

1146
00:58:44,200 --> 00:58:46,500
That doesn't help you in any way because no one can ever call.

1147
00:58:46,500 --> 00:58:48,700
It's just wasted space, right?

1148
00:58:49,700 --> 00:58:51,500
So what's happening here?

1149
00:58:53,700 --> 00:58:58,400
Is a very logical and very understandable process because here is the

1150
00:58:58,400 --> 00:58:58,800
key.

1151
00:58:59,600 --> 00:59:04,100
All of these translation units that I have in any project that I have,

1152
00:59:04,500 --> 00:59:08,000
all of them can have tons of symbols and all of those symbols can, you

1153
00:59:08,000 --> 00:59:10,300
know, point to each other, and blah, blah, blah.

1154
00:59:10,600 --> 00:59:12,400
But there's one step that's missing.

1155
00:59:12,800 --> 00:59:16,700
How do I actually start executing my program, right?

1156
00:59:16,700 --> 00:59:20,000
Because all of these files, and all of these functions have all

1157
00:59:20,000 --> 00:59:22,900
they're doing is pointing back at each other right there.

1158
00:59:23,100 --> 00:59:26,500
No, the operating system Microsoft Windows, which is actually going to

1159
00:59:26,500 --> 00:59:27,600
run my program.

1160
00:59:28,300 --> 00:59:31,300
I'm not linking with its source code, right?

1161
00:59:31,500 --> 00:59:33,100
So it can't call me.

1162
00:59:33,100 --> 00:59:34,100
How does it call me?

1163
00:59:34,200 --> 00:59:34,700
Right?

1164
00:59:36,000 --> 00:59:39,400
And so what you have to understand is the next step of the process,

1165
00:59:39,400 --> 00:59:39,900
right?

1166
00:59:40,200 --> 00:59:41,800
Which is that link time?

1167
00:59:42,500 --> 00:59:46,200
What's going to happen is we are going to be using knowledge, right?

1168
00:59:46,200 --> 00:59:49,400
The Linker is going to be using knowledge of the platform for which it

1169
00:59:49,400 --> 00:59:53,000
is exporting an executable, and it's going to utilize

1170
00:59:53,100 --> 00:59:58,700
Why's a priori knowledge of how that operating system loads

1171
00:59:58,700 --> 00:59:59,600
executables.

1172
01:00:00,500 --> 01:00:03,200
So what happens when people make an operating system?

1173
01:00:03,800 --> 01:00:11,100
Is they rigorously defined how they will load a piece of data off of

1174
01:00:11,100 --> 01:00:14,800
disk and start execution at it.

1175
01:00:15,300 --> 01:00:15,800
Right?

1176
01:00:16,700 --> 01:00:19,800
And then it is the linkers job to make sure that It prepares an

1177
01:00:19,800 --> 01:00:25,100
executable in such a way so that it conforms with that standard

1178
01:00:27,400 --> 01:00:28,000
Right.

1179
01:00:29,200 --> 01:00:33,300
Now, what I would like to do for the next step is going to take a

1180
01:00:33,300 --> 01:00:36,700
little while so you're going to have to bear with me here as we try to

1181
01:00:36,700 --> 01:00:37,300
get through it.

1182
01:00:37,500 --> 01:00:37,900
Right?

1183
01:00:38,300 --> 01:00:42,500
So first what I'll do is I'll show you the not particularly helpful

1184
01:00:42,500 --> 01:00:46,300
thing that's about to happen and then we'll sort of go a little bit

1185
01:00:46,300 --> 01:00:46,700
further.

1186
01:00:47,000 --> 01:00:51,100
So let's say, I actually use the standard for

1187
01:00:53,000 --> 01:00:58,100
For C programs and I put in here the standard sort of Maine that you

1188
01:00:58,100 --> 01:00:59,600
would expect, right?

1189
01:01:00,300 --> 01:01:01,700
Oops, I didn't mean to do that.

1190
01:01:02,000 --> 01:01:06,600
So I'm going to go ahead and do a compile now of Cl Maine.

1191
01:01:07,100 --> 01:01:11,800
And what you can see, if I add this sort of this boilerplate code,

1192
01:01:11,800 --> 01:01:15,800
that is everyone's seen for the, you know, how a C file is to put how

1193
01:01:15,800 --> 01:01:16,700
execution supposed to start.

1194
01:01:16,700 --> 01:01:17,500
And it C program.

1195
01:01:18,000 --> 01:01:21,400
What you can see is that if I do that, I know immediately get the

1196
01:01:21,400 --> 01:01:22,600
unresolved external symbols

1197
01:01:22,900 --> 01:01:26,300
Or if I'm only compiling that one translation unit that I would have

1198
01:01:26,300 --> 01:01:27,600
expected to get before.

1199
01:01:27,800 --> 01:01:29,200
Why am I getting it now?

1200
01:01:29,300 --> 01:01:32,500
Well, I'm getting it now, because I've actually defined a starting

1201
01:01:32,500 --> 01:01:33,400
point somewhere.

1202
01:01:34,000 --> 01:01:37,000
And so when I Define that actual starting point, the compiler, now

1203
01:01:37,000 --> 01:01:40,600
starts to look at other things that are in that translation unit.

1204
01:01:40,700 --> 01:01:43,700
Now it can choose not to look at them because I haven't actually

1205
01:01:43,700 --> 01:01:45,400
called them, right.

1206
01:01:45,500 --> 01:01:49,000
So the fact that it's complaining about missing bar refuge in

1207
01:01:49,000 --> 01:01:52,600
function, Foo is purely advisory really because it's underneath

1208
01:01:52,800 --> 01:01:54,700
Obligation to even really do that.

1209
01:01:54,700 --> 01:01:58,500
Because since I haven't called Foo, that's not actually necessary.

1210
01:01:58,600 --> 01:02:01,000
But I'm going to actually call Foo here anyway.

1211
01:02:01,200 --> 01:02:03,700
Just to make sure that if you are on a compiler, that's even more

1212
01:02:03,700 --> 01:02:04,200
aggressive.

1213
01:02:04,200 --> 01:02:05,400
It would work, right?

1214
01:02:06,500 --> 01:02:09,800
So point being at some point, when we actually start to use this, we

1215
01:02:09,800 --> 01:02:13,800
will now get our unresolved externals, because now it knows that we're

1216
01:02:13,800 --> 01:02:17,200
actually trying to use these files in these functions.

1217
01:02:17,200 --> 01:02:20,000
And so on, we're starting to actually use the stuff that's in these

1218
01:02:20,000 --> 01:02:21,300
translation units, right?

1219
01:02:21,500 --> 01:02:22,700
So that means I do

1220
01:02:22,800 --> 01:02:23,900
To have everything to find.

1221
01:02:23,900 --> 01:02:27,100
But once I have everything to find, what you'll notice is now the

1222
01:02:27,100 --> 01:02:31,100
linking step actually works and I get my main three dot exe.

1223
01:02:31,300 --> 01:02:33,000
Why is it called mean to .exe?

1224
01:02:34,000 --> 01:02:36,500
Because that happens to be the first thing that was specified on the

1225
01:02:36,800 --> 01:02:37,400
command line.

1226
01:02:37,600 --> 01:02:42,600
The definition of how Microsoft C compiler CL command works.

1227
01:02:42,800 --> 01:02:45,300
Is it will just call it the first thing it saw?

1228
01:02:45,300 --> 01:02:46,200
It will call it that .exe.

1229
01:02:47,400 --> 01:02:50,800
We can control that using like a directive like the output directive

1230
01:02:50,800 --> 01:02:52,700
to tell it to produce some other file, but

1231
01:02:52,800 --> 01:02:55,900
It's fine by me and if I want it to be the other way around, I could

1232
01:02:55,900 --> 01:02:57,200
just switch it like this too.

1233
01:02:57,200 --> 01:02:59,800
And then the automatic naming would produce a main w.

1234
01:03:00,000 --> 01:03:00,300
Right.

1235
01:03:00,300 --> 01:03:03,500
So I'm going to delete the main 31 and leave it like that.

1236
01:03:04,300 --> 01:03:08,300
So there's main dot exe, right again, we have not really covered how

1237
01:03:08,300 --> 01:03:09,200
well the Lincoln stuff works yet.

1238
01:03:09,200 --> 01:03:11,600
So we're getting there, but I've just got to take it one step at a

1239
01:03:11,600 --> 01:03:12,000
time.

1240
01:03:12,300 --> 01:03:12,700
Okay?

1241
01:03:13,100 --> 01:03:18,300
Now what you'll notice is a, some ridiculous stuff has now occurred,

1242
01:03:18,400 --> 01:03:22,900
okay, bad, bad, bad things have happened, the train is gone completely

1243
01:03:22,900 --> 01:03:23,800
off the rails.

1244
01:03:24,100 --> 01:03:26,000
And how do I know this has happened?

1245
01:03:26,000 --> 01:03:27,800
And why did I say that?

1246
01:03:27,800 --> 01:03:29,700
We're going to take a bunch of steps up few minutes ago.

1247
01:03:29,700 --> 01:03:29,800
You

1248
01:03:30,000 --> 01:03:32,200
you'll notice I said the next thing I'll show you going to take a lot

1249
01:03:32,200 --> 01:03:33,400
of steps you'll have to bear with me.

1250
01:03:33,700 --> 01:03:36,900
Well what what do you see in front of you right now?

1251
01:03:37,400 --> 01:03:39,300
What do you see when I take this directory?

1252
01:03:39,600 --> 01:03:45,200
Well you can see that main three that obj took 795 B to encode as an

1253
01:03:45,200 --> 01:03:50,500
object file and main.cpp and Maine to see the other translation unit

1254
01:03:50,500 --> 01:03:55,800
took 1409 B to encode right now.

1255
01:03:56,100 --> 01:03:59,400
You know, I'm no mathematician as I said at the beginning of the in

1256
01:03:59,400 --> 01:03:59,800
the, in the

1257
01:04:00,000 --> 01:04:00,300
Stream.

1258
01:04:00,300 --> 01:04:05,400
Actually we're talking about math but that's, you know, just just a

1259
01:04:05,400 --> 01:04:09,400
little over two k right in terms of size.

1260
01:04:09,900 --> 01:04:15,600
So that's how much machine code we asked the compiler to make, that's

1261
01:04:15,600 --> 01:04:19,900
how much it took to represent the source code, we gave it so why on

1262
01:04:19,900 --> 01:04:23,400
Earth is it an 80 K executable that popped out?

1263
01:04:23,500 --> 01:04:25,200
Like what happened here?

1264
01:04:25,500 --> 01:04:26,000
Right.

1265
01:04:26,200 --> 01:04:27,400
What is going on?

1266
01:04:29,000 --> 01:04:30,100
It's nuts, right?

1267
01:04:30,100 --> 01:04:34,800
I mean stuff has gone completely as going completely off the rails.

1268
01:04:36,200 --> 01:04:40,600
The answer here is a bunch of implicit stuff, a bunch of implicit

1269
01:04:40,600 --> 01:04:43,400
stuff that the compiler just does and which we are now going to have

1270
01:04:43,400 --> 01:04:47,200
to turn all of it off to try to get down to the understanding that I'm

1271
01:04:47,200 --> 01:04:49,100
trying to give you, which is about exactly what happened.

1272
01:04:49,100 --> 01:04:50,300
So bear with me.

1273
01:04:50,300 --> 01:04:54,300
As I talk about all the stuff that the compiler just basically pooped

1274
01:04:54,300 --> 01:04:56,900
on us in a little like, poop sauce Sunday.

1275
01:04:57,300 --> 01:04:59,900
All right, so where does this problem come from?

1276
01:04:59,900 --> 01:05:03,200
Well, it comes from the fact that if you think about what's supposed

1277
01:05:03,200 --> 01:05:03,900
to happen,

1278
01:05:04,800 --> 01:05:09,300
if you pop open a copy of kernighan and Ritchie C or something like

1279
01:05:09,300 --> 01:05:13,300
this or the definition of C, Is it supposed to be that if I want to

1280
01:05:13,300 --> 01:05:18,100
write a c program, I can have in Maine NRC Karis our RV and the

1281
01:05:18,800 --> 01:05:22,300
execution of my program will start there, right?

1282
01:05:22,300 --> 01:05:23,900
That is what's supposed to happen.

1283
01:05:23,900 --> 01:05:26,600
That's the definition of how a c program supposed to work.

1284
01:05:26,600 --> 01:05:27,400
It's in the standard.

1285
01:05:27,400 --> 01:05:28,900
That's just what happens, right?

1286
01:05:29,500 --> 01:05:34,400
Well unfortunately that has almost nothing to do with how windows.

1287
01:05:34,600 --> 01:05:37,000
Is actually runs executables at all.

1288
01:05:37,200 --> 01:05:40,100
Windows is not defined to conform to the C standard.

1289
01:05:40,100 --> 01:05:44,000
Window does his own operating system that has nothing to do with c and

1290
01:05:44,000 --> 01:05:49,100
in fact Pascal was probably a very common thing that Windows was

1291
01:05:49,100 --> 01:05:50,000
targeting originally.

1292
01:05:50,000 --> 01:05:54,000
If I remember correctly, in fact a lot of the really early Windows

1293
01:05:54,000 --> 01:05:55,600
stuff I think was Pascal targeted.

1294
01:05:56,800 --> 01:05:59,800
but neither here, nor there point being -

1295
01:06:00,000 --> 01:06:03,000
Such as an operating system, is a program that's running on the

1296
01:06:03,000 --> 01:06:03,600
computer.

1297
01:06:03,600 --> 01:06:07,200
It's the thing that needs to load and execute our executable.

1298
01:06:07,400 --> 01:06:09,800
Again, we'll talk about that a little bit later on when we get to

1299
01:06:09,800 --> 01:06:14,100
that, when we finally get to that point, but it has no interest in

1300
01:06:14,100 --> 01:06:16,700
specifying what ENT Main in our see.

1301
01:06:16,700 --> 01:06:20,000
Kara starts our RV has to do with anything, or how you call it or any

1302
01:06:20,000 --> 01:06:20,600
of that stuff.

1303
01:06:21,300 --> 01:06:26,000
So, actually, what happens is between the specification that Windows

1304
01:06:26,000 --> 01:06:29,900
lays down for our executables are supposed to run and the

1305
01:06:30,000 --> 01:06:34,700
Actual see specification of how compilation I'm sorry in, how

1306
01:06:34,700 --> 01:06:38,400
execution, and program starts as a supposed to start in between there,

1307
01:06:38,400 --> 01:06:43,500
there is a giant Golf and that Gulf is filled with code, from the C

1308
01:06:43,500 --> 01:06:47,500
standard Library, which Microsoft's compiler in order to make it

1309
01:06:47,500 --> 01:06:51,500
appear to be working when you just do in Maine in RTC and have the

1310
01:06:51,500 --> 01:06:54,800
program actually work, which it would in this case, right?

1311
01:06:56,000 --> 01:06:59,800
That Gulf is filled with runtime code that Microsoft's

1312
01:07:00,000 --> 01:07:02,800
Pilar will just plain stick in.

1313
01:07:03,100 --> 01:07:03,600
Okay.

1314
01:07:03,800 --> 01:07:07,400
So let's use dump bin, just to verify that this is going on again.

1315
01:07:07,600 --> 01:07:12,500
Remember I can do dis as mm, like I did before I can say main dot exe

1316
01:07:12,500 --> 01:07:16,100
and just ask it to give me the disassembly of that code.

1317
01:07:16,100 --> 01:07:21,500
Now what you will notice is it is massive, right?

1318
01:07:21,500 --> 01:07:26,200
All of this code, it just goes on and on and on and on and on and on

1319
01:07:26,200 --> 01:07:29,800
and on and on and all of that stuff is based on the

1320
01:07:29,900 --> 01:07:35,700
Fact again that Microsoft's compiler interprets your decision to try

1321
01:07:35,700 --> 01:07:41,300
and compile C code as an implicit request for the C runtime libraries

1322
01:07:41,400 --> 01:07:46,900
Preamble stuff, that allows you to get to Maine for that to be

1323
01:07:46,900 --> 01:07:47,500
included.

1324
01:07:47,500 --> 01:07:50,000
And that is all the code that you're seeing scrolling across three

1325
01:07:50,000 --> 01:07:50,400
right now.

1326
01:07:50,400 --> 01:07:55,000
It is the machine code that you are looking at, which has been

1327
01:07:55,000 --> 01:07:56,200
included for you.

1328
01:07:56,500 --> 01:07:59,800
That is all the C runtime, libraries set up stuff and

1329
01:08:00,000 --> 01:08:02,800
Preparation and thread will stuff and everything.

1330
01:08:02,900 --> 01:08:08,000
All that stuff is just getting welded in there for you, right?

1331
01:08:08,200 --> 01:08:09,300
You can't see it.

1332
01:08:09,300 --> 01:08:13,200
But that's actually what's happening and it's actually coming from dot

1333
01:08:13,200 --> 01:08:17,100
lib files which are files that the compiler has in its lib directory.

1334
01:08:17,100 --> 01:08:21,399
You can actually see in fact if we go back up here, you can see that

1335
01:08:21,399 --> 01:08:25,700
we've got this lib path here and there's all these sort of and lib

1336
01:08:25,700 --> 01:08:29,399
stuff where we've got these different path variables right.

1337
01:08:29,399 --> 01:08:29,700
Where

1338
01:08:29,899 --> 01:08:33,600
Microsoft is going to look at include and I think include in LeBar,

1339
01:08:33,600 --> 01:08:34,000
the two.

1340
01:08:34,000 --> 01:08:35,000
I think these two here.

1341
01:08:36,399 --> 01:08:39,000
It's going to look at these four pound include files automatically for

1342
01:08:39,000 --> 01:08:39,200
them.

1343
01:08:39,399 --> 01:08:42,700
It's also going to look for Libs automatically in here, right.

1344
01:08:43,300 --> 01:08:48,100
And what we can see if we want to, I believe I can sort of motivate

1345
01:08:48,100 --> 01:08:49,399
this a little bit better as you can see.

1346
01:08:49,399 --> 01:08:53,899
Well, okay, if I do this compile it succeeds, it's getting all this

1347
01:08:53,899 --> 01:08:54,700
code from somewhere.

1348
01:08:54,700 --> 01:08:56,800
We can tell that's true because we look at the file there's all this

1349
01:08:56,800 --> 01:08:57,500
code in there.

1350
01:08:57,600 --> 01:08:58,700
Where is it coming from?

1351
01:08:59,300 --> 01:08:59,800
Well, if

1352
01:09:00,000 --> 01:09:04,399
I want to, I can look at that, set lib and I see what that says there.

1353
01:09:04,600 --> 01:09:08,300
If I want to I could do like old lib equals lib, just get another, and

1354
01:09:08,300 --> 01:09:09,800
then set lib equal to nothing.

1355
01:09:10,100 --> 01:09:12,300
So now lib is just clear, right?

1356
01:09:12,800 --> 01:09:17,700
And I believe, now if I do the CL you'll see what I'm talking about.

1357
01:09:18,399 --> 01:09:23,100
So now I've done a CL here of Maine and Maine three that's to BP and

1358
01:09:23,100 --> 01:09:26,000
what you'll notice is the link failed this time.

1359
01:09:26,100 --> 01:09:27,100
Why did the link fail?

1360
01:09:27,100 --> 01:09:29,899
Well, the reason the linked fail is because now it

1361
01:09:30,000 --> 01:09:35,000
Can't find the code that it needed to insert because we took that

1362
01:09:35,000 --> 01:09:38,500
environment variable away that it was actually using, implicitly

1363
01:09:38,500 --> 01:09:41,800
didn't tell us anything about it but it was implicitly using that as a

1364
01:09:41,800 --> 01:09:44,600
search path to look for the C standard.

1365
01:09:44,600 --> 01:09:47,200
Libraries dot lib file, right?

1366
01:09:47,600 --> 01:09:49,300
But we don't want any of that now.

1367
01:09:49,300 --> 01:09:52,899
Right so now you can see if I take away at search path so the compiler

1368
01:09:52,899 --> 01:09:54,600
doesn't know where to find the libs.

1369
01:09:54,800 --> 01:09:59,700
It's like, hey I can't link my dude you know I can't find the

1370
01:10:00,000 --> 01:10:02,900
Runtime Library code and I need that code.

1371
01:10:02,900 --> 01:10:04,100
I implicitly link with it.

1372
01:10:04,100 --> 01:10:08,700
That's how I get to Maine DOT to Maine in RC car, starts our RV.

1373
01:10:08,700 --> 01:10:11,500
So, you know, you know, help me out here, right?

1374
01:10:13,200 --> 01:10:15,900
So the first step that we want to take because we're trying to

1375
01:10:15,900 --> 01:10:20,200
investigate this from first principles is we need to stop the compiler

1376
01:10:20,300 --> 01:10:23,800
from inserting a bunch of code that it wants to insert into our code.

1377
01:10:23,900 --> 01:10:29,000
And instead, tell the compiler to Just Produce an executable with only

1378
01:10:29,000 --> 01:10:30,600
our code right?

1379
01:10:30,600 --> 01:10:32,000
As close as possible.

1380
01:10:32,200 --> 01:10:36,300
Just take the object files that we gave you and produce just our code.

1381
01:10:36,300 --> 01:10:38,000
That's all we want, right?

1382
01:10:38,700 --> 01:10:42,000
So, the first thing that I think we can do here and I

1383
01:10:42,700 --> 01:10:46,900
It's always a bit of an archaeological process to get rid of the

1384
01:10:46,900 --> 01:10:49,300
default library, but let's go ahead and just try it.

1385
01:10:49,300 --> 01:10:50,400
We can always look it up.

1386
01:10:53,000 --> 01:10:58,000
See here, if I can find anything in here, ignore the default Salerno.

1387
01:10:58,000 --> 01:10:59,300
That's not what we want.

1388
01:11:00,000 --> 01:11:05,600
Omit default Library name, no enable, try gasps, no off by default.

1389
01:11:05,600 --> 01:11:06,900
No, Richard bugging fishing.

1390
01:11:06,900 --> 01:11:08,500
No send report.

1391
01:11:08,500 --> 01:11:11,000
No, no and no.

1392
01:11:11,000 --> 01:11:16,300
So unfortunately, in here, we don't have what we want.

1393
01:11:17,200 --> 01:11:19,800
So we're just going to have to wing it.

1394
01:11:20,500 --> 01:11:22,100
I believe it's no default lib.

1395
01:11:29,000 --> 01:11:34,300
Yeah, so when we actually get now we're going to we kind of have to

1396
01:11:35,100 --> 01:11:38,100
start talking about the different stages here, but that's okay because

1397
01:11:38,100 --> 01:11:39,200
this is act what I want to do.

1398
01:11:40,000 --> 01:11:43,800
So what I want to do now is I want to create a new basically, a new

1399
01:11:43,800 --> 01:11:47,600
build up at file where we're actually going to control the compilation

1400
01:11:47,800 --> 01:11:49,900
a little bit more succinctly here.

1401
01:11:50,000 --> 01:11:50,500
Right?

1402
01:11:51,300 --> 01:11:56,200
And so, you know what I'll do to is let me let me just go ahead and

1403
01:11:56,700 --> 01:11:58,400
make a like a dummy file here.

1404
01:11:58,400 --> 01:11:58,600
Bill.

1405
01:11:58,800 --> 01:11:59,500
Dot bat.

1406
01:12:03,600 --> 01:12:06,600
okay, and so this build up bat file,

1407
01:12:08,400 --> 01:12:12,700
What I'm doing going to do here is I'm going to sort of motivate this

1408
01:12:12,700 --> 01:12:16,500
by just showing how to do these steps individually and control each of

1409
01:12:16,500 --> 01:12:17,200
them individually.

1410
01:12:17,200 --> 01:12:20,800
So that again, because that's another thing I want to get do so on our

1411
01:12:20,800 --> 01:12:21,600
way to removing it.

1412
01:12:21,600 --> 01:12:22,600
Here's what I want to do.

1413
01:12:23,100 --> 01:12:26,100
Previously, we're specifying everything on one line and I was sort of

1414
01:12:26,100 --> 01:12:28,200
saying, well what's happening is through sneeze obj files and it's

1415
01:12:28,200 --> 01:12:32,100
calling the Linker let's do that manually now so we can see each

1416
01:12:32,100 --> 01:12:35,100
individual step and control each individual step, right?

1417
01:12:35,400 --> 01:12:38,100
So what I want to do in this case is I want to only

1418
01:12:38,200 --> 01:12:38,900
Output.

1419
01:12:39,400 --> 01:12:39,900
The C file.

1420
01:12:39,900 --> 01:12:41,600
I don't want to link, right?

1421
01:12:41,600 --> 01:12:46,300
I just want to say take in take an input translation, unit and produce

1422
01:12:46,300 --> 01:12:47,800
an obj from it, right?

1423
01:12:47,800 --> 01:12:51,200
That's the only thing that I want to do and I should be able to do

1424
01:12:51,200 --> 01:12:56,100
that by like a there's there's usually a switch for this again.

1425
01:12:56,100 --> 01:12:58,500
I never remember what these switches are because you do them once and

1426
01:12:58,500 --> 01:12:59,500
you put them in your ear.

1427
01:13:01,500 --> 01:13:02,900
Batch file menu, forget what they are.

1428
01:13:03,800 --> 01:13:05,900
So let's see.

1429
01:13:07,000 --> 01:13:08,600
Let me see if I can

1430
01:13:10,500 --> 01:13:11,000
Here.

1431
01:13:13,300 --> 01:13:14,000
For link?

1432
01:13:16,500 --> 01:13:18,600
No, there it is.

1433
01:13:18,600 --> 01:13:21,800
So it's I thought it was /c, but they look the such / lowercase C.

1434
01:13:22,300 --> 01:13:24,500
So you can see compile only no link.

1435
01:13:24,700 --> 01:13:29,100
So, if I want to, I can make in any one of these cases, I can say, oh,

1436
01:13:29,100 --> 01:13:30,100
compile main.cpp.

1437
01:13:32,200 --> 01:13:37,800
But what I want you to do is I want you to only I want you to only

1438
01:13:37,800 --> 01:13:38,800
produce the obj file.

1439
01:13:38,800 --> 01:13:42,300
So you can see that all it does in this case, it's reduce that one obj

1440
01:13:42,300 --> 01:13:42,500
file.

1441
01:13:42,500 --> 01:13:42,900
So in fact, if

1442
01:13:43,100 --> 01:13:46,000
If I delete all the obj's here, right?

1443
01:13:46,100 --> 01:13:51,500
So all my obj's are gone and now I do CL / C main.cpp.

1444
01:13:51,500 --> 01:13:54,200
You can see that, the only thing it did was reduce the obj.

1445
01:13:54,400 --> 01:13:58,100
So now we are in a position to actually be able to manually control

1446
01:13:58,100 --> 01:13:59,600
each step of the process and see it.

1447
01:13:59,800 --> 01:14:03,300
So we can say, all right, what I want you to do is produce, you know,

1448
01:14:03,300 --> 01:14:04,300
that obj.

1449
01:14:04,400 --> 01:14:07,600
I want you to produce this.obj, right?

1450
01:14:07,700 --> 01:14:11,500
And so if I do this, and I do a build, it does each of those red, it

1451
01:14:11,500 --> 01:14:12,700
produces both obj's.

1452
01:14:13,100 --> 01:14:16,600
And now what I can do is I can specify a link line, right?

1453
01:14:17,300 --> 01:14:21,500
So I'm actually going to invoke the Linker myself rather than letting

1454
01:14:21,500 --> 01:14:23,400
CL do it for me, right?

1455
01:14:23,400 --> 01:14:27,300
And what I can pass to the link line, is my to obj's, I can say, I

1456
01:14:27,300 --> 01:14:29,800
want you to link those two obj's.

1457
01:14:30,300 --> 01:14:34,500
And now we've gotten back right to the place we were before where I'm

1458
01:14:34,500 --> 01:14:37,400
like, I link these two obj's and it's like, I can't find my default

1459
01:14:37,400 --> 01:14:39,500
library because I nuked, it, slid path.

1460
01:14:39,500 --> 01:14:40,900
It can't find them, right?

1461
01:14:41,300 --> 01:14:42,600
It has no idea where they are.

1462
01:14:43,800 --> 01:14:48,300
Okay, so we now know that no default lib can be specified to the

1463
01:14:48,300 --> 01:14:53,200
Linker and to tell it to stop actually providing the C runtime Library

1464
01:14:53,900 --> 01:14:56,400
as something that it's going to link to right.

1465
01:14:56,800 --> 01:14:59,100
So now if I do my build I should get

1466
01:15:00,600 --> 01:15:05,500
Well, if you do exactly what I expected to do which is give me errors

1467
01:15:05,500 --> 01:15:08,300
based on stuff that it doesn't know how to do because it doesn't have

1468
01:15:08,300 --> 01:15:10,100
the C runtime Library more, right?

1469
01:15:13,400 --> 01:15:14,100
And that's okay.

1470
01:15:14,900 --> 01:15:22,200
So now we're down to a situation where we only have to deal with our

1471
01:15:22,200 --> 01:15:25,100
own code, but we have some issues.

1472
01:15:25,200 --> 01:15:27,800
So the first thing I'm going to do is I'm going to eliminate our

1473
01:15:27,800 --> 01:15:31,000
floating-point code because there's this thing called float used,

1474
01:15:31,700 --> 01:15:34,500
which is a way I don't really want to get into what this is right now.

1475
01:15:34,500 --> 01:15:37,500
This is a separate issue that has to do with just removing the C

1476
01:15:37,500 --> 01:15:38,400
runtime Library.

1477
01:15:38,900 --> 01:15:42,100
Basically, what it is is it's a way of the C runtime Library

1478
01:15:42,700 --> 01:15:46,800
The way for the compiler to signal that floating Point operations were

1479
01:15:46,800 --> 01:15:50,400
used in the course of compilation, it's has nothing to do with the

1480
01:15:50,400 --> 01:15:51,300
stuff that we're talking about.

1481
01:15:51,300 --> 01:15:55,100
Now, it's really better left for the subject of how to compile without

1482
01:15:55,100 --> 01:15:57,100
the C runtime Library, which is not what I want to get into.

1483
01:15:57,300 --> 01:16:02,100
So all I'm going to do is just leave that out for now and focus just

1484
01:16:02,100 --> 01:16:04,100
on the parts we actually care about right?

1485
01:16:04,100 --> 01:16:06,300
Because if you don't use floating point, you don't have that problem.

1486
01:16:06,800 --> 01:16:09,200
So we can talk about that some other, some on, some of the stream.

1487
01:16:09,700 --> 01:16:12,100
So, what you can see now is we've got our build

1488
01:16:12,400 --> 01:16:13,000
Working.

1489
01:16:13,200 --> 01:16:17,400
And I also wonder if I can maybe quiet down the compiler a little bit

1490
01:16:17,400 --> 01:16:23,100
here, in the case of keeps doing our this sort of over over, you know,

1491
01:16:23,700 --> 01:16:26,900
overly aggressive Preamble of printing out and stuff and I think you

1492
01:16:26,900 --> 01:16:33,500
kind of all get the point by now and let's see quiet, you know.

1493
01:16:40,200 --> 01:16:41,800
Let's see.

1494
01:16:42,500 --> 01:16:45,900
How do I get you to stop printing out the version?

1495
01:16:50,000 --> 01:16:53,100
Look like I really I know that I can you know what, let's take a look

1496
01:16:53,100 --> 01:16:55,500
at quickly at the build-up at and handmade mirror because I know that

1497
01:16:55,500 --> 01:16:59,300
I look this up before no logo, that's what we're looking for.

1498
01:16:59,900 --> 01:17:02,500
All right, so I'm also going to stick no logo in there.

1499
01:17:04,100 --> 01:17:06,400
Guess I'll also use this format.

1500
01:17:06,700 --> 01:17:10,800
Well I'll use a slash that's really the more Windows command line.

1501
01:17:10,900 --> 01:17:11,700
Way to do things.

1502
01:17:12,500 --> 01:17:12,900
All right.

1503
01:17:15,400 --> 01:17:18,500
Okay, so here we can see the steps occurring.

1504
01:17:18,500 --> 01:17:21,700
Here's the main.cpp compilation, here's the main three dot CPP

1505
01:17:21,700 --> 01:17:25,100
compilation, which again, this main.cpp, one includes main to.

1506
01:17:25,100 --> 01:17:26,900
So this is the translation unit.

1507
01:17:27,300 --> 01:17:28,500
No transition at those two.

1508
01:17:28,700 --> 01:17:29,700
Now we have the link line.

1509
01:17:29,700 --> 01:17:33,400
It can't find main CRT startup and now we're at the part that I

1510
01:17:33,400 --> 01:17:37,300
actually wanted to talk about next, which again, is that executable

1511
01:17:37,300 --> 01:17:40,200
loading and Running part of things, okay?

1512
01:17:41,500 --> 01:17:46,500
So what Windows is going to do is it is going to, you know, it's the

1513
01:17:46,500 --> 01:17:48,100
thing that runs the code, right?

1514
01:17:48,100 --> 01:17:50,500
It's the it's the thing that's running on the operating system that

1515
01:17:50,500 --> 01:17:53,500
booted that you booted into, it's the code that's running right now.

1516
01:17:53,700 --> 01:17:57,100
So in order to load and run an executable, it, what it has to do first

1517
01:17:57,100 --> 01:17:59,600
is it has to map that executable into memory somehow

1518
01:18:00,000 --> 01:18:02,800
Again, we don't really care how that's not really the point of this

1519
01:18:03,000 --> 01:18:04,000
particular investigation.

1520
01:18:04,600 --> 01:18:07,600
So we just care that it gets into memory somehow which it will and

1521
01:18:07,600 --> 01:18:09,900
then it needs to know where to start, right?

1522
01:18:10,000 --> 01:18:14,600
It needs to know how do I start executing the code in this executable,

1523
01:18:14,600 --> 01:18:15,000
right?

1524
01:18:15,000 --> 01:18:16,000
It needs a place.

1525
01:18:16,600 --> 01:18:19,000
And so what's going to happen with the Linker?

1526
01:18:20,700 --> 01:18:23,000
Is the Windows executable file format, right?

1527
01:18:23,000 --> 01:18:26,100
Because windows again, defines the file format for an x z how the

1528
01:18:26,100 --> 01:18:30,100
codes laid out stuff that Windows XP file format contains in it

1529
01:18:31,200 --> 01:18:33,900
information about how to know where to start.

1530
01:18:34,400 --> 01:18:37,000
So what's going to happen is Windows, is going to load the executable.

1531
01:18:37,000 --> 01:18:40,300
It's going to look at the information that's in the executable that

1532
01:18:40,300 --> 01:18:40,700
window.

1533
01:18:40,700 --> 01:18:42,500
Specifically defined to be in there.

1534
01:18:43,200 --> 01:18:45,100
It's going to pull out of that table.

1535
01:18:45,100 --> 01:18:46,400
Where am I supposed to start?

1536
01:18:46,700 --> 01:18:49,700
And it's going to point the exit the execution pointer.

1537
01:18:50,000 --> 01:18:53,900
Of the processor at that line of code and go right?

1538
01:18:53,900 --> 01:18:55,000
That's what's going to happen.

1539
01:18:55,600 --> 01:19:00,500
So what that means is, the Linker has to be able to produce that part

1540
01:19:00,500 --> 01:19:04,900
of the code, which says, here is you know, that that part of the

1541
01:19:04,900 --> 01:19:08,400
executable, which says, here's the address, here's the location, the

1542
01:19:08,400 --> 01:19:11,500
executable that you're supposed to start at windows, so start there

1543
01:19:12,000 --> 01:19:15,200
and the the convention that they've used for that is to say, well,

1544
01:19:15,300 --> 01:19:17,900
main CRT start-up is the name.

1545
01:19:17,900 --> 01:19:19,800
We will look for if we are not

1546
01:19:19,900 --> 01:19:24,200
Not told otherwise in order to start up, right?

1547
01:19:24,300 --> 01:19:29,600
And what you can see hopefully somewhere here.

1548
01:19:29,600 --> 01:19:35,700
Let's see, is the function signature for it?

1549
01:19:36,200 --> 01:19:40,500
Although I don't actually see the function signature for it.

1550
01:19:40,700 --> 01:19:43,500
Can you please msdn?

1551
01:19:43,500 --> 01:19:46,500
Tell me the fuck I just want to see the function signature.

1552
01:19:49,000 --> 01:19:52,500
But of course, it doesn't seem to tell me.

1553
01:19:56,700 --> 01:20:00,300
I just want the function signature just want the function signature.

1554
01:20:05,200 --> 01:20:06,300
Well, alright.

1555
01:20:08,800 --> 01:20:09,200
Hey.

1556
01:20:12,200 --> 01:20:13,100
Oh Windows.

1557
01:20:14,400 --> 01:20:16,900
Well I don't know where the function signature for this is but I don't

1558
01:20:16,900 --> 01:20:19,900
really care because I can easily find out, right?

1559
01:20:20,800 --> 01:20:23,900
All I really have to do if I want the function signature is I can just

1560
01:20:24,000 --> 01:20:26,800
look at what the C runtime Library defines the function signature, and

1561
01:20:26,800 --> 01:20:27,400
I can go from there.

1562
01:20:28,100 --> 01:20:30,800
So let's take a look at where is our simple?

1563
01:20:30,900 --> 01:20:33,000
We have like a test project right here, it is.

1564
01:20:42,900 --> 01:20:43,400
Here we go.

1565
01:20:44,700 --> 01:20:45,600
So here's our.

1566
01:20:46,000 --> 01:20:49,900
This is a test project that we had in handmade hero.

1567
01:20:49,900 --> 01:20:53,500
I'm just going to look at Main CRT startup.

1568
01:20:55,200 --> 01:20:56,100
What is it called?

1569
01:21:02,100 --> 01:21:03,500
And see if we can find it.

1570
01:21:06,900 --> 01:21:09,600
Probably I would have to change the type of project.

1571
01:21:09,600 --> 01:21:13,000
In this case, I guess I might have to even do a new one.

1572
01:21:14,000 --> 01:21:14,800
Let's see here.

1573
01:21:19,500 --> 01:21:20,700
Actually, you know what, I could do to?

1574
01:21:21,100 --> 01:21:25,000
I could just search for that in the C runtime Library.

1575
01:21:29,000 --> 01:21:33,800
So if I go through here and say, I don't need that folder, if I just

1576
01:21:33,800 --> 01:21:42,500
say, all right in program files, wherever this stuff ended up.

1577
01:21:42,500 --> 01:21:43,400
Let's see.

1578
01:21:44,900 --> 01:21:50,300
I can hear visual studio time Library.

1579
01:21:51,400 --> 01:21:54,100
So this is the source directory for the runtime Library.

1580
01:21:54,600 --> 01:21:57,200
It's going to say, tell me where that is.

1581
01:22:03,700 --> 01:22:04,300
All right.

1582
01:22:06,400 --> 01:22:11,400
So now in theory, I should be able to find this what the function

1583
01:22:11,400 --> 01:22:13,200
signature for main CRT startup is.

1584
01:22:13,400 --> 01:22:17,500
I just want positive confirmation of what it expects that thing to

1585
01:22:17,500 --> 01:22:18,100
look like.

1586
01:22:18,100 --> 01:22:21,400
And of course, we could just blindly guess, but let's see.

1587
01:22:21,700 --> 01:22:24,500
So here is mean CRT startup.

1588
01:22:25,100 --> 01:22:26,400
And looks like it.

1589
01:22:26,400 --> 01:22:28,000
Just does nothing, right?

1590
01:22:28,000 --> 01:22:29,400
It looks like there's no function.

1591
01:22:29,400 --> 01:22:33,000
Signature of there are no parameters passed to it, right?

1592
01:22:33,000 --> 01:22:34,000
That's what it looks like.

1593
01:22:34,300 --> 01:22:36,100
So I'm going to go with

1594
01:22:36,300 --> 01:22:38,900
That for now because we have a bunch of other stuff to talk about.

1595
01:22:40,300 --> 01:22:44,900
Okay, so here is our function, signature, I assume, although it

1596
01:22:44,900 --> 01:22:47,300
doesn't say what it returns as well.

1597
01:22:47,300 --> 01:22:48,900
Let's, let's actually take a look at that.

1598
01:22:48,900 --> 01:22:56,200
Here to means here to start up, and take a look and see what it

1599
01:22:56,200 --> 01:22:58,700
actually returns to me.

1600
01:22:58,700 --> 01:23:00,800
Answer it returns an integer.

1601
01:23:01,400 --> 01:23:03,900
So I'm going to turn it into juror as well.

1602
01:23:04,900 --> 01:23:06,500
Means here at you start up, okay?

1603
01:23:13,900 --> 01:23:18,800
Okay, so what we've done now is we've just conformed to the standard

1604
01:23:19,500 --> 01:23:22,200
or we haven't quite conform to certain, but we're close to conform to

1605
01:23:22,200 --> 01:23:23,000
the standard will still show.

1606
01:23:23,000 --> 01:23:24,400
There's one more thing involved here.

1607
01:23:25,200 --> 01:23:30,300
We've conform to the standard of what the Linker is looking for, as

1608
01:23:30,300 --> 01:23:34,200
the default entry point to the program, which it's going to look for

1609
01:23:34,200 --> 01:23:37,700
by name in the obj's, that it gets on the link line, it's going to

1610
01:23:37,700 --> 01:23:42,100
look for a main CRT startup function defined and if it finds one, it

1611
01:23:42,100 --> 01:23:43,500
will use that as the

1612
01:23:43,600 --> 01:23:46,000
Thing it puts in the executable that tells Windows here is where

1613
01:23:46,000 --> 01:23:49,200
execution will start right now.

1614
01:23:49,200 --> 01:23:52,400
Unfortunately, for us, that's really not going to quite comply and

1615
01:23:52,400 --> 01:23:55,700
that gets into the part of the obj's that I sort of said we're going

1616
01:23:55,700 --> 01:23:59,200
to talk about in a second and so now is the time that we will talk

1617
01:23:59,200 --> 01:23:59,800
about it.

1618
01:24:00,100 --> 01:24:03,500
So if I actually call the build here, what you can see is it still

1619
01:24:03,500 --> 01:24:07,100
says that the entry point must be defined and it's like well I thought

1620
01:24:07,100 --> 01:24:08,300
we defined the entry point.

1621
01:24:08,300 --> 01:24:10,800
I don't understand like what's going on here, right?

1622
01:24:10,800 --> 01:24:12,100
Something weird is happening.

1623
01:24:13,600 --> 01:24:18,200
Well the problem that we run into, if we look at what's defined in our

1624
01:24:18,200 --> 01:24:21,700
file is, if we look at these entry points we've got our 20 BJ's.

1625
01:24:21,800 --> 01:24:26,500
Let's take a look at what our end ostensibly.

1626
01:24:26,700 --> 01:24:29,900
The thing that defined main CRT startup what it actually.

1627
01:24:30,000 --> 01:24:31,800
Pain in the main dot obj, right?

1628
01:24:31,800 --> 01:24:33,100
Here's the disassembly for it.

1629
01:24:33,200 --> 01:24:39,100
Now, what you'll notice is actually the symbol main CRT startup has

1630
01:24:39,100 --> 01:24:41,200
not been defined anywhere.

1631
01:24:41,500 --> 01:24:46,700
The symbol we defined was question mark main CRT startup at at y HX Z,

1632
01:24:47,100 --> 01:24:47,700
right?

1633
01:24:49,900 --> 01:24:52,600
So now we have to ask the question, how do we Define an actual symbol

1634
01:24:52,600 --> 01:24:53,500
May answer to Startup?

1635
01:24:53,500 --> 01:24:57,100
And why the heck is what is this, right?

1636
01:24:57,100 --> 01:24:58,100
I glossed over it before.

1637
01:24:58,100 --> 01:24:58,800
What is this?

1638
01:25:00,600 --> 01:25:02,100
So now let's talk about what that is.

1639
01:25:02,200 --> 01:25:06,400
This is called C++ name mangling colloquially.

1640
01:25:07,200 --> 01:25:11,200
And what this is, is, remember early on, I sort of said, well in see

1641
01:25:11,200 --> 01:25:13,500
we didn't have function overloading.

1642
01:25:14,000 --> 01:25:18,900
Well, C++ does have function overloading and what that means is that

1643
01:25:18,900 --> 01:25:19,200
since

1644
01:25:19,400 --> 01:25:24,100
See, never allowed you to have more than one function with the same

1645
01:25:24,100 --> 01:25:24,700
name.

1646
01:25:25,500 --> 01:25:29,300
It's Linker was set up to just say, here's the name of a function.

1647
01:25:30,300 --> 01:25:32,500
And you call that function by name.

1648
01:25:32,500 --> 01:25:36,200
I can bind those two together, but when C++ came along that was no

1649
01:25:36,200 --> 01:25:39,800
longer sufficient, I can have many different versions of the same

1650
01:25:39,800 --> 01:25:40,200
function.

1651
01:25:40,200 --> 01:25:41,900
Foo one that takes an integer.

1652
01:25:41,900 --> 01:25:43,100
One that takes to care Stars.

1653
01:25:43,100 --> 01:25:44,000
One that takes a float.

1654
01:25:44,000 --> 01:25:46,900
One that takes a struct one that takes this but pop, right?

1655
01:25:47,700 --> 01:25:53,300
So what C++ did to continue backwards compatibility with existing see

1656
01:25:53,300 --> 01:25:54,200
linkers?

1657
01:25:55,800 --> 01:26:00,700
What's the just mangle the names of functions so that the name of the

1658
01:26:00,700 --> 01:26:05,300
function included markup that told you what its function signature

1659
01:26:05,300 --> 01:26:05,900
was?

1660
01:26:06,600 --> 01:26:10,700
So, this right here is a way of saying that it takes an integer,

1661
01:26:11,100 --> 01:26:11,600
right?

1662
01:26:13,000 --> 01:26:18,100
This right here is a way of saying it takes a void and that's what

1663
01:26:18,100 --> 01:26:19,600
that name mangling does.

1664
01:26:20,600 --> 01:26:24,000
What that means is that if an external program is trying to look at an

1665
01:26:24,000 --> 01:26:26,900
obj file in find a specific name.

1666
01:26:28,200 --> 01:26:32,700
If that name is compiled with C++ name mangling, it will not be found

1667
01:26:32,700 --> 01:26:36,000
because the name that it will actually be put under is some mangled

1668
01:26:36,000 --> 01:26:39,500
name that includes a bunch of stuff from the calling convention in the

1669
01:26:39,500 --> 01:26:41,200
type specification and all this other stuff.

1670
01:26:44,600 --> 01:26:51,300
so what we need to do is let the compiler, no, not the Linker, but the

1671
01:26:51,300 --> 01:26:58,600
compiler, that this particular function needs to be compiled compliant

1672
01:26:58,600 --> 01:26:59,900
with the sea

1673
01:27:00,800 --> 01:27:02,300
There's two ways we can do that.

1674
01:27:02,600 --> 01:27:06,500
One is we can put it in an extern, see block which tells it to just

1675
01:27:06,600 --> 01:27:09,500
use that, right?

1676
01:27:09,700 --> 01:27:10,800
And you can see what happens.

1677
01:27:10,800 --> 01:27:15,700
Now when I do it right there is my main CR to start up the other way

1678
01:27:15,700 --> 01:27:20,000
is we can tell it to do that just as a property of the function name

1679
01:27:20,000 --> 01:27:24,300
itself which I believe is just that right?

1680
01:27:25,800 --> 01:27:26,300
Nope.

1681
01:27:27,800 --> 01:27:28,600
Oh I know.

1682
01:27:28,600 --> 01:27:28,800
No.

1683
01:27:28,800 --> 01:27:30,000
Sorry, it's still extern.

1684
01:27:30,000 --> 01:27:31,600
See, that's just the calling convention.

1685
01:27:32,100 --> 01:27:32,800
It's that

1686
01:27:34,500 --> 01:27:35,000
Right.

1687
01:27:35,400 --> 01:27:39,700
And now we've actually got a main CRT startup that is actually defined

1688
01:27:39,700 --> 01:27:42,500
directly in the code, right?

1689
01:27:44,200 --> 01:27:48,100
Okay, so now we're in a good position to actually try to get these two

1690
01:27:48,100 --> 01:27:49,100
things to connect up.

1691
01:27:49,400 --> 01:27:52,500
And again, the only problem that we're going to face here is the

1692
01:27:52,500 --> 01:27:54,900
inability to find the correct what?

1693
01:27:54,900 --> 01:28:00,600
This should be correctly, defined as and I don't actually know because

1694
01:28:00,600 --> 01:28:03,900
again, I couldn't actually find that specifically, so let's just

1695
01:28:03,900 --> 01:28:04,200
double check.

1696
01:28:04,300 --> 01:28:08,200
Care when I tell it, we don't want that.

1697
01:28:08,400 --> 01:28:09,900
You notice we're getting an entry point.

1698
01:28:09,900 --> 01:28:13,700
Must be defined are now as opposed to a main CRT startup is not

1699
01:28:13,700 --> 01:28:14,300
defined.

1700
01:28:14,700 --> 01:28:19,400
So, in that particular in, let me, let me go ahead and here and just

1701
01:28:19,400 --> 01:28:20,000
take a look here.

1702
01:28:31,500 --> 01:28:32,700
We should find.

1703
01:28:32,800 --> 01:28:36,700
I think we need one additional thing here for their entry point is not

1704
01:28:36,700 --> 01:28:38,500
to find because I just want to again.

1705
01:28:38,500 --> 01:28:44,200
This is sort of a this sort of a compiler Linker sort of snafu here I

1706
01:28:44,200 --> 01:28:46,200
believe if we did this

1707
01:28:50,300 --> 01:28:52,400
And let's see here, / link.

1708
01:28:53,900 --> 01:28:54,900
No, default rib.

1709
01:28:57,800 --> 01:28:59,200
how do I do the

1710
01:29:00,700 --> 01:29:04,900
Never under I this this is the this is the part that always slows

1711
01:29:04,900 --> 01:29:07,300
everything down because we got to remember all the vagaries of this

1712
01:29:07,300 --> 01:29:09,900
particular compilers fun.

1713
01:29:09,900 --> 01:29:11,400
It's / lowercase.

1714
01:29:11,400 --> 01:29:16,700
Link /, lowercase link.

1715
01:29:17,300 --> 01:29:18,100
No default lip.

1716
01:29:18,100 --> 01:29:18,700
There we go.

1717
01:29:20,100 --> 01:29:20,700
Okay.

1718
01:29:23,300 --> 01:29:28,800
So again, at this point, now we're in the position of I just want to

1719
01:29:28,800 --> 01:29:32,900
make sure that this was, this was all happening correctly here.

1720
01:29:33,200 --> 01:29:37,200
So now we have to figure out how we're going to get the compiler to.

1721
01:29:37,300 --> 01:29:40,100
I'm sorry the Linker to recognize this as the entry point, which means

1722
01:29:40,100 --> 01:29:41,300
that the endpoint has to match.

1723
01:29:41,300 --> 01:29:42,000
Exactly.

1724
01:29:42,500 --> 01:29:45,000
It has to be named the right thing, and it has to take the right

1725
01:29:46,300 --> 01:29:47,300
variables as well.

1726
01:29:47,800 --> 01:29:50,700
So now we have to figure out how exactly were going to do that and

1727
01:29:50,700 --> 01:29:52,100
there's two parts to this.

1728
01:29:52,300 --> 01:29:52,600
So, the

1729
01:29:52,800 --> 01:29:56,600
first part is again you know lining up the thing correctly, but the

1730
01:29:56,600 --> 01:29:59,600
other part is which thing it's actually looking for so on Windows

1731
01:29:59,600 --> 01:29:59,800
there's

1732
01:30:00,000 --> 01:30:07,600
Two separate ways that it might look for the startup of the start of

1733
01:30:07,600 --> 01:30:08,000
the code.

1734
01:30:08,800 --> 01:30:12,200
The first way is, if you're trying to build an actual Windows

1735
01:30:12,200 --> 01:30:16,000
application, where it actually opens windows and stuff like this, the

1736
01:30:16,000 --> 01:30:20,000
second way is if you're building a console application and the Linker

1737
01:30:20,000 --> 01:30:24,300
actually has to specify, which of these two things you're doing in the

1738
01:30:24,300 --> 01:30:28,100
actual executable itself, and windows will load them differently,

1739
01:30:28,100 --> 01:30:29,800
based on which one you specify.

1740
01:30:30,900 --> 01:30:34,100
This is why I don't know if you've ever noticed this, this is a common

1741
01:30:34,100 --> 01:30:36,700
complaint of programmers and Microsoft has never fixed it to the semi

1742
01:30:36,700 --> 01:30:38,500
knowledge unless they finally did in Windows 10.

1743
01:30:38,500 --> 01:30:44,100
I don't know, I'm not familiar, very familiar with Windows 10, but at

1744
01:30:44,100 --> 01:30:45,400
least up through Windows 7.

1745
01:30:46,800 --> 01:30:51,500
There is no way to make an application, which when launched from an

1746
01:30:51,500 --> 01:30:57,900
icon in Windows in regular in the shell in the graphical user

1747
01:30:57,900 --> 01:30:59,900
interface does not pop

1748
01:31:00,000 --> 01:31:01,400
Up a console window.

1749
01:31:02,700 --> 01:31:08,000
And also, when run from a console window is able to Output text to

1750
01:31:08,000 --> 01:31:10,000
that console window via standard out.

1751
01:31:10,300 --> 01:31:11,500
There is no way to do it.

1752
01:31:11,500 --> 01:31:16,300
The reason is because this actually occurs in the actual executable as

1753
01:31:16,300 --> 01:31:19,200
a thing that windows will do differently depending on which one you

1754
01:31:19,200 --> 01:31:22,900
have, if you specify that, you are a console application, then when

1755
01:31:22,900 --> 01:31:26,100
you are run from the gooey, you will get a console window.

1756
01:31:26,100 --> 01:31:31,300
It will create one and you'll have it if you don't specify that and

1757
01:31:31,300 --> 01:31:32,300
your run from the console.

1758
01:31:32,500 --> 01:31:35,200
Will not get standard out, and there's nothing you can do about it.

1759
01:31:35,200 --> 01:31:37,900
So, people have tried to fake it by like, oh, finding your console

1760
01:31:37,900 --> 01:31:39,000
window and hiding it.

1761
01:31:39,000 --> 01:31:41,600
So you don't ever see the fact that it got created in stuff like this.

1762
01:31:41,800 --> 01:31:44,500
So they try to look approximate it, but there is no way to really do

1763
01:31:44,500 --> 01:31:45,000
it for real.

1764
01:31:45,000 --> 01:31:45,700
Unfortunately.

1765
01:31:46,300 --> 01:31:49,200
All right, so moving on from that.

1766
01:31:49,300 --> 01:31:50,100
How is that?

1767
01:31:50,400 --> 01:31:51,500
How is that specified?

1768
01:31:51,500 --> 01:31:51,900
Right?

1769
01:31:52,000 --> 01:31:54,200
What kind of these two, which of these two things?

1770
01:31:54,200 --> 01:31:55,100
Are we going to have?

1771
01:31:55,600 --> 01:31:59,400
Well, there's basically a thing called subsystem it's a switch to the

1772
01:31:59,400 --> 01:32:02,300
Linker and it tells the it what to put in the

1773
01:32:02,400 --> 01:32:04,100
executable to make that happen.

1774
01:32:04,100 --> 01:32:07,300
So you can see right here, here's the subsystems that are supported.

1775
01:32:07,400 --> 01:32:10,400
In our case, we only care about the ones for app level stuff, which is

1776
01:32:10,400 --> 01:32:13,700
console Windows, potentially, posix, we don't care about things like

1777
01:32:13,700 --> 01:32:17,200
EFI applications or boot applications things that are specific to

1778
01:32:17,200 --> 01:32:18,000
Hardware stuff.

1779
01:32:18,600 --> 01:32:20,700
And in our case, we could do windows or console

1780
01:32:22,000 --> 01:32:25,300
So what we could do here is say, well, you know, subsystem maybe is

1781
01:32:25,300 --> 01:32:26,700
Windows, right?

1782
01:32:27,200 --> 01:32:29,100
Maybe we want to make a regular Windows application.

1783
01:32:29,100 --> 01:32:31,100
Let's say that's what handmade hero does.

1784
01:32:31,600 --> 01:32:34,300
And so, let's see what happens when we when we do a build and what you

1785
01:32:34,300 --> 01:32:37,400
can see, is it now thinks that there's an unresolved external symbol

1786
01:32:37,400 --> 01:32:39,400
wind main CRT startup, right?

1787
01:32:39,500 --> 01:32:40,800
That's what it's looking for.

1788
01:32:40,800 --> 01:32:43,900
If we tell it, that's the subsystem if I switch the subsystem to

1789
01:32:43,900 --> 01:32:47,500
console now, it's actually works, right?

1790
01:32:47,500 --> 01:32:48,800
Why does it actually work?

1791
01:32:48,800 --> 01:32:51,100
Well, it actually works because now he knows

1792
01:32:51,200 --> 01:32:54,100
Knows what the default entry point should be.

1793
01:32:54,600 --> 01:32:57,400
And that default entry point is main crtc start-up.

1794
01:32:57,400 --> 01:32:59,400
If we hadn't have defined this,

1795
01:33:00,000 --> 01:33:00,400
Right.

1796
01:33:00,800 --> 01:33:04,800
It would complain about that instead so we need that subsystem line in

1797
01:33:04,800 --> 01:33:07,800
there to tell it which sort of startup code we wanted right.

1798
01:33:07,800 --> 01:33:09,800
Which kind of executable to Mark us as

1799
01:33:11,600 --> 01:33:15,100
And then we need to define the corresponding startup, but now that

1800
01:33:15,100 --> 01:33:18,800
we've defined all of that, we will actually get a working executable

1801
01:33:18,800 --> 01:33:20,700
and lo and behold are working.

1802
01:33:20,700 --> 01:33:27,000
Executable is now 1/40, the size that it was when it was shoving, the

1803
01:33:27,000 --> 01:33:29,700
C runtime library in that we didn't want.

1804
01:33:29,700 --> 01:33:32,900
And if we now look at what this looks like,

1805
01:33:35,000 --> 01:33:38,500
Under dis as mmm, it's quite proper, right?

1806
01:33:38,500 --> 01:33:42,200
You can see here, that this is our entire executable.

1807
01:33:42,200 --> 01:33:46,700
The, this is the, the entire package, the entire executable package of

1808
01:33:46,700 --> 01:33:50,900
it, you can see here that we've got three separate sort of functions

1809
01:33:50,900 --> 01:33:51,600
if you will.

1810
01:33:54,200 --> 01:33:59,800
And I want to kind of put these side by side so you can see how they

1811
01:33:59,800 --> 01:34:02,300
work and how that translation occurred.

1812
01:34:02,300 --> 01:34:03,400
So, what I'm going to do is I'm going to

1813
01:34:03,600 --> 01:34:05,100
Dump in our executable.

1814
01:34:05,600 --> 01:34:10,000
I'm going to dump in that executable out to Maine.

1815
01:34:10,100 --> 01:34:12,800
Exe dot as mm.

1816
01:34:13,500 --> 01:34:16,500
And then I'm going to dump our obj's.

1817
01:34:16,600 --> 01:34:21,800
So our main, our main obj, I'm going to just ask them that out and

1818
01:34:21,800 --> 01:34:25,900
then I'm going to also do our other translation unit out as well.

1819
01:34:26,000 --> 01:34:29,000
So here is the main three obj dot as mm.

1820
01:34:29,000 --> 01:34:29,500
Okay.

1821
01:34:30,100 --> 01:34:32,900
And so now what I'm going to do is I'm going to load those up so you

1822
01:34:32,900 --> 01:34:33,400
can see them.

1823
01:34:33,500 --> 01:34:33,700
M.

1824
01:34:34,100 --> 01:34:36,700
So cure I'm going to load, just me.

1825
01:34:38,700 --> 01:34:41,100
Here I'm going to load in all of those as in files.

1826
01:34:41,500 --> 01:34:45,700
So here is the executables as I'm file and you can see again this is

1827
01:34:45,700 --> 01:34:47,400
all of the information here.

1828
01:34:47,400 --> 01:34:49,200
That's the all of the code that's in there.

1829
01:34:49,800 --> 01:34:53,800
And then I'm going to load in here, the main obj dot, add some file,

1830
01:34:53,800 --> 01:34:57,700
and you know, here it is, right, and we'll look at that and then I'm

1831
01:34:57,700 --> 01:35:00,400
also going to load in that main 30 be treated as mmm.

1832
01:35:01,000 --> 01:35:04,000
So let's start with bar right here.

1833
01:35:04,000 --> 01:35:08,100
You can see the code for bar, and it's pretty obvious where this ended

1834
01:35:08,100 --> 01:35:08,600
up in our executable.

1835
01:35:08,600 --> 01:35:11,900
So, if we take a look down here, you can see that this code is pretty

1836
01:35:11,900 --> 01:35:13,600
much occurs verbatim, right?

1837
01:35:13,600 --> 01:35:14,900
Here's the RS.

1838
01:35:14,900 --> 01:35:15,600
P, + 8.

1839
01:35:15,600 --> 01:35:18,600
Here's the RSP 18h, right?

1840
01:35:18,600 --> 01:35:21,100
Here's the to RSP 20 HS.

1841
01:35:21,100 --> 01:35:25,500
Here's the d word pointer part, here's the eax, here's the RSV change,

1842
01:35:25,500 --> 01:35:26,100
here's the red.

1843
01:35:26,100 --> 01:35:28,100
Now that code exists verbatim.

1844
01:35:28,100 --> 01:35:29,800
Now why does that code exists for Batum?

1845
01:35:29,800 --> 01:35:30,800
Again, it

1846
01:35:31,100 --> 01:35:33,000
No, unresolved symbols.

1847
01:35:33,300 --> 01:35:37,400
So the only thing the Linker had to do when it saw this code, it just

1848
01:35:37,400 --> 01:35:41,600
had to find a place to put it in the executable, and cure is where it

1849
01:35:41,600 --> 01:35:42,100
put it, right?

1850
01:35:42,100 --> 01:35:48,700
So this is in our executable where it's stuck, the actual code, right?

1851
01:35:49,600 --> 01:35:50,500
That's just where to put it.

1852
01:35:50,900 --> 01:35:54,300
So now let's flip over to main, which has the rest of our azzam and

1853
01:35:54,300 --> 01:35:55,600
take a look at what happened there.

1854
01:35:56,000 --> 01:35:59,400
Here's our main CRT startup, we start up with an RSP 20.

1855
01:36:00,000 --> 01:36:02,300
Uh, you can see that that code is right here.

1856
01:36:02,300 --> 01:36:03,600
And now here's where things start to get.

1857
01:36:03,600 --> 01:36:07,800
Interesting, notice what happened to the call here is the call, right?

1858
01:36:07,900 --> 01:36:10,400
This is an instructor, this is an instruction of the processor to

1859
01:36:10,400 --> 01:36:15,600
Branch a way to separate piece of the code to execute it, and then,

1860
01:36:15,600 --> 01:36:16,300
come back.

1861
01:36:17,600 --> 01:36:19,100
This call is called the question.

1862
01:36:19,100 --> 01:36:19,400
Mark.

1863
01:36:19,400 --> 01:36:20,500
Fouad at why?

1864
01:36:20,500 --> 01:36:23,300
A h at Z, right?

1865
01:36:23,500 --> 01:36:26,300
And remember that is this code up here, right?

1866
01:36:26,300 --> 01:36:28,600
That is what that code is, right?

1867
01:36:28,600 --> 01:36:29,800
It's calling this code.

1868
01:36:30,700 --> 01:36:35,100
So it is going to have to put that code into the executable somewhere

1869
01:36:36,000 --> 01:36:39,700
and you can see that it did exactly that it put that code right here.

1870
01:36:40,200 --> 01:36:44,300
And so when the Linker smushed, these together and put the executable

1871
01:36:44,700 --> 01:36:47,200
together into one piece, you can see what it did is it.

1872
01:36:47,400 --> 01:36:52,100
Placed this symbol name, which is not useful to the processor because

1873
01:36:52,300 --> 01:36:54,900
CPUs have no idea what symbols are, they don't care.

1874
01:36:55,100 --> 01:36:58,600
They just want to see addresses it provided the address in the

1875
01:36:58,600 --> 01:37:02,800
executable where that code could be found and that is where this code

1876
01:37:02,800 --> 01:37:03,400
went.

1877
01:37:03,400 --> 01:37:07,900
You can also see that when this code wanted to call bar again a symbol

1878
01:37:07,900 --> 01:37:11,300
that was not known at the time of compilation, it replaced it with the

1879
01:37:11,300 --> 01:37:16,200
address of the of the code that was in a different compilation unit.

1880
01:37:16,200 --> 01:37:16,800
Remember,

1881
01:37:17,500 --> 01:37:18,300
Which is right here.

1882
01:37:19,100 --> 01:37:19,500
Okay.

1883
01:37:21,400 --> 01:37:25,700
So hopefully now you can see the complete process of assembly that

1884
01:37:25,700 --> 01:37:29,600
goes from compilation where you take translation units which are some

1885
01:37:29,600 --> 01:37:31,300
collection of files as matter what they are.

1886
01:37:31,400 --> 01:37:35,100
Some collection of files that can be interpreted as C code or C++ code

1887
01:37:35,700 --> 01:37:38,000
go from that source code to an obj file.

1888
01:37:38,100 --> 01:37:41,000
This is what an obj file looks like it's object code.

1889
01:37:41,300 --> 01:37:45,100
It's basically like machine machine instructions, where a bunch of

1890
01:37:45,100 --> 01:37:47,900
things have been left undetermined and just have names and their

1891
01:37:47,900 --> 01:37:49,300
places, right?

1892
01:37:49,700 --> 01:37:50,700
If then all of those

1893
01:37:50,900 --> 01:37:54,700
Is object files, are then synthesize together to produce a single

1894
01:37:54,700 --> 01:37:57,500
executable, which can be loaded by the operating system that

1895
01:37:57,500 --> 01:38:01,900
executable has all of the addresses resolved internally, right?

1896
01:38:03,300 --> 01:38:07,000
Okay, so hopefully everyone is comfortable with what's happening

1897
01:38:07,200 --> 01:38:07,700
there.

1898
01:38:08,600 --> 01:38:09,500
Now, there's a bunch of stuff in here.

1899
01:38:09,500 --> 01:38:11,100
That you probably don't understand very well.

1900
01:38:11,100 --> 01:38:13,500
All of this Preamble code and stuff.

1901
01:38:13,500 --> 01:38:16,400
Like this is maybe very unfamiliar to you because you don't program

1902
01:38:16,400 --> 01:38:16,900
Assembly Language.

1903
01:38:16,900 --> 01:38:17,800
You don't know what it is.

1904
01:38:18,100 --> 01:38:20,900
Hey no surprise there, I don't program in Assembly Language either.

1905
01:38:21,500 --> 01:38:25,000
So you know again it's definitely not the sort of thing that we're

1906
01:38:25,000 --> 01:38:28,200
used to reading but we're going to have to get a little bit more

1907
01:38:28,200 --> 01:38:31,000
familiar with it to complete the cycle here, hopefully everyone's on

1908
01:38:31,000 --> 01:38:33,000
board with the so far, hopefully nothing that I've said.

1909
01:38:33,100 --> 01:38:34,600
Ed so far is super mysterious.

1910
01:38:34,600 --> 01:38:37,600
Now that we've gone through every step of the process, you can see how

1911
01:38:37,600 --> 01:38:41,800
compilation goes from text files, on your hard drive to object code to

1912
01:38:41,800 --> 01:38:42,600
an executable.

1913
01:38:43,000 --> 01:38:45,200
Now, we just have to talk about what actually happens when the

1914
01:38:45,200 --> 01:38:48,900
executables actually run and how it might be partitioned into multiple

1915
01:38:48,900 --> 01:38:51,700
pieces that can get dynamically linked, so that we can finish

1916
01:38:51,700 --> 01:38:55,400
answering the questions posed by the email that I originally received

1917
01:38:55,500 --> 01:38:55,900
again.

1918
01:38:56,000 --> 01:38:59,700
Most of those questions we can now answer that we actually have

1919
01:39:00,100 --> 01:39:04,100
Look at exactly what's happening in the code and understand literally.

1920
01:39:04,100 --> 01:39:04,900
What's going on?

1921
01:39:05,000 --> 01:39:09,300
Not in some figurative, kind of language way, that is detached from

1922
01:39:09,300 --> 01:39:09,700
reality.

1923
01:39:09,700 --> 01:39:12,000
We can actually look at the reality of what's happening in the

1924
01:39:12,000 --> 01:39:12,600
processor.

1925
01:39:13,000 --> 01:39:13,400
Okay.

1926
01:39:15,300 --> 01:39:17,800
So now let's get to function pointers.

1927
01:39:18,800 --> 01:39:22,700
Right, let's get to actual function pointers because that is the place

1928
01:39:22,700 --> 01:39:25,700
that we kind of started this discussion, from where we, what we want

1929
01:39:25,700 --> 01:39:29,300
to discuss and all of this stuff was kind of necessary to discuss

1930
01:39:29,300 --> 01:39:29,900
those things.

1931
01:39:30,200 --> 01:39:34,900
We have two separate ways that we need to talk about function pointers

1932
01:39:35,400 --> 01:39:39,900
because one of them is completely Dynamic and one of them is slightly

1933
01:39:39,900 --> 01:39:41,000
less, so right?

1934
01:39:42,000 --> 01:39:44,900
And so we need to talk about those in a little bit more detail.

1935
01:39:46,200 --> 01:39:49,100
The first thing we need to talk about is just function pointers inside

1936
01:39:49,100 --> 01:39:52,500
regular code and that's the one we'll do first because the easiest to

1937
01:39:52,500 --> 01:39:55,100
talk about because we don't need to start involving windows in our

1938
01:39:55,100 --> 01:39:55,600
business.

1939
01:39:56,100 --> 01:39:59,200
The second one is the one that's a little more advanced which is what

1940
01:39:59,200 --> 01:40:02,400
happens when we're actually dealing with multiple executable.

1941
01:40:02,900 --> 01:40:09,200
Sort of entities like xzs dlls Windows system, libraries itself, those

1942
01:40:09,200 --> 01:40:09,700
are two things.

1943
01:40:09,800 --> 01:40:13,400
What happens at that point, when we're talking about different

1944
01:40:13,400 --> 01:40:15,800
executable modules, essentially calling each other run,

1945
01:40:16,300 --> 01:40:17,200
What's happening there?

1946
01:40:17,900 --> 01:40:19,700
So, let's leave that for the second part of the inquiry.

1947
01:40:19,700 --> 01:40:22,700
And we'll just focus on what happens in an individual program.

1948
01:40:23,000 --> 01:40:27,400
What goes on when we are actually calling functions right by pointer.

1949
01:40:28,700 --> 01:40:31,600
Okay, so hopefully, this point, everyone is comfortable with what

1950
01:40:31,600 --> 01:40:32,900
happens when you call things.

1951
01:40:33,000 --> 01:40:35,200
Not by a function pointer, right?

1952
01:40:35,300 --> 01:40:40,000
When you're just calling things by a function name in see, you have

1953
01:40:40,000 --> 01:40:41,900
seen exactly what happens.

1954
01:40:41,900 --> 01:40:43,200
So there is no mystery anymore.

1955
01:40:43,700 --> 01:40:45,600
It just puts the symbol into the

1956
01:40:45,900 --> 01:40:46,300
It file.

1957
01:40:46,300 --> 01:40:49,300
And then later the Linker resolves, that symbol to it hard coded

1958
01:40:49,300 --> 01:40:49,800
address.

1959
01:40:49,900 --> 01:40:52,400
That is related to where it is in the executable.

1960
01:40:52,500 --> 01:40:56,000
Now, there is a little bit of hand waving there because when that

1961
01:40:56,000 --> 01:41:00,300
executable is loaded into memory, this address is relative to where

1962
01:41:00,300 --> 01:41:02,000
the executable was loaded.

1963
01:41:02,000 --> 01:41:05,900
So it is worth noting that there is a little bit of fun there.

1964
01:41:06,100 --> 01:41:10,800
Where either the processor itself has to have the understanding of a

1965
01:41:10,800 --> 01:41:15,200
relative call where when you load in an executable you can call

1966
01:41:15,200 --> 01:41:15,800
relative to

1967
01:41:16,000 --> 01:41:16,600
Location.

1968
01:41:16,700 --> 01:41:20,400
So, it doesn't matter where in memory, you loaded it or the executable

1969
01:41:20,400 --> 01:41:22,800
has to always be loaded in a known Base address.

1970
01:41:23,000 --> 01:41:26,900
So that the hard coded addresses are the actual addresses that are in

1971
01:41:26,900 --> 01:41:32,700
memory, or when the executable is loaded, it has to patch the call

1972
01:41:32,700 --> 01:41:33,300
sites.

1973
01:41:33,700 --> 01:41:37,900
So that all of the call sites that are absolute are shifted based on

1974
01:41:37,900 --> 01:41:40,100
the loaded Base address of the executable.

1975
01:41:40,200 --> 01:41:42,000
And that requires a fix-up table.

1976
01:41:42,000 --> 01:41:44,800
That requires that, the executable having a fix-up table that says,

1977
01:41:44,800 --> 01:41:45,500
well, they all are

1978
01:41:45,900 --> 01:41:46,300
Right?

1979
01:41:46,400 --> 01:41:49,800
So there is actually a step that you have to consider that is about

1980
01:41:49,800 --> 01:41:52,400
how those addresses are translated into actual memory, addresses

1981
01:41:52,400 --> 01:41:52,900
later.

1982
01:41:53,100 --> 01:41:55,300
But you can understand how there's many ways that that could be

1983
01:41:55,300 --> 01:41:57,900
approached depending on the option and that's operating system and CPU

1984
01:41:57,900 --> 01:41:59,800
dependent, how those will work.

1985
01:42:00,100 --> 01:42:00,600
Right?

1986
01:42:01,200 --> 01:42:02,800
But you can understand the compilation process.

1987
01:42:02,800 --> 01:42:06,300
Now pointers are taken out of the equation to a certain extent and

1988
01:42:06,300 --> 01:42:09,000
we're literally hard-coding addresses, or we just like this is the

1989
01:42:09,000 --> 01:42:10,400
location to jump to.

1990
01:42:10,400 --> 01:42:12,500
Now, write for this call.

1991
01:42:13,500 --> 01:42:19,300
So what happens we want to investigate now is what happens in code

1992
01:42:19,300 --> 01:42:25,000
when we stop talking about jump to a specific function and we start

1993
01:42:25,000 --> 01:42:29,300
talking about a jump to a pointer which could be pointing to, to any

1994
01:42:30,000 --> 01:42:31,500
you know, number of functions potentially

1995
01:42:34,400 --> 01:42:35,700
So, let's get started.

1996
01:42:38,100 --> 01:42:41,000
Going back to actually I guess I'm reading my text editor.

1997
01:42:41,300 --> 01:42:42,200
I'm used to seeing this.

1998
01:42:42,200 --> 01:42:43,400
I'm in the bunker must be in the bunker.

1999
01:42:43,500 --> 01:42:44,300
No, you're not mad about her.

2000
01:42:44,300 --> 01:42:46,100
You're looking at this as in files.

2001
01:42:47,200 --> 01:42:53,600
So if I come back here to my main.cpp, my translation unit here, what

2002
01:42:53,600 --> 01:42:56,900
I want to do now is I want to start looking at the potential for what

2003
01:42:56,900 --> 01:42:58,200
I can do with function pointers.

2004
01:42:59,800 --> 01:43:00,300
Right.

2005
01:43:01,200 --> 01:43:04,300
And so what I want to do is I want to have the ability to call more

2006
01:43:04,300 --> 01:43:07,300
than one function or something like this and so I want to start

2007
01:43:07,300 --> 01:43:12,500
talking about how do I, how do I what happens in the compiler when I

2008
01:43:12,500 --> 01:43:13,600
have these function pointers?

2009
01:43:13,900 --> 01:43:16,700
So the first thing I need to do is be able to take the address of a

2010
01:43:16,700 --> 01:43:17,000
function.

2011
01:43:17,000 --> 01:43:19,200
But you know what, I don't really even need to do very much to do

2012
01:43:19,200 --> 01:43:19,900
that, right?

2013
01:43:20,000 --> 01:43:24,800
If I want to, I could say, let's create a void Star, right?

2014
01:43:25,400 --> 01:43:27,200
Because here, I got my call to fou, right?

2015
01:43:27,400 --> 01:43:29,500
Let's create a void star, I'm going to call that.

2016
01:43:29,600 --> 01:43:31,900
Star function pointer, right?

2017
01:43:32,300 --> 01:43:36,000
And I'm going to take as the value of function pointer, I'm just going

2018
01:43:36,000 --> 01:43:38,000
to take food, right?

2019
01:43:38,000 --> 01:43:40,000
That's what I'm going to do and I want to compile it.

2020
01:43:40,500 --> 01:43:43,900
Now what you'll notice is that actually worked right.

2021
01:43:43,900 --> 01:43:45,500
There was no errors involved there.

2022
01:43:45,700 --> 01:43:48,900
That actually worked and if I want to, I can take a look at what the

2023
01:43:48,900 --> 01:43:51,100
disassembly is of that particular.

2024
01:43:52,600 --> 01:43:53,000
Module.

2025
01:43:53,000 --> 01:43:57,900
Now here it is and what you can see happening is literally that exact

2026
01:43:57,900 --> 01:44:03,500
same that exact operation is occurring, right?

2027
01:44:03,600 --> 01:44:05,600
So let's take a look at what's going on here.

2028
01:44:05,700 --> 01:44:07,600
Here is the call to Foo, right?

2029
01:44:07,600 --> 01:44:10,600
And what you'll notice, is that call to Foo is using the symbol,

2030
01:44:11,100 --> 01:44:12,100
remember, right?

2031
01:44:12,100 --> 01:44:14,500
The it's, it doesn't know where that is yet.

2032
01:44:15,200 --> 01:44:17,400
It's using the symbol for food.

2033
01:44:18,500 --> 01:44:22,000
Now, granted when I say it doesn't know where that is, yet it does

2034
01:44:22,000 --> 01:44:22,200
know.

2035
01:44:22,400 --> 01:44:24,400
Out food because through is defined in this translation unit.

2036
01:44:24,500 --> 01:44:27,700
What it doesn't know is where the Linker it's going to put Foo right

2037
01:44:27,700 --> 01:44:30,300
because the linkers allowed to move this around and put it anywhere it

2038
01:44:30,300 --> 01:44:31,500
wants in the ending executable.

2039
01:44:31,600 --> 01:44:34,300
So it can't put in a hard coded address here because it doesn't know

2040
01:44:34,300 --> 01:44:35,800
where it's going to put it, right?

2041
01:44:36,200 --> 01:44:39,000
So it just puts in the symbol and says, hey when you mr.

2042
01:44:39,000 --> 01:44:42,600
Linker, when you decide where you're going to put Foo, you know, go

2043
01:44:42,600 --> 01:44:46,800
ahead and and patching that address here because I need to call it

2044
01:44:46,800 --> 01:44:47,200
right.

2045
01:44:47,700 --> 01:44:51,000
What you can see happening immediately after that is the the leaa

2046
01:44:51,000 --> 01:44:52,200
instruction which is a load-bearing

2047
01:44:52,300 --> 01:44:54,800
Basically is going to move to our ax.

2048
01:44:54,800 --> 01:44:58,400
There's a register in the processor, it's going to move in the that

2049
01:44:58,400 --> 01:44:59,600
same address.

2050
01:45:00,200 --> 01:45:01,700
Exactly where it was going to call.

2051
01:45:01,700 --> 01:45:05,600
It's going to move in that address to our ax, right?

2052
01:45:05,600 --> 01:45:06,800
Ed minutes, going to store.

2053
01:45:06,800 --> 01:45:09,000
It's going to turn around and store that to RS b.

2054
01:45:09,000 --> 01:45:09,800
+ 20 H.

2055
01:45:09,800 --> 01:45:11,600
Now RSP is the stack pointer.

2056
01:45:11,800 --> 01:45:17,400
So RFP plus 20 H is just the location of this function pointer Star,

2057
01:45:17,400 --> 01:45:17,900
right?

2058
01:45:17,900 --> 01:45:21,300
This it doesn't appear in here by name because it's a symbol that

2059
01:45:21,300 --> 01:45:22,900
nobody is referring to.

2060
01:45:23,100 --> 01:45:23,600
Right.

2061
01:45:24,300 --> 01:45:27,700
The compiler in general doesn't output names to the Linker, that would

2062
01:45:27,700 --> 01:45:28,700
just be extraneous.

2063
01:45:28,800 --> 01:45:29,800
So if nobody ever

2064
01:45:30,000 --> 01:45:32,300
Needs to refer to function pointer outside.

2065
01:45:32,300 --> 01:45:35,400
The scope of the function, that's being compiled, they don't get

2066
01:45:35,400 --> 01:45:38,400
names, they'll in the debug information, they'll get names because the

2067
01:45:38,400 --> 01:45:40,500
debugger needs to be able to inspect, by those names.

2068
01:45:40,800 --> 01:45:43,500
But the Linker doesn't need to see any of that other than in the debug

2069
01:45:43,500 --> 01:45:44,200
info, right?

2070
01:45:44,200 --> 01:45:45,700
So that's just not placed in there.

2071
01:45:46,200 --> 01:45:49,400
Now, what we could see though is, if we moved this function out to a

2072
01:45:49,400 --> 01:45:52,400
global variable, now, it does have a name

2073
01:45:53,600 --> 01:45:54,000
Right.

2074
01:45:54,000 --> 01:45:57,300
It does have a name because people can refer to that Global variable,

2075
01:45:57,400 --> 01:45:57,900
right?

2076
01:45:58,100 --> 01:45:59,800
If I was to do that now,

2077
01:46:01,500 --> 01:46:03,500
And I may need to decorate that a little bit to make sure, but I don't

2078
01:46:03,500 --> 01:46:03,800
think so.

2079
01:46:03,800 --> 01:46:04,100
Yeah.

2080
01:46:04,600 --> 01:46:07,400
If we would do that now, it becomes even more explicit.

2081
01:46:07,400 --> 01:46:08,800
Now you can see what it's saying to.

2082
01:46:08,800 --> 01:46:11,900
The Linker is, hey, call this function Foo, I don't know where it's

2083
01:46:11,900 --> 01:46:12,500
going to end up.

2084
01:46:12,500 --> 01:46:14,800
Just make sure wherever you put it, you're going to tell me what the

2085
01:46:14,800 --> 01:46:15,400
address is.

2086
01:46:16,000 --> 01:46:18,800
Okay, that's this line here, right?

2087
01:46:19,300 --> 01:46:22,600
Then I've got okay go load that address, you know what put that in a

2088
01:46:22,600 --> 01:46:25,100
register then store the contents of that.

2089
01:46:25,100 --> 01:46:25,700
So whatever.

2090
01:46:25,800 --> 01:46:29,100
Whatever this address is this now in our ax store that out to This

2091
01:46:29,100 --> 01:46:31,100
Global variable function pointer blah blah blah.

2092
01:46:31,300 --> 01:46:31,700
Right?

2093
01:46:32,300 --> 01:46:35,300
I don't know where that's going to be because again, the linkers free

2094
01:46:35,300 --> 01:46:38,300
to decide where the global variables go, when it's defining the sort

2095
01:46:38,300 --> 01:46:42,000
of the layout of the running executable, but wherever that's going to

2096
01:46:42,000 --> 01:46:44,600
be, that's where you need to put it, right.

2097
01:46:44,600 --> 01:46:50,800
So you can see Now function pointers in this initial sense are no

2098
01:46:50,800 --> 01:46:53,800
different than any other pointer in this initial sense.

2099
01:46:54,200 --> 01:46:59,500
All that's going to happen when you refer to a function by its name in

2100
01:46:59,500 --> 01:47:01,000
a context where it

2101
01:47:01,200 --> 01:47:02,400
Needs to know that address.

2102
01:47:02,400 --> 01:47:05,400
As if it was a pointer is you will literally just get the pointer.

2103
01:47:05,400 --> 01:47:08,400
It's just a pointer like any other pointer, right?

2104
01:47:09,500 --> 01:47:13,500
It points to some memory that memory happens to be in the mapped

2105
01:47:13,500 --> 01:47:18,200
memory where the executable code itself, resides and off you go,

2106
01:47:18,900 --> 01:47:19,400
right?

2107
01:47:20,000 --> 01:47:22,000
So that is exactly what will happen in this case.

2108
01:47:22,000 --> 01:47:27,000
And so in that way, a function pointer is no different than any other

2109
01:47:27,000 --> 01:47:27,300
pointer.

2110
01:47:27,300 --> 01:47:28,700
It's the same as a tent pointer.

2111
01:47:28,700 --> 01:47:31,100
It's the same as anything else and one of the things that

2112
01:47:31,300 --> 01:47:34,600
The person who wrote the email referred to was the fact that it was

2113
01:47:34,600 --> 01:47:35,200
confusing.

2114
01:47:35,200 --> 01:47:39,600
When you look in the debugger, he found that he was not actually able

2115
01:47:39,600 --> 01:47:42,100
to inspect the value of the function pointer.

2116
01:47:42,100 --> 01:47:46,000
And in that way, it was different, that integer that is strictly a

2117
01:47:46,400 --> 01:47:51,200
function of the fact that the debugger is is not showing you.

2118
01:47:51,200 --> 01:47:51,900
It right.

2119
01:47:53,100 --> 01:47:54,600
Actually, you could do that.

2120
01:47:54,900 --> 01:47:58,500
You can dereference a function pointer and see what's actually there.

2121
01:47:59,200 --> 01:47:59,700
Let's

2122
01:48:00,000 --> 01:48:03,000
Ruben right, let's prove that it's no different.

2123
01:48:03,400 --> 01:48:07,100
Now, what I'm going to do is I'm going to load this code, okay?

2124
01:48:07,400 --> 01:48:10,100
And I need to do a little bit first because I'm we're going to need

2125
01:48:10,100 --> 01:48:10,800
debug info.

2126
01:48:10,800 --> 01:48:14,100
So I'm going to go here to build that bat and I'm going to try and get

2127
01:48:14,100 --> 01:48:15,100
some debug info here.

2128
01:48:15,100 --> 01:48:23,100
I believe /zi is the thing that would direct it to produce debug info

2129
01:48:23,100 --> 01:48:25,200
for us, but I'm not entirely sure.

2130
01:48:25,200 --> 01:48:26,900
So I'm just going to hope that that's the case.

2131
01:48:27,500 --> 01:48:29,200
Let's take a look at that mean to object.

2132
01:48:30,200 --> 01:48:32,000
Again, you can see this code.

2133
01:48:32,000 --> 01:48:33,200
Here is the main Dobbs.

2134
01:48:33,300 --> 01:48:38,300
I'm going to invoke developer Studio here on our main dot exe and hope

2135
01:48:38,300 --> 01:48:40,400
that I have some debug information again.

2136
01:48:40,400 --> 01:48:43,100
I don't know that I do, we'll see I might need to tell the Linker

2137
01:48:43,100 --> 01:48:47,100
about it so I don't actually have the debug of well you know what

2138
01:48:47,100 --> 01:48:47,500
though?

2139
01:48:48,700 --> 01:48:49,400
Why do we care?

2140
01:48:49,400 --> 01:48:50,300
We're looking at the assembly.

2141
01:48:50,300 --> 01:48:50,900
I don't even care.

2142
01:48:50,900 --> 01:48:52,800
I don't even need to preserve do again for a forget.

2143
01:48:52,800 --> 01:48:53,500
It doesn't matter.

2144
01:48:53,600 --> 01:48:54,400
It's not important.

2145
01:48:56,000 --> 01:48:59,400
Alright, so here we are at the start of our code.

2146
01:48:59,700 --> 01:49:00,400
I'm in the debugger.

2147
01:49:00,400 --> 01:49:02,800
We're at the start of our coat and by now, even though you probably

2148
01:49:02,800 --> 01:49:05,000
don't know, Assembly Language, maybe you have no idea what assembly

2149
01:49:05,000 --> 01:49:07,600
languages at all really, but you can sort of see from what I'm talking

2150
01:49:07,600 --> 01:49:08,000
about.

2151
01:49:08,100 --> 01:49:09,700
You, at least have the pattern matching.

2152
01:49:09,700 --> 01:49:12,200
As I think the person originally wrote in called it, you have the

2153
01:49:12,200 --> 01:49:13,800
patterns, you know, this is the code, right?

2154
01:49:13,800 --> 01:49:15,000
We're looking at it right here.

2155
01:49:15,000 --> 01:49:15,900
Here's a code.

2156
01:49:16,000 --> 01:49:17,900
Even though I have no idea what these things mean, I can see it's the

2157
01:49:17,900 --> 01:49:19,000
same code, right?

2158
01:49:19,100 --> 01:49:22,000
And the only difference is the place where food was actually talked

2159
01:49:22,000 --> 01:49:23,100
about, right?

2160
01:49:23,200 --> 01:49:23,800
It's here.

2161
01:49:23,800 --> 01:49:25,200
It is, right?

2162
01:49:25,800 --> 01:49:28,600
It's been inserted that address has been inserted in place of the

2163
01:49:28,600 --> 01:49:29,400
symbol Foo.

2164
01:49:29,600 --> 01:49:31,100
I've have the address, right?

2165
01:49:32,400 --> 01:49:34,100
And so what I want to sort of underscore here.

2166
01:49:34,100 --> 01:49:36,100
So a couple things we can look at that are pretty interesting.

2167
01:49:36,100 --> 01:49:37,200
Actually, let you know.

2168
01:49:37,200 --> 01:49:39,100
Let me make a brief digression here.

2169
01:49:39,400 --> 01:49:42,700
Just to point out here is my main dot exe and one of the things that

2170
01:49:42,700 --> 01:49:46,600
you'll notice about this mean dot exe is you can see that actually the

2171
01:49:46,600 --> 01:49:50,400
thing that I was talking about before that relative addressing is

2172
01:49:50,400 --> 01:49:53,200
kicking in here where it's been relocated.

2173
01:49:53,300 --> 01:49:58,800
You can see that the actual addresses where we have been loaded, are

2174
01:49:58,800 --> 01:50:01,300
not the addresses that were filled in here.

2175
01:50:02,500 --> 01:50:04,700
It's slightly different, right?

2176
01:50:04,700 --> 01:50:06,500
You can see, this is 13 FF.

2177
01:50:06,700 --> 01:50:09,200
It's not 1,400 or whatever, right?

2178
01:50:09,200 --> 01:50:10,600
It is not the same addresses.

2179
01:50:10,800 --> 01:50:14,300
Let's let's load this one more time, right?

2180
01:50:15,400 --> 01:50:18,300
Notice anything suspicious suspicious?

2181
01:50:19,000 --> 01:50:20,300
I'm going to load this many times.

2182
01:50:20,800 --> 01:50:22,900
You see what's happening here, right?

2183
01:50:23,200 --> 01:50:25,900
These addresses change every run of the program.

2184
01:50:26,100 --> 01:50:28,500
Why do these addresses change every run of the program?

2185
01:50:28,700 --> 01:50:32,400
Well, there's the thing in Windows address.

2186
01:50:32,400 --> 01:50:38,200
Space layout, randomization my zation.

2187
01:50:39,100 --> 01:50:39,600
There we go.

2188
01:50:40,100 --> 01:50:43,200
A SLR address space layout.

2189
01:50:43,200 --> 01:50:45,100
Randomization is a technique.

2190
01:50:45,500 --> 01:50:48,600
That is designed to try to improve Security on your computer

2191
01:50:48,900 --> 01:50:54,400
basically, by making sure that hackers can't know the locations of

2192
01:50:54,400 --> 01:50:57,500
things in executables when they are running.

2193
01:50:57,900 --> 01:50:59,800
So if you imagine what would happen,

2194
01:51:00,000 --> 01:51:00,600
Right?

2195
01:51:01,800 --> 01:51:05,300
And this is true of older all older operating systems for the most

2196
01:51:05,300 --> 01:51:10,100
part and, you know, then windows and a bunch of Linux and stuff.

2197
01:51:10,100 --> 01:51:11,800
They start implementing address space layout.

2198
01:51:11,800 --> 01:51:16,500
Randomization as a sort of exploit mitigation tool originally, it was

2199
01:51:16,500 --> 01:51:19,200
generally the case that most of the time, if you load an executable,

2200
01:51:19,200 --> 01:51:20,900
you were going to get it loading at the same place.

2201
01:51:20,900 --> 01:51:23,800
It always loads like an executable just loads at a particular location

2202
01:51:24,300 --> 01:51:27,200
and the actual might even have been optimized to load at that location

2203
01:51:27,200 --> 01:51:29,900
by having all of the addresses hard-coded into

2204
01:51:30,000 --> 01:51:31,200
It or something like this, right?

2205
01:51:31,200 --> 01:51:34,200
Without even a fix-up table to fix them or maybe all the call

2206
01:51:34,200 --> 01:51:35,400
instructions were relative.

2207
01:51:35,700 --> 01:51:37,600
So it didn't have to hard code addresses.

2208
01:51:37,800 --> 01:51:40,300
It just hard coded offsets and so at that point it was fine, who

2209
01:51:40,300 --> 01:51:41,300
knows, right?

2210
01:51:42,800 --> 01:51:46,800
Well, what ends up happening in here without us for space layout.

2211
01:51:46,800 --> 01:51:51,200
Randomization is every time Windows loads or executable it picks a new

2212
01:51:51,200 --> 01:51:52,700
location in memory to load it.

2213
01:51:52,700 --> 01:51:55,800
At, because remember, virtual memory is such that Windows pretty much

2214
01:51:55,800 --> 01:51:59,600
picks, your address range for you, it can just say Here's Where in the

2215
01:51:59,600 --> 01:52:02,300
virtual address space, your executable going to be loaded, you have

2216
01:52:02,300 --> 01:52:06,100
potentially no saying that so it can move it all around, right?

2217
01:52:06,300 --> 01:52:08,600
And so every time we run we get different addresses.

2218
01:52:08,800 --> 01:52:12,400
So really the only thing that we know is that the actual effective

2219
01:52:12,600 --> 01:52:16,400
Address of all of our functions will be filled in in all of the

2220
01:52:16,400 --> 01:52:20,800
places, either by patching or because they were relative, the

2221
01:52:20,800 --> 01:52:26,500
instructions were encoded to be relative calls, you know, this is like

2222
01:52:26,500 --> 01:52:30,200
I said some processors support relative branching of certain sizes.

2223
01:52:30,200 --> 01:52:31,300
Some don't, it has to have it.

2224
01:52:31,300 --> 01:52:34,500
Bubba Bubba, Bubba, regardless of what that mechanism is all we know

2225
01:52:34,500 --> 01:52:38,100
is that will actually get the address of wherever it is in this run of

2226
01:52:38,100 --> 01:52:41,300
the program that may not be the same location in every run of the

2227
01:52:41,300 --> 01:52:42,400
program because of address.

2228
01:52:42,500 --> 01:52:43,700
Space layout randomization.

2229
01:52:43,800 --> 01:52:44,200
Okay.

2230
01:52:45,500 --> 01:52:49,000
So what we can see here, when we're coming through, here is the code,

2231
01:52:49,000 --> 01:52:50,300
we know exactly what code that is.

2232
01:52:50,300 --> 01:52:51,800
Like I said, we it's kind of cool.

2233
01:52:51,800 --> 01:52:53,900
We don't need the debug information because we just know what code

2234
01:52:53,900 --> 01:52:54,700
we're looking at.

2235
01:52:54,900 --> 01:52:56,700
We're looking at this code right here, right?

2236
01:52:58,000 --> 01:53:02,100
And so, what we can see when we step through this code is the

2237
01:53:02,400 --> 01:53:04,900
processor is doing exactly what I said I was going to do it's taking

2238
01:53:04,900 --> 01:53:07,600
the address of the function Foo, right?

2239
01:53:07,600 --> 01:53:10,700
Which has been filled in in this place right here and you can see it

2240
01:53:11,100 --> 01:53:13,000
loading it into the are eax register.

2241
01:53:13,100 --> 01:53:16,700
If I look at the registers here's our ax, it's a 64-bit register.

2242
01:53:16,900 --> 01:53:19,800
It's going to load that in and lo and behold there is the address of

2243
01:53:19,800 --> 01:53:24,700
Foo right there, and now it's going to move it out to the stack at

2244
01:53:24,700 --> 01:53:25,500
this location, right?

2245
01:53:25,500 --> 01:53:27,300
It's going to move our X2, I'm sorry.

2246
01:53:27,500 --> 01:53:27,900
A stock.

2247
01:53:27,900 --> 01:53:31,000
It's going to move it to our Global variable, which is this right here

2248
01:53:31,200 --> 01:53:33,000
that remember, I switched it.

2249
01:53:33,200 --> 01:53:34,500
I almost forgot that I switched it.

2250
01:53:34,700 --> 01:53:35,000
Oops.

2251
01:53:37,300 --> 01:53:39,400
To This Global variable function pointer, right?

2252
01:53:39,800 --> 01:53:41,300
And so I'm going to go to go do that.

2253
01:53:41,300 --> 01:53:44,800
And so now at that memory location, there is now a pointer that's

2254
01:53:44,800 --> 01:53:46,700
holding that that address that RX address.

2255
01:53:47,000 --> 01:53:47,800
That's what's happening.

2256
01:53:47,900 --> 01:53:49,300
Right now.

2257
01:53:50,100 --> 01:53:56,000
What I wanted to show you is you were saying that oh this this pointer

2258
01:53:56,000 --> 01:53:59,500
seems different than in pointer that's strictly because the debugger

2259
01:54:00,000 --> 01:54:03,600
Know how to show you a function if you dereference an integer, it

2260
01:54:03,600 --> 01:54:07,200
knows how to show you the integer, the debugger for whatever reason in

2261
01:54:07,200 --> 01:54:10,400
the watch, window doesn't think to show you disassembly, that's what

2262
01:54:10,400 --> 01:54:11,400
it should do, right?

2263
01:54:11,400 --> 01:54:13,600
It should show you the instruction at that point, if you try to

2264
01:54:13,600 --> 01:54:16,100
dereference a function pointer, it should show you the function, the

2265
01:54:16,100 --> 01:54:18,500
first line of code potentially at that point, right?

2266
01:54:19,600 --> 01:54:21,600
But I can prove to you that they're still the same kind of function

2267
01:54:21,600 --> 01:54:23,500
pointer because let's see exactly what happens.

2268
01:54:23,700 --> 01:54:25,200
Here's the address, right?

2269
01:54:25,900 --> 01:54:27,100
This is the address right here.

2270
01:54:27,200 --> 01:54:29,400
I'm going to look in a memory window and I'm going to paste that

2271
01:54:29,400 --> 01:54:29,800
address in.

2272
01:54:30,000 --> 01:54:30,800
In right?

2273
01:54:31,100 --> 01:54:31,900
And here we go.

2274
01:54:32,400 --> 01:54:34,300
This is I'm sorry.

2275
01:54:34,800 --> 01:54:36,000
Paste pick the wrong one.

2276
01:54:36,900 --> 01:54:38,900
That's the address of our function pointer.

2277
01:54:39,400 --> 01:54:42,200
This is the actual address that was loaded into the function pointer

2278
01:54:42,200 --> 01:54:44,000
which is the one that we want to look at, right?

2279
01:54:46,400 --> 01:54:50,000
So this is where that function pointer is actually pointing, right?

2280
01:54:50,000 --> 01:54:50,900
It's pointing here.

2281
01:54:51,100 --> 01:54:54,800
And we know that this should be the contents of food, right?

2282
01:54:55,200 --> 01:54:58,600
And if we take a look back at our disassembly, where is our food?

2283
01:54:59,400 --> 01:54:59,800
Let's see.

2284
01:55:00,800 --> 01:55:02,700
Don't bend this as them.

2285
01:55:03,500 --> 01:55:05,900
It should be the one at the top there, but I just want to make sure

2286
01:55:05,900 --> 01:55:06,800
that we've got it.

2287
01:55:06,800 --> 01:55:07,300
Here it is.

2288
01:55:08,300 --> 01:55:11,200
This is this is what food is supposed to look like, right?

2289
01:55:11,400 --> 01:55:13,800
It's supposed to look like, you know, this instruction, this

2290
01:55:13,800 --> 01:55:15,600
instruction, this instruction, this instruction, right?

2291
01:55:15,600 --> 01:55:20,000
So is our pointer is our function pointer that, we just snapped.

2292
01:55:21,100 --> 01:55:22,300
Is it actually pointing to?

2293
01:55:22,300 --> 01:55:25,400
This is it pointing is it just pointing to this memory which is like I

2294
01:55:25,400 --> 01:55:27,100
said, it should be exactly like an integer pointer.

2295
01:55:27,200 --> 01:55:29,700
It should just be pointing at some memory and the contents of that

2296
01:55:29,700 --> 01:55:32,800
memory should be a bunch of bytes that encode the function.

2297
01:55:32,900 --> 01:55:34,400
Well, how would we know if that was the case?

2298
01:55:34,600 --> 01:55:38,400
Well, it just so happens that disassemblies helpfully include the code

2299
01:55:38,400 --> 01:55:39,200
B in the corner.

2300
01:55:39,400 --> 01:55:43,300
These are the B 8, 9 4, C 2408.

2301
01:55:43,300 --> 01:55:45,500
That encode, this move instruction.

2302
01:55:45,700 --> 01:55:47,700
That is the Intel x64.

2303
01:55:47,700 --> 01:55:50,300
Well, I guess it should say MDX is before us and say to find the exit

2304
01:55:50,300 --> 01:55:50,700
divorced and

2305
01:55:51,100 --> 01:55:53,600
But it's partially the x86 standard obviously there you know it's the

2306
01:55:53,600 --> 01:55:58,800
extended xa6 for x86 instruction set for 64-bit so it's AMD Intel you

2307
01:55:58,800 --> 01:56:02,700
might say those are the code B that correspond to this move

2308
01:56:02,700 --> 01:56:03,300
instruction.

2309
01:56:03,400 --> 01:56:06,900
These are the code B that correspond to this move instruction blah

2310
01:56:06,900 --> 01:56:07,600
blah blah blah.

2311
01:56:07,600 --> 01:56:12,400
All the way down to here where we haven't really encoded the B because

2312
01:56:12,400 --> 01:56:14,600
we don't know what we should put here.

2313
01:56:14,700 --> 01:56:18,300
We know what the symbol is, but we don't yet know what the bites are.

2314
01:56:18,300 --> 01:56:20,700
So we would expect them to differ right here.

2315
01:56:21,000 --> 01:56:25,300
Because instead of having a symbol fix up, what we would expect to see

2316
01:56:25,300 --> 01:56:26,900
here is the actual address.

2317
01:56:27,100 --> 01:56:28,700
So, is that what we have?

2318
01:56:30,900 --> 01:56:34,600
89 for a see 2408 894 su-24.

2319
01:56:34,600 --> 01:56:38,900
Alright, 483 EC3 84-88, right?

2320
01:56:38,900 --> 01:56:39,800
Blah, blah blah blah, blah.

2321
01:56:39,800 --> 01:56:45,300
All the way down to the 8bc 88, where are we a PC 8th, right?

2322
01:56:45,400 --> 01:56:49,900
And now instead of all zeros, what we expect to see is the actual

2323
01:56:49,900 --> 01:56:54,700
address of something to call and we do for B 0 0, 0, 0 8, I Bubba,

2324
01:56:54,700 --> 01:56:55,200
right,

2325
01:56:57,300 --> 01:56:59,800
So again, function pointer in.

2326
01:57:00,300 --> 01:57:03,900
As far as she is concerned is the same as any other pointer in terms

2327
01:57:03,900 --> 01:57:08,800
of what the processor is actually going to do with that piece of

2328
01:57:08,800 --> 01:57:12,000
memory write, whenever you're referring to a function pointer, it's

2329
01:57:12,000 --> 01:57:14,800
just a piece of memory that will store an address.

2330
01:57:14,800 --> 01:57:20,700
That address is the first bite of the code encoding in x64 machine,

2331
01:57:20,700 --> 01:57:23,600
code of the stuff to do, right?

2332
01:57:24,900 --> 01:57:25,500
And

2333
01:57:26,600 --> 01:57:31,800
we can even take this one step further just to make sure that that

2334
01:57:34,200 --> 01:57:35,800
let's just go nuts.

2335
01:57:35,800 --> 01:57:38,100
Just in case, you don't believe anything that I said and you can't

2336
01:57:38,100 --> 01:57:39,000
really tie it back.

2337
01:57:39,000 --> 01:57:40,800
If you're just like, I don't know what you're talking about.

2338
01:57:40,900 --> 01:57:43,200
Like I did, this is, I don't get it.

2339
01:57:43,200 --> 01:57:45,000
I just don't understand, right?

2340
01:57:46,600 --> 01:57:48,600
Let's just make this 100% explicit.

2341
01:57:48,600 --> 01:57:51,700
Just how interchangeable these things are.

2342
01:57:51,800 --> 01:57:54,800
Okay, so now what I'm going to do is going to back up a little bit,

2343
01:57:55,200 --> 01:57:56,200
hopefully, all the stuff.

2344
01:57:56,400 --> 01:57:58,900
Up translation units and all that sort of stuff has sunken.

2345
01:57:59,200 --> 01:58:02,400
I'm just going to stop mentioning that stuff anymore and we're just

2346
01:58:02,400 --> 01:58:04,400
going to work in this one file, right?

2347
01:58:04,600 --> 01:58:07,700
And I suppose I should have left that include in because we got rid of

2348
01:58:07,700 --> 01:58:08,100
it there.

2349
01:58:09,700 --> 01:58:10,400
My bad.

2350
01:58:11,000 --> 01:58:15,500
So I suppose, what I can do here, just say let's let's sort of clean

2351
01:58:15,500 --> 01:58:17,900
this this away now, right?

2352
01:58:18,300 --> 01:58:21,900
And let's make something a little bit more straightforward.

2353
01:58:21,900 --> 01:58:24,900
So what I'm going to do here is I'm just going to have just in our one

2354
01:58:24,900 --> 01:58:26,100
translation unit.

2355
01:58:26,500 --> 01:58:29,400
I'm going to put a couple going to put two different things in there,

2356
01:58:29,500 --> 01:58:29,900
right?

2357
01:58:30,400 --> 01:58:33,000
So I'll leave that stuff in place so that we can talk about it later

2358
01:58:33,000 --> 01:58:33,500
if you want to.

2359
01:58:33,500 --> 01:58:35,300
But I'm going to, I'm going to create a very simple thing.

2360
01:58:36,000 --> 01:58:38,300
So what I'm going to do is I'm going to create

2361
01:58:40,100 --> 01:58:43,900
A piece of code here that will produce some value.

2362
01:58:43,900 --> 01:58:50,000
And let me, let me feel figure out how I want to make this work in the

2363
01:58:50,000 --> 01:58:51,400
in the sanest way possible.

2364
01:58:52,600 --> 01:58:53,700
So here's what I'm going to do.

2365
01:58:54,100 --> 01:58:57,500
I'm going to create a piece of code that just returns a constant

2366
01:58:57,500 --> 01:58:57,900
value.

2367
01:58:58,200 --> 01:58:59,700
That's it right?

2368
01:58:59,700 --> 01:59:00,600
That's all it does.

2369
01:59:01,400 --> 01:59:02,700
I'm gonna call it five.

2370
01:59:05,800 --> 01:59:07,700
and the only piece of code in five,

2371
01:59:09,100 --> 01:59:10,300
Is return five.

2372
01:59:11,500 --> 01:59:13,600
That's it, right?

2373
01:59:15,500 --> 01:59:20,000
Then what I'm going to do is I'm going to have a global integer here.

2374
01:59:20,900 --> 01:59:23,600
I'm going to have a global integer and I'm going to have a little

2375
01:59:23,600 --> 01:59:24,300
bunch of jerk.

2376
01:59:24,300 --> 01:59:25,700
All'd number

2377
01:59:27,600 --> 01:59:28,600
and delete this for now.

2378
01:59:31,900 --> 01:59:33,300
And I'm going to set number.

2379
01:59:33,600 --> 01:59:35,400
In fact, I guess I don't really need it to be global.

2380
01:59:39,400 --> 01:59:40,100
No, leave it global.

2381
01:59:41,700 --> 01:59:44,500
Equal to the result of calling five.

2382
01:59:45,700 --> 01:59:48,500
That's I'm going to do right, simple enough.

2383
01:59:48,900 --> 01:59:50,200
And now I'm going to step into that code.

2384
01:59:50,800 --> 01:59:51,400
And here we are.

2385
01:59:52,100 --> 01:59:54,400
Well this is the entirety of our program.

2386
01:59:54,700 --> 01:59:55,900
It's not particularly exciting.

2387
01:59:55,900 --> 01:59:59,700
Is it all we're doing set up the stack frame initially again,

2388
02:00:00,000 --> 02:00:01,700
Sub R SP that you see all over the place.

2389
02:00:01,700 --> 02:00:03,900
All that's doing is giving yourself 28 hex.

2390
02:00:04,000 --> 02:00:06,100
So 0, x, 28 worth of Stack space.

2391
02:00:06,100 --> 02:00:09,000
You're just moving the stack pointer down by that much.

2392
02:00:09,100 --> 02:00:11,100
It's not relevant to what we're doing right now.

2393
02:00:11,100 --> 02:00:13,500
This its stack frame stuff, we haven't really talked about yet and I

2394
02:00:13,500 --> 02:00:17,800
don't know that we really want to get into that yet, then we're going

2395
02:00:17,800 --> 02:00:19,200
to call this function right.

2396
02:00:19,200 --> 02:00:22,400
And that function is 5 and we can again let's just just so everyone

2397
02:00:22,400 --> 02:00:22,900
could see it.

2398
02:00:22,900 --> 02:00:24,700
Let's let's do the this awesome again.

2399
02:00:25,000 --> 02:00:28,200
Here's the dis Azam you can see our startup code again.

2400
02:00:28,200 --> 02:00:29,900
Sets up that stack frame, it calls.

2401
02:00:30,000 --> 02:00:32,500
The five function here is the five function up there.

2402
02:00:32,800 --> 02:00:36,800
We're going to do our mob right in our mom's going to take whatever

2403
02:00:36,800 --> 02:00:38,000
five returned.

2404
02:00:38,800 --> 02:00:42,600
And again, the reason that this is the return of five here is because

2405
02:00:42,600 --> 02:00:47,300
the definition in x64 What's called the a bi or application binary

2406
02:00:47,300 --> 02:00:47,800
interface.

2407
02:00:48,000 --> 02:00:52,000
It's the way that function signatures are expected to work the return

2408
02:00:52,000 --> 02:00:52,400
value.

2409
02:00:52,400 --> 02:00:56,400
If it will fit in in RX e, ax.

2410
02:00:56,700 --> 02:00:57,700
That is where it goes.

2411
02:00:57,700 --> 02:00:59,900
It stays in a register so it doesn't put it

2412
02:01:00,000 --> 02:01:01,000
Stack, the return value?

2413
02:01:01,000 --> 02:01:02,300
Just comes back in a register.

2414
02:01:02,500 --> 02:01:04,800
So what's going to happen is we're going to call five, were expecting

2415
02:01:04,800 --> 02:01:08,100
five to put 5 into a register or threatening to put in eax.

2416
02:01:08,200 --> 02:01:10,700
So when it comes back, we're going to copy whatever.

2417
02:01:10,700 --> 02:01:13,500
It was that that return five, right?

2418
02:01:13,500 --> 02:01:16,300
We're going to put it into number three.

2419
02:01:16,300 --> 02:01:16,800
Aha here.

2420
02:01:16,800 --> 02:01:17,900
Which is that Global variable?

2421
02:01:17,900 --> 02:01:18,800
We're going to move it in there.

2422
02:01:19,100 --> 02:01:20,800
Okay, that's all we're doing.

2423
02:01:22,100 --> 02:01:23,400
Hopefully everyone's on board with that.

2424
02:01:23,600 --> 02:01:27,300
Here we go set up the stack frame going to call here's our function.

2425
02:01:27,600 --> 02:01:28,700
That's the function.

2426
02:01:28,900 --> 02:01:31,200
It just puts five in eax and returns.

2427
02:01:31,300 --> 02:01:33,200
That's all it does, right?

2428
02:01:33,200 --> 02:01:37,300
So there we go, put five NEX return and now we're going to move the

2429
02:01:37,300 --> 02:01:40,200
resulting X and we can see in the registers.

2430
02:01:40,400 --> 02:01:41,500
There's ETA X.

2431
02:01:41,600 --> 02:01:42,800
ETA X is the bottom.

2432
02:01:42,800 --> 02:01:45,500
Half of our e^x e^x is 3 is the 32 bit.

2433
02:01:45,500 --> 02:01:49,800
Register name the wait until registers work is you have 16-bit 32-bit.

2434
02:01:51,200 --> 02:01:53,100
64-bit sort of registers that grow.

2435
02:01:53,200 --> 02:01:55,400
So if I want to I think you can refer to B.

2436
02:01:55,400 --> 02:01:57,000
So it's got like each individual one of them.

2437
02:01:57,400 --> 02:02:00,300
So if I want to refer to just the bottom half in this case an inch is

2438
02:02:00,300 --> 02:02:01,000
32 bits.

2439
02:02:01,300 --> 02:02:06,000
Eax is what it's called if I wanted to I could I can even ask it for

2440
02:02:06,000 --> 02:02:08,900
that in the watch window and you can see it Returns the bottom half of

2441
02:02:08,900 --> 02:02:09,400
that, right?

2442
02:02:09,400 --> 02:02:09,900
And it's fine.

2443
02:02:10,500 --> 02:02:12,700
So anyway, we're putting that into our X.

2444
02:02:12,700 --> 02:02:14,200
You can see that they're in the bottom half.

2445
02:02:14,200 --> 02:02:16,000
There's the five that we moved in there, right?

2446
02:02:16,000 --> 02:02:16,900
It's all good.

2447
02:02:17,300 --> 02:02:20,000
And then we're going to move that out to This Global variable here,

2448
02:02:20,000 --> 02:02:20,900
which is that Global variable?

2449
02:02:21,100 --> 02:02:24,200
And I can, I can watch that Global variable even without debug info.

2450
02:02:24,200 --> 02:02:25,100
I can just tell it.

2451
02:02:25,100 --> 02:02:28,800
Hey, by the way, that's an integer right at that location.

2452
02:02:29,600 --> 02:02:32,300
So why don't you go ahead and why can't I paste?

2453
02:02:35,000 --> 02:02:36,800
Cut paste.

2454
02:02:37,100 --> 02:02:37,600
There we go.

2455
02:02:40,400 --> 02:02:42,800
So, I can just go ahead and say, by the way, that's an integer.

2456
02:02:43,100 --> 02:02:45,300
And if we look at what's in the integer, you'll notice at startup.

2457
02:02:45,300 --> 02:02:46,900
It's nothing, right?

2458
02:02:47,100 --> 02:02:51,700
But after I execute this mob instruction, it has moved that five in

2459
02:02:51,700 --> 02:02:52,000
there.

2460
02:02:52,000 --> 02:02:55,600
And so now we're we have correctly, put five in there, which is what

2461
02:02:55,600 --> 02:02:56,200
we'd expect.

2462
02:02:56,200 --> 02:02:59,800
Alright, that is all hopefully everything that we

2463
02:03:00,100 --> 02:03:03,400
Today, all of the work we've done today should lead up to this point.

2464
02:03:03,400 --> 02:03:05,800
You should be completely comfortable with what happened there.

2465
02:03:05,900 --> 02:03:09,800
Except for this one sub stack bit here because we haven't talked about

2466
02:03:09,800 --> 02:03:13,300
the stack, but hopefully this part the call, right?

2467
02:03:13,600 --> 02:03:15,000
The getting the five I put in there.

2468
02:03:15,000 --> 02:03:17,800
It should not be very mysterious at this point, right?

2469
02:03:18,900 --> 02:03:19,300
Okay.

2470
02:03:19,800 --> 02:03:23,400
So, just to prove to you that the function pointer is literally just

2471
02:03:23,400 --> 02:03:25,300
that it's just that function pointer.

2472
02:03:25,500 --> 02:03:29,000
Now, we will go ahead and actually do some Shenanigans with it.

2473
02:03:29,000 --> 02:03:32,200
So you can see that it really is just a pointer to a block of memory.

2474
02:03:32,300 --> 02:03:35,200
Okay, so what do we need to do first?

2475
02:03:35,400 --> 02:03:40,000
Well, implicit in all of this, as you can see, is the fact that c

2476
02:03:40,000 --> 02:03:43,200
needs to understand how to call a function, and there's a lot of

2477
02:03:43,200 --> 02:03:46,700
aspects to how to call a function, the first aspect you've seen, and

2478
02:03:46,700 --> 02:03:48,300
it's the only one we're dealing with here.

2479
02:03:48,700 --> 02:03:49,900
I wanted to keep it simple is.

2480
02:03:50,200 --> 02:03:51,900
Where does the return value end up?

2481
02:03:51,900 --> 02:03:54,200
And what is that, return value, right?

2482
02:03:54,900 --> 02:03:56,400
In this case, it's just an integer.

2483
02:03:56,600 --> 02:03:59,200
So it knows that the return value would go in eax.

2484
02:03:59,400 --> 02:04:00,400
How does it know that?

2485
02:04:00,400 --> 02:04:02,700
It knows it because of the Avi, right?

2486
02:04:02,700 --> 02:04:08,500
And an Avi station, binary interface and ABI you can look up its this

2487
02:04:08,500 --> 02:04:09,700
this thing right here.

2488
02:04:10,300 --> 02:04:13,800
What an ABI is is it's a thing where people get together in this a.

2489
02:04:13,800 --> 02:04:14,400
All right, look

2490
02:04:15,700 --> 02:04:19,500
We've got the operating system, we've got user mode code, we've got

2491
02:04:19,500 --> 02:04:23,000
multiple compilers, we've got multiple languages.

2492
02:04:23,500 --> 02:04:25,600
All of this stuff has to call each other.

2493
02:04:25,600 --> 02:04:28,800
Maybe someone wrote A C library and it's got a call python, maybe

2494
02:04:28,800 --> 02:04:30,100
python has to call Pearl.

2495
02:04:30,100 --> 02:04:32,900
Maybe Pearl has to call in to the operating system and maybe the

2496
02:04:32,900 --> 02:04:34,800
operating system has to call back to some C code.

2497
02:04:35,900 --> 02:04:39,800
All of these people need to have an understanding if they're going to

2498
02:04:39,800 --> 02:04:45,400
work together about how functions are called and how return values

2499
02:04:45,400 --> 02:04:46,800
come back, right?

2500
02:04:47,400 --> 02:04:51,200
This is just a fundamental aspect of programming and it needs to be

2501
02:04:51,200 --> 02:04:55,400
obeyed because if it didn't you couldn't have anyone call anyone else.

2502
02:04:55,900 --> 02:05:00,300
Any given compiler could call code that it wrote itself, because it

2503
02:05:00,300 --> 02:05:03,200
knows how it's going to do stuff like, where it's going to put

2504
02:05:03,200 --> 02:05:05,200
parameters, and where the return values come back.

2505
02:05:05,400 --> 02:05:08,600
Remember that stuff is not specified at the processor.

2506
02:05:08,600 --> 02:05:09,100
Level.

2507
02:05:09,200 --> 02:05:13,900
A processor is just a machine that has registers and memory accesses.

2508
02:05:14,100 --> 02:05:18,300
It doesn't specify anything about how a function is called other than,

2509
02:05:18,300 --> 02:05:21,100
perhaps, some slight bias towards.

2510
02:05:21,100 --> 02:05:25,000
For example, the call instruction may be automatically, pushes the

2511
02:05:25,000 --> 02:05:29,100
location where things were executing previously on to the stack first,

2512
02:05:29,100 --> 02:05:31,700
so that a ret instruction will automatically pull them off or

2513
02:05:31,700 --> 02:05:32,500
something like this.

2514
02:05:32,500 --> 02:05:34,000
And we're going to look at that in a little bit.

2515
02:05:35,100 --> 02:05:35,900
But that's it.

2516
02:05:36,200 --> 02:05:40,300
So, all the other stuff about like, oh, where does the first float go

2517
02:05:40,300 --> 02:05:41,000
that you pass?

2518
02:05:41,000 --> 02:05:44,400
And where does the first ant go and what if I pass a structure where

2519
02:05:44,400 --> 02:05:45,300
do all the members go?

2520
02:05:45,300 --> 02:05:47,000
What if I pass a pointer to a structure?

2521
02:05:47,400 --> 02:05:48,600
What happens, right?

2522
02:05:48,800 --> 02:05:51,200
All of that stuff is defined in the ABI.

2523
02:05:51,800 --> 02:05:54,400
So once you understand the ABI you understand how functions are

2524
02:05:54,400 --> 02:05:54,900
called.

2525
02:05:55,200 --> 02:05:57,900
So fortunately for us, we don't really need to understand very much

2526
02:05:57,900 --> 02:05:59,800
about the Avi unless we're actually

2527
02:06:00,000 --> 02:06:03,300
Using machine code which were not really doing here in most cases in

2528
02:06:03,300 --> 02:06:04,600
handmade hero, certainly we're not.

2529
02:06:04,800 --> 02:06:08,900
But when we look at the assembly, it's important to understand that

2530
02:06:08,900 --> 02:06:12,300
the assembly we're looking at is generated that way because it is

2531
02:06:12,300 --> 02:06:16,400
complying with the ABI it is using the stack it is using the registers

2532
02:06:16,400 --> 02:06:20,500
and is using them in a way that complies with someone specific

2533
02:06:20,500 --> 02:06:25,300
definition of how code was supposed to call other code on this

2534
02:06:25,300 --> 02:06:25,900
platform.

2535
02:06:25,900 --> 02:06:29,800
This operating system and everyone is supposed to obey it, right?

2536
02:06:30,000 --> 02:06:30,000
Right?

2537
02:06:30,100 --> 02:06:32,200
So Linux lays down the law for Linux.

2538
02:06:32,200 --> 02:06:35,200
It says, anybody who's operating in our ecosystem.

2539
02:06:35,500 --> 02:06:37,200
This is how you're going to call stuff.

2540
02:06:37,900 --> 02:06:39,400
Just get it straight, right?

2541
02:06:39,400 --> 02:06:40,000
Or something.

2542
02:06:41,300 --> 02:06:44,500
And again, they have to do it for each processor type, they support as

2543
02:06:44,500 --> 02:06:48,200
well because the processors differ so whether you use a register or

2544
02:06:48,200 --> 02:06:49,700
stack or memory or whatever, right?

2545
02:06:49,700 --> 02:06:53,000
That stuff has to be defined per processor because the process differ.

2546
02:06:53,300 --> 02:06:56,100
But for all x 64 processors, for example.

2547
02:06:56,200 --> 02:06:58,400
Here's a bi and everyone has to obey.

2548
02:06:58,400 --> 02:07:00,000
Okay, so,

2549
02:07:01,600 --> 02:07:05,100
We know that the Linker is going to obey the ABI so we know that no

2550
02:07:05,100 --> 02:07:07,700
matter what we tell it to do in C, it's going to figure out a way to

2551
02:07:07,700 --> 02:07:09,400
do that properly in machine code.

2552
02:07:09,400 --> 02:07:10,200
That's great.

2553
02:07:10,300 --> 02:07:13,400
We don't have to worry much about that, but we do have to worry about,

2554
02:07:13,400 --> 02:07:15,100
is the compiler itself.

2555
02:07:15,100 --> 02:07:19,300
When it's actually going to go, like, process our code, it needs to

2556
02:07:19,300 --> 02:07:23,300
know what to, you know, basically how to do the code gen to conform to

2557
02:07:23,300 --> 02:07:27,300
the ABI for whatever function call we're doing, which is why it needs

2558
02:07:27,300 --> 02:07:30,900
to see a function signature, it needs to see the function signature so

2559
02:07:30,900 --> 02:07:31,300
it knows.

2560
02:07:31,400 --> 02:07:36,200
How to set up the call stack and the return value information so that

2561
02:07:36,200 --> 02:07:38,400
it can properly call the function, right?

2562
02:07:38,500 --> 02:07:40,100
It needs to know that information.

2563
02:07:41,100 --> 02:07:46,600
So, that is where we get to the weird typedef, part of C, right?

2564
02:07:47,400 --> 02:07:50,300
So let's say that I do avoid star.

2565
02:07:52,300 --> 02:07:53,000
Function.

2566
02:07:54,600 --> 02:07:55,500
Equals 5.

2567
02:07:55,700 --> 02:07:56,800
We know this works.

2568
02:07:56,900 --> 02:08:00,000
We know this takes the address of five and puts it into void star

2569
02:08:00,000 --> 02:08:01,300
function, right?

2570
02:08:01,900 --> 02:08:03,600
And now I want to call it

2571
02:08:04,700 --> 02:08:09,600
Well, I can't write and the reason I can't is specifically, I get a

2572
02:08:09,600 --> 02:08:10,400
compile error.

2573
02:08:11,600 --> 02:08:16,300
The reason I can't is for no other reason than it, simply does not

2574
02:08:16,300 --> 02:08:19,400
understand how to conform to an ABI.

2575
02:08:19,700 --> 02:08:22,900
When it doesn't know a function signature, it doesn't know what it's

2576
02:08:22,900 --> 02:08:23,900
supposed to return.

2577
02:08:24,000 --> 02:08:26,600
It doesn't know what arguments that supposed to pass, or what they

2578
02:08:26,600 --> 02:08:27,200
look like.

2579
02:08:27,400 --> 02:08:29,200
So, there's nothing it can really do.

2580
02:08:29,300 --> 02:08:33,300
If it just has a void star, it can't call a function because it

2581
02:08:33,300 --> 02:08:36,100
doesn't know what that function signature would be right.

2582
02:08:36,400 --> 02:08:38,800
So what we need to do is tell it

2583
02:08:39,600 --> 02:08:41,200
What the parameters are.

2584
02:08:42,300 --> 02:08:47,500
And what the return value is because this syntax in C is telling it to

2585
02:08:47,500 --> 02:08:51,600
treat this as a pointer to a function and we'll put the arguments in

2586
02:08:51,600 --> 02:08:51,900
here.

2587
02:08:51,900 --> 02:08:57,400
This syntax is function called syntax when it sees something with open

2588
02:08:57,400 --> 02:08:59,300
close parenthesis, that's a function call.

2589
02:09:00,000 --> 02:09:04,700
Could do this, it could call this location that part.

2590
02:09:04,700 --> 02:09:06,500
It knows what it doesn't know.

2591
02:09:06,500 --> 02:09:08,300
Is what's coming back?

2592
02:09:08,500 --> 02:09:10,600
How do I create code that obeys?

2593
02:09:10,600 --> 02:09:14,700
The ABI maybe I can infer because this is closed with nothing in it

2594
02:09:14,700 --> 02:09:15,600
that there's no arguments.

2595
02:09:15,600 --> 02:09:16,200
Okay.

2596
02:09:16,600 --> 02:09:18,200
But I don't know what it returns.

2597
02:09:18,500 --> 02:09:22,400
I know you're assigning it to an integer, but maybe it returns a short

2598
02:09:22,500 --> 02:09:24,500
and a short to an integer conversion would be okay.

2599
02:09:24,500 --> 02:09:27,700
Here maybe it returns a whole struct and this is an error.

2600
02:09:27,700 --> 02:09:28,400
I don't know.

2601
02:09:28,500 --> 02:09:29,800
I really don't know what to do.

2602
02:09:30,000 --> 02:09:33,600
Do so what we need to do is we need to give it enough information so

2603
02:09:33,600 --> 02:09:36,200
that it can properly generate the code that conforms to the ABI.

2604
02:09:36,400 --> 02:09:39,700
And furthermore again, since we're in C++, some of the information

2605
02:09:39,700 --> 02:09:42,800
we're giving, it isn't strictly for composite complying with the ABI.

2606
02:09:43,100 --> 02:09:45,700
It's actually also there to do error checking.

2607
02:09:45,700 --> 02:09:49,300
So that we don't try to call a function in a completely incorrect way,

2608
02:09:49,400 --> 02:09:50,000
right?

2609
02:09:51,000 --> 02:09:51,400
Okay.

2610
02:09:51,900 --> 02:09:54,000
So that's where the typedef stuff comes in.

2611
02:09:54,400 --> 02:09:57,400
The typedef stuff comes in to give us a function signature in a way

2612
02:09:57,400 --> 02:09:59,900
that we can use, so that we can do stuff like

2613
02:10:00,700 --> 02:10:01,600
Calling functions.

2614
02:10:01,900 --> 02:10:04,700
So if I say into, you know, number function,

2615
02:10:08,800 --> 02:10:12,200
What I've done here is, I've typed F the function signature so that I

2616
02:10:12,200 --> 02:10:13,500
can now use it to say.

2617
02:10:13,500 --> 02:10:15,900
This is the kind of function that I have, right?

2618
02:10:16,000 --> 02:10:18,300
This is the kind of function that I'm pointing to.

2619
02:10:18,300 --> 02:10:21,800
And again, nothing has changed in the code at all.

2620
02:10:21,800 --> 02:10:26,800
At this point on this line, I am still just moving in address into

2621
02:10:26,800 --> 02:10:28,000
this, this function pointer.

2622
02:10:28,000 --> 02:10:29,000
That's all I'm doing.

2623
02:10:29,200 --> 02:10:33,800
The only difference is I have now given the compiler at compile time.

2624
02:10:35,000 --> 02:10:39,200
The information it needs to know how to generate code conformant to

2625
02:10:39,200 --> 02:10:44,200
the ABI, to generate the preamble to the call instruction, that will

2626
02:10:44,200 --> 02:10:48,100
successfully set up the stack frame and the return stuff about

2627
02:10:48,100 --> 02:10:50,300
processing for this function, right?

2628
02:10:51,400 --> 02:10:54,600
Okay, so now we can pile and we get code that actually should work.

2629
02:10:54,600 --> 02:10:56,100
We can step in here again.

2630
02:10:56,100 --> 02:11:00,200
I'll show you the dis azzam here, just as we've been doing, you can

2631
02:11:00,200 --> 02:11:03,800
see it exactly as it goes before we do a call here.

2632
02:11:03,800 --> 02:11:08,400
And now, the only change has been we load in the address first and

2633
02:11:08,400 --> 02:11:12,300
then we store that address to a place on the stack, right?

2634
02:11:12,400 --> 02:11:15,800
And this again is just because the code is not optimized, we would

2635
02:11:15,800 --> 02:11:19,300
probably just call straight out or something similar.

2636
02:11:20,500 --> 02:11:23,600
Although maybe we wouldn't because we you know RX is going to get

2637
02:11:23,600 --> 02:11:24,500
destroyed by their turn.

2638
02:11:24,500 --> 02:11:27,000
So maybe it wouldn't who knows point being what the code does here?

2639
02:11:27,000 --> 02:11:29,800
Is this loading the address of the function to call its then storing

2640
02:11:29,800 --> 02:11:31,300
that to the stack at the location?

2641
02:11:31,300 --> 02:11:34,300
This is the space on the stack that was created to store our local

2642
02:11:34,300 --> 02:11:34,900
variable.

2643
02:11:35,000 --> 02:11:37,800
It's a space that was created to store function, right?

2644
02:11:38,000 --> 02:11:40,700
So this is function, it's then going to call it.

2645
02:11:40,900 --> 02:11:44,000
And again I can continue my trend of putting these AS Global

2646
02:11:44,000 --> 02:11:44,400
variables.

2647
02:11:44,400 --> 02:11:47,100
So they become name so you can see that, right?

2648
02:11:48,900 --> 02:11:50,500
If I compile now, oops.

2649
02:11:53,300 --> 02:11:57,900
If I can pile now and then do this step, you can see exactly what's

2650
02:11:57,900 --> 02:11:58,200
Happening.

2651
02:11:58,200 --> 02:11:59,800
Here I load in to eat too.

2652
02:12:00,000 --> 02:12:02,100
Ax the location of the function.

2653
02:12:02,300 --> 02:12:05,000
I store that location out to my function pointer.

2654
02:12:05,200 --> 02:12:09,700
I am going to call through my function pointer right which will call

2655
02:12:09,700 --> 02:12:10,200
out to here.

2656
02:12:10,200 --> 02:12:11,700
It will put 5 in eax.

2657
02:12:11,700 --> 02:12:15,600
I will then move that into X into my number my Global variable and I

2658
02:12:15,600 --> 02:12:16,700
am done right?

2659
02:12:17,000 --> 02:12:20,900
And again we can look at the at that happening in the debugger one

2660
02:12:20,900 --> 02:12:21,800
step at a time.

2661
02:12:22,000 --> 02:12:23,100
Right here we go.

2662
02:12:23,100 --> 02:12:24,900
I'm going to load in that address.

2663
02:12:25,100 --> 02:12:26,200
I'm going to move that.

2664
02:12:26,200 --> 02:12:28,200
Address out to the location on the stack.

2665
02:12:28,200 --> 02:12:28,600
That is

2666
02:12:29,800 --> 02:12:32,300
Corresponding to that Global variable function pointer, I'm going to

2667
02:12:32,300 --> 02:12:34,000
call through that function pointer.

2668
02:12:34,100 --> 02:12:37,000
And you can see now that I've arrived there, right?

2669
02:12:37,100 --> 02:12:39,800
And you'll notice this is the function pointers location.

2670
02:12:39,800 --> 02:12:42,700
So I'm calling through that pointer that's what this bracket syntax

2671
02:12:42,700 --> 02:12:45,300
this keyword pointer bracket syntax means it means look up.

2672
02:12:45,300 --> 02:12:47,800
What's the address at this address?

2673
02:12:47,900 --> 02:12:51,500
Don't Branch to this actual address so it's going to get this that we

2674
02:12:51,500 --> 02:12:52,200
stored there.

2675
02:12:52,200 --> 02:12:54,400
It's going to use that and Branch through it, right.

2676
02:12:54,400 --> 02:12:57,900
The until x64 is crazy, sis constructions that can do stuff like go

2677
02:12:57,900 --> 02:12:59,400
fetch a piece of memory.

2678
02:13:00,200 --> 02:13:02,000
And call in one instruction, right?

2679
02:13:02,900 --> 02:13:04,300
That's just Intel's encoding for you.

2680
02:13:05,100 --> 02:13:06,400
It's a cyst style encoding.

2681
02:13:06,900 --> 02:13:08,800
So anyway, we're going to Branch up there.

2682
02:13:08,800 --> 02:13:12,000
You can see we do we move into eax, exactly as you expect, there's

2683
02:13:12,000 --> 02:13:12,700
that eax.

2684
02:13:13,100 --> 02:13:18,200
We hit the ret, here we come down here and we do them off to put into

2685
02:13:18,200 --> 02:13:19,500
our Global variable the value.

2686
02:13:20,000 --> 02:13:24,300
And now, if we were to look at this value as we did before we would

2687
02:13:24,300 --> 02:13:24,700
see.

2688
02:13:24,700 --> 02:13:29,400
Oops, again, we would see that it was

2689
02:13:29,500 --> 02:13:31,100
Five as we expected, right?

2690
02:13:31,400 --> 02:13:32,900
No big mystery here.

2691
02:13:33,000 --> 02:13:36,500
All I have done is shown how to call through that function pointer.

2692
02:13:36,700 --> 02:13:40,300
Again, it's exactly the same as if we adjust inserted 5 here.

2693
02:13:40,300 --> 02:13:44,800
Except now, instead of calling having that call site, be patched

2694
02:13:45,000 --> 02:13:48,800
during the link phase to actually point to a specific location in the

2695
02:13:48,800 --> 02:13:52,000
executable instead, what it's doing is it's creating code that's

2696
02:13:52,000 --> 02:13:53,600
taking that same past address.

2697
02:13:53,600 --> 02:13:54,600
It is still patching hours.

2698
02:13:54,800 --> 02:13:55,700
Instead of patching.

2699
02:13:55,700 --> 02:13:58,700
The address at the call site it's taking that address the Linker is

2700
02:13:59,000 --> 02:13:59,400
putting that

2701
02:13:59,500 --> 02:14:03,000
To code that loads it into a global variable and then it's calling

2702
02:14:03,000 --> 02:14:03,900
through the global variable.

2703
02:14:04,200 --> 02:14:05,700
Hopefully you saw that happen.

2704
02:14:05,900 --> 02:14:08,500
Nothing, no, nothing weird, right?

2705
02:14:08,500 --> 02:14:10,500
It all makes pretty good sense to you, right?

2706
02:14:10,500 --> 02:14:10,900
Okay.

2707
02:14:11,100 --> 02:14:12,900
Again, let me show you

2708
02:14:14,100 --> 02:14:19,100
Yet one more way, just how unmiss terius this really is, let's

2709
02:14:19,100 --> 02:14:20,000
suppose.

2710
02:14:20,000 --> 02:14:22,700
We just want to make our own function.

2711
02:14:22,900 --> 02:14:24,700
I don't even have this anymore.

2712
02:14:24,700 --> 02:14:25,500
It's gone.

2713
02:14:26,500 --> 02:14:27,100
Okay.

2714
02:14:29,300 --> 02:14:30,400
I want to do that.

2715
02:14:31,200 --> 02:14:33,900
And if I wanted to do that, I need something here.

2716
02:14:34,400 --> 02:14:35,200
I don't know.

2717
02:14:35,200 --> 02:14:38,700
I need some kind of thing for my function, right?

2718
02:14:39,300 --> 02:14:40,800
So how would I go about doing that?

2719
02:14:40,800 --> 02:14:44,500
Well, we have the compiled version of this function, right?

2720
02:14:44,500 --> 02:14:45,600
I mean we've got it.

2721
02:14:46,100 --> 02:14:49,600
So let's suppose I step here and I go, well, this is the code for for

2722
02:14:49,600 --> 02:14:51,000
that function, right?

2723
02:14:51,100 --> 02:14:52,900
I mean, this is the code, it's be 80.

2724
02:14:52,900 --> 02:14:54,900
5000 C3.

2725
02:14:55,600 --> 02:14:56,400
That's the code.

2726
02:14:58,100 --> 02:14:58,600
Right?

2727
02:14:58,600 --> 02:14:59,800
But that that's it.

2728
02:15:00,000 --> 02:15:02,600
I mean, I can look at this location in memory in the memory watch

2729
02:15:02,600 --> 02:15:03,600
window, right?

2730
02:15:03,600 --> 02:15:06,000
I don't have to believe the disassembler and here it is.

2731
02:15:06,500 --> 02:15:10,000
So that's the code for five that just just, that's just the code

2732
02:15:10,000 --> 02:15:10,400
period.

2733
02:15:10,400 --> 02:15:11,700
There's nothing else to say about it.

2734
02:15:11,700 --> 02:15:12,500
That's the code.

2735
02:15:12,700 --> 02:15:15,800
So this is literally, and I'm going to just cut and paste it out.

2736
02:15:15,800 --> 02:15:20,900
Here this function 5 literally compiles to this byte sequence.

2737
02:15:26,400 --> 02:15:31,300
Okay, this is literally the code for this function.

2738
02:15:33,800 --> 02:15:34,700
That's the code.

2739
02:15:36,100 --> 02:15:38,100
That is what exists in memory at the time.

2740
02:15:38,100 --> 02:15:41,900
It's executed when we call it, that is what the processor literally

2741
02:15:41,900 --> 02:15:42,500
sees.

2742
02:15:43,800 --> 02:15:44,300
Right?

2743
02:15:46,000 --> 02:15:48,600
So what that means is once I've got it, what do I need this for?

2744
02:15:51,000 --> 02:15:52,900
It's not necessary, right?

2745
02:15:53,200 --> 02:15:55,900
Because I now have the compiled code 45.

2746
02:15:55,900 --> 02:15:59,100
I'm not even going to bother passing it to compiler, right?

2747
02:15:59,100 --> 02:15:59,700
Screw it.

2748
02:15:59,700 --> 02:16:00,300
Forget it.

2749
02:16:01,000 --> 02:16:04,100
So now when I compile it's like well I don't have this function 5 I'm

2750
02:16:04,100 --> 02:16:06,200
like I don't care just use this.

2751
02:16:07,200 --> 02:16:08,400
I just want you to Branch to that.

2752
02:16:08,400 --> 02:16:10,000
And it's like, well, I can transfer that.

2753
02:16:10,100 --> 02:16:11,000
It's not a function.

2754
02:16:11,100 --> 02:16:12,500
And I'm like, well you know what?

2755
02:16:12,600 --> 02:16:17,200
Pretend it is just trust me on this one pretend it's going to be and

2756
02:16:17,200 --> 02:16:20,300
of course this this doesn't okay, fine.

2757
02:16:20,300 --> 02:16:24,900
You know, if you don't want me to do that, let's just say point to the

2758
02:16:24,900 --> 02:16:26,000
beginning of it, right?

2759
02:16:29,400 --> 02:16:33,400
So I'm just saying look that first that very first and in fact, I

2760
02:16:33,400 --> 02:16:35,299
could, I could probably do this a little bit cleaner.

2761
02:16:35,299 --> 02:16:36,000
If I didn't Point you're there.

2762
02:16:36,000 --> 02:16:39,200
But anyway, the pointer to the first bite of this thing.

2763
02:16:39,500 --> 02:16:42,400
Just pretend that's a function pointer, right?

2764
02:16:42,400 --> 02:16:42,900
That's all.

2765
02:16:42,900 --> 02:16:47,000
I told it to do, I'm just, like, trust me, it's a function pointer.

2766
02:16:48,000 --> 02:16:48,600
Right.

2767
02:16:50,900 --> 02:16:52,900
So then I'm like, okay, let's see what happens.

2768
02:16:53,700 --> 02:16:57,299
And there might be some caveats here, but we'll kind of get to those

2769
02:16:57,299 --> 02:16:57,700
later.

2770
02:16:57,900 --> 02:17:01,299
So let's see what happens if I look at my disassembly here.

2771
02:17:01,299 --> 02:17:04,700
You'll be like, you'll kind of take a look at what's going on now.

2772
02:17:04,700 --> 02:17:09,500
We're like, hey, you know, this is a little bit weird, right?

2773
02:17:09,700 --> 02:17:13,100
Because you can see now when we're kind of looking at this, we have

2774
02:17:13,100 --> 02:17:14,400
code, 45 code.

2775
02:17:14,400 --> 02:17:18,000
45 isn't defined anywhere though, right?

2776
02:17:18,400 --> 02:17:20,600
So, when I look at this, I'm like, where is

2777
02:17:20,799 --> 02:17:22,299
The code 45 code.

2778
02:17:22,600 --> 02:17:27,100
And the answer is that basically we've only been looking at the code

2779
02:17:27,100 --> 02:17:28,600
section of an exit.

2780
02:17:29,200 --> 02:17:32,000
But as you saw before, when I kind of like brushed it aside because I

2781
02:17:32,000 --> 02:17:33,200
don't want to talk about it yet.

2782
02:17:34,700 --> 02:17:38,400
When we had that 2.0 times something I was like, oh it put that float

2783
02:17:38,400 --> 02:17:43,799
in some in the data segment, this executable this, I'm sorry, this

2784
02:17:43,799 --> 02:17:47,600
object file, in addition, to specifying code, which is what it's

2785
02:17:47,600 --> 02:17:49,500
dumping here in dis as mmm.

2786
02:17:49,900 --> 02:17:50,600
It also

2787
02:17:50,700 --> 02:17:53,600
It has data and so there's different sections.

2788
02:17:53,600 --> 02:17:57,100
Like I said this cough object format is kind of like a pack file.

2789
02:17:57,299 --> 02:17:59,799
It puts in or sorry I should say the object file for

2790
02:18:00,200 --> 02:18:03,100
Is kind of a pack file, doesn't have to be cough object file format.

2791
02:18:05,200 --> 02:18:07,100
Where it can put data in there as well.

2792
02:18:07,100 --> 02:18:09,500
And of course, you can understand why this might be the case.

2793
02:18:09,799 --> 02:18:13,600
It's not uncommon for code to have a bunch of tables in it and

2794
02:18:13,600 --> 02:18:17,000
constant values, the string, constants, and all that stuff that stuff

2795
02:18:17,000 --> 02:18:20,600
all has to flow through the whole process because the executable, when

2796
02:18:20,600 --> 02:18:23,400
it loads has to have all that data, because it's referenced, right?

2797
02:18:23,799 --> 02:18:27,100
So, in addition to having the code segments, which is what we see when

2798
02:18:27,100 --> 02:18:29,600
we do a dis a them, we can also ask it.

2799
02:18:29,600 --> 02:18:31,700
And again, this is going to tax my memory on how do this.

2800
02:18:31,900 --> 02:18:33,700
We can also ask it to see

2801
02:18:34,700 --> 02:18:37,500
parts of, of the

2802
02:18:39,700 --> 02:18:43,200
Of the data that are that are purely data.

2803
02:18:43,200 --> 02:18:47,000
It may charting part of the object file that are purely data-oriented

2804
02:18:47,400 --> 02:18:48,000
in nature.

2805
02:18:48,200 --> 02:18:51,400
And I don't know how to do that.

2806
02:18:53,400 --> 02:18:54,500
Exactly.

2807
02:18:57,100 --> 02:18:57,900
There's the raw denim.

2808
02:18:57,900 --> 02:19:00,400
Not tell it to actually print it out.

2809
02:19:00,600 --> 02:19:08,100
Is the problem show me how to print it out let's see.

2810
02:19:08,100 --> 02:19:09,600
Directors dependence.

2811
02:19:09,799 --> 02:19:11,600
Well, I don't know what if I set all what?

2812
02:19:11,600 --> 02:19:12,200
All help.

2813
02:19:12,700 --> 02:19:13,400
Probably not.

2814
02:19:14,299 --> 02:19:15,900
Hey yeah it did.

2815
02:19:16,600 --> 02:19:17,700
Yeah it does.

2816
02:19:18,299 --> 02:19:20,100
So you can see if I do all.

2817
02:19:20,100 --> 02:19:22,400
Now I'm getting a lot more stuff, right?

2818
02:19:22,400 --> 02:19:23,100
I'm getting all kinds.

2819
02:19:23,200 --> 02:19:26,799
The things that maybe I wasn't getting for before and what you can see

2820
02:19:26,799 --> 02:19:29,200
now is we've got a bunch more information.

2821
02:19:29,200 --> 02:19:32,500
Here's the symbols, here's all the symbols, we have code 45, is there,

2822
02:19:32,500 --> 02:19:32,700
right?

2823
02:19:32,700 --> 02:19:35,600
You can see it's relative offsets and all this stuff.

2824
02:19:35,600 --> 02:19:42,799
Here's a bunch of raw data and what we can see this be 80, 500, you

2825
02:19:42,799 --> 02:19:44,200
know, somewhere in here.

2826
02:19:44,400 --> 02:19:46,200
That's going to be right.

2827
02:19:46,600 --> 02:19:50,100
And I think we probably can find it.

2828
02:19:51,400 --> 02:19:53,100
Let's see if we can find it somewhere.

2829
02:19:53,200 --> 02:19:56,500
Um where I should probably just load this in and search but we should

2830
02:19:56,500 --> 02:20:00,900
have again some information about exactly where it is.

2831
02:20:01,200 --> 02:20:05,100
When we actually, look, let me let me go ahead and do a less here and

2832
02:20:05,100 --> 02:20:07,200
see if it if I could find it.

2833
02:20:07,200 --> 02:20:08,700
So let me look for B8.

2834
02:20:09,500 --> 02:20:10,300
No, we didn't get it.

2835
02:20:10,300 --> 02:20:10,700
So I don't know.

2836
02:20:10,700 --> 02:20:15,400
Maybe maybe all still doesn't actually tell me all of the data because

2837
02:20:15,400 --> 02:20:19,100
you can see like it's got this here and I don't know where it's

2838
02:20:19,100 --> 02:20:19,900
actually put it.

2839
02:20:20,500 --> 02:20:23,100
I'm not sure I want to spend the time trying to tell dump in how to

2840
02:20:23,200 --> 02:20:24,300
It but just trust me.

2841
02:20:25,200 --> 02:20:26,900
It's all going to be in this object file.

2842
02:20:26,900 --> 02:20:31,100
You can and you can presumably coerced dumpin to show it to you at the

2843
02:20:31,100 --> 02:20:33,000
very least, if I wanted to, right.

2844
02:20:33,000 --> 02:20:36,900
I could also just ask that list on here.

2845
02:20:36,900 --> 02:20:43,400
Yeah, I could presumably also asked to just show me the obj file and

2846
02:20:43,500 --> 02:20:47,900
in a hex editor, we could just come in here and actually find it right

2847
02:20:48,000 --> 02:20:52,600
because somewhere in here is going to be code 45 and we can find out

2848
02:20:52,600 --> 02:20:53,000
where that

2849
02:20:53,100 --> 02:20:55,300
it actually is and I can search for it, right?

2850
02:20:55,300 --> 02:20:59,700
So if I want to, I can look at for that, be 8, and here it is.

2851
02:21:00,000 --> 02:21:03,700
So, there's that code, the be a 05 code, right?

2852
02:21:04,200 --> 02:21:04,600
Be 80.

2853
02:21:04,600 --> 02:21:07,900
5000 C3, which is this code right here.

2854
02:21:08,000 --> 02:21:10,300
So, there it is in the executable right, Augusta?

2855
02:21:10,300 --> 02:21:14,300
And somehow, we could, if we had more time to play with dump in, we

2856
02:21:14,300 --> 02:21:16,100
could probably find a way to more clean, the do it.

2857
02:21:16,100 --> 02:21:18,700
And of course, it says here, what, the offsets are so we could have

2858
02:21:18,700 --> 02:21:23,000
known presumably as well wear and may not obj, it was right, but

2859
02:21:23,000 --> 02:21:26,100
anyway, point being now I produce an executable, which is going to

2860
02:21:26,100 --> 02:21:27,400
call that specifically.

2861
02:21:27,500 --> 02:21:29,900
And so if I look at the, the dump in here,

2862
02:21:30,000 --> 02:21:32,400
Here for my main.

2863
02:21:33,300 --> 02:21:33,900
There it is.

2864
02:21:34,500 --> 02:21:38,700
What you can see is now, we're loading the code, 45 address, right?

2865
02:21:38,800 --> 02:21:42,800
We're loading that in, which is just our array of data that we put in

2866
02:21:42,800 --> 02:21:43,200
there.

2867
02:21:44,100 --> 02:21:48,000
We're for whatever reason doing this array indexing.

2868
02:21:48,300 --> 02:21:51,700
And so you know I think this is just because we haven't specified that

2869
02:21:51,700 --> 02:21:53,300
the compiler should do any optimizations.

2870
02:21:53,500 --> 02:21:57,600
It's actually doing this 0 part here so you can see what it's doing.

2871
02:21:57,600 --> 02:21:58,900
Is it's saying like Okay

2872
02:21:59,900 --> 02:22:04,100
Let's go 0 far into here, right?

2873
02:22:04,200 --> 02:22:05,900
Let's go 0 far into this array.

2874
02:22:05,900 --> 02:22:09,000
It's like all right, I'll go 04 on the right, which is a still exact

2875
02:22:09,000 --> 02:22:12,300
same place and then it's actually loading that into the function

2876
02:22:12,300 --> 02:22:14,600
pointer and then it's calling that function pointer.

2877
02:22:14,800 --> 02:22:18,400
But fundamentally all it's doing is calling code 45, right?

2878
02:22:18,500 --> 02:22:22,100
That's all it's doing and presumably, I don't know.

2879
02:22:22,500 --> 02:22:25,800
I don't know if I can make that less obtuse.

2880
02:22:27,700 --> 02:22:31,800
I don't think I can make an initializer list in any other way.

2881
02:22:31,900 --> 02:22:32,900
I want to do it.

2882
02:22:32,900 --> 02:22:36,600
I would like to do it so that it wouldn't do that.

2883
02:22:37,000 --> 02:22:39,600
But you can see how it wants to.

2884
02:22:41,400 --> 02:22:45,600
It really wants to make me convince it that it's a pointer because

2885
02:22:45,600 --> 02:22:48,500
it's thinking of this as an array, right?

2886
02:22:49,700 --> 02:22:53,700
And you know I mean we could sort of fake it out by having it do.

2887
02:23:04,100 --> 02:23:05,100
Something like this.

2888
02:23:11,200 --> 02:23:12,400
Maybe I'll do it the other way around.

2889
02:23:21,500 --> 02:23:23,100
You know, I'm not going to do it, it's too much.

2890
02:23:23,500 --> 02:23:28,400
You'll just have to bear with me or believe me when I say that.

2891
02:23:28,400 --> 02:23:32,800
That's what that code does because again go ahead and

2892
02:23:37,400 --> 02:23:40,100
Because this is still going to be the simplest way I think is just to

2893
02:23:40,100 --> 02:23:40,900
show it, right?

2894
02:23:41,000 --> 02:23:41,900
So you can see here.

2895
02:23:41,900 --> 02:23:43,800
It's loading in the address, it's not

2896
02:23:46,300 --> 02:23:49,200
When it does this Advance by zero, that's not going to do anything,

2897
02:23:49,200 --> 02:23:49,700
right?

2898
02:23:49,800 --> 02:23:51,300
It's pretty much entirely.

2899
02:23:54,400 --> 02:23:55,600
Sorry allergy season.

2900
02:23:56,300 --> 02:23:58,900
It's pretty much just going to load that in its going to advance it by

2901
02:23:58,900 --> 02:23:59,800
0 and then it

2902
02:24:00,000 --> 02:24:01,300
Load that in and call through it right.

2903
02:24:01,300 --> 02:24:02,300
That's all it's doing.

2904
02:24:03,400 --> 02:24:06,000
So it's not particularly interesting, it's not it's really just

2905
02:24:06,000 --> 02:24:07,300
calling directly to that address.

2906
02:24:07,900 --> 02:24:10,800
So let's take a look at what actually happens when we do that, right.

2907
02:24:10,800 --> 02:24:12,800
When we actually do that, we come through here, right?

2908
02:24:12,800 --> 02:24:15,300
We end up with that function pointer and we're going to make a call

2909
02:24:15,300 --> 02:24:18,700
into this here and lo and behold when we make a call and we're here in

2910
02:24:18,700 --> 02:24:19,700
our data segment.

2911
02:24:19,800 --> 02:24:23,400
What do we find the exact code that we expected happening?

2912
02:24:23,400 --> 02:24:27,400
Right here is the code that moves 5 into eax, right?

2913
02:24:28,000 --> 02:24:30,700
And of course, this is the caveat that I said I was going to have to

2914
02:24:30,700 --> 02:24:32,600
deal with and then we're going to return

2915
02:24:33,200 --> 02:24:33,700
Right.

2916
02:24:33,900 --> 02:24:35,300
That's exactly what we want to do.

2917
02:24:35,400 --> 02:24:38,300
Now, what you'll notice is even though this was totally valid code, I

2918
02:24:38,300 --> 02:24:42,200
get an exception here right, access violation, executing location.

2919
02:24:42,800 --> 02:24:44,900
Why are we getting that, right?

2920
02:24:45,100 --> 02:24:46,300
Why are we getting that?

2921
02:24:47,400 --> 02:24:50,500
Well, the reason that we're getting that is because we're technically

2922
02:24:50,500 --> 02:24:57,300
not allowed to execute data that we haven't pre told the operating

2923
02:24:57,300 --> 02:24:59,000
system is executable.

2924
02:24:59,600 --> 02:25:01,800
Okay, why is this?

2925
02:25:01,800 --> 02:25:04,500
Well, it's the same as the address space layout, randomization

2926
02:25:04,500 --> 02:25:05,000
problem.

2927
02:25:05,500 --> 02:25:09,100
The problem is that security people get kind of overzealous or maybe

2928
02:25:09,100 --> 02:25:12,300
you would say just zealous because they're not necessary overzealous,

2929
02:25:12,300 --> 02:25:14,800
they are trying to prevent real hacking problems.

2930
02:25:15,700 --> 02:25:16,800
One of the things that

2931
02:25:17,200 --> 02:25:23,100
Gpus added recently was the concept that in addition to memory Pages

2932
02:25:23,100 --> 02:25:26,400
being marked readable or writable, they could also be marked

2933
02:25:26,500 --> 02:25:27,300
executable.

2934
02:25:27,500 --> 02:25:32,200
And if a page with not considered executable stuff in it couldn't be

2935
02:25:32,200 --> 02:25:32,900
executed.

2936
02:25:33,000 --> 02:25:35,500
Now, why would you ever need this because you never do.

2937
02:25:35,900 --> 02:25:38,600
Well, the answer is because hacking, right?

2938
02:25:39,200 --> 02:25:40,200
No reason.

2939
02:25:40,200 --> 02:25:42,000
Will programmer ever really needs this?

2940
02:25:42,000 --> 02:25:45,400
Because if you wanted to things, start executing some where you wanted

2941
02:25:45,400 --> 02:25:47,000
to start, excuse summer, but

2942
02:25:47,200 --> 02:25:49,100
But to prevent against hacks.

2943
02:25:49,100 --> 02:25:52,700
It's obviously interesting and useful to be able to say only things

2944
02:25:52,700 --> 02:25:56,100
that the operating system has previously, said can be executed, should

2945
02:25:56,100 --> 02:25:56,600
be executed.

2946
02:25:56,600 --> 02:26:00,400
So if somebody manages to slip some kind of a hack in that should that

2947
02:26:00,400 --> 02:26:03,700
that you know, tries to call into a data segment somehow that will be

2948
02:26:03,700 --> 02:26:04,800
prevented right?

2949
02:26:04,900 --> 02:26:08,000
And it prevents like stacking because stack is data, right?

2950
02:26:08,000 --> 02:26:11,400
And so if you can get some code on the stack and then try to Branch to

2951
02:26:11,400 --> 02:26:14,700
it, the operating system will immediately fault you because that page

2952
02:26:14,700 --> 02:26:16,900
was not marked as executable its stack, its memory

2953
02:26:17,200 --> 02:26:17,600
Right?

2954
02:26:18,700 --> 02:26:20,000
And so that's what's going on here.

2955
02:26:20,000 --> 02:26:25,100
So how do we prevent the operating system from from doing this?

2956
02:26:25,100 --> 02:26:29,900
And, you know, get our code actually marked as executable.

2957
02:26:30,000 --> 02:26:33,900
That unfortunately is a little bit harder, certainly, but we can

2958
02:26:33,900 --> 02:26:35,900
certainly try, right?

2959
02:26:35,900 --> 02:26:39,700
And this is where things become a little harder to read, but we'll do

2960
02:26:39,700 --> 02:26:40,900
our best.

2961
02:26:40,900 --> 02:26:47,000
So what happens here is, basically, we need to sort of let

2962
02:26:47,100 --> 02:26:51,900
The compiler know that this data that we've got here needs to be

2963
02:26:51,900 --> 02:26:52,700
executable.

2964
02:26:52,800 --> 02:26:55,500
And the way that you do that in Windows is via the virtual protect

2965
02:26:55,500 --> 02:26:55,900
call.

2966
02:26:56,300 --> 02:26:59,700
You can see here the list of memory protection contexts.

2967
02:27:00,500 --> 02:27:04,100
I'm sorry, Constance, that Windows, accepts page.

2968
02:27:04,100 --> 02:27:06,400
Execute is the one we need.

2969
02:27:07,000 --> 02:27:10,100
So what we really want is, is sort of to tell Windows.

2970
02:27:10,100 --> 02:27:16,600
Hey, I need you to allow me to, you know, to execute some memory that

2971
02:27:16,600 --> 02:27:18,400
I'm going to specify, right?

2972
02:27:18,700 --> 02:27:19,800
So let's just do it.

2973
02:27:20,200 --> 02:27:22,300
Let's just do it and take it all the way.

2974
02:27:22,500 --> 02:27:25,100
So here's a virtual, a lock and a virtual protect.

2975
02:27:25,100 --> 02:27:27,000
I'm going to call both of them, right?

2976
02:27:28,500 --> 02:27:31,400
And this will actually set us up for the final thing I want to talk

2977
02:27:31,400 --> 02:27:34,400
about anyway, which is how the operating system and you agree on

2978
02:27:34,400 --> 02:27:36,000
locations of things, right.

2979
02:27:36,000 --> 02:27:38,600
And first, I'm going to blow my nose again because allergies are

2980
02:27:38,600 --> 02:27:38,900
awesome.

2981
02:27:44,400 --> 02:27:47,900
So first, we need to get some memory and then we need to Virtual

2982
02:27:47,900 --> 02:27:48,600
protect it.

2983
02:27:48,800 --> 02:27:51,500
Although actually, I suppose, I could probably try to just virtual

2984
02:27:51,500 --> 02:27:52,200
protect the page.

2985
02:27:52,200 --> 02:27:55,700
I don't miss any to allocate it, I could just say, let's virtual

2986
02:27:55,700 --> 02:27:57,500
protect the code 45 page.

2987
02:27:57,500 --> 02:28:01,500
I just don't know if it's smart enough to take the base of that

2988
02:28:01,500 --> 02:28:05,200
address describe, the starting page of the region whose access

2989
02:28:05,200 --> 02:28:07,600
protection as we change all pages, in The specified region must be

2990
02:28:07,600 --> 02:28:10,700
within the same Reserve region, Al-Qaeda members Irv

2991
02:28:11,900 --> 02:28:14,200
They can't span adjacent Reserve region.

2992
02:28:14,200 --> 02:28:18,100
So the problem here, the reason I can't really use Virtual protected

2993
02:28:18,100 --> 02:28:21,600
because I don't know where the base of the allocated ranges.

2994
02:28:21,900 --> 02:28:23,800
So I'm basically going to have to do something like this.

2995
02:28:24,000 --> 02:28:26,200
I'm going to have to call the operating system and get a page of

2996
02:28:26,200 --> 02:28:26,600
memory.

2997
02:28:26,700 --> 02:28:29,400
I'm then going to have to protect that memory, as being legal to

2998
02:28:29,400 --> 02:28:32,900
execute, I'm going to have to copy the code, 45 code into their,

2999
02:28:33,300 --> 02:28:33,800
right?

3000
02:28:33,800 --> 02:28:35,100
And then I can jump to it.

3001
02:28:37,000 --> 02:28:37,900
So let's do that.

3002
02:28:39,500 --> 02:28:43,500
Here's Mike are unsigned code, 45.

3003
02:28:44,700 --> 02:28:47,300
I'm going to get it from virtual a lock, right?

3004
02:28:47,600 --> 02:28:51,300
That's not the way this actually works but you know, that's basically

3005
02:28:51,300 --> 02:28:52,900
we're going to do right.

3006
02:28:53,400 --> 02:28:55,700
Then what I'm going to do is I'm going to Virtual protect that page

3007
02:28:56,200 --> 02:29:00,000
and then what I'm going to do is I'm going to copy the bytes that I

3008
02:29:00,000 --> 02:29:01,600
actually need in there.

3009
02:29:02,200 --> 02:29:02,600
Okay.

3010
02:29:02,900 --> 02:29:04,000
So I'm going to do this.

3011
02:29:16,700 --> 02:29:20,200
Okay, so let's look up the function calls, I need.

3012
02:29:20,200 --> 02:29:21,400
So here's virtual a lock.

3013
02:29:26,300 --> 02:29:27,500
And here's the prototype for that.

3014
02:29:27,500 --> 02:29:28,800
I'm going to cut and paste that in here.

3015
02:29:40,600 --> 02:29:41,500
Just so we can see it.

3016
02:29:43,800 --> 02:29:45,700
So, we have a void.

3017
02:29:47,000 --> 02:29:48,000
Virtual lock.

3018
02:29:49,100 --> 02:29:50,500
Have a void star LP address.

3019
02:29:50,500 --> 02:29:53,100
I'm just translating the

3020
02:29:56,100 --> 02:29:57,100
for lack of, I don't know.

3021
02:29:57,100 --> 02:29:58,400
The the correct term.

3022
02:29:58,400 --> 02:29:59,800
I'm translating the

3023
02:30:00,200 --> 02:30:01,700
Hungarian notation, if you will.

3024
02:30:05,400 --> 02:30:07,600
into saying types, temporarily

3025
02:30:12,200 --> 02:30:13,200
Here's the virtual Alec.

3026
02:30:13,200 --> 02:30:15,200
All right, that we actually need.

3027
02:30:22,500 --> 02:30:23,000
There we go.

3028
02:30:24,500 --> 02:30:26,300
And then we also need that virtual protect call.

3029
02:30:27,600 --> 02:30:28,000
Oh wait.

3030
02:30:28,000 --> 02:30:28,100
No.

3031
02:30:28,100 --> 02:30:29,400
We don't, you know why?

3032
02:30:29,400 --> 02:30:34,100
Because we can actually pass the protection to it directly.

3033
02:30:34,200 --> 02:30:35,800
So we only need virtuality.

3034
02:30:35,900 --> 02:30:37,000
That's all we would need.

3035
02:30:38,400 --> 02:30:39,100
And then,

3036
02:30:41,400 --> 02:30:42,300
We should be good to go.

3037
02:30:42,900 --> 02:30:46,300
So size T in this case we need the definition of.

3038
02:30:46,900 --> 02:30:50,500
So what I'm going to do is I'm going to cheat again and use the

3039
02:30:50,800 --> 02:30:52,000
previous wind project here.

3040
02:30:52,300 --> 02:30:54,700
Sure we'll save that go ahead.

3041
02:30:56,500 --> 02:30:59,700
Let's go ahead and look that up when through and project.

3042
02:31:00,000 --> 02:31:04,000
So we need to know what is size t.

3043
02:31:06,200 --> 02:31:07,100
Go to definition.

3044
02:31:08,600 --> 02:31:09,600
And so there it is.

3045
02:31:10,200 --> 02:31:13,400
So it's really just one of these underscore underscore in 64 is the

3046
02:31:13,400 --> 02:31:14,200
unsigned.

3047
02:31:14,800 --> 02:31:16,300
So let's go ahead and put that in there.

3048
02:31:16,400 --> 02:31:16,900
There we go.

3049
02:31:17,300 --> 02:31:21,100
And so now we have the function prototype for virtual Alec, I'm going

3050
02:31:21,100 --> 02:31:23,800
to call it, I don't need a base address.

3051
02:31:24,500 --> 02:31:26,700
I the size can just be one page.

3052
02:31:26,700 --> 02:31:32,000
Let's say in fact we really only need 64 bytes but it'll round it up.

3053
02:31:32,800 --> 02:31:36,100
So you know I don't know it's really going to allocate the page anyway

3054
02:31:36,100 --> 02:31:37,900
might as well put one in there the out.

3055
02:31:38,000 --> 02:31:39,400
patient type in this case,

3056
02:31:41,800 --> 02:31:48,300
We're going to need to remember allocation allocate pages and we need,

3057
02:31:48,300 --> 02:31:49,700
we want to actually commit.

3058
02:31:49,900 --> 02:31:52,700
So we want these pages to actually be used for us.

3059
02:31:52,700 --> 02:31:54,800
So we need this constant, right?

3060
02:31:55,700 --> 02:31:56,400
So there it is.

3061
02:31:57,400 --> 02:32:01,000
And then finally, we want the correct memory protection.

3062
02:32:01,800 --> 02:32:03,300
We don't need any of that stuff.

3063
02:32:03,400 --> 02:32:07,800
So, we just need my protection constants here, page.

3064
02:32:07,800 --> 02:32:09,000
We just want everything, right?

3065
02:32:09,000 --> 02:32:10,800
We want to be able to read, write and execute.

3066
02:32:11,300 --> 02:32:12,300
So we want everything.

3067
02:32:12,800 --> 02:32:15,100
I don't know if that's a, if they have a convenient, one of those,

3068
02:32:15,100 --> 02:32:15,800
let's see.

3069
02:32:16,300 --> 02:32:16,700
Read.

3070
02:32:16,700 --> 02:32:21,900
Write read only no access execute, right?

3071
02:32:21,900 --> 02:32:24,300
Copy execute, read, right.

3072
02:32:25,700 --> 02:32:29,200
Execute read-only or read, write access to the committed region.

3073
02:32:29,700 --> 02:32:31,600
So this is the one that we want, I believe.

3074
02:32:31,800 --> 02:32:33,100
Let's go ahead and paste that in there.

3075
02:32:33,900 --> 02:32:38,800
Alright, so now I'm going to compile, we don't need this anymore, it's

3076
02:32:38,800 --> 02:32:39,200
gone.

3077
02:32:41,200 --> 02:32:46,500
And what you can see here is we pretty much are good to go in every

3078
02:32:46,500 --> 02:32:48,800
respect, except for one slight problem.

3079
02:32:49,400 --> 02:32:55,400
And that is that we don't currently have the the

3080
02:32:55,500 --> 02:32:57,600
The way to link with the virtual lock.

3081
02:32:57,600 --> 02:32:59,700
All right, so that's what we

3082
02:33:00,000 --> 02:33:03,700
Have to figure out.

3083
02:33:03,800 --> 02:33:04,600
Well, I guess, you know what?

3084
02:33:04,600 --> 02:33:05,400
We probably even do.

3085
02:33:05,400 --> 02:33:06,400
Let me just see if we do.

3086
02:33:07,200 --> 02:33:08,100
We should actually

3087
02:33:12,200 --> 02:33:14,700
Yeah, I think I think we actually can I take it all back?

3088
02:33:16,800 --> 02:33:19,800
So in theory, we probably can and I'll explain this in one second.

3089
02:33:19,800 --> 02:33:20,800
I apologize for

3090
02:33:22,900 --> 02:33:25,900
This is the stuff I want to get into, but I don't opes.

3091
02:33:35,600 --> 02:33:40,800
Let's see referenced in functions main sewer to start up unresolved

3092
02:33:40,800 --> 02:33:41,100
Sterno.

3093
02:33:41,100 --> 02:33:43,600
So it does actually need to specify Colonel pretty too.

3094
02:33:44,200 --> 02:33:45,000
So I will.

3095
02:33:45,400 --> 02:33:48,200
And so let me just and again, I apologize for getting a little bit

3096
02:33:48,200 --> 02:33:51,200
ahead but I want to finish talking about the execution part and then

3097
02:33:51,200 --> 02:33:55,600
we'll move on to all the stuff that I just did in a second.

3098
02:33:56,100 --> 02:33:58,500
So let's go ahead and get ourselves.

3099
02:33:58,500 --> 02:34:01,500
The one other thing we need and I'm going to again, keep us to only

3100
02:34:01,500 --> 02:34:04,600
stuff that's actually in our directory so that we're never going out.

3101
02:34:04,800 --> 02:34:07,400
Out of it so we can look at literally everything that there is.

3102
02:34:08,300 --> 02:34:10,600
So, let's go ahead and grab that out of here.

3103
02:34:10,700 --> 02:34:14,400
Let me see if I can find in here.

3104
02:34:15,300 --> 02:34:16,700
I don't know that it's in here.

3105
02:34:16,700 --> 02:34:19,100
I want the platform SDK.

3106
02:34:20,100 --> 02:34:21,900
Let's see it in here.

3107
02:34:27,600 --> 02:34:31,600
All right, I think that's sufficient for our purposes.

3108
02:34:32,000 --> 02:34:34,200
Let's copy this.

3109
02:34:37,900 --> 02:34:41,200
fell out and in to

3110
02:34:47,600 --> 02:34:48,200
All right.

3111
02:34:50,100 --> 02:34:52,900
Okay, so again, you'll have to bear with me for one second because I

3112
02:34:52,900 --> 02:34:55,300
want to tackle this part separately.

3113
02:34:56,800 --> 02:34:58,800
So we're going to talk about Libs and so on.

3114
02:35:00,400 --> 02:35:04,600
All right, so now in theory, if I jump back here and again, like I

3115
02:35:04,600 --> 02:35:05,700
said, I'll explain all of that.

3116
02:35:06,200 --> 02:35:07,200
I just don't want.

3117
02:35:07,300 --> 02:35:09,500
I want to show you the executed code.

3118
02:35:09,500 --> 02:35:12,600
First part to finish off that last part we were doing.

3119
02:35:14,100 --> 02:35:17,700
So let's go ahead and take a look at what this code does now.

3120
02:35:17,700 --> 02:35:20,700
And unfortunately, it gets a lot more complicated like I said, but we

3121
02:35:20,700 --> 02:35:23,600
have no choice because I don't really know if there's any way to

3122
02:35:23,600 --> 02:35:26,200
specify two maybe there.

3123
02:35:26,400 --> 02:35:29,000
Is a way to specify to the loader that you want execution prevention.

3124
02:35:29,000 --> 02:35:29,900
Turn protection.

3125
02:35:29,900 --> 02:35:31,600
Turned off, they're probably somewhere.

3126
02:35:31,600 --> 02:35:34,400
But this is the fastest way I could think of, on stream to do it.

3127
02:35:34,800 --> 02:35:37,200
So we can see down here where we actually do our function.

3128
02:35:37,200 --> 02:35:41,200
Call all of this right here is the code again unoptimized code, but

3129
02:35:41,200 --> 02:35:46,000
code nonetheless, to just move to do the construction of the the code

3130
02:35:46,000 --> 02:35:46,400
in memory.

3131
02:35:46,400 --> 02:35:49,600
So let's watch it happen, right here, right here is our call to

3132
02:35:49,600 --> 02:35:53,900
Virtual a lock and that call is going to return in our ax the pointer

3133
02:35:53,900 --> 02:35:54,700
that we got.

3134
02:35:55,100 --> 02:35:56,100
So here is in

3135
02:35:56,300 --> 02:35:58,500
Theory that pointer, right?

3136
02:36:00,100 --> 02:36:03,300
And now we're going to actually start moving stuff in there and we

3137
02:36:03,300 --> 02:36:04,900
should be able to actually look at it.

3138
02:36:04,900 --> 02:36:05,300
Right?

3139
02:36:05,400 --> 02:36:08,900
And I if I was smart, I would have saved that but we know it's our SP

3140
02:36:08,900 --> 02:36:10,500
+ 0, x 20, right?

3141
02:36:10,500 --> 02:36:11,200
According to this.

3142
02:36:11,300 --> 02:36:15,000
So it should be, at least it should be in there, right?

3143
02:36:15,400 --> 02:36:16,000
Let me actually

3144
02:36:18,100 --> 02:36:20,500
Let me get that out in a little bit more, same fashion.

3145
02:36:21,100 --> 02:36:24,900
All right, so let's try that one more time so I can make it easier on

3146
02:36:24,900 --> 02:36:25,500
myself.

3147
02:36:25,900 --> 02:36:27,000
So, here's our call.

3148
02:36:27,000 --> 02:36:31,600
Again, should be our call, our first call out to Virtual Alec, right?

3149
02:36:32,200 --> 02:36:36,300
So in here, where we are on the stack right now, if we look, we're in

3150
02:36:36,300 --> 02:36:39,400
kernel32 inside virtual a lock, right?

3151
02:36:40,000 --> 02:36:41,300
So I'm going to jump out of that.

3152
02:36:41,300 --> 02:36:44,300
That's after the virtual Alec has completed our X.

3153
02:36:44,300 --> 02:36:47,500
Now, the register itself has in theory.

3154
02:36:47,700 --> 02:36:51,400
Anyway, the pointer to the page that got allocated.

3155
02:36:52,000 --> 02:36:56,700
So now if I take a look and I do a car unsigned and I look at that

3156
02:36:56,900 --> 02:36:58,700
location, right?

3157
02:36:58,700 --> 02:37:03,600
So there's looking at this location and I look at, you know, say the

3158
02:37:03,600 --> 02:37:08,200
first 16 bytes of it, that's the first, that's the page that Windows

3159
02:37:08,200 --> 02:37:09,400
allocated for us.

3160
02:37:09,800 --> 02:37:12,400
Now, what I'm going to do is Step through the code that literally all

3161
02:37:12,400 --> 02:37:16,900
it's doing is filling this out with the code, so you can see it doing

3162
02:37:16,900 --> 02:37:17,500
that here.

3163
02:37:17,600 --> 02:37:20,200
Is our B 805 C3, right?

3164
02:37:20,200 --> 02:37:21,200
And that's the end of it.

3165
02:37:21,200 --> 02:37:22,300
So, it stops there.

3166
02:37:22,800 --> 02:37:26,500
This is just untouched right now.

3167
02:37:26,500 --> 02:37:28,800
We're going to call into that memory.

3168
02:37:29,000 --> 02:37:32,100
And this time when we get there again, it will look exactly the same

3169
02:37:32,100 --> 02:37:35,000
as it does before but now notes and things.

3170
02:37:35,900 --> 02:37:41,300
First of all, you can see that this time when we step it works, right?

3171
02:37:41,300 --> 02:37:42,500
We've done nothing differently.

3172
02:37:42,500 --> 02:37:45,800
Now the only thing is instead of it being in memory, That was supposed

3173
02:37:45,800 --> 02:37:47,600
to be part of our data segment which will

3174
02:37:47,700 --> 02:37:50,400
Those does not set the execution bid on when it loads it into memory

3175
02:37:50,400 --> 02:37:53,100
as part of our executable this time.

3176
02:37:53,200 --> 02:37:55,000
We did it in memory that we allocated.

3177
02:37:55,000 --> 02:37:59,500
And when we allocated it, we told Windows specifically, hey, this is

3178
02:37:59,500 --> 02:38:03,000
going to be executed, so allow that set the memory protection on this

3179
02:38:03,000 --> 02:38:06,000
page so that you will allow that the processor will not throw an

3180
02:38:06,000 --> 02:38:07,800
exception when it happens, right?

3181
02:38:09,200 --> 02:38:13,200
We executed it, it did exactly what we wanted to do, right?

3182
02:38:13,200 --> 02:38:14,900
And now we're doing a return call.

3183
02:38:15,600 --> 02:38:16,600
We get back here.

3184
02:38:16,800 --> 02:38:20,100
We finally complete the thing that we wanted to do which was actually

3185
02:38:20,100 --> 02:38:22,400
setting our Global variable equal to 5.

3186
02:38:22,400 --> 02:38:25,400
And remember we can actually now look and verify that, that is the

3187
02:38:25,400 --> 02:38:25,900
case.

3188
02:38:29,500 --> 02:38:32,000
And lo and behold, there is our five.

3189
02:38:32,700 --> 02:38:35,000
So, what we have done now, literally,

3190
02:38:36,200 --> 02:38:40,000
Is we actually made essentially our own compiler, right?

3191
02:38:40,000 --> 02:38:41,100
We made something that can do.

3192
02:38:41,100 --> 02:38:45,800
Exactly one thing, which is create a function that can return five.

3193
02:38:46,400 --> 02:38:47,900
So it's not a very good compiler.

3194
02:38:49,500 --> 02:38:50,400
It's not really compiler.

3195
02:38:50,400 --> 02:38:52,200
I suppose it's a code generator.

3196
02:38:52,500 --> 02:38:56,400
Let's say they can generate exactly one piece of code and that piece

3197
02:38:56,400 --> 02:38:59,000
of code is something that returns five but wait.

3198
02:39:00,400 --> 02:39:01,300
There's more.

3199
02:39:03,800 --> 02:39:06,500
Is it really something that can only return five?

3200
02:39:06,700 --> 02:39:09,300
Well, not really, right?

3201
02:39:09,700 --> 02:39:14,700
Because we kind of know that this 05 right here is the constant that's

3202
02:39:14,700 --> 02:39:15,700
getting returned.

3203
02:39:15,900 --> 02:39:20,100
The Intel encoding happens to encode that that return as an immediate

3204
02:39:20,200 --> 02:39:23,100
which means that the instruction itself, encodes the value that will

3205
02:39:23,100 --> 02:39:24,300
be moved to the register.

3206
02:39:24,800 --> 02:39:28,500
So really what we've done is a compiler that can generate a return of

3207
02:39:28,500 --> 02:39:29,400
any bite.

3208
02:39:30,200 --> 02:39:31,200
That you want?

3209
02:39:32,300 --> 02:39:32,900
Right?

3210
02:39:34,200 --> 02:39:36,400
And furthermore, it's really more than a bite.

3211
02:39:36,500 --> 02:39:38,000
Because this one, two, three, four.

3212
02:39:38,000 --> 02:39:39,500
Here is really 500.

3213
02:39:39,700 --> 02:39:43,100
This is the 32-bit value in coded as an immediate into the

3214
02:39:43,100 --> 02:39:45,200
instruction, that is getting returned.

3215
02:39:46,600 --> 02:39:48,600
so, if we wanted to,

3216
02:39:50,100 --> 02:39:53,800
We could produce a piece of code that returns any value by patching

3217
02:39:53,800 --> 02:39:56,900
that location equal to the thing.

3218
02:39:56,900 --> 02:39:57,900
We wanted to return.

3219
02:39:58,100 --> 02:40:01,400
Let's prove it right here.

3220
02:40:01,400 --> 02:40:02,600
Is an in Star.

3221
02:40:04,000 --> 02:40:08,100
I'm going to say that this location cure this code for 51.

3222
02:40:08,200 --> 02:40:11,600
I want to treat it as an in Star and I'm going to put the 5 in there,

3223
02:40:12,400 --> 02:40:12,900
okay?

3224
02:40:13,400 --> 02:40:16,700
So now let's dip in and see what happens to that particular piece of

3225
02:40:16,700 --> 02:40:19,700
code, right here, we come down.

3226
02:40:21,900 --> 02:40:23,600
And let's take a look at what we get.

3227
02:40:24,000 --> 02:40:29,400
You can see our in our hexadecimal display here, be 85 C3, right?

3228
02:40:29,700 --> 02:40:33,300
So that's the old style, let's go ahead and change that now to some

3229
02:40:33,300 --> 02:40:34,200
other variable.

3230
02:40:34,300 --> 02:40:39,400
Let's say 15 and let's do the same thing we come through here.

3231
02:40:40,000 --> 02:40:41,400
We take a look at what we get

3232
02:40:45,400 --> 02:40:46,100
Oh, you know what?

3233
02:40:46,100 --> 02:40:50,100
I got to remember since address base layer is randomization.

3234
02:40:50,300 --> 02:40:53,100
Every time I call this, it's going to every time I call virtual Alec,

3235
02:40:53,100 --> 02:40:54,200
it could give me back something different.

3236
02:40:54,200 --> 02:40:56,100
There it gave me back that address.

3237
02:40:56,100 --> 02:40:58,700
For example, instead of gotta, I gotta look at the right address every

3238
02:40:58,700 --> 02:40:59,900
time, right?

3239
02:41:01,800 --> 02:41:06,300
So here we go and we fill it out B8 and now you can see we put 15 in

3240
02:41:06,300 --> 02:41:07,700
here, right?

3241
02:41:07,700 --> 02:41:11,900
Instead, there's the 15 and now what we're going to do when we call

3242
02:41:11,900 --> 02:41:17,600
into our function you can see Hey look, it's no longer a move five,

3243
02:41:17,700 --> 02:41:18,900
it's a move 15.

3244
02:41:19,200 --> 02:41:23,500
So when it returns, it's going to return 15 instead of 5.

3245
02:41:23,500 --> 02:41:28,200
And when it moves out into our Global variable, now, the result of our

3246
02:41:28,200 --> 02:41:31,000
code is going to be something different entirely.

3247
02:41:32,100 --> 02:41:33,100
So here we go.

3248
02:41:33,200 --> 02:41:34,300
Looking at that code.

3249
02:41:39,600 --> 02:41:40,400
There's our 15.

3250
02:41:41,800 --> 02:41:44,100
So now we really do have a real code generator.

3251
02:41:44,100 --> 02:41:47,700
In a sense, we can generate something that returns any 32-bit value,

3252
02:41:47,700 --> 02:41:48,200
right?

3253
02:41:48,200 --> 02:41:51,800
So as long as you wanted to implement a language, that's only feature

3254
02:41:51,800 --> 02:41:53,700
that it could do is return a value.

3255
02:41:53,700 --> 02:41:55,600
And that value has to be a 32-bit number.

3256
02:41:56,000 --> 02:41:59,300
You've written the compiler for it essentially already, right?

3257
02:41:59,300 --> 02:41:59,800
That's what we've

3258
02:42:00,700 --> 02:42:03,900
Okay, it's pretty cool when you think about it because it's really no

3259
02:42:03,900 --> 02:42:06,600
more complicated than that to do on the Fly code generation.

3260
02:42:06,800 --> 02:42:09,500
This is an on-the-fly code generator it.

3261
02:42:09,500 --> 02:42:13,400
In fact, can generate any code that you want, if you started giving it

3262
02:42:13,400 --> 02:42:16,100
some ability to Output more, than just this simple set of

3263
02:42:16,100 --> 02:42:19,700
instructions, you can now build any x64 code, you want.

3264
02:42:19,700 --> 02:42:20,300
There's nothing.

3265
02:42:20,300 --> 02:42:21,600
You can't do anything.

3266
02:42:21,600 --> 02:42:24,400
You want to do in here you could do right?

3267
02:42:29,200 --> 02:42:31,800
Now, I don't know if I've lost everyone at this point or if everyone

3268
02:42:31,800 --> 02:42:34,300
is still on board, I'm hoping that everyone still on board.

3269
02:42:34,300 --> 02:42:38,100
Let's go ahead and push it a little bit further and just sort of take

3270
02:42:38,100 --> 02:42:40,200
it to its logical conclusions.

3271
02:42:40,200 --> 02:42:43,400
Before talking about the virtual a lock part of this and how the

3272
02:42:43,400 --> 02:42:47,300
operating system and dlls and that sort of stuff, get bound together,

3273
02:42:47,600 --> 02:42:48,000
right?

3274
02:42:49,300 --> 02:42:52,100
So in here, I have my code 45, right?

3275
02:42:52,100 --> 02:42:55,200
One of the things that's interesting about this code, 45 is I'm

3276
02:42:55,200 --> 02:42:57,800
generating some code in here.

3277
02:42:58,700 --> 02:43:02,800
Could that code call my code, right?

3278
02:43:02,900 --> 02:43:05,700
What if I needed that code to call something itself?

3279
02:43:07,200 --> 02:43:07,900
You know what I'm saying?

3280
02:43:09,300 --> 02:43:10,700
How would that work, right?

3281
02:43:10,900 --> 02:43:14,200
So let's go ahead and get our five back in here.

3282
02:43:14,500 --> 02:43:14,900
Okay.

3283
02:43:15,100 --> 02:43:17,400
And let's go ahead and take a look right here.

3284
02:43:17,500 --> 02:43:21,800
At what happens if we want to call five at say, this point in our

3285
02:43:21,800 --> 02:43:23,000
program, right?

3286
02:43:23,100 --> 02:43:25,200
So right here, we want to call five.

3287
02:43:25,200 --> 02:43:29,800
We want to get the result of five back or whatever.

3288
02:43:31,500 --> 02:43:34,500
Actually, let's see, how would we want to do this?

3289
02:43:34,700 --> 02:43:35,900
So I want to

3290
02:43:42,100 --> 02:43:42,800
Oh, and you know what?

3291
02:43:42,800 --> 02:43:44,800
This doesn't have to happen this way anymore, does it?

3292
02:43:45,500 --> 02:43:49,200
Yeah, so I'm just trying to think of how I want to do this.

3293
02:43:49,600 --> 02:43:51,400
So let's say what we wanted to do.

3294
02:43:51,400 --> 02:43:54,900
Oh you know what, I just realized, this is what we'll do, this is

3295
02:43:54,900 --> 02:43:55,700
totally what we'll do.

3296
02:43:56,900 --> 02:44:02,600
So let's say that I wanted to return, whatever, I get back from five.

3297
02:44:03,000 --> 02:44:05,700
Okay, so there we go, right?

3298
02:44:05,800 --> 02:44:09,100
So let's take a look at what actually happens in that code right

3299
02:44:09,100 --> 02:44:09,600
there.

3300
02:44:09,700 --> 02:44:10,200
Okay.

3301
02:44:11,900 --> 02:44:13,700
So now I'm going to step into this code.

3302
02:44:13,800 --> 02:44:14,900
I'm going to come down here.

3303
02:44:15,400 --> 02:44:19,100
You can see when I'm doing this sort of operation stuff.

3304
02:44:19,100 --> 02:44:22,000
You can, you can see the move, our ax, you can see the move, this is

3305
02:44:22,000 --> 02:44:26,600
the call to the function 5, right here is the call to that function,

3306
02:44:27,000 --> 02:44:27,500
right?

3307
02:44:29,600 --> 02:44:32,500
And it's a little bit complicated if you take a look at it, right,

3308
02:44:32,900 --> 02:44:36,800
because What's Happening Here is is really kind of confusing, right?

3309
02:44:37,300 --> 02:44:38,800
And let's try to break down, why?

3310
02:44:38,800 --> 02:44:40,100
It's why it's confusing.

3311
02:44:41,600 --> 02:44:46,700
What's Happening Here is we're calling essentially relative.

3312
02:44:46,800 --> 02:44:48,700
How do I know that we're calling your essentially relative?

3313
02:44:48,800 --> 02:44:51,700
Well, if you take a look at what's Happening Here, the bites for this

3314
02:44:51,700 --> 02:44:55,100
call in no way in code, this address, right?

3315
02:44:55,300 --> 02:44:57,300
So here's the address that we're calling.

3316
02:44:57,700 --> 02:44:59,700
And here's the code B for the instruction.

3317
02:45:00,500 --> 02:45:03,200
I would expect to see this in there and it ain't in there.

3318
02:45:03,700 --> 02:45:07,500
Now, what I do see instead is an FF FF FF 7 8.

3319
02:45:07,600 --> 02:45:12,500
That looks suspiciously like a negative number in two's complement,

3320
02:45:12,700 --> 02:45:13,400
right?

3321
02:45:13,900 --> 02:45:15,200
It sure does to me.

3322
02:45:15,200 --> 02:45:18,900
Anyway and furthermore, since this is little-endian it's really going

3323
02:45:18,900 --> 02:45:20,100
to look like this, right?

3324
02:45:20,100 --> 02:45:23,100
Because the smallest bite comes first which is the 78, then the FF and

3325
02:45:23,100 --> 02:45:24,100
the fsma I've have.

3326
02:45:24,200 --> 02:45:27,100
So it's really this value, right?

3327
02:45:27,800 --> 02:45:29,800
And it's that value I suspect.

3328
02:45:30,400 --> 02:45:33,300
As an integer, which is a negative 136.

3329
02:45:33,700 --> 02:45:39,700
Now, if we look at where we're at 13, f59 10, B, 3, right?

3330
02:45:39,700 --> 02:45:42,200
If I look at that, hexadecimal value,

3331
02:45:43,700 --> 02:45:44,400
Here it is.

3332
02:45:46,300 --> 02:45:46,900
Right.

3333
02:45:47,000 --> 02:45:52,600
If I look at that hexadecimal value and I want to subtract 136 from

3334
02:45:52,600 --> 02:45:53,700
it, right?

3335
02:45:53,700 --> 02:45:55,600
I would get a different hexadecimal value.

3336
02:45:55,700 --> 02:45:57,000
What hexadecimal value do?

3337
02:45:57,000 --> 02:46:05,200
I get I get 13f 5910 to be write something like this.

3338
02:46:05,600 --> 02:46:06,800
I think, right?

3339
02:46:06,800 --> 02:46:07,600
Is that what I get?

3340
02:46:07,600 --> 02:46:07,900
I don't know.

3341
02:46:07,900 --> 02:46:09,300
Did I type that incorrectly?

3342
02:46:10,400 --> 02:46:14,800
13 f59, 10 B 3, right?

3343
02:46:15,200 --> 02:46:15,800
Okay, yeah.

3344
02:46:16,000 --> 02:46:19,000
So I know that I'm calling this address, right?

3345
02:46:19,000 --> 02:46:22,300
And so if I look at it here, oops.

3346
02:46:24,500 --> 02:46:26,000
And I look at the location.

3347
02:46:29,500 --> 02:46:31,000
And I subtract the two of these.

3348
02:46:31,800 --> 02:46:32,400
There we go.

3349
02:46:34,200 --> 02:46:35,700
You can kind of see that.

3350
02:46:35,700 --> 02:46:39,000
It's almost what I would expect, right?

3351
02:46:39,100 --> 02:46:47,700
It's like, okay, so I have a negative 136 and the difference between

3352
02:46:47,700 --> 02:46:51,300
the thing that this is saying I'm jumping to and the instruction that

3353
02:46:51,300 --> 02:46:55,100
I'm currently on is - 131.

3354
02:46:55,400 --> 02:46:59,100
So it's almost right but not quite but so I

3355
02:46:59,300 --> 02:47:03,700
Sort of see how it's doing this encoding, I guess, right.

3356
02:47:04,200 --> 02:47:05,400
But not quite.

3357
02:47:05,400 --> 02:47:06,900
So, just from looking at it.

3358
02:47:06,900 --> 02:47:10,000
It's a little bit hard to reverse engineer, but it's pretty clear that

3359
02:47:10,000 --> 02:47:14,200
it's some kind of a relative jump, right?

3360
02:47:14,200 --> 02:47:17,400
It's like, hey, I know that I'm jumping to here.

3361
02:47:17,600 --> 02:47:22,400
This is where the instruction is, it really looks pretty darn close.

3362
02:47:22,500 --> 02:47:23,700
So why is it wrong?

3363
02:47:23,700 --> 02:47:27,100
And the answer is like, well the difference between these 13 6131.

3364
02:47:27,300 --> 02:47:27,900
Oh hey.

3365
02:47:27,900 --> 02:47:29,100
Look it

3366
02:47:29,200 --> 02:47:31,600
Happens to be 5 b, right?

3367
02:47:31,700 --> 02:47:36,200
So, it just so happens that the instruction is encoded based on after

3368
02:47:36,200 --> 02:47:41,900
the 5 b hits, right after I suck up those five, bytes, then I get that

3369
02:47:41,900 --> 02:47:44,300
encoding right then, I get the value.

3370
02:47:45,600 --> 02:47:48,900
So this is a relative call that calls relative to the instruction

3371
02:47:48,900 --> 02:47:49,900
pointer, right?

3372
02:47:50,400 --> 02:47:53,500
So, if we wanted to generate code ourselves and we know that we have

3373
02:47:53,500 --> 02:47:56,100
to write that code into a memory page somewhere.

3374
02:47:56,700 --> 02:47:59,800
Obviously, we can't use this call instruction.

3375
02:48:00,100 --> 02:48:04,600
Because of this call instruction is going to have to embed a relative

3376
02:48:04,600 --> 02:48:05,500
call in it.

3377
02:48:05,500 --> 02:48:09,900
And we don't know where our virtual page will be relative to this

3378
02:48:09,900 --> 02:48:10,300
page.

3379
02:48:10,300 --> 02:48:12,300
So we can't very well do anything about it.

3380
02:48:12,300 --> 02:48:16,200
Now we could hope that when we allocate the virtual page we will end

3381
02:48:16,200 --> 02:48:20,700
up being able to put them you know, close enough together.

3382
02:48:20,700 --> 02:48:23,400
Something like this that we could still use a relative call but

3383
02:48:23,400 --> 02:48:26,400
obviously it's a little dicey, right?

3384
02:48:28,100 --> 02:48:32,700
So what we'd much rather do is we'd probably rather have something

3385
02:48:33,100 --> 02:48:36,000
that can call sort of more absolutely but unfortunately it's pretty

3386
02:48:36,000 --> 02:48:39,900
hard to get something like that to work.

3387
02:48:40,300 --> 02:48:41,300
Sorry I get likes.

3388
02:48:41,300 --> 02:48:44,300
Get the compiler to output something like that so that we can look at

3389
02:48:44,300 --> 02:48:47,900
it because in all these cases it's going to be calling something

3390
02:48:49,000 --> 02:48:50,700
that's going to be pretty local in this case.

3391
02:48:50,800 --> 02:48:53,100
However we do have some guidance.

3392
02:48:54,600 --> 02:48:56,600
I suppose I can't set a breakpoint there.

3393
02:48:56,600 --> 02:48:57,200
Okay, there we go.

3394
02:48:58,900 --> 02:49:01,200
We know that this is going to call virtual a lock, right?

3395
02:49:01,200 --> 02:49:08,600
So here's a jump into into the virtual outcome, what you can see is

3396
02:49:08,600 --> 02:49:12,300
really, this is just a secondary jump which comes out here and then we

3397
02:49:12,300 --> 02:49:17,200
get another jump which is going to be to an address which is encoded

3398
02:49:17,500 --> 02:49:19,100
sort of more directly in here.

3399
02:49:19,100 --> 02:49:24,800
I suspect although still and I know this this this may still be a

3400
02:49:24,800 --> 02:49:27,600
relative jump 77 95d 328.

3401
02:49:28,700 --> 02:49:30,300
H, which is not the same here, right?

3402
02:49:30,300 --> 02:49:31,100
So, here we go.

3403
02:49:31,100 --> 02:49:32,000
Into another one.

3404
02:49:33,200 --> 02:49:34,200
Are we actually met?

3405
02:49:34,200 --> 02:49:35,900
And now we're actually in kernel-based.

3406
02:49:36,100 --> 02:49:37,400
So this is the code.

3407
02:49:37,400 --> 02:49:42,000
We actually wanted to call to here, which is 7 F EF like blah, blah

3408
02:49:42,000 --> 02:49:42,700
blah blah blah, right?

3409
02:49:42,700 --> 02:49:44,000
That's that's the actual

3410
02:49:45,500 --> 02:49:47,800
address that we were trying to call their that one.

3411
02:49:48,500 --> 02:49:51,900
Go ahead and switch that tax, a decimal View and if I step back out

3412
02:49:51,900 --> 02:49:57,700
here and I look at how that call was structured, unfortunately that

3413
02:49:57,700 --> 02:49:59,800
stepped out twice, I guess I shouldn't have done it that way.

3414
02:49:59,800 --> 02:50:01,000
Let me step in one more time.

3415
02:50:02,400 --> 02:50:03,000
There we go.

3416
02:50:04,500 --> 02:50:05,800
So there's the jump again.

3417
02:50:05,800 --> 02:50:08,400
The initial jump in the table and again we're going to talk about a

3418
02:50:08,400 --> 02:50:10,200
little bit of this little bit more.

3419
02:50:10,500 --> 02:50:11,800
Here's a secondary jump.

3420
02:50:12,000 --> 02:50:15,600
Here is the actual code that's going to be doing the virtual Alex

3421
02:50:15,600 --> 02:50:19,100
stuff and it does a secondary call in here, but it comes down to this

3422
02:50:19,100 --> 02:50:19,600
Rhett.

3423
02:50:21,600 --> 02:50:26,300
It's at the same location in both cases, 7fe FDA for 190.

3424
02:50:26,300 --> 02:50:28,800
So we know that that's the correct address still.

3425
02:50:29,000 --> 02:50:32,900
And so if we take a look at where that call is happening, oh I guess I

3426
02:50:32,900 --> 02:50:33,500
see what happened.

3427
02:50:33,500 --> 02:50:36,500
It returned there because those are the things we're jumps.

3428
02:50:36,500 --> 02:50:37,200
Not calls.

3429
02:50:37,400 --> 02:50:40,500
So they didn't modify the return address, but I found out the piece of

3430
02:50:40,500 --> 02:50:41,300
information I needed.

3431
02:50:41,300 --> 02:50:44,200
Which is that that particular location doesn't get modified with

3432
02:50:44,200 --> 02:50:44,600
about.

3433
02:50:44,600 --> 02:50:46,400
It doesn't get moved around.

3434
02:50:47,200 --> 02:50:50,500
So if we take a look at what's happening here, we're doing a jump to

3435
02:50:50,500 --> 02:50:51,100
this location.

3436
02:50:51,200 --> 02:50:53,100
Ation which again is not this.

3437
02:50:53,400 --> 02:50:56,200
Then we're doing a jump to this location.

3438
02:50:57,000 --> 02:50:59,800
That's basically reading out of this pointer.

3439
02:51:00,000 --> 02:51:04,200
It's here and that pointer has the location of virtual a lock, right?

3440
02:51:04,300 --> 02:51:07,100
The reason for the double indirection has to do with how dlls or

3441
02:51:07,100 --> 02:51:09,700
LinkedIn, we can talk about that again a little bit later.

3442
02:51:10,000 --> 02:51:14,300
So if I take a look at this, what's at this location?

3443
02:51:14,500 --> 02:51:21,000
What I should see again is a pointer to that virtual a lock function.

3444
02:51:21,600 --> 02:51:27,200
So if I take a look in here, see if I don't actually want that to be a

3445
02:51:27,200 --> 02:51:28,300
void star.

3446
02:51:37,100 --> 02:51:38,600
To be a void star star.

3447
02:51:38,800 --> 02:51:39,200
There we go.

3448
02:51:40,200 --> 02:51:42,800
So if I look at that void star star, I'm saying, what's at this

3449
02:51:42,800 --> 02:51:43,400
location?

3450
02:51:43,800 --> 02:51:45,300
And the answer is what's at this location?

3451
02:51:45,300 --> 02:51:48,900
Is this pointer to this function which is where I'm actually going to

3452
02:51:48,900 --> 02:51:50,400
Branch to, right?

3453
02:51:50,400 --> 02:51:54,600
So what it's doing here at the moment, I guess this table we were in,

3454
02:51:54,600 --> 02:52:00,100
is in the address space for a kernel32.dll, which is what we're

3455
02:52:00,100 --> 02:52:00,900
jumping into.

3456
02:52:01,000 --> 02:52:02,400
And again, it's sort of a

3457
02:52:04,200 --> 02:52:07,800
A redirection table that's going to move us out to the actual virtual

3458
02:52:07,800 --> 02:52:08,400
alochol.

3459
02:52:09,000 --> 02:52:12,100
So the question is still none of these have really given us what we

3460
02:52:12,100 --> 02:52:17,900
would need which is something that allows us to more easily crib off

3461
02:52:17,900 --> 02:52:23,500
the compiler something that we could call so that we can call like a

3462
02:52:23,500 --> 02:52:27,900
location where freely maybe.

3463
02:52:28,300 --> 02:52:28,600
Yeah.

3464
02:52:28,700 --> 02:52:29,100
Nothing.

3465
02:52:29,100 --> 02:52:29,400
I don't know.

3466
02:52:29,400 --> 02:52:32,800
I can't really think of anything that would allow us to do that.

3467
02:52:33,200 --> 02:52:33,600
So

3468
02:52:34,100 --> 02:52:37,500
I guess what I would say here is given the only thing that we're going

3469
02:52:37,500 --> 02:52:39,800
to be able to do is do a relative function.

3470
02:52:39,800 --> 02:52:43,900
Call in this case, I feel like what we need to do is just Embrace that

3471
02:52:43,900 --> 02:52:44,300
and go.

3472
02:52:44,300 --> 02:52:48,800
All right, let's figure out how to call some of our code directly by

3473
02:52:48,800 --> 02:52:51,300
using that same indirection style, right?

3474
02:52:52,300 --> 02:52:53,400
So what are we going to need?

3475
02:52:53,700 --> 02:52:55,700
Well we're going to need that sequence.

3476
02:52:56,200 --> 02:52:58,600
That uses a relative call, right?

3477
02:52:59,100 --> 02:53:02,200
So for example this thing right here this call keyword pointer.

3478
02:53:02,400 --> 02:53:03,600
Here is an address

3479
02:53:03,900 --> 02:53:09,000
And that address is saying, go there, read 64, bytes and Branch to

3480
02:53:09,000 --> 02:53:09,900
that, right?

3481
02:53:10,100 --> 02:53:12,900
So this is the sequence for doing that call.

3482
02:53:13,000 --> 02:53:14,700
This is the sequence that does that.

3483
02:53:14,800 --> 02:53:17,600
So let's grab those bites, right?

3484
02:53:17,600 --> 02:53:21,100
Let's just grab those out and look at how they correspond.

3485
02:53:21,700 --> 02:53:27,500
Okay, so in this case, we've got again that jump, in fact, maybe let's

3486
02:53:27,500 --> 02:53:28,800
use one, that's a little bit.

3487
02:53:29,700 --> 02:53:30,300
Do we have one?

3488
02:53:30,300 --> 02:53:33,700
That's that's that's not going to be so onerous, maybe a call

3489
02:53:33,800 --> 02:53:34,600
It's a little bit.

3490
02:53:34,600 --> 02:53:37,700
So here's here's a call that's going to be a little bit less finicky.

3491
02:53:37,700 --> 02:53:39,100
Perhaps so right here.

3492
02:53:39,800 --> 02:53:46,500
So this is the call that goes to to to our actual data, right?

3493
02:53:47,300 --> 02:53:49,200
And so let's take a look at how that's encoded.

3494
02:53:49,200 --> 02:53:53,100
So again, here is our hero, our B, right?

3495
02:53:53,300 --> 02:53:55,200
This is, this is the location of the code.

3496
02:53:55,200 --> 02:53:56,500
This is the pointer to the code.

3497
02:53:56,700 --> 02:53:59,800
This is the location that we are loading from.

3498
02:54:00,000 --> 02:54:00,800
I would like to load from.

3499
02:54:00,800 --> 02:54:01,600
So, this is the point.

3500
02:54:01,600 --> 02:54:04,600
This is where the data actually, is where that pointer is.

3501
02:54:05,800 --> 02:54:10,300
We know there are one, two, three, four, five, six, bytes in the call,

3502
02:54:10,500 --> 02:54:11,000
right?

3503
02:54:11,100 --> 02:54:14,900
So technically, we want to add 6 to this value, which is the one that

3504
02:54:14,900 --> 02:54:16,400
we'd be starting with, right?

3505
02:54:17,100 --> 02:54:20,600
And so then let's take a look at if we subtract that away.

3506
02:54:20,600 --> 02:54:24,400
So if we say, where would we have to go to get there?

3507
02:54:24,600 --> 02:54:26,400
Take a look here, right?

3508
02:54:28,000 --> 02:54:29,800
And then, let's see what we're actually.

3509
02:54:30,000 --> 02:54:32,600
A passing in here as the actual values.

3510
02:54:32,900 --> 02:54:35,700
Again, I'm not sure I quite did that correctly in the reverse

3511
02:54:35,700 --> 02:54:40,700
engineering there, so I'm going to have to be a little bit more

3512
02:54:40,700 --> 02:54:42,700
careful here when I'm looking at it.

3513
02:54:44,200 --> 02:54:46,200
Yeah, because just looking at it.

3514
02:54:47,200 --> 02:54:48,900
Maybe it's going forward.

3515
02:54:48,900 --> 02:54:52,800
I don't know exactly where it's trying to get that deer pointer, so

3516
02:54:53,200 --> 02:54:56,800
308, so it's going forward, right?

3517
02:54:56,800 --> 02:54:59,000
So that's why this number isn't - right.

3518
02:54:59,000 --> 02:55:01,600
So, we're expecting to see this to be a positive number.

3519
02:55:01,600 --> 02:55:04,200
It is, we look at the hexadecimal, it's 1 F.

3520
02:55:04,200 --> 02:55:07,000
5B is the actual value.

3521
02:55:07,200 --> 02:55:08,800
There is the one f5b.

3522
02:55:08,800 --> 02:55:10,800
So that's the 32-bit offset.

3523
02:55:10,800 --> 02:55:12,500
I believe that we are interested in.

3524
02:55:12,800 --> 02:55:16,900
So what this gives us right here is a sequence that would call

3525
02:55:17,300 --> 02:55:21,200
With a 32-bit offset, something relative to our current location,

3526
02:55:21,600 --> 02:55:22,000
right?

3527
02:55:23,200 --> 02:55:25,700
Okay, so let's go ahead and put that in there.

3528
02:55:25,800 --> 02:55:30,300
So instead what we want our function to do is rather than include the

3529
02:55:30,300 --> 02:55:34,400
code 45 that we're actually putting here, we want to actually put the

3530
02:55:34,400 --> 02:55:38,100
call to code 45 in the generated code.

3531
02:55:38,500 --> 02:55:40,100
Then we'll just return.

3532
02:55:40,100 --> 02:55:42,600
We know that c 3 does the return.

3533
02:55:43,100 --> 02:55:44,400
So we'll just do that.

3534
02:55:44,400 --> 02:55:44,800
Right?

3535
02:55:44,800 --> 02:55:48,900
So we'll call and then we'll return not particularly good code

3536
02:55:48,900 --> 02:55:52,000
regenerating here, but that's what we're going to do.

3537
02:55:52,200 --> 02:55:52,900
And like I said,

3538
02:55:53,100 --> 02:55:56,600
The five b1f part, that's the actual offset.

3539
02:55:56,600 --> 02:55:57,500
So off we go.

3540
02:55:57,800 --> 02:56:00,000
All right, so how will we do this?

3541
02:56:00,100 --> 02:56:03,400
Well, the way we'll do this is first by saying, all right, the code 45

3542
02:56:03,400 --> 02:56:09,100
needs the Preamble for the call, that's the FF and the 15, right?

3543
02:56:09,500 --> 02:56:12,200
We then know that the five b1f part

3544
02:56:13,400 --> 02:56:15,300
Right here, five b1f, right.

3545
02:56:15,300 --> 02:56:17,100
And you can see that's five b1f.

3546
02:56:17,100 --> 02:56:20,100
The 5 becomes first because again, because it's little-endian Phi b, 1

3547
02:56:20,100 --> 02:56:21,700
F 0, 0, 0 0.

3548
02:56:21,900 --> 02:56:23,700
That's the part, that's an in Star.

3549
02:56:23,700 --> 02:56:27,400
So this time we're looking at here, and we're looking at that integer,

3550
02:56:27,500 --> 02:56:28,700
this is our offset.

3551
02:56:28,700 --> 02:56:30,400
We don't know what that offset is yet.

3552
02:56:30,800 --> 02:56:33,100
That's going to be two, three, four and five.

3553
02:56:33,200 --> 02:56:35,900
Then we get to six and that's our rent, right?

3554
02:56:35,900 --> 02:56:40,500
So now what we need to do is we need to have some location somewhere

3555
02:56:40,900 --> 02:56:43,100
that's going to store the jump.

3556
02:56:43,200 --> 02:56:44,300
Okay ssion, right?

3557
02:56:44,300 --> 02:56:48,000
And again, this jump location can now be absolute because the relative

3558
02:56:48,000 --> 02:56:51,800
encoding is in the instruction that says, go look at this location,

3559
02:56:51,900 --> 02:56:53,700
pull out the pointer and jump there.

3560
02:56:54,000 --> 02:56:54,600
Right?

3561
02:56:55,000 --> 02:56:56,500
So let's go ahead and do that.

3562
02:56:56,800 --> 02:56:59,700
What we need to do is now store in code, 45 somewhere.

3563
02:57:00,200 --> 02:57:04,800
Let's say up after our return instruction, we're just going to put in

3564
02:57:04,800 --> 02:57:09,900
here the actual N64 address that we need which you know, in this case

3565
02:57:09,900 --> 02:57:12,100
would just be a void Star.

3566
02:57:12,100 --> 02:57:21,200
Right, we need to treat this address as if it's going to be a pointer

3567
02:57:21,200 --> 02:57:26,400
to something and we're going to put in to it the the function 5,

3568
02:57:27,900 --> 02:57:30,600
Okay, so let's go ahead and compile that.

3569
02:57:35,000 --> 02:57:37,300
Everything works except for the fact that we need this location.

3570
02:57:37,500 --> 02:57:39,400
We now know what this location is.

3571
02:57:39,800 --> 02:57:45,500
We just need to know the offset from where we are that that seven,

3572
02:57:45,500 --> 02:57:49,900
that that code for 57 is well, we know, we're going to end this

3573
02:57:49,900 --> 02:57:53,100
instruction at code for 55, right?

3574
02:57:53,100 --> 02:57:54,900
Or I should say it code, four, five, six.

3575
02:57:54,900 --> 02:57:57,600
That's where it's going to end after its when it's executing, so all

3576
02:57:57,600 --> 02:58:03,000
we need to know is where code 457 is relative for code to, you know,

3577
02:58:03,100 --> 02:58:04,300
to code, four, five, six,

3578
02:58:04,600 --> 02:58:08,300
Because the CPU will have consumed up to code 45.

3579
02:58:08,600 --> 02:58:12,200
I've code four, five, six code, 45 is a bad name.

3580
02:58:12,200 --> 02:58:14,000
Let me just call this code.

3581
02:58:17,900 --> 02:58:18,900
Or maybe just code.

3582
02:58:19,000 --> 02:58:19,900
Just call it code.

3583
02:58:29,200 --> 02:58:30,600
Just to get me out of that.

3584
02:58:30,700 --> 02:58:31,800
That was just hard to say.

3585
02:58:31,900 --> 02:58:37,300
Okay, so what we need to tell it is what's the difference right

3586
02:58:37,300 --> 02:58:40,200
between the address of where we're going to end, we're going to

3587
02:58:40,200 --> 02:58:43,300
destruction and where I need you to read the pointer from which is

3588
02:58:43,300 --> 02:58:44,600
right here, right?

3589
02:58:44,700 --> 02:58:46,000
And let's go ahead and compile that.

3590
02:58:46,900 --> 02:58:49,500
All right, so now let's look at what we've done.

3591
02:58:51,200 --> 02:58:54,100
Let's go in here and take a look at this monstrosity that we have

3592
02:58:54,100 --> 02:58:54,800
created.

3593
02:58:55,200 --> 02:58:56,800
So we're going to come through here again.

3594
02:58:56,800 --> 02:59:00,300
This is our call to Virtual a lock virtual Alec will return into our

3595
02:59:00,300 --> 02:59:06,000
ax the pointer that we now have allocated for our code generation.

3596
02:59:06,700 --> 02:59:10,700
I am going to go ahead and look at it as a car on the science, which

3597
02:59:10,700 --> 02:59:11,500
look at the B.

3598
02:59:11,700 --> 02:59:14,600
Here are the B now, we're going to go ahead and quote-unquote,

3599
02:59:14,600 --> 02:59:18,400
generate our code, which just involves a stuffing, the b n so you can

3600
02:59:18,400 --> 02:59:20,000
see uh, stuffing the b in here.

3601
02:59:20,100 --> 02:59:20,500
There's the

3602
02:59:20,600 --> 02:59:25,100
FF in the 15th and remember that FF in the 15 are just being hard set.

3603
02:59:25,100 --> 02:59:29,600
Now, what we're doing is going to insert the offset necessary to call

3604
02:59:29,800 --> 02:59:34,000
to get to this part of the of the code, right to this part of, it is

3605
02:59:34,000 --> 02:59:36,400
just a piece of data, we're sticking in there, but just that part of

3606
02:59:36,400 --> 02:59:38,600
the allocated memory, right?

3607
02:59:38,700 --> 02:59:41,000
So we need to do is fill that out.

3608
02:59:42,300 --> 02:59:43,500
And that should happen right here.

3609
02:59:45,800 --> 02:59:46,600
Or somewhere soon.

3610
02:59:46,600 --> 02:59:47,200
There it is.

3611
02:59:49,800 --> 02:59:50,400
Okay.

3612
02:59:50,600 --> 02:59:54,700
And that's correct actually it's only one bite now that I think about

3613
02:59:54,700 --> 02:59:54,900
it.

3614
02:59:54,900 --> 02:59:55,500
That's what it should be.

3615
02:59:55,500 --> 02:59:58,500
So we went away then we're going to stuff in The Return part, right?

3616
02:59:58,500 --> 02:59:59,900
And now at the end,

3617
03:00:00,000 --> 03:00:00,500
To the code.

3618
03:00:00,500 --> 03:00:02,000
So this is all of our code.

3619
03:00:02,000 --> 03:00:05,100
This is the call instruction plus the offset which is 1.

3620
03:00:05,100 --> 03:00:11,300
Byte the offset to look at the so it knows where to load the pointer,

3621
03:00:11,300 --> 03:00:14,600
right then the return instruction and now right here which is where

3622
03:00:14,600 --> 03:00:15,900
we've told it to look.

3623
03:00:16,000 --> 03:00:18,900
We sorry right here, where we've told to look, we need to put the

3624
03:00:18,900 --> 03:00:22,500
eight byte address of the function and that's what this code is going

3625
03:00:22,500 --> 03:00:24,300
to do right here, right?

3626
03:00:25,700 --> 03:00:26,400
And there it is.

3627
03:00:26,500 --> 03:00:28,600
So that's the actual address of the function.

3628
03:00:28,700 --> 03:00:32,200
Let's see if it actually did that correctly because we should actually

3629
03:00:32,200 --> 03:00:35,300
be able to find five, it should be right here.

3630
03:00:36,600 --> 03:00:43,100
So what we should be seeing is 310 8 C f8 13 right?

3631
03:00:43,100 --> 03:00:45,200
310 8 C f8.

3632
03:00:45,500 --> 03:00:45,900
Oops.

3633
03:00:49,300 --> 03:00:49,900
310.

3634
03:00:51,600 --> 03:00:51,900
Sorry.

3635
03:00:51,900 --> 03:00:53,700
See 8 or 8?

3636
03:00:53,700 --> 03:00:54,300
C?

3637
03:00:54,400 --> 03:00:56,300
Yes, f8.

3638
03:01:00,100 --> 03:01:00,400
Fa.

3639
03:01:00,400 --> 03:01:03,400
I'm just reading that wrong but yes, that's exactly right by my

3640
03:01:03,600 --> 03:01:05,100
reading comprehension, those are not great.

3641
03:01:05,100 --> 03:01:10,800
So we've loaded the location of this function 5 that the compiler

3642
03:01:10,800 --> 03:01:14,800
generated, we loaded it into our code page, right?

3643
03:01:14,800 --> 03:01:18,800
That we created and that's where relative addressing we told it to go

3644
03:01:18,800 --> 03:01:21,200
get the result when it does the call, right?

3645
03:01:22,300 --> 03:01:23,700
So, now, here comes the moment of truth.

3646
03:01:23,700 --> 03:01:24,600
Did we do it right?

3647
03:01:24,600 --> 03:01:25,800
I don't know, right?

3648
03:01:25,800 --> 03:01:28,900
That was pretty fast and loose that I was playing there.

3649
03:01:29,200 --> 03:01:29,700
Certainly

3650
03:01:30,000 --> 03:01:34,100
So we're going to have a load here of RX into this thing is like, this

3651
03:01:34,100 --> 03:01:37,400
is, that's this right here where we're loading in the function and

3652
03:01:37,400 --> 03:01:39,500
then we're going to call through there, okay?

3653
03:01:39,500 --> 03:01:40,900
So this is the Moment of Truth.

3654
03:01:40,900 --> 03:01:41,900
This is the call.

3655
03:01:42,000 --> 03:01:43,000
We're calling through it.

3656
03:01:43,000 --> 03:01:44,600
Here's our generated code.

3657
03:01:45,300 --> 03:01:46,100
It's beautiful.

3658
03:01:46,100 --> 03:01:46,700
Isn't it?

3659
03:01:46,800 --> 03:01:48,800
Look at the code we generated, aren't you?

3660
03:01:48,800 --> 03:01:49,500
Proud of yourself?

3661
03:01:49,500 --> 03:01:50,200
You should be.

3662
03:01:50,200 --> 03:01:54,000
If you've made it this far, here we are doing our load.

3663
03:01:54,800 --> 03:01:58,500
I'm sorry doing our call that loads the address to jump to out of this

3664
03:01:58,500 --> 03:01:59,200
location.

3665
03:01:59,300 --> 03:02:03,600
This location was encoded relatively right here by saying, one bite

3666
03:02:03,600 --> 03:02:06,900
after the end of this instruction, that is where we're going to go.

3667
03:02:07,200 --> 03:02:07,600
Okay?

3668
03:02:08,200 --> 03:02:10,200
That's exactly where we put it.

3669
03:02:10,200 --> 03:02:12,900
We put it right here so we're hoping it loads properly.

3670
03:02:13,000 --> 03:02:16,900
What you'll notice is the disassembler doesn't know, that's what we

3671
03:02:16,900 --> 03:02:17,500
made.

3672
03:02:17,900 --> 03:02:21,700
It still thinks it's code after the ret, we stuff data in there.

3673
03:02:21,700 --> 03:02:23,400
We didn't tell it, right.

3674
03:02:23,500 --> 03:02:24,400
So it's going to go ahead.

3675
03:02:24,600 --> 03:02:25,200
Disassemble.

3676
03:02:25,200 --> 03:02:29,800
That so it's thinks we stuck in an X or mob ad ad ad ad ad, right?

3677
03:02:30,300 --> 03:02:33,700
That's that we did, but it doesn't know the disassembler.

3678
03:02:33,700 --> 03:02:37,100
Just disassembles what's in memory assuming that it's code, right?

3679
03:02:37,500 --> 03:02:39,900
But instead what we're going to do is we're going to Branch out to the

3680
03:02:39,900 --> 03:02:42,300
location found at this place.

3681
03:02:42,700 --> 03:02:44,400
Let's see whether that actually.

3682
03:02:46,100 --> 03:02:49,100
Is if we actually encoded that properly.

3683
03:02:49,500 --> 03:02:53,600
So let's say that's a that's a pointer to a void.

3684
03:02:53,700 --> 03:02:59,300
Here it is and Hey look it's got the 13 f8c 10:30 in there.

3685
03:03:00,200 --> 03:03:02,100
Hopefully, the I think that was the right address, right?

3686
03:03:02,100 --> 03:03:03,300
So we're loading the address.

3687
03:03:03,400 --> 03:03:05,000
We're going to Branch boom.

3688
03:03:05,000 --> 03:03:06,600
There we are back at 5:00, right?

3689
03:03:06,600 --> 03:03:08,600
It's a great day to be alive for programming.

3690
03:03:08,900 --> 03:03:11,000
Everything worked just great here.

3691
03:03:11,000 --> 03:03:14,200
We are at the actual call site of five.

3692
03:03:14,200 --> 03:03:17,200
This is where we would have got the calls 85, but the place you jumped

3693
03:03:17,200 --> 03:03:20,600
you go to when you call five, just as if the compiler called it but we

3694
03:03:20,600 --> 03:03:21,100
called it.

3695
03:03:21,100 --> 03:03:23,700
We generated the code to call it right here we are.

3696
03:03:23,700 --> 03:03:27,100
It's going to return and it's going to

3697
03:03:29,300 --> 03:03:31,700
Have place in eax, the value of five.

3698
03:03:31,700 --> 03:03:35,900
So that's their right when we ret back out, we come to our Rhett.

3699
03:03:36,000 --> 03:03:37,600
We are not going to touch that, so that's fine.

3700
03:03:37,600 --> 03:03:41,500
It's going to leave that return value in there and lo and behold

3701
03:03:41,500 --> 03:03:45,500
through our own code that jumped into the code, the compiler

3702
03:03:45,500 --> 03:03:46,200
generated.

3703
03:03:46,200 --> 03:03:48,900
We got that value, 5 out and cure.

3704
03:03:48,900 --> 03:03:49,600
It is.

3705
03:03:49,800 --> 03:03:53,400
Ladies and gentlemen, it has been written out to our Global variable

3706
03:03:53,400 --> 03:03:55,300
just as we would have wanted.

3707
03:03:55,300 --> 03:03:58,400
And if we look at that Global variable and see what it contains,

3708
03:03:58,500 --> 03:03:58,800
Ins.

3709
03:03:59,300 --> 03:04:00,100
Like so.

3710
03:04:05,600 --> 03:04:07,300
Oops, that is if I can type.

3711
03:04:10,000 --> 03:04:13,200
There's the five, right?

3712
03:04:16,600 --> 03:04:19,500
so hopefully that demystify some of that stuff

3713
03:04:20,800 --> 03:04:23,500
the code that the compiler generates is just B.

3714
03:04:24,400 --> 03:04:28,300
Those bites when they are initially compiled may have empty spaces in

3715
03:04:28,300 --> 03:04:31,600
them that are just mentioned as a symbol is going to go here.

3716
03:04:31,600 --> 03:04:35,500
When you link the Linker fills in all of those symbols that are known

3717
03:04:35,500 --> 03:04:39,100
at link time although there may be some of the operations massive deal

3718
03:04:39,100 --> 03:04:39,300
with.

3719
03:04:39,300 --> 03:04:41,600
And that's the part we're going to get into now but mostly that's what

3720
03:04:41,600 --> 03:04:42,100
happens.

3721
03:04:43,400 --> 03:04:46,200
All of that code B that were generated.

3722
03:04:46,200 --> 03:04:49,300
They get loaded into memory when the operating system executes your

3723
03:04:49,300 --> 03:04:53,900
program and you can look at them, a function pointer just points into

3724
03:04:53,900 --> 03:04:54,600
those bites.

3725
03:04:55,600 --> 03:04:56,400
That's all it does.

3726
03:04:57,200 --> 03:05:01,100
And you can do anything you want with function pointers all the way

3727
03:05:01,100 --> 03:05:05,100
down to what I just showed you, where you can just make up the code

3728
03:05:05,100 --> 03:05:05,900
yourself.

3729
03:05:06,500 --> 03:05:12,000
Tell, see what kind of code you made and it will dispatch to your code

3730
03:05:12,100 --> 03:05:12,500
just like,

3731
03:05:12,600 --> 03:05:14,300
It would dispatch to its code.

3732
03:05:14,300 --> 03:05:15,200
No difference.

3733
03:05:15,500 --> 03:05:18,500
Furthermore, you can actually snap a pointer to code.

3734
03:05:18,500 --> 03:05:23,300
The compiler made, feed it into code that you make, and actually call

3735
03:05:23,300 --> 03:05:23,900
that.

3736
03:05:24,200 --> 03:05:28,100
So you can call into your code and then call back out again, it's none

3737
03:05:28,100 --> 03:05:28,800
of it's a mystery.

3738
03:05:28,800 --> 03:05:32,600
It's just bytes in memory and function pointers are just those

3739
03:05:32,600 --> 03:05:37,400
pointers and all that any of this other stuff does is it just informs

3740
03:05:37,400 --> 03:05:39,500
the compiler at the call site?

3741
03:05:39,500 --> 03:05:42,500
What does it have to do to dispatch to

3742
03:05:42,600 --> 03:05:43,200
That address.

3743
03:05:43,200 --> 03:05:44,400
That's all the function.

3744
03:05:44,400 --> 03:05:46,600
Signature really tells it, right?

3745
03:05:47,200 --> 03:05:55,300
Okay, time to finish up the understanding of what's going on with

3746
03:05:55,300 --> 03:05:59,500
these function pointers now to answer the last part of the question.

3747
03:06:00,200 --> 03:06:05,000
That was posed by the, the email that I received.

3748
03:06:06,200 --> 03:06:13,500
How do things work if you have two separate actual executable pieces

3749
03:06:13,500 --> 03:06:17,500
that are produced at the end because hopefully now you've seen there

3750
03:06:17,500 --> 03:06:22,000
should be no questions in your mind about how an individual program

3751
03:06:22,000 --> 03:06:22,500
works.

3752
03:06:23,600 --> 03:06:25,400
In terms of function pointers, right?

3753
03:06:25,500 --> 03:06:29,000
You can see that the code that's generated is just call instructions.

3754
03:06:29,200 --> 03:06:32,500
It's just going to get the pointers from wherever it needed to.

3755
03:06:32,500 --> 03:06:36,400
In terms of like, either those symbols were specified by the compiler,

3756
03:06:36,400 --> 03:06:39,700
initially when it generated piece of code or that that can be made by

3757
03:06:39,700 --> 03:06:42,000
us where we allocate memory and tell it to call it.

3758
03:06:42,200 --> 03:06:45,700
So it's just getting a pointer from somewhere reasonable and off you

3759
03:06:45,700 --> 03:06:49,100
go, it's all under your control and you have the ability to specify,

3760
03:06:49,100 --> 03:06:52,000
how it's going to happen and the Linker follows very specific rules

3761
03:06:52,000 --> 03:06:53,200
that we have now investigated and

3762
03:06:53,400 --> 03:06:55,400
Should have no trouble understanding how that's working.

3763
03:06:55,500 --> 03:06:57,900
You can even use tools like dumpin to inform you.

3764
03:06:57,900 --> 03:07:00,600
If you are confused about what the Linker is doing.

3765
03:07:02,000 --> 03:07:03,600
Okay, so

3766
03:07:05,200 --> 03:07:09,000
Now, the question becomes what happens with stuff like this call.

3767
03:07:10,000 --> 03:07:11,800
This virtual alochol.

3768
03:07:12,900 --> 03:07:14,700
We never defined that, right?

3769
03:07:14,800 --> 03:07:17,700
And you saw me have to do a bunch of mumbo-jumbo here.

3770
03:07:17,800 --> 03:07:23,000
I added you insert kernel32.dll, lib on to the end of our link line in

3771
03:07:23,000 --> 03:07:26,900
order to be able to call virtual a lock, okay.

3772
03:07:28,600 --> 03:07:32,700
And the question is like, how does that work?

3773
03:07:33,200 --> 03:07:36,300
Because virtual Alec is defined nowhere in any translation unit that

3774
03:07:36,300 --> 03:07:36,900
we have.

3775
03:07:37,400 --> 03:07:40,300
And in order to get access to it, I had to do a kernel32 lib.

3776
03:07:40,300 --> 03:07:43,200
Does the code live in there and if the code does live in there?

3777
03:07:43,400 --> 03:07:46,700
Well, the allocation is something that the operating system has to do,

3778
03:07:46,700 --> 03:07:47,200
right?

3779
03:07:47,200 --> 03:07:50,500
So how does it tell the operating system that it needs to do in a

3780
03:07:50,500 --> 03:07:51,600
like, what's happening?

3781
03:07:51,600 --> 03:07:52,800
How does any of this stuff work?

3782
03:07:53,000 --> 03:07:53,400
Right?

3783
03:07:55,000 --> 03:07:55,300
Okay.

3784
03:07:56,000 --> 03:07:56,400
Well

3785
03:07:57,900 --> 03:08:00,400
So let's start at the very very beginning.

3786
03:08:01,300 --> 03:08:05,500
Initially there was no such thing as the stuff that I'm about to tell

3787
03:08:05,500 --> 03:08:10,700
you earlier, computer programming, like under MS-DOS and stuff like

3788
03:08:10,700 --> 03:08:14,600
this or going further back, let's say in the Amiga days might be a

3789
03:08:14,600 --> 03:08:15,100
good example.

3790
03:08:15,100 --> 03:08:20,500
When you wrote a program, you have the option of writing a program

3791
03:08:20,500 --> 03:08:22,900
that would be the only program that was running on the system.

3792
03:08:22,900 --> 03:08:27,500
So there wasn't really an operating system per se in a lot of cases.

3793
03:08:27,500 --> 03:08:31,100
There was your code and whenever

3794
03:08:31,300 --> 03:08:34,900
Your code needed, something to happen that related to the actual

3795
03:08:34,900 --> 03:08:35,500
Hardware.

3796
03:08:36,200 --> 03:08:39,300
What you did was invoke an actual bios interrupt.

3797
03:08:39,800 --> 03:08:42,800
Now, what this means is, you were actually telling the processor.

3798
03:08:42,800 --> 03:08:44,400
I need you to jump into code.

3799
03:08:44,400 --> 03:08:50,200
That's actually stored in ROM in the computer, hard-coded, into the

3800
03:08:50,200 --> 03:08:50,800
hardware.

3801
03:08:51,800 --> 03:08:55,300
And that is the place where anything that I didn't right occurs.

3802
03:08:55,400 --> 03:08:58,700
So you're literally talking about like the firmware that's in the ROM,

3803
03:08:58,700 --> 03:08:59,800
that's mapped somehow.

3804
03:09:00,000 --> 03:09:02,200
Memory, who knows, what's going on depending on the system

3805
03:09:02,200 --> 03:09:02,700
architecture.

3806
03:09:02,700 --> 03:09:03,400
Blah, blah, blah.

3807
03:09:04,500 --> 03:09:09,700
The only things that you would be calling quote-unquote, that weren't

3808
03:09:09,700 --> 03:09:10,600
your code.

3809
03:09:10,700 --> 03:09:12,600
We're Hardware operations.

3810
03:09:13,600 --> 03:09:14,000
Okay.

3811
03:09:15,900 --> 03:09:21,500
But as the understanding of operating system ecosystem, sort of

3812
03:09:21,500 --> 03:09:26,900
matures over time, and this is not like contemporary contemporaneous

3813
03:09:26,900 --> 03:09:28,000
with a Meegan MS-DOS.

3814
03:09:28,000 --> 03:09:31,400
We're also systems like vax and so on where this had already occurred.

3815
03:09:31,400 --> 03:09:34,000
So it's, you know, it wasn't like it happened.

3816
03:09:34,000 --> 03:09:36,100
Only as Windows NT happened or something.

3817
03:09:36,700 --> 03:09:39,600
But anyway, as operating systems mature, they tend to end up at a

3818
03:09:39,600 --> 03:09:44,300
point where now, everything that your code does, if it's a user kind

3819
03:09:44,300 --> 03:09:44,900
of program.

3820
03:09:44,900 --> 03:09:45,400
So not the

3821
03:09:45,600 --> 03:09:46,200
Operating system.

3822
03:09:46,200 --> 03:09:50,700
But user mode code, it no longer directly interfaces with the

3823
03:09:50,700 --> 03:09:51,300
hardware.

3824
03:09:51,500 --> 03:09:55,100
The reason for that is because the operating system is required to

3825
03:09:55,200 --> 03:09:58,000
mitigate concerns that happen between programs.

3826
03:09:58,500 --> 03:09:59,400
What do I mean by this?

3827
03:09:59,400 --> 03:10:04,300
Well, if I am trying to allocate memory in a program, I wrote, but

3828
03:10:04,300 --> 03:10:05,700
it's a multitasking operating system.

3829
03:10:05,700 --> 03:10:09,100
So, somebody else's program is also trying to allocate memory.

3830
03:10:09,300 --> 03:10:12,500
Well, if we both talk directly to the hardware and said, here's the

3831
03:10:12,500 --> 03:10:14,400
memory, I want to use, right?

3832
03:10:14,700 --> 03:10:15,400
We might pick the

3833
03:10:15,500 --> 03:10:19,000
the same mapping in memory and overwrite each other's changes or who

3834
03:10:19,000 --> 03:10:22,700
knows what or one of us would update the memory mapping on the CPU

3835
03:10:22,700 --> 03:10:25,800
without being aware that the other person updated it and clobber their

3836
03:10:25,800 --> 03:10:26,500
change.

3837
03:10:26,600 --> 03:10:28,100
Who knows what happens, right?

3838
03:10:28,600 --> 03:10:32,500
So the operating system has to step in here and provide a set of API

3839
03:10:32,500 --> 03:10:36,200
calls, which will mitigate this sort of, like, sort of solve the

3840
03:10:36,200 --> 03:10:37,200
collective action problem.

3841
03:10:37,200 --> 03:10:40,700
It's sort of acting like the government does, where you got private

3842
03:10:40,700 --> 03:10:43,200
citizens, who want to do various things in the government, has to say.

3843
03:10:43,200 --> 03:10:45,400
Okay, let's arbitrate, who's going to do what?

3844
03:10:45,400 --> 03:10:45,500
We're

3845
03:10:45,600 --> 03:10:47,500
And who owns what property and so on, right?

3846
03:10:47,500 --> 03:10:49,100
It's for it's doing that same thing.

3847
03:10:49,100 --> 03:10:50,500
Nowadays the operating system is

3848
03:10:52,200 --> 03:10:58,300
Okay, so in this case, what we have is a modern-day operating system

3849
03:10:58,400 --> 03:11:03,600
provides usually, a very large surface of API functions.

3850
03:11:04,200 --> 03:11:08,200
And the way that this works is that when your code is initially

3851
03:11:08,200 --> 03:11:13,600
starting when your executable is loaded, there is a secondary link

3852
03:11:13,600 --> 03:11:18,200
phase so very much like the obj files that we had where we can, we

3853
03:11:18,200 --> 03:11:21,900
have the compiler produce obj's, which had

3854
03:11:22,000 --> 03:11:24,200
Symbols in them that were kind of missing, right?

3855
03:11:24,200 --> 03:11:27,600
They were sort of saying, well I know I need to call bar here but I

3856
03:11:27,600 --> 03:11:29,400
don't really know where that's going to be.

3857
03:11:29,500 --> 03:11:33,100
So just when you find out, when it's going to be later on down the

3858
03:11:33,100 --> 03:11:36,400
pipe, put in the address here so that this code will work, right?

3859
03:11:38,100 --> 03:11:41,300
So what the operating system does is it basically does that same thing

3860
03:11:41,300 --> 03:11:42,200
to your code.

3861
03:11:42,200 --> 03:11:46,300
In another link step that only happens when the executables actually

3862
03:11:46,300 --> 03:11:46,900
loaded.

3863
03:11:47,000 --> 03:11:49,000
That's what's actually going on, right?

3864
03:11:49,100 --> 03:11:51,500
And so, if we take a look at what's happening, we can now start to

3865
03:11:51,500 --> 03:11:51,800
speak.

3866
03:11:51,900 --> 03:11:54,000
Can start to inspect that process.

3867
03:11:54,500 --> 03:11:56,500
Let's take a look at this virtual AA, call.

3868
03:11:56,500 --> 03:11:59,500
For example, I can go ahead and do a dump bin like we were doing

3869
03:11:59,500 --> 03:11:59,800
before.

3870
03:12:00,500 --> 03:12:03,000
On our code in Maine obj.

3871
03:12:03,100 --> 03:12:06,900
And what I can see up with the virtual alochol, you can see right here

3872
03:12:06,900 --> 03:12:08,800
that the same sort of thing happened.

3873
03:12:08,900 --> 03:12:10,600
That was happening to our stuff before.

3874
03:12:10,800 --> 03:12:12,800
Do you see that input virtual Alec there?

3875
03:12:12,900 --> 03:12:19,100
Now, in Virtual a lock, is nowhere to be found, write our code, simply

3876
03:12:19,100 --> 03:12:22,000
does not have an imp virtual a lock.

3877
03:12:22,000 --> 03:12:25,400
So the question becomes, where is imp virtual a lock?

3878
03:12:25,400 --> 03:12:27,100
What is imp virtual a lock?

3879
03:12:27,100 --> 03:12:29,900
It's a symbol that's getting inserted into our code that

3880
03:12:30,000 --> 03:12:31,100
No one has defined.

3881
03:12:32,600 --> 03:12:36,900
And that is how we get to, what that lib was that I placed on the link

3882
03:12:36,900 --> 03:12:42,300
line, and that starts to inform how the dynamic link linking process

3883
03:12:42,700 --> 03:12:44,000
on Windows, actually works.

3884
03:12:44,000 --> 03:12:47,400
And how things are connected up to each other, right?

3885
03:12:48,700 --> 03:12:55,200
So if we go and look at how this works, that that link line, you can

3886
03:12:55,200 --> 03:12:57,700
see that I had to put kernel32.dll a bond there.

3887
03:12:57,700 --> 03:12:59,000
Well, what is kernel32.dll?

3888
03:12:59,200 --> 03:13:03,000
Abib kernel32.dll ID is this file that I copied in because like I

3889
03:13:03,000 --> 03:13:04,600
said, I wanted everything to be in here.

3890
03:13:04,600 --> 03:13:07,300
Oops, I want it to be lowercase as well, because I like things to look

3891
03:13:07,300 --> 03:13:07,900
lower case.

3892
03:13:08,300 --> 03:13:08,700
There we go.

3893
03:13:08,700 --> 03:13:11,100
Let's pretend that I had done that originally, and let's do another

3894
03:13:11,100 --> 03:13:11,500
directory.

3895
03:13:11,500 --> 03:13:12,100
There you go.

3896
03:13:14,500 --> 03:13:18,400
So looking at this here kernel32 lib what is that file?

3897
03:13:18,600 --> 03:13:19,400
Well a DOT.

3898
03:13:19,400 --> 03:13:20,800
Lib file is really nothing.

3899
03:13:20,800 --> 03:13:22,400
Mysterious a DOT lid.

3900
03:13:22,400 --> 03:13:26,500
File is really basically the same thing as an obj file for all intents

3901
03:13:26,500 --> 03:13:27,000
and purposes.

3902
03:13:27,000 --> 03:13:31,700
It's a pre bundles set of obj's, basically that you can link to so

3903
03:13:31,700 --> 03:13:34,600
that you don't have to have all the obj's that actually created it

3904
03:13:34,600 --> 03:13:35,500
lying around.

3905
03:13:35,600 --> 03:13:38,800
So it's sort of like instead of producing an actual executable that

3906
03:13:38,800 --> 03:13:41,800
you're going to ship to somebody and say here run this code if a

3907
03:13:41,800 --> 03:13:44,100
developer wants to ship something to another developer.

3908
03:13:44,300 --> 03:13:47,400
Say hey here's a bunch of code that I pre packaged together.

3909
03:13:47,400 --> 03:13:51,400
You can call it and link it into your executable on your link line.

3910
03:13:51,600 --> 03:13:54,500
A lib is just a way of bundling, a bunch of obj's together and

3911
03:13:54,500 --> 03:13:55,800
providing them to you to call.

3912
03:13:56,200 --> 03:13:57,400
So that's exactly what this is.

3913
03:13:57,400 --> 03:14:00,600
And what that means is we can look at it with dump in just like we

3914
03:14:00,600 --> 03:14:02,700
would look at an obj file actually.

3915
03:14:03,000 --> 03:14:07,100
So if I want to take a disassembled of kernel32, not live, I can write

3916
03:14:07,900 --> 03:14:11,400
now unfortunately, what you can see here is since this is a import

3917
03:14:11,400 --> 03:14:14,100
Library, we don't get very much information out of it, right?

3918
03:14:14,300 --> 03:14:14,400
Right.

3919
03:14:14,400 --> 03:14:17,600
It's not willing to give us a dis as mm of this up because it's in a

3920
03:14:17,600 --> 03:14:19,200
specific format.

3921
03:14:21,100 --> 03:14:22,800
Let's see if I can do this with a slash all.

3922
03:14:23,100 --> 03:14:24,200
It's an acidic format.

3923
03:14:24,200 --> 03:14:28,800
That's really only job is to provide a dispatch table for a dll and so

3924
03:14:28,800 --> 03:14:30,100
I'll kind of get into what that means.

3925
03:14:30,100 --> 03:14:32,000
But you can see it all is kind of scrolling by here.

3926
03:14:34,700 --> 03:14:36,000
Probably not super necessary.

3927
03:14:36,400 --> 03:14:37,400
Here you can see.

3928
03:14:39,000 --> 03:14:39,300
Yeah.

3929
03:14:40,900 --> 03:14:42,800
let me get this into something I can actually,

3930
03:14:44,400 --> 03:14:45,000
Here we go.

3931
03:14:45,500 --> 03:14:46,000
All right.

3932
03:14:47,700 --> 03:14:53,600
Alright, so here is kernel32 text, which is the dump bin of kernel32

3933
03:14:53,900 --> 03:14:58,000
and what you can see here is what we have in this library and it was

3934
03:14:58,000 --> 03:14:59,300
my bad for trying to diss azimut.

3935
03:14:59,300 --> 03:14:59,800
You can't just

3936
03:15:00,000 --> 03:15:02,300
Man import library and import libraries, slightly different from

3937
03:15:02,300 --> 03:15:06,200
regular Library again just because it's made to specifically instruct

3938
03:15:06,900 --> 03:15:10,700
a Windows, the Linker, how to create a permanent going to bind to

3939
03:15:10,700 --> 03:15:13,700
Windows, but it's still basically the exact same thing.

3940
03:15:13,700 --> 03:15:17,900
It's just a series of name symbols and those symbols are there to tell

3941
03:15:18,400 --> 03:15:20,900
the Linker how to patch up information.

3942
03:15:20,900 --> 03:15:24,300
And what you can see about this library, is that this Library?

3943
03:15:24,300 --> 03:15:29,800
All it has in, it is a bunch of basically names which are

3944
03:15:30,000 --> 03:15:30,500
Imp.

3945
03:15:30,500 --> 03:15:33,600
And then the function and it also has that function.

3946
03:15:33,800 --> 03:15:37,900
And all of these functions core are all the functions that exist in

3947
03:15:38,000 --> 03:15:41,800
Windows kernel Services right now.

3948
03:15:41,800 --> 03:15:44,700
I don't know if I installed depends on this machine.

3949
03:15:46,100 --> 03:15:47,300
I hope that I did.

3950
03:15:47,500 --> 03:15:49,500
I'm not sure how to find out if I did.

3951
03:15:52,500 --> 03:15:53,700
Do I have it?

3952
03:15:54,500 --> 03:15:55,800
I hope that I do.

3953
03:15:57,000 --> 03:15:59,700
Depends anyone?

3954
03:16:07,700 --> 03:16:08,600
Here it is.

3955
03:16:08,600 --> 03:16:14,200
Yes depends is a program that we can use to inspect dlls and basically

3956
03:16:14,200 --> 03:16:18,200
what it is, is it something that takes the dll and shows us what's

3957
03:16:18,500 --> 03:16:20,000
contained in there, right?

3958
03:16:20,300 --> 03:16:24,700
And so, let's talk a little bit of what, what a DL DL is to begin with

3959
03:16:24,900 --> 03:16:26,800
and how it relates to the import Library.

3960
03:16:26,800 --> 03:16:29,800
So what I'm going to do is I'm going to the windows system32

3961
03:16:29,800 --> 03:16:32,500
directory, a hilarious name considering that fact that it's actually

3962
03:16:32,500 --> 03:16:33,400
64-bit now.

3963
03:16:33,400 --> 03:16:34,400
But, hey, Legacy.

3964
03:16:35,200 --> 03:16:37,400
And this is the actual even though it's called

3965
03:16:37,500 --> 03:16:38,000
32.

3966
03:16:38,000 --> 03:16:42,300
And it's in the system trajectory, it's actually a 64-bit dll for

3967
03:16:42,300 --> 03:16:44,700
backwards compatibility reasons, they kept the names of same, instead

3968
03:16:44,700 --> 03:16:46,200
of curling it colonel 64.

3969
03:16:47,900 --> 03:16:48,300
Yeah.

3970
03:16:48,700 --> 03:16:51,600
Anyway, I'm going to open up kernel32.dll and what you can see in

3971
03:16:51,600 --> 03:16:56,400
kernel32.dll in this program depends you can see here all of the

3972
03:16:56,400 --> 03:17:00,000
functions that kernel32 actually exports.

3973
03:17:00,600 --> 03:17:03,000
And so what is a dll and why do we care?

3974
03:17:03,000 --> 03:17:03,900
And what is this?

3975
03:17:03,900 --> 03:17:06,600
Actually giving us that anyone needs to actually know.

3976
03:17:06,600 --> 03:17:10,200
Well, alright, so what you can see first of all is like, for example,

3977
03:17:10,200 --> 03:17:10,900
let's take.

3978
03:17:11,100 --> 03:17:13,200
Well let's take a virtual I like because that's the call.

3979
03:17:13,200 --> 03:17:14,000
We actually needed.

3980
03:17:14,000 --> 03:17:17,300
That was the only call that we're actually using in our in our code,

3981
03:17:17,300 --> 03:17:17,500
right?

3982
03:17:17,900 --> 03:17:20,900
Here's virtual a lock you can see right here.

3983
03:17:21,100 --> 03:17:25,000
It says we're virtual Alec is in the in the dll.

3984
03:17:25,400 --> 03:17:28,800
It has some other information are like ordinal which is a way to bind

3985
03:17:28,800 --> 03:17:30,900
things that by name by numbers instead of names.

3986
03:17:30,900 --> 03:17:34,000
Not really important to us now but there's that virtual alochol.

3987
03:17:34,100 --> 03:17:37,500
And the other thing that we can see is if we look inside the, the lib,

3988
03:17:37,600 --> 03:17:40,400
you can see that we've got those same exact things you can see like I

3989
03:17:40,400 --> 03:17:42,600
said these correspond exactly.

3990
03:17:43,300 --> 03:17:47,100
You can see them here, virtual Aqua TX free, right?

3991
03:17:47,600 --> 03:17:53,500
This import library that we dumped has the exact same structure as the

3992
03:17:53,500 --> 03:17:55,900
dll in terms of what's in it, right?

3993
03:17:56,000 --> 03:17:59,600
They're not the same but they correspond quite directly right?

3994
03:18:00,100 --> 03:18:05,900
So what this is is actually a way of describing code, a dll is a way

3995
03:18:05,900 --> 03:18:07,900
of sort of, bundling up a bunch of code.

3996
03:18:07,900 --> 03:18:10,900
So a dll and an executable are almost exactly the same.

3997
03:18:11,000 --> 03:18:13,100
They contain almost exactly the same stuff.

3998
03:18:13,400 --> 03:18:18,100
The only difference is the dll is basically not stand alone.

3999
03:18:18,200 --> 03:18:21,300
It's designed to be code that people call in, to, rather than

4000
03:18:21,300 --> 03:18:23,600
executable which kind of launches and does its own thing.

4001
03:18:23,600 --> 03:18:24,200
Right?

4002
03:18:24,400 --> 03:18:27,100
And so a dll, which stands, for course, Dynamic link.

4003
03:18:27,100 --> 03:18:29,800
Library is a library that's of code.

4004
03:18:30,000 --> 03:18:32,300
Code that's been pre compiled that you can just run.

4005
03:18:32,300 --> 03:18:33,000
It's not a lib.

4006
03:18:33,000 --> 03:18:33,700
It's not a library.

4007
03:18:33,700 --> 03:18:36,800
Like, in the linking sense of the word like we were talking about, its

4008
03:18:36,800 --> 03:18:38,600
actual code completed code.

4009
03:18:39,900 --> 03:18:43,300
With all the symbols resolved and it just has a bunch of entry points

4010
03:18:43,300 --> 03:18:46,500
in it, that you can call into that, do something specific.

4011
03:18:46,500 --> 03:18:51,000
So in our case, kernel32.dll has the code for virtual alloc init.

4012
03:18:51,200 --> 03:18:52,000
That's what it has.

4013
03:18:53,400 --> 03:18:59,500
What windows will do when it loads your executable is, it will map

4014
03:18:59,500 --> 03:19:04,200
into your processes memory space, these dll code.

4015
03:19:04,800 --> 03:19:07,000
So when our program is loaded,

4016
03:19:08,400 --> 03:19:13,800
it knows that it needs to map kernel32.dll in and it knows that we

4017
03:19:13,800 --> 03:19:17,000
need the code from kernel32.dll to complete our execution.

4018
03:19:17,000 --> 03:19:21,300
Specifically, we need virtual a lock right now.

4019
03:19:21,300 --> 03:19:22,200
How does it know that?

4020
03:19:22,800 --> 03:19:24,700
That's where the import Library comes from?

4021
03:19:25,100 --> 03:19:29,400
An import library, is specifically what you pass on the command line

4022
03:19:29,400 --> 03:19:34,900
to the Linker that says, here is a dll, right inside.

4023
03:19:34,900 --> 03:19:38,100
Kernel32 out, lib it basically says there is a dll

4024
03:19:38,200 --> 03:19:39,500
Kernel32.dll.

4025
03:19:40,100 --> 03:19:42,900
Here are all the entry points that that dll has.

4026
03:19:44,000 --> 03:19:51,000
And so, if someone wants a symbol like virtual a lock, I've got it,

4027
03:19:51,600 --> 03:19:52,500
here's where it.

4028
03:19:52,500 --> 03:19:56,500
And the way that you're going to resolve, that symbol is in the

4029
03:19:56,600 --> 03:19:57,400
executable.

4030
03:19:57,400 --> 03:20:00,700
What you output it, you're going to put in a line that says I need

4031
03:20:00,700 --> 03:20:04,600
kernel32.dll and I need virtual Alec from it.

4032
03:20:04,900 --> 03:20:07,700
I need you to patch that value in right here.

4033
03:20:09,500 --> 03:20:09,900
Okay.

4034
03:20:11,800 --> 03:20:15,900
So let's take that a little bit further here is my Depends.

4035
03:20:15,900 --> 03:20:19,000
Like are saying I'm going to load, depends allows me to look at

4036
03:20:19,600 --> 03:20:21,200
basically what sin, you know.

4037
03:20:21,200 --> 03:20:24,400
I've been saying all this time, it puts this thing in the executable

4038
03:20:24,400 --> 03:20:25,200
that you can lewd.

4039
03:20:26,200 --> 03:20:29,100
Depends is basically something which takes an executable file either a

4040
03:20:29,100 --> 03:20:30,100
dll or an exact.

4041
03:20:30,100 --> 03:20:31,600
Because, like I said, they're basically the same,

4042
03:20:33,200 --> 03:20:37,600
It takes one of those and it goes, what is in that specific section

4043
03:20:38,000 --> 03:20:39,200
that thing I keep talking about?

4044
03:20:39,200 --> 03:20:41,900
That's like, here's the thing that tells Windows what to do when I

4045
03:20:41,900 --> 03:20:44,100
load this and it dumps it for us.

4046
03:20:44,300 --> 03:20:48,700
So what that means is I can take our program, main dot exe and say,

4047
03:20:48,700 --> 03:20:53,000
look at that, and lo and behold what you can see is it tells us

4048
03:20:53,000 --> 03:20:57,000
exactly what we need to load.

4049
03:20:57,000 --> 03:20:59,700
Made idac, we only have one dependency.

4050
03:20:59,700 --> 03:20:59,900
It's

4051
03:21:00,000 --> 03:21:04,700
Colonel 32, dll and if we click on it it will show us exactly what we

4052
03:21:04,700 --> 03:21:07,600
call in that dll.

4053
03:21:08,500 --> 03:21:10,400
It's virtual Alec, right?

4054
03:21:11,700 --> 03:21:17,500
Again that is actually specified in the executable itself so you can

4055
03:21:17,500 --> 03:21:22,400
actually see depends let you actually see that in a GUI manner.

4056
03:21:22,400 --> 03:21:24,000
Now we could get a different way.

4057
03:21:24,400 --> 03:21:30,200
I believe dump bin / can I get Imports?

4058
03:21:31,500 --> 03:21:33,400
Imports we go

4059
03:21:35,900 --> 03:21:40,400
What we can see if we run dumpin in a less, pretty fashion is if we

4060
03:21:40,400 --> 03:21:43,700
run dumping on our executable again, what that's going to do is it's

4061
03:21:43,700 --> 03:21:46,700
going to take that executable file, and it's going to look at it and

4062
03:21:46,700 --> 03:21:50,100
grab that section that tells Windows what to do and tell us what's in

4063
03:21:50,100 --> 03:21:50,300
there.

4064
03:21:50,300 --> 03:21:54,700
And it says, here are the Imports kernel32.dll is required and the

4065
03:21:54,700 --> 03:21:56,000
symbol that comes out of it.

4066
03:21:56,000 --> 03:21:58,100
It's virtual a lock, right?

4067
03:22:00,500 --> 03:22:04,400
So again, this is just basically the exact same thing that the Linker

4068
03:22:04,400 --> 03:22:06,000
does at link time.

4069
03:22:07,000 --> 03:22:10,500
The dynamic Linker hence the name dynamic because happens at run time.

4070
03:22:10,700 --> 03:22:15,200
The dynamic Linker in Windows does at runtime so when our executable

4071
03:22:15,200 --> 03:22:19,600
comes in it performs the exact same function which is patching in

4072
03:22:19,800 --> 03:22:26,000
missing symbol addresses and it does that by mapping in the various

4073
03:22:26,000 --> 03:22:29,700
Dynamic libraries we need and wiring up.

4074
03:22:29,700 --> 03:22:29,900
So

4075
03:22:30,100 --> 03:22:33,400
Watching in those call sites to point to the correct location in

4076
03:22:33,400 --> 03:22:36,000
memory where that function actually exists.

4077
03:22:36,900 --> 03:22:37,300
Okay.

4078
03:22:39,200 --> 03:22:44,200
So we can see this happen directly if we step into our code right

4079
03:22:45,600 --> 03:22:46,200
here.

4080
03:22:46,300 --> 03:22:51,100
For example, is that call keyword pointer and this called goes to

4081
03:22:51,100 --> 03:22:52,100
Virtual a lock, right?

4082
03:22:52,100 --> 03:22:55,600
You can see it happening right here and here we end up in the code for

4083
03:22:55,600 --> 03:22:56,800
virtual a lock, right?

4084
03:22:57,500 --> 03:23:00,600
But if we actually look what's in our executable, it doesn't look like

4085
03:23:00,600 --> 03:23:01,800
that, right?

4086
03:23:01,900 --> 03:23:06,300
If we do a dis azzam of the executable main dot exe, you will notice

4087
03:23:06,900 --> 03:23:08,800
that we actually see no such thing.

4088
03:23:09,200 --> 03:23:13,800
Instead what we see when we look at this call to the this, this is the

4089
03:23:13,800 --> 03:23:18,100
location that we just step through that location here.

4090
03:23:19,500 --> 03:23:22,000
Four thousand two thousand H, right?

4091
03:23:22,900 --> 03:23:25,400
Is actually we can we get that?

4092
03:23:25,400 --> 03:23:26,800
I don't know if we can actually get that.

4093
03:23:30,100 --> 03:23:33,700
We can't actually look at the depends piece of information.

4094
03:23:33,700 --> 03:23:36,200
Can we, how can I, well,

4095
03:23:40,400 --> 03:23:42,300
This is the actual piece of information here.

4096
03:23:42,300 --> 03:23:44,500
I'm trying to think if I can get dumped into show us.

4097
03:23:52,200 --> 03:23:53,700
I know we can definitely do this.

4098
03:23:53,800 --> 03:23:59,400
I just don't know how this won't help us at all some while I'm typing

4099
03:23:59,400 --> 03:23:59,800
it in

4100
03:24:00,400 --> 03:24:01,900
Because we don't have any of that in there.

4101
03:24:07,000 --> 03:24:08,600
Well, I guess here's what I could do.

4102
03:24:16,400 --> 03:24:21,600
Okay, so let's just look at what the executable contains literally

4103
03:24:21,600 --> 03:24:22,800
before it is loaded.

4104
03:24:23,100 --> 03:24:26,300
Okay, here is the executable in a hex editor.

4105
03:24:27,100 --> 03:24:31,700
You can see the MZ prefix which is actually the tag, the header tag

4106
03:24:31,700 --> 03:24:36,000
that actually says that this is a Windows executable, you can actually

4107
03:24:36,000 --> 03:24:40,100
see if we actually look.

4108
03:24:40,200 --> 03:24:41,400
Where is my web browser?

4109
03:24:41,400 --> 03:24:41,900
There it is.

4110
03:24:43,800 --> 03:24:47,900
This is actually what they're called, they're called MZ executables,

4111
03:24:47,900 --> 03:24:48,500
right?

4112
03:24:48,900 --> 03:24:51,200
And what you'll notice is this is MS-DOS executable.

4113
03:24:51,200 --> 03:24:52,700
It says, this MZ.

4114
03:24:52,700 --> 03:24:54,900
Executable is actually the Preamble.

4115
03:24:55,500 --> 03:24:59,200
You can see that it says, this is this program cannot be run in DOS

4116
03:24:59,200 --> 03:24:59,700
mode.

4117
03:24:59,800 --> 03:25:04,700
What this is, is, this is actually a Das program and MS, DOS program,

4118
03:25:04,900 --> 03:25:09,200
that Windows still for legacy purposes, inserts at the front of a

4119
03:25:09,200 --> 03:25:10,600
linked executable.

4120
03:25:11,500 --> 03:25:12,500
Not making this up.

4121
03:25:14,100 --> 03:25:19,500
Such that if you were still to run it on MS-DOS, it would give you an

4122
03:25:19,500 --> 03:25:21,800
error that says, that this cannot be run in DOS mode.

4123
03:25:21,800 --> 03:25:23,900
So that, you know, you have to run it in Windows, right?

4124
03:25:23,900 --> 03:25:27,200
Again, this was when they initially made the transition, they spec,

4125
03:25:27,200 --> 03:25:31,400
the Windows File, executable format, to have the Das executable at the

4126
03:25:31,400 --> 03:25:32,300
beginning of it.

4127
03:25:32,300 --> 03:25:35,000
So that it would print that error message properly.

4128
03:25:35,300 --> 03:25:37,800
If someone tried to load the exe from da Smo.

4129
03:25:37,800 --> 03:25:39,300
It was a backwards compatibility feature.

4130
03:25:39,300 --> 03:25:41,100
So that's what that's doing there, right?

4131
03:25:42,600 --> 03:25:44,000
You can also see the rich G here.

4132
03:25:44,000 --> 03:25:47,900
I don't know the story behind that, I don't know who Rich G was.

4133
03:25:51,900 --> 03:25:52,900
Let's find out.

4134
03:25:54,300 --> 03:25:55,100
It, does it say?

4135
03:25:55,600 --> 03:25:59,600
I don't know, I'm not sure what the rich G comes from someone, from

4136
03:25:59,600 --> 03:26:02,700
Microsoft, can maybe fill us in on that anyway.

4137
03:26:03,000 --> 03:26:05,000
Maybe that means, maybe that's someone's name.

4138
03:26:05,000 --> 03:26:07,600
Maybe that means Rich graphic, I don't know.

4139
03:26:07,700 --> 03:26:14,300
Who knows point being that part of the MZ executable, that part of

4140
03:26:14,300 --> 03:26:18,400
this video format is just the dose Preamble, that's a piece of code

4141
03:26:18,400 --> 03:26:21,800
that's designed to cause MS.

4142
03:26:21,800 --> 03:26:23,600
DOS programs had no Dynamic linking.

4143
03:26:23,800 --> 03:26:23,900
They

4144
03:26:24,100 --> 03:26:26,900
Started at the first byte of the file, there's loaded it in point, the

4145
03:26:26,900 --> 03:26:28,100
Rest by the file and go.

4146
03:26:28,700 --> 03:26:29,100
Right.

4147
03:26:30,600 --> 03:26:34,700
And so that MZ X q0 to start the beginning in a just that's what's in

4148
03:26:34,700 --> 03:26:35,100
there, right?

4149
03:26:35,100 --> 03:26:37,700
As far as I know, and what know that's, that's a lie.

4150
03:26:38,300 --> 03:26:40,000
That's not, that's, that's totally not true.

4151
03:26:40,900 --> 03:26:44,000
The MZ part is loaded in, actually, check properly, it doesn't have a

4152
03:26:44,000 --> 03:26:44,700
dynamic linking.

4153
03:26:44,700 --> 03:26:48,200
It starts further in, obviously, it can't start executing it mzi.

4154
03:26:48,200 --> 03:26:52,100
So I think that what I just said is completely wrong, but you can see

4155
03:26:52,100 --> 03:26:55,100
that there's hardly anything in here and that's because again, no

4156
03:26:55,100 --> 03:26:56,500
Dynamic, limiting has to occur.

4157
03:26:56,500 --> 03:26:59,100
As far as I know for this to happen, it can just do a straight for it

4158
03:26:59,100 --> 03:26:59,800
interrupts to print.

4159
03:27:00,900 --> 03:27:01,800
Stuff to the console.

4160
03:27:01,800 --> 03:27:04,800
So I don't think there's anything in particular happening there.

4161
03:27:04,800 --> 03:27:08,400
Other than just the code starting somewhere in here again, has been a

4162
03:27:08,400 --> 03:27:09,700
long time, sentencing Das wise.

4163
03:27:09,700 --> 03:27:10,700
So don't quote me on that.

4164
03:27:11,200 --> 03:27:16,800
The PE here is where the executable actually starts for Windows in a

4165
03:27:19,200 --> 03:27:21,100
In Earnest.

4166
03:27:21,400 --> 03:27:24,500
And so you can see, it's called a PE portable executable format.

4167
03:27:24,800 --> 03:27:26,200
That's where this actually starts.

4168
03:27:26,200 --> 03:27:28,400
This is the windows part here.

4169
03:27:28,500 --> 03:27:31,900
These are the segments that are dated, a tepee data and so on.

4170
03:27:32,200 --> 03:27:35,500
And here is actually all of our code existing in here.

4171
03:27:35,600 --> 03:27:36,100
Right?

4172
03:27:36,400 --> 03:27:37,000
What that means?

4173
03:27:37,000 --> 03:27:39,300
Is that in this file, we can see what our code actually looks.

4174
03:27:39,300 --> 03:27:43,400
Like before the windows Linker, does anything to patch it up, right?

4175
03:27:43,400 --> 03:27:46,000
So, if we take a look, if we step in here,

4176
03:27:50,900 --> 03:27:51,500
Go ahead here.

4177
03:27:52,600 --> 03:27:53,200
Here we go.

4178
03:27:53,800 --> 03:27:58,400
So if we step in here and we see this, this jump, what we can see is

4179
03:27:58,800 --> 03:28:00,000
that jump there

4180
03:28:03,300 --> 03:28:03,900
That jump there.

4181
03:28:03,900 --> 03:28:08,300
You can see it's getting the, the the address from this location,

4182
03:28:08,300 --> 03:28:08,700
right?

4183
03:28:08,800 --> 03:28:12,000
13 fe0 2008, right?

4184
03:28:12,400 --> 03:28:18,000
That is something that's in our executable, that we have stored, and

4185
03:28:18,000 --> 03:28:21,000
it's doing very much like we did where it's getting a 64-bit, I

4186
03:28:21,000 --> 03:28:22,400
believe jump out of that.

4187
03:28:22,500 --> 03:28:25,900
So, if we take a look at what's in there, let me do this.

4188
03:28:32,700 --> 03:28:35,200
No not 9x.

4189
03:28:35,900 --> 03:28:36,400
There we go.

4190
03:28:37,600 --> 03:28:42,700
So if we assume that this thing right here is a pointer to a 64-bit

4191
03:28:42,700 --> 03:28:43,300
value.

4192
03:28:43,600 --> 03:28:48,900
Then we can see what that value actually is, and it's 778 d5c 40.

4193
03:28:48,900 --> 03:28:50,800
That's where it is, right?

4194
03:28:50,800 --> 03:28:52,300
It's at that location.

4195
03:28:53,000 --> 03:28:56,800
And what we can furthermore, tell is this address, right?

4196
03:28:57,100 --> 03:28:59,700
Where is that relative to the start of our code?

4197
03:28:59,900 --> 03:29:01,800
So here's where the code starts.

4198
03:29:02,500 --> 03:29:03,000
Right.

4199
03:29:04,600 --> 03:29:07,200
This is where a code starts, right here.

4200
03:29:07,300 --> 03:29:08,900
Where is this relative?

4201
03:29:09,200 --> 03:29:10,900
I just want to know where that is, right?

4202
03:29:10,900 --> 03:29:13,300
I just want to find out where that is relative to it.

4203
03:29:14,100 --> 03:29:14,500
Oops.

4204
03:29:18,600 --> 03:29:19,200
Here we go.

4205
03:29:19,900 --> 03:29:21,600
So that's 4,000.

4206
03:29:21,600 --> 03:29:23,300
That's 40-32 away.

4207
03:29:23,300 --> 03:29:25,200
So it's down here somewhere, right?

4208
03:29:25,200 --> 03:29:31,100
It's down in this 13, feo 2000, right?

4209
03:29:31,100 --> 03:29:32,600
So let's, let's go down there.

4210
03:29:33,000 --> 03:29:37,100
You can see that it is doo-doo-doo, doo-doo-doo-doo-doo-doo

4211
03:29:37,100 --> 03:29:38,200
doo-doo-doo-doo-doo.

4212
03:29:38,200 --> 03:29:38,900
There it is.

4213
03:29:41,500 --> 03:29:43,700
All right, so you can see where that is.

4214
03:29:43,700 --> 03:29:44,700
It's right here.

4215
03:29:46,700 --> 03:29:53,100
And this is getting disassembled as actual code but it's not right.

4216
03:29:53,100 --> 03:29:54,800
This is the same trick we used.

4217
03:29:54,800 --> 03:29:57,500
So the disassembler things is code, it's not really code.

4218
03:29:57,500 --> 03:29:58,800
It's actually the address.

4219
03:29:59,000 --> 03:29:59,900
It's actually this

4220
03:30:00,000 --> 03:30:00,700
Address.

4221
03:30:01,000 --> 03:30:01,500
Right.

4222
03:30:02,900 --> 03:30:03,700
Why did you do that?

4223
03:30:03,700 --> 03:30:04,100
To me?

4224
03:30:04,100 --> 03:30:07,000
I went all the way down there for a reason to bugger.

4225
03:30:12,200 --> 03:30:12,900
There we go.

4226
03:30:14,000 --> 03:30:17,500
You can actually see that that that address 7.

4227
03:30:17,800 --> 03:30:22,900
So it's 45, cd45 C8 D 77.

4228
03:30:23,200 --> 03:30:27,100
This is the same trick we used, where it just stored, the pointer that

4229
03:30:27,100 --> 03:30:32,600
it needed to jump to its stored that out here in in sort of the, the

4230
03:30:32,600 --> 03:30:39,500
part of the code where addresses, for, for dynamic, linking are going

4231
03:30:39,500 --> 03:30:40,000
to live.

4232
03:30:40,400 --> 03:30:40,800
Okay.

4233
03:30:41,300 --> 03:30:41,800
So what we

4234
03:30:41,900 --> 03:30:47,900
To know now is was that ever in the actual code, was that ever was

4235
03:30:47,900 --> 03:30:52,700
that in our executable that that address hardbound and the answer in

4236
03:30:52,700 --> 03:30:55,500
this case should be no, although this is taxing my knowledge of

4237
03:30:55,500 --> 03:30:59,100
whether Colonel gets gets special linkage because it's Colonel, but

4238
03:30:59,100 --> 03:31:03,800
assuming that it's not what actually presumably happened was that the

4239
03:31:03,800 --> 03:31:08,400
dynamic Linker patch this up from some other address that wasn't

4240
03:31:08,400 --> 03:31:09,800
actually there to begin with.

4241
03:31:09,800 --> 03:31:11,900
And what we do know is we know that

4242
03:31:11,900 --> 03:31:15,600
Know that it's from the start of our code, we do know how far away it

4243
03:31:15,600 --> 03:31:15,800
is.

4244
03:31:15,800 --> 03:31:18,500
Like I said, it's 40-32 away.

4245
03:31:18,800 --> 03:31:22,200
So what we might be able to do here is take a look at Main dot exe and

4246
03:31:22,200 --> 03:31:24,600
figure out if we can locate our actual code.

4247
03:31:24,600 --> 03:31:30,000
So ff15 a 3-0 f for example is code.

4248
03:31:30,000 --> 03:31:34,600
That should just exist in here somewhere and I'm going to search for

4249
03:31:34,600 --> 03:31:34,900
it.

4250
03:31:35,000 --> 03:31:37,000
Ff15 a 3-0 F.

4251
03:31:37,300 --> 03:31:38,000
Here we go.

4252
03:31:38,800 --> 03:31:40,800
And let's see if we've actually found our code.

4253
03:31:40,900 --> 03:31:41,800
So here is FL

4254
03:31:41,900 --> 03:31:44,200
15 a 3-0 F, right.

4255
03:31:44,200 --> 03:31:45,500
0 0 is Right.

4256
03:31:45,500 --> 03:31:46,500
48, 49.

4257
03:31:46,600 --> 03:31:51,800
So this is our code in our a, this is on disk or code, right?

4258
03:31:52,300 --> 03:31:56,600
And so, from the start of this segment here, that we looked at, which

4259
03:31:56,600 --> 03:31:59,300
was, which was actually here and furthermore, we could just look at

4260
03:31:59,300 --> 03:32:04,100
1000 because 1000 is probably where this actually started to a certain

4261
03:32:04,100 --> 03:32:04,600
extent, right?

4262
03:32:04,600 --> 03:32:06,400
It was probably loaded into this page.

4263
03:32:06,400 --> 03:32:08,000
This is probably nonsense here.

4264
03:32:08,400 --> 03:32:09,700
We probably got loaded there.

4265
03:32:10,800 --> 03:32:11,300
Right.

4266
03:32:11,600 --> 03:32:14,200
So, if we take a look at this, this code page, right?

4267
03:32:14,200 --> 03:32:18,800
At some point, we would assume that we'd get down to the location

4268
03:32:18,800 --> 03:32:22,700
where we would have been loading that pointer from, and that pointer

4269
03:32:22,700 --> 03:32:25,900
should actually have a different piece of information in it.

4270
03:32:25,900 --> 03:32:30,000
Now, you can see, we can even see just right here that this is the

4271
03:32:30,000 --> 03:32:30,400
table.

4272
03:32:30,400 --> 03:32:33,500
That tells us what we needed to load, because you can actually see it

4273
03:32:33,500 --> 03:32:33,900
right here.

4274
03:32:33,900 --> 03:32:36,300
It's kernel32.dll, virtual Alec, right?

4275
03:32:36,300 --> 03:32:40,500
So here's the table, that tells the windows Linker, what to patch

4276
03:32:40,900 --> 03:32:44,800
But the question now is where is the actual value that got patched?

4277
03:32:44,800 --> 03:32:46,200
And what was it, right?

4278
03:32:46,300 --> 03:32:51,800
And that's going to be a little harder to find because it's probably

4279
03:32:51,800 --> 03:32:55,000
just again zeroed out or something in here.

4280
03:32:55,000 --> 03:32:55,700
So I'm not sure.

4281
03:32:55,900 --> 03:32:58,600
Anyway, what I'd love to be able to do is actually,

4282
03:33:00,100 --> 03:33:03,800
See before the windows Linker actually does its patching but I don't

4283
03:33:03,800 --> 03:33:07,200
know any I don't really know any way to do that.

4284
03:33:08,000 --> 03:33:14,100
Like I don't know how to stop Windows from how to inspect code before

4285
03:33:14,100 --> 03:33:16,100
the windows Linker gets to do it.

4286
03:33:16,800 --> 03:33:21,800
So what I'm going to do instead is I'm going to try here, some things

4287
03:33:21,800 --> 03:33:24,000
that are not super advisable.

4288
03:33:26,900 --> 03:33:34,400
I'm going to try some some amusing things to do if that makes sense.

4289
03:33:34,400 --> 03:33:37,200
So I'm going to, I'm going to, I'm going to try and look at this,

4290
03:33:37,200 --> 03:33:42,400
musing some, some more hand-wavy stuff right in the actual file.

4291
03:33:42,400 --> 03:33:44,600
Although, I guess, you know, the other thing that I probably could do,

4292
03:33:44,800 --> 03:33:46,600
I could probably use dumped into kind base.

4293
03:33:46,600 --> 03:33:49,400
So let me actually try that instead because that would be less

4294
03:33:49,400 --> 03:33:52,000
ridiculous than what I was about to do, which I don't think we should

4295
03:33:52,000 --> 03:33:52,300
do.

4296
03:33:52,900 --> 03:33:53,200
Okay?

4297
03:33:53,200 --> 03:33:55,200
So let me go ahead and try here.

4298
03:33:56,700 --> 03:33:58,300
How do I get to my desktop?

4299
03:33:58,300 --> 03:33:59,000
There we go.

4300
03:33:59,700 --> 03:34:00,500
That up.

4301
03:34:03,000 --> 03:34:03,700
It's coming here.

4302
03:34:03,900 --> 03:34:08,400
I'm going to go ahead and call dump in, and I'm going to take a look

4303
03:34:08,400 --> 03:34:13,100
at the Imports remain dot exe, and I'm just going to see if I can get

4304
03:34:13,100 --> 03:34:13,700
it to tell me.

4305
03:34:13,700 --> 03:34:15,500
So you can see here, right?

4306
03:34:17,400 --> 03:34:21,700
These are the two pieces of information, that tell me, where, in the

4307
03:34:21,700 --> 03:34:26,200
code in the absolute addressing of the code before, it's had address

4308
03:34:26,200 --> 03:34:28,500
space layout, randomization applied to it.

4309
03:34:29,100 --> 03:34:32,400
But in sort of the canonical addressing of the code, where these two

4310
03:34:32,400 --> 03:34:32,800
things are,

4311
03:34:33,000 --> 03:34:35,400
Which correspond actually fairly reasonably.

4312
03:34:35,400 --> 03:34:35,900
Oops.

4313
03:34:37,200 --> 03:34:38,700
To where we're seeing them here, right?

4314
03:34:38,700 --> 03:34:42,700
You can kind of see the import address table is at this location and

4315
03:34:42,700 --> 03:34:47,100
the import name table is just just a little bit ahead of it.

4316
03:34:47,100 --> 03:34:48,300
So you can see here.

4317
03:34:48,400 --> 03:34:50,300
Here is, the name table, right?

4318
03:34:50,300 --> 03:34:50,900
Is here.

4319
03:34:51,100 --> 03:34:55,600
And it's only 50, B, assuming actually, I guess this is probably in

4320
03:34:55,600 --> 03:34:56,700
HEX, so it's 0 x.

4321
03:34:56,700 --> 03:35:02,600
50 B back is where the actual pointer table is, right where the actual

4322
03:35:02,800 --> 03:35:04,100
import address table is.

4323
03:35:04,400 --> 03:35:06,700
And so in this stuff right here,

4324
03:35:08,900 --> 03:35:10,500
Should be where that is stored.

4325
03:35:12,300 --> 03:35:12,900
That's my guess.

4326
03:35:13,000 --> 03:35:16,900
Now I don't know if I can get it to tell me any better than that, like

4327
03:35:16,900 --> 03:35:18,600
where it actually is in the output file.

4328
03:35:18,600 --> 03:35:21,800
Let me see if I can get it to give me something a little bit better

4329
03:35:21,800 --> 03:35:22,800
and again, I apologize.

4330
03:35:22,800 --> 03:35:26,700
I'm kind of rough at this sort of stuff.

4331
03:35:31,400 --> 03:35:32,300
See here.

4332
03:35:37,100 --> 03:35:38,700
So, okay, so this is pretty good.

4333
03:35:38,700 --> 03:35:42,000
This actually gives us the raw data which is exactly what what I want.

4334
03:35:42,100 --> 03:35:44,000
Okay, so, that's perfect, right.

4335
03:35:45,400 --> 03:35:45,800
Okay?

4336
03:35:46,700 --> 03:35:51,200
So in this case, right, we can see two pieces of information.

4337
03:35:51,400 --> 03:35:56,200
Here's this this raw data number four and this rotated.

4338
03:35:56,200 --> 03:35:58,400
Number one are not the interesting part.

4339
03:35:58,400 --> 03:35:59,100
It's this raw data.

4340
03:35:59,100 --> 03:35:59,900
Number two, how do

4341
03:36:00,000 --> 03:36:01,400
I know that this this rotted a number 2.

4342
03:36:01,400 --> 03:36:04,400
Well, the reason I know is because when I looked up with the Imports

4343
03:36:04,400 --> 03:36:07,600
where you can see that, it said the import address table was at this

4344
03:36:07,600 --> 03:36:10,900
location logical location and the import name tells that this logical

4345
03:36:10,900 --> 03:36:11,300
location out.

4346
03:36:11,300 --> 03:36:13,700
Again, these are not the locations are acting to be encode.

4347
03:36:13,900 --> 03:36:15,800
These are because of address, space layout.

4348
03:36:15,800 --> 03:36:20,000
Randomization, these are sort of the recommended Base address, so I

4349
03:36:20,000 --> 03:36:23,000
guess, one thing that I never quite mentioned was whenever the

4350
03:36:23,000 --> 03:36:25,700
compiler compiles, something, I'm sorry, whatever.

4351
03:36:25,700 --> 03:36:28,500
The Linker links, something it links it with an understanding of what

4352
03:36:28,500 --> 03:36:29,200
the Base address.

4353
03:36:29,200 --> 03:36:29,800
Probably will be

4354
03:36:30,000 --> 03:36:34,700
Be it picked looks like 140, 000 000, right?

4355
03:36:34,700 --> 03:36:37,900
And you can see that everything that it generated is based off of That

4356
03:36:37,900 --> 03:36:38,800
Base address.

4357
03:36:39,000 --> 03:36:42,300
So when it does a dump bin, it's just saying hey this is where I

4358
03:36:42,300 --> 03:36:45,900
expect this thing to be loaded in memory but of course windows will

4359
03:36:45,900 --> 03:36:48,200
randomize where it actually gets loaded.

4360
03:36:48,300 --> 03:36:52,500
So now that new lower corresponds used to be that majority of the time

4361
03:36:52,500 --> 03:36:54,300
in Windows when you run it ran a program.

4362
03:36:54,600 --> 03:36:58,800
What you got in dump bin was exactly where it would have ended up not

4363
03:36:58,800 --> 03:36:59,900
true anymore so you can

4364
03:37:00,000 --> 03:37:02,800
It's slightly off and that's because of that address, space layout,

4365
03:37:02,800 --> 03:37:04,200
randomization, okay?

4366
03:37:05,600 --> 03:37:06,700
But putting that aside.

4367
03:37:07,100 --> 03:37:10,100
So now we know that the address import table is at this location.

4368
03:37:10,300 --> 03:37:12,000
Here is the address import table.

4369
03:37:12,700 --> 03:37:14,700
This is this is it right?

4370
03:37:14,900 --> 03:37:17,400
We also know that the import name table starts here.

4371
03:37:17,400 --> 03:37:20,500
So here that is right this is the import name table.

4372
03:37:21,200 --> 03:37:22,200
And so, what's happening?

4373
03:37:22,200 --> 03:37:25,000
Is this value here, right?

4374
03:37:26,200 --> 03:37:29,900
And we should now be able to figure this out because we can, we can

4375
03:37:29,900 --> 03:37:34,500
now, do sort of a Delta ink from the B that we see in the code here in

4376
03:37:34,500 --> 03:37:38,100
the Raw data and where they are here, we should be able to, actually

4377
03:37:38,100 --> 03:37:44,600
do sort of a Delta there to figure out what, where it actually is

4378
03:37:44,900 --> 03:37:46,600
relative in the code, right?

4379
03:37:46,700 --> 03:37:49,700
So let's actually see if I can do that to a certain extent.

4380
03:37:49,800 --> 03:37:53,300
I'm going to look for the 894 see 2408, right?

4381
03:37:53,300 --> 03:37:55,800
That's what I'ma look for in here.

4382
03:37:56,000 --> 03:37:57,100
See if I can find it.

4383
03:37:59,200 --> 03:38:02,100
And maybe I can maybe I can't or actually, you know what?

4384
03:38:02,100 --> 03:38:03,900
I could probably do it the other way around.

4385
03:38:03,900 --> 03:38:07,000
Let's look for the ff15 part of things here.

4386
03:38:07,800 --> 03:38:08,800
So here it is.

4387
03:38:10,500 --> 03:38:11,400
A 30f.

4388
03:38:12,400 --> 03:38:15,700
So that is this piece of code right here.

4389
03:38:17,000 --> 03:38:17,500
Right.

4390
03:38:18,400 --> 03:38:21,900
And so working backwards from there, if I just kind of go backwards in

4391
03:38:22,000 --> 03:38:27,600
in code B, I should get back at some point to the first actual

4392
03:38:27,600 --> 03:38:32,200
instruction that I see here in this page, which is at the 40 part,

4393
03:38:32,200 --> 03:38:33,200
which is right here.

4394
03:38:33,300 --> 03:38:34,200
So that's 40.

4395
03:38:34,200 --> 03:38:35,800
80, 3, EC 38.

4396
03:38:35,800 --> 03:38:37,100
That's that piece of code.

4397
03:38:37,500 --> 03:38:38,000
Okay?

4398
03:38:38,400 --> 03:38:42,600
So if I take a look at where that loaded, so this is the location that

4399
03:38:42,600 --> 03:38:44,200
that piece of code loaded at.

4400
03:38:44,500 --> 03:38:46,700
I know that this is the place where I'm at.

4401
03:38:46,900 --> 03:38:51,800
In where the the Linker just guessed if the Base address started,

4402
03:38:51,900 --> 03:38:55,000
where it thought it was going to start at the 14 million or whatever.

4403
03:38:55,100 --> 03:38:58,900
Sorry, 140 million hex.

4404
03:39:00,000 --> 03:39:04,300
It's not you know 0x 1400 1000.

4405
03:39:05,000 --> 03:39:08,300
What I can do now is look at the Delta between these two and figure

4406
03:39:08,300 --> 03:39:13,600
out where that you know, where it corresponds to in this universe,

4407
03:39:13,700 --> 03:39:14,100
right?

4408
03:39:15,200 --> 03:39:18,400
So let's go ahead and look at where we're calling here.

4409
03:39:18,600 --> 03:39:20,700
We're calling at 2,000, right?

4410
03:39:20,700 --> 03:39:23,000
That's the location that we're looking at and again.

4411
03:39:23,000 --> 03:39:28,100
So if I was to take this location, which I did, originally the 1040

4412
03:39:28,100 --> 03:39:29,900
there, the start of the code and

4413
03:39:30,000 --> 03:39:30,100
Act.

4414
03:39:30,100 --> 03:39:34,100
It it's 4,000 32 away I want that in HEX.

4415
03:39:34,200 --> 03:39:37,200
Again, that's fc0 right.

4416
03:39:37,700 --> 03:39:40,400
And so what I want to do here is I want to know.

4417
03:39:40,500 --> 03:39:43,700
Well, if I was to start from here, right?

4418
03:39:46,300 --> 03:39:50,000
14 X, 14 000.

4419
03:39:51,000 --> 03:39:52,000
1040.

4420
03:39:53,500 --> 03:39:57,100
If I was to start from there and go that far forward, right?

4421
03:39:57,100 --> 03:39:59,600
Go fc0 forward.

4422
03:39:59,600 --> 03:40:00,700
Where would I end up?

4423
03:40:00,700 --> 03:40:02,600
And I'd end up right there, right?

4424
03:40:02,900 --> 03:40:04,700
That is literally the start right here.

4425
03:40:04,700 --> 03:40:08,300
So now we know definitively in our executable.

4426
03:40:08,300 --> 03:40:14,000
This is the address 60, 20 000, 000 000.

4427
03:40:14,000 --> 03:40:16,100
000 is actually.

4428
03:40:16,100 --> 03:40:16,900
What was there?

4429
03:40:18,000 --> 03:40:24,100
Right, but that's not what's there anymore, if that makes sense.

4430
03:40:24,400 --> 03:40:28,600
When we actually look at what was there, we find something totally

4431
03:40:28,900 --> 03:40:32,600
else altogether, which is what Windows has patched in.

4432
03:40:32,800 --> 03:40:37,100
So we know that Windows is now, over writing, that value, by using

4433
03:40:37,100 --> 03:40:40,900
this table, that's specified starting here, encoded in whatever

4434
03:40:40,900 --> 03:40:41,200
format.

4435
03:40:41,200 --> 03:40:44,700
So couldn't, we could actually go look up this encoding and actually

4436
03:40:44,700 --> 03:40:46,800
decrypt that, but this has been an incredibly long stream.

4437
03:40:46,800 --> 03:40:47,700
I think I want to say,

4438
03:40:47,800 --> 03:40:53,500
Heard of the stream at 2:30 potentially, maybe to 15, I think this has

4439
03:40:53,500 --> 03:40:55,900
been probably one of the longest dreams I've ever done.

4440
03:40:57,700 --> 03:41:00,400
So I won't belabor that point, but that's exactly what is happening

4441
03:41:00,400 --> 03:41:01,000
here, right?

4442
03:41:01,000 --> 03:41:04,500
It's using this table, which is information that actually has strings.

4443
03:41:04,500 --> 03:41:09,700
It's matching those strings to the actual dlls, it's patching in the

4444
03:41:09,700 --> 03:41:12,000
address so that it can jump into the dll.

4445
03:41:12,000 --> 03:41:13,900
And that is what's happening, right?

4446
03:41:14,200 --> 03:41:17,700
And so somewhere in between when it gets loaded, and when we actually

4447
03:41:17,800 --> 03:41:21,500
Actually get to start in the debugger that patch up occurred, which is

4448
03:41:21,500 --> 03:41:21,800
why?

4449
03:41:21,800 --> 03:41:26,200
When we go, and we look at where we jump, we jump to this value here.

4450
03:41:26,200 --> 03:41:30,500
Even though that value was nowhere to be found in here, right there is

4451
03:41:30,500 --> 03:41:33,900
that, that is not encoded anywhere, in our, executable Windows is

4452
03:41:33,900 --> 03:41:36,800
patching that in using this table, okay?

4453
03:41:38,800 --> 03:41:43,700
so now that we've done that, we now have a complete understanding

4454
03:41:44,900 --> 03:41:48,800
of exactly what is going on in all of the, handmade hero stuff.

4455
03:41:49,000 --> 03:41:51,700
Okay, from what I've given you today, you can go and apply it

4456
03:41:51,700 --> 03:41:52,900
completely to handmade hero.

4457
03:41:53,200 --> 03:41:54,400
How well, here you go.

4458
03:41:55,200 --> 03:41:56,300
We know in handmade hero.

4459
03:41:56,300 --> 03:41:57,600
We produce two things.

4460
03:41:57,700 --> 03:41:59,500
We produce one executable,

4461
03:42:00,300 --> 03:42:01,400
And one, dll?

4462
03:42:02,000 --> 03:42:02,400
Right?

4463
03:42:04,400 --> 03:42:06,900
The executable is the win32 platform code.

4464
03:42:08,000 --> 03:42:11,800
The dll is the game code we use.

4465
03:42:11,800 --> 03:42:16,500
Windows has Dynamic, loading capabilities to load the dynamic dll in,

4466
03:42:16,900 --> 03:42:17,200
right?

4467
03:42:17,200 --> 03:42:18,100
That's what we do.

4468
03:42:19,200 --> 03:42:24,000
And when we load that dynamic, dll in, we know that we have to get

4469
03:42:24,000 --> 03:42:26,700
some location of code to jump to

4470
03:42:27,600 --> 03:42:28,800
and how we can do that.

4471
03:42:29,300 --> 03:42:33,100
And the answer is, we use the exact same process that Windows uses to

4472
03:42:33,100 --> 03:42:34,900
figure out where to jump into our executable.

4473
03:42:35,300 --> 03:42:35,800
Right.

4474
03:42:36,800 --> 03:42:39,200
It's this these tables, right?

4475
03:42:39,200 --> 03:42:43,200
These tables are written into our executable and say stuff like where

4476
03:42:43,200 --> 03:42:46,600
the entry points are or if we have named functions like virtual Allah

4477
03:42:46,800 --> 03:42:48,700
like the dll does in

4478
03:42:51,000 --> 03:42:55,000
Like kernel32.dll, has it knows that there's specific name entry

4479
03:42:55,000 --> 03:42:55,400
points.

4480
03:42:55,700 --> 03:42:56,500
So, what is that?

4481
03:42:56,500 --> 03:42:57,900
It's get proc address.

4482
03:42:58,000 --> 03:43:01,300
If you go back and look at the win32 stuff, get proc addresses, a

4483
03:43:01,300 --> 03:43:04,500
thing that says, hey Windows, using the, all the mechanisms that you

4484
03:43:04,500 --> 03:43:08,800
use for dynamic, linking tell me, where does this name exists?

4485
03:43:08,800 --> 03:43:10,000
What, what entry point?

4486
03:43:10,000 --> 03:43:11,800
What function pointer, what I need?

4487
03:43:11,800 --> 03:43:16,700
If I wanted to start executing at this named entry point in this dll,

4488
03:43:16,700 --> 03:43:19,700
and it will return back using exactly the same tables that were

4489
03:43:19,700 --> 03:43:20,100
looking at.

4490
03:43:20,300 --> 03:43:23,000
Our it will return back here is where that is, right?

4491
03:43:24,500 --> 03:43:29,200
When we do that, we are then able to jump to that function, right?

4492
03:43:29,500 --> 03:43:31,500
As a function pointer just like we were doing before.

4493
03:43:31,500 --> 03:43:34,200
So it's just gives us back and address of that dll.

4494
03:43:35,100 --> 03:43:38,800
Furthermore, when we calmed that deal on handmade hero, we passed it

4495
03:43:38,800 --> 03:43:42,400
function pointers that point into our code again, no difference here.

4496
03:43:42,400 --> 03:43:45,600
All we're doing is passing those function pointers into that code so

4497
03:43:45,600 --> 03:43:49,100
it can call those function Point itself using exactly the same stuff

4498
03:43:49,200 --> 03:43:52,400
techniques that we showed today, that code is just code in memory, the

4499
03:43:52,400 --> 03:43:53,900
pointers just point at the location.

4500
03:43:54,100 --> 03:43:54,500
Memory.

4501
03:43:54,600 --> 03:43:58,600
We wanted to be able to provide them to the execute to the game code.

4502
03:43:58,600 --> 03:44:02,200
Dll, we did that by bundling them up in memory, and just passing it a

4503
03:44:02,200 --> 03:44:05,100
pointer to that memory, and that's it, right?

4504
03:44:05,900 --> 03:44:09,000
So let's take a look at that in a little bit more detail.

4505
03:44:11,100 --> 03:44:13,000
Let's go into the handmade hero directory.

4506
03:44:14,300 --> 03:44:14,900
Right.

4507
03:44:15,200 --> 03:44:15,600
Oops.

4508
03:44:16,200 --> 03:44:17,300
Build directory, actually.

4509
03:44:17,500 --> 03:44:20,600
And here is the code that we build for handmade hero here at all is,

4510
03:44:21,000 --> 03:44:21,500
right?

4511
03:44:21,700 --> 03:44:23,800
And let's take a look at the win32.

4512
03:44:23,800 --> 03:44:27,600
Handmade stuff using dumped in, right?

4513
03:44:31,300 --> 03:44:34,700
So if I actually take a look here, I don't know that I want to just

4514
03:44:34,700 --> 03:44:35,000
ask them.

4515
03:44:35,000 --> 03:44:37,600
That's because it's kind of wrong.

4516
03:44:37,600 --> 03:44:38,700
Way too much stuff at me.

4517
03:44:39,200 --> 03:44:41,200
Yeah, this is going to throw away too much stuff on me as well.

4518
03:44:41,300 --> 03:44:43,300
Stop stop, stop, stop, stop bad.

4519
03:44:43,300 --> 03:44:45,000
No stop, please.

4520
03:44:45,400 --> 03:44:46,000
Oh my God.

4521
03:44:46,500 --> 03:44:47,200
Just no.

4522
03:44:54,200 --> 03:44:59,000
Well, ladies and gentlemen, here's a nice print out, and me hitting

4523
03:44:59,000 --> 03:44:59,800
control syrupy.

4524
03:45:00,000 --> 03:45:03,400
But you're not getting any ability to stop it.

4525
03:45:03,600 --> 03:45:05,000
How about we just close this window?

4526
03:45:05,600 --> 03:45:07,000
That seems like a good compromise.

4527
03:45:08,700 --> 03:45:11,300
All right, try that one more time.

4528
03:45:12,700 --> 03:45:13,500
It's out of here.

4529
03:45:15,800 --> 03:45:18,700
Go go into the handmade directory.

4530
03:45:20,300 --> 03:45:21,200
Sorry, build directory.

4531
03:45:22,000 --> 03:45:24,100
And let's do a more modest.

4532
03:45:25,300 --> 03:45:28,000
Look at the Imports of handmade.

4533
03:45:29,300 --> 03:45:31,900
Through to handmade gotta see.

4534
03:45:32,800 --> 03:45:38,200
And so, to start out with, you can see the win32, handmade links to a

4535
03:45:38,200 --> 03:45:44,200
bunch of things user 32, GDI 3-2 win, mmm, opengl 32 kernel32, right?

4536
03:45:44,700 --> 03:45:46,800
And you can see all of the entry points we use.

4537
03:45:46,800 --> 03:45:50,000
Now, you can see, this is much more involved than the one, we looked

4538
03:45:50,000 --> 03:45:50,600
at before.

4539
03:45:50,600 --> 03:45:51,100
Why?

4540
03:45:51,100 --> 03:45:54,400
Because handmade hero calls the operating system in a bunch more entry

4541
03:45:54,400 --> 03:45:55,300
points, right?

4542
03:45:55,600 --> 03:45:58,900
So, it needs to map all of these dlls.

4543
03:45:59,000 --> 03:46:00,300
Into its address space.

4544
03:46:00,400 --> 03:46:03,800
At start up, windows will map all of the code for those into our

4545
03:46:03,800 --> 03:46:04,300
address space.

4546
03:46:04,300 --> 03:46:06,200
So we have, you know, our code.

4547
03:46:06,200 --> 03:46:08,000
We have GDI 32s code.

4548
03:46:08,000 --> 03:46:11,500
When M&M's code opengl 32, s-code all of that gets mapped in there.

4549
03:46:13,000 --> 03:46:14,800
And then all of these names, get resolved.

4550
03:46:14,800 --> 03:46:15,900
So it all gets wired up.

4551
03:46:15,900 --> 03:46:19,400
So everywhere there was a function pointer to say get device caps, it

4552
03:46:19,400 --> 03:46:24,900
is now replaced with an actual, the actual address of get device caps,

4553
03:46:25,100 --> 03:46:26,600
so that it can jump.

4554
03:46:26,600 --> 03:46:29,200
It can execute that call properly, right, but that's all that's

4555
03:46:29,200 --> 03:46:29,500
happening.

4556
03:46:29,500 --> 03:46:31,500
There's that's getting wired up, okay?

4557
03:46:32,500 --> 03:46:36,300
So then we can look and also look at our handmade that dll.

4558
03:46:36,300 --> 03:46:37,600
What does it import?

4559
03:46:39,500 --> 03:46:43,900
So what you can see from the Imports of the, handmade dll is basically

4560
03:46:43,900 --> 03:46:48,200
the stuff that's there is just the necessary stuff for dll.

4561
03:46:48,200 --> 03:46:50,200
The C, runtime libraries, dll stuff, right?

4562
03:46:50,200 --> 03:46:51,100
So this is all part of that.

4563
03:46:51,100 --> 03:46:53,600
This is all called from the C runtime Library cuz we don't call any of

4564
03:46:53,600 --> 03:46:54,400
this stuff, right?

4565
03:46:54,700 --> 03:46:57,800
When we remove the C runtime Library, eventually all of this will go

4566
03:46:57,800 --> 03:46:59,700
away and they're actually won't be anything here.

4567
03:47:00,400 --> 03:47:04,200
So the more important part for us to look at it, handmade dll is the

4568
03:47:04,200 --> 03:47:05,200
exports part.

4569
03:47:05,200 --> 03:47:07,600
And you can see here is what we export again.

4570
03:47:07,600 --> 03:47:09,000
These are the tables that windows

4571
03:47:09,300 --> 03:47:13,000
Into the DLR, the Lincoln Rode into the dll that windows can read, and

4572
03:47:13,000 --> 03:47:17,000
when we call get proc address, it will look at these to figure out

4573
03:47:17,000 --> 03:47:20,900
where in the act, this dll in the executable code of this, dll, these

4574
03:47:20,900 --> 03:47:25,600
things start so that they can patch up things that link to directly.

4575
03:47:25,600 --> 03:47:26,800
But we don't actually do that.

4576
03:47:26,900 --> 03:47:30,000
What we do is we call get proc address, kept proc I dress just looks

4577
03:47:30,000 --> 03:47:34,100
at this table and returns where these actually are, right?

4578
03:47:34,400 --> 03:47:39,000
Okay, so all that's happening when we do our load library on handmade,

4579
03:47:39,100 --> 03:47:43,600
Dll in win32 code, it's being mapped into the address space of the

4580
03:47:43,600 --> 03:47:45,700
win32 handmade executable.

4581
03:47:45,800 --> 03:47:49,300
We are then calling get proc address which searches the table in the

4582
03:47:49,400 --> 03:47:52,300
dll for that name that we're looking for.

4583
03:47:52,300 --> 03:47:54,700
For example, get sent game, get sound samples, or game update and

4584
03:47:54,700 --> 03:47:59,200
render returns back a function pointer, which again is just an address

4585
03:47:59,300 --> 03:47:59,800
that says

4586
03:48:00,000 --> 03:48:02,100
Here in this, you know, it mapped it into our process.

4587
03:48:02,100 --> 03:48:05,500
So, at some point loaded handmade dll, put into our address space,

4588
03:48:05,700 --> 03:48:09,800
where in our addresses, is the actual code off, it goes right.

4589
03:48:11,500 --> 03:48:12,700
That is all this happening.

4590
03:48:12,800 --> 03:48:15,300
Now, hopefully you're very comfortable function pointers all that

4591
03:48:15,300 --> 03:48:16,800
chefs and seemed very non mysterious.

4592
03:48:17,000 --> 03:48:19,600
The only thing we haven't covered is how those tables are actually

4593
03:48:19,600 --> 03:48:21,100
stored again.

4594
03:48:21,200 --> 03:48:26,400
Those actually can be described in here if you want to see them.

4595
03:48:27,000 --> 03:48:31,500
There's a whole bunch of information in here about how relocations

4596
03:48:31,500 --> 03:48:36,600
work you can see in here you've got import table specifications and

4597
03:48:36,600 --> 03:48:37,100
stuff like this.

4598
03:48:37,100 --> 03:48:40,800
You can actually see that stuff is all rigorous rigorously defined, we

4599
03:48:41,000 --> 03:48:41,200
I do.

4600
03:48:41,400 --> 03:48:44,700
I know the best place for it if there's a speck for this out here

4601
03:48:44,700 --> 03:48:46,300
somewhere, here it is.

4602
03:48:46,300 --> 03:48:49,600
So you can look at these and in the spec it would tell you exactly how

4603
03:48:49,600 --> 03:48:51,800
that was laid up laid out for example.

4604
03:48:53,800 --> 03:48:54,500
And go from there.

4605
03:48:54,800 --> 03:48:56,500
Also, probably the map, Patrick article.

4606
03:48:56,500 --> 03:48:59,200
I suspect this probably is a good tutorial on it as well.

4607
03:48:59,200 --> 03:49:00,000
Oh, and here you go.

4608
03:49:00,100 --> 03:49:04,300
So, Matt, Patrick writes pretty good articles about the sorts of

4609
03:49:04,300 --> 03:49:04,500
things.

4610
03:49:04,500 --> 03:49:06,200
Like one of the windows internals guys, right?

4611
03:49:06,300 --> 03:49:06,900
I believe.

4612
03:49:09,300 --> 03:49:10,500
Yeah, he's the one who's Charles got.

4613
03:49:10,800 --> 03:49:15,100
So if you want a something that's less dry, his articles would

4614
03:49:15,100 --> 03:49:17,700
probably tell you all about how that stuff is encoded in there, right?

4615
03:49:18,900 --> 03:49:20,500
But again, it's really academic.

4616
03:49:20,700 --> 03:49:23,200
All you really need to know is that there's some kind of binary

4617
03:49:23,200 --> 03:49:25,400
encoding, just like the kinds, we develop on him, a hero for storing,

4618
03:49:25,400 --> 03:49:26,200
art assets.

4619
03:49:26,400 --> 03:49:30,400
They just encoded in binary something that says, hey, here's I open

4620
03:49:30,400 --> 03:49:31,100
the file.

4621
03:49:31,300 --> 03:49:32,700
I got to look at the file and go.

4622
03:49:32,700 --> 03:49:34,100
Okay, where's the table?

4623
03:49:34,100 --> 03:49:34,900
So, I need some header.

4624
03:49:34,900 --> 03:49:36,100
That tells me where the table is, I go.

4625
03:49:36,100 --> 03:49:38,700
Look at the table, the table says, how many entries, it has in it for

4626
03:49:38,700 --> 03:49:39,100
each entry?

4627
03:49:39,100 --> 03:49:40,600
It has like here's how long the name is.

4628
03:49:40,800 --> 03:49:43,100
It has the name and where it is, right?

4629
03:49:43,100 --> 03:49:44,200
It's that kind of stuff.

4630
03:49:44,300 --> 03:49:46,300
So it's just the same things we're doing on him a hero.

4631
03:49:46,300 --> 03:49:48,300
The windows Dynamic Linker is exact same thing.

4632
03:49:48,300 --> 03:49:48,400
So,

4633
03:49:48,600 --> 03:49:52,000
A beautiful file reading that file into memory, right?

4634
03:49:52,000 --> 03:49:55,900
And and looking at the tables to figure out what it has to wire up,

4635
03:49:55,900 --> 03:49:56,900
it's nothing mysterious.

4636
03:49:56,900 --> 03:49:59,500
It's stuff that it's exact same code, we've already done in handmade

4637
03:49:59,500 --> 03:50:00,800
hero so

4638
03:50:02,300 --> 03:50:07,900
Once you've got that right, once you've got that happening, the only

4639
03:50:07,900 --> 03:50:12,100
real thing that I wanted to point out that underlies all of this.

4640
03:50:12,600 --> 03:50:15,900
And that we've never really talked about explicitly on handmade hero

4641
03:50:16,900 --> 03:50:22,100
is the notion that the CPU is executing code somewhere and the notion

4642
03:50:22,100 --> 03:50:23,100
that there's a stack.

4643
03:50:23,600 --> 03:50:25,100
And I don't want to go into those too much detail.

4644
03:50:25,100 --> 03:50:27,500
Because this has been a huge amount of information to cover in one

4645
03:50:27,500 --> 03:50:30,200
session, but hopefully it was a complete enough explanation that Now

4646
03:50:30,400 --> 03:50:31,100
function pointers are.

4647
03:50:31,900 --> 03:50:32,800
To a certain extent.

4648
03:50:32,800 --> 03:50:38,600
Anyway, I just want to cover one brief discussion of how that works to

4649
03:50:38,600 --> 03:50:39,100
ground.

4650
03:50:39,100 --> 03:50:41,900
It a little bit for you and maybe some other time we can go into more

4651
03:50:41,900 --> 03:50:43,300
detail about what these things mean.

4652
03:50:44,100 --> 03:50:46,000
So, what I want to do is show you now

4653
03:50:47,700 --> 03:50:48,800
Looking at this code.

4654
03:50:48,900 --> 03:50:52,200
First of all, I want to explain what it means to say that the

4655
03:50:52,200 --> 03:50:55,800
processor is executing code somewhere, right?

4656
03:50:55,900 --> 03:50:59,700
And what it means to say that a call is relative to our location,

4657
03:50:59,700 --> 03:50:59,800
right?

4658
03:51:00,000 --> 03:51:02,100
Those are kind of like nebulous words.

4659
03:51:02,600 --> 03:51:05,600
Well, what I want you to do is look at the register window in the

4660
03:51:05,600 --> 03:51:09,200
bugger and pay attention to this R.I.P, okay?

4661
03:51:09,200 --> 03:51:12,700
This is one of the registers in the processor r.i.p.

4662
03:51:14,100 --> 03:51:18,600
and what hopefully you can see is that the address in our IP is the

4663
03:51:18,600 --> 03:51:19,700
address we are at.

4664
03:51:20,200 --> 03:51:25,700
And when we executed instruction r.i.p., advances to the next

4665
03:51:25,700 --> 03:51:26,400
instruction.

4666
03:51:27,400 --> 03:51:29,100
This is actually.

4667
03:51:30,200 --> 03:51:34,000
How the processor is tracking, where it is, executing, right?

4668
03:51:34,100 --> 03:51:36,900
Quite literally, if I say, what is the value of r?

4669
03:51:36,900 --> 03:51:41,500
I p, it is always the address of the instruction that I am currently

4670
03:51:41,500 --> 03:51:43,100
executing literally.

4671
03:51:43,600 --> 03:51:48,600
If I were to change the contents of this register, I want to go back

4672
03:51:48,600 --> 03:51:54,100
and instruction so I cut and pasted into here the address like so I

4673
03:51:54,100 --> 03:51:56,800
move the instruction pointer literally.

4674
03:51:57,800 --> 03:51:58,400
You can see that.

4675
03:51:58,400 --> 03:52:00,200
I just did it, right?

4676
03:52:00,300 --> 03:52:01,600
Let's move it back further.

4677
03:52:03,200 --> 03:52:05,200
I don't know, let's move it there.

4678
03:52:06,000 --> 03:52:07,200
I don't even think that's legal.

4679
03:52:07,200 --> 03:52:10,400
What I just did, but that's what happens, right?

4680
03:52:10,400 --> 03:52:13,900
I just moved it to some totally nonsense location and that's just what

4681
03:52:13,900 --> 03:52:15,300
goes on, right?

4682
03:52:16,500 --> 03:52:19,200
So when I say we are X, the processors executing at a particular

4683
03:52:19,200 --> 03:52:19,700
location.

4684
03:52:20,000 --> 03:52:22,000
What that means is actually very concrete.

4685
03:52:22,000 --> 03:52:23,100
It's not abstract.

4686
03:52:23,200 --> 03:52:27,600
There is literally a register in the processor that register literally

4687
03:52:27,600 --> 03:52:30,800
contains the virtual byte address.

4688
03:52:31,100 --> 03:52:32,800
Again, this is in the processes address space.

4689
03:52:33,100 --> 03:52:35,500
So it goes through the virtual table, it's not a physical memory

4690
03:52:35,500 --> 03:52:37,600
addresses of virtual memory address, so it still goes to the mapping

4691
03:52:37,600 --> 03:52:42,700
table to virtual memory it, but it holds the virtual address at which

4692
03:52:42,700 --> 03:52:44,800
code is being executed at that time.

4693
03:52:45,000 --> 03:52:47,900
And if the value in that register changes, it is executing at a

4694
03:52:47,900 --> 03:52:49,300
different place period.

4695
03:52:50,200 --> 03:52:54,400
The definition of an executing, an instruction is to read what is at

4696
03:52:54,400 --> 03:52:55,800
that location and execute it?

4697
03:52:56,200 --> 03:52:59,700
According to the rules of x64 instruction encoding and to advance

4698
03:52:59,700 --> 03:53:00,400
r.i.p.

4699
03:53:00,500 --> 03:53:02,500
by the number of bytes it consumed.

4700
03:53:02,700 --> 03:53:06,200
Every time that is all we are doing, right?

4701
03:53:07,800 --> 03:53:13,600
So when I say that this call in coded, the location relative to the

4702
03:53:13,600 --> 03:53:14,500
current place.

4703
03:53:15,100 --> 03:53:19,200
What I mean to say is that after it consumes the bites of this call,

4704
03:53:19,200 --> 03:53:22,800
our IP will have advanced by that many bites and is now at a

4705
03:53:22,800 --> 03:53:26,600
particular value, the value that you put in here is quite

4706
03:53:26,600 --> 03:53:29,300
specifically, or sorry, I shouldn't say that value put in here.

4707
03:53:29,300 --> 03:53:30,700
This is the translation of it.

4708
03:53:30,700 --> 03:53:34,000
The value that you put right here in the actual instruction, encoding

4709
03:53:34,700 --> 03:53:37,100
the value that you put right there is literally the

4710
03:53:37,200 --> 03:53:44,500
The Delta between what RIPD the the register equals after the

4711
03:53:44,500 --> 03:53:48,500
instruction has been decoded and where you would like it to go, it's

4712
03:53:48,500 --> 03:53:49,800
the Delta, right?

4713
03:53:50,200 --> 03:53:53,400
This is actually called, Rip relative addressing I believe

4714
03:53:56,200 --> 03:53:59,800
Jimmy because it is addressing relative to our IP.

4715
03:54:00,200 --> 03:54:03,500
And what it means is that when you have instructions that support rep

4716
03:54:03,500 --> 03:54:08,000
relative addressing, you can encode instead of an absolute offset and

4717
03:54:08,000 --> 03:54:11,900
offset relative to the instruction pointer at that time, okay?

4718
03:54:13,100 --> 03:54:17,500
Also same thing with the stack, the stack which we always talk about

4719
03:54:17,500 --> 03:54:20,100
what is this talking to set up the stack of just a stack blah blah,

4720
03:54:20,500 --> 03:54:23,200
the stack is just by convention.

4721
03:54:24,100 --> 03:54:27,000
There's nothing really magic about the stack other than I believe push

4722
03:54:27,000 --> 03:54:29,900
and pop calls have built into them and

4723
03:54:30,000 --> 03:54:32,700
Ending of the fact that there's a particular register that stores the

4724
03:54:32,700 --> 03:54:32,900
stack.

4725
03:54:32,900 --> 03:54:34,700
But other than that, the stack is meaningless.

4726
03:54:34,700 --> 03:54:38,800
The stock is just a convention that's obeyed by when code is generated

4727
03:54:39,100 --> 03:54:44,500
point being our SP, the register is just the pointer to the, the

4728
03:54:44,500 --> 03:54:46,600
program stack, the code stack, right?

4729
03:54:47,600 --> 03:54:50,300
So all the time, when you see things address on the stack, it's just

4730
03:54:50,300 --> 03:54:53,100
our SP plus some number, right?

4731
03:54:53,100 --> 03:54:56,500
So it's saying, here's here's where the stack pointer is at and I'm

4732
03:54:56,500 --> 03:54:58,400
going to reference off of that all the time.

4733
03:54:58,900 --> 03:54:59,900
So, again, the

4734
03:55:00,200 --> 03:55:03,200
And the instruction pointer the stack pointer partner.

4735
03:55:03,200 --> 03:55:06,800
I actually just registers that are just there there's nothing magical

4736
03:55:06,800 --> 03:55:08,300
about them either.

4737
03:55:08,500 --> 03:55:13,400
They're just numbers that store where in the virtual address space

4738
03:55:13,400 --> 03:55:15,400
stuff is, that's it.

4739
03:55:15,600 --> 03:55:19,900
So none of this is mysterious at all, there's nothing weird about the

4740
03:55:19,900 --> 03:55:22,100
relative to where we are, or what we are means.

4741
03:55:22,100 --> 03:55:25,300
It's, it's very concrete the r.i.p.

4742
03:55:25,300 --> 03:55:29,800
registers stores where we are and when we say, we're going to be

4743
03:55:29,900 --> 03:55:31,600
Relative to where we are.

4744
03:55:31,600 --> 03:55:34,200
We just mean our IP plus some number

4745
03:55:37,500 --> 03:55:48,000
Okay, let's go ahead and just and go to a brief Q&A here.

4746
03:55:48,300 --> 03:55:53,700
I hope I've covered everything that you might want to know, but I'll

4747
03:55:53,700 --> 03:55:56,200
take some questions in case there were things that that kind of

4748
03:55:56,200 --> 03:55:56,800
slipped by.

4749
03:55:56,800 --> 03:56:00,000
So so let's go ahead and do that.

4750
03:56:00,000 --> 03:56:03,700
I think H MH D butter whatever is dead so I can't.

4751
03:56:03,900 --> 03:56:07,500
So it's not dead in the handmade hero chat but it is dead in the

4752
03:56:07,600 --> 03:56:13,000
Twitch chat, I guess, for whatever reason.

4753
03:56:25,300 --> 03:56:26,900
So, pseudonym 73.

4754
03:56:27,300 --> 03:56:28,400
Also

4755
03:56:30,300 --> 03:56:32,100
Also known as our resident math.

4756
03:56:32,100 --> 03:56:34,300
Expert is

4757
03:56:39,200 --> 03:56:46,500
Is saying that www II see si.com Linker is worth a plug and if he says

4758
03:56:46,500 --> 03:56:50,700
so he's probably correct but I don't know what that is.

4759
03:56:52,100 --> 03:56:57,900
Oh it's a linkers and loaders Thing by John Levine so let's try and

4760
03:56:57,900 --> 03:56:59,800
get that up on the screen there because that probably

4761
03:57:00,000 --> 03:57:08,600
Pretty good thing to know, www.is, EC.com Linker here you go.

4762
03:57:09,400 --> 03:57:12,000
Here's the chapters of that book that talks about all this stuff.

4763
03:57:12,000 --> 03:57:12,400
Look at that.

4764
03:57:12,400 --> 03:57:13,000
That's great.

4765
03:57:13,000 --> 03:57:15,500
So this would be a great thing for marine that go into a lot more

4766
03:57:15,500 --> 03:57:17,800
depth than I would

4767
03:57:20,200 --> 03:57:20,900
But why not?

4768
03:57:20,900 --> 03:57:23,300
One says technically you need to call flush instruction cache.

4769
03:57:23,300 --> 03:57:27,300
When you generate code, I don't think that's actually true, is it you

4770
03:57:27,300 --> 03:57:29,000
only need to call flush instruction cache?

4771
03:57:29,000 --> 03:57:34,100
If the instruction cache could have had those instructions in it,

4772
03:57:34,100 --> 03:57:37,300
which if you've never executed the code before, it can't write.

4773
03:57:37,900 --> 03:57:40,400
So is that actually true?

4774
03:57:45,500 --> 03:57:49,600
I suppose, maybe it's true because virtual Alec could have given you

4775
03:57:49,600 --> 03:57:53,200
back a thing that was Matt, well, but

4776
03:57:59,800 --> 03:58:00,700
So that's a good question.

4777
03:58:00,700 --> 03:58:01,500
I don't really know.

4778
03:58:02,200 --> 03:58:04,900
Maybe you do, maybe you don't, I don't really know.

4779
03:58:06,500 --> 03:58:07,800
That's a really good question.

4780
03:58:16,900 --> 03:58:18,300
Well, let's talk about what that means.

4781
03:58:18,300 --> 03:58:22,600
It probably is true that you should call it because if it, if it, if

4782
03:58:22,600 --> 03:58:27,900
it may have had that piece of memory in previously for another reason,

4783
03:58:40,300 --> 03:58:44,500
well I'm going to say what this is and we'll leave whether or not this

4784
03:58:44,500 --> 03:58:48,200
in this particular case you actually have to call it as an exercise

4785
03:58:48,200 --> 03:58:51,300
for the reader because I'll be honest I really don't know if you do or

4786
03:58:51,300 --> 03:58:56,700
don't I would suspect that you don't in this case need to call it, but

4787
03:58:56,700 --> 03:59:01,300
that may not be true because it may be the case that

4788
03:59:03,300 --> 03:59:05,300
Well yeah, I mean the instruction prefetch.

4789
03:59:05,300 --> 03:59:08,300
Maybe could hit it before you got there or something, and then be

4790
03:59:08,300 --> 03:59:08,600
wrong.

4791
03:59:08,600 --> 03:59:10,100
I don't know if that's how that works.

4792
03:59:12,300 --> 03:59:15,700
My knowledge of the Ecstasy for CPU is simply not good enough to say.

4793
03:59:16,100 --> 03:59:21,200
So, I'll just simply say what this is talking about and why you may

4794
03:59:21,200 --> 03:59:23,300
need to call it or may not.

4795
03:59:25,400 --> 03:59:30,000
So we all know from talking about it, on handmade here, obviously,

4796
03:59:30,000 --> 03:59:32,000
that data always goes through a cash, right?

4797
03:59:32,000 --> 03:59:34,400
In the processor, there's this cash sitting there and the reason for

4798
03:59:34,400 --> 03:59:37,400
that is because typically speaking when a processor touches the piece

4799
03:59:37,400 --> 03:59:39,200
of data, it's probably going to touch it more than once.

4800
03:59:39,400 --> 03:59:41,900
So usually when the processor goes and does some

4801
03:59:42,100 --> 03:59:44,600
Operation, on memory nowadays, it goes through a cache.

4802
03:59:44,600 --> 03:59:47,800
The cache is designed to be a smaller version of memory, that's faster

4803
03:59:47,800 --> 03:59:48,700
to operate on.

4804
03:59:48,800 --> 03:59:51,800
So things, move into the cache much like they move into registers

4805
03:59:51,800 --> 03:59:52,600
which are even faster.

4806
03:59:52,600 --> 03:59:55,600
It's kind of like this tiered system of things come from memory to L3,

4807
03:59:55,600 --> 03:59:59,300
cache to L2 cache, L1 cache, two registers back out to L1, L2, L3, and

4808
03:59:59,300 --> 03:59:59,800
so on, right?

4809
04:00:00,000 --> 04:00:00,600
How that works.

4810
04:00:01,100 --> 04:00:03,000
Well, the same thing is true for instructions.

4811
04:00:03,000 --> 04:00:05,200
Instructions actually go into a cash as well.

4812
04:00:05,400 --> 04:00:08,700
And the interesting thing about this cash is this cash may actually

4813
04:00:08,700 --> 04:00:11,800
not store the actual contents of the instructions.

4814
04:00:13,700 --> 04:00:18,300
What this cash actually stores potentially are the Micro Ops of the

4815
04:00:18,300 --> 04:00:18,800
instructions.

4816
04:00:18,800 --> 04:00:22,700
So there's actually different kinds of caches, there's caching the

4817
04:00:22,700 --> 04:00:25,800
actual bytes of data that form the instructions.

4818
04:00:26,100 --> 04:00:28,500
And that's one way that the instructions might be cached.

4819
04:00:28,500 --> 04:00:29,800
But there's another thing called a Trace

4820
04:00:30,000 --> 04:00:32,500
Cash which oppressor can have, which is the thing that actually

4821
04:00:32,500 --> 04:00:33,000
stores?

4822
04:00:33,400 --> 04:00:36,100
A more specific decomposed version.

4823
04:00:36,100 --> 04:00:39,700
That the processors already looked at and potentially stored in an

4824
04:00:39,700 --> 04:00:43,200
even more decomposed form than the assembly language.

4825
04:00:43,200 --> 04:00:45,400
Do something that's more specific to the processor and how it's going

4826
04:00:45,400 --> 04:00:46,100
to execute it.

4827
04:00:46,200 --> 04:00:48,900
So there's actually multiple ways in which code can be cashing.

4828
04:00:48,900 --> 04:00:51,700
The cash just in terms of caching the memory, but it can also be

4829
04:00:51,700 --> 04:00:56,700
cashed in a way that that has actually sort of dis disaggregated the

4830
04:00:56,700 --> 04:00:59,800
code into smaller pieces, like Micro Ops that the op that

4831
04:01:00,100 --> 04:01:02,000
A processor actually wants to operate on.

4832
04:01:02,300 --> 04:01:06,200
So there's multiple ways in which codes can be cached, and if the

4833
04:01:06,200 --> 04:01:09,200
processor is not smart enough in a particular circumstance to know

4834
04:01:09,200 --> 04:01:13,400
that you have modified a piece of code and that it needs to invalidate

4835
04:01:13,400 --> 04:01:14,300
its cash.

4836
04:01:14,500 --> 04:01:15,700
You can tell it.

4837
04:01:15,700 --> 04:01:17,000
So that's what this function is.

4838
04:01:17,000 --> 04:01:21,600
It's flush instruction cache and basically what it does is it says I'm

4839
04:01:21,600 --> 04:01:25,700
going to give you a pointer and a size and I want you to take

4840
04:01:25,700 --> 04:01:28,100
everything that's in there and assume that you're going to have to

4841
04:01:28,100 --> 04:01:28,700
reek.

4842
04:01:31,000 --> 04:01:34,600
Refresh your caches of that if they happen to be there for it for

4843
04:01:34,600 --> 04:01:35,900
execution, right?

4844
04:01:36,100 --> 04:01:39,000
And so, if we want to do that, what we would do is after we generated

4845
04:01:39,000 --> 04:01:43,700
the code, we would call flush instruction cache with the actual.

4846
04:01:43,700 --> 04:01:45,900
I should put that pure as well, because this is another

4847
04:01:48,100 --> 04:01:48,800
One of these.

4848
04:01:51,600 --> 04:01:54,500
We've this is a symptom signed don't quote me on that.

4849
04:01:55,100 --> 04:02:03,500
This is a handle, this is a LP void and this is another one of those

4850
04:02:03,500 --> 04:02:04,600
size tease.

4851
04:02:11,900 --> 04:02:14,900
Okay, so there's our flush instruction cache and we're going to have

4852
04:02:14,900 --> 04:02:17,300
to deal with this definition of handle in a second here.

4853
04:02:18,100 --> 04:02:20,700
But then we're going to have to do is we're going to have to pass

4854
04:02:20,800 --> 04:02:24,100
flushing destruction cast, something for that handle but then we're

4855
04:02:24,100 --> 04:02:27,200
just going to be able to do exactly what we did for our virtual Alec

4856
04:02:27,200 --> 04:02:29,800
so we can pass that and the code size.

4857
04:02:29,800 --> 04:02:32,400
So what we really want to do here is just say how big is our code

4858
04:02:32,400 --> 04:02:32,900
page.

4859
04:02:33,600 --> 04:02:38,400
So we'll say code page size and we'll just say 4096 and then we'll

4860
04:02:38,400 --> 04:02:41,500
say, Okay, past that here pass that

4861
04:02:41,600 --> 04:02:44,000
There and that will flush the instruction cache.

4862
04:02:44,000 --> 04:02:45,000
Now, the handle

4863
04:02:46,700 --> 04:02:52,200
in this case 4-H process again, we sort of have this problem of where

4864
04:02:52,200 --> 04:02:53,100
we going to get that from.

4865
04:02:53,300 --> 04:02:55,600
And furthermore, we need a way to get our actual process.

4866
04:02:55,600 --> 04:02:59,800
I believe I showed this on handmade hero but the get

4867
04:03:00,000 --> 04:03:03,400
Handle function actually will do that for us.

4868
04:03:03,800 --> 04:03:04,400
I don't know.

4869
04:03:04,400 --> 04:03:07,100
Can we pass 04 that I should have double-checked?

4870
04:03:07,500 --> 04:03:08,800
I don't know if we can.

4871
04:03:09,200 --> 04:03:10,100
I don't think so.

4872
04:03:10,100 --> 04:03:14,100
Although sometimes you can and they don't say so I don't actually know

4873
04:03:14,100 --> 04:03:17,400
but I'll go ahead and do the full version anyway.

4874
04:03:17,700 --> 04:03:20,700
Get module handle gets the process handle and windows of the

4875
04:03:20,700 --> 04:03:26,500
particular process and you can pass zero for the module handle name

4876
04:03:26,500 --> 04:03:26,900
there.

4877
04:03:27,200 --> 04:03:29,000
So, in this case, I've got this

4878
04:03:31,300 --> 04:03:31,900
Like so.

4879
04:03:34,200 --> 04:03:36,600
Long prayer to a string module name.

4880
04:03:38,100 --> 04:03:38,700
There we go.

4881
04:03:39,300 --> 04:03:44,100
And so I'm going to go ahead and just pass get module handle.

4882
04:03:46,300 --> 04:03:47,000
Zero here.

4883
04:03:47,300 --> 04:03:49,800
And so the only thing that we really need now is a definition for

4884
04:03:49,800 --> 04:03:54,600
these two things of of handle and of H module, which we don't

4885
04:03:54,600 --> 04:03:55,300
currently have.

4886
04:03:55,300 --> 04:03:58,000
But again, I can do the exact same thing I did before to get those

4887
04:03:58,000 --> 04:04:00,300
definitions into our program here.

4888
04:04:02,400 --> 04:04:04,600
And if you're wondering why I'm doing this sort of just lb including

4889
04:04:04,600 --> 04:04:08,600
windows .h, it's because I wanted to keep it so that we are completely

4890
04:04:08,600 --> 04:04:09,500
in control the process.

4891
04:04:09,700 --> 04:04:12,300
And we are, we are providing all of the code that's actually getting

4892
04:04:12,300 --> 04:04:14,900
compiled because that's kind of the you know, low-level sir.

4893
04:04:15,100 --> 04:04:17,100
That we were doing so here.

4894
04:04:17,100 --> 04:04:20,500
If I do get module handle, right?

4895
04:04:22,200 --> 04:04:27,000
And I ask for the definition of that, you can see here that with it

4896
04:04:27,100 --> 04:04:32,600
goes to ask you version there, and let's take a look at the H.

4897
04:04:32,600 --> 04:04:34,700
Module definition, go to definition.

4898
04:04:35,500 --> 04:04:37,400
You can see that there's a bunch of typedefs here.

4899
04:04:37,400 --> 04:04:38,900
It's actually an H.

4900
04:04:38,900 --> 04:04:43,100
Instance, is what that is and declare handle is used for that.

4901
04:04:43,400 --> 04:04:44,900
We need to go to declare

4902
04:04:45,000 --> 04:04:45,500
Andal.

4903
04:04:46,900 --> 04:04:50,900
And you can see that basically it's just an anonymous struct with an

4904
04:04:50,900 --> 04:04:52,400
intent in it, right?

4905
04:04:52,400 --> 04:04:54,000
That's about all that's happening here.

4906
04:04:54,600 --> 04:04:59,300
And so if we want to create one of those, we can pretty simply by just

4907
04:04:59,300 --> 04:05:05,500
saying, okay really all we're talking about here for a handle is this

4908
04:05:07,400 --> 04:05:10,500
and I believe it doesn't matter at all.

4909
04:05:10,500 --> 04:05:13,400
These are just things that get it seems they're just dummies trucks

4910
04:05:13,700 --> 04:05:15,900
dummy, ways of talking about it, right?

4911
04:05:16,500 --> 04:05:18,300
So I believe we should be fine here.

4912
04:05:18,400 --> 04:05:20,200
Oops, gotta have that semicolon there.

4913
04:05:21,100 --> 04:05:24,500
And now our get module handle unresolved.

4914
04:05:24,500 --> 04:05:25,600
Eternal symbol.

4915
04:05:25,600 --> 04:05:26,500
Is that really true?

4916
04:05:32,100 --> 04:05:32,400
Right?

4917
04:05:32,500 --> 04:05:35,500
It's because we need the ASCII version of that, maybe it doesn't

4918
04:05:35,500 --> 04:05:36,900
really matter which one we have there.

4919
04:05:39,000 --> 04:05:39,500
There we go.

4920
04:05:40,200 --> 04:05:44,400
So now we can call flush instruction cache as well which again I don't

4921
04:05:44,400 --> 04:05:48,400
really know that in this case we absolutely needed to do but it's a

4922
04:05:48,400 --> 04:05:50,600
good point to bring up regardless.

4923
04:05:52,200 --> 04:05:55,600
So if I come back here to our code here, we should now be able to call

4924
04:05:55,600 --> 04:05:56,400
both of those functions.

4925
04:05:56,400 --> 04:05:58,900
So, here's the virtual AA call, right?

4926
04:05:58,900 --> 04:05:59,800
That's calling through here.

4927
04:06:00,600 --> 04:06:04,100
Then we're going to generate all the code, so here's all the code gen

4928
04:06:04,400 --> 04:06:05,400
etc, etc, etc.

4929
04:06:05,900 --> 04:06:12,100
Then we're going to call, I guess, after all the koujun, we have to

4930
04:06:12,100 --> 04:06:16,700
call get module handle, a, and we have to call flush instruction

4931
04:06:16,700 --> 04:06:17,300
cache.

4932
04:06:17,700 --> 04:06:19,100
So let's take a look here.

4933
04:06:24,400 --> 04:06:25,100
There we go.

4934
04:06:25,300 --> 04:06:28,400
I believe that's the get module handle, although we should actually

4935
04:06:28,400 --> 04:06:32,100
cut the dump in to verify that I believe this is the flesh instruction

4936
04:06:32,100 --> 04:06:33,900
cache cache.

4937
04:06:37,300 --> 04:06:38,500
And actually correct.

4938
04:06:43,700 --> 04:06:44,200
Let's take it.

4939
04:06:44,200 --> 04:06:45,300
Let's look at the done.

4940
04:06:46,500 --> 04:06:48,300
I don't want to say that because I have to look at that a little bit.

4941
04:06:48,300 --> 04:06:52,600
I have to look at that a little more closely before I would be able to

4942
04:06:52,600 --> 04:06:53,400
say that, that was true.

4943
04:06:55,300 --> 04:06:57,600
Cannot open input file, that's because we're not in the right

4944
04:06:57,600 --> 04:06:58,100
directory.

4945
04:07:01,800 --> 04:07:05,000
All right, let me actually.

4946
04:07:08,600 --> 04:07:11,800
Okay, so yeah, you can see, here's the call, get module handle a right

4947
04:07:11,800 --> 04:07:14,500
there and there's the flush instruction cache.

4948
04:07:14,700 --> 04:07:17,900
So if I actually come back here and take a look at it and kind of

4949
04:07:17,900 --> 04:07:23,000
scroll down past all the code flowing out there after the leaa

4950
04:07:25,500 --> 04:07:26,000
There we go.

4951
04:07:27,000 --> 04:07:30,300
So there's the Ellie, and then there's the call to get module handle.

4952
04:07:30,300 --> 04:07:31,200
So there it is.

4953
04:07:32,000 --> 04:07:33,500
The call right here.

4954
04:07:33,700 --> 04:07:37,300
And what you can actually see here is that it's again, there's that

4955
04:07:37,400 --> 04:07:38,800
the Linker has patched it, right?

4956
04:07:38,800 --> 04:07:41,100
You can see that the patching happened there because before there

4957
04:07:41,100 --> 04:07:41,900
wasn't anything here.

4958
04:07:41,900 --> 04:07:43,200
And now there is a 73, right?

4959
04:07:43,200 --> 04:07:47,200
So there's the patch that the Linker did and then similarly, here's

4960
04:07:47,200 --> 04:07:49,900
the patch again and you can see that these were indirect patches.

4961
04:07:50,100 --> 04:07:52,000
So the Linker, probably patch this one.

4962
04:07:52,000 --> 04:07:54,400
And then the dynamic Linker, patched this one

4963
04:07:55,200 --> 04:07:56,900
Right, it patched this right here.

4964
04:07:57,700 --> 04:08:00,500
So it's kind of a double indirection, right?

4965
04:08:00,700 --> 04:08:03,900
And in fact, that's when you've got a bunch of these you can see how

4966
04:08:03,900 --> 04:08:04,600
it decide to do that.

4967
04:08:04,600 --> 04:08:07,400
So instead of welding that call indirectly, it did a double disc

4968
04:08:07,700 --> 04:08:09,400
interaction there but there you go.

4969
04:08:30,600 --> 04:08:39,600
Let's see insofar as says, I think something like / section, colon dot

4970
04:08:39,600 --> 04:08:40,100
data.

4971
04:08:40,100 --> 04:08:41,400
/ RW e.

4972
04:08:41,400 --> 04:08:43,900
+ /n, x compat:.

4973
04:08:43,900 --> 04:08:46,900
No, to link XE might work for the non-virtual.

4974
04:08:46,900 --> 04:08:48,300
Protect code in a real thing.

4975
04:08:48,300 --> 04:08:51,300
So, yeah, like I said, I don't really know.

4976
04:08:51,300 --> 04:08:53,100
You might be right?

4977
04:08:57,000 --> 04:08:59,800
in theory, the executable has

4978
04:09:00,000 --> 04:09:00,200
It.

4979
04:09:00,200 --> 04:09:02,500
Here are my data sections here, my code sections.

4980
04:09:02,500 --> 04:09:05,200
Here's how I need you to Mark those when you load them mr.

4981
04:09:05,200 --> 04:09:05,800
Windows.

4982
04:09:05,900 --> 04:09:06,400
Right.

4983
04:09:08,000 --> 04:09:11,700
And I guess the thing about that is just that yeah, there's probably a

4984
04:09:11,700 --> 04:09:13,600
magic incantation that lets you say.

4985
04:09:13,800 --> 04:09:18,400
I want my data segment to be executable please but I didn't want to

4986
04:09:18,400 --> 04:09:20,700
try and figure out what that was so that may be, right?

4987
04:09:22,900 --> 04:09:26,200
I have no idea but they're almost certainly is some way to do it.

4988
04:09:30,200 --> 04:09:32,700
an acre 314, who is the person who originally asked the question,

4989
04:09:32,900 --> 04:09:35,600
maybe this episode belongs to the intro to see week as episode six,

4990
04:09:35,900 --> 04:09:36,500
Maybe

4991
04:09:39,700 --> 04:09:45,300
Is there 549 may be the smallest CRT ever and it's a link to

4992
04:09:45,300 --> 04:09:45,900
something.

4993
04:09:47,700 --> 04:09:48,400
Let's see here.

4994
04:10:02,300 --> 04:10:04,700
Feel Adele ski says, is there a little reason?

4995
04:10:04,700 --> 04:10:06,200
You don't like virtual functions?

4996
04:10:06,700 --> 04:10:09,100
My understanding of them is that they're basically just function

4997
04:10:09,100 --> 04:10:09,900
pointers in a table.

4998
04:10:09,900 --> 04:10:10,800
That is dereferenced.

4999
04:10:11,000 --> 04:10:12,600
Yes, there actually is a low-level reason.

5000
04:10:12,600 --> 04:10:14,800
I don't like virtual functions and that is that they are uncie

5001
04:10:14,800 --> 04:10:15,600
realizable.

5002
04:10:16,500 --> 04:10:21,300
So, one of my main complaints with and and furthermore, I can't patch

5003
04:10:21,300 --> 04:10:21,500
them.

5004
04:10:21,500 --> 04:10:21,900
Right.

5005
04:10:22,100 --> 04:10:26,300
One of my main complaints with the way, C++ does virtual function

5006
04:10:26,300 --> 04:10:26,900
calls is.

5007
04:10:26,900 --> 04:10:30,800
It's an opaque system, so you're not allowed to specify how it's

5008
04:10:30,800 --> 04:10:31,400
working.

5009
04:10:31,800 --> 04:10:38,600
You can't say, for example, that what you want to have inside your

5010
04:10:38,900 --> 04:10:43,800
structs or classes is just an integer that says, what class it is.

5011
04:10:43,800 --> 04:10:47,100
And then that integer looks up into a dispatch table somewhere else,

5012
04:10:47,100 --> 04:10:49,400
or something like that, which would be serializable.

5013
04:10:49,400 --> 04:10:55,000
For example, so low level wise virtual functions are just not very

5014
04:10:55,000 --> 04:10:55,700
good, right?

5015
04:10:55,700 --> 04:10:59,100
They don't give you the control that you need that you have if you

5016
04:10:59,100 --> 04:11:00,600
actually build your own function pointer.

5017
04:11:00,600 --> 04:11:01,200
Tables.

5018
04:11:01,700 --> 04:11:04,000
As you can do anything you want there, you can have them be double

5019
04:11:04,000 --> 04:11:05,300
dispatch, single dispatch.

5020
04:11:05,300 --> 04:11:08,000
You can have them dispatch off an integer that you control that

5021
04:11:08,000 --> 04:11:09,000
serializable.

5022
04:11:09,400 --> 04:11:10,300
You can put it anywhere.

5023
04:11:10,300 --> 04:11:12,800
You want in the struct, you can get rid of it in the struct if you

5024
04:11:12,800 --> 04:11:14,800
don't need it because you can infer it for something else.

5025
04:11:15,700 --> 04:11:16,400
So yeah.

5026
04:11:16,400 --> 04:11:19,100
Like like I don't really like anything about virtual functions right

5027
04:11:19,100 --> 04:11:19,300
there.

5028
04:11:19,300 --> 04:11:22,000
They're a bad feature because they take control away from the program

5029
04:11:22,000 --> 04:11:23,000
that they actually need.

5030
04:11:23,100 --> 04:11:23,900
There's a good way.

5031
04:11:23,900 --> 04:11:27,400
They could have done that and C++, they didn't do it because they

5032
04:11:27,400 --> 04:11:31,000
chose not to give you the control that you need in order to write.

5033
04:11:31,700 --> 04:11:33,800
Code, that's flexible and interesting.

5034
04:11:35,300 --> 04:11:38,100
They chose to go with the really procrustean version that takes a lot

5035
04:11:38,100 --> 04:11:41,500
of away Along the power that you get if you're actually using function

5036
04:11:41,500 --> 04:11:42,100
pointers yourself.

5037
04:11:45,300 --> 04:11:47,800
Engineering says, first of all, thank you so much for this stream.

5038
04:11:48,000 --> 04:11:49,800
You are very welcome at the beginning.

5039
04:11:49,800 --> 04:11:52,400
You mentioned you hadn't done some of these things for a while.

5040
04:11:52,400 --> 04:11:55,500
My question is in, what context did you originally?

5041
04:11:55,500 --> 04:11:56,200
Learn and apply.

5042
04:11:56,200 --> 04:11:57,000
All this information.

5043
04:11:57,000 --> 04:11:58,800
It seems like spending time at work exploring.

5044
04:11:58,800 --> 04:11:59,800
This may be considered time

5045
04:12:00,800 --> 04:12:03,500
Taken away from actually being quote, unquote, productive is it just

5046
04:12:03,500 --> 04:12:05,500
something you have to learn on your own time.

5047
04:12:06,700 --> 04:12:10,500
I guess I would say that it depends on the place that you work for.

5048
04:12:10,600 --> 04:12:14,900
You know, if you work for a company that values low-level programming

5049
04:12:14,900 --> 04:12:19,500
skills and people who can debug very difficult problems and also

5050
04:12:19,500 --> 04:12:23,700
create, you know, creative Technical Solutions to things they should

5051
04:12:23,700 --> 04:12:25,200
value this quite highly.

5052
04:12:26,200 --> 04:12:29,400
I cannot imagine the situation where, you know, Jeff would have come

5053
04:12:29,400 --> 04:12:30,000
into my office at

5054
04:12:30,400 --> 04:12:31,700
Add and found me.

5055
04:12:31,700 --> 04:12:34,700
Looking at how something was happening in a link loader, and telling

5056
04:12:34,700 --> 04:12:37,000
me that I was wasting my time, you probably would have been delighted

5057
04:12:37,000 --> 04:12:40,200
and probably would have helped explain it to me because he's a very

5058
04:12:41,000 --> 04:12:42,300
talented level programmer.

5059
04:12:43,300 --> 04:12:45,600
And so that's just the nature of where you work.

5060
04:12:45,700 --> 04:12:49,300
If you work at a company whose like main job is to, like stack python

5061
04:12:49,300 --> 04:12:54,300
on top of JavaScript, on top of, you know, 12, you know, piles of

5062
04:12:54,400 --> 04:12:59,700
libraries 10 high to get sort of a, some weird thing working on top of

5063
04:12:59,700 --> 04:13:00,000
the Google.

5064
04:13:00,100 --> 04:13:00,900
Maps API.

5065
04:13:00,900 --> 04:13:03,600
Yeah, they probably have no interest in you learning stuff because

5066
04:13:03,600 --> 04:13:06,500
when would it ever come up and it has nothing to do with you know,

5067
04:13:07,500 --> 04:13:09,300
getting the next round of venture capital or whatever.

5068
04:13:09,900 --> 04:13:13,200
It just depends on the attitude of the company I work for and what

5069
04:13:13,200 --> 04:13:14,000
their priorities are.

5070
04:13:14,200 --> 04:13:18,200
I can tell you that, we very rare for you to go to engine development

5071
04:13:18,200 --> 04:13:23,700
company for games and have somebody tell you that learning this stuff

5072
04:13:23,700 --> 04:13:26,600
is not a good use of your time at the company because this is

5073
04:13:26,600 --> 04:13:28,500
definitely a good use of your time, right?

5074
04:13:29,200 --> 04:13:30,000
But if you're at a

5075
04:13:30,200 --> 04:13:34,300
Higher level than that, I can easily see them saying that because it's

5076
04:13:34,300 --> 04:13:36,800
not relevant to what you do there, right?

5077
04:13:37,200 --> 04:13:40,000
And so, it's all dependent on what your job function is and what

5078
04:13:40,000 --> 04:13:40,600
you're doing.

5079
04:13:41,400 --> 04:13:44,400
Furthermore, I would say that in the web development context, I think

5080
04:13:44,400 --> 04:13:47,000
this would also not be wasting your time, if you're somebody who's

5081
04:13:47,000 --> 04:13:47,500
job, it is.

5082
04:13:47,500 --> 04:13:51,100
Let's say at Facebook to do like, back-end stuff where you have to

5083
04:13:51,100 --> 04:13:55,900
optimize like some crazy huge amounts of PHP code that's coming in and

5084
04:13:55,900 --> 04:13:58,700
you're trying to write this, like, compiler thing that's going to make

5085
04:13:58,700 --> 04:14:00,000
your stuff perform better.

5086
04:14:00,100 --> 04:14:03,000
Because you've got all this Legacy code that needs executor whatever.

5087
04:14:04,900 --> 04:14:09,000
You know, even if you're doing web development, there are places in

5088
04:14:09,000 --> 04:14:12,700
web development where the metal or what do they say?

5089
04:14:12,700 --> 04:14:15,900
The rubber hits the road, if you will and those people need to know

5090
04:14:15,900 --> 04:14:16,700
all these things.

5091
04:14:16,900 --> 04:14:21,300
So you know the people who are powering the Google search back end you

5092
04:14:21,300 --> 04:14:26,000
know base level stuff and the people who are working on optimizing,

5093
04:14:26,100 --> 04:14:30,000
you know Facebook's file IO stuff or whatever.

5094
04:14:30,200 --> 04:14:32,400
We all need to know this stuff.

5095
04:14:32,500 --> 04:14:35,900
And I don't think those divisions, even though they're in companies

5096
04:14:35,900 --> 04:14:38,100
that are piling libraries on top of libraries, in our libraries,

5097
04:14:38,100 --> 04:14:39,200
that's one part of company.

5098
04:14:39,400 --> 04:14:42,400
There's usually going to be a part of a company that cares a lot about

5099
04:14:42,400 --> 04:14:43,000
little programming.

5100
04:14:43,200 --> 04:14:45,700
Those people would not consider this a waste of your time.

5101
04:15:08,800 --> 04:15:11,100
So I think that's, it doesn't look like we have any more questions.

5102
04:15:11,100 --> 04:15:13,000
So I think I will just wrap it up there.

5103
04:15:14,900 --> 04:15:17,800
That was an incredibly long handmade hero stream to say, the very

5104
04:15:17,800 --> 04:15:22,400
least, but it covered just about everything that I wanted to cover and

5105
04:15:22,400 --> 04:15:24,400
hopefully it answered the original question.

5106
04:15:24,800 --> 04:15:29,300
Well enough to say that basically now like all of the parts of it are

5107
04:15:29,300 --> 04:15:33,000
demystified hopefully and there isn't any sort of like hand wavy weird

5108
04:15:33,000 --> 04:15:33,800
thing happening.

5109
04:15:36,000 --> 04:15:41,200
Where you're not really sure about what's really going on, right?

5110
04:15:42,600 --> 04:15:47,100
So anyway, hopefully that is, that is everything there is to say about

5111
04:15:47,100 --> 04:15:47,400
that.

5112
04:15:47,400 --> 04:15:50,000
In terms of an introduction, obviously there's loads more, you can

5113
04:15:50,000 --> 04:15:56,400
explore on your own, I do appreciate that link from from pseudonym 73,

5114
04:15:56,400 --> 04:15:59,700
which I bet is a great place to investigate more about that.

5115
04:15:59,700 --> 04:16:03,000
If you want to learn more about Dynamic linking or static linking and

5116
04:16:03,000 --> 04:16:04,700
all those sorts of things that we talked about.

5117
04:16:04,900 --> 04:16:05,600
So please do

5118
04:16:05,800 --> 04:16:11,000
That out if you're interested in more or post on the forums, and

5119
04:16:11,000 --> 04:16:11,700
that's about it.

5120
04:16:11,800 --> 04:16:16,300
So, thanks for joining me for another episode of handmade hero chat.

5121
04:16:16,400 --> 04:16:19,500
This time, if you have questions about the sort of stuff we covered,

5122
04:16:19,500 --> 04:16:24,800
you can ask it on the farm site and that is about it for this week.

5123
04:16:24,900 --> 04:16:30,100
Next week, we will be back to do regular game coding again until then

5124
04:16:30,100 --> 04:16:34,000
have fun, programming and exploring some hopefully low-level code

5125
04:16:34,000 --> 04:16:35,100
stuff on your own.

5126
04:16:36,200 --> 04:16:37,800
And I'll see everyone on the internet.

5127
04:16:37,800 --> 04:16:39,000
So take it easy everybody.

