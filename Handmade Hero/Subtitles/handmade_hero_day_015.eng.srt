1
00:00:00,000 --> 00:00:04,200
So I'm going to go ahead and hit that recording flip button there and

2
00:00:04,200 --> 00:00:05,500
we should be good to go.

3
00:00:05,800 --> 00:00:07,300
Welcome to handmade hero.

4
00:00:07,500 --> 00:00:09,600
It is a sleepy Friday morning here.

5
00:00:10,100 --> 00:00:13,900
The fact that I am always sick apparently now, which is a late motif,

6
00:00:13,900 --> 00:00:16,700
of course means that I never get any sleep, which is awesome.

7
00:00:17,300 --> 00:00:20,600
So I'm kind of a little blurry at this point a little bleary-eyed.

8
00:00:20,600 --> 00:00:25,600
But I think it should not stop us from doing what we need to do today,

9
00:00:26,000 --> 00:00:29,300
which is just some like last odds and ends in the win32 stuff.

10
00:00:30,000 --> 00:00:33,200
For we do next week will basically be clean up and transition over

11
00:00:33,200 --> 00:00:35,400
into game code is what I'm expecting.

12
00:00:35,700 --> 00:00:37,600
So I'm not sure exactly what we're going to do today.

13
00:00:37,600 --> 00:00:40,000
Besides the file I/O, we're going to have to kind of play it by ear.

14
00:00:40,000 --> 00:00:42,400
I need least need to show you a little file IO stuff.

15
00:00:42,900 --> 00:00:45,900
But other than that, we're going to have to kind of decide, maybe,

16
00:00:45,900 --> 00:00:46,900
probably Midway through the stream.

17
00:00:46,900 --> 00:00:47,900
Exact, what we're going to do.

18
00:00:48,300 --> 00:00:50,900
So, welcome to handmade hero.

19
00:00:50,900 --> 00:00:52,000
We are on day 15.

20
00:00:52,000 --> 00:00:53,100
It is the third.

21
00:00:53,100 --> 00:00:57,300
The end of the third week of handmade hero coding, and we are closing

22
00:00:57,300 --> 00:00:59,900
in on having our complete platform.

23
00:01:00,600 --> 00:01:03,400
Stuff running, where we basically have our game code isolated in a

24
00:01:03,400 --> 00:01:07,300
platform, independent layer, and we've got our win32 implementation of

25
00:01:07,300 --> 00:01:08,300
the platform layer.

26
00:01:08,500 --> 00:01:11,100
And so that we're all set up to do porting in the future.

27
00:01:11,100 --> 00:01:12,100
And that sort of stuff.

28
00:01:12,900 --> 00:01:15,300
If you are following along, if you're one of the folks who pre-ordered

29
00:01:15,300 --> 00:01:17,100
the game and are following along with the source code at home.

30
00:01:17,100 --> 00:01:19,800
You will want to unzip day, 14 source.

31
00:01:20,300 --> 00:01:25,700
That is what we are starting here obviously on day 15, so let's jump

32
00:01:25,700 --> 00:01:28,900
into that and this and talk about file IO a little bit.

33
00:01:30,200 --> 00:01:31,800
Before I go ahead and implement it.

34
00:01:32,000 --> 00:01:34,400
It's actually going to be pretty basic the thing that we're going to

35
00:01:34,400 --> 00:01:37,400
do very straightforward, not a lot to talk about but I just want to

36
00:01:37,400 --> 00:01:39,800
give you the sort of the the high level overview.

37
00:01:40,300 --> 00:01:47,800
So basically in games file file IO typically breaks down into two

38
00:01:48,000 --> 00:01:49,100
distinct categories.

39
00:01:49,600 --> 00:01:51,600
One is loading.

40
00:01:51,600 --> 00:01:52,000
What is this?

41
00:01:52,100 --> 00:01:53,200
What are essentially read?

42
00:01:53,200 --> 00:01:55,800
Only assets from something.

43
00:01:56,100 --> 00:01:56,600
Basically.

44
00:01:56,600 --> 00:01:59,600
This is your music, your sound.

45
00:01:59,900 --> 00:02:04,100
Your art artwork, whatever happens to be if it's 3D 3D models and

46
00:02:04,100 --> 00:02:08,699
textures if it's 2D than the Sprite bitmaps and so on basically what

47
00:02:08,699 --> 00:02:11,200
you're talking about when you're talking about that primary I/O

48
00:02:11,200 --> 00:02:15,800
functions, you're talking about getting stuff off of the drive and

49
00:02:15,800 --> 00:02:20,700
into memory where the game can use it and you're never touching these

50
00:02:20,700 --> 00:02:21,100
files.

51
00:02:21,100 --> 00:02:22,200
Other than that read.

52
00:02:22,200 --> 00:02:25,800
So it's essentially read only that, you're never writing to them.

53
00:02:26,300 --> 00:02:28,100
You're never putting stuff out to the disk.

54
00:02:28,100 --> 00:02:29,600
You're only pulling off of

55
00:02:29,700 --> 00:02:30,100
the disc.

56
00:02:30,100 --> 00:02:33,200
And by disc, this can mean a number of things.

57
00:02:33,200 --> 00:02:35,600
Sometimes it can mean the network potentially.

58
00:02:35,700 --> 00:02:39,800
Sometimes it can mean an optical drive, but in our case and most often

59
00:02:39,800 --> 00:02:44,100
nowadays, it tends to mean a hard drive of some kind or an SSD drive.

60
00:02:44,100 --> 00:02:48,000
So something that's the main Drive of the machine or a secondary, but

61
00:02:48,000 --> 00:02:49,700
still primary style drive.

62
00:02:50,800 --> 00:02:53,500
Basically something that stores all of the users games.

63
00:02:53,500 --> 00:02:54,900
And it's got all the assets on there.

64
00:02:58,000 --> 00:02:59,200
So, that's class one.

65
00:03:00,900 --> 00:03:05,100
Glass to is saving basically the state of the game.

66
00:03:05,800 --> 00:03:08,800
And so this is where the game actually reads and writes.

67
00:03:09,200 --> 00:03:12,900
Basically, what's going to happen is there's the configuration for the

68
00:03:12,900 --> 00:03:13,500
game.

69
00:03:14,000 --> 00:03:17,100
So if your game allows you to run say in windowed and full-screen

70
00:03:17,100 --> 00:03:19,500
mode, that would be one example of something that would need to get

71
00:03:19,500 --> 00:03:21,200
saved their stuff.

72
00:03:21,200 --> 00:03:24,600
Like, if you have separate settings for how loud, the sound versus the

73
00:03:24,600 --> 00:03:26,000
music is things like this.

74
00:03:26,300 --> 00:03:29,700
So there's stuff that's the configuration of the game and then there's

75
00:03:29,700 --> 00:03:29,900
stuff.

76
00:03:30,000 --> 00:03:34,400
If that's like the state of the of the game in progress at the players

77
00:03:34,400 --> 00:03:34,800
playing.

78
00:03:34,800 --> 00:03:39,500
So like a save game file or if there's unlocks things that they've

79
00:03:39,500 --> 00:03:44,300
unlocked so far, that sort of stuff that forms sort of a secondary

80
00:03:44,300 --> 00:03:48,100
class and that class is things that were basically writing to as well

81
00:03:48,100 --> 00:03:48,900
as reading from.

82
00:03:49,100 --> 00:03:53,300
So it's stuff that the game creates along the way and then pulls from

83
00:03:53,400 --> 00:03:56,700
later sort of to figure out what the state was.

84
00:03:56,700 --> 00:03:59,600
The last time the game was run because obviously the game runs

85
00:03:59,600 --> 00:03:59,900
multiple.

86
00:04:00,000 --> 00:04:00,400
Times.

87
00:04:00,400 --> 00:04:03,100
And there's no way to persist things across those runs.

88
00:04:03,100 --> 00:04:06,900
If we want to, without writing them to disk first and then pulling

89
00:04:06,900 --> 00:04:07,600
them back in.

90
00:04:08,000 --> 00:04:12,200
So we basically, when we're talking about a game, I oh we're basically

91
00:04:12,200 --> 00:04:14,600
talking about two separate classes of IO.

92
00:04:14,600 --> 00:04:18,700
Usually one that's for reading and writing files and one that's for

93
00:04:18,700 --> 00:04:19,600
just reading them.

94
00:04:20,300 --> 00:04:25,300
And they also tend to have different sort of criteria for Success.

95
00:04:26,200 --> 00:04:27,700
The sort of saved game things.

96
00:04:28,800 --> 00:04:30,900
Typically are relatively tiny.

97
00:04:31,100 --> 00:04:33,500
They can typically would be loaded in a flat call.

98
00:04:33,500 --> 00:04:36,000
That doesn't really have to be streamed or anything like this.

99
00:04:36,700 --> 00:04:40,400
Whereas, with the with the read-only stuff where you're pulling in

100
00:04:40,400 --> 00:04:44,000
assets, typically games nowadays, like to stream that stuff in the

101
00:04:44,000 --> 00:04:47,100
background so that the user isn't sitting on loading screens any

102
00:04:47,100 --> 00:04:49,100
longer than they have to did.

103
00:04:49,100 --> 00:04:52,600
You try to overlap that work, as much as possible with other things?

104
00:04:52,600 --> 00:04:53,600
Keep the game running.

105
00:04:54,200 --> 00:04:58,300
So, basically, with the with the assets, you're reading a ton of

106
00:04:58,500 --> 00:05:03,400
It typically gigabytes worth of data potentially and it's not

107
00:05:03,400 --> 00:05:05,000
something that's instantaneous anymore.

108
00:05:05,000 --> 00:05:07,900
It's not something that can be ignored as a performance criteria,

109
00:05:08,200 --> 00:05:10,000
because it's happening all the time.

110
00:05:10,200 --> 00:05:12,800
And it's, it's operating on a large scale.

111
00:05:12,800 --> 00:05:17,100
And so typically, if you really want a well performing game that, that

112
00:05:17,100 --> 00:05:20,000
other class, the read-only class of IO that we're pulling in the

113
00:05:20,000 --> 00:05:24,500
assets that has to be a lot more hardcore Engineering in there.

114
00:05:25,400 --> 00:05:26,900
Then just the reading, right?

115
00:05:27,200 --> 00:05:30,400
So I want you to understand those two two things separately.

116
00:05:30,900 --> 00:05:33,900
Now, we don't want to at this point.

117
00:05:34,000 --> 00:05:36,300
Try to address the specifics of these things.

118
00:05:36,300 --> 00:05:37,000
Just yet.

119
00:05:37,300 --> 00:05:40,600
We kind of have to crawl before we can walk here because if I start it

120
00:05:40,600 --> 00:05:44,600
on two or three weeks of, let's design a very efficient asset

121
00:05:44,600 --> 00:05:46,300
streaming system with multi-threading.

122
00:05:46,800 --> 00:05:49,400
We would be putting the cart massively before the horse because we

123
00:05:49,400 --> 00:05:52,800
haven't even gotten a game playable yet.

124
00:05:52,800 --> 00:05:55,000
So it'd be really premature to kind of go in.

125
00:05:55,100 --> 00:05:56,300
And say, all right.

126
00:05:56,300 --> 00:05:59,800
Let's let's focus on the asset loading system, but

127
00:06:00,100 --> 00:06:03,700
Obviously, we also can't get our game running with real Sprites or

128
00:06:03,700 --> 00:06:05,800
anything unless we can load stuff.

129
00:06:05,900 --> 00:06:10,100
So, basically, our job today is to just put in a minimal set of file

130
00:06:10,100 --> 00:06:13,600
I/O functions that we can use to get the game running so that we can

131
00:06:13,700 --> 00:06:16,900
get it to a point where we know exactly what we need.

132
00:06:17,000 --> 00:06:18,700
At least from the asset streaming system.

133
00:06:18,700 --> 00:06:21,300
Hopefully, from both the asset streaming system and the save load

134
00:06:21,300 --> 00:06:24,200
system, get it to a point where we can see exactly what we need.

135
00:06:24,200 --> 00:06:28,500
And what would be optimal API wise, then we can write that API and

136
00:06:28,500 --> 00:06:29,800
then spend a week or two.

137
00:06:30,000 --> 00:06:34,400
Implementing the actual win32 subsystem that will properly service

138
00:06:34,400 --> 00:06:36,300
that in an optimal way.

139
00:06:36,500 --> 00:06:38,400
So that's our goal for today, basically.

140
00:06:38,500 --> 00:06:40,100
So thankfully, that's pretty simple.

141
00:06:40,100 --> 00:06:43,200
We don't have to deal with all the complexity that we would have to

142
00:06:43,200 --> 00:06:46,400
deal with in a real system because we're just trying to get the basics

143
00:06:46,400 --> 00:06:46,800
working.

144
00:06:47,400 --> 00:06:50,100
So basically what we're going to do here is we're going to I'm going

145
00:06:50,100 --> 00:06:55,500
to Quick say roughly how file layers are used kind of used to be done

146
00:06:55,700 --> 00:06:57,600
and then how they're typically done today.

147
00:06:57,900 --> 00:06:59,900
Because how they're done today is a lot better than how they

148
00:07:00,000 --> 00:07:00,300
Are done.

149
00:07:00,300 --> 00:07:03,100
So I just want to show you real quickly, how that used to work.

150
00:07:03,400 --> 00:07:07,200
So in the old days, basically, what would happen is you had something

151
00:07:07,500 --> 00:07:11,400
that was basically a file file handle.

152
00:07:14,600 --> 00:07:19,500
So typically what you would do is let's say what I wanted to do is at

153
00:07:19,500 --> 00:07:20,400
start up here.

154
00:07:20,700 --> 00:07:22,900
When we're initializing our game.

155
00:07:23,000 --> 00:07:26,600
I wanted to load a bitmap and I kind of know where that bitmap is.

156
00:07:26,600 --> 00:07:29,500
Let's say, you know, normally we wouldn't know where the bitmap is

157
00:07:29,500 --> 00:07:29,800
we'd have.

158
00:07:29,900 --> 00:07:33,300
Some kind of asset thing that finds assets or whatever but let's say I

159
00:07:33,300 --> 00:07:34,100
just know where it is.

160
00:07:34,100 --> 00:07:37,600
So I've got a file name here, and I know that I'm going to load

161
00:07:37,600 --> 00:07:42,000
something like backdrop or are you know what let's just make it test

162
00:07:42,200 --> 00:07:43,500
dot BMP or something.

163
00:07:43,500 --> 00:07:45,000
So I'm going to try and load this file.

164
00:07:45,900 --> 00:07:49,900
Basically what happens here is when I'm going to load the file.

165
00:07:49,900 --> 00:07:57,000
I would say something like file handle, file equals open file, right?

166
00:07:57,000 --> 00:07:59,800
And I would pass it that file name and then it would, it would give me

167
00:08:00,000 --> 00:08:04,200
Back a handle to the file and then I would then from there, do things

168
00:08:04,200 --> 00:08:06,400
like read from the file.

169
00:08:06,800 --> 00:08:08,000
How many bytes I wanted.

170
00:08:08,000 --> 00:08:10,600
Let's say I wanted to read 128 bytes from the file.

171
00:08:10,700 --> 00:08:13,200
I would say that and I would give it a buffer.

172
00:08:13,200 --> 00:08:15,300
So I would do something like this.

173
00:08:15,400 --> 00:08:18,600
I would say here's a buffer of 128 bytes, right?

174
00:08:18,900 --> 00:08:22,700
And then I would read from that buffer basically like this.

175
00:08:22,700 --> 00:08:26,800
So maybe I'll say however, big the buffer is and the buffer size and

176
00:08:26,800 --> 00:08:28,700
this would typically be ifft.

177
00:08:28,800 --> 00:08:29,800
So I would say if

178
00:08:29,900 --> 00:08:35,700
The read succeeded then, you know, I can use that thing use buffer.

179
00:08:35,700 --> 00:08:38,200
If it didn't then I have an error, right?

180
00:08:38,200 --> 00:08:42,799
This is an air-conditioned but couldn't read from the file now at 0

181
00:08:42,799 --> 00:08:45,300
and of course at the end of this we would also have to clean up that

182
00:08:45,300 --> 00:08:45,900
file handle.

183
00:08:45,900 --> 00:08:46,400
Right?

184
00:08:47,600 --> 00:08:54,100
So basically that is that is basically how this works.

185
00:08:54,500 --> 00:08:55,100
Now.

186
00:08:55,500 --> 00:08:57,800
There's a lot of things not to like about this.

187
00:08:58,000 --> 00:08:59,800
So first of all, the way that it works is,

188
00:09:00,000 --> 00:09:01,500
You can imagine if I was going to do this again.

189
00:09:01,500 --> 00:09:04,600
If I needed to read another thing out of this, right?

190
00:09:04,600 --> 00:09:08,300
Maybe I got to read another 128 bytes, or maybe I got some other thing

191
00:09:08,300 --> 00:09:13,200
in here but for to something like that and so I'm going to read 256

192
00:09:13,200 --> 00:09:13,500
bytes.

193
00:09:13,500 --> 00:09:16,100
Assuming I read the 128 bytes, you end up with code that looks a lot

194
00:09:16,100 --> 00:09:17,200
like this, right?

195
00:09:17,200 --> 00:09:23,100
And there's definitely things you can do to minimize the degree of if

196
00:09:23,100 --> 00:09:24,200
Enos going on.

197
00:09:24,200 --> 00:09:27,200
If you were to do it this way, but the thing that I want to point out

198
00:09:27,200 --> 00:09:29,600
here is this is basically

199
00:09:30,000 --> 00:09:31,600
We a streaming API.

200
00:09:31,700 --> 00:09:35,700
So what it assumes is that we're opening the file in a method where

201
00:09:35,700 --> 00:09:38,400
we're going to pull things from it incrementally.

202
00:09:38,500 --> 00:09:43,200
And we expect the underlining underlying file system to basically

203
00:09:43,500 --> 00:09:47,000
maintain sort of a location in the file.

204
00:09:47,200 --> 00:09:50,900
And when we asked for bits of IO, it's pulling it from wherever that

205
00:09:50,900 --> 00:09:54,500
is, right, and we're pulling and pulling and pulling.

206
00:09:54,700 --> 00:09:59,800
And we're assuming that basically any of those pulls could fail, like

207
00:10:00,000 --> 00:10:02,200
Anytime we do a read, it could fail.

208
00:10:02,200 --> 00:10:08,900
And that's, that's not a, that's not a overly cautious, assumption.

209
00:10:09,500 --> 00:10:13,200
Because if you think about it, at any time, the hard drive could fail

210
00:10:13,200 --> 00:10:16,000
the file could get locked, the file could get deleted.

211
00:10:16,200 --> 00:10:18,600
The user, could could flat-out pull the drive out.

212
00:10:18,600 --> 00:10:21,500
If it's a USB drive, they could just yank it out of the machine.

213
00:10:22,100 --> 00:10:28,200
So realistically it is true that any read can just fail.

214
00:10:28,800 --> 00:10:29,800
That's just flat-out.

215
00:10:29,900 --> 00:10:30,700
Out the case.

216
00:10:31,300 --> 00:10:34,700
Same thing on consoles is that DVD drive gets ejected.

217
00:10:34,700 --> 00:10:38,100
Well, that's the last time you're going to read from that DVD until

218
00:10:38,100 --> 00:10:40,300
the user Danes, to put it back in the drive again.

219
00:10:40,300 --> 00:10:43,900
So it is a realistic concern that the reads can always fail.

220
00:10:46,900 --> 00:10:48,600
So basically what we've got here.

221
00:10:50,200 --> 00:10:53,400
Is we've got a something that is doing a bunch of work.

222
00:10:53,400 --> 00:10:55,900
We don't care about to support that streaming thing.

223
00:10:57,100 --> 00:11:00,200
Basically, we're introducing a bunch of failure cases.

224
00:11:00,200 --> 00:11:03,800
Every read is a new failure case that we theoretically have to handle

225
00:11:03,800 --> 00:11:07,000
or have some strategy for handling in a more Global sense.

226
00:11:07,200 --> 00:11:07,500
Right?

227
00:11:07,500 --> 00:11:08,500
So that has to happen.

228
00:11:09,300 --> 00:11:15,000
We also have the problem of the the threading safety and we haven't

229
00:11:15,000 --> 00:11:16,000
talked about multi-threading it all.

230
00:11:16,000 --> 00:11:17,800
So I'm just going to mention this and not going to detail.

231
00:11:17,800 --> 00:11:19,000
You'll understand it more.

232
00:11:19,000 --> 00:11:19,800
If you don't know about that.

233
00:11:20,400 --> 00:11:24,700
Later on, these file handles are very stateful.

234
00:11:24,800 --> 00:11:27,300
They store a location where you're reading in the file.

235
00:11:27,300 --> 00:11:31,700
So if two different people wanted to use the same file, they need

236
00:11:31,700 --> 00:11:34,700
multiple of these handles because each one is writing two different

237
00:11:34,700 --> 00:11:35,000
position.

238
00:11:35,000 --> 00:11:39,700
So basically every thread needs its own file handle to sort of talk

239
00:11:39,700 --> 00:11:41,100
about where in the file.

240
00:11:41,100 --> 00:11:45,500
They thought they were reading all sorts of things like this are bad

241
00:11:46,000 --> 00:11:49,800
and then two is if that's not enough, keeping.

242
00:11:49,900 --> 00:11:50,900
Everything on there.

243
00:11:51,200 --> 00:11:53,100
The final thing that's awful about this.

244
00:11:53,100 --> 00:11:57,500
Is it, is it totally synchronous, like this, read the code that

245
00:11:57,500 --> 00:11:59,800
executes after the read can't start.

246
00:12:00,000 --> 00:12:02,000
QT because it's going to start touching this buffer.

247
00:12:02,300 --> 00:12:05,200
The code that's after the recant start executing until the Reed has

248
00:12:05,200 --> 00:12:06,100
completed.

249
00:12:06,200 --> 00:12:10,100
And definitely it's true that the hard drive is the slowest piece of

250
00:12:10,100 --> 00:12:11,600
memory in your system.

251
00:12:11,600 --> 00:12:13,000
Even if it's an SSD drive.

252
00:12:13,000 --> 00:12:17,100
It is much slower than the CPU is executing much lower than main

253
00:12:17,100 --> 00:12:17,600
memory.

254
00:12:17,800 --> 00:12:21,100
And so basically what we're talking about right here is stalling the

255
00:12:21,100 --> 00:12:24,700
whole program at this point where the read happens.

256
00:12:24,900 --> 00:12:28,200
And so especially if we're going to do two reads in a row and stuff

257
00:12:28,200 --> 00:12:29,000
like that.

258
00:12:29,000 --> 00:12:29,800
It's just awful.

259
00:12:30,000 --> 00:12:33,900
Because it means we're like waiting and then waiting again, when we

260
00:12:33,900 --> 00:12:37,200
could have just said, hey we need to do both these reads, Q those up.

261
00:12:37,200 --> 00:12:39,800
Let me know when you're done with them, and then we'll process them.

262
00:12:39,800 --> 00:12:40,300
Right.

263
00:12:41,400 --> 00:12:46,000
So basically, there's nothing good about streaming base file, I/O for

264
00:12:46,000 --> 00:12:47,200
our purposes.

265
00:12:47,200 --> 00:12:50,600
There are perhaps circumstances where you really do need to talk about

266
00:12:50,600 --> 00:12:54,200
things as if they are streams worse, where streams make more sense.

267
00:12:54,600 --> 00:12:58,300
But in our for our purposes, they make no sense whatsoever, especially

268
00:12:58,300 --> 00:12:59,800
because we are always going to be.

269
00:13:00,000 --> 00:13:03,400
Reading stuff that we know how big it is, like, basically, we're never

270
00:13:03,400 --> 00:13:07,800
going to be in situations where we're reading from an 8 GB stream and

271
00:13:07,800 --> 00:13:10,500
we just want to pull pieces off of it, which is a case where a

272
00:13:10,500 --> 00:13:11,900
streaming might make some more sense.

273
00:13:12,000 --> 00:13:13,600
If we have an 8 gigabyte file.

274
00:13:13,700 --> 00:13:16,500
We know how it's subdivided up and we're going to jump into it and

275
00:13:16,500 --> 00:13:18,300
grab a whole, a set of the time.

276
00:13:18,400 --> 00:13:22,400
We just want to do those whole asset reads and just have the operating

277
00:13:22,400 --> 00:13:24,200
system tell us when they're done with them.

278
00:13:25,900 --> 00:13:29,000
So we basically don't want anything to do with this even in our test

279
00:13:29,000 --> 00:13:29,400
layer.

280
00:13:29,900 --> 00:13:31,800
Even for just the basic stuff that we Implement.

281
00:13:31,800 --> 00:13:35,100
Now, we want to set ourselves up for success by at least starting to

282
00:13:35,100 --> 00:13:35,600
go.

283
00:13:35,800 --> 00:13:40,200
All right, let's make a file API, even for the debug for are, you

284
00:13:40,200 --> 00:13:43,700
know, sort of training wheels, purposes here, to get things going.

285
00:13:44,700 --> 00:13:46,400
Basically, even for that.

286
00:13:46,500 --> 00:13:48,100
We don't want to do things this way.

287
00:13:48,100 --> 00:13:53,200
What we would much rather do is basically just say for our debug

288
00:13:53,200 --> 00:13:53,800
purposes.

289
00:13:53,800 --> 00:13:59,800
We're just going to always read files or chunks of files at once in.

290
00:14:00,000 --> 00:14:03,200
In a block we're basically going to tell it where we want to read and

291
00:14:03,200 --> 00:14:05,700
how much we want to read and we're going to assume that we do all of

292
00:14:05,700 --> 00:14:09,500
our reads to like all of that read is together and succeeds or fails.

293
00:14:09,500 --> 00:14:13,100
So if you're loading a bitmap file, we're going to load the whole file

294
00:14:13,100 --> 00:14:16,100
at once and it's just going to come back to us as one big chunk.

295
00:14:16,100 --> 00:14:16,600
Right?

296
00:14:17,400 --> 00:14:21,500
And basically what we're going to do is we're going to use that for

297
00:14:21,500 --> 00:14:25,100
the entire time that we don't have a giant packed asset file.

298
00:14:25,200 --> 00:14:28,800
And then when we move to having a pact asset file of some kind, we're

299
00:14:28,800 --> 00:14:29,700
going to use.

300
00:14:30,200 --> 00:14:33,200
More like a streaming system where we're going to be multi-threaded at

301
00:14:33,200 --> 00:14:36,900
that point and then we'll start talking about always having basically

302
00:14:36,900 --> 00:14:41,400
that one file open and doing sub reads out of it, but we're never

303
00:14:41,400 --> 00:14:42,800
going to do the streaming thing.

304
00:14:42,800 --> 00:14:45,000
The streaming thing is just not going to be the case.

305
00:14:45,100 --> 00:14:48,500
The only time we would do anything with streaming stored of IO will be

306
00:14:48,500 --> 00:14:51,800
if we write a log file to disk for debugging purposes or something.

307
00:14:51,800 --> 00:14:54,200
That's that's it and we're not going to do that right now.

308
00:14:54,200 --> 00:14:59,700
Anyway, so what we want to do is something that looks more like, you

309
00:14:59,700 --> 00:14:59,800
know,

310
00:15:00,900 --> 00:15:08,300
This bitmap memory equals read entire file and we pass the file name.

311
00:15:08,500 --> 00:15:13,100
So it looks more like that and then free file memory, something like

312
00:15:13,100 --> 00:15:14,700
this bitmap memory.

313
00:15:15,200 --> 00:15:18,000
And so basically what we're going to treat it as is we're going to

314
00:15:18,000 --> 00:15:23,200
treat it as we're going to treat it almost like a memory allocation.

315
00:15:23,800 --> 00:15:26,700
We're going to say we're going to basically allocate this file in some

316
00:15:26,700 --> 00:15:29,800
sense and it's just going to appear in memory and

317
00:15:30,000 --> 00:15:33,600
You'll notice I even alluded to this in the previous stream.

318
00:15:34,100 --> 00:15:37,700
Basically, this is the one thing that we're going to allow to be

319
00:15:37,700 --> 00:15:38,700
around trip.

320
00:15:38,700 --> 00:15:40,900
You remember I was talking about round tripping and trying to minimize

321
00:15:40,900 --> 00:15:41,400
that.

322
00:15:42,000 --> 00:15:45,000
So, the one thing that we're kind of going to allow to be a round trip

323
00:15:45,300 --> 00:15:49,500
is going to be file IO, but mostly only for this for this training

324
00:15:49,500 --> 00:15:54,000
wheels version because in the real version were even not, we're really

325
00:15:54,000 --> 00:15:57,100
not going to even allow round-tripping in the real version in the

326
00:15:57,100 --> 00:15:59,800
fullest in the full concept of the word round tripping.

327
00:16:00,200 --> 00:16:03,500
What we're actually going to do in the real version is we're going to

328
00:16:03,500 --> 00:16:06,800
write to a queue that will get processed asynchronously.

329
00:16:07,500 --> 00:16:09,400
So this is the most round-tripping thing.

330
00:16:09,400 --> 00:16:13,000
We will probably see in the entire layer and it's only going to be.

331
00:16:13,000 --> 00:16:16,900
It's not ever meant to actually run on the user's machine.

332
00:16:16,900 --> 00:16:19,200
Probably, that'd be my guest.

333
00:16:19,200 --> 00:16:20,700
So we're never really going to ship code.

334
00:16:20,700 --> 00:16:22,100
Like this in the final version.

335
00:16:25,200 --> 00:16:26,900
But basically this is how we're going to do it.

336
00:16:27,100 --> 00:16:30,300
We're basically just going to do a thing that says, please read this

337
00:16:30,300 --> 00:16:31,200
entire file.

338
00:16:31,900 --> 00:16:34,200
Now, I could do this in one of two ways.

339
00:16:34,500 --> 00:16:36,000
There's two totally valid ways.

340
00:16:36,000 --> 00:16:37,900
I could decide to do this.

341
00:16:38,000 --> 00:16:41,200
One would be to get the size of the file first, right?

342
00:16:41,200 --> 00:16:45,400
And so, you could imagine something like this file size equals.

343
00:16:45,400 --> 00:16:48,200
Get file size of the file name, right?

344
00:16:49,600 --> 00:16:54,500
Then I would use that game memory to basically say, the bitmap memory

345
00:16:54,600 --> 00:16:54,900
is going.

346
00:16:55,100 --> 00:17:01,100
Be, you know, getting it memory or Reserve memory, write for, for the

347
00:17:01,100 --> 00:17:01,900
file size.

348
00:17:02,100 --> 00:17:03,400
And that would that would do this.

349
00:17:03,400 --> 00:17:06,200
So, this would sub allocate out of that chunk of game memory that we

350
00:17:06,200 --> 00:17:12,400
have, then we would go ahead and say, ok, then read entire file into

351
00:17:12,400 --> 00:17:13,099
memory.

352
00:17:14,000 --> 00:17:17,200
And we would give it the file name and we would give it the memory

353
00:17:17,200 --> 00:17:20,000
pointer, right the bitmap memory like this.

354
00:17:20,400 --> 00:17:21,400
Does that make some sense?

355
00:17:21,500 --> 00:17:24,700
So we basically say, okay, get that file size read

356
00:17:25,200 --> 00:17:28,000
Get get enough memory to hold it and then put it in there.

357
00:17:28,300 --> 00:17:31,600
That is how we would write it if this were going to be a permanent

358
00:17:31,600 --> 00:17:32,000
API.

359
00:17:32,000 --> 00:17:34,200
Probably because I would want the game.

360
00:17:34,200 --> 00:17:38,900
I wouldn't want the the operating system to be doing more memory work

361
00:17:38,900 --> 00:17:40,300
than it has to probably.

362
00:17:41,200 --> 00:17:43,300
I wouldn't necessarily say that has to be that way.

363
00:17:43,300 --> 00:17:45,900
We still even if we were shipping it we could let the operating system

364
00:17:45,900 --> 00:17:46,600
allocate it.

365
00:17:46,900 --> 00:17:50,300
The reasons for that is we could use file mapping or things like that.

366
00:17:50,300 --> 00:17:50,900
Possibly happen.

367
00:17:50,900 --> 00:17:53,400
And also it's already something that can fail.

368
00:17:53,400 --> 00:17:54,900
We know that a read can fail.

369
00:17:55,000 --> 00:17:56,600
All the Reed can fail.

370
00:17:56,700 --> 00:17:59,600
So having the operating system, allocate memory and read.

371
00:18:00,700 --> 00:18:02,800
Doesn't introduce a new failure point.

372
00:18:03,000 --> 00:18:07,200
But like I said, I do like knowing exactly how much memory the game

373
00:18:07,200 --> 00:18:07,700
needs.

374
00:18:07,700 --> 00:18:10,600
And so, having files be allocated in the platform layer.

375
00:18:10,600 --> 00:18:12,900
Dynamically doesn't wouldn't feel great to me.

376
00:18:13,300 --> 00:18:17,200
So if we were actually doing this API for real, we might consider

377
00:18:17,200 --> 00:18:18,000
something like this.

378
00:18:18,200 --> 00:18:20,400
Since we're only doing this in a debug sense.

379
00:18:20,800 --> 00:18:25,600
This is basically, this is basically what what we're going to do.

380
00:18:26,100 --> 00:18:28,200
So we're just going to let it do the whole allocation.

381
00:18:28,200 --> 00:18:29,400
Then we're going to release it later.

382
00:18:29,400 --> 00:18:30,000
Does that make sense?

383
00:18:30,600 --> 00:18:31,700
Hopefully, that makes some sense.

384
00:18:31,900 --> 00:18:38,100
So basically come to me, this will return a null pointer of return 0.

385
00:18:38,400 --> 00:18:42,000
If it couldn't read the file, or couldn't allocate the memory, and if

386
00:18:42,000 --> 00:18:45,000
not, then we assume we got the whole read and it worked and then we

387
00:18:45,000 --> 00:18:46,800
can process it and off we go.

388
00:18:46,800 --> 00:18:49,900
So that's basically that's basically what we're talking about here.

389
00:18:49,900 --> 00:18:53,400
Hopefully that makes a fair bit of sense and isn't too complicated.

390
00:18:53,600 --> 00:18:56,000
So that's that's basically all we want.

391
00:18:56,000 --> 00:18:58,800
And what I'm going to do here is this is a platform call.

392
00:18:58,800 --> 00:19:00,000
Obviously, we're calling into the platform.

393
00:19:00,100 --> 00:19:00,700
At form here.

394
00:19:01,000 --> 00:19:04,900
So I'm going to prefix it with platform and I also want to sort of

395
00:19:04,900 --> 00:19:11,400
make some kind of note that this is, is really not for runtime use.

396
00:19:11,800 --> 00:19:13,400
So I'm going to call this debug.

397
00:19:13,500 --> 00:19:16,600
I'm just going to put a flat out debug in front of it so that we kind

398
00:19:16,600 --> 00:19:19,600
of know that if we were to search through the code for this, we would

399
00:19:19,600 --> 00:19:23,400
kind of see it light up like a Christmas tree that this is not really

400
00:19:23,400 --> 00:19:26,300
supposed to be hanging out in a shipping build.

401
00:19:26,400 --> 00:19:29,800
There's other things we can do about that that are kind of interesting

402
00:19:29,800 --> 00:19:30,000
for

403
00:19:30,200 --> 00:19:34,400
A, we have we have this handmade internal thing and in the future,

404
00:19:34,400 --> 00:19:37,800
what we might do is we might do something like this, where, if

405
00:19:37,800 --> 00:19:42,400
handmade internal exists, then we Define these and if it doesn't, we

406
00:19:42,400 --> 00:19:45,300
don't just to make sure that no one can actually call them.

407
00:19:45,300 --> 00:19:49,000
So basically, you know, we might have something we're only if this is

408
00:19:49,000 --> 00:19:53,100
the case, do these, get defined at all, you know, does that make

409
00:19:53,100 --> 00:19:53,400
sense?

410
00:19:53,600 --> 00:19:56,400
In fact, we could even do that now, maybe I just will.

411
00:19:56,700 --> 00:19:59,900
So basically what we're talking about here is when you go to do

412
00:20:00,100 --> 00:20:03,100
Your first shipping build, you got to you got to have this stuff, go

413
00:20:03,100 --> 00:20:03,600
away.

414
00:20:03,700 --> 00:20:04,300
Right?

415
00:20:05,000 --> 00:20:06,100
Just something we could do.

416
00:20:06,800 --> 00:20:07,600
We'll do it for now.

417
00:20:07,600 --> 00:20:08,900
It seems totally reasonable.

418
00:20:09,200 --> 00:20:13,000
So we're going to basically just say, you know, what for file I/O,

419
00:20:13,000 --> 00:20:14,000
that's just the way it goes.

420
00:20:14,000 --> 00:20:15,700
Now that goes in this.

421
00:20:15,700 --> 00:20:19,100
Remember we set this up here, basically services that the platform

422
00:20:19,100 --> 00:20:20,300
layer provides to the game.

423
00:20:20,400 --> 00:20:21,900
We said they're going to be a couple of them.

424
00:20:22,300 --> 00:20:23,400
Well here is our first one.

425
00:20:23,400 --> 00:20:27,200
It's a debug ability to load a file and to release that file.

426
00:20:27,600 --> 00:20:29,000
So basically that's what we're going to do.

427
00:20:29,000 --> 00:20:30,000
We're going to say here is the file.

428
00:20:30,100 --> 00:20:30,500
Name.

429
00:20:30,900 --> 00:20:36,000
And we're going to say here is the memory to release and again,

430
00:20:36,000 --> 00:20:37,400
there's a lot of other things.

431
00:20:37,400 --> 00:20:39,800
We might can be concerned with here.

432
00:20:42,300 --> 00:20:42,700
Excuse me.

433
00:20:43,400 --> 00:20:43,700
Hmm.

434
00:20:46,000 --> 00:20:48,000
Man, all right.

435
00:20:48,600 --> 00:20:51,400
Basically, the things we might be concerned with is, do we need to

436
00:20:51,400 --> 00:20:53,400
support UTF filenames, these sorts of things.

437
00:20:53,700 --> 00:20:54,800
This is for debugging only.

438
00:20:54,800 --> 00:20:57,700
So we know, we're always ever antsy, so we don't really need to think

439
00:20:57,700 --> 00:20:58,500
about this much.

440
00:21:01,600 --> 00:21:03,300
Now, I want a symmetric thing.

441
00:21:04,100 --> 00:21:07,700
So in addition to reading, I would also like to be able to write.

442
00:21:08,000 --> 00:21:10,400
So I would like to be able to say platform, right?

443
00:21:10,400 --> 00:21:14,300
Entire file and write entire file would just be here's the file name

444
00:21:14,300 --> 00:21:16,400
to write to here's the memory to, right?

445
00:21:16,600 --> 00:21:19,700
And then here is the memory size, how big it actually is.

446
00:21:20,100 --> 00:21:23,900
Now one thing we might do is we might want to say or we're never going

447
00:21:23,900 --> 00:21:29,300
to allow writing a files that are more than 4 gigabytes which point we

448
00:21:29,300 --> 00:21:29,800
would make this.

449
00:21:30,000 --> 00:21:33,900
Us a Unit 32, I don't know which one I want to do there.

450
00:21:33,900 --> 00:21:38,900
It's I think we may want to support writing giant.

451
00:21:39,400 --> 00:21:41,200
Maybe maybe not now probably not.

452
00:21:41,300 --> 00:21:44,700
So we could we could just say that that's going to be under under that

453
00:21:44,700 --> 00:21:45,100
size.

454
00:21:45,300 --> 00:21:46,000
So there you go.

455
00:21:46,800 --> 00:21:48,300
That's basically all we're talking about here.

456
00:21:48,900 --> 00:21:51,100
And so that's really pretty, pretty straightforward.

457
00:21:51,300 --> 00:21:53,900
You can see if we compile everything compiles, fine.

458
00:21:54,200 --> 00:21:55,700
There's not much to talk about there.

459
00:21:56,000 --> 00:21:58,600
All we have to do, is we got our Linker warning says, we haven't

460
00:21:58,600 --> 00:21:59,900
implemented these, but I can just

461
00:22:00,000 --> 00:22:00,900
Implement these now.

462
00:22:01,100 --> 00:22:02,400
So here's our file layer.

463
00:22:02,700 --> 00:22:03,800
We go into win32.

464
00:22:03,800 --> 00:22:05,000
Handmade dot CPP.

465
00:22:05,400 --> 00:22:08,500
We're just going to drop those in there and you can notice we already

466
00:22:08,500 --> 00:22:09,700
did the implements five.

467
00:22:10,000 --> 00:22:12,700
I was talking about this and I already had dropped this in here as a

468
00:22:12,700 --> 00:22:13,300
note.

469
00:22:13,500 --> 00:22:17,000
So basically, we're going to go ahead and delete that old stub and

470
00:22:17,000 --> 00:22:18,200
make this here.

471
00:22:18,300 --> 00:22:18,600
Okay.

472
00:22:18,600 --> 00:22:19,300
There we go.

473
00:22:19,500 --> 00:22:21,400
These should be marked internal as well.

474
00:22:21,700 --> 00:22:24,400
You go ahead and Mark that because basically, I said, all of our

475
00:22:24,400 --> 00:22:28,300
functions are internal just to help the compiler out so that it knows

476
00:22:28,300 --> 00:22:29,800
there's no external linkage or

477
00:22:29,900 --> 00:22:32,000
compiling in just one file, so,

478
00:22:33,300 --> 00:22:36,700
What I need to do here is straight-up call windows and say, hey

479
00:22:36,700 --> 00:22:39,200
Windows, read this, entire file for me.

480
00:22:39,500 --> 00:22:40,200
Nothing.

481
00:22:40,200 --> 00:22:42,300
Nothing, interesting going on here.

482
00:22:42,600 --> 00:22:44,400
It's going to be the most basic.

483
00:22:45,200 --> 00:22:49,000
Most basic thing that there is, we're not going to get fancy at all.

484
00:22:49,200 --> 00:22:53,700
So we're just going to call a function called create file and and also

485
00:22:53,700 --> 00:22:55,100
one that gets the file size.

486
00:22:55,600 --> 00:22:59,000
So basically, this is this is what we're going to call to open that

487
00:22:59,000 --> 00:22:59,600
file.

488
00:23:00,600 --> 00:23:02,900
Basically, what I'll talk about what that does in second.

489
00:23:03,100 --> 00:23:03,300
Leave.

490
00:23:03,300 --> 00:23:06,700
There's just a flat-out file size called.

491
00:23:06,700 --> 00:23:09,800
We'll, just tell us how big a file is, nothing particularly

492
00:23:09,800 --> 00:23:11,200
complicated about that.

493
00:23:11,200 --> 00:23:12,700
So, there we go with that.

494
00:23:14,500 --> 00:23:19,800
And, and I think that's mostly all we're going to need.

495
00:23:20,100 --> 00:23:21,300
We're going to get that file size.

496
00:23:21,300 --> 00:23:25,800
Then we're going to, of course, she's me have to close the file as

497
00:23:25,800 --> 00:23:28,000
well, which is the close handle call.

498
00:23:28,000 --> 00:23:32,400
It can close any type of handle including a file handle and then we're

499
00:23:32,400 --> 00:23:33,000
going to need

500
00:23:33,000 --> 00:23:37,300
One more, which is read file and that will be the way that will

501
00:23:37,300 --> 00:23:39,000
actually get it in.

502
00:23:39,000 --> 00:23:39,900
So there we go.

503
00:23:40,200 --> 00:23:44,000
Alright, so so really, there's not a lot of mystery here.

504
00:23:44,100 --> 00:23:47,500
I'll kind of explain what these things do but it's like pretty darn

505
00:23:47,500 --> 00:23:48,100
boring.

506
00:23:48,700 --> 00:23:53,200
So basically what happens is first we say, all right, we've got to get

507
00:23:53,200 --> 00:23:57,600
a handle to a file because operating systems like handles basically

508
00:23:57,600 --> 00:23:59,700
the way operating systems tend to work is

509
00:24:00,100 --> 00:24:05,200
Resources that are on the operating system sides sockets, files

510
00:24:05,200 --> 00:24:09,700
streams, whatever they are processes, you name it and basically they

511
00:24:09,700 --> 00:24:13,600
need a way of talking about those to you the the the process that's

512
00:24:13,600 --> 00:24:16,300
running and they use handles for that.

513
00:24:16,400 --> 00:24:19,400
Those are typically just, you know, indexes into a table or pointers

514
00:24:19,400 --> 00:24:20,100
into kernel memory.

515
00:24:20,100 --> 00:24:23,400
That say, here is the thing that I'm talking about on your side.

516
00:24:23,700 --> 00:24:26,000
So for a file, we basically want to say hey, here's something.

517
00:24:26,000 --> 00:24:28,200
I want to read from the disk.

518
00:24:28,200 --> 00:24:29,900
I'm going to give you the name of it and I

519
00:24:30,000 --> 00:24:32,700
I want you to go open that and give me back a handle, so I can keep

520
00:24:32,700 --> 00:24:35,600
talking about it to you and telling you what to do to it, like,

521
00:24:35,600 --> 00:24:36,900
reading it and getting it sighs.

522
00:24:37,300 --> 00:24:37,900
Right.

523
00:24:37,900 --> 00:24:40,900
So, basically we need to pass the file name, then we need to pass a

524
00:24:40,900 --> 00:24:42,800
bunch of stuff that's largely meaningless for us.

525
00:24:42,800 --> 00:24:44,500
But that makes them more sense in Windows.

526
00:24:45,000 --> 00:24:47,300
If you actually care about other things.

527
00:24:47,500 --> 00:24:50,500
Basically what these are are like things like how we need the file to

528
00:24:50,500 --> 00:24:52,300
be open to how we need to be accessed.

529
00:24:52,600 --> 00:24:55,600
So if you look in here, the documentation msdn, you can see this

530
00:24:55,600 --> 00:24:56,600
desired access.

531
00:24:56,800 --> 00:24:57,300
Basically.

532
00:24:57,300 --> 00:24:58,800
We just telling you a Windows.

533
00:24:58,900 --> 00:24:59,800
What we actually

534
00:25:00,100 --> 00:25:04,700
I need to do because Windows may allow multiple.

535
00:25:04,800 --> 00:25:08,400
There's basically different ways of opening files, where the operating

536
00:25:08,400 --> 00:25:11,400
system can determine whether multiple people can open the file the

537
00:25:11,400 --> 00:25:12,100
same time.

538
00:25:12,500 --> 00:25:13,800
So basically, we need to tell it.

539
00:25:13,900 --> 00:25:16,600
Do we need to read or do we need to write or both?

540
00:25:17,000 --> 00:25:19,300
And then we also need to tell it later in this.

541
00:25:19,300 --> 00:25:21,200
This is what share mode is the next parameter.

542
00:25:22,000 --> 00:25:24,600
What do we allow other processes to do?

543
00:25:24,800 --> 00:25:29,200
So, we may open a file for reading and we know that we want it to not

544
00:25:29,200 --> 00:25:29,800
be written to it.

545
00:25:29,900 --> 00:25:30,400
At that time.

546
00:25:30,400 --> 00:25:34,600
So we may say well, another process could open it for reading but

547
00:25:34,600 --> 00:25:35,900
don't allow them to write to it.

548
00:25:35,900 --> 00:25:36,500
Right?

549
00:25:36,700 --> 00:25:37,900
Similarly, if we're writing to a file.

550
00:25:37,900 --> 00:25:40,700
We may say don't let any other process read from it or right from it

551
00:25:40,700 --> 00:25:42,100
because we're modifying it right now.

552
00:25:42,300 --> 00:25:43,600
So it's basically, like a mutex.

553
00:25:43,600 --> 00:25:47,700
It's a lock that basically says, all right, when one person have the

554
00:25:47,700 --> 00:25:50,800
file open, the operating system allows them to basically say don't let

555
00:25:50,800 --> 00:25:53,300
other people do stuff at this time because we will create errors by

556
00:25:53,300 --> 00:25:54,100
doing that.

557
00:25:54,600 --> 00:25:57,900
So what we know here is, we're just reading a file so we can just say,

558
00:25:57,900 --> 00:25:59,500
generic read, right?

559
00:25:59,600 --> 00:25:59,800
We're just

560
00:26:00,000 --> 00:26:02,400
Going to read from the file and then the share mode.

561
00:26:02,500 --> 00:26:05,300
We know that basically anyone else could read from it.

562
00:26:05,600 --> 00:26:06,100
Right?

563
00:26:06,200 --> 00:26:09,500
But we don't want them to delete or right to it because we're don't

564
00:26:09,500 --> 00:26:12,800
want them to modify it while we're doing something while we're doing

565
00:26:12,800 --> 00:26:14,100
this, with one read that we do.

566
00:26:14,100 --> 00:26:16,000
We're only gonna have it locked for a very short time.

567
00:26:16,300 --> 00:26:16,900
So that's fine.

568
00:26:16,900 --> 00:26:17,600
So, there you go.

569
00:26:18,300 --> 00:26:19,600
Now security attributes.

570
00:26:19,800 --> 00:26:20,900
We don't care about.

571
00:26:21,100 --> 00:26:24,600
This is basically, if we're trying to do things more about like, which

572
00:26:24,700 --> 00:26:28,200
whether the file handle can be passed to a subprocess and all, there's

573
00:26:28,200 --> 00:26:29,800
all sorts of other things that you might care.

574
00:26:29,900 --> 00:26:32,300
About, but we don't care about those for our purposes.

575
00:26:32,300 --> 00:26:33,700
We're just reading the file ourselves.

576
00:26:33,700 --> 00:26:34,700
We don't have a subprocess.

577
00:26:34,700 --> 00:26:35,600
We don't have anything else.

578
00:26:35,900 --> 00:26:36,800
We need to worry about there.

579
00:26:36,800 --> 00:26:38,700
So it doesn't matter so we can pass null for that.

580
00:26:39,300 --> 00:26:39,700
Again.

581
00:26:39,700 --> 00:26:42,300
I use zero instead of know, some people like to use null.

582
00:26:42,300 --> 00:26:44,600
And so if you want to use, no, that would be a null for you.

583
00:26:44,600 --> 00:26:48,100
Not a zero nose defined to be 0 and windows.

584
00:26:49,200 --> 00:26:53,900
so when we when we're opening a file, obviously, we also have the

585
00:26:53,900 --> 00:26:59,700
ability in Windows to basically say, create the file or don't create

586
00:26:59,700 --> 00:26:59,800
the

587
00:27:00,000 --> 00:27:02,600
Well if it didn't exist already, so basically what it kind of needs to

588
00:27:02,600 --> 00:27:06,600
know is if there's already a file on the drive, what should I do with

589
00:27:06,600 --> 00:27:06,800
it?

590
00:27:06,800 --> 00:27:09,700
And if there isn't a file on the drive, should I make one, or should I

591
00:27:09,700 --> 00:27:10,400
return an error?

592
00:27:10,400 --> 00:27:11,300
All that sort of stuff?

593
00:27:11,400 --> 00:27:12,700
So this is a read.

594
00:27:12,700 --> 00:27:13,700
This is our read call.

595
00:27:13,700 --> 00:27:15,400
We're saying we're going to read something from a file.

596
00:27:15,700 --> 00:27:18,900
So what we want to do here is we want to say, okay.

597
00:27:18,900 --> 00:27:21,900
I want you to always open a file that already exists.

598
00:27:22,100 --> 00:27:25,200
If there isn't a file existing, I want that to be an error so that the

599
00:27:25,200 --> 00:27:25,800
game knows.

600
00:27:25,800 --> 00:27:29,300
It was trying to load an asset that just plain a there, right?

601
00:27:30,100 --> 00:27:31,200
So that's that's it.

602
00:27:31,400 --> 00:27:34,300
So flags and attributes is basically stuff.

603
00:27:34,300 --> 00:27:37,900
Like, you know, when you go, I don't know, you probably have

604
00:27:37,900 --> 00:27:38,700
experience with this.

605
00:27:38,700 --> 00:27:39,800
If you're a programmer at all.

606
00:27:39,800 --> 00:27:43,400
I'm sure that you have if you go on to your drive and your right click

607
00:27:43,400 --> 00:27:46,900
on something to get properties, there's this stuff down here, read

608
00:27:46,900 --> 00:27:48,500
only hidden that sort of stuff.

609
00:27:48,900 --> 00:27:50,900
Basically, you could specify those things.

610
00:27:51,100 --> 00:27:55,500
If you were creating the file, you can specify those things.

611
00:27:55,500 --> 00:27:59,300
You can also specify a bunch of other flags that have to do with how

612
00:27:59,300 --> 00:27:59,800
the Opera,

613
00:28:00,000 --> 00:28:03,700
Some is going to use this file likes, weird stuff like delete on

614
00:28:03,700 --> 00:28:04,900
clothes, right?

615
00:28:04,900 --> 00:28:07,500
So you can have a temporary files that kind of get to cleaned up

616
00:28:07,500 --> 00:28:10,500
immediately after you close them where you don't have to do it and the

617
00:28:10,500 --> 00:28:13,100
operating system cut, I can do extra stuff there because it knows

618
00:28:13,600 --> 00:28:15,500
there's all sorts of other stuff overlapped.

619
00:28:15,500 --> 00:28:19,600
IO is like possibly how will do, I think we might use IO complete

620
00:28:19,600 --> 00:28:23,200
reports, but that ignore that stuff for now.

621
00:28:23,400 --> 00:28:25,900
There's there's things you can basically set that are how the file

622
00:28:25,900 --> 00:28:28,800
will be read from and those might be relevant to us in the future, but

623
00:28:28,800 --> 00:28:29,800
they're not right now, so,

624
00:28:29,900 --> 00:28:32,300
I don't think we actually have any flags and attributes.

625
00:28:32,300 --> 00:28:33,100
I can't remember.

626
00:28:33,100 --> 00:28:36,200
It's been a while since I've written any file IO code in Windows.

627
00:28:36,700 --> 00:28:40,000
Typically, I use my eye, you know, I have kind of stuff that I have

628
00:28:40,000 --> 00:28:42,800
written a long time ago and used, but I don't think there's anything

629
00:28:42,800 --> 00:28:44,200
we really care about in here.

630
00:28:44,200 --> 00:28:46,900
So I think we can be 0 again and then the template file.

631
00:28:46,900 --> 00:28:47,100
Again.

632
00:28:47,100 --> 00:28:48,500
We also don't need any of that stuff.

633
00:28:48,500 --> 00:28:53,600
So we're basically, we're basically fine with this and basically it's

634
00:28:53,900 --> 00:28:56,700
not equal to invalid handle value.

635
00:28:56,700 --> 00:28:57,700
That is what it will return.

636
00:28:57,800 --> 00:28:59,800
So basically, we're just going to go ahead and try to open the file.

637
00:29:00,300 --> 00:29:01,300
Using these flags.

638
00:29:01,300 --> 00:29:02,200
I think I've got him set.

639
00:29:02,200 --> 00:29:02,400
Right?

640
00:29:02,400 --> 00:29:05,000
But will double check and make sure that I do then.

641
00:29:05,000 --> 00:29:06,000
We'll go in here.

642
00:29:06,200 --> 00:29:09,300
Once we have an open file handle, we can ask for the size.

643
00:29:09,400 --> 00:29:14,200
Here's the file size now, get file size is a little Antiquated.

644
00:29:14,600 --> 00:29:16,500
So we might want to call get file size, the X.

645
00:29:16,500 --> 00:29:20,700
Let me show you what the why I say that we don't really need it for

646
00:29:20,700 --> 00:29:23,200
our purposes, but we could just to be a little more complete.

647
00:29:23,700 --> 00:29:25,900
Basically, what we've got here is.

648
00:29:27,500 --> 00:29:29,500
Yeah, so you can kind of see what

649
00:29:29,900 --> 00:29:30,200
Ins.

650
00:29:30,600 --> 00:29:33,700
This get file size function returns A d word.

651
00:29:33,700 --> 00:29:37,400
Basically, you it's just kind of its just kind of janky.

652
00:29:37,400 --> 00:29:39,600
Let me see if there's a, if there's a less janky one.

653
00:29:39,800 --> 00:29:40,900
Don't know if there is or not.

654
00:29:41,900 --> 00:29:42,400
Yeah.

655
00:29:42,500 --> 00:29:44,000
So let will use the non-genuine.

656
00:29:44,000 --> 00:29:44,700
I'll tell you why.

657
00:29:44,700 --> 00:29:46,700
It's janky and then we'll go from there.

658
00:29:47,000 --> 00:29:49,900
So basically get file size, was written kind of in the days before

659
00:29:49,900 --> 00:29:50,800
64-bit.

660
00:29:51,100 --> 00:29:55,900
A file obviously can be more than 32 bits of space wide, right?

661
00:29:55,900 --> 00:29:57,500
32 bits is 4 billion.

662
00:29:57,500 --> 00:29:59,800
Bytes, roughly, and for, that's a forgery.

663
00:30:00,000 --> 00:30:00,600
File.

664
00:30:00,800 --> 00:30:03,900
Now, anyone who's ever BitTorrent in stuff knows that 4 GB is not

665
00:30:03,900 --> 00:30:05,300
necessarily that large.

666
00:30:05,400 --> 00:30:09,100
You could have files that are more than 4 gigabytes, large, a single

667
00:30:09,100 --> 00:30:09,500
file.

668
00:30:12,700 --> 00:30:16,700
So when you asked for the file size, it needs to return a 64-bit value

669
00:30:16,800 --> 00:30:20,200
because a 32-bit value won't hold the size of some files on a drive.

670
00:30:21,000 --> 00:30:22,500
There's nothing that says that files on a drive.

671
00:30:22,500 --> 00:30:24,500
Have to be limited to four gigs anymore.

672
00:30:24,700 --> 00:30:27,700
I think there used to be in the fat 32 days or something.

673
00:30:27,700 --> 00:30:30,000
There's probably a limitation or something like that or in the regular

674
00:30:30,000 --> 00:30:33,300
fat days are certainly was but there isn't any more certainly not an

675
00:30:33,300 --> 00:30:36,300
NTFS and not on XT XT XT for.

676
00:30:36,800 --> 00:30:39,800
So basically, what you end up doing is when you do a get file size,

677
00:30:40,000 --> 00:30:41,900
it's got a return you to have

678
00:30:42,200 --> 00:30:46,600
Of the third of the 64-bit value, the high 32 bits and the low 32

679
00:30:46,600 --> 00:30:46,800
bits.

680
00:30:46,800 --> 00:30:49,500
And then we would have to basically shift them up and order them

681
00:30:49,500 --> 00:30:50,900
together to put back together.

682
00:30:50,900 --> 00:30:53,000
The actual 64-bit value, right?

683
00:30:53,600 --> 00:30:54,800
Which is not what we want.

684
00:30:54,800 --> 00:30:57,300
We'd rather just have it return a 64-bit value to us.

685
00:30:57,300 --> 00:30:59,300
So there's this get file size, e^x thing.

686
00:30:59,400 --> 00:31:02,300
And if we look down here, we can see it was supported on Windows XP,

687
00:31:02,300 --> 00:31:04,000
which is our minimum supported client.

688
00:31:04,100 --> 00:31:05,100
So this is a function.

689
00:31:05,100 --> 00:31:08,900
They introduced later which basically just flat-out gives us the

690
00:31:08,900 --> 00:31:11,900
64-bit value, which is what we actually would prefer.

691
00:31:12,000 --> 00:31:12,100
/.

692
00:31:12,100 --> 00:31:16,800
So what I'm going to do instead is use get file size X, pass it that

693
00:31:16,800 --> 00:31:19,300
handle that we opened and then pass it.

694
00:31:19,300 --> 00:31:23,100
The address of our file size value, right?

695
00:31:23,100 --> 00:31:25,900
So that, that way, we don't have to deal with that janking.

696
00:31:25,900 --> 00:31:30,900
It's just makes life a little easier for us which, you know, we want,

697
00:31:30,900 --> 00:31:31,800
if we can get it.

698
00:31:31,800 --> 00:31:34,100
So we're going to define a large integer.

699
00:31:34,100 --> 00:31:35,700
We've seen this large integer before.

700
00:31:35,700 --> 00:31:37,800
I don't know, if you remember, when we're doing query performance

701
00:31:37,800 --> 00:31:38,400
counter.

702
00:31:38,400 --> 00:31:42,000
So that quad part is the 64-bit value that we were looking.

703
00:31:42,100 --> 00:31:42,500
For.

704
00:31:42,600 --> 00:31:47,400
So basically file size dot quad, part is what we're looking for tuning

705
00:31:48,200 --> 00:31:48,500
and all.

706
00:31:48,500 --> 00:31:50,700
We're going to do here is assuming that we got the file size.

707
00:31:51,000 --> 00:31:55,900
We will go ahead and try to Virtual a lock that thing basically in

708
00:31:55,900 --> 00:31:59,500
the, you know, something that's that big that will give us our memory.

709
00:32:00,000 --> 00:32:02,800
So this is essentially the result that we're going to return void,

710
00:32:02,800 --> 00:32:04,300
star result.

711
00:32:04,500 --> 00:32:08,200
And then we are going to see if we got it.

712
00:32:08,200 --> 00:32:11,900
If we got the memory, we're going to go ahead and try to read.

713
00:32:12,000 --> 00:32:18,200
Into it by read file like so there we go, and assuming that worked.

714
00:32:18,300 --> 00:32:20,000
There we go that in there.

715
00:32:20,400 --> 00:32:23,200
Then we're going to have to handle some failure cases.

716
00:32:23,500 --> 00:32:27,700
All right, and then of course at the end assuming that we were able to

717
00:32:27,700 --> 00:32:31,100
open the file, we're going to have to close the file as well.

718
00:32:31,100 --> 00:32:33,800
So we're going to go ahead and close this file handle.

719
00:32:33,900 --> 00:32:34,300
There we go.

720
00:32:34,900 --> 00:32:37,000
All right, so a couple things to talk about here and then, of course,

721
00:32:37,000 --> 00:32:38,500
I'm going to return the result.

722
00:32:38,700 --> 00:32:39,200
There we go.

723
00:32:40,200 --> 00:32:41,900
Now, this will just be on here.

724
00:32:42,300 --> 00:32:44,500
Freeing is is Trivial compared.

725
00:32:44,500 --> 00:32:46,500
It's just virtual free.

726
00:32:46,500 --> 00:32:50,500
I believe it was the we've never had to free memory before.

727
00:32:50,500 --> 00:32:51,500
This is our first time.

728
00:32:52,000 --> 00:32:52,900
This is our first time.

729
00:32:52,900 --> 00:32:55,100
People think it's just virtual free.

730
00:32:55,500 --> 00:32:59,800
I don't remember what we need to pass the address, the son.

731
00:33:00,100 --> 00:33:01,800
Is okay.

732
00:33:01,800 --> 00:33:02,700
We're releasing it though.

733
00:33:02,700 --> 00:33:04,200
So we don't actually need the size.

734
00:33:05,000 --> 00:33:06,700
So it's just release.

735
00:33:06,700 --> 00:33:07,400
Memory least.

736
00:33:07,400 --> 00:33:08,300
I think that's it.

737
00:33:08,800 --> 00:33:11,700
So we're just going to release this memory and that's, that's all

738
00:33:11,700 --> 00:33:12,300
we're doing.

739
00:33:12,800 --> 00:33:14,800
So that should be it address free.

740
00:33:14,800 --> 00:33:15,500
Let's see.

741
00:33:15,500 --> 00:33:17,700
A dress size free.

742
00:33:18,200 --> 00:33:20,500
So basically, what's going to happen?

743
00:33:20,500 --> 00:33:23,600
Here is we have a little bit of a janky scenario going on.

744
00:33:24,600 --> 00:33:28,100
But there's not a lot we can do really.

745
00:33:28,300 --> 00:33:34,700
We could memory map, the file, you know, there's, there's other things

746
00:33:34,700 --> 00:33:35,400
we could do here.

747
00:33:35,400 --> 00:33:37,400
I'm going to try and keep it a little simpler than that.

748
00:33:37,700 --> 00:33:40,900
So basically doing it in the straightforward way, where we read it

749
00:33:40,900 --> 00:33:41,400
like this.

750
00:33:41,900 --> 00:33:43,900
Basically we're going to read from the file handle.

751
00:33:44,200 --> 00:33:44,900
We're going to pass it.

752
00:33:44,900 --> 00:33:46,600
The buffer that we allocated, right?

753
00:33:46,600 --> 00:33:51,500
We're going to ask it to read the the file size that we allocated as

754
00:33:51,500 --> 00:33:51,800
well.

755
00:33:52,000 --> 00:33:54,200
And there's, there's some tankiness in there.

756
00:33:55,200 --> 00:33:58,300
And then let's put that in there as well.

757
00:33:58,600 --> 00:34:01,900
And then we're going to pass 04 that overlap parameter because that's

758
00:34:01,900 --> 00:34:05,100
a that's, the overlapped parameter is a thing that basically lets us

759
00:34:05,100 --> 00:34:10,100
say, oh, we want to do this read asynchronously and we're not at that

760
00:34:10,100 --> 00:34:10,500
point yet.

761
00:34:10,500 --> 00:34:13,900
So we're going to pass zero for that first passing the handle where to

762
00:34:13,900 --> 00:34:17,400
put the stuff you read, how much we want you to read.

763
00:34:17,400 --> 00:34:19,699
And then a pointer that says the result.

764
00:34:20,699 --> 00:34:27,199
So basically what you can see here, excuse me is if we really wanted

765
00:34:27,199 --> 00:34:29,300
to support reading large files.

766
00:34:29,600 --> 00:34:32,400
We would have to actually do a loop here because the read file

767
00:34:32,400 --> 00:34:36,699
function in win32 doesn't actually let us pass a 64-bit value.

768
00:34:36,800 --> 00:34:38,199
It was a d word here.

769
00:34:38,500 --> 00:34:40,600
So I'm assuming I'll just get a compile error.

770
00:34:40,800 --> 00:34:41,400
Hopefully.

771
00:34:41,400 --> 00:34:42,400
All right, I gotta do.

772
00:34:42,400 --> 00:34:46,000
Our virtual Alec actually have to pass the rest of the things do it.

773
00:34:46,100 --> 00:34:48,500
We go like that.

774
00:34:49,100 --> 00:34:50,400
So we've got

775
00:34:50,699 --> 00:34:55,699
Zero and that there we go.

776
00:34:56,400 --> 00:34:58,000
So basically the problem here.

777
00:35:02,400 --> 00:35:02,900
There we go.

778
00:35:03,500 --> 00:35:04,500
The problem here.

779
00:35:05,100 --> 00:35:06,300
Is that this guy?

780
00:35:07,600 --> 00:35:12,800
This quad part is actually a 64-bit value, but read file,

781
00:35:13,100 --> 00:35:18,100
unfortunately, doesn't actually take a 64-bit value.

782
00:35:18,100 --> 00:35:21,400
So, if we go in here and we look, it just takes a d word.

783
00:35:21,600 --> 00:35:22,100
Right?

784
00:35:22,300 --> 00:35:26,500
And the problem with that is the d word is not Siz only 32 bits.

785
00:35:26,600 --> 00:35:29,700
So, if the file actually were larger than 4 gigabytes.

786
00:35:29,700 --> 00:35:33,800
This, this would fail, the allocation would probably succeed but the

787
00:35:33,800 --> 00:35:35,500
read would just flat-out fail.

788
00:35:35,800 --> 00:35:37,200
Now we don't actually care.

789
00:35:37,400 --> 00:35:37,900
About right.

790
00:35:37,900 --> 00:35:39,100
Reading in our debug.

791
00:35:39,100 --> 00:35:42,500
We're never going to read a 4 gigabyte file into memory in one.

792
00:35:42,500 --> 00:35:43,300
Go like that.

793
00:35:43,400 --> 00:35:44,800
That's not something we're going to do.

794
00:35:44,900 --> 00:35:48,000
So what we can do here is just assert.

795
00:35:48,200 --> 00:35:50,800
This is again where the assert thing comes in which is nice.

796
00:35:51,200 --> 00:35:53,500
We can just assert that that file size.

797
00:35:53,500 --> 00:35:59,800
Quad part is basically less than the maximum value.

798
00:36:00,200 --> 00:36:01,200
That we would get here.

799
00:36:01,300 --> 00:36:01,700
Right?

800
00:36:01,800 --> 00:36:06,100
So this sort of a thing basically that it's less than the maximum

801
00:36:06,100 --> 00:36:09,800
32-bit value, then that you can have or up to it.

802
00:36:09,800 --> 00:36:10,200
I suppose.

803
00:36:10,200 --> 00:36:11,300
We could be up to it.

804
00:36:11,600 --> 00:36:12,400
Exactly.

805
00:36:12,600 --> 00:36:16,100
Now, one of the nice things we could do is, and this is something,

806
00:36:16,100 --> 00:36:19,400
maybe we'll do next week, when we're sort of going through to dues, is

807
00:36:20,300 --> 00:36:24,400
defines for maximum values because it would be nice here to be able to

808
00:36:24,400 --> 00:36:28,100
do something like you, Aunt, 32 Max in that.

809
00:36:28,100 --> 00:36:29,700
So people know why we're trying to test

810
00:36:30,000 --> 00:36:32,500
It's that because we're basically saying is the max value and the

811
00:36:32,500 --> 00:36:37,900
standard in .h, I believe or limits .h, there's there are C runtime

812
00:36:37,900 --> 00:36:38,900
Library function.

813
00:36:39,000 --> 00:36:44,300
Seen there are platform defines that tell us these values so we can

814
00:36:44,300 --> 00:36:45,900
actually get them pretty easily as well.

815
00:36:46,000 --> 00:36:48,800
So anyway, that's something but for now, we could just say assert that

816
00:36:48,800 --> 00:36:51,900
the sizes less than 32 bits and then we're fine, right?

817
00:36:51,900 --> 00:36:53,200
Then, and then we're totally fine.

818
00:36:53,500 --> 00:36:58,300
So, after that, we could do something like this file size 32, we could

819
00:36:58,300 --> 00:36:59,800
we could even make it explicit.

820
00:37:00,000 --> 00:37:01,300
Doing here, right?

821
00:37:01,700 --> 00:37:03,100
And and off we go.

822
00:37:03,300 --> 00:37:06,500
So that is one way to do it.

823
00:37:06,600 --> 00:37:07,500
Another thing we could do.

824
00:37:07,500 --> 00:37:10,500
That's that's also safe and I kind of like I kind of like this a

825
00:37:10,500 --> 00:37:15,800
little bit is we can define something like this where we do safe

826
00:37:15,800 --> 00:37:21,900
truncate 32 or something like this like that and then we pass it in 64

827
00:37:21,900 --> 00:37:24,000
value, you N64 value here.

828
00:37:25,000 --> 00:37:28,400
So maybe something like this safe, truncate you N64.

829
00:37:28,900 --> 00:37:29,800
And that basically

830
00:37:29,900 --> 00:37:30,800
Says, all right.

831
00:37:30,800 --> 00:37:32,000
I've got a you N64.

832
00:37:32,000 --> 00:37:35,300
I want to, I want to truncate it to 32 bits and I want to make sure

833
00:37:35,300 --> 00:37:36,400
that there's an assertion around it.

834
00:37:36,400 --> 00:37:37,100
So I know.

835
00:37:37,200 --> 00:37:38,400
So here is the value.

836
00:37:38,400 --> 00:37:39,600
I'm just going to bake this.

837
00:37:39,600 --> 00:37:41,000
What we did in there.

838
00:37:41,000 --> 00:37:41,200
Right?

839
00:37:41,200 --> 00:37:43,900
So I'm going to assert that, whatever the value is, is less than

840
00:37:43,900 --> 00:37:45,600
whatever the maximum is, right?

841
00:37:45,700 --> 00:37:46,500
Something like this.

842
00:37:47,000 --> 00:37:49,300
And then I'm going to go ahead and say all right.

843
00:37:49,500 --> 00:37:51,700
The result is going to be that thing.

844
00:37:51,700 --> 00:37:53,800
Truncated and then we returned it.

845
00:37:53,800 --> 00:37:56,800
So just a nice little inline function here that does that truncation.

846
00:37:57,000 --> 00:37:59,300
Now, I can see what's going on a little cleaner.

847
00:37:59,400 --> 00:37:59,800
I can say,

848
00:38:00,000 --> 00:38:05,200
All right, safe, truncate that and that makes me aware that at least

849
00:38:05,400 --> 00:38:07,000
always in debug mode.

850
00:38:07,300 --> 00:38:10,700
I know that I would, I would get an immediate hard error.

851
00:38:11,100 --> 00:38:15,100
If for some reason, the things weren't small, like, I thought so.

852
00:38:15,200 --> 00:38:18,500
So, you know, I'll put that out in our in our platform independent

853
00:38:18,500 --> 00:38:21,900
layer because it is platform independent, basically, in our little

854
00:38:21,900 --> 00:38:23,500
utilities here, right?

855
00:38:23,700 --> 00:38:25,600
That's just, that's just kind of a nice thing to have.

856
00:38:26,000 --> 00:38:28,500
So I like that, I like doing stuff like that.

857
00:38:28,500 --> 00:38:29,800
We're now I can just bake it out and just know.

858
00:38:29,900 --> 00:38:32,800
No, now from, now on anytime, I'm going to do on those truncations.

859
00:38:33,000 --> 00:38:35,000
I can feel a little more comfortable that at least they're getting it

860
00:38:35,200 --> 00:38:35,800
asserted.

861
00:38:35,800 --> 00:38:38,700
So, if someone starts using this code for purposes other than what I

862
00:38:38,700 --> 00:38:41,800
thought, they'll immediately get that assertion and know what's going

863
00:38:41,800 --> 00:38:43,400
on, why their code isn't working anymore.

864
00:38:43,700 --> 00:38:45,700
So that's one thing right?

865
00:38:45,700 --> 00:38:46,200
There we go.

866
00:38:47,500 --> 00:38:50,900
So, okay, so we now we're okay, because we're basically saying we're

867
00:38:50,900 --> 00:38:52,700
never going to read files that big, so it's fine.

868
00:38:52,700 --> 00:38:55,000
So we're checking the file size and make sure that it's going to work

869
00:38:55,000 --> 00:38:56,800
and it will hopefully work.

870
00:38:57,000 --> 00:38:58,000
Once we get in here.

871
00:38:58,000 --> 00:38:59,800
We're going to do our read file in our read.

872
00:39:00,000 --> 00:39:02,500
How can fail, of course, right?

873
00:39:02,600 --> 00:39:06,900
So basically, if since our read file can fail one thing before I

874
00:39:06,900 --> 00:39:11,400
forget to, these are all a functions, right?

875
00:39:12,300 --> 00:39:13,400
Because they take a file name.

876
00:39:13,900 --> 00:39:14,300
Yeah.

877
00:39:14,400 --> 00:39:17,500
So this is a create file, a for those of you who are doing Unicode at

878
00:39:17,500 --> 00:39:17,800
home.

879
00:39:18,000 --> 00:39:18,400
All right.

880
00:39:18,400 --> 00:39:21,600
Anyway, so basically when we're doing these, when we're doing this

881
00:39:21,600 --> 00:39:23,200
Reed, the Reed can fail.

882
00:39:23,300 --> 00:39:27,500
If the read fails, we don't want to return the memory.

883
00:39:27,600 --> 00:39:29,800
We want to free it.

884
00:39:30,000 --> 00:39:31,100
It right here, right?

885
00:39:31,100 --> 00:39:35,900
We want to basically say free this memory that we had immediately

886
00:39:36,000 --> 00:39:39,400
because we don't want the memory left sitting around.

887
00:39:39,400 --> 00:39:44,100
So that result that we did we want to free that and set it to 0.

888
00:39:44,100 --> 00:39:46,800
So that it's as if we never allocated in the first place, it's the

889
00:39:46,800 --> 00:39:48,100
same as an allocation failure.

890
00:39:48,100 --> 00:39:51,800
Basically, if the read fails, because otherwise, if the read fails, we

891
00:39:51,800 --> 00:39:54,600
would still have, we still had the memory, we'd return the memory to

892
00:39:54,600 --> 00:39:55,800
the to the caller.

893
00:39:55,800 --> 00:39:58,100
They would think they read the file, but it actually what they have is

894
00:39:58,100 --> 00:39:58,900
garbage memory.

895
00:39:59,100 --> 00:39:59,800
There's no sense in

896
00:40:00,000 --> 00:40:03,400
Enforcing the the layer to figure that out on its own, right?

897
00:40:03,400 --> 00:40:04,500
So we don't want to do that.

898
00:40:04,700 --> 00:40:05,700
So assuming here.

899
00:40:06,100 --> 00:40:11,800
This is the success case File read successfully and then we get there

900
00:40:11,800 --> 00:40:12,100
we go.

901
00:40:12,100 --> 00:40:15,600
Now, you might wonder why I left an empty when here I just like I like

902
00:40:15,600 --> 00:40:20,500
to get further nested in success and put my errors in the else cases

903
00:40:21,100 --> 00:40:22,800
and and you know, logging in there.

904
00:40:22,800 --> 00:40:25,600
So, you know, maybe we'll do some logging here, right?

905
00:40:25,600 --> 00:40:26,200
That's the way.

906
00:40:26,200 --> 00:40:29,800
I like things to always look, that is the only reason that that looks

907
00:40:29,800 --> 00:40:29,800
like.

908
00:40:29,900 --> 00:40:32,700
Like that, so we could we could have logging in here for an inability

909
00:40:32,700 --> 00:40:34,000
to open files and stuff like that.

910
00:40:34,000 --> 00:40:34,500
Right.

911
00:40:34,500 --> 00:40:35,000
Make sense.

912
00:40:35,600 --> 00:40:37,000
So that's that's all that is.

913
00:40:37,900 --> 00:40:39,100
Yeah, pretty straightforward.

914
00:40:39,100 --> 00:40:41,500
So that's basically it.

915
00:40:41,800 --> 00:40:44,800
There isn't really a lot else to it, besides that.

916
00:40:45,400 --> 00:40:48,800
And, and if we were going to do a right, it's basically the exact same

917
00:40:48,800 --> 00:40:49,100
stuff.

918
00:40:49,100 --> 00:40:51,600
Let me compile this and make sure we're working here.

919
00:40:51,600 --> 00:40:52,000
Oh, right.

920
00:40:52,000 --> 00:40:53,200
The actual bytes red.

921
00:40:54,900 --> 00:40:55,800
Let's see here.

922
00:40:58,100 --> 00:41:02,500
D word, b, read that will tell us how many we actually read.

923
00:41:02,700 --> 00:41:02,900
Now.

924
00:41:02,900 --> 00:41:05,700
The interesting thing here is technically the read could read less

925
00:41:05,700 --> 00:41:07,500
than how many we asked it to read.

926
00:41:07,800 --> 00:41:12,300
I don't think that's actually possible in any scenario.

927
00:41:14,700 --> 00:41:16,000
That isn't going to wear.

928
00:41:16,000 --> 00:41:17,600
The read isn't going to fail meaning.

929
00:41:17,600 --> 00:41:18,400
I don't think it can.

930
00:41:18,700 --> 00:41:20,300
I don't think that it can read less.

931
00:41:20,300 --> 00:41:23,300
If we know that the file is that big if someone went in and truncated

932
00:41:23,300 --> 00:41:26,900
it maybe in between then it would fail.

933
00:41:28,400 --> 00:41:29,600
So, you know what?

934
00:41:29,600 --> 00:41:35,500
I might I might say I might go ahead and say let's handle that case as

935
00:41:35,500 --> 00:41:35,900
well.

936
00:41:36,600 --> 00:41:38,300
Let's so let's say here.

937
00:41:38,400 --> 00:41:42,800
Let's just also say that we want file size 32 to be equal to B read.

938
00:41:42,900 --> 00:41:44,100
So we're basically going to say,

939
00:41:46,100 --> 00:41:47,200
Do this read.

940
00:41:47,300 --> 00:41:48,500
Assuming the read return.

941
00:41:48,500 --> 00:41:52,400
True check to see whether B read in file size or equal.

942
00:41:52,400 --> 00:41:54,100
If they are, then considered success.

943
00:41:54,100 --> 00:41:59,000
Otherwise consider it a failure because just in case we hit someone

944
00:41:59,000 --> 00:41:59,800
truncated the file.

945
00:42:00,000 --> 00:42:03,200
Between there and we only read part part of it out because technically

946
00:42:03,200 --> 00:42:07,800
the way read file always works in things as you can, specify a larger

947
00:42:07,800 --> 00:42:11,800
value than the size of the file than is left in the file.

948
00:42:12,500 --> 00:42:14,100
And basically, it will just give you back.

949
00:42:14,100 --> 00:42:15,500
However, much it could read.

950
00:42:15,600 --> 00:42:17,900
That's just how they're usually defined and that's not an error that's

951
00:42:17,900 --> 00:42:18,700
just allowed.

952
00:42:18,900 --> 00:42:21,700
And so, if someone went in and truncated the file, while we in

953
00:42:21,700 --> 00:42:25,400
between, when we got it Sighs, and when we read it, technically we

954
00:42:25,400 --> 00:42:28,500
would hit that error case, where it would just it would, the read file

955
00:42:28,500 --> 00:42:29,900
would succeed, but we would

956
00:42:30,000 --> 00:42:30,900
Get back less bytes.

957
00:42:30,900 --> 00:42:33,500
So we want to consider it a success only if we actually were able to

958
00:42:33,500 --> 00:42:34,300
read the whole file.

959
00:42:34,300 --> 00:42:35,400
So I'm just going to go ahead and say that.

960
00:42:35,400 --> 00:42:39,000
Now notice we took advantage of the short circuiting here.

961
00:42:39,200 --> 00:42:40,500
When we did the read file.

962
00:42:41,600 --> 00:42:45,400
We're saying we're not going to do bother doing this check until after

963
00:42:45,400 --> 00:42:46,200
this is done.

964
00:42:46,300 --> 00:42:49,600
And so the fact that we know that this has to happen before, this is

965
00:42:49,600 --> 00:42:50,600
the only reason that works.

966
00:42:50,600 --> 00:42:54,400
If see could do these in any order, this code wouldn't work properly

967
00:42:54,400 --> 00:42:58,000
because this could be evaluated before the read file and of course

968
00:42:58,000 --> 00:42:59,600
read file, modifies B story.

969
00:43:00,000 --> 00:43:00,700
B red.

970
00:43:00,800 --> 00:43:05,000
So that wouldn't work but we know that c is required to execute these

971
00:43:05,000 --> 00:43:05,500
in the order.

972
00:43:05,500 --> 00:43:06,700
They appear on the line.

973
00:43:07,200 --> 00:43:11,600
That's how the and the operator and is defined to always do.

974
00:43:11,600 --> 00:43:14,400
It's the thing before it first and then the thing after it.

975
00:43:14,700 --> 00:43:16,100
So we know that that's going to be okay.

976
00:43:16,700 --> 00:43:18,300
So that's that's our read.

977
00:43:19,000 --> 00:43:21,300
We can step into it now and see if it worked.

978
00:43:21,400 --> 00:43:25,200
Of course, we know that that file that I asked for, it doesn't exist.

979
00:43:25,300 --> 00:43:28,600
So what should happen if things are working properly here is it should

980
00:43:28,600 --> 00:43:29,500
be an error?

981
00:43:29,900 --> 00:43:31,900
So, let's go ahead in there.

982
00:43:32,300 --> 00:43:32,800
What?

983
00:43:32,800 --> 00:43:35,200
I actually want handmade that CP, which is not open yet, but that's

984
00:43:35,200 --> 00:43:35,700
okay.

985
00:43:36,200 --> 00:43:40,500
We'll just set a break point where we actually call it and then we'll

986
00:43:40,500 --> 00:43:41,200
step in there.

987
00:43:41,500 --> 00:43:45,200
So, all right, so we come in here and basically we're going to call

988
00:43:45,200 --> 00:43:46,200
this again.

989
00:43:46,200 --> 00:43:48,600
We're passing it test dot BMP.

990
00:43:48,900 --> 00:43:51,700
So that's going to call create file and that should just flat-out fail

991
00:43:51,700 --> 00:43:52,300
and it does.

992
00:43:53,500 --> 00:43:57,500
So what we need to do here is we now need to give it a file.

993
00:43:57,500 --> 00:43:59,800
That actually could be loaded something.

994
00:44:00,000 --> 00:44:01,300
Actually exists.

995
00:44:01,400 --> 00:44:04,700
So I'm just going to pick a random file temporarily for purposes of

996
00:44:04,700 --> 00:44:05,200
testing.

997
00:44:05,700 --> 00:44:06,700
Let's take a look.

998
00:44:06,800 --> 00:44:08,800
What is on W Colin's?

999
00:44:09,000 --> 00:44:09,900
Let's see.

1000
00:44:09,900 --> 00:44:10,900
Handmade.

1001
00:44:12,800 --> 00:44:14,000
In fact, you know what we could do?

1002
00:44:14,000 --> 00:44:16,000
We could just say this.

1003
00:44:17,200 --> 00:44:22,000
That is a c preprocessor, macro that inserts the name of the file that

1004
00:44:22,000 --> 00:44:22,900
got compiled.

1005
00:44:23,000 --> 00:44:27,100
So I could just try to load myself basically, so I come in here.

1006
00:44:27,700 --> 00:44:28,300
Let's see.

1007
00:44:28,500 --> 00:44:29,900
Let's take a look at that file name.

1008
00:44:30,400 --> 00:44:31,700
W, handmade code.

1009
00:44:31,700 --> 00:44:33,400
Handmade always good.

1010
00:44:33,900 --> 00:44:35,900
So let's go in there and see if we can read that.

1011
00:44:36,200 --> 00:44:40,400
We did the, the create file, and the file handle came back valid.

1012
00:44:40,400 --> 00:44:41,000
This time.

1013
00:44:41,500 --> 00:44:42,400
We take a look at it.

1014
00:44:42,400 --> 00:44:44,900
We get the file size and let's see what that file size.

1015
00:44:45,400 --> 00:44:45,800
Actually.

1016
00:44:45,800 --> 00:44:46,800
Is it?

1017
00:44:47,000 --> 00:44:47,700
Well, you know what?

1018
00:44:47,700 --> 00:44:50,100
Let's see it in decimal because that would be better.

1019
00:44:50,600 --> 00:44:51,300
There we go.

1020
00:44:52,000 --> 00:44:54,100
So we'll take a look at that file size.

1021
00:44:54,300 --> 00:44:56,400
It's 3091 B.

1022
00:44:56,900 --> 00:44:59,500
Does that square with our expectation?

1023
00:45:00,000 --> 00:45:03,100
Of what the file actually is on disk.

1024
00:45:03,500 --> 00:45:06,300
Yep, 3091 exactly.

1025
00:45:06,300 --> 00:45:06,600
Right?

1026
00:45:06,600 --> 00:45:07,400
So that worked fine.

1027
00:45:07,700 --> 00:45:10,200
We're going to Alec that memory will take a look at it.

1028
00:45:10,200 --> 00:45:14,700
Check the results that works fine.

1029
00:45:14,700 --> 00:45:18,500
The read file succeeded, which is what we would expect.

1030
00:45:18,500 --> 00:45:20,900
We close it and we come out here.

1031
00:45:20,900 --> 00:45:22,100
Now in theory.

1032
00:45:22,100 --> 00:45:25,200
We now have our quote, unquote bitmap memory.

1033
00:45:25,200 --> 00:45:29,000
Of course, it's not really bitmap, but we could take a look at that

1034
00:45:29,000 --> 00:45:30,000
memory if we wanted to.

1035
00:45:30,000 --> 00:45:33,600
To write we can see what's in there and what we would expect to see is

1036
00:45:33,600 --> 00:45:35,100
the contents of the file, right?

1037
00:45:35,100 --> 00:45:35,900
Because that's what we did.

1038
00:45:35,900 --> 00:45:38,100
We told it to load it off the disk.

1039
00:45:38,100 --> 00:45:39,300
So here's that address.

1040
00:45:39,500 --> 00:45:41,000
I'm going to paste that address in here.

1041
00:45:41,200 --> 00:45:41,800
There we go.

1042
00:45:42,700 --> 00:45:44,200
And hey lo and behold there it is.

1043
00:45:44,200 --> 00:45:47,400
There's our file looks exactly like it looks.

1044
00:45:47,800 --> 00:45:48,600
So there you go.

1045
00:45:49,000 --> 00:45:50,100
So that all worked fine.

1046
00:45:50,500 --> 00:45:51,800
Then, we're going to go ahead and free it.

1047
00:45:51,900 --> 00:45:52,400
Going here.

1048
00:45:52,400 --> 00:45:55,800
The virtual free gets rid of it, which is exactly what we wanted.

1049
00:45:55,800 --> 00:45:56,800
You can see it Vapes.

1050
00:45:56,800 --> 00:45:58,700
The least the member back to the OS.

1051
00:45:58,700 --> 00:45:59,800
So we can't read anymore.

1052
00:46:00,000 --> 00:46:01,300
Exactly what we wanted.

1053
00:46:01,500 --> 00:46:03,000
So that's all good.

1054
00:46:03,000 --> 00:46:05,000
And we are pretty much done.

1055
00:46:05,000 --> 00:46:05,200
That.

1056
00:46:05,200 --> 00:46:07,900
Is that is file IO, very exciting.

1057
00:46:08,600 --> 00:46:10,800
Now again, just to be clear on things.

1058
00:46:10,800 --> 00:46:14,000
This is only for debugging, you would not want a virtual Alec every

1059
00:46:14,000 --> 00:46:16,700
individual file like that because virtual Alec is for large

1060
00:46:16,700 --> 00:46:17,500
applications.

1061
00:46:18,000 --> 00:46:21,100
I think it's minimum allocation size is 64.

1062
00:46:21,100 --> 00:46:21,600
K.

1063
00:46:21,900 --> 00:46:22,900
Maybe something like that.

1064
00:46:22,900 --> 00:46:26,600
It allocates in 4k pages, but I think you can't allocate less than 64

1065
00:46:26,600 --> 00:46:26,800
of them.

1066
00:46:26,800 --> 00:46:29,800
Because basically the granularity of it is,

1067
00:46:29,900 --> 00:46:30,400
That.

1068
00:46:31,100 --> 00:46:33,900
So you're using up that much of the virtual address space.

1069
00:46:34,000 --> 00:46:34,300
I do.

1070
00:46:34,800 --> 00:46:35,700
Although you may not care.

1071
00:46:35,700 --> 00:46:38,500
It's a long story but point being you don't want to be doing lots of

1072
00:46:38,500 --> 00:46:39,700
small virtual Alex.

1073
00:46:39,900 --> 00:46:42,000
So the only reason we're doing this is because we know that this is

1074
00:46:42,000 --> 00:46:43,300
only for our debugging purposes.

1075
00:46:43,500 --> 00:46:47,300
You wouldn't be you wouldn't be doing that normally and if you care

1076
00:46:47,300 --> 00:46:49,000
too much you could do this.

1077
00:46:49,000 --> 00:46:50,500
You could call Heap a lock.

1078
00:46:50,800 --> 00:46:53,500
If you, if you actually cared about it because that will use the

1079
00:46:53,500 --> 00:46:57,400
actual OS Heap which is designed for more small applications like

1080
00:46:57,400 --> 00:46:59,000
that, but we don't care about that.

1081
00:46:59,000 --> 00:46:59,800
So we're just going to stick to use.

1082
00:47:00,000 --> 00:47:01,000
Virtual work for now.

1083
00:47:01,200 --> 00:47:02,100
So that's it.

1084
00:47:02,200 --> 00:47:05,100
The only thing we need to do now is basically clone this function for

1085
00:47:05,100 --> 00:47:05,600
writing.

1086
00:47:06,200 --> 00:47:07,400
It's pretty straightforward.

1087
00:47:07,500 --> 00:47:10,200
Basically, we don't need to do any of the allocations stuff anymore.

1088
00:47:10,200 --> 00:47:12,300
So that simplifies our life quite a bit.

1089
00:47:12,300 --> 00:47:14,000
Nor do we need to get the science for things.

1090
00:47:14,500 --> 00:47:18,700
All we really need to do is just open the file right to it and close

1091
00:47:18,700 --> 00:47:18,800
it.

1092
00:47:18,800 --> 00:47:21,200
So basically all we're going to do here is change, what we're passing.

1093
00:47:21,400 --> 00:47:23,000
We're going to do generic, right?

1094
00:47:23,200 --> 00:47:26,500
We're going to say that we don't have any file sharing, and we're

1095
00:47:26,500 --> 00:47:29,600
going to be do a create always basically

1096
00:47:30,400 --> 00:47:31,300
Well, actually, you know what?

1097
00:47:31,300 --> 00:47:32,000
I got to go look.

1098
00:47:32,000 --> 00:47:34,700
And make sure what the actual flags are for saying.

1099
00:47:34,700 --> 00:47:36,500
We always want to overwrite everything.

1100
00:47:37,300 --> 00:47:38,200
Let's double-check.

1101
00:47:39,800 --> 00:47:44,900
All right, so create file basically, going to take the share mode is

1102
00:47:44,900 --> 00:47:45,400
zero right?

1103
00:47:45,400 --> 00:47:47,300
Other possum opening at all.

1104
00:47:47,300 --> 00:47:48,300
That's what we wanted.

1105
00:47:48,500 --> 00:47:50,300
So we're changing our share mode, 20.

1106
00:47:50,600 --> 00:47:52,400
We're asking for generic, right pillars.

1107
00:47:52,400 --> 00:47:53,600
We don't need to read from it.

1108
00:47:53,700 --> 00:47:56,000
So we can just say generic, right?

1109
00:47:56,100 --> 00:47:57,900
And then we've got create always.

1110
00:47:59,300 --> 00:47:59,800
Let's see.

1111
00:48:01,600 --> 00:48:02,700
Yes, I think we're good.

1112
00:48:02,700 --> 00:48:06,600
If the specified file exists, the function overrides the file, which

1113
00:48:06,600 --> 00:48:07,500
is what we want.

1114
00:48:08,000 --> 00:48:09,700
If it doesn't exist a new files created.

1115
00:48:09,700 --> 00:48:12,800
So I think that's exactly what we want because we want to overwrite

1116
00:48:12,800 --> 00:48:13,800
old files.

1117
00:48:14,400 --> 00:48:18,300
So that should be it's that's all we really need.

1118
00:48:19,500 --> 00:48:21,100
That's all we really need.

1119
00:48:21,200 --> 00:48:23,300
So then when we come in here, we're just going to write the memory to

1120
00:48:23,300 --> 00:48:23,500
it.

1121
00:48:23,500 --> 00:48:27,300
So we're basically just going to do the equivalent right file.

1122
00:48:27,600 --> 00:48:29,800
We're basically what we do is we pass the memory size.

1123
00:48:30,000 --> 00:48:31,300
Sighs there.

1124
00:48:31,600 --> 00:48:34,300
And the memory, that should be it.

1125
00:48:34,800 --> 00:48:35,500
Like that.

1126
00:48:35,700 --> 00:48:36,600
Something like that.

1127
00:48:36,600 --> 00:48:38,200
I don't actually know what you pass, the right file.

1128
00:48:38,200 --> 00:48:39,500
Let's take a look right?

1129
00:48:39,500 --> 00:48:39,900
Wow.

1130
00:48:43,500 --> 00:48:44,000
There we go.

1131
00:48:45,400 --> 00:48:52,100
So right file, we pass the file handle which we did pass the buffer

1132
00:48:52,500 --> 00:48:53,400
which we did.

1133
00:48:54,100 --> 00:48:56,800
We pass the number of bytes to right which we did.

1134
00:48:56,900 --> 00:49:00,100
Then we need the B written which is equivalent here.

1135
00:49:00,100 --> 00:49:01,400
B written.

1136
00:49:02,500 --> 00:49:04,300
And then we've got the overlap parameters.

1137
00:49:04,300 --> 00:49:05,000
So there we go.

1138
00:49:05,100 --> 00:49:05,900
Basically the same.

1139
00:49:06,900 --> 00:49:10,200
We are going to basically do.

1140
00:49:10,200 --> 00:49:11,100
None of that.

1141
00:49:11,400 --> 00:49:16,700
I guess we could log it, if they wanted to, when we do our logging and

1142
00:49:16,700 --> 00:49:19,600
that is it really, that's not a lot to it.

1143
00:49:20,000 --> 00:49:21,400
Basically, the same stuff here.

1144
00:49:21,400 --> 00:49:24,600
We're going to assume false failure and then we're going to set our

1145
00:49:24,600 --> 00:49:28,200
result parameter to whether the B written equals.

1146
00:49:28,200 --> 00:49:31,300
The, the size that we were trying to, right, right, like that.

1147
00:49:31,300 --> 00:49:32,600
So that's it.

1148
00:49:32,600 --> 00:49:35,800
Really, and you'll notice the way I have structured these I tend to

1149
00:49:35,800 --> 00:49:39,700
like to make a result variable set it to failure at the outset.

1150
00:49:41,000 --> 00:49:43,600
Which I try to make V2 zero value as much as possible.

1151
00:49:43,900 --> 00:49:45,700
So the default failure is zero there.

1152
00:49:46,400 --> 00:49:50,100
I try to do the operations and when I get all the way onto the inside,

1153
00:49:50,200 --> 00:49:54,300
I will then set that result to whether or not the thing succeeded and

1154
00:49:54,300 --> 00:49:56,900
then up, and then let that fall out, that's tends to be the way that I

1155
00:49:56,900 --> 00:49:57,600
write these functions.

1156
00:49:57,600 --> 00:50:02,700
I find it's pretty clean and makes it easy to verify that everything

1157
00:50:02,700 --> 00:50:03,000
went.

1158
00:50:03,000 --> 00:50:03,500
Okay.

1159
00:50:03,700 --> 00:50:06,800
So that's our right entire file and nothing really special there.

1160
00:50:06,800 --> 00:50:09,900
It's just the inverse of the read basically, you know.

1161
00:50:10,800 --> 00:50:11,500
Opening is the same.

1162
00:50:11,500 --> 00:50:14,400
And then just instead of calling the read, we just call a right that's

1163
00:50:14,400 --> 00:50:14,800
it.

1164
00:50:15,200 --> 00:50:16,000
Nothing else to it.

1165
00:50:16,000 --> 00:50:17,800
And of course, we don't need to do any allocations there.

1166
00:50:17,800 --> 00:50:21,000
So it's a simpler function, so, out.

1167
00:50:21,000 --> 00:50:22,300
And here we could do that.

1168
00:50:22,300 --> 00:50:26,400
Now, we could say, basically we don't call this bitmap memory because

1169
00:50:26,400 --> 00:50:27,300
it ain't a bitmap.

1170
00:50:27,500 --> 00:50:29,600
So we're basically to read the entire file.

1171
00:50:29,800 --> 00:50:32,400
Then if we're here, we'll do Platform, right?

1172
00:50:32,400 --> 00:50:33,300
Entire file.

1173
00:50:33,700 --> 00:50:36,900
And basically what we'll do is we'll write out a test file here.

1174
00:50:37,100 --> 00:50:39,600
I'll just say w handmade.

1175
00:50:40,800 --> 00:50:43,000
Test dot out, like that.

1176
00:50:43,600 --> 00:50:44,400
And whoop.

1177
00:50:45,000 --> 00:50:45,900
Almond milk fail.

1178
00:50:46,900 --> 00:50:47,400
There we go.

1179
00:50:47,400 --> 00:50:49,300
Always got to put it out here a little further.

1180
00:50:49,300 --> 00:50:51,200
I think that's the right thing to do.

1181
00:50:51,400 --> 00:50:51,700
Okay.

1182
00:50:51,700 --> 00:50:54,200
So basically all we're doing here is I'm just going to read the file

1183
00:50:54,200 --> 00:50:56,000
in and then I'm going to write out an another file.

1184
00:50:56,000 --> 00:50:59,400
That's basically a test file will put that in the data directory.

1185
00:51:00,400 --> 00:51:01,700
Just just to test it.

1186
00:51:02,400 --> 00:51:05,700
Let's see, does not take one arguments.

1187
00:51:05,700 --> 00:51:06,600
You're very right.

1188
00:51:06,600 --> 00:51:06,900
Sir.

1189
00:51:06,900 --> 00:51:08,100
It does not.

1190
00:51:08,800 --> 00:51:10,600
Oh, good point.

1191
00:51:10,800 --> 00:51:13,900
See this is the this is the thing, people always got.

1192
00:51:14,000 --> 00:51:16,700
You always got a right to usage code or you're going to miss stuff.

1193
00:51:16,900 --> 00:51:20,900
You always got to have the usage code, never, develop an API without

1194
00:51:20,900 --> 00:51:21,600
the usage code.

1195
00:51:21,600 --> 00:51:25,400
So basically, what happened here is, I forgot one crucial thing, which

1196
00:51:25,400 --> 00:51:27,100
is when we actually have these.

1197
00:51:27,800 --> 00:51:28,600
Where was that there?

1198
00:51:28,600 --> 00:51:29,100
There it is.

1199
00:51:29,400 --> 00:51:30,000
When we actually

1200
00:51:30,300 --> 00:51:33,900
Is when we read the entire file, we need to know how big it was as

1201
00:51:33,900 --> 00:51:34,300
well.

1202
00:51:34,400 --> 00:51:38,100
So we actually need debug read file result.

1203
00:51:38,100 --> 00:51:44,300
You actually need to return the, the, the data like the contents of

1204
00:51:44,300 --> 00:51:44,900
the file.

1205
00:51:45,600 --> 00:51:49,600
But we also need the flat, the content size, right?

1206
00:51:49,700 --> 00:51:52,800
We need both of those things and we don't have them right now.

1207
00:51:53,200 --> 00:51:56,600
So, basically, what we need to do is we need to return this from that

1208
00:51:56,600 --> 00:51:58,100
read entire file function.

1209
00:51:58,200 --> 00:51:58,900
Does that make sense?

1210
00:51:59,300 --> 00:52:00,100
So, that was good.

1211
00:52:00,200 --> 00:52:04,000
Catch their who always write the usage code, you got to have that uses

1212
00:52:04,000 --> 00:52:04,400
code.

1213
00:52:04,400 --> 00:52:07,300
Otherwise you go ship that thing to someone and then you realize that

1214
00:52:07,300 --> 00:52:08,800
no one can actually use it in practice.

1215
00:52:09,000 --> 00:52:09,800
It's so good.

1216
00:52:09,800 --> 00:52:10,400
The usage code.

1217
00:52:10,400 --> 00:52:11,700
Saves you so much time.

1218
00:52:11,900 --> 00:52:14,300
Always, always, always develop the usage code.

1219
00:52:15,800 --> 00:52:17,300
Developed usage code if you can.

1220
00:52:18,000 --> 00:52:18,400
All right.

1221
00:52:18,400 --> 00:52:21,100
So anyway, here's our actual result.

1222
00:52:21,600 --> 00:52:25,000
We're going to initialize that there and then what we'll do here is

1223
00:52:25,000 --> 00:52:28,500
when we come through assuming that the file was read successfully,

1224
00:52:29,000 --> 00:52:30,100
then we're going to have own

1225
00:52:30,200 --> 00:52:31,900
We're going to actually have a void star.

1226
00:52:32,300 --> 00:52:32,800
Well, no.

1227
00:52:32,800 --> 00:52:34,600
Yes, we have to have results to our contents.

1228
00:52:34,800 --> 00:52:37,800
So, everywhere we were using result before you actually have result,

1229
00:52:37,800 --> 00:52:45,300
start contents, is the thing like this like that, like that.

1230
00:52:45,400 --> 00:52:47,700
And like this.

1231
00:52:47,900 --> 00:52:48,600
There we go.

1232
00:52:48,900 --> 00:52:49,900
Looking good.

1233
00:52:50,300 --> 00:52:52,900
And then, all we want to do here is basically assuming that we

1234
00:52:52,900 --> 00:52:56,500
actually if everything succeeded, we're going to set that content size

1235
00:52:56,900 --> 00:52:59,400
equal to the file size like that.

1236
00:53:01,600 --> 00:53:02,600
Let's take a look here.

1237
00:53:03,500 --> 00:53:11,000
So now we have to actually do this, debug read file result, file.

1238
00:53:11,300 --> 00:53:12,600
So we're going to read that in.

1239
00:53:12,700 --> 00:53:14,400
We've got file dot, contents.

1240
00:53:15,000 --> 00:53:16,900
We're assuming that's going to be true.

1241
00:53:17,300 --> 00:53:18,000
There we go.

1242
00:53:18,700 --> 00:53:22,300
Then we're going to go ahead and write that out file dot content, size

1243
00:53:22,300 --> 00:53:24,400
file, dot, contents like that.

1244
00:53:24,700 --> 00:53:27,700
And then we're going to free that memory.

1245
00:53:27,900 --> 00:53:28,500
There we go.

1246
00:53:28,900 --> 00:53:30,400
Yeah, so that's

1247
00:53:31,400 --> 00:53:32,100
That's it.

1248
00:53:32,700 --> 00:53:33,700
That's pretty good there.

1249
00:53:33,900 --> 00:53:35,300
Let's take a look at what happens?

1250
00:53:40,700 --> 00:53:43,600
Yeah, now and you'll notice.

1251
00:53:43,900 --> 00:53:47,000
So here's one of those things, if we had, if this would have been part

1252
00:53:47,000 --> 00:53:47,800
of our system.

1253
00:53:47,900 --> 00:53:50,400
Remember I was saying for debugging purposes.

1254
00:53:50,400 --> 00:53:52,900
It's nice to set that base of virtual a lock.

1255
00:53:53,000 --> 00:53:55,600
Well, that's exactly what would have been nicer because our memory

1256
00:53:55,600 --> 00:53:57,800
window would have been showing the right location already.

1257
00:53:58,400 --> 00:53:59,800
But since virtual apps and returned,

1258
00:54:00,000 --> 00:54:03,600
Things every time for when we don't specify the Base address it

1259
00:54:03,600 --> 00:54:03,900
wouldn't.

1260
00:54:03,900 --> 00:54:05,200
So that's the kind of thing that I sang for.

1261
00:54:05,200 --> 00:54:08,600
Our regular game code is nice to have that, you know, when you can get

1262
00:54:08,600 --> 00:54:11,000
it anyway, so here is our file.

1263
00:54:12,500 --> 00:54:17,000
Let's take a look at the contents to make sure they're correct.

1264
00:54:17,100 --> 00:54:17,200
There.

1265
00:54:17,200 --> 00:54:17,800
They are.

1266
00:54:17,900 --> 00:54:19,200
Now we're going to write to this file.

1267
00:54:19,200 --> 00:54:20,300
So let's step in there.

1268
00:54:20,600 --> 00:54:22,200
Let's see if we can open that file.

1269
00:54:22,300 --> 00:54:22,400
Now.

1270
00:54:22,400 --> 00:54:23,600
We should on the drive.

1271
00:54:24,100 --> 00:54:24,500
Actually.

1272
00:54:24,500 --> 00:54:25,500
Start to see it show up.

1273
00:54:25,500 --> 00:54:28,700
So if I go in here to the data directory, we should see it.

1274
00:54:28,700 --> 00:54:31,800
There it is, you know, it says zero size because it has not actually

1275
00:54:31,800 --> 00:54:32,900
finished the right to it.

1276
00:54:32,900 --> 00:54:36,400
Yet will do the right and I believe it'll still show zero size.

1277
00:54:36,500 --> 00:54:36,900
Yeah.

1278
00:54:37,200 --> 00:54:40,300
So basically the way that NTFS typically reports these things it'll

1279
00:54:40,300 --> 00:54:41,900
say zero size till it actually closes.

1280
00:54:42,100 --> 00:54:45,800
Handle, so you'll notice the B, the free B went down by the amount we

1281
00:54:45,800 --> 00:54:46,400
wrote.

1282
00:54:46,400 --> 00:54:50,100
So you can actually tell that it did the right but it stays 0.

1283
00:54:50,400 --> 00:54:52,200
Then we close that handle.

1284
00:54:52,700 --> 00:54:54,000
We now should see it.

1285
00:54:54,300 --> 00:54:55,300
Go to the sighs.

1286
00:54:55,300 --> 00:54:55,500
There.

1287
00:54:55,500 --> 00:54:57,600
It is and off we go.

1288
00:54:58,000 --> 00:55:00,500
So that's it for that off.

1289
00:55:00,500 --> 00:55:02,200
We go, we come in here.

1290
00:55:02,500 --> 00:55:07,900
We freed the memory and we end and now if it worked properly we should

1291
00:55:07,900 --> 00:55:09,000
see as well.

1292
00:55:09,300 --> 00:55:11,700
The fact that that file is the same file.

1293
00:55:11,700 --> 00:55:11,900
So if

1294
00:55:12,000 --> 00:55:15,000
If I go ahead and open it now, right, there it is.

1295
00:55:15,200 --> 00:55:16,900
And that's, that's what we wanted.

1296
00:55:17,100 --> 00:55:19,500
All right, so that's about it.

1297
00:55:19,900 --> 00:55:21,400
There isn't a lot else to it.

1298
00:55:22,300 --> 00:55:26,100
I don't think we actually need to save this test code anymore because

1299
00:55:26,400 --> 00:55:29,000
the problem is this, this path is hard coded here.

1300
00:55:29,300 --> 00:55:29,900
Right?

1301
00:55:30,200 --> 00:55:33,000
And we don't really want a hard-coded path in this thing.

1302
00:55:33,700 --> 00:55:35,200
That was just for testing purposes.

1303
00:55:35,700 --> 00:55:37,500
So unless we were actually going to start doing it.

1304
00:55:37,500 --> 00:55:39,200
I guess we could do, you know we could do.

1305
00:55:39,200 --> 00:55:41,900
We could just do that because the data directory,

1306
00:55:42,000 --> 00:55:45,200
Our startup directory anyway, so basically what we can do is say well,

1307
00:55:45,200 --> 00:55:47,100
alright in the solution Explorer.

1308
00:55:47,100 --> 00:55:48,100
We right-click on this thing.

1309
00:55:48,100 --> 00:55:50,800
We did properties and don't know if you remember I set this to the

1310
00:55:50,800 --> 00:55:54,100
data directory so that we wouldn't have to use absolute paths for

1311
00:55:54,100 --> 00:55:54,500
things.

1312
00:55:54,500 --> 00:55:58,000
So what I can do is I can just say test that out here and that'll

1313
00:55:58,000 --> 00:56:00,100
right to the data directory because that's that's it's just going to

1314
00:56:00,100 --> 00:56:01,300
look for that in the current directory.

1315
00:56:01,300 --> 00:56:02,500
Right?

1316
00:56:02,500 --> 00:56:07,600
So what I can do is something like this, then when I run it in theory

1317
00:56:07,600 --> 00:56:11,200
that should still write out that file and there it is.

1318
00:56:11,200 --> 00:56:12,000
So that's good.

1319
00:56:12,000 --> 00:56:13,400
Good, that that'll be.

1320
00:56:13,600 --> 00:56:16,100
That'll be good for now.

1321
00:56:16,500 --> 00:56:20,100
So I think that's it for file IO for the debug.

1322
00:56:25,800 --> 00:56:29,600
I don't think we'll need anything else to get ourselves up and running

1323
00:56:29,700 --> 00:56:31,000
because will base to be able to load.

1324
00:56:31,000 --> 00:56:34,100
Our bitmaps are sound files, that way and we'll go from there, and we

1325
00:56:34,100 --> 00:56:36,400
can write our state out using that.

1326
00:56:36,400 --> 00:56:40,100
It'll be pretty basic, but it should should sort of work.

1327
00:56:41,600 --> 00:56:41,700
Now.

1328
00:56:41,700 --> 00:56:46,700
I'm going to add some notes in here, basically, to the to, this this

1329
00:56:46,700 --> 00:56:50,200
part right here and basically say just to be clear.

1330
00:56:53,200 --> 00:56:57,000
Note Casey these in fact, you know what?

1331
00:56:57,000 --> 00:56:58,400
I might even do it this way.

1332
00:56:59,000 --> 00:56:59,800
I like a little

1333
00:57:00,000 --> 00:57:01,800
Important thing there.

1334
00:57:01,800 --> 00:57:03,500
Oh, I don't know, man.

1335
00:57:05,100 --> 00:57:06,800
That's that's going to have to get fixed.

1336
00:57:06,800 --> 00:57:10,000
So on my in the emacs file that I shipped out.

1337
00:57:10,000 --> 00:57:17,800
I guess I didn't include the the, oh, yeah, I didn't include important

1338
00:57:17,800 --> 00:57:18,600
and study.

1339
00:57:19,800 --> 00:57:23,300
So this is an old because this machine had an old index file.

1340
00:57:23,600 --> 00:57:25,100
I'm going to go ahead and do that right now.

1341
00:57:25,100 --> 00:57:28,100
In fact, just so you can see, I'm going to look up what my colors are

1342
00:57:28,100 --> 00:57:31,800
normally for them on my other machine because I this is relatively

1343
00:57:31,800 --> 00:57:32,600
important for me.

1344
00:57:33,500 --> 00:57:34,600
I like these a lot.

1345
00:57:34,900 --> 00:57:35,900
What I typically do.

1346
00:57:37,100 --> 00:57:40,300
Is in here in, this is just in the da TMX file.

1347
00:57:40,300 --> 00:57:42,400
So those of you who are not using body Max, don't have to worry about

1348
00:57:42,400 --> 00:57:42,600
this.

1349
00:57:42,600 --> 00:57:49,600
But what I typically do is I basically have a thing like this where I

1350
00:57:49,600 --> 00:57:55,600
Define some other keywords besides the besides the to do and the note,

1351
00:57:55,600 --> 00:57:56,700
which I already have to find.

1352
00:57:56,700 --> 00:58:00,800
I've got study and I've got an important and then basically what I do

1353
00:58:00,800 --> 00:58:03,300
is down here I've got

1354
00:58:04,100 --> 00:58:08,800
Study and important and then those are dark.

1355
00:58:08,800 --> 00:58:10,400
No, they're both yellow.

1356
00:58:10,400 --> 00:58:10,900
I guess.

1357
00:58:11,000 --> 00:58:11,600
Let's see.

1358
00:58:11,800 --> 00:58:15,800
So these are yellow and yellow.

1359
00:58:16,000 --> 00:58:16,300
All right.

1360
00:58:16,300 --> 00:58:16,800
There we go.

1361
00:58:17,500 --> 00:58:20,600
So, important notes are just ones that are like, you got to read them

1362
00:58:20,600 --> 00:58:22,900
and study is something that I want to look at later.

1363
00:58:23,200 --> 00:58:25,100
So I use those pretty typically.

1364
00:58:25,700 --> 00:58:27,600
That's that's that's relatively important.

1365
00:58:27,600 --> 00:58:30,900
Okay, so sorry about that little Excursion, but you got to have that.

1366
00:58:31,200 --> 00:58:33,900
These are not for doing

1367
00:58:34,100 --> 00:58:38,800
Anything in the shipping game?

1368
00:58:41,700 --> 00:58:50,400
The, they are blocking and the right doesn't protect against lost

1369
00:58:50,400 --> 00:58:52,000
data, right?

1370
00:58:52,300 --> 00:58:55,100
And basically, what I mean by that is when we do this, right, let's

1371
00:58:55,100 --> 00:58:57,700
say we were updating the person's unlocks.

1372
00:58:58,900 --> 00:59:01,900
The file on the drive where they save their unlocks.

1373
00:59:01,900 --> 00:59:03,900
And you know what, while I'm well I'm saying this discussion.

1374
00:59:03,900 --> 00:59:08,900
I'm going to go ahead and restart emacs there so that I can get my 0

1375
00:59:08,900 --> 00:59:09,600
or not.

1376
00:59:10,300 --> 00:59:10,700
Let's see.

1377
00:59:10,700 --> 00:59:12,200
There is the problem.

1378
00:59:12,700 --> 00:59:14,900
Died to find one of those one of those things wrong.

1379
00:59:15,000 --> 00:59:15,700
Oh, I did.

1380
00:59:15,800 --> 00:59:21,500
Yeah, man, I tell you, you cannot, you cannot trifle with Emax people.

1381
00:59:21,700 --> 00:59:23,000
You cannot try for with you, Max.

1382
00:59:23,000 --> 00:59:27,100
I'm like the worst emacs guy because I know nothing about emacs.

1383
00:59:27,100 --> 00:59:28,600
I only like pigeonhole.

1384
00:59:28,700 --> 00:59:31,400
I'll learn the basic thing.

1385
00:59:31,800 --> 00:59:37,300
I forgot that for some reason, emacs always wants you to do what's

1386
00:59:37,300 --> 00:59:38,100
going on here.

1387
00:59:38,300 --> 00:59:41,700
Always want you to do these defines first, man.

1388
00:59:41,700 --> 00:59:45,200
If you're emacs, doesn't if you're emacs file, is busted.

1389
00:59:45,200 --> 00:59:47,800
You're just in a world of hurt because none of your stuff works

1390
00:59:47,800 --> 00:59:48,300
anymore.

1391
00:59:48,800 --> 00:59:53,300
Okay, so make face font lock, can't even see that.

1392
00:59:53,300 --> 00:59:53,900
There we go.

1393
00:59:53,900 --> 00:59:57,200
Make face font lock study face.

1394
00:59:57,500 --> 00:59:58,500
And make

1395
00:59:58,700 --> 00:59:59,800
Bass song.

1396
01:00:00,100 --> 01:00:02,100
Glock important face.

1397
01:00:02,100 --> 01:00:02,600
There we go.

1398
01:00:02,600 --> 01:00:03,400
Forgot those.

1399
01:00:03,800 --> 01:00:04,200
Okay.

1400
01:00:04,600 --> 01:00:05,100
There we go.

1401
01:00:05,500 --> 01:00:07,000
Now we should be back in business.

1402
01:00:07,800 --> 01:00:11,400
Hopefully anyways, let's take a look.

1403
01:00:11,400 --> 01:00:11,700
Now.

1404
01:00:12,000 --> 01:00:14,300
Does that work properly and made, uh,

1405
01:00:16,200 --> 01:00:17,500
Where's my important?

1406
01:00:18,400 --> 01:00:18,600
There?

1407
01:00:18,600 --> 01:00:19,000
It is.

1408
01:00:20,600 --> 01:00:22,800
So I like having that just so it kind of sticks out a little bit.

1409
01:00:23,400 --> 01:00:26,200
Basically, what I was talking about here before we go to the Q&A.

1410
01:00:26,800 --> 01:00:31,800
What I was talking about is when you write to a critical file, so

1411
01:00:31,800 --> 01:00:37,100
let's say you've got the, the unlocks on the, on the user's machine.

1412
01:00:37,300 --> 01:00:39,100
Like what stuff they've unlocked in the game.

1413
01:00:40,400 --> 01:00:43,300
You typically don't just want to overwrite the old file.

1414
01:00:43,500 --> 01:00:47,000
And the reason for that is your overwrite could fail and only

1415
01:00:47,000 --> 01:00:47,800
partially overwrite.

1416
01:00:47,800 --> 01:00:50,300
The file leaving them with a corrupted save file.

1417
01:00:50,600 --> 01:00:51,500
So what you want to do?

1418
01:00:51,500 --> 01:00:56,300
Instead usually is right to a different file and either have a rolling

1419
01:00:56,300 --> 01:00:56,900
buffer scheme.

1420
01:00:56,900 --> 01:01:00,700
So basically you have like an A and A B file and you write to the be

1421
01:01:00,700 --> 01:01:01,100
file.

1422
01:01:01,100 --> 01:01:02,200
Then you write to the a file.

1423
01:01:02,200 --> 01:01:06,600
Then you write to the B file on alternating runs of the game so that

1424
01:01:06,600 --> 01:01:09,700
and you load whatever one is most recent or

1425
01:01:09,900 --> 01:01:13,500
You write to a secondary temp file, delete the old file, and then

1426
01:01:13,500 --> 01:01:15,100
rename the file into place.

1427
01:01:15,200 --> 01:01:18,000
So that at least, you know, that it's the renamed would have to fail,

1428
01:01:18,000 --> 01:01:20,700
but you're not going to run out of space on the drive and fail or

1429
01:01:20,700 --> 01:01:21,400
stuff like that.

1430
01:01:21,900 --> 01:01:27,000
So we want to, when we actually do the stuff that writes to the save

1431
01:01:27,000 --> 01:01:27,800
game file.

1432
01:01:28,000 --> 01:01:30,400
We're going to want to do something much more protected than this.

1433
01:01:31,200 --> 01:01:32,100
I hate when games.

1434
01:01:32,100 --> 01:01:35,700
Don't do safe ways of saving stuff and then lose your saved game or

1435
01:01:35,700 --> 01:01:36,200
something like that.

1436
01:01:36,200 --> 01:01:36,900
I hate that.

1437
01:01:37,100 --> 01:01:39,400
So we're, you know, we're gonna make sure we don't do that.

1438
01:01:39,800 --> 01:01:44,100
So anyway, I think that's everything for file IO that we wanted to do.

1439
01:01:44,100 --> 01:01:45,300
I don't think there's anything else.

1440
01:01:45,600 --> 01:01:48,500
So, next week, we should be in good shape to, just go through clean

1441
01:01:48,500 --> 01:01:49,200
things up.

1442
01:01:49,500 --> 01:01:52,900
Basically are clocking values, need to be cleaned up and then let's

1443
01:01:52,900 --> 01:01:56,400
look at some to dues keyboard input should be piped through.

1444
01:01:56,700 --> 01:01:58,400
So we're basically, we already get the keyboard input.

1445
01:01:58,400 --> 01:02:00,300
We don't pipe it through our input system.

1446
01:02:00,700 --> 01:02:03,400
So, basically next week, just cleaning up everything that that we

1447
01:02:03,400 --> 01:02:07,000
hadn't actually just finished and then we should be good to go.

1448
01:02:07,100 --> 01:02:09,700
We are basically at a place where we've got all the

1449
01:02:09,900 --> 01:02:14,800
Line stuff for the for the game, to actually start to exist which is

1450
01:02:14,800 --> 01:02:15,600
pretty darn cool.

1451
01:02:15,600 --> 01:02:21,400
So with that, let's go to the Q&A and see if anyone has questions

1452
01:02:21,800 --> 01:02:22,700
about what was covered.

1453
01:02:22,700 --> 01:02:26,800
Please make sure that your question has senior at, Orion it so that I

1454
01:02:26,800 --> 01:02:27,500
will see it.

1455
01:02:27,700 --> 01:02:29,700
And also, please keep questions to stuff.

1456
01:02:29,700 --> 01:02:32,900
We have implemented today or in a previous day.

1457
01:02:33,800 --> 01:02:36,800
No questions about what we're going to implement because we're going

1458
01:02:36,800 --> 01:02:38,300
to get to those when we Implement them.

1459
01:02:41,100 --> 01:02:42,200
Let's see.

1460
01:02:55,600 --> 01:02:58,800
Will the game be able to carry on in spite of some big-time failure

1461
01:02:58,800 --> 01:02:59,700
like a graphics?

1462
01:03:00,000 --> 01:03:03,200
This reset and a software rendering make that easier to deal with.

1463
01:03:03,800 --> 01:03:06,600
Yes, the fact that we have set up a software renderer does mean that's

1464
01:03:06,600 --> 01:03:07,400
easier to deal with.

1465
01:03:07,400 --> 01:03:11,200
But in general with files and GPU and all that stuff.

1466
01:03:11,200 --> 01:03:17,800
We will try for the most part to make it so that and that we ride over

1467
01:03:17,800 --> 01:03:22,300
transient failures as much as possible, you know, if there's stuff

1468
01:03:22,300 --> 01:03:24,700
that we literally can't recover from then, obviously not.

1469
01:03:24,700 --> 01:03:27,300
But, you know, we'll try to be relatively good about that.

1470
01:03:27,300 --> 01:03:29,800
And that's one of the reasons I say that these are debug

1471
01:03:30,000 --> 01:03:33,600
Only because these these aren't these are set up for Success a little

1472
01:03:33,600 --> 01:03:34,100
bit.

1473
01:03:34,900 --> 01:03:37,900
In the sense that if this fails, you just get one failure and you can

1474
01:03:37,900 --> 01:03:38,600
handle it pretty easily.

1475
01:03:38,600 --> 01:03:42,000
So these are better than the average in terms of apis for that.

1476
01:03:42,000 --> 01:03:43,200
But we're going to try to make them.

1477
01:03:43,500 --> 01:03:46,000
I'll show you what we're going to do.

1478
01:03:46,000 --> 01:03:48,500
We'll be doing some stuff that really does handle stuff pretty well.

1479
01:03:48,500 --> 01:03:51,600
So that basically if you yanked let's say this was what running off a

1480
01:03:51,600 --> 01:03:53,800
USB to USB drive and you yanked it.

1481
01:03:53,900 --> 01:03:55,300
The game was still run, just fine.

1482
01:03:55,800 --> 01:03:57,100
Only you wouldn't be any time.

1483
01:03:57,100 --> 01:03:58,700
There was sort of been something new.

1484
01:03:59,000 --> 01:03:59,800
You'll just see like a

1485
01:04:00,000 --> 01:04:04,000
Think error bitmap or something, but then when you jam that USB drive

1486
01:04:04,000 --> 01:04:05,600
back in, it would start working again.

1487
01:04:06,000 --> 01:04:07,000
We'll try to make things work.

1488
01:04:07,000 --> 01:04:07,800
Roughly that way.

1489
01:04:07,900 --> 01:04:11,500
No other games ever work like that, like, nobody writes stuff at that

1490
01:04:11,500 --> 01:04:11,700
safe.

1491
01:04:11,700 --> 01:04:15,400
Pretty much, but we will because again, this is for educational

1492
01:04:15,400 --> 01:04:17,500
purposes and we should show how to do stuff, right?

1493
01:04:17,500 --> 01:04:19,700
Instead of just doing the minimum necessary to ship.

1494
01:04:28,400 --> 01:04:31,300
Would it make sense to call normal file size and assert, that the high

1495
01:04:31,300 --> 01:04:32,900
32 bit value is 0.

1496
01:04:34,100 --> 01:04:38,300
Yes, and no, I think that actually technically misses one case.

1497
01:04:38,500 --> 01:04:44,800
So basically, if you look in here, if the loops is not read file, file

1498
01:04:44,800 --> 01:04:46,800
size, yet file size.

1499
01:04:47,300 --> 01:04:50,400
I think there's it's a little janky or even than you think it is.

1500
01:04:50,400 --> 01:04:55,000
Because if you go read this, if the function fails

1501
01:04:56,700 --> 01:05:00,400
The return value is invalid, file size and invalid, file size.

1502
01:05:00,400 --> 01:05:05,000
I think is actually 0 x FF FF FF FF, which means that if you had a

1503
01:05:05,000 --> 01:05:08,400
file that was exactly the largest.

1504
01:05:08,400 --> 01:05:11,400
You could have a 32-bit file, get file size.

1505
01:05:11,400 --> 01:05:12,700
Looks like it just failed.

1506
01:05:13,000 --> 01:05:13,600
Right?

1507
01:05:15,100 --> 01:05:19,000
So like it says, right here, when file size is null, the results

1508
01:05:19,000 --> 01:05:21,500
returned for large file sizes, and you will not be able to run the

1509
01:05:21,500 --> 01:05:24,200
actual file size determined by get file size.

1510
01:05:24,200 --> 01:05:24,800
Eax.

1511
01:05:25,300 --> 01:05:28,800
If the function fails, and it's non null and you got to use the get

1512
01:05:28,800 --> 01:05:32,000
last error, so, basically, you'd have to call get last error to

1513
01:05:32,000 --> 01:05:37,300
determine whether the file size was actually 0xffff, and I don't want

1514
01:05:37,300 --> 01:05:37,800
to do any of that.

1515
01:05:37,800 --> 01:05:41,400
So it's just even if you're only doing 32-bit files, reads, you want

1516
01:05:41,400 --> 01:05:43,200
to call this, I think.

1517
01:05:44,900 --> 01:05:47,800
Just let you handle one more case without doing any actual work doing.

1518
01:05:47,800 --> 01:05:49,400
Less work handle, one more case.

1519
01:05:49,400 --> 01:05:50,700
That's just all good, right?

1520
01:05:53,400 --> 01:05:54,200
Let's see here.

1521
01:05:54,200 --> 01:05:54,900
Where are we?

1522
01:06:00,000 --> 01:06:02,300
It'd be useful for us to write our own allocation functions

1523
01:06:02,300 --> 01:06:05,100
specifically allocate sections of our earlier already, reserved

1524
01:06:05,100 --> 01:06:06,200
temporary mayor, memory.

1525
01:06:06,400 --> 01:06:08,400
I'm having trouble understanding why we were doing separate

1526
01:06:08,400 --> 01:06:09,500
allocations.

1527
01:06:11,000 --> 01:06:14,400
Well, so, the reason is because this is only debug code.

1528
01:06:14,400 --> 01:06:17,200
So there's no point in writing an alligator to handle it because we

1529
01:06:17,200 --> 01:06:18,500
wouldn't shift that allocator.

1530
01:06:19,100 --> 01:06:21,300
This is only allowed to be in the internal build.

1531
01:06:21,500 --> 01:06:25,900
So you would literally just be wasting your time if you went, and

1532
01:06:25,900 --> 01:06:29,600
wrote an alligator that allocates out of your temporary memory because

1533
01:06:30,000 --> 01:06:34,300
It's not going to ship, never write code that you don't intend to

1534
01:06:34,300 --> 01:06:34,900
ship.

1535
01:06:35,000 --> 01:06:38,100
If it doesn't do anything that helps you in debug mode.

1536
01:06:38,200 --> 01:06:39,100
So calling virtual.

1537
01:06:39,100 --> 01:06:40,600
Alec is free for us in debug mode.

1538
01:06:40,600 --> 01:06:44,200
So it's there's really no reason why you would do what you're

1539
01:06:44,200 --> 01:06:44,900
suggesting.

1540
01:06:44,900 --> 01:06:49,300
It's strictly would just waste you time and get you no benefit.

1541
01:06:49,300 --> 01:06:50,600
So you don't want to do that.

1542
01:06:51,000 --> 01:06:53,700
We will be sub allocating out of our temporary memory for all the

1543
01:06:53,700 --> 01:06:54,700
stuff we do in the game.

1544
01:06:54,700 --> 01:06:58,500
That's actually stuff, you know, all the stuff that we do starting

1545
01:06:58,500 --> 01:06:59,800
right after we finish our clean up next.

1546
01:07:00,700 --> 01:07:02,800
all the stuff we do from then on will be some allocated out of the

1547
01:07:02,800 --> 01:07:07,500
game memory, but that yeah, you really you really don't want to waste

1548
01:07:07,500 --> 01:07:08,400
your time like

1549
01:07:09,600 --> 01:07:12,300
I know it seems like I'm doing things that could be considered by some

1550
01:07:12,300 --> 01:07:13,000
people to waste time.

1551
01:07:13,000 --> 01:07:15,400
Like why are you just letting the system do all your allocation for

1552
01:07:15,400 --> 01:07:16,200
you and stuff like that.

1553
01:07:16,200 --> 01:07:18,200
I actually am getting benefits out of this, right?

1554
01:07:18,200 --> 01:07:19,400
I'm getting fault tolerance.

1555
01:07:19,400 --> 01:07:22,100
I'm getting a knowledge of exactly the footprint so we can, we will be

1556
01:07:22,100 --> 01:07:22,700
Port.

1557
01:07:22,800 --> 01:07:24,000
We can Port it easily.

1558
01:07:24,400 --> 01:07:27,500
We're actually getting a lot of efficiency because we don't have to

1559
01:07:27,500 --> 01:07:30,800
worry about making our allocator be performant because we won't have

1560
01:07:30,800 --> 01:07:31,100
one.

1561
01:07:31,200 --> 01:07:33,600
So there's actually a lot of benefits to the things that I'm doing in

1562
01:07:33,600 --> 01:07:34,100
my mind.

1563
01:07:34,100 --> 01:07:34,600
Anyway,

1564
01:07:35,400 --> 01:07:39,200
But I don't just waste time like I won't just go right in allocator

1565
01:07:39,200 --> 01:07:40,200
just to write one.

1566
01:07:40,400 --> 01:07:42,000
That's not something I would do.

1567
01:07:42,200 --> 01:07:44,900
I only write an alligator if I actually am gonna get some utility out

1568
01:07:44,900 --> 01:07:45,300
of it.

1569
01:07:45,600 --> 01:07:48,500
So that's why we're not doing that is because there'd be absolutely no

1570
01:07:48,500 --> 01:07:49,500
use to doing it.

1571
01:07:52,900 --> 01:07:58,000
Let's see when we Implement some kind of cloud storage for the rights.

1572
01:07:58,600 --> 01:07:59,100
So.

1573
01:08:00,400 --> 01:08:05,000
Probably not because as far as I know, the only circumstance where we

1574
01:08:05,000 --> 01:08:08,100
would have access to cloud storage is steam, which I think, does the

1575
01:08:08,100 --> 01:08:09,500
cloud storage for us.

1576
01:08:09,500 --> 01:08:15,300
So if we release the game on Steam, then we could call their API for

1577
01:08:15,300 --> 01:08:15,800
doing that.

1578
01:08:15,800 --> 01:08:19,200
Certainly, but we don't have a cloud.

1579
01:08:19,700 --> 01:08:20,899
Like, we don't have a server.

1580
01:08:21,300 --> 01:08:25,000
So, there's no way we can really Implement cloud storage for our

1581
01:08:25,000 --> 01:08:25,500
stuff.

1582
01:08:28,100 --> 01:08:30,899
You know, if we do steam integration of some point, which would

1583
01:08:31,200 --> 01:08:34,399
require valve to give us steam approval or something.

1584
01:08:35,300 --> 01:08:38,800
Then we could, we could use like the cloud storage that they

1585
01:08:38,800 --> 01:08:41,000
implement, but then we won't really be implementing it, right?

1586
01:08:41,000 --> 01:08:42,000
They implemented it.

1587
01:08:42,800 --> 01:08:45,100
So, yeah, so there's really not much we can do with cloud storage.

1588
01:08:50,000 --> 01:08:51,100
Let's see here.

1589
01:08:55,899 --> 01:08:57,899
I know you removed it for now.

1590
01:08:58,600 --> 01:08:59,800
I'm not sure what you mean by it.

1591
01:09:00,000 --> 01:09:02,700
That sentence but I know you removed it for now, but wouldn't a

1592
01:09:02,700 --> 01:09:06,300
reserved memory method with an arbitrary file size.

1593
01:09:06,600 --> 01:09:08,700
Still introduce a failure Point.

1594
01:09:08,700 --> 01:09:12,000
Since it could fail like virtual Alec and we have simply moved the

1595
01:09:12,000 --> 01:09:14,200
memory, allocation burden onto ourselves.

1596
01:09:14,700 --> 01:09:18,700
I'm not sure what you mean like I was saying before, this is never

1597
01:09:18,700 --> 01:09:22,600
going to be called in the game when you actually ship it.

1598
01:09:22,700 --> 01:09:27,300
So these can fail, but we're never going to actually call them in the

1599
01:09:27,300 --> 01:09:27,500
game.

1600
01:09:27,500 --> 01:09:29,899
These are strictly for our own debugging purposes.

1601
01:09:30,000 --> 01:09:34,600
Has and like when we write asset processing code will use these

1602
01:09:34,700 --> 01:09:38,200
because we don't care the asset processing only happens on our machine

1603
01:09:38,200 --> 01:09:39,600
and we know when it failed.

1604
01:09:39,899 --> 01:09:42,399
So so basically, these are not to be shipped.

1605
01:09:42,399 --> 01:09:42,899
So I'm not sure.

1606
01:09:42,899 --> 01:09:44,100
I understand the question.

1607
01:09:46,000 --> 01:09:48,000
Could you go over the difference between transient and permanent

1608
01:09:48,000 --> 01:09:48,300
storage?

1609
01:09:48,300 --> 01:09:48,600
Again?

1610
01:09:48,600 --> 01:09:52,700
It's hard for me to see what kinds of memory will be used for each.

1611
01:09:52,700 --> 01:09:54,800
So, we covered that in yesterday's Q&A.

1612
01:09:55,800 --> 01:10:01,300
If you missed it, you can reload your emacs eggs without blowing

1613
01:10:01,300 --> 01:10:01,800
everything up.

1614
01:10:01,800 --> 01:10:03,100
Each time with eval buffer.

1615
01:10:03,100 --> 01:10:07,300
Can you like so you I know about eval buffer and sometimes that works.

1616
01:10:07,300 --> 01:10:11,000
But for font lock, you have to do a bunch of stuff to make that work.

1617
01:10:12,200 --> 01:10:13,300
If I remember correctly.

1618
01:10:13,500 --> 01:10:15,200
You have to turn off Van.

1619
01:10:15,400 --> 01:10:18,400
Lock, re-evaluate the buffer reload fought, like, there's like, a

1620
01:10:18,400 --> 01:10:19,000
bunch of steps.

1621
01:10:19,000 --> 01:10:21,300
So I just usually restart emacs instead of trying to remember what

1622
01:10:21,300 --> 01:10:23,400
they all are four simple things.

1623
01:10:23,400 --> 01:10:26,000
I'll use eval buffer, if it's just like adding something I'll use it,

1624
01:10:26,000 --> 01:10:26,900
but I don't think you can use it.

1625
01:10:26,900 --> 01:10:30,200
In this case, you have to do a bunch of steps in addition to eval

1626
01:10:30,200 --> 01:10:32,100
buffer and I don't remember what they all are.

1627
01:10:35,600 --> 01:10:36,700
Let's see.

1628
01:10:38,400 --> 01:10:39,500
What are you drinking?

1629
01:10:40,200 --> 01:10:40,900
I am drinking.

1630
01:10:40,900 --> 01:10:44,100
Almond milk spiked with coffee this morning because it's my morning

1631
01:10:44,100 --> 01:10:44,500
coffee.

1632
01:10:44,500 --> 01:10:47,300
So I just put instant coffee in the almond milk.

1633
01:10:48,100 --> 01:10:49,000
It's like coffee milk.

1634
01:10:52,000 --> 01:10:53,000
Let's see.

1635
01:10:54,900 --> 01:10:56,900
Are there any other benefits to doing one?

1636
01:10:56,900 --> 01:11:00,000
Massive allocation aside from having one failure point also does the

1637
01:11:00,000 --> 01:11:02,900
order of properties in your structs matter when it comes to

1638
01:11:02,900 --> 01:11:04,100
Performance efficiency?

1639
01:11:05,300 --> 01:11:08,100
Yes, and yes, the other benefits of doing one.

1640
01:11:08,100 --> 01:11:08,400
Massive.

1641
01:11:08,400 --> 01:11:11,800
Allocation is like I said during debugging, we can have a stable base

1642
01:11:11,800 --> 01:11:14,000
point for our allocations.

1643
01:11:14,100 --> 01:11:15,400
So that's pretty handy.

1644
01:11:16,600 --> 01:11:19,200
You the only other way you get that is by doing a bunch of work to

1645
01:11:19,200 --> 01:11:21,000
turn off Windows address randomization.

1646
01:11:21,000 --> 01:11:22,700
So that's a pretty big benefit.

1647
01:11:23,100 --> 01:11:23,800
There's other things.

1648
01:11:24,000 --> 01:11:28,400
To do later in development that allow it to be like there's a lot of

1649
01:11:28,400 --> 01:11:28,900
fringe benefits.

1650
01:11:28,900 --> 01:11:31,500
You'll see as we go that we're constantly taking advantage of the fact

1651
01:11:31,500 --> 01:11:33,700
that we just have one big allocation.

1652
01:11:34,300 --> 01:11:37,600
So yeah, there's a lot of them the order of properties in the structs

1653
01:11:37,600 --> 01:11:39,700
does matter when it comes to Performance and efficiency.

1654
01:11:40,900 --> 01:11:45,700
I'm not really the right guy to tell you what they all are, because

1655
01:11:45,700 --> 01:11:48,900
I'm not enough of an optimization head to know these days, exactly

1656
01:11:48,900 --> 01:11:49,500
what they all are.

1657
01:11:49,500 --> 01:11:52,800
But just to give you a trivial example, let's say you had a lot of a

1658
01:11:52,800 --> 01:11:53,300
struct.

1659
01:11:54,800 --> 01:11:55,400
Right.

1660
01:11:55,900 --> 01:11:58,400
Let's say you had a lot of struct and you did something like this.

1661
01:12:04,100 --> 01:12:04,700
Right.

1662
01:12:04,700 --> 01:12:09,200
Let's say you type that in and you had 10,000 of these.

1663
01:12:09,600 --> 01:12:15,700
Well, this actually because of the way that sees packing works.

1664
01:12:16,000 --> 01:12:20,800
This will actually cause this to bloat out quite a bit more than if it

1665
01:12:20,800 --> 01:12:22,500
was done like this, right?

1666
01:12:23,200 --> 01:12:25,600
Let's say I've got something like this here, right?

1667
01:12:27,000 --> 01:12:28,200
This is a better example.

1668
01:12:35,200 --> 01:12:35,600
Okay.

1669
01:12:36,800 --> 01:12:38,000
This is my fake struck.

1670
01:12:38,500 --> 01:12:39,000
There we go.

1671
01:12:39,400 --> 01:12:40,400
Let's compile that.

1672
01:12:41,000 --> 01:12:43,900
So basically here is just a trivial example.

1673
01:12:44,100 --> 01:12:47,200
And like I said, I'm not the guy to give you the rundown on this, you

1674
01:12:47,200 --> 01:12:50,200
want an optimization head, someone who studies it all the time and

1675
01:12:50,200 --> 01:12:53,200
especially on Modern machines, but I'm going to give you example of

1676
01:12:53,200 --> 01:12:54,500
the sorts of things that could happen.

1677
01:12:55,100 --> 01:12:58,100
So let's take a look at the size of fake struct here and well I can't

1678
01:12:58,100 --> 01:12:59,300
because I don't actually have one.

1679
01:12:59,600 --> 01:13:03,500
So let's make sure that I actually get one so that I can I can

1680
01:13:03,500 --> 01:13:04,900
actually make that.

1681
01:13:05,100 --> 01:13:07,100
Happened in 32 handmade.

1682
01:13:07,300 --> 01:13:12,300
So let's go into wind Main and just go ahead and say fake struct a

1683
01:13:13,500 --> 01:13:15,900
this fake struck BB.

1684
01:13:15,900 --> 01:13:17,400
And I'm going to do this.

1685
01:13:20,600 --> 01:13:21,400
All right.

1686
01:13:23,400 --> 01:13:26,900
And let's step into that and take a look.

1687
01:13:27,000 --> 01:13:34,300
I'm going to ask for the size of a and the size of B.

1688
01:13:35,300 --> 01:13:37,500
What what is the problem here?

1689
01:13:37,500 --> 01:13:38,300
What's going on?

1690
01:13:38,600 --> 01:13:42,100
Why am I not able to actually a, we compiling an optimization with

1691
01:13:42,100 --> 01:13:43,500
optimizations on or something.

1692
01:13:44,000 --> 01:13:44,500
Did I?

1693
01:13:45,500 --> 01:13:47,000
Did I forget to turn that off?

1694
01:13:48,400 --> 01:13:48,800
Know.

1695
01:13:49,100 --> 01:13:50,200
Why can I not?

1696
01:13:51,600 --> 01:13:55,700
Why can I not expect our inspect my stuff?

1697
01:13:57,000 --> 01:13:57,900
What's going on here?

1698
01:13:59,100 --> 01:14:00,900
What's going on here people?

1699
01:14:07,700 --> 01:14:09,100
Felt like the op is should not be.

1700
01:14:09,100 --> 01:14:11,700
Maybe I had to turn would have to turn all optimizations offer that.

1701
01:14:11,700 --> 01:14:11,800
Okay.

1702
01:14:11,800 --> 01:14:12,400
There we go.

1703
01:14:13,100 --> 01:14:15,500
Well, yeah, it was just optimizing those out.

1704
01:14:16,100 --> 01:14:18,900
So I guess we don't have our optimizations fully disabled which is too

1705
01:14:18,900 --> 01:14:19,200
bad.

1706
01:14:19,200 --> 01:14:22,300
But oh well, alright.

1707
01:14:22,500 --> 01:14:27,000
So what I wanted to show you here if I can manage to not cough.

1708
01:14:27,000 --> 01:14:30,100
The death first is basically inside my hand.

1709
01:14:30,100 --> 01:14:32,200
May .h I Define two different structs.

1710
01:14:32,600 --> 01:14:37,200
They have exactly the same members XYZ and UV and basically, you can

1711
01:14:37,200 --> 01:14:37,500
see that

1712
01:14:37,600 --> 01:14:38,700
They have exact same types.

1713
01:14:38,700 --> 01:14:41,100
The why is 32 bit and everything else is 8-bit.

1714
01:14:41,100 --> 01:14:42,300
Same exact straps.

1715
01:14:42,600 --> 01:14:45,500
Let's say, I've got 10,000 of these, right?

1716
01:14:45,800 --> 01:14:50,100
Well, if you take a look at the sizes, you will note that a is 12 B,

1717
01:14:50,100 --> 01:14:51,500
and B is only eight.

1718
01:14:52,700 --> 01:14:56,800
So basically you have wasted four, bytes of memory per structure by

1719
01:14:56,800 --> 01:14:59,800
going with this ordering as opposed to this order.

1720
01:15:00,500 --> 01:15:02,700
No other difference between them whatsoever.

1721
01:15:02,700 --> 01:15:05,700
In terms of when you are using them, yet.

1722
01:15:05,700 --> 01:15:09,700
You've basically caused yourself a massive amount of memory blow

1723
01:15:09,700 --> 01:15:11,300
potentially 4, bytes per.

1724
01:15:11,600 --> 01:15:13,600
So, however, many you had 100,000 of them.

1725
01:15:13,600 --> 01:15:14,700
It will see you at 100,000 them.

1726
01:15:14,700 --> 01:15:18,800
You would be wasting four hundred thousand bytes and don't really you

1727
01:15:18,800 --> 01:15:20,900
don't have to care too much about the memory because memory is cheap.

1728
01:15:20,900 --> 01:15:25,400
Oftentimes, but performance is not and reading all that extra memory

1729
01:15:25,400 --> 01:15:28,300
in all that cash pollution is going to cost you.

1730
01:15:28,300 --> 01:15:29,800
So yes, the order matters.

1731
01:15:30,000 --> 01:15:33,300
It's because how see, decides to pad things out matters and you got to

1732
01:15:33,300 --> 01:15:35,400
make sure that you pack your things in properly.

1733
01:15:35,600 --> 01:15:40,400
So that's just one example of how it could be a real problem for you.

1734
01:15:40,400 --> 01:15:41,100
In practice.

1735
01:15:41,100 --> 01:15:42,300
Not just theoretical one.

1736
01:15:42,700 --> 01:15:46,300
So the order does matter, I'm just Nest not decided the guy to tell

1737
01:15:46,300 --> 01:15:49,800
you exactly everything about that that you might want to know, but it

1738
01:15:49,800 --> 01:15:50,600
definitely matters.

1739
01:15:58,800 --> 01:16:03,200
You mentioned, wait, two games, really usually?

1740
01:16:03,200 --> 01:16:05,800
Right to a second file rather than using some sort of safe, right?

1741
01:16:05,800 --> 01:16:06,100
Function.

1742
01:16:06,100 --> 01:16:08,200
That won't overwrite it if it's somehow fails.

1743
01:16:10,100 --> 01:16:13,600
So, no games don't usually.

1744
01:16:13,600 --> 01:16:16,400
And that's why they often mess up your saved games and stuff like

1745
01:16:16,400 --> 01:16:16,800
that.

1746
01:16:18,600 --> 01:16:20,600
There is no such thing as a safe, right function.

1747
01:16:22,400 --> 01:16:28,100
I mean, well, there are transacted write functions that in theory

1748
01:16:28,100 --> 01:16:32,100
would be okay, but no, oftentimes games just full-on do lots of tiny

1749
01:16:32,100 --> 01:16:33,400
rights to the save file.

1750
01:16:33,500 --> 01:16:36,800
And if one of them start fails or something hat or Runs Out of Space,

1751
01:16:37,600 --> 01:16:40,200
right at the time when it was about to try and write the last bit of

1752
01:16:40,200 --> 01:16:43,000
that file in it just flat-out corrupts your stuff.

1753
01:16:43,700 --> 01:16:47,700
Or if the game crashes, this is another one if the game crashes right

1754
01:16:47,700 --> 01:16:48,300
in the middle of

1755
01:16:48,400 --> 01:16:52,500
To save file, which happens then you've lost the whole save file

1756
01:16:52,600 --> 01:16:54,500
because it's just corrupted and you're done.

1757
01:16:54,800 --> 01:16:56,800
So games, don't normally do that.

1758
01:16:56,800 --> 01:16:59,400
They should every game should do hundred percent.

1759
01:16:59,400 --> 01:17:03,600
Safe writing, if they can, the way I will probably do it in this game

1760
01:17:03,600 --> 01:17:07,300
as will write to a secondary file will write, basically rolling

1761
01:17:07,300 --> 01:17:07,900
buffer.

1762
01:17:08,500 --> 01:17:11,100
So we'll say, like, let's say we got 16, save files and will just

1763
01:17:11,100 --> 01:17:13,900
write to them sequentially and then wrap and then we'll just look at

1764
01:17:13,900 --> 01:17:15,900
whichever ones, latest and load that that way.

1765
01:17:15,900 --> 01:17:18,200
No matter what happens, even if there's random

1766
01:17:18,400 --> 01:17:22,000
ins will always at least make sure we can roll back to a previous save

1767
01:17:22,100 --> 01:17:24,300
and not lose everything that the user tried to do.

1768
01:17:27,900 --> 01:17:28,700
Let's see.

1769
01:17:31,700 --> 01:17:34,000
Do you miss multiple return values and see for the moments when you

1770
01:17:34,000 --> 01:17:35,700
have great C hat?

1771
01:17:35,700 --> 01:17:38,200
Seek allows you to have multiple turned as far as I know.

1772
01:17:41,900 --> 01:17:45,600
Oh, you're saying, I see you're saying, do I miss being not be able to

1773
01:17:45,600 --> 01:17:47,700
do like tuples just in line.

1774
01:17:47,800 --> 01:17:48,700
It don't like.

1775
01:17:48,700 --> 01:17:48,900
Okay.

1776
01:17:48,900 --> 01:17:53,300
So I think that I think he's asking do I do I miss not being able to

1777
01:17:53,300 --> 01:17:57,500
just have a quick way to just say this returns to things, you know,

1778
01:17:57,500 --> 01:17:59,700
like like like this, right?

1779
01:18:00,300 --> 01:18:02,900
Put the two things in here, instead of having to actually device

1780
01:18:02,900 --> 01:18:03,300
truck.

1781
01:18:03,800 --> 01:18:04,500
Not really.

1782
01:18:04,600 --> 01:18:05,900
It doesn't bother me to type this.

1783
01:18:05,900 --> 01:18:09,100
Yeah, it could be a little shorter, but it's fine.

1784
01:18:09,200 --> 01:18:15,000
I mean, would I prefer it if it looked just, you know, just like this,

1785
01:18:16,900 --> 01:18:18,400
you know, something like that.

1786
01:18:18,400 --> 01:18:22,000
What I prefer that probably, but it's not really that much typing.

1787
01:18:22,000 --> 01:18:24,300
It's one extra thing struck blah.

1788
01:18:24,400 --> 01:18:27,100
So, you know really care, does it really matter?

1789
01:18:30,700 --> 01:18:33,400
Why don't we just map the file into memory?

1790
01:18:34,100 --> 01:18:36,400
I mentioned that and the reason is because I didn't want to

1791
01:18:36,400 --> 01:18:38,600
overcomplicate things because this is only for debug.

1792
01:18:38,600 --> 01:18:42,000
So the only reason to just do them to the to do the memory map would

1793
01:18:42,000 --> 01:18:45,100
be if you were concerned about whether Windows could get performance

1794
01:18:45,100 --> 01:18:48,300
out of using the backing store and stuff like that, but I don't care

1795
01:18:48,300 --> 01:18:49,300
about any of that.

1796
01:18:49,500 --> 01:18:50,700
This is just the debug read.

1797
01:18:50,700 --> 01:18:53,600
So memory mapping the file just introduced as a bunch of complexity

1798
01:18:53,600 --> 01:18:56,000
for no reason, so that's why we didn't do that.

1799
01:18:58,200 --> 01:18:59,600
Let's see.

1800
01:19:01,800 --> 01:19:04,300
During one of the earlier cast, you mentioned that you're not a fan of

1801
01:19:04,300 --> 01:19:05,400
high-level languages.

1802
01:19:08,400 --> 01:19:10,000
Well, I'd rather not tackle that now.

1803
01:19:10,000 --> 01:19:12,000
That's probably a pre stream question because it's not really about

1804
01:19:12,000 --> 01:19:12,900
what we were working on.

1805
01:19:14,100 --> 01:19:15,100
Let's see.

1806
01:19:19,400 --> 01:19:21,900
Will allocating a single amount of memory upfront, make it more

1807
01:19:21,900 --> 01:19:25,400
difficult to selectively enable disable certain features of the game.

1808
01:19:25,600 --> 01:19:28,700
Since there could be many combinations, each requiring different

1809
01:19:28,700 --> 01:19:29,600
amounts of memory.

1810
01:19:30,700 --> 01:19:35,900
I don't think so, because basically, we will be allocating based on

1811
01:19:36,400 --> 01:19:38,400
what the system's capabilities are.

1812
01:19:38,800 --> 01:19:42,300
So which would also determine what options you are not allowed to

1813
01:19:42,300 --> 01:19:42,700
enable.

1814
01:19:42,700 --> 01:19:44,400
So I think those are both be the same.

1815
01:19:44,800 --> 01:19:47,700
I can't think of any options that actually affect memory though.

1816
01:19:48,200 --> 01:19:49,100
In our case.

1817
01:19:50,200 --> 01:19:51,900
Yeah, I don't think so.

1818
01:19:52,800 --> 01:19:56,700
But I could be wrong and if I again, we have flexibility here.

1819
01:19:56,900 --> 01:20:00,500
If we want to, we can always have it so that the platform layer could

1820
01:20:00,500 --> 01:20:05,800
redo the allocation and change how big it is, but we, it probably

1821
01:20:05,800 --> 01:20:06,900
won't really ever be an issue.

1822
01:20:06,900 --> 01:20:11,100
Because again, when we allocate that memory, if we can always choose

1823
01:20:11,100 --> 01:20:12,500
not to use it all as well.

1824
01:20:12,500 --> 01:20:15,000
We're just reserving the memory with Windows essentially.

1825
01:20:15,400 --> 01:20:18,300
So what we can do to is just reserved, the maximum, we can always

1826
01:20:18,300 --> 01:20:19,500
reserved for gigabytes.

1827
01:20:19,600 --> 01:20:23,800
Something assuming we're on 64-bit thing and then just not use it all.

1828
01:20:33,400 --> 01:20:36,100
Why does the order of fake struct A and B matter?

1829
01:20:36,900 --> 01:20:38,900
Well, it's like I said it because it changes the size.

1830
01:20:38,900 --> 01:20:44,200
And the reason for that is that see a lines things to their their

1831
01:20:44,200 --> 01:20:45,000
boundary.

1832
01:20:45,500 --> 01:20:49,500
So basically, if you have an 8-bit thing, it's going to be it's going

1833
01:20:49,500 --> 01:20:51,200
to be on one bite boundaries.

1834
01:20:51,200 --> 01:20:54,700
If you have a 32-bit thing it's going to be on 34 B boundaries.

1835
01:20:54,900 --> 01:20:58,100
So if you have an 8-bit thing, followed by a 32-bit thing, it's got to

1836
01:20:58,100 --> 01:20:59,800
insert 24 bits of Paddington.

1837
01:21:00,000 --> 01:21:04,100
The next 32, bit B bout to get to the next four byte boundary or

1838
01:21:04,100 --> 01:21:05,800
32-bit boundary, right?

1839
01:21:06,000 --> 01:21:07,000
So that just happens.

1840
01:21:11,100 --> 01:21:12,700
Why did you do the B macros?

1841
01:21:12,700 --> 01:21:14,000
But hesitate on the swap?

1842
01:21:14,000 --> 01:21:16,500
Is there, some hidden complexity on pointer swaps?

1843
01:21:17,500 --> 01:21:24,600
So the reason is because so I'll tell you just to get back to what

1844
01:21:24,600 --> 01:21:27,500
where the what the person is asking about suits, just to give you some

1845
01:21:27,500 --> 01:21:28,700
context if you don't know.

1846
01:21:29,600 --> 01:21:31,100
So here is the thing.

1847
01:21:31,100 --> 01:21:32,400
I did to swap the pointers.

1848
01:21:32,800 --> 01:21:36,400
I basically did new input assignment to tempt then assigned old and

1849
01:21:36,400 --> 01:21:38,900
put two new and put in this, I attempt to Old input, right?

1850
01:21:40,500 --> 01:21:44,800
So the problem is, if you want to do a swap, you kind of have this

1851
01:21:44,800 --> 01:21:46,000
nasty problem.

1852
01:21:47,500 --> 01:21:48,400
So, alright.

1853
01:21:48,500 --> 01:21:52,000
So you see how I wrote that there, it's pretty clear what happened,

1854
01:21:52,100 --> 01:21:52,600
right?

1855
01:21:52,600 --> 01:21:53,400
It's pretty obvious.

1856
01:21:53,400 --> 01:21:54,200
What's going on?

1857
01:21:55,000 --> 01:21:58,600
You could read this code if I want to do a swap, right?

1858
01:21:58,600 --> 01:22:04,000
If I do swap a be right, like this, then the problem is, how do I

1859
01:22:04,000 --> 01:22:04,800
write that?

1860
01:22:04,900 --> 01:22:05,100
Right?

1861
01:22:05,100 --> 01:22:07,500
If I wanted to put this exactly in there.

1862
01:22:07,800 --> 01:22:08,800
I've got this.

1863
01:22:08,800 --> 01:22:14,400
I've got a, I've got be a, I've got a temp, right?

1864
01:22:14,700 --> 01:22:15,900
This is this is what.

1865
01:22:16,400 --> 01:22:16,800
Oops.

1866
01:22:17,600 --> 01:22:18,800
Yeah, this is what this is.

1867
01:22:18,800 --> 01:22:19,500
What's going on?

1868
01:22:20,100 --> 01:22:23,100
Ten people's a a quills beep equals 10 sir.

1869
01:22:23,200 --> 01:22:23,600
There we go.

1870
01:22:24,700 --> 01:22:25,900
That's what I actually wanted.

1871
01:22:26,200 --> 01:22:28,200
So I basically got this.

1872
01:22:28,400 --> 01:22:32,300
The problem is I don't know what type temp is like.

1873
01:22:32,300 --> 01:22:34,000
I have no idea, right?

1874
01:22:34,100 --> 01:22:36,600
Because in the macro, I can't figure out what type it is.

1875
01:22:36,800 --> 01:22:40,100
So you could use a template and C++, but I don't want to introduce

1876
01:22:40,100 --> 01:22:42,900
templates in here because I don't really want to ever use them so that

1877
01:22:42,900 --> 01:22:45,800
when we if we ever write our own compiler, for this or whatever, we

1878
01:22:45,800 --> 01:22:47,100
wouldn't have to support templates.

1879
01:22:47,300 --> 01:22:48,700
Because they're mostly useless.

1880
01:22:49,400 --> 01:22:54,200
And so you're basically just wasting a bunch of language space and

1881
01:22:54,200 --> 01:22:57,500
adding a bunch of complexity for for largely useless feature set.

1882
01:22:57,600 --> 01:23:00,300
And so, basically, like you could use templates here, but if you

1883
01:23:00,300 --> 01:23:03,100
actually want to write the swap swap macro without knowing you'd have

1884
01:23:03,100 --> 01:23:05,000
to pass the type, right?

1885
01:23:05,100 --> 01:23:10,800
Like this, oops, which is a little janky, right?

1886
01:23:11,000 --> 01:23:14,800
Or if you don't want to pass the type, you can implement it using an X

1887
01:23:14,800 --> 01:23:17,200
or basically, there's a way you can do.

1888
01:23:18,200 --> 01:23:23,300
You can do a swap by xoring things together to just sort of do the

1889
01:23:23,300 --> 01:23:24,500
swap in place.

1890
01:23:25,600 --> 01:23:28,000
I don't know if you guys know what I'm talking about, but basically

1891
01:23:28,000 --> 01:23:32,700
like xor swap is like a thing, right?

1892
01:23:32,800 --> 01:23:34,500
You can see it's like a famous thing.

1893
01:23:34,500 --> 01:23:36,400
In fact, right.

1894
01:23:36,500 --> 01:23:40,800
So basically, it's this thing you can read about it if you want to.

1895
01:23:41,400 --> 01:23:46,300
And basically what happens is, it's a way of using the things in place

1896
01:23:46,900 --> 01:23:47,200
to do.

1897
01:23:47,300 --> 01:23:50,300
Do a bunch of exercises with each other that produced the ends up

1898
01:23:50,300 --> 01:23:51,400
producing the swab.

1899
01:23:52,000 --> 01:23:52,800
Does that make sense?

1900
01:23:54,800 --> 01:23:57,200
So, that's the only way you could really write it in a macro that I

1901
01:23:57,200 --> 01:23:59,800
know of, and I didn't really want to do that.

1902
01:24:00,000 --> 01:24:01,300
Just like, you know what?

1903
01:24:01,300 --> 01:24:03,000
I don't even know if I'm going to swap that many things.

1904
01:24:03,000 --> 01:24:04,400
I'm just like, forget about it.

1905
01:24:04,400 --> 01:24:06,600
Whereas the bite stuff for macros is Trivial.

1906
01:24:07,000 --> 01:24:08,200
There's no reason not to do it.

1907
01:24:08,200 --> 01:24:09,000
So I just did it.

1908
01:24:09,800 --> 01:24:10,800
Hopefully, that makes sense.

1909
01:24:14,400 --> 01:24:16,900
And yet the people were saying, C++ 11, decal type.

1910
01:24:17,000 --> 01:24:17,700
Sure you can do that.

1911
01:24:17,700 --> 01:24:20,200
But like I said, I just I don't want to introduce language complexity

1912
01:24:20,200 --> 01:24:22,300
if I don't have to right.

1913
01:24:27,100 --> 01:24:28,200
Let's see here.

1914
01:24:35,600 --> 01:24:40,200
So structs with unions in them have bad performance issues as well.

1915
01:24:40,500 --> 01:24:41,300
No.

1916
01:24:43,300 --> 01:24:44,300
Structures unions in them.

1917
01:24:44,300 --> 01:24:47,100
Don't have any putting a union inside.

1918
01:24:47,100 --> 01:24:49,200
A structure doesn't have any performance implications.

1919
01:24:49,700 --> 01:24:54,300
The basically you always have that alignment thing.

1920
01:24:54,600 --> 01:24:57,500
So, stuck inside the union would also have the same alignment

1921
01:24:57,500 --> 01:25:02,900
constraints wherever it appears in the struct, but there isn't any

1922
01:25:02,900 --> 01:25:05,700
special thing about unions that makes them a problem.

1923
01:25:05,700 --> 01:25:09,700
They're they're the same as just any other member of the struct.

1924
01:25:11,100 --> 01:25:15,400
You mentioned, iocp 40 IO completion ports.

1925
01:25:15,700 --> 01:25:17,400
That's what comments about saying for a sync file.

1926
01:25:17,400 --> 01:25:17,600
I/O.

1927
01:25:17,600 --> 01:25:19,700
Are you planning to use multiple worker threads?

1928
01:25:19,900 --> 01:25:23,100
I've been doing some multi-threaded e-poll code on Linux, and it's

1929
01:25:23,100 --> 01:25:26,500
very janky API, unless you're only using one worker thread.

1930
01:25:26,700 --> 01:25:31,500
There are even a few articles on lwn dotnet only about how to safely

1931
01:25:31,500 --> 01:25:33,100
remove a file descriptor with e-poll.

1932
01:25:33,800 --> 01:25:34,300
So

1933
01:25:35,500 --> 01:25:36,400
On Windows.

1934
01:25:36,700 --> 01:25:39,900
I suspect we will use IO completion ports and just queue up all our

1935
01:25:39,900 --> 01:25:42,800
reads and do them that way, but I don't know for sure.

1936
01:25:43,800 --> 01:25:47,900
You don't even need worker threads at all.

1937
01:25:47,900 --> 01:25:50,900
You can just queue them up and windows to do it for you.

1938
01:25:51,900 --> 01:25:58,000
So the worker threads would only be on the code side and we probably

1939
01:25:58,000 --> 01:25:59,200
would only need one.

1940
01:25:59,300 --> 01:26:01,700
Because all it's really going to do is like, copy the memory and

1941
01:26:01,700 --> 01:26:02,100
stuff.

1942
01:26:02,100 --> 01:26:04,700
Although we could try to speed that up by doing multiple CPU, if

1943
01:26:04,700 --> 01:26:05,100
there's like,

1944
01:26:05,200 --> 01:26:08,500
Lot of decompression work or something, we could do that, but I don't

1945
01:26:08,500 --> 01:26:08,900
know.

1946
01:26:09,000 --> 01:26:09,900
As for Linux.

1947
01:26:10,200 --> 01:26:13,300
I have never tried to do efficient overlapped IO and Linux why I'm no

1948
01:26:13,300 --> 01:26:14,700
idea might be a nightmare.

1949
01:26:15,200 --> 01:26:15,900
I have no idea.

1950
01:26:15,900 --> 01:26:17,600
Well, we'll find out when we get there.

1951
01:26:17,600 --> 01:26:18,200
Basically.

1952
01:26:18,800 --> 01:26:20,400
That'll be interesting experience for me as well.

1953
01:26:20,400 --> 01:26:22,600
Because I don't know how you do those things on Windows.

1954
01:26:22,600 --> 01:26:23,300
Very optimally.

1955
01:26:27,300 --> 01:26:28,000
On the swap.

1956
01:26:28,000 --> 01:26:30,300
Why does it have to be a macro, wouldn't a function?

1957
01:26:30,300 --> 01:26:33,100
Do the job and cover the janky complexity with types in the macro?

1958
01:26:33,600 --> 01:26:35,900
Well, yes we could and so that's like I said, I just didn't want to

1959
01:26:35,900 --> 01:26:37,900
think about it much we could do it.

1960
01:26:38,200 --> 01:26:42,100
But the problem is if you make it a function, you have to have one a

1961
01:26:42,100 --> 01:26:44,900
separate function for every type, right?

1962
01:26:46,400 --> 01:26:49,600
So, yeah, it's a little it's a little janky.

1963
01:26:49,600 --> 01:26:51,900
Even even then you have to have one function for every type.

1964
01:26:51,900 --> 01:26:52,800
You're trying to swap.

1965
01:26:56,800 --> 01:26:58,500
Let's see.

1966
01:27:02,800 --> 01:27:04,100
Let's see.

1967
01:27:07,400 --> 01:27:12,300
F Radix, why do I Define the swap macro to be pound?

1968
01:27:12,300 --> 01:27:15,500
Define swap, do type of 80?

1969
01:27:15,500 --> 01:27:15,800
Again?

1970
01:27:15,800 --> 01:27:17,900
I don't want to introduce any more language features.

1971
01:27:18,300 --> 01:27:19,100
I basically just want.

1972
01:27:19,100 --> 01:27:21,700
See, I just want if you can write a c compiler.

1973
01:27:21,700 --> 01:27:23,400
I want you to be able to compile handmade hero.

1974
01:27:23,400 --> 01:27:26,900
So the only thing we're really doing is overloading is I think the

1975
01:27:26,900 --> 01:27:30,400
only thing we're actually going to really be allowing because I think

1976
01:27:30,400 --> 01:27:31,400
it's valuable.

1977
01:27:32,900 --> 01:27:34,200
It's like it's sort of a necessity.

1978
01:27:34,200 --> 01:27:36,300
Does array count macro work with strings.

1979
01:27:37,100 --> 01:27:41,200
No, it's because the string isn't an array.

1980
01:27:42,400 --> 01:27:44,300
So so it wouldn't work with strings.

1981
01:27:46,500 --> 01:27:48,300
A sink I/O and Linux is nutty.

1982
01:27:48,600 --> 01:27:52,400
All right, if Juan says, so it is probably true.

1983
01:27:53,000 --> 01:27:55,400
Juan 3D is actually watch on.

1984
01:27:55,400 --> 01:27:57,400
He is working on the rad to bugger right now.

1985
01:27:57,400 --> 01:28:01,900
In fact, and he knows Linux things a lot better than I do.

1986
01:28:02,000 --> 01:28:06,400
If he says, the async io is nutty, then it probably is pretty nutty.

1987
01:28:08,200 --> 01:28:09,800
All right, are we at the end of questions?

1988
01:28:09,800 --> 01:28:11,100
We have two minutes left.

1989
01:28:11,200 --> 01:28:14,200
I think we've answered all the questions brown or blue.

1990
01:28:14,200 --> 01:28:16,500
I think the answer is Brown at the zoom.

1991
01:28:16,500 --> 01:28:20,100
You're asking about the switches on the keyboard, to be honest.

1992
01:28:20,100 --> 01:28:21,300
I've been a little bit.

1993
01:28:22,300 --> 01:28:29,500
I really like the dust keyboard three and I really like the Das

1994
01:28:29,500 --> 01:28:33,500
Keyboard three, but I don't like the dust keyboard.

1995
01:28:33,500 --> 01:28:37,800
For as much, the keys are feel too heavy to me, like the

1996
01:28:38,000 --> 01:28:40,900
Springs are like tighter or something.

1997
01:28:41,500 --> 01:28:42,000
So I don't know.

1998
01:28:42,000 --> 01:28:45,500
I mean to do a test side by side, with the Das Keyboard 3, and the 4

1999
01:28:45,800 --> 01:28:47,600
to see if I'm just imagining that.

2000
01:28:47,600 --> 01:28:50,700
But I liked the Das Keyboard threes key, feel a little bit better than

2001
01:28:50,700 --> 01:28:51,700
the Das Keyboard for it.

2002
01:28:51,700 --> 01:28:54,600
To be honest with you, Clemens bound.

2003
01:28:54,700 --> 01:28:55,500
It actually works string.

2004
01:28:55,500 --> 01:28:55,800
Literals.

2005
01:28:55,800 --> 01:29:00,000
Yeah, so when you're asking about the array count string thing, so if

2006
01:29:00,000 --> 01:29:05,300
you happen to Define, if you, if you happen to Define your string

2007
01:29:05,300 --> 01:29:07,800
slightly differently, if you did this.

2008
01:29:10,800 --> 01:29:12,700
Then I think a re count would not work for you.

2009
01:29:12,700 --> 01:29:18,300
But if you did this it would because that actually is an array now in

2010
01:29:18,300 --> 01:29:23,400
terms of what see does, so I'll double check that for you here.

2011
01:29:27,800 --> 01:29:29,100
But I believe that's true.

2012
01:29:29,500 --> 01:29:37,400
So I believe that basically, if we went in here and said in t-bar, AC

2013
01:29:37,400 --> 01:29:41,700
equals array account bar and went boo.

2014
01:29:41,700 --> 01:29:44,300
AC equals array account, boo.

2015
01:29:44,600 --> 01:29:48,600
I suspect that one will be correct in one will be wrong.

2016
01:29:48,800 --> 01:29:49,900
That's just my assumption.

2017
01:29:50,500 --> 01:29:52,200
Let's take a look Bareilles.

2018
01:29:52,200 --> 01:29:53,300
See there.

2019
01:29:53,300 --> 01:29:54,400
We see ya.

2020
01:29:54,600 --> 01:29:57,400
So basically, if you happen to be talking about

2021
01:29:57,500 --> 01:29:59,700
about a literal array.

2022
01:30:00,000 --> 01:30:05,200
You defined as an array c will actually properly initialize that as an

2023
01:30:05,200 --> 01:30:05,900
array.

2024
01:30:06,000 --> 01:30:08,300
That is the string and that'll work.

2025
01:30:08,800 --> 01:30:11,900
But that's really the only time array count would work for a string.

2026
01:30:11,900 --> 01:30:13,700
It'll never work for anything else.

2027
01:30:14,300 --> 01:30:18,200
So, yeah, again, I would not recommend using a rake out with a string

2028
01:30:18,200 --> 01:30:20,700
ever because you're very likely to make a mistake.

2029
01:30:21,300 --> 01:30:25,000
As you change the code that you as the code like kind of goes through

2030
01:30:25,000 --> 01:30:25,500
changes.

2031
01:30:31,500 --> 01:30:33,400
Oh Clemens, mom was saying you could do it.

2032
01:30:33,500 --> 01:30:34,200
I see what you're saying.

2033
01:30:34,200 --> 01:30:37,000
You were saying actually this and yes, I was that works too because

2034
01:30:37,000 --> 01:30:39,300
that's similar to this one as well.

2035
01:30:39,300 --> 01:30:40,900
It's actually a simpler case than this one.

2036
01:30:40,900 --> 01:30:42,600
So yeah, those those should both work.

2037
01:30:42,600 --> 01:30:43,200
I would think.

2038
01:30:47,900 --> 01:30:50,200
Let's see.

2039
01:30:52,900 --> 01:30:54,300
All right, last questions here.

2040
01:30:54,300 --> 01:30:58,800
Looks like there are no more string questions.

2041
01:31:00,700 --> 01:31:01,500
So I think we're done.

2042
01:31:02,000 --> 01:31:04,700
Is there any chance to continue John and Casey show?

2043
01:31:05,300 --> 01:31:08,600
I don't know what John and Casey show is but the Jeff and Casey show,

2044
01:31:08,800 --> 01:31:10,100
if that's what you're talking about.

2045
01:31:10,200 --> 01:31:11,800
It's just that Jeff and Casey show.com.

2046
01:31:11,800 --> 01:31:13,300
It's been going continuously.

2047
01:31:13,400 --> 01:31:14,200
It's still there.

2048
01:31:14,600 --> 01:31:17,700
It never never didn't can discontinued itself.

2049
01:31:18,700 --> 01:31:19,600
All right, people.

2050
01:31:20,300 --> 01:31:23,700
Thank you very much for joining me for another edition of handmade

2051
01:31:23,700 --> 01:31:24,200
hero.

2052
01:31:24,900 --> 01:31:26,500
We are closing in again.

2053
01:31:26,800 --> 01:31:29,700
Like I said yesterday, and I think we're, we

2054
01:31:29,900 --> 01:31:31,500
We did what we want to do today.

2055
01:31:31,500 --> 01:31:35,600
So I think we are closing in on win32 being essentially done in our

2056
01:31:35,600 --> 01:31:38,400
platform independent layer, essentially being done for the time being

2057
01:31:38,700 --> 01:31:39,800
which is pretty awesome.

2058
01:31:39,900 --> 01:31:43,500
We can move onto a fresh new set of things to work on all of, which I

2059
01:31:43,500 --> 01:31:45,100
think will be pretty, pretty cool.

2060
01:31:45,900 --> 01:31:48,200
So, hopefully, you'll join me next week.

2061
01:31:48,200 --> 01:31:48,500
Again.

2062
01:31:48,500 --> 01:31:50,000
We're starting Monday at 8 p.m.

2063
01:31:50,000 --> 01:31:50,800
PST again.

2064
01:31:50,800 --> 01:31:51,800
Hope to see you there.

2065
01:31:52,300 --> 01:31:55,700
We'll probably do a little bit of cleanup or we might push a little

2066
01:31:55,700 --> 01:31:58,900
further forward ahead first just because it's a Monday and we can and

2067
01:31:58,900 --> 01:31:59,600
then maybe save the

2068
01:31:59,800 --> 01:32:03,300
in up for for Thursday and Friday, something like that.

2069
01:32:03,400 --> 01:32:05,900
I don't know exactly what we'll do, but we'll do something like that,

2070
01:32:06,200 --> 01:32:07,700
but next week should be pretty fun.

2071
01:32:07,700 --> 01:32:09,400
So, I hope to see you guys here again.

2072
01:32:09,400 --> 01:32:11,600
If you would like to follow along with the source code at home.

2073
01:32:11,600 --> 01:32:15,200
You can pre-order the game on handmade hero dot-org and that'll give

2074
01:32:15,200 --> 01:32:18,000
you a link that you can use to download the source code every night.

2075
01:32:18,200 --> 01:32:20,800
And that's going to be increasingly important as we go.

2076
01:32:20,800 --> 01:32:24,700
Because this will also have the assets that you'll need to follow

2077
01:32:24,700 --> 01:32:27,800
along at home with a actual like Sprites and stuff like that, which is

2078
01:32:27,800 --> 01:32:29,700
going to be important going forward.

2079
01:32:29,800 --> 01:32:33,300
Words, also, if you want to discuss, ask questions and discuss news

2080
01:32:33,300 --> 01:32:35,700
and forums has like the schedule for the week.

2081
01:32:35,700 --> 01:32:38,400
It's got a code discussion area where you can ask questions, all sorts

2082
01:32:38,400 --> 01:32:38,800
of stuff.

2083
01:32:38,900 --> 01:32:39,800
So, check that out for sure.

2084
01:32:39,800 --> 01:32:41,500
It's also got extended episode guide.

2085
01:32:42,000 --> 01:32:43,900
And the Twitter feed, as always.

2086
01:32:44,200 --> 01:32:46,800
I tweet every day when the stream will be, if you're curious.

2087
01:32:46,800 --> 01:32:48,400
You can always take, check the Twitter feed.

2088
01:32:48,800 --> 01:32:50,300
So check all that stuff out.

2089
01:32:50,600 --> 01:32:53,500
Thank you very much for joining me for another episode of handmade

2090
01:32:53,500 --> 01:32:56,200
hero, and I hope to see you Monday at 8:00 p.m.

2091
01:32:56,200 --> 01:32:56,800
Sharp.

2092
01:32:57,000 --> 01:32:59,300
Thanks everybody, and I will see you next week.

