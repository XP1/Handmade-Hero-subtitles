1
00:00:02,600 --> 00:00:03,000
Okay.

2
00:00:03,000 --> 00:00:04,800
Hello everyone and welcome to animate.

3
00:00:04,800 --> 00:00:05,100
Here.

4
00:00:05,100 --> 00:00:05,300
Are the show?

5
00:00:05,300 --> 00:00:09,100
We could complete game live on stream today?

6
00:00:09,100 --> 00:00:10,800
We are going to do a little more sorting.

7
00:00:10,800 --> 00:00:12,300
We're pretty much done with sorting.

8
00:00:12,300 --> 00:00:14,500
There's really not a whole lot to say about it.

9
00:00:15,100 --> 00:00:19,200
It was really just an excuse to talk about a few CS things that we

10
00:00:19,200 --> 00:00:24,100
don't really talk about much on handmade hero, and probably are more

11
00:00:24,100 --> 00:00:28,100
for sort of self-study sorts of things, but I do want to finish up

12
00:00:28,100 --> 00:00:29,300
what we were doing with.

13
00:00:31,400 --> 00:00:35,200
With the Sorting just so you can kind of see today D 234 on handmade

14
00:00:35,200 --> 00:00:35,400
hero.

15
00:00:35,400 --> 00:00:39,400
So if you want to follow along at home and you're one of those peoples

16
00:00:39,400 --> 00:00:43,000
who has kindly pre-ordered handmade hero on handmade here at up or you

17
00:00:43,000 --> 00:00:44,900
will want to unpack day 233.

18
00:00:45,200 --> 00:00:47,600
That is a source code that I'm looking at today.

19
00:00:47,600 --> 00:00:50,900
Now if you remember from Friday, we tried to see if it would be

20
00:00:50,900 --> 00:00:54,400
reasonable for us to implement mergesort in place and it did not seem

21
00:00:55,000 --> 00:00:56,000
like it would be.

22
00:00:56,400 --> 00:00:59,700
It seemed like it would just be very expensive and involve a lot of

23
00:00:59,700 --> 00:01:01,000
like move, you know?

24
00:01:01,200 --> 00:01:05,500
Complex, not complex, but expensive moves of the buffer to really do

25
00:01:05,500 --> 00:01:06,200
it in place.

26
00:01:06,400 --> 00:01:11,400
So we tried just not doing it in place and and that was obviously

27
00:01:11,400 --> 00:01:12,800
very, very easy to implement.

28
00:01:12,800 --> 00:01:16,500
In fact we implemented that you know, in just just a few minutes so we

29
00:01:16,500 --> 00:01:17,300
have that working.

30
00:01:20,400 --> 00:01:21,600
which means we can now

31
00:01:23,800 --> 00:01:27,700
We can now freely choose at any time whether we want to use a bubble

32
00:01:27,700 --> 00:01:28,800
sort or merge sort.

33
00:01:28,800 --> 00:01:32,600
And in fact we could I suppose make these just for the sake of the

34
00:01:32,600 --> 00:01:35,600
people who might want to play with them at home, make a bubble sort

35
00:01:35,600 --> 00:01:39,300
and merge sort you know, that sort of thing where we just do

36
00:01:41,000 --> 00:01:44,400
You know, some kind of a generic thing where it's like, okay, you can

37
00:01:44,400 --> 00:01:46,700
call the merge sort or you can call the bubble sort.

38
00:01:46,700 --> 00:01:50,400
It's your choice, so cures the bubble sort and then in here we just

39
00:01:50,400 --> 00:01:54,300
say, Okay, bubble, sort count, entries temp space,

40
00:01:56,300 --> 00:01:58,300
And then we can just pick which one of these we call.

41
00:01:58,300 --> 00:02:01,900
And so, you know, we can comment bubble sort and call the merge sort

42
00:02:02,300 --> 00:02:06,200
if we want to and everything is, is happy.

43
00:02:06,400 --> 00:02:11,500
And so in here, yeah, like I think we can just say first for that, and

44
00:02:11,500 --> 00:02:14,600
then we pretty much have that pulled out again.

45
00:02:14,600 --> 00:02:16,600
Not doing anything here, other than extracting that.

46
00:02:16,700 --> 00:02:18,500
So now, we've got the bubble sort and merge sort.

47
00:02:18,800 --> 00:02:23,200
And so really, you know, that's really all there is to it for those

48
00:02:23,200 --> 00:02:23,600
sorts.

49
00:02:23,600 --> 00:02:25,700
There's not much to them, people want it.

50
00:02:25,900 --> 00:02:30,400
Know about the Radix sort, this was a very thing something that really

51
00:02:30,400 --> 00:02:31,800
people were excited about.

52
00:02:32,000 --> 00:02:34,800
I don't know necessarily why they're that, excited about it.

53
00:02:35,300 --> 00:02:37,300
But you know, if they are that's great.

54
00:02:37,300 --> 00:02:38,900
It's always good to be excited about things.

55
00:02:40,400 --> 00:02:43,300
By the way, the fact that I'm still so Tethered to this and I can't

56
00:02:43,300 --> 00:02:50,500
even sit up straight, I look to find a cable that would, you know,

57
00:02:50,500 --> 00:02:54,700
this is a, this is a like an iPhone, not an iPhone.

58
00:02:55,800 --> 00:02:58,500
Or like an Android, just whatever a tip, ring ring sleeve, right?

59
00:02:58,500 --> 00:02:59,800
It's one of the things it's got like, the microphone.

60
00:03:00,000 --> 00:03:03,600
The headpiece, like you plug into a cell phone and I just looked for

61
00:03:03,600 --> 00:03:09,300
someone who made a cable along cable that was like a plug for that, on

62
00:03:09,300 --> 00:03:12,700
one end, you know, just one plug that you plug a head for a standard

63
00:03:12,700 --> 00:03:17,500
cell phone headphone microphone cable into and on the other end just

64
00:03:17,500 --> 00:03:22,400
to mic Jacks for the, you know, what are they quarter inch Jack's?

65
00:03:22,400 --> 00:03:24,600
I can't remember what they're called, but that go into the back of the

66
00:03:24,600 --> 00:03:25,100
computer.

67
00:03:25,200 --> 00:03:28,600
So it goes into the headphone slot and the

68
00:03:29,800 --> 00:03:32,800
and their microphone slot and I could not find anything that was

69
00:03:32,800 --> 00:03:34,200
longer than like that long.

70
00:03:35,500 --> 00:03:38,200
So if you happen to have a link handy where it's like, here's a cable,

71
00:03:38,200 --> 00:03:39,200
that's like a nice.

72
00:03:39,200 --> 00:03:41,400
Like three foot long cable or something.

73
00:03:42,900 --> 00:03:45,600
Even a foot long cable, would be way better than what I have.

74
00:03:46,500 --> 00:03:47,500
I would really appreciate it.

75
00:03:47,500 --> 00:03:48,800
Okay, enough about that.

76
00:03:49,500 --> 00:03:50,400
I'm still tethered down.

77
00:03:50,400 --> 00:03:53,700
Its Libyan oppressed by the cable, by the cable, man.

78
00:03:55,400 --> 00:03:58,500
So let's talk about Radix sort because like I said, people were

79
00:03:58,500 --> 00:03:59,800
excited about Radix sort.

80
00:03:59,800 --> 00:04:03,400
So I would like to, at least cover it.

81
00:04:03,400 --> 00:04:05,000
I'm not the best person to talk about it.

82
00:04:05,300 --> 00:04:08,200
Sort, I don't write Red X or it's hardly ever if ever.

83
00:04:11,500 --> 00:04:16,800
Not that I Really Right sorts of any kind all that often but it's not

84
00:04:17,100 --> 00:04:19,200
certainly not something that I spend a lot of time thinking about.

85
00:04:19,200 --> 00:04:22,400
But point being, let's talk about what a Radix sort is and how it

86
00:04:22,400 --> 00:04:22,700
works.

87
00:04:22,700 --> 00:04:24,200
I mentioned it briefly the other day.

88
00:04:24,200 --> 00:04:27,900
I'm going to say what it is in a little more detail today.

89
00:04:28,600 --> 00:04:38,200
So today, 234 Radix sort now a Radix sort a again, like I said, I'm

90
00:04:38,200 --> 00:04:41,100
the wrong person to really explain them because not my area of

91
00:04:41,300 --> 00:04:41,500
Teeth.

92
00:04:41,500 --> 00:04:45,200
But the way that I would think of a Radix sort is, we talked about the

93
00:04:45,200 --> 00:04:46,900
concept of a stable sort.

94
00:04:48,700 --> 00:04:49,200
Right?

95
00:04:49,700 --> 00:04:52,800
We talk to someone asked about it on the Q&A and I sort of explain

96
00:04:52,800 --> 00:04:54,200
what that was a stable.

97
00:04:54,200 --> 00:04:58,100
Sort is a sort where you have some set of items, okay?

98
00:04:58,700 --> 00:05:01,500
And the order in which the items occurs,

99
00:05:03,600 --> 00:05:07,100
Is not changed, if they don't need to be sorted.

100
00:05:07,100 --> 00:05:13,300
So any any ordering that's currently in the list, if two items are?

101
00:05:13,300 --> 00:05:17,200
If it does not detect that any particular item is out of place in that

102
00:05:17,200 --> 00:05:21,500
list relative, something else, it will not change their relative

103
00:05:21,500 --> 00:05:22,100
location.

104
00:05:22,300 --> 00:05:24,900
So for example, if here is my list of things

105
00:05:26,100 --> 00:05:28,800
And I perform my sort, right.

106
00:05:29,300 --> 00:05:32,800
If this list instead, we're say something like this.

107
00:05:37,300 --> 00:05:38,000
Right?

108
00:05:38,500 --> 00:05:42,500
And the sort was designed to just sort on the first character meaning

109
00:05:42,500 --> 00:05:45,700
to sort were running is sort in alphabetical order by the first

110
00:05:45,700 --> 00:05:46,100
character.

111
00:05:46,100 --> 00:05:49,000
Don't look at the second character ever, just first character and I've

112
00:05:49,000 --> 00:05:51,800
got a ABAC bdb, you know, whatever.

113
00:05:51,800 --> 00:05:52,400
Right.

114
00:05:52,700 --> 00:05:53,800
And I do this sort.

115
00:05:54,000 --> 00:05:59,300
Well in order to satisfy this criteria, right, this criteria of a, a

116
00:05:59,300 --> 00:05:59,800
be

117
00:06:00,000 --> 00:06:01,500
CC appearing, in order.

118
00:06:01,800 --> 00:06:04,900
We know that the output has to look like this.

119
00:06:05,000 --> 00:06:11,300
It has to look like a, a a,b,c c, right?

120
00:06:12,000 --> 00:06:15,200
Because we know that in order to satisfy the criteria that the first

121
00:06:15,200 --> 00:06:18,600
letters we sorted, the best look like that, but what we did not

122
00:06:18,600 --> 00:06:23,000
specify is what would happen to these actual elements because these

123
00:06:23,000 --> 00:06:24,900
elements all have a as the first character.

124
00:06:24,900 --> 00:06:29,800
And this element also does, there is no, we have defined no criteria.

125
00:06:30,000 --> 00:06:31,900
A afore how they have to appear in here?

126
00:06:32,900 --> 00:06:33,500
Right.

127
00:06:33,600 --> 00:06:38,700
A, the definition of sorting does not specify what has to happen to

128
00:06:38,700 --> 00:06:43,000
elements that sort to the same relative location that don't have any

129
00:06:43,000 --> 00:06:47,300
determining between them when they are compared the compare equal not

130
00:06:47,300 --> 00:06:48,900
less than or greater than or whatever.

131
00:06:49,000 --> 00:06:49,400
Right?

132
00:06:50,300 --> 00:06:55,300
And so this concept of a stable sort a stable sort is one that

133
00:06:55,300 --> 00:07:00,400
preserves the order in which the things appeared in the original list,

134
00:07:00,500 --> 00:07:01,000
right?

135
00:07:01,600 --> 00:07:02,600
And so in this case,

136
00:07:02,900 --> 00:07:07,200
There would be only one actual answer here, even though we're not

137
00:07:07,200 --> 00:07:12,200
defining any additional sort criteria, we are defining this, you know,

138
00:07:12,200 --> 00:07:17,400
sort of additional non sort criteria if you will, or maybe you could

139
00:07:17,400 --> 00:07:20,000
even say we were defining additional search criteria.

140
00:07:20,100 --> 00:07:24,100
The additional search criteria is where it was in the list, right?

141
00:07:33,500 --> 00:07:36,400
Which as I'm saying it out loud.

142
00:07:36,400 --> 00:07:41,000
I realize again, since I never work on sorting, I had never occurred

143
00:07:41,000 --> 00:07:44,500
to me, but it seems like can't you just make

144
00:07:46,800 --> 00:07:48,400
like isn't

145
00:07:50,100 --> 00:07:53,800
any sort a stable sort.

146
00:07:55,400 --> 00:07:56,400
if you just,

147
00:07:58,200 --> 00:08:01,100
Add the original ordinal.

148
00:08:04,100 --> 00:08:05,000
To the sort key.

149
00:08:08,600 --> 00:08:12,200
Like, if you wanted to take a sort that wasn't stable and make it

150
00:08:12,200 --> 00:08:16,500
stable, can't you just say that the sort key is just whatever the key

151
00:08:16,500 --> 00:08:20,900
was Plus at the end of that key, whatever the position was in the

152
00:08:20,900 --> 00:08:21,900
list, originally?

153
00:08:22,900 --> 00:08:24,900
Doesn't that just give you a stable sort for free?

154
00:08:25,300 --> 00:08:26,500
Like why do you even care?

155
00:08:26,500 --> 00:08:29,700
If a sword is stable when you could just add that to the cake?

156
00:08:30,800 --> 00:08:31,200
I don't know.

157
00:08:31,200 --> 00:08:33,100
These are the kinds of questions I don't care about because I don't

158
00:08:33,100 --> 00:08:36,400
really care about sort, but point being, it would seem to me that it'd

159
00:08:36,400 --> 00:08:38,400
be pretty easy, but we don't care about that.

160
00:08:38,400 --> 00:08:39,600
Right now, I'm talking about ready to start.

161
00:08:39,600 --> 00:08:40,600
Forget I even said it.

162
00:08:42,500 --> 00:08:43,600
Just a thought I happen to have.

163
00:08:44,800 --> 00:08:48,800
Anyway, so what we are doing here is just saying, hey, we're adding

164
00:08:48,800 --> 00:08:52,900
another criteria if we say the sort is stable, it means that anything

165
00:08:53,000 --> 00:08:56,100
that occurred in a particular order here, has to occur in a particular

166
00:08:56,100 --> 00:08:56,900
order here.

167
00:08:56,900 --> 00:08:59,800
If it's, you know, if it's otherwise

168
00:09:00,000 --> 00:09:01,200
To do so, right?

169
00:09:01,200 --> 00:09:06,500
So since all of these here AAA have no restrictions on the order they

170
00:09:06,500 --> 00:09:11,400
come, it has to use the order they came in here so it has to be ABCD,

171
00:09:11,600 --> 00:09:12,000
right?

172
00:09:12,000 --> 00:09:13,500
I'm sorry, abce.

173
00:09:15,000 --> 00:09:17,500
They have to go in this order and that doesn't matter about the

174
00:09:17,500 --> 00:09:18,300
alphabetical nature.

175
00:09:18,300 --> 00:09:23,800
Like this could have been be here and a here, and a here, and a here,

176
00:09:23,800 --> 00:09:24,400
as well.

177
00:09:24,900 --> 00:09:28,400
And then this would have had to have been Bae, right?

178
00:09:28,400 --> 00:09:30,400
It just has to be whatever order comes in here.

179
00:09:30,600 --> 00:09:35,600
Now, this is still free to come after meaning, it's still supposed to

180
00:09:35,600 --> 00:09:40,200
change the order of this and this because it is supposed to sort on

181
00:09:40,200 --> 00:09:43,800
the actual part that that is that you were requesting, right?

182
00:09:43,900 --> 00:09:44,400
So it does

183
00:09:44,600 --> 00:09:45,000
Is the order.

184
00:09:45,000 --> 00:09:46,900
It just doesn't change the order of anything.

185
00:09:46,900 --> 00:09:50,800
It doesn't have to change the order of, and that's the stable sort

186
00:09:50,800 --> 00:09:51,200
part.

187
00:09:51,800 --> 00:09:52,100
Okay?

188
00:09:52,100 --> 00:09:53,700
So hopefully you're all clear on that.

189
00:09:54,200 --> 00:09:59,300
So now, a Radix sort is basically, like I've got to just Define it as

190
00:09:59,900 --> 00:10:01,900
some number.

191
00:10:03,900 --> 00:10:05,400
Of successive.

192
00:10:07,100 --> 00:10:08,500
Stable sorts.

193
00:10:10,900 --> 00:10:13,300
On some part.

194
00:10:15,400 --> 00:10:16,500
Of the sort key.

195
00:10:20,300 --> 00:10:22,600
This is really what we're actually talking about.

196
00:10:22,600 --> 00:10:27,100
When we talk about a Radix sort, a Radix sort is basically repeatedly,

197
00:10:27,200 --> 00:10:35,000
stabili sorting your list of elements on only a portion of the key at

198
00:10:35,000 --> 00:10:37,200
any given time, right?

199
00:10:37,700 --> 00:10:41,800
So let's take the simplest possible example for a Radix sort,

200
00:10:42,900 --> 00:10:46,100
Would be where we don't have anything in particular in the sort key.

201
00:10:46,100 --> 00:10:50,900
Other than, just a series of bits that we know represent a number of

202
00:10:50,900 --> 00:10:52,300
our sorting by, right?

203
00:10:52,500 --> 00:10:55,200
So let's say we had something like a 32-bit integer.

204
00:10:56,200 --> 00:10:57,200
What's the sort key?

205
00:10:57,700 --> 00:11:02,200
Okay, and what we want to be able to do for our 32-bit integer is we

206
00:11:02,200 --> 00:11:10,000
would like to be able to to put our list in order based on how high

207
00:11:10,000 --> 00:11:10,700
does number is.

208
00:11:10,700 --> 00:11:14,300
So it's just a straight-up sort on how high the 32-bit integer is will

209
00:11:14,300 --> 00:11:17,000
even say it's unsigned, right?

210
00:11:18,700 --> 00:11:19,100
Okay.

211
00:11:19,600 --> 00:11:21,600
So, how Radix sort decides to tackle?

212
00:11:21,600 --> 00:11:25,200
This problem is, it says well, okay, I know I've got some series of

213
00:11:25,200 --> 00:11:29,400
items and I know there are 32 bit integers, right?

214
00:11:29,800 --> 00:11:35,000
So here's, you know, some 32-bit integer, you know, 105 or actually, I

215
00:11:35,000 --> 00:11:38,600
suppose, what I should do is, is break this down to make it easier for

216
00:11:38,600 --> 00:11:41,700
IMAX with explanation, let's break this down into B.

217
00:11:42,100 --> 00:11:48,200
So here is like, you know, this is this is B 0 through 7, this is B.

218
00:11:48,400 --> 00:11:49,300
8315.

219
00:11:49,300 --> 00:11:52,000
This is B 16 through 24.

220
00:11:52,700 --> 00:11:56,800
I'm sorry 23 and this is B 23 through 31.

221
00:11:58,400 --> 00:11:59,000
Make sense.

222
00:12:00,100 --> 00:12:04,000
So basically, I've eight bits in each of these, right?

223
00:12:04,300 --> 00:12:04,800
And

224
00:12:10,600 --> 00:12:11,000
I don't know why.

225
00:12:11,000 --> 00:12:12,800
I just did that supposed to be 24.

226
00:12:14,600 --> 00:12:16,700
So you have 8 Bits in each of these, right?

227
00:12:16,800 --> 00:12:20,300
And you can imagine we just have some set of 32-bit integers.

228
00:12:20,300 --> 00:12:24,500
So this is, you know, these each one of these slots holds some 32-bit

229
00:12:24,500 --> 00:12:29,700
integer and for the sake of discussion let's just say that I'll

230
00:12:29,700 --> 00:12:32,600
alphabetize them here in the order.

231
00:12:32,600 --> 00:12:33,500
They would come.

232
00:12:33,500 --> 00:12:36,300
So for example, let's you know I'll just pick Reza's G.

233
00:12:36,300 --> 00:12:39,600
This is z this is a, this is f e.

234
00:12:40,200 --> 00:12:43,000
X q, right?

235
00:12:43,300 --> 00:12:46,200
And so this is just to let us know quickly because we're going to be

236
00:12:46,200 --> 00:12:49,500
having, you know, if I have to if you have to imagine some 32-bit

237
00:12:49,500 --> 00:12:52,000
number of they're pretty large like 4 billion, something or other

238
00:12:52,000 --> 00:12:53,100
could be in there, or whatever.

239
00:12:53,300 --> 00:12:55,800
Let's just say that these letters represent.

240
00:12:55,800 --> 00:12:59,700
The order that they come in, I could even be a little bit more concise

241
00:12:59,700 --> 00:13:02,900
and say that since we have one, two, three, four, five, six, seven of

242
00:13:02,900 --> 00:13:03,300
them.

243
00:13:04,000 --> 00:13:06,800
We can just use, like, ABCDEFG.

244
00:13:07,100 --> 00:13:08,200
So it's like, you know,

245
00:13:10,200 --> 00:13:17,200
You know, G first then a then C then B then e, then F ABC.

246
00:13:17,200 --> 00:13:21,300
Where's my DD ABCDEFG?

247
00:13:21,300 --> 00:13:21,900
Right?

248
00:13:22,100 --> 00:13:25,600
So we just know that the numbers come in this order so if we were to

249
00:13:25,600 --> 00:13:28,900
sort them we would expect the 81 to come first and then the D and then

250
00:13:28,900 --> 00:13:31,100
and so on that's just to make it a little easier on us when we're

251
00:13:31,100 --> 00:13:32,400
looking at these things, right?

252
00:13:33,600 --> 00:13:37,700
Okay, so we know that these are 32-bit integers.

253
00:13:37,900 --> 00:13:41,500
And so, what we want to do is we want to sort this array using the

254
00:13:41,500 --> 00:13:44,000
Radix sort into something that's going to come in the proper order

255
00:13:44,000 --> 00:13:46,800
instead of the in correct order, which is what it starts in or we

256
00:13:46,800 --> 00:13:49,500
assume it starts in otherwise we wouldn't be calling sort.

257
00:13:50,200 --> 00:13:53,900
So, what we do for a Radix sort, is we just sort it in place multiple

258
00:13:53,900 --> 00:13:58,500
times and we sort it in place, multiple times by slicing the sort key

259
00:13:58,500 --> 00:13:59,600
up into parts.

260
00:14:00,600 --> 00:14:06,000
And The crucial observation here is that if you can write the sort key

261
00:14:06,000 --> 00:14:09,200
and this is actually more or less required for a Radix sort.

262
00:14:09,200 --> 00:14:12,800
Although people have come up with many clever ways to turn things that

263
00:14:12,800 --> 00:14:13,700
don't quite seem.

264
00:14:13,700 --> 00:14:15,900
Like, they look like this into things that are right exportable,

265
00:14:15,900 --> 00:14:18,200
because you can kind of think of it as anything.

266
00:14:18,200 --> 00:14:21,200
You could sort by slices kind of works this way.

267
00:14:21,200 --> 00:14:27,600
So if you can turn your sort key into just something that looks like a

268
00:14:27,600 --> 00:14:30,500
series of bits, then what you can do is choose.

269
00:14:30,600 --> 00:14:35,700
Used to accelerate the sort by slicing that into portions that are of

270
00:14:35,700 --> 00:14:38,800
a size where you can do some tricks, right?

271
00:14:39,500 --> 00:14:43,000
So for example, in a traditional Radix sort, if you were to slice it

272
00:14:43,000 --> 00:14:46,300
into 8 Bits, as I've done here, where we have our sort key and we have

273
00:14:46,300 --> 00:14:51,400
like each portion of it of the sort key is a particular 8-bit piece.

274
00:14:51,900 --> 00:14:55,300
Then, for example, if I have some number that's relatively complicated

275
00:14:55,400 --> 00:14:58,700
you know the the number that we're actually talking about is like, you

276
00:14:58,700 --> 00:14:59,800
know, in hexadecimal

277
00:15:00,100 --> 00:15:07,900
Is, you know, for ef-1, you know, be a 95 or something.

278
00:15:08,000 --> 00:15:08,600
Right?

279
00:15:09,200 --> 00:15:10,000
Then in here.

280
00:15:10,000 --> 00:15:12,700
You could imagine each particular part of this number,

281
00:15:14,600 --> 00:15:20,100
as it as it occurs in the original sort, key each part can be broken

282
00:15:20,100 --> 00:15:21,800
down into 8-bit chunks, right?

283
00:15:21,800 --> 00:15:24,900
I can slice each one of these sort Keys into a pick chunks.

284
00:15:25,200 --> 00:15:32,100
And what do we know about the result of sorting on any one of these

285
00:15:32,100 --> 00:15:34,100
particular 8-bit chunks, right?

286
00:15:34,100 --> 00:15:38,900
Well, if I was to sort on just the highest, the most important ones

287
00:15:38,900 --> 00:15:39,400
right?

288
00:15:39,400 --> 00:15:42,500
Like suppose I'm going to sort and I'm just going to look at those top

289
00:15:42,500 --> 00:15:43,300
eight bits

290
00:15:43,700 --> 00:15:46,800
Well, if I just sorted on just the top eight bits, I would know that I

291
00:15:46,800 --> 00:15:48,600
would roughly right?

292
00:15:48,600 --> 00:15:52,300
Roughly organize my list by order of magnitude, right?

293
00:15:52,300 --> 00:15:57,500
Meaning anything that's really important to the value of this number

294
00:15:57,500 --> 00:16:01,000
comes in this first bit here, right?

295
00:16:01,000 --> 00:16:04,800
These first 8 Bits are the most significant ones, not shouldn't say

296
00:16:04,800 --> 00:16:09,700
first, these high order eight bits are the most different ones if that

297
00:16:09,700 --> 00:16:11,600
top bit is set, right?

298
00:16:11,600 --> 00:16:13,300
That changes the value.

299
00:16:13,900 --> 00:16:17,600
By the maximum number, a bit can possibly change the value, right?

300
00:16:18,000 --> 00:16:21,100
It's to to the 31st is what that bit controls?

301
00:16:21,400 --> 00:16:25,500
Whereas the bits down here, could never possibly hope to affect it,

302
00:16:25,500 --> 00:16:26,100
right?

303
00:16:26,400 --> 00:16:31,800
So what I'm getting at is that if you were to sort by this, this is

304
00:16:31,800 --> 00:16:34,700
the most important thing to sort by, right?

305
00:16:34,700 --> 00:16:36,700
No matter what happens down here.

306
00:16:36,900 --> 00:16:41,500
These should never appear in anything other than ascending order after

307
00:16:41,500 --> 00:16:43,100
the sword is done, right?

308
00:16:43,200 --> 00:16:43,500
Because

309
00:16:43,600 --> 00:16:46,700
If they were at anything other than a sorting order, it wouldn't

310
00:16:46,700 --> 00:16:50,700
matter how what order these parts of the number we're in, right?

311
00:16:50,800 --> 00:16:53,700
And you can see this, if you think of it, not in binary and easier way

312
00:16:53,700 --> 00:17:01,100
to think of it would be if you had something like 101, 107, 100 106

313
00:17:01,300 --> 00:17:03,300
207, right?

314
00:17:04,700 --> 00:17:09,000
When you look at this you can immediately say well it doesn't matter

315
00:17:09,099 --> 00:17:11,900
if these parts come in order, right?

316
00:17:12,000 --> 00:17:16,700
If you were to take this and you were to say 0 1 0 1, you know what

317
00:17:16,700 --> 00:17:17,200
I'm sorry.

318
00:17:17,300 --> 00:17:21,599
100 101 106 107,

319
00:17:23,700 --> 00:17:26,700
Or sorry, rather, 2007 107, right.

320
00:17:27,599 --> 00:17:32,500
I put these in order but these are not in order, right?

321
00:17:32,600 --> 00:17:37,100
And so since this is the most significant part, this is not the

322
00:17:37,100 --> 00:17:37,900
correct, sort order.

323
00:17:37,900 --> 00:17:40,900
We all know this to be true intuitively, right?

324
00:17:41,500 --> 00:17:44,100
But that's actually a more General concept.

325
00:17:44,100 --> 00:17:48,000
You can just apply to sorting and think about inserting the these have

326
00:17:48,000 --> 00:17:49,400
to go in order first.

327
00:17:49,500 --> 00:17:52,100
Then these then these, right?

328
00:17:52,800 --> 00:17:53,300
And that is the

329
00:17:53,400 --> 00:17:59,300
crucial idea behind the Radix sort is that you can sort by the most

330
00:18:00,800 --> 00:18:02,000
Portion, right?

331
00:18:02,300 --> 00:18:04,300
That part has to be true.

332
00:18:04,300 --> 00:18:09,300
And then inside any section where the most significant part is

333
00:18:09,300 --> 00:18:10,600
equivalent, right?

334
00:18:10,700 --> 00:18:13,700
Like right here, for example, I'm sorry.

335
00:18:15,200 --> 00:18:20,000
I got to put this in actual order now, inside the places where the

336
00:18:20,000 --> 00:18:24,700
most significant part is all the same, then you care about what the

337
00:18:24,700 --> 00:18:28,000
order is for the other things but only that right.

338
00:18:28,000 --> 00:18:31,300
If these two differ, you don't care if these parts are in order.

339
00:18:31,300 --> 00:18:34,300
If there was a 20-6 here, right?

340
00:18:35,400 --> 00:18:39,300
Again you don't care if the to 0, if the sixes came together here, you

341
00:18:39,300 --> 00:18:43,100
don't care about that because the to overrides that and now you only

342
00:18:43,100 --> 00:18:44,900
care about what happens between

343
00:18:45,100 --> 00:18:48,200
This part when these are already sorted, right?

344
00:18:49,000 --> 00:18:50,400
So, that's the main content of a Radix.

345
00:18:50,400 --> 00:18:54,700
Sort is saying we have to sort by these first, then these, then these

346
00:18:54,700 --> 00:18:56,400
then these right?

347
00:18:56,900 --> 00:19:01,500
But there's a reason why you don't apply it quite exactly.

348
00:19:01,500 --> 00:19:03,700
Like, what I just said, Okay?

349
00:19:04,600 --> 00:19:07,600
The reason why you don't apply it quite like I just said, is because

350
00:19:07,600 --> 00:19:11,500
again if you consider what happens when you sort of buffer, if I was

351
00:19:11,500 --> 00:19:14,800
to sort first by the most significant thing mean

352
00:19:15,000 --> 00:19:17,000
Can I call sort on it first?

353
00:19:17,900 --> 00:19:21,900
Then I call sort on the next one, right?

354
00:19:23,700 --> 00:19:29,200
You would end up with the obvious problem of of it, would rearrange

355
00:19:29,200 --> 00:19:30,400
the order, right?

356
00:19:31,000 --> 00:19:34,400
So, there's a couple ways, you know, you could choose to have the

357
00:19:34,400 --> 00:19:35,200
Radix, sort work.

358
00:19:35,300 --> 00:19:39,900
You could choose to make it go in and basically, either order

359
00:19:39,900 --> 00:19:42,900
depending on whether you sub sort ranges or whether you sort the

360
00:19:42,900 --> 00:19:43,800
entire buffer.

361
00:19:44,300 --> 00:19:44,800
And there's really

362
00:19:45,000 --> 00:19:48,500
Ways you can implement, it will take a look at that in a second.

363
00:19:49,600 --> 00:19:53,300
But anyway, conceptually that's what a Radix sort is doing its saying.

364
00:19:53,400 --> 00:19:58,700
Let me slice, this, the sort key up into chunks and sort just one of

365
00:19:58,700 --> 00:20:01,200
the chunks first, then another chunk than another chunk.

366
00:20:01,400 --> 00:20:05,900
And if you imagine just doing it to one buffer over and over, then you

367
00:20:05,900 --> 00:20:08,900
can sort of imagine why I was saying about a series of sable sorts.

368
00:20:09,200 --> 00:20:12,600
If I was to just sort the buffer based on the lowest order thing

369
00:20:12,600 --> 00:20:14,800
first, then I sorted

370
00:20:15,000 --> 00:20:18,900
And stably by the next one up and then the next one up and the next

371
00:20:18,900 --> 00:20:19,500
one up.

372
00:20:19,600 --> 00:20:22,300
When I got to the end my buffer would be sorted, right?

373
00:20:22,500 --> 00:20:26,000
Because like again taking this example, the first sort puts these in

374
00:20:26,000 --> 00:20:35,500
order so it says oh I've got 10 10, 100, 1, 0 1, 1 0 6, 2006 right 10

375
00:20:35,500 --> 00:20:37,800
7, 2007, right?

376
00:20:37,800 --> 00:20:38,600
That's what it says.

377
00:20:39,000 --> 00:20:40,800
Again all of these are now in order.

378
00:20:40,900 --> 00:20:44,600
But these are not right, then it sorts by this stably.

379
00:20:45,000 --> 00:20:48,600
Have to make any changes, then it sorts by this against stabili.

380
00:20:48,700 --> 00:20:49,300
So, it goes.

381
00:20:49,300 --> 00:20:49,800
Okay.

382
00:20:49,900 --> 00:20:51,800
I've got 100, 100 100.

383
00:20:52,100 --> 00:20:52,600
And 6.

384
00:20:52,600 --> 00:20:54,400
2006, not in place.

385
00:20:54,500 --> 00:20:56,400
107 would come there, right?

386
00:20:56,400 --> 00:20:59,200
Then I've got 2006 2007.

387
00:21:00,000 --> 00:21:05,500
Stable sort and so now, even though I only sorted on this was only

388
00:21:05,500 --> 00:21:09,000
starting on this digit, that time, I end up with the right answer

389
00:21:09,000 --> 00:21:12,800
overall because the stable the stability of the sort means that I can

390
00:21:12,800 --> 00:21:17,700
sort just by this and since I know these are already in order, I know

391
00:21:17,700 --> 00:21:22,700
that the final result will come out in entirety ordered entirely

392
00:21:22,800 --> 00:21:23,300
right.

393
00:21:25,100 --> 00:21:25,500
Okay.

394
00:21:26,600 --> 00:21:30,200
So that's basically how Radix sort, like, what the idea behind Radix

395
00:21:30,200 --> 00:21:31,300
sort is right.

396
00:21:31,700 --> 00:21:34,400
But the question is, why would we care about that?

397
00:21:34,400 --> 00:21:36,800
Like, why do we want to slice it up?

398
00:21:37,000 --> 00:21:40,600
What's the magic that makes it like, what does slicing it up?

399
00:21:40,600 --> 00:21:41,200
Give us.

400
00:21:41,400 --> 00:21:45,400
Yes, that would work to stably sort this thing in place, you know, in

401
00:21:45,400 --> 00:21:48,500
the case of the 32-bit number B, 4 different times.

402
00:21:48,500 --> 00:21:50,500
But why do I want to sort it for different times?

403
00:21:51,400 --> 00:21:53,800
Well, the answer is because once you chopped

404
00:21:54,000 --> 00:22:00,900
Down the total number of possible, things possible values of the sort

405
00:22:00,900 --> 00:22:01,200
key.

406
00:22:01,300 --> 00:22:04,200
Once you chop it down into something, tractable like 8 Bits.

407
00:22:04,400 --> 00:22:05,800
What do we know about eight bits?

408
00:22:05,800 --> 00:22:08,100
Well, there's 256 possible values.

409
00:22:11,700 --> 00:22:13,400
In 8 Bits, right?

410
00:22:13,800 --> 00:22:17,200
8 B is only 200 spots of ice.

411
00:22:17,200 --> 00:22:21,600
It's trivial these days on Modern computers to do something like in t.

412
00:22:21,600 --> 00:22:24,400
Count 256, right?

413
00:22:27,200 --> 00:22:27,500
Right.

414
00:22:27,500 --> 00:22:28,300
Very, very simple.

415
00:22:28,500 --> 00:22:30,900
No one would bat an eyelash about that.

416
00:22:31,700 --> 00:22:35,500
So what that means is, if we can, if we can make something that's

417
00:22:35,500 --> 00:22:37,000
that's this small.

418
00:22:37,200 --> 00:22:42,800
We can start to use interesting table logic to reduce the actual work,

419
00:22:42,800 --> 00:22:43,500
we have to do.

420
00:22:43,800 --> 00:22:47,600
So, in the case of a Radix, sort, what we do is exactly something like

421
00:22:47,600 --> 00:22:47,800
this.

422
00:22:47,800 --> 00:22:51,100
We say, okay, let's start with a table.

423
00:22:52,100 --> 00:22:55,500
That tells us how many of each type of sort key.

424
00:22:55,500 --> 00:23:00,900
We have we know that once we slice it into B that each byte value for

425
00:23:00,900 --> 00:23:05,200
the sort key, can only have 8 Bits of data or go only 256 possible

426
00:23:05,200 --> 00:23:05,800
values.

427
00:23:05,900 --> 00:23:09,900
So in one pass, we're only dealing with 256 possible sort Keys.

428
00:23:10,200 --> 00:23:12,000
We could run through the thing again.

429
00:23:12,000 --> 00:23:14,900
Om time to go through all the elements right?

430
00:23:14,900 --> 00:23:17,300
It would only take Owen time to go through all the elements once.

431
00:23:18,700 --> 00:23:22,200
Look at that section of their sort key and increment the count value

432
00:23:22,300 --> 00:23:26,200
to tell us how many of that sort key we have, right?

433
00:23:27,200 --> 00:23:28,900
So again, coming up here to this example.

434
00:23:28,900 --> 00:23:31,600
If we were to do this, you can imagine making a table.

435
00:23:31,800 --> 00:23:33,400
This again is base 10.

436
00:23:33,400 --> 00:23:36,500
So we would have something that was like count ten right?

437
00:23:36,800 --> 00:23:37,800
For each of the digits.

438
00:23:38,000 --> 00:23:42,800
We would go through here and we would say, Okay 40's, we have 14 ones.

439
00:23:42,800 --> 00:23:46,900
We have to, I'm sorry one, right four sixes,

440
00:23:48,300 --> 00:23:51,400
We have to this one in this one for sevens.

441
00:23:51,500 --> 00:23:54,800
We also have to write everything else was 0.

442
00:23:56,200 --> 00:23:59,800
So once we know this now,

443
00:24:00,000 --> 00:24:05,500
After we're done, it is Trivial for us to put these in exactly the

444
00:24:05,500 --> 00:24:07,600
right place, right?

445
00:24:08,100 --> 00:24:12,200
Because now when we come through the second past, right?

446
00:24:12,200 --> 00:24:14,400
Because we do a know one thing to get these counts.

447
00:24:14,600 --> 00:24:18,300
Now if we just Loop over the elements again, we can say exactly where

448
00:24:18,300 --> 00:24:22,900
they go because we know if something has a sort key of one, it just

449
00:24:22,900 --> 00:24:25,300
has to go after the first one of these.

450
00:24:26,200 --> 00:24:26,700
Right?

451
00:24:27,200 --> 00:24:31,200
If something has a sort key of seven, it just goes after the the

452
00:24:31,200 --> 00:24:33,900
second one of these, right?

453
00:24:34,500 --> 00:24:37,100
So we can just do two passes, right?

454
00:24:37,100 --> 00:24:39,800
So, it's basically 0 to n to do one of these.

455
00:24:39,900 --> 00:24:43,600
We do two passes, first account, how many of each we have and then to

456
00:24:43,600 --> 00:24:47,700
put things in their place that's really all we need to do in terms of

457
00:24:47,700 --> 00:24:48,200
the N.

458
00:24:49,800 --> 00:24:53,800
right now, if we just do that exact operation,

459
00:24:55,000 --> 00:24:59,900
Four times in a row for our binary, right for our for our 32-bit guy,

460
00:25:00,200 --> 00:25:04,900
if we just did for 8-bit passes of that to anything, we would have

461
00:25:04,900 --> 00:25:08,800
something that was 04 times 2N, right?

462
00:25:08,800 --> 00:25:09,900
Or a 10.

463
00:25:10,600 --> 00:25:13,600
We would have something that was a 10 to put all of the things, all of

464
00:25:13,600 --> 00:25:17,500
these in order, no matter how big the in is the end could be a billion

465
00:25:18,500 --> 00:25:23,500
and it would still only be eight billion cost now compare this to and

466
00:25:23,500 --> 00:25:24,200
login.

467
00:25:24,700 --> 00:25:28,200
It or O N squared, which were are other sort options.

468
00:25:28,900 --> 00:25:32,400
And you can see why this might be kind of nice, because if the number

469
00:25:32,400 --> 00:25:37,500
was a billion, Well, Log n or say four billion login, in that case

470
00:25:37,500 --> 00:25:38,600
would have been 32.

471
00:25:39,300 --> 00:25:42,100
But here are constant, is only eight, right?

472
00:25:42,400 --> 00:25:44,500
Which is a very big Improvement, potentially,

473
00:25:45,600 --> 00:25:46,200
Makes sense.

474
00:25:47,500 --> 00:25:51,800
Now again there's a little bit of an extra cost here which is that

475
00:25:51,800 --> 00:25:55,900
like I've got to initialize this table, two zeros and I've got to do

476
00:25:55,900 --> 00:25:57,300
these, you know, these counter comments.

477
00:25:57,500 --> 00:26:00,900
So you know, it's not free to break it up into this.

478
00:26:00,900 --> 00:26:03,900
But again in terms of scaling and remember, that's what we were

479
00:26:03,900 --> 00:26:06,300
talking about, with order annotation in terms of scaling.

480
00:26:06,400 --> 00:26:10,200
You can see that this scales very well because unlike the other sorts,

481
00:26:10,500 --> 00:26:15,800
which always scale by some super linear factor of n either squared or

482
00:26:15,800 --> 00:26:16,500
a log n.

483
00:26:18,100 --> 00:26:22,000
The Radix sort is one of the very few sorts that does not.

484
00:26:22,300 --> 00:26:24,300
It actually just scales by n.

485
00:26:25,200 --> 00:26:28,400
And again, it does that by taking advantage of the fact that what you

486
00:26:28,400 --> 00:26:32,600
actually store in a computer is typically finite, it's not an infinite

487
00:26:32,600 --> 00:26:37,500
Precision arithmetic, kind of a thing, it's finite and so you can use

488
00:26:37,500 --> 00:26:42,300
that finiteness to slice it up into more tractable parts.

489
00:26:42,400 --> 00:26:42,900
Right.

490
00:26:43,000 --> 00:26:46,000
If these were infinite Precision numbers, this would not work

491
00:26:47,000 --> 00:26:51,200
But because these are very specific, finite Precision finite bounded

492
00:26:51,200 --> 00:26:53,500
numbers which is what we typically do with a computer.

493
00:26:53,700 --> 00:26:57,400
You can take that shortcut and make it work, right?

494
00:26:58,800 --> 00:26:59,300
Okay.

495
00:27:00,000 --> 00:27:02,100
Let's see how we would need to do that.

496
00:27:02,100 --> 00:27:05,000
It's going to be a little complicated for our particular case,

497
00:27:05,000 --> 00:27:05,700
unfortunately.

498
00:27:05,700 --> 00:27:11,200
Because right, we have a Radix sort situation where we don't actually

499
00:27:11,200 --> 00:27:13,500
have a 32-bit integer sort key.

500
00:27:13,700 --> 00:27:15,200
We have a floating points or key.

501
00:27:15,300 --> 00:27:18,600
So we're going to have to do something with that to get our sort to

502
00:27:18,600 --> 00:27:19,200
work properly.

503
00:27:19,200 --> 00:27:21,900
But for now we can just pretend we don't and write the sort first and

504
00:27:21,900 --> 00:27:24,700
then we'll deal with the fact of how do we transform our problem into

505
00:27:24,700 --> 00:27:25,800
an actual Radix, sort.

506
00:27:26,100 --> 00:27:27,500
Let's see how much time I have.

507
00:27:27,500 --> 00:27:29,500
I think I started at 5:20.

508
00:27:30,000 --> 00:27:32,700
So I actually have until about 6:20 to finish.

509
00:27:32,900 --> 00:27:34,200
So we've got a bit of time here.

510
00:27:34,800 --> 00:27:36,200
So here's our Radix sort.

511
00:27:36,500 --> 00:27:38,400
And here's I'm going to go ahead and

512
00:27:40,300 --> 00:27:42,000
Put that together there.

513
00:27:42,200 --> 00:27:44,800
And so now we'll just get rid of our Birds sort and we'll call our

514
00:27:44,800 --> 00:27:45,500
Radix sort.

515
00:27:46,000 --> 00:27:47,200
And so, how are we going to do it?

516
00:27:47,200 --> 00:27:47,600
What we're going to do?

517
00:27:47,600 --> 00:27:49,200
Exactly what I said before?

518
00:27:49,700 --> 00:27:52,500
We know that our count can be no more than 32 bits because that's the

519
00:27:52,500 --> 00:27:53,800
value that we got passed in.

520
00:27:53,800 --> 00:27:54,200
So we know.

521
00:27:54,200 --> 00:27:55,900
We only have 4 billion or less items.

522
00:27:56,200 --> 00:27:58,500
So we know we can just use a that for our accounts.

523
00:27:58,800 --> 00:28:05,200
So, what we'll do is, you know, sort sort key accounts or something

524
00:28:05,200 --> 00:28:05,800
like that.

525
00:28:06,300 --> 00:28:09,000
And like I said, if we know that we have just a third

526
00:28:09,200 --> 00:28:11,700
Floating-point number will assume for now that it's only going to be,

527
00:28:12,300 --> 00:28:15,900
it's going to only be four passes, right?

528
00:28:15,900 --> 00:28:18,700
It's going to be 32 bits will do it by B, just like I did in the

529
00:28:18,700 --> 00:28:19,400
diagram there.

530
00:28:19,700 --> 00:28:23,800
So, that means we've got 256 possible, sort key values for each slice

531
00:28:23,800 --> 00:28:25,500
of our thing, right?

532
00:28:26,400 --> 00:28:26,800
Okay.

533
00:28:27,100 --> 00:28:30,600
Now again, we need to clear that 20 which is kind of unfortunate, but

534
00:28:30,600 --> 00:28:34,000
like I said, it's just there's some cost to setting up the Radix sort.

535
00:28:34,100 --> 00:28:35,800
I don't think there's a lot of ways around that.

536
00:28:36,300 --> 00:28:39,000
So, the first thing that we would do is we'd say, okay, we've got

537
00:28:39,100 --> 00:28:43,000
To go through and we've got to take our sort keys and figure out how

538
00:28:43,000 --> 00:28:44,600
many of each kind we have.

539
00:28:44,800 --> 00:28:49,100
And like I also said for each time through, when we do this, we have

540
00:28:49,100 --> 00:28:53,100
to have some way of doing it for each slice, right?

541
00:28:53,200 --> 00:28:56,500
So we also have a thing here that's like, for our sort key, if it's 32

542
00:28:56,500 --> 00:28:59,400
bits, we know that we have like a bite index, do it, right?

543
00:28:59,600 --> 00:29:01,700
And the B index is going to have to be

544
00:29:04,400 --> 00:29:05,600
It's going to have to go up, right?

545
00:29:05,600 --> 00:29:07,300
We're gonna have to slice the bottom bite off.

546
00:29:07,300 --> 00:29:09,400
Then the next bite, then the next bite the next fight.

547
00:29:09,400 --> 00:29:12,100
If we want to do it from stable, sort from bottom up, right?

548
00:29:12,400 --> 00:29:15,900
At least significant byte to most significant byte, we could choose to

549
00:29:15,900 --> 00:29:16,300
do it.

550
00:29:16,300 --> 00:29:20,500
I think potentially it would be possible to maybe do it another way,

551
00:29:20,900 --> 00:29:22,600
but it would be a little fuzzier.

552
00:29:22,600 --> 00:29:24,400
So, anyway, so we'll do it that way again.

553
00:29:24,400 --> 00:29:30,200
Like I said for for stable sort passes over the array to sort it by

554
00:29:30,200 --> 00:29:32,300
each increasingly more important bite.

555
00:29:32,400 --> 00:29:33,300
Right, every time.

556
00:29:33,700 --> 00:29:37,000
Okay, so we go through here, we have our B index, we then want to Loop

557
00:29:37,000 --> 00:29:38,700
over our items, right?

558
00:29:38,900 --> 00:29:43,200
So this is just our entry index into the array.

559
00:29:43,500 --> 00:29:47,500
And so, as we come through here, we just need to say, whatever our,

560
00:29:47,600 --> 00:29:49,300
like, our entries are

561
00:29:50,800 --> 00:29:54,100
Whatever our particular entry is here, it has a sort key.

562
00:29:55,200 --> 00:29:58,800
And what we need to do is call, like, sort key to you 32.

563
00:30:00,800 --> 00:30:01,400
Right?

564
00:30:02,000 --> 00:30:05,100
Because like I said, we need it to be you 32 for this scheme to work.

565
00:30:05,100 --> 00:30:09,200
So we need to call that and we don't know what that is yet and

566
00:30:09,300 --> 00:30:11,200
honestly to be completely, honestly, I'm gonna have to think about

567
00:30:11,200 --> 00:30:15,400
what that is because I'm not really sure, but we've got something

568
00:30:15,400 --> 00:30:18,600
there, which is going to pass in this floating point value and we've

569
00:30:18,600 --> 00:30:20,000
got to turn it into a u-32.

570
00:30:20,200 --> 00:30:24,200
Okay, so so this is our Radix value.

571
00:30:24,200 --> 00:30:24,700
This is the thing.

572
00:30:24,700 --> 00:30:26,500
We're actually going to sort on.

573
00:30:27,000 --> 00:30:28,400
Once we have that Radix value.

574
00:30:28,400 --> 00:30:30,400
We know that we have a bite index here, that

575
00:30:30,600 --> 00:30:31,900
Going to operate on.

576
00:30:33,300 --> 00:30:38,500
So we take that Radix value and we shift down by the B Index, right?

577
00:30:38,500 --> 00:30:41,200
Because the B index 0 we're going to take that first, at least

578
00:30:41,200 --> 00:30:41,900
significant byte.

579
00:30:42,000 --> 00:30:45,600
So we need to shift down as it goes up to the next pass through by

580
00:30:45,600 --> 00:30:46,400
tanks going to be one.

581
00:30:46,400 --> 00:30:48,300
We're going to shift down by eight bits, right?

582
00:30:48,300 --> 00:30:49,200
8, B, 8 Bits.

583
00:30:49,200 --> 00:30:53,200
So each time we go through, we want to take out a successively higher

584
00:30:53,200 --> 00:30:59,100
part, and again, we only want just that just the 8-Bit value at the

585
00:30:59,100 --> 00:31:00,800
bottom because we're doing eight bits at a time.

586
00:31:00,800 --> 00:31:02,700
So we got a mask it out and so

587
00:31:02,800 --> 00:31:03,300
Here we go.

588
00:31:03,500 --> 00:31:07,400
So now we have, like our B piece or something, whatever you want to

589
00:31:07,400 --> 00:31:10,000
call it Radix piece, something like that.

590
00:31:10,500 --> 00:31:13,000
So this is the full Radix value that we're sorting on.

591
00:31:13,100 --> 00:31:15,700
This is the piece that we're starting on in this pass.

592
00:31:16,900 --> 00:31:18,700
And then we go to our sort keys.

593
00:31:20,000 --> 00:31:24,600
And we say, whatever that piece is, whatever that pieces.

594
00:31:24,600 --> 00:31:27,000
We got to increment that count because now we know we have one more of

595
00:31:27,000 --> 00:31:27,400
those.

596
00:31:28,200 --> 00:31:28,700
Right?

597
00:31:30,000 --> 00:31:31,300
So there we go.

598
00:31:31,400 --> 00:31:33,700
That's all of our key counts.

599
00:31:33,900 --> 00:31:36,100
Now, we can also do something else here, which is keep track of the

600
00:31:36,100 --> 00:31:39,500
total, and you can do this in two different ways, but we do need to

601
00:31:42,500 --> 00:31:44,000
No, I'm sorry, that's not actually true.

602
00:31:44,000 --> 00:31:45,100
We don't need to keep track of the total.

603
00:31:45,200 --> 00:31:47,500
I know why I'm saying that we need to, we need to do the running

604
00:31:47,500 --> 00:31:48,500
total, which will do here.

605
00:31:49,500 --> 00:31:54,000
Okay, so we go through there, we keep track of how many keys are now.

606
00:31:54,000 --> 00:31:57,800
We have our stuff set up so that we know are sort key.

607
00:31:57,800 --> 00:32:01,800
Counts are however many, there are in each one of our effectively

608
00:32:01,800 --> 00:32:02,900
buckets, you could almost think of them.

609
00:32:02,900 --> 00:32:03,300
Right.

610
00:32:03,400 --> 00:32:06,200
We know how many sort Keys fall into each possible.

611
00:32:06,200 --> 00:32:08,900
8-bit value that there is okay.

612
00:32:10,800 --> 00:32:18,600
So now we want to go through our different sort Keys like directly and

613
00:32:18,600 --> 00:32:21,000
say for each of our sort key.

614
00:32:24,700 --> 00:32:27,700
For each of these entries into our sort Keys.

615
00:32:27,700 --> 00:32:29,200
We now need to know

616
00:32:30,700 --> 00:32:34,500
the running total like of all the sort keys that happen before them.

617
00:32:34,700 --> 00:32:35,200
Right.

618
00:32:35,200 --> 00:32:37,800
Because remember the next thing we're going to do is we're going to do

619
00:32:37,800 --> 00:32:38,900
a thing here, oops.

620
00:32:41,600 --> 00:32:43,800
we're going to do, you know,

621
00:32:45,200 --> 00:32:47,600
First pass, count.

622
00:32:47,700 --> 00:32:50,300
How many of each key, right?

623
00:32:50,300 --> 00:32:51,300
That's what we're doing here.

624
00:32:52,300 --> 00:32:54,800
And then here, we're going to do

625
00:32:57,100 --> 00:32:59,400
Second Pass Place.

626
00:33:00,300 --> 00:33:01,700
Into the right location.

627
00:33:02,400 --> 00:33:06,000
Okay, so by the time we get to the second pass, when we get down here

628
00:33:06,300 --> 00:33:10,100
and we extract the Radix, peace, we have to be able to essentially do

629
00:33:10,100 --> 00:33:14,900
this and place it exactly where it needs to go.

630
00:33:15,900 --> 00:33:18,100
Right, that's what we actually need to do.

631
00:33:19,100 --> 00:33:25,100
So in here, what we need to do is transform this sort key count to a

632
00:33:25,100 --> 00:33:27,200
sort key offset, right?

633
00:33:27,200 --> 00:33:30,500
And in fact we might want to actually call it that to begin with

634
00:33:31,300 --> 00:33:33,700
because that's what it ends up being, right?

635
00:33:35,900 --> 00:33:39,000
So then what we do is we say, alright, we initialize our running total

636
00:33:39,600 --> 00:33:40,900
and say we're going to start off.

637
00:33:40,900 --> 00:33:44,700
Obviously, the first thing we'll go in slot 0, that's pretty obvious,

638
00:33:44,700 --> 00:33:45,200
right?

639
00:33:45,600 --> 00:33:48,200
So we go through our sort keys and say, all right, we've got the sort

640
00:33:48,200 --> 00:33:51,200
key offset, whatever.

641
00:33:51,200 --> 00:33:56,600
This sort key offset actually is we want to take that value and save

642
00:33:56,600 --> 00:33:57,900
it for a second, right?

643
00:33:57,900 --> 00:34:00,600
This is like the count at the moment.

644
00:34:00,900 --> 00:34:04,300
We then want to take that sort key offset and say, okay, for

645
00:34:04,400 --> 00:34:08,600
this particular sort key, we know that it would start at wherever our

646
00:34:08,600 --> 00:34:12,699
current total is so wherever we would, you know, however, many things

647
00:34:12,699 --> 00:34:16,500
were occupied in the list up to this point, that's where we would

648
00:34:16,500 --> 00:34:20,100
start putting things that have this sort key and then we would say,

649
00:34:20,100 --> 00:34:24,400
alright advance that running total by whatever our count actually was,

650
00:34:25,600 --> 00:34:26,600
Do you see how that works?

651
00:34:27,000 --> 00:34:29,900
I'll just briefly sort of say it again over here.

652
00:34:30,900 --> 00:34:33,400
So we've gone through our list, right?

653
00:34:33,500 --> 00:34:36,900
We've done a no end pass over the array of entries, right?

654
00:34:36,900 --> 00:34:40,900
This is the entries and we've counted how many of each sort key we

655
00:34:40,900 --> 00:34:41,400
saw.

656
00:34:41,600 --> 00:34:45,500
So in this past we end up with sort key counts.

657
00:34:47,300 --> 00:34:51,300
Right now, what we need to do is do another pass where we can put

658
00:34:51,300 --> 00:34:53,400
things in the right place, but in order to do that, we need to know

659
00:34:53,400 --> 00:34:56,400
where the right place is for each type of sort key.

660
00:34:57,000 --> 00:35:00,200
Okay, so we've got these sort key counts, right?

661
00:35:00,200 --> 00:35:02,800
And we've got 256 of these, right?

662
00:35:03,300 --> 00:35:05,800
And what we need to do is we've got something that looks like oh

663
00:35:05,900 --> 00:35:07,800
there's you know sort Keys 0.

664
00:35:08,500 --> 00:35:10,100
Well that's got three sort key.

665
00:35:10,100 --> 00:35:15,600
One that's got none sort Q2 that's got five sort Q 3 right and so when

666
00:35:15,600 --> 00:35:16,900
I come through on my

667
00:35:17,100 --> 00:35:17,600
S.

668
00:35:17,700 --> 00:35:20,300
Om pass to put the entries in the right place.

669
00:35:20,300 --> 00:35:23,800
Well uh oh I can't look up in here.

670
00:35:23,800 --> 00:35:27,400
If the first thing had a sort key of to all I know is there are five

671
00:35:27,400 --> 00:35:27,900
of them?

672
00:35:28,100 --> 00:35:30,100
Well that doesn't tell me where to put it.

673
00:35:30,800 --> 00:35:35,000
What I need to know is what was the sum of all previous sort keys,

674
00:35:35,200 --> 00:35:35,800
right?

675
00:35:35,900 --> 00:35:38,900
Because the correct place to put to put something in the list.

676
00:35:39,000 --> 00:35:42,400
If it has a sort key of to, is after the third one, right?

677
00:35:42,400 --> 00:35:46,900
Because there's three elements before it, it will are occupied.

678
00:35:47,000 --> 00:35:48,600
Pied by people with a sort P of 0.

679
00:35:48,600 --> 00:35:49,800
So they have to come first.

680
00:35:49,800 --> 00:35:52,100
Those first three are filled by the people of zero, right.

681
00:35:52,100 --> 00:35:55,700
So when I do this, I'm gonna have some of the sort Kia 0 here, 0 here,

682
00:35:55,800 --> 00:35:56,500
0 here.

683
00:35:56,600 --> 00:35:59,800
And then I can start putting people with the sort key of

684
00:36:00,400 --> 00:36:01,100
Right.

685
00:36:01,400 --> 00:36:04,800
So all I'm doing here is just summing up keeping a running total so

686
00:36:04,800 --> 00:36:08,800
that I can change these to the to be offsets of where those sort Keys

687
00:36:08,800 --> 00:36:10,400
occur, right?

688
00:36:11,500 --> 00:36:12,100
Finally.

689
00:36:12,100 --> 00:36:13,700
In the second pass, right?

690
00:36:13,700 --> 00:36:18,600
And this is Casey change counts to offsets.

691
00:36:21,700 --> 00:36:25,300
So finally in the second pass, I go through each one, I do the exact

692
00:36:25,300 --> 00:36:27,700
same thing as I did in the first pass where I get out that Radix

693
00:36:27,700 --> 00:36:28,200
piece.

694
00:36:28,600 --> 00:36:30,300
This is the sort key for this pass.

695
00:36:31,100 --> 00:36:33,600
And what I need to do is take the sort key offset.

696
00:36:34,700 --> 00:36:35,800
For this Radix piece.

697
00:36:36,100 --> 00:36:39,800
And I just need to put this entry there, right?

698
00:36:39,800 --> 00:36:49,700
So, I need to say, dest of that equals source of Index, right, and

699
00:36:49,700 --> 00:36:50,800
that does the sort move.

700
00:36:51,100 --> 00:36:56,700
Now, remember, I may have many entries that have the same sort key

701
00:36:56,700 --> 00:36:57,300
piece.

702
00:36:57,600 --> 00:37:00,200
In fact, that's the whole reason I counted is because I might have a,

703
00:37:00,200 --> 00:37:03,800
who knows how many arbitrarily many I could have count many, all of,

704
00:37:03,900 --> 00:37:05,700
Could have the same value this time round.

705
00:37:06,000 --> 00:37:09,200
In fact, many of The Times They will, the top values might be all 0.

706
00:37:09,200 --> 00:37:12,400
For example, if you're a sorting, some low 32-bit values.

707
00:37:13,300 --> 00:37:18,700
And so each time I place one in here, I need to increment that offset

708
00:37:18,900 --> 00:37:22,700
because the next one who comes through here, will have to be placed in

709
00:37:22,700 --> 00:37:25,800
the, in the subsequent slot, right?

710
00:37:26,300 --> 00:37:29,900
So you can almost think of these Source key offsets as basically 256

711
00:37:29,900 --> 00:37:33,800
pointers in some sense, 200 basis.

712
00:37:33,900 --> 00:37:37,000
That say where the next place is too, right?

713
00:37:38,200 --> 00:37:40,200
The element that has that sort key.

714
00:37:41,200 --> 00:37:41,700
Okay.

715
00:37:42,900 --> 00:37:47,700
All right, so now what you'll notice about this is I'm just straight

716
00:37:47,700 --> 00:37:51,800
up romping over my array, so source and desk can't be the same here,

717
00:37:51,800 --> 00:37:52,800
because, right?

718
00:37:52,800 --> 00:37:54,200
I've got to have two different things.

719
00:37:54,600 --> 00:37:59,300
So, again, Radix sort In-Place, probably exists don't even want to try

720
00:37:59,300 --> 00:37:59,700
it.

721
00:38:02,700 --> 00:38:05,600
So, Radix, sort want some temp memory?

722
00:38:06,000 --> 00:38:06,400
Okay.

723
00:38:07,800 --> 00:38:11,100
So, here's my first and here's my temp, right?

724
00:38:11,200 --> 00:38:13,600
So I'm going to start off and say, well, I've got tile sword entry.

725
00:38:15,600 --> 00:38:19,000
And I've got my source, my source obviously Begins by pulling from

726
00:38:19,000 --> 00:38:19,600
first.

727
00:38:19,900 --> 00:38:25,000
I've got my my dest that begins by being temp, right?

728
00:38:25,300 --> 00:38:28,900
And then each time through here, I'm going to do a swap, right?

729
00:38:29,500 --> 00:38:35,500
So I've kind of got a swap value, that's, that's going to be equal to

730
00:38:36,700 --> 00:38:37,400
dest.

731
00:38:37,600 --> 00:38:40,400
I'm going to change desk to be source, and I'm going to change source

732
00:38:40,400 --> 00:38:41,200
to be swapped in.

733
00:38:41,700 --> 00:38:44,500
So I'm just going to go ahead and ping.

734
00:38:44,800 --> 00:38:48,000
The buffer is so each time through eyesore into a new buffer, right?

735
00:38:48,300 --> 00:38:52,900
So the first time through sort and dest source and estar first attempt

736
00:38:53,000 --> 00:38:56,900
next time through it goes from temp to First next time through it goes

737
00:38:56,900 --> 00:38:59,500
from first attempt next, a ghost room, temp 2 first and hey, what do

738
00:38:59,500 --> 00:38:59,800
you know?

739
00:39:00,100 --> 00:39:04,300
I believe that actually puts it back in exactly the place that we

740
00:39:04,300 --> 00:39:05,900
wanted it, right?

741
00:39:07,200 --> 00:39:11,700
Okay so that oh and this has to be source as well.

742
00:39:11,800 --> 00:39:15,600
Sorry so that is basically a Radix sort.

743
00:39:15,700 --> 00:39:20,500
I may have type some bugs in there but that is basically the idea and

744
00:39:20,700 --> 00:39:21,900
and there you go.

745
00:39:22,400 --> 00:39:24,300
This is obviously not an arrow.

746
00:39:24,300 --> 00:39:27,700
That's one of these and there we go.

747
00:39:29,100 --> 00:39:34,600
okay, so our sort q2u, 32 we don't actually know what that is right

748
00:39:34,600 --> 00:39:38,400
now so you know, we could just just straight up cast it, that will not

749
00:39:38,400 --> 00:39:44,400
actually work, but now we have our Radix sort running anyway, and so

750
00:39:44,400 --> 00:39:49,400
if I now go to to run this, presumably, this will not actually sort

751
00:39:49,400 --> 00:39:53,100
because we probably won't get that lucky with the floating Point

752
00:39:53,100 --> 00:39:57,500
values, so we should hit an assertion, which will tell us that

753
00:39:57,500 --> 00:39:58,600
actually, hey,

754
00:39:59,400 --> 00:40:03,000
Great job guys but you didn't in fact, sort the buffer.

755
00:40:04,100 --> 00:40:07,100
Now, the first thing I want to make sure is that I actually did that

756
00:40:07,100 --> 00:40:10,900
correct in my head and that we are actually putting it into the

757
00:40:10,900 --> 00:40:14,100
entries output area as I would have expected.

758
00:40:14,500 --> 00:40:16,900
Let me see if that's the case.

759
00:40:18,800 --> 00:40:21,500
Well, I guess I wouldn't really know even if it was the case.

760
00:40:21,600 --> 00:40:25,500
So actually, I guess what I would rather do is just step through and

761
00:40:25,500 --> 00:40:27,000
verify that that's true.

762
00:40:27,500 --> 00:40:32,000
So, let's go ahead and come through here and I'm going to run to the

763
00:40:32,000 --> 00:40:33,000
end of this routine.

764
00:40:33,300 --> 00:40:33,700
And I just

765
00:40:34,000 --> 00:40:37,500
See what desk is equal to, right?

766
00:40:37,600 --> 00:40:43,100
So here's first, here's temp, what's test equal to so it's okay

767
00:40:43,100 --> 00:40:43,800
perfect.

768
00:40:43,800 --> 00:40:46,500
So the last time through the loop, it will swap the things.

769
00:40:46,600 --> 00:40:52,600
So if I was correct desk, should be pointing to Temp at the end and it

770
00:40:52,600 --> 00:40:54,600
and it is so that's exactly what I wanted.

771
00:40:54,600 --> 00:40:55,300
So that's good.

772
00:40:55,400 --> 00:40:55,800
Okay.

773
00:40:57,400 --> 00:41:00,000
So maybe I did the rig sort, right?

774
00:41:00,000 --> 00:41:01,600
Maybe I didn't, I don't know.

775
00:41:01,600 --> 00:41:05,500
We haven't actually gotten that far yet, but because what we need to

776
00:41:05,500 --> 00:41:14,300
do now is have something we need to turn our 32-bit floating-point

777
00:41:15,200 --> 00:41:22,300
value into some strictly ascending 32-bit integer.

778
00:41:23,200 --> 00:41:23,600
Value.

779
00:41:25,200 --> 00:41:26,000
Right?

780
00:41:26,000 --> 00:41:27,800
So you can see the problem here.

781
00:41:27,900 --> 00:41:33,600
This only works when you can actually slice out the b and compare them

782
00:41:33,900 --> 00:41:35,400
as if they were actually parts.

783
00:41:35,400 --> 00:41:41,000
Of a singly ordered 32-bit surgery is a 32-bit numbers floating Point

784
00:41:41,000 --> 00:41:41,500
values.

785
00:41:41,500 --> 00:41:44,600
Again are not exactly going to be that, okay?

786
00:41:44,600 --> 00:41:45,500
And why aren't they?

787
00:41:45,500 --> 00:41:49,700
Well, if you remember this is the 32-bit

788
00:41:50,500 --> 00:41:53,800
IEEE float kind of value here.

789
00:41:55,300 --> 00:41:56,800
What do these look like?

790
00:41:57,300 --> 00:41:59,400
Okay, what does a 32-bit?

791
00:42:00,000 --> 00:42:00,400
Point value.

792
00:42:00,400 --> 00:42:01,800
Look like we talked about this.

793
00:42:01,800 --> 00:42:03,400
We've talked about this, right?

794
00:42:04,300 --> 00:42:09,800
And it looks like this, it's got a mantissa, it's got an exponent and

795
00:42:09,800 --> 00:42:11,800
it's got a sign bit, okay?

796
00:42:12,300 --> 00:42:18,200
Now the sign bit, if I remember correctly, doesn't that help us here,

797
00:42:18,600 --> 00:42:19,100
right?

798
00:42:19,400 --> 00:42:25,400
Because the sign bit will be set to 0 if it's positive but it'll set

799
00:42:25,400 --> 00:42:28,400
to 1 if it's - right.

800
00:42:28,600 --> 00:42:29,600
And the way that we're

801
00:42:30,000 --> 00:42:37,800
And right now we will sort negative values as being greater than

802
00:42:38,000 --> 00:42:39,200
positive values, right?

803
00:42:39,200 --> 00:42:44,200
We will put negative values after positive values and obviously, that

804
00:42:44,600 --> 00:42:46,900
is not what we want, right?

805
00:42:48,400 --> 00:42:52,800
So at the very even right off the bat, we're in trouble because the

806
00:42:52,800 --> 00:42:56,100
sine value creates obviously a problem for us.

807
00:42:56,800 --> 00:43:01,500
Now, the rest of this probably doesn't really create a problem for us

808
00:43:01,800 --> 00:43:07,100
because the exponent is the part that is the most important in terms

809
00:43:07,100 --> 00:43:12,300
of how, how much magnitude and number has, right?

810
00:43:12,300 --> 00:43:16,300
We're trying to sort these by magnitude in, you know, this is our Z

811
00:43:16,300 --> 00:43:16,500
value.

812
00:43:16,500 --> 00:43:17,100
Essentially, we're trying

813
00:43:17,300 --> 00:43:22,100
It effectively, ZZ magnitude for the most part, the exponent is the

814
00:43:22,100 --> 00:43:28,200
most important part that says, you know, two to the exponent here is

815
00:43:28,200 --> 00:43:33,100
exactly what we is exactly what we want to come first because the

816
00:43:33,100 --> 00:43:35,900
mantissa is actually the least important part, right?

817
00:43:35,900 --> 00:43:41,200
That's the like you know, one point, you know, some number thing here

818
00:43:41,300 --> 00:43:43,000
that's part of our scientific notation.

819
00:43:43,000 --> 00:43:46,700
It's this it's mantissa times 2 to the exponent, the to, to the

820
00:43:46,700 --> 00:43:47,100
exponents.

821
00:43:47,200 --> 00:43:50,100
Obviously, the most important part because the mantissa can only ever

822
00:43:50,100 --> 00:43:51,700
be one point something.

823
00:43:53,700 --> 00:43:54,200
Right?

824
00:43:54,900 --> 00:43:58,100
So this is already in a natural order and the mantissa part would just

825
00:43:58,100 --> 00:44:01,000
work sorting by the mantissa would just work because the higher the

826
00:44:01,000 --> 00:44:03,800
value their, the higher, the value is, and that's fine, right?

827
00:44:03,900 --> 00:44:06,100
So mantissa, we don't have to worry about those bits could actually

828
00:44:06,100 --> 00:44:09,300
stay exactly the same the exponent part.

829
00:44:09,300 --> 00:44:14,600
I think also just works and the reason that I think that part just

830
00:44:14,600 --> 00:44:18,200
works is because the exponent

831
00:44:19,800 --> 00:44:26,100
Is actually set up biased instead of being like - n2n.

832
00:44:26,100 --> 00:44:29,200
I believe the way that floating-point exponents are stored, our is

833
00:44:29,200 --> 00:44:35,200
they start at like 0 to 127 is considered - and like 128 to like you

834
00:44:35,200 --> 00:44:36,700
know I'm sorry.

835
00:44:37,600 --> 00:44:40,700
It's only seven bits of the I think this is only 7 B actually.

836
00:44:41,600 --> 00:44:45,800
So it's actually a 02 like 63 or something, right?

837
00:44:45,900 --> 00:44:49,000
And then 64 to 127 is positive.

838
00:44:50,500 --> 00:44:54,100
I believe that's how they're stored, which means that, I think the X1

839
00:44:54,100 --> 00:44:56,400
itself also goes in the proper order.

840
00:44:56,600 --> 00:44:59,400
Meaning, these are negative exponents, so they'll be very small

841
00:44:59,400 --> 00:44:59,800
numbers.

842
00:45:00,000 --> 00:45:02,300
These are positive exponents so they'll be larger numbers.

843
00:45:02,500 --> 00:45:05,400
So I believe exponent Plus mantissa.

844
00:45:06,500 --> 00:45:12,500
As B is actually probably fine meaning we can just we can just use

845
00:45:12,500 --> 00:45:13,200
that value.

846
00:45:13,300 --> 00:45:17,700
Its I think only the sign bit that actually would cause us a problem.

847
00:45:18,600 --> 00:45:22,800
I think right now.

848
00:45:22,800 --> 00:45:23,600
Let's take a look.

849
00:45:25,600 --> 00:45:26,800
And see what's going on here.

850
00:45:28,800 --> 00:45:32,800
If I break into what's going on, it's complaining that I didn't

851
00:45:32,800 --> 00:45:33,500
recompile.

852
00:45:33,500 --> 00:45:33,900
Okay.

853
00:45:33,900 --> 00:45:34,900
Well, here you go.

854
00:45:38,300 --> 00:45:40,800
If I stop, when it, when it gets confused here, right?

855
00:45:41,100 --> 00:45:42,500
And I take a look at the entry.

856
00:45:42,500 --> 00:45:44,200
So how many entries are there?

857
00:45:44,700 --> 00:45:47,100
There's, there's not very many right.

858
00:45:47,100 --> 00:45:52,400
There's only eight entries and here is a are

859
00:45:56,500 --> 00:45:57,400
Let's see what we've got.

860
00:45:57,400 --> 00:45:59,600
So, here are my values.

861
00:45:59,900 --> 00:46:03,300
I'm not quite certain that looks.

862
00:46:04,400 --> 00:46:05,800
Busted to me.

863
00:46:05,900 --> 00:46:07,200
Does it not as that?

864
00:46:07,300 --> 00:46:08,300
Is that right?

865
00:46:08,600 --> 00:46:09,500
What's going on there?

866
00:46:11,000 --> 00:46:13,400
I wonder if we wonder if I've got a bug in there.

867
00:46:13,400 --> 00:46:14,400
Let's take a look here.

868
00:46:17,000 --> 00:46:19,400
Are those really the values that are got entered in?

869
00:46:21,300 --> 00:46:21,900
Let's see.

870
00:46:21,900 --> 00:46:23,500
So, here are my entries.

871
00:46:23,500 --> 00:46:24,800
I've only got one.

872
00:46:25,000 --> 00:46:30,400
There is my entry, okay, so that's just some some giant number.

873
00:46:30,600 --> 00:46:32,300
Let me, let me try to get some more.

874
00:46:32,300 --> 00:46:35,800
I want something that's going to have more entries here.

875
00:46:37,300 --> 00:46:40,400
That's the count value, right?

876
00:46:40,400 --> 00:46:40,700
Here we go.

877
00:46:40,900 --> 00:46:44,500
Sorry, I got to stop down the Radix, sort.

878
00:46:45,000 --> 00:46:45,300
All right.

879
00:46:45,300 --> 00:46:45,800
So let me see.

880
00:46:45,800 --> 00:46:48,300
I want to get something where we've got like that.

881
00:46:48,300 --> 00:46:50,200
Ate, those eight values there.

882
00:46:50,200 --> 00:46:50,600
There we go.

883
00:46:50,600 --> 00:46:51,500
So 43.

884
00:46:53,200 --> 00:46:57,000
All right, so, let me take a look at my 43 values before I go weeks,

885
00:46:57,000 --> 00:46:58,200
or what do they look like?

886
00:46:58,700 --> 00:47:04,400
So, here's all my values for some reason, they're all - right, and I

887
00:47:04,400 --> 00:47:07,300
guess that's just some kind of artifact of how we're passing them in.

888
00:47:07,300 --> 00:47:08,600
But I guess that's okay.

889
00:47:08,700 --> 00:47:09,200
I'm not sure.

890
00:47:09,200 --> 00:47:15,000
I understand why they are so I guess they're because they're further

891
00:47:15,000 --> 00:47:16,100
down, I don't know.

892
00:47:16,600 --> 00:47:19,100
It's a little bit weird, but we have to think about why our sort keys

893
00:47:19,100 --> 00:47:19,600
are what they are.

894
00:47:19,600 --> 00:47:22,900
It doesn't matter point being we can see them and they're all

895
00:47:23,400 --> 00:47:23,900
Right.

896
00:47:24,600 --> 00:47:29,800
So, you know, Radix, sort and Theory should be totally wrong for how

897
00:47:29,800 --> 00:47:30,400
that works.

898
00:47:30,400 --> 00:47:35,800
In theory, I would think although that weirdly did exactly the right

899
00:47:35,800 --> 00:47:36,300
thing.

900
00:47:37,500 --> 00:47:40,100
so, the sign bit,

901
00:47:41,900 --> 00:47:44,700
The sign bit should have made that happen wrong.

902
00:47:44,700 --> 00:47:46,000
Oh no, it wouldn't.

903
00:47:46,000 --> 00:47:51,500
I guess, because the sign bits always on for all of them but yeah,

904
00:47:51,500 --> 00:47:54,800
well, no, that's still be wrong because which they should have come

905
00:47:54,800 --> 00:47:56,000
out in the opposite order.

906
00:47:56,400 --> 00:47:57,400
Should they not have

907
00:47:59,500 --> 00:47:59,800
I feel.

908
00:48:00,000 --> 00:48:04,000
He should have come out with the 457 at the bottom, right?

909
00:48:05,700 --> 00:48:06,800
I don't know about that.

910
00:48:10,000 --> 00:48:11,300
How did it do it, right?

911
00:48:11,500 --> 00:48:12,900
I feel like it should have done it wrong.

912
00:48:14,500 --> 00:48:17,800
I'm very confused by that, but I'll go take a look and find out why

913
00:48:21,400 --> 00:48:22,900
That's just really unusual.

914
00:48:24,200 --> 00:48:25,300
We're Not Unusual.

915
00:48:25,500 --> 00:48:26,900
It's just not what I expected.

916
00:48:27,700 --> 00:48:28,900
So let's try that one more time.

917
00:48:30,300 --> 00:48:34,700
Okay, so here we are stopping at a Radix sort that didn't work

918
00:48:34,700 --> 00:48:40,200
properly and here are, it's a, it's an eight long one.

919
00:48:40,600 --> 00:48:41,700
And so, here they are.

920
00:48:41,700 --> 00:48:44,400
And, yeah, they're just like, totally not correct.

921
00:48:44,700 --> 00:48:45,200
Right?

922
00:48:45,800 --> 00:48:51,000
So, again, this is what I would have expected more, I guess.

923
00:48:51,900 --> 00:48:53,000
but,

924
00:48:55,200 --> 00:48:56,100
But I don't know.

925
00:48:56,400 --> 00:48:56,900
Oh,

926
00:48:59,000 --> 00:49:04,100
Maybe it's just because yet you know what I I'm not actually just

927
00:49:04,100 --> 00:49:05,100
casting.

928
00:49:06,300 --> 00:49:11,000
This is what I probably should be doing if I just want to cast to a

929
00:49:11,000 --> 00:49:14,900
you 32 and if that was actually converting it, so that would have

930
00:49:14,900 --> 00:49:17,200
actually just gotten rid of the floating-point part.

931
00:49:17,700 --> 00:49:21,800
So that's that's why I was just forgot that we weren't actually

932
00:49:22,200 --> 00:49:24,200
looking at the bits yet if that makes sense.

933
00:49:25,000 --> 00:49:31,200
So now it's doing what I what I would have expected, right?

934
00:49:31,300 --> 00:49:34,500
Which is that it's not actually sorting these things at all correctly,

935
00:49:34,500 --> 00:49:35,100
right?

936
00:49:35,300 --> 00:49:35,900
Which is here.

937
00:49:36,100 --> 00:49:38,000
We go for 31 values.

938
00:49:38,400 --> 00:49:45,000
So like - 532 is at the end, that's really the smallest number but

939
00:49:45,000 --> 00:49:50,700
because it thinks the sign bit is effectively is one when the number

940
00:49:50,700 --> 00:49:52,300
is higher in zero and snot.

941
00:49:52,400 --> 00:49:58,200
We end up in a situation where we, we have the sort of that sign.

942
00:49:58,200 --> 00:49:59,700
Bit confounding, the sort.

943
00:49:59,800 --> 00:50:02,700
If the sound it wasn't set, we would be totally fine.

944
00:50:02,800 --> 00:50:03,100
Right.

945
00:50:03,100 --> 00:50:05,900
If for, for positive floating Point numbers, this would just

946
00:50:06,000 --> 00:50:06,400
Twerk.

947
00:50:07,800 --> 00:50:10,400
But unfortunately, we don't have that option.

948
00:50:10,800 --> 00:50:14,500
So really what we would want to do here is we want to turn this into

949
00:50:14,800 --> 00:50:21,800
a, we'd want to turn this into a 32 bit number that properly reflected

950
00:50:21,800 --> 00:50:22,700
the sign bit.

951
00:50:22,700 --> 00:50:26,900
So I guess what you would do here is say, well, you know, if the sign

952
00:50:26,900 --> 00:50:33,000
bit you can imagine saying if result and 0 X8, right?

953
00:50:36,700 --> 00:50:41,600
This is if we have the sign bit set, otherwise we don't, right?

954
00:50:42,300 --> 00:50:44,800
And I believe what we could do is say well,

955
00:50:49,200 --> 00:50:52,600
If the sign bit wasn't set.

956
00:50:54,100 --> 00:50:58,400
then these things will just sort correctly, but we need to make room

957
00:50:58,400 --> 00:50:59,500
for having

958
00:51:00,900 --> 00:51:03,400
For that - piece, right?

959
00:51:04,400 --> 00:51:08,500
So I might say, all right, if the sign bit wasn't set,

960
00:51:09,800 --> 00:51:11,000
Like if the sign bit.

961
00:51:13,100 --> 00:51:15,000
Was not set, set it.

962
00:51:17,100 --> 00:51:19,900
So positive values get their sign bit set.

963
00:51:20,700 --> 00:51:21,300
Right?

964
00:51:21,900 --> 00:51:27,100
- values need to go like in the opposite order because the bigger the

965
00:51:27,100 --> 00:51:30,000
number, the more - it is, right?

966
00:51:30,600 --> 00:51:36,000
So essentially what we want to do is like invert the meaning of the

967
00:51:36,000 --> 00:51:37,500
bits, right?

968
00:51:37,500 --> 00:51:42,100
We want to do like a subtract effectively, that will do like a carry,

969
00:51:42,200 --> 00:51:43,000
I guess.

970
00:51:43,600 --> 00:51:45,700
So that the numbers flip around.

971
00:51:46,900 --> 00:51:50,300
This is probably not the most efficient way to do this at all but

972
00:51:50,300 --> 00:51:54,400
again I'm just trying to figure out something that would work, right?

973
00:51:55,000 --> 00:52:03,000
So I need in this case when the sign bit is set I need some way of

974
00:52:03,000 --> 00:52:09,900
making the numbers go in the opposite order so that like you know 01

975
00:52:10,200 --> 00:52:12,300
comes before 10 right?

976
00:52:12,300 --> 00:52:13,600
Like in other words,

977
00:52:15,200 --> 00:52:21,300
Normally in binary, if I've got, you know, 0, 0, 0, 1, 1 0 1.

978
00:52:21,300 --> 00:52:25,900
1, as the order things are sorting in, I need them to go the opposite

979
00:52:25,900 --> 00:52:26,400
way.

980
00:52:26,600 --> 00:52:34,400
So that instead I get 1 1 1 0 0, 1 0 0 is the actual sort order now,

981
00:52:34,700 --> 00:52:35,300
right?

982
00:52:44,200 --> 00:52:47,700
So, I wonder if can I just literally flip the bits?

983
00:52:48,400 --> 00:52:49,200
Is it like that?

984
00:52:49,200 --> 00:52:49,700
Simple?

985
00:52:54,000 --> 00:52:55,600
I mean does that just work?

986
00:52:58,200 --> 00:53:01,500
It seems like it might I mean I'd have to think about whether I can

987
00:53:01,500 --> 00:53:05,000
really prove that that's true, but in other words, if that sign bit is

988
00:53:05,000 --> 00:53:08,400
set, can I just can I just

989
00:53:09,700 --> 00:53:12,000
Facts or the value, right?

990
00:53:12,000 --> 00:53:15,900
Can I just X or the value and just flip all the bits in it?

991
00:53:19,000 --> 00:53:22,400
Or rather just just set it to not itself.

992
00:53:25,700 --> 00:53:26,100
I don't know.

993
00:53:26,100 --> 00:53:29,000
Seems like that's too easy, so maybe I think I'm probably just totally

994
00:53:29,000 --> 00:53:29,600
missing something.

995
00:53:29,600 --> 00:53:34,400
But I'd be interested to see what that actually does.

996
00:53:34,400 --> 00:53:35,900
So let's step in here.

997
00:53:42,000 --> 00:53:44,400
We're is that there it is.

998
00:53:46,500 --> 00:53:49,700
So I'm going to step into each of them want to see what this does in

999
00:53:49,700 --> 00:53:50,400
each case.

1000
00:53:52,500 --> 00:53:53,100
All right.

1001
00:53:55,100 --> 00:53:59,800
so here's my result value and this is

1002
00:54:00,200 --> 00:54:02,300
A negative number, right?

1003
00:54:02,800 --> 00:54:06,200
So and this is like a negative number that has basically everything

1004
00:54:06,200 --> 00:54:06,800
set.

1005
00:54:07,400 --> 00:54:09,100
So, what, what is this value?

1006
00:54:09,100 --> 00:54:10,500
This must be a special case.

1007
00:54:10,500 --> 00:54:16,600
This must be like, one of those like, yeah, it's like the real

1008
00:54:16,600 --> 00:54:19,500
minimums, like, where the Clear goes, right?

1009
00:54:19,500 --> 00:54:20,900
I think that's what that value is.

1010
00:54:20,900 --> 00:54:23,400
It's like a clear, you know, clears want to sort all the way to the

1011
00:54:23,400 --> 00:54:24,200
back always.

1012
00:54:25,000 --> 00:54:26,900
So that's like the maximum value.

1013
00:54:26,900 --> 00:54:29,900
So, you know that I guess we

1014
00:54:30,000 --> 00:54:34,900
I won't learn anything from this but when we flip it, we get that

1015
00:54:35,400 --> 00:54:36,000
right.

1016
00:54:42,800 --> 00:54:44,200
Is that correct?

1017
00:54:49,800 --> 00:54:51,500
like I said, it's hard for you to think about

1018
00:54:54,200 --> 00:54:56,500
We're never going to know what this one because that's the oh it seems

1019
00:54:56,500 --> 00:54:58,400
to only appear by itself in most of these.

1020
00:54:59,200 --> 00:54:59,600
Let me

1021
00:55:05,300 --> 00:55:06,000
Let me see.

1022
00:55:12,600 --> 00:55:13,100
There we go.

1023
00:55:14,200 --> 00:55:16,600
So I'm just going to do a thing where I'm going to see if I can just

1024
00:55:16,600 --> 00:55:17,800
jump back in here.

1025
00:55:18,200 --> 00:55:19,200
Oh you know what I can do.

1026
00:55:21,800 --> 00:55:24,500
I think I can just do something where I

1027
00:55:30,000 --> 00:55:31,300
where I extract.

1028
00:55:31,400 --> 00:55:32,500
Yeah, this would be a good thing.

1029
00:55:32,800 --> 00:55:36,800
So I'm going to just extract the sort keys for some things that I know

1030
00:55:36,800 --> 00:55:38,700
what they are, right?

1031
00:55:39,100 --> 00:55:39,900
Meaning I'm going to go.

1032
00:55:39,900 --> 00:55:43,300
All right, tell me what the sort key.

1033
00:55:46,700 --> 00:55:51,200
Is for something that I'm going to just feed you to be like so I want

1034
00:55:51,200 --> 00:55:52,400
-1.0.

1035
00:55:53,400 --> 00:55:57,700
- 2 3 4 5 .5, right?

1036
00:56:06,200 --> 00:56:11,200
All right, so just some basic values and I want to see what this does

1037
00:56:12,300 --> 00:56:14,000
because like I said, I've never really done this before.

1038
00:56:14,000 --> 00:56:17,200
So I have no idea what the best thing to do is just want to explore it

1039
00:56:17,200 --> 00:56:19,500
and see what I get.

1040
00:56:19,700 --> 00:56:20,200
Right?

1041
00:56:20,800 --> 00:56:24,600
So there is a result, a result, be result, see result, D result, e.e.

1042
00:56:25,900 --> 00:56:26,600
results.

1043
00:56:27,200 --> 00:56:27,700
F

1044
00:56:30,200 --> 00:56:33,800
G h, i j.

1045
00:56:35,500 --> 00:56:35,900
Okay.

1046
00:56:37,800 --> 00:56:39,700
So here we go.

1047
00:56:39,700 --> 00:56:45,600
Result a is negative 1 and like you can see that it won't have the

1048
00:56:45,600 --> 00:56:47,700
high bit set so that's good.

1049
00:56:48,900 --> 00:56:52,600
This seems because we haven't done this yet.

1050
00:56:52,600 --> 00:56:53,100
There we go.

1051
00:56:55,100 --> 00:56:59,900
okay, so all these have the high bit set and they do go up by

1052
00:57:00,100 --> 00:57:02,000
Either way that I would have expected, right?

1053
00:57:02,200 --> 00:57:04,500
So result.

1054
00:57:07,000 --> 00:57:10,500
And then C then C 0 for C 0?

1055
00:57:10,500 --> 00:57:14,200
8, CB, so those those seem to go in order, right?

1056
00:57:14,300 --> 00:57:16,100
I mean that looks about right to me.

1057
00:57:18,900 --> 00:57:22,400
Yeah, I mean, that's, that's what I would expect.

1058
00:57:24,100 --> 00:57:28,900
Right, I don't see anything particularly odd about that.

1059
00:57:30,200 --> 00:57:31,600
We'll have to play around with it a little bit more.

1060
00:57:31,600 --> 00:57:39,000
But and then these guys for the negatives, negative one is properly

1061
00:57:39,000 --> 00:57:46,900
higher than negative 2 to the negative 3, lower than that - 4 - 5 .5,

1062
00:57:46,900 --> 00:57:47,900
lower still.

1063
00:57:48,300 --> 00:57:52,000
So that looks, you know, I'm probably missing something but that looks

1064
00:57:52,000 --> 00:57:53,700
like cursorily correct.

1065
00:57:55,100 --> 00:57:57,900
So let me see what my actual problem is here.

1066
00:57:59,800 --> 00:58:02,100
Where we start to get the assertion.

1067
00:58:03,000 --> 00:58:09,700
We've got in that case, 11 values and the entries.

1068
00:58:11,100 --> 00:58:12,800
For those 11 values.

1069
00:58:16,000 --> 00:58:18,700
Are still, so those are still going up.

1070
00:58:23,300 --> 00:58:26,400
Those are still going up in.

1071
00:58:30,600 --> 00:58:33,000
In the order, as if we hadn't fixed it.

1072
00:58:35,300 --> 00:58:36,100
Why is that?

1073
00:58:39,800 --> 00:58:41,000
Dare I ask.

1074
00:58:42,200 --> 00:58:44,900
We need to turn our 32 bit floating point value so I strictly sending

1075
00:58:44,900 --> 00:58:45,300
it through to.

1076
00:58:45,300 --> 00:58:46,600
Yes, that's true.

1077
00:58:47,300 --> 00:58:51,200
When the sign bit set, we flip the values.

1078
00:58:55,600 --> 00:58:56,900
So what does it think?

1079
00:58:56,900 --> 00:58:58,700
The sort keys are for these.

1080
00:59:00,000 --> 00:59:06,600
I pray tell sort key to you, 32 of - for 57.0.

1081
00:59:07,800 --> 00:59:09,400
And what is sort key to you.

1082
00:59:09,400 --> 00:59:15,000
32 of - 470, 7.0 and what is sort key to you.

1083
00:59:15,000 --> 00:59:18,200
32 of - 53 2.0,

1084
00:59:20,900 --> 00:59:26,900
So tell me it looks like our sort is just broken because tell me how

1085
00:59:26,900 --> 00:59:31,000
we sorted these in that order, if these are what the sort keys were.

1086
00:59:31,300 --> 00:59:37,000
So that looks actually like I just have a bug in the actual sort to

1087
00:59:37,000 --> 00:59:39,000
me, right?

1088
00:59:39,300 --> 00:59:42,200
Because those should not be in that order.

1089
00:59:44,700 --> 00:59:47,400
- 47 shouldn't come first, it's higher.

1090
00:59:48,600 --> 00:59:49,100
Right.

1091
00:59:49,900 --> 00:59:51,700
So what did I mess up there?

1092
00:59:51,900 --> 00:59:53,700
Why is it not?

1093
00:59:54,300 --> 00:59:55,800
Let's let's see.

1094
00:59:55,800 --> 00:59:59,800
Can we can we jump back here set next day?

1095
01:00:00,100 --> 01:00:01,900
Can I jump in here, possibly?

1096
01:00:04,100 --> 01:00:05,200
Let's find out.

1097
01:00:05,400 --> 01:00:10,700
So here is our source and we've got how many again 11.

1098
01:00:10,700 --> 01:00:13,300
So here's our source ears are dest.

1099
01:00:15,200 --> 01:00:15,700
Right.

1100
01:00:17,100 --> 01:00:17,800
There we are.

1101
01:00:18,400 --> 01:00:25,700
So if I come through here and I count my values, let me see, sort key

1102
01:00:25,900 --> 01:00:26,800
offsets,

1103
01:00:28,500 --> 01:00:33,800
Actually, I guess I don't super care about this quite yet, but let's

1104
01:00:33,800 --> 01:00:37,000
see Radix piece 255.

1105
01:00:46,600 --> 01:00:50,100
Yeah, that's that'll do it.

1106
01:00:51,100 --> 01:00:52,500
That would do it folks.

1107
01:00:53,600 --> 01:01:01,100
Notice that I'm shifting down by the B index, but yeah, not exactly

1108
01:01:01,100 --> 01:01:01,800
correct.

1109
01:01:01,800 --> 01:01:08,300
Is it, when the bite index is used as a bit shift

1110
01:01:10,000 --> 01:01:12,100
I'm not going to use a Flawless shame because we're in the middle of

1111
01:01:12,100 --> 01:01:16,000
debugging, but like that's a baby owl of Shame like, come on, like

1112
01:01:17,600 --> 01:01:18,200
Right.

1113
01:01:18,500 --> 01:01:19,700
I would I would say baby.

1114
01:01:19,700 --> 01:01:23,100
I love shame on that because I mean, seriously.

1115
01:01:24,200 --> 01:01:28,400
So yeah, I think we probably want to do maybe something more like

1116
01:01:28,400 --> 01:01:29,000
that.

1117
01:01:29,400 --> 01:01:31,700
So we'll actually do 8, 16 24.

1118
01:01:34,900 --> 01:01:36,700
Let's try this again.

1119
01:01:38,200 --> 01:01:40,100
Hey, look, it works now.

1120
01:01:40,600 --> 01:01:42,500
What a shocking surprise.

1121
01:01:44,400 --> 01:01:49,500
Yeah, anyway, so we are Radix.

1122
01:01:49,500 --> 01:01:56,100
Sorting are things now and that's all good, you know, no complaints

1123
01:01:56,100 --> 01:02:01,300
there and the Radix sort seems to be working nicely and so everyone is

1124
01:02:01,300 --> 01:02:03,900
happy and everything's fine.

1125
01:02:04,400 --> 01:02:06,900
Great, fantastic, good.

1126
01:02:08,000 --> 01:02:08,600
There we go.

1127
01:02:09,400 --> 01:02:09,900
All right.

1128
01:02:09,900 --> 01:02:10,700
So

1129
01:02:12,700 --> 01:02:13,900
That's our Radix sort.

1130
01:02:15,100 --> 01:02:20,000
Yeah, don't have a lot to say about it other than you asked for it.

1131
01:02:20,000 --> 01:02:23,900
You got it and that we got a little bit of time left for Q&A.

1132
01:02:23,900 --> 01:02:25,500
So we can go over to Q&A.

1133
01:02:27,200 --> 01:02:29,400
and if you have questions about the Radix sort,

1134
01:02:30,600 --> 01:02:32,900
I'm not going to promise that I can answer them, but

1135
01:02:33,800 --> 01:02:34,800
you're welcome to ask them.

1136
01:02:55,100 --> 01:02:55,600
Ratchet.

1137
01:02:55,600 --> 01:02:56,000
Freak.

1138
01:02:56,000 --> 01:02:58,400
Why didn't you build merge sort from the bottom up?

1139
01:03:00,100 --> 01:03:02,900
Well, because we didn't really get to the point where we're actually

1140
01:03:02,900 --> 01:03:05,500
trying to optimize one of these sorts yet that makes sense.

1141
01:03:06,800 --> 01:03:11,100
So it depends which one of these we actually want to do.

1142
01:03:11,600 --> 01:03:16,700
And to be honest, I don't really know if we decide that mergesort

1143
01:03:16,700 --> 01:03:20,500
should be the one we keep, then we would implement it so that it, you

1144
01:03:20,500 --> 01:03:25,300
know, does the minimum amount of work, but I don't know that it would

1145
01:03:25,300 --> 01:03:27,700
be since we bothered with a Radix sort.

1146
01:03:30,900 --> 01:03:33,600
I'm guessing that the Radix sort will end up being the one to use

1147
01:03:33,600 --> 01:03:36,900
because we'll have more than two hundred six elements.

1148
01:03:37,700 --> 01:03:42,500
Most of the time I mean I assume I don't know.

1149
01:03:56,700 --> 01:04:00,900
Fod 669 your Radix sort looks like it's 08 and because you're doing

1150
01:04:00,900 --> 01:04:02,200
two passes over the list.

1151
01:04:02,200 --> 01:04:02,700
/ B.

1152
01:04:02,700 --> 01:04:08,200
Couldn't you make it o5n by getting all the offsets counts in one pass

1153
01:04:08,500 --> 01:04:12,100
at the cost of three more 256 element arrays?

1154
01:04:13,100 --> 01:04:16,900
Yes I think.

1155
01:04:19,000 --> 01:04:20,100
I mean, here's the thing.

1156
01:04:21,400 --> 01:04:24,700
I'm not prepared to say whether something is a 10 or 5 n or anything

1157
01:04:24,700 --> 01:04:27,800
else because that's the Cs sort of stuff.

1158
01:04:28,100 --> 01:04:31,600
And, you know, you might say that well, but then you have to clear

1159
01:04:31,600 --> 01:04:33,800
this thing multiple times per something.

1160
01:04:33,800 --> 01:04:35,600
And so it's doing that many more rights.

1161
01:04:35,600 --> 01:04:38,400
So it doesn't matter, right?

1162
01:04:38,400 --> 01:04:43,600
I mean, I don't know, it's like,

1163
01:04:45,400 --> 01:04:48,300
Doing passes over the list.

1164
01:04:48,300 --> 01:04:52,200
Versus just this is why I think they don't put the constant in there

1165
01:04:52,600 --> 01:04:55,700
is because it's not really that relevant because doing passes over the

1166
01:04:55,700 --> 01:04:59,000
list versus doing more operations inside the loop.

1167
01:04:59,800 --> 01:05:03,700
You know, it's like it's sort of six of one half-dozen of the other.

1168
01:05:03,700 --> 01:05:06,500
In terms of what you'd actually say, the complexity of the algorithm

1169
01:05:06,500 --> 01:05:06,800
was.

1170
01:05:07,100 --> 01:05:12,200
So is it a potentially better to do this in terms, you know, of a

1171
01:05:14,000 --> 01:05:17,200
In terms of a performance thing for our purposes.

1172
01:05:17,200 --> 01:05:18,200
Probably, yes.

1173
01:05:19,000 --> 01:05:19,900
I would assume.

1174
01:05:20,100 --> 01:05:21,500
But then again, that's the sort of thing.

1175
01:05:21,500 --> 01:05:24,400
We would just have the time to figure out, is it something that

1176
01:05:24,400 --> 01:05:27,200
affects the complexity of the algorithm know?

1177
01:05:27,200 --> 01:05:30,200
Because it's n regardless that makes sense.

1178
01:06:20,600 --> 01:06:24,200
Elvin, of course jumps in with a horribly off topic question.

1179
01:06:25,800 --> 01:06:27,500
But he did Market with off-topic.

1180
01:06:29,300 --> 01:06:32,600
I'm a bit confused about axis angle rotations versus quaternion

1181
01:06:32,600 --> 01:06:37,100
rotations, I thought quaternions do represent an angle and axis of

1182
01:06:37,100 --> 01:06:37,700
rotation.

1183
01:06:38,100 --> 01:06:43,100
What's the difference, the answer is that all rotation representations

1184
01:06:43,100 --> 01:06:47,000
encode in Access in an angle because it acts as an angle is what

1185
01:06:47,000 --> 01:06:49,400
defines a rotation if that makes sense.

1186
01:06:51,700 --> 01:06:58,500
So, essentially the difference between all of the different rotation

1187
01:06:58,600 --> 01:07:02,200
representations is not whether they encode in acts as an angle.

1188
01:07:02,300 --> 01:07:03,200
It's how.

1189
01:07:04,300 --> 01:07:09,200
So, if you take a look at the common ones, right?

1190
01:07:09,500 --> 01:07:11,200
You've got Euler angles.

1191
01:07:13,300 --> 01:07:18,300
Or, you know, I it's very confusing because there's Euler angles,

1192
01:07:18,300 --> 01:07:20,200
which are like three angles, right?

1193
01:07:20,200 --> 01:07:22,900
Which is, which is like three things of rotation, you know.

1194
01:07:22,900 --> 01:07:25,800
First I rotate around one axis, then I rotate around another axis and

1195
01:07:25,800 --> 01:07:29,800
then I rotate around, you know, I gotta draw yet another axis.

1196
01:07:29,800 --> 01:07:30,200
There we go.

1197
01:07:31,700 --> 01:07:32,400
Yes, I'm learning.

1198
01:07:32,400 --> 01:07:34,600
Is this three-set sequential rotations?

1199
01:07:35,700 --> 01:07:37,300
Around three different, axes, right.

1200
01:07:38,600 --> 01:07:42,200
There's also things called Euler parameters, which are not the same

1201
01:07:42,200 --> 01:07:45,700
thing will ignore that for now.

1202
01:07:45,700 --> 01:07:48,400
But boiler or other parameters are actually more in the like

1203
01:07:48,400 --> 01:07:50,500
quaternion exponential map family of things.

1204
01:07:50,800 --> 01:07:56,300
But anyway, yes, that's like Euler angles which are encoding, the, the

1205
01:07:56,300 --> 01:08:01,600
rotation around like, like three different axes sequentially.

1206
01:08:01,600 --> 01:08:04,700
So I rotate around this axis, our return on that Axis or Taro this

1207
01:08:04,700 --> 01:08:05,100
axis,

1208
01:08:05,400 --> 01:08:10,600
But the result right is still some orientation that you could have got

1209
01:08:10,600 --> 01:08:16,100
to buy starting at wherever the, you know, at rest and rotating by

1210
01:08:16,100 --> 01:08:18,600
some angle around some axis.

1211
01:08:19,000 --> 01:08:24,300
So this is the encoding but the result is still a single rotation

1212
01:08:24,300 --> 01:08:27,300
around a single axis because all row two orientations can be

1213
01:08:27,300 --> 01:08:28,800
represented that way, right?

1214
01:08:29,300 --> 01:08:32,500
So then we've got something like, you know, axis angle

1215
01:08:34,300 --> 01:08:37,200
And that's where I have, you know, like oh and we could, I don't know

1216
01:08:37,200 --> 01:08:40,399
what these are normally, they're like fada fee and something.

1217
01:08:40,399 --> 01:08:44,000
I don't even know what this guy normally is, you know, Omega, I don't

1218
01:08:44,000 --> 01:08:44,200
know.

1219
01:08:44,899 --> 01:08:45,600
Whatever he is.

1220
01:08:46,500 --> 01:08:49,000
So the Euler angles are three scalars, right?

1221
01:08:49,100 --> 01:08:52,700
Axis angle is typically, you know, I've got something like this.

1222
01:08:54,100 --> 01:08:56,100
Right, maybe I'll write it this way.

1223
01:08:57,700 --> 01:08:59,800
So access angle is like, you know, I've got an A

1224
01:09:00,000 --> 01:09:01,200
The rotation and angle.

1225
01:09:01,300 --> 01:09:04,700
So here, I just directly encode it exactly what it is.

1226
01:09:06,100 --> 01:09:09,300
And like I said, any orientation can be encoded that way, but you

1227
01:09:09,300 --> 01:09:13,300
know, this close includes explicitly quaternion.

1228
01:09:15,399 --> 01:09:17,000
Is again, just another encoding.

1229
01:09:17,200 --> 01:09:22,200
So, instead of a Theta and an XYZ, in this case, I've got instead,

1230
01:09:22,899 --> 01:09:27,600
I've got sine of half the angle times the X sine of half the angle

1231
01:09:27,600 --> 01:09:33,000
times, the Y, sine of half the angle times the Z, and then cosine of

1232
01:09:33,000 --> 01:09:33,899
half the angle.

1233
01:09:36,200 --> 01:09:37,800
In the W, right?

1234
01:09:38,000 --> 01:09:41,300
So here you can kind of see it's actually sort of a composite form.

1235
01:09:41,300 --> 01:09:46,300
It's actually a thing where I've got a vector, it's got its got the

1236
01:09:46,300 --> 01:09:48,399
cosine of half the angle in the bottom.

1237
01:09:48,600 --> 01:09:53,600
It's got the sine of half the angle in the top times that axis of

1238
01:09:53,600 --> 01:09:55,100
rotation, right?

1239
01:09:55,100 --> 01:09:57,000
So these two are the same thing.

1240
01:09:57,700 --> 01:10:01,400
These two are the same thing but we just we actually did some trig.

1241
01:10:01,400 --> 01:10:03,700
We divide it by 2 and did some trig on it, right?

1242
01:10:03,900 --> 01:10:05,600
So the encoding for quaternion

1243
01:10:05,700 --> 01:10:06,700
Less Direct.

1244
01:10:06,700 --> 01:10:08,400
There's a lot I could talk for very long.

1245
01:10:08,400 --> 01:10:08,900
Time about why?

1246
01:10:08,900 --> 01:10:09,500
That's true.

1247
01:10:09,500 --> 01:10:13,800
I'm not going to do that right now but there's reasons why they do

1248
01:10:13,800 --> 01:10:18,000
that, obviously, they don't just do it for fun and then there's the

1249
01:10:18,000 --> 01:10:20,700
exponential map, right?

1250
01:10:23,200 --> 01:10:26,900
Exponential map is just a direct multiplication of axis angle.

1251
01:10:27,000 --> 01:10:31,100
If I remember correctly, I believe that's true because I believe,

1252
01:10:31,100 --> 01:10:33,600
exponential map yet exponential map.

1253
01:10:33,600 --> 01:10:34,200
It's been a long time.

1254
01:10:34,200 --> 01:10:36,900
So I represent things exponential, map is sort of the same as

1255
01:10:36,900 --> 01:10:38,300
instantaneous velocity.

1256
01:10:41,900 --> 01:10:43,000
Angular velocity.

1257
01:10:44,500 --> 01:10:49,400
So it's just literally like some angle times, the vector, so it's a

1258
01:10:49,400 --> 01:10:50,800
vector that looks like this.

1259
01:10:52,800 --> 01:10:57,000
Right, I directly scale the vector by the amount of rotation that I

1260
01:10:57,000 --> 01:10:57,900
wanted to do.

1261
01:10:59,400 --> 01:11:01,500
And so again that's like this.

1262
01:11:06,600 --> 01:11:07,400
So, it's a vector.

1263
01:11:07,400 --> 01:11:08,600
That's a multiplication of these.

1264
01:11:08,600 --> 01:11:10,200
Again, these are the same.

1265
01:11:10,300 --> 01:11:11,800
These are the same.

1266
01:11:12,300 --> 01:11:16,100
So again, still its axis angle all the way through.

1267
01:11:16,100 --> 01:11:18,000
It's just which encoding you're using.

1268
01:11:21,000 --> 01:11:23,600
That's, that's really all I have to say about it.

1269
01:11:23,600 --> 01:11:24,200
I guess.

1270
01:11:26,600 --> 01:11:27,200
So yeah.

1271
01:11:29,000 --> 01:11:31,900
All of the encoding is, are different in the sense that they encode,

1272
01:11:31,900 --> 01:11:32,700
different numeric values.

1273
01:11:32,700 --> 01:11:35,400
But they are all orientation.

1274
01:11:35,900 --> 01:11:41,500
And in orientation is always, can always be thought of as an axis and

1275
01:11:41,500 --> 01:11:44,600
an angle of rotation around, that make sense.

1276
01:11:54,200 --> 01:11:56,700
So far as I noticed, the frame times are growing quite large now.

1277
01:11:56,700 --> 01:11:59,100
Are you planning to optimize the software under further or switch to a

1278
01:11:59,100 --> 01:11:59,800
hardware-accelerated?

1279
01:12:00,000 --> 01:12:08,700
Aim, I'm not sure they're still totally do usable for development so I

1280
01:12:08,700 --> 01:12:09,800
don't super care.

1281
01:12:10,800 --> 01:12:17,600
I'm not sure what the frame rate difference is if I turn again, I

1282
01:12:17,600 --> 01:12:23,000
don't remember what the actual performances for if I turn it down to

1283
01:12:23,000 --> 01:12:24,400
low res, right?

1284
01:12:24,800 --> 01:12:28,100
So if I say Where's that stuff?

1285
01:12:28,900 --> 01:12:34,100
If I decide to run in a half or quarter res mode, right?

1286
01:12:39,800 --> 01:12:44,300
And I, and I also turn off our debug stuff.

1287
01:12:47,800 --> 01:12:51,500
I'm not sure what the feel is of the game.

1288
01:12:54,500 --> 01:12:57,400
So yeah, so I probably would not optimized further.

1289
01:12:57,400 --> 01:13:01,100
I just run in low-res it for now, right?

1290
01:13:01,700 --> 01:13:06,000
Because that's super Zippy and totally fine for

1291
01:13:07,200 --> 01:13:08,000
Making the game.

1292
01:13:10,200 --> 01:13:11,200
How much is that?

1293
01:13:11,200 --> 01:13:16,200
How much of that does the debug system suck up in terms of time here?

1294
01:13:16,200 --> 01:13:17,300
Probably law, huh?

1295
01:13:18,400 --> 01:13:19,100
And actually, no.

1296
01:13:20,200 --> 01:13:21,200
That's not too bad.

1297
01:13:22,800 --> 01:13:26,100
So basically yeah if we just if we just are willing to go and low-res

1298
01:13:26,400 --> 01:13:30,200
then we don't have a problem so so I think I can find with that for a

1299
01:13:30,200 --> 01:13:30,600
while.

1300
01:13:33,600 --> 01:13:36,100
Alrighty, let's see.

1301
01:13:36,300 --> 01:13:38,700
Any other questions?

1302
01:13:57,000 --> 01:13:58,400
Think we're good.

1303
01:14:13,600 --> 01:14:14,300
All right.

1304
01:14:14,600 --> 01:14:17,100
Well, no further questions.

1305
01:14:17,800 --> 01:14:19,800
Then I will shut down the stream.

1306
01:14:20,800 --> 01:14:21,300
We go.

1307
01:14:23,300 --> 01:14:24,400
And I'll save this.

1308
01:14:31,400 --> 01:14:33,400
All right, thanks everyone for joining me for another episode of

1309
01:14:33,400 --> 01:14:34,200
handmade hero.

1310
01:14:34,300 --> 01:14:35,300
It's been a pleasure coding with you.

1311
01:14:35,300 --> 01:14:40,000
As always, we have pretty much finished our sorting, we just gonna

1312
01:14:40,000 --> 01:14:44,900
have to decide which one to keep, and I don't even know if we have to

1313
01:14:44,900 --> 01:14:45,200
do that.

1314
01:14:45,200 --> 01:14:49,100
Now all of them work we could save that for some time when we're

1315
01:14:49,100 --> 01:14:52,300
profiling and have a lot more enemies on the screen.

1316
01:14:52,900 --> 01:14:54,500
So hey we wrote them all there in there.

1317
01:14:54,500 --> 01:14:58,900
Now some point we can optimize them if we so choose or even write an

1318
01:14:58,900 --> 01:14:59,800
entirely different sort.

1319
01:15:00,100 --> 01:15:03,200
Now that we know what we're doing, but that means tomorrow, I think we

1320
01:15:03,200 --> 01:15:04,200
should probably move on to something new.

1321
01:15:04,200 --> 01:15:06,300
I don't see any real reason to belabor the point.

1322
01:15:06,800 --> 01:15:10,200
I think you guys all get it by now and you kind of see how sorting

1323
01:15:10,200 --> 01:15:10,400
works.

1324
01:15:10,400 --> 01:15:13,300
It's not a huge deal at the end of the day and I don't think it's

1325
01:15:13,300 --> 01:15:16,900
going to be a significant part of our running performance anyway.

1326
01:15:17,500 --> 01:15:22,200
But if it does become so such, then we will obviously be able to take

1327
01:15:22,200 --> 01:15:23,000
care of that.

1328
01:15:23,000 --> 01:15:25,100
Now that we kind of know what what our options are.

1329
01:15:25,900 --> 01:15:28,800
So that's it, if you're would like to follow along with series at

1330
01:15:28,800 --> 01:15:34,200
home, obviously, you can go ahead and pre-order the game on Hamid org

1331
01:15:34,200 --> 01:15:36,300
and it comes to the source code, even right as we speak.

1332
01:15:36,300 --> 01:15:39,600
So you can play around with at home and follow the episodes on your

1333
01:15:39,600 --> 01:15:39,900
own.

1334
01:15:40,600 --> 01:15:42,800
We also have a forum site where you can ask questions, we have a

1335
01:15:42,800 --> 01:15:46,100
patreon page, you can spread the video series and we have a tweetbot

1336
01:15:46,100 --> 01:15:50,000
that we'd schedule at you and that tree pot right now, we'll be

1337
01:15:50,000 --> 01:15:50,500
tweeting it.

1338
01:15:50,500 --> 01:15:53,400
You that we will be back here live tomorrow at 5 p.m.

1339
01:15:53,400 --> 01:15:55,500
Pacific Standard time to move on.

1340
01:15:55,700 --> 01:15:59,100
To our next thing, which I don't know what it's going to be because we

1341
01:15:59,100 --> 01:16:02,900
only have a few things left to do really before we Implement our

1342
01:16:02,900 --> 01:16:04,000
actual game game.

1343
01:16:05,900 --> 01:16:08,000
Which, of course, is the part that's terrifying because I'm not a game

1344
01:16:08,000 --> 01:16:09,200
designer, so that's going to be rough.

1345
01:16:09,200 --> 01:16:09,800
But

1346
01:16:12,100 --> 01:16:13,300
God, you at some point.

1347
01:16:13,400 --> 01:16:17,300
So anyway, until tomorrow, I hope all of you have fun programming.

1348
01:16:17,300 --> 01:16:19,100
I'm I will see you on the internet.

1349
01:16:19,200 --> 01:16:20,100
Take it easy, everyone.

