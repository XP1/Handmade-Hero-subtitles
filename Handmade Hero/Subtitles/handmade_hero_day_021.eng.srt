1
00:00:00,600 --> 00:00:01,600
A clean record.

2
00:00:02,300 --> 00:00:03,100
Alright.

3
00:00:03,400 --> 00:00:06,600
Hello everyone, and welcome to handmade hero.

4
00:00:06,600 --> 00:00:10,700
The show where we code a complete game live on Twitch from scratch.

5
00:00:11,000 --> 00:00:11,900
No engine.

6
00:00:11,900 --> 00:00:12,700
No libraries.

7
00:00:12,700 --> 00:00:13,300
No, nothing.

8
00:00:13,800 --> 00:00:16,800
Just we can learn basically everything that is involved in the

9
00:00:16,800 --> 00:00:20,800
complete sort of software stack of a game all the way down to the

10
00:00:20,800 --> 00:00:24,300
hardware, which I think is actually really important and is becoming a

11
00:00:24,300 --> 00:00:25,800
little bit more of a lost art these days.

12
00:00:25,800 --> 00:00:28,300
So this product kind of attempt to bring that back to basically have

13
00:00:28,300 --> 00:00:30,200
everything there from start to finish.

14
00:00:30,400 --> 00:00:34,700
Anyone who wants to really study, how games work through the entire

15
00:00:35,100 --> 00:00:38,400
pipeline, through the entire code base, have the opportunity to do so.

16
00:00:38,400 --> 00:00:41,000
And I think it's really great to just in general for everyone to kind

17
00:00:41,000 --> 00:00:42,400
of be aware of this sort of stuff.

18
00:00:42,400 --> 00:00:42,700
I know.

19
00:00:42,700 --> 00:00:46,000
It certainly, makes it much easier for me to do any kind of work that

20
00:00:46,000 --> 00:00:46,800
I'm doing on games.

21
00:00:46,800 --> 00:00:49,400
Whether it happens to be using libraries or happens to be using

22
00:00:49,400 --> 00:00:51,500
engines or not, because you can always go in there and fix stuff.

23
00:00:51,500 --> 00:00:53,400
You can debug so much more effectively.

24
00:00:53,400 --> 00:00:56,600
You can know when something is suspicious, just when you have sort of

25
00:00:56,600 --> 00:01:00,100
that that kind of, that kind of full background, so that's what we're

26
00:01:00,100 --> 00:01:00,200
doing.

27
00:01:00,300 --> 00:01:00,600
Doing here.

28
00:01:00,600 --> 00:01:03,700
And we have basically finished sort of our prototyping layer.

29
00:01:03,700 --> 00:01:08,100
We made a win32 layer the past couple weeks so that we can basically

30
00:01:08,600 --> 00:01:12,300
do all of our own stuff right on top of Windows without having to use

31
00:01:12,300 --> 00:01:13,200
any libraries or anything.

32
00:01:13,200 --> 00:01:14,900
And it's pretty basic at this point.

33
00:01:14,900 --> 00:01:19,200
It does basic sound output and basic bitmap output, but it and also it

34
00:01:19,200 --> 00:01:23,800
does basic input from user devices, like keyboards and gamepads.

35
00:01:23,900 --> 00:01:26,800
And that's really everything that we need to get a game up and

36
00:01:26,800 --> 00:01:27,100
running.

37
00:01:27,100 --> 00:01:30,200
So that's exactly what we're going to start doing here, but I felt

38
00:01:30,200 --> 00:01:30,200
like

39
00:01:30,400 --> 00:01:34,100
Like we had done a bunch of the hard work of like, picking through

40
00:01:34,100 --> 00:01:37,100
windows and like dealing with all of its apis to do stuff.

41
00:01:37,500 --> 00:01:40,100
And really, we were just doing that in order to get sound output bit

42
00:01:40,100 --> 00:01:42,800
but map output and input into the thing.

43
00:01:42,800 --> 00:01:47,900
And so what I thought would be nice to do tonight is to do something

44
00:01:47,900 --> 00:01:50,600
fun with the windows API to kind of show.

45
00:01:50,600 --> 00:01:54,000
Like, okay, when you're down there and you're doing crazy stuff, you

46
00:01:54,000 --> 00:01:55,700
can actually do some cool things.

47
00:01:55,700 --> 00:01:59,000
If you've done all of this yourself, and so what I wanted to show is

48
00:01:59,000 --> 00:02:00,000
kind of like an

49
00:02:00,300 --> 00:02:03,100
Example of something pretty cool you can do and it's going to be an

50
00:02:03,100 --> 00:02:08,900
example of sort of something very useful to a game developer.

51
00:02:09,400 --> 00:02:14,400
So if you are following along at home here on day 21, if you have

52
00:02:14,400 --> 00:02:16,800
purchased the source code, using this handy, dandy pre-order button

53
00:02:16,800 --> 00:02:21,700
here on handmade hero dot-org, you will get a link in your email, that

54
00:02:22,100 --> 00:02:23,100
should have allowed you to.

55
00:02:23,100 --> 00:02:25,500
Basically there's a link that comes when you pre-order the game and

56
00:02:25,500 --> 00:02:27,100
that will always allow you to download the source code.

57
00:02:27,100 --> 00:02:29,300
So save that link go there.

58
00:02:29,500 --> 00:02:30,100
And there should

59
00:02:30,300 --> 00:02:34,800
A day 20 zip file inside the source code ZIP.

60
00:02:34,800 --> 00:02:36,600
If you unzip that one, that is the source code.

61
00:02:36,600 --> 00:02:37,200
We're starting with.

62
00:02:37,200 --> 00:02:40,700
So look for day 20 because every day we start with the previous day's

63
00:02:40,700 --> 00:02:41,200
source code.

64
00:02:41,200 --> 00:02:44,300
So if you unzip that into a directory, you will have exactly the same

65
00:02:44,300 --> 00:02:45,400
source code that I am starting with now.

66
00:02:45,400 --> 00:02:48,300
So you can follow along at home, which I know a lot of people like to

67
00:02:48,300 --> 00:02:48,600
do.

68
00:02:49,100 --> 00:02:54,300
So, let's go ahead in there and we have some stuff.

69
00:02:54,400 --> 00:02:57,400
We have a few issues that I have my notebook that I want to address

70
00:02:57,400 --> 00:02:59,800
from previous day's, but right now, I'm just going to go ahead.

71
00:03:00,000 --> 00:03:01,300
This will get to them in the Q&A.

72
00:03:01,300 --> 00:03:03,700
So I'm going to go ahead and jump right into like new stuff.

73
00:03:04,000 --> 00:03:05,400
Sort of the fun stuff I want to do.

74
00:03:05,400 --> 00:03:05,800
So.

75
00:03:06,100 --> 00:03:06,400
All right.

76
00:03:06,400 --> 00:03:10,000
So basically, one of the things that people often ask me, in fact,

77
00:03:10,000 --> 00:03:14,900
they ask me this multiple times on the sort of about handmade hero.

78
00:03:15,300 --> 00:03:17,600
They basically say, like, are you going to implement a scripting

79
00:03:17,600 --> 00:03:18,200
language?

80
00:03:18,300 --> 00:03:20,100
This is asked this has been asked many times.

81
00:03:23,200 --> 00:03:25,300
Or more specifically, I suppose are you going to use a scripting

82
00:03:25,300 --> 00:03:25,800
language?

83
00:03:26,300 --> 00:03:28,300
And the answer is no, of course, we're not going to use a scripting

84
00:03:28,300 --> 00:03:31,000
language, but the question of whether or not we were going to build a

85
00:03:31,000 --> 00:03:31,700
scripting language.

86
00:03:31,700 --> 00:03:34,400
Well that would still be making something from scratch so we could

87
00:03:34,400 --> 00:03:36,800
decide to build our own scripting language if we want to but we have

88
00:03:36,800 --> 00:03:37,400
to ask ourselves.

89
00:03:37,400 --> 00:03:42,200
The question is building a scripting language really all that great.

90
00:03:42,200 --> 00:03:43,900
I of an idea right?

91
00:03:44,300 --> 00:03:47,100
And in order to know whether it's a great idea not you have to kind of

92
00:03:47,100 --> 00:03:48,500
stop and ask yourself.

93
00:03:49,200 --> 00:03:52,300
What do you think you're going to use this scripting language for?

94
00:03:53,000 --> 00:03:58,200
And is it going to provide more benefits to you versus the downsides

95
00:03:58,200 --> 00:03:59,200
of the scripting language has?

96
00:03:59,200 --> 00:04:01,600
And of course, scripting languages have a lot of downsides that maybe

97
00:04:01,600 --> 00:04:05,500
people don't realize right away, one of which is performance problems.

98
00:04:05,600 --> 00:04:08,600
Because remember if you implement a scripting language, you are also

99
00:04:08,600 --> 00:04:11,400
on the hook for ensuring that that scripting language is performant,

100
00:04:11,400 --> 00:04:13,900
which may mean that you have to use just in time compilation or all

101
00:04:13,900 --> 00:04:15,100
these other sorts of things that order.

102
00:04:15,100 --> 00:04:17,300
If you know, if a significant amount of your game is written in the

103
00:04:17,300 --> 00:04:20,300
scripting language, you're on the hook for that performance, and

104
00:04:20,300 --> 00:04:22,200
that's something you have to be aware of, right?

105
00:04:22,600 --> 00:04:22,800
It's

106
00:04:22,900 --> 00:04:25,500
Not like see where, you know, how to optimize it and you've already

107
00:04:25,500 --> 00:04:29,000
got tools to profile it in all these and optimizing compiler there to

108
00:04:29,000 --> 00:04:29,700
back you up.

109
00:04:29,800 --> 00:04:30,400
It's not like that.

110
00:04:30,400 --> 00:04:33,200
When you're using a scripting language, you're on your own right.

111
00:04:33,600 --> 00:04:35,400
And similarly with scripting languages.

112
00:04:35,400 --> 00:04:36,800
You have to ask yourself.

113
00:04:36,800 --> 00:04:37,900
What you going to do about debugging.

114
00:04:37,900 --> 00:04:39,800
Do you have a debugger for the scripting language or you going to

115
00:04:39,800 --> 00:04:41,000
write one yourself?

116
00:04:41,100 --> 00:04:42,600
Are you going to use some third-party one?

117
00:04:42,600 --> 00:04:44,900
And will that integrate properly with the debugger for the platform

118
00:04:44,900 --> 00:04:45,500
that you're using?

119
00:04:45,500 --> 00:04:47,800
Or you going to have to constantly ping-pong back and forth between

120
00:04:47,800 --> 00:04:48,300
the buggers?

121
00:04:48,400 --> 00:04:50,000
There's all sorts of things that could go wrong.

122
00:04:50,000 --> 00:04:52,800
And so when you're talking about implementing a scripting language,

123
00:04:53,000 --> 00:04:55,000
A huge number of costs that go with it.

124
00:04:55,300 --> 00:04:58,000
And so you have to be very aware of those costs that doesn't

125
00:04:58,000 --> 00:05:00,800
necessarily mean that you shouldn't do it, but it does mean, you have

126
00:05:00,800 --> 00:05:04,500
to think very hard about whether or not it's a good decision for

127
00:05:04,500 --> 00:05:07,100
handmade hero since we're doing everything from scratch.

128
00:05:07,300 --> 00:05:09,700
I think it's kind of a no-brainer that it would be a bad decision.

129
00:05:09,700 --> 00:05:12,000
Because we're certainly not going to want to take the time to write a

130
00:05:12,000 --> 00:05:13,900
debugger, for the scripting language and an Optimizer for the

131
00:05:13,900 --> 00:05:15,800
scripting language, compiler from schedule, a all blah, blah, blah

132
00:05:15,800 --> 00:05:16,100
blah, blah.

133
00:05:16,100 --> 00:05:19,600
All the things we have to do to do a really good job of using the

134
00:05:19,600 --> 00:05:20,600
scripting language in a game.

135
00:05:20,600 --> 00:05:22,800
We're not they do those things because that would take

136
00:05:22,900 --> 00:05:24,800
A huge amount of time, out of learning stuff.

137
00:05:24,800 --> 00:05:27,500
We want to learn, which is more about how to write the game code.

138
00:05:27,500 --> 00:05:31,000
And so given that, that's the case.

139
00:05:31,000 --> 00:05:35,300
I would then say well, okay, what are the reasons why people might

140
00:05:35,300 --> 00:05:36,400
want a scripting language.

141
00:05:36,400 --> 00:05:37,700
Like, what is a scripting language?

142
00:05:37,700 --> 00:05:40,100
Good for y, or do they even think they need it?

143
00:05:40,100 --> 00:05:44,500
And can we just go ahead and get those benefits without having to do

144
00:05:44,500 --> 00:05:45,900
all of the work, right?

145
00:05:45,900 --> 00:05:50,200
So I think one of the primary benefits of the scripting language is

146
00:05:50,200 --> 00:05:52,600
that people perceive it to be easier to write things in a scripting

147
00:05:52,600 --> 00:05:52,800
language.

148
00:05:53,700 --> 00:05:56,500
I don't really know necessarily where that comes from so much because

149
00:05:56,500 --> 00:05:58,800
I think it's actually pretty easy to write things and see if you make

150
00:05:58,800 --> 00:05:59,900
the API to it.

151
00:06:00,600 --> 00:06:02,500
So, I don't think we're going to have too much trouble writing, our

152
00:06:02,500 --> 00:06:03,200
game code in C.

153
00:06:03,200 --> 00:06:05,200
I think we're probably going to be fine with that.

154
00:06:05,600 --> 00:06:08,600
But one of the other things that people often point to in scripting

155
00:06:08,600 --> 00:06:10,200
languages, that's a benefit.

156
00:06:10,300 --> 00:06:12,800
Is the fact that we can do things, like, edit the scripting language

157
00:06:12,800 --> 00:06:13,600
while the game is running.

158
00:06:13,600 --> 00:06:13,700
Now.

159
00:06:13,700 --> 00:06:17,300
This is a pretty big bonus in a lot of cases, because if you can edit

160
00:06:17,300 --> 00:06:19,700
the scripting language, while the game is running, you can tune

161
00:06:19,700 --> 00:06:21,000
variables live on the Fly.

162
00:06:21,000 --> 00:06:24,700
You don't have to try to, you know, exit recompile.

163
00:06:24,700 --> 00:06:27,800
Go back into the game that sort of thing and you can also do stuff

164
00:06:27,800 --> 00:06:29,800
like, well, if you're trying to debug the behavior of a boss,

165
00:06:30,000 --> 00:06:30,500
Boss monster.

166
00:06:30,500 --> 00:06:33,300
You can just go in there, you know, get when you get to the boss

167
00:06:33,300 --> 00:06:34,500
monster and see this not working.

168
00:06:34,500 --> 00:06:35,200
You can just right there.

169
00:06:35,200 --> 00:06:38,000
Pop up the scripts or editing and see what the boss monster does and

170
00:06:38,000 --> 00:06:38,300
change it.

171
00:06:38,300 --> 00:06:41,000
Not stuff and it saves you from having to make a whole bunch of

172
00:06:41,000 --> 00:06:44,300
scaffolding to allow you to like exit the game change some pasta

173
00:06:44,300 --> 00:06:46,900
master code, jump back into the game, jump straight to the boss.

174
00:06:46,900 --> 00:06:49,300
Monster actually deal with the stuff.

175
00:06:49,300 --> 00:06:50,500
They're look see how it went.

176
00:06:50,500 --> 00:06:50,700
Go.

177
00:06:50,700 --> 00:06:51,600
Okay, it did work.

178
00:06:51,600 --> 00:06:52,900
Jump back out, blah, blah, blah.

179
00:06:53,600 --> 00:06:56,400
So there's kind of a lot of stuff there where it's like that ability

180
00:06:56,400 --> 00:06:59,800
to just use to edit the code, right?

181
00:07:00,000 --> 00:07:01,600
All of the game is pretty valuable.

182
00:07:01,600 --> 00:07:03,000
Actually, that's a pretty big thing.

183
00:07:03,400 --> 00:07:06,300
And so, there is something you can do there, right?

184
00:07:06,300 --> 00:07:08,300
You can inside Dev studio, right?

185
00:07:08,300 --> 00:07:11,400
If I open up Dev Studio, there's a thing called edit and continue,

186
00:07:12,000 --> 00:07:12,500
right?

187
00:07:12,500 --> 00:07:15,400
Which allows you to edit stuff inside, Deb through, you can set a

188
00:07:15,400 --> 00:07:15,900
breakpoint.

189
00:07:15,900 --> 00:07:18,400
You can edit some stuff and you can have it recompile.

190
00:07:18,900 --> 00:07:22,500
And that works for some very limited cases, like unfortunately a lot

191
00:07:22,500 --> 00:07:24,200
of the time and it continued doesn't really work.

192
00:07:24,200 --> 00:07:26,400
Like if you're writing tons of new functions, and if you're actually

193
00:07:26,400 --> 00:07:29,500
trying to really write new code edit and continue doesn't work.

194
00:07:29,500 --> 00:07:29,800
It's usually

195
00:07:29,900 --> 00:07:32,700
For small changes is the only thing that is really reliable for

196
00:07:33,000 --> 00:07:34,300
otherwise it mostly just breaks.

197
00:07:34,600 --> 00:07:37,500
So editing continue isn't really a good solution, but it's sort of

198
00:07:37,500 --> 00:07:38,400
like what we would want.

199
00:07:38,400 --> 00:07:38,600
Right?

200
00:07:38,600 --> 00:07:41,300
What we'd like to be able to do is just kind of go like, all right,

201
00:07:41,300 --> 00:07:43,100
the games running and we have the C code.

202
00:07:43,100 --> 00:07:45,600
We want to just be able to edit the C code and have the game just keep

203
00:07:45,600 --> 00:07:46,000
on running.

204
00:07:46,000 --> 00:07:46,600
Right?

205
00:07:47,100 --> 00:07:51,700
So the question is well, could we basically Implement our own version

206
00:07:51,900 --> 00:07:53,200
of edit and continue, right?

207
00:07:53,200 --> 00:07:57,900
Like is there some way that we could go ahead and do that where we

208
00:07:57,900 --> 00:07:59,800
actually don't have to worry, you know?

209
00:08:00,000 --> 00:08:05,100
We basically don't have to care about visual C++ and whether it can do

210
00:08:05,100 --> 00:08:07,100
whatever it's supposed to be doing with this compilation step.

211
00:08:07,100 --> 00:08:11,900
Could we actually make it so that we have what amounts to our own sort

212
00:08:11,900 --> 00:08:14,000
of relatively foolproof editing continue.

213
00:08:14,800 --> 00:08:16,800
And so what I'm going to do tonight is, I'm basically going to try to

214
00:08:16,800 --> 00:08:17,500
implement that.

215
00:08:17,500 --> 00:08:19,600
I'm going to try to implant a way where we can basically have our game

216
00:08:19,600 --> 00:08:23,000
running, change the code live, and not have to restart the game to see

217
00:08:23,000 --> 00:08:23,700
the results.

218
00:08:24,100 --> 00:08:26,900
And just basically, let us kind of go from there and we'll see how far

219
00:08:26,900 --> 00:08:29,300
we can get towards that goal, basically.

220
00:08:30,000 --> 00:08:31,300
And I think that's kind of fun.

221
00:08:31,300 --> 00:08:34,400
So I said tonight, Scott kind of time to do something fun rather than

222
00:08:34,500 --> 00:08:37,100
spending all our time, doing stuff, just to get Windows, sort of as a

223
00:08:37,100 --> 00:08:37,900
conduit working.

224
00:08:38,100 --> 00:08:41,200
Let's see if we can actually use Windows to help us now to make

225
00:08:41,200 --> 00:08:42,200
something pretty cool.

226
00:08:42,900 --> 00:08:45,300
So the first thing that I want to do is go.

227
00:08:45,300 --> 00:08:45,700
All right.

228
00:08:45,700 --> 00:08:49,300
Well, what I know about the way that I've set up the game because I

229
00:08:49,300 --> 00:08:52,600
think I've architected it pretty well is basically I've got this sort

230
00:08:52,600 --> 00:08:54,900
of platform independent part here, right?

231
00:08:55,200 --> 00:08:56,700
That's going to hold all of the game code.

232
00:08:56,700 --> 00:08:59,300
It's going to hold that stuff that I want to be able to edit on the

233
00:08:59,300 --> 00:08:59,600
Fly.

234
00:08:59,700 --> 00:08:59,900
and then,

235
00:09:00,000 --> 00:09:02,500
Gotta win 32 portion, which is separate.

236
00:09:03,100 --> 00:09:06,600
So, the first thing that I'm going to want to do is I'm going to say,

237
00:09:06,600 --> 00:09:10,200
well, could I in just split those two things apart?

238
00:09:10,200 --> 00:09:12,300
So that we basically have one part.

239
00:09:12,300 --> 00:09:15,100
That's the, the platform code that's compiled separately.

240
00:09:15,100 --> 00:09:18,500
And one part that is the platform, not zip code that's compiled

241
00:09:18,500 --> 00:09:21,600
separately and then maybe, you know, just merge them together and, you

242
00:09:21,600 --> 00:09:23,000
know, can I do that in some way?

243
00:09:23,000 --> 00:09:28,300
That doesn't Force us to unload to to kill the executable, and you've

244
00:09:28,300 --> 00:09:29,800
already basically scene.

245
00:09:30,000 --> 00:09:31,900
The answer to this question is yes, right?

246
00:09:31,900 --> 00:09:33,900
Because you've already seen that.

247
00:09:33,900 --> 00:09:38,900
We have a thing here, which is basically the load Library.

248
00:09:39,000 --> 00:09:41,400
I don't know if you remember when we were talking about this kind of a

249
00:09:41,400 --> 00:09:42,100
while back.

250
00:09:42,300 --> 00:09:45,300
We have the ability to load code out of a library already.

251
00:09:45,300 --> 00:09:46,600
Dynamically, right?

252
00:09:46,800 --> 00:09:48,800
We can basically pass a file name.

253
00:09:48,900 --> 00:09:50,800
That's one of these dll things, right?

254
00:09:50,800 --> 00:09:53,100
That's something that that Windows is implemented.

255
00:09:53,100 --> 00:09:56,800
We can load that in, we can call get proc address on it.

256
00:09:56,800 --> 00:09:57,200
Right.

257
00:09:57,200 --> 00:09:59,500
And get proc address will give us a pointer to a function that's in

258
00:09:59,500 --> 00:09:59,900
there and

259
00:10:00,000 --> 00:10:01,500
We can just call the function.

260
00:10:01,800 --> 00:10:02,400
Right?

261
00:10:03,000 --> 00:10:07,900
So if we want to do that, we could just do that with our own code.

262
00:10:08,100 --> 00:10:11,800
So there's really no reason why I couldn't instead of compiling this

263
00:10:11,800 --> 00:10:14,400
monolithically, as one translation unit.

264
00:10:14,400 --> 00:10:17,700
I just compiled it as two separate translation units, one for the

265
00:10:17,700 --> 00:10:21,100
platform code 14, the platform independent code, right?

266
00:10:21,400 --> 00:10:23,100
And that platform independent piece of code.

267
00:10:23,100 --> 00:10:27,700
I didn't just load as if it's a dll, I call into it, to do, whatever

268
00:10:27,700 --> 00:10:28,900
it is, I needed to do.

269
00:10:29,200 --> 00:10:29,800
And then

270
00:10:29,900 --> 00:10:33,900
When when I want to refresh it, if I feel like it's needs to be

271
00:10:33,900 --> 00:10:34,600
reloaded.

272
00:10:34,600 --> 00:10:36,100
I can just close it.

273
00:10:36,100 --> 00:10:38,900
I can just Free Library, which is the corresponding call it to load

274
00:10:38,900 --> 00:10:39,200
Library.

275
00:10:39,200 --> 00:10:43,700
I can just free that library and reload the new freshly compiled code

276
00:10:43,900 --> 00:10:45,700
and I don't have to kill my executable.

277
00:10:45,700 --> 00:10:46,300
Right?

278
00:10:46,600 --> 00:10:48,400
I mean, it should just work.

279
00:10:48,800 --> 00:10:53,700
So the reason that this is simple is because as you know, we're

280
00:10:53,700 --> 00:10:56,100
basically passing in the game memory as a chunk.

281
00:10:56,100 --> 00:10:58,300
Now, I've said a couple times at there's a lot of good reasons to do

282
00:10:58,300 --> 00:10:58,500
this.

283
00:10:58,500 --> 00:10:59,800
Well, this is a big one of them.

284
00:11:00,100 --> 00:11:03,800
Since we're passing in all of the game memory, the game itself is not

285
00:11:03,800 --> 00:11:04,100
input.

286
00:11:04,100 --> 00:11:06,800
The, the get, the actual game code is never actually doing anything

287
00:11:06,800 --> 00:11:07,300
with memory.

288
00:11:07,600 --> 00:11:10,800
So if we just keep, if we just hold on to that game every which we've

289
00:11:10,800 --> 00:11:13,400
allocated, we pass it to the dll when it needs to run.

290
00:11:13,700 --> 00:11:16,500
We can unload that dll and we still have all the memory.

291
00:11:16,500 --> 00:11:20,100
So if we then reload another dll, that's a new version of the game

292
00:11:20,100 --> 00:11:20,400
code.

293
00:11:20,400 --> 00:11:22,200
We can just call into that and pass it.

294
00:11:22,200 --> 00:11:25,200
The same exact memory that the previous dll was using and poof.

295
00:11:25,200 --> 00:11:27,000
It'll just go ahead and keep running in there.

296
00:11:27,100 --> 00:11:27,200
Now.

297
00:11:27,200 --> 00:11:29,300
There's a couple caveats of times when it doesn't.

298
00:11:29,900 --> 00:11:33,000
Allow you to do that because depending on what your change in the C++

299
00:11:33,000 --> 00:11:36,800
code, but for now, that's a pretty easy way to Envision a very simple

300
00:11:36,800 --> 00:11:38,400
way to make this work.

301
00:11:38,400 --> 00:11:42,900
So, what I'm going to do here is I'm just going to change our build up

302
00:11:42,900 --> 00:11:45,200
at a very, very tiny amount, right?

303
00:11:45,300 --> 00:11:48,600
Basically, instead of compiling this, this 64-bit, instead of

304
00:11:48,600 --> 00:11:50,500
compiling it this way.

305
00:11:50,600 --> 00:11:52,700
I'm Ashley going to compile two different things.

306
00:11:52,900 --> 00:11:56,100
I'm going to compile the handmade dot CPP.

307
00:11:56,200 --> 00:11:59,000
I'm going to compile that, and I'm going to compile the win32,

308
00:11:59,000 --> 00:11:59,800
handmade.

309
00:12:00,000 --> 00:12:00,700
Dot CPP.

310
00:12:00,700 --> 00:12:02,600
Exactly like that.

311
00:12:02,700 --> 00:12:06,900
So basically what happens here is inside this where we have this sort

312
00:12:06,900 --> 00:12:07,600
of stuff here.

313
00:12:07,600 --> 00:12:08,100
Right?

314
00:12:08,700 --> 00:12:13,700
I'm effectively going to start to bifurcate these two code paths,

315
00:12:13,700 --> 00:12:14,200
right?

316
00:12:14,200 --> 00:12:16,900
I'm going to go ahead and take into handmade here.

317
00:12:16,900 --> 00:12:21,400
O.h., I'm going to go ahead and pull the things that we actually had

318
00:12:21,400 --> 00:12:22,900
pound to find out here, right?

319
00:12:22,900 --> 00:12:24,900
I'm going to pull those into here like this.

320
00:12:25,300 --> 00:12:28,400
So now I've basically got a should keep that at the top, so they're

321
00:12:28,400 --> 00:12:28,600
not.

322
00:12:28,600 --> 00:12:29,600
I've kind of got those out there.

323
00:12:29,600 --> 00:12:29,800
This

324
00:12:30,000 --> 00:12:33,800
Guy is still going to look at handmade .h, right?

325
00:12:34,400 --> 00:12:36,400
This this guy still going to have to look at that.

326
00:12:36,400 --> 00:12:38,400
It's going to need to see a couple of these things.

327
00:12:38,400 --> 00:12:39,000
Right?

328
00:12:39,300 --> 00:12:44,100
But now the it's no longer going to include this handmade dot CPP

329
00:12:44,100 --> 00:12:44,700
anymore.

330
00:12:44,800 --> 00:12:45,800
That's not going to happen.

331
00:12:45,800 --> 00:12:50,300
So instead, handmade dot CPP is only going to happen inside actual

332
00:12:50,300 --> 00:12:51,200
handmade dot CPP.

333
00:12:51,200 --> 00:12:52,400
So it's going to be compiled separately.

334
00:12:52,400 --> 00:12:55,600
We're not going to like pound include the CPP file into win32

335
00:12:55,600 --> 00:12:56,300
handmade.

336
00:12:56,300 --> 00:12:56,600
Right?

337
00:12:56,600 --> 00:12:57,300
Does that make sense?

338
00:12:57,900 --> 00:12:59,700
So then all I need to do in my building.

339
00:13:00,100 --> 00:13:01,600
And there's a couple of things we're going to have to do here.

340
00:13:01,600 --> 00:13:04,400
But basically all I have to do my hammer in my hand made here at I bet

341
00:13:04,400 --> 00:13:06,800
it's figure out my build up that I should say.

342
00:13:06,800 --> 00:13:11,100
It's I have to figure out what to pass to this seal thing to build.

343
00:13:11,100 --> 00:13:14,100
One of these dlls, one of those dlls that we were loading before.

344
00:13:14,400 --> 00:13:18,400
Basically the compiler has the ability to build dlls as well as well

345
00:13:18,400 --> 00:13:21,400
as link with them and so on, like we were doing where we can import

346
00:13:21,400 --> 00:13:22,600
libraries and doing stuff like that.

347
00:13:22,600 --> 00:13:25,200
It has the ability to build dlls itself.

348
00:13:25,200 --> 00:13:28,500
So, what I really want to do is just make it so that I can build that

349
00:13:28,500 --> 00:13:29,600
dll as well.

350
00:13:30,300 --> 00:13:33,200
And so, what I have to do there is, I believe it.

351
00:13:33,200 --> 00:13:35,200
I think it's a pretty straightforward.

352
00:13:35,200 --> 00:13:39,800
So actually, I believe it's just a dll switch to the Linker.

353
00:13:40,100 --> 00:13:42,300
It's been a long time since I passed it, but I'm pretty sure there's

354
00:13:42,300 --> 00:13:43,300
almost nothing to it.

355
00:13:43,300 --> 00:13:45,200
It's like, yeah, it's just that / dll.

356
00:13:45,700 --> 00:13:48,400
I believe that's a pretty much almost almost the entirety of all.

357
00:13:48,400 --> 00:13:50,100
We're going to have to do so /.

358
00:13:50,100 --> 00:13:55,300
Dll there, I think is all we're going to have to do and I don't think

359
00:13:55,300 --> 00:13:57,800
we're really gonna have to do anything else.

360
00:13:57,800 --> 00:13:59,700
We don't actually even need

361
00:14:00,500 --> 00:14:04,400
Most of those other Libs there as because, because really, in fact, we

362
00:14:04,400 --> 00:14:05,900
don't really need any of this stuff.

363
00:14:05,900 --> 00:14:08,500
None of these common Linker flags are actually relevant to us.

364
00:14:08,500 --> 00:14:11,700
I think all we actually need is the / dll.

365
00:14:11,700 --> 00:14:14,300
So let's go ahead and take a look at what that does first.

366
00:14:14,300 --> 00:14:17,300
Just so I can see what's going on here.

367
00:14:17,300 --> 00:14:17,900
All right.

368
00:14:18,200 --> 00:14:20,600
These guys are no longer internal.

369
00:14:20,600 --> 00:14:21,100
Obviously.

370
00:14:21,100 --> 00:14:25,400
These are actual linkage calls will have to deal with that in a second

371
00:14:25,400 --> 00:14:25,700
here.

372
00:14:26,400 --> 00:14:27,300
Let's see here.

373
00:14:27,500 --> 00:14:29,800
So we gotta get rid of that because they're actually going to be

374
00:14:29,900 --> 00:14:30,200
boarded.

375
00:14:30,200 --> 00:14:32,400
This is the first time we'll ever have an exported function.

376
00:14:33,100 --> 00:14:33,800
Let's take a look.

377
00:14:33,800 --> 00:14:36,400
We've got those are not.

378
00:14:36,400 --> 00:14:36,900
Yes, right.

379
00:14:36,900 --> 00:14:37,800
These are the calls.

380
00:14:37,800 --> 00:14:41,000
These are our calls back back into it.

381
00:14:41,000 --> 00:14:42,000
Let's see here you go.

382
00:14:42,000 --> 00:14:43,400
Platform, read entire file.

383
00:14:43,800 --> 00:14:46,300
So these are no longer internal either.

384
00:14:47,000 --> 00:14:50,300
Those are going to be like that and there we go.

385
00:14:50,500 --> 00:14:51,200
Alright.

386
00:14:51,700 --> 00:14:55,900
So now, I think besides having are unresolved externals.

387
00:14:55,900 --> 00:14:57,900
I think we're in pretty good shape here.

388
00:14:58,500 --> 00:14:59,800
Let's take a look at our error.

389
00:15:00,000 --> 00:15:03,900
Win32 handmade as well because we were expecting, link are errors that

390
00:15:03,900 --> 00:15:06,100
we're going to deal with a second, explain how to do with those.

391
00:15:06,100 --> 00:15:08,100
It's like, if I just want to take a look at these.

392
00:15:08,100 --> 00:15:09,000
Let's see here.

393
00:15:09,800 --> 00:15:11,100
We've got right.

394
00:15:11,100 --> 00:15:12,300
These are no longer internal.

395
00:15:12,300 --> 00:15:15,500
These are called externally, although that's not really true.

396
00:15:15,500 --> 00:15:16,700
Well, we'll see you in a second.

397
00:15:16,700 --> 00:15:19,100
What we do with those, those are probably premature.

398
00:15:19,200 --> 00:15:19,700
All right.

399
00:15:19,800 --> 00:15:23,100
So basically, all I did was I just split the code into two compilation

400
00:15:23,100 --> 00:15:23,300
units.

401
00:15:23,300 --> 00:15:26,700
As you can see, there's basically places where they called each other

402
00:15:26,700 --> 00:15:29,200
game, update, and render, and game set, and get sound samples.

403
00:15:29,400 --> 00:15:29,800
And then the

404
00:15:30,000 --> 00:15:33,000
The debug read free file memory, right?

405
00:15:33,000 --> 00:15:35,700
Entire file, and, and read entire file.

406
00:15:36,000 --> 00:15:39,000
These are basically the places where our two halves of our code called

407
00:15:39,000 --> 00:15:39,500
each other.

408
00:15:39,600 --> 00:15:41,900
And so, as you can see, now that we're compiling them separately.

409
00:15:41,900 --> 00:15:46,000
We just get a bunch of liquor errors that tell us, you know, I can't

410
00:15:46,000 --> 00:15:47,200
resolve the stuff anymore.

411
00:15:47,200 --> 00:15:48,500
You're calling stuff.

412
00:15:48,500 --> 00:15:50,800
That doesn't exist in the translation, you know, I don't know where to

413
00:15:50,800 --> 00:15:51,900
find it and that's an error.

414
00:15:52,600 --> 00:15:55,000
So, we have to do, is figure out ways to resolve these.

415
00:15:55,000 --> 00:15:58,500
Now, the the to where the platform layer calls the game.

416
00:15:58,500 --> 00:15:59,900
I just said how we can do that.

417
00:16:00,300 --> 00:16:02,200
That's really straightforward for us to resolve.

418
00:16:02,200 --> 00:16:06,100
We're going to treat it just like we treated xinput, where we're going

419
00:16:06,100 --> 00:16:07,800
to load library and do that kind of stuff.

420
00:16:07,800 --> 00:16:10,900
You can see here, where we basically have sort of these get proc

421
00:16:10,900 --> 00:16:12,100
addresses, this sort of stuff.

422
00:16:12,300 --> 00:16:13,800
That's all we really need to do.

423
00:16:13,800 --> 00:16:17,500
So really, all we need to do here is basically do something where we

424
00:16:17,500 --> 00:16:21,600
go win32, load game code, or something like this.

425
00:16:22,000 --> 00:16:25,300
And all we're going to do with that is we're just going to do that.

426
00:16:25,300 --> 00:16:28,900
Load library and ropes will call this handmade dot DL.

427
00:16:28,900 --> 00:16:29,800
For now we can

428
00:16:29,900 --> 00:16:34,500
Obviously, play with that a little bit later, handmade code or because

429
00:16:34,500 --> 00:16:37,100
call this game code or game code.

430
00:16:37,100 --> 00:16:37,700
Dll.

431
00:16:37,700 --> 00:16:44,000
If that actually works, then we will try to do get proc addresses on

432
00:16:44,000 --> 00:16:49,200
it and those get proc address calls will give us the pointers to those

433
00:16:49,200 --> 00:16:50,800
exported functions that we wanted.

434
00:16:50,800 --> 00:16:52,300
So basically, we're in here.

435
00:16:53,000 --> 00:16:55,800
You can see, we've got game update and render and get sound samples.

436
00:16:56,100 --> 00:16:56,300
All.

437
00:16:56,300 --> 00:16:59,700
I'm going to do now is do the exact same trick we did.

438
00:17:00,000 --> 00:17:00,500
X input.

439
00:17:00,500 --> 00:17:02,400
It's going to be literally exactly the same.

440
00:17:02,400 --> 00:17:04,400
It's this, this exact stuff right here.

441
00:17:04,500 --> 00:17:04,900
Nothing.

442
00:17:05,000 --> 00:17:06,099
Nothing else do it.

443
00:17:06,200 --> 00:17:12,300
So all I'm going to do is basically say there is a game update and

444
00:17:12,300 --> 00:17:16,099
render and that takes a name and it is exactly this function prototype

445
00:17:16,099 --> 00:17:17,599
that we had here before.

446
00:17:18,000 --> 00:17:21,200
So I'm just going to go ahead and make that like this.

447
00:17:21,700 --> 00:17:25,800
Then I will make a typedef for it just like I did before and this will

448
00:17:25,800 --> 00:17:29,800
be called game update.

449
00:17:29,900 --> 00:17:34,700
8 and render, and then I will make a stub for it, just like I did

450
00:17:34,700 --> 00:17:35,300
before.

451
00:17:35,400 --> 00:17:38,400
So, this will be game update.

452
00:17:38,500 --> 00:17:42,800
Oops, game update and render stub.

453
00:17:42,900 --> 00:17:45,300
And of course, that doesn't need to actually return anything.

454
00:17:45,800 --> 00:17:46,700
So, that's it.

455
00:17:47,300 --> 00:17:51,200
That's really all I need to do there and we don't actually even need a

456
00:17:51,200 --> 00:17:52,200
global variable for it.

457
00:17:52,200 --> 00:17:55,300
I don't think we might do something slightly different than that.

458
00:17:55,300 --> 00:17:57,600
So, I'm going to, I'm going to delete those, those do not need to be

459
00:17:57,600 --> 00:17:57,800
there.

460
00:17:57,800 --> 00:17:59,800
So, this is the entirety of what we

461
00:18:00,000 --> 00:18:02,500
To do there and we'll get rid of that like that.

462
00:18:02,600 --> 00:18:03,000
Okay.

463
00:18:03,200 --> 00:18:04,100
So we're going to do that.

464
00:18:04,100 --> 00:18:06,700
And then the other thing that we're going to do is we're going to do

465
00:18:06,700 --> 00:18:08,300
the same thing for get sound samples.

466
00:18:08,300 --> 00:18:09,400
So get sound samples.

467
00:18:09,400 --> 00:18:14,100
Again, will be a game, get sound samples, and this will take a name

468
00:18:14,300 --> 00:18:17,200
and then we're just going to use exact same function prototype that we

469
00:18:17,200 --> 00:18:18,400
were using before for game.

470
00:18:18,400 --> 00:18:24,400
Get sound samples only now, it'll do this and then I will do a typedef

471
00:18:24,400 --> 00:18:24,800
of it.

472
00:18:24,800 --> 00:18:26,500
Did I remember to remove the semicolon there?

473
00:18:26,500 --> 00:18:29,000
No, I did not doesn't really matter, but I want to get rid of it

474
00:18:29,000 --> 00:18:29,400
anyway.

475
00:18:30,000 --> 00:18:31,000
Just to be cleaner.

476
00:18:31,000 --> 00:18:33,100
You can have more than one semicolon at the end of the line.

477
00:18:33,100 --> 00:18:35,900
It doesn't seem that anyone really cares a lot of the time, but just,

478
00:18:35,900 --> 00:18:37,600
you know, just to keep it a little cleaner.

479
00:18:38,300 --> 00:18:42,000
So this is game get sound samples, right?

480
00:18:42,300 --> 00:18:45,200
And then I'm going to do a game, get sound samples.

481
00:18:46,500 --> 00:18:48,900
Oops, get sound samples stuff.

482
00:18:51,700 --> 00:18:52,800
So that's really about it.

483
00:18:53,000 --> 00:18:57,400
Then what I would like to do because I don't see any reason why not?

484
00:18:57,400 --> 00:18:59,800
Is I would like to then say, well,

485
00:19:00,500 --> 00:19:04,100
We're going to do so, there's a couple different ways that I could

486
00:19:04,100 --> 00:19:04,600
have done this.

487
00:19:04,600 --> 00:19:07,700
In fact, you know what, maybe I'll do this slightly even a little bit

488
00:19:07,700 --> 00:19:08,300
differently.

489
00:19:08,700 --> 00:19:12,700
Instead of having stubs for these since, I don't actually really need

490
00:19:12,700 --> 00:19:12,900
this stuff.

491
00:19:12,900 --> 00:19:13,800
Well, yeah.

492
00:19:14,300 --> 00:19:14,800
It's a little

493
00:19:19,000 --> 00:19:20,400
It's a tough call.

494
00:19:20,500 --> 00:19:21,300
Really is.

495
00:19:21,700 --> 00:19:22,200
But you know what?

496
00:19:22,200 --> 00:19:22,800
I think I'm going to.

497
00:19:22,800 --> 00:19:23,900
I'm thinking to do one more.

498
00:19:23,900 --> 00:19:29,700
I think I'm just going to go one more, and I'm going to do game get

499
00:19:30,300 --> 00:19:30,900
functions.

500
00:19:31,000 --> 00:19:34,400
Let's say called game get functions and basically game get functions

501
00:19:34,400 --> 00:19:37,000
is just going to be something that basically returns its functions

502
00:19:37,000 --> 00:19:37,300
else.

503
00:19:37,300 --> 00:19:37,900
Do I need?

504
00:19:38,500 --> 00:19:41,500
You know, I do I'm gonna have to its I'm conflicted.

505
00:19:41,500 --> 00:19:44,500
You can hear it in my voice, you know, it's true, but I'm not I was

506
00:19:44,500 --> 00:19:46,300
going to try a different way and I just wasn't sure.

507
00:19:46,300 --> 00:19:48,800
I can't quite tell exactly which one I want but I'm gonna

508
00:19:48,900 --> 00:19:50,300
Stick with the one that I was really doing.

509
00:19:50,500 --> 00:19:51,500
So we're going to do it that way.

510
00:19:52,000 --> 00:19:53,600
And that means that inside here.

511
00:19:53,700 --> 00:19:57,200
I'm also going to go ahead and say that game get sound samples is

512
00:19:57,200 --> 00:20:00,700
actually going to be one of these now, right?

513
00:20:01,000 --> 00:20:02,000
So that's that.

514
00:20:02,400 --> 00:20:05,400
So that will automatically Define that for us and game update and

515
00:20:05,400 --> 00:20:08,000
render is also going to be one of those.

516
00:20:08,000 --> 00:20:08,900
So there we go.

517
00:20:09,500 --> 00:20:10,200
Like that.

518
00:20:10,800 --> 00:20:14,900
And we may have a little bit of funkiness that we have to do there as

519
00:20:14,900 --> 00:20:15,300
well.

520
00:20:15,500 --> 00:20:16,500
That'll tell you about the second.

521
00:20:16,500 --> 00:20:18,800
But yeah, so now hopefully we

522
00:20:18,900 --> 00:20:21,500
Can still compiled and we can so that's good.

523
00:20:21,900 --> 00:20:25,500
And now, inside here, what I do the load game code, remember?

524
00:20:25,500 --> 00:20:29,300
I'm still including handmade .h just so I can see these type, these

525
00:20:29,300 --> 00:20:30,300
defined types here.

526
00:20:31,000 --> 00:20:34,100
Basically, what I want to be able to do now is I want to be able to

527
00:20:34,100 --> 00:20:37,600
actually get proc address these things here.

528
00:20:37,800 --> 00:20:41,700
So I'm going to try and load game, get sound samples want to load

529
00:20:41,700 --> 00:20:42,200
that.

530
00:20:42,500 --> 00:20:44,300
And that is a game.

531
00:20:44,300 --> 00:20:48,400
Get sound samples pointer like that and that's going to load from our

532
00:20:48,400 --> 00:20:48,700
game code.

533
00:20:48,900 --> 00:20:51,300
Dll, right, so I want to do that.

534
00:20:51,300 --> 00:20:55,600
And I'm going to make a little struct here which is win32 game code

535
00:20:55,700 --> 00:20:58,100
and it's going to have pointers to both of these things.

536
00:20:58,100 --> 00:20:59,800
It's going to have pointers to this.

537
00:21:00,300 --> 00:21:02,500
Bat and pointer to this.

538
00:21:02,800 --> 00:21:05,600
So that's get sound samples.

539
00:21:06,000 --> 00:21:07,100
And this is game.

540
00:21:07,100 --> 00:21:08,900
Well, actually don't need the board game anymore.

541
00:21:08,900 --> 00:21:09,700
That's get sounds tables.

542
00:21:09,700 --> 00:21:11,700
And this is update and render.

543
00:21:11,900 --> 00:21:14,400
And basically, what I'm going to do here is just say that there's a

544
00:21:14,400 --> 00:21:15,800
win, 3-2 game code struct.

545
00:21:15,800 --> 00:21:18,900
Comes back from this, we have win32 game code.

546
00:21:18,900 --> 00:21:19,900
That's the result.

547
00:21:20,300 --> 00:21:23,600
And basically what happens is that right?

548
00:21:24,000 --> 00:21:29,300
We will initialize to the sub functions, equals the stub there.

549
00:21:30,500 --> 00:21:33,800
Salt this stuff there.

550
00:21:34,500 --> 00:21:38,000
So basically get sound samples.

551
00:21:38,000 --> 00:21:40,300
We will start off pointing just to stub function.

552
00:21:40,300 --> 00:21:43,800
So things that don't do anything then, assuming we can actually load

553
00:21:43,800 --> 00:21:44,200
it.

554
00:21:44,700 --> 00:21:49,500
We will go ahead and do it this way so we can get our functions in

555
00:21:49,500 --> 00:21:49,700
here.

556
00:21:49,700 --> 00:21:56,700
So, get sound samples, will go there and game update and render will

557
00:21:56,700 --> 00:21:57,400
go there.

558
00:21:58,400 --> 00:22:02,400
Update and render like that and there we go.

559
00:22:02,700 --> 00:22:04,700
Okay, so that's pretty good.

560
00:22:04,800 --> 00:22:06,800
And then I will return that result back.

561
00:22:06,800 --> 00:22:07,200
Okay.

562
00:22:07,500 --> 00:22:09,700
So now what should be able to happen?

563
00:22:10,200 --> 00:22:13,700
Just to start things off to get us sort of in position in Striking

564
00:22:13,700 --> 00:22:17,100
Distance of what we want to do at least in the platform layer stuff.

565
00:22:17,100 --> 00:22:19,600
I'm just going to do this sort of at the outset.

566
00:22:19,600 --> 00:22:21,000
The first thing I'm going to do is just do this.

567
00:22:21,000 --> 00:22:21,200
Now.

568
00:22:21,200 --> 00:22:23,600
We're going to have to move this later because we want to we want to

569
00:22:23,600 --> 00:22:24,700
load things on the fly.

570
00:22:24,700 --> 00:22:28,000
But for now, what I'm going to do is just do this and then

571
00:22:28,200 --> 00:22:31,900
Um, from then on basically I should have two errors here.

572
00:22:31,900 --> 00:22:37,500
Yeah, I can just put do game code or just game update and render and

573
00:22:37,500 --> 00:22:39,400
then the get sound samples right?

574
00:22:39,400 --> 00:22:40,500
Can be game dot.

575
00:22:40,500 --> 00:22:43,300
Get sound samples and let's see here.

576
00:22:43,300 --> 00:22:44,400
So there we go.

577
00:22:44,500 --> 00:22:48,900
So now our win32 platform layer compiles properly.

578
00:22:49,600 --> 00:22:52,500
And basically what it's doing now is instead of actually calling

579
00:22:52,500 --> 00:22:56,300
functions that were that are in its own, executables of the Linker

580
00:22:56,300 --> 00:22:56,800
resolves.

581
00:22:56,800 --> 00:22:57,700
I'm now what it does.

582
00:22:57,700 --> 00:22:58,000
Is it leaves

583
00:22:58,100 --> 00:23:01,100
Leaves those function calls.

584
00:23:01,500 --> 00:23:02,500
It makes those function calls.

585
00:23:02,500 --> 00:23:04,100
Go through pointers and those pointers.

586
00:23:04,500 --> 00:23:07,800
We are loading inside this game code function.

587
00:23:07,800 --> 00:23:11,200
So basically any time we want to, we could always just reload them,

588
00:23:11,300 --> 00:23:11,600
right?

589
00:23:11,600 --> 00:23:13,100
We could go ahead and fill on reload them.

590
00:23:13,800 --> 00:23:17,500
And I also want to set us up for Success here to this, to the extent

591
00:23:17,600 --> 00:23:22,300
possible by basically saying that, the dll itself will go up here.

592
00:23:23,200 --> 00:23:25,500
And so that way we will track.

593
00:23:25,500 --> 00:23:27,900
Basically, when we load it.

594
00:23:28,300 --> 00:23:32,300
That we can basically free it later to load a new one, right?

595
00:23:32,300 --> 00:23:35,800
That's so I just want to track that instead of it having be having it

596
00:23:35,800 --> 00:23:37,500
be entirely local to this thing.

597
00:23:37,800 --> 00:23:38,900
So, there we go.

598
00:23:38,900 --> 00:23:40,700
Now we've got that stuff.

599
00:23:40,900 --> 00:23:44,700
And what I want to do here again is also check to make sure that we

600
00:23:44,700 --> 00:23:47,600
actually got these and that they're not bogus.

601
00:23:47,700 --> 00:23:51,800
So, what I can do is basically have something in here which is like,

602
00:23:51,800 --> 00:23:54,200
you know, is valid or something like this.

603
00:23:54,700 --> 00:23:58,000
And basically, I can make is valid be equal to

604
00:23:58,100 --> 00:23:59,600
to these two guys.

605
00:24:00,100 --> 00:24:00,900
So in fact, you know what?

606
00:24:00,900 --> 00:24:03,300
There's another thing I can do here which is, which will be cool.

607
00:24:03,500 --> 00:24:07,000
So, we'll check to make sure we got both things and if we didn't get

608
00:24:07,000 --> 00:24:09,000
both things, then it's invalid.

609
00:24:09,000 --> 00:24:11,500
But what I can also do there as move this down here, right?

610
00:24:11,500 --> 00:24:15,700
I can say if it's not valid, then set them to the sub function.

611
00:24:15,700 --> 00:24:16,500
So no one fails.

612
00:24:16,500 --> 00:24:19,000
So that's kind of nice and clean that'll work pretty well.

613
00:24:19,300 --> 00:24:22,700
But now we at least can return to whether or not we actually think we

614
00:24:22,700 --> 00:24:24,600
got the functions that we wanted to get.

615
00:24:25,100 --> 00:24:26,400
So that seems like it should work.

616
00:24:26,400 --> 00:24:29,800
Okay, for now and that will load that handmade.

617
00:24:30,000 --> 00:24:30,400
Dll.

618
00:24:30,400 --> 00:24:33,600
But now we have to deal with the reverse process, right?

619
00:24:33,600 --> 00:24:35,200
How are we going to deal with that?

620
00:24:35,300 --> 00:24:37,400
How are we going to deal with that?

621
00:24:37,600 --> 00:24:41,300
Because we can't get proc address back on our executable, or maybe we

622
00:24:41,300 --> 00:24:41,800
could

623
00:24:46,100 --> 00:24:49,300
We could load the executable in the dll.

624
00:24:49,400 --> 00:24:52,000
Load a hand over that and reverse call into it, right?

625
00:24:52,000 --> 00:24:55,100
We could do that, could do all sorts of fun things.

626
00:24:56,100 --> 00:24:58,800
But if you think about it, really, there's no need to do that.

627
00:24:58,800 --> 00:25:00,700
That would just be a waste of everyone's time.

628
00:25:00,700 --> 00:25:04,700
Because if you think about it, when we pass in our structure here, we

629
00:25:04,700 --> 00:25:06,000
pass in all these things.

630
00:25:06,000 --> 00:25:09,400
When we call game update, and render everybody is getting the game

631
00:25:09,400 --> 00:25:10,000
memory struct.

632
00:25:10,000 --> 00:25:12,000
For example, we could just decide that.

633
00:25:12,100 --> 00:25:13,600
That inside the game memory struct.

634
00:25:13,600 --> 00:25:17,600
We also pass the pointers to the debug Services, right?

635
00:25:17,600 --> 00:25:20,500
We can just just begin, just flat-out past those, right?

636
00:25:20,600 --> 00:25:24,300
Because these things here don't actually have to be function calls.

637
00:25:24,300 --> 00:25:27,200
They can just be pointers to function calls, right?

638
00:25:27,300 --> 00:25:28,900
So we can do the exact same thing.

639
00:25:28,900 --> 00:25:31,400
In the reverse only instead of having to get proc at just, then we

640
00:25:31,400 --> 00:25:34,300
just pass them because we already have a pointer to the game code.

641
00:25:34,300 --> 00:25:36,000
So when we call into it will just pass it.

642
00:25:36,000 --> 00:25:36,200
Right.

643
00:25:36,200 --> 00:25:39,100
It's it's totally simple.

644
00:25:39,100 --> 00:25:40,000
It's trivial.

645
00:25:40,000 --> 00:25:41,600
There's, there's no reason not to do it.

646
00:25:41,800 --> 00:25:41,800
So,

647
00:25:42,100 --> 00:25:42,700
Go ahead and do it.

648
00:25:42,700 --> 00:25:45,500
So the debug services will just be done the exact same way.

649
00:25:46,100 --> 00:25:51,300
Basically, we have debug platform, read, entire file.

650
00:25:51,700 --> 00:25:53,000
And that's it for that.

651
00:25:53,700 --> 00:25:56,400
We will type def that this way, right?

652
00:25:57,000 --> 00:26:02,500
We just have to go ahead and no, wait, that's not right.

653
00:26:03,400 --> 00:26:03,500
There.

654
00:26:03,500 --> 00:26:10,100
We go, debug platform, read entire file, and that will just take this

655
00:26:10,100 --> 00:26:10,900
guy here.

656
00:26:13,000 --> 00:26:18,100
Okay, and then the same is true for the rest of these guys.

657
00:26:18,200 --> 00:26:19,400
Debug platform.

658
00:26:19,400 --> 00:26:21,000
Free file memory.

659
00:26:21,900 --> 00:26:22,300
Oops.

660
00:26:22,500 --> 00:26:23,200
That's no good.

661
00:26:23,400 --> 00:26:24,900
That goes here.

662
00:26:25,500 --> 00:26:29,000
So that will basically be the same thing again name.

663
00:26:30,500 --> 00:26:30,600
Hi.

664
00:26:30,600 --> 00:26:35,000
Def memory like that.

665
00:26:35,300 --> 00:26:36,800
And this should be named as well.

666
00:26:37,100 --> 00:26:38,100
Get those out of there.

667
00:26:38,100 --> 00:26:40,400
Okay, the type deaths are good.

668
00:26:40,800 --> 00:26:42,800
And the last one same thing.

669
00:26:42,800 --> 00:26:46,100
So basically, instead of actually ever defining the functions in here.

670
00:26:47,000 --> 00:26:50,600
This is right entire file, instead of actually doing that.

671
00:26:50,700 --> 00:26:51,800
We're just going to not do that.

672
00:26:51,800 --> 00:26:55,700
We're just going to Define what types they are and assume later that

673
00:26:55,700 --> 00:26:58,800
someone will pass pointers of them to the game, right?

674
00:26:59,300 --> 00:26:59,800
So right in

675
00:27:00,000 --> 00:27:00,500
File.

676
00:27:00,500 --> 00:27:01,100
There it is.

677
00:27:01,100 --> 00:27:04,700
So now we have defined the types for those pointers and a macro that

678
00:27:04,700 --> 00:27:08,900
defines something of that type, so that we can use that inside the

679
00:27:08,900 --> 00:27:09,800
platform layer.

680
00:27:10,100 --> 00:27:13,700
And basically, all we need to do now is just pass these to the game.

681
00:27:13,700 --> 00:27:15,400
So I'm gonna stick them in game memory for now.

682
00:27:15,600 --> 00:27:17,300
I'm just going to say inside game memory.

683
00:27:17,900 --> 00:27:22,700
You actually also get basically pointers to all these things.

684
00:27:22,700 --> 00:27:23,500
Debug.

685
00:27:24,900 --> 00:27:25,700
Oh wait that tight.

686
00:27:25,700 --> 00:27:26,700
Those are those are new.

687
00:27:27,100 --> 00:27:28,000
Those are named wrong.

688
00:27:28,100 --> 00:27:29,000
That is a typo.

689
00:27:30,000 --> 00:27:30,600
A cap here.

690
00:27:30,600 --> 00:27:37,500
This should be debugged platform, 3 file memory and debug platform,

691
00:27:37,600 --> 00:27:38,100
right?

692
00:27:38,200 --> 00:27:40,400
Entire file like that.

693
00:27:40,500 --> 00:27:40,800
Okay.

694
00:27:40,800 --> 00:27:44,100
So basically all we need to do is just actually pass pointers to each

695
00:27:44,100 --> 00:27:45,000
of these things.

696
00:27:45,500 --> 00:27:46,000
This

697
00:27:47,400 --> 00:27:48,600
Right, that's it.

698
00:27:49,200 --> 00:27:55,500
And so this will be debug platform, read, entire file, debug platform,

699
00:27:55,500 --> 00:27:56,900
3 file memory.

700
00:27:58,600 --> 00:28:01,800
And debug platform right entire file.

701
00:28:02,100 --> 00:28:04,000
So we have those now and sort of what we've done.

702
00:28:04,000 --> 00:28:06,000
Here is basically created our own little vtable.

703
00:28:06,000 --> 00:28:08,600
If you think about it, it's sort of almost like making our own little

704
00:28:08,600 --> 00:28:12,300
dispatch only instead of it having to be all C++ and weird.

705
00:28:12,300 --> 00:28:14,400
We actually can see it and do whatever we want with it.

706
00:28:18,200 --> 00:28:20,100
So now when we pass game memory.

707
00:28:21,200 --> 00:28:23,900
We should just be able to call our stuff directly out of that.

708
00:28:24,200 --> 00:28:24,800
What did I do?

709
00:28:24,800 --> 00:28:31,000
I did something wrong here Undeclared.

710
00:28:31,000 --> 00:28:33,700
Identifier, debug plant Loops.

711
00:28:33,800 --> 00:28:34,600
That's no good.

712
00:28:35,000 --> 00:28:36,000
That's no good.

713
00:28:36,000 --> 00:28:37,100
Gotta pass the name.

714
00:28:37,300 --> 00:28:37,900
There we go.

715
00:28:38,500 --> 00:28:41,500
And then in these so anywhere we were calling those.

716
00:28:41,500 --> 00:28:44,900
Now we can just we can just call them straight off of our memory,

717
00:28:45,100 --> 00:28:45,500
right?

718
00:28:45,600 --> 00:28:46,500
Just like that.

719
00:28:46,500 --> 00:28:47,200
And that's it.

720
00:28:48,100 --> 00:28:50,900
So basically,

721
00:28:51,800 --> 00:28:56,700
I think that is basically all we need to do here, got to move that up

722
00:28:56,700 --> 00:29:00,200
above there, because this actually calls that, that should be it for

723
00:29:00,200 --> 00:29:00,500
that.

724
00:29:00,500 --> 00:29:05,000
Alright, so now, all we have to do is actually initialize those in our

725
00:29:05,100 --> 00:29:05,600
memory call.

726
00:29:05,600 --> 00:29:12,000
So these should actually be these guys, here should actually be using

727
00:29:12,000 --> 00:29:15,100
this macro because that way, if the macro change is, these will be

728
00:29:15,100 --> 00:29:15,400
correct.

729
00:29:15,400 --> 00:29:18,000
So, we've got free file memory and I'll rearrange the order here.

730
00:29:18,600 --> 00:29:20,800
I like things to always be in the same order every

731
00:29:21,000 --> 00:29:24,200
I don't know why, but I just like everything to be in the same order.

732
00:29:24,600 --> 00:29:26,200
It's some kind of OCD tendency.

733
00:29:26,700 --> 00:29:29,000
So anyway, we'll go ahead and do that.

734
00:29:29,100 --> 00:29:29,900
So, there we go.

735
00:29:30,000 --> 00:29:35,200
Debug platform, free file, memory braid, entire file will now be

736
00:29:35,200 --> 00:29:36,300
defined but the macro.

737
00:29:36,300 --> 00:29:39,200
So, again, this is just making it so that I don't have the same

738
00:29:40,000 --> 00:29:44,600
parameter list in tons of different places, because that just makes

739
00:29:44,600 --> 00:29:47,000
for more maintenance work for me, which I don't want to do.

740
00:29:48,000 --> 00:29:48,800
So, there we go.

741
00:29:48,800 --> 00:29:50,800
And now, if I build this, we should be good to go.

742
00:29:51,000 --> 00:29:54,700
Yes, we have never actually when we created our game memory struct, we

743
00:29:54,700 --> 00:29:56,200
haven't actually set the pointers in it.

744
00:29:56,200 --> 00:29:57,200
So they'll all be pointing to 0.

745
00:29:57,200 --> 00:29:59,800
Which means we'd crash immediately when we tried to call them.

746
00:30:00,200 --> 00:30:04,600
We know, but I'd rather just not have to to go through that crash to

747
00:30:04,600 --> 00:30:05,000
see that.

748
00:30:05,000 --> 00:30:08,300
So what I'm going to do instead is just go ahead and initialize them

749
00:30:08,600 --> 00:30:11,500
to what we would then go and do after we saw the crash.

750
00:30:12,200 --> 00:30:14,500
So let's just skip that whole crash process.

751
00:30:15,000 --> 00:30:16,500
If no one has any objections.

752
00:30:16,700 --> 00:30:19,500
Basically, I'm just going to initialize those pointers so that when

753
00:30:19,500 --> 00:30:23,600
the game gets the memory Struck it has each thing initialized

754
00:30:23,600 --> 00:30:24,000
properly.

755
00:30:24,000 --> 00:30:24,800
So that's it.

756
00:30:25,000 --> 00:30:27,000
That's basically the end of it, right?

757
00:30:27,500 --> 00:30:29,600
Don't think there's really anything else to do so.

758
00:30:30,000 --> 00:30:31,500
Now we're actually compiling correctly.

759
00:30:31,500 --> 00:30:35,300
But let's take a look to see if we actually got in our build

760
00:30:35,300 --> 00:30:36,900
directory, what we wanted, right?

761
00:30:36,900 --> 00:30:39,000
Because I don't actually know if we did or not.

762
00:30:39,300 --> 00:30:41,800
So it doesn't look like we did because I passed that dll switch.

763
00:30:41,800 --> 00:30:46,000
But you notice, we're still building an egg Z here and I don't want it

764
00:30:46,000 --> 00:30:46,800
to build an egg Z.

765
00:30:46,900 --> 00:30:48,000
That's not what it's supposed to do.

766
00:30:48,000 --> 00:30:52,200
So I still, I'm not passing the correct things.

767
00:30:52,200 --> 00:30:54,400
So let's let's double-check that.

768
00:30:54,400 --> 00:30:56,400
I'm not doing something wrong.

769
00:30:57,300 --> 00:31:05,100
So let's see here to maybe that because we're specifying other things,

770
00:31:05,100 --> 00:31:06,000
that it's a problem.

771
00:31:06,000 --> 00:31:08,800
I'm not entirely sure.

772
00:31:10,100 --> 00:31:11,000
Let's take a look.

773
00:31:11,300 --> 00:31:14,800
Let's take a look because all we really need to do now is make sure

774
00:31:14,800 --> 00:31:17,500
that that's actually getting followed.

775
00:31:17,500 --> 00:31:22,600
Is this something that you pass to their entry point must be defined?

776
00:31:23,600 --> 00:31:27,300
That doesn't help us and if it's linked, what's going on there?

777
00:31:27,300 --> 00:31:28,500
Why are we not?

778
00:31:28,800 --> 00:31:32,300
Why are we not getting the dll that we asked for?

779
00:31:32,300 --> 00:31:35,000
Because we asked for a dll and we're not getting one.

780
00:31:35,500 --> 00:31:39,400
So, basically, all we have to do is decrypt, the magical switches and

781
00:31:39,400 --> 00:31:40,800
then we will figure that out.

782
00:31:40,900 --> 00:31:42,600
So it's still producing an egg's e-what.

783
00:31:42,900 --> 00:31:44,700
Are my common, compiler Flags.

784
00:31:46,100 --> 00:31:49,200
Let's see nothing suspicious there.

785
00:31:49,500 --> 00:31:53,000
There's an output of the map file, which should probably

786
00:31:53,100 --> 00:31:57,800
Be specified separately, but that's really not going to do it.

787
00:31:57,800 --> 00:31:59,600
That's a separate thing entirely.

788
00:32:00,200 --> 00:32:03,200
That's just, we will need those two output, two different things as

789
00:32:03,200 --> 00:32:03,600
all.

790
00:32:04,700 --> 00:32:06,900
But yeah, I don't see.

791
00:32:06,900 --> 00:32:12,500
We're looks like we're out putting everything as you would expect.

792
00:32:12,500 --> 00:32:17,100
So I'm not sure why it's disobeying, my dll call.

793
00:32:17,100 --> 00:32:20,200
I do not actually know why.

794
00:32:20,200 --> 00:32:21,600
It is disobeying that call.

795
00:32:22,300 --> 00:32:25,400
So they're not producing the map properly, but it's still producing an

796
00:32:25,400 --> 00:32:25,800
x z.

797
00:32:25,800 --> 00:32:27,000
So let's double check.

798
00:32:28,200 --> 00:32:29,600
Let's see here.

799
00:32:31,700 --> 00:32:34,300
Module definition statement, the base and deal options together

800
00:32:34,300 --> 00:32:35,700
equivalent to the library.

801
00:32:39,800 --> 00:32:41,100
A dealer just going to its exports.

802
00:32:41,100 --> 00:32:41,400
Yes.

803
00:32:41,400 --> 00:32:43,000
I know we're going to do that in a second.

804
00:32:43,000 --> 00:32:48,100
But what I want to know is why won't you build a dll from I just want

805
00:32:48,100 --> 00:32:48,600
you to out.

806
00:32:48,600 --> 00:32:49,700
I just want to see.

807
00:32:50,300 --> 00:32:51,900
I just want to visually see the

808
00:32:52,000 --> 00:32:56,900
You're outputting it CL Flags to make a dll.

809
00:32:56,900 --> 00:32:59,800
So please tell me what to say.

810
00:33:00,200 --> 00:33:00,700
Overflow.

811
00:33:00,700 --> 00:33:03,300
Say here's your big chance to redeem yourself stackoverflow.

812
00:33:03,800 --> 00:33:06,000
Be correct about something.

813
00:33:06,400 --> 00:33:07,300
Let's take a look.

814
00:33:12,000 --> 00:33:12,800
What is this?

815
00:33:16,500 --> 00:33:17,800
This doesn't look?

816
00:33:19,700 --> 00:33:21,400
This doesn't look useful.

817
00:33:21,900 --> 00:33:24,100
This doesn't look useful at all.

818
00:33:24,100 --> 00:33:29,100
Actually, no, no.

819
00:33:30,600 --> 00:33:32,900
No, come on people.

820
00:33:32,900 --> 00:33:34,000
How hard could this be?

821
00:33:34,700 --> 00:33:36,700
I mean, seriously, there should just be, like, a thing.

822
00:33:37,300 --> 00:33:39,200
That's like, here is how you build a deal.

823
00:33:39,200 --> 00:33:41,800
Alright, I mean, how hard is this?

824
00:33:41,900 --> 00:33:42,200
Normally?

825
00:33:42,200 --> 00:33:46,100
What I do is I go I go open up one of my existing projects that builds

826
00:33:46,100 --> 00:33:47,800
a dll and I look at what it does.

827
00:33:48,400 --> 00:33:50,600
But of course, I'm trying to go through the steps.

828
00:33:50,600 --> 00:33:53,200
I would have to go through if I didn't have anything.

829
00:33:54,100 --> 00:33:55,600
So I can't actually do that.

830
00:33:55,600 --> 00:33:58,000
So why mr.

831
00:33:58,000 --> 00:34:00,200
Finicky, do you not see?

832
00:34:00,300 --> 00:34:00,900
To want to do that.

833
00:34:00,900 --> 00:34:03,800
It says right here, the deal option builds a dll is the main output

834
00:34:03,800 --> 00:34:04,200
file.

835
00:34:04,700 --> 00:34:08,699
I am passing it, but it doesn't actually seem to do anything.

836
00:34:09,400 --> 00:34:13,900
Now if it's, if it's not followed by slash link, if I just do that, it

837
00:34:13,900 --> 00:34:16,400
says entry point, must be defined.

838
00:34:16,500 --> 00:34:17,800
So maybe what's happening?

839
00:34:18,500 --> 00:34:22,300
I'm going to guess I'm going to hope this is my hope that this was

840
00:34:22,300 --> 00:34:23,100
that tough passing.

841
00:34:23,100 --> 00:34:26,400
It after the link thing actually makes it not work and this makes it

842
00:34:26,400 --> 00:34:30,000
work because we don't specify a dll main which is

843
00:34:30,199 --> 00:34:31,900
nothing, what we would actually probably need to do.

844
00:34:31,900 --> 00:34:36,300
So, let's hope that this is the correct switch and we'll go add the

845
00:34:36,300 --> 00:34:40,500
dll main and and then hope that that was actually doing it properly.

846
00:34:40,500 --> 00:34:42,300
So I'm gonna, I'm gonna hope that that's true.

847
00:34:42,300 --> 00:34:44,400
And then it's just like, if you put it after the slash link, it

848
00:34:44,400 --> 00:34:47,199
doesn't work because because it doesn't.

849
00:34:47,699 --> 00:34:48,300
All right.

850
00:34:48,500 --> 00:34:52,600
So, basically what we need to do here is inside handmade dot CPP,

851
00:34:52,600 --> 00:34:53,300
right?

852
00:34:53,600 --> 00:34:55,600
We still have the problem of

853
00:34:56,600 --> 00:35:01,800
We basically solved the problem that we need to make a win32 version.

854
00:35:01,800 --> 00:35:05,900
So we have our win32 handmade sort of Library thing.

855
00:35:05,900 --> 00:35:11,900
But we also have our win32 handmade game or something like that.

856
00:35:11,900 --> 00:35:14,800
So we've got, we've based got to win32 things happening if that makes

857
00:35:14,800 --> 00:35:15,200
sense.

858
00:35:15,800 --> 00:35:20,300
So basically what I want to do because how should I say this,

859
00:35:20,700 --> 00:35:25,200
executables have the same thing dlls have the same thing as

860
00:35:25,200 --> 00:35:25,800
executables.

861
00:35:25,800 --> 00:35:26,200
That's a good.

862
00:35:26,400 --> 00:35:31,900
Set windows will still call us when even if we're loaded as a dll, it

863
00:35:31,900 --> 00:35:35,300
will still call in to us for no real reason other than to give us a

864
00:35:35,300 --> 00:35:36,700
chance to do startup stuff.

865
00:35:37,200 --> 00:35:40,200
So really we don't actually need Windows to do that.

866
00:35:40,200 --> 00:35:41,900
But Windows is going to do that.

867
00:35:42,100 --> 00:35:45,300
So even though we're building a chunk of code that we don't actually

868
00:35:45,300 --> 00:35:46,600
need it to jump into.

869
00:35:46,700 --> 00:35:49,300
I don't know if there's a way to tell it, just don't bother jumping

870
00:35:49,300 --> 00:35:49,900
into us.

871
00:35:50,200 --> 00:35:52,500
So what we need to do is just put a little stub in there.

872
00:35:52,500 --> 00:35:54,300
Now, we could do that in one of two ways.

873
00:35:54,500 --> 00:35:56,200
In fact, maybe this is an easier way to do.

874
00:35:56,300 --> 00:35:57,100
It, I don't know.

875
00:35:58,500 --> 00:35:59,800
Like we could we could not.

876
00:36:00,000 --> 00:36:03,900
This, we could just stick a stub at the bottom of handmade dot CPP,

877
00:36:03,900 --> 00:36:04,300
right?

878
00:36:04,300 --> 00:36:08,200
You could go in here and do something like this, but it maybe is a

879
00:36:08,200 --> 00:36:09,200
little uglier, right?

880
00:36:09,200 --> 00:36:15,600
We could do something like, say, okay, if it's handmade win32, right?

881
00:36:16,500 --> 00:36:19,500
Then we just stick the stub in here because it isn't actually code

882
00:36:19,500 --> 00:36:22,100
that anyone has to read and it could go below here.

883
00:36:22,500 --> 00:36:23,600
I don't know how I feel about that.

884
00:36:23,600 --> 00:36:26,800
Like I said, I like to keep the code segregated and multiple files,

885
00:36:27,200 --> 00:36:28,100
but we could.

886
00:36:28,300 --> 00:36:29,800
And so basically what we would need to do.

887
00:36:30,000 --> 00:36:32,300
I'll do it in here and then we can kind of look at it and decide

888
00:36:32,300 --> 00:36:34,400
whether we care about that and whether we want to move it out.

889
00:36:34,400 --> 00:36:38,300
Basically, we've got this thing here, which is dll, Main, and dll,

890
00:36:38,300 --> 00:36:42,000
Main basically is essentially the same as when main, right?

891
00:36:42,400 --> 00:36:45,100
Basically, it's just a thing where this happens.

892
00:36:45,100 --> 00:36:48,900
We have to include Windows .h to Define these things and that we just

893
00:36:48,900 --> 00:36:51,700
go ahead and we have to process this call.

894
00:36:51,700 --> 00:36:52,000
Now.

895
00:36:52,000 --> 00:36:54,800
I don't actually think there's almost anything that you need to do.

896
00:36:55,000 --> 00:36:56,500
I think it's all pretty route.

897
00:36:57,200 --> 00:36:57,900
Let's take a look.

898
00:36:57,900 --> 00:36:58,900
There's our community editions.

899
00:36:58,900 --> 00:36:59,800
Do we have

900
00:37:03,600 --> 00:37:04,600
Is there, there it is.

901
00:37:04,600 --> 00:37:07,700
Using Dynamic link, libraries, creating a simple Dynamic link Library.

902
00:37:07,700 --> 00:37:10,100
There should be just the bare minimum.

903
00:37:11,000 --> 00:37:14,800
Yeah, of stuff that we would need to do in a dynamic link Library.

904
00:37:17,100 --> 00:37:18,100
Let's see.

905
00:37:18,500 --> 00:37:19,800
This doesn't seem to be.

906
00:37:19,800 --> 00:37:21,200
This is not what I want.

907
00:37:21,900 --> 00:37:23,000
This is not what I want.

908
00:37:23,000 --> 00:37:27,000
I want something that just shows me the minimum set of things to do in

909
00:37:27,000 --> 00:37:28,000
a dll main.

910
00:37:29,300 --> 00:37:29,800
Let's see.

911
00:37:29,900 --> 00:37:32,200
Here, let's see.

912
00:37:32,400 --> 00:37:33,000
Here we go.

913
00:37:33,500 --> 00:37:36,100
So basically this is what where Windows is going to call us back in

914
00:37:36,100 --> 00:37:39,900
our dll, when that dll gets loaded into memory by another process,

915
00:37:39,900 --> 00:37:41,800
which in this case is also going to be our process.

916
00:37:42,500 --> 00:37:45,200
So basically these are the things that it's going to ask us to do

917
00:37:45,200 --> 00:37:49,700
attach detach and so on, if basically saying okay process attached

918
00:37:49,700 --> 00:37:53,400
thread attached thread to attach process detach so it'll call us at

919
00:37:53,400 --> 00:37:58,000
this dll main every time a process or a thread starts using the dll or

920
00:37:58,000 --> 00:37:59,800
stops using the dll we do.

921
00:38:00,000 --> 00:38:03,500
To do anything because we're not going to master any resources, right?

922
00:38:03,500 --> 00:38:05,700
The whole point of this platform not specific code is that it doesn't

923
00:38:05,700 --> 00:38:09,700
do anything other than respond to calls from the platform layer

924
00:38:09,700 --> 00:38:10,100
itself.

925
00:38:10,100 --> 00:38:12,600
So really all we should have to do honestly is just return.

926
00:38:12,600 --> 00:38:13,100
True.

927
00:38:13,200 --> 00:38:16,200
It looks like there's absolutely nothing that we would have to do

928
00:38:16,200 --> 00:38:16,600
here.

929
00:38:16,700 --> 00:38:20,200
So I think we can just do that and leave it at that.

930
00:38:21,100 --> 00:38:21,900
However,

931
00:38:23,800 --> 00:38:24,200
Okay.

932
00:38:24,700 --> 00:38:26,700
So what's the problem here?

933
00:38:26,700 --> 00:38:30,700
If I actually compile this, it says entry point must be defined.

934
00:38:30,900 --> 00:38:34,300
I have the dll main that you asked me for.

935
00:38:35,600 --> 00:38:38,100
So why are you complaining?

936
00:38:38,100 --> 00:38:43,600
This is the part where I'm not sure if the /d at Jude me, the / delos

937
00:38:43,600 --> 00:38:44,500
actually working.

938
00:38:44,500 --> 00:38:46,800
Of course, let's let's take a look here.

939
00:38:47,500 --> 00:38:53,000
If I was to go into win32 handmade and put a

940
00:38:53,100 --> 00:38:54,000
In Maine in here.

941
00:38:54,600 --> 00:38:56,000
Would that compile?

942
00:38:56,000 --> 00:38:59,800
And if it does yeah, we're sad so it's still not building a dll.

943
00:39:02,000 --> 00:39:04,500
So Windows, why are you not building a dll?

944
00:39:04,500 --> 00:39:07,000
Just tell me, you know, you don't have to be cagey.

945
00:39:07,300 --> 00:39:08,600
Why not?

946
00:39:09,500 --> 00:39:11,000
I really don't understand why.

947
00:39:12,000 --> 00:39:12,800
Let's see.

948
00:39:12,800 --> 00:39:13,500
Let's see.

949
00:39:13,500 --> 00:39:14,900
What is the reason why?

950
00:39:21,900 --> 00:39:22,600
I'm not sure.

951
00:39:23,000 --> 00:39:24,900
I honestly don't know, I must be forgetting something.

952
00:39:24,900 --> 00:39:27,300
It's going to be just the standard thing where you kind of slap your

953
00:39:27,300 --> 00:39:31,000
head and go and feel stupid at the end of it.

954
00:39:31,400 --> 00:39:32,600
But let's see here.

955
00:39:34,600 --> 00:39:36,000
Let's see.

956
00:39:38,000 --> 00:39:38,400
Surely.

957
00:39:38,400 --> 00:39:44,000
There's just a simple DLo example or something that I can just see

958
00:39:44,700 --> 00:39:45,400
what it is.

959
00:39:45,400 --> 00:39:46,500
So we've done this.

960
00:39:49,400 --> 00:39:53,300
That's but this is not the final example, is the source code need to

961
00:39:53,300 --> 00:39:54,600
create a simple dll.

962
00:39:54,900 --> 00:39:57,700
But this doesn't even require I guess.

963
00:39:57,700 --> 00:40:00,900
So, is it just that we haven't exported any functions.

964
00:40:01,300 --> 00:40:02,400
Is that the problem?

965
00:40:03,500 --> 00:40:05,700
Well, I guess we're going to have to the anyway, so I'll talk about

966
00:40:05,700 --> 00:40:06,800
that and we'll see.

967
00:40:07,600 --> 00:40:08,700
We'll see if that's the case.

968
00:40:08,800 --> 00:40:11,800
Alright, so basically what has to happen.

969
00:40:12,800 --> 00:40:15,500
In order for a dll to export entry points.

970
00:40:15,500 --> 00:40:17,400
Basically, because remember, the compiler is going to compile this

971
00:40:17,400 --> 00:40:17,500
code.

972
00:40:17,500 --> 00:40:19,800
It's going to Output a dll for us.

973
00:40:19,800 --> 00:40:22,300
And a dll is something that's essentially executable code is

974
00:40:22,300 --> 00:40:27,800
essentially the same as an x z, right, but it has table in it of

975
00:40:27,800 --> 00:40:30,800
places in the code marked by strings.

976
00:40:30,800 --> 00:40:34,400
So you can basically say get proc address like we did before pass it a

977
00:40:34,400 --> 00:40:37,300
string, it will look at the dll and it's got a string table in there

978
00:40:37,300 --> 00:40:40,800
that map strings two locations in the code so that you can basically

979
00:40:40,800 --> 00:40:42,700
do linking at runtime.

980
00:40:42,800 --> 00:40:45,800
I'm dynamically which is why it's called Dynamic link library.

981
00:40:46,200 --> 00:40:49,900
And what we will have to do in order for this to happen is we will

982
00:40:49,900 --> 00:40:52,900
have to actually have some things that are exported.

983
00:40:53,000 --> 00:40:56,700
Now, one way to do things that are exported is to put decal spec dll

984
00:40:56,700 --> 00:40:58,100
export in the code.

985
00:40:58,100 --> 00:41:00,900
This is just some crazy syntactic stuff.

986
00:41:00,900 --> 00:41:02,200
That Microsoft's compiler.

987
00:41:02,400 --> 00:41:06,600
Basically uses to tell you that the thing is that is being exported

988
00:41:08,000 --> 00:41:11,200
the function that it's tagged on is going to be exported, we can use

989
00:41:11,200 --> 00:41:11,800
that.

990
00:41:11,900 --> 00:41:12,700
But another thing we can,

991
00:41:12,800 --> 00:41:16,200
Can do is we can just specify what the exports are directly.

992
00:41:16,200 --> 00:41:19,400
And I don't actually remember exactly how to do those but they're

993
00:41:19,400 --> 00:41:21,200
actually pretty straightforward.

994
00:41:21,200 --> 00:41:22,200
If I remember correctly.

995
00:41:22,600 --> 00:41:26,100
Basically, it's like yeah, it's this so you can actually just on the

996
00:41:26,100 --> 00:41:26,600
link line.

997
00:41:26,600 --> 00:41:29,400
If you don't want to cut up your code with Windows specific stuff,

998
00:41:29,800 --> 00:41:31,700
which we'd like to minimize as much as possible.

999
00:41:31,700 --> 00:41:36,300
You can use / export on the link line to basically say that a

1000
00:41:36,300 --> 00:41:39,200
particular piece of code is going to be / export.

1001
00:41:39,200 --> 00:41:39,600
Now.

1002
00:41:40,300 --> 00:41:42,600
There's one other, there's one caveat to that.

1003
00:41:42,800 --> 00:41:45,900
See you in a second, but basically / export.

1004
00:41:45,900 --> 00:41:49,000
I don't know where it's got the, the Define for that.

1005
00:41:49,000 --> 00:41:50,400
Should have it in here somewhere.

1006
00:41:51,300 --> 00:41:54,600
Let's see in this PC /.

1007
00:41:54,600 --> 00:41:56,600
Export blinkers switch.

1008
00:41:57,700 --> 00:41:58,000
Yeah.

1009
00:41:58,900 --> 00:41:59,700
Let's see here.

1010
00:42:00,000 --> 00:42:01,000
For its function.

1011
00:42:02,600 --> 00:42:05,900
My net is slow or maybe it's just a mistake and it's slow.

1012
00:42:06,900 --> 00:42:09,200
All right, so basically this right.

1013
00:42:09,400 --> 00:42:11,600
So basically what this does is you can basically say, Okay.

1014
00:42:11,600 --> 00:42:14,600
I want to export a particular name.

1015
00:42:14,600 --> 00:42:17,300
I want to export it and I can just give the name of the function

1016
00:42:17,300 --> 00:42:17,600
there.

1017
00:42:17,600 --> 00:42:20,600
But there's a caveat here that we'll see in a second basically.

1018
00:42:20,600 --> 00:42:23,400
Okay, I'll put it in and you could see what I mean.

1019
00:42:23,600 --> 00:42:25,900
So I'm going to do export entry name here.

1020
00:42:26,000 --> 00:42:29,400
I'm going to say that I want to export get sound samples because we

1021
00:42:29,400 --> 00:42:30,800
said we wanted to export that.

1022
00:42:31,000 --> 00:42:32,300
And I also want to export,

1023
00:42:32,900 --> 00:42:34,400
Game update and render, right?

1024
00:42:34,400 --> 00:42:36,700
So I just want to do those two things, right?

1025
00:42:36,700 --> 00:42:38,300
Well, okay, I guess I got to put them.

1026
00:42:40,700 --> 00:42:41,900
After the link line.

1027
00:42:43,200 --> 00:42:43,800
Like that.

1028
00:42:44,900 --> 00:42:49,300
Alright, so yeah, I just don't know.

1029
00:42:49,300 --> 00:42:50,800
I'm failing tonight.

1030
00:42:50,900 --> 00:42:54,200
This might be an ally of same moment because I am failing.

1031
00:42:54,200 --> 00:42:55,900
Just to know what the compiler switches are to do.

1032
00:42:55,900 --> 00:42:57,500
The thing that I actually needed to do.

1033
00:42:58,000 --> 00:43:00,400
I really need this thing to actually build a dll for me.

1034
00:43:00,400 --> 00:43:04,200
But it really doesn't seem to want to but now that I've got some

1035
00:43:04,200 --> 00:43:06,200
exports, it seems like it's actually doing it.

1036
00:43:06,200 --> 00:43:09,900
So maybe the whole time, it was really just upset about that.

1037
00:43:09,900 --> 00:43:12,800
I don't know, but it's still outputting an executable.

1038
00:43:13,000 --> 00:43:16,600
I can see that it's outputting an executable which is which is kind of

1039
00:43:16,600 --> 00:43:16,900
weird.

1040
00:43:16,900 --> 00:43:20,600
But anyway, all right, and it but it's even it's creating a lip.

1041
00:43:20,700 --> 00:43:21,200
Do you notice that?

1042
00:43:21,200 --> 00:43:23,900
So it's actually creating an import Library as if it was about to

1043
00:43:23,900 --> 00:43:29,400
build a deal and even an export to so, very strange, but let's just

1044
00:43:29,400 --> 00:43:31,600
finish what we were doing and then we'll go try to debug that some

1045
00:43:31,600 --> 00:43:31,800
more.

1046
00:43:31,800 --> 00:43:36,200
So anyway, I've got the exports here, game update render get sound

1047
00:43:36,200 --> 00:43:41,400
samples, but there's a rub basically, which is that we have not

1048
00:43:41,400 --> 00:43:42,800
actually marked up these

1049
00:43:42,900 --> 00:43:43,300
auctions.

1050
00:43:44,400 --> 00:43:49,500
To avoid having them be named mangled.

1051
00:43:49,500 --> 00:43:52,100
Now know, if you remember the name, mangling stuff.

1052
00:43:52,100 --> 00:43:57,000
I showed where C++ mangles the names in order to work with old-school.

1053
00:43:57,000 --> 00:43:57,500
See linkers.

1054
00:43:57,500 --> 00:43:59,300
There's this sort of whole process.

1055
00:43:59,300 --> 00:44:00,600
I talked about it in detail.

1056
00:44:00,600 --> 00:44:01,700
Hopefully you guys remember

1057
00:44:04,900 --> 00:44:08,600
So, if we look at what these functions actually get called, they ain't

1058
00:44:08,600 --> 00:44:11,800
called game that sound samples and game update, and rendered their

1059
00:44:11,800 --> 00:44:13,200
names, or something, totally different.

1060
00:44:13,200 --> 00:44:16,900
So in order to make sure that they don't essentially get.

1061
00:44:18,600 --> 00:44:20,200
That they don't get mangled in.

1062
00:44:20,200 --> 00:44:20,700
That way.

1063
00:44:20,700 --> 00:44:23,500
I can put a thing called extra and see in front of them if that makes

1064
00:44:23,500 --> 00:44:23,900
sense.

1065
00:44:24,400 --> 00:44:26,100
And what extra and see does.

1066
00:44:26,100 --> 00:44:27,800
And do not ask me where they came up with.

1067
00:44:27,800 --> 00:44:30,500
This particular syntax is very different from just about anything else

1068
00:44:30,900 --> 00:44:34,700
what extra and see does is it says, okay this function in particular

1069
00:44:34,700 --> 00:44:39,200
it needs to be following this the old-school sea convention.

1070
00:44:39,400 --> 00:44:41,600
Don't mangle the name, right?

1071
00:44:41,600 --> 00:44:44,600
And so if we take a look at what actually gets output, hopefully it

1072
00:44:44,600 --> 00:44:47,800
will get out, put it in the map as well so I can actually show you.

1073
00:44:49,500 --> 00:44:50,200
Dot map.

1074
00:44:50,500 --> 00:44:51,200
Let's see.

1075
00:44:52,400 --> 00:44:58,900
Update and render update and see.

1076
00:44:59,200 --> 00:44:59,900
What did I use that?

1077
00:45:00,000 --> 00:45:03,300
That's not what I meant to do is I used the wrong function function

1078
00:45:03,300 --> 00:45:05,000
their date and render.

1079
00:45:05,000 --> 00:45:05,200
Okay.

1080
00:45:05,200 --> 00:45:05,800
There we go.

1081
00:45:06,000 --> 00:45:08,800
So here's the simple demo of this.

1082
00:45:08,900 --> 00:45:12,200
So, before extern, see, game update and render, I'm going to do the

1083
00:45:12,200 --> 00:45:12,800
build.

1084
00:45:12,900 --> 00:45:15,000
I'm going to look at the map file, which remember I said, is the thing

1085
00:45:15,000 --> 00:45:17,300
that gets outputted that shows us where all our functions are.

1086
00:45:17,500 --> 00:45:19,500
And now, I look at what the names of these things are.

1087
00:45:19,700 --> 00:45:22,100
Well, here's the name mangled version of that, right?

1088
00:45:22,100 --> 00:45:23,700
It's total crazy town, right?

1089
00:45:23,700 --> 00:45:25,300
It's like it's not the name at all.

1090
00:45:25,400 --> 00:45:29,800
Okay, and so if I go in now and I add that extra in, see

1091
00:45:30,000 --> 00:45:32,600
See, you can see now that it will change it.

1092
00:45:32,600 --> 00:45:36,200
To what I actually wanted, which is just the straight name game update

1093
00:45:36,200 --> 00:45:39,000
and render game get sound samples, right?

1094
00:45:39,100 --> 00:45:40,700
So that's exactly what I wanted.

1095
00:45:40,900 --> 00:45:41,900
And that's it.

1096
00:45:41,900 --> 00:45:46,400
So, the only thing we have to do now is try to convince em SVC to

1097
00:45:46,400 --> 00:45:47,400
Output a DOT DL L.

1098
00:45:47,400 --> 00:45:51,700
Now, I suspect because it actually imported the I suspect because of

1099
00:45:51,700 --> 00:45:54,600
the way that it did this that we could actually load the executable

1100
00:45:55,000 --> 00:45:55,800
directly.

1101
00:45:57,600 --> 00:45:59,600
I feel like it's just naming it XZ or something.

1102
00:45:59,600 --> 00:46:00,600
But hold on a second.

1103
00:46:00,600 --> 00:46:03,000
Will actually try that and see.

1104
00:46:03,100 --> 00:46:06,200
So basically, if I go up here, instead of letting loading handmade dot

1105
00:46:07,000 --> 00:46:08,600
DL, I load, handmade .exe.

1106
00:46:08,600 --> 00:46:10,100
I just want to see what actually happens.

1107
00:46:10,300 --> 00:46:12,300
So let's go ahead and step into our code here.

1108
00:46:13,500 --> 00:46:15,300
When I load the game code, I want to see what happens.

1109
00:46:15,700 --> 00:46:18,200
Yeah, so it's opening up this, right?

1110
00:46:18,200 --> 00:46:21,600
It's opening up this guy and then it goes ahead and asks for game

1111
00:46:21,600 --> 00:46:24,500
update and render and it got it right.

1112
00:46:24,600 --> 00:46:25,300
So there we go.

1113
00:46:26,100 --> 00:46:27,300
And hey, look at that.

1114
00:46:27,300 --> 00:46:29,400
It's actually well.

1115
00:46:29,400 --> 00:46:33,900
No, actually, I think it's probably not quite working at that point

1116
00:46:34,000 --> 00:46:36,600
because we should have seen the we're not actually getting the game

1117
00:46:36,600 --> 00:46:37,200
code running.

1118
00:46:37,700 --> 00:46:41,200
Let's see there, but it actually got updated, render it, got an

1119
00:46:41,200 --> 00:46:43,100
address back for it and it got

1120
00:46:43,300 --> 00:46:45,500
Address back forums for sound samples as well.

1121
00:46:46,400 --> 00:46:49,300
So I'm not sure is valid.

1122
00:46:49,600 --> 00:46:50,600
Oh, right.

1123
00:46:50,900 --> 00:46:51,400
Typo.

1124
00:46:53,200 --> 00:46:55,000
Not valid then we overwrite it.

1125
00:46:55,900 --> 00:46:56,900
So let's take a look now.

1126
00:46:57,700 --> 00:47:00,800
Yeah, so who knows why we'll have to figure out why Windows is

1127
00:47:00,800 --> 00:47:03,900
deciding to extra to create an exe instead of a dll.

1128
00:47:03,900 --> 00:47:04,800
We don't know yet.

1129
00:47:04,900 --> 00:47:07,900
But basically doesn't matter for our current purposes.

1130
00:47:07,900 --> 00:47:10,900
Maybe we'll do it the Q&A because I'm sure someone on the stream has

1131
00:47:10,900 --> 00:47:12,800
already thought of what the problem is.

1132
00:47:13,200 --> 00:47:16,900
So basically what we're doing here is now we're actually loading our

1133
00:47:16,900 --> 00:47:17,400
own code.

1134
00:47:17,400 --> 00:47:18,300
Dynamically, right?

1135
00:47:18,300 --> 00:47:20,400
We're actually loading out of that XZ.

1136
00:47:20,400 --> 00:47:21,300
That was produced.

1137
00:47:21,800 --> 00:47:22,700
We're doing the load.

1138
00:47:22,800 --> 00:47:24,900
Sells this, Handmade by DX e, right.

1139
00:47:24,900 --> 00:47:29,600
So now what we could do, if we wanted to, we can make it so that we

1140
00:47:29,600 --> 00:47:32,900
can just reload that code on demand essentially rent.

1141
00:47:32,900 --> 00:47:37,200
So if we want to, we can say, okay, this is win32 load code.

1142
00:47:37,200 --> 00:47:42,900
We could also do something like this when pretty, to unload game code,

1143
00:47:42,900 --> 00:47:43,400
right?

1144
00:47:43,400 --> 00:47:48,600
Which would basically be taking this one through to game code thing

1145
00:47:48,600 --> 00:47:52,200
here and it will take one of these and

1146
00:47:52,800 --> 00:47:55,100
It just just flat-out, get rid of it.

1147
00:47:55,100 --> 00:47:55,400
Right?

1148
00:47:55,400 --> 00:47:56,500
So we've got our game code.

1149
00:47:56,500 --> 00:47:59,100
It's going to take a pointer to the game code and it's going to go

1150
00:47:59,100 --> 00:47:59,800
ahead and say

1151
00:48:00,000 --> 00:48:01,100
It's valid, right?

1152
00:48:01,100 --> 00:48:02,700
Well, actually I guess doesn't even need to do that.

1153
00:48:02,700 --> 00:48:07,600
It's going to go ahead and do a free library on game code dll.

1154
00:48:07,700 --> 00:48:14,400
Right, assuming that game code, dll was actually there we go, assuming

1155
00:48:14,400 --> 00:48:15,300
that it was actually there.

1156
00:48:15,300 --> 00:48:18,300
It's going to free it and then regardless of what it's going to do.

1157
00:48:18,500 --> 00:48:23,600
It'll just go ahead and set this stuff so that basically the game code

1158
00:48:23,600 --> 00:48:26,200
is no longer considered valid, right?

1159
00:48:26,200 --> 00:48:29,800
It's not valid anymore and the

1160
00:48:30,000 --> 00:48:32,100
It's the, everything is reset to the stuffs game.

1161
00:48:32,100 --> 00:48:34,000
Code update render.

1162
00:48:35,300 --> 00:48:41,400
Game code samples that and so that will unload our game code, right?

1163
00:48:42,500 --> 00:48:46,900
So let's see No Object file generated on login code on reference local

1164
00:48:46,900 --> 00:48:47,400
function.

1165
00:48:47,400 --> 00:48:47,900
Okay.

1166
00:48:48,200 --> 00:48:50,000
Well, that's fine because we're about to use it.

1167
00:48:50,200 --> 00:48:54,300
So now if we really wanted to be absurd, which I don't want to be but

1168
00:48:54,300 --> 00:48:58,000
I'm just going to demonstrate the fact that we could be absurd.

1169
00:48:58,000 --> 00:49:04,200
If we wanted to in theory we could go ahead and actually just load and

1170
00:49:04,200 --> 00:49:04,800
unload the

1171
00:49:05,100 --> 00:49:08,100
Code every time through this Loop, right?

1172
00:49:08,200 --> 00:49:11,600
There's absolutely no reason why we couldn't do that, right?

1173
00:49:11,700 --> 00:49:14,100
I can go in here and I can say, all right.

1174
00:49:14,200 --> 00:49:17,400
I'm going to take this game code and I'm going to load and I'm going

1175
00:49:17,400 --> 00:49:20,000
to unload it every time, right?

1176
00:49:20,000 --> 00:49:21,300
So there's the, there's the load.

1177
00:49:21,300 --> 00:49:21,700
Oops.

1178
00:49:23,300 --> 00:49:23,800
Sporadic.

1179
00:49:23,800 --> 00:49:25,600
Equest, there's the load.

1180
00:49:25,600 --> 00:49:26,300
There's the unload.

1181
00:49:26,300 --> 00:49:31,200
So what I'll do is, I'll go into our running thing at the top of the

1182
00:49:31,200 --> 00:49:31,600
loop.

1183
00:49:31,600 --> 00:49:33,200
I'll load the game code in.

1184
00:49:33,500 --> 00:49:37,900
And after we're done with our game Loop, I'll just unload it, right.

1185
00:49:38,200 --> 00:49:38,900
Which one of these.

1186
00:49:38,900 --> 00:49:39,600
Let's see here.

1187
00:49:39,600 --> 00:49:40,800
That's wild Global running.

1188
00:49:40,800 --> 00:49:41,500
So there we go.

1189
00:49:41,600 --> 00:49:42,700
That's the samples.

1190
00:49:44,100 --> 00:49:46,900
So, in theory, I think that'll actually work but it'd probably take

1191
00:49:46,900 --> 00:49:48,800
our frame rate, but I think it actually would work.

1192
00:49:48,800 --> 00:49:49,700
Let's find out.

1193
00:49:49,900 --> 00:49:51,000
Yeah, so it totally.

1194
00:49:51,000 --> 00:49:53,100
It's going to ruin things a bit for us.

1195
00:49:53,300 --> 00:49:57,100
But, you know, it appears to work and you can actually see it.

1196
00:49:57,100 --> 00:49:58,400
If you actually look in here.

1197
00:49:58,400 --> 00:50:03,300
If we look at our history, you can see us, unload, and load unload,

1198
00:50:03,300 --> 00:50:06,200
and load, unload and load all the time.

1199
00:50:06,200 --> 00:50:06,700
Right?

1200
00:50:08,000 --> 00:50:10,900
So basically, what's happening there is it's actually going to load

1201
00:50:10,900 --> 00:50:11,700
and unload.

1202
00:50:11,800 --> 00:50:15,300
This guy that stuff that we built in here all the time.

1203
00:50:15,500 --> 00:50:19,400
Now, what we can do is we can go in here and say now we we actually

1204
00:50:19,400 --> 00:50:20,100
have a problem.

1205
00:50:20,100 --> 00:50:21,100
I just realized

1206
00:50:22,200 --> 00:50:24,900
We still have a static variable in here, right?

1207
00:50:25,000 --> 00:50:28,800
That t sine should have gotten moved out to the game state, but it

1208
00:50:28,800 --> 00:50:29,700
never did.

1209
00:50:30,000 --> 00:50:32,900
So we need, we need to get rid of all our local persist because there

1210
00:50:32,900 --> 00:50:34,100
shouldn't have been any more of those.

1211
00:50:34,100 --> 00:50:36,700
And that's going to cause a problem because those things are in the

1212
00:50:36,700 --> 00:50:39,400
dll, so it gets loaded and unloaded they're going to reset every time.

1213
00:50:39,900 --> 00:50:43,900
So we've got a t sign here, let's go ahead and and fix that.

1214
00:50:43,900 --> 00:50:46,500
So that t sine actually gets initialized properly.

1215
00:50:46,500 --> 00:50:49,800
So in the game State, when we set the tone hurts, we're going to go

1216
00:50:49,800 --> 00:50:51,800
ahead and set the T sine equal to zero point zero.

1217
00:50:52,400 --> 00:50:56,600
And now when T sign gets used, we're actually going to use sort of the

1218
00:50:56,600 --> 00:50:59,000
game State T sign, right?

1219
00:50:59,200 --> 00:50:59,700
So

1220
00:51:00,100 --> 00:51:03,500
Here, game State, and all I'm doing, they're really very

1221
00:51:03,500 --> 00:51:04,100
straightforward.

1222
00:51:04,100 --> 00:51:04,200
Right?

1223
00:51:04,200 --> 00:51:07,500
I'm just, I had a old static variable, a local persistent variable,

1224
00:51:07,500 --> 00:51:10,400
and I don't want that because we don't want anything stored in the

1225
00:51:10,400 --> 00:51:11,100
dll.

1226
00:51:11,200 --> 00:51:14,300
We just want everything to come in in the standard memory like we

1227
00:51:14,300 --> 00:51:15,000
planned.

1228
00:51:15,400 --> 00:51:17,000
And so, I'm going to go ahead and do that.

1229
00:51:17,300 --> 00:51:19,500
And now, we just need to pass that game State.

1230
00:51:19,600 --> 00:51:23,600
Because presumably, this does not take that currently.

1231
00:51:24,200 --> 00:51:24,900
So here we go.

1232
00:51:24,900 --> 00:51:28,100
Game state do right up there.

1233
00:51:29,800 --> 00:51:31,400
So game output sound.

1234
00:51:31,400 --> 00:51:32,800
Now has to take the game state.

1235
00:51:32,800 --> 00:51:35,900
But other than that, everything is good and let's rerun it.

1236
00:51:37,000 --> 00:51:37,800
There we go.

1237
00:51:38,000 --> 00:51:43,300
Good as new and somehow that is so fast that we actually can do it

1238
00:51:43,300 --> 00:51:44,100
every frame.

1239
00:51:44,500 --> 00:51:46,000
I guess because their code is so small.

1240
00:51:46,200 --> 00:51:50,200
It's a little surprising, but it kind of works right now in theory and

1241
00:51:50,200 --> 00:51:52,400
I don't know because we're loading and unloading it so fast.

1242
00:51:52,400 --> 00:51:54,900
The compiler may not be able to slip in there to actually write the

1243
00:51:54,900 --> 00:51:57,200
file in theory.

1244
00:51:57,200 --> 00:52:01,700
What we should be able to do if we really want to write is while this

1245
00:52:01,700 --> 00:52:05,800
is running, we should now be able to do some really crazy town stuff.

1246
00:52:06,500 --> 00:52:09,200
Right, we should be able to come in here and say, okay.

1247
00:52:09,900 --> 00:52:11,500
I don't know the games running.

1248
00:52:12,200 --> 00:52:15,700
But if I wanted to, I could come in here and say that this was

1249
00:52:15,700 --> 00:52:19,900
actually going to be shifted up 16 instead, right when I compile that.

1250
00:52:20,300 --> 00:52:23,200
Yeah, so that's the problem is it can't ever open it for writing to

1251
00:52:23,200 --> 00:52:24,200
see how that's happening.

1252
00:52:24,300 --> 00:52:27,100
So I got to do the next of my process before we can really get to the

1253
00:52:27,100 --> 00:52:27,700
awesomeness.

1254
00:52:28,100 --> 00:52:31,200
All right, that's ok, because the next step is pretty darn trivial.

1255
00:52:32,300 --> 00:52:34,100
The next step is pretty darn trivial.

1256
00:52:34,600 --> 00:52:36,200
So all we have to do

1257
00:52:36,400 --> 00:52:39,700
Now, is we're loading, and unloading this code every frame, but we're

1258
00:52:39,700 --> 00:52:40,800
loading, and unloading it.

1259
00:52:40,800 --> 00:52:44,400
So fast that the compiler doesn't actually have a chance to write to

1260
00:52:44,400 --> 00:52:47,800
the file because it's always being opened by hours.

1261
00:52:48,000 --> 00:52:50,300
So, I guess one thing I could do.

1262
00:52:50,500 --> 00:52:53,100
Here's a, here's an easier way to do it than what I was going to do.

1263
00:52:53,100 --> 00:52:56,000
So let's let's actually try to verify that this works first and then

1264
00:52:56,000 --> 00:52:59,300
we'll go back and do it the fancier way because we're almost out of

1265
00:52:59,300 --> 00:53:02,800
time and so maybe the fancier way we'll have to wait till tomorrow.

1266
00:53:02,900 --> 00:53:05,800
So where is my load game code?

1267
00:53:05,800 --> 00:53:06,200
So here's my

1268
00:53:06,300 --> 00:53:07,200
I load game code.

1269
00:53:07,200 --> 00:53:10,500
So all I'm going to do is I'm going to load the game code before we

1270
00:53:10,500 --> 00:53:11,900
enter here, right?

1271
00:53:12,300 --> 00:53:15,500
But then I'm going to take the free code, the VM, the unload game

1272
00:53:15,500 --> 00:53:16,600
code, right?

1273
00:53:16,600 --> 00:53:19,200
And I'm actually just going to do at the top of the loop.

1274
00:53:19,500 --> 00:53:23,700
I'm going to do the unload game code and then I'm going to do the load

1275
00:53:23,700 --> 00:53:26,300
game code immediately after, right?

1276
00:53:26,700 --> 00:53:29,300
And I'm going to actually, I think what I want to do here.

1277
00:53:29,800 --> 00:53:30,800
Well, no, this is fine.

1278
00:53:31,200 --> 00:53:33,500
So we'll basically just do this, right?

1279
00:53:33,600 --> 00:53:34,200
So there we go.

1280
00:53:35,200 --> 00:53:36,200
That so

1281
00:53:36,400 --> 00:53:39,900
All I'm going to do here is I'm going to basically say, you know, I've

1282
00:53:39,900 --> 00:53:44,600
got a counter load counter and that load counter is going to be like

1283
00:53:44,600 --> 00:53:46,800
every 60 frames or something like that.

1284
00:53:46,800 --> 00:53:47,000
Right?

1285
00:53:47,000 --> 00:53:49,900
So every 2 seconds, maybe we'll make it a little bit more, right?

1286
00:53:49,900 --> 00:53:50,600
Like that.

1287
00:53:50,900 --> 00:53:55,400
And what I'm going to do here is basically say if the load counter is

1288
00:53:55,400 --> 00:53:59,300
greater than 120, then we'll reset the load counter so that we just do

1289
00:53:59,300 --> 00:53:59,800
it.

1290
00:54:00,000 --> 00:54:03,900
Every few times through the loop, if that makes sense, but that's all

1291
00:54:03,900 --> 00:54:04,400
we're going to do.

1292
00:54:05,100 --> 00:54:08,800
So we will say every time through the loop increment, the load

1293
00:54:08,800 --> 00:54:09,300
counter.

1294
00:54:09,400 --> 00:54:12,500
This will give us 120 frames.

1295
00:54:12,500 --> 00:54:14,300
30 frames a second is like four seconds.

1296
00:54:14,400 --> 00:54:17,400
That should give the compiler some time to open the file.

1297
00:54:17,400 --> 00:54:20,200
So that's that's that's all I did is I just said, all right, let's

1298
00:54:20,200 --> 00:54:23,500
let's only unload and load it that frequently if that makes sense.

1299
00:54:23,800 --> 00:54:24,900
So off we go.

1300
00:54:26,000 --> 00:54:26,400
Let's see.

1301
00:54:26,400 --> 00:54:29,800
Now if we can actually get the file to open at some point.

1302
00:54:30,000 --> 00:54:30,900
So, let's see here.

1303
00:54:30,900 --> 00:54:31,700
Can we do it?

1304
00:54:32,200 --> 00:54:33,100
Can we do it?

1305
00:54:33,600 --> 00:54:34,500
Can we do it?

1306
00:54:34,600 --> 00:54:35,500
No, we can't.

1307
00:54:36,700 --> 00:54:37,100
Well.

1308
00:54:39,100 --> 00:54:42,500
I wonder if that's a wonder if I'm doing something wrong in terms of

1309
00:54:42,500 --> 00:54:46,500
freeing the library because that could also be the case Free Library.

1310
00:54:47,000 --> 00:54:49,700
We are still, we are doing the Free Library.

1311
00:54:49,700 --> 00:54:51,300
Although this should actually do.

1312
00:54:52,600 --> 00:54:55,400
I should actually set this so that it's clear.

1313
00:54:55,400 --> 00:54:57,800
What's happening here for some reason?

1314
00:54:58,700 --> 00:55:01,300
That is oh well, duh.

1315
00:55:01,500 --> 00:55:03,600
I don't know why I thought that was going to make it any better.

1316
00:55:03,800 --> 00:55:04,600
Now that I think about it.

1317
00:55:04,600 --> 00:55:07,500
That's just dumb because basically yeah.

1318
00:55:07,900 --> 00:55:10,200
Basically, I still have to do one more step of the problem process

1319
00:55:10,200 --> 00:55:13,200
because this will still only leave it unlocked in between there just

1320
00:55:13,200 --> 00:55:14,500
because I'm not reloading it again.

1321
00:55:14,700 --> 00:55:18,100
Obviously, the dll will be locked while it's being used.

1322
00:55:18,300 --> 00:55:20,600
So I got to do one more step of the process.

1323
00:55:20,800 --> 00:55:21,300
Right?

1324
00:55:21,900 --> 00:55:24,900
What I gotta do is I gotta make it so that I'm not locking the thing

1325
00:55:24,900 --> 00:55:27,400
that the compiler is outputting to, right.

1326
00:55:27,700 --> 00:55:30,500
So the way that I'm going to do that is I'm just going to when I do

1327
00:55:30,500 --> 00:55:33,400
the reload, I'm just going to copy that file, right?

1328
00:55:33,400 --> 00:55:36,200
I'm just going to use the copy file call, which is a Windows call,

1329
00:55:36,700 --> 00:55:37,000
right?

1330
00:55:37,000 --> 00:55:37,700
Copy file.

1331
00:55:37,800 --> 00:55:42,400
Oh, and the copy file function, just basically takes two things and

1332
00:55:42,500 --> 00:55:43,600
does the copy.

1333
00:55:43,700 --> 00:55:46,600
Write, it just takes an existing file and a new file.

1334
00:55:46,600 --> 00:55:48,300
It copies from the existing to the new one.

1335
00:55:48,300 --> 00:55:48,800
That's it.

1336
00:55:48,800 --> 00:55:51,600
And you can pass it whether you want to fail if the new file exists or

1337
00:55:51,600 --> 00:55:52,000
not.

1338
00:55:52,100 --> 00:55:55,100
So if you want to always create a new one, which we know, so all I'm

1339
00:55:55,100 --> 00:55:57,500
going to do is basically like call.

1340
00:55:57,700 --> 00:55:58,500
There's something called.

1341
00:55:58,500 --> 00:56:01,000
Let's say handmade temp dot DL.

1342
00:56:01,000 --> 00:56:01,400
L.

1343
00:56:01,700 --> 00:56:05,600
And I'm going to copy handmade .exe to that handmade tap, right?

1344
00:56:05,600 --> 00:56:06,600
That's all I'm going to do.

1345
00:56:06,700 --> 00:56:07,700
Nothing for nothing.

1346
00:56:07,900 --> 00:56:08,500
We're there.

1347
00:56:08,500 --> 00:56:10,900
I'm gonna do that copy, right?

1348
00:56:11,900 --> 00:56:15,000
And the copy is going to allow me to lock a file.

1349
00:56:15,000 --> 00:56:18,800
That is not the file that the compiler is outputting to write pretty

1350
00:56:18,800 --> 00:56:19,600
straightforward.

1351
00:56:19,800 --> 00:56:23,800
So I know that'll work because now I'm not locking that file anymore.

1352
00:56:23,800 --> 00:56:27,600
I'm locking and unlocking a different file, and I know that I will do

1353
00:56:27,600 --> 00:56:29,100
the copy when I have it unlocked.

1354
00:56:29,100 --> 00:56:31,600
So let's take a look at this here.

1355
00:56:31,600 --> 00:56:32,000
Oops.

1356
00:56:32,200 --> 00:56:32,900
That's not good.

1357
00:56:32,900 --> 00:56:34,500
Looks like my copy did not work particularly.

1358
00:56:34,500 --> 00:56:37,500
Well, did that actually work?

1359
00:56:37,800 --> 00:56:41,400
Where's my copy file juror 0?

1360
00:56:41,400 --> 00:56:43,600
Because we're running in the data directory as well, aren't we?

1361
00:56:44,500 --> 00:56:50,300
Okay, so we need to do one more thing, which is a little janky.

1362
00:56:50,300 --> 00:56:52,800
Okay, but we can get we can get around that for the time being.

1363
00:56:53,300 --> 00:56:53,600
All right.

1364
00:56:53,600 --> 00:56:56,800
So basically the problem here though, is this stuff only works.

1365
00:56:56,800 --> 00:56:59,000
This is only without a path.

1366
00:56:59,100 --> 00:56:59,800
This is only going to work.

1367
00:57:00,000 --> 00:57:02,500
If this stuff is in the current directory, so what I need to do

1368
00:57:02,500 --> 00:57:05,300
temporarily is set the current director do that because until we do

1369
00:57:05,300 --> 00:57:07,300
the full thing, which I guess we'll have to again.

1370
00:57:07,300 --> 00:57:08,600
Wait till tomorrow to do.

1371
00:57:08,900 --> 00:57:11,500
We don't have, we don't know where we're looking for stuff.

1372
00:57:11,500 --> 00:57:13,400
We don't know where those dlls are going to be.

1373
00:57:13,500 --> 00:57:15,600
So we don't really want a handmade.

1374
00:57:16,000 --> 00:57:18,100
We don't really want to hard-code this path in there.

1375
00:57:18,300 --> 00:57:21,100
So what I'm going to do is I'm going to actually just run it in the

1376
00:57:21,100 --> 00:57:24,900
build directory where everything is and that should actually work,

1377
00:57:25,100 --> 00:57:25,600
right?

1378
00:57:25,600 --> 00:57:28,700
And so now you can see if I look in here, it actually did that.

1379
00:57:28,700 --> 00:57:29,100
It did that?

1380
00:57:29,100 --> 00:57:29,600
Copy that?

1381
00:57:29,600 --> 00:57:29,700
I

1382
00:57:30,000 --> 00:57:33,200
To do and it should be doing that copy every so often, right?

1383
00:57:33,200 --> 00:57:35,300
Because remember I put a timer on the why didn't that lie?

1384
00:57:35,300 --> 00:57:38,400
Timer, it's a frame counter on there so that it will periodically do

1385
00:57:38,400 --> 00:57:38,500
it.

1386
00:57:38,500 --> 00:57:42,800
So now, when I go in here in theory, I should be able to actually

1387
00:57:43,000 --> 00:57:45,000
write to the file, but I don't actually know.

1388
00:57:45,000 --> 00:57:50,100
Let's see are going to program database handmade pdb.

1389
00:57:50,800 --> 00:57:52,600
Oh, but okay.

1390
00:57:53,900 --> 00:57:59,000
So we do have one more problem, which is that the the debugger itself

1391
00:57:59,000 --> 00:57:59,700
is locking.

1392
00:57:59,700 --> 00:57:59,800
Our

1393
00:58:00,000 --> 00:58:05,600
Pdb file as well, which is definitely not what we wanted it to do.

1394
00:58:06,400 --> 00:58:08,400
Oh debugger to bugger.

1395
00:58:08,400 --> 00:58:12,900
Well, alright so we can still make this happen in the short term.

1396
00:58:12,900 --> 00:58:13,200
Here.

1397
00:58:13,800 --> 00:58:14,600
We can run.

1398
00:58:14,700 --> 00:58:18,400
We can run our game outside of the debugger and we can do this.

1399
00:58:18,400 --> 00:58:19,200
I suppose.

1400
00:58:19,300 --> 00:58:20,100
Let's see here.

1401
00:58:20,400 --> 00:58:21,000
There we go.

1402
00:58:23,100 --> 00:58:23,900
So there you go.

1403
00:58:24,400 --> 00:58:27,900
This is now actually doing what we wanted it to do, which is basically

1404
00:58:27,900 --> 00:58:32,400
we can edit the code and have it update while we're running.

1405
00:58:32,600 --> 00:58:33,100
Right?

1406
00:58:33,100 --> 00:58:37,100
And we don't actually have to stop the executable.

1407
00:58:37,100 --> 00:58:39,600
And again, the state is all actually there as well.

1408
00:58:39,600 --> 00:58:39,800
Right?

1409
00:58:39,800 --> 00:58:44,200
There's no, we could get to the bus fight, change the code and see it

1410
00:58:44,200 --> 00:58:48,300
update in real time and without any actual without having to do

1411
00:58:48,300 --> 00:58:48,900
anything, right?

1412
00:58:48,900 --> 00:58:52,300
So, it's, it's sort of as good as having a scripting language, in some

1413
00:58:52,300 --> 00:58:52,600
sense.

1414
00:58:52,800 --> 00:58:57,800
It basically allows us if we want to to edit all the code and we can

1415
00:58:57,800 --> 00:58:59,800
do all sorts of weird stuff here, right?

1416
00:58:59,800 --> 00:59:05,300
We could decide that this was, you know, some other thing and that

1417
00:59:05,300 --> 00:59:07,500
would just be, you know, I don't know, whatever.

1418
00:59:07,500 --> 00:59:09,500
You can see whenever it updates.

1419
00:59:09,500 --> 00:59:12,000
We don't even know what it is, but you can play with the patterns here

1420
00:59:12,500 --> 00:59:14,200
and get pretty immediate feedback.

1421
00:59:14,200 --> 00:59:18,000
Now the feedbacks not quite instant because we're waiting for seconds

1422
00:59:18,000 --> 00:59:21,500
between reloads, but we'll see, we're out of time tonight.

1423
00:59:21,500 --> 00:59:22,700
What will see tomorrow?

1424
00:59:22,700 --> 00:59:25,400
Aro, when we do all the rest of the stuff that has to back this up

1425
00:59:26,000 --> 00:59:28,200
because we only just got it in with the wire tonight.

1426
00:59:28,900 --> 00:59:31,500
What we'll see tomorrow, when we do the rest of us at the back, step

1427
00:59:31,500 --> 00:59:33,600
is how to make that basically instantaneous.

1428
00:59:33,600 --> 00:59:37,400
So that as soon as we hit recompile, it will reload.

1429
00:59:37,800 --> 00:59:38,600
So there you go.

1430
00:59:38,800 --> 00:59:40,300
That was just something again.

1431
00:59:40,300 --> 00:59:42,800
Like I thought we deserved to do something fun because we had done so

1432
00:59:42,800 --> 00:59:47,400
much sort of just wrote stuff with the win32 API where we kind of just

1433
00:59:47,400 --> 00:59:50,000
had to play by its rules and do what it wanted us to do so that we

1434
00:59:50,000 --> 00:59:51,500
could get access to the stuff that we wanted to.

1435
00:59:51,500 --> 00:59:52,700
I thought maybe it'd be fun to do.

1436
00:59:52,800 --> 00:59:55,900
Something cool with the win32 API that lets us do something

1437
00:59:55,900 --> 00:59:56,300
interesting.

1438
00:59:56,300 --> 00:59:58,200
And this is not specific to win32.

1439
00:59:58,700 --> 00:59:59,800
You can do the same sorts of

1440
01:00:00,900 --> 01:00:05,200
On other platforms as well, because almost every platform supports

1441
01:00:05,200 --> 01:00:06,100
Dynamic linking.

1442
01:00:06,700 --> 01:00:09,000
So anyway, this is kind of kind of awesome.

1443
01:00:09,000 --> 01:00:12,000
I like this sort of thing because it just makes it feel a lot cooler

1444
01:00:12,000 --> 01:00:14,100
when you can code to just do that.

1445
01:00:14,100 --> 01:00:19,100
And then it's like, once you, once you change the thing, it I don't

1446
01:00:19,100 --> 01:00:19,200
know.

1447
01:00:19,200 --> 01:00:20,200
It just it just makes it cool.

1448
01:00:20,200 --> 01:00:20,500
So you can see.

1449
01:00:20,500 --> 01:00:23,100
Now we're only clearing like half the screen right?

1450
01:00:23,100 --> 01:00:27,500
Or whatever etcetera, but we've got a lot, this gets even diskettes

1451
01:00:27,500 --> 01:00:29,900
way cooler, so we'll do.

1452
01:00:30,000 --> 01:00:33,200
So much much cooler version of this, as well as some time soon.

1453
01:00:33,300 --> 01:00:34,200
Let's also do.

1454
01:00:34,200 --> 01:00:34,500
I don't know.

1455
01:00:34,500 --> 01:00:37,800
Let's, let's, let's let's play with the with the size of the gradient.

1456
01:00:37,800 --> 01:00:40,000
Maybe, it's just fun to watch it.

1457
01:00:40,000 --> 01:00:41,500
Go sometimes, right.

1458
01:00:42,100 --> 01:00:45,600
There's there's one that's sort of why writer write so on.

1459
01:00:45,900 --> 01:00:47,100
So, anyway, that's pretty cool.

1460
01:00:47,200 --> 01:00:48,700
I hope you enjoyed that little trick.

1461
01:00:48,900 --> 01:00:50,100
We're not done with it.

1462
01:00:50,100 --> 01:00:51,200
It's not nearly as cool.

1463
01:00:51,200 --> 01:00:54,600
It's going to be tomorrow, but we only barely got in there and also we

1464
01:00:54,600 --> 01:00:55,200
do not know.

1465
01:00:55,200 --> 01:00:58,800
I still don't know why it's outputting an egg Z.

1466
01:01:00,000 --> 01:01:00,500
I gotta go.

1467
01:01:00,500 --> 01:01:03,700
I'll go look at my other stuff and find out why?

1468
01:01:03,700 --> 01:01:08,500
Or, you know, I don't know because it's it's still seems to want to do

1469
01:01:08,500 --> 01:01:10,600
an X the export and I do not know why.

1470
01:01:11,100 --> 01:01:11,800
All right.

1471
01:01:12,700 --> 01:01:13,700
So anyway, there we go.

1472
01:01:13,700 --> 01:01:15,100
We've basically taken.

1473
01:01:15,100 --> 01:01:17,500
I mean, that was not very much work, right?

1474
01:01:18,100 --> 01:01:19,000
All we did.

1475
01:01:19,000 --> 01:01:19,300
We did it.

1476
01:01:19,300 --> 01:01:22,600
Extremely, you know, all the work that people put into scripting

1477
01:01:22,600 --> 01:01:25,800
languages and like at the end of the day, there's a lot of stuff.

1478
01:01:25,800 --> 01:01:28,400
You could just do and see if you just tried, right?

1479
01:01:28,400 --> 01:01:29,800
And so, this is an example.

1480
01:01:29,900 --> 01:01:31,000
Ample of how to do that.

1481
01:01:31,400 --> 01:01:34,500
And now you can reload all your code, not just your scripting language

1482
01:01:34,500 --> 01:01:35,800
code at runtime, right?

1483
01:01:35,800 --> 01:01:39,800
So we can reload all the engine code to if we want to which is going

1484
01:01:39,800 --> 01:01:40,800
to be pretty awesome.

1485
01:01:41,300 --> 01:01:43,900
Now, there's a problem of course, which is if the game crashes what do

1486
01:01:43,900 --> 01:01:44,200
you do?

1487
01:01:44,200 --> 01:01:45,000
But that's the thing.

1488
01:01:45,000 --> 01:01:46,900
We're going to take care of tomorrow.

1489
01:01:47,200 --> 01:01:50,900
So anyway, so for tonight, just to recap what we did, as we enter the

1490
01:01:50,900 --> 01:01:51,500
Q&A here.

1491
01:01:51,500 --> 01:01:54,400
Please make sure your questions includes senior ettore in them.

1492
01:01:54,400 --> 01:01:57,400
So I'll see them and try to keep them on what we did today or past.

1493
01:01:57,400 --> 01:01:59,500
But I'm just gonna do a quick recap here because I went pretty fast

1494
01:01:59,500 --> 01:01:59,800
for everything.

1495
01:02:01,200 --> 01:02:03,600
Basically, what we did is we took our build up at file.

1496
01:02:03,800 --> 01:02:05,000
We decided to build two things.

1497
01:02:05,000 --> 01:02:05,900
Instead of one thing.

1498
01:02:06,200 --> 01:02:11,200
We split the game, code into one, basically executable chunk, and the

1499
01:02:11,500 --> 01:02:13,600
platform code into another executable chunk.

1500
01:02:13,800 --> 01:02:14,300
Right?

1501
01:02:14,500 --> 01:02:17,600
We then have the platform executable chunk load.

1502
01:02:17,600 --> 01:02:21,700
And whenever it wants to it, will reload the game executable chunk.

1503
01:02:22,000 --> 01:02:27,600
It then calls Windows to ask it to give it the address of functions in

1504
01:02:27,600 --> 01:02:29,500
that junk in the trunk that loaded.

1505
01:02:29,600 --> 01:02:30,200
It says,

1506
01:02:30,300 --> 01:02:33,400
Are the, where's the sound samples function and the update and render

1507
01:02:33,400 --> 01:02:35,400
function because that's the two functions that I need to call.

1508
01:02:35,600 --> 01:02:37,700
It, gets us back from Windows, it calls them.

1509
01:02:37,700 --> 01:02:40,600
And when it calls them, it passes in a struct in addition to the

1510
01:02:40,600 --> 01:02:40,900
structure.

1511
01:02:40,900 --> 01:02:43,400
We already defined like the asking buffer and that sort of stuff.

1512
01:02:43,700 --> 01:02:44,700
In addition to those.

1513
01:02:44,700 --> 01:02:49,000
We also pass in any functions that we need it to call us back at,

1514
01:02:49,000 --> 01:02:49,100
right.

1515
01:02:49,100 --> 01:02:53,400
So, any calls that go back to the platform layer, which are only debug

1516
01:02:53,400 --> 01:02:54,200
calls at the moment.

1517
01:02:54,200 --> 01:02:57,600
But if we had any that we're actually real calls, we could pass those

1518
01:02:57,600 --> 01:02:58,100
right.

1519
01:02:58,300 --> 01:02:59,500
Those get passed in.

1520
01:03:00,100 --> 01:03:03,500
So that the game has pointers back to where the functions are in the

1521
01:03:03,500 --> 01:03:04,700
main executable as well.

1522
01:03:05,600 --> 01:03:06,500
That's all we did.

1523
01:03:06,500 --> 01:03:09,400
And then we just put in a simple frame counter so that every 120

1524
01:03:09,400 --> 01:03:11,600
frames, it tries to reload the game code.

1525
01:03:11,600 --> 01:03:15,000
That's all we did in the code proper at this time.

1526
01:03:15,000 --> 01:03:18,900
So there you go, pretty simple really straightforward.

1527
01:03:18,900 --> 01:03:22,700
If you architect the code correctly in the first place like we did,

1528
01:03:22,900 --> 01:03:26,100
this is Trivial and I hopefully you saw that was trivial.

1529
01:03:26,100 --> 01:03:29,400
In fact, most of the work we have to do is figuring out which

1530
01:03:30,000 --> 01:03:31,900
On switch to pass to cl to get it out.

1531
01:03:31,900 --> 01:03:35,500
Put the dll that was like, most of the time, but, yeah, but there you

1532
01:03:35,500 --> 01:03:35,800
go.

1533
01:03:35,900 --> 01:03:37,300
So I'll go to the questions now.

1534
01:03:43,000 --> 01:03:44,800
Okay.

1535
01:03:53,200 --> 01:03:57,800
So bunch of people say they think maybe /ld will tell it to Output a

1536
01:03:57,800 --> 01:03:59,200
deal on not an executable.

1537
01:03:59,200 --> 01:04:01,600
So let's try that and hope that they're right.

1538
01:04:01,600 --> 01:04:05,600
Because yeah, I don't we don't I mean we don't have to produce a deal

1539
01:04:05,600 --> 01:04:09,400
as you saw an executable works fine, but it just seems nicer to to do

1540
01:04:09,400 --> 01:04:12,100
a dll because that's I don't know why.

1541
01:04:12,100 --> 01:04:13,500
It's just that's what people do.

1542
01:04:14,600 --> 01:04:16,100
So let's try it LD.

1543
01:04:18,700 --> 01:04:20,000
Incremental link.

1544
01:04:20,600 --> 01:04:23,000
So one of the things we also, you know, I forgot to do this.

1545
01:04:23,200 --> 01:04:25,800
One of the things, we also should do on our common Linker, frags is

1546
01:04:25,800 --> 01:04:29,100
turn off the incremental Linker because since we build everything from

1547
01:04:29,100 --> 01:04:31,400
scratch, every time that's just wasting everyone's time.

1548
01:04:32,200 --> 01:04:34,200
Is it incremental know?

1549
01:04:35,900 --> 01:04:36,300
Okay.

1550
01:04:36,900 --> 01:04:37,600
So let's see.

1551
01:04:37,600 --> 01:04:39,400
I'm going to go in here to our build directory.

1552
01:04:39,600 --> 01:04:42,300
I'm going to delete a handmade star.

1553
01:04:42,500 --> 01:04:43,600
All right, so that's gone.

1554
01:04:44,500 --> 01:04:46,500
And then I am going to rebuild.

1555
01:04:46,600 --> 01:04:47,600
Let's see what we get here.

1556
01:04:48,900 --> 01:04:49,700
Yay.

1557
01:04:49,700 --> 01:04:51,100
Okay, thank you stream.

1558
01:04:51,500 --> 01:04:52,300
That is what we needed.

1559
01:04:52,300 --> 01:04:55,900
We just needed to specify some extra sauce here to just tell, I guess

1560
01:04:55,900 --> 01:05:00,900
the LD / eldest, which this this / DL else, which, I guess tells the

1561
01:05:00,900 --> 01:05:04,700
Linker doubt, put a dll but the /ld switch tells the compiler to do a

1562
01:05:04,700 --> 01:05:07,500
deal on this much market, so that it gets an exit name instead of a

1563
01:05:07,500 --> 01:05:08,200
deal.

1564
01:05:08,200 --> 01:05:10,000
I don't actually know the interaction of these switches.

1565
01:05:10,200 --> 01:05:13,400
I'm not sure it might be that we don't need this one anymore as well.

1566
01:05:13,500 --> 01:05:16,300
Like, once you pass this, it may automatically imply that I'm not

1567
01:05:16,300 --> 01:05:16,500
sure.

1568
01:05:16,500 --> 01:05:17,200
Let's take a look.

1569
01:05:18,200 --> 01:05:18,500
Yeah, so

1570
01:05:18,700 --> 01:05:20,000
Like we can just pass that.

1571
01:05:20,200 --> 01:05:23,800
So basically, I guess it's just if you happen to be calling CL which

1572
01:05:23,800 --> 01:05:27,600
is itself going to summon the Linker, you do /ld.

1573
01:05:27,600 --> 01:05:28,700
I guess is how that works.

1574
01:05:29,000 --> 01:05:29,600
I'm not sure.

1575
01:05:29,700 --> 01:05:31,100
But thank you stream for.

1576
01:05:31,100 --> 01:05:33,200
That's that's really all we needed to get that going.

1577
01:05:33,400 --> 01:05:37,000
So what we can do now is do what we want to do here, which is instead

1578
01:05:37,000 --> 01:05:38,000
of loading him a DOT exe.

1579
01:05:38,000 --> 01:05:40,300
We can load handmade dot DL l.

1580
01:05:41,400 --> 01:05:43,800
Okay, and I'm going to put the two dudes in here as well.

1581
01:05:43,800 --> 01:05:49,400
So Casey to do need to get the proper path here, right?

1582
01:05:50,400 --> 01:05:58,200
And to do automatic determination of when updates.

1583
01:06:00,600 --> 01:06:02,100
Snuggle those in there for tomorrow.

1584
01:06:04,300 --> 01:06:06,800
Okay.

1585
01:06:14,400 --> 01:06:18,300
Use a key, press to unload and keep pressed to load.

1586
01:06:18,600 --> 01:06:20,300
No, so we're going to do something better than a key.

1587
01:06:20,300 --> 01:06:21,600
Press to load/unload tomorrow.

1588
01:06:21,600 --> 01:06:23,500
So we should be we should be fine with that.

1589
01:06:25,000 --> 01:06:26,600
So we have small code right now.

1590
01:06:26,600 --> 01:06:29,800
How does dynamic linking and compiling to Annex e work with huge games

1591
01:06:29,800 --> 01:06:30,500
that are gigs.

1592
01:06:30,500 --> 01:06:35,300
Well, first of all, the reason most huge games are huge, is because

1593
01:06:35,300 --> 01:06:37,600
they are not written, right.

1594
01:06:37,900 --> 01:06:41,100
I know, that's kind of a strong thing to say, but basically like

1595
01:06:42,800 --> 01:06:45,400
Basically, this game will never get huge.

1596
01:06:46,300 --> 01:06:49,100
We will never have a 20 GB executable.

1597
01:06:49,100 --> 01:06:50,200
That's just not going to happen.

1598
01:06:50,800 --> 01:06:52,300
So we really don't have to worry about it.

1599
01:06:52,300 --> 01:06:55,100
The reason that that sort of thing happens is because of bad,

1600
01:06:55,100 --> 01:06:59,000
programming decisions, basically, and sometimes those, sometimes,

1601
01:06:59,000 --> 01:07:02,100
those bad, programming decisions aren't bad in the sense that like

1602
01:07:02,100 --> 01:07:06,300
they were made, because there's a thousand programmers on the project

1603
01:07:06,300 --> 01:07:09,700
and there's no way to actually get everyone to do the right thing.

1604
01:07:09,700 --> 01:07:11,800
So it was just better to have the thing be 20.

1605
01:07:11,900 --> 01:07:12,400
Then whatever.

1606
01:07:12,400 --> 01:07:15,300
And that's so I'm not trying to point the finger at people and say you

1607
01:07:15,300 --> 01:07:16,400
were stupid or anything.

1608
01:07:16,800 --> 01:07:19,000
You may well have been smart and it was the only thing that you could

1609
01:07:19,000 --> 01:07:23,100
do, but when you are architecting things properly, you will never

1610
01:07:23,100 --> 01:07:23,700
ever.

1611
01:07:23,900 --> 01:07:25,800
No matter how complex the game is.

1612
01:07:26,400 --> 01:07:28,400
You will never have a 20 GB executable.

1613
01:07:28,400 --> 01:07:29,600
That's just not going to happen.

1614
01:07:30,200 --> 01:07:31,900
So you're pretty much safe.

1615
01:07:37,800 --> 01:07:39,000
Let's see here.

1616
01:07:40,700 --> 01:07:43,500
For people suggesting find, first change notification.

1617
01:07:43,500 --> 01:07:44,400
Don't spoiler.

1618
01:07:44,400 --> 01:07:45,500
Tomorrow stream.

1619
01:07:45,900 --> 01:07:47,200
I'm not going to tell you what we're using.

1620
01:07:47,200 --> 01:07:49,400
We're going to use some stuff tomorrow.

1621
01:07:49,500 --> 01:07:50,400
That's for tomorrow.

1622
01:07:51,100 --> 01:07:51,700
No, spoilers.

1623
01:07:52,700 --> 01:07:53,900
Let's see here.

1624
01:08:01,300 --> 01:08:04,900
I always have problems with loops and how they work.

1625
01:08:04,900 --> 01:08:09,300
Have you in all your years of coding, learned an easy way to help with

1626
01:08:09,300 --> 01:08:10,000
loops.

1627
01:08:13,300 --> 01:08:16,800
That I do not totally understand CI 12.

1628
01:08:21,600 --> 01:08:25,500
I mean a loop is just very simple, a loop.

1629
01:08:25,800 --> 01:08:27,800
Basically is this

1630
01:08:35,600 --> 01:08:39,500
Write a loop is basically some point in your code.

1631
01:08:40,000 --> 01:08:43,399
And you do some code and then when you get to the end of it you go to

1632
01:08:43,399 --> 01:08:47,200
back to the to the point in the code, right?

1633
01:08:47,399 --> 01:08:52,399
And basically, the only thing that a loop is is a way of conveniently

1634
01:08:52,399 --> 01:08:57,000
writing like a while loop right where I have while you know, something

1635
01:08:57,000 --> 01:08:58,000
is true.

1636
01:08:59,300 --> 01:08:59,800
Do

1637
01:09:00,000 --> 01:09:02,000
Stuff, right.

1638
01:09:02,399 --> 01:09:03,800
Basically, a while loop.

1639
01:09:03,899 --> 01:09:06,300
All of these just get turned into this form.

1640
01:09:06,700 --> 01:09:13,100
This is just basically, if something is true go to top else.

1641
01:09:13,100 --> 01:09:14,700
Don't right.

1642
01:09:18,500 --> 01:09:22,700
So basically, this is a loop, the condition goes in here, right?

1643
01:09:22,700 --> 01:09:24,100
The stuff you do goes in here.

1644
01:09:24,100 --> 01:09:28,700
All these are and all all of see Loops are, is basically the stuff

1645
01:09:28,700 --> 01:09:30,700
that has to get done happens, right?

1646
01:09:30,700 --> 01:09:34,600
And in fact, in this case, we would skip the first one.

1647
01:09:34,600 --> 01:09:38,300
So while loop checks it first, so if something is true, it does the

1648
01:09:38,300 --> 01:09:39,399
stuff, right?

1649
01:09:39,399 --> 01:09:41,600
Then it goes to the, then it goes back to the top.

1650
01:09:42,100 --> 01:09:44,700
And if something isn't true, it just doesn't right.

1651
01:09:44,899 --> 01:09:47,100
So really, it's just, you can imagine it.

1652
01:09:47,100 --> 01:09:48,200
Just executing line by line.

1653
01:09:48,300 --> 01:09:52,600
I'm you can turn any Loop into just an if statement in a go to really

1654
01:09:52,800 --> 01:09:53,100
right.

1655
01:09:53,100 --> 01:09:55,400
There's not there's really nothing to it.

1656
01:09:55,700 --> 01:09:57,200
So, I don't know if you have a more specific question.

1657
01:09:57,200 --> 01:09:58,000
I could try to answer it.

1658
01:09:58,000 --> 01:10:02,000
But Loops you don't have to think of them as something special go to,

1659
01:10:02,000 --> 01:10:04,900
like jump is the only thing that actually exists.

1660
01:10:05,000 --> 01:10:07,200
Go to is the only thing that actually exists at the CPU.

1661
01:10:07,400 --> 01:10:12,000
Loops are purely syntactic sugar, that high-level language is put on

1662
01:10:12,000 --> 01:10:13,100
top of a go to.

1663
01:10:13,400 --> 01:10:14,700
That is all they are.

1664
01:10:16,200 --> 01:10:16,700
So yeah.

1665
01:10:21,400 --> 01:10:25,000
So yeah, let's take a look here.

1666
01:10:29,800 --> 01:10:32,100
Do you recommend playing around with creating dll files or is it?

1667
01:10:32,100 --> 01:10:33,900
Mainly used in specific cases?

1668
01:10:34,500 --> 01:10:37,400
No, I recommend playing around with them all the time.

1669
01:10:37,400 --> 01:10:39,900
Yeah, being able to dynamically load code is a great idea.

1670
01:10:40,000 --> 01:10:40,900
So play around with them.

1671
01:10:40,900 --> 01:10:41,900
See what you can do with them.

1672
01:10:41,900 --> 01:10:43,700
I mean, you saw how easy it is.

1673
01:10:43,900 --> 01:10:46,200
All you have to do is say, here's an entry point.

1674
01:10:46,300 --> 01:10:49,300
I needed exported and then you can get proc address it and off you go.

1675
01:10:49,500 --> 01:10:51,200
So, yeah, see what you can do with it.

1676
01:10:51,200 --> 01:10:53,800
I mean, go to town.

1677
01:10:54,100 --> 01:10:54,900
That's what I would say.

1678
01:11:01,100 --> 01:11:03,000
Let's see.

1679
01:11:07,400 --> 01:11:11,500
Can someone now create a dummy handmade dll and use it to intercept

1680
01:11:11,500 --> 01:11:13,700
the game update and render function to get a pointer to game?

1681
01:11:13,700 --> 01:11:15,700
Memory and change stuff is security.

1682
01:11:15,700 --> 01:11:17,600
Something you will cover in a later stream.

1683
01:11:17,600 --> 01:11:18,900
This is by ambiguous Panda.

1684
01:11:19,700 --> 01:11:25,200
So I don't know why that would be relevant.

1685
01:11:25,200 --> 01:11:28,800
So one of the important things so security is one of those things

1686
01:11:28,800 --> 01:11:32,000
where I don't feel like people really understand it.

1687
01:11:32,000 --> 01:11:37,000
Usually, they tend to think that something is more or less secure.

1688
01:11:37,200 --> 01:11:40,200
Based on a bunch of stuff that isn't actually relevant to its

1689
01:11:40,200 --> 01:11:40,900
security.

1690
01:11:41,300 --> 01:11:44,700
So, if you think about the, the threat model that you're talking

1691
01:11:44,700 --> 01:11:50,000
about, basically, I've got a handmade exe and I've got a handmade dll

1692
01:11:51,300 --> 01:11:53,700
and the only threat model that I've introduced.

1693
01:11:53,700 --> 01:11:56,800
Now that didn't exist previously would be, if for some reason, someone

1694
01:11:56,800 --> 01:11:59,800
had write privileges to handmade dll but didn't

1695
01:12:00,200 --> 01:12:03,900
Have write privileges to handmade exe since they were both installed

1696
01:12:03,900 --> 01:12:07,500
by the same user at the same time who installed the game in the same

1697
01:12:07,500 --> 01:12:08,200
directory.

1698
01:12:09,400 --> 01:12:11,100
I'm not exactly sure.

1699
01:12:11,100 --> 01:12:15,200
Why you would ever think it was less secure to load eggs out of two

1700
01:12:15,200 --> 01:12:17,600
files, executable code out of two files.

1701
01:12:18,000 --> 01:12:18,900
Then one.

1702
01:12:20,300 --> 01:12:21,700
It just really doesn't make any sense.

1703
01:12:21,900 --> 01:12:22,400
Right?

1704
01:12:23,000 --> 01:12:26,400
Because whoever overwrote handmade up dll could have just over wrote

1705
01:12:26,400 --> 01:12:27,500
handmade exe.

1706
01:12:27,700 --> 01:12:27,900
Right?

1707
01:12:27,900 --> 01:12:29,800
There's no reason for them to.

1708
01:12:30,000 --> 01:12:32,800
There's no reason for them to attack handmade dot DL because it

1709
01:12:32,800 --> 01:12:37,400
doesn't have any weaker security than hand me that exe had all virus

1710
01:12:37,400 --> 01:12:39,900
Checkers, understand that there's code in dll and x z.

1711
01:12:39,900 --> 01:12:42,500
So, there isn't such a thing as a place where it's like, checking one

1712
01:12:42,500 --> 01:12:43,000
of the other.

1713
01:12:43,800 --> 01:12:45,800
So basically, yeah, there's really no.

1714
01:12:47,000 --> 01:12:48,500
There's really no security hold there.

1715
01:12:49,800 --> 01:12:51,400
At least not one that I can think of.

1716
01:12:52,100 --> 01:12:52,400
So.

1717
01:12:57,500 --> 01:13:00,000
Also, I think security for games is silly, like that should just be

1718
01:13:00,000 --> 01:13:00,700
built in the OS.

1719
01:13:00,700 --> 01:13:02,800
The fact that the games have to even think about security is

1720
01:13:02,800 --> 01:13:05,500
ridiculous because security should Games should run in a sandbox.

1721
01:13:05,500 --> 01:13:07,300
They're not an application that interconnects.

1722
01:13:07,300 --> 01:13:10,500
So like the fact, you should be able to ship as many security holes as

1723
01:13:10,500 --> 01:13:12,700
you want in a game because game should always run us out.

1724
01:13:12,700 --> 01:13:15,600
Its Windows is entire fault that that isn't true.

1725
01:13:16,000 --> 01:13:22,100
That was just a colossal, a colossal boxing up.

1726
01:13:22,100 --> 01:13:22,700
As they say.

1727
01:13:24,100 --> 01:13:25,200
Let's see here.

1728
01:13:33,200 --> 01:13:34,400
Let's see.

1729
01:13:34,400 --> 01:13:36,600
I'm going to post this again because I'm sure mine got buried.

1730
01:13:36,600 --> 01:13:37,900
We have a tiny application right now.

1731
01:13:37,900 --> 01:13:40,000
So, with code that takes minutes to compile.

1732
01:13:40,200 --> 01:13:40,800
How do we do?

1733
01:13:40,800 --> 01:13:41,500
What we just did?

1734
01:13:41,500 --> 01:13:41,700
Okay.

1735
01:13:41,700 --> 01:13:43,200
So I'm going to say this again.

1736
01:13:44,200 --> 01:13:47,200
I already answered part of that question, but I'm an answer it again

1737
01:13:47,900 --> 01:13:49,700
because you asked it slightly differently this time.

1738
01:13:49,700 --> 01:13:51,500
You asked about taking this to compile.

1739
01:13:51,700 --> 01:13:54,900
If your code ever takes minutes to compile, you've done it.

1740
01:13:54,900 --> 01:13:59,000
Wrong code, should take less than 10 seconds to compile period.

1741
01:13:59,100 --> 01:14:00,600
If your code takes more than 10 seconds.

1742
01:14:00,800 --> 01:14:01,300
Compile.

1743
01:14:02,900 --> 01:14:06,200
You need to stop and figure out why you have written code that way

1744
01:14:06,200 --> 01:14:08,800
because that is a bad way to write code period.

1745
01:14:09,300 --> 01:14:11,300
And I know there's a lot of people who will disagree with that

1746
01:14:11,300 --> 01:14:17,300
statement, but they're wrong like I do not.

1747
01:14:17,300 --> 01:14:19,100
I've never encountered something.

1748
01:14:19,100 --> 01:14:22,500
So complicated that it could not compiled in less than 10 seconds.

1749
01:14:24,400 --> 01:14:27,200
So that's really all I can say.

1750
01:14:28,900 --> 01:14:30,600
I really don't care what it is.

1751
01:14:30,600 --> 01:14:35,300
Like, it's just compilers are extraordinarily fast and machines are

1752
01:14:35,300 --> 01:14:38,000
extraordinarily fast now and the reason that things take 10 minutes to

1753
01:14:38,000 --> 01:14:41,300
compile is because people decided to use all kinds of weird, template

1754
01:14:41,300 --> 01:14:44,400
metaprogramming nonsense and stuff that slows the compiler down

1755
01:14:44,400 --> 01:14:45,100
tremendously.

1756
01:14:45,400 --> 01:14:50,300
And if you go that route, then you basically have sacrificed all of

1757
01:14:50,300 --> 01:14:53,600
the benefits that you could have had, and it's just a really bad

1758
01:14:53,600 --> 01:14:54,100
programming.

1759
01:14:54,300 --> 01:14:56,800
Even so don't make that decision, never make that decision, and you

1760
01:14:56,800 --> 01:14:57,800
won't ever have to worry about it.

1761
01:14:57,800 --> 01:14:59,800
If you do, make that decision all

1762
01:15:00,000 --> 01:15:02,900
Rough and I really can't help you write your in a situation that you

1763
01:15:02,900 --> 01:15:06,000
sort of created and then you will have to do all sorts of things.

1764
01:15:06,000 --> 01:15:08,400
Like now you have to implement an entire scripting language and add

1765
01:15:08,400 --> 01:15:11,100
the butter and at Optimizer for scripting language because you made

1766
01:15:11,100 --> 01:15:14,300
the poor decision to write code that takes multiple minutes to

1767
01:15:14,300 --> 01:15:15,800
compile, right?

1768
01:15:15,800 --> 01:15:17,500
So yeah.

1769
01:15:17,600 --> 01:15:18,600
What can you do now?

1770
01:15:18,600 --> 01:15:22,700
What I will say is verify that you really are in that position.

1771
01:15:23,000 --> 01:15:27,900
Can you break your huge amount of code up into multiple dlls and only

1772
01:15:27,900 --> 01:15:29,800
reload the ones that changed, right?

1773
01:15:30,000 --> 01:15:34,600
Right, you know, can you make if you've got 20 Gigabytes of code, can

1774
01:15:34,600 --> 01:15:39,300
you break that into two hundred dlls and then you only rebuild one

1775
01:15:39,300 --> 01:15:40,900
dll, and it gets reloaded, right?

1776
01:15:40,900 --> 01:15:44,600
I mean, there's an option for you potentially, but there's a lot of

1777
01:15:44,600 --> 01:15:46,500
headaches that go around along with doing something like that.

1778
01:15:46,500 --> 01:15:47,300
So again, I don't know.

1779
01:15:47,300 --> 01:15:50,800
So, the right decision in my opinion is, if your code takes longer

1780
01:15:50,800 --> 01:15:51,600
than 10 seconds to compile.

1781
01:15:51,600 --> 01:15:55,700
You've done something wrong assume that that is true and build your

1782
01:15:55,700 --> 01:15:56,800
project from there.

1783
01:16:09,600 --> 01:16:12,800
Would you be able to load the deal though yourself using read file and

1784
01:16:12,800 --> 01:16:14,900
Implement get proc address as well?

1785
01:16:15,000 --> 01:16:18,100
Assuming there's an easy way to make the memory executable like em

1786
01:16:18,100 --> 01:16:18,700
map.

1787
01:16:18,900 --> 01:16:21,400
Yes, you totally can do that.

1788
01:16:21,400 --> 01:16:25,000
The reason I'm not doing that is because we would like the debugger to

1789
01:16:25,000 --> 01:16:26,900
understand the code.

1790
01:16:27,400 --> 01:16:31,900
So what you have to what you have to understand is that a debugger

1791
01:16:31,900 --> 01:16:37,700
runs by looking at the executable that it is debugging and loading,

1792
01:16:37,700 --> 01:16:39,200
corresponding debug info for

1793
01:16:39,300 --> 01:16:42,500
That executable when a dynamic link library is loaded.

1794
01:16:42,500 --> 01:16:46,100
That is a new set of code that is brought in and the debug information

1795
01:16:46,100 --> 01:16:49,700
for that code is not present in the debug info for the main

1796
01:16:49,700 --> 01:16:50,100
executable.

1797
01:16:50,100 --> 01:16:54,700
So, it has to go and find the debug information for that dll.

1798
01:16:54,700 --> 01:16:59,200
Now, the way that it does this is because loading, the dll through

1799
01:16:59,200 --> 01:17:01,700
Windows is standard hooks, right?

1800
01:17:01,700 --> 01:17:05,400
Load Library, Free Library, the debugger sees those happen and it

1801
01:17:05,400 --> 01:17:09,100
knows to go get the debug info when it sees those happen for the

1802
01:17:09,300 --> 01:17:13,200
Dlls that it's he's loading if we implement the load ourselves.

1803
01:17:13,700 --> 01:17:16,700
Then we get into a situation where the debugger doesn't know.

1804
01:17:16,700 --> 01:17:17,900
We've loaded that code.

1805
01:17:17,900 --> 01:17:21,500
So we can't load the debug information and we can't step through the

1806
01:17:21,500 --> 01:17:23,500
code that we've loaded, right?

1807
01:17:23,900 --> 01:17:26,600
You could go ahead and write a symbol server that the debugger

1808
01:17:26,600 --> 01:17:30,100
connected to and Implement your own symbol server, which made up for

1809
01:17:30,100 --> 01:17:35,300
this shortcoming or stuff like this potentially, which then faked the

1810
01:17:35,300 --> 01:17:37,300
symbols for the executable to look.

1811
01:17:37,300 --> 01:17:39,100
Like they were whatever the symbols were for the

1812
01:17:39,300 --> 01:17:43,400
Hidden code in some back-channel like you could do stuff to patch that

1813
01:17:43,400 --> 01:17:48,500
hole but it's a real long road if you decide to go down Route, so

1814
01:17:48,500 --> 01:17:51,600
basically the reason that we're using Windows to load this and the

1815
01:17:51,600 --> 01:17:54,500
reason that will use like other platforms as well, and we're Implement

1816
01:17:54,500 --> 01:17:58,200
like this on Linux will do the same thing in their way.

1817
01:17:58,700 --> 01:17:59,800
The reason that you do that.

1818
01:18:00,200 --> 01:18:04,700
Is specifically because we want the debugger to understand that we

1819
01:18:04,700 --> 01:18:08,000
loaded that code and to support us which it can do if we go through

1820
01:18:08,000 --> 01:18:08,900
the standard Channel.

1821
01:18:12,500 --> 01:18:14,300
Let us see.

1822
01:18:17,900 --> 01:18:20,800
Is this technique still possible without using the passing of a large

1823
01:18:20,800 --> 01:18:23,100
memory block between the dll and the X Z?

1824
01:18:26,800 --> 01:18:27,800
Well?

1825
01:18:30,900 --> 01:18:31,900
Well.

1826
01:18:41,200 --> 01:18:45,300
So, I believe the answer should generally be yes.

1827
01:18:49,200 --> 01:18:51,700
Let me, let me let me state it this way.

1828
01:18:55,400 --> 01:19:00,800
As long as the dll code always gets its memory from the main

1829
01:19:00,800 --> 01:19:01,600
executable.

1830
01:19:01,800 --> 01:19:02,700
You will be fine.

1831
01:19:03,300 --> 01:19:06,300
Now, there's multiple ways that this can happen, one way that it could

1832
01:19:06,300 --> 01:19:09,400
happen would be to do it the way that I'm doing it right now with the

1833
01:19:09,400 --> 01:19:13,400
does debug calls where when the dll gets loaded it basically gets

1834
01:19:13,400 --> 01:19:16,400
handed some pointers and then you call those pointers when you want

1835
01:19:16,400 --> 01:19:17,100
more memory.

1836
01:19:18,300 --> 01:19:21,400
Because that way all the memory is still allocated in the executable

1837
01:19:21,600 --> 01:19:25,500
and there's no issues with what happens when the dll gets unloaded.

1838
01:19:26,700 --> 01:19:27,300
but,

1839
01:19:29,400 --> 01:19:34,800
By default that is already sort of what happens in Windows because

1840
01:19:34,800 --> 01:19:39,400
what happens is when the dll gets loaded if you use.

1841
01:19:39,600 --> 01:19:45,200
Well, it's not really true if you're using static linking, I don't

1842
01:19:45,200 --> 01:19:49,800
know what happens if you just call new, like, or Malik directly from

1843
01:19:49,800 --> 01:19:50,500
the dll.

1844
01:19:50,500 --> 01:19:52,900
I think when you unload it it'll get freed.

1845
01:19:53,100 --> 01:19:57,500
If it was a statically linked C, runtime library in the dll.

1846
01:19:57,800 --> 01:19:58,300
Now what you can

1847
01:19:58,400 --> 01:20:02,700
Do is, you can change to using a dynamic C, runtime Library, which

1848
01:20:02,700 --> 01:20:08,300
means that both the executable and the dll that you load will share a

1849
01:20:08,300 --> 01:20:08,900
dll.

1850
01:20:08,900 --> 01:20:10,100
That is the C runtime Library.

1851
01:20:10,100 --> 01:20:11,500
So they both call into that.

1852
01:20:12,400 --> 01:20:15,800
But in order to do that, you would have to go onto the build line and

1853
01:20:15,800 --> 01:20:20,200
you'd have to change this - Mt to a minus MD or whatever it is.

1854
01:20:20,200 --> 01:20:21,000
I don't remember.

1855
01:20:21,800 --> 01:20:26,200
So, I mean, so the short answer is, yes, it certainly can work without

1856
01:20:26,200 --> 01:20:28,200
the monolithic block, but the answer is,

1857
01:20:28,300 --> 01:20:29,900
No, you can't just do it willy-nilly.

1858
01:20:29,900 --> 01:20:33,700
You have to actually think about where that memory is coming from and

1859
01:20:33,700 --> 01:20:39,300
make sure that it's coming from a place that won't get purged when the

1860
01:20:39,300 --> 01:20:44,300
dll gets unloaded, so you can definitely make it work, but just you

1861
01:20:44,300 --> 01:20:46,300
have to be aware that it's not free.

1862
01:20:46,800 --> 01:20:50,300
It does take a little bit of planning, but it's it still works.

1863
01:20:55,300 --> 01:20:58,900
Okay, what's next?

1864
01:21:00,900 --> 01:21:03,000
Does the dll prevent the compiler from inlining?

1865
01:21:03,200 --> 01:21:07,100
It prevents the compiler from inlining across the dll boundary, but as

1866
01:21:07,100 --> 01:21:10,400
you've noticed, we don't need that to happen.

1867
01:21:10,500 --> 01:21:10,900
Right?

1868
01:21:11,500 --> 01:21:16,400
We have like, basically our entire game runs inside this function,

1869
01:21:16,700 --> 01:21:17,300
right?

1870
01:21:18,200 --> 01:21:20,100
The entire game is going to be in here.

1871
01:21:20,600 --> 01:21:22,900
So you call game update and render and everything that happens in the

1872
01:21:22,900 --> 01:21:23,700
game is called off here.

1873
01:21:23,700 --> 01:21:26,100
So all of the in line that will have to happen in the game happens

1874
01:21:26,100 --> 01:21:29,500
inside the dll, we never need to in line across that boundary.

1875
01:21:30,400 --> 01:21:31,700
So we don't have to worry about that.

1876
01:21:31,700 --> 01:21:35,400
But know, if, for some reason you wanted to have lots of functions in

1877
01:21:35,400 --> 01:21:38,700
the dll that were small and were called from the platform layer and

1878
01:21:38,700 --> 01:21:42,000
you were counting on inlining, to make that fast, that is a problem

1879
01:21:42,200 --> 01:21:46,000
and that will not work, but you know, don't do that.

1880
01:21:48,600 --> 01:21:50,500
How are we going to implement dlls on Linux Mac?

1881
01:21:50,600 --> 01:21:51,100
They bait.

1882
01:21:51,100 --> 01:21:52,800
They basically have the same thing.

1883
01:21:52,900 --> 01:21:55,200
So they basically have shared libraries as well.

1884
01:21:55,600 --> 01:21:56,500
There's like

1885
01:21:57,700 --> 01:22:00,900
there's just they're just called different things, but that's the

1886
01:22:00,900 --> 01:22:01,200
same.

1887
01:22:04,300 --> 01:22:05,900
Let's see.

1888
01:22:11,400 --> 01:22:12,900
Are there vods for this series?

1889
01:22:12,900 --> 01:22:14,800
I just stumbled upon it and really want to catch up.

1890
01:22:14,800 --> 01:22:16,700
Yes, handmade, hero dot-org.

1891
01:22:17,700 --> 01:22:20,400
If you go to handmade hero dot or you will have everything that you

1892
01:22:20,400 --> 01:22:23,600
need basically news and forums, you click on that.

1893
01:22:24,300 --> 01:22:28,200
And then episode guide will have a bunch of stuff for you that you

1894
01:22:28,200 --> 01:22:28,700
need.

1895
01:22:28,900 --> 01:22:30,300
So that is what you want.

1896
01:22:34,300 --> 01:22:36,200
Let's see here.

1897
01:22:45,200 --> 01:22:48,000
I'm looking for a new question.

1898
01:22:53,000 --> 01:22:57,300
That is on top of the basic.

1899
01:23:03,100 --> 01:23:06,000
Are you ever going to write the platform layers for other platforms on

1900
01:23:06,000 --> 01:23:07,500
the stream in the far future?

1901
01:23:07,500 --> 01:23:10,100
Yes, at the moment.

1902
01:23:10,100 --> 01:23:17,100
If you just want a platform layer to use, you can go to sew and Hammer

1903
01:23:17,100 --> 01:23:17,500
here.or.

1904
01:23:17,500 --> 01:23:20,100
If you click on that news and forums thing again, there's a coating

1905
01:23:20,100 --> 01:23:24,500
resources page and people have already ported it to both sdl and Mac

1906
01:23:24,500 --> 01:23:25,300
OS native.

1907
01:23:26,200 --> 01:23:29,200
So if you want to just run it on other platform, that's actually

1908
01:23:29,200 --> 01:23:31,600
pretty trivial because people already did the hard work for you.

1909
01:23:32,300 --> 01:23:36,800
If you want to watch me pour it, it that won't happen for quite some

1910
01:23:36,800 --> 01:23:40,200
time because basically porting work is just straightforward.

1911
01:23:40,200 --> 01:23:43,400
Grimble work of, take the things we did in win32 and do them in Linux.

1912
01:23:43,400 --> 01:23:46,700
There's nothing, it's literally as uninteresting as it gets.

1913
01:23:46,900 --> 01:23:48,900
So now that we have one platform layer working.

1914
01:23:48,900 --> 01:23:52,900
I'm not going to spend any more time on platform layers until we go to

1915
01:23:52,900 --> 01:23:53,500
ship things.

1916
01:23:54,400 --> 01:23:57,900
But if you just want to get it running right now, you can go access

1917
01:23:57,900 --> 01:23:58,700
those resources.

1918
01:24:09,000 --> 01:24:11,600
Is the process roughly the same for doing the Linux equivalent with

1919
01:24:11,600 --> 01:24:12,400
shared libraries?

1920
01:24:12,400 --> 01:24:15,700
Having seen your windows version would a couple hours of Googling and

1921
01:24:15,700 --> 01:24:19,200
GCC clang, documentation, dignity likely to get me there or should I

1922
01:24:19,200 --> 01:24:20,700
be looking for something specific?

1923
01:24:21,300 --> 01:24:23,000
Yeah, I think so.

1924
01:24:23,000 --> 01:24:26,200
I don't know if David GAO is planning to do.

1925
01:24:26,500 --> 01:24:31,100
So, if you go again to coding resources, David guy who has done this

1926
01:24:31,100 --> 01:24:32,900
awesome thing called handmade penguin.

1927
01:24:33,600 --> 01:24:36,900
That if you go look on here, it's just it's got all sorts of stuff

1928
01:24:36,900 --> 01:24:38,300
that you want to know if you're doing.

1929
01:24:38,500 --> 01:24:39,500
Linux version of this.

1930
01:24:39,500 --> 01:24:43,700
In fact, it's probably I'm going to guess and I don't know, but I'm

1931
01:24:43,700 --> 01:24:46,400
going to guess that this is a better resource than looking at how I

1932
01:24:46,400 --> 01:24:49,200
will port to Linux because I'm less knowledge about Linux that he is,

1933
01:24:49,200 --> 01:24:50,000
I suspect.

1934
01:24:50,800 --> 01:24:54,700
So if he decides to do the dll loading, you may be able to just wait

1935
01:24:54,700 --> 01:24:57,700
for him to do it for you because he may already understand that stuff.

1936
01:24:58,000 --> 01:24:58,300
Really.

1937
01:24:58,300 --> 01:24:58,700
Well.

1938
01:24:59,800 --> 01:25:00,800
If not, then yes.

1939
01:25:00,800 --> 01:25:03,700
I do think that it shouldn't take too long to implement.

1940
01:25:03,700 --> 01:25:06,800
What I just did because you're just looking for three things, how to

1941
01:25:06,800 --> 01:25:08,300
export functions from something.

1942
01:25:08,400 --> 01:25:11,400
I'm in a way so that you could basically call the compiler and say,

1943
01:25:11,500 --> 01:25:14,400
Here's a make, a dynamic library with these functions exported.

1944
01:25:14,400 --> 01:25:18,000
Then you just need load library and get proc address well and free

1945
01:25:18,000 --> 01:25:19,100
library, right?

1946
01:25:19,200 --> 01:25:22,900
So you basically just have those things to do if you can find those,

1947
01:25:23,000 --> 01:25:24,000
that's all you need.

1948
01:25:24,200 --> 01:25:25,600
Right tomorrow.

1949
01:25:25,600 --> 01:25:27,200
We'll do some other fancier stuff.

1950
01:25:27,200 --> 01:25:32,100
And so you may need a couple other things, but, you know, if you just

1951
01:25:32,100 --> 01:25:32,800
want the basics,

1952
01:25:43,100 --> 01:25:46,200
The internet FTW says, you're a pound to find type of magic kind of

1953
01:25:46,200 --> 01:25:48,900
bugs me and that it hides, the arguments return type away from the

1954
01:25:48,900 --> 01:25:49,700
implementation.

1955
01:25:49,700 --> 01:25:52,600
How much of a win is having the signature in one place?

1956
01:25:53,000 --> 01:25:55,400
The answer is, it depends how many times it happens?

1957
01:25:55,900 --> 01:25:59,300
So for these, it's probably no big deal.

1958
01:26:00,100 --> 01:26:02,900
I would say, just if you don't like it, don't do it.

1959
01:26:03,800 --> 01:26:09,100
The the person who's asking the question is asking about these sorts

1960
01:26:09,100 --> 01:26:11,300
of things that I do to make it so that you never have.

1961
01:26:11,400 --> 01:26:15,700
Have to change what the parameters are in multiple places for a

1962
01:26:15,700 --> 01:26:16,300
callback.

1963
01:26:17,000 --> 01:26:19,400
And yeah, you you don't have to do that.

1964
01:26:19,800 --> 01:26:22,300
If you'd rather not do it, then you don't have to.

1965
01:26:23,600 --> 01:26:27,300
But there are certain cases where I would strongly advise that you do,

1966
01:26:27,300 --> 01:26:27,700
do it.

1967
01:26:27,700 --> 01:26:31,200
And those are places where you have lots of the same type of calls.

1968
01:26:31,200 --> 01:26:34,900
So for example, example, if you're making like an entity dispatch and

1969
01:26:34,900 --> 01:26:39,000
you've got 300 entity types in your system, you really want to use

1970
01:26:39,000 --> 01:26:41,300
this macro because if you decide to change the

1971
01:26:41,400 --> 01:26:42,800
Orders that go to an entity dispatch.

1972
01:26:42,800 --> 01:26:44,500
You really don't want to go change it.

1973
01:26:44,500 --> 01:26:47,100
300 times or more depending on the circumstance.

1974
01:26:50,400 --> 01:26:51,900
Let's see.

1975
01:26:55,100 --> 01:26:57,100
How does Windows manage memory in a dll?

1976
01:26:57,100 --> 01:26:59,800
Is there a dll process space where our variables may be?

1977
01:27:00,000 --> 01:27:00,600
A text or at?

1978
01:27:00,600 --> 01:27:03,200
How is Heap memory managed that is allocated from a dll.

1979
01:27:03,200 --> 01:27:08,400
So the answer is, I don't remember some of the specifics of that.

1980
01:27:13,900 --> 01:27:15,200
Basically, what happens is?

1981
01:27:17,800 --> 01:27:21,000
We had some mspaint going on here.

1982
01:27:21,000 --> 01:27:21,400
Yeah.

1983
01:27:23,000 --> 01:27:26,000
So, basically, what happens, let's take a 32-bit executable because

1984
01:27:26,000 --> 01:27:30,200
it's a little simpler to going to conceptualize 64-bit, such a much

1985
01:27:30,200 --> 01:27:31,200
bigger address space.

1986
01:27:32,000 --> 01:27:34,800
So basically, here's two gigabytes of memory.

1987
01:27:35,300 --> 01:27:39,000
And here's two gigabytes of memory here, totaling four gigabytes of

1988
01:27:39,000 --> 01:27:43,900
memory, which for 32 bits of address, space is all the address space.

1989
01:27:43,900 --> 01:27:45,100
There is right.

1990
01:27:45,200 --> 01:27:49,700
Four gigabytes is the maximum addressable memory for for a 32 bits

1991
01:27:49,900 --> 01:27:51,500
pointers, right?

1992
01:27:52,000 --> 01:27:52,600
So typically

1993
01:27:52,700 --> 01:27:57,600
What happens in Windows is you basically have the upper two gig?

1994
01:27:57,700 --> 01:28:00,600
So this is the 2gig with the high bit set.

1995
01:28:01,400 --> 01:28:06,500
The, the high 2gig is for the OS, and the low to gig is for you.

1996
01:28:07,100 --> 01:28:07,600
Right?

1997
01:28:07,600 --> 01:28:08,500
That's how that works.

1998
01:28:09,500 --> 01:28:13,900
So, as far as I know, what happens when you load a dll, is it just

1999
01:28:13,900 --> 01:28:17,600
flat-out picks a place in here and slams that dll code right on in

2000
01:28:17,600 --> 01:28:17,900
there.

2001
01:28:19,100 --> 01:28:22,000
And basically what it does is it uses a memory mapped file to

2002
01:28:22,000 --> 01:28:22,500
basically

2003
01:28:22,600 --> 01:28:24,000
map the file.

2004
01:28:24,000 --> 01:28:25,800
So if this is the disc, right?

2005
01:28:25,800 --> 01:28:27,900
If here's the disc, right?

2006
01:28:28,700 --> 01:28:31,300
You've got your eggs e is on disk somewhere, right?

2007
01:28:31,300 --> 01:28:32,300
There's the X Z.

2008
01:28:32,900 --> 01:28:35,200
And here's the dll is on disk somewhere.

2009
01:28:35,300 --> 01:28:36,800
Who knows where right?

2010
01:28:37,100 --> 01:28:41,200
Basically, what happens is, I shouldn't probably have drawn that quite

2011
01:28:41,200 --> 01:28:41,900
so soon.

2012
01:28:42,200 --> 01:28:43,700
Basically, what happens, right?

2013
01:28:43,700 --> 01:28:47,500
Is when you start up your XZ is mapped into here somewhere, right?

2014
01:28:47,800 --> 01:28:50,000
I'm not trying to say where I'm not trying to say that it slow.

2015
01:28:50,000 --> 01:28:52,500
I'm just saying somewhere in your address, space your eggs.

2016
01:28:52,700 --> 01:28:57,100
Is file gets mapped in and then your dlls file gets mapped in when you

2017
01:28:57,100 --> 01:28:58,500
load it, right?

2018
01:28:59,300 --> 01:29:03,600
And that is how the code gets mapped in now when you allocate memory.

2019
01:29:04,800 --> 01:29:06,600
Basically, there's stuff in here.

2020
01:29:07,000 --> 01:29:09,500
There's different ways of allocating memory, right?

2021
01:29:09,800 --> 01:29:12,600
If a dll were to call virtual a lock.

2022
01:29:13,300 --> 01:29:19,000
I don't know whether that counts towards the exit charge or the dll

2023
01:29:19,000 --> 01:29:19,300
charts.

2024
01:29:19,300 --> 01:29:26,100
So so this is why I say I don't remember the specifics well enough for

2025
01:29:26,100 --> 01:29:26,700
an egg Z.

2026
01:29:26,700 --> 01:29:31,000
If you call virtual Alec like we are, it basically takes some range of

2027
01:29:31,000 --> 01:29:34,500
your executable and reserves it for use as memory and you get back a

2028
01:29:34,500 --> 01:29:35,100
pointer to it.

2029
01:29:35,100 --> 01:29:36,500
So now the X Z is pointing to it.

2030
01:29:36,500 --> 01:29:41,100
When you leave when you when you call virtual free you can free it or

2031
01:29:41,100 --> 01:29:43,300
when your ex he dies, obviously that reservation.

2032
01:29:43,400 --> 01:29:46,700
And goes away and all of the information window stored about that page

2033
01:29:46,700 --> 01:29:47,400
goes away.

2034
01:29:48,300 --> 01:29:50,200
But with the dll, I don't know.

2035
01:29:50,200 --> 01:29:53,900
If it remembers virtual Alex from dlls are not my.

2036
01:29:53,900 --> 01:29:58,900
So my assumption is that it doesn't but I could be wrong about that.

2037
01:29:58,900 --> 01:29:59,800
My assumption is that you

2038
01:30:00,000 --> 01:30:04,700
Virtual Alec from a dll with Alec in here, in your memory space and

2039
01:30:04,700 --> 01:30:07,800
that it would just stay and when you unload the dll, it would still be

2040
01:30:07,800 --> 01:30:11,200
there and the XE could use it but I don't know if that's true.

2041
01:30:12,600 --> 01:30:14,400
The reason that I think that's true.

2042
01:30:15,500 --> 01:30:18,600
So I'll tell you why.

2043
01:30:18,600 --> 01:30:22,800
I think that's true, but you will have to go and verify it yourself.

2044
01:30:24,700 --> 01:30:26,500
So here's virtual Alec.

2045
01:30:27,500 --> 01:30:28,000
Right.

2046
01:30:28,500 --> 01:30:31,800
That's this is what it looks like and virtuality takes an address.

2047
01:30:32,000 --> 01:30:33,700
It says, this is where I want the memory to be.

2048
01:30:33,700 --> 01:30:35,600
It could be zero if you just want Windows to pick an address.

2049
01:30:35,600 --> 01:30:36,800
Here's how big I want it.

2050
01:30:37,200 --> 01:30:39,900
Here's the type of allocation I want and here's the memory protection

2051
01:30:39,900 --> 01:30:40,400
for it.

2052
01:30:40,600 --> 01:30:41,100
Right?

2053
01:30:41,600 --> 01:30:43,800
Well, nowhere in that code.

2054
01:30:43,900 --> 01:30:46,600
Did it have a module handle, right.

2055
01:30:46,600 --> 01:30:51,800
So when you call this Windows, doesn't actually know who's calling it.

2056
01:30:52,000 --> 01:30:57,200
Other than the information about the thread itself, but called.

2057
01:30:57,500 --> 01:31:00,000
Right, it has some way of determining, which thread called it, but

2058
01:31:00,000 --> 01:31:01,000
that's about it.

2059
01:31:01,600 --> 01:31:06,400
So, because that occurs, let's say we go ahead and do a get proc

2060
01:31:06,400 --> 01:31:07,000
address.

2061
01:31:07,600 --> 01:31:10,300
So, we load this dll and there's a procedure in here.

2062
01:31:10,300 --> 01:31:13,200
We do a get proc address and that procedure calls virtual Alec.

2063
01:31:13,200 --> 01:31:15,000
We do a get proc address in the XZ.

2064
01:31:15,100 --> 01:31:17,800
We now have a pointer into this code, right?

2065
01:31:17,900 --> 01:31:18,800
It's just a pointer.

2066
01:31:19,600 --> 01:31:21,100
It's just like, any other function pointer.

2067
01:31:21,800 --> 01:31:25,600
When we dispatch into that from the X Z and then it calls virtual

2068
01:31:25,600 --> 01:31:26,200
Alec.

2069
01:31:26,400 --> 01:31:27,100
I don't see how

2070
01:31:27,200 --> 01:31:31,800
How Windows would even know that the virtual Alec call was coming from

2071
01:31:31,800 --> 01:31:32,600
the DOL.

2072
01:31:32,800 --> 01:31:33,700
Does that make sense?

2073
01:31:34,400 --> 01:31:40,700
So, basically, my assumption is that that, like I said, you have to be

2074
01:31:40,700 --> 01:31:41,500
aware.

2075
01:31:41,500 --> 01:31:44,100
Like I was answering the person before it was saying, what happens if

2076
01:31:44,100 --> 01:31:47,500
you don't pass memory from the executable, yo, you have to be aware

2077
01:31:47,500 --> 01:31:51,300
that there's a difference of between code in the dll and code in the

2078
01:31:51,300 --> 01:31:51,800
XZ.

2079
01:31:51,800 --> 01:31:57,100
You have to be aware of it, but it doesn't mean that you have to

2080
01:31:57,600 --> 01:32:00,200
It doesn't mean that you can't just do all the things that you want to

2081
01:32:00,200 --> 01:32:00,600
do.

2082
01:32:01,500 --> 01:32:03,600
So here's the part that I don't know.

2083
01:32:04,700 --> 01:32:08,300
There are things called heaps that we aren't using right now.

2084
01:32:08,700 --> 01:32:11,200
Okay, and that kind of looks like herpes.

2085
01:32:11,300 --> 01:32:12,700
So let's try and draw that again.

2086
01:32:12,700 --> 01:32:14,100
So that it actually looks like heaps.

2087
01:32:16,300 --> 01:32:16,800
There we go.

2088
01:32:17,900 --> 01:32:22,200
Keeps our a different thing entirely heaps are not virtual.

2089
01:32:22,200 --> 01:32:22,900
Alec calls.

2090
01:32:23,100 --> 01:32:27,000
Heaps are basically things that have called virtual Alec in some way

2091
01:32:27,200 --> 01:32:32,200
and are now portioning out that virtual a lock for you as you ask for

2092
01:32:32,200 --> 01:32:32,700
stuff.

2093
01:32:32,800 --> 01:32:34,800
So they're more like a traditional memory allocator.

2094
01:32:35,500 --> 01:32:40,500
What, I don't know is if there's a heap created for the dll that by

2095
01:32:40,500 --> 01:32:44,500
default calls in the dll that are static, C, runtime Library,

2096
01:32:44,500 --> 01:32:45,700
allocation calls.

2097
01:32:46,100 --> 01:32:50,900
into it, at link time when the dll is linked, not dynamically time,

2098
01:32:50,900 --> 01:32:56,200
but statically Linked In, when the dlls produced, if there is a heap,

2099
01:32:56,200 --> 01:32:59,800
that is normally used that goes with the dll and that

2100
01:33:00,000 --> 01:33:01,500
Will be freed by Windows.

2101
01:33:01,500 --> 01:33:03,000
When the dll is unloaded.

2102
01:33:03,100 --> 01:33:06,700
I suspect that there is and I suspect that you would get into trouble

2103
01:33:06,700 --> 01:33:07,900
if you were relying on that.

2104
01:33:07,900 --> 01:33:13,000
So, for example, if you call new right, and the function new inside

2105
01:33:13,000 --> 01:33:17,100
this dll, when it was called gets compiled to calling and address

2106
01:33:17,100 --> 01:33:20,200
which uses a keep that is the Heap from the dll in some way.

2107
01:33:22,100 --> 01:33:25,600
I don't know, Wright uses a static variable.

2108
01:33:25,600 --> 01:33:29,300
That is the heat pointer that got allocated to dll main or God knows

2109
01:33:29,300 --> 01:33:30,300
what right?

2110
01:33:30,700 --> 01:33:33,000
Hopefully you can follow me why this is not ridiculous what I'm

2111
01:33:33,000 --> 01:33:37,600
saying, then it could very well be that that gets purged on exit.

2112
01:33:38,200 --> 01:33:40,900
So I guess what I would say is there's a lot of things that could be

2113
01:33:40,900 --> 01:33:44,000
going on here if you wanted to do stuff, other than what I showed you,

2114
01:33:44,300 --> 01:33:48,300
you should learn this stuff well, and then you should be able to do

2115
01:33:48,300 --> 01:33:48,600
it.

2116
01:33:49,200 --> 01:33:51,700
But as a rule of thumb, I would

2117
01:33:51,900 --> 01:33:56,700
I'd say that if you're only calling virtual a lock, I suspect, it

2118
01:33:56,700 --> 01:33:59,700
would never matter whether you called it from the exit, or the dll.

2119
01:33:59,700 --> 01:34:03,700
Because I don't think Windows knows which one you're doing.

2120
01:34:04,600 --> 01:34:09,400
If you use new or Malik on the other hand, those are not operating

2121
01:34:09,400 --> 01:34:10,200
system calls.

2122
01:34:10,400 --> 01:34:15,400
Those are calls that call into the CRT and so the same diagram again,

2123
01:34:16,000 --> 01:34:16,600
right?

2124
01:34:18,400 --> 01:34:22,200
Basically, you have to imagine there's a c runtime component of this,

2125
01:34:22,700 --> 01:34:23,300
right?

2126
01:34:23,700 --> 01:34:27,900
So here's my x z and let's say that both the C runtime Library, both

2127
01:34:27,900 --> 01:34:32,600
my eggs e and my dll were statically linked with the c runtime

2128
01:34:32,600 --> 01:34:35,300
Library, not dynamically linked, right.

2129
01:34:35,400 --> 01:34:39,200
Then I look like this, the dll code has a see runtime library in the

2130
01:34:39,200 --> 01:34:39,500
XZ.

2131
01:34:39,500 --> 01:34:40,200
Has a certain time.

2132
01:34:40,200 --> 01:34:42,200
I'll bring it included in.

2133
01:34:42,300 --> 01:34:44,400
This is a static.

2134
01:34:44,400 --> 01:34:47,400
Let's say a static pointer.

2135
01:34:47,600 --> 01:34:50,400
To a heap that gets initialized at startup.

2136
01:34:50,500 --> 01:34:55,500
So there's a static heap, if there's a static Heap then that static

2137
01:34:55,500 --> 01:34:59,400
heat could very well be used by all the calls to Malik that happen in

2138
01:34:59,400 --> 01:35:03,100
this dll because remember the call to malloc exist.

2139
01:35:03,100 --> 01:35:06,700
Now there's there's code for Malik in both of these and both of them

2140
01:35:06,700 --> 01:35:08,100
can use a different static.

2141
01:35:08,100 --> 01:35:10,500
There's a static keep here as well, right?

2142
01:35:11,600 --> 01:35:16,000
So, depending on which compilation unit, you're in, you have resolved

2143
01:35:16,000 --> 01:35:20,800
your calls to Malik to be calling into different pieces of code at

2144
01:35:20,800 --> 01:35:24,700
runtime and all these calls to Malik may use this Heap and all these

2145
01:35:24,700 --> 01:35:29,000
clothes to Malik may use this Heap, which means, two things one, when

2146
01:35:29,000 --> 01:35:33,200
this dll gets unloaded all the heat goes away, that it ever Alec gone.

2147
01:35:33,200 --> 01:35:33,500
Poof.

2148
01:35:33,500 --> 01:35:34,100
Goodbye.

2149
01:35:34,400 --> 01:35:37,400
Right, but the other thing it means is you better be darn.

2150
01:35:37,400 --> 01:35:37,700
Sure.

2151
01:35:37,700 --> 01:35:40,900
That you never pass a pointer that you Mallet in the dll.

2152
01:35:41,000 --> 01:35:45,100
Over to the CRT where then would call free because now you're freeing

2153
01:35:45,100 --> 01:35:45,800
out of a heap.

2154
01:35:45,800 --> 01:35:48,900
That's not the Heap you allocated out of and the same goes vice versa.

2155
01:35:48,900 --> 01:35:51,700
Don't pass in a Malik here that's going to get freed on this guy's

2156
01:35:51,700 --> 01:35:53,500
Heap because now you got to keep mismatch.

2157
01:35:53,500 --> 01:35:57,700
So the solution that a lot of people use to fix that problem, which I

2158
01:35:57,700 --> 01:35:58,700
believe is actually a problem.

2159
01:35:58,700 --> 01:35:59,900
Like I said, I don't remember a lot of

2160
01:36:00,100 --> 01:36:02,600
Because I don't use any of it anymore, but point being.

2161
01:36:04,800 --> 01:36:05,800
You know, it's a thing.

2162
01:36:06,400 --> 01:36:10,400
Basically, what ends up happening is you've got an x z here, right?

2163
01:36:10,500 --> 01:36:12,200
You've got your dll, which is here.

2164
01:36:12,400 --> 01:36:16,500
They then have a CRT dll, so they link dynamically with the c runtime

2165
01:36:16,500 --> 01:36:17,000
library.

2166
01:36:17,400 --> 01:36:21,100
Now both of these guys call into mallik, right?

2167
01:36:22,700 --> 01:36:27,000
And now you're always using the same Heap because the staticky pointer

2168
01:36:27,000 --> 01:36:27,900
is the same for everybody.

2169
01:36:27,900 --> 01:36:30,900
So that is one benefit to using.

2170
01:36:30,900 --> 01:36:32,600
If you're doing crazy stuff like this.

2171
01:36:32,600 --> 01:36:35,000
What should I say crazy, but it's how most people do it?

2172
01:36:35,000 --> 01:36:35,900
I think it's crazy.

2173
01:36:35,900 --> 01:36:40,100
But if you were doing crazy stuff like that, that is one reason to use

2174
01:36:40,100 --> 01:36:46,600
a shared a dynamic link library for the dll because then everyone can

2175
01:36:46,600 --> 01:36:49,900
just malloc and free memory using standard new and delete or malloc

2176
01:36:49,900 --> 01:36:50,000
and free.

2177
01:36:50,000 --> 01:36:52,700
And it just works because they're all sharing the same.

2178
01:36:52,700 --> 01:36:55,000
Same code for the C runtime Library.

2179
01:36:56,900 --> 01:36:59,000
Okay, so we're basically done here.

2180
01:36:59,000 --> 01:36:59,700
We're out of time.

2181
01:36:59,700 --> 01:37:02,100
So let me just double check to see what we've got.

2182
01:37:03,000 --> 01:37:04,500
Let's see.

2183
01:37:07,200 --> 01:37:09,100
Let's see here.

2184
01:37:12,100 --> 01:37:13,500
Let's see here.

2185
01:37:15,500 --> 01:37:17,100
Any Mouse doesn't Windows no.

2186
01:37:17,100 --> 01:37:20,500
By the instruction pointer is leading up to the virtual a lot call.

2187
01:37:21,400 --> 01:37:26,600
No, I mean it would have to walk the stack right in order to know who

2188
01:37:26,600 --> 01:37:30,300
it was because you're not passing, really anything that would identify

2189
01:37:30,300 --> 01:37:30,400
them.

2190
01:37:30,400 --> 01:37:32,400
I don't think so.

2191
01:37:32,400 --> 01:37:37,400
It could walk the stack and try to figure out, but, you know, or look

2192
01:37:37,400 --> 01:37:39,200
at the return value address, I guess.

2193
01:37:39,200 --> 01:37:41,000
And then you see which one that's in.

2194
01:37:41,000 --> 01:37:44,300
But, you know, that's, that's work that I don't think it does.

2195
01:37:45,000 --> 01:37:48,000
Does, I'm not sure but we'll see.

2196
01:37:49,600 --> 01:37:52,700
Again, I don't do any of that stuff because I don't want to rely on

2197
01:37:52,700 --> 01:37:54,600
operating system behavior that I don't have to.

2198
01:37:54,700 --> 01:37:56,600
So it's one of the reasons rather reasons.

2199
01:37:56,600 --> 01:37:59,200
I don't know that answer offhand is because I just don't do that

2200
01:37:59,600 --> 01:38:02,600
because it can only lead to portability problems in some sense.

2201
01:38:03,300 --> 01:38:05,400
If you start relying on stuff like that, I think.

2202
01:38:08,000 --> 01:38:08,900
So.

2203
01:38:09,900 --> 01:38:10,700
What is the?

2204
01:38:10,700 --> 01:38:14,600
So Gareth Lewin is saying that allocating cross-boundary is there's a

2205
01:38:14,600 --> 01:38:17,200
different reason for it, but I'm not sure he doesn't actually

2206
01:38:18,200 --> 01:38:20,000
Posted what it is.

2207
01:38:20,300 --> 01:38:25,600
So I'm not sure what the answer is, what he wanted me to say.

2208
01:38:27,900 --> 01:38:31,500
So, I don't know if there is a way he could, of course, there's a

2209
01:38:31,500 --> 01:38:32,000
delay.

2210
01:38:32,000 --> 01:38:37,500
So now he doesn't know that I'm asking him to post what he wants to

2211
01:38:37,500 --> 01:38:40,000
say, but let's see.

2212
01:38:50,400 --> 01:38:53,000
So the internet FTW, such a mess around the system, maintains a

2213
01:38:53,000 --> 01:38:54,500
purpose reference count for each dll.

2214
01:38:54,500 --> 01:38:54,700
Yes.

2215
01:38:54,700 --> 01:38:55,100
It does.

2216
01:38:55,100 --> 01:38:57,300
When the reference cap comes 0 DLC, unloaded from the virtual address

2217
01:38:57,300 --> 01:38:58,000
space of the process.

2218
01:38:58,000 --> 01:38:58,200
Yes.

2219
01:38:58,200 --> 01:38:58,700
It does.

2220
01:38:58,700 --> 01:38:59,800
The dll uses the stack.

2221
01:39:00,200 --> 01:39:02,700
The calling thread and the virtual address base of the calling

2222
01:39:02,700 --> 01:39:03,400
process.

2223
01:39:03,500 --> 01:39:06,800
Yes, the dll kids memory from the virtual address space of the calling

2224
01:39:06,800 --> 01:39:07,200
process.

2225
01:39:07,200 --> 01:39:07,700
Yes.

2226
01:39:10,000 --> 01:39:11,200
so,

2227
01:39:12,800 --> 01:39:15,400
But that's what I'll just said, right?

2228
01:39:15,400 --> 01:39:19,600
So that sounds like, msdn is just saying what I said, is there

2229
01:39:19,600 --> 01:39:20,600
something that?

2230
01:39:20,700 --> 01:39:21,200
So I don't know.

2231
01:39:21,200 --> 01:39:23,900
If someone could tell me what they think is incorrect because I just

2232
01:39:23,900 --> 01:39:26,000
want to make sure before we end the stream that if there is something

2233
01:39:26,000 --> 01:39:28,300
incorrect that I could correct it or Point people to the correct

2234
01:39:28,300 --> 01:39:31,300
version of it, but that sounds exactly, correct.

2235
01:39:41,000 --> 01:39:41,900
so,

2236
01:39:44,100 --> 01:39:44,800
I got nothing.

2237
01:39:46,100 --> 01:39:47,200
So Gareth Lewin.

2238
01:39:48,200 --> 01:39:53,900
You you have a few more seconds here to tell me what it is.

2239
01:39:53,900 --> 01:39:55,100
You think is incorrect.

2240
01:39:55,700 --> 01:39:58,800
Otherwise, it will have to wait, I suppose till discussion on the

2241
01:39:58,800 --> 01:39:59,400
forums.

2242
01:39:59,600 --> 01:40:02,200
If someone thinks there's something incorrect about that explanation.

2243
01:40:03,900 --> 01:40:06,200
So I will go ahead and say that now.

2244
01:40:06,600 --> 01:40:09,900
So if we are basically at the end of the string, but I'm going to wait

2245
01:40:09,900 --> 01:40:11,700
a little bit, just to let the questions cup up.

2246
01:40:11,700 --> 01:40:13,800
Catch up there in case someone wants to type in what they think was

2247
01:40:13,800 --> 01:40:15,000
wrong about that explanation.

2248
01:40:15,600 --> 01:40:15,800
Based.

2249
01:40:16,000 --> 01:40:21,800
Only, if you go to handmade here a.org and obviously you can pre-order

2250
01:40:21,800 --> 01:40:24,400
The Source on here, if you'd like to if you'd like to follow along at

2251
01:40:24,400 --> 01:40:25,800
home, you can get the source code every night.

2252
01:40:25,800 --> 01:40:29,100
I push the source code every night so you can redownload it and see

2253
01:40:29,100 --> 01:40:30,000
where we were at.

2254
01:40:30,400 --> 01:40:31,600
If you'd like to follow along at home.

2255
01:40:31,600 --> 01:40:35,400
It makes it a lot easier, but you can also click on news and forums

2256
01:40:35,600 --> 01:40:37,700
and that will get you a little resource site.

2257
01:40:37,700 --> 01:40:37,900
Here.

2258
01:40:37,900 --> 01:40:39,900
It has the schedule for the week to post it on there.

2259
01:40:39,900 --> 01:40:43,900
It has an episode guide that you can use to catch up if you're or to

2260
01:40:43,900 --> 01:40:45,100
re reference older things.

2261
01:40:45,400 --> 01:40:45,700
It has a

2262
01:40:45,900 --> 01:40:48,500
Coding Resource page with has ports and stuff like that, but you can

2263
01:40:48,500 --> 01:40:50,600
go to do as well as other informational.

2264
01:40:50,600 --> 01:40:51,800
Good information, materials.

2265
01:40:52,000 --> 01:40:55,000
And finally, there's a Code discussion button here, which is where you

2266
01:40:55,000 --> 01:40:55,700
can post stuff.

2267
01:40:55,700 --> 01:40:59,200
Like if you think an explanation was incorrect or you just weren't

2268
01:40:59,200 --> 01:41:02,300
sure about something you could post on here and other people and me

2269
01:41:02,600 --> 01:41:05,600
read it and try to answer those questions to try and help out people

2270
01:41:05,600 --> 01:41:06,300
who are trying to learn.

2271
01:41:06,300 --> 01:41:08,700
So that's a good place to go to follow up.

2272
01:41:09,400 --> 01:41:10,500
So, let's see here.

2273
01:41:14,300 --> 01:41:14,700
Okay.

2274
01:41:17,800 --> 01:41:19,200
Let's see.

2275
01:41:22,100 --> 01:41:24,200
So, alright, Gareth Luwin says, the mistake.

2276
01:41:24,200 --> 01:41:25,000
Is that using Ms.

2277
01:41:25,000 --> 01:41:25,200
V.

2278
01:41:25,200 --> 01:41:26,000
CR T dot DL.

2279
01:41:26,000 --> 01:41:28,500
L won't solve the cross-boundary allocation issue.

2280
01:41:29,200 --> 01:41:32,100
So, if you could post a reference to why it doesn't, that would be

2281
01:41:32,100 --> 01:41:36,800
helpful because it definitely does in practice because I have worked

2282
01:41:36,800 --> 01:41:42,200
on projects in the past, which rely on that specific thing, if that

2283
01:41:42,200 --> 01:41:42,800
makes sense.

2284
01:41:48,700 --> 01:41:50,800
Well, the deal is loaded into the same outer space, as the

2285
01:41:50,800 --> 01:41:53,200
application, its own Statics are unique.

2286
01:41:54,100 --> 01:41:56,500
So I don't believe that's actually true.

2287
01:41:56,500 --> 01:41:57,700
I believe that it depends.

2288
01:41:57,700 --> 01:41:59,800
I believe that basically

2289
01:42:00,000 --> 01:42:04,100
The way that the dll gets mapped in is Statics, aren't all the same.

2290
01:42:04,100 --> 01:42:04,900
If that makes sense.

2291
01:42:05,600 --> 01:42:09,100
They can be defined as shared or not shared in.

2292
01:42:09,100 --> 01:42:11,600
Maybe I don't actually know exactly how that's implemented under the

2293
01:42:11,600 --> 01:42:15,800
hood, but I'm pretty sure M SV C, RT D LL actually does the right

2294
01:42:15,800 --> 01:42:21,100
thing there and we'll put like uses the same Heap for each instance of

2295
01:42:21,100 --> 01:42:22,400
the dll that's loaded.

2296
01:42:22,500 --> 01:42:24,700
At least that was the way that it used to work.

2297
01:42:27,400 --> 01:42:29,900
I'm like 99% sure about that.

2298
01:42:30,400 --> 01:42:32,600
So, yeah, but all right.

2299
01:42:32,600 --> 01:42:34,900
So if that's the only objection you had, I'm pretty sure that's not

2300
01:42:34,900 --> 01:42:39,500
actually true so we should but we can pick that up on the forums.

2301
01:42:39,500 --> 01:42:41,800
Now that I know what the thing is because that's a pretty small minor

2302
01:42:41,800 --> 01:42:42,100
thing.

2303
01:42:42,500 --> 01:42:45,300
So, let's go ahead and pick that up on the forums and we can see which

2304
01:42:45,300 --> 01:42:47,600
which which one is correct.

2305
01:42:47,600 --> 01:42:50,500
But other than that we are now over time by 15 minutes.

2306
01:42:50,500 --> 01:42:53,900
So I apologize for the slightly long string by just wanted to make

2307
01:42:53,900 --> 01:42:54,700
sure that was on there.

2308
01:42:55,600 --> 01:42:57,000
Thank you very much everyone for joining.

2309
01:42:57,300 --> 01:43:02,300
I hope you enjoyed this little sort of fun dive into how to make see

2310
01:43:02,600 --> 01:43:04,200
be editable at run time tomorrow.

2311
01:43:04,200 --> 01:43:07,500
We're going to do the super cool thing of making it super easy to

2312
01:43:07,500 --> 01:43:07,700
edit.

2313
01:43:07,700 --> 01:43:10,200
It run time, getting rid of sort of the, some of the hacky things.

2314
01:43:10,200 --> 01:43:11,400
We did just get it working today.

2315
01:43:12,000 --> 01:43:14,700
And so after that, we should be in a point where we can just

2316
01:43:14,700 --> 01:43:17,200
literally, leave the code up and running the whole time, if we want to

2317
01:43:17,200 --> 01:43:17,300
do.

2318
01:43:17,300 --> 01:43:21,100
I don't know if we should or not, but we could from now on too for the

2319
01:43:21,100 --> 01:43:22,800
most part except for a certain circumstances.

2320
01:43:22,800 --> 01:43:24,700
Well, we'll have to kind of do some reloading but well, there's some

2321
01:43:24,700 --> 01:43:26,800
other cool stuff tomorrow much like we did today.

2322
01:43:27,100 --> 01:43:31,700
I hope you enjoyed it and I will see you tomorrow at 8:00 p.m.

2323
01:43:31,800 --> 01:43:37,000
Pacific Standard time when we will continue doing some some fun.

2324
01:43:37,000 --> 01:43:38,100
We're in 32 stuff.

2325
01:43:38,100 --> 01:43:38,700
All right.

2326
01:43:38,700 --> 01:43:41,800
Thanks everyone for joining me and I will see you tomorrow.

