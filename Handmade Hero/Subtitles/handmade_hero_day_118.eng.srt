1
00:00:01,400 --> 00:00:02,000
Here we go.

2
00:00:03,800 --> 00:00:05,700
Hello, everyone and welcome to handmade hero.

3
00:00:05,700 --> 00:00:09,600
The show Rico to complete game live on stream, on Twitch know,

4
00:00:09,600 --> 00:00:12,600
libraries, no engine, it's a complete educational stream here on

5
00:00:12,800 --> 00:00:13,400
handmade her.

6
00:00:13,400 --> 00:00:17,800
Where really we try to make sure that every last little bit of what

7
00:00:17,800 --> 00:00:19,500
goes into game development is covered.

8
00:00:19,500 --> 00:00:24,000
So no matter what type of programming, you're thinking of, we will

9
00:00:24,000 --> 00:00:25,800
eventually do that here on the stream.

10
00:00:25,800 --> 00:00:26,700
And right.

11
00:00:26,800 --> 00:00:28,700
Right now we're in the middle of some, pretty interesting stuff.

12
00:00:28,700 --> 00:00:31,200
We're doing optimizations for the first time here on handmade hero and

13
00:00:31,200 --> 00:00:33,500
we're right in the middle of transitioning.

14
00:00:33,600 --> 00:00:37,700
During a routine from regular scalar C code into intrinsics which

15
00:00:37,700 --> 00:00:42,200
allows us to take advantage of the assembly instructions on the x64

16
00:00:42,200 --> 00:00:43,900
processor, which is what we're running on right now.

17
00:00:43,900 --> 00:00:47,300
And we've already seen a 3X speed up just from doing the basic stuff

18
00:00:47,300 --> 00:00:50,600
that we've done so far just to kind of underscore exactly how

19
00:00:50,600 --> 00:00:51,800
important these are.

20
00:00:51,800 --> 00:00:54,500
Even before you start really looking seriously at the optimization of

21
00:00:54,500 --> 00:00:58,500
things literally just translating routines, in this fashion can have

22
00:00:58,500 --> 00:01:02,500
pretty massive speed increases and so we're going to finish up some of

23
00:01:02,500 --> 00:01:03,100
that today.

24
00:01:03,100 --> 00:01:03,400
Hopefully

25
00:01:03,600 --> 00:01:07,000
Lee because we're kind of coming to the end of that translation

26
00:01:07,000 --> 00:01:07,600
process.

27
00:01:08,200 --> 00:01:10,200
But before I go ahead and get started with that, I just want to remind

28
00:01:10,200 --> 00:01:10,400
everyone.

29
00:01:10,400 --> 00:01:13,300
If you preorder the game on handmade hero dot org and you would like

30
00:01:13,300 --> 00:01:17,700
to follow along with today's episode, it's 118 is today.

31
00:01:17,800 --> 00:01:23,400
So download The Source zip and unpack day, 117 out of it and that

32
00:01:23,400 --> 00:01:27,500
will, you know, give you the exact starting point that I'm, you know,

33
00:01:27,500 --> 00:01:28,300
using today.

34
00:01:28,900 --> 00:01:33,000
So, let's recap where we left off yesterday, because we had a very

35
00:01:33,000 --> 00:01:33,400
specific

36
00:01:33,600 --> 00:01:37,900
Saying that we were about to do on when we kind of stopped yesterday.

37
00:01:38,300 --> 00:01:39,900
And so we want to pick up, right?

38
00:01:39,900 --> 00:01:40,800
Where we left off.

39
00:01:41,700 --> 00:01:46,000
So, if you take a look at where we're at, if if you run the thing

40
00:01:46,000 --> 00:01:48,500
we're running through all of our SEC past but you see, we have these

41
00:01:48,500 --> 00:01:49,500
black bars on things.

42
00:01:49,500 --> 00:01:52,700
And the reason that we have, those black bars is because in order to

43
00:01:52,700 --> 00:01:58,100
do some work with, you know, with changing over how we write pixels to

44
00:01:58,100 --> 00:02:03,500
be Cindy, we commented out the line that actually checks for this

45
00:02:03,500 --> 00:02:04,200
should fill thing.

46
00:02:04,200 --> 00:02:07,100
So, if you remember how this worked, since we're filling for pixels at

47
00:02:07,100 --> 00:02:11,100
a time, we had created a little array here called should fill

48
00:02:11,600 --> 00:02:14,700
And each time we went through a pixel, we set should fill equal to the

49
00:02:14,700 --> 00:02:18,500
bind the Boolean operation, which says, whether or not it fell within

50
00:02:18,700 --> 00:02:22,100
the rectangle that we were supposed to be writing out, right?

51
00:02:22,400 --> 00:02:26,200
And so if you come down here and look, we commented out.

52
00:02:26,200 --> 00:02:29,100
The should fill because we didn't know how to implement that in Cindy.

53
00:02:29,100 --> 00:02:29,300
Right.

54
00:02:29,300 --> 00:02:30,500
I have not covered that yet.

55
00:02:30,500 --> 00:02:32,600
So I didn't want to put that in.

56
00:02:33,800 --> 00:02:35,100
and so, you can see,

57
00:02:38,400 --> 00:02:40,500
That we have a little to do here, which is to say, right?

58
00:02:40,500 --> 00:02:43,400
Only the pixels where it should fill equals true.

59
00:02:43,400 --> 00:02:46,100
And when we run it, you can see what happens when that's not

60
00:02:46,100 --> 00:02:46,400
occurring.

61
00:02:46,400 --> 00:02:50,000
You can see that we're writing these black pixels here which were not

62
00:02:50,000 --> 00:02:53,500
supposed to be writing because up at the top Loop.

63
00:02:53,500 --> 00:02:54,100
Right.

64
00:02:54,500 --> 00:02:56,800
You can see us right here.

65
00:02:56,900 --> 00:02:57,700
Setting should fill.

66
00:02:57,700 --> 00:02:58,200
I wheat.

67
00:02:58,200 --> 00:02:58,700
We do an.

68
00:02:58,700 --> 00:02:59,800
If and we don't actually

69
00:03:00,000 --> 00:03:03,200
Any of this work when should fill is not set to True, right?

70
00:03:03,200 --> 00:03:04,700
So there's just nothing in the buffers.

71
00:03:04,900 --> 00:03:07,600
So when we go to write it out, we just write out garbage data here.

72
00:03:08,000 --> 00:03:11,800
Okay, so what we need to do is we need to start writing in some way

73
00:03:12,000 --> 00:03:15,800
that's going to actually preserve that information that should fill

74
00:03:16,300 --> 00:03:17,000
information.

75
00:03:17,000 --> 00:03:21,500
So what I'd like to do is talk really briefly about how this process

76
00:03:21,600 --> 00:03:22,600
is going to work.

77
00:03:22,700 --> 00:03:24,200
It's not very complicated.

78
00:03:24,400 --> 00:03:28,400
But again, since this is all completely new, we have not talked about

79
00:03:28,400 --> 00:03:29,200
any stuff like it on.

80
00:03:29,200 --> 00:03:29,600
Handmade here.

81
00:03:29,600 --> 00:03:29,800
I just

82
00:03:30,000 --> 00:03:31,700
To make sure everyone's on the same page.

83
00:03:31,700 --> 00:03:36,700
So right now where we got ourselves to yesterday if you remember is we

84
00:03:36,700 --> 00:03:39,900
have a 128-bit Cindy register right?

85
00:03:39,900 --> 00:03:41,000
That we have prepared.

86
00:03:43,200 --> 00:03:48,000
And we essentially have rgba rgba triples, and I'm sorry.

87
00:03:48,500 --> 00:03:51,000
Rgba quads in it, right?

88
00:03:51,000 --> 00:03:52,500
We have stuff that looks like this.

89
00:03:56,500 --> 00:04:02,300
Like so, and what we want to do is we want to be able to write this

90
00:04:02,300 --> 00:04:03,500
out in one big chunk.

91
00:04:03,500 --> 00:04:06,700
So we can just use one instruction to write the whole thing out into

92
00:04:06,800 --> 00:04:09,900
the destination buffer, but the problem is that the destination

93
00:04:09,900 --> 00:04:11,300
buffer, right?

94
00:04:13,800 --> 00:04:19,200
The destination buffer may only have some values which were actually

95
00:04:19,200 --> 00:04:20,399
supposed to overwrite, right?

96
00:04:20,399 --> 00:04:22,500
This is for Pixel values, right?

97
00:04:22,500 --> 00:04:26,500
This is pixel 1 0 1, 2 and 3, right?

98
00:04:26,900 --> 00:04:30,900
And it may be that we're only supposed to write in to say these two

99
00:04:30,900 --> 00:04:32,600
pixels, okay?

100
00:04:34,200 --> 00:04:36,800
So, you know, given that that's true.

101
00:04:37,100 --> 00:04:41,200
Well, there is one thing that we can do right off the bat, right?

102
00:04:41,200 --> 00:04:45,200
Which is that we could just make sure that if we're only supposed to

103
00:04:45,200 --> 00:04:48,700
write into these two pixels, we could just make sure that these other

104
00:04:48,700 --> 00:04:50,600
two pixels that were going to write.

105
00:04:51,500 --> 00:04:55,600
You know, are actually filled with valid data, okay?

106
00:04:56,000 --> 00:04:59,300
And if these were filled with valid data which is whatever was in the

107
00:04:59,300 --> 00:05:03,500
destination beforehand, then it doesn't matter that we're going to

108
00:05:03,500 --> 00:05:03,900
overwrite them.

109
00:05:04,000 --> 00:05:06,700
We're just going to overwrite them with whatever they were before.

110
00:05:07,300 --> 00:05:11,500
So what we want to do at least want to look at doing first and we'll

111
00:05:11,500 --> 00:05:13,800
see if there's any reason not to do it this way, but we want to look

112
00:05:13,800 --> 00:05:16,000
at first, is what we can do.

113
00:05:16,000 --> 00:05:21,100
To make sure that when we do this, if we've computed new values here

114
00:05:21,100 --> 00:05:25,400
and here, but we're not going to process these values that we still

115
00:05:25,400 --> 00:05:25,600
stick.

116
00:05:25,600 --> 00:05:30,200
The old values from the frame buffer into these two positions so that,

117
00:05:30,800 --> 00:05:33,300
you know, it will still produce correct results.

118
00:05:33,700 --> 00:05:33,800
Now,

119
00:05:33,900 --> 00:05:39,000
Now, one way to think about this is that well we want to save all of

120
00:05:39,000 --> 00:05:40,000
this work that we're doing here.

121
00:05:40,000 --> 00:05:43,100
We'd want to not do all this work for pixels that we didn't have to

122
00:05:43,100 --> 00:05:43,300
do.

123
00:05:43,300 --> 00:05:47,400
But at the moment since we're doing things for wide really doing the

124
00:05:47,400 --> 00:05:50,200
work for a single Pixel as expensive as doing it for all four.

125
00:05:50,200 --> 00:05:53,800
So unless we tried to figure out, some way to pack different pixels

126
00:05:53,800 --> 00:05:57,200
from different locations and then scatter them back out later which is

127
00:05:57,200 --> 00:05:59,700
probably not worth it for four pixels, but hard to say, you know,

128
00:06:00,000 --> 00:06:01,200
We're not going to try that right now.

129
00:06:01,800 --> 00:06:06,200
What that means is it's totally okay to just do all these operations.

130
00:06:07,400 --> 00:06:08,700
For all of the pixels.

131
00:06:08,900 --> 00:06:14,800
The only problem is that if we do all these operations for the pixels

132
00:06:14,900 --> 00:06:17,200
when we get to the end, right?

133
00:06:19,100 --> 00:06:23,600
We would have to have figured out a way to essentially stuff all of

134
00:06:23,600 --> 00:06:26,200
these Texel ARB RCR.

135
00:06:26,200 --> 00:06:28,800
Do you know all of this stuff that's going to get operated on?

136
00:06:29,100 --> 00:06:32,600
We would have to have figured out a way to shove values into all of

137
00:06:32,600 --> 00:06:37,000
these that would reproduce whatever is already in the destination.

138
00:06:37,000 --> 00:06:41,500
After going through all of this entire pipeline which seems like a

139
00:06:41,500 --> 00:06:45,500
little bit, it just seems like a little bit of trouble, right?

140
00:06:45,500 --> 00:06:48,700
I mean, that seems like a bit of a bit of a stretch

141
00:06:49,800 --> 00:06:54,900
Another option that we would have, right, is right before we're about

142
00:06:54,900 --> 00:06:55,900
to write it out.

143
00:06:56,300 --> 00:07:00,200
If we were to take our Vector of new values, right?

144
00:07:00,200 --> 00:07:05,800
So, we've computed new values in all four slots and our Vector of old

145
00:07:05,800 --> 00:07:06,600
values,

146
00:07:07,700 --> 00:07:08,200
Right.

147
00:07:11,700 --> 00:07:15,500
If you were to take these and we know that these are actually invalid

148
00:07:15,500 --> 00:07:17,800
and these are the only two that are correct.

149
00:07:17,900 --> 00:07:22,700
What we could do is use bitwise operations to combine these two.

150
00:07:23,200 --> 00:07:27,800
So that we end up with a final Vector to write out, which has old in

151
00:07:27,800 --> 00:07:31,400
the places where old should be and new in the places where a new

152
00:07:31,400 --> 00:07:37,300
should be right and it's pretty easy to see what we would need to make

153
00:07:37,300 --> 00:07:38,400
that happen, right?

154
00:07:38,500 --> 00:07:41,000
We already know that we can combine two vectors

155
00:07:41,700 --> 00:07:44,300
Right by using or right?

156
00:07:44,400 --> 00:07:48,600
We know that we can take, you know, and, and sort of, if we had all

157
00:07:48,600 --> 00:07:50,600
zeros here, right?

158
00:07:51,100 --> 00:07:55,800
And all zeros in here in these two vectors, we could order them

159
00:07:55,800 --> 00:07:58,800
together and it would leave the news in the middle and the olds on the

160
00:07:58,800 --> 00:08:01,600
ends because the zeros would not interfere, right?

161
00:08:02,000 --> 00:08:06,100
So, the only question is, how do we knock out these values and in the

162
00:08:06,100 --> 00:08:08,700
places where we don't want them and turn them into zeros?

163
00:08:08,800 --> 00:08:11,000
And the answer is we can use and for that

164
00:08:11,300 --> 00:08:11,600
Right?

165
00:08:11,800 --> 00:08:15,900
If we were to build a mask which was essentially that looked like this

166
00:08:16,000 --> 00:08:20,300
right, you know, it's ones and zeros here, right?

167
00:08:20,900 --> 00:08:27,000
So all zeros here all ones and here we could end this with new to

168
00:08:27,000 --> 00:08:31,500
produce, you know, a new template we could and the opposite, you know,

169
00:08:31,500 --> 00:08:36,700
the not of it with the with the old and then or the two together,

170
00:08:36,799 --> 00:08:37,299
right?

171
00:08:37,299 --> 00:08:40,799
And that would produce a final Vector that looked like this.

172
00:08:41,200 --> 00:08:44,300
So we know the exact operations we would need to do, we all we would

173
00:08:44,300 --> 00:08:49,100
have to do is make sure we can produce a mask value that basically has

174
00:08:49,100 --> 00:08:54,600
all zeros, where there should be old values and all ones where there

175
00:08:54,600 --> 00:08:55,700
should be new values, right?

176
00:08:55,700 --> 00:08:56,500
And then we could do it.

177
00:08:56,500 --> 00:08:59,900
Pretty trivially, in fact, you know, it would just look like this.

178
00:09:00,100 --> 00:09:04,400
We would take out right that maybe I'll make a new one just so we can

179
00:09:04,400 --> 00:09:06,900
see it make something called masked out.

180
00:09:07,300 --> 00:09:12,500
If we go ahead and do an or here and I do an or with that you know the

181
00:09:12,500 --> 00:09:13,200
and

182
00:09:16,300 --> 00:09:18,700
Like I just said, oops, I didn't mean add mint.

183
00:09:18,700 --> 00:09:19,900
And there we go.

184
00:09:21,000 --> 00:09:23,100
If we were to and the out,

185
00:09:24,600 --> 00:09:29,300
Like so if it were to and the out with our right mask, right?

186
00:09:29,300 --> 00:09:31,700
Which is what it basically is, it's the place that we're going to

187
00:09:31,700 --> 00:09:37,600
write with and then I were to and the original dest with the right

188
00:09:37,600 --> 00:09:38,800
mask, right?

189
00:09:39,300 --> 00:09:42,400
And something like this, but I want the inverse of it, right?

190
00:09:42,400 --> 00:09:45,800
And I believe, I think there might be a mnemonic this by don't

191
00:09:45,800 --> 00:09:46,600
actually know.

192
00:09:46,600 --> 00:09:50,100
Let me see here until intrinsics guide.

193
00:09:50,500 --> 00:09:53,500
Our trusty friend, should probably just leave this tab open while

194
00:09:53,500 --> 00:09:54,000
we're doing this.

195
00:09:55,600 --> 00:09:57,400
Mmm, and not.

196
00:09:58,600 --> 00:10:04,800
So you can see here that basically, this is Computing, the not of B

197
00:10:04,900 --> 00:10:08,800
and then it is re the not of a and then it ends it with be.

198
00:10:09,200 --> 00:10:11,200
So probably want to do it this way.

199
00:10:12,100 --> 00:10:15,300
So you can see the mask more properly like so,

200
00:10:16,600 --> 00:10:23,000
So you can see here is we are effectively producing amassed version of

201
00:10:23,000 --> 00:10:27,900
the out by taking the original dest masking out, the places where

202
00:10:27,900 --> 00:10:31,900
we're trying to write taking the new result, you know the actual

203
00:10:31,900 --> 00:10:36,400
pixels we computed masking out the parts we don't want to write fusing

204
00:10:36,400 --> 00:10:40,100
them together and then over writing the entire destination, right?

205
00:10:40,700 --> 00:10:43,800
And so if we just go ahead and write Mast out here, all we would need

206
00:10:43,800 --> 00:10:46,000
to do is compute this right mask somehow.

207
00:10:46,900 --> 00:10:50,000
And make sure that we're storing our original destination.

208
00:10:50,000 --> 00:10:53,500
So, let's go back up here and make sure that that's actually

209
00:10:53,500 --> 00:10:54,100
happening.

210
00:10:54,200 --> 00:10:57,600
So, in the load destination, for example, we would have to make sure

211
00:10:57,900 --> 00:11:02,500
that that always happens, meaning it cannot be inside of this, for I

212
00:11:02,900 --> 00:11:04,500
Loop conditional, right?

213
00:11:04,600 --> 00:11:07,300
It can't be only if we're going to fill it, we have to load it always

214
00:11:07,900 --> 00:11:13,700
but once we do that, we could make sure that our desk tars gsb's an

215
00:11:13,700 --> 00:11:16,000
days when they come out.

216
00:11:16,200 --> 00:11:20,000
We could preserve those now into original dest, right?

217
00:11:21,200 --> 00:11:21,500
Actually.

218
00:11:21,500 --> 00:11:25,100
Now that I think about this, we haven't actually Cindy eyes this.

219
00:11:25,100 --> 00:11:28,900
So these are still actually being directly up converted to float.

220
00:11:29,400 --> 00:11:33,100
So, I think what I'm also going to do here in the meantime, actually,

221
00:11:33,100 --> 00:11:33,800
we'll just leave that.

222
00:11:33,800 --> 00:11:34,300
Like this.

223
00:11:34,600 --> 00:11:37,400
I'm going to actually put in one part of this.

224
00:11:37,500 --> 00:11:38,600
This that we haven't done yet.

225
00:11:38,600 --> 00:11:41,100
I'm going to have original desk here.

226
00:11:43,000 --> 00:11:46,500
And I'm going to make that be a load you.

227
00:11:48,800 --> 00:11:50,000
I'm going to show you this right here.

228
00:11:51,600 --> 00:11:52,000
See.

229
00:11:56,100 --> 00:11:57,000
So, do you see this?

230
00:11:58,400 --> 00:11:59,800
You see how before down?

231
00:12:00,100 --> 00:12:04,400
Yesterday, we did that store you which says store on aligned and it

232
00:12:04,400 --> 00:12:08,900
allows us to take one of these 70 registers and write it out to a

233
00:12:08,900 --> 00:12:09,500
pointer.

234
00:12:09,600 --> 00:12:11,200
I want to do the same thing here.

235
00:12:11,200 --> 00:12:14,700
I want to do an explicit load and I want to do an explicit load of

236
00:12:14,700 --> 00:12:16,500
exactly the place that we're writing.

237
00:12:16,600 --> 00:12:17,100
Right.

238
00:12:17,200 --> 00:12:21,600
So I essentially want to do exactly this and say what was there in a

239
00:12:21,600 --> 00:12:25,100
position that we're writing what was there before hand, right?

240
00:12:25,100 --> 00:12:28,900
So I want to do one of these loads to get that original desktop and

241
00:12:28,900 --> 00:12:29,700
then later,

242
00:12:30,000 --> 00:12:32,300
As we haven't Cindy eyes this, we just won't touch this for now.

243
00:12:32,300 --> 00:12:33,800
We'll leave that loading the way it was.

244
00:12:34,000 --> 00:12:37,600
But later, once we have this, this load working, we can actually

245
00:12:37,600 --> 00:12:40,700
change this all this code to be working off of sympathy as well.

246
00:12:40,700 --> 00:12:43,000
So that's what we, you know, obviously, we were planning on doing

247
00:12:43,000 --> 00:12:45,400
that, but I just want to jump the gun a little bit here to make sure

248
00:12:45,400 --> 00:12:48,000
we have that original desk just as it was

249
00:12:49,100 --> 00:12:53,200
Okay, so we come down here and then we're going to have is we're going

250
00:12:53,200 --> 00:12:55,800
to have well, besides that syntax error for my typo.

251
00:12:56,300 --> 00:13:00,300
We're going to have a problem with right mask basically, okay.

252
00:13:00,300 --> 00:13:03,200
And the problem with right mask is we have never computed, this

253
00:13:05,300 --> 00:13:06,100
explicitly,

254
00:13:07,500 --> 00:13:11,400
So for the time being what we're going to do is again just like we did

255
00:13:11,700 --> 00:13:14,200
with our other things, we're just going to approximate this.

256
00:13:16,200 --> 00:13:23,000
We can set it to a dummy value at the moment and I'm set one SOS a

257
00:13:23,000 --> 00:13:26,500
epi32 and we'll just set it to 0 should do it.

258
00:13:26,900 --> 00:13:28,400
So we're going to have a right mask of zero.

259
00:13:28,400 --> 00:13:29,600
If we in fact, look at what's happened.

260
00:13:29,600 --> 00:13:32,900
Now, we don't write anything and that is exactly what we would have

261
00:13:32,900 --> 00:13:33,300
expected.

262
00:13:33,300 --> 00:13:36,400
Because if the right mask was set to 0, that means you'd never write

263
00:13:36,400 --> 00:13:37,200
anything right?

264
00:13:37,600 --> 00:13:40,400
Whereas if I set the right mask let's say to all ones.

265
00:13:40,400 --> 00:13:42,900
So each 32-bit Lane of the right.

266
00:13:42,900 --> 00:13:44,100
Mask is all set to ones.

267
00:13:44,100 --> 00:13:47,000
We should see that it returns to our previous thing which is just it

268
00:13:47,000 --> 00:13:48,000
always writes everywhere.

269
00:13:48,300 --> 00:13:49,500
Right, so that's good.

270
00:13:49,700 --> 00:13:52,800
So now all we have to do is figure out a way to set, right?

271
00:13:52,800 --> 00:13:55,800
Mask equal to the proper thing and of course we can sort of just do

272
00:13:55,800 --> 00:14:02,300
that down here by using sort of our cheesy set macros until we know a

273
00:14:02,300 --> 00:14:03,900
better way to do it.

274
00:14:03,900 --> 00:14:05,400
So let's go ahead and do that.

275
00:14:05,400 --> 00:14:07,000
We will essentially set it to

276
00:14:07,700 --> 00:14:08,900
You know, all FS.

277
00:14:09,400 --> 00:14:10,200
Got one too many.

278
00:14:10,200 --> 00:14:11,000
There we go.

279
00:14:11,500 --> 00:14:14,400
And so now we're setting, the right mask, only in the cases, where we

280
00:14:14,400 --> 00:14:15,500
thought we should have filled.

281
00:14:15,600 --> 00:14:16,900
We're setting that right mask.

282
00:14:17,000 --> 00:14:17,400
Okay.

283
00:14:17,900 --> 00:14:19,100
Oh, oh, dear.

284
00:14:21,500 --> 00:14:23,000
That's, that's a bit garish.

285
00:14:24,200 --> 00:14:28,800
What do I have to say?

286
00:14:29,400 --> 00:14:31,300
That's pretty cool.

287
00:14:31,700 --> 00:14:33,800
What, what just happened?

288
00:14:34,900 --> 00:14:40,100
I, I was not expecting that effect, but it's it's pretty great.

289
00:14:40,700 --> 00:14:45,200
It's like some kind of a like fancy artistic filter that has been

290
00:14:45,200 --> 00:14:48,600
applied to our game.

291
00:14:49,300 --> 00:14:49,900
That's

292
00:14:50,800 --> 00:14:52,100
That's just bizarre.

293
00:14:53,600 --> 00:14:54,200
You got to admit.

294
00:14:54,200 --> 00:14:55,200
That's pretty bizarre.

295
00:14:55,400 --> 00:14:56,000
Wow.

296
00:14:57,200 --> 00:14:57,900
All right.

297
00:15:00,000 --> 00:15:03,600
Well, you know, I kind of tempted to try and figure out a way to

298
00:15:03,600 --> 00:15:06,800
preserve that particular thing.

299
00:15:08,100 --> 00:15:13,100
Oh, but you can see why it's because it was a floating Point.

300
00:15:14,400 --> 00:15:15,700
Seth, that was happening there.

301
00:15:15,900 --> 00:15:19,700
So we kind of need one again just temporarily that works.

302
00:15:19,700 --> 00:15:22,600
An integer that that was cool though.

303
00:15:22,700 --> 00:15:24,100
You gotta admit, that was pretty cool.

304
00:15:24,600 --> 00:15:27,000
But this is what we actually wanted, right?

305
00:15:27,100 --> 00:15:29,600
We actually wanted something that masks out the

306
00:15:30,000 --> 00:15:33,600
Use and now you can kind of see that happening properly.

307
00:15:33,600 --> 00:15:36,200
That, that was pretty darn cool.

308
00:15:38,400 --> 00:15:39,400
That, that was great.

309
00:15:39,600 --> 00:15:44,100
So I guess setting it to extremely high, floating-point number does

310
00:15:44,100 --> 00:15:45,400
some pretty awesome stuff.

311
00:15:47,800 --> 00:15:50,000
leave that as an exercise to the reader to play around with if you'd

312
00:15:50,000 --> 00:15:50,400
like

313
00:15:51,300 --> 00:15:55,000
Okay, so now we're properly masking out things based on the right

314
00:15:55,000 --> 00:15:55,300
Mass.

315
00:15:55,300 --> 00:15:57,900
So we've gotten rid of our black borders and so that's yet another to

316
00:15:57,900 --> 00:15:58,400
do down.

317
00:15:58,400 --> 00:16:03,500
Now, I want to mention another thing here, which is that again are

318
00:16:03,500 --> 00:16:08,500
helping friendly Fabien wrote in to me to say that we actually can

319
00:16:08,500 --> 00:16:11,500
count on pretty much always, unless we change it.

320
00:16:11,500 --> 00:16:12,000
The SS.

321
00:16:12,000 --> 00:16:14,800
He's rounding mode for convert PS.

322
00:16:14,800 --> 00:16:17,300
Just the regular convert PS, which we were using yesterday.

323
00:16:17,300 --> 00:16:21,000
Before we change it to the ad will actually do round to nearest.

324
00:16:21,400 --> 00:16:25,000
By default and that is what we should leave the rounding mode set to

325
00:16:25,000 --> 00:16:25,900
he said anyway.

326
00:16:26,500 --> 00:16:30,300
So what that implies is that really we don't have to worry about those

327
00:16:30,300 --> 00:16:30,800
ads.

328
00:16:30,800 --> 00:16:33,800
We can just count on round to nearest being the normal thing that it

329
00:16:33,800 --> 00:16:36,500
does and if round to nearest is the normal thing that it does, then we

330
00:16:36,500 --> 00:16:38,400
don't have to worry about doing this half.

331
00:16:38,700 --> 00:16:41,300
So we're pretty much good to go just with that so we can get rid of

332
00:16:41,300 --> 00:16:44,900
that to do as well because apparently that's just easier for us

333
00:16:44,900 --> 00:16:45,500
anyway.

334
00:16:46,000 --> 00:16:46,900
So we're all good.

335
00:16:46,900 --> 00:16:47,700
So there we go.

336
00:16:48,100 --> 00:16:49,500
And there's our little happy hero.

337
00:16:50,500 --> 00:16:52,600
He's running pretty zip Ali.

338
00:16:52,600 --> 00:16:55,900
Now, to again, we've already got them down to like the 110 cycle

339
00:16:55,900 --> 00:17:02,000
range, but we now have, you know, we certainly have a bit of work left

340
00:17:02,000 --> 00:17:05,200
to do before we even finished translating this entire thing.

341
00:17:06,500 --> 00:17:09,800
So what I'd like to do now is move up to our last remaining for I

342
00:17:09,800 --> 00:17:13,400
Loop, which is this Loop right here, okay.

343
00:17:16,500 --> 00:17:16,900
so,

344
00:17:19,200 --> 00:17:21,099
The first thing I like to focus on is again.

345
00:17:21,099 --> 00:17:24,400
We know how to do some packing and unpacking and things like that.

346
00:17:25,000 --> 00:17:29,900
So I feel like at this point we should be able to move these things

347
00:17:29,900 --> 00:17:31,300
which we're doing for.

348
00:17:31,300 --> 00:17:33,400
I Loops for doing the unpacks of ours.

349
00:17:33,400 --> 00:17:37,600
The geez, the bees that sort of stuff, we should be able to move those

350
00:17:37,700 --> 00:17:40,100
essentially outside into Cindy, right?

351
00:17:40,100 --> 00:17:43,800
That shouldn't be too hard because this is all stuff that we have done

352
00:17:43,900 --> 00:17:44,400
before.

353
00:17:44,400 --> 00:17:47,800
We, you know, we we did essentially the reverse of this, we did the

354
00:17:47,800 --> 00:17:48,200
packing density.

355
00:17:48,300 --> 00:17:50,700
Down and so we should be able to go think about it for a little while

356
00:17:50,700 --> 00:17:53,600
and then just be able to produce something that does these unpacked.

357
00:17:53,600 --> 00:17:57,500
So what I want to do here is I want to go ahead and move one of these

358
00:17:57,500 --> 00:17:59,800
outside and I'll

359
00:18:00,000 --> 00:18:00,700
Head and move.

360
00:18:00,700 --> 00:18:02,700
Let's say Texel a are outside.

361
00:18:02,900 --> 00:18:07,000
Like so and what we want to do is we want to convert this to Cindy.

362
00:18:07,000 --> 00:18:11,400
So instead of doing it this way, in here, where we have the those

363
00:18:11,400 --> 00:18:15,500
Texel samples which get loaded, what I'd rather do is have it so that

364
00:18:15,500 --> 00:18:18,100
the Texel samples are actually just being loaded.

365
00:18:19,200 --> 00:18:22,900
Straight away out of a you and 32, let's say right.

366
00:18:23,000 --> 00:18:26,100
And I guess we don't even need to to do it as a unit 32, I guess I can

367
00:18:26,100 --> 00:18:30,900
just put it in the low part of an actual m120.

368
00:18:30,900 --> 00:18:34,600
A tie that seems like that would be fine as well.

369
00:18:35,100 --> 00:18:38,700
So I'm going to go ahead and say that we've got this this sample, a

370
00:18:38,700 --> 00:18:40,000
here, right?

371
00:18:40,300 --> 00:18:42,400
I'm going to go ahead and say that we've got that sample.

372
00:18:42,400 --> 00:18:42,700
A

373
00:18:49,400 --> 00:18:51,700
I think we want it to be stored in the bottom of a 128.

374
00:18:51,700 --> 00:18:52,900
I have to think about that.

375
00:18:52,900 --> 00:18:57,300
Maybe we don't, maybe we actually want them stored, sort of stride it

376
00:18:57,300 --> 00:18:58,100
or something like that.

377
00:18:58,100 --> 00:18:58,600
I don't know.

378
00:18:58,600 --> 00:19:00,700
I mean, the other thing we could do is for now just say that it's

379
00:19:00,700 --> 00:19:03,400
actually the UN 32 and then we'll load it in later.

380
00:19:03,400 --> 00:19:06,600
I'm not sure what the best thing to do would be.

381
00:19:06,600 --> 00:19:07,900
But again, we have four of them.

382
00:19:07,900 --> 00:19:10,600
So let's go ahead and just start with that, right?

383
00:19:11,000 --> 00:19:14,100
And what I want to do is say here the sample, a right?

384
00:19:14,100 --> 00:19:17,200
We're going to grab it out of the I like that, right?

385
00:19:17,900 --> 00:19:20,800
Then when we come down here, we know we have four sample A's.

386
00:19:21,200 --> 00:19:25,500
And we could, if we wanted to write, we can also just go ahead and do

387
00:19:25,500 --> 00:19:26,900
it this way.

388
00:19:29,600 --> 00:19:31,100
For starters, right?

389
00:19:31,300 --> 00:19:35,300
This would just be the explicit version where we actually do them all

390
00:19:35,500 --> 00:19:37,000
sort of piecemeal, right?

391
00:19:42,000 --> 00:19:43,300
Oops, that's no good.

392
00:19:44,900 --> 00:19:45,200
Yeah.

393
00:19:47,300 --> 00:19:49,500
And so, if we take a look at that, right, will get essentially the

394
00:19:49,500 --> 00:19:51,100
same thing that we had before, right?

395
00:19:51,100 --> 00:19:52,100
Nothing bad happening.

396
00:19:52,100 --> 00:19:53,900
And we could do this for all of them.

397
00:19:54,100 --> 00:19:54,800
Pretty trivially.

398
00:19:54,800 --> 00:19:57,700
Again, it just kind of generates a lot of code that spammed out there.

399
00:19:57,700 --> 00:20:01,300
But we could do that pretty simply for everything, right?

400
00:20:01,300 --> 00:20:03,500
We can have all of our samples be done that way.

401
00:20:03,500 --> 00:20:06,600
If we wanted to, we can do VC + D.

402
00:20:06,600 --> 00:20:08,600
Exactly the same way, right?

403
00:20:09,800 --> 00:20:12,400
And then, all of these guys would move out there as well.

404
00:20:18,500 --> 00:20:18,900
Okay.

405
00:20:23,300 --> 00:20:24,600
So here's what that looks like.

406
00:20:25,800 --> 00:20:28,700
And again, then we just have to do these guys.

407
00:20:31,000 --> 00:20:31,500
This way.

408
00:20:44,200 --> 00:20:47,400
And again, I apologize to anyone who doesn't like waiting for me to

409
00:20:47,400 --> 00:20:49,600
kind of structure things like this, but I find that it's good on the

410
00:20:49,600 --> 00:20:52,300
stream to just take it one step at a time, so that everyone can kind

411
00:20:52,300 --> 00:20:57,100
of see exactly how things go and in the future again.

412
00:20:57,200 --> 00:20:59,800
Oops, I do that in the future.

413
00:21:01,800 --> 00:21:06,200
When we do more Cindy stuff, if we decide, we want to do more assembly

414
00:21:06,200 --> 00:21:09,500
stuff, we can, you know, take some shortcuts and not do that.

415
00:21:09,500 --> 00:21:12,200
But, you know, just for a little while everyone learns at different

416
00:21:12,200 --> 00:21:16,300
speeds, I don't want to kind of jump into things and just write stuff

417
00:21:16,300 --> 00:21:20,400
and Cindy right off the bat, I want to be able to kind of show how

418
00:21:20,400 --> 00:21:24,200
this stuff happens and especially with a routine like this, this this

419
00:21:24,200 --> 00:21:26,600
specific part of this routine, kind of the Preamble where things are

420
00:21:26,600 --> 00:21:27,000
loading.

421
00:21:27,700 --> 00:21:29,900
As I think, you'll see it's going to get a little hairy in

422
00:21:30,000 --> 00:21:34,900
R because just of the way the fact that we can't load things directly

423
00:21:34,900 --> 00:21:37,300
in the format that we've liked because they're coming from these pack

424
00:21:37,300 --> 00:21:42,500
textures definitely does mean that things are a little bit more wonky

425
00:21:42,500 --> 00:21:45,800
like the stuff that we're going to have to do is going to be a little

426
00:21:45,800 --> 00:21:49,900
bit more, a little more sketchy if you will.

427
00:21:51,400 --> 00:21:56,400
All right, so now everything is running, sort of that sort of more

428
00:21:56,400 --> 00:21:57,600
direct way, right?

429
00:21:57,800 --> 00:22:02,200
And what's kind of interesting is you can see again like I said I just

430
00:22:02,200 --> 00:22:05,100
kind of point this out every time it happens but you can see that our

431
00:22:05,100 --> 00:22:06,800
cycle counts actually got less.

432
00:22:07,200 --> 00:22:09,700
We're now down below 100 Cycles, often times.

433
00:22:11,000 --> 00:22:15,200
And what's kind of interesting is that, you know, hopefully that's

434
00:22:15,900 --> 00:22:18,900
might strike you as kind of counterintuitive because we move stuff out

435
00:22:18,900 --> 00:22:20,500
of a conditional, right?

436
00:22:20,900 --> 00:22:23,600
Move stuff out of a conditional into a place where it's now always

437
00:22:23,600 --> 00:22:26,700
happening all the time instead of only happening during the

438
00:22:26,700 --> 00:22:27,300
conditional.

439
00:22:27,700 --> 00:22:29,900
And so I know that some of this stuff can be counterintuitive.

440
00:22:29,900 --> 00:22:32,800
It's worth pointing out that like, processor the way, the compiler

441
00:22:32,800 --> 00:22:35,400
optimizes things down and the way the processor executes them and so

442
00:22:35,400 --> 00:22:38,200
on can lead to some very non-intuitive results.

443
00:22:38,200 --> 00:22:40,800
And so especially with routines of any significant complexity, like

444
00:22:40,800 --> 00:22:44,800
this, you you might be surprised when ends up happening when you move

445
00:22:44,800 --> 00:22:46,200
things out like that.

446
00:22:46,200 --> 00:22:47,500
So anyway, just pointing that out.

447
00:22:47,500 --> 00:22:48,600
But let's continue on.

448
00:22:49,300 --> 00:22:50,700
So now we have the destination,

449
00:22:50,900 --> 00:22:51,000
No.

450
00:22:52,100 --> 00:22:55,700
And I think the destination actually might be the easiest one for us

451
00:22:55,700 --> 00:22:56,400
to start with.

452
00:22:56,400 --> 00:22:59,700
We have our original Des, which we've already done a load you for here

453
00:22:59,700 --> 00:23:01,100
and we know we're always going to load it.

454
00:23:01,300 --> 00:23:05,800
So maybe what we'll do is we'll start by doing the load destination,

455
00:23:07,800 --> 00:23:08,600
you know, I don't know.

456
00:23:08,600 --> 00:23:09,200
I'm gonna finish this.

457
00:23:09,200 --> 00:23:12,200
ER, maybe what we'll actually do is the right mask, I don't know.

458
00:23:12,200 --> 00:23:13,500
We'll see, we'll see you in a second.

459
00:23:14,200 --> 00:23:19,000
So let's go ahead out here and and finish this guy off.

460
00:23:27,300 --> 00:23:30,200
Like so, and again, we have to do this.

461
00:23:30,300 --> 00:23:30,600
Oops.

462
00:23:44,600 --> 00:23:45,100
Okay.

463
00:23:48,100 --> 00:23:49,700
So here we are again, move.

464
00:23:49,700 --> 00:23:53,800
Some more stuff outside, and check out what happens when we move

465
00:23:53,800 --> 00:23:56,900
things outside the conditional, we just saved another 10 Cycles by

466
00:23:56,900 --> 00:23:59,100
cutting, and pasting the code out of a loop.

467
00:24:00,300 --> 00:24:04,200
All right, and by the way, anyone in thought we weren't going to get

468
00:24:04,200 --> 00:24:09,600
down to 50 Cycles, the pixel, which?

469
00:24:10,700 --> 00:24:15,100
Yeah, we're almost at and we haven't actually finished translating the

470
00:24:15,100 --> 00:24:15,700
routine.

471
00:24:15,900 --> 00:24:18,100
I think we've got a really good shot at it.

472
00:24:18,800 --> 00:24:19,200
Yeah.

473
00:24:20,700 --> 00:24:21,200
Yeah.

474
00:24:21,500 --> 00:24:24,600
Anyway so we've got those and now we're still just kind of stuck with

475
00:24:24,600 --> 00:24:28,600
this stuff here and so what I'd like to do first of all I kind of

476
00:24:28,600 --> 00:24:30,700
changed my mind a little bit as we went there.

477
00:24:31,300 --> 00:24:34,400
What I kind of want to do is say let's fix this right mask nonsense.

478
00:24:34,700 --> 00:24:40,300
Okay, so we're Computing these u and v values here, right?

479
00:24:40,400 --> 00:24:43,500
And then what we're doing is we're comparing the u and v values to

480
00:24:43,500 --> 00:24:49,000
make sure that they're obeying these certain constraints.

481
00:24:49,100 --> 00:24:50,400
They have to be greater than equal to 0.

482
00:24:50,700 --> 00:24:53,300
And less than or equal to 1 both of them do, right?

483
00:24:54,100 --> 00:25:00,300
So what I'd like to be able to do is I'd like to be able to go ahead

484
00:25:00,300 --> 00:25:04,500
and compute that right mask directly without ever having to actually

485
00:25:04,500 --> 00:25:07,500
do this sort of scalar extraction because if you look at what this

486
00:25:07,500 --> 00:25:11,800
code is doing here, it's grabbing out pieces of these vectors and

487
00:25:11,800 --> 00:25:13,200
doing them in a loop.

488
00:25:13,300 --> 00:25:14,900
What I'd rather do is figure out.

489
00:25:14,900 --> 00:25:16,700
Can I compute this should value?

490
00:25:16,700 --> 00:25:20,400
This should fill value as its own wide value can

491
00:25:20,500 --> 00:25:25,400
I basically compute right Mass directly without packing it into each

492
00:25:25,400 --> 00:25:26,800
of the four lanes separately.

493
00:25:27,600 --> 00:25:29,700
And of course, the answer is yes, I can.

494
00:25:29,900 --> 00:25:33,200
The SSE instruction set gives me a lot of opportunities to do that.

495
00:25:35,300 --> 00:25:40,500
So let's introduce SSE comparison operations.

496
00:25:40,900 --> 00:25:45,300
So if we take a look in here, there's actually a special category for

497
00:25:45,300 --> 00:25:46,400
this right compare.

498
00:25:47,000 --> 00:25:50,700
And you can see that we've got a ton of comparison operations to

499
00:25:50,700 --> 00:25:51,300
choose from

500
00:25:52,700 --> 00:25:57,200
All of these intrinsics, you know, kind of our will map to a different

501
00:25:57,200 --> 00:25:58,100
sort of comparison.

502
00:25:58,100 --> 00:26:01,200
We want to do but for example we've got a greater than or equal to and

503
00:26:01,200 --> 00:26:04,400
you can see here and mmm comp greater than equal to PS.

504
00:26:05,200 --> 00:26:07,800
And what that does is exactly what you might think.

505
00:26:07,800 --> 00:26:12,400
It takes an A, and A B, and it looks to see if a is greater than b, if

506
00:26:12,400 --> 00:26:16,800
it is, it puts all 1s in the lane and if it's not, it puts all zeros

507
00:26:16,800 --> 00:26:17,900
in the lane, okay?

508
00:26:18,500 --> 00:26:21,700
Now, this is exactly the kind of operation, you know, this instruction

509
00:26:21,700 --> 00:26:22,000
set was

510
00:26:22,200 --> 00:26:25,100
Designed for the most part to do the sorts of things that we're doing.

511
00:26:25,200 --> 00:26:27,800
So, it's basically designed exactly to produce this thing.

512
00:26:28,000 --> 00:26:32,000
What it will do is it will take a look Bai Ling, right?

513
00:26:32,000 --> 00:26:34,500
So we have a zero should say the site.

514
00:26:34,500 --> 00:26:37,600
We have a 0, a 1, a 2, a 3, right?

515
00:26:37,600 --> 00:26:42,300
And then here, we've got b0, B1 B2 B3.

516
00:26:44,100 --> 00:26:47,400
What it's going to do, if we say could do a greater than or equal to

517
00:26:48,000 --> 00:26:51,900
is, it's actually going to compare each lane individually, right?

518
00:26:52,200 --> 00:26:54,900
And it's going to produce in the result.

519
00:26:55,200 --> 00:26:59,500
It's going to either produce all zeros in the case that it's false.

520
00:27:00,600 --> 00:27:03,100
Or all ones in the case that it's true.

521
00:27:03,900 --> 00:27:08,900
So it's literally set up specifically to produce these kinds of masks,

522
00:27:09,100 --> 00:27:09,700
why?

523
00:27:10,400 --> 00:27:17,200
Because if the concept of doing an, if no longer makes any sense in

524
00:27:17,200 --> 00:27:22,300
wide operations, the only time you ever want conditional control flow

525
00:27:22,800 --> 00:27:28,100
in wide operations, is, if all the values are 0, or all the values are

526
00:27:28,100 --> 00:27:29,900
1, right, meaning it would

527
00:27:30,000 --> 00:27:32,800
Have to be something that would apply to everything because if you

528
00:27:32,800 --> 00:27:37,700
think about what an if does, and if predicates some set of operations,

529
00:27:37,900 --> 00:27:45,100
right on you know, some some condition of the inputs, well, if some of

530
00:27:45,100 --> 00:27:47,900
them could be true and some of them could be false which is what

531
00:27:47,900 --> 00:27:49,800
happens if you do for ifs at once.

532
00:27:50,700 --> 00:27:54,700
There can't be any control flow because you can't only partially

533
00:27:54,700 --> 00:27:58,000
execute some operations for some parts of the lane and partially

534
00:27:58,000 --> 00:27:59,400
executed for others, right?

535
00:28:00,600 --> 00:28:04,600
So, if that are not on the entire Vector at once, if that are only

536
00:28:04,600 --> 00:28:10,200
between lanes stuff, cease to become ifs, and they become masks,

537
00:28:10,500 --> 00:28:11,100
right?

538
00:28:11,200 --> 00:28:14,600
What ends up happening is it always takes for anything that you'd

539
00:28:14,600 --> 00:28:16,000
have, right?

540
00:28:18,200 --> 00:28:21,800
We do an, if op 0 else.

541
00:28:23,500 --> 00:28:25,700
Up 1, right?

542
00:28:26,100 --> 00:28:29,000
So we're doing an F on some condition and we have some operational

543
00:28:29,000 --> 00:28:29,200
going to do.

544
00:28:29,200 --> 00:28:32,800
If it's true in some operation, if it's not what ifs become is.

545
00:28:32,800 --> 00:28:38,600
Instead you just always do both of these, this becomes up, zero up

546
00:28:38,600 --> 00:28:39,500
one, right?

547
00:28:39,500 --> 00:28:44,600
We do like a equals zero be quills up one and then we do a we do

548
00:28:44,600 --> 00:28:46,100
essentially a select.

549
00:28:46,100 --> 00:28:52,800
You might say we do a select of a and be subject to this if whatever

550
00:28:52,800 --> 00:28:53,200
this

551
00:28:53,300 --> 00:28:58,400
Liz and we pick the parts, the lanes of a where the conditional was

552
00:28:58,400 --> 00:28:58,700
true.

553
00:28:58,700 --> 00:29:00,500
We pick up 0, right?

554
00:29:00,800 --> 00:29:05,600
And the lanes where this condition was false, we pick the second top,

555
00:29:05,800 --> 00:29:06,400
right?

556
00:29:06,400 --> 00:29:08,800
And that is precisely what this, right?

557
00:29:08,800 --> 00:29:11,200
Mask was set up to do before, okay?

558
00:29:11,500 --> 00:29:15,200
We're always Computing, both the value, that's in dest, right?

559
00:29:15,200 --> 00:29:16,700
We loaded it and saved it.

560
00:29:16,700 --> 00:29:20,600
And we're always Computing the result of all four pixels because we do

561
00:29:20,600 --> 00:29:22,000
that computation, right?

562
00:29:23,100 --> 00:29:25,000
So what we're doing essentially with that, right?

563
00:29:25,000 --> 00:29:28,900
Mask is where essentially Computing both sides of an if statement and

564
00:29:28,900 --> 00:29:33,200
selecting / Lane which one we wanted to do?

565
00:29:33,800 --> 00:29:34,600
Does that make sense?

566
00:29:36,300 --> 00:29:36,900
So

567
00:29:38,400 --> 00:29:41,800
What we can do is we can use these comparisons to generate that,

568
00:29:41,800 --> 00:29:42,000
right?

569
00:29:42,000 --> 00:29:44,900
Mask directly because SSE was set up to do this because they knew you

570
00:29:44,900 --> 00:29:48,500
needed conditionals but you couldn't use conditionals anymore you have

571
00:29:48,500 --> 00:29:53,000
to use masking so they set it up to enable exactly that masking.

572
00:29:53,100 --> 00:29:57,500
So what we're going to do instead of our right Mass being set to 0 is

573
00:29:57,500 --> 00:29:59,800
our right mask is going to be set up to

574
00:30:00,000 --> 00:30:02,700
Will the results of these comparisons, right?

575
00:30:04,000 --> 00:30:07,600
so if I just take exactly this comparisons here, if I go ahead and

576
00:30:07,600 --> 00:30:09,800
say, we've got em em and

577
00:30:11,500 --> 00:30:13,500
PS, like so.

578
00:30:14,500 --> 00:30:20,900
And I've got an M&M and PS that happens on two ands, right?

579
00:30:21,400 --> 00:30:25,400
Because if you look here, we've got, we got to do this and this and

580
00:30:25,400 --> 00:30:28,200
this and this, and we've got to add those together, basically, right?

581
00:30:28,200 --> 00:30:31,200
So we're doing for us, or for things and it together

582
00:30:32,200 --> 00:30:37,100
so when we do that, we've got to on the you and to on the V what we

583
00:30:37,100 --> 00:30:41,600
want to do is say we want to say is it greater than or equal to

584
00:30:43,200 --> 00:30:47,100
We want to know whether you is greater than or equal to the zero

585
00:30:47,100 --> 00:30:49,300
Vector which we already set up up here, right?

586
00:30:49,300 --> 00:30:52,100
We already have this zero Vector, we already have the one vector.

587
00:30:52,100 --> 00:30:55,400
So those values are already loaded or we've already set them up, I

588
00:30:55,400 --> 00:30:56,000
should say.

589
00:30:57,800 --> 00:31:02,900
We also want to do a comparison for less than or equal to with one,

590
00:31:03,400 --> 00:31:03,900
right?

591
00:31:04,300 --> 00:31:07,200
And then we're going to do the exact same thing on v0m.

592
00:31:10,600 --> 00:31:13,700
M less than equal to 1.

593
00:31:15,000 --> 00:31:19,900
So now we've produced the right mask strictly by using SSE operations,

594
00:31:20,000 --> 00:31:20,500
right?

595
00:31:20,600 --> 00:31:22,300
And if I go ahead and compile that

596
00:31:29,600 --> 00:31:31,600
What is the same cannot convert?

597
00:31:31,700 --> 00:31:34,000
Oh yes sorry this right.

598
00:31:34,000 --> 00:31:38,500
Mask is actually needs to be cast because it is not it's coming from

599
00:31:38,900 --> 00:31:39,900
floating Point values.

600
00:31:39,900 --> 00:31:43,400
So after we do all of the Anne's we're going to have to actually cast

601
00:31:43,400 --> 00:31:43,700
it.

602
00:31:44,000 --> 00:31:47,400
You know, we're going to have to do one of these si128.

603
00:31:50,300 --> 00:31:50,800
There we go.

604
00:31:51,600 --> 00:31:52,900
So now we're producing that, right?

605
00:31:52,900 --> 00:31:56,800
Mask entirely, just by using operations, and you can see that it's

606
00:31:56,800 --> 00:31:59,500
actually working quite nicely here, right?

607
00:31:59,500 --> 00:32:00,200
So there we go.

608
00:32:00,900 --> 00:32:04,000
Now, unfortunately, we're still actually doing all the computations

609
00:32:04,000 --> 00:32:05,800
here and we're doing the computations.

610
00:32:07,100 --> 00:32:10,700
Because we still need to load our Textures in scalar.

611
00:32:10,700 --> 00:32:12,800
As you can see right now.

612
00:32:12,800 --> 00:32:16,400
We have a problem here which is that we can't just get rid of this if

613
00:32:16,400 --> 00:32:19,600
entirely and just always load the textures all the time.

614
00:32:20,100 --> 00:32:23,000
The reason that we can't do that is because we might be loading out of

615
00:32:23,000 --> 00:32:25,400
invalid memory, right.

616
00:32:26,600 --> 00:32:31,000
We, you know we have to make sure that we're always actually loading a

617
00:32:31,000 --> 00:32:35,300
valid value out when we, when we do this because otherwise we could

618
00:32:35,300 --> 00:32:36,700
access memory that was in.

619
00:32:36,900 --> 00:32:37,400
Salad.

620
00:32:37,900 --> 00:32:40,100
So what we probably want to do here, right?

621
00:32:40,300 --> 00:32:42,300
Is, we probably want to clamp.

622
00:32:42,400 --> 00:32:45,900
Are you in RV to make sure that they're never out of range.

623
00:32:46,200 --> 00:32:49,000
And then we could always load the textures, even in the cases where

624
00:32:49,000 --> 00:32:52,000
the textures were not actually going to be used.

625
00:32:52,000 --> 00:32:54,100
Now that might not be the most efficient thing, but that's something

626
00:32:54,100 --> 00:32:57,600
that we can do just off the bat to make sure that everything works

627
00:32:57,600 --> 00:32:58,200
properly.

628
00:32:58,300 --> 00:32:59,900
So once we have the u and v here and

629
00:33:00,000 --> 00:33:02,400
Convert it and we've actually computed the right mask.

630
00:33:02,400 --> 00:33:05,000
What we can then do is take the U and the V.

631
00:33:06,200 --> 00:33:10,900
And go ahead and clamp them because now we know that any pixels that

632
00:33:10,900 --> 00:33:14,000
are going to be written with the u and v have actually been computer

633
00:33:14,000 --> 00:33:16,200
with the proper you envy and anything where the u and v was out of

634
00:33:16,200 --> 00:33:16,500
range.

635
00:33:16,500 --> 00:33:19,400
Has already been masked out and won't be valid.

636
00:33:19,400 --> 00:33:24,200
So what we can do here is we can just say, OK, U equals mmm and we

637
00:33:24,200 --> 00:33:26,900
already did this code before you remember this thing right here,

638
00:33:27,000 --> 00:33:27,200
right?

639
00:33:27,200 --> 00:33:31,400
We do this to do a clamp between zero and one so we can just go ahead

640
00:33:31,400 --> 00:33:35,300
and clamp the values like so right?

641
00:33:37,600 --> 00:33:41,500
So there's our clamp and now we can actually get rid of this entirely

642
00:33:41,500 --> 00:33:44,600
if we want to, and we should be in a situation where we're never

643
00:33:44,600 --> 00:33:47,500
actually going to pick outside of the texture because it has been

644
00:33:48,200 --> 00:33:50,100
clamped ahead of time, right?

645
00:33:50,900 --> 00:33:53,100
So let's take a look, if that works.

646
00:33:54,300 --> 00:33:54,900
Oh dear.

647
00:33:55,900 --> 00:34:01,000
Well, to suffice to say, no, that did not work.

648
00:34:01,900 --> 00:34:04,600
I'm not exactly sure what I did wrong there.

649
00:34:04,700 --> 00:34:07,700
Of course, let's see.

650
00:34:10,100 --> 00:34:12,500
What did I do?

651
00:34:13,199 --> 00:34:17,699
It looks like this is actually Max PS.

652
00:34:18,100 --> 00:34:22,500
It's doing the maximum of 30 and the minimum of the u-value and one

653
00:34:23,000 --> 00:34:25,500
that's should be.

654
00:34:25,699 --> 00:34:26,699
Correct.

655
00:34:26,699 --> 00:34:30,199
Should it not what happened there?

656
00:34:31,100 --> 00:34:32,900
Oh, there we go.

657
00:34:33,300 --> 00:34:33,800
Typo.

658
00:34:33,800 --> 00:34:34,699
Didn't put the v in

659
00:34:36,400 --> 00:34:38,199
I wish you would be didn't look so darn similar.

660
00:34:39,000 --> 00:34:39,800
So there we go.

661
00:34:40,500 --> 00:34:43,600
Now, our little guy is ripping around just fine and we're always

662
00:34:43,600 --> 00:34:47,800
loading the textures so you know they're always filled in there.

663
00:34:47,800 --> 00:34:48,500
We're never doing.

664
00:34:48,500 --> 00:34:52,199
If so we never have to compute it explicitly we still have a for I

665
00:34:52,199 --> 00:34:55,300
Loop because unfortunately you know we've got some stuff that has to

666
00:34:55,300 --> 00:34:59,600
be done here for I Loop wise but we also are kind of getting to the

667
00:34:59,600 --> 00:35:03,700
point where probably we could do some of this wide as well, right?

668
00:35:03,900 --> 00:35:06,000
We could probably go ahead and leave.

669
00:35:06,200 --> 00:35:07,600
Only the Texel fetch.

670
00:35:07,700 --> 00:35:09,500
So let's go ahead and do that part as well.

671
00:35:09,500 --> 00:35:11,800
We might as well just you know we're on a roll here.

672
00:35:11,800 --> 00:35:15,900
People we're on a roll we might as well sort of go with that roll,

673
00:35:16,100 --> 00:35:16,500
right?

674
00:35:18,400 --> 00:35:21,300
So we have the X and Y that gets pulled out here.

675
00:35:21,400 --> 00:35:24,500
I'm thinking maybe we can just go ahead and do all of these

676
00:35:24,500 --> 00:35:27,500
computations in sympathy as well.

677
00:35:27,600 --> 00:35:29,700
So let's try and do the txt.

678
00:35:29,700 --> 00:35:32,000
Why one's right shall we?

679
00:35:32,300 --> 00:35:35,100
Because that seems like that should be fairly straightforward.

680
00:35:35,300 --> 00:35:40,500
Okay, so do in order to produce txt why, what we would have to do is

681
00:35:40,500 --> 00:35:43,800
we have to preload a vector with texture with minus 2 and 1 with

682
00:35:43,800 --> 00:35:45,400
texture height minus 2

683
00:35:51,200 --> 00:35:51,600
All right.

684
00:35:54,800 --> 00:35:55,500
So, up here.

685
00:35:56,600 --> 00:35:59,800
and then 128 with M2,

686
00:36:00,000 --> 00:36:00,700
Let's call it.

687
00:36:01,100 --> 00:36:02,400
M m--, set 1, PS.

688
00:36:05,400 --> 00:36:06,700
Just grab this out here.

689
00:36:07,900 --> 00:36:08,400
Here we go.

690
00:36:09,400 --> 00:36:13,600
So what we want to do is grab that value and make up a four wide

691
00:36:13,600 --> 00:36:17,100
version of that and then let's make a high temp to.

692
00:36:17,100 --> 00:36:17,600
There we go.

693
00:36:18,600 --> 00:36:21,800
And do that one set, one PS.

694
00:36:25,000 --> 00:36:25,300
Yeah.

695
00:36:27,600 --> 00:36:32,500
So now we've got both the height and the width minus 2, and we're just

696
00:36:32,500 --> 00:36:36,100
going to go ahead and use those right here to compute this is Echo

697
00:36:36,100 --> 00:36:38,400
Valley, because these are just wide multiplies, right?

698
00:36:38,400 --> 00:36:41,100
They're just going to do a multiply across the board.

699
00:36:41,500 --> 00:36:43,800
And so, if I go ahead and grab this out here,

700
00:36:44,400 --> 00:36:48,500
We still have to do this for my texture, boundary stuff.

701
00:36:48,500 --> 00:36:50,900
So we'll have to modify this a little bit later but that's okay,

702
00:36:50,900 --> 00:36:56,200
right, so I'm just going to call this m 128 tx4, right?

703
00:36:56,200 --> 00:36:56,700
Click so.

704
00:36:56,700 --> 00:37:04,600
And I believe this only actually gets used inside here, right and I

705
00:37:04,600 --> 00:37:08,200
right about that it does appear to be the case.

706
00:37:08,900 --> 00:37:10,700
Yeah, so we're going to do these wide.

707
00:37:10,700 --> 00:37:13,600
And then in here we're just going to extract them.

708
00:37:13,600 --> 00:37:14,400
So we can still use

709
00:37:14,500 --> 00:37:15,300
Some in scalar.

710
00:37:16,700 --> 00:37:17,300
Right.

711
00:37:19,500 --> 00:37:23,200
And again, I don't actually know ahead of time when I'm making these

712
00:37:23,200 --> 00:37:23,700
steps.

713
00:37:23,800 --> 00:37:24,900
I don't actually know ahead of time.

714
00:37:24,900 --> 00:37:25,900
That all of these things are things.

715
00:37:25,900 --> 00:37:30,000
We actually do want to do in that in this way.

716
00:37:30,300 --> 00:37:32,800
So we're, you know, we'll have to maybe backpedal on some of these we

717
00:37:32,800 --> 00:37:35,100
don't actually know, but we're, I'm just doing the whole

718
00:37:35,100 --> 00:37:38,400
transformation first so that we'll have everything in Cindy except the

719
00:37:38,400 --> 00:37:42,000
textile loads and then we'll see about what we can do to make that

720
00:37:42,000 --> 00:37:43,000
extraction fast.

721
00:37:43,600 --> 00:37:47,300
Alright, so up here, if we want to compute these values, what I want

722
00:37:47,300 --> 00:37:49,100
to do is I want to change this over 2A.

723
00:37:49,300 --> 00:37:56,800
Memo PS right where I multiply the U Vector for wide by the width M2

724
00:37:56,800 --> 00:37:57,600
Vector, right.

725
00:37:57,600 --> 00:37:58,700
Which is just going to do that.

726
00:37:58,700 --> 00:38:02,500
Multiply for all of the pixels at once instead of downshifting and

727
00:38:02,500 --> 00:38:04,100
doing them in scalar.

728
00:38:04,100 --> 00:38:06,100
Like we were doing them before.

729
00:38:06,200 --> 00:38:06,800
There we go.

730
00:38:07,000 --> 00:38:08,300
So we can compute those values.

731
00:38:08,300 --> 00:38:12,300
We also could do this the rest of this to write.

732
00:38:12,300 --> 00:38:15,800
If you look at this like FX and so on there's really no reason we

733
00:38:15,800 --> 00:38:18,200
couldn't have done those as well if we come down here.

734
00:38:19,900 --> 00:38:22,900
Like so and we have these FX values.

735
00:38:22,900 --> 00:38:26,300
You can see that the FX value is really just a subtraction and

736
00:38:26,300 --> 00:38:27,200
subtraction.

737
00:38:28,000 --> 00:38:29,600
You know, for this right here.

738
00:38:29,800 --> 00:38:33,800
So what we could do is we could just call this txt why we could do the

739
00:38:33,800 --> 00:38:36,400
cast and Cindy as well, right?

740
00:38:36,800 --> 00:38:39,000
These are actually, sorry and 128.

741
00:38:39,700 --> 00:38:43,800
We could do the cast and send these as well to produce that X vector

742
00:38:44,200 --> 00:38:46,100
and that y Vector, right?

743
00:38:47,700 --> 00:38:48,900
Like so I know,

744
00:38:50,300 --> 00:38:51,000
This is interesting.

745
00:38:51,000 --> 00:38:53,800
This Y is actually.

746
00:38:55,400 --> 00:38:56,800
Done in kind of a weird way there.

747
00:38:56,800 --> 00:38:59,800
Why is the why not called why?

748
00:39:00,500 --> 00:39:04,100
I oh, I guess because, yeah.

749
00:39:04,100 --> 00:39:07,400
So I feel like these are a little bit poorly named because there's the

750
00:39:07,400 --> 00:39:10,600
in slept here that actually are those things and then we shadowed it

751
00:39:10,600 --> 00:39:14,900
effectively with the Y parameter, which is kind of janky, right.

752
00:39:16,100 --> 00:39:17,300
That's a little bit nasty.

753
00:39:17,800 --> 00:39:20,100
I don't love it to be completely honest with you.

754
00:39:20,700 --> 00:39:24,100
So I'm going to I'm going to maybe introduce these as fetch X.

755
00:39:24,200 --> 00:39:27,400
Fetch why I think might be a better thing to do.

756
00:39:29,300 --> 00:39:30,200
Just for the moment.

757
00:39:31,100 --> 00:39:32,200
Let's do it like that.

758
00:39:34,900 --> 00:39:35,500
There we go.

759
00:39:36,500 --> 00:39:40,300
And then we've got this stuff and this stuff

760
00:39:41,500 --> 00:39:42,000
Right?

761
00:39:42,200 --> 00:39:44,000
So what I want to do is go ahead and get it down to this.

762
00:39:44,000 --> 00:39:47,000
So that we've got these fetches here and what this is going to be is

763
00:39:47,000 --> 00:39:49,400
this is going to be an m

764
00:39:51,200 --> 00:39:54,700
And EM fetch out right foot, just going to sort of extract that value

765
00:39:55,100 --> 00:39:57,500
from something that will compute up above.

766
00:39:57,500 --> 00:40:01,400
Which will just be, you know, fetch X for x or something.

767
00:40:04,800 --> 00:40:05,800
Something like that.

768
00:40:06,300 --> 00:40:06,700
Okay?

769
00:40:07,500 --> 00:40:10,000
So, this will be a fetch X for X.

770
00:40:10,200 --> 00:40:11,400
This will be the fetch y4y.

771
00:40:12,900 --> 00:40:15,100
Oops, that's why 4X

772
00:40:16,500 --> 00:40:20,500
So essentially, all I wanted to do here was introduced that convert PS

773
00:40:20,500 --> 00:40:20,800
right?

774
00:40:20,800 --> 00:40:23,000
The thing that does the the rounding or whatever.

775
00:40:25,400 --> 00:40:29,300
The problem with this, of course, is that the convert PS is going to

776
00:40:29,300 --> 00:40:30,000
be working.

777
00:40:32,200 --> 00:40:38,000
In round to nearest, whereas what we wanted to do was truncate, right?

778
00:40:38,200 --> 00:40:40,800
So we're going to have to do if we want to truncate.

779
00:40:41,300 --> 00:40:46,400
The value is, we're going to have to do a sub first to subtract .5

780
00:40:46,400 --> 00:40:49,900
from it so that it will fall into the correct bucket.

781
00:40:49,900 --> 00:40:51,500
I believe that's the correct thing to do.

782
00:40:52,100 --> 00:40:54,600
We'll have to take a little bit more closer look at that later.

783
00:40:54,600 --> 00:40:56,700
But again, since we can't actually

784
00:40:58,300 --> 00:40:59,000
Do that work.

785
00:40:59,500 --> 00:41:03,400
Since we can't basically ask it to truncate for us, although wait a

786
00:41:03,400 --> 00:41:03,800
minute.

787
00:41:03,900 --> 00:41:04,700
No, that's not true.

788
00:41:04,900 --> 00:41:06,100
We can do the truncate.

789
00:41:06,200 --> 00:41:09,900
We learned that yesterday, in fact, because I believe Martin's pointed

790
00:41:09,900 --> 00:41:14,400
that up for us, we actually can use that thing.

791
00:41:14,400 --> 00:41:19,900
That always does truncate right, there was the mm convert PS.

792
00:41:22,300 --> 00:41:23,800
Which always truncates.

793
00:41:25,000 --> 00:41:25,800
With truncation.

794
00:41:25,800 --> 00:41:28,700
All right, so that's actually super handy.

795
00:41:28,700 --> 00:41:30,200
We don't have to do subtraction either.

796
00:41:30,300 --> 00:41:33,200
Can just do that and get ourselves.

797
00:41:33,200 --> 00:41:34,100
Always truncated.

798
00:41:34,700 --> 00:41:35,100
Okay?

799
00:41:37,100 --> 00:41:41,100
All right, so we do the multiplication here to produce RT, X Cy.

800
00:41:41,100 --> 00:41:41,300
Right.

801
00:41:41,300 --> 00:41:44,600
That's where in the texture, we're going to fetch in floating point.

802
00:41:44,600 --> 00:41:47,400
We then truncate that to produce the value that we were using to

803
00:41:47,400 --> 00:41:50,300
figure out exactly which pixel to get directly out of the array.

804
00:41:50,600 --> 00:41:54,400
And, you know, turn to give us our base corner for our, for wide

805
00:41:54,400 --> 00:41:54,900
fetch.

806
00:41:55,000 --> 00:41:55,600
Right.

807
00:41:55,800 --> 00:41:59,800
We then have our FX and FY, which we were

808
00:42:00,000 --> 00:42:00,500
Computing.

809
00:42:03,500 --> 00:42:07,700
Excuse me by figuring out what the fractional part of X and Y is.

810
00:42:07,800 --> 00:42:12,600
So all that's going to be is a subtraction between again, the the

811
00:42:12,600 --> 00:42:14,800
truncated version and the non truncated version.

812
00:42:15,400 --> 00:42:19,800
So we just have to do subtraction from t x and t.

813
00:42:19,800 --> 00:42:23,500
Why of essentially upconverted, right?

814
00:42:23,700 --> 00:42:28,300
We want to do, we don't want to cast, we want to convert epi32 PS.

815
00:42:28,300 --> 00:42:31,000
We basically want to do the conversion of the other direction.

816
00:42:31,000 --> 00:42:33,100
Take an integer and convert it up.

817
00:42:33,200 --> 00:42:34,200
Floating Point.

818
00:42:35,200 --> 00:42:45,200
Let's see where that is where that is compared close-ups are not

819
00:42:45,200 --> 00:42:51,600
convert convert so that's going to be it converts epi32 PS.

820
00:42:51,800 --> 00:42:54,500
So you can see this one here, goes the other direction, right?

821
00:42:54,500 --> 00:42:58,800
It can it converts the integers up to floating point which is what we

822
00:42:58,800 --> 00:43:00,200
were doing before, right?

823
00:43:00,400 --> 00:43:02,700
So we can do exactly that operation.

824
00:43:03,300 --> 00:43:06,400
To up convert the rounded versions that we just did.

825
00:43:06,800 --> 00:43:07,600
Which are these

826
00:43:09,400 --> 00:43:14,200
There's RX there's our Y and then that's doing this operation that we

827
00:43:14,200 --> 00:43:15,800
use to be doing in the loop.

828
00:43:15,800 --> 00:43:19,900
It's doing that for a wide and then we're down to literally just doing

829
00:43:19,900 --> 00:43:23,600
just those Texel fetches I think everything else is now being done

830
00:43:24,100 --> 00:43:25,000
properly there.

831
00:43:26,300 --> 00:43:29,600
See here conversion from float to int possible.

832
00:43:29,600 --> 00:43:31,000
Also dips that's supposed to be an.

833
00:43:31,000 --> 00:43:32,800
Am I like so?

834
00:43:33,400 --> 00:43:35,400
And I'm a we did a bunch of Ops there.

835
00:43:35,400 --> 00:43:37,400
So I may have gotten something wrong but I'm not sure.

836
00:43:37,400 --> 00:43:38,100
Looks like it's

837
00:43:38,200 --> 00:43:39,600
It's all correct though.

838
00:43:40,100 --> 00:43:44,200
So we got that converted properly and we are now down to under 70

839
00:43:44,200 --> 00:43:46,400
Cycles as well, which is kind of cool.

840
00:43:46,500 --> 00:43:48,600
Right, there we go.

841
00:43:50,800 --> 00:43:55,200
Okay, so looking back up on here, right?

842
00:43:55,600 --> 00:43:58,500
We still have a plenty of work to do because we actually have a bunch

843
00:43:58,500 --> 00:44:01,400
of other things that we kind of cut and paste it out of that Loop, but

844
00:44:01,400 --> 00:44:05,500
that still aren't done actually for wide and we can get these guys

845
00:44:05,500 --> 00:44:05,700
now.

846
00:44:05,700 --> 00:44:08,900
Since they're all none of those guys have to be initialized in that

847
00:44:08,900 --> 00:44:10,000
kind of janky way anymore.

848
00:44:10,500 --> 00:44:16,800
They can all actually be be done just in time down here, right?

849
00:44:17,400 --> 00:44:19,000
So we can do

850
00:44:20,500 --> 00:44:21,500
basically, this

851
00:44:30,700 --> 00:44:34,300
All right, and in theory, the compiler should not complain about that

852
00:44:34,300 --> 00:44:34,700
anymore.

853
00:44:34,700 --> 00:44:37,200
We had only initialize those because the compiler was complaining and

854
00:44:37,200 --> 00:44:38,800
so now they aren't complaining anymore.

855
00:44:39,100 --> 00:44:40,100
So that's a good thing.

856
00:44:40,800 --> 00:44:45,200
And so we should be able to basically get all of those done this way

857
00:44:46,100 --> 00:44:46,800
like so

858
00:44:50,900 --> 00:44:51,300
Oops.

859
00:44:54,600 --> 00:44:55,300
Thirsty.

860
00:45:01,000 --> 00:45:01,400
See.

861
00:45:05,400 --> 00:45:06,400
And finally d.

862
00:45:15,500 --> 00:45:16,000
Okay?

863
00:45:16,000 --> 00:45:18,700
And now the Blended and dust also work that way, right?

864
00:45:18,700 --> 00:45:20,400
We can come down and see those here.

865
00:45:22,000 --> 00:45:24,600
Certainly dest obviously is exactly the same.

866
00:45:24,600 --> 00:45:28,900
As the other ones were believe Blended is a little further down

867
00:45:29,300 --> 00:45:30,200
there's desk

868
00:45:33,900 --> 00:45:38,600
And down here, where is our Blended lended?

869
00:45:38,600 --> 00:45:39,200
There it is.

870
00:45:40,800 --> 00:45:42,600
So our Blended can actually be done.

871
00:45:42,600 --> 00:45:43,600
Just right in line.

872
00:45:43,600 --> 00:45:44,300
I think right.

873
00:45:44,300 --> 00:45:46,100
This could just be M1 28.

874
00:45:46,600 --> 00:45:49,400
Like so defined as it's used.

875
00:45:50,400 --> 00:45:53,100
Alrighty, so off we go again.

876
00:45:53,700 --> 00:45:56,500
Again, we're well south of 70 Cycles.

877
00:45:56,500 --> 00:45:59,800
Now per pixel, which is pretty darn cool.

878
00:46:00,900 --> 00:46:03,500
Kid things continue to get faster, literally just from translating

879
00:46:03,500 --> 00:46:04,600
things and assembly.

880
00:46:05,800 --> 00:46:09,900
And if I come back now and take a look at where we're at, we've got

881
00:46:09,900 --> 00:46:13,800
almost everything in CMD, except for the textile loads, which were

882
00:46:13,800 --> 00:46:16,100
probably have to stay out of some because there's no such thing as a

883
00:46:16,100 --> 00:46:16,800
Cindy fetch.

884
00:46:16,800 --> 00:46:19,600
Unfortunately, it be great if you could fetch things for a wide,

885
00:46:19,600 --> 00:46:20,100
that's

886
00:46:20,200 --> 00:46:24,900
Thing I think in avx-512, but, you know, it's not here yet, so we

887
00:46:24,900 --> 00:46:25,800
can't do that.

888
00:46:26,000 --> 00:46:29,600
But all this stuff is happening for white up here and everything below

889
00:46:29,600 --> 00:46:31,000
here is happening for a wide.

890
00:46:31,300 --> 00:46:33,200
So really, we're just looking at this part.

891
00:46:33,400 --> 00:46:36,300
Now, we're we're extracting those textiles and up converting them.

892
00:46:36,900 --> 00:46:40,300
That is the only part that is not happening for wide, that could be

893
00:46:40,300 --> 00:46:41,700
and should be happening for a wide.

894
00:46:41,700 --> 00:46:43,800
So let's take a look at how to do that.

895
00:46:43,800 --> 00:46:48,000
We have our low destination here, we want to basically do the reverse

896
00:46:48,000 --> 00:46:49,200
of what we were doing before.

897
00:46:50,400 --> 00:46:52,100
When we were trying to write pixels out.

898
00:46:52,200 --> 00:46:57,600
So what we have right, is when we load from the destination, we've got

899
00:46:57,600 --> 00:46:59,500
something that looks like this.

900
00:47:00,100 --> 00:47:04,500
Where we've got packed pixels in here that are packed in sort of this

901
00:47:04,500 --> 00:47:13,000
again be gra, you know, be G, ra, be gra be gra, right?

902
00:47:13,000 --> 00:47:17,200
That's what we've got and what we want to be able to do again is we

903
00:47:17,200 --> 00:47:19,800
need to take one of these guys.

904
00:47:20,000 --> 00:47:26,000
A single one of these guys and we need to be able to unpack it out

905
00:47:26,000 --> 00:47:30,400
into something that looks like this, right?

906
00:47:30,400 --> 00:47:31,600
We need to get

907
00:47:33,400 --> 00:47:34,900
all of save the bees.

908
00:47:35,900 --> 00:47:40,300
We need to get all of those out into vectors that look like this,

909
00:47:40,800 --> 00:47:41,300
right?

910
00:47:46,400 --> 00:47:47,000
Right.

911
00:47:47,000 --> 00:47:50,700
And then immediately after down with that, we got to do exactly the

912
00:47:50,700 --> 00:47:53,800
same thing for the other components now.

913
00:47:53,800 --> 00:47:57,800
Fortunately, I mean, I think we can probably do this in exactly the

914
00:47:57,800 --> 00:47:59,800
same way that we were doing it before kind of

915
00:48:00,000 --> 00:48:00,600
Reverse.

916
00:48:00,900 --> 00:48:04,600
If we were to knock out if we're to mask out all these values and just

917
00:48:04,600 --> 00:48:06,400
leave the bees, right?

918
00:48:06,500 --> 00:48:08,900
We could then convert the be in place because we know it's a value

919
00:48:08,900 --> 00:48:09,900
between 0 and 25.

920
00:48:09,900 --> 00:48:11,300
We know it's a bite, right?

921
00:48:11,300 --> 00:48:14,600
We convert it in place and then multiply it to convert it to a

922
00:48:14,600 --> 00:48:15,900
floating point value, right?

923
00:48:15,900 --> 00:48:18,900
So we actually can do essentially the exact opposite of what we were

924
00:48:18,900 --> 00:48:23,200
doing on the desk and it should in theory be fine.

925
00:48:23,200 --> 00:48:26,400
So for example, if I'm going to Target desk be I'm just going to knock

926
00:48:26,400 --> 00:48:29,800
out the desk bees of all of these here, right?

927
00:48:31,300 --> 00:48:34,000
And we have original death, which is the loaded version of our

928
00:48:34,000 --> 00:48:36,300
destination that's packed in that, that way.

929
00:48:36,600 --> 00:48:40,700
So if I want to go ahead here and create a version of death, be that

930
00:48:40,700 --> 00:48:43,000
comes directly from original desk.

931
00:48:43,000 --> 00:48:47,600
Instead of being done in this sort of piecemeal scalar fashion, where

932
00:48:47,600 --> 00:48:50,400
were, you know, writing all over the registers and doing ridiculous,

933
00:48:50,400 --> 00:48:51,300
extraction stuff.

934
00:48:52,000 --> 00:48:55,600
If I wanted to do that all I would have to do is first mask it out,

935
00:48:55,600 --> 00:48:56,200
right?

936
00:48:56,500 --> 00:48:58,400
And again, we know we just did this, right?

937
00:48:58,400 --> 00:49:00,400
We're just going to do a mask where we

938
00:49:00,600 --> 00:49:05,100
Mask out a portion of the of the thing.

939
00:49:07,700 --> 00:49:11,100
And so we want this to be like basically our Arlo mask.

940
00:49:11,100 --> 00:49:16,200
So we want this to be you know our mask 255 or something and call that

941
00:49:16,200 --> 00:49:21,200
but like you know basically this this value mask FF maybe let's call

942
00:49:21,200 --> 00:49:21,600
that.

943
00:49:22,200 --> 00:49:28,900
So we want to end this with a 4 wide replica FF to do that operation,

944
00:49:29,000 --> 00:49:29,600
right?

945
00:49:30,100 --> 00:49:33,000
And then what we want to do is we want to up convert that using

946
00:49:33,000 --> 00:49:35,300
convert, PS epi32,

947
00:49:35,500 --> 00:49:40,800
we want to basically up convert that into that, that endpoint now it's

948
00:49:40,800 --> 00:49:42,500
a 025 floating point value.

949
00:49:42,600 --> 00:49:46,200
And so then the only thing that we would have to do following that

950
00:49:46,200 --> 00:49:46,800
right?

951
00:49:46,800 --> 00:49:51,100
Is we have to well, I guess, you know what, I don't think we have to

952
00:49:51,100 --> 00:49:54,100
do anything after that, actually, because the desk is already getting

953
00:49:54,100 --> 00:49:55,200
taken care of down here.

954
00:49:55,200 --> 00:49:59,400
It's already being done with its in 55 multiply so, really, actually,

955
00:49:59,400 --> 00:50:00,300
I guess that's it.

956
00:50:00,400 --> 00:50:02,200
That's the entirety of what we have to do.

957
00:50:02,500 --> 00:50:03,700
Am I wrong about that?

958
00:50:04,000 --> 00:50:04,900
We just need

959
00:50:06,700 --> 00:50:07,800
We just need that mask.

960
00:50:07,800 --> 00:50:11,300
If F value to be declared which again is really, really simple.

961
00:50:11,800 --> 00:50:15,800
All that is mask FF, right?

962
00:50:15,800 --> 00:50:20,900
All that is is set one epi32.

963
00:50:21,600 --> 00:50:24,900
It's just one of these

964
00:50:26,200 --> 00:50:26,700
Right.

965
00:50:29,700 --> 00:50:30,100
Oops.

966
00:50:34,000 --> 00:50:35,200
What is the question?

967
00:50:35,200 --> 00:50:35,900
Not convert?

968
00:50:35,900 --> 00:50:37,900
Argument one from 2128.

969
00:50:37,900 --> 00:50:38,400
Oh whoops.

970
00:50:42,400 --> 00:50:45,100
Sorry, I always get the sense wrong, which one we're going to.

971
00:50:45,200 --> 00:50:49,400
This means we're going from an Epi 32 to a PS value.

972
00:50:50,100 --> 00:50:50,600
There we go.

973
00:50:51,300 --> 00:50:53,400
So that converts our blue channel, right?

974
00:50:53,400 --> 00:50:56,200
And there's no reason that we can't do all of the destination that

975
00:50:56,200 --> 00:50:56,700
way, right?

976
00:50:56,700 --> 00:50:59,200
Because it's going to be the exact same operation in all cases.

977
00:50:59,400 --> 00:50:59,800
So now

978
00:51:00,000 --> 00:51:04,500
Essentially just got, you know, RGB and a we can do all of them

979
00:51:04,500 --> 00:51:05,400
exactly this way.

980
00:51:05,400 --> 00:51:09,300
All we would have to do is shift them into the right place, right?

981
00:51:10,100 --> 00:51:13,500
Because they're all exactly the same mask operation.

982
00:51:13,700 --> 00:51:19,300
All we need to do is, you know, right before we do that mask, make

983
00:51:19,300 --> 00:51:21,100
sure we shift them down, right?

984
00:51:22,200 --> 00:51:28,000
So we just need to make sure that we do a right shift and I guess I

985
00:51:28,000 --> 00:51:30,100
don't remember to be honest with you.

986
00:51:30,400 --> 00:51:35,800
What exactly the pi3 to, I don't even remember what the shift value

987
00:51:35,800 --> 00:51:36,600
actually is.

988
00:51:37,100 --> 00:51:42,500
It's something like rli for right?

989
00:51:42,500 --> 00:51:44,000
Logical immediate.

990
00:51:45,100 --> 00:51:45,600
Car.

991
00:51:47,800 --> 00:51:48,800
Shift right?

992
00:51:48,800 --> 00:51:49,800
Logical immediate.

993
00:51:49,800 --> 00:51:50,600
Is that what it is?

994
00:51:52,200 --> 00:51:56,500
Nope, you guessed wrong Casey shift.

995
00:51:59,200 --> 00:52:00,400
Shift, right.

996
00:52:00,400 --> 00:52:01,700
Logical immediate.

997
00:52:01,700 --> 00:52:02,300
There we go.

998
00:52:02,300 --> 00:52:03,500
Epi32.

999
00:52:03,800 --> 00:52:04,400
There we go.

1000
00:52:06,500 --> 00:52:07,200
All right.

1001
00:52:07,300 --> 00:52:08,400
So shift.

1002
00:52:08,500 --> 00:52:09,000
Right?

1003
00:52:09,000 --> 00:52:10,300
Logical immediate.

1004
00:52:10,300 --> 00:52:14,300
There we go and we want to be able to shift that down by the our

1005
00:52:14,300 --> 00:52:14,700
shift.

1006
00:52:14,700 --> 00:52:16,100
Which again is 16, right?

1007
00:52:16,100 --> 00:52:17,900
It's exactly like it was up here.

1008
00:52:19,700 --> 00:52:20,300
There we go.

1009
00:52:21,500 --> 00:52:26,200
So we want to shift the G by 8, which is our eighth shift and we want

1010
00:52:26,200 --> 00:52:30,700
the alpha to be shifted by 24, which is the alpha shift, right?

1011
00:52:31,400 --> 00:52:35,900
And so we can stack those I guess by their memory order just for fun.

1012
00:52:37,300 --> 00:52:37,800
Right.

1013
00:52:39,300 --> 00:52:40,100
And that's about it.

1014
00:52:40,100 --> 00:52:44,600
So, that gets rid of all of this and makes that kind of a nice more

1015
00:52:44,600 --> 00:52:46,600
clean, more concise fashion.

1016
00:52:47,300 --> 00:52:47,900
Like, so,

1017
00:52:49,900 --> 00:52:54,000
And still didn't lie, pick up, much on that again, we're kind of down

1018
00:52:54,000 --> 00:52:58,400
to the plate where we're only doing saving a few things and I don't

1019
00:52:58,400 --> 00:53:01,400
even know how much the processor might be able to figure some of those

1020
00:53:01,400 --> 00:53:02,000
out for us.

1021
00:53:02,200 --> 00:53:06,500
But anyway, we can now do the exact same thing for these guys in

1022
00:53:06,500 --> 00:53:11,500
theory, but it's a little bit harder because remember, we have this

1023
00:53:11,500 --> 00:53:17,100
problem, where we actually don't load for textiles, we have to

1024
00:53:17,100 --> 00:53:18,600
replicate, if you will

1025
00:53:19,000 --> 00:53:24,200
We have to kind of like well here let me just show you on the board.

1026
00:53:24,900 --> 00:53:27,800
So when we were doing dust, it was easy because dust already have the

1027
00:53:27,800 --> 00:53:29,600
values in here, right?

1028
00:53:31,000 --> 00:53:33,400
What we want to do with our texels is.

1029
00:53:33,500 --> 00:53:36,400
We have four different samples, right?

1030
00:53:36,400 --> 00:53:38,400
We've got sample a sample, B sample.

1031
00:53:38,400 --> 00:53:39,600
See, and Sample D.

1032
00:53:39,800 --> 00:53:44,700
And we, those are actually the samples that need to get Blended for

1033
00:53:44,800 --> 00:53:46,400
each of the pixels.

1034
00:53:46,500 --> 00:53:48,800
And each of the pixels has a separate one loaded.

1035
00:53:48,800 --> 00:53:49,400
Right.

1036
00:53:49,900 --> 00:53:55,100
So we essentially have if you will a matrix which is kind of kind of

1037
00:53:55,100 --> 00:53:59,800
nasty, we have a 4 wide Matrix for tall.

1038
00:54:00,000 --> 00:54:01,200
Tracks right?

1039
00:54:01,500 --> 00:54:03,800
Which is broken up.

1040
00:54:05,800 --> 00:54:07,200
Like so, right?

1041
00:54:07,700 --> 00:54:12,300
We have, which pixel we're operating on, right?

1042
00:54:12,400 --> 00:54:15,400
So we basically have like, you know, pixel 0 pixel.

1043
00:54:15,400 --> 00:54:18,200
Well, I guess I'll do it in standard order here.

1044
00:54:18,400 --> 00:54:23,000
So we have pixel 0, pixel, one, pixel to pixel 3, but then we also

1045
00:54:23,000 --> 00:54:25,300
have sample, a sample, B sample.

1046
00:54:25,300 --> 00:54:27,700
See, sample d right now.

1047
00:54:27,700 --> 00:54:31,300
What we would like to do is we'd like to be able to treat those pixel

1048
00:54:31,300 --> 00:54:31,900
values.

1049
00:54:32,100 --> 00:54:35,500
Treat those sample size as if they were packed pixelize even though

1050
00:54:35,700 --> 00:54:36,900
Came from multiple locations.

1051
00:54:36,900 --> 00:54:40,400
So what we want to do is prepare an a, a sample, a value.

1052
00:54:40,800 --> 00:54:48,700
That actually packs a 0 here, A 1 here, a 2 here, and a 3 here, right

1053
00:54:49,900 --> 00:54:54,300
into one Cindy register, so that we can do the operations on all the

1054
00:54:54,300 --> 00:54:55,100
pixels at once.

1055
00:54:55,100 --> 00:54:56,900
Like we were doing before, right?

1056
00:54:57,800 --> 00:55:00,800
So, in order to do that, what I'd like to do is say, well, let's make

1057
00:55:00,800 --> 00:55:05,300
this sample stuff actually be packed in exactly that way, right?

1058
00:55:05,600 --> 00:55:09,400
Let's make that be packed across the pixels.

1059
00:55:10,800 --> 00:55:15,600
So instead of having that array, we're going to make these into packed

1060
00:55:15,600 --> 00:55:16,400
registers.

1061
00:55:18,600 --> 00:55:20,600
Packed per pixel like so.

1062
00:55:21,200 --> 00:55:26,200
And then these guys are going to become 128 and 128 eyes, right?

1063
00:55:34,600 --> 00:55:35,300
Makes sense.

1064
00:55:36,100 --> 00:55:41,400
So once those guys are packed now, all of these things can actually be

1065
00:55:41,400 --> 00:55:41,900
done.

1066
00:55:42,200 --> 00:55:42,400
Right?

1067
00:55:42,400 --> 00:55:45,600
This way, as an MI value,

1068
00:55:47,400 --> 00:55:49,400
In fact, let's see.

1069
00:55:49,400 --> 00:55:51,600
Can we do some crazy Kung Fu here?

1070
00:55:51,800 --> 00:55:52,900
Let's find out if we can.

1071
00:55:53,800 --> 00:55:55,300
So I'm going to do a keyboard macro.

1072
00:55:55,300 --> 00:56:00,100
I'm going to search for wax sample, right.

1073
00:56:00,100 --> 00:56:01,200
Go back to it.

1074
00:56:01,300 --> 00:56:05,800
Insert the em, I hope in the parentheses, look for the bracket, close

1075
00:56:05,800 --> 00:56:08,700
it space come over and do that.

1076
00:56:09,400 --> 00:56:12,300
There we go, and off, we go.

1077
00:56:14,600 --> 00:56:16,900
Macros to the rescue.

1078
00:56:19,100 --> 00:56:19,700
Here we go.

1079
00:56:22,400 --> 00:56:23,100
And done.

1080
00:56:23,700 --> 00:56:28,100
All right, now we're doing things out of pack registers as you can see

1081
00:56:28,300 --> 00:56:32,400
no change, Although our cycle count continues to drop of course.

1082
00:56:34,200 --> 00:56:35,000
So there we go.

1083
00:56:35,600 --> 00:56:38,200
So now that we've gotten those into packed, we can start to look at

1084
00:56:38,200 --> 00:56:39,600
these and do these exactly same way.

1085
00:56:39,600 --> 00:56:43,100
Now, they pretty much are exactly this operation, right?

1086
00:56:43,200 --> 00:56:47,100
Because now, we essentially have what is the equivalent of the same

1087
00:56:47,100 --> 00:56:50,600
packing format in original dest in each of our samples.

1088
00:56:50,800 --> 00:56:51,800
So, if we want to do these,

1089
00:56:52,000 --> 00:56:55,700
Axel's we should in theory, just be able to clone exactly this code,

1090
00:56:55,800 --> 00:56:56,300
right?

1091
00:56:56,300 --> 00:56:59,200
We should be able to say that Texel.

1092
00:57:00,000 --> 00:57:04,400
DB right Texel DG Texel, Dr.

1093
00:57:04,500 --> 00:57:08,300
And Texel da are just the exact same things.

1094
00:57:08,700 --> 00:57:12,700
All that we were doing to unpack the desk but we're doing them off of

1095
00:57:12,700 --> 00:57:16,400
that sample, D that we prepared, which is basically a 4 pixel pack

1096
00:57:16,600 --> 00:57:17,700
version of the previous thing.

1097
00:57:17,700 --> 00:57:19,200
And then we just get rid of all this.

1098
00:57:19,400 --> 00:57:24,300
And we've got that little concise piece of code to process Texel d,

1099
00:57:24,400 --> 00:57:26,400
right off we go.

1100
00:57:26,600 --> 00:57:28,300
Everything looks good, right?

1101
00:57:28,400 --> 00:57:29,900
So essentially, what we can do is we can just

1102
00:57:30,000 --> 00:57:34,000
Do that for each of these and then we get rid of all of that, sort of

1103
00:57:34,000 --> 00:57:36,300
scalar version of the code and everything.

1104
00:57:36,400 --> 00:57:38,800
Can now be done why.

1105
00:57:39,100 --> 00:57:42,000
So, if I just go ahead and delete all this, just get rid of all this

1106
00:57:42,000 --> 00:57:45,000
code, goodbye, and just do each of these.

1107
00:57:45,100 --> 00:57:49,700
Once for each of our texels for each of our, you know, bilinear,

1108
00:57:49,700 --> 00:57:52,200
textiles texture samples here, like so

1109
00:57:55,000 --> 00:57:56,400
Let's go ahead and get those out there.

1110
00:58:01,000 --> 00:58:02,300
And Sample a.

1111
00:58:03,000 --> 00:58:07,400
We now have a pretty much everything converted to Cindy.

1112
00:58:09,100 --> 00:58:09,700
There we go.

1113
00:58:10,500 --> 00:58:11,600
And hey, look at that.

1114
00:58:12,000 --> 00:58:15,400
We're pretty much right down to where we wanted to be 50 cycles for

1115
00:58:15,400 --> 00:58:18,600
Pixel, strictly with just converting things to Cindy.

1116
00:58:18,600 --> 00:58:21,700
We're basically already there and we haven't really even done anything

1117
00:58:21,700 --> 00:58:22,400
else yet.

1118
00:58:22,700 --> 00:58:24,200
So, that's pretty awesome as well.

1119
00:58:25,000 --> 00:58:30,100
Okay, so we've got two minutes left, right?

1120
00:58:31,700 --> 00:58:33,800
Trying to think if there's anything else that we didn't do in here

1121
00:58:33,800 --> 00:58:38,600
that we have load destination unpack?

1122
00:58:39,200 --> 00:58:40,300
Paxil samples.

1123
00:58:44,600 --> 00:58:49,000
It looks like almost everything is now going through there except the

1124
00:58:49,000 --> 00:58:50,300
Texel fetch.

1125
00:58:50,300 --> 00:58:52,600
That looks like pretty much it.

1126
00:58:54,500 --> 00:58:57,200
I might be forgetting something, but it looks pretty good.

1127
00:58:57,700 --> 00:59:00,800
So there's one thing that we could do also right now which might be

1128
00:59:00,800 --> 00:59:01,500
kind of fun.

1129
00:59:02,200 --> 00:59:07,000
Which is I was saying before, what happens if you, if we don't really

1130
00:59:07,000 --> 00:59:08,900
need to set anything, right?

1131
00:59:09,300 --> 00:59:11,700
If you take a look at what happens here, we compute these u and v,

1132
00:59:11,700 --> 00:59:15,100
vectors we compute our right mask, right?

1133
00:59:15,500 --> 00:59:19,700
And I'm going to go ahead and move this original desk computation kind

1134
00:59:19,700 --> 00:59:23,700
of down here just for a second thing that loads the destination we

1135
00:59:23,700 --> 00:59:24,300
compute this

1136
00:59:24,500 --> 00:59:25,300
Mask.

1137
00:59:25,600 --> 00:59:28,400
But what if the right mask was all zeros, right?

1138
00:59:28,400 --> 00:59:32,200
So what if none of the pixels actually needed to get written?

1139
00:59:32,700 --> 00:59:33,400
You know what I'm saying?

1140
00:59:34,600 --> 00:59:38,500
If none of the pixels get written, we could effectively, do you know,

1141
00:59:38,900 --> 00:59:43,500
a giant, if around this whole thing where we just don't do any work at

1142
00:59:43,500 --> 00:59:44,000
all.

1143
00:59:44,000 --> 00:59:47,000
When we know that we're completely all four of the pixels are

1144
00:59:47,000 --> 00:59:51,800
completely outside of the fill, right?

1145
00:59:51,900 --> 00:59:52,800
We could do that.

1146
00:59:53,400 --> 00:59:57,300
And what I wanted to point out was there actually is a thing that

1147
00:59:57,300 --> 00:59:59,400
allows us to do that, right?

1148
01:00:00,000 --> 01:00:03,600
There is a thing called move mask, right?

1149
01:00:05,500 --> 01:00:08,100
And what move mask does you can see here.

1150
01:00:08,500 --> 01:00:12,000
It creates a mass from the most significant bit of each 8-bit element

1151
01:00:12,000 --> 01:00:14,200
in a and the stores, the result in dest.

1152
01:00:14,200 --> 01:00:21,100
So it basically takes every 8 bit and it puts it out into a scalar,

1153
01:00:21,600 --> 01:00:22,200
right?

1154
01:00:22,600 --> 01:00:26,300
So if we wanted to, we could also just do just trivially just to see

1155
01:00:26,300 --> 01:00:27,300
if it helped at all.

1156
01:00:27,500 --> 01:00:32,600
We could do a move mask Epi on the right mask and only if something

1157
01:00:32,600 --> 01:00:34,400
was set right.

1158
01:00:35,600 --> 01:00:40,200
Only, if some pixel was going to get filled, would we actually do the

1159
01:00:40,200 --> 01:00:40,600
work?

1160
01:00:40,600 --> 01:00:45,600
And so we can run that here and you can actually see the results right

1161
01:00:45,700 --> 01:00:45,800
now.

1162
01:00:45,800 --> 01:00:49,200
Unfortunately, that doesn't seem to give us any that doesn't give us

1163
01:00:49,200 --> 01:00:50,500
any speed when there.

1164
01:00:51,900 --> 01:00:53,500
But I just wanted to point out that it's possible.

1165
01:00:53,700 --> 01:00:59,300
If we were looping over a bunch of pixels which to do here,

1166
01:01:02,300 --> 01:01:03,700
Later recheck.

1167
01:01:03,700 --> 01:01:07,300
If this helps there's no point doing it doesn't help just want to

1168
01:01:07,300 --> 01:01:12,100
point out that it is possible to get things out of the conversion out

1169
01:01:12,100 --> 01:01:15,100
of the four wide into scalar if you want to do tests.

1170
01:01:15,800 --> 01:01:20,300
All right, so let's go ahead and go to the Q&A.

1171
01:01:27,200 --> 01:01:28,800
I think we're in pretty good shape here.

1172
01:01:28,800 --> 01:01:30,500
Looking at how things are working.

1173
01:01:32,900 --> 01:01:34,200
Doesn't look too bad.

1174
01:01:34,500 --> 01:01:35,900
Does not look too bad.

1175
01:01:40,600 --> 01:01:41,600
At 55 Cycles.

1176
01:01:41,600 --> 01:01:42,000
A pixel.

1177
01:01:42,000 --> 01:01:43,800
This is plenty Zippy.

1178
01:01:44,000 --> 01:01:45,800
You could easily play the game this way.

1179
01:01:46,000 --> 01:01:47,600
If you were so inclined,

1180
01:02:02,600 --> 01:02:03,300
All right.

1181
01:02:03,300 --> 01:02:07,200
Could you not just align the ex Corde to a 4 pixel, boundary upfront

1182
01:02:07,200 --> 01:02:09,800
and thereby use aligned loads and stores?

1183
01:02:09,900 --> 01:02:14,200
Yes, we absolutely could but you're getting ahead of us grumpy giant,

1184
01:02:14,600 --> 01:02:15,800
you are getting ahead of us.

1185
01:02:16,900 --> 01:02:20,600
Basically, I don't want to do that just yet because you'll notice that

1186
01:02:20,600 --> 01:02:28,200
we're still doing some nonsense here with with pre making the width

1187
01:02:28,200 --> 01:02:31,400
and height not actually be full so that we don't overwrite them.

1188
01:02:31,400 --> 01:02:31,900
And so,

1189
01:02:32,300 --> 01:02:36,900
I have to go back and properly allocate our frame buffer to make sure

1190
01:02:37,300 --> 01:02:41,400
that it's aligned in the first place in order to make all of this

1191
01:02:41,400 --> 01:02:42,500
stuff work properly, right?

1192
01:02:42,500 --> 01:02:43,600
So we just have to do this.

1193
01:02:43,600 --> 01:02:46,400
A couple things I want to show how to do before we get to that, but we

1194
01:02:46,400 --> 01:02:47,800
will actually do that.

1195
01:02:47,900 --> 01:02:48,400
I don't know that.

1196
01:02:48,400 --> 01:02:51,100
It'll actually have an effect on this processor but we will be doing

1197
01:02:51,100 --> 01:02:51,500
that.

1198
01:02:52,800 --> 01:02:55,900
Probably I suspect will test to make sure it's faster.

1199
01:03:03,400 --> 01:03:06,000
We pulling this code over into the ground Splat soon.

1200
01:03:06,900 --> 01:03:10,800
So actually this would already be working for the ground Splats if we

1201
01:03:10,800 --> 01:03:15,500
turned it on there, I turned off the ground / just because you know,

1202
01:03:15,500 --> 01:03:18,300
they were eating up a but they are what gets called first.

1203
01:03:18,300 --> 01:03:20,500
And so they were eating up a bunch of time.

1204
01:03:20,500 --> 01:03:24,600
But I, you know, if we turned it on, it is what's getting used for the

1205
01:03:24,600 --> 01:03:26,300
ground spots at the moment.

1206
01:03:28,300 --> 01:03:29,800
But those are so heavy weight.

1207
01:03:29,800 --> 01:03:34,000
At this point, I'm afraid, I don't know that we've sped it up enough

1208
01:03:34,400 --> 01:03:40,400
to make a difference with that code right because it's just doing way

1209
01:03:40,400 --> 01:03:45,300
too many of the Splats for a large number of reasons, one of which

1210
01:03:45,300 --> 01:03:48,100
being the fact that it's doing it in perspective at the moment, right?

1211
01:03:49,700 --> 01:03:55,300
So you can see we're still super janky there because we've just got

1212
01:03:55,800 --> 01:03:58,900
So much more Phil that's happening because of those those grants

1213
01:03:58,900 --> 01:03:59,100
chunks.

1214
01:03:59,100 --> 01:04:04,700
You know, one thing that I could do, I suppose to ameliorate that a

1215
01:04:04,700 --> 01:04:08,600
little bit, if you want the ground chunks on temporarily even though

1216
01:04:08,600 --> 01:04:11,900
now's not really a good time to have those ground chunks on because we

1217
01:04:11,900 --> 01:04:17,200
just haven't, we haven't done what we need to do that code but what we

1218
01:04:17,200 --> 01:04:21,700
could do if you really want to is the ground, buffer count, if it was

1219
01:04:21,700 --> 01:04:25,600
extended to a higher number would make it so that it

1220
01:04:26,000 --> 01:04:30,900
Miss the cash every frame and that would probably be sufficient to

1221
01:04:30,900 --> 01:04:32,600
make the ground buffers a little more usable.

1222
01:04:34,200 --> 01:04:36,800
But you can see, it's still every time it has to fill that cash.

1223
01:04:36,800 --> 01:04:38,400
You get that hiccup, right?

1224
01:04:39,900 --> 01:04:42,900
So we've got we've got work to do before.

1225
01:04:42,900 --> 01:04:47,300
We can really put the ground chunks in as I guess what I would say and

1226
01:04:47,300 --> 01:04:50,200
we have, you know, we've got a bunch of stuff to do here, you know,

1227
01:04:50,200 --> 01:04:52,700
like you've got to get rid of that blinking and so on, we've got, we

1228
01:04:52,700 --> 01:04:53,900
got a ton of stuff, we got to do.

1229
01:04:54,600 --> 01:04:55,600
So we'll get to the ground chuck.

1230
01:04:55,800 --> 01:04:59,400
I stood enough but that's why I did not have them in there.

1231
01:04:59,400 --> 01:05:00,300
Temporarily

1232
01:05:15,700 --> 01:05:19,400
Is it me or after this wholesome deconversion the cycles per pixel.

1233
01:05:19,400 --> 01:05:21,400
Pixel are much more consistent.

1234
01:05:27,100 --> 01:05:30,400
To be honest, I don't know if it's possible but I don't know.

1235
01:05:44,300 --> 01:05:45,800
I have kind of missed the past few days.

1236
01:05:45,800 --> 01:05:49,100
I'm wondering if doing CPU intrinsics, like exclusively for sse2 and

1237
01:05:49,100 --> 01:05:50,200
your game code is bad.

1238
01:05:50,200 --> 01:05:52,100
Or are we targeting sse2?

1239
01:05:52,400 --> 01:05:53,100
For example?

1240
01:05:53,100 --> 01:05:55,100
Shouldn't we wrap everything into platform, static file.

1241
01:05:55,100 --> 01:05:58,300
So it's easy to flag other Target platforms to compile.

1242
01:05:58,600 --> 01:05:59,000
Well,

1243
01:06:00,700 --> 01:06:01,600
So yes and no.

1244
01:06:02,000 --> 01:06:04,800
First of all at this point.

1245
01:06:04,900 --> 01:06:08,400
No, you definitely don't want to do that because nobody on this stream

1246
01:06:08,400 --> 01:06:09,900
besides me, potentially.

1247
01:06:09,900 --> 01:06:13,200
Well I mean there's other people on stream who are more, who it are

1248
01:06:13,200 --> 01:06:15,800
watching the stream more for entertainment purposes but people who are

1249
01:06:15,800 --> 01:06:18,100
learning from the stream of never programmed as a sea before.

1250
01:06:18,600 --> 01:06:21,500
So it would be massively putting the cart before the horse to try to

1251
01:06:21,500 --> 01:06:26,700
design an abstraction layer for your, for wide operation stuff before

1252
01:06:26,700 --> 01:06:29,500
you even ever optimize the routine, right?

1253
01:06:30,500 --> 01:06:34,400
And even so I typically always write the routine, the first time

1254
01:06:34,600 --> 01:06:37,300
directly in whatever the platform is that I'm working on.

1255
01:06:37,400 --> 01:06:40,100
And then I worry about pouring it over right.

1256
01:06:40,300 --> 01:06:43,500
It's a really bad idea to Target things ahead of time.

1257
01:06:45,300 --> 01:06:49,300
If you don't have some specific reason to do so or if you don't know

1258
01:06:49,300 --> 01:06:51,700
exactly how you want to do it, right?

1259
01:06:52,200 --> 01:06:55,100
Because then you know you don't really gain anything by doing that.

1260
01:06:55,200 --> 01:06:58,500
We know that this is the code that we now want, and we could easily

1261
01:06:58,500 --> 01:06:59,900
abstract it by just replacing

1262
01:07:00,000 --> 01:07:04,100
The intrinsics by macros that will compile to other intrinsics on me

1263
01:07:04,100 --> 01:07:05,100
on say, right?

1264
01:07:05,200 --> 01:07:09,000
So there really isn't anything to be gained by pre abstracting.

1265
01:07:09,000 --> 01:07:15,100
It that said will be have to do some platform work on this later.

1266
01:07:19,300 --> 01:07:20,800
Honestly, my gut feeling is no.

1267
01:07:21,500 --> 01:07:24,300
I don't think we'll ever run this on anything other than SSE.

1268
01:07:24,500 --> 01:07:28,600
The reason that I say that is because on the only platforms that we

1269
01:07:28,600 --> 01:07:30,000
might Target for neon,

1270
01:07:32,500 --> 01:07:34,900
The renderer is not gonna be running in software, like we're not going

1271
01:07:34,900 --> 01:07:37,700
to run a software renderer on an iPhone or something, right?

1272
01:07:38,100 --> 01:07:40,600
We're not going to run a software under on an Android phone.

1273
01:07:41,100 --> 01:07:43,300
We're certainly not going to run a software renderer on the Raspberry

1274
01:07:43,300 --> 01:07:44,700
Pi, right?

1275
01:07:45,700 --> 01:07:50,900
So this sse2 stuff is more for our edification to see how you do code

1276
01:07:50,900 --> 01:07:52,900
optimization for a thing like a software renderer.

1277
01:07:54,200 --> 01:07:58,400
And it's so that we have a complete view of the entire pipeline of

1278
01:07:58,400 --> 01:07:59,400
what renders the game.

1279
01:08:00,100 --> 01:08:00,800
But in

1280
01:08:01,000 --> 01:08:01,500
He will.

1281
01:08:01,500 --> 01:08:05,200
This code ever be ported to platforms, other than sse2, probably not.

1282
01:08:05,700 --> 01:08:09,900
We might do other sse2 optimizations elsewhere in the game that will

1283
01:08:09,900 --> 01:08:12,700
have to run a multiple platforms because you know for the physics or

1284
01:08:12,700 --> 01:08:15,700
something maybe but for the renderer probably not.

1285
01:08:35,200 --> 01:08:38,300
What does it mean for intrinsics that don't have a specified

1286
01:08:38,300 --> 01:08:39,000
throughput?

1287
01:08:39,700 --> 01:08:40,700
I it depends.

1288
01:08:40,700 --> 01:08:42,300
Which intrinsic are you referring to?

1289
01:08:51,600 --> 01:08:55,000
Instead of loading the destination first, would it be faster to skip

1290
01:08:55,000 --> 01:08:55,500
that step?

1291
01:08:55,500 --> 01:08:57,200
And instead do a mast, right?

1292
01:08:57,300 --> 01:08:59,800
Egm mask, move si64.

1293
01:09:01,500 --> 01:09:02,000
Well.

1294
01:09:03,899 --> 01:09:10,200
The only way to answer a question like that is to try it, usually, so

1295
01:09:10,200 --> 01:09:14,399
if you want to try a mass move, we can certainly try it.

1296
01:09:14,399 --> 01:09:17,200
So, here's the mass move conditionally store, 8-bit integer, Ellen

1297
01:09:17,300 --> 01:09:21,399
elements from a into memory using masks elements or not story when the

1298
01:09:21,399 --> 01:09:24,600
highest bit is set to the corresponding and a non temporal memory

1299
01:09:24,600 --> 01:09:24,899
hint.

1300
01:09:25,100 --> 01:09:26,399
So I don't know, we

1301
01:09:30,200 --> 01:09:32,399
You know, it's kind of interesting that this is mass moved.

1302
01:09:32,399 --> 01:09:33,200
So, it's interesting.

1303
01:09:33,200 --> 01:09:36,800
I guess there's no penalty for unaligned if you do a mass move, so,

1304
01:09:36,800 --> 01:09:39,600
all right, if we switch to a line we wouldn't be able to use this.

1305
01:09:39,600 --> 01:09:41,399
But for the moment we're doing a line anyway.

1306
01:09:41,399 --> 01:09:43,200
So yes, we could certainly try that.

1307
01:09:45,000 --> 01:09:46,200
Here's what that would look like.

1308
01:09:53,500 --> 01:10:05,000
So that's a mask review si128 and that is the out parameter, the right

1309
01:10:05,000 --> 01:10:11,300
mask parameter and the address to, which we are writing, right?

1310
01:10:11,900 --> 01:10:13,500
And it wants that as a care star.

1311
01:10:15,500 --> 01:10:16,900
So there is that mask move?

1312
01:10:17,400 --> 01:10:19,300
So let's take a look and see if it helps us

1313
01:10:22,600 --> 01:10:25,300
Here is our game running right now.

1314
01:10:25,300 --> 01:10:31,300
It seems to Min out at 55 cycles per pixel at the moment, right?

1315
01:10:32,200 --> 01:10:35,500
And then if we go in here and we switch to using the mask move,

1316
01:10:38,900 --> 01:10:40,700
And we take a look at what happens.

1317
01:10:42,700 --> 01:10:43,200
Well.

1318
01:10:45,700 --> 01:10:46,700
That certainly doesn't look very good.

1319
01:10:46,700 --> 01:10:47,300
Does it?

1320
01:10:49,300 --> 01:10:52,300
It is three times slower to use the mask move.

1321
01:10:54,200 --> 01:10:58,000
To be honest with you, I don't know why it's three times slower to use

1322
01:10:58,000 --> 01:10:58,800
the mask move.

1323
01:11:00,400 --> 01:11:03,100
But it currently is three times slower to use the mass move.

1324
01:11:05,000 --> 01:11:11,800
So, yeah, again that maybe a exercise left for when Fabi and does some

1325
01:11:11,800 --> 01:11:16,900
streams for educational purposes, because I don't know why that's

1326
01:11:16,900 --> 01:11:17,300
lower.

1327
01:11:20,200 --> 01:11:25,600
But at least turning it on in this simple case that was definitely bad

1328
01:11:25,600 --> 01:11:32,100
because if we just don't do the mass move, its way, way way, way

1329
01:11:32,100 --> 01:11:33,800
faster, three times faster.

1330
01:11:33,800 --> 01:11:34,400
In fact,

1331
01:11:42,100 --> 01:11:42,700
How are you doing?

1332
01:11:42,700 --> 01:11:43,600
Got other questions?

1333
01:11:56,700 --> 01:11:59,800
Would it be a good idea to just simply for all?

1334
01:12:00,000 --> 01:12:02,400
Math operations, in all our programs.

1335
01:12:03,700 --> 01:12:04,900
Well, yes, and no.

1336
01:12:05,000 --> 01:12:10,300
So Cindy is only useful if you happen to be able to do four things at

1337
01:12:10,300 --> 01:12:12,000
once, right?

1338
01:12:12,400 --> 01:12:18,100
So it's worth noting that when the when you're doing regular math,

1339
01:12:18,400 --> 01:12:21,100
like when we do stuff like, you know, this

1340
01:12:23,300 --> 01:12:28,700
This operation is done in the CMD set, right?

1341
01:12:28,800 --> 01:12:32,600
So if you take a look at what this actually does, if I go to this

1342
01:12:32,600 --> 01:12:34,300
assembly, right?

1343
01:12:37,100 --> 01:12:37,400
You can.

1344
01:12:37,400 --> 01:12:42,300
And I suppose I should probably turn it so we can actually see see

1345
01:12:42,300 --> 01:12:44,800
here, turn it to debug mode.

1346
01:12:50,900 --> 01:12:54,400
So when I compile and debug mode here, let's come in here.

1347
01:12:54,400 --> 01:12:57,800
And we're going to do this this compilation.

1348
01:13:00,800 --> 01:13:01,600
So, here we are.

1349
01:13:03,300 --> 01:13:04,300
In the disassembly.

1350
01:13:07,500 --> 01:13:14,500
Yeah, so if we go ahead and we do all this, this nonsense right load

1351
01:13:14,500 --> 01:13:18,200
things in of a Cess.

1352
01:13:24,800 --> 01:13:27,400
All right, I take it back.

1353
01:13:27,400 --> 01:13:34,200
I was going to say we should be able to see it do, but it's calling

1354
01:13:34,200 --> 01:13:34,800
up.

1355
01:13:34,800 --> 01:13:35,200
Oh, okay.

1356
01:13:35,200 --> 01:13:37,100
We're it's still actually doing the call.

1357
01:13:37,100 --> 01:13:38,500
That's why I was confused.

1358
01:13:38,500 --> 01:13:41,200
I'm like, where to do but it didn't in line it.

1359
01:13:41,200 --> 01:13:41,900
So that's fine.

1360
01:13:42,800 --> 01:13:43,700
That's all fine.

1361
01:13:46,600 --> 01:13:48,900
Try again, Visual Studio try again.

1362
01:13:51,000 --> 01:13:53,300
So this is actually where we want to be sorry about that.

1363
01:13:54,100 --> 01:13:55,400
This is what I wanted to show you.

1364
01:13:57,400 --> 01:13:59,600
So, if you look at what happens here, right?

1365
01:14:01,100 --> 01:14:05,800
It's actually using those same D registers to do all the operations.

1366
01:14:05,900 --> 01:14:09,300
Right is still doing everything in the exact same way.

1367
01:14:09,300 --> 01:14:11,200
It was doing it before, right?

1368
01:14:11,700 --> 01:14:16,800
The only difference is that instead of, you know, it'll, it'll do like

1369
01:14:16,800 --> 01:14:18,400
this mob to XM M 0.

1370
01:14:18,700 --> 01:14:21,300
It's going to put it in the x10 register and then instead of doing a

1371
01:14:21,300 --> 01:14:24,800
multi multiplication of the pack singles, it just does a

1372
01:14:24,800 --> 01:14:28,600
multiplication of just the first Lane, right?

1373
01:14:28,700 --> 01:14:30,800
So you're still, it's still, it's using the same.

1374
01:14:30,900 --> 01:14:32,300
It's doing essentially the same thing.

1375
01:14:32,300 --> 01:14:35,400
The only difference is is not doing it for wide, right?

1376
01:14:35,500 --> 01:14:38,800
It's still, it's still all exactly the same stuff, it's just not for

1377
01:14:38,800 --> 01:14:40,200
wide, okay?

1378
01:14:41,200 --> 01:14:45,500
And so the important thing to understand there is the only way that

1379
01:14:45,500 --> 01:14:48,900
you get a win from switching to the compiler.

1380
01:14:48,900 --> 01:14:53,100
Intrinsics in terms of the width is if you can actually do four things

1381
01:14:53,100 --> 01:14:57,400
at once all the time and a lot of times it's not the case.

1382
01:14:57,400 --> 01:14:59,800
A lot of times you don't have it set up to do it that way.

1383
01:15:00,300 --> 01:15:01,100
Right?

1384
01:15:02,000 --> 01:15:03,300
So that's one thing.

1385
01:15:05,200 --> 01:15:08,200
The other thing is that it may not be worth it to figure out how to do

1386
01:15:08,200 --> 01:15:12,700
the same D properly everywhere, it may be too much work, right?

1387
01:15:12,700 --> 01:15:16,600
And it may be that the speed wind that you would get out of it is is

1388
01:15:16,600 --> 01:15:17,800
very limited, right?

1389
01:15:18,000 --> 01:15:20,200
So you also want to be able to Target pieces of your code that where

1390
01:15:20,200 --> 01:15:22,600
you think you're actually going to be able to get a performance

1391
01:15:22,600 --> 01:15:26,800
increase by forcing, all of the data to work in a 4 wide fashion

1392
01:15:26,800 --> 01:15:28,000
because it's not free, right?

1393
01:15:28,000 --> 01:15:29,400
You've got you got to do.

1394
01:15:29,400 --> 01:15:29,900
You got to do?

1395
01:15:30,100 --> 01:15:32,700
To put it in and out of that format and all sorts of things like that.

1396
01:15:36,200 --> 01:15:38,100
Example of an intrinsic with no throughput.

1397
01:15:38,100 --> 01:15:40,400
MM, cop gtps.

1398
01:15:42,400 --> 01:15:45,100
I have a guess as to why that probably is, but let's find out.

1399
01:15:57,400 --> 01:15:58,300
Interesting.

1400
01:16:00,200 --> 01:16:00,800
Well.

1401
01:16:05,400 --> 01:16:06,600
Well, you know what?

1402
01:16:07,300 --> 01:16:07,900
I don't know.

1403
01:16:08,100 --> 01:16:08,800
Let's see.

1404
01:16:11,000 --> 01:16:12,500
Let's take a little closer look.

1405
01:16:17,900 --> 01:16:19,900
So, here we are in the Intel architecture guide.

1406
01:16:22,800 --> 01:16:27,500
And we'll take a look at the compiler intrinsics the actual

1407
01:16:27,500 --> 01:16:30,200
instruction set documentation for those intrinsic.

1408
01:16:30,200 --> 01:16:31,100
So here we are.

1409
01:16:31,900 --> 01:16:33,900
Compared packed single integers for greater than

1410
01:16:36,300 --> 01:16:39,600
And let's take a look and see if it's got any information about it in

1411
01:16:39,600 --> 01:16:39,900
here.

1412
01:16:39,900 --> 01:16:42,400
That would help us understand what's going on.

1413
01:16:42,400 --> 01:16:47,100
I don't know they will but we can at least take a quick check.

1414
01:16:47,400 --> 01:16:48,100
Let's see.

1415
01:16:54,800 --> 01:16:57,600
Forms a 70, sunk a for greater value.

1416
01:16:57,600 --> 01:17:04,900
W is still in the source up rinkeby Ms.

1417
01:17:04,900 --> 01:17:07,300
Yes they see Second Source operating.

1418
01:17:07,300 --> 01:17:11,000
Okay 0 strategy will you d?

1419
01:17:13,000 --> 01:17:17,800
So I don't see anything particularly noteworthy here.

1420
01:17:19,400 --> 01:17:20,300
So, I don't know.

1421
01:17:25,600 --> 01:17:27,600
I do not know why that is the case.

1422
01:17:28,100 --> 01:17:29,200
So what we could do

1423
01:17:37,500 --> 01:17:39,700
well that's signed integers as well.

1424
01:17:40,100 --> 01:17:42,700
I feel like that was the wrong one there.

1425
01:17:43,200 --> 01:17:44,500
Cop gtps.

1426
01:17:44,500 --> 01:17:46,900
Let's just make sure we get the right one there.

1427
01:17:50,000 --> 01:17:56,600
So, it's comp PS is what's actually being called C mpps.

1428
01:18:03,900 --> 01:18:04,400
Okay.

1429
01:18:10,800 --> 01:18:13,400
Compare pack single Precision floating Point values.

1430
01:18:14,000 --> 01:18:19,100
This is the actual operation for the one that you just asked about.

1431
01:18:20,200 --> 01:18:21,600
Let's see.

1432
01:18:34,600 --> 01:18:35,700
So, I do Wonder.

1433
01:18:36,900 --> 01:18:38,400
A little bit about this.

1434
01:18:40,800 --> 01:18:41,000
Note.

1435
01:18:41,000 --> 01:18:42,100
The processor is with CPR.

1436
01:18:42,100 --> 01:18:46,500
Do 1 H EC X AV x equals 0 to not implement the greater than greater

1437
01:18:46,500 --> 01:18:49,900
than or equal to naught greater than or not going to lations these

1438
01:18:49,900 --> 01:18:53,200
comparison can be made either by using an inverse relationship, using

1439
01:18:53,200 --> 01:18:57,100
not less than or equal to to make a greater than or by using software

1440
01:18:57,100 --> 01:19:00,000
emulation when using cell from which the premise swap, the operands

1441
01:19:00,200 --> 01:19:02,900
copywriters, administrative protect the data, that will now be in the

1442
01:19:02,900 --> 01:19:06,400
destination, and then perform the compare using different predicate.

1443
01:19:23,900 --> 01:19:25,200
So, I'm not sure.

1444
01:19:31,400 --> 01:19:32,400
I'm not sure.

1445
01:19:35,200 --> 01:19:41,300
So let's take a look at what comp PS throughput says here.

1446
01:19:44,600 --> 01:19:45,300
Let's take a look.

1447
01:19:51,000 --> 01:19:52,300
so, it looks like

1448
01:19:53,800 --> 01:20:00,700
It at least looks like documentation wise here that the throughput is.

1449
01:20:01,800 --> 01:20:05,400
Is 24 comp PS?

1450
01:20:06,100 --> 01:20:09,500
Actually assuming that I'm reading this right here.

1451
01:20:10,500 --> 01:20:14,700
Let me see if anyone else has a particular.

1452
01:20:16,200 --> 01:20:17,700
I know if anyone else has

1453
01:20:19,100 --> 01:20:20,300
something we want to look at there.

1454
01:20:21,800 --> 01:20:24,300
So I don't know why it's listed that way in here, to be honest with

1455
01:20:24,300 --> 01:20:28,000
you, I'm not sure it looks like the answer might actually more

1456
01:20:28,000 --> 01:20:31,600
correctly, be too, but somebody more familiar at this would have to

1457
01:20:31,600 --> 01:20:33,400
answer that because I don't see an obvious answer.

1458
01:21:00,900 --> 01:21:01,900
And grumpy giant post.

1459
01:21:01,900 --> 01:21:05,700
That agner fog says, the throughput is one, which also seems like a

1460
01:21:05,700 --> 01:21:07,700
pretty reasonable thing that would be true.

1461
01:21:07,700 --> 01:21:08,900
So I don't know.

1462
01:21:10,500 --> 01:21:13,400
It might be because of the fact that it's not sure.

1463
01:21:19,100 --> 01:21:22,200
But it's, I mean, it's even listing comp PS as the instruction here.

1464
01:21:22,200 --> 01:21:23,000
So I don't know.

1465
01:21:23,700 --> 01:21:24,300
I don't know why.

1466
01:21:24,300 --> 01:21:27,500
It thinks the throughput is Dash.

1467
01:21:29,900 --> 01:21:32,000
It would be nice if someone from Intel would tell us.

1468
01:21:32,000 --> 01:21:35,600
Maybe I'll try to ask someone and be like, why is it's a dash here?

1469
01:21:43,700 --> 01:21:44,500
Anyone else?

1470
01:22:00,600 --> 01:22:01,100
No.

1471
01:22:03,800 --> 01:22:05,900
Alright, I guess we have come to the end.

1472
01:22:17,000 --> 01:22:17,400
And mr.

1473
01:22:17,400 --> 01:22:18,600
Stone 56.

1474
01:22:20,900 --> 01:22:21,500
Yes, it is.

1475
01:22:21,500 --> 01:22:24,600
The amount latency is the total amount of time.

1476
01:22:24,600 --> 01:22:28,300
It takes from start to finish for any given issues of that

1477
01:22:28,300 --> 01:22:29,000
instruction.

1478
01:22:30,800 --> 01:22:35,000
Whereas throughput is, if you issue them back to back, that's how many

1479
01:22:35,000 --> 01:22:37,300
you can eventually get due to the overlap.

1480
01:22:45,100 --> 01:22:45,800
The marsala.

1481
01:22:45,800 --> 01:22:48,700
What is the end goal of the optimization trying to get below a certain

1482
01:22:48,700 --> 01:22:51,000
threshold or just getting everything converted?

1483
01:22:51,500 --> 01:22:52,100
The end goal.

1484
01:22:52,100 --> 01:22:54,800
The optimization is actually for us to go ahead.

1485
01:22:55,100 --> 01:22:56,400
We haven't done this yet.

1486
01:22:56,400 --> 01:23:00,900
We have probably will be able to do it tomorrow I think, but we're

1487
01:23:00,900 --> 01:23:05,400
trying to basically have everything converted so that we can get an

1488
01:23:05,400 --> 01:23:07,700
estimate of how many cycles per pixel.

1489
01:23:07,700 --> 01:23:09,500
We think we should be able to get it too.

1490
01:23:10,900 --> 01:23:18,000
And then once we know that number, we will see how close we can get to

1491
01:23:18,000 --> 01:23:19,400
whatever that theoretical number is.

1492
01:23:46,300 --> 01:23:47,100
Anyone else?

1493
01:23:48,700 --> 01:23:49,500
We all good.

1494
01:23:56,300 --> 01:23:59,800
Does size of variables and stuff matter to Cindy like 30.

1495
01:24:00,000 --> 01:24:01,600
It versus 64-bit.

1496
01:24:02,500 --> 01:24:05,900
Yes, the size absolutely does matter and the reason it matters is

1497
01:24:05,900 --> 01:24:08,800
because it determines how many of them you can fit inside a single

1498
01:24:08,800 --> 01:24:09,500
operation.

1499
01:24:10,100 --> 01:24:18,000
So Cindy registers in SSE are 128 bits in AVX, their 256 bits.

1500
01:24:18,700 --> 01:24:21,200
And in avx-512 there 512 bits

1501
01:24:22,400 --> 01:24:25,000
What that means is the maximum number.

1502
01:24:26,300 --> 01:24:29,900
Of things you can fit into a single register which is how many you can

1503
01:24:29,900 --> 01:24:33,900
operate on at once, is that number of B divided by the size of the

1504
01:24:33,900 --> 01:24:34,800
data type.

1505
01:24:35,100 --> 01:24:39,000
So if you are doing 32-bit values, you can operate on four of them and

1506
01:24:39,000 --> 01:24:45,600
SSE, eight of them in a VX and 16 of them in avx-512, right?

1507
01:24:45,900 --> 01:24:48,900
If on the other hand, you wanted to operate on 64-bit values,

1508
01:24:49,900 --> 01:24:52,600
You would only be able to fit two of them at a time through the

1509
01:24:52,600 --> 01:24:53,800
pipeline in SSE.

1510
01:24:55,000 --> 01:25:01,300
Four of them at a time in AV x, + 8 of them at a time in avx-512, in

1511
01:25:01,300 --> 01:25:02,300
addition to that.

1512
01:25:03,400 --> 01:25:07,900
Some operations may be more costly in 64-bit than they are in 32-bit.

1513
01:25:08,100 --> 01:25:12,400
So when you look up one of the operations, you may find that doing,

1514
01:25:12,400 --> 01:25:16,400
for example, a divided and 64-bit is more expensive than doing a

1515
01:25:16,400 --> 01:25:17,700
divide in 32-bit.

1516
01:25:18,300 --> 01:25:22,500
So in some cases you may be you may get hit twice, it may both be

1517
01:25:22,500 --> 01:25:24,600
operating on less and it may be

1518
01:25:24,800 --> 01:25:25,100
Lower.

1519
01:25:26,500 --> 01:25:30,200
So it does matter quite a bit and typically what you want to do is you

1520
01:25:30,200 --> 01:25:34,300
want to use the smallest size variables that you can to still do the

1521
01:25:34,300 --> 01:25:36,100
operations that you need to do.

1522
01:25:38,700 --> 01:25:39,400
That makes sense.

1523
01:25:44,700 --> 01:25:46,100
It's the SS C code.

1524
01:25:46,100 --> 01:25:48,500
Doing any cash prefetch or hinting stuff yet?

1525
01:25:48,500 --> 01:25:48,900
No.

1526
01:25:49,700 --> 01:25:51,500
In fact we are not even aligned yet.

1527
01:25:52,000 --> 01:25:53,700
We have not gotten to the memory part of things.

1528
01:25:53,700 --> 01:25:58,000
Yet we just did our translation of the routine into Cindy directly and

1529
01:25:58,000 --> 01:26:00,000
we haven't done any other work at all.

1530
01:26:00,800 --> 01:26:03,000
So there's no pre-caching there's no alignment.

1531
01:26:06,100 --> 01:26:08,800
I think if there's anything else there's no non-temporal stores,

1532
01:26:08,800 --> 01:26:11,200
although in this case, I don't think we would want those.

1533
01:26:11,900 --> 01:26:16,000
So there's very little besides just the root transformation.

1534
01:26:17,000 --> 01:26:19,000
I'm not sure how much we're going to get out of that.

1535
01:26:20,700 --> 01:26:22,000
Prefetch might get us something.

1536
01:26:22,000 --> 01:26:22,300
I don't know.

1537
01:26:22,300 --> 01:26:26,100
We're going to have to find out, but it's hard to say, Obviously,

1538
01:26:26,100 --> 01:26:27,100
until you test it.

1539
01:26:27,900 --> 01:26:30,900
It's kind of running surprisingly fast at the moment.

1540
01:26:31,400 --> 01:26:33,500
It's down to like 50 cycles per pixel.

1541
01:26:35,300 --> 01:26:38,900
That means the total routine is running at something like 200 Cycles.

1542
01:26:40,000 --> 01:26:45,600
So you know a 200 cycle Loop doesn't have a huge amount there.

1543
01:26:45,700 --> 01:26:49,200
There can't be that many memory stalls in a 200 cycle Loop.

1544
01:26:49,300 --> 01:26:49,800
Right?

1545
01:26:51,100 --> 01:26:55,500
So unfortunately I don't know that we're going to get a huge amount of

1546
01:26:55,500 --> 01:26:59,800
wind from prefetching but you know if we're lucky

1547
01:27:00,000 --> 01:27:04,200
Some of that 200 Cycles is sitting around waiting for something that

1548
01:27:04,200 --> 01:27:05,200
could be prefetched.

1549
01:27:05,900 --> 01:27:07,100
I don't know if it will be or not.

1550
01:27:07,200 --> 01:27:08,000
We'll just have to see.

1551
01:27:12,100 --> 01:27:15,900
Couldn't we use a half float instead of floats, as we don't need that

1552
01:27:15,900 --> 01:27:18,400
much of precision with only two and five discrete values.

1553
01:27:20,000 --> 01:27:26,300
We cannot use half float because the SSC operations do not support

1554
01:27:26,300 --> 01:27:27,000
half float.

1555
01:27:28,000 --> 01:27:33,800
SSE 2 does not have multiplication etc for half with floats so we

1556
01:27:33,800 --> 01:27:35,800
can't use them at the moment.

1557
01:27:36,700 --> 01:27:40,800
We could try to implement half float, ourselves ourselves but my would

1558
01:27:40,800 --> 01:27:43,800
suspect that that would actually be much more costly than if we just

1559
01:27:43,800 --> 01:27:45,500
use 16-bit fixed point.

1560
01:27:45,500 --> 01:27:49,400
So if we were going to do that, we would probably try try to do 16-bit

1561
01:27:49,400 --> 01:27:53,700
fixed Point instead because 16-bit fixed point would be way easier to

1562
01:27:53,700 --> 01:27:54,900
implement than

1563
01:27:56,400 --> 01:27:57,400
32-bit float.

1564
01:27:58,600 --> 01:28:02,800
Now, whether 16-bit fixed point would be faster or not.

1565
01:28:02,800 --> 01:28:06,400
It's hard to say, it's might be something that we might want to try

1566
01:28:06,400 --> 01:28:07,000
doing.

1567
01:28:07,300 --> 01:28:10,100
It's something that I kind of had the back of my mind.

1568
01:28:11,400 --> 01:28:16,000
If you look at how this routine ended up, there aren't that many math

1569
01:28:16,000 --> 01:28:16,900
operations.

1570
01:28:18,000 --> 01:28:23,200
So it's possible that maybe we could get a win there by being creative

1571
01:28:23,200 --> 01:28:24,400
about how we did stuff.

1572
01:28:25,300 --> 01:28:26,000
I don't know.

1573
01:28:28,800 --> 01:28:30,700
It's it's, it's hard to say.

1574
01:28:31,400 --> 01:28:34,600
I suspect that it would be a bit of a battle but, you know, if we

1575
01:28:34,600 --> 01:28:38,400
could keep it similar to the number, the same number of operations

1576
01:28:38,400 --> 01:28:41,800
somehow but be able to go down to 16 bit.

1577
01:28:41,800 --> 01:28:44,500
That would that would double the amount of pixels we can do at a time

1578
01:28:44,500 --> 01:28:45,900
and that would be pretty awesome, right?

1579
01:28:46,400 --> 01:28:46,900
So,

1580
01:28:48,600 --> 01:28:49,300
There's that.

1581
01:28:55,300 --> 01:28:57,900
Use the normal map code going to be converted to Cindy.

1582
01:28:58,500 --> 01:28:59,600
Yes, eventually.

1583
01:28:59,600 --> 01:29:03,800
I think we will try to convert the normal map code to Cindy once we

1584
01:29:03,800 --> 01:29:06,300
actually figure out how it should work, exactly?

1585
01:29:06,600 --> 01:29:07,100
Right.

1586
01:29:23,900 --> 01:29:24,400
Anyone.

1587
01:29:26,300 --> 01:29:27,800
All right, I think we are done.

1588
01:29:27,800 --> 01:29:30,700
I think we have come to the end of the stream.

1589
01:29:31,800 --> 01:29:36,100
So let's go ahead and wrap things up.

1590
01:29:45,000 --> 01:29:49,000
Okay, thank you, everyone for joining me for another episode of

1591
01:29:49,000 --> 01:29:49,700
handmade hero.

1592
01:29:49,700 --> 01:29:55,200
It's been a pleasure coding with you, as always, it was kind of fun to

1593
01:29:55,200 --> 01:29:59,500
get to the end of the Cindy translation stuff today will sort of look

1594
01:29:59,500 --> 01:29:59,800
at things.

1595
01:30:00,000 --> 01:30:03,400
A little bit outside of that tomorrow, but it's pretty cool.

1596
01:30:03,600 --> 01:30:05,700
We've come a long way, right?

1597
01:30:07,000 --> 01:30:10,800
When we started this, our game was running so slowly that you could

1598
01:30:10,800 --> 01:30:12,400
barely move the character on the screen at all.

1599
01:30:12,400 --> 01:30:17,700
And now we are totally running like 30 frames/second, no problems, so

1600
01:30:17,700 --> 01:30:21,400
optimization for the win and we haven't really even hit it with all

1601
01:30:21,400 --> 01:30:22,700
that much of an optimization Hammer yet.

1602
01:30:22,700 --> 01:30:27,000
All we did was take advantage of the processors ability to do for wide

1603
01:30:27,000 --> 01:30:29,800
pixel operations, and that was enough.

1604
01:30:31,200 --> 01:30:34,000
For us to, to get a pretty massive speed win.

1605
01:30:34,000 --> 01:30:36,800
So I hope you've enjoyed that and we've got some more good stuff

1606
01:30:36,800 --> 01:30:37,100
coming.

1607
01:30:37,100 --> 01:30:40,300
In terms of optimization that will be doing pretty soon.

1608
01:30:40,300 --> 01:30:44,400
Here, we'll do some more tomorrow and certainly, you know, throughout

1609
01:30:44,400 --> 01:30:46,900
the week and then we also have, you know, multi-threading, which is on

1610
01:30:46,900 --> 01:30:49,000
the horizon because multi-threading the render is also something we

1611
01:30:49,000 --> 01:30:49,600
can do.

1612
01:30:49,700 --> 01:30:52,600
That's not particularly difficult that get will get us a significant

1613
01:30:52,600 --> 01:30:55,700
speed Improvement because you know pretty much all machines.

1614
01:30:55,700 --> 01:30:59,500
These days have between four and eight threads, you can take advantage

1615
01:30:59,500 --> 01:31:00,600
of that actually do accelerate.

1616
01:31:00,700 --> 01:31:01,800
Hardware by using them.

1617
01:31:02,300 --> 01:31:05,500
And so that's something that we probably want to take a look at as

1618
01:31:05,500 --> 01:31:05,700
well.

1619
01:31:05,700 --> 01:31:07,200
So we'll maybe take a look at that.

1620
01:31:08,000 --> 01:31:09,500
So just a bunch of good stuff coming up.

1621
01:31:09,500 --> 01:31:11,600
Hope you'll tune in for that again.

1622
01:31:12,200 --> 01:31:13,500
Tomorrow, 5:00 p.m.

1623
01:31:13,500 --> 01:31:13,900
Pacific.

1624
01:31:13,900 --> 01:31:17,100
Daylight time is when we will be live if you'd like to catch the next

1625
01:31:17,100 --> 01:31:17,600
stream.

1626
01:31:18,800 --> 01:31:21,000
In the meantime, if you like to play around with source code at home,

1627
01:31:21,200 --> 01:31:23,900
you can always pre-order the game on handmade hero dot org and it

1628
01:31:23,900 --> 01:31:26,200
comes with the full source code so that you can play around with it at

1629
01:31:26,200 --> 01:31:28,800
home and do your own experiments play around with optimization.

1630
01:31:29,200 --> 01:31:30,500
It's a good way to learn from the stream.

1631
01:31:31,100 --> 01:31:35,100
We also have a forum that you can go to which is a place to ask

1632
01:31:35,100 --> 01:31:35,600
questions.

1633
01:31:35,600 --> 01:31:38,800
You can also look at ports, the community's done to like mac and Linux

1634
01:31:38,800 --> 01:31:39,400
that sort of stuff.

1635
01:31:39,400 --> 01:31:41,700
There's an annotated episode guide, things like that.

1636
01:31:42,300 --> 01:31:44,300
We also have a tweetbot, the tweets, the schedule it you.

1637
01:31:44,300 --> 01:31:45,600
So if you want to

1638
01:31:48,300 --> 01:31:52,500
Be kept up to date when the the next live stream is that's an error

1639
01:31:52,700 --> 01:31:54,000
and what the whole schedule for the week going to be?

1640
01:31:54,000 --> 01:31:55,400
In fact, that's a great place to do that.

1641
01:31:55,400 --> 01:31:58,800
You can subscribe to that Twitter feed and it will tell you so that's

1642
01:31:58,800 --> 01:31:59,500
about it.

1643
01:31:59,800 --> 01:32:01,500
I hope to see you all back here, tomorrow.

1644
01:32:01,600 --> 01:32:02,100
5:00 p.m.

1645
01:32:02,100 --> 01:32:03,200
same time, same place.

1646
01:32:03,600 --> 01:32:09,100
Until then, please have a fun coating evening and I will catch you

1647
01:32:09,100 --> 01:32:09,800
guys tomorrow.

1648
01:32:10,100 --> 01:32:10,700
All right, take it.

1649
01:32:10,700 --> 01:32:11,400
Easy, everyone.

