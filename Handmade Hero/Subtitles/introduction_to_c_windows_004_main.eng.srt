1
00:00:00,000 --> 00:00:01,100
Do you are intro to see?

2
00:00:03,400 --> 00:00:03,800
Okay.

3
00:00:03,800 --> 00:00:08,300
Hello everyone and welcome to the fourth day of the test stream here

4
00:00:08,300 --> 00:00:12,000
where we're doing a little introduction to see yesterday.

5
00:00:12,500 --> 00:00:14,200
We got to do some fun stuff.

6
00:00:14,200 --> 00:00:19,400
We sort of started to really see how the code and the memory actually

7
00:00:19,400 --> 00:00:23,400
works together and we sort of did some some we played around a little

8
00:00:23,400 --> 00:00:25,800
bit sort of showing where things are stored in the computer.

9
00:00:25,800 --> 00:00:28,800
We did a bunch of things that I kind of been, you know, hoping to get

10
00:00:28,800 --> 00:00:30,900
two in the first two streams.

11
00:00:30,900 --> 00:00:33,000
I was kind of like building up to them and

12
00:00:33,200 --> 00:00:34,600
Tonight's stream was pretty good.

13
00:00:34,600 --> 00:00:34,900
That way.

14
00:00:34,900 --> 00:00:36,300
I got to tie a lot of things together.

15
00:00:36,300 --> 00:00:37,200
So it's pretty excited.

16
00:00:37,200 --> 00:00:38,600
There was one snafu.

17
00:00:40,700 --> 00:00:43,500
In the Stream and I will correct it.

18
00:00:43,500 --> 00:00:47,500
Now, if you're there for the Q&A, then you already know what it is.

19
00:00:47,500 --> 00:00:48,300
I'm talking about.

20
00:00:48,300 --> 00:00:54,000
But what I tried to do yesterday, I wanted to show you because the,

21
00:00:54,000 --> 00:00:56,000
you know, on I believe it was Thursday night.

22
00:00:56,000 --> 00:00:56,500
Sorry.

23
00:00:56,700 --> 00:00:57,900
Yeah, Thursday, night's dream.

24
00:00:58,500 --> 00:00:59,900
We started to look at the disassembly.

25
00:00:59,900 --> 00:01:02,600
So we had written some C code and we were looking at the disassembly

26
00:01:02,600 --> 00:01:03,800
and I was showing you some stuff.

27
00:01:03,800 --> 00:01:06,900
And I said, well this these numbers over here on the side, you know,

28
00:01:06,900 --> 00:01:10,400
those numbers basically correspond to addresses in memory.

29
00:01:10,500 --> 00:01:13,000
Three of where your code actually is.

30
00:01:13,000 --> 00:01:17,000
Because the processor obviously, has to read the code to execute it.

31
00:01:17,000 --> 00:01:18,500
It's got a read the stuff that we write.

32
00:01:18,600 --> 00:01:21,100
And so it's just memory, like, everything else code is memory, just

33
00:01:21,100 --> 00:01:22,000
like data is in memory.

34
00:01:22,000 --> 00:01:24,200
Everything is in memory, everything you ever do is going to be in

35
00:01:24,200 --> 00:01:25,100
memory somewhere.

36
00:01:25,800 --> 00:01:29,600
And so I was like, you know, this was the address of where this

37
00:01:29,600 --> 00:01:33,100
particular piece of code is in the actual member of the computer.

38
00:01:33,100 --> 00:01:35,400
When the CPU is going to go, fetch it, execute it.

39
00:01:35,600 --> 00:01:36,900
And I was like, I want to show that.

40
00:01:36,900 --> 00:01:40,400
So what I did is I had showed earlier in the

41
00:01:40,500 --> 00:01:40,900
The stream.

42
00:01:40,900 --> 00:01:43,100
I had showed, you know, you go over here to the memory window.

43
00:01:43,100 --> 00:01:44,800
You can open up this memory window.

44
00:01:44,900 --> 00:01:47,700
And if you're trying to look at something, you can cut and paste an

45
00:01:47,700 --> 00:01:50,500
address in there which I did and I showed you, like, here's the

46
00:01:50,500 --> 00:01:51,200
memory, right?

47
00:01:51,200 --> 00:01:52,500
Like we could see the memory we played with it.

48
00:01:52,500 --> 00:01:54,000
It was great, it all work, great.

49
00:01:54,000 --> 00:01:57,700
And then I was like, well, you can grab, you know, and the address

50
00:01:57,700 --> 00:01:58,800
here and look at your code.

51
00:01:58,800 --> 00:02:01,300
And when I did it, it was like unable to vote expression.

52
00:02:01,300 --> 00:02:04,100
Now, I really know what was going on there because you should be able

53
00:02:04,100 --> 00:02:07,600
to look at the code, but I assume that maybe it was something that had

54
00:02:07,600 --> 00:02:10,300
changed recently in Windows since like, the last time I, you know,

55
00:02:10,500 --> 00:02:13,000
Anything like that because it's not something you do that often.

56
00:02:13,000 --> 00:02:14,800
Look at the code, the actual code segments and stuff.

57
00:02:16,000 --> 00:02:18,100
So, I just assume, well, maybe for security purposes.

58
00:02:18,100 --> 00:02:21,600
They turned off reading because any given page and memory.

59
00:02:21,600 --> 00:02:25,500
Any virtual page in memory can be marked as readable executable

60
00:02:25,600 --> 00:02:26,900
writable these sorts of things.

61
00:02:27,500 --> 00:02:28,700
So I was pretty sure.

62
00:02:28,700 --> 00:02:30,500
I mean I was like, well, yeah, I don't know what's going on here.

63
00:02:30,500 --> 00:02:31,300
Maybe they marked it.

64
00:02:31,300 --> 00:02:34,500
So you can't read those pages to avoid some kind of hacking attempt.

65
00:02:34,500 --> 00:02:35,100
I don't know.

66
00:02:35,300 --> 00:02:37,100
But point being I was, I was kind of confused.

67
00:02:37,100 --> 00:02:38,400
I said endorsement was going on.

68
00:02:38,400 --> 00:02:40,000
It turns out that was just me.

69
00:02:40,400 --> 00:02:43,900
Not remembering or maybe they change it, but I'm assuming it just me

70
00:02:43,900 --> 00:02:47,200
not remembering that when you put a hexadecimal address, which is what

71
00:02:47,200 --> 00:02:48,100
this is in here.

72
00:02:48,300 --> 00:02:52,000
You have to prefix it with zero X just like you would in code.

73
00:02:52,000 --> 00:02:54,700
It's like a little notation that says the thing that's coming, next is

74
00:02:54,700 --> 00:02:57,600
hexadecimal, which doesn't really make much sense when you look at it

75
00:02:57,600 --> 00:02:59,700
this way because it's like, okay, but got D's in it.

76
00:03:00,100 --> 00:03:03,300
Missy not decimal, must be hexadecimal, but if you had a number that

77
00:03:03,300 --> 00:03:05,700
just was hexadecimal, didn't happen to use any of the letters.

78
00:03:05,700 --> 00:03:06,200
You could see it.

79
00:03:06,200 --> 00:03:07,500
Maybe wouldn't know which one you meant.

80
00:03:07,500 --> 00:03:11,000
So putting the 0x in actually does let you look at the code and

81
00:03:11,000 --> 00:03:14,000
thankfully, Someone caught that and and mentioned on the Q&A.

82
00:03:14,000 --> 00:03:16,500
So we were able to do it in the Q&A, but I just wanted to correct that

83
00:03:16,500 --> 00:03:17,900
for anyone who doesn't watch the Q&A?

84
00:03:18,200 --> 00:03:19,100
That was what had happened.

85
00:03:19,100 --> 00:03:20,500
So it's actually totally fine.

86
00:03:20,800 --> 00:03:24,600
And those pages are not marked unreadable or anything like that.

87
00:03:24,600 --> 00:03:25,500
And you know, it makes sense.

88
00:03:25,500 --> 00:03:27,700
Anyway, it was, it was really the real one of the reasons it was so

89
00:03:27,700 --> 00:03:28,800
confusing to me is because

90
00:03:30,000 --> 00:03:30,900
I'm looking at it here.

91
00:03:30,900 --> 00:03:34,300
I mean the debugger obviously can access that code page because you

92
00:03:34,300 --> 00:03:36,800
know, if it couldn't that how is it showing us the disassembly?

93
00:03:36,800 --> 00:03:39,100
How is it showing us what the code is here?

94
00:03:39,100 --> 00:03:40,300
If it couldn't inspect it.

95
00:03:40,400 --> 00:03:43,100
So when I asked the debugger to inspect it in here, it shouldn't be

96
00:03:43,100 --> 00:03:46,000
like able to inspect it in one window and not able to expect it in the

97
00:03:46,000 --> 00:03:46,400
other.

98
00:03:46,500 --> 00:03:49,800
But you know, I've learned not to assume stuff like that because when

99
00:03:49,800 --> 00:03:52,900
you're programming on a giant complicated operating system with a

100
00:03:52,900 --> 00:03:57,000
giant complicated IDE, you never know what could be happening, right?

101
00:03:57,000 --> 00:03:59,800
I mean, you never know what might be going on internally.

102
00:04:00,000 --> 00:04:03,400
Could be that the person who implemented the thing that disassembles

103
00:04:03,400 --> 00:04:06,300
here was using a different way of getting it to pages.

104
00:04:06,300 --> 00:04:08,900
And so it worked and then the person who wrote the memory window

105
00:04:08,900 --> 00:04:09,300
didn't.

106
00:04:09,300 --> 00:04:12,900
So I didn't want to jump to conclusions and also during a live stream.

107
00:04:13,400 --> 00:04:16,500
I mean, I'll be honest when you're live streaming, your brain is

108
00:04:16,500 --> 00:04:19,300
thinking a lot about how to explain stuff and it's not thinking as

109
00:04:19,300 --> 00:04:20,800
well about how to troubleshoot stuff.

110
00:04:20,800 --> 00:04:23,400
So, it really does help to have people in the Stream watching out for

111
00:04:23,400 --> 00:04:26,100
me, and I really appreciate that because your brains are focused on

112
00:04:26,100 --> 00:04:28,300
what I'm doing and my brains focusing on explaining.

113
00:04:28,500 --> 00:04:29,500
So having the two

114
00:04:29,900 --> 00:04:30,700
Is actually pretty good.

115
00:04:30,700 --> 00:04:31,800
It's kind of like, pair programming.

116
00:04:31,800 --> 00:04:32,600
If someone can be like, no, no.

117
00:04:32,600 --> 00:04:33,900
No, you just forgot the blonde.

118
00:04:33,900 --> 00:04:34,900
It's like, very good.

119
00:04:34,900 --> 00:04:36,400
So I really appreciate that.

120
00:04:36,400 --> 00:04:37,000
Whoever that was.

121
00:04:37,000 --> 00:04:37,600
Thank you very much.

122
00:04:37,600 --> 00:04:41,100
I know it was Matthew vandevander, who, who actually posted it at the

123
00:04:41,100 --> 00:04:43,400
end of the chat, but I think he said that it was someone else who had

124
00:04:43,400 --> 00:04:44,000
said it earlier.

125
00:04:44,000 --> 00:04:44,900
Like, at the time.

126
00:04:45,300 --> 00:04:48,100
I don't read the chat during the stuff because it'd be too distracting

127
00:04:48,100 --> 00:04:49,400
for me, but I read it at the end.

128
00:04:49,900 --> 00:04:54,000
So anyway, that's just the one thing that I wanted to correct, and

129
00:04:54,100 --> 00:04:55,200
it's not that big of a deal.

130
00:04:55,200 --> 00:04:58,400
You will rarely be doing that with code by just wanted to show you

131
00:04:58,800 --> 00:04:59,500
that it is there.

132
00:04:59,500 --> 00:04:59,800
Because

133
00:05:00,000 --> 00:05:02,700
Again, one of the main things that I could keep harping on through

134
00:05:02,700 --> 00:05:05,800
this entire series is just so he's saying everything is in memory.

135
00:05:05,800 --> 00:05:09,000
Everything is just talking about how to get things into the CPU, do

136
00:05:09,000 --> 00:05:09,500
stuff on them.

137
00:05:09,500 --> 00:05:10,400
Put them back out to memory.

138
00:05:10,400 --> 00:05:11,100
That's the whole thing.

139
00:05:11,100 --> 00:05:13,400
And so I just want to show that even the code is there.

140
00:05:13,600 --> 00:05:18,300
And basically all code is is it's a bunch of in codings for these

141
00:05:18,300 --> 00:05:18,900
instructions.

142
00:05:18,900 --> 00:05:21,000
And I think there's a thing show code B yet.

143
00:05:21,500 --> 00:05:25,800
So show code B actually put right after the address.

144
00:05:25,800 --> 00:05:28,400
It actually puts you what the encoding actually was.

145
00:05:28,600 --> 00:05:29,400
So this

146
00:05:29,900 --> 00:05:34,800
mnemonic and this, you know, operand and this operand are actually

147
00:05:34,800 --> 00:05:36,100
encoded this way.

148
00:05:36,100 --> 00:05:40,200
This is how Intel encodes how the x86 and cook.

149
00:05:40,400 --> 00:05:40,600
Sorry.

150
00:05:40,600 --> 00:05:42,100
This is now, this is x86.

151
00:05:42,100 --> 00:05:43,000
We're compiling a 32-bit mode.

152
00:05:43,200 --> 00:05:47,300
So the x86 processor expects to read things that will read them like

153
00:05:47,300 --> 00:05:50,900
this and know that this is what you wanted to do and the disassembler.

154
00:05:50,900 --> 00:05:53,300
The things that showing us the actual Assembly Language here is

155
00:05:53,300 --> 00:05:56,600
basically just reading these code B ins, you know, visual Studios

156
00:05:56,600 --> 00:05:59,800
reading these code B, and then disassembling them and going, okay.

157
00:06:00,000 --> 00:06:01,300
That's the mnemonic for move.

158
00:06:01,300 --> 00:06:02,700
That's like that means a move instruction.

159
00:06:02,700 --> 00:06:03,500
So I'm going to write move.

160
00:06:03,500 --> 00:06:04,700
So it's easier for you to read.

161
00:06:04,700 --> 00:06:05,900
So you don't have to sit around going.

162
00:06:05,900 --> 00:06:08,400
Oh, what is 6f 445 FBF?

163
00:06:08,400 --> 00:06:09,800
Because I have no idea what that is.

164
00:06:09,900 --> 00:06:10,400
You'd have to go.

165
00:06:10,400 --> 00:06:12,100
Look at instruction tables to know what they are.

166
00:06:12,100 --> 00:06:14,500
And if you're a hardcore Assembly Language program, or you probably

167
00:06:14,500 --> 00:06:17,500
know what some of them translate to but I'm so not that guy.

168
00:06:17,500 --> 00:06:19,300
So I need the translation.

169
00:06:22,100 --> 00:06:22,700
Anyway.

170
00:06:24,100 --> 00:06:26,900
So one of the interesting things here and this is just an aside

171
00:06:27,400 --> 00:06:29,300
because hey, it's a weekend stream.

172
00:06:29,500 --> 00:06:31,000
We could be a little more Meandering.

173
00:06:31,700 --> 00:06:32,800
One thing that's kind of interesting here.

174
00:06:32,800 --> 00:06:35,600
A little side is that there's different types of processors.

175
00:06:36,300 --> 00:06:39,100
I mean, I guess I should say there's different types of philosophies

176
00:06:39,100 --> 00:06:40,400
in processor architecture.

177
00:06:40,600 --> 00:06:43,300
And like I made abundantly clear on last week's dream.

178
00:06:43,300 --> 00:06:44,300
I am not a hardware guy.

179
00:06:44,300 --> 00:06:46,000
So I'm not the person to explain them to you.

180
00:06:46,000 --> 00:06:49,700
But what I will say just in passing is that there's different kinds,

181
00:06:49,900 --> 00:06:51,200
some kinds of processors.

182
00:06:51,200 --> 00:06:53,400
The philosophy philosophy is the

183
00:06:53,700 --> 00:06:55,800
Auctions are a fixed size.

184
00:06:56,000 --> 00:06:57,900
So, like the number of bytes.

185
00:06:57,900 --> 00:07:00,800
It takes to encode, any given instruction is fixed.

186
00:07:00,800 --> 00:07:03,800
So, if you have an instruction, like, you know, move this to here, or

187
00:07:03,800 --> 00:07:07,800
whatever, or add this to this or whatever, like we've got, those would

188
00:07:07,800 --> 00:07:08,900
all be the same size.

189
00:07:08,900 --> 00:07:12,300
It doesn't matter what the instruction is, there always the same size

190
00:07:12,900 --> 00:07:17,900
and that, you know, that would be like, I believe on, for example,

191
00:07:17,900 --> 00:07:18,700
powerpc.

192
00:07:18,700 --> 00:07:19,400
That was true.

193
00:07:19,400 --> 00:07:22,600
So, like, you know, on a powerpc, every instruction in memory as it's

194
00:07:22,600 --> 00:07:23,500
encoded, when it, you know,

195
00:07:23,600 --> 00:07:25,100
In the CPU, is reading it out of memory.

196
00:07:25,200 --> 00:07:26,600
Those instructions are the same size.

197
00:07:26,600 --> 00:07:31,200
But on Intel CPUs that they don't use that philosophy.

198
00:07:31,400 --> 00:07:34,200
They have instructions that are variable length.

199
00:07:34,300 --> 00:07:38,100
So basically, as the instruction is being decoded, it looks at what

200
00:07:38,100 --> 00:07:39,700
the actual instruction is.

201
00:07:39,800 --> 00:07:44,100
And what the actual code, you know, code, b, r to figure out how many

202
00:07:44,100 --> 00:07:44,800
It should read.

203
00:07:44,800 --> 00:07:47,200
So it kind of dynamically impacts it and you can actually see that

204
00:07:47,200 --> 00:07:48,500
going on here, right?

205
00:07:48,500 --> 00:07:52,300
You can see if we're to take this line, for example, which is one of

206
00:07:52,300 --> 00:07:53,300
those move instructions.

207
00:07:53,300 --> 00:07:53,500
It's

208
00:07:53,700 --> 00:07:58,000
Bring the value f f into which again is 255.

209
00:07:58,200 --> 00:08:00,400
That's the hexadecimal, which actually going to cover hexadecimal

210
00:08:00,400 --> 00:08:02,600
today for the first time, even though it's kind of keeps poking out a

211
00:08:02,600 --> 00:08:02,800
tooth.

212
00:08:04,300 --> 00:08:06,300
So it's going to move that 255.

213
00:08:06,300 --> 00:08:08,300
It's going to move it to this location.

214
00:08:08,300 --> 00:08:11,300
The test test location, whatever the address is of test.

215
00:08:11,300 --> 00:08:12,300
It's going to do that move.

216
00:08:12,500 --> 00:08:17,600
That is encoded as four bytes here, c64 5f BFF, right?

217
00:08:18,100 --> 00:08:20,800
And hexadecimal again, which we'll cover in a little bit.

218
00:08:20,900 --> 00:08:22,600
It's each letter is basically four bits.

219
00:08:22,600 --> 00:08:23,500
So if you see

220
00:08:23,600 --> 00:08:28,700
two hexadecimal letters or numbers, you know that you're looking at a

221
00:08:28,700 --> 00:08:29,000
bit.

222
00:08:29,000 --> 00:08:31,600
So this is 32 bits right here, right?

223
00:08:31,700 --> 00:08:38,500
It's 8 16, 24 32, but if we go down and look at this, add instruction

224
00:08:38,600 --> 00:08:41,600
where we're just adding one to the register eax, we're taking whatever

225
00:08:41,600 --> 00:08:45,200
is in that register or adding one that is encoded as only three.

226
00:08:45,700 --> 00:08:50,300
So it's encoded as 83 C, 0 0 1 and there isn't a fourth, you know,

227
00:08:50,600 --> 00:08:53,500
fourth B there the fourth B is actually

228
00:08:53,600 --> 00:08:56,000
Actually, you know, just used for the next instruction.

229
00:08:56,000 --> 00:08:59,300
So it's only three bites per instruction for these guys and I am

230
00:08:59,300 --> 00:08:59,800
certainly not.

231
00:09:00,000 --> 00:09:02,900
Knowledgeable enough about Hardware to tell you which one of those is

232
00:09:02,900 --> 00:09:06,100
the right methodology or what, the trade-offs are between them.

233
00:09:07,400 --> 00:09:09,100
I just wanted to point out that, that is the case.

234
00:09:09,100 --> 00:09:11,000
And so it's interesting to kind of think about a little bit, that

235
00:09:11,000 --> 00:09:12,200
there's so much of a difference there.

236
00:09:15,500 --> 00:09:17,700
This can get pretty extreme because as you can see down here,

237
00:09:18,800 --> 00:09:24,700
This guy only has one one bite of code push edx, which is a stack push

238
00:09:24,700 --> 00:09:25,300
kind of thing.

239
00:09:25,300 --> 00:09:27,200
You know, we were talking about the stack and I think the stack grows,

240
00:09:27,200 --> 00:09:28,200
this grows the stack.

241
00:09:30,700 --> 00:09:31,100
One could.

242
00:09:31,100 --> 00:09:35,300
But anyway, so I won't that's not really super relevant to us and it's

243
00:09:35,300 --> 00:09:36,900
not something that's going to come up in the series.

244
00:09:37,100 --> 00:09:40,400
I don't think at all, but it's worth kind of noting the differences

245
00:09:40,400 --> 00:09:42,700
between CPUs there and that there's different kind of architectures

246
00:09:42,700 --> 00:09:44,100
and different sorts of things happen in them.

247
00:09:44,300 --> 00:09:48,800
Because as you go, if you start to care more, as you code about what

248
00:09:48,800 --> 00:09:50,200
the processor is, and how it works.

249
00:09:50,200 --> 00:09:52,400
And, you know, or even if it's just fascinating to you, a lot of

250
00:09:52,400 --> 00:09:53,700
things are just of interest to me.

251
00:09:53,700 --> 00:09:56,400
I like learning about them, even though I'm not an expert and don't

252
00:09:56,400 --> 00:09:58,800
actually need necessarily some of that knowledge.

253
00:09:59,000 --> 00:10:00,300
It's just fun to learn about these

254
00:10:00,500 --> 00:10:03,000
Two things like wise talking about learning about the adding circuits

255
00:10:03,000 --> 00:10:06,500
fun to know how people make a CPU, add numbers together or something.

256
00:10:06,500 --> 00:10:06,800
Right?

257
00:10:06,800 --> 00:10:09,500
Because it's you know, it's what we use every day is kind of

258
00:10:09,500 --> 00:10:11,800
interesting to learn a little bit about the other disciplines that are

259
00:10:11,800 --> 00:10:15,100
involved in making a game Run that have nothing to do with maybe what

260
00:10:15,100 --> 00:10:16,000
we do day to day.

261
00:10:16,400 --> 00:10:21,200
So today what I'd like to do since we kind of got to the point where

262
00:10:21,200 --> 00:10:24,000
we were actually thinking about memory and code and that sort of stuff

263
00:10:24,000 --> 00:10:26,300
is I want to actually go over

264
00:10:28,200 --> 00:10:31,400
Some I wrote actually even had some notes Here.

265
00:10:31,600 --> 00:10:36,300
I want to go over sort of looking at memory in a little more detail in

266
00:10:36,300 --> 00:10:41,500
terms of what see how we actually program in C to use memory

267
00:10:42,000 --> 00:10:42,800
effectively.

268
00:10:43,100 --> 00:10:46,700
And so the first thing I wanted to talk about was basically like

269
00:10:46,700 --> 00:10:48,200
casting and indianness.

270
00:10:48,200 --> 00:10:52,000
I wanted to start talking about how these values actually work.

271
00:10:52,200 --> 00:10:54,500
So what we're going to do here is we're going to, we're going to get

272
00:10:54,500 --> 00:10:55,800
rid of the code that we were writing.

273
00:10:56,100 --> 00:10:57,000
We're going to start.

274
00:10:57,100 --> 00:10:59,300
Fresh air ghost going to check.

275
00:10:59,300 --> 00:11:01,400
Make sure we have the clean compile and we do.

276
00:11:01,800 --> 00:11:05,300
So what I'm going to do now is I am going to go back to what we did

277
00:11:05,300 --> 00:11:05,800
originally.

278
00:11:05,800 --> 00:11:09,900
I'm going to make a unsigned, I'm going to make an unsigned 8-bit

279
00:11:09,900 --> 00:11:12,600
value is like my cord gets caught here.

280
00:11:13,200 --> 00:11:16,200
I'm going to make an unsigned 8-bit value, that we are going to start

281
00:11:16,200 --> 00:11:20,600
looking at and I think I'll stick with calling it test and I am going

282
00:11:20,600 --> 00:11:22,100
to assign a value to it.

283
00:11:22,100 --> 00:11:24,200
I'm going to assign the value.

284
00:11:24,800 --> 00:11:26,900
Let's say 500.

285
00:11:27,400 --> 00:11:29,100
Now that's not going to work 200.

286
00:11:29,700 --> 00:11:31,300
And since of course, it's only 8 Bits.

287
00:11:31,300 --> 00:11:33,500
I can't represent 500 off to a good start today.

288
00:11:34,300 --> 00:11:37,700
What I'm going to do is going to run to that line and then we are

289
00:11:37,700 --> 00:11:40,700
going to execute that line and we should see.

290
00:11:42,200 --> 00:11:46,600
Our value getting set to 200, and it is exactly what we expected.

291
00:11:46,800 --> 00:11:51,700
Now, if you remember from last time, the Ampersand, if I want to I can

292
00:11:51,700 --> 00:11:55,100
always put an ampersand in front of something to ask where in memory

293
00:11:55,100 --> 00:11:58,600
that thing is, it's taking the address of that variable.

294
00:11:58,600 --> 00:11:59,800
And so this tells me exactly

295
00:12:00,000 --> 00:12:03,800
Where it is, and now we remember we can go to our memory window, which

296
00:12:03,800 --> 00:12:06,200
I guess at this point since I'm talking about memory so much.

297
00:12:06,300 --> 00:12:08,900
Maybe we should even doc, maybe we should even talk that.

298
00:12:09,000 --> 00:12:11,200
So one of things they can do and visual Studios, you can kind of drag

299
00:12:11,200 --> 00:12:14,400
these things around, and there's this little flower pattern thing.

300
00:12:14,600 --> 00:12:19,000
If you use the little arrows that are on the flower pattern, I don't

301
00:12:19,000 --> 00:12:20,900
know if you can see that on the stream, because it may not be

302
00:12:20,900 --> 00:12:22,900
something that it was captured, but it comes up a little flower

303
00:12:22,900 --> 00:12:25,400
pattern and there's arrows pointing up down left and right.

304
00:12:25,600 --> 00:12:28,800
If you pick one, it'll doc look above to the left to the right of or

305
00:12:28,800 --> 00:12:29,900
whatever, but I'm just going

306
00:12:30,000 --> 00:12:32,500
To pick the middle thing that doesn't have an arrow on it, which docks

307
00:12:32,500 --> 00:12:33,400
it right in place.

308
00:12:34,100 --> 00:12:36,600
And so now I've got a memory window that's just kind of sitting down

309
00:12:36,600 --> 00:12:37,900
here and that should be fine.

310
00:12:37,900 --> 00:12:40,200
I think for our purposes and I'll move it up a little bit so that it's

311
00:12:40,200 --> 00:12:44,900
not obscured too much by the by the the video of me talking to you.

312
00:12:45,300 --> 00:12:51,000
So if I go here now and I look at this address that we've got four at,

313
00:12:51,000 --> 00:12:55,100
you know, for test the actual address of the variable that address is

314
00:12:55,200 --> 00:12:59,900
0, x 2 3, F9 17 and here we are looking

315
00:13:00,000 --> 00:13:02,600
At the actual values and I'm going to switch out of hexadecimal

316
00:13:02,600 --> 00:13:05,700
display again, because I don't want to talk about that quite yet.

317
00:13:05,700 --> 00:13:07,200
Although, we will actually talk about today.

318
00:13:07,800 --> 00:13:12,700
So I am going to go to why is it, you know, it always likes to slide

319
00:13:12,700 --> 00:13:13,200
me around.

320
00:13:13,200 --> 00:13:14,700
I wish it would just kind of leave that there.

321
00:13:14,700 --> 00:13:15,300
There we go.

322
00:13:15,900 --> 00:13:16,300
Okay.

323
00:13:16,600 --> 00:13:17,500
So here we are.

324
00:13:17,700 --> 00:13:19,200
And here is our 200.

325
00:13:19,200 --> 00:13:22,300
We've actually, you know, done the assignment already and what I'd

326
00:13:22,300 --> 00:13:26,000
like to point out to you is that we are looking at these values as

327
00:13:26,000 --> 00:13:27,200
individual bytes.

328
00:13:27,300 --> 00:13:29,800
So each one of these values that you see in the memory.

329
00:13:29,900 --> 00:13:34,500
Window corresponds to 8 Bits of the memory, in the computer.

330
00:13:35,100 --> 00:13:37,100
So, what we're going to start to address?

331
00:13:37,100 --> 00:13:42,800
Now, is what happens if we ask for more than 8 Bits, right?

332
00:13:42,800 --> 00:13:47,200
What happens if instead of saying unsigned car, right?

333
00:13:47,300 --> 00:13:49,800
What happens if I were to say, unsigned short?

334
00:13:49,800 --> 00:13:52,800
I remember an unsigned short is 16 bits.

335
00:13:53,200 --> 00:13:54,700
So care is eight.

336
00:13:54,900 --> 00:13:56,200
Short is 16.

337
00:13:56,300 --> 00:13:59,800
So now I could do the 500, but I typed in originally,

338
00:14:00,300 --> 00:14:03,600
But that will take more than 8 Bits to represent and we've asked for

339
00:14:03,600 --> 00:14:04,300
16 bit.

340
00:14:04,300 --> 00:14:05,300
So it shouldn't be a problem.

341
00:14:05,300 --> 00:14:08,800
But the question is, since we were looking at memory there, where does

342
00:14:08,800 --> 00:14:10,300
it actually go, right?

343
00:14:10,300 --> 00:14:11,300
Where does it actually go?

344
00:14:11,300 --> 00:14:13,200
When I, when I write that 500?

345
00:14:13,200 --> 00:14:14,600
Well, so again, let's take a look.

346
00:14:15,000 --> 00:14:16,900
And I'll cut, you know, get this value out here.

347
00:14:16,900 --> 00:14:22,100
We'll look at the memory 33 fbe for and we're going to go ahead and

348
00:14:22,100 --> 00:14:24,900
write into this location 500.

349
00:14:25,000 --> 00:14:25,400
So, let's see.

350
00:14:25,400 --> 00:14:26,800
What happens step.

351
00:14:27,200 --> 00:14:27,200
Now.

352
00:14:27,200 --> 00:14:28,600
Did you see those to change?

353
00:14:28,800 --> 00:14:29,500
It was these

354
00:14:30,000 --> 00:14:30,600
Right.

355
00:14:31,100 --> 00:14:35,300
So what actually happened was here is the B that was actually being

356
00:14:35,300 --> 00:14:37,200
pointed to right here is the location.

357
00:14:37,400 --> 00:14:42,000
It wrote to that bite, it wrote 244 and then it wrote to one bite

358
00:14:42,100 --> 00:14:42,700
after it.

359
00:14:43,200 --> 00:14:47,200
Okay, and what I'd like you to notice about these two is that if we

360
00:14:47,200 --> 00:14:51,200
actually break down the binary, as to what these two things represent,

361
00:14:51,900 --> 00:14:56,900
you know, that the 244 isn't the higher part of the binary isn't the

362
00:14:56,900 --> 00:14:58,400
higher part of the 16 bits.

363
00:14:58,600 --> 00:14:59,800
Because what are the 16

364
00:15:00,000 --> 00:15:01,200
For 500, right?

365
00:15:01,300 --> 00:15:04,400
The 16 bits for 500 are this, right?

366
00:15:04,400 --> 00:15:06,600
You've got, you know what, I could even make a little, I'm gonna make

367
00:15:06,600 --> 00:15:07,900
a cute little diagram here.

368
00:15:08,000 --> 00:15:10,200
You're Gonna Love You Gonna Love My ASCII art skills.

369
00:15:10,400 --> 00:15:11,300
They're going to be awesome.

370
00:15:11,700 --> 00:15:12,200
Right?

371
00:15:12,500 --> 00:15:16,400
So I'm going to make a thing that shows you 16 bits here.

372
00:15:16,400 --> 00:15:17,000
Right?

373
00:15:17,800 --> 00:15:19,300
These are actually the bits.

374
00:15:19,400 --> 00:15:21,500
So these are not hexadecimal values.

375
00:15:21,500 --> 00:15:23,700
You can either be ones or zeros, right?

376
00:15:23,900 --> 00:15:27,400
And so what we want to do is we want to represent 500.

377
00:15:27,400 --> 00:15:29,900
So our highest bit that we want to

378
00:15:30,000 --> 00:15:33,000
Do is going to be 256, right?

379
00:15:33,000 --> 00:15:35,700
Which is this value here, that equals 256 is remember.

380
00:15:35,700 --> 00:15:36,700
These are powers of 2.

381
00:15:36,900 --> 00:15:38,800
I don't expect you to know these in your head but it goes right.

382
00:15:38,800 --> 00:15:39,200
1248.

383
00:15:41,300 --> 00:15:42,900
This guy right here is 16.

384
00:15:43,100 --> 00:15:44,300
I don't know how to do that.

385
00:15:46,000 --> 00:15:46,600
Look at me, go.

386
00:15:46,600 --> 00:15:47,400
There's and gentlemen.

387
00:15:47,400 --> 00:15:48,200
Can you believe it?

388
00:15:48,300 --> 00:15:52,700
32 64, right 128.

389
00:15:56,700 --> 00:16:00,100
256 and then they'll keep going up 512 and whatever.

390
00:16:00,100 --> 00:16:02,900
We don't actually need those to represent 500 because since we know

391
00:16:02,900 --> 00:16:06,500
the next bit here, this bit would be 512 right.

392
00:16:06,600 --> 00:16:08,600
Read these vertically by 512.

393
00:16:10,000 --> 00:16:12,500
512, 256, 128.

394
00:16:12,500 --> 00:16:15,900
And it's a little hard to read since this bit would be 512 and that's

395
00:16:15,900 --> 00:16:16,800
higher than the number.

396
00:16:16,800 --> 00:16:19,700
We know that the first bit that we have to set is 256.

397
00:16:19,800 --> 00:16:20,400
Right?

398
00:16:20,500 --> 00:16:24,100
So if we subtract 500 from 256, and in fact, we can even use calc to

399
00:16:24,100 --> 00:16:24,400
do this.

400
00:16:24,400 --> 00:16:29,100
I don't pretend to be a math whiz so if we have five hundred and we

401
00:16:29,100 --> 00:16:32,600
subtracted 56, we're left with 244, right?

402
00:16:32,900 --> 00:16:37,700
And so if we if we want to do 244 we can go ahead and set 128 as well,

403
00:16:37,900 --> 00:16:38,400
right?

404
00:16:38,500 --> 00:16:39,500
And then we'll subtract.

405
00:16:39,700 --> 00:16:40,100
It from it.

406
00:16:40,100 --> 00:16:41,500
So now we've added five.

407
00:16:41,500 --> 00:16:43,400
We've had a 256 and 128.

408
00:16:43,400 --> 00:16:47,900
We're left with 116 which is still higher than 64 so we can set that,

409
00:16:47,900 --> 00:16:48,100
right?

410
00:16:48,100 --> 00:16:53,700
So we'll set that 64, we're down to 52 52 still higher than 32.

411
00:16:53,700 --> 00:16:58,000
So we got to subtract 32 from it as well down to 2016.

412
00:16:58,000 --> 00:17:04,400
Still there - 16 we're down to four that 1 minus 4 is 0.

413
00:17:04,400 --> 00:17:08,099
So we have successfully created our number in binary by hand.

414
00:17:08,200 --> 00:17:09,500
You add 4 to 16.

415
00:17:09,599 --> 00:17:14,900
Into 32 to 64 to 128 to 256 and you will get 500 very exciting.

416
00:17:14,900 --> 00:17:15,400
Right?

417
00:17:16,200 --> 00:17:20,200
So if we actually look at these two parts, right?

418
00:17:20,200 --> 00:17:22,800
I said that we were seeing in B over here.

419
00:17:23,000 --> 00:17:28,200
So our B part is going to be the first 8 Bits which is this, right 1 1

420
00:17:28,200 --> 00:17:30,100
1 1 0 1 0 0.

421
00:17:30,400 --> 00:17:32,500
Yeah, it kind of sounds like a Flight of the Conchords song.

422
00:17:33,000 --> 00:17:35,800
But the part up here is actually just one.

423
00:17:35,800 --> 00:17:39,400
We only use in our second bite that we ask for the high.

424
00:17:39,700 --> 00:17:42,400
terabyte is what we would call that typically because there's like

425
00:17:42,500 --> 00:17:47,300
it's high and low based on basically how much power it sort of has, if

426
00:17:47,300 --> 00:17:50,800
you want to add a very high number, you're going to add something in

427
00:17:50,800 --> 00:17:53,900
the higher-order B because they all correspond to things that are all

428
00:17:53,900 --> 00:17:57,500
higher powers of 2, then the lower order B, if you will, so, if we

429
00:17:57,500 --> 00:17:59,900
take a look at this, right, the only thing that we

430
00:18:00,000 --> 00:18:02,800
A higher order, byte is just one, just the one bit was set.

431
00:18:03,000 --> 00:18:07,300
But in this one we actually had the 4-bit, the 16-bit 32-bit to 64-bit

432
00:18:07,300 --> 00:18:08,300
and 128-bit.

433
00:18:08,300 --> 00:18:08,800
Right?

434
00:18:08,800 --> 00:18:09,100
Oops.

435
00:18:09,200 --> 00:18:10,600
You don't need to do that at all.

436
00:18:11,000 --> 00:18:13,900
So if I go back to my calc here and I see what that's actually going

437
00:18:13,900 --> 00:18:14,900
to be, right?

438
00:18:14,900 --> 00:18:20,300
It's going to be 4 plus 16, plus 32, plus 64, plus 128 and that's to

439
00:18:20,300 --> 00:18:22,500
44, which is exactly what we got here.

440
00:18:22,600 --> 00:18:25,200
So our low byte is 244 are high.

441
00:18:25,200 --> 00:18:27,800
B is one, which is exactly what we expected.

442
00:18:28,200 --> 00:18:29,800
But now what I want you to think about

443
00:18:30,000 --> 00:18:33,500
Out is why they are in that order, right?

444
00:18:33,600 --> 00:18:35,300
We have an address in memory.

445
00:18:35,400 --> 00:18:36,900
These count up sequentially.

446
00:18:37,000 --> 00:18:42,100
This right here is the three million four hundred and six thousand,

447
00:18:42,100 --> 00:18:46,200
eight hundred and twentieth B in memory in our virtual memory space

448
00:18:46,800 --> 00:18:48,900
and then this one will be the one one.

449
00:18:48,900 --> 00:18:50,000
One after that.

450
00:18:50,000 --> 00:18:50,900
It goes to quench turrets.

451
00:18:50,900 --> 00:18:51,900
This will be one Higher.

452
00:18:52,300 --> 00:18:55,200
That one will be the three million four thousand six eight hundred

453
00:18:55,200 --> 00:18:59,800
twenty first byte in memory twenty second third fourth fifth going on.

454
00:19:00,100 --> 00:19:04,100
Going on and on and on, but when you think about it, since we have

455
00:19:04,100 --> 00:19:07,200
these bytes in memory, it's totally arbitrary.

456
00:19:07,200 --> 00:19:10,000
How the CPU chooses to interpret them.

457
00:19:10,300 --> 00:19:14,500
It didn't have to put the low order byte first and then the higher

458
00:19:14,500 --> 00:19:15,000
order byte.

459
00:19:15,000 --> 00:19:17,600
It could have chosen to do them in the opposite order.

460
00:19:17,700 --> 00:19:19,900
There's no reason it's just convention, right?

461
00:19:19,900 --> 00:19:22,000
The CPU is going to have a circuit in it.

462
00:19:22,000 --> 00:19:23,600
That knows how to add together.

463
00:19:23,700 --> 00:19:28,500
Things that are 16 bits long, but where it got each part of the 16

464
00:19:28,500 --> 00:19:29,500
bits is

465
00:19:29,900 --> 00:19:31,500
Avant it doesn't matter.

466
00:19:31,500 --> 00:19:31,700
Right?

467
00:19:31,700 --> 00:19:35,400
There isn't some hard law of physics that says that you must store the

468
00:19:35,400 --> 00:19:37,600
low part first and the high part s.

469
00:19:37,800 --> 00:19:39,500
So what this is called.

470
00:19:39,500 --> 00:19:43,500
It is actually an arbitrary choice on the part of the CPU designer,

471
00:19:43,500 --> 00:19:45,800
way back when the person first designed the x86.

472
00:19:48,400 --> 00:19:54,100
What this is called is called, This is called endianness and honestly,

473
00:19:55,200 --> 00:19:59,700
I don't know if it's one inner tube, you know, spelling also not my

474
00:19:59,700 --> 00:20:00,500
strong suit.

475
00:20:00,900 --> 00:20:05,400
So we're just going to say endian for now and adding this to the end

476
00:20:05,400 --> 00:20:07,000
will be an exercise list for Google.

477
00:20:07,900 --> 00:20:14,100
These are called little endian mode and big-endian mode and I believe

478
00:20:14,100 --> 00:20:16,100
they come, I want to see it.

479
00:20:16,200 --> 00:20:19,000
Comes from like Gulliver's Travels.

480
00:20:19,100 --> 00:20:22,900
It comes from like a crazy fiction, book reference that happened a

481
00:20:22,900 --> 00:20:24,200
long time before.

482
00:20:24,200 --> 00:20:25,400
Like, I was born.

483
00:20:25,800 --> 00:20:26,600
I don't even know.

484
00:20:27,000 --> 00:20:31,600
But point being the convention in Computing is to use the term little

485
00:20:31,600 --> 00:20:32,200
endian.

486
00:20:32,900 --> 00:20:38,500
If the low order, byte comes first, in memory and big-endian.

487
00:20:38,700 --> 00:20:44,000
If the high order comes first in memory, so what we are right?

488
00:20:44,000 --> 00:20:46,100
If since we put our 254 first and our

489
00:20:46,200 --> 00:20:47,000
One second.

490
00:20:47,000 --> 00:20:50,700
That was low and then High we are little endian because the little

491
00:20:50,700 --> 00:20:56,000
part comes first and in fact x86 processors, the standard mode used

492
00:20:56,000 --> 00:20:57,500
for arm processors, although arms.

493
00:20:57,500 --> 00:20:59,800
I believe the architecture is actually switchable so it but

494
00:21:00,000 --> 00:21:02,300
Standard kind that you would see in like an Android or iOS.

495
00:21:02,300 --> 00:21:07,600
Device, arm processors are x64, the 64-bit version of x86.

496
00:21:07,600 --> 00:21:11,600
That's what sinews and most processors today, when you run stuff, like

497
00:21:11,900 --> 00:21:17,200
64-bit windows and that sort of stuff or 64-bit Linux on on Intel

498
00:21:17,200 --> 00:21:17,900
machines.

499
00:21:17,900 --> 00:21:19,300
That's all little-endian.

500
00:21:19,300 --> 00:21:23,300
So mostly, we're all in the little endian these days and it's great

501
00:21:23,300 --> 00:21:25,700
because having only one, endianness makes things a lot simpler

502
00:21:25,700 --> 00:21:27,600
actually, it's, it's funny.

503
00:21:27,600 --> 00:21:29,800
We'll see kind of where that I'll mention a little

504
00:21:30,000 --> 00:21:31,200
Cases, that, that comes up later.

505
00:21:31,300 --> 00:21:33,600
But there are big Indian architectures.

506
00:21:33,600 --> 00:21:37,200
And in the older times, they were a lot more prevalent than they are

507
00:21:37,200 --> 00:21:37,800
today.

508
00:21:37,900 --> 00:21:42,300
For example, the powerpc, which I mentioned earlier today is a big,

509
00:21:42,300 --> 00:21:43,400
endian architecture.

510
00:21:43,500 --> 00:21:47,500
And so things like the Xbox 360, the PlayStation 3.

511
00:21:48,200 --> 00:21:52,700
Before those switched from powerpc, in their older incarnations to the

512
00:21:52,700 --> 00:21:57,900
Xbox One and the PlayStation 4, which are now running x64 based

513
00:21:58,500 --> 00:21:59,200
architectures.

514
00:22:00,000 --> 00:22:03,500
To be power PC, like the cell processor, for example, is a powerpc

515
00:22:03,500 --> 00:22:06,000
based processor, the PS3.

516
00:22:06,000 --> 00:22:10,100
And so on those were big Indian, which meant that data was the other

517
00:22:10,100 --> 00:22:11,000
way around, in memory.

518
00:22:11,000 --> 00:22:14,900
So the one would have come first and the to 5044 would have come

519
00:22:14,900 --> 00:22:15,500
second.

520
00:22:15,900 --> 00:22:16,000
Now.

521
00:22:16,000 --> 00:22:20,300
The reason that this is actually somewhat of concern to programmers is

522
00:22:20,300 --> 00:22:23,700
because, if you are writing things that deal with memory directly,

523
00:22:23,700 --> 00:22:28,900
which often times game, programmers are almost all games will have to

524
00:22:28,900 --> 00:22:29,800
deal with memory directly.

525
00:22:29,900 --> 00:22:33,200
Ali in a number of ways when it does, like data loading and stuff like

526
00:22:33,200 --> 00:22:34,900
this, at the very least.

527
00:22:34,900 --> 00:22:38,100
Once the data, you know, from getting the data from the disk where

528
00:22:38,100 --> 00:22:39,700
it's stored onto the computer.

529
00:22:40,200 --> 00:22:44,800
What usually turns out to be the case, is, the data stored on disk for

530
00:22:44,800 --> 00:22:45,600
a program.

531
00:22:45,600 --> 00:22:47,800
Like, let's say you're writing a game and you've got a lot of art

532
00:22:47,800 --> 00:22:48,200
assets.

533
00:22:48,200 --> 00:22:51,400
So there's textures, but on there and audio and all this sort of stuff

534
00:22:51,600 --> 00:22:54,400
and all this kind of metadata about entities and all this stuff.

535
00:22:55,200 --> 00:22:57,700
If you look at all that data, it's stored on disk.

536
00:22:57,700 --> 00:22:59,700
You typically, just have one package for your game.

537
00:22:59,700 --> 00:23:02,500
You've built all the, you've processed all the data and spend that

538
00:23:02,500 --> 00:23:03,200
sort of stuff.

539
00:23:03,200 --> 00:23:07,000
You may not process all that data into a different disc Pac package

540
00:23:07,000 --> 00:23:07,900
for every platform.

541
00:23:07,900 --> 00:23:09,300
You may want to use the same.

542
00:23:09,300 --> 00:23:12,200
This package everywhere both on the PC and on the Xbox and so on.

543
00:23:12,500 --> 00:23:16,700
And what that means is that data is going to be in one endian format

544
00:23:16,700 --> 00:23:17,700
or another, right?

545
00:23:17,700 --> 00:23:20,300
It's going to either be little-endian or big-endian because it's

546
00:23:20,300 --> 00:23:24,900
stored on disk in a particular order and you know, whatever.

547
00:23:25,100 --> 00:23:26,800
You wrote it out, as is what it's going to stay.

548
00:23:26,800 --> 00:23:31,700
As so if you try to load data, that is big, endian on a little endian

549
00:23:31,700 --> 00:23:36,400
machine, you need to do a conversion first to swap, the order of

550
00:23:36,500 --> 00:23:39,400
things around, in order to make them readable proper, you know,

551
00:23:39,400 --> 00:23:41,100
operable properly on the CPU.

552
00:23:41,100 --> 00:23:43,400
Because like I just said, the order would be different.

553
00:23:43,500 --> 00:23:46,500
The, the CPU will expect numbers that are bigger than 8, Bits to be

554
00:23:46,500 --> 00:23:50,200
encoded differently in each one and where you see this rear?

555
00:23:50,200 --> 00:23:51,200
Its ugly head.

556
00:23:51,300 --> 00:23:54,900
Even today, when everything is like, all little endian for the most

557
00:23:55,000 --> 00:23:59,100
Part is in file formats because portable file formats.

558
00:23:59,100 --> 00:23:59,800
Like let's say

559
00:24:00,300 --> 00:24:02,300
PSD the, for the of a Photoshop file.

560
00:24:02,300 --> 00:24:04,900
You want to read in a Photoshop file, but your artist created, right?

561
00:24:04,900 --> 00:24:07,100
And into a processing tool, Photoshop.

562
00:24:07,100 --> 00:24:10,400
I believe is big-endian format because it was originally on Max, which

563
00:24:10,400 --> 00:24:14,300
were originally Motorola and Motorola, which was sort of the earlier,

564
00:24:14,500 --> 00:24:15,800
lineage of the powerpc.

565
00:24:16,700 --> 00:24:18,900
Like the sixty sixty eight thousand.

566
00:24:19,200 --> 00:24:20,100
What the hell was the name of thing?

567
00:24:20,100 --> 00:24:22,500
68000 processor Motorola.

568
00:24:22,900 --> 00:24:23,300
You know what?

569
00:24:23,300 --> 00:24:29,500
My memory is so bad these days someone give me a web browser.

570
00:24:30,700 --> 00:24:36,800
Motorola 68 km/h 16 s is the one I wanted.

571
00:24:36,800 --> 00:24:40,900
Yes, the Motorola 68000 so macintoshes.

572
00:24:40,900 --> 00:24:44,500
I believe ran on the Motorola 68k line for a while.

573
00:24:44,500 --> 00:24:44,900
I don't know.

574
00:24:44,900 --> 00:24:45,900
I never had a Macintosh.

575
00:24:45,900 --> 00:24:48,600
So I don't really know the Amiga certainly did and I loved the Amiga

576
00:24:48,600 --> 00:24:50,300
and it had 68k line in it.

577
00:24:50,600 --> 00:24:52,000
Those were powerpc-based.

578
00:24:52,000 --> 00:24:52,300
I'm sorry.

579
00:24:52,300 --> 00:24:57,100
Those were big endian based just like the power PCS that followed them

580
00:24:57,200 --> 00:25:00,200
and what that means in practice is that

581
00:25:00,500 --> 00:25:04,100
File formats that were developed on those systems are often big endian

582
00:25:04,100 --> 00:25:07,000
because they just wrote out the data just the way it was in memory.

583
00:25:07,000 --> 00:25:10,800
They didn't do any kind of different packing just because it was on

584
00:25:11,100 --> 00:25:11,400
disk.

585
00:25:11,400 --> 00:25:15,800
So what you end up with is a lot of those file formats still have

586
00:25:15,800 --> 00:25:19,500
their endianness of their Source architecture based baked into them.

587
00:25:20,300 --> 00:25:25,600
So that's just a little, you know, a little aside that you should be

588
00:25:25,600 --> 00:25:29,400
aware of and unfortunately or a rat should say perhaps fortunately we

589
00:25:29,400 --> 00:25:30,300
probably won't really

590
00:25:30,400 --> 00:25:34,800
I run into that too much on the on the stream because since we are in

591
00:25:34,800 --> 00:25:38,400
a sort of a good World these days where everything's the same and Ian,

592
00:25:38,400 --> 00:25:40,800
this we might only ever really run into it a little bit when we're

593
00:25:40,800 --> 00:25:42,900
doing something like, say reading a Photoshop file, if that's what we

594
00:25:42,900 --> 00:25:43,400
want to do.

595
00:25:43,400 --> 00:25:46,300
But, you know, for the most part we're sort of isolated from it

596
00:25:46,300 --> 00:25:49,900
because we're not probably going to have to Target any processors that

597
00:25:49,900 --> 00:25:51,000
aren't already Little Indians.

598
00:25:51,000 --> 00:25:53,800
So it's, you know, it's good and it's bad, it's bad because you won't

599
00:25:53,800 --> 00:25:56,500
really learn it in practice, but it's it's good in that really.

600
00:25:56,500 --> 00:25:59,400
It's kind of just annoying and it would be better if all processors

601
00:25:59,400 --> 00:26:00,300
just stuck with little-endian.

602
00:26:00,500 --> 00:26:01,000
From now on.

603
00:26:01,000 --> 00:26:02,400
So no one ever had to learn it again.

604
00:26:03,000 --> 00:26:06,900
Anyway, now that we've got that out of the way, hopefully, you can see

605
00:26:07,400 --> 00:26:12,400
and understand now, very directly what it means to lay out things that

606
00:26:12,400 --> 00:26:14,800
are bigger than one bite in memory.

607
00:26:14,800 --> 00:26:18,500
Basically, all that happens is, you know, you go through and you start

608
00:26:18,500 --> 00:26:22,200
stacking up each bite that you needed for the composite value into

609
00:26:22,200 --> 00:26:22,600
memory.

610
00:26:22,600 --> 00:26:26,300
And if we were to do this again with something that was even bigger,

611
00:26:26,300 --> 00:26:26,600
right?

612
00:26:26,600 --> 00:26:29,600
I could go in here and make something that's going to be 32 bits long

613
00:26:29,700 --> 00:26:30,200
and maybe.

614
00:26:30,400 --> 00:26:33,300
I make something that is quite large.

615
00:26:33,300 --> 00:26:36,500
For example, that value there.

616
00:26:36,900 --> 00:26:40,100
We will see although you know what let's make it so it won't be an

617
00:26:40,100 --> 00:26:43,400
even power of to do that.

618
00:26:43,400 --> 00:26:44,900
So it will get more bit set.

619
00:26:46,300 --> 00:26:47,900
If we do something, that's even larger.

620
00:26:48,000 --> 00:26:51,400
We will, as you would expect see that it occupies more bites.

621
00:26:51,400 --> 00:26:54,600
And in this case, we would expect it to occupy for B, because we asked

622
00:26:54,600 --> 00:26:56,200
for a 32-bit value.

623
00:26:56,500 --> 00:26:59,200
There's me forgetting my 0x always, okay.

624
00:27:00,200 --> 00:27:03,500
And you can see there at wrote 01 4853, 199 again.

625
00:27:03,500 --> 00:27:04,800
This is the low order.

626
00:27:05,000 --> 00:27:07,600
So, there is nothing in the low order byte.

627
00:27:07,600 --> 00:27:07,900
Then.

628
00:27:07,900 --> 00:27:10,800
There's the next byte, which is the next higher power 148 next higher

629
00:27:10,800 --> 00:27:13,300
priority, three next higher power, 119.

630
00:27:14,000 --> 00:27:16,600
And that's, that's all there is to it.

631
00:27:16,700 --> 00:27:20,000
So that is how things are actually laid out in memory, when you ask

632
00:27:20,000 --> 00:27:21,900
for more than 32 bits, but

633
00:27:23,100 --> 00:27:27,300
In when we are actually programming for reals in the mainstream.

634
00:27:27,600 --> 00:27:31,900
We do not want to constantly have to declare everything as little

635
00:27:32,100 --> 00:27:34,800
parts of little bites and all these sorts of things because we would

636
00:27:34,800 --> 00:27:35,800
go crazy quickly.

637
00:27:35,800 --> 00:27:39,300
So what C allows us to do is it allows us to ask for things that are

638
00:27:39,300 --> 00:27:44,000
actually Composites of many different types of things, all of which

639
00:27:44,000 --> 00:27:45,100
might have different bit counts.

640
00:27:45,100 --> 00:27:49,000
So, for example, let's say we were programming in the mainstream and

641
00:27:49,000 --> 00:27:52,000
we decided that we wanted to make.

642
00:27:53,100 --> 00:27:56,600
You know, something that you will see a lot of games, let's say a

643
00:27:56,600 --> 00:27:58,600
projectile, right?

644
00:27:58,700 --> 00:28:03,400
I want to make something that is going to shoot across the screen.

645
00:28:03,700 --> 00:28:05,800
And so maybe I have something in there.

646
00:28:05,800 --> 00:28:07,500
That's like an NT.

647
00:28:08,100 --> 00:28:12,900
Which says, you know, let's say it's going to be is this thing, you

648
00:28:12,900 --> 00:28:14,300
know, it's really not doing it quite yet.

649
00:28:14,300 --> 00:28:14,800
Let's do it.

650
00:28:14,800 --> 00:28:18,100
Let's do a care unsigned that is like, is this on fire?

651
00:28:18,400 --> 00:28:20,400
We'll just call it that and we'll say that.

652
00:28:20,400 --> 00:28:21,200
You know what?

653
00:28:21,500 --> 00:28:22,800
This is going to be.

654
00:28:23,000 --> 00:28:28,700
One if it's on fire and 0 if it's not this isn't probably how I would

655
00:28:28,700 --> 00:28:32,300
do it in the mainstream because I'm trying to do something fairly

656
00:28:32,300 --> 00:28:33,800
basic for educational purposes.

657
00:28:33,800 --> 00:28:38,100
But let's just say that we felt like using 8 Bits to store something.

658
00:28:38,100 --> 00:28:41,400
That is essentially only one bit of data will get into ways of not

659
00:28:41,400 --> 00:28:42,100
doing that later.

660
00:28:42,100 --> 00:28:45,400
But let's just say we were and then we're going to say how much damage

661
00:28:45,400 --> 00:28:45,900
it does.

662
00:28:46,000 --> 00:28:48,900
So maybe we have a full 32 bits just because we care about it.

663
00:28:49,000 --> 00:28:51,500
We're saying to say the in the damage note.

664
00:28:51,500 --> 00:28:52,800
This is how

665
00:28:52,900 --> 00:28:56,200
Much damage does on impact.

666
00:28:56,300 --> 00:29:01,400
And then we have like, you know, something like particles per second.

667
00:29:01,500 --> 00:29:06,000
This is, you know for special effects blah blah blah.

668
00:29:06,200 --> 00:29:09,600
Maybe I've got something that's like a short which is like, you know,

669
00:29:09,600 --> 00:29:10,200
whatever.

670
00:29:12,100 --> 00:29:16,200
You know, how many cooks there are in in the program.

671
00:29:16,200 --> 00:29:17,400
In case there are too many.

672
00:29:18,100 --> 00:29:18,600
Right.

673
00:29:19,100 --> 00:29:21,100
So let's say we have something like this.

674
00:29:21,600 --> 00:29:22,200
So

675
00:29:23,000 --> 00:29:24,600
What this thing allows us to do that.

676
00:29:24,600 --> 00:29:28,600
I've typed in called a struct is, it's a very simple construct in C.

677
00:29:28,600 --> 00:29:32,900
But it is the backbone of most of the programming that gets done in C.

678
00:29:33,200 --> 00:29:37,700
It is something that allows us to declare a layout of memory in a

679
00:29:37,700 --> 00:29:42,000
prefab way that allows us to refer to it by its parts.

680
00:29:42,000 --> 00:29:45,300
So we don't have to remember how we have packed these things in

681
00:29:45,300 --> 00:29:45,800
memory.

682
00:29:46,000 --> 00:29:47,800
We can just straight-up.

683
00:29:47,800 --> 00:29:48,900
Use it so much.

684
00:29:48,900 --> 00:29:52,600
Like we said down here, we said unsigned int if we wanted to.

685
00:29:52,700 --> 00:29:55,100
To make test be something more complicated.

686
00:29:55,100 --> 00:29:57,800
We could say, it was a projectile.

687
00:29:57,900 --> 00:29:59,800
And now, what it will do is instead of it.

688
00:30:00,000 --> 00:30:00,700
In one thing.

689
00:30:00,700 --> 00:30:04,700
As part of test, it will actually declare all of these things for us

690
00:30:04,800 --> 00:30:08,900
in pack together in memory in one place that we can refer to as that

691
00:30:08,900 --> 00:30:09,600
one name.

692
00:30:09,900 --> 00:30:16,600
And we will be able to do something like this this on fire equals one

693
00:30:16,600 --> 00:30:18,400
because of course, we want it to be on fire.

694
00:30:18,700 --> 00:30:22,600
We want the damage to be a bunch because this is super powerful

695
00:30:22,600 --> 00:30:23,200
projectile.

696
00:30:23,200 --> 00:30:23,600
Obvious.

697
00:30:23,700 --> 00:30:26,200
Obviously, oops little typo there.

698
00:30:26,300 --> 00:30:29,800
I want particles per second per second, you can

699
00:30:30,000 --> 00:30:30,900
We have too many particles.

700
00:30:30,900 --> 00:30:35,300
So that thing should be pretty large to, obviously tons of particles.

701
00:30:35,400 --> 00:30:37,900
I mean, if the engine can't handle that many particles per second and

702
00:30:37,900 --> 00:30:42,200
what good is it anyway, and then there should be maybe like 50 Cooks

703
00:30:42,200 --> 00:30:44,500
because you don't want there to be too many cooks, right?

704
00:30:44,500 --> 00:30:46,100
You want them to be reasonable number of cooks.

705
00:30:46,700 --> 00:30:52,900
So what I have done here is I have used the C Syntax for accessing a

706
00:30:52,900 --> 00:30:56,100
member, which is what the so-called right these.

707
00:30:57,900 --> 00:31:03,100
Are the members for fields of this structure?

708
00:31:03,600 --> 00:31:04,100
Right?

709
00:31:05,700 --> 00:31:10,700
This is how I act as though, I put a period in between the name of the

710
00:31:10,700 --> 00:31:13,500
one that I'm talking about the name of the particular structure that

711
00:31:13,500 --> 00:31:17,800
I'm talking about and the thing inside it that I want to set I then

712
00:31:17,800 --> 00:31:19,700
can use that in any place.

713
00:31:19,700 --> 00:31:22,600
I would have used it if I just had declared it outside.

714
00:31:22,600 --> 00:31:26,100
So if I was just declared this itself and started using it.

715
00:31:26,900 --> 00:31:27,500
Me where I could use it.

716
00:31:27,500 --> 00:31:29,600
We find I can use it on the other side of things too.

717
00:31:29,600 --> 00:31:33,400
I could, for example, make the damage be based on whether it had fire.

718
00:31:33,400 --> 00:31:37,600
So for example, I could make the damage be that so it will add one to

719
00:31:37,600 --> 00:31:38,400
the damage.

720
00:31:38,400 --> 00:31:40,800
If the thing was on fire, for example, right?

721
00:31:41,200 --> 00:31:43,100
And these are again, this is programming.

722
00:31:43,100 --> 00:31:46,500
So, their order dependent the CPU at will do these in the order in

723
00:31:46,500 --> 00:31:47,500
which they appear.

724
00:31:47,800 --> 00:31:51,300
And what that means is that the, this on fire will be set to one

725
00:31:51,300 --> 00:31:52,400
before it gets used here.

726
00:31:52,400 --> 00:31:54,800
Now, if I had done that in the opposite order, it's obviously worth

727
00:31:54,800 --> 00:31:56,700
noting this would actually have been

728
00:31:56,800 --> 00:31:58,800
Just whatever was in memory.

729
00:31:58,900 --> 00:32:00,700
Whatever was in the part of memory that was reserved.

730
00:32:00,700 --> 00:32:01,200
At the time.

731
00:32:01,200 --> 00:32:02,800
It would be totally uninitialized.

732
00:32:02,900 --> 00:32:06,100
And that would be pretty much probably a bug in the code because God

733
00:32:06,100 --> 00:32:07,400
knows what that value would be.

734
00:32:07,900 --> 00:32:10,300
But since we're doing it in this order, we know that we initialize the

735
00:32:10,300 --> 00:32:13,200
first so we can use it safely and know that the value is going to be

736
00:32:13,200 --> 00:32:14,400
what we set it to 0, which is 1.

737
00:32:15,000 --> 00:32:15,600
All right.

738
00:32:15,600 --> 00:32:18,700
So if I go ahead and run the program to this point,

739
00:32:19,800 --> 00:32:21,200
We can do the same thing.

740
00:32:21,200 --> 00:32:22,300
Even though this is a structure.

741
00:32:22,300 --> 00:32:23,100
That's a bunch of things.

742
00:32:23,100 --> 00:32:27,700
We can still use that little operator, the memory of the addressing

743
00:32:27,700 --> 00:32:31,600
operator a, and we can still use that to get where the structure is.

744
00:32:31,600 --> 00:32:31,900
Right?

745
00:32:31,900 --> 00:32:37,100
0, X4, to FDC for is where our structure is, and what that will do is

746
00:32:37,100 --> 00:32:40,500
that will give us the beginning of the structure, right?

747
00:32:40,500 --> 00:32:44,600
Will give us where the first value, the first ones to find.

748
00:32:44,600 --> 00:32:48,000
This is on fire, where that is, and then we can assume that the

749
00:32:48,000 --> 00:32:49,500
compiler has basically.

750
00:32:49,600 --> 00:32:54,400
Lee, you know, packed everything else sequentially, but what we will

751
00:32:54,400 --> 00:32:56,800
notice and I think we'll even see this here because of the way that

752
00:32:56,800 --> 00:32:59,800
I've typed it out, what we don't know.

753
00:33:00,000 --> 00:33:02,200
How much space it might leave in between them.

754
00:33:02,200 --> 00:33:08,200
So the compiler is not under any particular constraint to lay these

755
00:33:08,200 --> 00:33:09,800
things out compact.

756
00:33:09,800 --> 00:33:10,100
Wait.

757
00:33:10,300 --> 00:33:12,500
So this is 8 Bits, right?

758
00:33:12,500 --> 00:33:13,600
It's care unsigned.

759
00:33:13,800 --> 00:33:15,400
So, in fact, I'll go ahead and do this.

760
00:33:15,600 --> 00:33:17,100
I'll go ahead and do this math for you here.

761
00:33:17,600 --> 00:33:21,600
So, if we say that, we have a care in sign, then that's one bite,

762
00:33:21,700 --> 00:33:22,100
right?

763
00:33:22,100 --> 00:33:23,000
So, it's one bite.

764
00:33:23,000 --> 00:33:23,800
For the first thing.

765
00:33:23,900 --> 00:33:26,000
We have a 32-bit value for the damage.

766
00:33:26,000 --> 00:33:27,100
So that's 4 bytes.

767
00:33:27,100 --> 00:33:27,700
Right?

768
00:33:27,800 --> 00:33:29,800
We have a 32-bit value for the particles.

769
00:33:30,100 --> 00:33:32,000
Per second, that's for B.

770
00:33:32,100 --> 00:33:35,900
And we have a short which is two more bites 16 bits.

771
00:33:36,400 --> 00:33:37,500
That is how many cooks are.

772
00:33:37,500 --> 00:33:37,900
All right.

773
00:33:37,900 --> 00:33:38,900
So this is what we've got.

774
00:33:39,000 --> 00:33:43,200
So we would expect Agnes together, 4 plus 4 is 8, plus 2 is 10, plus 1

775
00:33:43,200 --> 00:33:43,800
is 11.

776
00:33:43,900 --> 00:33:47,800
We would expect to see something like 11 B reserved for our

777
00:33:47,800 --> 00:33:48,500
projectile.

778
00:33:48,500 --> 00:33:48,800
Right?

779
00:33:48,800 --> 00:33:50,100
Every time we want a projectile.

780
00:33:50,100 --> 00:33:53,200
We would expect the compiler to reserve 11 B.

781
00:33:54,000 --> 00:33:57,600
But before I go ahead here and show you this, I think I'm actually

782
00:33:57,600 --> 00:33:59,800
going to do something a little bit different, which is

783
00:33:59,900 --> 00:34:02,000
Throw this this in the mix.

784
00:34:02,000 --> 00:34:05,300
There is a compile-time keyword.

785
00:34:05,300 --> 00:34:09,900
You can use in see, called size of which will actually tell you how

786
00:34:09,900 --> 00:34:11,300
big something is.

787
00:34:11,300 --> 00:34:15,300
So we can actually do size of n, t, equal size of NT.

788
00:34:15,300 --> 00:34:20,300
We can do size of car, equal size of car, and we can even stick

789
00:34:20,300 --> 00:34:21,600
something like unsigned in there.

790
00:34:21,600 --> 00:34:25,300
So any type that you want can go in here and I'll tell you, we can do

791
00:34:25,300 --> 00:34:26,300
size of in, we did that.

792
00:34:26,300 --> 00:34:29,600
And then we can finally do size of tests, which is, however, big.

793
00:34:29,600 --> 00:34:29,900
This thing was,

794
00:34:29,900 --> 00:34:34,500
Would be, which will be the same as asking size or projectile size of

795
00:34:34,500 --> 00:34:35,300
projectile.

796
00:34:35,400 --> 00:34:40,900
The type is the same as size of test, the variable, because test is a

797
00:34:40,900 --> 00:34:42,000
projectile, right?

798
00:34:42,199 --> 00:34:45,400
So, let's see what happens if I actually go and do these things.

799
00:34:46,500 --> 00:34:48,699
If I come down and do these things and I look at them in the Watchman.

800
00:34:48,699 --> 00:34:55,600
Do I do sighs of car-sized event size of projectile, size of test.

801
00:34:56,000 --> 00:34:56,600
We will see that.

802
00:34:56,600 --> 00:35:00,300
Some things are what we expected in some things, aren't so size of car

803
00:35:00,300 --> 00:35:03,600
is one, which is exactly what I said, because it always returns it in

804
00:35:03,600 --> 00:35:06,000
B, and we said that Char was one bite.

805
00:35:06,100 --> 00:35:07,500
It was eight bits, right?

806
00:35:07,800 --> 00:35:11,200
In t, we said was 32 bits, which is 4, bytes, exactly what you said

807
00:35:11,200 --> 00:35:12,300
for right?

808
00:35:12,400 --> 00:35:13,300
And you know what?

809
00:35:13,300 --> 00:35:14,900
I didn't do this one, but we could totally do it.

810
00:35:14,900 --> 00:35:16,200
Sighs of short is too.

811
00:35:16,300 --> 00:35:17,500
Which is exactly what we said.

812
00:35:17,700 --> 00:35:20,700
So, you know, this, this match should be right, right.

813
00:35:20,700 --> 00:35:22,100
It's one bite before, but spy for us.

814
00:35:22,100 --> 00:35:23,100
But to B is 11 B.

815
00:35:23,100 --> 00:35:23,900
What's wrong?

816
00:35:24,000 --> 00:35:24,600
What happened?

817
00:35:24,600 --> 00:35:25,400
What's weird here?

818
00:35:25,400 --> 00:35:25,900
Right?

819
00:35:26,500 --> 00:35:29,400
And the answer is, like, I sort of started saying before, is that the

820
00:35:29,400 --> 00:35:35,300
compiler is not under any constraint to lay this structure out in

821
00:35:35,300 --> 00:35:38,000
packed, as as compactly as possible.

822
00:35:38,000 --> 00:35:40,000
If you will, it is not necessary.

823
00:35:40,000 --> 00:35:41,400
It doesn't have to do that.

824
00:35:41,700 --> 00:35:44,500
So what it can do is if it thinks it would be more efficient because

825
00:35:44,500 --> 00:35:46,200
of the way the CPU accesses.

826
00:35:46,200 --> 00:35:47,000
as, for example,

827
00:35:49,600 --> 00:35:52,300
And the instructions it has at its disposal if it thinks it would be

828
00:35:52,300 --> 00:35:56,600
more efficient, for example, to reserve 32 bits for each of these

829
00:35:56,900 --> 00:35:59,600
because let's say the CPU is much slower.

830
00:36:00,000 --> 00:36:03,600
Accessing an 8-bit value that is unaligned.

831
00:36:03,600 --> 00:36:06,600
It's like kind of add a you know, that's that's off of a 32-bit

832
00:36:06,600 --> 00:36:07,200
boundary.

833
00:36:07,800 --> 00:36:12,200
Maybe the processor set up to access things at on 32-bit boundaries

834
00:36:12,200 --> 00:36:16,400
very quickly, but 8-bit boundaries not so fast, right.

835
00:36:16,500 --> 00:36:18,400
So it may be like, oh, you know what?

836
00:36:18,400 --> 00:36:21,800
I'm I'm actually not going to pack these things tightly.

837
00:36:21,800 --> 00:36:25,400
I'm going to actually reserved 32 bits for each of them because I know

838
00:36:25,400 --> 00:36:27,000
I can generate faster code that way.

839
00:36:27,100 --> 00:36:29,100
The compiler is allowed to do that.

840
00:36:29,400 --> 00:36:29,800
So,

841
00:36:30,000 --> 00:36:32,500
So what we actually see Happening Here, the sides are projectile

842
00:36:32,500 --> 00:36:32,800
inside.

843
00:36:32,800 --> 00:36:34,100
The test is not 11.

844
00:36:34,100 --> 00:36:39,100
It's actually 16 and 16 is sort of doing exactly what I said.

845
00:36:39,200 --> 00:36:42,700
If we look at this, we see that there are four elements and each of

846
00:36:42,700 --> 00:36:45,600
those elements having four bytes would be 16.

847
00:36:45,800 --> 00:36:47,300
So, did that happen?

848
00:36:47,700 --> 00:36:48,200
I don't know.

849
00:36:48,300 --> 00:36:51,400
Let's find out if I go in here and set something that makes it much

850
00:36:51,400 --> 00:36:52,600
easier for us to see.

851
00:36:52,700 --> 00:36:56,300
I'll just put a 1 in each one of these things, right?

852
00:36:57,500 --> 00:36:59,900
Then what we would expect to see in our memory window.

853
00:36:59,900 --> 00:37:03,500
If I look at the address of test is, we should be able to see as it

854
00:37:03,500 --> 00:37:06,400
fill those in exactly how it decided to pack them for us.

855
00:37:06,400 --> 00:37:08,900
And there's another way we can actually tell that to so we'll see.

856
00:37:08,900 --> 00:37:10,300
We're going to see it in two different ways here.

857
00:37:10,500 --> 00:37:13,900
But so if I go ahead and step now, you'll see it wrote the one in

858
00:37:13,900 --> 00:37:16,900
there and you'll notice it didn't actually write anything else.

859
00:37:16,900 --> 00:37:20,200
So it only wrote to the first bite but then when it wrote to the next

860
00:37:20,200 --> 00:37:22,800
one, you will note that it skipped.

861
00:37:22,800 --> 00:37:26,300
It did exactly what I suspected it would do which is it skipped three

862
00:37:26,300 --> 00:37:26,800
bites.

863
00:37:27,400 --> 00:37:29,100
To keep things on.

864
00:37:29,200 --> 00:37:31,900
It's actually a 32-bit boundary a 4 byte boundary.

865
00:37:32,300 --> 00:37:35,300
Now it wrote all of them this time and the reason that it will all

866
00:37:35,300 --> 00:37:37,400
this time is because this one is declared as an end.

867
00:37:37,400 --> 00:37:39,200
Since this was declared as a car on sign.

868
00:37:39,200 --> 00:37:42,500
It is not incumbent upon the compiler to actually do anything with

869
00:37:42,500 --> 00:37:43,100
these values.

870
00:37:43,400 --> 00:37:44,700
Essentially, they were just padding.

871
00:37:44,800 --> 00:37:47,700
They were there to make sure that things were aligned on particular

872
00:37:47,700 --> 00:37:51,200
boundaries for the CPU, to be more efficient, which it turns out x86,

873
00:37:51,400 --> 00:37:52,100
is more efficient.

874
00:37:52,100 --> 00:37:54,800
I think, at a number of things in this way, so it's probably smarter

875
00:37:54,800 --> 00:37:55,700
than power to do that.

876
00:37:55,700 --> 00:37:56,600
But point being,

877
00:37:57,400 --> 00:38:00,200
It does not actually have to write any values to these because we will

878
00:38:00,200 --> 00:38:00,900
never access them.

879
00:38:00,900 --> 00:38:04,000
We will only ever be reading just these 8 Bits here.

880
00:38:04,000 --> 00:38:06,200
And so it was strictly doing that to maintain the alignment.

881
00:38:06,200 --> 00:38:08,000
Same thing as particles per second.

882
00:38:08,000 --> 00:38:11,000
It's going to write the 32 bits there and it's going to write all of

883
00:38:11,000 --> 00:38:13,900
them as we expect and then too many cooks does exactly what the first

884
00:38:13,900 --> 00:38:14,400
one did.

885
00:38:14,400 --> 00:38:17,500
Only this one's 16 bits instead of 8 Bits, And it leaves the other two

886
00:38:17,500 --> 00:38:18,300
untouched.

887
00:38:18,300 --> 00:38:22,600
But we know that it reserves 16-bit B, because we asked the compiler,

888
00:38:22,600 --> 00:38:25,300
how big it was, and it said 16, so it's actually using all of those.

889
00:38:25,300 --> 00:38:27,200
Now, we

890
00:38:27,500 --> 00:38:29,400
Also ask a different way.

891
00:38:29,600 --> 00:38:34,700
We can ask where each individual memory piece is by using the address

892
00:38:34,700 --> 00:38:35,100
operator.

893
00:38:35,100 --> 00:38:35,600
Again.

894
00:38:35,600 --> 00:38:36,000
Oops.

895
00:38:36,900 --> 00:38:38,900
Is this on fire?

896
00:38:38,900 --> 00:38:40,700
Not his this of fire.

897
00:38:41,800 --> 00:38:45,700
I can actually ask where each individual part of this structure is in

898
00:38:45,700 --> 00:38:48,500
memory and we can actually see that.

899
00:38:48,500 --> 00:38:51,400
The number of the address goes up.

900
00:38:51,500 --> 00:38:56,700
Exactly as we'd expect right eight to see 2024, but can we really see

901
00:38:56,700 --> 00:38:57,200
that?

902
00:38:57,400 --> 00:38:59,900
No, we can't because we haven't done hexadecimal yet, which brings me?

903
00:39:00,000 --> 00:39:03,600
To my next topic for today, which is understanding hexadecimal.

904
00:39:03,800 --> 00:39:04,200
Okay.

905
00:39:04,400 --> 00:39:07,000
Now I alluded to this a bit in the Stream beforehand.

906
00:39:11,900 --> 00:39:12,400
Okay.

907
00:39:13,500 --> 00:39:14,900
I allude to this a little bit in this dream.

908
00:39:15,300 --> 00:39:16,900
I believe, I don't know, two days ago.

909
00:39:16,900 --> 00:39:18,500
I'm not even sure when we've done enough screams.

910
00:39:18,500 --> 00:39:19,900
Now that I remember what's on every dream.

911
00:39:21,000 --> 00:39:23,100
I want to teach you, just quickly how to read hexadecimal.

912
00:39:23,100 --> 00:39:26,000
Just so you'll know and you can start to practice it because like I

913
00:39:26,000 --> 00:39:28,000
said, everything is kind of written in it when you're looking at

914
00:39:28,000 --> 00:39:30,700
memory addresses because they get big and so it just keeps a little

915
00:39:30,700 --> 00:39:31,400
more compact.

916
00:39:31,400 --> 00:39:35,700
That's also if you look at this number, for example, yeah, once you do

917
00:39:35,700 --> 00:39:37,200
that, you don't need to do that.

918
00:39:37,200 --> 00:39:37,400
Mr.

919
00:39:37,400 --> 00:39:38,100
Compiler.

920
00:39:40,000 --> 00:39:45,600
There, if you look at this number, basically this people prefer this

921
00:39:45,600 --> 00:39:48,600
kind of concise more concise notation to that.

922
00:39:49,500 --> 00:39:50,700
To be honest with you.

923
00:39:50,700 --> 00:39:54,000
I've never been a huge mr.

924
00:39:54,100 --> 00:39:56,000
You know really excited about hexadecimal.

925
00:39:56,000 --> 00:40:00,100
I think that, but the reason that it does also become kind of nice to

926
00:40:00,100 --> 00:40:00,400
use.

927
00:40:00,400 --> 00:40:04,500
At some point is just because it's binary aligned, if you think of it

928
00:40:04,500 --> 00:40:08,700
that way like this number, a decimal number is not binary aligned.

929
00:40:08,700 --> 00:40:09,700
So you can't

930
00:40:09,900 --> 00:40:13,600
Peel off the digits as if they were powers of 2, there's nowhere, I

931
00:40:13,600 --> 00:40:18,300
can stop in this number and say, that was just the first bite was that

932
00:40:18,300 --> 00:40:19,300
part, right?

933
00:40:20,100 --> 00:40:23,100
Because it's all mixed together since its base 10 and we're, you know,

934
00:40:23,100 --> 00:40:26,500
the binary based to and base-10, they don't overlap correctly.

935
00:40:27,100 --> 00:40:29,900
So basically the nice thing about hexadecimal, if I just want to talk

936
00:40:29,900 --> 00:40:31,800
about what's in the bottom, B, I know.

937
00:40:31,800 --> 00:40:33,700
That's just the first two characters and I can look at them

938
00:40:33,700 --> 00:40:34,300
separately.

939
00:40:34,600 --> 00:40:38,200
And so that's really probably where most of the use of hexadecimal

940
00:40:38,200 --> 00:40:39,400
comes in, in practice.

941
00:40:39,800 --> 00:40:42,200
Is just that ability to kind of say what's the low B.

942
00:40:42,200 --> 00:40:44,600
What's the high B without having to try and figure it out from a

943
00:40:44,600 --> 00:40:46,700
decimal, which makes it kind of hard to do.

944
00:40:47,100 --> 00:40:53,400
So, the way to read hexadecimal is it just looks like this zero

945
00:40:54,100 --> 00:40:56,300
through 16.

946
00:41:10,800 --> 00:41:16,700
And when I get to the part where I would be rapping in base 10 to 10,

947
00:41:17,000 --> 00:41:18,600
I actually switched to using.

948
00:41:19,900 --> 00:41:20,800
A through F.

949
00:41:21,700 --> 00:41:26,800
So basically, this is the hexadecimal conversion chart whenever you

950
00:41:26,800 --> 00:41:29,800
are trying to represent the numbers from 0 to 15, you simply change

951
00:41:29,800 --> 00:41:32,900
them into the numbers, 0 through the letter F, and that is

952
00:41:32,900 --> 00:41:33,500
hexadecimal.

953
00:41:33,500 --> 00:41:37,500
So if I have a, as a hexadecimal number, you can see, it is always

954
00:41:37,500 --> 00:41:39,300
written with a 0x prefix.

955
00:41:39,300 --> 00:41:44,200
That is basically just I have no idea how they picked 0x, but they

956
00:41:44,200 --> 00:41:47,700
write in a with a 0x prefix to, basically say, the number that comes

957
00:41:47,700 --> 00:41:49,000
next will not be decimal.

958
00:41:49,000 --> 00:41:49,500
It will be hex.

959
00:41:49,700 --> 00:41:51,500
Decimal, if I say 0xa.

960
00:41:51,600 --> 00:41:56,000
What I really mean is 10 if I say 0xaa, right?

961
00:41:56,100 --> 00:41:59,500
What I really mean is 10 for this first one, right?

962
00:41:59,500 --> 00:41:59,800
Because they

963
00:42:00,000 --> 00:42:04,000
They are written just like decimal the lowest value comes at the far

964
00:42:04,000 --> 00:42:10,500
end and I'm going upwards and power from their plus 16 times 10,

965
00:42:10,600 --> 00:42:11,000
right?

966
00:42:11,000 --> 00:42:13,800
Because each one of these letters goes up by 16.

967
00:42:13,800 --> 00:42:19,100
So this is really a hundred and sixty plus ten, right or 160.

968
00:42:19,100 --> 00:42:19,400
Right?

969
00:42:19,400 --> 00:42:24,500
So if I was in here, and I said 0xaa, yes, thank you.

970
00:42:24,500 --> 00:42:25,900
I don't care about edit continue.

971
00:42:25,900 --> 00:42:26,800
Just please show me.

972
00:42:28,500 --> 00:42:30,300
Damn you sorry way to do math there.

973
00:42:30,300 --> 00:42:32,000
Casey plus 10.

974
00:42:32,500 --> 00:42:33,600
I told you I was bad at math.

975
00:42:33,600 --> 00:42:34,300
I wasn't kidding.

976
00:42:34,300 --> 00:42:36,100
I couldn't even add one 6210.

977
00:42:36,200 --> 00:42:36,600
Awesome.

978
00:42:37,100 --> 00:42:40,400
So yeah, if I put a 0 XA and there I get 170 and similarly.

979
00:42:40,400 --> 00:42:41,900
It just keeps going up by 16.

980
00:42:41,900 --> 00:42:46,500
So if I did 0xaa, I'm talking about 16 times, 16 times 10 plus 16

981
00:42:46,500 --> 00:42:47,300
times 10.

982
00:42:47,500 --> 00:42:47,900
Oops.

983
00:42:49,600 --> 00:42:50,100
Right.

984
00:42:52,800 --> 00:42:55,700
Plus 10 and it's the same exact thing as base 10.

985
00:42:55,800 --> 00:43:00,800
If I were to tell you that I have the number, you know 444 right

986
00:43:00,800 --> 00:43:01,700
that's taking 4 times.

987
00:43:01,700 --> 00:43:04,500
100 plus 4 times 10 plus 4, right?

988
00:43:04,500 --> 00:43:07,700
And so all we're doing is the exact same damn thing in a different

989
00:43:07,700 --> 00:43:08,100
base.

990
00:43:08,100 --> 00:43:09,500
We're just multiplying by 16.

991
00:43:09,500 --> 00:43:12,100
Every time we go out one digit instead of x 10.

992
00:43:12,100 --> 00:43:14,200
It's the easiest stupid thing in the world.

993
00:43:14,300 --> 00:43:16,800
And like I said, the only even reason that I think anyone actually

994
00:43:16,800 --> 00:43:19,800
cares or does it is because a little more concise and it lines up with

995
00:43:19,800 --> 00:43:22,500
binary, which is all we really wanted and decimal doesn't line up.

996
00:43:22,700 --> 00:43:23,100
Binary.

997
00:43:23,300 --> 00:43:25,200
So it tends to not be used.

998
00:43:25,200 --> 00:43:27,200
When binary is the thing that were mainly talking about.

999
00:43:27,200 --> 00:43:32,500
But for the most part numbers in C will usually be decimal or they'll

1000
00:43:32,500 --> 00:43:35,300
be what's called floating point, which is basically like a, you know,

1001
00:43:35,300 --> 00:43:39,300
it's like 1.23 to or something like a fractional number will be using

1002
00:43:39,300 --> 00:43:40,700
mostly numbers that look like that.

1003
00:43:40,800 --> 00:43:43,800
So actually hexadecimal will mostly be when we're talking about bit

1004
00:43:43,800 --> 00:43:47,400
like specific little fiddly bit things and so you won't really have to

1005
00:43:47,400 --> 00:43:49,800
worry about them that much like you don't have to be some kind of

1006
00:43:49,800 --> 00:43:50,300
awesome.

1007
00:43:50,300 --> 00:43:52,500
I can translate hexadecimal in my head kind of way.

1008
00:43:52,900 --> 00:43:54,000
To do anything like that?

1009
00:43:56,200 --> 00:43:58,700
Okay, so that's actually decimal.

1010
00:43:59,200 --> 00:44:02,500
So let's see where we're at here for the day.

1011
00:44:02,500 --> 00:44:03,800
I like I said, I have no today.

1012
00:44:03,800 --> 00:44:07,000
Even we did end and Enos and we did hexadecimal.

1013
00:44:07,100 --> 00:44:08,400
We did struct.

1014
00:44:08,700 --> 00:44:12,700
And so the other thing that I'd like to look at then is, is casting.

1015
00:44:13,400 --> 00:44:15,300
I'd like to look at how casting works.

1016
00:44:15,600 --> 00:44:20,000
So, what I'd like to now do is point out again that one of the main

1017
00:44:20,100 --> 00:44:22,900
advantages of programming in something like C is that you are in

1018
00:44:22,900 --> 00:44:24,600
complete control, a lot of times.

1019
00:44:24,600 --> 00:44:25,200
And you know,

1020
00:44:25,400 --> 00:44:27,600
It controls wrong because Assembly Language is really the only place

1021
00:44:27,600 --> 00:44:31,500
where you complete control, but you're in a pretty complete control

1022
00:44:31,800 --> 00:44:35,300
about how things are happening with memory and how the CPU is is doing

1023
00:44:35,300 --> 00:44:36,600
the things that it's going to do.

1024
00:44:36,900 --> 00:44:38,700
And so given that that's the case.

1025
00:44:39,500 --> 00:44:42,800
If you look at something like this projectile struck where I asked the

1026
00:44:42,800 --> 00:44:44,400
compiler to lay this thing out for me.

1027
00:44:45,300 --> 00:44:51,700
Basically, I can do more complex stuff than just access it in this

1028
00:44:51,700 --> 00:44:52,100
way.

1029
00:44:52,100 --> 00:44:55,100
Like it's not like something like a highly.

1030
00:44:55,300 --> 00:44:57,300
Structured high-level programming language.

1031
00:44:57,300 --> 00:44:59,900
Where once you say this, you must always use.

1032
00:45:00,000 --> 00:45:02,800
It this way and there's no way to do anything else with it.

1033
00:45:02,800 --> 00:45:04,600
I don't have to do that at all.

1034
00:45:05,000 --> 00:45:07,200
I can do some pretty fantastically wacky.

1035
00:45:07,200 --> 00:45:10,600
Things if I should want to or if they should become interesting for me

1036
00:45:10,600 --> 00:45:13,000
to do and so I will show you a little bit of that.

1037
00:45:13,000 --> 00:45:17,800
Now, let's say that what I really wanted to do is look at this

1038
00:45:17,800 --> 00:45:21,200
structure as if it were a series of shorts, right?

1039
00:45:21,200 --> 00:45:24,000
So what I want to do is I want to use the pointer thing that I had

1040
00:45:24,000 --> 00:45:25,500
referred to in the previous.

1041
00:45:26,600 --> 00:45:30,100
Stream, I want to use a pointer called.

1042
00:45:30,100 --> 00:45:37,000
Let's say, mister pointer, man, and I want to look at test as if it

1043
00:45:37,000 --> 00:45:38,400
were a bunch of shorts.

1044
00:45:38,600 --> 00:45:40,500
So I'll do the assignments first.

1045
00:45:40,500 --> 00:45:41,500
I'll put these on there.

1046
00:45:41,500 --> 00:45:44,500
I'll actually do the the assignments, the one and you know, what, I'll

1047
00:45:44,500 --> 00:45:46,800
make it so that we can tell which ones, which just by MIT, you know,

1048
00:45:46,800 --> 00:45:48,200
assigning a different value to each of them.

1049
00:45:48,200 --> 00:45:53,700
Let's say and what's going to happen is I am going to ask to see, I

1050
00:45:53,700 --> 00:45:55,900
want to basically look at the memory.

1051
00:45:56,200 --> 00:46:00,000
Occupied by test as if it was just a bunch of 16-bit values.

1052
00:46:00,000 --> 00:46:03,700
Instead of looking at it in the way that it's laid out here by name.

1053
00:46:04,200 --> 00:46:07,900
Now, in order to see is a statically typed programming language is

1054
00:46:07,900 --> 00:46:08,700
what it's called.

1055
00:46:09,000 --> 00:46:14,100
That's the type of language it is and static typing means that c keeps

1056
00:46:14,100 --> 00:46:16,200
track of what you said things were.

1057
00:46:16,200 --> 00:46:19,000
If you said something was an indoor, you said something was a Karen

1058
00:46:19,000 --> 00:46:21,500
signed, or you said something was a projectile.

1059
00:46:21,600 --> 00:46:25,400
It keeps track of those and it will warn you or give you an error.

1060
00:46:25,600 --> 00:46:26,000
If you try.

1061
00:46:26,200 --> 00:46:28,700
Try to use something in a way that you didn't tell it.

1062
00:46:31,600 --> 00:46:32,100
so,

1063
00:46:33,400 --> 00:46:36,500
when I asked for the address of something like, if I were to ask for

1064
00:46:36,500 --> 00:46:40,900
the address of test, for example, if I was to say, projectile pointer,

1065
00:46:41,700 --> 00:46:45,900
you know, equals at test and I compile this, you will notice that this

1066
00:46:45,900 --> 00:46:49,300
line compiles, fine, but the line that I want to show you does not

1067
00:46:49,300 --> 00:46:50,800
compile fine, right?

1068
00:46:51,100 --> 00:46:52,200
It gives me an error.

1069
00:46:52,200 --> 00:46:55,200
It says initializing cannot convert from projectile star to short

1070
00:46:55,200 --> 00:46:55,600
star.

1071
00:46:56,000 --> 00:46:57,900
And the reason for that is because when I take the address of

1072
00:46:57,900 --> 00:47:00,300
something, it's assumed to be the type of the thing.

1073
00:47:00,600 --> 00:47:02,600
Plus the star saying it is a pointer.

1074
00:47:02,700 --> 00:47:03,100
It is a

1075
00:47:03,200 --> 00:47:07,100
Patient in memory that says, wear something like this is.

1076
00:47:07,400 --> 00:47:10,900
But down here since test isn't a short.

1077
00:47:10,900 --> 00:47:11,800
It's a projectile.

1078
00:47:12,000 --> 00:47:13,400
It says, hey, wait a minute.

1079
00:47:13,800 --> 00:47:15,900
I think you may have made a mistake.

1080
00:47:16,000 --> 00:47:18,900
You asked me for the pointer to a projectile.

1081
00:47:19,000 --> 00:47:22,400
I gave that to you and now you're trying to turn that into a point or

1082
00:47:22,400 --> 00:47:26,000
a short that seems like a bug now, it's very good that it did that for

1083
00:47:26,000 --> 00:47:26,100
me.

1084
00:47:26,100 --> 00:47:27,800
Even though I love low-level programming.

1085
00:47:27,800 --> 00:47:28,900
I love static type.

1086
00:47:28,900 --> 00:47:29,200
Checking.

1087
00:47:29,200 --> 00:47:32,700
I really like static typed languages because I they catch errors.

1088
00:47:32,700 --> 00:47:33,000
I make

1089
00:47:33,200 --> 00:47:34,100
Mistakes all the time.

1090
00:47:34,100 --> 00:47:36,100
You've seen me make errors in this very stream.

1091
00:47:36,700 --> 00:47:37,600
Maybe not tonight.

1092
00:47:37,600 --> 00:47:38,500
I don't know if I made errors yet.

1093
00:47:38,500 --> 00:47:39,300
I probably have.

1094
00:47:39,300 --> 00:47:40,400
But, like, in last night's dream.

1095
00:47:40,400 --> 00:47:42,000
For example, I made a mistake.

1096
00:47:42,100 --> 00:47:45,300
I made two mistakes, even I think so.

1097
00:47:45,400 --> 00:47:48,100
I make mistakes all the time and one of the things that you need to

1098
00:47:48,100 --> 00:47:51,300
be, when you write a lot of code, you need to learn how to use

1099
00:47:51,300 --> 00:47:53,500
language features to effectively, catch your mistakes.

1100
00:47:53,700 --> 00:47:54,700
And this is a great one.

1101
00:47:54,700 --> 00:47:59,100
This catches a ton of mistakes at compile time.

1102
00:47:59,200 --> 00:47:59,800
You don't have to run the

1103
00:48:00,000 --> 00:48:01,200
Graham knows, there's a problem.

1104
00:48:02,000 --> 00:48:05,800
But like I said, see you let you do pretty much anything you want with

1105
00:48:05,800 --> 00:48:06,200
memory.

1106
00:48:06,200 --> 00:48:08,600
So that error is just there to let you know.

1107
00:48:08,600 --> 00:48:12,100
You may have made a mistake, but you can easily tell the compiler.

1108
00:48:12,100 --> 00:48:13,200
It's okay, man.

1109
00:48:13,700 --> 00:48:14,900
I know what I'm doing.

1110
00:48:14,900 --> 00:48:18,100
I'm a trained professional in quotes.

1111
00:48:19,100 --> 00:48:24,400
So I am going to go ahead and tell you it's okay to let me do the

1112
00:48:24,400 --> 00:48:25,500
thing that I was about to try.

1113
00:48:25,500 --> 00:48:28,000
And the way that you do that was a thing called a cast.

1114
00:48:28,100 --> 00:48:29,900
And the way that you cast things is you basically

1115
00:48:30,000 --> 00:48:34,800
A just put in parentheses before the value you put in parentheses the

1116
00:48:34,800 --> 00:48:37,400
type, you want the thing to become.

1117
00:48:37,600 --> 00:48:39,600
So yes, this is a projectile star.

1118
00:48:39,700 --> 00:48:41,700
I would like it to become a short star, please.

1119
00:48:41,800 --> 00:48:45,100
And then this line will compile properly as you can see.

1120
00:48:45,700 --> 00:48:48,400
So now, if I run to this line, right?

1121
00:48:50,100 --> 00:48:54,000
I will be able to go into the watch window here and I will be able to

1122
00:48:54,000 --> 00:48:54,500
look at mr.

1123
00:48:54,500 --> 00:48:55,400
Pointer, man.

1124
00:48:55,800 --> 00:48:57,600
And what you can do in the Watchman.

1125
00:48:57,600 --> 00:48:58,900
Do this has nothing to do with C.

1126
00:48:58,900 --> 00:48:59,300
By the way.

1127
00:48:59,300 --> 00:49:02,200
This is just something that the watch window supports if you want if

1128
00:49:02,200 --> 00:49:03,400
you have a pointer like mr.

1129
00:49:03,400 --> 00:49:06,200
Pointer man, I showed you in a previous treatment, you can open this

1130
00:49:06,200 --> 00:49:08,800
little plus and it will show you the values that are in it, right?

1131
00:49:08,800 --> 00:49:11,100
It'll show you what the different values actually are.

1132
00:49:12,200 --> 00:49:13,800
And so if I look at mr.

1133
00:49:13,800 --> 00:49:15,500
Pointer, man, oops, man.

1134
00:49:15,500 --> 00:49:19,600
Copy that it'll show me the first value, but I know we already

1135
00:49:19,700 --> 00:49:21,800
I knew that I was estimating it would be 11 B.

1136
00:49:21,800 --> 00:49:23,600
The way the compiler actually packed.

1137
00:49:23,600 --> 00:49:25,600
It was actually 16 bytes, right?

1138
00:49:25,600 --> 00:49:26,900
So it's actually 16.

1139
00:49:28,300 --> 00:49:29,600
Oh, this is going to make me to compile again.

1140
00:49:29,600 --> 00:49:29,900
Isn't it?

1141
00:49:29,900 --> 00:49:31,300
Damn you edit and continue.

1142
00:49:31,300 --> 00:49:32,600
I need to turn it into new off.

1143
00:49:32,800 --> 00:49:33,800
It's ruining my flow.

1144
00:49:34,600 --> 00:49:36,600
So anyway, when I, when I get mr.

1145
00:49:36,600 --> 00:49:39,400
Appointment, I can look at the first one, but I may want to look at

1146
00:49:39,400 --> 00:49:40,800
more of them because it's 16.

1147
00:49:40,800 --> 00:49:41,300
Bytes.

1148
00:49:41,400 --> 00:49:42,600
That's eight shorts.

1149
00:49:42,600 --> 00:49:44,200
That's eight 16-bit values.

1150
00:49:44,300 --> 00:49:48,400
So if I want to look at all of it, I can put comma 8 after it and then

1151
00:49:48,400 --> 00:49:49,900
that will tell it to look at eight values.

1152
00:49:49,900 --> 00:49:52,900
And you can see that it shows me all eight values here, right?

1153
00:49:53,100 --> 00:49:57,400
And what's interesting about this is, you can actually now see, sort

1154
00:49:57,400 --> 00:49:57,600
of

1155
00:49:58,100 --> 00:50:04,700
The the structure thing in action, if you will, we looked at the

1156
00:50:04,700 --> 00:50:07,700
memory before and I will, I will bring it up again.

1157
00:50:08,900 --> 00:50:12,200
16 FC, 38, right.

1158
00:50:12,500 --> 00:50:13,400
We looked at the memory.

1159
00:50:13,400 --> 00:50:17,000
And what we have here is we asked it to interpret as shorts which

1160
00:50:17,000 --> 00:50:20,200
means that even though I wrote a one as the this is on fire.

1161
00:50:20,200 --> 00:50:22,900
It's only wrote eight bits of that and it just use the rest as

1162
00:50:22,900 --> 00:50:23,400
padding.

1163
00:50:23,500 --> 00:50:26,600
So, when I ask it to interpret as a short, it's actually going to grab

1164
00:50:26,600 --> 00:50:28,900
the 2004 and the one, right?

1165
00:50:28,900 --> 00:50:32,800
So it's going to actually use all of that to compute the actual short

1166
00:50:32,800 --> 00:50:33,000
value.

1167
00:50:33,000 --> 00:50:35,300
And I asked to be signed, you know what, since we haven't really done

1168
00:50:35,300 --> 00:50:35,800
signed yet.

1169
00:50:35,800 --> 00:50:37,300
I'm SMS which to unsigned.

1170
00:50:39,300 --> 00:50:39,700
Oops.

1171
00:50:40,800 --> 00:50:43,600
Remember the cast always has to line up and you see that caught

1172
00:50:43,600 --> 00:50:44,000
another.

1173
00:50:44,100 --> 00:50:46,800
Well, it didn't catch an error, but you can see it always warns me at

1174
00:50:46,800 --> 00:50:47,100
the types.

1175
00:50:47,100 --> 00:50:49,700
Don't align so you when you cast something, then the thing that you

1176
00:50:49,700 --> 00:50:51,700
put it into is going to have to be that same type.

1177
00:50:52,200 --> 00:50:57,100
So, anyway, if I go here and I go ahead and look at that memory 38f,

1178
00:50:57,100 --> 00:50:57,600
988,

1179
00:51:00,000 --> 00:51:04,000
I go here at hair and look, it will have grabbed these values so it

1180
00:51:04,000 --> 00:51:07,600
grabbed 204 and that's in the high B.

1181
00:51:07,700 --> 00:51:11,200
So it's 204 times 256 in the high B.

1182
00:51:11,200 --> 00:51:13,800
Plus the one and you can see that comes out to be the value.

1183
00:51:13,800 --> 00:51:15,400
That's actually they're right.

1184
00:51:15,500 --> 00:51:18,700
Because remember the high B start to 256.

1185
00:51:18,700 --> 00:51:23,500
So one in the high B is 286 to is 512 and so on, right?

1186
00:51:23,500 --> 00:51:25,400
So it goes up times 56.

1187
00:51:26,900 --> 00:51:29,900
So that's why that happened is because the garbage that was in

1188
00:51:30,000 --> 00:51:32,000
There beforehand doesn't get a Race.

1189
00:51:32,000 --> 00:51:35,100
So if we start to interpret it, we get garbage, which is exactly

1190
00:51:35,100 --> 00:51:35,500
expect.

1191
00:51:35,500 --> 00:51:37,700
This is 204 204.

1192
00:51:37,700 --> 00:51:40,000
So it's 2 O 4 plus 2.

1193
00:51:40,000 --> 00:51:43,200
6 times 20 for editing continue.

1194
00:51:43,200 --> 00:51:45,100
Why why must you do it?

1195
00:51:45,100 --> 00:51:50,500
You know what I feel like there's got to be a way to turn off edit and

1196
00:51:50,500 --> 00:51:53,100
continued since this is a weekend stream can be a little more

1197
00:51:53,100 --> 00:51:53,800
Meandering.

1198
00:51:54,100 --> 00:51:57,100
I am going to figure out how to turn off this this damn edit and

1199
00:51:57,100 --> 00:51:58,400
continue adding.

1200
00:51:58,400 --> 00:51:59,000
Continue.

1201
00:51:59,400 --> 00:51:59,800
No,

1202
00:52:00,600 --> 00:52:02,300
Don't don't do this.

1203
00:52:02,300 --> 00:52:02,800
How do I?

1204
00:52:02,800 --> 00:52:03,400
Okay?

1205
00:52:03,800 --> 00:52:04,900
No, no, no.

1206
00:52:04,900 --> 00:52:05,400
No.

1207
00:52:05,600 --> 00:52:06,200
All right.

1208
00:52:06,200 --> 00:52:06,700
Hold on a second.

1209
00:52:06,700 --> 00:52:07,700
Maybe we have to stop.

1210
00:52:10,800 --> 00:52:14,200
I want to set the settings and make it never ever do that again.

1211
00:52:14,400 --> 00:52:15,300
No, no, no.

1212
00:52:15,300 --> 00:52:15,600
No.

1213
00:52:15,600 --> 00:52:18,200
No, so view solution.

1214
00:52:18,200 --> 00:52:22,000
Explorer properties is s in here.

1215
00:52:22,000 --> 00:52:22,600
I don't even know.

1216
00:52:22,600 --> 00:52:24,100
No, maybe that was an options.

1217
00:52:24,100 --> 00:52:25,200
Tools options.

1218
00:52:25,400 --> 00:52:26,700
Heading to new in a no.

1219
00:52:26,700 --> 00:52:27,200
There we go.

1220
00:52:27,200 --> 00:52:28,100
Okay, that's what you want.

1221
00:52:28,100 --> 00:52:30,200
It's just off just don't ever do that again.

1222
00:52:30,400 --> 00:52:34,500
I don't ever want to hear from you again ever in the history of time,

1223
00:52:34,600 --> 00:52:36,800
bad at it and continue bad.

1224
00:52:37,000 --> 00:52:39,700
I think with that's trying to do is that's basically trying to let me

1225
00:52:39,800 --> 00:52:40,400
edit code.

1226
00:52:40,600 --> 00:52:41,100
Fly.

1227
00:52:41,100 --> 00:52:44,200
And then keep running, which is not something, I had any interest in

1228
00:52:44,200 --> 00:52:46,500
doing in this particular series.

1229
00:52:46,800 --> 00:52:49,800
All right, so hopefully now let's find out.

1230
00:52:49,900 --> 00:52:50,200
Actually.

1231
00:52:50,200 --> 00:52:54,200
Let me just test this first to see if I do.

1232
00:52:54,200 --> 00:52:55,000
Do do.

1233
00:52:58,400 --> 00:52:59,700
Ah, there we go.

1234
00:52:59,700 --> 00:53:01,400
Okay, so it'll warn me now which is fine.

1235
00:53:01,400 --> 00:53:02,300
I don't mind warning.

1236
00:53:02,500 --> 00:53:06,400
I don't need to turn that off but I just wanted it to stop hassling me

1237
00:53:06,400 --> 00:53:07,900
and Bruce making me restart the program.

1238
00:53:07,900 --> 00:53:11,100
Especially since we're in the mode where it has to rebase all the

1239
00:53:11,100 --> 00:53:11,300
time.

1240
00:53:11,300 --> 00:53:12,900
It's doing the security-based rebasing.

1241
00:53:12,900 --> 00:53:16,600
So I have to type the address in every time in the, in the thing.

1242
00:53:16,800 --> 00:53:20,700
Alright, so back to our regularly, scheduled program.

1243
00:53:21,300 --> 00:53:25,900
If we look in here, we can see the various values as they are getting

1244
00:53:25,900 --> 00:53:26,500
written out.

1245
00:53:26,500 --> 00:53:28,000
And they

1246
00:53:28,100 --> 00:53:29,700
Exactly where we expected them to be.

1247
00:53:29,700 --> 00:53:31,000
Everything is copacetic.

1248
00:53:31,000 --> 00:53:32,800
We see that the values are what we expect.

1249
00:53:32,900 --> 00:53:35,600
Like I was saying, it's 20 4 plus 2 to 6 times, 2 or 4 in the next

1250
00:53:35,600 --> 00:53:39,700
one, which is exactly what we expected to see the next one because it

1251
00:53:39,700 --> 00:53:42,200
was written out as an actual.

1252
00:53:44,200 --> 00:53:50,500
Let's see for a 40 or we go because it was written out as a 32-bit

1253
00:53:50,500 --> 00:53:51,000
value.

1254
00:53:51,600 --> 00:53:55,000
What that'll do is it's going to use this to as the next short, which

1255
00:53:55,000 --> 00:53:58,000
is 20, which is just to again, and then two zeros, which

1256
00:53:58,100 --> 00:53:59,300
Which is zero, right?

1257
00:54:00,000 --> 00:54:02,500
Which is 3 and 0 0, which is 0.

1258
00:54:02,600 --> 00:54:04,400
Then the for was written out as a short.

1259
00:54:04,400 --> 00:54:07,000
So we see it as a short properly, but then there's still two extra

1260
00:54:07,000 --> 00:54:09,700
bytes of padding and we see that number again, which is 204, 204 it

1261
00:54:09,700 --> 00:54:13,400
now, one thing you may be wondering, and I alluded to this in a

1262
00:54:13,400 --> 00:54:15,100
previous dream, but explain it now.

1263
00:54:19,800 --> 00:54:21,600
Is why is everything 2004?

1264
00:54:22,100 --> 00:54:23,100
Why is it 2004?

1265
00:54:23,200 --> 00:54:26,200
If this is just garbage memory that we have initialized yet and

1266
00:54:26,200 --> 00:54:27,300
haven't written anything to.

1267
00:54:27,500 --> 00:54:33,600
Why is it always to of for the answer is because 2004 in hexadecimal,

1268
00:54:34,300 --> 00:54:37,500
is CC do that.

1269
00:54:38,100 --> 00:54:43,900
So, oxc cccccc is basically 204 204, 204 204.

1270
00:54:44,700 --> 00:54:48,900
And what happens when you compile in debug mode in Vin?

1271
00:54:49,600 --> 00:54:50,600
Using visual studio.

1272
00:54:50,600 --> 00:54:53,900
Compiler is that you can turn on a thing and it's turned on by

1273
00:54:53,900 --> 00:54:54,400
default.

1274
00:54:54,400 --> 00:54:57,300
So when I added this, when I made this new project, is turned on the

1275
00:54:57,300 --> 00:54:58,400
default and debug builds.

1276
00:54:58,600 --> 00:55:04,500
There's the thing that basically says, clear all values, 20x CCC CCC

1277
00:55:04,500 --> 00:55:10,100
CCC, CCC and sees, all the way to the end, right CCs in their 2004's

1278
00:55:10,100 --> 00:55:14,500
the whole time, because a lot of Errors come from initial at

1279
00:55:14,600 --> 00:55:17,500
uninitialized values, like a lot of errors in code.

1280
00:55:17,600 --> 00:55:19,400
Come from you, doing something like the thing.

1281
00:55:19,500 --> 00:55:21,900
I alluded to before, like, saying this.

1282
00:55:23,300 --> 00:55:28,300
When I never initialized this, you know, test this is on fire, right?

1283
00:55:28,600 --> 00:55:34,000
So if things were uninitialized, they might default to zero, they

1284
00:55:34,000 --> 00:55:35,500
might default to some value.

1285
00:55:35,500 --> 00:55:39,000
That might work, they might default to some value that you might not

1286
00:55:39,000 --> 00:55:39,500
notice.

1287
00:55:39,900 --> 00:55:42,500
But 0, x cc is very blatant.

1288
00:55:42,600 --> 00:55:44,600
It doesn't come up that often by accident.

1289
00:55:44,700 --> 00:55:48,100
And so what the compiler does to try to help you in debug builds, is

1290
00:55:48,100 --> 00:55:51,900
it just clears the values, 20 x CC so that when you're stepping

1291
00:55:51,900 --> 00:55:53,000
through your code and you get the

1292
00:55:53,100 --> 00:55:55,500
Something like this and you look and you go.

1293
00:55:55,500 --> 00:55:56,900
Oh this this wasn't working.

1294
00:55:56,900 --> 00:55:57,800
Right, what's going on?

1295
00:55:57,800 --> 00:55:59,000
And I look at this is on fire.

1296
00:55:59,000 --> 00:56:02,100
I co X CC and I'm like, oh it's an uninitialized variable.

1297
00:56:02,400 --> 00:56:02,900
Right?

1298
00:56:02,900 --> 00:56:05,700
Whereas if it hadn't done that, maybe it might have been zero because

1299
00:56:05,700 --> 00:56:06,800
that's what was in there before.

1300
00:56:06,800 --> 00:56:08,900
0 is a common value to appear in memory.

1301
00:56:09,000 --> 00:56:09,600
And memory.

1302
00:56:09,600 --> 00:56:12,300
I think on Windows is even zeroed before you get it.

1303
00:56:12,300 --> 00:56:14,000
Normally, because of security concerns.

1304
00:56:14,000 --> 00:56:15,300
It has to erase the memory.

1305
00:56:15,800 --> 00:56:16,300
Hmm.

1306
00:56:17,300 --> 00:56:18,500
In case you were to get physical memory.

1307
00:56:18,500 --> 00:56:20,200
That was occupied by like a password or something.

1308
00:56:20,200 --> 00:56:21,400
That would be a security leak.

1309
00:56:21,900 --> 00:56:22,500
So,

1310
00:56:23,100 --> 00:56:25,800
It might well be 0 which would make you think your code was working

1311
00:56:25,800 --> 00:56:28,000
right up to the point where you accidentally happen to get some

1312
00:56:28,000 --> 00:56:28,200
memory.

1313
00:56:28,200 --> 00:56:30,500
That was recycled from something else and you're saying process and

1314
00:56:30,500 --> 00:56:34,800
it's not set to zero and now all your code is ruined and you don't

1315
00:56:34,800 --> 00:56:37,300
know why and you've got a really hard to find bug because it doesn't

1316
00:56:37,300 --> 00:56:38,000
happen all the time.

1317
00:56:38,000 --> 00:56:40,600
It only happens when that page gets recycled and blah blah blah, very

1318
00:56:40,600 --> 00:56:41,600
hard bugs to find.

1319
00:56:41,800 --> 00:56:46,500
So the reason that everything is 0 x cc is because this is a debug

1320
00:56:46,500 --> 00:56:46,700
build.

1321
00:56:46,700 --> 00:56:50,100
If This Were a real he's build with that feature turned off, we would

1322
00:56:50,100 --> 00:56:51,200
be trying to be more optimal.

1323
00:56:51,200 --> 00:56:52,800
The compiler would not spend its time.

1324
00:56:52,800 --> 00:56:52,900
Clear.

1325
00:56:53,100 --> 00:56:57,000
Alice to Cece because that would be inefficient and you don't want to

1326
00:56:57,000 --> 00:56:59,500
do that in a release build that supposed to be performance-oriented.

1327
00:57:00,100 --> 00:57:00,900
So there you go.

1328
00:57:01,400 --> 00:57:02,900
Okay, so that is casting.

1329
00:57:02,900 --> 00:57:03,800
We've covered endianness.

1330
00:57:03,800 --> 00:57:05,500
We've covered casting recovered structs.

1331
00:57:05,500 --> 00:57:06,700
We've covered hexadecimal.

1332
00:57:07,200 --> 00:57:12,300
The only other thing I wanted to cover today is I wanted to cover the

1333
00:57:13,900 --> 00:57:17,400
the some bitwise operators and some other things about accessing

1334
00:57:17,400 --> 00:57:17,900
structures.

1335
00:57:20,600 --> 00:57:23,600
So we're going to go for maybe about 10 more minutes and get those

1336
00:57:23,600 --> 00:57:25,200
things out before the Q&A.

1337
00:57:26,000 --> 00:57:30,300
So you may be wondering, I know that you are.

1338
00:57:30,400 --> 00:57:32,900
Oh and by the way, just I mean, I'm sure this is kind of starting to

1339
00:57:32,900 --> 00:57:34,500
be obvious by no, you know, what?

1340
00:57:35,300 --> 00:57:37,400
Instead of me having to say it isn't a side, I'll just do it as an

1341
00:57:37,400 --> 00:57:38,600
actual thing because it can lead right in.

1342
00:57:39,200 --> 00:57:40,600
So there's another thing you can do in C.

1343
00:57:41,100 --> 00:57:45,800
It is called array indexing and basically in a lot of other languages

1344
00:57:45,800 --> 00:57:48,300
when you hear the term array, what that means is that means a

1345
00:57:48,300 --> 00:57:50,300
collection of objects that are in

1346
00:57:50,400 --> 00:57:53,700
Next by a value, that is a number.

1347
00:57:53,800 --> 00:57:58,100
So for example, I may have a bunch of projectiles and so in other

1348
00:57:58,100 --> 00:58:02,100
languages, you may see something like this where I type in.

1349
00:58:02,100 --> 00:58:03,300
I want a bunch of projectiles.

1350
00:58:03,300 --> 00:58:06,500
I want 40 projectiles, right?

1351
00:58:06,600 --> 00:58:11,300
And this little bracket syntax here means that I want you to make 40

1352
00:58:11,500 --> 00:58:12,300
of these.

1353
00:58:12,400 --> 00:58:18,200
So instead of me having to do something ridiculous like this, right?

1354
00:58:18,300 --> 00:58:19,300
Blah blah blah blah blah.

1355
00:58:19,300 --> 00:58:20,200
Here's all my project.

1356
00:58:20,400 --> 00:58:23,900
Giles one, two three, right blah blah blah at 40.

1357
00:58:24,200 --> 00:58:25,000
I don't have to do that.

1358
00:58:25,000 --> 00:58:26,200
I can just say, give me 40 of them.

1359
00:58:26,200 --> 00:58:29,900
I know I need for you to just do it and furthermore when it does it,

1360
00:58:29,900 --> 00:58:33,500
instead of it being fine for the compiler to put them anywhere that it

1361
00:58:33,500 --> 00:58:34,200
wants to.

1362
00:58:35,200 --> 00:58:35,700
Well.

1363
00:58:35,900 --> 00:58:40,700
I want them to be laid out at regular intervals in memory so that I

1364
00:58:40,700 --> 00:58:42,200
can access them by an integer.

1365
00:58:42,200 --> 00:58:47,400
So that I can say projectiles for and get the fourth one, predictably,

1366
00:58:47,500 --> 00:58:47,800
right?

1367
00:58:47,800 --> 00:58:50,200
It doesn't have to be me, like, guessing words.

1368
00:58:50,400 --> 00:58:50,900
They are.

1369
00:58:50,900 --> 00:58:54,100
So if I had some if I actually had this the kind of crazy thing I was

1370
00:58:54,100 --> 00:58:59,000
talking about before where I have projectile zero, let's say and I

1371
00:58:59,000 --> 00:59:00,700
have projectile one.

1372
00:59:01,100 --> 00:59:04,500
Let's say I have an integer called which projectile that's going to be

1373
00:59:04,500 --> 00:59:06,700
set to be either 0 or 1, right?

1374
00:59:06,700 --> 00:59:11,600
And I want to be able to use that integer to still doing it.

1375
00:59:11,600 --> 00:59:12,900
You know, I'm just going to cover this right now.

1376
00:59:12,900 --> 00:59:13,800
I've done it too many times.

1377
00:59:13,900 --> 00:59:17,200
You can stick the equals right after the Declaration instead of having

1378
00:59:17,200 --> 00:59:17,900
to do this.

1379
00:59:19,600 --> 00:59:20,600
So I've done it so many times.

1380
00:59:20,600 --> 00:59:22,700
I just need to get it all the way, shouldn't the very first dream.

1381
00:59:23,600 --> 00:59:27,000
So instead of doing this, where I just declare something and then give

1382
00:59:27,000 --> 00:59:29,700
it a value, you can, you can always just do it on the same line.

1383
00:59:29,800 --> 00:59:30,200
It's fine.

1384
00:59:30,300 --> 00:59:30,500
Right?

1385
00:59:30,500 --> 00:59:31,300
So, that's all I was doing.

1386
00:59:31,600 --> 00:59:34,900
So, if I have a value here and I want to use that value to pick one of

1387
00:59:34,900 --> 00:59:35,600
these projectiles.

1388
00:59:35,600 --> 00:59:37,200
There's no easy way to do it.

1389
00:59:37,400 --> 00:59:39,500
I would have to use something that we're going to cover in the next

1390
00:59:39,500 --> 00:59:43,700
stream where I do something like 0, which projectile if it's equal to

1391
00:59:43,700 --> 00:59:49,000
one, then do the thing, you know here do do something to projectile

1392
00:59:49,000 --> 00:59:49,300
one.

1393
00:59:49,400 --> 00:59:57,000
One else do it to projectile to you know zero or something like this

1394
00:59:57,000 --> 00:59:59,800
you would end up in in some kind of bad.

1395
01:00:00,000 --> 01:00:02,700
Relation where you're doing something like this.

1396
01:00:02,700 --> 01:00:06,300
And again, I'll cover what these, what if statement stuff are in the

1397
01:00:06,300 --> 01:00:06,700
next room?

1398
01:00:06,700 --> 01:00:10,100
So I go into it, but I'd have to do something where I actually write

1399
01:00:10,100 --> 01:00:14,200
what's called, control flow code to actually get at the projectile

1400
01:00:14,200 --> 01:00:14,700
that I want.

1401
01:00:14,700 --> 01:00:18,300
And so what I'd rather do is lay them out in memory so that I can just

1402
01:00:18,300 --> 01:00:22,200
use arithmetic to access the one that I want, and that is what happens

1403
01:00:22,300 --> 01:00:23,700
when you use this syntax.

1404
01:00:23,700 --> 01:00:27,000
It lays them out consecutively in memory spaced by a known number

1405
01:00:27,000 --> 01:00:27,800
unknown size.

1406
01:00:27,800 --> 01:00:29,600
Usually the size of the structure itself.

1407
01:00:30,600 --> 01:00:34,400
And then I can use this bracket to just access one of them and I can

1408
01:00:34,400 --> 01:00:37,600
even access them by a variable.

1409
01:00:37,600 --> 01:00:41,500
So if I have, you know, which projectiles for I can do that right now.

1410
01:00:41,500 --> 01:00:45,100
In other languages, this is actually an abstract construct.

1411
01:00:45,100 --> 01:00:47,600
There's nothing you can do with it in a lot of other languages.

1412
01:00:47,600 --> 01:00:49,100
You're just like you got 40 of them.

1413
01:00:49,100 --> 01:00:50,700
You can access them with this syntax.

1414
01:00:50,700 --> 01:00:51,300
That's all, you know.

1415
01:00:53,600 --> 01:00:59,500
When see, that is not the case in see this actually creates just, it's

1416
01:00:59,500 --> 01:01:00,500
just about memory layout.

1417
01:01:00,500 --> 01:01:02,300
All it means is do that memory layout that.

1418
01:01:02,300 --> 01:01:05,400
I just said, which means that you can actually go ahead and do

1419
01:01:05,400 --> 01:01:11,200
something like take that projectile pointer that we had before us take

1420
01:01:11,200 --> 01:01:13,600
that projectile pointer and make the projectile pointer.

1421
01:01:13,600 --> 01:01:15,200
Be equal to the start of the array.

1422
01:01:15,200 --> 01:01:20,000
Right now, you'll notice that normally what you may have expected me

1423
01:01:20,000 --> 01:01:22,300
to have to do, is put the address there, because I said, when we want

1424
01:01:22,300 --> 01:01:23,600
to take the address of something, I need to

1425
01:01:23,500 --> 01:01:26,600
If you address operator, but in see one of the weird things they

1426
01:01:26,600 --> 01:01:30,400
decided to do is make it so that this actually is just a pointer

1427
01:01:30,400 --> 01:01:34,300
arrays aren't really all that different from just having a pointer to

1428
01:01:34,300 --> 01:01:34,600
the beginning.

1429
01:01:34,600 --> 01:01:38,100
So instead of bothering to make you write the syntax, which honestly,

1430
01:01:38,100 --> 01:01:40,300
it may have been better if they had done because there's some reasons

1431
01:01:40,300 --> 01:01:41,600
why it's a little bit wonky.

1432
01:01:41,600 --> 01:01:45,300
There's some things that there are a few things that c does wonky.

1433
01:01:45,300 --> 01:01:46,100
And this is one of them.

1434
01:01:46,100 --> 01:01:48,800
There's reasons why it's a little wonky but I won't belabor them now

1435
01:01:48,800 --> 01:01:50,400
because I think they're really relevant.

1436
01:01:50,400 --> 01:01:53,000
But point being this may have been a better decision depending on how

1437
01:01:53,000 --> 01:01:53,400
you want to look.

1438
01:01:53,600 --> 01:01:56,500
At it basically what happens when you do this is you just end up with

1439
01:01:56,500 --> 01:01:58,700
a pointer to the first one.

1440
01:01:58,800 --> 01:02:00,000
That's what you basically have.

1441
01:02:00,000 --> 01:02:02,600
So if you want to get a pointer to where they are, you end up with

1442
01:02:02,600 --> 01:02:05,300
this, so if I actually go ahead here, compile this

1443
01:02:07,600 --> 01:02:08,800
Oh, hey, look at this.

1444
01:02:09,000 --> 01:02:11,100
So, you know, I was talking about that 0 XE, C thing.

1445
01:02:11,600 --> 01:02:12,400
This is kind of nice.

1446
01:02:12,400 --> 01:02:16,000
It gave me a warning that test was uninitialized when I used it.

1447
01:02:16,000 --> 01:02:17,800
That this, this on fire thing was I'm going to realize.

1448
01:02:17,900 --> 01:02:19,700
So that's kind of doesn't have anything to what we're doing now, but

1449
01:02:19,700 --> 01:02:20,900
it's just it's good to know, right?

1450
01:02:20,900 --> 01:02:22,500
That the compiler will catch some of those for you.

1451
01:02:22,500 --> 01:02:23,300
That's awesome.

1452
01:02:23,400 --> 01:02:25,700
So that was the zeros, xcc thing, as well.

1453
01:02:25,900 --> 01:02:29,500
It's basically got multiple ways to help you not make that mistake.

1454
01:02:29,600 --> 01:02:33,300
It's got the zero X EC to prevent it and it's also got if it can tell,

1455
01:02:33,300 --> 01:02:36,500
if the compiler can look at the code and just obviously tell

1456
01:02:37,400 --> 01:02:39,700
Often times it can't because the codes too complicated and it doesn't

1457
01:02:39,700 --> 01:02:41,100
know where you're getting stuff from.

1458
01:02:41,200 --> 01:02:43,600
But in the case, where it can tell it can give you a warning, which is

1459
01:02:43,600 --> 01:02:44,000
awesome.

1460
01:02:44,100 --> 01:02:44,300
Yeah.

1461
01:02:44,400 --> 01:02:45,100
So those are good.

1462
01:02:46,700 --> 01:02:47,900
Wow, I'm going to type that.

1463
01:02:47,900 --> 01:02:49,800
How many times we going to take this is of Fire.

1464
01:02:51,600 --> 01:02:52,100
There we go.

1465
01:02:52,700 --> 01:02:53,000
All right.

1466
01:02:53,000 --> 01:02:56,300
So if I go ahead and jump down here and I take a look at what I get

1467
01:02:56,700 --> 01:02:59,100
with my projectiles that you can see first of all, in the watch window

1468
01:02:59,100 --> 01:02:59,800
I can ask for

1469
01:03:00,000 --> 01:03:01,900
Projectiles, which is the whole array.

1470
01:03:02,000 --> 01:03:05,000
And if I expand it, you can see, I've got all the ones I asked for it.

1471
01:03:05,000 --> 01:03:05,300
Right?

1472
01:03:05,300 --> 01:03:07,700
I've got all the projectiles are in here and I can look at each

1473
01:03:07,700 --> 01:03:08,600
individual one.

1474
01:03:08,600 --> 01:03:09,100
Right?

1475
01:03:09,100 --> 01:03:11,100
And it's made that structure for me.

1476
01:03:11,300 --> 01:03:13,700
And of course, they're completely uninitialized.

1477
01:03:13,700 --> 01:03:14,200
Crap.

1478
01:03:14,200 --> 01:03:15,000
At this point, right?

1479
01:03:15,000 --> 01:03:18,400
There's nothing, you know, I I haven't written in any of those.

1480
01:03:18,600 --> 01:03:21,900
So they're all oxc cccccc and debug mode.

1481
01:03:21,900 --> 01:03:24,200
Like I said and what you can see, they all have the same values and

1482
01:03:24,200 --> 01:03:24,900
it's all garbage.

1483
01:03:24,900 --> 01:03:26,000
Is all 0.

1484
01:03:26,100 --> 01:03:28,100
It's all 24 2004 as the whole way.

1485
01:03:30,200 --> 01:03:32,900
So because I haven't even in release mode, they would have just been

1486
01:03:32,900 --> 01:03:36,400
whatever, who knows whatever happened to be in that place in memory at

1487
01:03:36,400 --> 01:03:37,800
the time when it reserved it.

1488
01:03:38,500 --> 01:03:39,700
So, that's what I've got.

1489
01:03:39,900 --> 01:03:43,900
And when I look at the address of this zero X zero zero two, five,

1490
01:03:43,900 --> 01:03:44,200
right?

1491
01:03:44,200 --> 01:03:47,500
I can go in here if I want to again and just like everything else.

1492
01:03:47,500 --> 01:03:51,200
I can look at it and see course it's a giant block of 204, is that it

1493
01:03:51,200 --> 01:03:56,200
just initialized to when I look at projectile pointer, right

1494
01:03:56,200 --> 01:03:56,900
projectile.

1495
01:03:57,200 --> 01:03:58,100
Oh, no.

1496
01:03:58,700 --> 01:03:59,800
Okay, my look.

1497
01:04:00,000 --> 01:04:00,800
Decked Out pointer.

1498
01:04:01,700 --> 01:04:03,300
You can see that it's the same value.

1499
01:04:03,400 --> 01:04:06,200
So projectiles a projectile pointer are essentially the same.

1500
01:04:06,400 --> 01:04:06,600
Now.

1501
01:04:06,600 --> 01:04:08,600
The reason that I say that they're essentially the same and not

1502
01:04:08,600 --> 01:04:12,000
exactly the same is because of this little problem right here.

1503
01:04:12,000 --> 01:04:14,400
And this is why I say C is a little wonky, something that's good to be

1504
01:04:14,400 --> 01:04:15,100
aware of.

1505
01:04:15,200 --> 01:04:17,400
If I were to ask how big this is.

1506
01:04:17,400 --> 01:04:19,600
Well, how big do we expect this to be?

1507
01:04:19,600 --> 01:04:20,100
Right?

1508
01:04:20,100 --> 01:04:22,400
How big do they expect an array of 40 projectiles to be?

1509
01:04:22,400 --> 01:04:25,300
Well, we know that the compiler decided to reserve 16, bytes per

1510
01:04:25,300 --> 01:04:25,700
product.

1511
01:04:25,700 --> 01:04:29,800
I'll so we might expect this to be 16 times.

1512
01:04:29,900 --> 01:04:30,400
40.

1513
01:04:30,500 --> 01:04:30,800
Right?

1514
01:04:30,800 --> 01:04:32,700
That's what we would probably expect that to be.

1515
01:04:32,700 --> 01:04:39,500
So if I said size and projectiles, you know, how big is it right arm.

1516
01:04:39,500 --> 01:04:42,400
You know what, let me make this a little better size of projectiles,

1517
01:04:43,000 --> 01:04:43,500
right?

1518
01:04:43,600 --> 01:04:45,900
I would expect it to see that, right?

1519
01:04:45,900 --> 01:04:52,100
But if I ask for size of projectile pointer, right, what is the size

1520
01:04:52,100 --> 01:04:53,500
of projectile, pointer?

1521
01:04:54,700 --> 01:04:57,600
Well, I would expect to see something else now because I know what it

1522
01:04:57,600 --> 01:04:57,900
is.

1523
01:04:57,900 --> 01:05:01,200
I expect to see for because I believe pointers to be 4, bytes on the

1524
01:05:01,200 --> 01:05:04,100
thing that I compiling to and this is a pointer, right?

1525
01:05:04,100 --> 01:05:05,300
So I'm going to actually double check.

1526
01:05:05,300 --> 01:05:06,500
Those are both case.

1527
01:05:06,700 --> 01:05:11,200
So we look on here and we say size of projectiles and size of

1528
01:05:11,200 --> 01:05:12,100
projectile.

1529
01:05:13,200 --> 01:05:14,700
Projectile pointer.

1530
01:05:15,100 --> 01:05:15,600
Yep.

1531
01:05:15,600 --> 01:05:20,000
That's what we thought 16 times 40 is, in fact 640, everyone's happy,

1532
01:05:20,100 --> 01:05:21,800
exactly what we thought, but

1533
01:05:22,500 --> 01:05:27,200
I will point out that is the little bit of a snafu so I can set this

1534
01:05:27,200 --> 01:05:28,500
equal to this thing.

1535
01:05:28,500 --> 01:05:28,900
Right?

1536
01:05:28,900 --> 01:05:31,800
I can say that projectile pointer equals projectiles, which means that

1537
01:05:31,800 --> 01:05:34,100
c is and it didn't give me a warning or an error.

1538
01:05:34,100 --> 01:05:39,800
Anything see is agreeing with me that projectiles is just a pointer to

1539
01:05:40,400 --> 01:05:44,100
the first one and and that, you know, that totally worked and we saw

1540
01:05:44,100 --> 01:05:44,500
it work.

1541
01:05:44,500 --> 01:05:45,700
We know that's what it does.

1542
01:05:46,100 --> 01:05:52,000
But even though that's the case, see secretly understands during the,

1543
01:05:52,000 --> 01:05:52,200
you know.

1544
01:05:52,300 --> 01:05:54,700
Oh, in a place where it can see this definition, it secretly

1545
01:05:54,700 --> 01:05:55,400
understands.

1546
01:05:55,400 --> 01:05:59,000
Actually, how big it is such that when I ask, even though he knows

1547
01:05:59,000 --> 01:05:59,800
it's functional.

1548
01:06:00,000 --> 01:06:00,500
Pointer.

1549
01:06:00,800 --> 01:06:02,100
And I can treat it as a pointer.

1550
01:06:02,100 --> 01:06:03,700
I can I can do that with it.

1551
01:06:04,100 --> 01:06:07,000
It's not really treating it as a pointer because it actually does

1552
01:06:07,000 --> 01:06:08,800
remember that it's this bigger thing.

1553
01:06:09,100 --> 01:06:12,200
And so that's why I say it's a little wonky because really these

1554
01:06:12,200 --> 01:06:13,700
aren't exactly the same type.

1555
01:06:13,700 --> 01:06:15,700
And so this probably should just fail.

1556
01:06:15,700 --> 01:06:18,900
The probably should have thought of it a little differently but, you

1557
01:06:18,900 --> 01:06:20,700
know, see is a great language.

1558
01:06:20,700 --> 01:06:22,600
I'm not here to second-guess their design decisions.

1559
01:06:22,600 --> 01:06:23,900
Maybe there's good reasons for it.

1560
01:06:23,900 --> 01:06:24,500
I don't know.

1561
01:06:25,100 --> 01:06:28,200
But point being, it does seem like that's one of the places where C is

1562
01:06:28,200 --> 01:06:29,800
maybe not quite as watertight.

1563
01:06:30,000 --> 01:06:31,100
As one would have hoped.

1564
01:06:31,200 --> 01:06:33,500
So there you go.

1565
01:06:34,000 --> 01:06:36,400
Alright, so that's what's called array syntax.

1566
01:06:36,400 --> 01:06:40,800
And this is a ray accessor, which allows you to pull out individual

1567
01:06:40,800 --> 01:06:41,000
things.

1568
01:06:41,000 --> 01:06:44,700
And what I wanted to demonstrate for you was that array syntax is

1569
01:06:44,700 --> 01:06:47,500
really, it's complete shorthand.

1570
01:06:47,500 --> 01:06:50,100
It's all it is is just shorthand for messing with memory.

1571
01:06:50,100 --> 01:06:56,300
So if I wanted to, for example, talk about the 30th projectile, right?

1572
01:06:56,300 --> 01:06:57,300
And we talked about the 33 act.

1573
01:06:57,300 --> 01:06:59,900
Well, I'm gonna set the 30s projectile damage to

1574
01:07:00,000 --> 01:07:01,500
See, that's what I'm going to do.

1575
01:07:02,400 --> 01:07:04,300
What this actually translates into.

1576
01:07:04,600 --> 01:07:10,300
Okay is nothing more than the pointer to the base of it, right?

1577
01:07:10,300 --> 01:07:16,800
The pointer to the base of it, plus 30 times, the size of a

1578
01:07:16,800 --> 01:07:19,800
projectile, one projectile, right?

1579
01:07:21,600 --> 01:07:22,500
Dot damage.

1580
01:07:23,200 --> 01:07:27,400
Actually, I'm at talk about what this guy is right here in a second.

1581
01:07:27,500 --> 01:07:33,000
But if I wanted to, I could use this exact same syntax to access the

1582
01:07:33,000 --> 01:07:33,600
30th one.

1583
01:07:33,600 --> 01:07:34,900
And I'll talk about what this guy is saying to me.

1584
01:07:34,900 --> 01:07:36,800
It's another weird cc is MM.

1585
01:07:37,300 --> 01:07:40,300
But this is basically the same as this dot operator up here, but I'll

1586
01:07:40,300 --> 01:07:42,700
talk about why I couldn't use the dot in a second.

1587
01:07:42,700 --> 01:07:44,700
So if I wanted to do that.

1588
01:07:46,200 --> 01:07:46,700
Hello.

1589
01:07:47,300 --> 01:07:48,100
What is the problem?

1590
01:07:51,200 --> 01:07:52,300
Compile compile.

1591
01:07:52,300 --> 01:07:56,400
There we go, projectile Undeclared, identifier UPS projectiles.

1592
01:07:58,000 --> 01:07:58,500
There we go.

1593
01:07:58,800 --> 01:08:00,800
Spelling errors, always good.

1594
01:08:00,900 --> 01:08:04,700
Okay, so if I want to look at this, I'm going to look at the

1595
01:08:04,700 --> 01:08:05,100
projector.

1596
01:08:05,100 --> 01:08:06,200
I'm gonna get projectile, 30.

1597
01:08:06,200 --> 01:08:09,700
Like I said, and I'm gonna expect it to be set to 60 and Hey, look,

1598
01:08:09,800 --> 01:08:10,700
it's set to 60.

1599
01:08:10,700 --> 01:08:13,900
In fact, you know what, let's let's just double-check will make sure

1600
01:08:13,900 --> 01:08:15,100
that it's all going, right?

1601
01:08:15,600 --> 01:08:16,000
Stop.

1602
01:08:16,000 --> 01:08:16,700
Stop everyone.

1603
01:08:16,700 --> 01:08:17,200
Stop.

1604
01:08:17,399 --> 01:08:19,600
No, don't do it.

1605
01:08:21,100 --> 01:08:21,399
Yes.

1606
01:08:21,399 --> 01:08:21,899
There we go.

1607
01:08:22,200 --> 01:08:22,600
Okay.

1608
01:08:25,899 --> 01:08:26,800
One of the thing I need.

1609
01:08:27,399 --> 01:08:30,399
Sorry, it's bringing out more things than I more things than I was

1610
01:08:30,399 --> 01:08:31,100
hoping for.

1611
01:08:32,000 --> 01:08:32,700
Hmm.

1612
01:08:32,899 --> 01:08:33,500
All right.

1613
01:08:34,700 --> 01:08:37,399
This is my first tip bad teaching mistake that I've made.

1614
01:08:37,600 --> 01:08:38,200
All right.

1615
01:08:38,300 --> 01:08:40,000
Well, we're going to take this in two steps.

1616
01:08:40,100 --> 01:08:43,000
I just realized that the thing that I wanted to do, you can't quite

1617
01:08:43,000 --> 01:08:43,800
show directly.

1618
01:08:44,200 --> 01:08:44,800
So all right.

1619
01:08:44,800 --> 01:08:48,100
We gotta show this, I'll show this first and then I'll show this, it's

1620
01:08:48,100 --> 01:08:49,300
just it's just crazy.

1621
01:08:49,300 --> 01:08:52,700
How much syntax I have to do to show the thing that I wanted to do.

1622
01:08:53,600 --> 01:08:54,399
So, okay.

1623
01:08:54,500 --> 01:08:54,800
Yeah.

1624
01:08:55,500 --> 01:08:58,200
Sorry, it's a little more.

1625
01:08:58,200 --> 01:08:59,100
It's a little more.

1626
01:09:00,800 --> 01:09:04,600
Involved, I guess I would say then then then what I had hoped for.

1627
01:09:04,600 --> 01:09:05,899
Okay, let's do that again.

1628
01:09:06,300 --> 01:09:10,500
Alright, so back to where we are and I will promise, I'll explain all

1629
01:09:10,500 --> 01:09:11,300
of that in a second.

1630
01:09:11,300 --> 01:09:12,700
I'm not trying to hand wave on you.

1631
01:09:12,700 --> 01:09:14,800
It's just I realized that the thing I was trying to do wouldn't

1632
01:09:14,800 --> 01:09:17,899
actually work the way that I wanted to show you how to do it, because

1633
01:09:17,899 --> 01:09:18,899
it involves more casting.

1634
01:09:18,899 --> 01:09:20,100
So we're gonna have to get to that second.

1635
01:09:20,399 --> 01:09:24,899
So we see that damage is set to 60 on the 30th projectile, which is

1636
01:09:24,899 --> 01:09:26,100
exactly what I was trying to do.

1637
01:09:26,300 --> 01:09:28,800
Now, what I wanted to show you as well, is that I can also choose to

1638
01:09:28,800 --> 01:09:29,800
point arithmetic, but the

1639
01:09:30,000 --> 01:09:33,000
Thing is see tries to be helpful.

1640
01:09:33,500 --> 01:09:36,800
And I kind of didn't think about this when I was going to type it in.

1641
01:09:36,800 --> 01:09:39,399
But, you know, when I'm actually coding, it's second nature.

1642
01:09:39,399 --> 01:09:40,000
You would know this.

1643
01:09:40,000 --> 01:09:42,399
It's just that I was trying to think teaching wise.

1644
01:09:42,700 --> 01:09:43,800
So I got a little ahead of myself.

1645
01:09:43,800 --> 01:09:47,200
But what see does when it does pointer arithmetic like this.

1646
01:09:47,200 --> 01:09:50,600
When I look at when I when I take a pointer to some place and memory

1647
01:09:50,600 --> 01:09:54,100
and I add something to it, actually uses the type that you have told

1648
01:09:54,100 --> 01:09:57,900
it that it was which was projectile, projectile pointer is a

1649
01:09:57,900 --> 01:09:58,400
projectile.

1650
01:09:58,700 --> 01:09:59,900
It uses the type that

1651
01:10:00,000 --> 01:10:03,700
Told you it was and it actually automatically does the multiplication

1652
01:10:03,700 --> 01:10:04,200
for you.

1653
01:10:04,300 --> 01:10:07,900
So I want to show you how to do this multiplication, but actually see

1654
01:10:07,900 --> 01:10:08,800
will do this multiplication.

1655
01:10:08,800 --> 01:10:12,100
It's going to automatically multiplied by the size of the projectile

1656
01:10:12,100 --> 01:10:12,900
when I add 30.

1657
01:10:12,900 --> 01:10:18,700
So this here is actually this see just inserts that multiplication for

1658
01:10:18,700 --> 01:10:18,900
you.

1659
01:10:19,000 --> 01:10:23,200
So it knows I'm trying to go by projectiles and it adds 30 times that

1660
01:10:23,200 --> 01:10:27,200
so when I look at this, what I'm actually looking at as 30 times 16

1661
01:10:27,400 --> 01:10:29,800
down from the start of projectile pointer and then

1662
01:10:29,900 --> 01:10:32,000
Then I set the damage equal to 100.

1663
01:10:32,000 --> 01:10:34,500
So, now, if we execute this line, right, you will see that it did

1664
01:10:34,500 --> 01:10:35,200
exactly what it said.

1665
01:10:35,200 --> 01:10:35,400
It would.

1666
01:10:35,400 --> 01:10:38,700
Do it sets it to 100, so I can actually do the point arithmetic

1667
01:10:38,700 --> 01:10:39,600
myself, right?

1668
01:10:39,900 --> 01:10:42,600
But what I want to show you what to do it entirely manually.

1669
01:10:42,800 --> 01:10:47,100
And in order to do that, what I have to do is first for C, using a

1670
01:10:47,100 --> 01:10:47,700
cast.

1671
01:10:47,700 --> 01:10:51,600
Just, like I said before, to treat this pointer, as if it was pointing

1672
01:10:51,600 --> 01:10:53,900
to only 8 Bits, which is care, right?

1673
01:10:54,100 --> 01:10:57,500
Then I can do the ad in individual bytes.

1674
01:10:58,100 --> 01:10:59,800
Then I can cast it back to a

1675
01:11:00,000 --> 01:11:04,900
Tactile to access the damage member of it, which will set it to 100.

1676
01:11:05,100 --> 01:11:06,000
Does that make sense?

1677
01:11:06,200 --> 01:11:07,600
And that will do exactly that.

1678
01:11:07,600 --> 01:11:08,000
Of course.

1679
01:11:08,000 --> 01:11:09,200
We already had it had to 100.

1680
01:11:09,200 --> 01:11:11,500
So it's just going to set it to 100 an approach to me that different

1681
01:11:11,500 --> 01:11:11,800
value.

1682
01:11:13,000 --> 01:11:16,300
So, let's take that a little bit more slowly since I had to sort of,

1683
01:11:16,300 --> 01:11:19,400
whip out a bunch of stuff that I kind of didn't want to have to whip

1684
01:11:19,400 --> 01:11:20,200
out just at that point.

1685
01:11:20,200 --> 01:11:22,600
But, you know, what, you going to do programming is complicated.

1686
01:11:22,600 --> 01:11:24,300
Sometimes you got to roll with it.

1687
01:11:24,700 --> 01:11:28,100
So yes, this is actually a little more straightforward.

1688
01:11:28,100 --> 01:11:29,800
Hopefully, this is understandable there.

1689
01:11:29,900 --> 01:11:33,900
The reason that I enclosed this in parentheses is because parentheses

1690
01:11:33,900 --> 01:11:36,400
much like they do in math help to group things together.

1691
01:11:36,400 --> 01:11:38,100
So, the compiler knows what order to do things.

1692
01:11:38,200 --> 01:11:41,600
You can imagine that if I had written this, right, it would be very

1693
01:11:41,600 --> 01:11:43,900
confusing for the compiler because it looks like I'm trying to access

1694
01:11:43,900 --> 01:11:46,900
the damage member of 30, which doesn't make any sense.

1695
01:11:47,200 --> 01:11:48,900
So the parentheses just allow it to know.

1696
01:11:48,900 --> 01:11:49,200
Okay.

1697
01:11:49,200 --> 01:11:51,700
I'm trying to add 32 projectile pointer, which gives me a new

1698
01:11:51,700 --> 01:11:54,400
projectile pointer that happens to be 30, projectiles down from where

1699
01:11:54,400 --> 01:11:55,200
it started.

1700
01:11:55,400 --> 01:11:58,700
And then I'm going to, you know, make that damage equal to 100 makes

1701
01:11:58,700 --> 01:11:59,500
makes reasonable sense.

1702
01:12:00,000 --> 01:12:03,900
Now what this catastrophic line is, right, is this is actually doing a

1703
01:12:03,900 --> 01:12:05,000
series of operations.

1704
01:12:05,100 --> 01:12:05,500
First.

1705
01:12:05,500 --> 01:12:08,700
It is making a bite pointer that just points to B, and it's making a

1706
01:12:08,700 --> 01:12:11,400
bite pointer by doing this operation, right?

1707
01:12:11,400 --> 01:12:14,200
Remember I said, casting turn something into a type that it wasn't

1708
01:12:14,200 --> 01:12:14,500
before.

1709
01:12:14,500 --> 01:12:16,300
It just says, Hey see, trust me.

1710
01:12:16,500 --> 01:12:18,900
And remember, really this is to get rid of the error.

1711
01:12:19,000 --> 01:12:20,800
It's not really changing what the code does.

1712
01:12:20,800 --> 01:12:21,600
In any particular way.

1713
01:12:21,600 --> 01:12:23,600
It's just to get rid of the air that I would get, right?

1714
01:12:23,600 --> 01:12:27,000
You see, I get an error there because this is a part or projectile and

1715
01:12:27,000 --> 01:12:28,100
I wanted a projector to a care.

1716
01:12:28,100 --> 01:12:29,800
I can't just do that without telling see hey.

1717
01:12:30,000 --> 01:12:31,500
Hey relax, it's cool.

1718
01:12:31,600 --> 01:12:32,300
I know what I'm doing.

1719
01:12:32,300 --> 01:12:33,900
I'm a professional programmer.

1720
01:12:34,000 --> 01:12:35,800
So I'm going to do the cast and it's good.

1721
01:12:36,200 --> 01:12:36,900
So there we go.

1722
01:12:37,800 --> 01:12:38,300
That's fine.

1723
01:12:38,500 --> 01:12:39,700
I'm creating a bite pointer.

1724
01:12:40,000 --> 01:12:40,200
Now.

1725
01:12:40,200 --> 01:12:44,900
I want to move the bike pointer forwards right by the right amount.

1726
01:12:44,900 --> 01:12:50,800
So that is 30 times the size of the projectile, right?

1727
01:12:50,800 --> 01:12:54,200
That will get me to where I want to be but you know, and I can

1728
01:12:54,400 --> 01:12:56,000
certainly compile this code.

1729
01:12:56,000 --> 01:12:59,800
You can see that it all works, but I can't now do B pointer.

1730
01:13:00,100 --> 01:13:04,000
Arrow damage equals 200, right?

1731
01:13:04,000 --> 01:13:06,500
If I were to try and try and do that, I get an error.

1732
01:13:06,800 --> 01:13:09,400
And the reason I got an error is because this is a point to a car and

1733
01:13:09,400 --> 01:13:11,000
a car is just eight bits.

1734
01:13:11,100 --> 01:13:12,000
Totally Anonymous.

1735
01:13:12,000 --> 01:13:14,800
There is no such thing as damage of those.

1736
01:13:14,900 --> 01:13:15,400
Right?

1737
01:13:15,600 --> 01:13:20,200
And so what what I have to do before I can do that is I have to turn

1738
01:13:20,200 --> 01:13:23,900
that pointer back into a projectile pointer, right?

1739
01:13:23,900 --> 01:13:27,500
I have to do projectile pointer 30, right?

1740
01:13:27,500 --> 01:13:29,800
And then I can cast back just like I was

1741
01:13:29,900 --> 01:13:34,600
Doing before by pointer like this, and now I can use that that pointer

1742
01:13:34,700 --> 01:13:37,300
will work right and you can see that works fine.

1743
01:13:37,600 --> 01:13:38,200
So

1744
01:13:39,600 --> 01:13:41,200
That is the crazy Shenanigans.

1745
01:13:41,200 --> 01:13:43,700
You have to do to do the pointer of the because C is trying to help

1746
01:13:43,700 --> 01:13:44,100
you out.

1747
01:13:44,100 --> 01:13:48,300
It's trying to help you not have to remember or not have to know at

1748
01:13:48,300 --> 01:13:49,700
that particular point in the code.

1749
01:13:49,700 --> 01:13:51,600
What you would need to add to it.

1750
01:13:51,600 --> 01:13:53,000
In order to get you 30 things down.

1751
01:13:53,000 --> 01:13:55,700
It wants you to be able to just use the 30 directly which is kind of

1752
01:13:55,700 --> 01:13:56,000
helpful.

1753
01:13:56,000 --> 01:13:56,600
Most of the time.

1754
01:13:56,600 --> 01:13:57,700
It is what you want.

1755
01:13:57,800 --> 01:14:00,700
But for purposes of this demonstration where I wanted to show you how

1756
01:14:00,700 --> 01:14:02,800
the memory is something that's directly controllable by you.

1757
01:14:02,800 --> 01:14:05,200
And you can actually go in at the byte level and poke everything.

1758
01:14:05,200 --> 01:14:07,800
I just wanted to show you that you can move these things around and do

1759
01:14:07,800 --> 01:14:08,800
the array accesses yourself.

1760
01:14:08,800 --> 01:14:09,200
So,

1761
01:14:09,300 --> 01:14:13,100
Line is nothing other than this magic sequence right here, or this

1762
01:14:13,100 --> 01:14:15,300
sequence right here and you can see what I did.

1763
01:14:15,400 --> 01:14:19,000
This is just exactly the previous thing, right?

1764
01:14:19,000 --> 01:14:21,900
Justin more concise in it all wrapped up in one line.

1765
01:14:22,200 --> 01:14:22,600
First.

1766
01:14:22,600 --> 01:14:24,400
I cast it to a caressed are right, that right.

1767
01:14:24,400 --> 01:14:26,800
There, is this right?

1768
01:14:26,900 --> 01:14:29,300
Then I added 30 times the size of it.

1769
01:14:29,400 --> 01:14:31,100
That's this right?

1770
01:14:31,200 --> 01:14:33,500
Then I cast it back to a projectile.

1771
01:14:33,700 --> 01:14:34,800
That's this.

1772
01:14:35,200 --> 01:14:36,900
Then I access the damage member.

1773
01:14:36,900 --> 01:14:37,700
That's this.

1774
01:14:38,000 --> 01:14:39,100
So I just wrapped all that.

1775
01:14:39,200 --> 01:14:41,100
Up into one line, and you can always do that.

1776
01:14:41,100 --> 01:14:44,300
And see, you can wrap crazy amounts of stuff into one little

1777
01:14:44,300 --> 01:14:45,300
expression if you want to.

1778
01:14:45,700 --> 01:14:50,100
So, the final thing that I wanted to talk about, I guess because the

1779
01:14:50,100 --> 01:14:52,000
stream is about up now.

1780
01:14:52,300 --> 01:14:53,100
I don't know if I want to.

1781
01:14:53,300 --> 01:14:55,100
I think I'm going to say the other thing I'm going to talk about till

1782
01:14:55,100 --> 01:14:58,100
next time is this Arrow, right?

1783
01:14:58,200 --> 01:14:59,000
Cuz I kind of wave does.

1784
01:14:59,000 --> 01:14:59,800
I got the air has to be

1785
01:15:00,000 --> 01:15:00,400
The dart.

1786
01:15:00,400 --> 01:15:02,500
Whatever, what does that actually mean?

1787
01:15:02,700 --> 01:15:05,900
Well, in see there's a difference between a pointer and an actual

1788
01:15:05,900 --> 01:15:06,200
thing.

1789
01:15:06,600 --> 01:15:11,800
So if I say projectile test, like I did up above right, this thing

1790
01:15:11,800 --> 01:15:13,700
right here, right?

1791
01:15:13,700 --> 01:15:17,100
If I say projectile test then accessing it looks like this.

1792
01:15:17,200 --> 01:15:19,100
That's how acts as a test dot the thing.

1793
01:15:19,400 --> 01:15:23,000
But if I say projectile STAR test, so I have a pointer to a test,

1794
01:15:23,000 --> 01:15:23,300
right?

1795
01:15:23,300 --> 01:15:25,200
And I'm actually talking about the pointer itself.

1796
01:15:25,400 --> 01:15:27,100
I have to use the arrow syntax.

1797
01:15:27,400 --> 01:15:29,900
There is no difference between these two things other than

1798
01:15:30,000 --> 01:15:31,300
That, that is the only difference.

1799
01:15:31,400 --> 01:15:32,000
It is strictly.

1800
01:15:32,000 --> 01:15:35,000
Whether the thing you have is declared to be a pointer or whether

1801
01:15:35,000 --> 01:15:35,600
you're talking about.

1802
01:15:35,600 --> 01:15:38,400
The actual thing on the actual stack.

1803
01:15:38,400 --> 01:15:43,700
That is the only difference there really is, absolutely no reason for

1804
01:15:43,700 --> 01:15:46,600
this distinction and it's another one of the places that I think she

1805
01:15:46,600 --> 01:15:47,500
is a little wonky.

1806
01:15:47,700 --> 01:15:48,900
Really probably.

1807
01:15:48,900 --> 01:15:52,100
What should have happened is this should have just been considered a

1808
01:15:52,100 --> 01:15:55,700
pointer and it should always have just been got to access everything

1809
01:15:55,700 --> 01:15:56,700
or something like that.

1810
01:15:56,700 --> 01:15:58,600
But again, not a language designer.

1811
01:15:58,700 --> 01:15:59,800
I don't really want a second case.

1812
01:16:00,000 --> 01:16:01,200
Second-guess the C++ to be.

1813
01:16:01,200 --> 01:16:02,500
I'm going to see designers.

1814
01:16:02,700 --> 01:16:05,100
So I'm not going to say that was necessarily good or bad.

1815
01:16:05,100 --> 01:16:07,700
I'm just going to say it does seem to be a little bit wonky because

1816
01:16:07,900 --> 01:16:11,800
they don't really do anything different and there's almost even no way

1817
01:16:11,800 --> 01:16:13,300
to make a bug out of it.

1818
01:16:13,300 --> 01:16:17,100
Like it's not like it can catch a bug if I had that as a dot, it

1819
01:16:17,100 --> 01:16:17,500
really?

1820
01:16:17,900 --> 01:16:19,200
It doesn't even help that.

1821
01:16:19,200 --> 01:16:20,400
It's going to tell me it's wrong, right?

1822
01:16:20,400 --> 01:16:22,100
Like the fact that it tells me it's wrong.

1823
01:16:22,500 --> 01:16:23,400
There's almost nothing else.

1824
01:16:23,400 --> 01:16:26,600
I could have meant there other than other than Arrow, so, it's, yeah,

1825
01:16:26,600 --> 01:16:29,000
it's really kind of weird that it's even a thing.

1826
01:16:29,000 --> 01:16:29,800
It's just

1827
01:16:29,900 --> 01:16:30,900
Doesn't make a lot of sense.

1828
01:16:31,000 --> 01:16:32,300
So anyway, that's the only other thing.

1829
01:16:32,300 --> 01:16:36,100
I want to carrot to to mention is that the arrow syntax and the dot

1830
01:16:36,100 --> 01:16:39,000
syntax, you have to know whether you were dealing with a pointer or

1831
01:16:39,000 --> 01:16:42,200
whether you're dealing with actually a thing on the stack in order to

1832
01:16:42,200 --> 01:16:43,500
know which one of them to use.

1833
01:16:43,600 --> 01:16:47,900
But fortunately the compiler always tells you and the answer is always

1834
01:16:47,900 --> 01:16:48,800
just to switch it.

1835
01:16:48,900 --> 01:16:51,300
So if you were the person who typed this you would instantly get a

1836
01:16:51,300 --> 01:16:53,500
compile error, the compiler error would tell exactly where it was.

1837
01:16:53,500 --> 01:16:56,800
It would say must have a class structure Union type of projectile.

1838
01:16:56,800 --> 01:16:58,300
Did you intend to use Arrow?

1839
01:16:58,300 --> 01:16:59,800
It even gives you the recommendation in the answer?

1840
01:17:00,000 --> 01:17:02,700
Yes, I did intend to use Arrow.

1841
01:17:03,200 --> 01:17:07,000
So I think that is everything that I wanted to cover today.

1842
01:17:07,000 --> 01:17:11,200
It's basically how to do memory layout, using struts which we did and

1843
01:17:11,200 --> 01:17:12,400
it was sort of showed you some of the things.

1844
01:17:12,600 --> 01:17:16,200
There is one thing I did not mention, which I will mention very

1845
01:17:16,200 --> 01:17:16,700
quickly.

1846
01:17:16,700 --> 01:17:19,200
I don't think it's maybe something you really need to know, but there

1847
01:17:19,200 --> 01:17:24,600
is a thing called a pragma which we didn't cover Loops that you can

1848
01:17:24,600 --> 01:17:24,900
use.

1849
01:17:24,900 --> 01:17:27,800
Also something called an attribute, you can use depending on the

1850
01:17:27,800 --> 01:17:29,700
compiler, you can use

1851
01:17:29,900 --> 01:17:33,700
Extra like things that are outside of the scope of the language

1852
01:17:33,700 --> 01:17:36,800
necessarily it certainly outside scope of the original, see that you

1853
01:17:36,800 --> 01:17:41,400
can put, that will allow you to wrap projectile or any struct in a way

1854
01:17:41,400 --> 01:17:44,000
that tells the compiler that they have to be packed.

1855
01:17:44,000 --> 01:17:46,200
So, remember when I said, okay, we expected 11, B.

1856
01:17:46,200 --> 01:17:50,000
We got 16, if you really care and you know, that you need to be.

1857
01:17:50,000 --> 01:17:53,500
So there are ways to turn off that padding.

1858
01:17:53,500 --> 01:17:56,400
It's saying, hey look, I know there might be a performance penalty.

1859
01:17:56,500 --> 01:17:59,100
I realize, you know, I'm putting you out here mr.

1860
01:17:59,100 --> 01:17:59,700
Compiler.

1861
01:18:00,000 --> 01:18:03,300
But please, I really need you to pack these things tightly and it will

1862
01:18:03,300 --> 01:18:03,800
do it.

1863
01:18:03,800 --> 01:18:04,900
So, there are ways.

1864
01:18:04,900 --> 01:18:07,700
I'm not going to cover them right now, but there are ways of telling

1865
01:18:07,700 --> 01:18:09,500
it to pack something tightly.

1866
01:18:09,500 --> 01:18:10,500
When you need it pack tightly.

1867
01:18:10,500 --> 01:18:13,100
Just most of the time, you don't need things packed, tightly.

1868
01:18:13,200 --> 01:18:15,700
So you'd rather have it optimize them for.

1869
01:18:15,700 --> 01:18:18,800
However, whatever platform you're compiling to lay them out, in the

1870
01:18:18,800 --> 01:18:20,600
most sensible way for performance.

1871
01:18:21,400 --> 01:18:23,800
And I think that is basically everything.

1872
01:18:24,400 --> 01:18:26,000
I'm not going to cover a bitwise operators.

1873
01:18:26,000 --> 01:18:29,600
I'm going to do them next stream tomorrow, so hopefully

1874
01:18:30,000 --> 01:18:30,900
I'm really glad that.

1875
01:18:30,900 --> 01:18:32,300
I think there's a fair number of people.

1876
01:18:32,300 --> 01:18:34,500
There's there's us over 200 people on the stream.

1877
01:18:34,500 --> 01:18:37,800
That's awesome for sort of an impromptu Saturday stream.

1878
01:18:37,800 --> 01:18:39,000
So thank you so much.

1879
01:18:39,000 --> 01:18:40,300
Everyone for showing up.

1880
01:18:40,300 --> 01:18:44,100
It has been a another delightful coding session with all of you and I

1881
01:18:44,100 --> 01:18:49,000
am going to stop the recording now and I will restart it in a second

1882
01:18:49,000 --> 01:18:51,600
for Q&A, which will go for probably about 30 minutes.

1883
01:18:51,600 --> 01:18:55,000
So thanks so much for joining me and I will see you tomorrow.

1884
01:18:55,000 --> 01:18:59,400
If you would like to finish up, our intro to see series before we move

1885
01:18:59,400 --> 01:18:59,800
on.

1886
01:19:00,100 --> 01:19:03,800
To the full handmade hero stream on Monday.

