1
00:00:01,200 --> 00:00:04,100
Alright, hello everyone and welcome to handmade here of the show.

2
00:00:04,100 --> 00:00:07,000
We could complete game live on stream today.

3
00:00:07,000 --> 00:00:11,700
We are going to talk about shaders because we need to put shaders into

4
00:00:11,700 --> 00:00:16,700
the game for possibly some some effects reasons.

5
00:00:16,700 --> 00:00:20,700
Obviously we might want to do some things with Lighting in the future

6
00:00:20,700 --> 00:00:22,900
that would require us to have a Shader in there.

7
00:00:22,900 --> 00:00:26,100
But the more pressing need in the reason that we're doing them, at the

8
00:00:26,100 --> 00:00:30,500
immediate moment is just because we have to do some modification of

9
00:00:30,700 --> 00:00:30,800
the

10
00:00:30,900 --> 00:00:35,500
You values that are used for z-buffering in the game and I am pretty

11
00:00:35,500 --> 00:00:39,900
sure that the most efficient way to support that rather than monkeying

12
00:00:39,900 --> 00:00:45,700
with vertices when they are output at runtime is actually instead to

13
00:00:46,200 --> 00:00:49,900
in the Shader taken additional coordinate that will tell the Shader to

14
00:00:49,900 --> 00:00:54,200
go ahead and tweak the resulting Z values after the transform that I

15
00:00:54,200 --> 00:00:58,100
think will be the most efficient thing for us to do.

16
00:00:58,800 --> 00:01:00,700
We will see in a second if that's actually true,

17
00:01:00,900 --> 00:01:02,100
not, but I'm pretty sure it is.

18
00:01:02,300 --> 00:01:07,000
So in order to get there though, I've got to explain a bunch of stuff,

19
00:01:07,100 --> 00:01:10,700
so hopefully we can get through that in a relatively short amount of

20
00:01:10,700 --> 00:01:11,100
time.

21
00:01:13,000 --> 00:01:16,800
And then we can move on to actually trying to get one of the shaders

22
00:01:16,800 --> 00:01:19,600
working in game two.

23
00:01:19,600 --> 00:01:20,800
Basically, just replicate the pipeline.

24
00:01:20,800 --> 00:01:22,000
We have now with shaders.

25
00:01:22,000 --> 00:01:24,900
And then we don't have to get all the way to the fixing the Z part

26
00:01:24,900 --> 00:01:30,700
because that we can do the following week if we want to, but let's go.

27
00:01:30,900 --> 00:01:35,800
Ahead and open up Milton here.

28
00:01:42,800 --> 00:01:46,400
All right, so today is day 3.

29
00:01:46,400 --> 00:01:47,300
69

30
00:01:52,000 --> 00:01:56,200
feels like my tablet is not pressure recognized for some reason.

31
00:02:02,200 --> 00:02:02,800
Where is it?

32
00:02:05,900 --> 00:02:06,500
There it is.

33
00:02:07,400 --> 00:02:07,800
Yeah.

34
00:02:09,500 --> 00:02:13,500
All right, so let's see Jay.

35
00:02:15,000 --> 00:02:16,200
369.

36
00:02:17,600 --> 00:02:18,200
so,

37
00:02:21,700 --> 00:02:23,000
Let's talk about.

38
00:02:24,000 --> 00:02:24,700
Shaders.

39
00:02:25,700 --> 00:02:31,300
I've mentioned these in the past and we should go ahead and give to

40
00:02:31,300 --> 00:02:34,900
sort of a brief recap in order to understand shaders.

41
00:02:35,000 --> 00:02:38,300
The very most important thing is that you understand how renderers

42
00:02:38,300 --> 00:02:39,200
work in general.

43
00:02:39,200 --> 00:02:41,500
And so the number one thing you should do.

44
00:02:41,500 --> 00:02:45,800
If you aren't comfortable with it or didn't watch, it is go back and

45
00:02:45,800 --> 00:02:51,100
watch the implementation of the software, renderer both the

46
00:02:51,400 --> 00:02:53,600
implementation of the rotation part and

47
00:02:53,800 --> 00:02:58,200
Imitation of the optimization part because that is crucial to

48
00:02:58,200 --> 00:02:59,700
understanding how shaders work that.

49
00:03:00,000 --> 00:03:04,400
100%, what you need to know, to know, understand how shaders work.

50
00:03:04,400 --> 00:03:08,300
If you don't understand that stuff very well, go back there.

51
00:03:08,300 --> 00:03:12,500
First, don't even bother watching this episode because that is the

52
00:03:12,500 --> 00:03:13,800
crucial thing to understand first.

53
00:03:14,100 --> 00:03:19,400
So I'm going to briefly say why that is just so you can map the

54
00:03:19,400 --> 00:03:21,800
knowledge on and then we'll talk about the Shader specific stuff.

55
00:03:22,400 --> 00:03:25,800
So the way Hardware in most cases,

56
00:03:27,000 --> 00:03:34,200
On the PC does pixel processing is that the pixels themselves are

57
00:03:34,200 --> 00:03:35,600
treated as a block.

58
00:03:35,800 --> 00:03:40,700
So if you recall the way our software renderer worked is we took four

59
00:03:40,700 --> 00:03:44,300
pixels in a row that were packed rgba.

60
00:03:44,300 --> 00:03:52,300
So it was, you know, rgba rgba rgba or I think it our case.

61
00:03:52,300 --> 00:03:56,600
We actually, because of the windows format, we were doing BG

62
00:03:56,800 --> 00:03:59,300
RAB gra, right?

63
00:03:59,600 --> 00:04:00,200
But point being.

64
00:04:00,200 --> 00:04:01,600
We had four packed pixels.

65
00:04:01,600 --> 00:04:07,500
Each of which had eight bytes per channel of RGB and a, which is 32

66
00:04:07,700 --> 00:04:08,300
bits.

67
00:04:08,300 --> 00:04:16,600
So we had four 32-bit pixels or 4 by 32 here which is 128 bits, right?

68
00:04:18,300 --> 00:04:22,700
For 32-bit slots, if you will.

69
00:04:24,600 --> 00:04:27,400
So if you imagine what that looks like, you can imagine those pixels

70
00:04:27,400 --> 00:04:28,400
here, here's pixel.

71
00:04:28,400 --> 00:04:30,400
0, 1, 2 3.

72
00:04:30,400 --> 00:04:31,500
And there you go.

73
00:04:31,700 --> 00:04:34,700
Right now in graphics Hardware.

74
00:04:36,000 --> 00:04:39,300
There is obviously no particular.

75
00:04:39,400 --> 00:04:43,600
So if you imagine what a typical Graphics primitive, looks like a

76
00:04:43,600 --> 00:04:47,400
triangle or something, like this, that we're going to want to treat

77
00:04:47,400 --> 00:04:49,000
individually to rasterize.

78
00:04:49,000 --> 00:04:51,400
Right to produce the pixels for particular triangle.

79
00:04:51,800 --> 00:04:53,600
Obviously there's no particular.

80
00:04:53,800 --> 00:04:58,700
- towards them looking like long and slivery like that, right?

81
00:04:58,900 --> 00:05:04,700
Or like this typically triangles are more like this shape right there.

82
00:05:04,700 --> 00:05:07,000
More like reasonably sized.

83
00:05:07,400 --> 00:05:13,500
In most cases if typically, artwork is trying to, if it can distribute

84
00:05:13,500 --> 00:05:17,000
the triangle load evenly over the artwork, so that gets good coverage.

85
00:05:17,000 --> 00:05:21,100
So, typically, they are more reasonable in terms of their area, their

86
00:05:21,100 --> 00:05:23,000
more even in terms of their area,

87
00:05:23,800 --> 00:05:25,900
And not extremely long and eccentric.

88
00:05:27,200 --> 00:05:32,200
So what I would say is, if you look at these pixels in a row here, the

89
00:05:32,200 --> 00:05:37,700
fact that we were treating our pixels in a row like this sort of

90
00:05:37,700 --> 00:05:41,200
suggests this style of triangle, right?

91
00:05:42,000 --> 00:05:43,200
A more sensible way.

92
00:05:43,200 --> 00:05:47,400
Potentially, if you could control everything about it would be instead

93
00:05:47,400 --> 00:05:50,500
to have arranged are pixels like this.

94
00:05:52,200 --> 00:05:52,800
Right?

95
00:05:52,800 --> 00:05:57,200
Because now we maximize the chance for a triangle that all of the

96
00:05:57,200 --> 00:05:58,800
pixels fall inside.

97
00:05:58,800 --> 00:05:59,800
Whereas in this case

98
00:06:00,100 --> 00:06:00,500
Right?

99
00:06:00,500 --> 00:06:03,600
We are sort of maximizing the chances that they don't, because we're

100
00:06:03,600 --> 00:06:07,400
creating the longest possible run in one dimension, right?

101
00:06:08,800 --> 00:06:13,300
Which isn't very good at keeping things inside, uniform, size shapes

102
00:06:15,700 --> 00:06:16,100
now.

103
00:06:17,900 --> 00:06:21,100
the reason we did that was just because in terms of how we load in

104
00:06:21,100 --> 00:06:21,500
memory,

105
00:06:26,600 --> 00:06:29,800
and because we are required to Output things in a certain way to

106
00:06:29,800 --> 00:06:34,400
Windows that just made the most sense we needed to use Cindy, right,

107
00:06:34,400 --> 00:06:37,900
which is Cindy single instruction, multiple data, right?

108
00:06:37,900 --> 00:06:39,700
We needed to use the SSE.

109
00:06:41,900 --> 00:06:45,300
Streaming simply extensions on the Intel architecture to do fast

110
00:06:45,300 --> 00:06:49,600
processing of pixels and that is 4 wide at a minimum, right?

111
00:06:49,600 --> 00:06:53,600
The, the version we were targeting as for wide, it does operations on

112
00:06:53,600 --> 00:06:56,300
four things at once in floating point.

113
00:06:56,400 --> 00:06:59,800
And so we wanted to be able to load something that was 128 bits.

114
00:07:00,100 --> 00:07:04,400
Blow it out into channels and do for why Tops on them.

115
00:07:08,400 --> 00:07:10,400
And of course, when you're doing the operations, you're doing

116
00:07:10,400 --> 00:07:11,300
operations specifically,

117
00:07:11,500 --> 00:07:13,100
Red Channel, green Channel blue channel.

118
00:07:13,300 --> 00:07:17,100
So you want for Red's for greens for blues and for Alphas right?

119
00:07:17,100 --> 00:07:23,600
In order to fill your entire CMD with right now, all of that stuff, if

120
00:07:23,600 --> 00:07:25,900
that sounds unfamiliar to you have to go back and watch those.

121
00:07:25,900 --> 00:07:27,400
I'm not going to explain that again here.

122
00:07:27,500 --> 00:07:28,900
You have to know that stuff.

123
00:07:28,900 --> 00:07:32,500
So go back and make sure you've got your fundamentals of software

124
00:07:32,500 --> 00:07:33,400
rendering first.

125
00:07:33,500 --> 00:07:35,900
So that you'll understand what we're talking about with shaders.

126
00:07:36,800 --> 00:07:42,300
Okay, so yes this rectangle I'm sorry the square much better pattern

127
00:07:42,300 --> 00:07:46,300
for keeping things on average inside uniformly shaped things.

128
00:07:46,700 --> 00:07:50,900
So the way that graphics cards actually prices things is they do

129
00:07:50,900 --> 00:07:51,800
process them in squares.

130
00:07:51,800 --> 00:07:56,700
Now, it depends on the card itself necessarily, right?

131
00:07:56,700 --> 00:08:02,900
It's not always the same, but basically, what you get is you get a

132
00:08:02,900 --> 00:08:06,300
extension of the size of things being processed into.

133
00:08:06,600 --> 00:08:08,700
Thing more like this.

134
00:08:09,400 --> 00:08:12,200
And this is not exact, like I said, every graphics card can be

135
00:08:12,200 --> 00:08:14,500
different depending on the architecture.

136
00:08:14,600 --> 00:08:15,600
AMD versus a video.

137
00:08:15,600 --> 00:08:16,300
How wide it is?

138
00:08:16,300 --> 00:08:17,100
This sorts of things?

139
00:08:18,500 --> 00:08:23,700
But this is an example of what it might be 16 pixels at a time, right?

140
00:08:24,500 --> 00:08:26,900
And so what it does is it creates a square.

141
00:08:26,900 --> 00:08:30,800
It still does load for a pixels in a row, but it also loads basically

142
00:08:31,300 --> 00:08:32,700
four rows of that.

143
00:08:32,700 --> 00:08:35,799
So it's 4 by 4 again in a square pattern especially when you get to

144
00:08:35,799 --> 00:08:40,299
this size, you can imagine if we did 16 pixels across there's almost

145
00:08:40,299 --> 00:08:45,200
be no chance that most of those would fall inside the same triangle.

146
00:08:45,200 --> 00:08:48,200
So they tend to try to put it into more.

147
00:08:48,300 --> 00:08:50,500
Metrically reasonable spaces, right?

148
00:08:52,000 --> 00:08:54,500
So it's going to load 16 pixels at a time.

149
00:08:54,500 --> 00:08:57,200
Let's say some I think only load eight.

150
00:08:57,200 --> 00:08:59,800
I don't know the exact breakdowns of which cards do

151
00:09:00,000 --> 00:09:02,800
How that goes, you'd have to talk to more of a GPU expert for those

152
00:09:02,800 --> 00:09:05,200
sorts of nitty-gritty details.

153
00:09:05,200 --> 00:09:08,100
There's also things like pixel packing, which try to gather pixels in

154
00:09:08,100 --> 00:09:11,800
and there's all sorts of shenanigans that happen on gpus.

155
00:09:11,800 --> 00:09:16,000
So this is again just the high-level overview and I'm not trying to

156
00:09:16,000 --> 00:09:19,400
say this is exactly how a GPU is going to function because it's not.

157
00:09:20,700 --> 00:09:24,200
So you have to imagine when you start thinking about shaders that when

158
00:09:24,200 --> 00:09:28,200
I'm going to start filling pixels, I'm going to do them in exactly the

159
00:09:28,200 --> 00:09:29,900
same way we did in our software rasterizer.

160
00:09:30,000 --> 00:09:31,700
Only I'm probably going to do it much wider.

161
00:09:31,700 --> 00:09:38,900
So instead of a 4 wide 70 think 8 wide or 16 wide Cindy so much wider

162
00:09:39,500 --> 00:09:44,200
which means we want to gather up a good chunk of pixels either 8 or 16

163
00:09:45,000 --> 00:09:48,600
to do all our operations on and we're gonna do those operations just

164
00:09:48,600 --> 00:09:50,300
like our system.

165
00:09:51,500 --> 00:09:52,600
They are masked.

166
00:09:52,800 --> 00:09:57,700
So if the triangle passed through in this way, then you're going to

167
00:09:57,700 --> 00:10:00,900
get a mask which says, well, all of these pixels are filled.

168
00:10:01,000 --> 00:10:03,400
But these two weren't, right?

169
00:10:03,700 --> 00:10:07,300
And that mask is going to say how to write back the results.

170
00:10:07,300 --> 00:10:12,600
So it won't affect even though computed 3 and 12, it won't affect 3

171
00:10:12,600 --> 00:10:14,100
and 12, right?

172
00:10:17,200 --> 00:10:20,300
This is also sometimes colloquially called a warp in Nvidia.

173
00:10:20,300 --> 00:10:25,400
Parlance, when you're looking at like Cooter, something they talked

174
00:10:25,400 --> 00:10:27,500
about the number of things being processed together.

175
00:10:27,700 --> 00:10:29,300
I just think of it as Cindy.

176
00:10:29,300 --> 00:10:33,700
Again, I just think it is the register with or the operation with but

177
00:10:33,700 --> 00:10:36,700
the things that travel together like this, where we're pressing all

178
00:10:36,700 --> 00:10:39,100
the pixels together, they call a warp for some reason.

179
00:10:39,100 --> 00:10:43,000
I don't know why they probably have a reason but I don't know what it

180
00:10:43,000 --> 00:10:43,200
is.

181
00:10:49,100 --> 00:10:50,400
That might come, I don't know.

182
00:10:50,500 --> 00:10:54,100
Work might come from some multi-processing literature like earlier on,

183
00:10:54,100 --> 00:10:54,900
I'm not sure.

184
00:10:55,300 --> 00:11:01,600
Anyway so fundamentally speaking, when we are talking about writing a

185
00:11:01,600 --> 00:11:05,600
pixel Shader, what we are writing even though it doesn't look like it.

186
00:11:05,600 --> 00:11:11,500
When we write it, what we are writing is 100% just the exact exact

187
00:11:11,500 --> 00:11:13,000
same kind of code.

188
00:11:13,500 --> 00:11:13,800
That

189
00:11:14,000 --> 00:11:14,700
Were writing.

190
00:11:15,900 --> 00:11:19,300
When we wrote the software rasterizer, when you are writing a Shader,

191
00:11:19,300 --> 00:11:22,100
it is literally the exact same process.

192
00:11:22,100 --> 00:11:25,200
You should be thinking exactly the same way as you are.

193
00:11:25,200 --> 00:11:30,100
Thinking, when you write SMD software rasterizer, which is why having

194
00:11:30,100 --> 00:11:33,100
done that, you're in much better position to understand how to write a

195
00:11:33,100 --> 00:11:36,800
Shader and if you haven't done that, you're going to be kind of

196
00:11:36,800 --> 00:11:37,400
confused.

197
00:11:39,200 --> 00:11:40,300
So why do I say that?

198
00:11:40,300 --> 00:11:44,400
Well when you write a Shader, what you're going to see in the Shader

199
00:11:44,400 --> 00:11:45,600
is you're going to see code.

200
00:11:45,600 --> 00:11:48,300
That looks a lot like C code and it won't look very much.

201
00:11:48,300 --> 00:11:52,800
Like some decode in the Shader you'll see things like, okay, I have a

202
00:11:52,800 --> 00:11:59,500
veck for and the Veeck for is, maybe like the texture sample, right?

203
00:12:01,000 --> 00:12:09,000
And I will call something like texture 2D and I will pass it, you

204
00:12:09,000 --> 00:12:11,700
know, some UV coordinates, well I'll pass it.

205
00:12:11,800 --> 00:12:15,800
You know, the texture to sample and the u and v or something like

206
00:12:15,800 --> 00:12:16,600
this, right?

207
00:12:18,600 --> 00:12:19,400
So you'll see code.

208
00:12:19,400 --> 00:12:20,300
That looks a lot like this.

209
00:12:20,300 --> 00:12:21,800
It will have built-in types.

210
00:12:21,800 --> 00:12:26,200
And those built-in types will be types that are defined by the opengl

211
00:12:26,200 --> 00:12:27,100
Shader compiler.

212
00:12:27,100 --> 00:12:31,800
So Vic for is basically equivalent to our V4, right?

213
00:12:31,800 --> 00:12:35,500
It's a bundle of, for floating Point values, you declare variables

214
00:12:35,500 --> 00:12:36,200
their variables.

215
00:12:36,200 --> 00:12:38,800
Just like you would think of them and see which are like text sample

216
00:12:38,800 --> 00:12:40,900
or whatever, you give them a name and they correspond.

217
00:12:40,900 --> 00:12:44,400
They have a type, you will see assignment and you'll see built-in

218
00:12:44,400 --> 00:12:44,900
functions.

219
00:12:44,900 --> 00:12:48,200
So this is a function specified by opengl that does texture.

220
00:12:48,400 --> 00:12:51,700
Rambling, you pass it some parameters so it knows what it's going to

221
00:12:51,700 --> 00:12:52,600
do this texture.

222
00:12:52,600 --> 00:12:55,400
This you and this V will have to get from somewhere, right?

223
00:12:55,600 --> 00:13:00,300
And the textures are usually abstract, they're not pointers directly a

224
00:13:00,300 --> 00:13:04,700
lot of the times because we don't have access to the pointers at that

225
00:13:04,700 --> 00:13:08,200
kind of a level so you can use extensions and actually do some stuff

226
00:13:08,200 --> 00:13:10,700
like that with like a video instead extensions and stuff.

227
00:13:10,700 --> 00:13:12,500
But we're not going to talk too much about that because that's a

228
00:13:12,500 --> 00:13:15,000
little that hasn't really made into the mainstream as much yet

229
00:13:15,500 --> 00:13:17,400
although the 4.5 ARB stuff.

230
00:13:17,400 --> 00:13:18,100
I think actually,

231
00:13:18,300 --> 00:13:19,800
Does let you do that?

232
00:13:20,500 --> 00:13:23,800
Not I don't think all the bio stuff there that's a rat hole.

233
00:13:23,800 --> 00:13:27,300
We can talk about at some future date after we get the basics down,

234
00:13:27,600 --> 00:13:28,500
not important right now.

235
00:13:29,500 --> 00:13:31,500
Anyway, this is the sort of code, you will see

236
00:13:32,900 --> 00:13:37,100
But the important thing to understand it when we're writing this is

237
00:13:37,100 --> 00:13:41,100
that any time that we're seeing things that are happening here, all of

238
00:13:41,100 --> 00:13:43,000
these things are time 16.

239
00:13:43,400 --> 00:13:47,500
So even though we aren't going to write anything other than what

240
00:13:47,500 --> 00:13:48,900
happens for a single Pixel.

241
00:13:48,900 --> 00:13:51,100
So this is like an example of instruction that would happen for a

242
00:13:51,100 --> 00:13:52,400
single Pixel, right?

243
00:13:52,500 --> 00:13:55,400
Here's the texture, here is the UV, we're sampling a texture, we're

244
00:13:55,400 --> 00:13:59,900
getting back an RGB Vector for that says, here's what the color is,

245
00:14:00,100 --> 00:14:00,600
right?

246
00:14:01,300 --> 00:14:02,600
So we're looking

247
00:14:02,700 --> 00:14:05,700
At it, and we're typing it in and it seems like it's a single Pixel.

248
00:14:05,700 --> 00:14:06,700
It's not.

249
00:14:06,800 --> 00:14:10,700
It's 16 pixels or some number of pixels that are having this happen,

250
00:14:11,000 --> 00:14:11,700
right?

251
00:14:12,000 --> 00:14:14,600
So you have to understand that basically all of these things that

252
00:14:14,600 --> 00:14:18,700
you're writing in are effectively as if you were doing the wide

253
00:14:18,700 --> 00:14:19,200
version.

254
00:14:19,200 --> 00:14:22,000
So then when you then say text sample, right?

255
00:14:24,500 --> 00:14:29,600
Down here and you're like, oh, I want a x equal that by 4.0 to like,

256
00:14:29,600 --> 00:14:33,300
you know, I don't know, make it be and I don't think you put F Saint

257
00:14:33,300 --> 00:14:36,100
anything and shaders until later they added the ability to that.

258
00:14:36,100 --> 00:14:37,500
But regionally, you didn't do that.

259
00:14:38,600 --> 00:14:42,600
If you do text sample, x equals 4.0 to multiply all of the members of

260
00:14:42,600 --> 00:14:47,600
that by for, let's say, this is actually the equivalent of doing

261
00:14:47,600 --> 00:14:52,000
something like what we were doing before, where we have the mmm,

262
00:14:52,100 --> 00:14:52,700
right.

263
00:14:53,700 --> 00:14:57,400
Mole, PS stuff.

264
00:14:57,400 --> 00:14:59,900
And we said, okay, we've

265
00:15:00,000 --> 00:15:06,600
Out the oops think that's just underscore mou PS we write something

266
00:15:06,600 --> 00:15:09,400
like that and we just say okay we've got the text sample.

267
00:15:11,300 --> 00:15:16,700
And the mm set one PS4 Point O.

268
00:15:17,200 --> 00:15:21,900
So if you remember how we wrote that code this is basically equivalent

269
00:15:21,900 --> 00:15:22,600
to that.

270
00:15:22,700 --> 00:15:26,000
So every time in a Shader you write a basic operation.

271
00:15:26,000 --> 00:15:28,000
That looks like a scalar operation in.

272
00:15:28,000 --> 00:15:32,400
See it's actually expanding it out to a Cyndi operation.

273
00:15:32,400 --> 00:15:36,200
That's going to operate on many things at once.

274
00:15:36,500 --> 00:15:40,000
You don't know how many because the graphics card is free to choose

275
00:15:40,600 --> 00:15:44,200
Like some graphics cards are 16:8 wide, whatever they could be 32

276
00:15:44,200 --> 00:15:45,100
wide, who knows?

277
00:15:49,100 --> 00:15:50,600
Whatever the manufacturer wanted.

278
00:15:52,100 --> 00:15:54,800
So you have to understand that that's what's happening.

279
00:15:55,300 --> 00:15:58,800
Now, the reason it's important to understand, why understand that and

280
00:15:58,800 --> 00:16:02,500
to understand the fact that these things are getting blown out to the

281
00:16:02,500 --> 00:16:03,000
width,

282
00:16:04,500 --> 00:16:08,700
is because what that means is, when you think about the peak

283
00:16:08,900 --> 00:16:12,600
throughput of the sampler, when you think about how much performance

284
00:16:12,600 --> 00:16:18,700
it's going to get, it's going to be based entirely on how much of this

285
00:16:18,700 --> 00:16:24,800
number, you can leverage right if you are constantly filling all 16

286
00:16:24,800 --> 00:16:26,700
pixels and using them

287
00:16:27,800 --> 00:16:31,700
And all of the instructions for all 16 pixels are getting used, then

288
00:16:31,700 --> 00:16:36,300
you are going to get close to doing the number of gigaflops that that

289
00:16:36,300 --> 00:16:37,800
card is capable of doing.

290
00:16:37,800 --> 00:16:42,800
You're going to be using the floating-point capabilities of that card

291
00:16:43,700 --> 00:16:45,600
to the fullest extent that you can.

292
00:16:46,000 --> 00:16:50,800
However, if you don't do that, then you could go anywhere from slight

293
00:16:50,900 --> 00:16:55,000
degradation in performance to drastic degradations and performance.

294
00:16:55,000 --> 00:16:57,500
As much as like, 1/16 the

295
00:16:57,600 --> 00:16:59,700
So who knows even less, right?

296
00:17:00,900 --> 00:17:06,099
And how that happens is if you write Shader code unaware of what is

297
00:17:06,099 --> 00:17:10,900
actually going to happen under the hood, this is pretty harmless.

298
00:17:11,200 --> 00:17:17,000
This will only get next on the 16 when the triangle itself doesn't

299
00:17:17,000 --> 00:17:18,800
cover enough pixels, right?

300
00:17:18,900 --> 00:17:22,000
So when you're doing something like this and you've got 60 in there

301
00:17:22,000 --> 00:17:25,599
and only these fraction of them are in, then you're not going to get

302
00:17:25,900 --> 00:17:27,300
that 16, right?

303
00:17:27,500 --> 00:17:31,300
And so there's always some loss and that loss, you know, it could even

304
00:17:31,300 --> 00:17:33,500
be half, you know, who knows how much it is.

305
00:17:33,700 --> 00:17:36,900
But there's always going to be some loss, just due to the fact that

306
00:17:36,900 --> 00:17:42,800
you can't always get enough pixels actually relevant into the Shader,

307
00:17:42,900 --> 00:17:43,500
right?

308
00:17:43,600 --> 00:17:47,000
And that's the fault of the geometry and that's something you do have

309
00:17:47,000 --> 00:17:49,200
to be aware of when you're thinking about how to make sure your

310
00:17:49,200 --> 00:17:55,800
geometry is nicely is nicely even and does reasonable filling and that

311
00:17:55,800 --> 00:17:56,900
sort of stuff right?

312
00:17:57,800 --> 00:17:59,200
And remember this gets better.

313
00:17:59,200 --> 00:17:59,800
Once you start,

314
00:18:00,000 --> 00:18:01,100
About msaa.

315
00:18:01,100 --> 00:18:01,300
Right.

316
00:18:01,300 --> 00:18:05,200
Because with multi sample anti-aliasing, this 16 wide.

317
00:18:05,200 --> 00:18:10,000
Well, if you did 16 x over sampling, like let's say you did 16x msaa.

318
00:18:10,400 --> 00:18:13,200
Then this 16 wide is all inside, a single Pixel.

319
00:18:14,400 --> 00:18:14,900
Right.

320
00:18:15,900 --> 00:18:20,000
So, you know, it gets better with the more multi sample and aliasing,

321
00:18:20,000 --> 00:18:22,800
you have because then you're less, and less likely to have triangles

322
00:18:22,800 --> 00:18:23,500
missing things.

323
00:18:23,500 --> 00:18:24,800
So there's there's that as well.

324
00:18:25,800 --> 00:18:29,700
But anyway, so you start off and you assume you've got some losses due

325
00:18:29,700 --> 00:18:32,400
to coverage which you can't really control as much.

326
00:18:32,400 --> 00:18:33,400
The more amount of sample.

327
00:18:33,400 --> 00:18:35,900
Anything you have probably the less of that you have to worry about

328
00:18:35,900 --> 00:18:41,700
because you have less and less pixels per per warp and just you know a

329
00:18:41,700 --> 00:18:43,900
lot of those are samples that are inside the same pixel.

330
00:18:43,900 --> 00:18:44,000
So

331
00:18:44,200 --> 00:18:44,600
Good.

332
00:18:45,100 --> 00:18:45,700
But

333
00:18:47,500 --> 00:18:53,100
you and again, even those samples though, our can still be outside I

334
00:18:53,100 --> 00:18:54,700
guess if there were think of it too, right?

335
00:18:54,700 --> 00:18:59,000
So if you're right on the edge of the triangle, then you can sell the

336
00:18:59,000 --> 00:19:00,000
samples outside.

337
00:19:00,000 --> 00:19:02,500
Just like, you have pixels outside, but I guess what I'm trying to say

338
00:19:02,500 --> 00:19:05,300
is multi sample and feeling kind of it increases your effective

339
00:19:05,300 --> 00:19:08,400
resolution by up to 4 by 4, right?

340
00:19:08,500 --> 00:19:12,500
At which point, you're just much more likely to have a triangles of

341
00:19:12,500 --> 00:19:15,300
the same size, cover more of your samples, right?

342
00:19:15,300 --> 00:19:16,100
That that's all.

343
00:19:16,900 --> 00:19:20,500
It's just like increasing the resolution increases or decreases the

344
00:19:20,500 --> 00:19:22,100
sizes of the 4 by 4.

345
00:19:22,200 --> 00:19:25,600
If the triangle stay the same size, they're going to cover more of

346
00:19:25,600 --> 00:19:26,400
them, right?

347
00:19:26,900 --> 00:19:29,500
So anyway, when we go through this, we have some losses due to

348
00:19:29,500 --> 00:19:30,100
Geometry.

349
00:19:30,100 --> 00:19:32,800
That's understandable, and that's not your fault.

350
00:19:32,800 --> 00:19:35,300
In the fragment Shader, maybe your fault for how you set up the

351
00:19:35,300 --> 00:19:37,100
geometry, but that's separate issue.

352
00:19:39,100 --> 00:19:43,100
Once you get into the Shader prepper, you can lose a lot of that

353
00:19:43,100 --> 00:19:46,600
parallelism by not

354
00:19:46,700 --> 00:19:48,900
Thinking through what things cost.

355
00:19:49,100 --> 00:19:52,700
So, for example, in a Shader you can write an if I could say, for

356
00:19:52,700 --> 00:19:57,900
example, if the text samples, right, and the Veeck fours work, very

357
00:19:57,900 --> 00:20:00,200
similar to how we wrote them in our C code.

358
00:20:00,200 --> 00:20:03,800
So you can say for example dot R to get the red Channel out of a veck

359
00:20:03,800 --> 00:20:04,200
for.

360
00:20:05,100 --> 00:20:11,000
So I say if a text sample read for, you know, is not equal to 0.

361
00:20:11,000 --> 00:20:15,300
Let's say, then I'm going to do some code here and then I'll do an

362
00:20:15,300 --> 00:20:16,600
else branch and

363
00:20:16,800 --> 00:20:19,900
Well, if it was equal to 0, I'll do something else, right.

364
00:20:20,900 --> 00:20:23,000
So, you can write these sorts of things in a Shader.

365
00:20:23,300 --> 00:20:26,000
Similarly, you can write for I Loops or something right.

366
00:20:26,000 --> 00:20:27,400
I could write a for Loop here.

367
00:20:28,200 --> 00:20:33,600
I could say, you know, for I don't know or a while loop like while,

368
00:20:34,800 --> 00:20:36,200
you know, text sample.

369
00:20:37,900 --> 00:20:41,400
R is greater than zero and we just go through here.

370
00:20:41,400 --> 00:20:44,800
And at the end of this, I do like our, you know, text sample.

371
00:20:48,200 --> 00:20:53,000
R- equals 0 .1, right?

372
00:20:56,800 --> 00:20:59,800
so shaders, let you write complex flow control, just like you

373
00:21:00,000 --> 00:21:01,700
Right, and see you can call functions.

374
00:21:01,700 --> 00:21:03,600
You can do if statements, you can do while Loops.

375
00:21:03,600 --> 00:21:07,700
But like I said, it's crucial to understand if you just look at that

376
00:21:07,700 --> 00:21:14,700
and you don't understand how Cindy code Works, you're going to be very

377
00:21:14,700 --> 00:21:18,400
confused as to why your performance is what it is.

378
00:21:19,000 --> 00:21:24,600
So what happens when you write these things is just like we wrote

379
00:21:24,600 --> 00:21:25,000
them.

380
00:21:26,100 --> 00:21:32,000
For our masks, for our right masks, in the Shader, the in the software

381
00:21:32,000 --> 00:21:32,600
rasterizer code.

382
00:21:32,600 --> 00:21:33,500
That we wrote,

383
00:21:34,500 --> 00:21:35,600
Just like that.

384
00:21:37,300 --> 00:21:42,300
All the branches of a lip of a loop and all I'm sorry.

385
00:21:42,300 --> 00:21:45,300
All the branches of an if and all of the iterations of the loop have

386
00:21:45,300 --> 00:21:46,500
to happen for everybody.

387
00:21:46,500 --> 00:21:52,500
Always because remember there's just one Processing Unit responsible

388
00:21:52,500 --> 00:21:58,200
for executing this code for all 16 pixels at a time or 16 samples at a

389
00:21:58,200 --> 00:21:58,600
time.

390
00:22:00,000 --> 00:22:00,700
Right?

391
00:22:00,700 --> 00:22:06,100
There are multiple cores on a GPU but in terms of one set of 16 pixels

392
00:22:06,100 --> 00:22:10,500
flowing through that pipe or 8 or however many ever wide, it is just

393
00:22:10,500 --> 00:22:15,500
like Cindy is only one core doing it so you can't branch.

394
00:22:17,000 --> 00:22:22,400
Uniquely per sample, you have to Branch one way for all 16 samples.

395
00:22:22,600 --> 00:22:27,800
So what ends up happening is when you do an, if and you look at text

396
00:22:27,800 --> 00:22:29,400
sample, dot R is not equal to 0.

397
00:22:29,700 --> 00:22:32,700
It's going to do the same kind of early out that we might do in the

398
00:22:32,700 --> 00:22:37,100
software rasterizer, they might do a check to say are all of the

399
00:22:37,100 --> 00:22:37,500
texture.

400
00:22:37,500 --> 00:22:40,100
Sample .rs, not equal to 0.

401
00:22:40,400 --> 00:22:44,700
If they are, then it will just execute this branch and not this one if

402
00:22:44,700 --> 00:22:46,700
they definitely are not.

403
00:22:46,900 --> 00:22:49,800
If they all are not, it could execute just this branch and not this

404
00:22:49,800 --> 00:22:50,700
one, right?

405
00:22:51,100 --> 00:22:55,000
But most of the time probably and again this is just one you need to

406
00:22:55,000 --> 00:22:57,300
be aware of if you know that that's the case.

407
00:22:57,300 --> 00:23:00,100
Like it's always all zeros or it's always all not zeros.

408
00:23:00,200 --> 00:23:03,100
Then you're probably fine performance wise here because you haven't

409
00:23:03,100 --> 00:23:06,300
introduced a problem but assuming it can be a mixture.

410
00:23:07,600 --> 00:23:11,800
Then you are going to execute both branches, both branches will always

411
00:23:11,800 --> 00:23:13,400
be executed, right?

412
00:23:13,600 --> 00:23:16,700
And what will happen is it will create a mask.

413
00:23:16,700 --> 00:23:20,600
This instruction will actually do a comparison and take the mask and

414
00:23:20,600 --> 00:23:23,300
it'll leave that mask in a register.

415
00:23:23,800 --> 00:23:27,200
It will then execute all of these instructions and all of these

416
00:23:27,200 --> 00:23:31,700
instructions and then it will combine them using the mask into the

417
00:23:31,700 --> 00:23:32,500
result.

418
00:23:32,700 --> 00:23:37,100
So, all of the pixels in the warp that had the red

419
00:23:37,300 --> 00:23:38,700
It'll not equal to 0.

420
00:23:38,900 --> 00:23:44,300
Will get these results fused in to their slots, and all of the ones

421
00:23:44,300 --> 00:23:45,200
that didn't.

422
00:23:45,300 --> 00:23:47,700
We'll have it fused in, will have what happened?

423
00:23:47,700 --> 00:23:49,200
He refused in, right?

424
00:23:49,200 --> 00:23:52,000
So this produces one, result, whatever it is.

425
00:23:52,000 --> 00:23:56,600
This reduces another and then they get masks together, right into the

426
00:23:56,600 --> 00:23:57,200
result.

427
00:23:58,700 --> 00:23:59,400
So again.

428
00:24:00,000 --> 00:24:03,600
Understanding the Shader, just knowing what it does.

429
00:24:03,600 --> 00:24:06,500
You can read this just like scalar code and yes, that's fine.

430
00:24:06,600 --> 00:24:09,200
But understanding a how it performs and works.

431
00:24:09,200 --> 00:24:13,300
It's crucial for you to understand that depending on the architecture

432
00:24:13,300 --> 00:24:18,200
of the GPU, there can be very serious performance, concerns to things

433
00:24:18,200 --> 00:24:21,900
like if statements or Loops, if you don't understand what you're

434
00:24:21,900 --> 00:24:23,400
actually asking the processor to do.

435
00:24:23,400 --> 00:24:26,300
If you think that you're just asking to do one or the other you're

436
00:24:26,300 --> 00:24:26,700
wrong.

437
00:24:26,700 --> 00:24:29,800
That's not actually what it often times will have to do.

438
00:24:30,000 --> 00:24:34,000
Do so that's just worth understanding and again this multiplier is Big

439
00:24:34,800 --> 00:24:39,000
getting 16 times the performance out of something from Cindy is no

440
00:24:39,000 --> 00:24:39,700
laughing matter.

441
00:24:39,700 --> 00:24:40,000
Right?

442
00:24:40,000 --> 00:24:44,600
Take how fast your graphics card is divided it by 16, right.

443
00:24:44,600 --> 00:24:48,000
That means if it's Max frame, rate was 60 frames a second, you're

444
00:24:48,000 --> 00:24:50,000
talking about dividing it by 16.

445
00:24:50,100 --> 00:24:53,400
You're going down to something that you wouldn't that wouldn't even be

446
00:24:53,400 --> 00:24:54,100
playable, right?

447
00:24:54,100 --> 00:24:56,500
You're going down to Something in the like, 23 frames a second,

448
00:24:56,500 --> 00:24:58,000
something like that, right?

449
00:24:58,700 --> 00:24:59,900
So you have to

450
00:25:00,000 --> 00:25:04,400
And that every time you start losing, you start shaving off some of

451
00:25:04,400 --> 00:25:05,600
that performance.

452
00:25:06,400 --> 00:25:09,400
You're hurting yourself, in terms of getting what you need out of the

453
00:25:09,400 --> 00:25:10,100
graphics card.

454
00:25:10,100 --> 00:25:14,400
So you can't just willy-nilly right things that'll like do things to

455
00:25:14,400 --> 00:25:17,400
just one or two pixels all the time and they'd all get fused together

456
00:25:17,400 --> 00:25:20,500
in this giant Shader it'll cost you right.

457
00:25:21,700 --> 00:25:26,200
The same is true for loops loops are just ifs and jumps right?

458
00:25:26,200 --> 00:25:26,900
That's all they are.

459
00:25:26,900 --> 00:25:29,500
They're just like I'm going to do a comparison and say if this thing

460
00:25:29,500 --> 00:25:29,800
is

461
00:25:30,300 --> 00:25:32,300
You know, true or not, true.

462
00:25:32,300 --> 00:25:34,300
I'm going to jump one way or the other depending on it either.

463
00:25:34,300 --> 00:25:36,400
I'm going to not, you know, I'm gonna let it fall out a blueprint to

464
00:25:36,400 --> 00:25:37,300
jump back to the top of it.

465
00:25:37,500 --> 00:25:38,900
So the same thing happens here.

466
00:25:39,300 --> 00:25:45,000
However, many times through this while loop, the longest pixel goes,

467
00:25:45,000 --> 00:25:47,800
that's how many everyone goes.

468
00:25:47,800 --> 00:25:53,000
So even if you're on average, all of your pixels like only take one or

469
00:25:53,000 --> 00:25:54,800
two Loops, let's say, right?

470
00:25:54,800 --> 00:25:59,600
But in every war / 16, there happens to be one that goes like

471
00:26:00,000 --> 00:26:07,000
100 Loops then every time it will be doing 300 Loops right now.

472
00:26:07,000 --> 00:26:08,500
It's probably not going to happen that way.

473
00:26:08,500 --> 00:26:12,000
It's probably going to be that only a few you know of those Works will

474
00:26:12,000 --> 00:26:13,200
have the 300 Loop case.

475
00:26:13,200 --> 00:26:17,900
But again every time you hit the 300 Loop case you're doing that 300

476
00:26:17,900 --> 00:26:21,400
Loop for all 16 samples, not just that one.

477
00:26:21,700 --> 00:26:25,400
So you lose the performance on everyone in the warp when that happens

478
00:26:25,600 --> 00:26:27,800
and that's very important to understand, right?

479
00:26:31,300 --> 00:26:31,800
so,

480
00:26:33,000 --> 00:26:36,100
That's the thing to keep in your mind when you're writing shaders is

481
00:26:36,100 --> 00:26:40,200
that you are wide and everything, you do is going to be interpreted as

482
00:26:40,200 --> 00:26:41,900
Sim dstyle instructions.

483
00:26:43,100 --> 00:26:46,300
So just keep that in mind as we're writing it and you'll be much much

484
00:26:46,300 --> 00:26:51,600
better off in terms of understanding the performance on handmade hero.

485
00:26:51,600 --> 00:26:54,700
We don't have a lot of complex things that we need to do in the Shader

486
00:26:55,100 --> 00:26:59,700
so we probably won't have to keep this in mind for ourselves very

487
00:26:59,700 --> 00:26:59,800
much.

488
00:27:00,300 --> 00:27:04,600
We will not be pushing the graphics cards Shader capabilities in the

489
00:27:04,600 --> 00:27:05,300
real way.

490
00:27:05,500 --> 00:27:09,300
So I won't have a chance to really show you this in action.

491
00:27:09,600 --> 00:27:12,300
But when you are doing more complicated engine work, where you're

492
00:27:12,300 --> 00:27:14,700
trying to do photorealistic rendering or who knows what else you're

493
00:27:14,700 --> 00:27:18,800
doing, gather indirect lighting, who knows that sort of stuff.

494
00:27:18,800 --> 00:27:21,300
This is the sort of thing that you have to understand.

495
00:27:21,500 --> 00:27:23,900
It's going to be important for you to get it right.

496
00:27:26,100 --> 00:27:26,500
Okay.

497
00:27:27,900 --> 00:27:30,800
So, now, the only other thing that we need to talk about before we can

498
00:27:30,800 --> 00:27:34,800
go write some Shader stuff, is that there's two parts to this traitor

499
00:27:34,800 --> 00:27:39,800
pipeline, one of which we haven't really mentioned yet and the other

500
00:27:39,800 --> 00:27:42,000
is the the part that we just talked about.

501
00:27:42,200 --> 00:27:45,200
So that part I just talked about in opengl parlance is called the

502
00:27:45,200 --> 00:27:46,200
fragment Shader.

503
00:27:47,800 --> 00:27:48,300
Right.

504
00:27:53,100 --> 00:27:53,500
There we go.

505
00:27:54,900 --> 00:27:56,000
Let's try that one more time.

506
00:28:00,200 --> 00:28:01,000
Fragment.

507
00:28:03,800 --> 00:28:06,400
But we also need a thing called a Vertex Shader.

508
00:28:07,600 --> 00:28:10,800
And what a Vertex Shader does is a vertex Shader is basically the

509
00:28:10,800 --> 00:28:14,800
transform stuff that we have done in our Graphics pipeline to do that

510
00:28:14,800 --> 00:28:19,700
perspective, transform and you know anything else that you want to do,

511
00:28:19,800 --> 00:28:21,700
that happens per vertex.

512
00:28:22,300 --> 00:28:22,900
So

513
00:28:25,200 --> 00:28:26,500
In up in jail, right?

514
00:28:26,500 --> 00:28:31,900
We're sending down these vertices x y, z w.

515
00:28:31,900 --> 00:28:33,400
You know, x y z.

516
00:28:33,400 --> 00:28:35,400
W etcetera, right?

517
00:28:35,500 --> 00:28:40,000
We're sending down these vertices to the graphics card and then we

518
00:28:40,000 --> 00:28:40,900
just talked about.

519
00:28:40,900 --> 00:28:41,200
Okay?

520
00:28:41,200 --> 00:28:46,500
Then somewhere over here, the graphics card is going to have this warp

521
00:28:46,700 --> 00:28:51,500
of pixels and it's going to fill or samples you know pixels in our

522
00:28:51,500 --> 00:28:51,800
case.

523
00:28:51,800 --> 00:28:54,000
Now it's samples because we're doing msaa.

524
00:28:55,000 --> 00:28:57,100
So it's going to have this work of samples.

525
00:28:57,300 --> 00:28:58,800
Those samples are going to be

526
00:29:01,300 --> 00:29:02,500
Are going to be computed.

527
00:29:02,800 --> 00:29:08,400
And so obviously somehow we got from here to here and that's where the

528
00:29:08,400 --> 00:29:10,000
vertex Shader part comes in.

529
00:29:10,100 --> 00:29:12,600
There's also other things called tessellation and geometry shaders,

530
00:29:12,600 --> 00:29:15,800
which can happen before the vertex Shader stage, if you want to do

531
00:29:15,800 --> 00:29:18,600
more complex work on these vertices.

532
00:29:19,600 --> 00:29:25,700
This is essentially the, like, one in one out pipeline, right?

533
00:29:25,700 --> 00:29:29,600
You put in say, three vertices for a triangle, you get out three

534
00:29:29,600 --> 00:29:30,400
vertices that get

535
00:29:30,700 --> 00:29:38,300
Drives into a triangle for fragment shading, but there's other ways

536
00:29:38,300 --> 00:29:41,300
you can do say, if you want to just put in one vertex and have that

537
00:29:41,300 --> 00:29:44,900
blow out to hundreds of vertices that got interpreted as triangles or

538
00:29:44,900 --> 00:29:45,600
something like that.

539
00:29:45,800 --> 00:29:47,600
So for amplification, that sort of thing.

540
00:29:48,700 --> 00:29:51,400
If you want to do stuff like that, there are shaders that can do those

541
00:29:51,400 --> 00:29:55,200
sorts of things as well, they happen before they happen back here

542
00:29:55,800 --> 00:29:56,400
right there.

543
00:30:00,300 --> 00:30:01,500
Having a lot of Milton problems here.

544
00:30:01,500 --> 00:30:02,100
What's going on?

545
00:30:02,800 --> 00:30:03,200
Here we go.

546
00:30:05,400 --> 00:30:08,400
So there's stuff that happens to the left of this diagram, that we

547
00:30:08,400 --> 00:30:09,800
don't need to worry about right now.

548
00:30:10,700 --> 00:30:14,100
But for our purposes, we do need to know about these two.

549
00:30:15,000 --> 00:30:19,200
So a Vertex Shader is exactly the same kind of code.

550
00:30:19,200 --> 00:30:22,400
As a pixel Shader, there's almost no difference between the two of

551
00:30:22,400 --> 00:30:22,800
them.

552
00:30:23,100 --> 00:30:28,500
The only difference is instead of working on say 16 warp, a 16 size,

553
00:30:28,500 --> 00:30:32,600
warp of fragments are samples or pixels.

554
00:30:33,700 --> 00:30:37,500
Instead we're going to do a 16 x warp of vertices.

555
00:30:38,600 --> 00:30:41,900
So instead of taking in fragments, we're just going to take in like

556
00:30:41,900 --> 00:30:47,900
16, x, 16, y, 16, V 16 W is into our vertex Shader and we're going to

557
00:30:47,900 --> 00:30:48,600
operate on them.

558
00:30:49,800 --> 00:30:50,200
Right?

559
00:30:51,100 --> 00:30:52,100
All the same stuff.

560
00:30:52,100 --> 00:30:53,200
I just said, applies.

561
00:30:53,200 --> 00:30:54,500
In fact, it does not.

562
00:30:54,500 --> 00:30:58,000
You don't even have to think in either Shader about anything different

563
00:30:58,000 --> 00:30:58,800
at all really.

564
00:30:59,200 --> 00:31:02,900
They're both pretty much exactly the same in almost all respects.

565
00:31:02,900 --> 00:31:05,600
Except for some things like fragment discard and stuff that will kind

566
00:31:05,600 --> 00:31:09,300
of touch on a little bit, maybe later, but basically exactly the same,

567
00:31:09,600 --> 00:31:14,100
it's just taking a big old batch of scalar values.

568
00:31:14,100 --> 00:31:16,900
16 x16 by 16 z6w 16.

569
00:31:16,900 --> 00:31:19,500
Anything else, color 16, movies for your texture 16.

570
00:31:19,600 --> 00:31:25,400
Whatever's right transforming those and preparing them to be output to

571
00:31:25,400 --> 00:31:26,300
the fragment Shader.

572
00:31:26,600 --> 00:31:30,600
So what we will do is we will say when we declare these and you'll see

573
00:31:30,600 --> 00:31:34,800
me do it will say what travels across this boundary, you know,

574
00:31:34,800 --> 00:31:39,000
probably the positions for the vertices of the triangles that are

575
00:31:39,000 --> 00:31:42,300
going to be rasterized, probably the texture coordinates that are

576
00:31:42,300 --> 00:31:44,900
going to be used to look at the textures, probably a color value for

577
00:31:44,900 --> 00:31:46,500
doing that modulation, right?

578
00:31:46,700 --> 00:31:49,400
So we're going to declare the stuff that goes across and we'll

579
00:31:49,500 --> 00:31:50,300
Make them line up.

580
00:31:50,300 --> 00:31:54,300
But basically that all that's going to happen in here, there's nothing

581
00:31:54,300 --> 00:31:55,100
special at all.

582
00:31:55,100 --> 00:32:00,200
It's just doing a bulk, the bulk work of taking in rough, vertices

583
00:32:00,200 --> 00:32:06,900
from the app streams that are we Define and sending them over to the

584
00:32:06,900 --> 00:32:10,500
fragment Shader processed so that it can start doing rasterization on

585
00:32:10,500 --> 00:32:10,700
them.

586
00:32:10,700 --> 00:32:17,300
Right now, again, there actually is a rasterizer in here, right?

587
00:32:17,300 --> 00:32:19,500
That we don't see and that's the thing that

588
00:32:19,600 --> 00:32:24,900
Takes an actual triangle and generates the pixels that are actual

589
00:32:24,900 --> 00:32:28,600
samples that are actually used in the fragment Shader, that is not

590
00:32:28,600 --> 00:32:29,300
programmable.

591
00:32:29,800 --> 00:32:34,000
So the vertex Shader outputs, the vertices that will be used to

592
00:32:34,000 --> 00:32:35,300
rasterize the triangles.

593
00:32:35,500 --> 00:32:38,900
The, the fragment Shader takes in the fragments that that triangle

594
00:32:38,900 --> 00:32:40,400
covers, right?

595
00:32:41,500 --> 00:32:45,100
But in between there, there is the rasterization step and you don't

596
00:32:45,100 --> 00:32:45,700
see that.

597
00:32:46,200 --> 00:32:49,400
So you don't get to see how triangles rasterize or

598
00:32:49,500 --> 00:32:53,900
Change it that may change in the future but for right now it's not.

599
00:32:54,000 --> 00:32:54,900
That's just what it is.

600
00:32:57,800 --> 00:32:59,800
Okay, so

601
00:33:00,100 --> 00:33:01,100
Is the end of that.

602
00:33:03,800 --> 00:33:08,800
Let's go ahead now and actually do some work with these so that we can

603
00:33:08,800 --> 00:33:10,300
see how this works in practice.

604
00:33:10,300 --> 00:33:14,800
Now that you get the idea about how they work and again this is day

605
00:33:14,800 --> 00:33:15,100
39.

606
00:33:15,500 --> 00:33:20,600
So start with day 368 source code and that's what I'm me starting with

607
00:33:20,600 --> 00:33:20,900
now.

608
00:33:21,300 --> 00:33:23,900
So here's on the opengl side of things.

609
00:33:26,000 --> 00:33:29,400
if you remember correctly, we started with our

610
00:33:31,400 --> 00:33:32,200
Let's see here.

611
00:33:34,300 --> 00:33:34,800
Here we go.

612
00:33:36,000 --> 00:33:38,400
First thing I want to do is actually correct.

613
00:33:38,400 --> 00:33:40,700
Something that Martin's pointed out, one of the problems with

614
00:33:40,700 --> 00:33:43,700
programming opengl on stream is I don't have time to really read the

615
00:33:43,700 --> 00:33:46,000
docs much and opengl.

616
00:33:46,000 --> 00:33:49,900
I don't tend to know by heart just because I don't tend to really love

617
00:33:49,900 --> 00:33:51,500
Graphics, apis, if you couldn't tell.

618
00:33:52,300 --> 00:33:56,700
So I usually just make my own and then I kind of just write a little

619
00:33:56,700 --> 00:33:59,700
binding layer and read the docs for a few weeks to get the right

620
00:33:59,700 --> 00:34:00,200
stuff.

621
00:34:00,800 --> 00:34:04,000
But I tend to not think in terms of opengl or anything.

622
00:34:04,200 --> 00:34:04,700
That.

623
00:34:05,100 --> 00:34:11,600
So I sometimes make errors in the minutiae and in this case Martin's

624
00:34:11,600 --> 00:34:15,199
pointed out that validate looking at the validate status to get

625
00:34:15,199 --> 00:34:18,699
compile errors isn't necessary and perhaps not wanted because

626
00:34:18,699 --> 00:34:22,400
validation what it does is it checks the entire state of a program

627
00:34:22,400 --> 00:34:25,600
including whether or not things like the arrays that are bound at the

628
00:34:25,600 --> 00:34:30,400
time to take vertices are compliant with that vertex Shader and stuff

629
00:34:30,400 --> 00:34:30,900
like that.

630
00:34:31,100 --> 00:34:32,699
We didn't want any of that sort of thing.

631
00:34:32,699 --> 00:34:34,000
We didn't want a full validation.

632
00:34:34,100 --> 00:34:34,300
Ian.

633
00:34:34,400 --> 00:34:39,199
So really all we need to do here when we check the status is we really

634
00:34:39,199 --> 00:34:44,600
just wanted the Lincoln compiled status so we can get the link status

635
00:34:45,199 --> 00:34:46,800
and compiled status like so.

636
00:34:47,199 --> 00:34:51,000
And so what we can do is say you know link validated

637
00:34:53,400 --> 00:34:54,900
Compiled validated.

638
00:34:59,100 --> 00:35:00,200
LinkedIn compiled.

639
00:35:09,500 --> 00:35:12,000
And then we've got a way to check, like, okay, if we linked and

640
00:35:12,000 --> 00:35:13,400
compile their, if we didn't.

641
00:35:14,100 --> 00:35:16,600
So I'm just going to go ahead and grab those in just to make that.

642
00:35:16,600 --> 00:35:19,800
Because that's, I don't want to leave that in sort of a, not quite the

643
00:35:19,800 --> 00:35:23,000
right way to do it state.

644
00:35:24,000 --> 00:35:27,000
So let me just go ahead and get core are about here.

645
00:35:28,100 --> 00:35:28,500
Oops.

646
00:35:31,000 --> 00:35:32,300
And I'm going to grab those guys.

647
00:35:39,100 --> 00:35:44,000
All right, and we'll leave out its ass in there because we may want to

648
00:35:44,000 --> 00:35:46,900
do validation later on so we probably want to keep that going.

649
00:35:48,000 --> 00:35:52,700
All right, so now in theory, if we run this we should be able to still

650
00:35:52,700 --> 00:35:55,700
get compile errors on it which is what we wanted.

651
00:35:56,200 --> 00:35:59,800
Here's that that Shader validation failed and if we look

652
00:36:00,000 --> 00:36:05,100
Get we get the logs that we wanted which is what we which is what

653
00:36:05,100 --> 00:36:05,800
we're doing before.

654
00:36:06,700 --> 00:36:13,000
So what we want to do now is we want to actually start doing some of

655
00:36:13,000 --> 00:36:15,600
these shaders, we want to try to compile the Shader.

656
00:36:16,600 --> 00:36:19,400
Martin's also pointed out that that

657
00:36:21,000 --> 00:36:27,500
In 20 in, in visual studio 2013, which is the version we are using on

658
00:36:27,500 --> 00:36:34,800
handmade hero, you can use the multi-line strings.

659
00:36:35,200 --> 00:36:40,800
It does have that support as in 2013, apparently, I've never tried it

660
00:36:41,100 --> 00:36:42,100
but he said you can.

661
00:36:42,800 --> 00:36:49,700
And what that means is that we could do something that allowed well,

662
00:36:49,700 --> 00:36:50,700
here I'll bring it up.

663
00:36:57,400 --> 00:36:58,700
Do we have a?

664
00:37:06,500 --> 00:37:10,300
So this one right here is the one we're talking about.

665
00:37:11,000 --> 00:37:14,900
I don't know if the here doc stuff.

666
00:37:19,700 --> 00:37:23,200
yeah, you can ignore the rest of this for now, but

667
00:37:25,000 --> 00:37:29,100
You can see here how this stuff works where you can say.

668
00:37:29,100 --> 00:37:34,500
Okay you've got this are prefix where you're basically saying, hey,

669
00:37:34,700 --> 00:37:38,800
this is going to be a string because I don't know if you remember, if

670
00:37:39,100 --> 00:37:39,900
I don't remember forever.

671
00:37:39,900 --> 00:37:41,000
Did wide strings?

672
00:37:41,000 --> 00:37:46,700
I don't know that we ever actually did that but in C++, you can prefix

673
00:37:46,800 --> 00:37:50,700
for example, a string with an l and the L prefix means that it's going

674
00:37:50,700 --> 00:37:54,000
to be a 16, a utf-16 string, right?

675
00:37:54,500 --> 00:37:57,300
Um and you can see some other things in here where they've got some

676
00:37:57,300 --> 00:37:58,500
other prefixes, right?

677
00:37:58,500 --> 00:38:02,400
But basically what this is is something that pre that comes before the

678
00:38:02,400 --> 00:38:06,300
quote that will tell you, this is a that will tell the C compiler.

679
00:38:06,300 --> 00:38:10,200
This is a special kind of string and this kind of string is basically

680
00:38:10,200 --> 00:38:14,200
a way of saying, hey I'm going to put a delimiter in here.

681
00:38:14,200 --> 00:38:17,800
That's going to tell you when you can end.

682
00:38:17,800 --> 00:38:20,300
And so there's going to be a delimiter, followed by an open

683
00:38:20,300 --> 00:38:23,400
parenthesis and the closed parenthesis, and then another delimiter.

684
00:38:23,400 --> 00:38:24,300
And I'm going to

685
00:38:24,500 --> 00:38:28,400
Guarantee to you that that delimiter will never appear anywhere in

686
00:38:28,400 --> 00:38:28,800
here.

687
00:38:29,200 --> 00:38:32,200
So basically, I'm going to give you the way of telling when you've got

688
00:38:32,200 --> 00:38:36,300
to the end and that again, is we talked about, this is the here docs

689
00:38:36,300 --> 00:38:36,800
for it.

690
00:38:36,800 --> 00:38:42,200
I didn't think that that was in 2013 yet, but Martin says it is, so

691
00:38:42,200 --> 00:38:43,100
that's good.

692
00:38:43,100 --> 00:38:46,800
If we can do it because at that means we could make our shaders pretty

693
00:38:46,800 --> 00:38:47,900
conveniently, right?

694
00:38:48,900 --> 00:38:51,400
That means we could do something like this.

695
00:38:56,900 --> 00:38:58,200
And then close it like this.

696
00:39:01,700 --> 00:39:08,100
And then we don't actually have to do anything bizarre.

697
00:39:09,900 --> 00:39:10,800
In theory anyway.

698
00:39:12,000 --> 00:39:12,800
If it worked.

699
00:39:13,700 --> 00:39:16,000
Now, I don't know if it will but that's the.

700
00:39:16,200 --> 00:39:16,600
Yep.

701
00:39:16,600 --> 00:39:17,100
And it does.

702
00:39:17,400 --> 00:39:20,900
So I guess we can actually use those, those hear Doc's, which is

703
00:39:20,900 --> 00:39:21,400
awesome.

704
00:39:22,600 --> 00:39:25,600
It also means we can write our shaders and include them in line if

705
00:39:25,600 --> 00:39:26,300
we'd like to.

706
00:39:27,000 --> 00:39:29,300
So, we could write them as separate files if we want them to be

707
00:39:29,300 --> 00:39:33,000
separate files, but we can sort of cross that bridge when we get a

708
00:39:33,000 --> 00:39:35,300
little further down the road.

709
00:39:38,000 --> 00:39:39,700
So, let's go ahead and try this here.

710
00:39:44,300 --> 00:39:44,700
Oops.

711
00:39:52,500 --> 00:39:54,900
I don't know when they added this but it's nice that they did.

712
00:39:58,700 --> 00:40:00,000
I wonder if it's in 2012.

713
00:40:00,700 --> 00:40:02,700
I don't know when it's, when I don't know when it made it in there

714
00:40:03,400 --> 00:40:03,900
anyway.

715
00:40:04,100 --> 00:40:04,400
Hmm.

716
00:40:16,900 --> 00:40:18,800
Let Stoops don't need that.

717
00:40:19,700 --> 00:40:22,300
So you know, if we take a look at how that works,

718
00:40:25,000 --> 00:40:28,300
I guess there's really probably not a lot of.

719
00:40:29,700 --> 00:40:33,800
You know, I'm a I'm assuming that pound includes in here would not be

720
00:40:33,800 --> 00:40:39,900
parsed so we would still if even if we wanted to write a file that had

721
00:40:39,900 --> 00:40:43,700
the Shader and it would probably still have to put the r: in front of

722
00:40:43,700 --> 00:40:43,800
it.

723
00:40:43,800 --> 00:40:45,000
I would guess.

724
00:40:48,700 --> 00:40:51,100
But, you know, that's probably okay.

725
00:40:54,300 --> 00:40:58,800
So, still not quite ideal for our purposes, I guess.

726
00:41:01,800 --> 00:41:05,400
But nothing you can do about it, all right.

727
00:41:07,900 --> 00:41:08,500
So here we go.

728
00:41:09,200 --> 00:41:11,600
Here is our header code, here's our vertex code and here's our

729
00:41:11,600 --> 00:41:12,400
fragment code.

730
00:41:13,200 --> 00:41:16,600
And essentially what we need to do now is we need to sort of learn the

731
00:41:16,800 --> 00:41:21,900
structural syntax of these shaders so that you can do useful stuff

732
00:41:21,900 --> 00:41:22,400
with them.

733
00:41:22,700 --> 00:41:28,100
And one of the things that typically helps, if you can find it and

734
00:41:28,200 --> 00:41:30,100
we'll have to talk about the versioning a little bit here.

735
00:41:30,100 --> 00:41:34,600
But if you can find, it is a, this Shader is fast.

736
00:41:35,100 --> 00:41:37,200
This Shader language is called.

737
00:41:37,700 --> 00:41:39,800
Sell right, the GL shading language.

738
00:41:41,000 --> 00:41:48,400
And if you use that glsl search term and look for a glsl like version,

739
00:41:48,500 --> 00:41:52,200
you know, like one point three quick reference card.

740
00:41:56,200 --> 00:41:57,500
Hopefully, you can find one.

741
00:42:00,200 --> 00:42:00,800
Here we go.

742
00:42:01,100 --> 00:42:08,500
I think 130 is the version number for whatever reason on opengl

743
00:42:08,800 --> 00:42:10,600
shading, Shader language 3.2.

744
00:42:10,600 --> 00:42:16,400
I think, maybe I can't quite remember what the version numbering is

745
00:42:16,400 --> 00:42:17,300
the version numbering on.

746
00:42:17,300 --> 00:42:18,500
These is really weird.

747
00:42:19,300 --> 00:42:25,000
That's the reason I typed in 1.3, you don't put pound 320 to do a

748
00:42:25,100 --> 00:42:25,800
Shader.

749
00:42:26,900 --> 00:42:29,200
In this one, you do pound.

750
00:42:30,100 --> 00:42:33,100
You'll see that in a second, if it sounds like I'm babbling about it.

751
00:42:33,100 --> 00:42:34,000
Let me take a look here.

752
00:42:35,400 --> 00:42:39,300
So, version directive.

753
00:42:52,500 --> 00:42:53,700
So it's this thing.

754
00:42:56,700 --> 00:43:00,200
Basically what happens here is you can kind of take a look and see

755
00:43:00,200 --> 00:43:05,700
like okay so if I want the you know to select a Shader version that's

756
00:43:05,700 --> 00:43:09,500
going to be backwards compatible to sort of older things you know you

757
00:43:09,500 --> 00:43:14,600
can go back to say opengl 3.0 or 3.2 and pick out one of the version

758
00:43:14,600 --> 00:43:18,500
numbers and unfortunately the version numbers don't correspond with

759
00:43:18,500 --> 00:43:21,700
the opengl versions because reasons.

760
00:43:23,100 --> 00:43:26,300
So typically what ends up happening is the pound is

761
00:43:27,300 --> 00:43:31,400
You have to pick a version of the language to say what your Shader

762
00:43:31,400 --> 00:43:34,500
because the Shader does get the Shader versions are not backwards

763
00:43:34,500 --> 00:43:35,600
compatible with each other.

764
00:43:35,800 --> 00:43:38,300
So you have to pick a version that you're going to use.

765
00:43:38,300 --> 00:43:41,600
And once you pick that version, the first thing you have to do inside

766
00:43:41,600 --> 00:43:44,700
the Shader code is say what version it is that you think you're

767
00:43:44,700 --> 00:43:48,400
actually trying to use so that you can guarantee that the compiler

768
00:43:48,400 --> 00:43:50,900
will know what you were looking for, right?

769
00:43:52,800 --> 00:43:55,900
So in our case, we can probably get away since we're doing, we're not

770
00:43:55,900 --> 00:43:59,100
really doing much of anything in the Shader at this point.

771
00:43:59,100 --> 00:44:01,700
We can probably get away with just using Shader 3.0.

772
00:44:01,700 --> 00:44:05,500
Let's say so a pound 130 version would be fine.

773
00:44:06,100 --> 00:44:10,000
And so what we can do here is just say, all right give us Shader

774
00:44:10,000 --> 00:44:11,200
version 130.

775
00:44:11,500 --> 00:44:12,000
Okay.

776
00:44:12,700 --> 00:44:14,700
And in theory that should work just fine.

777
00:44:14,700 --> 00:44:16,400
Oops don't need to put that in all of them.

778
00:44:16,400 --> 00:44:17,700
I can just put that in the shared header.

779
00:44:20,100 --> 00:44:21,700
So in theory that should be fine if I

780
00:44:21,900 --> 00:44:25,800
This code, I would assume that we will not get any complaints about

781
00:44:25,800 --> 00:44:27,800
that and I am correct about this.

782
00:44:28,100 --> 00:44:30,000
There is no problems there, right?

783
00:44:31,400 --> 00:44:31,900
So,

784
00:44:33,400 --> 00:44:36,900
Once we have that and we know what version were in having the quick

785
00:44:36,900 --> 00:44:39,800
reference card up is nice because the quick reference card will tell

786
00:44:39,800 --> 00:44:44,400
you everything you need to know about what exists in this version of

787
00:44:44,400 --> 00:44:48,100
opengl Shader language which is not always easy to remember.

788
00:44:48,300 --> 00:44:55,500
Because even once, you know what those are, you may not remember which

789
00:44:55,500 --> 00:44:57,000
ones go with which versions.

790
00:44:57,600 --> 00:44:59,700
Now this looks to me like the API.

791
00:45:00,000 --> 00:45:00,800
So here's okay.

792
00:45:00,800 --> 00:45:01,400
Here we go.

793
00:45:01,600 --> 00:45:06,300
Opengl shading language 150, quick reference card.

794
00:45:06,300 --> 00:45:06,800
Here you go.

795
00:45:08,100 --> 00:45:13,000
Although I gotta be honest, this doesn't look like the one I actually

796
00:45:13,000 --> 00:45:14,000
wanted.

797
00:45:14,100 --> 00:45:15,800
Okay, here's the guy, there's more of it.

798
00:45:15,900 --> 00:45:16,600
Yeah, here we go.

799
00:45:16,600 --> 00:45:18,200
I was like, I wanted more than that.

800
00:45:18,800 --> 00:45:20,500
So right here is where it starts.

801
00:45:21,200 --> 00:45:24,800
Okay, so the reason I think it's good to have one of these up.

802
00:45:24,800 --> 00:45:27,200
Like I said is it's hard to remember all the stuff that's in there

803
00:45:27,200 --> 00:45:29,700
even after you kind of are more familiar with it.

804
00:45:30,000 --> 00:45:33,500
So I like to have one of these so second to remember oh wait is there

805
00:45:33,500 --> 00:45:36,900
a function that lets me sample a texture at a particular level of

806
00:45:36,900 --> 00:45:37,700
detail?

807
00:45:38,200 --> 00:45:40,200
You know, an integer position or whatever?

808
00:45:40,200 --> 00:45:40,800
Blah, blah blah.

809
00:45:40,800 --> 00:45:43,300
And you're like, oh yeah, okay it does or doesn't have that.

810
00:45:43,300 --> 00:45:47,000
It's easy to kind of look through here and see whether that's in there

811
00:45:47,000 --> 00:45:49,100
rather than trying to learn it and remember it all.

812
00:45:50,900 --> 00:45:52,500
So that's kind of nice.

813
00:45:53,000 --> 00:45:57,400
But anyway, what you can see in terms of how this breaks down, you can

814
00:45:57,400 --> 00:45:59,600
see in here, this is the version directive stuff.

815
00:46:00,000 --> 00:46:02,700
And like I said, we're not going to use full of 150 because I don't

816
00:46:02,700 --> 00:46:03,500
think we need it.

817
00:46:03,800 --> 00:46:05,000
So there might be some things in here.

818
00:46:05,000 --> 00:46:07,800
We can't access, but most of the things, we should be able to access

819
00:46:07,800 --> 00:46:08,300
just fine.

820
00:46:09,000 --> 00:46:13,000
You can see on here that a lot of the stuff is very self-explanatory,

821
00:46:13,000 --> 00:46:13,500
right?

822
00:46:13,600 --> 00:46:15,800
Like you can see all the types that exist in glsl.

823
00:46:15,800 --> 00:46:19,500
They're all types that we have that we have written ourselves, sort of

824
00:46:20,500 --> 00:46:24,100
In handmade hero, which is like you know, Vic to vector v of X.

825
00:46:24,100 --> 00:46:28,100
For all very familiar to you, you've got vectors of Boolean factors of

826
00:46:28,100 --> 00:46:29,400
integers, just like we did.

827
00:46:29,500 --> 00:46:32,000
Sometimes we would create, you know, other things.

828
00:46:32,800 --> 00:46:36,100
You've got the matrices for 2x2 3x3 for my for, right?

829
00:46:36,100 --> 00:46:40,500
And you've got ones that are abnormally size as well like a 2, by 3

830
00:46:40,500 --> 00:46:41,100
Matrix.

831
00:46:41,800 --> 00:46:43,700
So all that stuff is very familiar.

832
00:46:44,000 --> 00:46:46,400
Some of the other stuff is probably not so familiar.

833
00:46:46,900 --> 00:46:48,500
You've got floating points a types.

834
00:46:48,500 --> 00:46:50,300
This is things that sample from textures.

835
00:46:50,400 --> 00:46:51,100
It is just a types.

836
00:46:51,100 --> 00:46:54,800
Also, Sam from textures, you got implicit conversions, that will tell

837
00:46:54,800 --> 00:46:56,600
you how their conversions work.

838
00:46:56,600 --> 00:46:59,100
You can see here, they've got good Vistaprint.

839
00:46:59,100 --> 00:47:04,200
Just like just like in C you can create a raised structures and blocks

840
00:47:04,200 --> 00:47:06,900
just like you can see blocks are special.

841
00:47:07,200 --> 00:47:08,600
They're not something that you've seen in.

842
00:47:08,600 --> 00:47:09,000
See.

843
00:47:09,300 --> 00:47:14,300
It block is basically just a structure style thing that lets, you

844
00:47:14,300 --> 00:47:19,400
know, that something corresponds to a piece of code, you're going to

845
00:47:19,400 --> 00:47:20,300
talk about in your

846
00:47:20,400 --> 00:47:20,900
In line.

847
00:47:20,900 --> 00:47:24,500
Because one of the things that you'll see us have to do, as we get a

848
00:47:24,500 --> 00:47:27,500
little further down, is figure out how to get data into these shaders

849
00:47:27,500 --> 00:47:32,500
from the outside, from our code, all the operators are the same pretty

850
00:47:32,500 --> 00:47:36,100
much is what you've expectancy with some subtle differences so mostly

851
00:47:36,100 --> 00:47:37,700
you can use your intuition here.

852
00:47:37,700 --> 00:47:42,400
You know, you've got assignments and bitwise operators, logical,

853
00:47:42,400 --> 00:47:45,800
operators shifting multiplication, all that stuff.

854
00:47:45,800 --> 00:47:50,000
Most of the things you're used to having our their parentheses all

855
00:47:50,000 --> 00:47:50,200
that.

856
00:47:50,400 --> 00:47:52,600
Duff is exactly as expect.

857
00:47:52,700 --> 00:47:55,700
For Vector components is exactly like see where you do the bracketed

858
00:47:55,700 --> 00:47:56,300
initialize list.

859
00:47:56,300 --> 00:47:59,500
So the people who made these shade languages, we're see.

860
00:47:59,600 --> 00:47:59,800
See

861
00:48:00,000 --> 00:48:02,300
People, they made it look like sea.

862
00:48:02,400 --> 00:48:07,200
And so most of the stuff that you expect to be there is there.

863
00:48:07,700 --> 00:48:09,300
You also have tons of built-in functions.

864
00:48:09,300 --> 00:48:11,600
So you get a math library that comes with this.

865
00:48:12,500 --> 00:48:15,700
That's built in either to the car door to the shading compiler.

866
00:48:15,700 --> 00:48:18,400
One of the other you don't necessarily know which at any given time

867
00:48:18,400 --> 00:48:22,500
but you they're guaranteed generally to be reasonably performant for

868
00:48:22,500 --> 00:48:24,600
whatever the operation is what you could expect.

869
00:48:24,600 --> 00:48:28,200
So things like sine cosine, tangent, taking the max to the minimum,

870
00:48:28,200 --> 00:48:29,900
doing a mod, a ceiling a

871
00:48:30,000 --> 00:48:35,500
The floor rounding all that sort of stuff.

872
00:48:35,500 --> 00:48:35,800
I guess.

873
00:48:35,800 --> 00:48:37,600
Florida, they don't have in there.

874
00:48:37,600 --> 00:48:41,900
Yes, I guess you'd have to use you use frak that I don't see floor in

875
00:48:41,900 --> 00:48:42,000
here.

876
00:48:42,000 --> 00:48:42,800
Oh no, there it is.

877
00:48:42,800 --> 00:48:43,600
That's what they should be there.

878
00:48:44,100 --> 00:48:45,700
Flora truncation taking the sign.

879
00:48:45,700 --> 00:48:48,600
Absolute value Powers logs blah, blah, blah, blah blah.

880
00:48:48,600 --> 00:48:51,300
So you've got a full math library in there as well.

881
00:48:51,300 --> 00:48:53,800
Linear interpolation is here, they call it mix.

882
00:48:55,200 --> 00:48:58,800
So it also a smooth step function which is like a little like cubic

883
00:48:58,800 --> 00:48:59,100
curve.

884
00:48:59,100 --> 00:48:59,900
So to like

885
00:49:00,000 --> 00:49:01,000
Then he's out of stuff.

886
00:49:01,400 --> 00:49:04,500
So there's a lot of things you can do here, dot products, cross

887
00:49:04,500 --> 00:49:07,900
products, take the distance, all the things we implemented in our math

888
00:49:07,900 --> 00:49:11,800
library and handmade hero are here and probably some that aren't.

889
00:49:12,600 --> 00:49:15,700
So they've got a lot of stuff to work with and then you've got a bunch

890
00:49:15,700 --> 00:49:18,200
of built-in functions for doing things like getting information from

891
00:49:18,200 --> 00:49:21,400
textures getting gradients which are things that we'll talk about.

892
00:49:21,400 --> 00:49:22,900
Potentially if we ever get to them, we don't know.

893
00:49:22,900 --> 00:49:25,900
We will noise values that sort of thing.

894
00:49:27,200 --> 00:49:28,800
So there you go, right.

895
00:49:29,500 --> 00:49:29,700
And

896
00:49:29,900 --> 00:49:34,200
So understanding how to program the opengl shading, language is pretty

897
00:49:34,200 --> 00:49:34,800
straightforward.

898
00:49:34,800 --> 00:49:37,100
You'll see, once we get going you have a lot of stuff at your

899
00:49:37,100 --> 00:49:37,600
disposal.

900
00:49:37,600 --> 00:49:38,900
It's all standardized.

901
00:49:39,100 --> 00:49:40,900
So you can just use everything that's here.

902
00:49:40,900 --> 00:49:45,800
And the compiler will make that into efficient GPU code, and you can

903
00:49:45,800 --> 00:49:46,700
just rely on it.

904
00:49:46,700 --> 00:49:48,700
Usually, there aren't a lot of surprises there.

905
00:49:49,700 --> 00:49:58,800
Okay, so now the way that this works is there is for whatever reason,

906
00:49:58,800 --> 00:49:59,700
a Mane.

907
00:50:00,000 --> 00:50:01,600
Did actually call it main.

908
00:50:02,400 --> 00:50:05,300
So we I don't think that's specified anywhere on here.

909
00:50:05,300 --> 00:50:07,700
So I guess you just kind of have to know, at least, I don't see it

910
00:50:07,700 --> 00:50:10,800
anywhere, maybe it's defined.

911
00:50:12,300 --> 00:50:13,100
Woohoo.

912
00:50:15,200 --> 00:50:16,400
Maybe it's defined on here somewhere.

913
00:50:16,400 --> 00:50:20,200
I'm not entirely certain, but you start off in a main just like you do

914
00:50:20,200 --> 00:50:21,100
at a sea program.

915
00:50:22,000 --> 00:50:26,800
And then one of the things that obviously is a little confusing is

916
00:50:27,300 --> 00:50:29,000
well, okay, so I've got two main.

917
00:50:29,000 --> 00:50:32,400
This thing is supposed to operate on 16 pixels or 16 vertices of the

918
00:50:32,400 --> 00:50:32,800
time.

919
00:50:33,000 --> 00:50:38,600
How do I say, what the result is like, how do I get information in?

920
00:50:39,000 --> 00:50:40,800
And how do I put information back?

921
00:50:41,100 --> 00:50:44,000
And the answer is, it's all done by global variables.

922
00:50:44,500 --> 00:50:46,800
And so let me show you how that happens.

923
00:50:48,700 --> 00:50:53,100
all right, so let's say, we're going to write some vertex code, for

924
00:50:53,100 --> 00:50:58,300
example, what we have to do in the vertex code, and I'll show you this

925
00:50:58,300 --> 00:50:59,800
in just a quick second here, but

926
00:51:00,900 --> 00:51:03,900
For starters, we have to have some kind of input.

927
00:51:03,900 --> 00:51:08,500
So we're going to have some kind of an input vertices here.

928
00:51:08,500 --> 00:51:10,300
So like input vertices

929
00:51:11,600 --> 00:51:13,500
Input vertex, right?

930
00:51:14,900 --> 00:51:16,800
We're going to have some kind of input predicts that we have to

931
00:51:16,800 --> 00:51:20,200
operate on and we're going to have to Define that as something, right?

932
00:51:20,600 --> 00:51:23,800
We're going to have a main here and we're going to have to Define that

933
00:51:23,900 --> 00:51:24,500
function.

934
00:51:25,100 --> 00:51:29,000
But essentially what we're going to do is also have after that and

935
00:51:29,000 --> 00:51:32,700
output vertex and we're going to have to write some code that does

936
00:51:32,700 --> 00:51:34,800
something along the lines of oops.

937
00:51:36,500 --> 00:51:40,800
Output vertex equals input vertex.

938
00:51:41,900 --> 00:51:44,300
And obviously, probably we're going to want something like our

939
00:51:44,300 --> 00:51:45,400
transform here.

940
00:51:49,800 --> 00:51:53,700
And so fundamentally speaking a Shader basically looks like this it's

941
00:51:53,700 --> 00:51:57,100
going to Define some Global variable called an input vertex and

942
00:51:57,100 --> 00:52:02,000
somehow and we're going to get to that later somehow that will get

943
00:52:02,100 --> 00:52:08,600
correspondent later on in our code with the vertices coming from our C

944
00:52:08,600 --> 00:52:09,000
code.

945
00:52:09,100 --> 00:52:13,900
So, our actual code for handmade hero in the game, will be setting

946
00:52:13,900 --> 00:52:17,200
some things so that the opengl subsystem knows what should go into

947
00:52:17,200 --> 00:52:17,800
input.

948
00:52:18,300 --> 00:52:21,300
We're going to define something that's an output for a text here and

949
00:52:21,300 --> 00:52:24,100
it won't actually probably called output vertex because you'll see in

950
00:52:24,100 --> 00:52:24,400
a second.

951
00:52:24,400 --> 00:52:27,100
It's got a special name but we're going to basically a sign that

952
00:52:27,100 --> 00:52:33,600
output vertex to whatever we do to our input vertices and then we're

953
00:52:33,600 --> 00:52:36,200
going to have some information, we're going to need like this

954
00:52:36,200 --> 00:52:36,900
transform.

955
00:52:37,000 --> 00:52:39,600
That's going to have to again come from handmade hero, that's going to

956
00:52:39,600 --> 00:52:43,100
do the transform and basically this is what a Shader is going to look

957
00:52:43,100 --> 00:52:47,800
like the main is essentially, in your head is going to be called for

958
00:52:47,900 --> 00:52:49,400
For every input vertex.

959
00:52:49,600 --> 00:52:54,600
So, every input vertex will go through whatever we write in here, and

960
00:52:54,600 --> 00:52:55,900
this can be as complicated as we want.

961
00:52:55,900 --> 00:52:58,200
This going to be many lines, we can call function, can have loops can

962
00:52:58,200 --> 00:53:01,600
have ifs, but at some point, we have to assign something to the output

963
00:53:01,600 --> 00:53:04,500
for a text and whatever ends up being assigned to the output per text.

964
00:53:04,500 --> 00:53:07,600
At the end is what will actually be output of the Shader.

965
00:53:08,400 --> 00:53:08,900
Okay.

966
00:53:09,300 --> 00:53:12,100
And again this even though it's input vertex output vertex and

967
00:53:12,100 --> 00:53:13,700
transform, it looks like it's only doing one thing.

968
00:53:13,700 --> 00:53:17,100
It's doing this for like 16 pixels at a time or more, right?

969
00:53:17,100 --> 00:53:17,800
I'm sorry 16.

970
00:53:18,000 --> 00:53:18,900
She's a time from work.

971
00:53:19,500 --> 00:53:23,300
Okay, so let's start with output vertex because that's the easiest

972
00:53:23,500 --> 00:53:25,900
instead of us defining, a global variable for this.

973
00:53:25,900 --> 00:53:30,300
What actually happens is opengl has already defined a global variable

974
00:53:30,300 --> 00:53:33,000
for this and I believe those are in here.

975
00:53:35,400 --> 00:53:36,200
Somewhere.

976
00:53:37,300 --> 00:53:37,900
Here you go.

977
00:53:39,200 --> 00:53:42,900
So you can see here is built in inputs outputs and constants.

978
00:53:43,400 --> 00:53:47,400
You can see here, all of them are specified for what we care about

979
00:53:47,600 --> 00:53:49,200
here is the vertex language.

980
00:53:49,600 --> 00:53:51,400
Here's what's coming in.

981
00:53:51,800 --> 00:53:55,200
We've got GL color, secondary color, and normal vertex multitec,

982
00:53:55,200 --> 00:53:57,200
scored and fog cord, right?

983
00:53:57,200 --> 00:53:57,900
That's I believe.

984
00:53:57,900 --> 00:53:59,800
If you're using the fixed function pipeline, those will be

985
00:54:00,000 --> 00:54:04,000
Again, otherwise you'll see there, you can Define your own and which

986
00:54:04,000 --> 00:54:09,100
is probably what we'll do a little bit later on but then in the

987
00:54:09,100 --> 00:54:16,500
outputs for this you end up having a glp position somewhere.

988
00:54:16,500 --> 00:54:17,100
There it is.

989
00:54:17,900 --> 00:54:21,500
A GL position which is going to be no, that's not trailer.

990
00:54:21,500 --> 00:54:22,100
Where is it?

991
00:54:22,900 --> 00:54:25,600
There should be an output to this summer.

992
00:54:25,600 --> 00:54:26,200
There it is.

993
00:54:27,200 --> 00:54:29,800
GL position this GL position.

994
00:54:30,500 --> 00:54:34,200
Is the actual output in clip coordinates it that's going to be the

995
00:54:34,200 --> 00:54:37,900
thing that we're actually using right that that the that the Shader

996
00:54:37,900 --> 00:54:39,000
will actually output.

997
00:54:39,300 --> 00:54:42,300
So this is automatically defined by opengl.

998
00:54:42,500 --> 00:54:46,000
As are these other ones clip vertex trip distance and point size we

999
00:54:46,000 --> 00:54:48,700
can output to if we want to override those things.

1000
00:54:48,700 --> 00:54:51,800
We have no need to have any of those values be set to anything.

1001
00:54:52,100 --> 00:54:54,400
We only care about the position because that's all we're using in the

1002
00:54:54,400 --> 00:54:55,000
pipeline.

1003
00:54:55,300 --> 00:54:59,000
So, this output vertex is actually just this

1004
00:55:00,700 --> 00:55:02,600
And it's already defined for us as a vector for.

1005
00:55:02,900 --> 00:55:03,900
So, effectively.

1006
00:55:03,900 --> 00:55:09,900
Opengl had this defined for us at the top of the program, but we're

1007
00:55:09,900 --> 00:55:12,700
not going to touch it because it's a special variable that it knows is

1008
00:55:12,700 --> 00:55:14,200
the output from the Shader.

1009
00:55:15,100 --> 00:55:19,200
So then we have what our inputs and our transform our.

1010
00:55:19,400 --> 00:55:23,500
And in this case, we have, I believe GL underscore vertex.

1011
00:55:23,500 --> 00:55:26,400
If we use the fixed function pipeline, I've never tried to use the

1012
00:55:26,400 --> 00:55:27,400
fixed function parameters.

1013
00:55:27,700 --> 00:55:29,100
Let's give it a shot.

1014
00:55:29,900 --> 00:55:33,600
I don't know if it'll work or not, probably won't and we can go ahead

1015
00:55:33,600 --> 00:55:36,700
and go to the, the primary way to do it, which is what we want to get

1016
00:55:36,700 --> 00:55:38,200
to anyway, but we'll put it in there for now.

1017
00:55:39,300 --> 00:55:45,800
So effectively, there's this being defined as well, which is the input

1018
00:55:45,800 --> 00:55:46,800
vertex in this case.

1019
00:55:47,000 --> 00:55:48,800
So we can do this.

1020
00:55:48,800 --> 00:55:49,200
Oops,

1021
00:55:54,400 --> 00:55:57,500
And so this is just saying the output is equal to the transform of the

1022
00:55:57,500 --> 00:55:59,400
input vertex vertex coordinates.

1023
00:55:59,400 --> 00:56:02,600
So the x y z w here is going to get multiplied by transforming it's

1024
00:56:02,600 --> 00:56:07,000
going to Output 2 GL position that is all we need if we had this

1025
00:56:07,000 --> 00:56:07,700
transform.

1026
00:56:07,800 --> 00:56:11,600
Now we know that this is a 4 by 4 Matrix, right?

1027
00:56:11,700 --> 00:56:15,700
And you can see in here, you got Matt, and we could do Matt for or we

1028
00:56:15,700 --> 00:56:17,200
can type it in Matt 4x4.

1029
00:56:17,200 --> 00:56:18,400
Either one will work.

1030
00:56:19,100 --> 00:56:20,000
I'd like Matt 4x4.

1031
00:56:20,000 --> 00:56:21,900
It's a little clearer so maybe I'll leave it that way.

1032
00:56:23,900 --> 00:56:28,200
We we know we want to map 4x4 transform here but what we don't know is

1033
00:56:28,200 --> 00:56:30,000
where this would come from, right?

1034
00:56:30,000 --> 00:56:33,700
Because remember this is going to get called from our code in our

1035
00:56:33,700 --> 00:56:34,500
code.

1036
00:56:34,600 --> 00:56:39,000
This this is going to be executed on the GPU when we try to dispatch a

1037
00:56:39,000 --> 00:56:42,500
batch of criminals right when we try to do some rendering like a GL,

1038
00:56:42,500 --> 00:56:46,200
begin GL end that batch of vertices is going to have to go through

1039
00:56:46,200 --> 00:56:47,000
this Shader.

1040
00:56:47,500 --> 00:56:49,900
Where does the transform come from right?

1041
00:56:50,000 --> 00:56:52,900
How is it going to get there because it needs to get past effectively.

1042
00:56:53,000 --> 00:56:57,900
We from our C code in handmade hero to the code operating on the GPU.

1043
00:56:57,900 --> 00:56:59,100
And how is that going to happen?

1044
00:57:00,000 --> 00:57:05,000
Well, the way that happens is this thing called a uniform, which when

1045
00:57:05,000 --> 00:57:09,400
you declare something as a uniform, what that's trying to say is this

1046
00:57:09,400 --> 00:57:11,800
is something that doesn't vary per vertex.

1047
00:57:11,800 --> 00:57:14,500
That's where the term uniform comes from, right?

1048
00:57:14,500 --> 00:57:17,200
It doesn't vary depending on the thing.

1049
00:57:17,200 --> 00:57:21,100
I'm operating on it's going to be set by somebody and then all of the

1050
00:57:21,100 --> 00:57:24,500
vertices that come down in a set, are going to use it.

1051
00:57:24,500 --> 00:57:29,100
So what that means is we can set these uniforms before.

1052
00:57:30,000 --> 00:57:34,800
Execute a Shader and those uniforms will then be able to be

1053
00:57:34,800 --> 00:57:36,800
communicated from our C code, right?

1054
00:57:38,000 --> 00:57:39,900
So how that works?

1055
00:57:42,400 --> 00:57:45,500
Is, if you come up here and you can see render group entry render

1056
00:57:45,500 --> 00:57:46,400
entry bitmap, right?

1057
00:57:46,400 --> 00:57:50,400
This is the code that we want to have happen.

1058
00:57:51,300 --> 00:57:55,700
What we would do is in this code, we would have a called here and

1059
00:57:55,700 --> 00:57:56,300
we'll have to look up.

1060
00:57:56,300 --> 00:57:57,200
What that call is, right?

1061
00:57:57,200 --> 00:57:59,800
It's GL uniform, but, you know, I want to show it to you in, whatever

1062
00:58:00,700 --> 00:58:05,600
they'll be a call, which will say, all right, I want you to bind and

1063
00:58:05,600 --> 00:58:08,300
it won't quite work this way because we'll have to look it up first.

1064
00:58:08,300 --> 00:58:10,100
In fact, it's more like this sort of thing.

1065
00:58:22,100 --> 00:58:27,200
What we will effectively have to do is take the transform that we want

1066
00:58:27,200 --> 00:58:30,500
to be used here and that transform again.

1067
00:58:30,500 --> 00:58:38,000
We actually do know what it is because we load it right here right we

1068
00:58:38,000 --> 00:58:43,500
do this load Matrix M for my for proj transpose this sort of thing.

1069
00:58:44,400 --> 00:58:45,800
What we can do is just say oh

1070
00:58:47,900 --> 00:58:50,000
okay, let's just

1071
00:58:52,500 --> 00:58:55,200
let's just keep this project around, right?

1072
00:58:55,200 --> 00:58:58,200
Every time we come through and we generate the four, by four Matrix, I

1073
00:58:58,200 --> 00:59:04,100
can now specify that, I want that Matrix to be the Matrix that gets

1074
00:59:04,100 --> 00:59:09,500
used every time that you're going to do one of these things, right?

1075
00:59:09,700 --> 00:59:10,900
So when we do this,

1076
00:59:15,400 --> 00:59:18,900
Specification here, what we can do is say we need to know what the

1077
00:59:18,900 --> 00:59:23,200
ideas of this transform, and then we need to set that transform to be

1078
00:59:23,200 --> 00:59:24,800
this value, right?

1079
00:59:25,400 --> 00:59:30,700
And so what this will do is this will tell opengl, hey, this line will

1080
00:59:30,700 --> 00:59:32,600
say, go look at the Shader

1081
00:59:33,800 --> 00:59:38,100
Figure out what your you know, what is the ID?

1082
00:59:38,100 --> 00:59:38,400
You know?

1083
00:59:38,400 --> 00:59:38,900
Basically.

1084
00:59:38,900 --> 00:59:43,100
What do you what do you use to talk about the location where this

1085
00:59:43,100 --> 00:59:43,800
string?

1086
00:59:44,700 --> 00:59:46,600
This strings name goes right?

1087
00:59:46,600 --> 00:59:47,200
In other words.

1088
00:59:47,900 --> 00:59:48,700
I should explain this.

1089
00:59:49,000 --> 00:59:49,500
So,

1090
00:59:52,100 --> 00:59:54,100
We've got something that says uniform.

1091
00:59:59,700 --> 00:59:59,800
Matt.

1092
01:00:00,000 --> 01:00:02,900
Four by four transform.

1093
01:00:07,100 --> 01:00:09,500
And then blah blah blah blah Shader, right?

1094
01:00:09,500 --> 01:00:10,600
Here's my shooter code.

1095
01:00:13,800 --> 01:00:17,200
So, you know, all right, I've got uniform at forward for a transform.

1096
01:00:17,200 --> 01:00:21,900
I've got some Shader stuff here and I need to be able to set this,

1097
01:00:22,100 --> 01:00:22,700
right?

1098
01:00:22,900 --> 01:00:27,600
So what's going to happen when opengl compiles this down, right?

1099
01:00:27,700 --> 01:00:29,400
This is going to go through the compiler.

1100
01:00:32,600 --> 01:00:36,500
Is it's going to go through a compiler specific to the GPU.

1101
01:00:36,600 --> 01:00:39,900
So on this machine it's AMD so it's going to go through amd's compiler

1102
01:00:39,900 --> 01:00:44,500
and it's going to Output a bunch of AMD right machine code.

1103
01:00:48,200 --> 01:00:51,800
So this is stuff that's going to be run on the AMD core, right?

1104
01:00:52,200 --> 01:00:55,700
So all of our Shader instructions are going to get compiled down just

1105
01:00:55,700 --> 01:00:57,200
like they would have got compiled down.

1106
01:00:58,500 --> 01:01:02,100
If it was regular C code to exit x64, they're going to get compiled

1107
01:01:02,100 --> 01:01:03,400
down to MD machine code.

1108
01:01:03,600 --> 01:01:08,800
That AMD machine code is going to be referencing a specific location

1109
01:01:08,800 --> 01:01:12,300
in memory where it expects this transform to be.

1110
01:01:12,500 --> 01:01:15,100
It's going to expect 16 floats.

1111
01:01:15,900 --> 01:01:20,500
Right to be somewhere in memory and it will have picked where that is.

1112
01:01:20,700 --> 01:01:26,100
So it will have an address that it knows it's going to grab.

1113
01:01:26,100 --> 01:01:29,200
When it goes to execute this Shader, this machine code will be looking

1114
01:01:29,400 --> 01:01:30,400
at that address.

1115
01:01:30,400 --> 01:01:33,600
Now that address is relative to the core because obviously it's

1116
01:01:33,600 --> 01:01:35,800
working on a particular batch at that time.

1117
01:01:36,000 --> 01:01:40,000
So it's not like it's necessarily a fixed address in the GPS memory

1118
01:01:40,100 --> 01:01:45,000
for all time but it has some idea of for a particular execution.

1119
01:01:45,000 --> 01:01:45,400
There's some

1120
01:01:45,700 --> 01:01:49,200
Will memory for this execution and where that is in here.

1121
01:01:49,200 --> 01:01:50,800
It knows, right?

1122
01:01:50,900 --> 01:01:54,200
So it's got, you know, we'll call it an offset address, where that's

1123
01:01:54,200 --> 01:01:55,100
supposed to be.

1124
01:01:56,000 --> 01:01:57,800
What we need to do is tell opengl.

1125
01:01:57,800 --> 01:02:00,500
Hey, we're going to give you that 16 floats.

1126
01:02:00,800 --> 01:02:01,900
Okay, here they are.

1127
01:02:02,100 --> 01:02:06,700
I need you to copy that down to the card and I need it to go into the

1128
01:02:06,700 --> 01:02:11,100
location where it needs to go for this Shader execution, right?

1129
01:02:11,800 --> 01:02:15,200
So what we're doing here is were saying, hey go look at when you

1130
01:02:15,200 --> 01:02:15,500
compile

1131
01:02:15,600 --> 01:02:16,400
All this Shader.

1132
01:02:16,600 --> 01:02:19,800
Tell me where this variable ended up, right?

1133
01:02:19,900 --> 01:02:21,200
Give me back a cookie.

1134
01:02:21,200 --> 01:02:24,500
Basically that I can use to talk to you about that location because I

1135
01:02:24,500 --> 01:02:26,900
don't need to know what it is, right?

1136
01:02:27,200 --> 01:02:30,200
I just need to tell you to put something there and here's me telling

1137
01:02:30,200 --> 01:02:32,900
you this is what I want to put there and then it will go down there,

1138
01:02:32,900 --> 01:02:33,400
right?

1139
01:02:33,400 --> 01:02:37,400
And then for this execution, the Shader for the GL, begins UGL, and

1140
01:02:37,400 --> 01:02:40,000
pair here, it will take that.

1141
01:02:41,200 --> 01:02:43,100
And use it, right?

1142
01:02:43,100 --> 01:02:46,000
It'll use that as the as the value of that variable.

1143
01:02:47,400 --> 01:02:48,700
So that's affected what we need to do.

1144
01:02:48,700 --> 01:02:52,200
Obviously we don't need to do this every time the like look up for the

1145
01:02:52,200 --> 01:02:55,700
name and that could be expensive for all we know.

1146
01:02:55,900 --> 01:02:58,300
So what we really want to do is have in here

1147
01:03:03,700 --> 01:03:05,600
Something like this, right?

1148
01:03:05,600 --> 01:03:08,000
Where our opengl that were using.

1149
01:03:08,600 --> 01:03:12,600
We can just say that it's a global because it's never going to change.

1150
01:03:12,800 --> 01:03:16,900
So when we do our initialization and we do create program, we're going

1151
01:03:16,900 --> 01:03:18,600
to want to do that, call down here.

1152
01:03:19,700 --> 01:03:19,900
Right?

1153
01:03:19,900 --> 01:03:21,600
So that it snapped and saved.

1154
01:03:22,700 --> 01:03:27,800
Okay, so that's how the vertex Shader code will work.

1155
01:03:27,800 --> 01:03:31,600
And we need to work out what those calls are obviously.

1156
01:03:31,700 --> 01:03:34,200
But other than that,

1157
01:03:35,900 --> 01:03:38,300
We are now okay to move forward.

1158
01:03:38,400 --> 01:03:40,600
So we have our GL position.

1159
01:03:40,600 --> 01:03:47,200
We're doing our transform there, and we've got our, our fragment code

1160
01:03:47,200 --> 01:03:50,600
now that we need to to create as well.

1161
01:03:50,900 --> 01:03:52,800
Same exact thing applies here.

1162
01:03:53,200 --> 01:03:55,700
We're going to have to define a main, and we're going to have to do

1163
01:03:55,700 --> 01:03:57,400
something with what's going on.

1164
01:03:57,400 --> 01:04:01,000
Oops, in terms of our inputs and outputs.

1165
01:04:01,200 --> 01:04:05,600
Now what you'll see here for the first time is we

1166
01:04:05,700 --> 01:04:11,700
Now, have a way that this needs to get communicated things have

1167
01:04:11,700 --> 01:04:14,800
communicated from the vertex Shader to the fragment Shader, which we

1168
01:04:14,800 --> 01:04:18,400
haven't had to do yet because remember this GL position is a special

1169
01:04:18,400 --> 01:04:20,000
variable that outputs the position.

1170
01:04:20,100 --> 01:04:22,800
The reason there's a special variable that I've put the position is

1171
01:04:22,800 --> 01:04:26,000
because it has to go into this piece that we don't control.

1172
01:04:26,100 --> 01:04:26,400
Oops.

1173
01:04:32,200 --> 01:04:35,000
Remember I said there's this rasterizer in between so we do some

1174
01:04:35,000 --> 01:04:35,100
stuff.

1175
01:04:35,100 --> 01:04:38,300
The vertex Shader, there's a rasterizer that rasterizes the triangles

1176
01:04:38,300 --> 01:04:41,400
then we get the French Quarter, this guy needs to know the positions

1177
01:04:41,400 --> 01:04:44,600
because it needs to know the corners of those vertices in order to

1178
01:04:44,600 --> 01:04:45,600
rasterize the triangle.

1179
01:04:45,600 --> 01:04:49,700
So GL position is defined as that communication, right?

1180
01:04:49,700 --> 01:04:51,300
GL position is the value.

1181
01:04:51,300 --> 01:04:53,600
You need to give the rasterizer for those vertices.

1182
01:04:53,600 --> 01:04:56,800
So we didn't have to Define that because it's already something that's

1183
01:04:56,800 --> 01:04:58,500
built in because the rasterizer has to know it.

1184
01:04:58,500 --> 01:05:00,500
So it has to be known to the glsl.

1185
01:05:00,500 --> 01:05:01,500
It has to be something that

1186
01:05:02,200 --> 01:05:05,200
Understands natively, it can't be a variable we Define.

1187
01:05:05,600 --> 01:05:10,800
However, we now get to something, we're in our fragment code, we

1188
01:05:10,800 --> 01:05:14,600
actually do need to know something, because we have to know what

1189
01:05:14,600 --> 01:05:18,600
texture we are going to be sampling from and we're right.

1190
01:05:19,200 --> 01:05:22,300
So we're going to have to have a texture coordinate that gets passed

1191
01:05:22,300 --> 01:05:23,700
down here, right?

1192
01:05:23,700 --> 01:05:26,900
We're going to have to have some way of getting texture coordinates in

1193
01:05:27,600 --> 01:05:31,100
and some way of outputting texture coordinates to the fragment Shader.

1194
01:05:32,700 --> 01:05:33,500
Now, I think about it though.

1195
01:05:33,500 --> 01:05:35,600
We can probably hold off on that for a second.

1196
01:05:36,500 --> 01:05:41,000
So hold that thought, actually, because we should probably get this

1197
01:05:41,000 --> 01:05:42,800
working with without textures first.

1198
01:05:44,000 --> 01:05:46,900
Alright, so in the fragment code, the same thing is true.

1199
01:05:46,900 --> 01:05:48,500
As in the vertex Shader code.

1200
01:05:48,900 --> 01:05:51,600
If you take a look at these vertex language built-in outputs and

1201
01:05:51,600 --> 01:05:52,200
constants, right?

1202
01:05:52,200 --> 01:05:53,800
You can see what all the them were there.

1203
01:05:54,600 --> 01:05:57,900
And then we've got the same is true for the fragment language so you

1204
01:05:57,900 --> 01:05:59,600
can see all the in values.

1205
01:06:00,000 --> 01:06:03,900
It, you've got the fragment coordinate the whether it was front facing

1206
01:06:04,000 --> 01:06:09,300
the clip distance, the point coordinates which are if you were doing a

1207
01:06:10,600 --> 01:06:11,700
the points right stuff.

1208
01:06:11,700 --> 01:06:12,100
That's same.

1209
01:06:12,100 --> 01:06:13,900
As the point size thing here it's again, not.

1210
01:06:13,900 --> 01:06:16,700
So when we care about what the Primitive ID was again, not something

1211
01:06:16,700 --> 01:06:18,700
we care about and the fragment death.

1212
01:06:19,400 --> 01:06:21,800
So you can see here, we've got some

1213
01:06:23,800 --> 01:06:26,500
We've got some inputs, none of which we really care about and we have

1214
01:06:26,500 --> 01:06:29,800
an output which we sort of care about potentially, right?

1215
01:06:29,800 --> 01:06:33,100
This is the depth value which we might care about, but you'll notice

1216
01:06:33,100 --> 01:06:35,200
the color actually, isn't there?

1217
01:06:36,100 --> 01:06:39,700
And the reason that the color isn't there, if I remember correctly, is

1218
01:06:39,700 --> 01:06:42,200
that actually for reasons?

1219
01:06:42,200 --> 01:06:49,900
I do not completely understand and really couldn't say what the reason

1220
01:06:49,900 --> 01:06:53,500
was instead of there being a predefined

1221
01:06:53,600 --> 01:06:55,400
Output for that.

1222
01:06:56,000 --> 01:07:00,200
You can actually just Define your own if I remember correctly.

1223
01:07:00,500 --> 01:07:09,200
Now, I thought that you could also use GL frag color and I feel like

1224
01:07:09,200 --> 01:07:10,900
that might be something that comes in a later.

1225
01:07:10,900 --> 01:07:12,400
Shader language version.

1226
01:07:12,600 --> 01:07:15,300
Meaning when they went up, in fact, let me just look to see if I'm

1227
01:07:15,300 --> 01:07:17,100
right about this because I'm just curious now

1228
01:07:37,800 --> 01:07:41,400
Yeah, okay so let's see.

1229
01:07:41,600 --> 01:07:46,700
No it's still not there so I guess maybe I'm just hallucinating about

1230
01:07:46,700 --> 01:07:47,200
that.

1231
01:07:47,600 --> 01:07:51,000
But anyway, what I was going to say beforehand before I kind of got

1232
01:07:51,000 --> 01:07:57,400
sidetracked on wondering whether or not that was true, is my

1233
01:07:57,400 --> 01:08:03,100
recollection, is that just whatever you define as an output variable

1234
01:08:04,700 --> 01:08:06,000
ends up being?

1235
01:08:06,100 --> 01:08:07,500
If the first one is,

1236
01:08:07,700 --> 01:08:10,900
The output color and if you define more than there are more output

1237
01:08:10,900 --> 01:08:14,400
colors that go to more buffers or something weird like this.

1238
01:08:16,300 --> 01:08:17,700
All right, so let's look at that for a second.

1239
01:08:18,700 --> 01:08:22,100
So as you can see here in the pre declared variable declarations, you

1240
01:08:22,100 --> 01:08:27,000
can see there's these ins and these outs those are not in C, right?

1241
01:08:27,000 --> 01:08:30,000
We never use in and out declarations and see because little variables

1242
01:08:30,000 --> 01:08:31,800
are just Global variables in shaders.

1243
01:08:31,899 --> 01:08:35,300
Since there are these pieces of code that kind of get welded together

1244
01:08:35,300 --> 01:08:37,000
with known things on either side.

1245
01:08:37,000 --> 01:08:37,500
Like the

1246
01:08:37,600 --> 01:08:40,600
Mance rayder has inputs from the vertex Shader and outputs pixel

1247
01:08:40,600 --> 01:08:41,100
values.

1248
01:08:41,200 --> 01:08:44,000
The vertex Shader has inputs from the tessellation of geometry

1249
01:08:44,000 --> 01:08:45,899
shaders, or the opengl pipeline itself.

1250
01:08:46,200 --> 01:08:49,700
And then has outputs that go to the fragment Shader, there's this

1251
01:08:49,700 --> 01:08:52,500
notion of in and out Global's because they're the things that the

1252
01:08:52,500 --> 01:08:54,800
context in which the Shader was being executed.

1253
01:08:54,800 --> 01:08:58,700
What comes in, what goes out, we can use those to say.

1254
01:08:58,700 --> 01:08:59,800
Okay, there's a now.

1255
01:09:00,000 --> 01:09:05,100
Variable here, it's going to be a vector for and it's going to be the

1256
01:09:05,100 --> 01:09:06,000
fragment color.

1257
01:09:10,500 --> 01:09:13,399
And then all we would do is say well, okay, whatever that is, let's

1258
01:09:13,399 --> 01:09:18,200
say the result color is effect for that's just read.

1259
01:09:19,700 --> 01:09:20,000
Right.

1260
01:09:20,000 --> 01:09:20,700
It's just red.

1261
01:09:23,700 --> 01:09:24,100
Okay.

1262
01:09:25,300 --> 01:09:30,000
And so again, this would in theory, be a completely usable pipeline,

1263
01:09:30,000 --> 01:09:34,600
if this transform value, we're set it would work, right?

1264
01:09:35,000 --> 01:09:39,300
It would be something that takes in vertex, coordinates transforms

1265
01:09:39,300 --> 01:09:42,300
them out to positions the positions get rasterized in between these

1266
01:09:42,300 --> 01:09:46,600
two then it calls the fragment code for each pixel or sample that got

1267
01:09:46,600 --> 01:09:47,399
rasterized.

1268
01:09:47,399 --> 01:09:51,899
It has to produce an output color so at least one output Vector for

1269
01:09:52,000 --> 01:09:53,399
has to be declared for the

1270
01:09:53,500 --> 01:09:56,700
What color the result color is going to always be set to read but in

1271
01:09:56,700 --> 01:09:58,700
the future, we'll set something more complicated.

1272
01:10:01,400 --> 01:10:02,300
And that's the end of it.

1273
01:10:03,000 --> 01:10:08,200
Now we have to go up here and actually put in this this code that I

1274
01:10:08,200 --> 01:10:12,500
was talking about before and since we have a quick reference card up

1275
01:10:12,500 --> 01:10:13,600
we might as well use it.

1276
01:10:14,100 --> 01:10:17,600
We actually have in here all of the stuff that you can use for

1277
01:10:17,600 --> 01:10:18,000
shaders.

1278
01:10:18,200 --> 01:10:21,100
You can see the uniform calls being talked about here.

1279
01:10:21,400 --> 01:10:23,000
This is all we really need.

1280
01:10:23,100 --> 01:10:23,800
You can see it here.

1281
01:10:23,800 --> 01:10:27,300
We've got uniform Matrix, f v.

1282
01:10:28,200 --> 01:10:33,300
There's the ENT location, the size, I count the Boolean transpose and

1283
01:10:33,300 --> 01:10:37,500
the consulate value that is exactly what we want, right?

1284
01:10:37,500 --> 01:10:40,400
We're trying to specify a uniform Matrix.

1285
01:10:41,500 --> 01:10:46,600
And again, we want it to be a 4 by 4 Matrix, which

1286
01:10:49,500 --> 01:10:52,000
They don't support.

1287
01:10:56,900 --> 01:10:59,300
Oh, I guess they don't support a 4 by 4.

1288
01:10:59,300 --> 01:11:01,100
So, you just put for, at the end of it.

1289
01:11:01,100 --> 01:11:01,500
All right?

1290
01:11:01,500 --> 01:11:02,200
So, whatever.

1291
01:11:02,800 --> 01:11:04,600
So that's effectively this, but they don't have it.

1292
01:11:06,800 --> 01:11:08,300
So, it's gonna be like, that would be bizarre.

1293
01:11:08,300 --> 01:11:10,100
I've done this many times, and I don't remember that.

1294
01:11:10,100 --> 01:11:12,900
I guess it's just they didn't bother giving the 4 by 4, this is only

1295
01:11:12,900 --> 01:11:15,700
for odd sizes for non-square sizes.

1296
01:11:16,700 --> 01:11:17,700
So there's that location.

1297
01:11:17,700 --> 01:11:21,300
Like I said that, we have to query, we then have a count.

1298
01:11:21,300 --> 01:11:24,200
We only want to specify 1 Matrix, it allows you to specify a bunch of

1299
01:11:24,200 --> 01:11:25,200
matrices in bulk.

1300
01:11:26,000 --> 01:11:27,000
There's a transpose.

1301
01:11:27,200 --> 01:11:31,000
Now, one of the nice things about that is the transpose part.

1302
01:11:31,000 --> 01:11:35,200
Like I said, before we can now, we were doing that transpose manually

1303
01:11:35,200 --> 01:11:35,600
ourselves.

1304
01:11:35,700 --> 01:11:38,700
And remember when we did that, I said when we get to shaders, we won't

1305
01:11:38,700 --> 01:11:39,600
have to do that anymore.

1306
01:11:39,600 --> 01:11:41,900
Well that is 100% the case.

1307
01:11:41,900 --> 01:11:45,700
Now we can if we want to just stop doing this

1308
01:11:48,800 --> 01:11:49,700
Entirely.

1309
01:11:50,200 --> 01:11:53,900
And instead say that proj just equals clip proj.

1310
01:11:56,300 --> 01:11:58,700
And it will work, so that's pretty cool.

1311
01:12:00,000 --> 01:12:02,500
For now, since I want to see if I can maintain these two pipes, just

1312
01:12:02,500 --> 01:12:03,100
for a second.

1313
01:12:03,100 --> 01:12:06,900
As we transition them over, this may be a complete disaster to try and

1314
01:12:06,900 --> 01:12:08,100
do but we'll try it anyway.

1315
01:12:09,200 --> 01:12:13,000
We're just going to say okay for now we won't transpose though.

1316
01:12:17,900 --> 01:12:22,000
So again location count transpose and value.

1317
01:12:22,000 --> 01:12:25,900
And so then there's that value which is just the main two floats of

1318
01:12:25,900 --> 01:12:27,400
that Matrix, right?

1319
01:12:28,500 --> 01:12:30,100
So that's what we need to do there.

1320
01:12:30,600 --> 01:12:36,200
And of course I actually have to well, you know what?

1321
01:12:37,600 --> 01:12:38,100
That's fine.

1322
01:12:40,700 --> 01:12:43,400
So we're going to have to load that variable certainly.

1323
01:12:43,500 --> 01:12:45,900
But then while we're at it we might as well grab the other one we need

1324
01:12:45,900 --> 01:12:50,300
to which is that when we're doing this transfer my D stuff, we've got

1325
01:12:50,300 --> 01:12:53,700
to have a way of getting it and what you can see is we want to get

1326
01:12:53,700 --> 01:12:54,800
this location ID.

1327
01:12:55,000 --> 01:12:58,300
We need a place to get that from and you can see here with Universe,

1328
01:12:58,300 --> 01:13:01,400
you've got this get uniform location, right?

1329
01:13:01,700 --> 01:13:04,000
And that's exactly what we want to be able to do.

1330
01:13:04,000 --> 01:13:07,700
We want to be able to get uniform location for a program and a name,

1331
01:13:08,000 --> 01:13:08,500
right?

1332
01:13:08,500 --> 01:13:09,800
So that's the function that we

1333
01:13:09,900 --> 01:13:10,300
Need.

1334
01:13:14,100 --> 01:13:19,000
And so, this opengl basic Z bias program that we get back, that's

1335
01:13:19,000 --> 01:13:21,300
actually what we want to get our transform back.

1336
01:13:22,200 --> 01:13:22,700
Right?

1337
01:13:23,400 --> 01:13:29,600
So we need get uniform location and we need the ability to load the

1338
01:13:29,600 --> 01:13:30,200
uniform.

1339
01:13:30,400 --> 01:13:34,800
But in addition to that, what you'll notice here is that no point,

1340
01:13:34,800 --> 01:13:40,400
have we ever specified how to actually say that we're trying to run

1341
01:13:40,400 --> 01:13:42,000
that program, right?

1342
01:13:42,000 --> 01:13:43,600
So at no time that we actually

1343
01:13:43,700 --> 01:13:48,100
Told opengl that we want this program to be run.

1344
01:13:48,700 --> 01:13:52,200
So we need some way of specifying that, right?

1345
01:13:52,700 --> 01:13:56,700
And we can do that by using the called GL use program.

1346
01:13:57,100 --> 01:14:00,000
So what Jill use program does is it says, I'm going to tell you the

1347
01:14:00,000 --> 01:14:05,200
program now that I want you to actually operate on and so that program

1348
01:14:05,200 --> 01:14:07,600
is that one that we compiled, right?

1349
01:14:08,100 --> 01:14:09,700
It's the basic see bias program.

1350
01:14:13,600 --> 01:14:16,700
And again, I've never tried to use the fixed function pipeline like

1351
01:14:16,700 --> 01:14:19,400
this before, and I'm pretty nervous that it's not going to work.

1352
01:14:20,200 --> 01:14:23,800
So we might have to first pour everything over to the program version

1353
01:14:23,800 --> 01:14:24,800
before we get it working.

1354
01:14:25,300 --> 01:14:26,800
That's not a lot of work.

1355
01:14:26,800 --> 01:14:32,500
So it's not a big deal but just fair warning, that may happen.

1356
01:14:32,500 --> 01:14:34,300
So, so be advised.

1357
01:14:35,000 --> 01:14:38,200
All right, so that's all we need at the moment.

1358
01:14:38,200 --> 01:14:42,100
So we just have to get those two uniform Matrix and get uniform

1359
01:14:42,100 --> 01:14:42,600
location.

1360
01:14:42,800 --> 01:14:44,300
We just need those, too.

1361
01:14:50,600 --> 01:14:51,300
Functions.

1362
01:14:51,800 --> 01:14:53,100
And then we should be good to go.

1363
01:14:59,500 --> 01:14:59,800
So,

1364
01:15:00,000 --> 01:15:05,500
See, let's just go ahead and grab that get uniform location.

1365
01:15:17,500 --> 01:15:20,600
And then we also want basically all of this stuff.

1366
01:15:21,200 --> 01:15:21,600
You know.

1367
01:15:21,600 --> 01:15:25,300
We might want any number of these but probably none of these were

1368
01:15:25,300 --> 01:15:27,500
probably always going to load in bulk.

1369
01:15:27,500 --> 01:15:32,500
So I would say we probably only really need, you know, this one and

1370
01:15:32,500 --> 01:15:37,200
this one we probably won't use much more than that.

1371
01:15:38,900 --> 01:15:39,300
Oops.

1372
01:15:53,200 --> 01:15:53,600
Okay.

1373
01:15:56,700 --> 01:16:00,800
So these are the new functions we will need again.

1374
01:16:00,800 --> 01:16:03,600
There's nothing mysterious hear about these.

1375
01:16:03,800 --> 01:16:08,900
So I'm just going to go ahead and do exactly what we always do with

1376
01:16:08,900 --> 01:16:09,300
them.

1377
01:16:35,600 --> 01:16:38,400
Know how I did the those before.

1378
01:16:39,700 --> 01:16:40,900
I guess I do it that way.

1379
01:16:50,400 --> 01:16:53,000
And then these get lower case of fide.

1380
01:17:03,500 --> 01:17:04,200
So, there you go.

1381
01:17:05,200 --> 01:17:08,400
And so now I just have to actually get these

1382
01:17:24,700 --> 01:17:25,200
Like so.

1383
01:17:55,500 --> 01:17:59,200
And last but not least, paste the name.

1384
01:18:34,400 --> 01:18:36,000
I suppose.

1385
01:18:41,100 --> 01:18:41,600
There we go.

1386
01:18:43,000 --> 01:18:46,500
So now we're effectively doing everything that probably would be

1387
01:18:46,500 --> 01:18:48,900
necessary to bind things together here.

1388
01:18:49,400 --> 01:18:54,100
But again, we may have to kind of push a little bit further before we

1389
01:18:54,100 --> 01:18:55,100
can actually get things running.

1390
01:18:55,400 --> 01:18:58,000
I'm going to go ahead and run first and see what's going on with our

1391
01:18:58,000 --> 01:19:00,600
shaders here because we may have errors and stuff.

1392
01:19:01,600 --> 01:19:04,700
So, oh yeah, that's a good point.

1393
01:19:05,200 --> 01:19:07,100
We never actually put in the main

1394
01:19:09,200 --> 01:19:10,100
I just left that in there.

1395
01:19:10,800 --> 01:19:15,300
So the glsl Declaration for main, I don't even remember.

1396
01:19:17,000 --> 01:19:18,000
What it looks like.

1397
01:19:22,700 --> 01:19:24,300
So, that's a good question.

1398
01:19:32,300 --> 01:19:33,900
So it looks like it's just void main void.

1399
01:19:41,500 --> 01:19:42,200
Which is fine.

1400
01:19:50,200 --> 01:19:53,600
Although, it seems to be complaining about our vertex shaders having

1401
01:19:53,600 --> 01:19:54,700
one, which is odd.

1402
01:19:57,200 --> 01:20:00,400
Oh, no, I only put that in the fragment Shader.

1403
01:20:01,600 --> 01:20:02,100
There we go.

1404
01:20:32,000 --> 01:20:33,700
So, you know what?

1405
01:20:38,600 --> 01:20:44,000
I guess now that I think about it is that even when I did that compile

1406
01:20:44,000 --> 01:20:47,100
status there, I may have done that slightly wrong.

1407
01:20:47,100 --> 01:20:51,700
When I put that in there pile status, let's take a look.

1408
01:20:57,800 --> 01:20:59,800
because compiled status may not be something that's

1409
01:21:00,000 --> 01:21:04,700
Find in the program Ivy, let me go ahead and just grab out because

1410
01:21:04,700 --> 01:21:07,800
we're now compiling properly, but we're getting an error, and I'm

1411
01:21:07,800 --> 01:21:10,000
probably just asking that for the wrong thing.

1412
01:21:10,000 --> 01:21:12,700
So let's double check here, dot DL.

1413
01:21:14,900 --> 01:21:15,900
Let's take a look.

1414
01:21:19,100 --> 01:21:21,800
Yeah, so you can see compiled status is not actually on here.

1415
01:21:21,800 --> 01:21:24,400
So compiled status must be only for get Shader.

1416
01:21:27,400 --> 01:21:31,200
So, I should be able to just say, get link status is probably all I

1417
01:21:31,200 --> 01:21:36,500
really need would be my guess because the link status would fail.

1418
01:21:36,500 --> 01:21:38,200
Presumably if the

1419
01:21:43,700 --> 01:21:45,500
like presumably, I can just do

1420
01:21:46,900 --> 01:21:47,400
This.

1421
01:21:56,300 --> 01:22:02,300
All right, so hey, I guess that actually worked, which I wasn't

1422
01:22:02,300 --> 01:22:07,800
expecting it to because like I said, I wasn't expecting it to actually

1423
01:22:07,800 --> 01:22:10,000
be able to mix with the function fixed function placement, so

1424
01:22:10,000 --> 01:22:10,400
smoothly.

1425
01:22:10,400 --> 01:22:13,300
I mean, I know it's supposed to but, you know, that's not a path that

1426
01:22:13,300 --> 01:22:16,500
anyone cares about in opengl because nobody uses it right.

1427
01:22:17,800 --> 01:22:18,700
But hey, there you go.

1428
01:22:18,700 --> 01:22:22,700
So there's that red that our Shader is doing, right?

1429
01:22:23,200 --> 01:22:26,000
And remember this stretch to Infinity is because our

1430
01:22:26,100 --> 01:22:27,900
You coordinate is set completely nuts.

1431
01:22:28,200 --> 01:22:30,400
So hey, let's see if our Shader really is working.

1432
01:22:31,000 --> 01:22:34,700
Let's go ahead and take that W coordinate and correct it.

1433
01:22:35,000 --> 01:22:38,100
Right, let's go ahead and say that GL vertex.

1434
01:22:38,900 --> 01:22:42,700
I'm going to find a veck for here, which is input for at x equals g l

1435
01:22:42,700 --> 01:22:44,000
vertex, right?

1436
01:22:44,200 --> 01:22:47,200
And then let's take our input vertex and let's set the W coordinate

1437
01:22:47,200 --> 01:22:48,000
equal to 1.

1438
01:22:51,100 --> 01:22:51,600
Right.

1439
01:22:51,900 --> 01:22:55,700
So that now we're not having that cause remember we were using the w,

1440
01:22:55,700 --> 01:22:59,600
we modify the pipeline to specify in the W, coordinate, r, z bias

1441
01:22:59,600 --> 01:23:02,800
value, which ruined the W coordinate which is what caused everything

1442
01:23:02,800 --> 01:23:04,900
to stretch into Infinity when we did it.

1443
01:23:05,600 --> 01:23:08,100
Now in our vertex Shader, let's take that out.

1444
01:23:10,700 --> 01:23:11,300
and he look,

1445
01:23:12,500 --> 01:23:13,800
Now, we're all correct.

1446
01:23:14,000 --> 01:23:17,100
So now you can actually see our vertex Shader is running, and it's

1447
01:23:17,100 --> 01:23:18,800
actually doing something useful.

1448
01:23:18,800 --> 01:23:22,700
Now, it's not particularly great because we're just drawing red,

1449
01:23:22,700 --> 01:23:27,400
rectangles, but that's pretty close to two working, right?

1450
01:23:27,400 --> 01:23:29,400
I mean, that's, that's roughly what we wanted.

1451
01:23:30,900 --> 01:23:31,700
So that's great.

1452
01:23:32,800 --> 01:23:36,200
And now all we have to do is say, alright, let's start taking this a

1453
01:23:36,200 --> 01:23:37,600
little bit further.

1454
01:23:37,600 --> 01:23:40,500
So, first of all, what we could do is say, well, you can kind of see

1455
01:23:40,500 --> 01:23:42,400
here where we create our GL position.

1456
01:23:42,500 --> 01:23:46,100
This GL position is going to have the x y&z w on it, right?

1457
01:23:47,100 --> 01:23:50,700
So what be pretty interesting to do here is say well okay, what if we

1458
01:23:50,700 --> 01:23:55,300
just use that Z bias value that, we have our GL vertex, W is the Z

1459
01:23:55,300 --> 01:23:56,700
bias value that we have.

1460
01:23:56,800 --> 01:23:59,500
We could if we wanted to offset the Z,

1461
01:24:00,600 --> 01:24:04,900
That we use for z-buffering by that value, right now, that value has

1462
01:24:04,900 --> 01:24:10,000
to be set to something reasonable obviously, because if we don't set

1463
01:24:10,000 --> 01:24:12,700
it to something reasonable, it has to be reasonable based on what

1464
01:24:12,700 --> 01:24:16,100
we're actually doing to our values here, right?

1465
01:24:16,900 --> 01:24:22,400
So after the transform and things are mapped into the Z space, that Z

1466
01:24:22,400 --> 01:24:27,500
space is negative 1 to 1, that bias value has to in some way,

1467
01:24:27,500 --> 01:24:29,700
correspond to this, right?

1468
01:24:30,800 --> 01:24:35,200
But if we want to be kind of lazy which I kind of do it right now

1469
01:24:35,200 --> 01:24:38,400
because I don't want to go work out any math that I don't have to yet,

1470
01:24:39,400 --> 01:24:43,200
you can imagine saying well we have a z bias value, let's just

1471
01:24:43,200 --> 01:24:47,600
transfer them to points and then we'll set the Z value to be whatever

1472
01:24:47,600 --> 01:24:49,200
the biased one Z value is.

1473
01:24:50,600 --> 01:24:53,500
And and and that's how we'll do it, right?

1474
01:24:53,600 --> 01:24:55,600
So we can say Veeck for

1475
01:24:57,400 --> 01:24:58,400
Z transform.

1476
01:24:59,400 --> 01:25:08,100
And what that'll be is, that'll be times the input vertex, Susie

1477
01:25:08,100 --> 01:25:08,600
vertex.

1478
01:25:16,100 --> 01:25:19,000
What we'll do is we'll just take the input vertex and we'll take the Z

1479
01:25:19,000 --> 01:25:20,700
coordinate of it, right?

1480
01:25:21,600 --> 01:25:25,800
And we'll add to that Z coordinate, whatever the Z bias value was,

1481
01:25:25,800 --> 01:25:28,000
which is coming through in the W coordinate, right?

1482
01:25:28,200 --> 01:25:29,400
Will transform it.

1483
01:25:29,500 --> 01:25:33,300
And then after we get the z-transform, version will take our GL

1484
01:25:33,300 --> 01:25:34,100
position.

1485
01:25:34,200 --> 01:25:37,600
The output that we're going to have there and we'll just over, right?

1486
01:25:37,600 --> 01:25:43,600
Oops, we'll just overwrite the GL positions Z coordinate with this.

1487
01:25:43,800 --> 01:25:45,700
He transforms Z coordinate.

1488
01:25:49,200 --> 01:25:49,600
Right.

1489
01:25:51,300 --> 01:25:56,600
So now what you can actually see is we are getting the biasing that we

1490
01:25:56,600 --> 01:25:57,100
wanted.

1491
01:25:57,100 --> 01:26:00,700
We're no longer clipping through the cubes right now.

1492
01:26:00,700 --> 01:26:04,000
We haven't set up texturing yet so we're kind of just sitting there

1493
01:26:04,300 --> 01:26:09,200
looking pretty dumb, but because we're just all red bread values, but

1494
01:26:09,300 --> 01:26:11,300
you will notice that these things.

1495
01:26:11,300 --> 01:26:16,200
These, these Sprites are still clipping straight through the cubes, we

1496
01:26:16,200 --> 01:26:20,500
just never see it because they're Z bias is always taking care of it.

1497
01:26:21,200 --> 01:26:22,600
So did you see how I did that?

1498
01:26:22,900 --> 01:26:26,400
All I did was I just wrote in the Shader code I was like, all right, I

1499
01:26:26,400 --> 01:26:28,000
have an input for Texas coming in.

1500
01:26:28,300 --> 01:26:32,300
I know that the W coordinate is secretly the Z bias, right?

1501
01:26:32,900 --> 01:26:37,400
So I'm going to overwrite the in the Z value that I'm going to

1502
01:26:37,400 --> 01:26:41,100
actually use, I'm going to overwrite that with one because that's what

1503
01:26:41,100 --> 01:26:43,600
I actually want to use for my transform, right?

1504
01:26:44,800 --> 01:26:48,500
Then I'm going to create another vertex which is the same as the input

1505
01:26:48,500 --> 01:26:52,700
vertex, but instead of having its normal Z value going to offset it C

1506
01:26:52,700 --> 01:26:54,500
value by that Z bias, right?

1507
01:26:54,600 --> 01:26:56,000
And you can think of it this way.

1508
01:27:01,700 --> 01:27:02,200
Right.

1509
01:27:04,400 --> 01:27:05,900
Another way to think of it might be.

1510
01:27:09,200 --> 01:27:10,100
Think you can do this.

1511
01:27:16,100 --> 01:27:17,200
We're going to find out.

1512
01:27:21,700 --> 01:27:22,900
So do you think it might be, okay?

1513
01:27:22,900 --> 01:27:26,500
The input vertex is actually whatever the GL vertex is

1514
01:27:29,000 --> 01:27:29,800
XYZ.

1515
01:27:29,900 --> 01:27:32,500
But then it's w coordinates going to be 1, right?

1516
01:27:32,600 --> 01:27:35,700
Then the Z bias is actually coming out of the W coordinate of the

1517
01:27:35,700 --> 01:27:37,100
input vertex, right?

1518
01:27:37,100 --> 01:27:40,000
So we're using the x y z in the W for two separate purposes.

1519
01:27:40,200 --> 01:27:42,400
Then we're going to create this synthetic vertex, that's the same as

1520
01:27:42,400 --> 01:27:45,500
our input vertex, but with the Z coordinate offset by whatever this

1521
01:27:45,500 --> 01:27:47,400
bias is right there.

1522
01:27:47,400 --> 01:27:49,100
We're going to transform them both.

1523
01:27:50,300 --> 01:27:52,200
And in fact, I can make this clearer by going.

1524
01:28:05,800 --> 01:28:09,800
Transform the input vertex, transform the output vertex, right?

1525
01:28:10,400 --> 01:28:12,000
I transfer the input for text transform.

1526
01:28:12,000 --> 01:28:14,400
The the one with the biased, right?

1527
01:28:14,900 --> 01:28:19,100
Then when we want to do our output, the output is just going to be.

1528
01:28:41,500 --> 01:28:42,400
And off you go.

1529
01:28:47,500 --> 01:28:49,200
So hopefully that's a little clearer now, right?

1530
01:28:50,400 --> 01:28:55,300
So we take the inputs, we bias, we created a secondary Point, that's

1531
01:28:55,300 --> 01:28:56,300
biased, right?

1532
01:28:56,300 --> 01:28:58,700
That's up further, we transform them both.

1533
01:28:58,700 --> 01:29:01,300
And then we just use the Z of the transformed one.

1534
01:29:01,300 --> 01:29:07,200
So it's as if it had been raised up in terms of its depth values, but

1535
01:29:07,200 --> 01:29:09,600
in terms of where it actually shows up on the screen, it uses the same

1536
01:29:09,600 --> 01:29:10,000
thing.

1537
01:29:15,400 --> 01:29:19,900
Now this may look really inefficient, right?

1538
01:29:20,500 --> 01:29:23,800
But actually it's a lot less inefficient than you might think.

1539
01:29:24,400 --> 01:29:27,400
The way that these Shader compilers work is they basically do, you

1540
01:29:27,400 --> 01:29:31,100
know, single static assignment kind of style form, where they

1541
01:29:31,100 --> 01:29:35,100
basically take a look at the thread that produces an output.

1542
01:29:35,100 --> 01:29:38,400
So it knows that the only thing it needs is GL position so it knows

1543
01:29:38,400 --> 01:29:41,100
that the only values it needs are these for so it

1544
01:29:41,200 --> 01:29:44,300
Was that the only thing that's going to use a zMAX transform is this,

1545
01:29:44,500 --> 01:29:47,800
so it knows that it doesn't accept to do this entire transform, it can

1546
01:29:47,800 --> 01:29:51,800
just do the Z part of the transform and it won't ever bother doing the

1547
01:29:51,800 --> 01:29:52,300
rest.

1548
01:29:52,600 --> 01:29:57,100
So it does have an Optimizer that is going to do relatively reasonable

1549
01:29:57,100 --> 01:29:57,500
stuff.

1550
01:29:57,500 --> 01:29:59,800
In terms of only Computing things that needs

1551
01:30:00,300 --> 01:30:03,800
That is true now, it's not an amazing Optimizer.

1552
01:30:03,800 --> 01:30:06,500
So don't get too excited, but it's definitely going to be able to do

1553
01:30:06,500 --> 01:30:07,600
some basic stuff for you.

1554
01:30:07,700 --> 01:30:10,400
So, you don't have to worry too much about that kind of code

1555
01:30:10,400 --> 01:30:11,000
structure.

1556
01:30:11,000 --> 01:30:14,100
It's not going to be literally executing the stuff that you wrote In.

1557
01:30:16,300 --> 01:30:21,000
All right, so in order to get ourselves back up to actually working,

1558
01:30:21,000 --> 01:30:25,000
here we need to put our textures back in because right now we don't

1559
01:30:25,000 --> 01:30:28,600
have any way of sampling from textures and we need to sample from

1560
01:30:28,600 --> 01:30:29,200
textures.

1561
01:30:29,500 --> 01:30:33,800
So inside our fragment code here we need to be able to get a texture

1562
01:30:33,800 --> 01:30:38,700
coordinate and so this is where we need to start having the idea of

1563
01:30:38,700 --> 01:30:41,600
colors and textures getting passed through.

1564
01:30:42,100 --> 01:30:45,900
So what happens here is we've got remember uniform

1565
01:30:46,200 --> 01:30:49,300
Like I said, uniform, is something to get specified once for a whole

1566
01:30:49,300 --> 01:30:51,000
batch, and then just gets used.

1567
01:30:51,100 --> 01:30:55,200
So it's coming from the C code that distinguishes itself, for sewing,

1568
01:30:55,200 --> 01:30:59,600
that's per vertex like this GL position output, or this GL vertex

1569
01:30:59,600 --> 01:31:04,200
input, which are per vertex in order to get texture coordinates in.

1570
01:31:04,200 --> 01:31:06,600
We want another thing that's per vertex.

1571
01:31:06,900 --> 01:31:08,800
So what you typically use?

1572
01:31:09,300 --> 01:31:12,400
They use the thing called varying, for example, to distinguish it from

1573
01:31:12,400 --> 01:31:13,000
uniform.

1574
01:31:13,200 --> 01:31:15,500
I don't know what this version of the shaders.

1575
01:31:16,100 --> 01:31:16,900
Actually uses.

1576
01:31:17,000 --> 01:31:19,500
So let's double check real quick because it changed actually.

1577
01:31:19,500 --> 01:31:21,100
Remember it changing

1578
01:31:22,600 --> 01:31:25,300
Used to be varying, or used to not be varying in, then it was, or I

1579
01:31:25,300 --> 01:31:29,900
don't even remember it was all big fun stuff.

1580
01:31:30,100 --> 01:31:35,400
Anyway, you can see here, we got qualifiers storage cars in centroid

1581
01:31:35,400 --> 01:31:36,400
in out uniform.

1582
01:31:36,500 --> 01:31:41,300
So it looks like there's no need to specify varying, so if we simply

1583
01:31:41,300 --> 01:31:45,100
don't say, uniform, it is assumed to be per vertex, is how this

1584
01:31:45,100 --> 01:31:47,700
version of the shariat straighter goes as far as I can tell.

1585
01:31:48,900 --> 01:31:51,200
So let's go ahead and make that happen.

1586
01:31:51,400 --> 01:31:52,200
So, we know we have

1587
01:31:52,400 --> 01:31:59,100
In in very value here, we know it's going to be a vector to, it's

1588
01:31:59,100 --> 01:32:01,500
going to be the UV coordinates, right?

1589
01:32:02,900 --> 01:32:09,100
And we'll call this input u v and then we also know that we want a

1590
01:32:09,100 --> 01:32:10,300
veck for for color.

1591
01:32:12,200 --> 01:32:14,200
maybe I won't type input, I'll just type in

1592
01:32:21,400 --> 01:32:22,100
Right.

1593
01:32:24,300 --> 01:32:27,200
So now if you look at that, you're like, well, okay, I've specified

1594
01:32:27,200 --> 01:32:30,700
things that come in, they must come from somewhere, I don't know where

1595
01:32:30,700 --> 01:32:33,100
they come from and it's like, okay, we don't really know where those

1596
01:32:33,100 --> 01:32:33,600
come from.

1597
01:32:35,100 --> 01:32:38,100
But then in terms of output, we have to do the same thing.

1598
01:32:38,100 --> 01:32:40,700
Because remember the place we actually want this, eventually is in the

1599
01:32:40,700 --> 01:32:41,600
fragment code.

1600
01:32:41,700 --> 01:32:44,000
So in here, we want the same thing.

1601
01:32:50,300 --> 01:32:54,100
It will call this frag UV and fried color, right?

1602
01:32:59,300 --> 01:32:59,800
Or maybe.

1603
01:33:00,200 --> 01:33:01,100
UV invert color.

1604
01:33:01,100 --> 01:33:04,200
I don't know what you want to call this interpolated color.

1605
01:33:04,700 --> 01:33:08,400
We this is basically, when we get down to the fragment Shader, you

1606
01:33:08,400 --> 01:33:11,800
know, each vertex had a UV coordinate in a in a color and we're

1607
01:33:11,800 --> 01:33:17,100
interpolating that along the, the line inside the triangle

1608
01:33:17,100 --> 01:33:17,700
barycentric.

1609
01:33:17,700 --> 01:33:17,900
Lie.

1610
01:33:17,900 --> 01:33:20,900
I don't know what we want to call this, but this is, this is, you

1611
01:33:20,900 --> 01:33:25,200
know, the I mean, I guess frag is probably this thing for now.

1612
01:33:26,600 --> 01:33:33,000
So here, we're going to need this and this, and we need to declare

1613
01:33:33,000 --> 01:33:34,400
these in the fragment Shader.

1614
01:33:35,100 --> 01:33:38,700
In addition, we need one more piece of information, usually.

1615
01:33:40,600 --> 01:33:44,500
And you can see it here which is smooth flat or non perspective.

1616
01:33:45,100 --> 01:33:48,800
Now, what's interesting about this is this is something that you can't

1617
01:33:48,800 --> 01:33:51,600
really appreciate and handmade hero because it doesn't really come up

1618
01:33:52,200 --> 01:33:53,700
super much in what we were doing.

1619
01:33:53,800 --> 01:33:55,300
But it's important to understand.

1620
01:33:55,500 --> 01:33:58,300
So I'll kind of go over it just really briefly here.

1621
01:34:04,900 --> 01:34:06,500
Was it no perspective.

1622
01:34:16,400 --> 01:34:20,200
All right, so three choices for variables that are in the fragment

1623
01:34:20,200 --> 01:34:20,700
Shader.

1624
01:34:20,700 --> 01:34:22,100
And why do we need these?

1625
01:34:22,100 --> 01:34:26,900
Well, okay, inside a Vertex Shader, remember, we've just got vertices

1626
01:34:27,600 --> 01:34:28,400
right x.

1627
01:34:28,400 --> 01:34:29,800
Y z w.

1628
01:34:30,000 --> 01:34:32,500
These are basically coming directly from the app.

1629
01:34:32,600 --> 01:34:37,300
So I'm specifying these in C, and the vertex Shader is just munching

1630
01:34:37,300 --> 01:34:40,500
on them and outputting stuff for the rasterizer, right?

1631
01:34:40,500 --> 01:34:45,100
So it's outputting these xy's and depth values right for the

1632
01:34:45,100 --> 01:34:45,900
rasterizer.

1633
01:34:48,200 --> 01:34:53,000
At no time, there wasn't anything here, that needed to interpolate any

1634
01:34:53,000 --> 01:34:54,300
values that it got.

1635
01:34:54,500 --> 01:34:56,800
But once these come to the rasterizer, right?

1636
01:34:56,800 --> 01:34:58,500
It's going to line up these as a triangle.

1637
01:34:58,500 --> 01:35:01,400
It's going to go like, oh, here's this guy, here's this guy.

1638
01:35:03,500 --> 01:35:05,800
And here's this guy, right?

1639
01:35:07,000 --> 01:35:09,000
Here's my Triangle.

1640
01:35:09,100 --> 01:35:11,800
Well I now need to shade some stuff that's in here.

1641
01:35:12,400 --> 01:35:16,400
How do I know what to pass for these values?

1642
01:35:16,400 --> 01:35:21,600
If all of a sudden I start augmenting this with like u and v, right?

1643
01:35:21,900 --> 01:35:24,200
How do I know what the UV is in here?

1644
01:35:24,200 --> 01:35:25,600
Because I know what the UV is out here.

1645
01:35:25,600 --> 01:35:26,600
I don't know what it is in here.

1646
01:35:26,600 --> 01:35:29,400
And the answer is, it has to do a very eccentric interpolation.

1647
01:35:29,400 --> 01:35:32,300
Just like we did a member go back to the software rasterizer.

1648
01:35:32,300 --> 01:35:35,500
If you aren't comfortable these things because we did them all, we

1649
01:35:35,500 --> 01:35:37,000
need to figure out what the UV is.

1650
01:35:37,000 --> 01:35:40,600
Using in some kind of a very eccentric interpolation between these

1651
01:35:40,600 --> 01:35:41,300
three points.

1652
01:35:41,300 --> 01:35:43,200
But there's multiple ways you could do it.

1653
01:35:43,500 --> 01:35:46,200
One way, is called Flat in opengl.

1654
01:35:46,400 --> 01:35:50,100
That's if it's always just stays the same, right?

1655
01:35:50,200 --> 01:35:53,600
So, that would mean, that, whatever like the first vertex is ones, are

1656
01:35:53,600 --> 01:35:54,600
the whole triangle gets it.

1657
01:35:54,600 --> 01:35:56,100
So, there's no interpolation at all.

1658
01:35:56,100 --> 01:35:57,500
It just doesn't interpolate

1659
01:36:00,000 --> 01:36:01,800
Next kind is called No perspective.

1660
01:36:01,800 --> 01:36:05,300
That's what we did in the software rasterizer that just says, I don't

1661
01:36:05,300 --> 01:36:06,900
need to do anything fancy.

1662
01:36:07,100 --> 01:36:10,300
Just go ahead and use whatever the barycentric interpolation would

1663
01:36:10,300 --> 01:36:15,100
give you at this point in screens face smooth.

1664
01:36:15,100 --> 01:36:18,500
On the other hand is for normal 3D games, which we are not really, but

1665
01:36:18,500 --> 01:36:21,200
if we were, and this will actually just would actually be the case

1666
01:36:21,200 --> 01:36:24,500
with our cubes when we use, when we do our cubes because they do have

1667
01:36:24,500 --> 01:36:26,700
things that slice downward and Z.

1668
01:36:27,600 --> 01:36:29,900
What that says is hey, let's say we

1669
01:36:30,000 --> 01:36:32,700
We're looking at something head-on like the wall of a dungeon or

1670
01:36:32,700 --> 01:36:33,600
something, right?

1671
01:36:35,700 --> 01:36:41,800
This doesn't interpolate evenly across its surface because it's going

1672
01:36:41,800 --> 01:36:43,000
backwards and Z.

1673
01:36:43,200 --> 01:36:45,100
So things that are close together.

1674
01:36:45,100 --> 01:36:48,800
Back here are actually much further apart than things that are close

1675
01:36:48,800 --> 01:36:50,000
together up here, right?

1676
01:36:50,000 --> 01:36:52,700
Just just perspective, things are closer together get bigger.

1677
01:36:53,400 --> 01:36:57,600
So when we interpolate the texture coordinates, we want to interpolate

1678
01:36:57,600 --> 01:37:00,200
them with respect to perspective.

1679
01:37:00,200 --> 01:37:03,600
So emotion up here should be moved.

1680
01:37:03,700 --> 01:37:04,600
This should move

1681
01:37:04,800 --> 01:37:07,300
UV coordinates more than motion back here.

1682
01:37:07,300 --> 01:37:08,600
Should write.

1683
01:37:09,500 --> 01:37:10,200
If that makes sense.

1684
01:37:12,100 --> 01:37:13,400
That's the bad way to say it.

1685
01:37:13,500 --> 01:37:16,600
But point being what we're trying to do is simulate the fact that we

1686
01:37:16,600 --> 01:37:20,200
actually did a perspective transform on the texture rather than just

1687
01:37:20,200 --> 01:37:21,800
warped it right.

1688
01:37:22,000 --> 01:37:25,100
And this is like if you remember looking at the PS1 Graphics, I think

1689
01:37:25,100 --> 01:37:28,800
we mentioned this before like PlayStation 1 was all kind of War P.

1690
01:37:29,700 --> 01:37:32,100
That is exactly what happens when you don't do perspective.

1691
01:37:32,100 --> 01:37:37,600
Correct or Ultima underworlds walls right that sort of stuff.

1692
01:37:38,500 --> 01:37:41,600
So smooth is what you would pretty much always do by default unless

1693
01:37:41,600 --> 01:37:44,500
you really wanted something specific because that's the one that does.

1694
01:37:44,500 --> 01:37:44,900
Correct.

1695
01:37:44,900 --> 01:37:48,100
3D interpolation, you only would specify the other ones if you had

1696
01:37:48,100 --> 01:37:50,100
some special thing reason that you wanted them.

1697
01:37:50,100 --> 01:37:53,300
So you'll know you'd know if you wanted them if you don't really

1698
01:37:53,300 --> 01:37:54,100
aren't thinking about it.

1699
01:37:54,100 --> 01:37:55,300
You want smooth pretty much.

1700
01:37:57,200 --> 01:37:59,300
So, let's suppose we get these in here, right?

1701
01:37:59,300 --> 01:38:00,500
It's not supposed to be back for

1702
01:38:02,400 --> 01:38:02,800
Right.

1703
01:38:03,600 --> 01:38:04,800
So let's suppose we get these in here.

1704
01:38:04,800 --> 01:38:07,900
Then we will do some things like say if we want to do modulation,

1705
01:38:08,600 --> 01:38:09,100
right?

1706
01:38:10,400 --> 01:38:11,100
There's a module 8.

1707
01:38:11,100 --> 01:38:16,500
We can just multiply now they don't use hadamard product in their

1708
01:38:16,500 --> 01:38:17,800
stuff, they just do.

1709
01:38:17,800 --> 01:38:20,400
Multiplication is is a hadamard.

1710
01:38:20,600 --> 01:38:22,900
So X is the hadamard product.

1711
01:38:23,200 --> 01:38:27,600
Then they use Dot and cross the words Dot and cross to specify dot

1712
01:38:27,600 --> 01:38:28,700
product and cross product.

1713
01:38:28,700 --> 01:38:34,100
So those are the four, the three Vector multiplications, they support.

1714
01:38:36,100 --> 01:38:37,900
So we can do modulation by the fragment color.

1715
01:38:37,900 --> 01:38:39,600
Just like we do in the software rasterizer.

1716
01:38:40,700 --> 01:38:46,300
Or just like opengl was doing before and then we can also do this

1717
01:38:46,300 --> 01:38:46,900
fragmovie.

1718
01:38:46,900 --> 01:38:49,100
We can we can look up a texture, right?

1719
01:38:54,100 --> 01:38:55,600
So instead of this red, right?

1720
01:38:55,600 --> 01:38:57,400
Like, here's our Vector for

1721
01:39:02,500 --> 01:39:03,200
I've read.

1722
01:39:03,300 --> 01:39:06,500
So instead of doing the texture sample, as just pretending, we have

1723
01:39:06,500 --> 01:39:07,800
pure red as a texture.

1724
01:39:08,200 --> 01:39:11,700
We can go in here and say, okay, let's take this UV and let's get a

1725
01:39:11,700 --> 01:39:12,600
texture sample.

1726
01:39:12,900 --> 01:39:13,900
So how do we get texture sample?

1727
01:39:13,900 --> 01:39:16,000
Well, like I said, there's a whole bunch of things built in for doing

1728
01:39:16,000 --> 01:39:16,500
that.

1729
01:39:18,700 --> 01:39:21,200
Where are you?

1730
01:39:21,600 --> 01:39:22,300
There you go.

1731
01:39:22,300 --> 01:39:26,100
Texture grad offset.

1732
01:39:26,100 --> 01:39:27,800
Here we go texture look up.

1733
01:39:28,300 --> 01:39:29,400
So here's texture.

1734
01:39:29,700 --> 01:39:31,300
You can see that there's all these different things.

1735
01:39:31,400 --> 01:39:34,000
Sampler 12 to the array by blah blah.

1736
01:39:34,100 --> 01:39:35,500
What we want is just the basic.

1737
01:39:35,500 --> 01:39:38,700
These are for things like cubemap sampling or Texture or a sampling

1738
01:39:38,700 --> 01:39:39,200
whatever.

1739
01:39:40,000 --> 01:39:45,100
What we want is we want something that's a g of x 4 that's going to

1740
01:39:45,100 --> 01:39:46,500
give us back a full sample.

1741
01:39:47,500 --> 01:39:49,100
We want a 2d sampler.

1742
01:39:49,100 --> 01:39:49,300
Right.

1743
01:39:49,300 --> 01:39:52,800
So we probably want something looks like this where we pass in a UV

1744
01:39:52,800 --> 01:39:56,200
here and the sampler that were sampling from and it gives us back the

1745
01:39:56,200 --> 01:39:56,500
color.

1746
01:39:56,500 --> 01:39:57,900
So that's the one that we want.

1747
01:39:58,000 --> 01:39:59,000
So we want texture.

1748
01:40:02,200 --> 01:40:03,300
We need to text your sampler.

1749
01:40:04,700 --> 01:40:07,500
And then we need just that that UV which is right there.

1750
01:40:07,800 --> 01:40:08,100
Okay.

1751
01:40:08,800 --> 01:40:11,900
So the only other thing we need now is a way to get this texture.

1752
01:40:11,900 --> 01:40:12,400
Sampler.

1753
01:40:12,700 --> 01:40:17,900
And again this is like a thing that is much like this Matt 4x4 up

1754
01:40:17,900 --> 01:40:18,300
here.

1755
01:40:18,400 --> 01:40:19,900
This is something that's uniform.

1756
01:40:19,900 --> 01:40:22,600
It's set one time right by the batch.

1757
01:40:22,600 --> 01:40:24,700
And this is the texture that we're going to use, and it's got to be

1758
01:40:24,700 --> 01:40:25,900
set from the C code.

1759
01:40:25,900 --> 01:40:28,300
So it's something that we have to tell the GPU to communicate down to

1760
01:40:28,300 --> 01:40:29,200
us, right?

1761
01:40:29,500 --> 01:40:32,600
Same exact thing as the transform was up here.

1762
01:40:33,000 --> 01:40:33,900
So we need

1763
01:40:34,000 --> 01:40:35,900
Say that we wipe have a sampler, too.

1764
01:40:37,100 --> 01:40:39,800
Because it's a 2d texture, right?

1765
01:40:40,400 --> 01:40:42,900
And that's all we need to say that.

1766
01:40:42,900 --> 01:40:46,500
It's a floating Point, Texas, a uniform, sampler to texture sampler.

1767
01:40:47,400 --> 01:40:50,600
Then it will go ahead and say, all right, assuming that someone bound

1768
01:40:50,600 --> 01:40:53,600
something to this at some point and we'll have to get to that later,

1769
01:40:54,000 --> 01:40:56,000
then we can, you know, make that happen.

1770
01:40:58,000 --> 01:41:02,300
All right, so what should happen now and let's just go ahead and I'll

1771
01:41:02,300 --> 01:41:05,100
show you the error first and then we'll show you show you the solution

1772
01:41:05,100 --> 01:41:06,800
to it as we should get compiler.

1773
01:41:06,800 --> 01:41:10,900
We do and the compiler errors should be that we don't actually have

1774
01:41:10,900 --> 01:41:12,300
the inputs that we wanted.

1775
01:41:12,300 --> 01:41:12,900
Right?

1776
01:41:13,800 --> 01:41:15,700
Oh well actually I've got a different one to hear.

1777
01:41:16,900 --> 01:41:19,300
Internal are unexpected qualifier texture.

1778
01:41:19,300 --> 01:41:20,700
Sampler parse error.

1779
01:41:23,900 --> 01:41:25,400
Did I specify something wrong?

1780
01:41:25,400 --> 01:41:25,700
Oh,

1781
01:41:27,500 --> 01:41:30,400
That's a it's not ass a to it's a 2d, right?

1782
01:41:31,600 --> 01:41:32,000
Yeah.

1783
01:41:33,200 --> 01:41:33,700
There we go.

1784
01:41:36,300 --> 01:41:36,700
Whoops.

1785
01:41:39,700 --> 01:41:42,300
Well, that wasn't what I was expecting to have happen.

1786
01:41:43,900 --> 01:41:47,300
So I was expecting it, an error there and I'll tell you, whether there

1787
01:41:47,300 --> 01:41:49,900
was I was expecting but I guess it's not an error for whatever reason.

1788
01:41:50,800 --> 01:41:53,800
So you notice, we've got these inputs here and these inputs, I guess

1789
01:41:53,800 --> 01:41:55,200
it just defaults them to 0.

1790
01:41:55,200 --> 01:41:56,900
These inputs aren't specified.

1791
01:41:57,100 --> 01:41:57,700
Right?

1792
01:41:58,000 --> 01:41:59,800
Was the point that I was trying to get to

1793
01:42:00,500 --> 01:42:05,500
And so, what we need is a way for our vertex code to Output, what

1794
01:42:05,500 --> 01:42:10,200
these values should be per vertex so that they can get interpolated by

1795
01:42:10,200 --> 01:42:11,100
the rasterizer.

1796
01:42:11,400 --> 01:42:15,400
So what we need to do here is we just need to specify these as as

1797
01:42:15,700 --> 01:42:17,100
output variables.

1798
01:42:18,900 --> 01:42:21,200
That line up with what we expect to come in.

1799
01:42:21,300 --> 01:42:24,500
So, our output names here, just have to line up with our input names

1800
01:42:24,500 --> 01:42:24,800
here.

1801
01:42:24,800 --> 01:42:28,000
And then when these two programs are linked together, they will line

1802
01:42:28,000 --> 01:42:28,300
them.

1803
01:42:28,300 --> 01:42:33,400
They will, the Shader compiler will understand that.

1804
01:42:33,400 --> 01:42:37,900
It's supposed to Output stuff from, you know, stuff that gets written

1805
01:42:37,900 --> 01:42:41,500
to here, gets red for in in here, right?

1806
01:42:41,700 --> 01:42:45,300
That it just needs to be able to make that sort of that binding,

1807
01:42:45,500 --> 01:42:46,000
right?

1808
01:42:46,800 --> 01:42:48,500
So what we want to do is we just

1809
01:42:48,700 --> 01:42:49,900
Want to pass through.

1810
01:42:50,100 --> 01:42:51,600
We want to Output a frag UV.

1811
01:42:51,600 --> 01:42:53,600
That's whatever the UV that was inputted.

1812
01:42:53,600 --> 01:42:55,600
And we want to Output a frog color.

1813
01:42:55,600 --> 01:42:57,200
That's whatever was inputted.

1814
01:42:57,200 --> 01:43:00,300
So basically, we're assuming these come from the vertex dream somehow

1815
01:43:00,300 --> 01:43:03,400
here and we'll talk about how to get that in a second and then we're

1816
01:43:03,400 --> 01:43:04,700
out putting them like this.

1817
01:43:05,100 --> 01:43:09,500
Now, I think, again, fixed function pipeline wise, we may be able to

1818
01:43:09,500 --> 01:43:12,900
cheat here and not quite start doing the array specification stuff

1819
01:43:13,300 --> 01:43:17,100
that we would need to do to find our own vertex dreams yet because I

1820
01:43:17,100 --> 01:43:18,500
believe, yeah,

1821
01:43:18,600 --> 01:43:24,000
We've got GL multitec, scored and GL color, so we can actually just

1822
01:43:24,000 --> 01:43:36,500
for go these for the moment and actually just say GL multitec scored 0

1823
01:43:37,300 --> 01:43:40,800
+ GL color, those are the fixed function versions.

1824
01:43:41,400 --> 01:43:45,900
And so in theory, those can get bound and output to the fragment

1825
01:43:45,900 --> 01:43:46,900
Shader, right?

1826
01:43:47,600 --> 01:43:47,900
Oops.

1827
01:43:53,500 --> 01:43:54,400
I need a jail mate.

1828
01:43:54,400 --> 01:43:54,900
Texas Court.

1829
01:43:54,900 --> 01:43:55,600
Did I

1830
01:44:08,200 --> 01:44:12,600
Did I spell that wrong or is that not supported in this version

1831
01:44:13,700 --> 01:44:15,900
multitec scored zero?

1832
01:44:26,300 --> 01:44:28,100
Because that is the value.

1833
01:44:28,100 --> 01:44:29,000
Is it not?

1834
01:44:31,900 --> 01:44:33,700
Geo multi Tax Court.

1835
01:44:45,500 --> 01:44:46,700
Vertex Shader was fine.

1836
01:44:47,400 --> 01:44:48,600
Fragment Shader was fine.

1837
01:44:50,100 --> 01:44:51,600
Frog, color interpolate modes.

1838
01:44:51,600 --> 01:44:52,800
Do not match in two stages.

1839
01:44:52,800 --> 01:44:54,700
Ah yes sorry.

1840
01:44:56,700 --> 01:44:57,300
The smooth.

1841
01:44:57,300 --> 01:44:59,000
Needs to be replicated in both places.

1842
01:44:59,000 --> 01:44:59,800
I don't know why.

1843
01:45:00,400 --> 01:45:01,000
But it does.

1844
01:45:03,900 --> 01:45:05,800
all right, so

1845
01:45:08,500 --> 01:45:12,000
we need some way of getting the texture sampler and the texture

1846
01:45:12,000 --> 01:45:13,200
coordinates set up here.

1847
01:45:13,900 --> 01:45:16,400
I don't know why I can't access multitec scored.

1848
01:45:16,400 --> 01:45:21,800
It may be because that isn't actually in this version of the Shader

1849
01:45:21,800 --> 01:45:22,800
language.

1850
01:45:23,100 --> 01:45:26,600
Let me take a quick look to see what the deal is with that again, I'm

1851
01:45:26,600 --> 01:45:30,500
trying to do something here that just as the transition that we really

1852
01:45:30,800 --> 01:45:34,500
are on kind of off the beat, we're off the beaten path, which is using

1853
01:45:34,500 --> 01:45:35,900
the fixed function Pipeline with shaders.

1854
01:45:35,900 --> 01:45:38,200
Normally, you just use one of the other

1855
01:45:38,500 --> 01:45:41,900
You don't mix and match like I am some pushing it a little bit here

1856
01:45:41,900 --> 01:45:42,900
but we got this far.

1857
01:45:42,900 --> 01:45:45,800
I might as well do it because like I said, it's been nice being able

1858
01:45:45,800 --> 01:45:48,700
to show you the individual steps not having to do the whole thing in

1859
01:45:48,700 --> 01:45:49,900
one big kerplunk.

1860
01:45:52,200 --> 01:45:56,400
So yeah, so let's take a look and see what the deal is.

1861
01:45:56,500 --> 01:45:58,000
Is there Shader wise?

1862
01:46:00,100 --> 01:46:01,200
Let's see.

1863
01:46:01,200 --> 01:46:07,800
Jill multitec scored just want to know what the Shader version is for

1864
01:46:07,800 --> 01:46:08,300
that.

1865
01:46:08,500 --> 01:46:10,300
Is there a maybe in this Shader version?

1866
01:46:10,300 --> 01:46:11,300
There was just a GL Tech.

1867
01:46:11,300 --> 01:46:11,700
Scored?

1868
01:46:11,700 --> 01:46:12,600
Was that a thing?

1869
01:46:39,400 --> 01:46:43,100
So maybe this just isn't allowed anymore, I don't know.

1870
01:46:43,100 --> 01:46:45,700
I'm confused as to why I'm not.

1871
01:46:45,700 --> 01:46:47,600
Also just try this because I'm just curious.

1872
01:47:02,300 --> 01:47:03,200
okay, so that

1873
01:47:05,000 --> 01:47:06,200
That looks like that was correct.

1874
01:47:06,200 --> 01:47:08,300
So so it looks like it's just a version mismatch.

1875
01:47:08,500 --> 01:47:13,000
So GL Tax Court is the thing, and so we only want the first two values

1876
01:47:13,000 --> 01:47:16,100
of it because we're only outputting to were not end texture,

1877
01:47:16,100 --> 01:47:18,700
coordinates are actually defined as full four dimensional coordinates

1878
01:47:19,200 --> 01:47:20,000
on input.

1879
01:47:20,100 --> 01:47:23,800
So we can just use just the U and the V part which is all we wanted

1880
01:47:24,200 --> 01:47:27,000
and then we should be good to go potentially I guess.

1881
01:47:37,200 --> 01:47:39,900
Can I apply dot operator to an array?

1882
01:47:41,100 --> 01:47:45,000
Oh, so it was actually just named differently, but it is still GL Tech

1883
01:47:45,000 --> 01:47:45,500
scored.

1884
01:47:45,600 --> 01:47:47,600
It is still a multi-textured array, I guess.

1885
01:47:47,900 --> 01:47:48,400
All right.

1886
01:47:50,000 --> 01:47:50,600
Fair enough.

1887
01:47:51,600 --> 01:47:52,100
All right.

1888
01:47:52,100 --> 01:47:55,400
So I believe we are now passing down everything that we need to pass

1889
01:47:55,400 --> 01:47:55,800
down.

1890
01:47:56,000 --> 01:47:59,500
The only problem is we are not actually, we don't actually have a

1891
01:48:00,000 --> 01:48:01,500
Sampler set up.

1892
01:48:01,500 --> 01:48:03,800
So we don't actually have a way of accessing the texture, right?

1893
01:48:03,800 --> 01:48:07,600
We are the we just name this Phantom texture sample and we're like,

1894
01:48:07,600 --> 01:48:08,600
hey, there should be technically.

1895
01:48:08,800 --> 01:48:12,200
I don't know if we can access the fixed function pipeline there, but I

1896
01:48:12,200 --> 01:48:13,100
guess I'll try again.

1897
01:48:13,100 --> 01:48:16,200
Just to continue with just doing it one step at a time there.

1898
01:48:16,700 --> 01:48:19,900
Let me take a look at the quick reference guide and see if that is

1899
01:48:19,900 --> 01:48:23,100
actually true fragment language.

1900
01:48:24,300 --> 01:48:25,400
It doesn't look like it.

1901
01:48:25,400 --> 01:48:25,600
Right?

1902
01:48:25,600 --> 01:48:30,100
So it doesn't look like those are defaulted to the Samplers are

1903
01:48:30,100 --> 01:48:31,400
defaulted in any way.

1904
01:48:31,400 --> 01:48:33,100
It looks like you have to specify a texture.

1905
01:48:33,100 --> 01:48:33,800
Sampler.

1906
01:48:36,000 --> 01:48:41,700
unless I'm very much mistaken and about that about that, that

1907
01:48:44,700 --> 01:48:45,900
Yeah, it looks like it.

1908
01:48:50,300 --> 01:48:53,700
All right, so the last thing we have to do then is just to get this

1909
01:48:53,700 --> 01:48:56,800
texture, sampler bound as well, right?

1910
01:48:57,400 --> 01:49:00,100
So again, this is exactly analogous to the transform thing.

1911
01:49:00,100 --> 01:49:02,900
This is something that per batch we want to set a texture sample.

1912
01:49:03,000 --> 01:49:07,300
So, we wanted to set a texture for the sampler just like we set a

1913
01:49:07,300 --> 01:49:09,800
transform for the vertex Shader.

1914
01:49:10,200 --> 01:49:13,800
So what we need to do in our opengl call calls, are we have to

1915
01:49:13,800 --> 01:49:17,700
actually have a thing here, which is the texture sampler ID and that's

1916
01:49:17,700 --> 01:49:19,300
going to get out of that program.

1917
01:49:20,100 --> 01:49:24,500
Extra sampler right now that'll work just fine.

1918
01:49:25,000 --> 01:49:28,500
The only problem is we don't do anything with it, so we're going to

1919
01:49:28,500 --> 01:49:30,700
have to have lips.

1920
01:49:34,400 --> 01:49:37,100
So, we're going to have to actually do something with it at some

1921
01:49:37,100 --> 01:49:37,700
point.

1922
01:49:44,400 --> 01:49:49,600
So what we need is you know, when we're doing our GL uniform Matrix up

1923
01:49:49,600 --> 01:49:50,300
here, we bind it.

1924
01:49:50,300 --> 01:49:53,900
We kind of need another deal uniform here which is going to specify

1925
01:49:54,100 --> 01:49:57,400
that we want our texture, sampler to line up with some kind of a

1926
01:49:57,400 --> 01:50:00,200
texture that we have bound to something, right?

1927
01:50:02,100 --> 01:50:07,400
So we essentially need to do a GL uniform, and in this case, I think I

1928
01:50:07,400 --> 01:50:08,500
misspoke before actually.

1929
01:50:08,500 --> 01:50:11,400
Now I think about it, I guess we do need a GL uniform.

1930
01:50:11,400 --> 01:50:13,000
I, in this case

1931
01:50:13,900 --> 01:50:17,600
Because we need to set the texture sampler up and we're going to have

1932
01:50:17,600 --> 01:50:19,000
to specify an integer, right?

1933
01:50:19,000 --> 01:50:21,700
So basically what we're going to do is we're going to set the uniform.

1934
01:50:22,300 --> 01:50:24,600
We're going to set it to be which texture slot.

1935
01:50:24,600 --> 01:50:25,100
It's in.

1936
01:50:25,100 --> 01:50:25,800
Oops, sorry.

1937
01:50:26,300 --> 01:50:27,100
Open Jill.

1938
01:50:37,400 --> 01:50:42,300
Yeah, and it also occurs to me that this should probably have this

1939
01:50:42,300 --> 01:50:43,400
going on here, right?

1940
01:50:49,800 --> 01:50:52,200
I'm pretty sure you have to bind the program to set these uniforms.

1941
01:50:52,200 --> 01:50:54,200
I don't know why that worked before, but I guess it did.

1942
01:50:56,800 --> 01:50:59,500
Anyway, we're going to have to specify a uniform here and the uniform

1943
01:50:59,500 --> 01:50:59,800
is going.

1944
01:51:00,000 --> 01:51:04,200
To bind the sampler ID to something right now this Parts a little

1945
01:51:04,200 --> 01:51:04,900
confusing.

1946
01:51:05,100 --> 01:51:08,500
Again, all of this binding stuff is really, it's a really messy part

1947
01:51:08,500 --> 01:51:08,900
of the API.

1948
01:51:08,900 --> 01:51:13,600
It's not done particularly well, it never really gets done,

1949
01:51:13,600 --> 01:51:16,700
particularly well, unless you scale all the way up to nvidia's by

1950
01:51:16,700 --> 01:51:17,200
endless.

1951
01:51:17,800 --> 01:51:21,900
Extensions are the only time that I've ever seen any done properly and

1952
01:51:21,900 --> 01:51:25,400
any API really for this sort of stuff.

1953
01:51:25,400 --> 01:51:26,200
So there's that.

1954
01:51:26,200 --> 01:51:29,900
But what we need to do here is we need to basically say,

1955
01:51:30,000 --> 01:51:31,100
For this uniform location.

1956
01:51:31,100 --> 01:51:35,500
We need to sort of correspond it to something texture related in

1957
01:51:35,500 --> 01:51:36,200
opengl.

1958
01:51:36,200 --> 01:51:39,500
And the way they chose to do that was basically with the concept sort

1959
01:51:39,500 --> 01:51:43,900
of texture units in the sense that like okay we're going to treat the

1960
01:51:43,900 --> 01:51:44,300
texture.

1961
01:51:44,300 --> 01:51:46,700
Sampler as if it's basically just an index.

1962
01:51:46,700 --> 01:51:51,500
So we're going to specify what index of the texture unit.

1963
01:51:51,500 --> 01:51:53,900
We're going to which texture unit index.

1964
01:51:53,900 --> 01:51:54,700
We want it to use.

1965
01:51:54,700 --> 01:51:55,600
So we'll say.

1966
01:51:55,600 --> 01:51:59,900
OK, bind to texture sampler, Z bind, the text.

1967
01:52:00,000 --> 01:52:04,200
Sampler for this ID, bind it to unit 0, or bind it to unit, one or

1968
01:52:04,200 --> 01:52:07,600
bias unit 2 and then we still text talk to it.

1969
01:52:07,600 --> 01:52:10,900
Exactly the way we talk to this stuff, right?

1970
01:52:12,500 --> 01:52:13,900
That's how this actually works.

1971
01:52:15,400 --> 01:52:19,600
So yeah, we don't have time to probably get this working, but let me

1972
01:52:19,600 --> 01:52:21,200
just go ahead and grab that function.

1973
01:52:21,200 --> 01:52:22,500
I can at least do that much.

1974
01:52:25,000 --> 01:52:28,900
But I thought, yeah, I thought that buying program was necessary to

1975
01:52:28,900 --> 01:52:30,900
use those uniforms, but we didn't do that.

1976
01:52:30,900 --> 01:52:33,500
I don't know why we didn't do that.

1977
01:52:33,500 --> 01:52:34,000
Hold on a second.

1978
01:52:34,000 --> 01:52:35,100
Let me just take a look.

1979
01:52:53,200 --> 01:52:53,800
What is the value?

1980
01:52:53,800 --> 01:52:54,900
Beautiful, very jewelry friendly.

1981
01:52:55,200 --> 01:52:57,300
Bubba, blah, blah, blah, blah, blah, blah.

1982
01:53:02,200 --> 01:53:07,300
None of this is what I want the commands by assuming uniform vote, a

1983
01:53:07,300 --> 01:53:08,100
blah blah.

1984
01:53:13,100 --> 01:53:13,400
Yes.

1985
01:53:13,400 --> 01:53:14,300
It's real uniform.

1986
01:53:14,300 --> 01:53:17,100
I and Jillian for IV of the only 200 meters is uniform.

1987
01:53:17,100 --> 01:53:18,500
Fails to find a sampler types.

1988
01:53:18,700 --> 01:53:20,200
Long-established function right.

1989
01:53:20,900 --> 01:53:22,500
But I don't know where it says.

1990
01:53:26,600 --> 01:53:27,700
The program has to be bound.

1991
01:53:28,600 --> 01:53:29,600
Well, doesn't matter.

1992
01:53:30,200 --> 01:53:32,300
Anyway, point being, let's move finish up what we're doing.

1993
01:53:32,300 --> 01:53:33,400
We can take a look at that again.

1994
01:53:34,600 --> 01:53:37,000
So let's go ahead and do Jill uniform.

1995
01:53:38,400 --> 01:53:39,100
Ivy.

1996
01:53:43,200 --> 01:53:44,100
Should be here somewhere.

1997
01:54:05,200 --> 01:54:05,800
No.

1998
01:54:10,600 --> 01:54:11,100
There it is.

1999
01:54:14,200 --> 01:54:16,900
so in this case, we just want Jill uniform, one eye

2000
01:54:35,100 --> 01:54:36,300
And same thing here.

2001
01:55:05,500 --> 01:55:08,600
So buying program, let's see here.

2002
01:55:08,600 --> 01:55:11,000
Texture texture or like that.

2003
01:55:13,000 --> 01:55:15,200
So buying program I guess we should also grab because I'm pretty sure

2004
01:55:15,200 --> 01:55:15,600
you needed.

2005
01:55:15,600 --> 01:55:15,900
I guess.

2006
01:55:15,900 --> 01:55:18,900
I just couldn't find any positive confirmation that we actually did,

2007
01:55:19,500 --> 01:55:21,700
but I felt like that should probably be there.

2008
01:55:31,900 --> 01:55:33,600
Is it just is just use program.

2009
01:55:34,900 --> 01:55:38,000
So is it just the use program is sets it in and of itself?

2010
01:55:38,000 --> 01:55:39,600
I don't have to bind it I guess not.

2011
01:55:43,600 --> 01:55:44,300
No, I guess not.

2012
01:55:44,300 --> 01:55:44,800
All right.

2013
01:55:45,200 --> 01:55:45,800
Okay, cool.

2014
01:55:46,000 --> 01:55:47,100
So I don't need that good.

2015
01:55:49,000 --> 01:55:53,300
Okay, so I think that's about it for this week.

2016
01:55:53,300 --> 01:55:56,500
We'll have to wait to do the rest of the texture stuff until next

2017
01:55:56,500 --> 01:55:58,400
week, but we're almost there.

2018
01:55:59,000 --> 01:56:01,600
So we're close close.

2019
01:56:01,600 --> 01:56:02,300
But no cigar

2020
01:56:05,500 --> 01:56:08,800
We will have to, like I said, play around with this a little bit more.

2021
01:56:10,000 --> 01:56:12,100
I'll leave this in the opengl code.

2022
01:56:12,100 --> 01:56:13,800
I'll leave the texture.

2023
01:56:13,800 --> 01:56:15,900
Sampler, so we can see things.

2024
01:56:17,300 --> 01:56:22,300
I'll I'll leave the alpha value at one just for fun.

2025
01:56:26,200 --> 01:56:28,400
So that we can actually see where things are.

2026
01:56:28,400 --> 01:56:31,600
But other than that, we'll go ahead and go to the Q&A, and we'll do

2027
01:56:31,600 --> 01:56:37,200
the texturing next week when we can both do the texturing and make

2028
01:56:37,200 --> 01:56:40,200
sure that we're handling Alpha correctly and stuff like that in there

2029
01:56:40,200 --> 01:56:43,000
because we will want to put in an alpha discard and stuff like this.

2030
01:56:43,000 --> 01:56:45,600
So we have a couple more things that we're going to want to do but

2031
01:56:45,600 --> 01:56:46,300
we're pretty close.

2032
01:56:59,400 --> 01:56:59,800
How is?

2033
01:57:00,200 --> 01:57:01,300
Wait seriously.

2034
01:57:06,400 --> 01:57:07,500
How is that possible?

2035
01:57:07,500 --> 01:57:09,800
Because I don't have any hotkeys set.

2036
01:57:14,100 --> 01:57:18,000
None controlled W.

2037
01:57:18,000 --> 01:57:19,000
Are you nuts?

2038
01:57:19,100 --> 01:57:20,400
How did that get set?

2039
01:57:20,400 --> 01:57:22,200
That has never been set before.

2040
01:57:27,500 --> 01:57:29,500
That must have got set for some other reason.

2041
01:57:33,100 --> 01:57:34,100
Well, that's terrible.

2042
01:57:37,800 --> 01:57:40,200
Yeah, I guess I don't hit control very often.

2043
01:57:40,200 --> 01:57:43,500
It's probably why we never noticed it before.

2044
01:57:46,700 --> 01:57:48,800
That must have gotten set during some stream.

2045
01:57:48,800 --> 01:57:52,200
We did for some other reason, I'm glad we now know what that is

2046
01:57:52,200 --> 01:57:54,700
because that would have plagued us for a while.

2047
01:58:00,200 --> 01:58:01,200
All right, let's verify that.

2048
01:58:01,200 --> 01:58:02,300
That won't happen again.

2049
01:58:03,400 --> 01:58:04,200
Well w.

2050
01:58:11,100 --> 01:58:11,900
That do anything.

2051
01:58:13,000 --> 01:58:14,600
No good.

2052
01:58:17,800 --> 01:58:19,100
That's still doing it.

2053
01:58:19,900 --> 01:58:22,400
I have cleared the hotkey, but it's still doing it.

2054
01:58:25,500 --> 01:58:27,500
How do I make it stop?

2055
01:58:33,500 --> 01:58:35,900
OBS seems to really want that hockey.

2056
01:58:42,200 --> 01:58:46,500
So those hot keys are still there, even though I've cleared them out,

2057
01:58:46,500 --> 01:58:49,700
I'm not sure how to make it not do that.

2058
01:58:58,800 --> 01:58:59,700
Hmm.

2059
01:59:03,500 --> 01:59:04,000
Well.

2060
01:59:23,100 --> 01:59:26,100
I can try like restarting obs.

2061
01:59:45,100 --> 01:59:46,900
Check your global settings.

2062
01:59:52,400 --> 01:59:52,800
Please.

2063
01:59:57,700 --> 01:59:59,800
I don't think there are any

2064
02:00:17,400 --> 02:00:21,800
Well yeah that's that's really problematic.

2065
02:00:21,800 --> 02:00:26,600
I mean I'm definitely gonna have that accidentally happen again if I

2066
02:00:26,600 --> 02:00:29,800
can't get rid of that because that's real bad.

2067
02:00:30,900 --> 02:00:33,700
Thank you OBS, for that wonderful feature.

2068
02:00:36,400 --> 02:00:41,700
well, can I set it to something like Ctrl, alt shift, semicolon,

2069
02:00:47,000 --> 02:00:47,500
Nope.

2070
02:00:49,000 --> 02:00:52,000
Boy, this this hotkey, sure is interesting.

2071
02:01:17,700 --> 02:01:19,100
Yeah, that's a good idea.

2072
02:01:19,100 --> 02:01:22,400
If I just deleted, these wouldn't be able to switch.

2073
02:01:27,900 --> 02:01:28,800
Let's do that.

2074
02:01:31,100 --> 02:01:32,000
Remove.

2075
02:01:33,400 --> 02:01:34,200
Remove.

2076
02:01:38,100 --> 02:01:38,800
All right.

2077
02:01:40,700 --> 02:01:41,800
That's what we want.

2078
02:01:42,000 --> 02:01:43,500
Let's just leave it that.

2079
02:01:43,500 --> 02:01:44,600
So it's less risky.

2080
02:02:08,800 --> 02:02:11,400
Brooke tag now that we've gone up in jail, do you still think the

2081
02:02:11,400 --> 02:02:13,300
Raspberry Pi option is still on the list?

2082
02:02:13,300 --> 02:02:16,600
Actually, the only way we were ever going to do a Raspberry Pi is if

2083
02:02:16,600 --> 02:02:22,900
we did open jail because or some 3D Hardware something, because

2084
02:02:22,900 --> 02:02:32,100
unfortunately, the Raspberry Pi is a lot of the power on the Raspberry

2085
02:02:32,100 --> 02:02:35,200
Pi is in the graphics GPU.

2086
02:02:38,100 --> 02:02:41,100
So if we're ever do a Raspberry Pi version, we're going to have to do

2087
02:02:41,100 --> 02:02:42,600
it with the grant with the GPU.

2088
02:02:42,600 --> 02:02:47,600
It's not it doesn't have enough CPU performance to run a game.

2089
02:02:47,600 --> 02:02:50,100
I don't think software rendered

2090
02:02:59,600 --> 02:02:59,800
Would you?

2091
02:03:00,000 --> 02:03:02,100
What's the code for what you have done in the last two to four

2092
02:03:02,100 --> 02:03:02,600
minutes?

2093
02:03:02,900 --> 02:03:03,700
Yes.

2094
02:03:05,600 --> 02:03:08,300
Let's, let's go ahead and just go over what I ended up doing.

2095
02:03:08,300 --> 02:03:09,500
Just so it's clear.

2096
02:03:11,200 --> 02:03:13,000
Let me make sure this open Jill.

2097
02:03:13,000 --> 02:03:15,100
I mean, this thing is kind of, okay, so that seems to work.

2098
02:03:15,100 --> 02:03:19,500
Okay, all right, so all I did was I said, well, okay.

2099
02:03:20,400 --> 02:03:24,300
We're going to need to do the same thing with the texture sampler that

2100
02:03:24,300 --> 02:03:25,800
we did with the transform.

2101
02:03:25,800 --> 02:03:27,800
So it's a uniform value.

2102
02:03:28,100 --> 02:03:29,900
It's going to be this thing called a sampling.

2103
02:03:30,000 --> 02:03:30,100
Sure.

2104
02:03:30,100 --> 02:03:33,100
And what a Samplers is just a way of getting texture Samplers, right?

2105
02:03:33,100 --> 02:03:33,900
Texture samples.

2106
02:03:35,600 --> 02:03:38,400
We don't know anything about it, meaning the gravis card doesn't tell

2107
02:03:38,400 --> 02:03:40,000
us how it's doing that.

2108
02:03:40,000 --> 02:03:45,200
We just know that at some point we can call texture and give it a UV

2109
02:03:45,200 --> 02:03:48,000
coordinate and one of these Samplers and it will go get us, the

2110
02:03:48,000 --> 02:03:51,200
corresponding sample from the texture, and that sample will do,

2111
02:03:51,200 --> 02:03:55,500
whatever the thing is set up to do in the open gel texture unit.

2112
02:03:55,500 --> 02:03:58,300
So if it's set up to do bi linear interpolation, it'll do bi linear

2113
02:03:58,300 --> 02:03:59,100
interpolation.

2114
02:04:00,000 --> 02:04:02,400
It's not set up to do by their traditional won't.

2115
02:04:02,400 --> 02:04:05,500
There's also ways of trying to tell it inside the shooter, what you

2116
02:04:05,500 --> 02:04:07,600
want to do, whether you want to do by linear whether you want to do

2117
02:04:07,600 --> 02:04:08,800
this or that, right?

2118
02:04:09,400 --> 02:04:11,100
So it's going to do that, that sample.

2119
02:04:11,100 --> 02:04:12,700
It's going to get us back to texture sample.

2120
02:04:13,600 --> 02:04:16,500
Then we're going to use the texture sample to do, whatever texturing

2121
02:04:16,500 --> 02:04:17,100
we want to do.

2122
02:04:17,200 --> 02:04:19,200
That all is just very straightforward.

2123
02:04:19,200 --> 02:04:23,300
However, this thing at some point just like the transform has to get

2124
02:04:23,300 --> 02:04:24,700
passed down, right?

2125
02:04:24,900 --> 02:04:29,800
So we need some way of the C code being able to tell the Shader code,

2126
02:04:30,000 --> 02:04:33,000
This is what you're supposed to use for texture.

2127
02:04:33,000 --> 02:04:34,800
Sampling, right.

2128
02:04:35,600 --> 02:04:37,400
Which texture unit you're supposed to use.

2129
02:04:37,600 --> 02:04:40,000
So what we had to do to do that was to add.

2130
02:04:40,200 --> 02:04:41,900
Well, first of all, we had to add

2131
02:04:43,600 --> 02:04:47,500
Texture sampler ID, which is the same as the transform, just getting

2132
02:04:47,500 --> 02:04:48,600
the location out.

2133
02:04:48,700 --> 02:04:52,300
So it's basically tell us what uniform location we're supposed to use

2134
02:04:52,600 --> 02:04:55,500
right to talk about this value.

2135
02:04:56,100 --> 02:04:57,000
So we did that.

2136
02:04:58,100 --> 02:05:01,600
And then the other thing that we have to do is when we actually go to

2137
02:05:01,600 --> 02:05:06,500
call that we have to wear as it where we do use program.

2138
02:05:06,500 --> 02:05:08,400
Here you go, where we do use program.

2139
02:05:08,600 --> 02:05:09,700
We then have to say okay?

2140
02:05:09,700 --> 02:05:12,600
Just like we set up the Matrix we have to tell you what texture

2141
02:05:12,600 --> 02:05:13,200
sampler where you

2142
02:05:13,900 --> 02:05:17,900
At the moment, we haven't done anything to get that working.

2143
02:05:18,400 --> 02:05:20,400
So like I said, that's not really going to do anything.

2144
02:05:20,400 --> 02:05:24,600
I just am sending it to zero at the moment so you can see that it's

2145
02:05:24,600 --> 02:05:31,400
just this nothing particularly, it's not actually working yet, but

2146
02:05:31,400 --> 02:05:32,800
that's that's all I did.

2147
02:05:33,300 --> 02:05:33,900
That, was it?

2148
02:05:34,000 --> 02:05:37,400
It was just just to get away of now specifying.

2149
02:05:38,100 --> 02:05:41,300
Some piece of information that goes with that texture, sampler.

2150
02:06:22,700 --> 02:06:23,400
Oh, okay.

2151
02:06:25,400 --> 02:06:25,900
So

2152
02:06:28,200 --> 02:06:34,700
we got a little help here from wgg 25 on the Geotech score thing

2153
02:06:34,700 --> 02:06:37,500
because this was the part that I wasn't sure about before.

2154
02:06:37,500 --> 02:06:39,400
Like I said, I'm not sure where that's coming from.

2155
02:06:40,100 --> 02:06:45,400
He was saying that it's actually specified like that and the GL text

2156
02:06:45,400 --> 02:06:48,000
word one is an output 1 for fixed function pipeline.

2157
02:06:49,600 --> 02:06:52,300
So if that's the case, then that would be nice because I was just

2158
02:06:52,300 --> 02:06:54,900
trying to figure out how to get the fixed function input which again

2159
02:06:54,900 --> 02:06:56,400
like I said, normally you don't do

2160
02:06:58,500 --> 02:06:59,700
But let's see if that works.

2161
02:07:01,000 --> 02:07:02,300
Okay, there we go.

2162
02:07:03,100 --> 02:07:05,600
So that was, the only problem was that we weren't getting the right

2163
02:07:05,600 --> 02:07:06,800
fixed function, input there.

2164
02:07:07,500 --> 02:07:08,400
Thank you very much.

2165
02:07:09,700 --> 02:07:14,900
In this case, I can remove the, the setting it to 1.0 there.

2166
02:07:20,300 --> 02:07:20,900
There we go.

2167
02:07:20,900 --> 02:07:26,000
So now we're getting what we expect to get.

2168
02:07:26,000 --> 02:07:28,000
Pretty much in all cases, actually.

2169
02:07:28,000 --> 02:07:32,400
Now, we've were basically restored to what we want.

2170
02:07:32,400 --> 02:07:35,100
You can see, this is what we're actually outputting these sort of

2171
02:07:35,100 --> 02:07:38,100
flattened Sprites, right?

2172
02:07:38,100 --> 02:07:39,200
But it looks correct.

2173
02:07:39,200 --> 02:07:40,400
Now, when we look at them, right?

2174
02:07:40,400 --> 02:07:43,400
You can see the trees look like what they should look like and

2175
02:07:43,400 --> 02:07:43,700
everything.

2176
02:07:43,700 --> 02:07:45,800
But we still do have one problem.

2177
02:07:45,800 --> 02:07:49,000
One that we probably can't fix on this particular card.

2178
02:07:49,000 --> 02:07:50,300
As far as I know,

2179
02:07:50,400 --> 02:07:51,800
Because we don't have.

2180
02:07:55,500 --> 02:07:57,600
Well, I mean we could fix it I guess by trying to work around it in

2181
02:07:57,600 --> 02:08:01,200
the Shader but we don't actually do.

2182
02:08:01,700 --> 02:08:08,400
We don't actually have the GL srgb flag set still and if you remember

2183
02:08:08,400 --> 02:08:14,200
but when we create our multi, sample buffers here, for whatever

2184
02:08:14,200 --> 02:08:17,800
reason, even though it's supposed to, this card is not allowing us to

2185
02:08:17,800 --> 02:08:24,300
set the internal texture format to srgb, which is very bizarre, right?

2186
02:08:25,300 --> 02:08:29,100
So I'm not sure yeah we don't have a lot, we can do to work around

2187
02:08:29,100 --> 02:08:32,900
that although we could do it directly in the shaders ourselves which

2188
02:08:32,900 --> 02:08:35,800
but seems like a bad idea because we want to use the hardware for it

2189
02:08:36,100 --> 02:08:36,800
directly.

2190
02:08:40,000 --> 02:08:40,400
Yeah.

2191
02:09:12,700 --> 02:09:13,300
Midler.

2192
02:09:13,300 --> 02:09:19,100
I don't generally, I have to say, I have to go to both q&a's and type

2193
02:09:19,100 --> 02:09:23,300
in pound Q&A, so it doesn't automatically replicate anymore.

2194
02:09:24,900 --> 02:09:27,500
I think the handmade bought used to do it but it doesn't or in.

2195
02:09:27,500 --> 02:09:29,200
So about you said, do it, but doesn't anymore.

2196
02:09:29,500 --> 02:09:31,400
Sometimes I forget to put it in both.

2197
02:09:41,700 --> 02:09:45,900
Tag, you mentioned the new assets will not be rectangular like the

2198
02:09:45,900 --> 02:09:47,000
current assets.

2199
02:09:47,000 --> 02:09:50,400
Do we need to update the asset pipeline know the new assets are

2200
02:09:50,400 --> 02:09:51,200
rectangular

2201
02:11:02,200 --> 02:11:04,600
Every sure are we completely dropping support for the sufferer?

2202
02:11:04,600 --> 02:11:09,800
Now, no, we will definitely make the software renderer work as well.

2203
02:11:14,100 --> 02:11:15,200
I don't know when we'll do that.

2204
02:11:15,200 --> 02:11:18,000
You know, we might choose to do that much later on because we don't

2205
02:11:18,000 --> 02:11:22,100
need it for anything, but I would like to have them both running

2206
02:11:22,600 --> 02:11:23,300
eventually.

2207
02:11:36,700 --> 02:11:39,900
Ty says, I mean the hero head versus body versus

2208
02:11:42,100 --> 02:11:45,500
Cape are all the same shape.

2209
02:11:46,100 --> 02:11:46,900
Oh, yeah.

2210
02:11:48,100 --> 02:11:52,900
Yes, the we will have to do some changes to the code when we update

2211
02:11:52,900 --> 02:11:53,300
the artwork.

2212
02:11:53,300 --> 02:11:55,400
Certainly, but that'll be true in a lot of ways.

2213
02:11:59,000 --> 02:11:59,900
Can you explain what a little?

2214
02:12:00,000 --> 02:12:00,700
More detail.

2215
02:12:00,700 --> 02:12:02,100
How the Z bias thing works?

2216
02:12:02,100 --> 02:12:03,600
I'm not sure I understand it.

2217
02:12:04,800 --> 02:12:06,500
Yes, I can.

2218
02:12:12,800 --> 02:12:16,900
so, our situation as we had, it was

2219
02:12:19,200 --> 02:12:24,200
That we've got the camera looking down at a very steep angle, right?

2220
02:12:24,700 --> 02:12:29,200
And so we've got the right cards that are necessarily parallel to it

2221
02:12:29,200 --> 02:12:34,700
so that they can appear, you know, like Sprite cards on the screen.

2222
02:12:35,400 --> 02:12:40,600
But of course, if they are laying down that flat, they get intersected

2223
02:12:40,600 --> 02:12:45,100
here by other geometry that they really should be in front of.

2224
02:12:45,200 --> 02:12:48,200
We want them to look more like they're standing up straight like that.

2225
02:12:48,800 --> 02:12:52,700
But that would make them warp with the perspective projection.

2226
02:12:53,300 --> 02:12:56,700
So we want to leave them so that their face onto the camera.

2227
02:12:56,700 --> 02:12:58,200
So we have two choices here.

2228
02:12:58,500 --> 02:13:01,400
One is that we could actually have them stand up straight and then

2229
02:13:01,400 --> 02:13:05,500
adjust the, you know, if you took this is looking at it from the side,

2230
02:13:05,500 --> 02:13:09,200
if you looked at it, sort of more head on right here is those two

2231
02:13:09,700 --> 02:13:14,100
cubes and we've got the Sprite card that looks like this.

2232
02:13:15,400 --> 02:13:19,200
Flat one is to say well, okay.

2233
02:13:22,200 --> 02:13:26,300
We're gonna go ahead and widen or Shrink part of this.

2234
02:13:26,300 --> 02:13:31,500
So, we'll go ahead and, you know, move this up to here, but will

2235
02:13:31,500 --> 02:13:33,000
shrink it like that.

2236
02:13:33,300 --> 02:13:37,500
So, that the perspective that, you know, projection that fans, it out

2237
02:13:37,500 --> 02:13:41,500
will make it still appear to be a rectangle, right?

2238
02:13:41,700 --> 02:13:44,500
Because as it gets closer as it gets closer to the camera, it's going

2239
02:13:44,500 --> 02:13:46,200
to get you know bigger.

2240
02:13:46,200 --> 02:13:49,100
So if we don't have it in exactly.

2241
02:13:49,100 --> 02:13:49,900
And one,

2242
02:13:51,500 --> 02:13:55,700
Should I should back up and say anything in an XY plane relative to

2243
02:13:55,700 --> 02:13:57,300
the camera where the Z values don't change.

2244
02:13:57,300 --> 02:14:03,500
That's going to be a perfect rectangle on the screen with all four

2245
02:14:03,500 --> 02:14:03,800
corners.

2246
02:14:03,800 --> 02:14:04,200
Right?

2247
02:14:04,200 --> 02:14:04,600
Angled.

2248
02:14:04,600 --> 02:14:05,100
Right.

2249
02:14:05,100 --> 02:14:10,100
But anytime we make it come out of that plane, it's going to change

2250
02:14:10,100 --> 02:14:13,400
the apparent size of the top or the bottom right.

2251
02:14:13,400 --> 02:14:16,300
It's going to shrink or expand and you're going to end up with

2252
02:14:16,300 --> 02:14:18,400
something that on the screen looks like that or like this.

2253
02:14:18,400 --> 02:14:19,600
Right?

2254
02:14:19,600 --> 02:14:21,000
So what do we do?

2255
02:14:21,000 --> 02:14:21,400
It is to just

2256
02:14:21,500 --> 02:14:25,700
Just a pre is to make the opposite parallelogram in 3D that will undo

2257
02:14:25,700 --> 02:14:28,800
that projection so it's still projects to a rectangle even though it's

2258
02:14:28,800 --> 02:14:33,700
not the other way to do it is to leave it in the plane and in because

2259
02:14:33,700 --> 02:14:37,700
the only thing remember that makes the determines who shows up is the

2260
02:14:37,700 --> 02:14:37,900
Z.

2261
02:14:37,900 --> 02:14:43,800
Buffer is to just pass the Z buffer values from this but past the

2262
02:14:43,800 --> 02:14:46,200
actual coordinates from this, right?

2263
02:14:47,400 --> 02:14:48,500
And so, that's all we're doing.

2264
02:14:48,800 --> 02:14:51,400
What I do is I say okay, every

2265
02:14:51,600 --> 02:14:56,000
Text now has an x y z z bias, right?

2266
02:14:56,200 --> 02:14:59,700
So the W coordinate is actually Z bias in the Shader.

2267
02:14:59,700 --> 02:14:59,800
I

2268
02:15:00,000 --> 02:15:03,200
First that value to one point zero, so that the transform still

2269
02:15:03,200 --> 02:15:06,300
happens as if it's x y z 1, right?

2270
02:15:06,900 --> 02:15:12,100
So that just works, but then what I do is I take what this value was

2271
02:15:12,400 --> 02:15:19,000
and I transform a second Point that's x y z plus Z bias, right?

2272
02:15:19,000 --> 02:15:22,700
That gives me what the Z coordinate would be at this point.

2273
02:15:22,800 --> 02:15:26,600
And then I just say that that is the new point x.

2274
02:15:26,600 --> 02:15:27,100
Y.

2275
02:15:27,700 --> 02:15:29,900
And what if, what if that transform ends up being?

2276
02:15:30,000 --> 02:15:30,900
Being right.

2277
02:15:32,700 --> 02:15:34,400
So, you can see that happening in the code here.

2278
02:15:37,200 --> 02:15:38,400
The input vertex comes in.

2279
02:15:38,400 --> 02:15:42,300
I take just the XYZ and I slam this W 12:45.

2280
02:15:42,600 --> 02:15:46,200
So then I, I know that I'm going to transform it just like it normally

2281
02:15:46,200 --> 02:15:49,800
would be if we didn't have the Z bias at, all right?

2282
02:15:50,100 --> 02:15:52,500
Then, that transform happens, right here, right?

2283
02:15:52,500 --> 02:15:54,600
Zoom in transform is transferred in vertex.

2284
02:15:54,800 --> 02:15:57,700
I use that for the X Y and W values.

2285
02:15:58,000 --> 02:16:00,400
So the only thing I want to do now is change the Z values.

2286
02:16:00,400 --> 02:16:03,700
Member the Z value is only going to get used for z-buffering.

2287
02:16:04,000 --> 02:16:05,400
Write the W values.

2288
02:16:05,400 --> 02:16:05,600
What?

2289
02:16:05,600 --> 02:16:06,900
We'll do the divide and we're

2290
02:16:07,100 --> 02:16:10,800
The W value from the original vertex so it's unchanged so project to

2291
02:16:10,800 --> 02:16:14,000
the right place in screen space but to compute the Z coordinate.

2292
02:16:14,000 --> 02:16:17,300
What I do instead is I say all right let's make a new vertex that's

2293
02:16:17,300 --> 02:16:22,100
the same as the input vertex but now takes that Z bias and apply it to

2294
02:16:22,100 --> 02:16:22,700
move it in.

2295
02:16:22,700 --> 02:16:25,300
Z, do that transform and it will pass.

2296
02:16:25,300 --> 02:16:26,200
That is the Z.

2297
02:16:26,700 --> 02:16:30,000
So, effectively transforming two points, one, that's the original

2298
02:16:30,000 --> 02:16:30,300
point.

2299
02:16:30,300 --> 02:16:33,299
And one does the Original Point with a z offset and then we're using

2300
02:16:33,299 --> 02:16:36,799
the Z buffer value from that one, that allows us to pass the Z bias.

2301
02:16:37,000 --> 02:16:42,000
Skin per vertex, so that the two base vertices which are, you know,

2302
02:16:42,000 --> 02:16:45,200
the bottom of the Sprite will get nosy biasing and the two top ones

2303
02:16:45,200 --> 02:16:46,600
will get whatever we want.

2304
02:16:48,200 --> 02:16:49,400
Does that make more sense?

2305
02:17:51,299 --> 02:17:53,500
All right, think that's basically it.

2306
02:18:01,400 --> 02:18:03,600
Are we going to implement some for my Z before in Cipher?

2307
02:18:03,600 --> 02:18:06,200
Yes, we'll just exactly implement the z-buffer in software.

2308
02:18:19,700 --> 02:18:20,000
Yeah.

2309
02:18:20,000 --> 02:18:24,000
And so the key part of that, yeah like like Mansfield was saying just

2310
02:18:24,000 --> 02:18:24,900
to underscore it.

2311
02:18:24,900 --> 02:18:29,799
Is that effectively what we're doing is we're just transforming the

2312
02:18:29,799 --> 02:18:33,200
point as it normally would have been if we just specified it normally

2313
02:18:33,200 --> 02:18:37,600
without the weird Z bias then we just transform another one and Wii U

2314
02:18:37,700 --> 02:18:44,000
with the Z bias in and we use that result as the way that the Z buffer

2315
02:18:44,000 --> 02:18:47,000
will be used the W is, what does the does, the divided?

2316
02:18:47,000 --> 02:18:48,799
So as long as we use the

2317
02:18:49,000 --> 02:18:53,100
From our original default transform with 1.0 going through the

2318
02:18:53,100 --> 02:18:57,600
pipeline will get the right screen space physician and this Z will not

2319
02:18:57,600 --> 02:19:01,200
affect because this Z is not involved in the Divide at all.

2320
02:19:01,299 --> 02:19:02,799
Remember Z we don't divide by Z.

2321
02:19:02,799 --> 02:19:03,900
We divided by w.

2322
02:19:20,000 --> 02:19:23,799
All right, I'm going to go ahead and close it down.

2323
02:19:27,299 --> 02:19:29,299
See here, where are we at?

2324
02:19:29,299 --> 02:19:32,500
So, really our main problem at the moment is not being able to use the

2325
02:19:32,500 --> 02:19:35,900
srgb because it means all the colors are wrong, right?

2326
02:19:35,900 --> 02:19:39,500
Everything is too dark, because we can't specify srgb.

2327
02:19:40,299 --> 02:19:43,799
So I think we just need to actually move to a graphic card that isn't

2328
02:19:43,799 --> 02:19:48,299
seven years old which I maybe I'll have to try and do at some point

2329
02:19:48,299 --> 02:19:52,500
here to make things work a little bit more sanely.

2330
02:19:53,000 --> 02:19:54,600
So, yeah.

2331
02:19:55,100 --> 02:19:59,500
that's that's what we'll have to do but everything else seems to be

2332
02:19:59,500 --> 02:20:02,200
working relatively sanely here

2333
02:20:05,300 --> 02:20:09,000
We just need to get those colors fixed so that they're not all messed

2334
02:20:09,000 --> 02:20:09,300
up.

2335
02:20:10,400 --> 02:20:11,000
All right.

2336
02:20:13,200 --> 02:20:14,300
Alrighty.

2337
02:20:16,200 --> 02:20:18,200
Thanks everyone for joining me, for this of it, handmade here.

2338
02:20:18,200 --> 02:20:19,400
It's been a pleasure cooking with you.

2339
02:20:19,400 --> 02:20:23,500
As always, if you would like to follow along the series at home, you

2340
02:20:23,500 --> 02:20:25,700
can always pre-order the game on handmade hero dot-org.

2341
02:20:26,500 --> 02:20:28,500
It comes with a source code so you can play around with it.

2342
02:20:29,000 --> 02:20:30,800
We also have a forum site, you can go to.

2343
02:20:30,800 --> 02:20:33,300
If you want to ask questions a patreon page for on Sports video

2344
02:20:33,300 --> 02:20:36,300
series, a schedule bot that tweet the schedule at you.

2345
02:20:36,300 --> 02:20:40,800
If you would like to know when we're going to be live and an episode

2346
02:20:40,800 --> 02:20:45,400
guide for catching up on old episodes, that's about it for this week.

2347
02:20:46,000 --> 02:20:49,000
I will be back next week when we will.

2348
02:20:49,000 --> 02:20:53,200
Well, I'm not sure what we'll be doing next week actually, because

2349
02:20:53,200 --> 02:20:57,400
that's pretty much what we needed to do in terms of Z by saying, I

2350
02:20:57,400 --> 02:20:59,800
think we will probably want to maybe just take

2351
02:21:00,000 --> 02:21:03,800
And clean up and stop using the fixed function pipeline.

2352
02:21:03,800 --> 02:21:07,400
Probably, because we're probably on thin ice there in terms of

2353
02:21:07,400 --> 02:21:08,200
compatibility.

2354
02:21:08,800 --> 02:21:10,200
We're lucky that that worked.

2355
02:21:10,400 --> 02:21:14,500
So just finish transitioning away from that was probably the best

2356
02:21:14,500 --> 02:21:15,000
idea.

2357
02:21:15,600 --> 02:21:19,400
So we'll probably take a look at that next weekend, and that is about

2358
02:21:19,400 --> 02:21:19,700
that.

2359
02:21:19,700 --> 02:21:21,700
All right, thanks everyone.

2360
02:21:22,500 --> 02:21:24,900
Until next time, have fun programming and I'll see you on the

2361
02:21:24,900 --> 02:21:25,300
internet.

2362
02:21:25,300 --> 02:21:26,100
Take it easy, everybody.

