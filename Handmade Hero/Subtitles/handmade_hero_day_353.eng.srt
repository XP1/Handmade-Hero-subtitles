1
00:00:02,200 --> 00:00:04,500
Hello everyone, and welcome to handmade hero show.

2
00:00:04,500 --> 00:00:07,700
Rico to complete game live on stream before we get started today.

3
00:00:08,500 --> 00:00:14,800
I just wanted to put in a brief little aside on LZ versus run length,

4
00:00:14,800 --> 00:00:15,700
encoding compression.

5
00:00:18,500 --> 00:00:23,100
The, the fine fellow who's responsible for the past episodes.

6
00:00:24,300 --> 00:00:31,000
This this past episode guide that we use on handmade hero is currently

7
00:00:31,000 --> 00:00:33,400
working on a run length and coder.

8
00:00:33,400 --> 00:00:36,100
And I was just he was mentioning it in the pre stream and I was just

9
00:00:36,100 --> 00:00:36,700
mentioning that.

10
00:00:36,700 --> 00:00:39,800
Hey, if you make a run length, encoding, it's not that much of a jump

11
00:00:40,300 --> 00:00:41,600
to making an LZ encoder.

12
00:00:41,600 --> 00:00:45,600
The decompressor is actually basically the same and it's only the

13
00:00:45,600 --> 00:00:47,900
compressor actually gets a little more complicated, but I

14
00:00:48,100 --> 00:00:51,500
And to diagram that for folks, because there's a really interesting

15
00:00:51,500 --> 00:00:55,200
thing that happens with LZ compression and run length, encoding that I

16
00:00:55,200 --> 00:00:59,300
thought would be interesting for beginners here.

17
00:01:00,200 --> 00:01:04,300
So let me just go ahead and sort of diagram that out.

18
00:01:04,599 --> 00:01:08,800
So let me just talk about rle versus LZ.

19
00:01:10,900 --> 00:01:14,200
Alright, so, for those of you who don't know very much about these

20
00:01:14,200 --> 00:01:17,300
sorts of things, which by the way is also me, I'm not a compression

21
00:01:17,300 --> 00:01:20,000
expert as I think I mentioned it this this recent handmade con.

22
00:01:20,000 --> 00:01:23,700
One of the reasons I asked the folks that Rod to come and talk about

23
00:01:23,700 --> 00:01:25,200
it is because they are compression experts.

24
00:01:27,000 --> 00:01:29,400
I'm a waitress a, they are the compression experts.

25
00:01:30,500 --> 00:01:36,100
As like, the him, the people who currently have, like the world's

26
00:01:36,100 --> 00:01:39,500
reigning smallest size, fastest speed, compressor, or whatever it is.

27
00:01:41,100 --> 00:01:45,300
But, you know, just some basic things here because compression is kind

28
00:01:45,300 --> 00:01:48,100
of just interesting and encoders are interesting in the general case

29
00:01:48,100 --> 00:01:51,100
and there's some simple things you can start to look at about them.

30
00:01:51,500 --> 00:01:54,900
So, what what are these things?

31
00:01:54,900 --> 00:01:56,300
Well, you know, if you imagine that

32
00:01:56,500 --> 00:02:00,700
You're sending something and you or encoding something that you want

33
00:02:00,700 --> 00:02:02,000
to make smaller, right?

34
00:02:02,200 --> 00:02:04,400
There's a number of ways that you might go about doing this.

35
00:02:04,400 --> 00:02:09,800
And, you know, every way that you might try to compress something is,

36
00:02:09,900 --> 00:02:13,300
is basically about figuring out what special properties of the data

37
00:02:13,300 --> 00:02:16,400
are that you're working with, and exploiting those special properties.

38
00:02:16,400 --> 00:02:20,400
Because in general, you know, I like I said, I'm not a compression

39
00:02:20,400 --> 00:02:20,800
expert.

40
00:02:20,800 --> 00:02:25,400
But the general consensus among people in terms of the math on this,

41
00:02:27,400 --> 00:02:31,100
Is the information Theory wise in terms of what we've been able to

42
00:02:31,100 --> 00:02:35,700
determine about how information really works, it's kind of provable

43
00:02:35,700 --> 00:02:38,300
that there is no way to generally compress things.

44
00:02:38,300 --> 00:02:43,400
Meaning you know if you wanted to make something that can fit stuff in

45
00:02:43,400 --> 00:02:46,300
a smaller space, always it's not really possible.

46
00:02:46,500 --> 00:02:49,600
All you can do is make things that fit things in smaller spaces for

47
00:02:49,600 --> 00:02:52,500
certain classes of information, right?

48
00:02:53,700 --> 00:02:57,100
And and again like that's you know, math, as we

49
00:02:57,200 --> 00:02:59,900
no, it seems to indicate very strongly that this is the

50
00:03:00,000 --> 00:03:03,200
Ace and you know I mean who knows maybe someday we'll come up with

51
00:03:03,200 --> 00:03:06,300
weird things that sort of change the way we think about the world or

52
00:03:06,300 --> 00:03:12,100
something, but assuming that the math we currently have is is, you

53
00:03:12,100 --> 00:03:15,100
know, as infallible as it as we currently think it is.

54
00:03:15,100 --> 00:03:17,600
Then there's nothing you can really do to make a thing that

55
00:03:17,600 --> 00:03:21,800
generically makes information smaller that doesn't happen.

56
00:03:21,800 --> 00:03:27,700
But with any piece of information, usually you're transmitting it in a

57
00:03:27,700 --> 00:03:28,500
context, right?

58
00:03:28,500 --> 00:03:29,900
Like, for example, maybe I'm

59
00:03:30,000 --> 00:03:31,300
Making an image compressor.

60
00:03:31,300 --> 00:03:33,800
Well, well, that means that I kind of fundamentally.

61
00:03:33,800 --> 00:03:37,800
No, I'm transmitting images as opposed to other data, so that already

62
00:03:37,800 --> 00:03:42,000
puts me in like a class of sort of information or storing them or

63
00:03:42,000 --> 00:03:42,300
whatever.

64
00:03:42,300 --> 00:03:43,300
I'm going to do, right?

65
00:03:43,900 --> 00:03:46,200
And similarly, maybe I know these are photographs.

66
00:03:46,200 --> 00:03:50,800
So there's even more restricted, the kinds of sort of information that

67
00:03:50,800 --> 00:03:53,700
might be in here and the way that it looks and so typically what we're

68
00:03:53,700 --> 00:03:54,900
doing with a compressor,

69
00:03:57,700 --> 00:04:00,600
Is there saying well for the particular category of stuff that we're

70
00:04:00,600 --> 00:04:04,700
working with what we're going to do is say we know that the the type

71
00:04:04,700 --> 00:04:05,200
of information.

72
00:04:05,200 --> 00:04:08,000
We're compressing has certain fundamental properties that are often

73
00:04:08,000 --> 00:04:12,500
true and by exploiting the fact that those things are more often true

74
00:04:12,500 --> 00:04:13,000
than not.

75
00:04:13,000 --> 00:04:16,800
We can encode the information in a smaller space because we are

76
00:04:16,899 --> 00:04:21,100
effectively giving up the ability to encode other pieces of

77
00:04:21,100 --> 00:04:23,800
information that are not relevant to our interest.

78
00:04:23,800 --> 00:04:26,000
In this case, those

79
00:04:26,200 --> 00:04:27,000
Would get bigger.

80
00:04:27,100 --> 00:04:27,700
Right?

81
00:04:27,800 --> 00:04:31,300
So if you imagine this playing out in a scenario, like, like I said

82
00:04:31,300 --> 00:04:34,100
with image compression, let's say we're trying to losslessly compress

83
00:04:34,100 --> 00:04:35,000
an image.

84
00:04:35,000 --> 00:04:38,400
Well, we kind of know, the sorts of images humans, tend to make and

85
00:04:38,400 --> 00:04:39,800
transmit or store.

86
00:04:40,400 --> 00:04:43,400
Again, we also know photographs versus like line art or that sort of

87
00:04:43,400 --> 00:04:43,800
thing.

88
00:04:44,200 --> 00:04:45,900
These all have very surprised to them.

89
00:04:46,100 --> 00:04:49,800
It's very unusual that someone would make an image that's just like

90
00:04:49,800 --> 00:04:51,500
white noise, right?

91
00:04:51,500 --> 00:04:52,200
Or an image.

92
00:04:52,200 --> 00:04:56,000
That's just like a very specific weird pattern of alternating Dot

93
00:04:56,200 --> 00:04:59,100
Or whatever those are very unusual images.

94
00:04:59,500 --> 00:05:03,800
So by saying that we don't care how big those images are to encode, we

95
00:05:03,800 --> 00:05:07,400
can make a bunch of sort of assumptions about how our image data is

96
00:05:07,400 --> 00:05:09,500
going to look that will allow us to encode.

97
00:05:09,500 --> 00:05:13,500
Other the images, we work frequently care about in smaller space,

98
00:05:13,700 --> 00:05:14,100
right?

99
00:05:14,800 --> 00:05:16,800
So that's generally what we're talking about when we talk about

100
00:05:16,800 --> 00:05:17,400
compression.

101
00:05:17,400 --> 00:05:22,200
It's this sort of selecting a sort of an area of information that we

102
00:05:22,200 --> 00:05:25,700
care about storing, and we're pre saying we're only going to work well

103
00:05:25,700 --> 00:05:26,000
on those

104
00:05:26,200 --> 00:05:26,600
Of things.

105
00:05:26,700 --> 00:05:30,000
And then we start to make a bunch of concessions to that type of data.

106
00:05:30,200 --> 00:05:33,400
That means that other types of data would get bigger and we'd actually

107
00:05:33,400 --> 00:05:37,300
have an inflator not a compressor if we ran it on those but since we

108
00:05:37,300 --> 00:05:39,400
never care about running on those it's okay.

109
00:05:39,400 --> 00:05:41,100
And that's basically what compression is about.

110
00:05:41,100 --> 00:05:44,100
It's about baking those assumptions in to a piece of code that then

111
00:05:44,100 --> 00:05:48,000
allows you to store and transmit a certain class of information, often

112
00:05:48,000 --> 00:05:51,100
much more efficiently because you have sort of given up on these

113
00:05:51,100 --> 00:05:52,400
others on the other

114
00:05:53,600 --> 00:05:58,800
Classes of information that you don't care about and so rle or run

115
00:05:58,800 --> 00:05:59,000
length.

116
00:05:59,000 --> 00:05:59,900
Encoding is usually

117
00:06:00,000 --> 00:06:03,000
First kind of compression that anyone comes across and it's the kind

118
00:06:03,000 --> 00:06:07,400
that you used to use way way back in the day before, sort of more

119
00:06:08,500 --> 00:06:10,300
extensive compressors were really common.

120
00:06:15,300 --> 00:06:18,600
But all it is is it's called run length.

121
00:06:20,200 --> 00:06:20,900
Encoding.

122
00:06:22,300 --> 00:06:27,000
And what it is is rle, schemes are a family of schemes that all work,

123
00:06:27,400 --> 00:06:30,900
you know, very similarly but the specific way that you might pick how

124
00:06:30,900 --> 00:06:34,600
to encode them might change a little bit but the idea is simply that,

125
00:06:34,900 --> 00:06:38,600
well, if I'm coding, a piece of data, you know, that has some data, as

126
00:06:38,600 --> 00:06:45,000
you know, maybe it's got, you know, an a b, a c and e, g, and H, and

127
00:06:45,000 --> 00:06:47,800
then an a again, and then it'd be and whatever it comes to here, and

128
00:06:47,800 --> 00:06:49,100
that's my message.

129
00:06:49,100 --> 00:06:50,800
But then, it does something like.

130
00:06:50,800 --> 00:06:51,900
Well, now, there's just a bunch

131
00:06:52,100 --> 00:06:54,300
Of bees in a row, right?

132
00:06:56,400 --> 00:07:00,200
And you can imagine this sort of thing is a little bit more popular.

133
00:07:00,200 --> 00:07:04,800
Perhaps, in pixel art, where you've got, you know, maybe big Phil's of

134
00:07:04,800 --> 00:07:07,000
of the same color or something like this, right?

135
00:07:07,700 --> 00:07:10,200
Well what run length encoding does is it says all right, if I'm going

136
00:07:10,200 --> 00:07:13,800
to encode this message well and the unencoded version of this message,

137
00:07:13,900 --> 00:07:14,300
right?

138
00:07:14,400 --> 00:07:15,200
How many are there here?

139
00:07:15,200 --> 00:07:20,500
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16.

140
00:07:20,500 --> 00:07:21,000
Right?

141
00:07:21,000 --> 00:07:25,400
So there's 16 sort of pieces of information are symbols if you

142
00:07:25,500 --> 00:07:29,200
In this, you know, this piece of information that I'm trying to

143
00:07:29,200 --> 00:07:29,500
encode.

144
00:07:29,500 --> 00:07:36,000
But one, two, three, four, five, six, seven, eight of them, right?

145
00:07:36,000 --> 00:07:40,600
Are actually sort of information that I, that I would have to encode,

146
00:07:40,600 --> 00:07:42,200
perhaps individually.

147
00:07:42,200 --> 00:07:42,900
Right.

148
00:07:42,900 --> 00:07:46,000
But then there's this big long set, that's just duplicated.

149
00:07:46,000 --> 00:07:51,500
So, what I might be able to do is put a number first, for example, you

150
00:07:51,500 --> 00:07:52,500
know, right before here.

151
00:07:52,500 --> 00:07:55,100
If I've got these, I'm going to

152
00:07:55,500 --> 00:07:57,300
Stop it right here and say I've got these seven, right?

153
00:07:57,300 --> 00:07:59,200
One, two, three, four, five, six, seven.

154
00:07:59,300 --> 00:08:08,100
If I first encoded a seven and then said a b c EG h, a right, well,

155
00:08:08,100 --> 00:08:10,500
I've expanded my message by one.

156
00:08:10,600 --> 00:08:12,100
I've inserted one symbol here.

157
00:08:12,100 --> 00:08:15,400
Alright, so it got a little bit bigger, but then what I could do is

158
00:08:15,400 --> 00:08:18,700
I've got one, two, three, four, five, six, seven, eight, nine,

159
00:08:18,700 --> 00:08:19,500
repeated B's.

160
00:08:19,500 --> 00:08:22,800
I could just say nine and then, Abby, right?

161
00:08:24,700 --> 00:08:28,500
And so if you look at what happens here, all I would need to do now is

162
00:08:28,500 --> 00:08:33,500
encode some way of saying the seven is how many things I have in a row

163
00:08:33,500 --> 00:08:35,100
that I care about, right?

164
00:08:35,200 --> 00:08:40,200
And the 9 is, is the thing that encodes the thing that comes after?

165
00:08:40,200 --> 00:08:41,799
It is just duplicated a bunch of times.

166
00:08:41,799 --> 00:08:45,500
Instead of looking for New pieces of information that come after it

167
00:08:45,600 --> 00:08:48,300
and often times the way that this works in early, it says, well, I

168
00:08:48,300 --> 00:08:51,800
won't even bother spending any extra information to communicate that

169
00:08:51,800 --> 00:08:53,900
all I'll say is that we just go in.

170
00:08:54,000 --> 00:08:58,600
A I send a number of literals as they're called, you know, basically

171
00:08:58,600 --> 00:08:59,800
things I'm going to encode directly.

172
00:09:00,200 --> 00:09:03,700
And then a run literals run, literals run.

173
00:09:03,700 --> 00:09:06,400
So I just do how many pieces of new information do I have?

174
00:09:06,400 --> 00:09:07,200
I put them in there.

175
00:09:07,400 --> 00:09:09,000
How many pieces of replicated information?

176
00:09:09,000 --> 00:09:09,400
Do I have?

177
00:09:09,400 --> 00:09:11,000
I put them in there, right?

178
00:09:12,400 --> 00:09:14,600
And then the next one, it would be a literal count again.

179
00:09:14,600 --> 00:09:18,500
And if I didn't have a run and I was at the maximum size that I could

180
00:09:18,500 --> 00:09:20,100
fit in here, like let's say, these are B.

181
00:09:20,100 --> 00:09:23,600
So maybe the maximum number of literals, I can have, is 255 for the

182
00:09:23,600 --> 00:09:26,400
run, I just encode a zero and then it would be like, okay, there's

183
00:09:26,400 --> 00:09:26,900
nothing.

184
00:09:26,900 --> 00:09:29,800
There are no repeated values here and then the next thing would be

185
00:09:29,800 --> 00:09:31,500
another count of literals, right?

186
00:09:32,100 --> 00:09:34,600
So hopefully you can see how that run cutting very, very simple.

187
00:09:34,600 --> 00:09:37,200
It's basically just a number of how many new piece of information.

188
00:09:37,200 --> 00:09:41,400
I have been a number of how many replications I want to do of the next

189
00:09:41,400 --> 00:09:42,000
bite.

190
00:09:42,200 --> 00:09:42,600
Right?

191
00:09:42,600 --> 00:09:46,900
So it's just like new B and then the B run count and then the B to

192
00:09:46,900 --> 00:09:51,900
repeat new B and the B run count the run to repeat, right.

193
00:09:59,300 --> 00:10:03,200
So hopefully that makes a fair bit of sense, right?

194
00:10:04,400 --> 00:10:05,800
It's very, very simple encoding.

195
00:10:05,800 --> 00:10:08,800
And, you know, for those of you who ever were back in the day, if you

196
00:10:08,800 --> 00:10:13,600
ever heard of like the old-school formats, like maybe you're like me,

197
00:10:13,600 --> 00:10:14,500
you grew up.

198
00:10:14,500 --> 00:10:17,200
You had an Amiga in the household to me, computer.

199
00:10:18,100 --> 00:10:24,000
Electronic Arts, I believe is the company who introduced this format.

200
00:10:24,000 --> 00:10:27,300
It was called The Interchange file format, her iff, and it had the

201
00:10:27,300 --> 00:10:29,900
interleave bitmap format was a sub format of it.

202
00:10:29,900 --> 00:10:31,200
That could be put in there.

203
00:10:31,200 --> 00:10:33,800
Ifm was kind of a container format, that can hold multiple formats.

204
00:10:34,300 --> 00:10:36,500
It was our iff related.

205
00:10:36,600 --> 00:10:39,900
I don't remember what our iife even stands for, but riff chunks are a

206
00:10:39,900 --> 00:10:42,700
standard thing and I, I'm sorry, I can't remember what it stands for.

207
00:10:42,700 --> 00:10:49,200
But anyway, this file format actually had run length, encoding in it.

208
00:10:49,200 --> 00:10:53,400
So if you ever remember how bitmaps are sorted on the Amiga, I believe

209
00:10:53,400 --> 00:10:54,400
our Ellie was in there.

210
00:10:56,600 --> 00:10:57,500
Again, back in the day.

211
00:11:00,500 --> 00:11:03,200
I believe there's also like maybe PCX.

212
00:11:03,200 --> 00:11:07,400
I'm sorry my memory is kind of fading here but there's some old-school

213
00:11:08,000 --> 00:11:11,800
formats that Graphics formats that that use this.

214
00:11:12,000 --> 00:11:15,000
It's not really something that's used very commonly anymore, but it's,

215
00:11:15,000 --> 00:11:21,100
you know, it's and it was, it was not so uncommon back in the day and

216
00:11:21,100 --> 00:11:22,300
why was it not so uncommon?

217
00:11:22,300 --> 00:11:25,800
Well, if you think about it, it's really, really simple, right?

218
00:11:26,000 --> 00:11:29,100
You know, this can be coated in a few lines of code, it's just

219
00:11:29,300 --> 00:11:34,500
Read read one byte you know, copy the number of bytes from the input

220
00:11:34,500 --> 00:11:38,000
stream to the output stream that you just read read one, byte and a

221
00:11:38,000 --> 00:11:41,700
replication, B, and just do a for Loop to Output that bite that many

222
00:11:41,700 --> 00:11:42,900
times, right?

223
00:11:43,700 --> 00:11:44,400
That's it.

224
00:11:45,000 --> 00:11:46,800
So it's very, very, very simple.

225
00:11:47,900 --> 00:11:51,900
You know, there's its it takes almost no code and can run very

226
00:11:51,900 --> 00:11:52,800
quickly, right?

227
00:11:53,900 --> 00:11:57,200
So the point that I want to make about early versus L, see here that

228
00:11:57,200 --> 00:11:58,700
came from the pre stream is LZ.

229
00:11:58,700 --> 00:11:59,800
Compression is a sort of

230
00:12:00,700 --> 00:12:03,300
Much more heavy-duty form of compression.

231
00:12:03,300 --> 00:12:05,300
You might say, and why do I say that?

232
00:12:05,300 --> 00:12:08,800
Because, you know, at the outset I sort of said, well, you know,

233
00:12:09,300 --> 00:12:12,000
compression is a no-win scenario, right?

234
00:12:12,000 --> 00:12:15,000
It's like, it's just about selecting, certain sets of information that

235
00:12:15,000 --> 00:12:17,200
you can encode and you can't really ever make something that makes

236
00:12:17,500 --> 00:12:18,600
everything smaller.

237
00:12:18,700 --> 00:12:21,300
So why am I saying that this is like more heavyweight.

238
00:12:21,300 --> 00:12:22,200
What does that even mean?

239
00:12:22,200 --> 00:12:24,500
Certainly it should just be that no matter what.

240
00:12:24,500 --> 00:12:25,300
Encoding you choose.

241
00:12:25,300 --> 00:12:26,600
Some things are much better than others.

242
00:12:26,600 --> 00:12:28,000
And Bubba Bubba Bubba right.

243
00:12:29,600 --> 00:12:29,800
Well

244
00:12:30,000 --> 00:12:34,100
Oh, I really mean to say by this is this is a much more commonly

245
00:12:34,100 --> 00:12:35,500
applied compression technique.

246
00:12:35,500 --> 00:12:39,100
So if nothing else, we could probably say that our experience.

247
00:12:39,100 --> 00:12:44,200
So far has shown that LZ as a technique tends to encode, human-style

248
00:12:44,200 --> 00:12:48,900
messages much more interestingly than rle does for in terms of getting

249
00:12:48,900 --> 00:12:49,900
good compression out of it.

250
00:12:49,900 --> 00:12:53,300
So, you know, even though compression is a zero-sum game, it doesn't

251
00:12:53,300 --> 00:12:54,300
mean there aren't better.

252
00:12:54,300 --> 00:12:56,700
And worse compressors for the kind of information that we typically

253
00:12:56,700 --> 00:12:57,500
care about.

254
00:12:59,000 --> 00:13:00,900
And Elsie compression is something that's used in.

255
00:13:00,900 --> 00:13:07,600
Basically everything that you use today whether it's 7-Zip or pkzip or

256
00:13:07,600 --> 00:13:12,600
you know any of the sort of zip based utilities that you use or in a

257
00:13:13,100 --> 00:13:14,000
PNG file.

258
00:13:14,000 --> 00:13:17,500
For example, anywhere that you're doing lossless encoding.

259
00:13:17,500 --> 00:13:21,900
You're going to see a lot of LZ related techniques and it's been

260
00:13:21,900 --> 00:13:23,000
around for a very long time.

261
00:13:23,000 --> 00:13:27,600
It's been around since the 70s and it's just something that hasn't

262
00:13:27,700 --> 00:13:28,600
really been beaten.

263
00:13:29,000 --> 00:13:32,100
It's, I guess, for whatever reason, it really hits a sweet spot in

264
00:13:32,100 --> 00:13:36,600
terms of efficiency of coding versus ability to, actually get

265
00:13:36,600 --> 00:13:41,500
compression out of the types of messages humans, typically send or

266
00:13:41,500 --> 00:13:42,300
care about storing.

267
00:13:42,300 --> 00:13:46,200
So, l z is a very, very popular compression format but, you know,

268
00:13:46,200 --> 00:13:50,200
maybe it's a little bit more daunting to understand than our Ali or

269
00:13:50,200 --> 00:13:53,500
something like this or maybe, you know, you think that it's like, oh,

270
00:13:53,500 --> 00:13:54,600
it's kind of lure out there.

271
00:13:54,600 --> 00:13:57,300
And I just wanted to make the point when, because we're talking about

272
00:13:57,300 --> 00:13:57,600
on the

273
00:13:57,800 --> 00:14:00,800
I'm that LZ in our earlier base are almost identical.

274
00:14:01,600 --> 00:14:05,400
LZ is just a tiny, tiny, little bit more than are at least.

275
00:14:05,400 --> 00:14:09,500
So if you feel comfortable programming run-length, encoding, you also

276
00:14:09,500 --> 00:14:14,500
trust me will feel very comfortable programming LZ, which stands for

277
00:14:14,500 --> 00:14:15,200
lempel ziv.

278
00:14:15,200 --> 00:14:18,400
It's named after the people, it's not like run-length encoding where

279
00:14:18,400 --> 00:14:20,000
it's named after kind of what it does.

280
00:14:22,900 --> 00:14:25,300
So this is very easy, especially the decoder.

281
00:14:25,300 --> 00:14:32,000
Now, the encoders are a little more complicated, not that much more

282
00:14:32,000 --> 00:14:36,500
complicated because you don't have to take it to the nth degree.

283
00:14:36,700 --> 00:14:40,300
One of the things about encoding that I'll talk about in a second.

284
00:14:40,500 --> 00:14:44,500
Is that the reason that a gnarly encoder is more is more

285
00:14:44,500 --> 00:14:46,000
straightforward than an LZ encoder.

286
00:14:46,000 --> 00:14:48,500
Although, you know, one of the reasons is you'll see in a second is

287
00:14:48,500 --> 00:14:51,100
this because there's a little more bookkeeping to do just to make

288
00:14:51,400 --> 00:14:52,600
pills of encoder.

289
00:14:53,700 --> 00:14:57,500
Then there is our Ally but with a limp L7 coder, there are choices

290
00:14:57,500 --> 00:14:59,800
about what's the best thing to encode.

291
00:15:01,100 --> 00:15:05,200
So, there's options, there's not just one right way to do a lempel ziv

292
00:15:05,200 --> 00:15:09,600
in code, in terms of what the code looks at it, whereas with rle,

293
00:15:09,600 --> 00:15:10,800
that's not true rle.

294
00:15:10,800 --> 00:15:14,000
There's only one way to encode, the data for any given scheme.

295
00:15:14,000 --> 00:15:18,800
So it's just instant, pretty much how it works, you know, I guess.

296
00:15:19,000 --> 00:15:19,600
Well, you know,

297
00:15:21,800 --> 00:15:23,200
Maybe that's not exactly true.

298
00:15:23,200 --> 00:15:26,100
I mean, I could see for summarily schemes, like the one I laid out

299
00:15:26,100 --> 00:15:26,300
here.

300
00:15:26,300 --> 00:15:27,900
Maybe there are a couple of choices you could make.

301
00:15:27,900 --> 00:15:31,300
So I, you know, maybe I wouldn't even go that far, I guess, maybe the

302
00:15:31,300 --> 00:15:35,700
better way to say it would be with something like lempel, ziv, your

303
00:15:35,700 --> 00:15:40,300
encoder couldn't get perhaps significantly more compression by making

304
00:15:40,300 --> 00:15:44,400
different choices often times whereas with our Ali, maybe that's not

305
00:15:44,400 --> 00:15:45,100
the case as often.

306
00:15:45,100 --> 00:15:48,400
So I don't know minimalists often that a little bit but either way,

307
00:15:48,400 --> 00:15:49,400
you could ignore all that.

308
00:15:49,400 --> 00:15:51,500
All I really wanted to show was about the decompression.

309
00:15:51,700 --> 00:15:55,300
Then how simple LZ really is, so that you can feel like it.

310
00:15:55,300 --> 00:15:57,800
Maybe it's a little bit more accessible to you, then it would be.

311
00:15:57,800 --> 00:16:00,800
So again, they feel comfortable with our Ali, you should feel very

312
00:16:00,800 --> 00:16:01,500
comfortable with LZ.

313
00:16:01,500 --> 00:16:02,300
And here's why

314
00:16:03,600 --> 00:16:07,300
So, all an LZ encoder does, is basically exactly the same thing that

315
00:16:07,300 --> 00:16:08,400
we talked about.

316
00:16:09,000 --> 00:16:12,900
But instead of encoding runs the Run Part, right?

317
00:16:12,900 --> 00:16:16,000
So the literal part is almost exactly the same in LZ.

318
00:16:16,000 --> 00:16:17,800
There's really no difference at some.

319
00:16:17,800 --> 00:16:21,200
There's going to be some way in a lempel ziv scheme to encode.

320
00:16:21,200 --> 00:16:25,100
The fact that we've got a bunch of new B coming and then we encode the

321
00:16:25,100 --> 00:16:27,800
B that part stays basically the same.

322
00:16:28,300 --> 00:16:32,500
The part that changes is the Run Part instead of talking about runs in

323
00:16:32,500 --> 00:16:33,100
a generic sense.

324
00:16:33,300 --> 00:16:42,600
And right where we're saying oh hey, by the way, when I say something

325
00:16:42,600 --> 00:16:45,400
is a run, I'm just going to give you a bite and you replicate that

326
00:16:45,400 --> 00:16:46,500
bite.

327
00:16:47,800 --> 00:16:50,000
So, rather than encoding runs that way.

328
00:16:50,000 --> 00:16:54,100
Instead, what I'm going to say is in addition to just account, I'm

329
00:16:54,100 --> 00:16:57,100
also going to give you an offset, okay?

330
00:16:57,400 --> 00:17:02,600
And the offset is going to be some look back into.

331
00:17:02,600 --> 00:17:03,000
What I've

332
00:17:03,200 --> 00:17:07,099
Already sent you and then you're going to take that many, whatever.

333
00:17:07,099 --> 00:17:11,000
I said, the Run was, you're going to copy that many things from the

334
00:17:11,000 --> 00:17:11,800
previous information.

335
00:17:11,800 --> 00:17:20,300
So, for example, if I had something like a b, c, d, e, f, g, h i j b,

336
00:17:20,300 --> 00:17:24,599
GH, ABCD, right.

337
00:17:24,599 --> 00:17:30,300
And one way that I might encode, this is say, well, okay, if my

338
00:17:30,300 --> 00:17:32,700
encoder notices that we have an

339
00:17:33,200 --> 00:17:36,500
Edie and an ABCD in both places, right?

340
00:17:37,100 --> 00:17:38,400
Then it might choose to.

341
00:17:38,400 --> 00:17:40,700
And there's the, you know, you can notice that this a be here.

342
00:17:40,700 --> 00:17:41,900
I'll talk about that in a second.

343
00:17:41,900 --> 00:17:43,400
And these GH is right.

344
00:17:44,000 --> 00:17:44,800
We'll talk about those in a second.

345
00:17:44,800 --> 00:17:49,200
But I see these ABCDs here in the encoder and I say, oh okay, so maybe

346
00:17:49,200 --> 00:17:56,000
I say 1, 2, 3 4 5 6 7 8 9, 10 11, maybe I encode my 11 and then I

347
00:17:56,000 --> 00:17:57,700
encode this, right?

348
00:17:57,800 --> 00:17:58,900
And those are all new B.

349
00:17:58,900 --> 00:17:59,800
So these are literals

350
00:18:00,000 --> 00:18:00,400
Right.

351
00:18:00,900 --> 00:18:06,500
Then I look at the ABCD and I say, oh back here I already sent an

352
00:18:06,500 --> 00:18:07,400
ABCD.

353
00:18:07,700 --> 00:18:14,400
So instead what I'll say is just 0 go back 1 2 3, 4 5 6 7 8 9 10, 11

354
00:18:14,400 --> 00:18:21,200
B, right and then copy for B so you know the run like this is for the

355
00:18:21,200 --> 00:18:24,000
distance is 11 and that's all I needed to encode.

356
00:18:24,000 --> 00:18:27,500
So instead of having to write for things into the input stream I only

357
00:18:27,500 --> 00:18:28,600
had to write to

358
00:18:29,500 --> 00:18:30,000
Right.

359
00:18:36,400 --> 00:18:41,400
Okay so hopefully that makes some sense and you know again there's

360
00:18:41,400 --> 00:18:45,400
some subtlety here because when you encode things like this you still

361
00:18:45,400 --> 00:18:46,600
have the problem of.

362
00:18:46,800 --> 00:18:49,400
How do I encode?

363
00:18:49,400 --> 00:18:50,700
What thing I'm doing?

364
00:18:50,800 --> 00:18:55,600
Like if I say that I have an 11:00 here or a for how do I know what

365
00:18:55,600 --> 00:18:59,000
that means and like one answer like it was in the early case is to

366
00:18:59,000 --> 00:19:02,000
just say that they're alternating so the decompressor always knows it

367
00:19:02,000 --> 00:19:02,100
does.

368
00:19:02,300 --> 00:19:04,200
And then the other one, the other one than the other.

369
00:19:04,200 --> 00:19:05,900
It doesn't have to spare any extra bits.

370
00:19:06,300 --> 00:19:09,800
Other things might have individual bits on there that are like, codes

371
00:19:09,800 --> 00:19:12,200
that say, oh, you do this or you do that.

372
00:19:12,200 --> 00:19:15,800
So, you know, you can trade off information, in various ways.

373
00:19:15,800 --> 00:19:18,600
That's again, getting into sort of the minutiae compression, which I

374
00:19:18,600 --> 00:19:21,900
wasn't sort of going to try to do, but I just want to point that out.

375
00:19:21,900 --> 00:19:25,100
So, if you feel comfortable coding, this, you probably feel Comfort

376
00:19:25,100 --> 00:19:25,400
coding.

377
00:19:25,400 --> 00:19:26,600
This, I mean, how simple is this?

378
00:19:26,600 --> 00:19:29,000
You compressor I just read a number, right?

379
00:19:29,400 --> 00:19:32,100
I then copy that number of bytes, then I

380
00:19:32,200 --> 00:19:34,500
I read a number and a second number.

381
00:19:34,700 --> 00:19:38,300
I use the second number to figure out how many bytes to go backwards

382
00:19:38,300 --> 00:19:38,700
for Mike.

383
00:19:38,700 --> 00:19:41,900
I just look my pointer backwards that many bytes and then I copy them

384
00:19:41,900 --> 00:19:44,500
this many bytes to the input stream, right?

385
00:19:45,300 --> 00:19:49,900
Okay, so again, hopefully anyone watching who's at all comfortable

386
00:19:49,900 --> 00:19:52,600
with anything we do in handmade hero is going to be very comfortable

387
00:19:52,600 --> 00:19:53,000
with that.

388
00:19:53,000 --> 00:19:54,600
Because I mean, how simple is that?

389
00:19:54,600 --> 00:19:54,900
Right?

390
00:19:54,900 --> 00:19:56,000
Very, very simple.

391
00:19:56,100 --> 00:19:59,800
It's certainly only the tiniest bit different than this.

392
00:20:00,600 --> 00:20:02,000
So it's just it's very very

393
00:20:02,300 --> 00:20:05,500
Like to write an LZ decode decoder in that sense, right?

394
00:20:06,300 --> 00:20:06,600
So,

395
00:20:07,800 --> 00:20:12,100
The thing that I wanted to show you in addition, this was the part

396
00:20:12,100 --> 00:20:14,400
that originally made me want to go say this because I first of all

397
00:20:14,400 --> 00:20:17,700
wanted to say, hey me blow, if you feel comfortable, darlie, you

398
00:20:17,700 --> 00:20:20,800
probably would feel very comfortable this and I think, hopefully, I'm

399
00:20:20,800 --> 00:20:21,200
right.

400
00:20:22,500 --> 00:20:27,000
But here's the really cool part about LZ and I rarely see this sort of

401
00:20:27,000 --> 00:20:31,500
thing mentioned probably because it's so by the time someone becomes a

402
00:20:31,500 --> 00:20:35,600
compression expert, this is so not interesting to them that they

403
00:20:35,600 --> 00:20:37,400
probably don't think it's as cool as like I

404
00:20:37,600 --> 00:20:37,900
It is.

405
00:20:37,900 --> 00:20:41,700
I recently implemented my first actual like compressor that will

406
00:20:41,700 --> 00:20:44,100
probably ship in something, because I never do compression.

407
00:20:44,100 --> 00:20:47,300
But for, for 1935, for the game that I'm working on.

408
00:20:47,300 --> 00:20:50,500
Now, I did my own compressor because I basically wanted almost, you

409
00:20:50,500 --> 00:20:53,600
know, essentially all the code in the game to be code that I wrote.

410
00:20:53,900 --> 00:20:56,800
And so, I had to write a compressor for it and I kind of had to learn

411
00:20:56,800 --> 00:20:58,700
like roughly how to do some of these things.

412
00:20:58,700 --> 00:20:59,800
And I thought this was just

413
00:21:00,000 --> 00:21:00,600
Cool.

414
00:21:02,100 --> 00:21:06,700
When you have an LZ compressor, based on what I just told you at first

415
00:21:06,700 --> 00:21:09,200
and again, so, you know, I'm assuming that you're like me, those of

416
00:21:09,200 --> 00:21:11,000
you out there compression experts already know this.

417
00:21:11,000 --> 00:21:14,100
But if you're like me and have kind of saw this stuff for the first

418
00:21:14,100 --> 00:21:14,700
time, right?

419
00:21:14,700 --> 00:21:18,400
Going through it, you're like, okay, well, if I come from a gnarly

420
00:21:18,400 --> 00:21:21,700
compressor and I go to LZ compressor that allows me to like exploit

421
00:21:21,700 --> 00:21:26,300
these patterns really cleanly, but I've lost the ability to do.

422
00:21:26,300 --> 00:21:28,900
Big runs of the same thing, right?

423
00:21:31,300 --> 00:21:38,400
Because now, you know, naively you might think well, now if I wanted

424
00:21:38,400 --> 00:21:42,300
to encode a big long run of these bees like this it's like well how do

425
00:21:42,300 --> 00:21:42,700
I do it?

426
00:21:42,700 --> 00:21:48,000
Well, you know, I guess I in code maybe for bees or something or some

427
00:21:48,000 --> 00:21:49,200
reasonable number of them.

428
00:21:49,400 --> 00:21:53,600
And then I encode a replication that says to replicate those for bees

429
00:21:53,800 --> 00:21:58,200
and then you know I encode a replication that says, replicate those

430
00:21:58,200 --> 00:21:59,800
eight bees or something, you know, like,

431
00:22:00,000 --> 00:22:03,400
You build up by doing squared every time like I replicate, I put two

432
00:22:03,400 --> 00:22:03,900
bees in.

433
00:22:03,900 --> 00:22:06,800
I replicate the to bees and I left the Four B's everybody pees, right,

434
00:22:06,800 --> 00:22:10,200
and build it up and it seems like I'm taking a lot more space to

435
00:22:10,200 --> 00:22:10,800
encode.

436
00:22:10,800 --> 00:22:13,700
Just a big long run of like, you know a hundred bees or something like

437
00:22:13,700 --> 00:22:14,100
this.

438
00:22:16,000 --> 00:22:22,900
But the reality is as long as your LZ, decoder is operating sort of in

439
00:22:23,400 --> 00:22:27,000
just in a buffer and you're just kind of writing to the buffer, you

440
00:22:27,000 --> 00:22:29,800
can actually get an orally in coding.

441
00:22:29,900 --> 00:22:32,300
Basically, for free in your LZ encoder.

442
00:22:32,400 --> 00:22:36,200
Because of the fact that there is no reason you can't, replicate

443
00:22:36,200 --> 00:22:38,200
symbols in the middle of the same run.

444
00:22:38,200 --> 00:22:40,400
And let me show you how this works because this is the thing that I

445
00:22:40,400 --> 00:22:41,200
thought was so cool.

446
00:22:41,200 --> 00:22:44,100
I was like, oh wait, I when I realized this I'm kind of like working

447
00:22:44,100 --> 00:22:45,600
on it and I'm like, oh well.

448
00:22:45,800 --> 00:22:47,600
Oh cool, right?

449
00:22:49,600 --> 00:22:52,600
So what happens here is, let's say that I have that exact scenario

450
00:22:52,600 --> 00:22:53,800
that I'm talking about.

451
00:22:54,200 --> 00:22:59,800
So I've got a b c d d, d, d d and it just goes on forever.

452
00:23:00,000 --> 00:23:00,300
Right.

453
00:23:00,300 --> 00:23:02,900
So there's just an Infinity of Dee's that come after this and I want

454
00:23:02,900 --> 00:23:03,800
to encode them all.

455
00:23:04,500 --> 00:23:05,800
How do I do it, right?

456
00:23:06,100 --> 00:23:08,900
And so, like I said, the naive way to do this would be to say, oh

457
00:23:08,900 --> 00:23:13,800
okay, you know, maybe I put out my first literal, you know, and I just

458
00:23:13,800 --> 00:23:16,100
try to get that far in, right?

459
00:23:16,100 --> 00:23:19,000
So I say, like, oh my first one is one, two, three, four, five, six,

460
00:23:19,000 --> 00:23:20,000
seven, right?

461
00:23:20,000 --> 00:23:21,100
So I said, okay, seven.

462
00:23:21,200 --> 00:23:24,800
And then I encode my a,b,c,d DD d, right?

463
00:23:24,900 --> 00:23:26,500
Then I go, we'll all replicate.

464
00:23:26,600 --> 00:23:28,300
I go back for right.

465
00:23:28,300 --> 00:23:29,700
So I say my

466
00:23:29,900 --> 00:23:33,400
Distance to look back is for something like this and then my

467
00:23:33,400 --> 00:23:35,900
replication is for, right?

468
00:23:35,900 --> 00:23:39,900
So I just take this and then that'll output at dddd, right?

469
00:23:40,100 --> 00:23:42,900
And then I saying like Okay the next thing I want to do is replicate

470
00:23:42,900 --> 00:23:43,700
this whole thing.

471
00:23:43,700 --> 00:23:47,300
So I would do like oh my look back is 8 and I want to replicate 8 and

472
00:23:47,300 --> 00:23:50,900
then I've got 16 and then I got right and you can see why I'm saying

473
00:23:50,900 --> 00:23:53,900
that that looks really bad because like, hey, that's so much worse.

474
00:23:53,900 --> 00:23:58,000
The rle version of this would have just said, oh, I've got, you know,

475
00:23:58,000 --> 00:23:59,800
however, many I've got 100 and then

476
00:24:00,000 --> 00:24:03,400
And that's all I would have had to have sent and there's all the D's,

477
00:24:03,400 --> 00:24:03,700
right?

478
00:24:03,700 --> 00:24:09,400
So it looks like this is way worse, but what you have to remember is

479
00:24:09,400 --> 00:24:13,000
that if the decoder is just writing it into a buffer, you can actually

480
00:24:13,000 --> 00:24:14,600
just do the rle part for free.

481
00:24:14,600 --> 00:24:16,400
When I get here, I go.

482
00:24:16,400 --> 00:24:18,600
Oh, I've got all of these deals that come here.

483
00:24:18,900 --> 00:24:24,700
So then all I do is say well, okay, in code for ABCD right now, I want

484
00:24:24,700 --> 00:24:26,100
to replicate this D.

485
00:24:26,400 --> 00:24:29,800
Well, all I have to do is encode the one which basically says,

486
00:24:30,000 --> 00:24:33,000
Look Backwards, one for the start of my run which is here.

487
00:24:33,500 --> 00:24:35,900
And then I just say how many I want, right?

488
00:24:36,000 --> 00:24:39,600
I want you know, 99 more D's right?

489
00:24:39,700 --> 00:24:42,300
And look what happens the decoder goes.

490
00:24:42,300 --> 00:24:45,700
Oh okay take a deep from the input stream right because it's starting

491
00:24:45,700 --> 00:24:48,000
here and it's going to copy and where does it write it?

492
00:24:48,000 --> 00:24:50,700
Well, it writes it right here because that's the output point.

493
00:24:50,800 --> 00:24:56,400
Now it goes forward to try and continue reading the run and it looks

494
00:24:56,400 --> 00:24:59,800
and finds the D that it just wrote like the decoder just wrote

495
00:25:00,000 --> 00:25:03,300
The D, but it's there in the buffer, right?

496
00:25:03,600 --> 00:25:08,000
So then it reads that D and goes, okay, and right, sit here, right?

497
00:25:08,200 --> 00:25:13,800
So essentially, an LZ, decoder can self-replicate what it just wrote,

498
00:25:14,600 --> 00:25:18,300
which means that it is no less efficient really, to encode those rods.

499
00:25:18,300 --> 00:25:21,700
It's a slightly less efficient because like I said, you have to

500
00:25:21,700 --> 00:25:25,800
include encode the look-back potentially, so it might not be quite as

501
00:25:25,800 --> 00:25:29,500
efficient, you know, in terms of 107 the bits, but in terms of

502
00:25:29,900 --> 00:25:30,300
Derrek, Lee.

503
00:25:30,300 --> 00:25:32,200
Speaking, how hard is it to encode a run?

504
00:25:32,500 --> 00:25:36,000
It's actually really hard to really easy to encode a run because it

505
00:25:36,000 --> 00:25:37,300
just self replicates out.

506
00:25:37,300 --> 00:25:42,800
And what's more important is that unlike rle which has to talk about a

507
00:25:42,800 --> 00:25:45,700
specific pattern potentially.

508
00:25:45,700 --> 00:25:50,900
Like, you know, if I wanted to look at my early encoder, well, if I

509
00:25:50,900 --> 00:25:53,800
wanted to encode a run of something more complicated than just one

510
00:25:53,800 --> 00:25:54,300
symbol.

511
00:25:54,400 --> 00:25:58,300
Let's say I wanted to encode biddy, biddy biddy or something like this

512
00:25:58,900 --> 00:25:59,800
I would need an additional

513
00:26:00,000 --> 00:26:01,100
Channel symbol in here.

514
00:26:01,100 --> 00:26:05,300
In addition to the run count, I need how long the sub piece of the Run

515
00:26:05,300 --> 00:26:09,100
was so that the decoder would know how many of these symbols to pick

516
00:26:09,100 --> 00:26:11,000
out and replicate right.

517
00:26:11,100 --> 00:26:16,500
Not so, with LZ with LZ the look-back, count is basically the same as

518
00:26:16,500 --> 00:26:18,400
the duplication count, right?

519
00:26:18,400 --> 00:26:23,300
It's if I wanted to replicate CD many times, I just encode a to here

520
00:26:23,500 --> 00:26:26,800
and then I would have 99 copies of CD because it would write a see

521
00:26:26,800 --> 00:26:27,400
here.

522
00:26:27,500 --> 00:26:29,000
Addy here, right?

523
00:26:29,100 --> 00:26:29,800
It's going because it's like

524
00:26:29,900 --> 00:26:33,300
It's reading from here, it moves to here reads from here and it wrote

525
00:26:33,300 --> 00:26:37,200
here and here then it moves to hear and read C and D again and then it

526
00:26:37,200 --> 00:26:40,400
keeps so it just keeps self-replicating its own pattern and on and on

527
00:26:40,400 --> 00:26:41,300
and on right?

528
00:26:42,300 --> 00:26:46,200
So essentially an LZ, decoder has a run length and coder built into it

529
00:26:46,200 --> 00:26:46,700
for free.

530
00:26:47,500 --> 00:26:50,300
And you know, free is not really probably the correct term here but

531
00:26:50,300 --> 00:26:51,200
almost free.

532
00:26:53,600 --> 00:26:57,500
so that's just a really, really cool aspect of l z and it kind of just

533
00:26:57,500 --> 00:26:59,800
shows why it's such an interesting algorithm to

534
00:27:00,000 --> 00:27:02,600
it's got so much versatility there because not only

535
00:27:04,200 --> 00:27:05,000
Can it do that?

536
00:27:05,000 --> 00:27:10,900
Nice grabbing patterns that I've seen before but it can also go ahead

537
00:27:10,900 --> 00:27:14,200
and duplicate just like a gnarly is in big long runs.

538
00:27:14,300 --> 00:27:15,400
What's more is that?

539
00:27:15,400 --> 00:27:19,200
It only takes two steps to do, a duplication from anywhere in the

540
00:27:19,200 --> 00:27:19,500
street.

541
00:27:19,500 --> 00:27:22,700
Because if you think about it, what was the requirement for me being

542
00:27:22,700 --> 00:27:23,700
able to dupe here?

543
00:27:23,900 --> 00:27:28,400
Well, the requirement for me being able to do peer was that I am able

544
00:27:28,400 --> 00:27:31,900
to put the piece, the thing I want to do at the end of the stream,

545
00:27:31,900 --> 00:27:32,500
right?

546
00:27:32,600 --> 00:27:33,600
Because it needs to be able

547
00:27:33,700 --> 00:27:36,000
BCD, right?

548
00:27:36,000 --> 00:27:39,700
And if I want to do is like C&D, C&D, C&D, right?

549
00:27:39,900 --> 00:27:43,600
Well, if I wanted to do this duplication, the requirement is just that

550
00:27:43,600 --> 00:27:44,700
I have to send it.

551
00:27:44,800 --> 00:27:47,900
And then the last thing in the buffer, right?

552
00:27:48,100 --> 00:27:51,100
Has to be the thing that I want to do because I'm going to encode a

553
00:27:51,100 --> 00:27:52,300
look back, right?

554
00:27:52,400 --> 00:27:55,200
And then I'm going to encode, the duplication count, whatever it is,

555
00:27:55,700 --> 00:27:59,800
and it's going to replicate replicate replicate, I couldn't encode a

556
00:27:59,800 --> 00:28:00,200
bigger.

557
00:28:00,200 --> 00:28:01,000
Look back.

558
00:28:01,000 --> 00:28:03,100
Like if I encoded for here

559
00:28:03,600 --> 00:28:06,200
because I wanted to replicate a be like, you know, I'm just doing an

560
00:28:06,200 --> 00:28:06,600
example.

561
00:28:06,600 --> 00:28:10,600
Let's say it's a b, c, d, A.B, A.B A.B.

562
00:28:11,300 --> 00:28:13,800
I couldn't do this one and the reason that I couldn't do this one is

563
00:28:13,800 --> 00:28:18,300
because if I looked back to hear, you know, and I'm right here, if I

564
00:28:18,300 --> 00:28:22,600
look back to here and start copying, I'm going to have to copy the CD.

565
00:28:22,800 --> 00:28:23,400
So it's going.

566
00:28:23,400 --> 00:28:26,800
Because if if you know, if I say 99 and I look back is for it's going

567
00:28:26,800 --> 00:28:29,400
to go like ABCD when it reads the a be.

568
00:28:29,400 --> 00:28:30,800
Yeah, it'll put the a be here.

569
00:28:30,800 --> 00:28:33,500
It'll write the, a low right to be but then it'll write a see in a

570
00:28:33,700 --> 00:28:37,200
In the here before it gets to the, a be again, right?

571
00:28:37,200 --> 00:28:38,500
So, I'll end up with ABCD.

572
00:28:38,500 --> 00:28:44,100
ABCD ABCD so the LZ can can can wrap that last thing in the buffer,

573
00:28:44,100 --> 00:28:50,400
but it can't rep an arbitrary, pull out, but with two steps it can

574
00:28:50,500 --> 00:28:54,300
because obviously any point in l z if I've got some big wrong run

575
00:28:54,300 --> 00:28:55,300
here, let's say,

576
00:28:57,100 --> 00:28:59,800
Let's say this is the thing that I want to do it.

577
00:28:59,800 --> 00:29:01,400
This is going to replicate many many times.

578
00:29:01,400 --> 00:29:04,200
I've got abcdefgh is a big long string, you know.

579
00:29:04,200 --> 00:29:08,800
However, long it is and then I've got, you know, ijk or oops.

580
00:29:08,900 --> 00:29:10,400
I J K here.

581
00:29:10,600 --> 00:29:18,300
And then I've got the dupe, abcdefgh, abcdefgh, dot, dot, dot, dot

582
00:29:18,300 --> 00:29:19,600
dot, audit on, and on and on.

583
00:29:20,300 --> 00:29:23,700
So I encode this big long thing as a literal and then I get to hear

584
00:29:23,700 --> 00:29:26,800
and I'm like, oh, I want to do it like an infinite dupe base.

585
00:29:26,900 --> 00:29:27,600
Do you like many?

586
00:29:27,600 --> 00:29:30,300
Maybe this replicates many 99 times like the other one.

587
00:29:30,300 --> 00:29:31,700
What are does or whatever?

588
00:29:33,100 --> 00:29:33,900
Or a hundred times.

589
00:29:34,600 --> 00:29:38,000
I want to sort of grab this part, and I want to replicate it, but I

590
00:29:38,000 --> 00:29:39,700
can't do that because not the end of the buffer.

591
00:29:39,700 --> 00:29:40,400
Well, that's okay.

592
00:29:40,400 --> 00:29:42,300
It only takes me two steps, right?

593
00:29:42,300 --> 00:29:44,000
I just encode the look back here.

594
00:29:44,000 --> 00:29:47,200
One, two, three, four, five, six, seven, eight, nine, ten, eleven,

595
00:29:47,200 --> 00:29:47,700
right?

596
00:29:47,700 --> 00:29:49,500
So I say, oh, the look back is 11.

597
00:29:49,600 --> 00:29:52,900
And then I say one, two, three, four, five, six, seven eight is, is

598
00:29:52,900 --> 00:29:54,800
the thing to copy, right?

599
00:29:56,400 --> 00:29:58,200
So I go ahead and put that forward.

600
00:30:01,300 --> 00:30:05,200
That will write the first one in and then I just encode immediately

601
00:30:05,200 --> 00:30:06,100
after that.

602
00:30:06,100 --> 00:30:08,500
That my look back is just another eight.

603
00:30:08,500 --> 00:30:11,300
And then my replication count, which is 8 times 100.

604
00:30:11,300 --> 00:30:12,300
However, many I wanted their.

605
00:30:12,300 --> 00:30:14,600
It's 800 or something like that right now.

606
00:30:14,600 --> 00:30:15,800
Granted that's greater than 255.

607
00:30:15,800 --> 00:30:19,400
So I'd probably do this in pieces but you can see how I can just move

608
00:30:19,400 --> 00:30:20,000
it to the end.

609
00:30:20,100 --> 00:30:22,600
And by the way, guess I should, I kind of miss poker when I said the

610
00:30:22,600 --> 00:30:23,800
replication are 99.

611
00:30:24,200 --> 00:30:26,200
What I really mean is 99 times to, right?

612
00:30:26,200 --> 00:30:29,700
I mean times the the length of the thing that I'm replicating, right?

613
00:30:29,700 --> 00:30:30,000
So that

614
00:30:30,100 --> 00:30:33,900
That was just a, that was a typo there or a mental slip.

615
00:30:34,900 --> 00:30:37,800
So hopefully, you can kind of see how it's really very versatile

616
00:30:37,800 --> 00:30:40,000
because the encoder can do lots of things, right?

617
00:30:40,000 --> 00:30:44,000
The encoder can encode just chunks that it wants to replicate, but it

618
00:30:44,000 --> 00:30:47,200
can also move chunks to the front and then dupe them or just dupe.

619
00:30:47,200 --> 00:30:52,300
The last thing that it's saw for the entire size of the rep count it

620
00:30:52,300 --> 00:30:53,500
can do, right?

621
00:30:54,400 --> 00:30:57,600
So it kind of gets you just a lot of Versatility there and that's one

622
00:30:57,600 --> 00:31:00,000
of the reasons why l z is such a popular.

623
00:31:00,100 --> 00:31:05,000
Awesome because it's very very versatile and gets you know gets a lot

624
00:31:05,000 --> 00:31:05,900
of bang for the buck there.

625
00:31:08,800 --> 00:31:12,900
Again, if you assume you're sending see a lot of signal.

626
00:31:13,500 --> 00:31:16,600
If you assume that the information you're dealing with, has a lot of

627
00:31:16,600 --> 00:31:22,000
self-replication or ceph self regularity to it, which again, is

628
00:31:22,000 --> 00:31:25,200
generally true of the sorts of things that humans tend to do.

629
00:31:25,200 --> 00:31:29,100
Like we tend to have a lot of regularity in our information, hence l z

630
00:31:29,100 --> 00:31:30,000
works very well.

631
00:31:30,000 --> 00:31:33,800
If we were a species, whose information typically included a lot of

632
00:31:33,800 --> 00:31:37,200
white noise, this would be useless because

633
00:31:37,300 --> 00:31:41,000
Data would look all completely random and there wouldn't be pieces

634
00:31:41,000 --> 00:31:44,100
that you want to copy and the kinds of techniques we would use to

635
00:31:44,100 --> 00:31:44,500
compress.

636
00:31:44,500 --> 00:31:47,300
Things like white noise would be very different, right?

637
00:31:48,900 --> 00:31:53,400
It wouldn't be this kind of thing where our information we tend to

638
00:31:53,700 --> 00:31:54,600
Value information.

639
00:31:54,600 --> 00:31:55,400
That's highly ordered.

640
00:31:55,400 --> 00:31:58,200
That's the kind of information that humans traffic in probably for

641
00:31:58,200 --> 00:32:03,900
good reasons, but I won't try to suss out any philosophical

642
00:32:03,900 --> 00:32:04,800
underpinnings there.

643
00:32:05,000 --> 00:32:09,000
I'll simply say that, you know it we tend to have how you order data

644
00:32:09,000 --> 00:32:13,100
and so things that can exploit the order in the data like that tend to

645
00:32:13,100 --> 00:32:15,300
be very useful for human style information.

646
00:32:15,500 --> 00:32:18,500
And that is exactly what we care about when we are doing compression.

647
00:32:19,100 --> 00:32:22,200
For things like games that are made up entirely of human created

648
00:32:22,200 --> 00:32:25,000
assets, you know, there you go.

649
00:32:25,400 --> 00:32:30,800
So that's LZ now, if you want to write an LCD compressor, hopefully,

650
00:32:30,800 --> 00:32:33,900
it's just immediately obvious how to do so, from what I've just said,

651
00:32:33,900 --> 00:32:34,100
right?

652
00:32:34,100 --> 00:32:35,400
There's no mystery to it.

653
00:32:35,400 --> 00:32:39,600
It's literally like read a number of bytes to Output output.

654
00:32:39,600 --> 00:32:43,800
Those bytes read a number of bytes to replicate plus a number that

655
00:32:43,800 --> 00:32:46,700
tells you where to look back into the stream and do the replication.

656
00:32:46,900 --> 00:32:48,500
Now, one of the things that I baked into here,

657
00:32:48,700 --> 00:32:51,500
That I didn't really mention is well, why is it encoded that way

658
00:32:52,100 --> 00:32:54,300
because you couldn't coat it in a lot of different ways, right?

659
00:32:55,600 --> 00:32:59,800
And the reason that typically elzy schemes tend to be about looking

660
00:33:00,000 --> 00:33:02,700
From where you are is because most of the time.

661
00:33:02,700 --> 00:33:06,300
Again, this is sort of like a prejudgment, right?

662
00:33:06,300 --> 00:33:10,100
If you will, you know, I hate to use the term Prejudice because that

663
00:33:10,100 --> 00:33:13,100
sounds - we're not really trying to be negative about it.

664
00:33:13,100 --> 00:33:14,900
It's just that's what it tends to be.

665
00:33:14,900 --> 00:33:19,900
It's a, it's a premade sort of idea about how this data is going to

666
00:33:19,900 --> 00:33:20,300
look that.

667
00:33:20,300 --> 00:33:22,000
We don't really know that it's going to be true.

668
00:33:22,000 --> 00:33:26,300
But most of the time we hope that it is, we're going to pre say that

669
00:33:26,300 --> 00:33:29,800
we expect most of the time when we see patterns,

670
00:33:30,000 --> 00:33:33,200
Those patterns are more localized than globalized.

671
00:33:33,200 --> 00:33:37,400
So, if I have some very long message, you know, and I've got, you

672
00:33:37,400 --> 00:33:39,600
know, maybe this is a novel or something.

673
00:33:40,300 --> 00:33:43,800
And I've got all these pages of my novel, right, you know, and here's

674
00:33:43,800 --> 00:33:46,000
page, 1 and page 2 and page 3, and Page 4.

675
00:33:46,000 --> 00:33:49,700
And then I'm up to page like 927 because, you know, maybe this is by

676
00:33:49,700 --> 00:33:51,300
missioner, so it's really, really long.

677
00:33:53,600 --> 00:33:54,800
And it just goes on forever.

678
00:33:56,600 --> 00:33:59,800
Well you know you could imagine I'm trying to encode these things.

679
00:33:59,800 --> 00:34:02,500
Again, remember everything that you encode has a cost.

680
00:34:02,500 --> 00:34:07,400
If I want to encode the distance to look back for example or what, you

681
00:34:07,400 --> 00:34:08,199
know, where I'm going.

682
00:34:08,199 --> 00:34:11,400
The let's let's make it more generic if I'm going to encode the

683
00:34:11,400 --> 00:34:16,600
location of the data that I'm trying to grab with some number of bits.

684
00:34:16,600 --> 00:34:20,699
Well, however, many bits, I choose is going to affect how good of a

685
00:34:20,699 --> 00:34:21,600
compression I get.

686
00:34:21,699 --> 00:34:23,000
Get in various ways.

687
00:34:23,000 --> 00:34:27,400
If I say that I'm going to use 8 Bits to encode, where to look, well,

688
00:34:27,400 --> 00:34:31,600
that means that I can only specify 255 different positions to look in,

689
00:34:31,699 --> 00:34:32,199
right?

690
00:34:33,400 --> 00:34:37,000
If I said that, I was going to use 32 bits will, now I can do four

691
00:34:37,000 --> 00:34:42,600
gigabytes worth of location but every time I encode one it's four

692
00:34:42,600 --> 00:34:46,600
times larger than this to encode that position, right?

693
00:34:46,800 --> 00:34:51,300
So I'm losing compression by gaining the ability to perhaps get some

694
00:34:51,300 --> 00:34:51,600
work in.

695
00:34:51,800 --> 00:34:53,800
Action by being more specific about where to look.

696
00:34:53,800 --> 00:34:57,600
So there's this kind of trade-off there about how many bits I'm using,

697
00:34:58,200 --> 00:34:58,800
right?

698
00:34:59,500 --> 00:35:01,400
This gets a little bit more complicated.

699
00:35:01,400 --> 00:35:03,500
When you talk about back ends, right?

700
00:35:03,500 --> 00:35:07,300
And entropy encoding and I'll kind of leave that.

701
00:35:07,300 --> 00:35:09,800
I'll say a final word about that, if I remember afterwards.

702
00:35:09,800 --> 00:35:13,300
But so, you kind of do you have to remember that in a lot of encoders?

703
00:35:13,300 --> 00:35:16,600
There's a step after l z which is like Huffman encoding arithmetic,

704
00:35:16,600 --> 00:35:20,500
encoding, Rands encoding, these sorts of things that is designed to

705
00:35:20,900 --> 00:35:21,600
more.

706
00:35:21,700 --> 00:35:25,200
Only deal with the bit count, but the point still stands that,

707
00:35:25,200 --> 00:35:27,400
however, many bits you actually use.

708
00:35:28,300 --> 00:35:31,200
It makes a difference, even if you're using one of those back ends

709
00:35:31,400 --> 00:35:35,900
because it's the all those back ends do for lack of a better term, is

710
00:35:35,900 --> 00:35:40,500
they make it so that you're only paying for B you actually use and not

711
00:35:40,500 --> 00:35:41,300
for B you don't use.

712
00:35:41,300 --> 00:35:44,300
So for example this 32-bits it may be that the high for bits are very

713
00:35:44,300 --> 00:35:48,300
rarely used, you know, once in a while they are but very rarely

714
00:35:48,600 --> 00:35:51,600
instead of paying for them, every time you pay

715
00:35:51,700 --> 00:35:53,800
Channel to how often you use them, right?

716
00:35:54,000 --> 00:35:57,800
That is what those other sort of back ends, help you do so.

717
00:35:57,900 --> 00:35:59,800
It's not, it's not.

718
00:36:00,000 --> 00:36:03,800
Clean as saying it's four times bigger to like do this encoding or

719
00:36:03,800 --> 00:36:05,700
something like that, there's more to it than that.

720
00:36:05,700 --> 00:36:06,200
So I was going to.

721
00:36:06,200 --> 00:36:10,200
But for purposes of thinking about it, it's not really that different

722
00:36:10,200 --> 00:36:11,000
than saying this.

723
00:36:11,100 --> 00:36:13,800
Let's assume that you're actually using the B you're allocating.

724
00:36:13,800 --> 00:36:15,500
It is four times bigger, right?

725
00:36:16,500 --> 00:36:16,900
Okay.

726
00:36:17,900 --> 00:36:19,900
So this has a cost there.

727
00:36:20,000 --> 00:36:25,100
So it has a cost to say that I'm going to allow my compressor to

728
00:36:25,100 --> 00:36:29,000
encode the signal in a way or the information rather by reaching

729
00:36:29,000 --> 00:36:29,700
further.

730
00:36:30,100 --> 00:36:34,500
In back or by you know, picking a particular position in the Stream.

731
00:36:34,500 --> 00:36:38,200
So if we were to say that we're going to use 32 bits, it might be fine

732
00:36:38,200 --> 00:36:41,300
to use an absolute position like we could just start at the beginning

733
00:36:41,300 --> 00:36:44,100
and say, where the thing was that we're replicating, right?

734
00:36:44,500 --> 00:36:48,900
But that would require that we have enough bits to, you know, sort of

735
00:36:48,900 --> 00:36:51,600
Encompass the whole message because otherwise, when we start getting

736
00:36:51,700 --> 00:36:54,300
eventually, we'd only have the first few pages, right?

737
00:36:55,200 --> 00:36:57,800
So let's say that's what we did and we said eight bits.

738
00:36:57,900 --> 00:36:59,300
Well, eight bits is only going to get us.

739
00:36:59,300 --> 00:37:00,900
Maybe the first page of our novel.

740
00:37:01,100 --> 00:37:04,300
That would mean that if it was an absolute encoding scheme, right?

741
00:37:04,300 --> 00:37:07,300
Where we just said, we start at the first character of the entire

742
00:37:07,300 --> 00:37:11,000
stream we've done and we just go to and 5205 bites into it.

743
00:37:11,100 --> 00:37:12,700
That's only like the first page of our novel.

744
00:37:12,700 --> 00:37:16,000
It means that the only signal we can reference to duplicate the only

745
00:37:16,000 --> 00:37:16,800
pieces of information.

746
00:37:16,800 --> 00:37:19,500
We can duplicate are from that first page.

747
00:37:19,700 --> 00:37:23,700
Well, if all of the words that we tend to use frequently all occurred

748
00:37:23,700 --> 00:37:24,800
on the first page, great.

749
00:37:25,300 --> 00:37:27,000
But what's the chances of that?

750
00:37:27,000 --> 00:37:30,300
Probably, there are new characters who were introduced into the thing,

751
00:37:30,300 --> 00:37:31,800
new location names.

752
00:37:31,800 --> 00:37:35,000
New, manners of speaking depending on which chapter maybe some said

753
00:37:35,000 --> 00:37:38,300
first-person sums in third person, you know how a novel is right?

754
00:37:39,100 --> 00:37:41,300
So it doesn't make a lot of sense to encode.

755
00:37:41,300 --> 00:37:43,700
The nine hundred and twenty seventh page of our book.

756
00:37:43,800 --> 00:37:47,300
Using the same information is encoded the first page of our book.

757
00:37:47,800 --> 00:37:51,900
And that's why encoders like this tend to use relative positioning

758
00:37:52,100 --> 00:37:54,800
because the chances of finding a match for what we're

759
00:37:54,900 --> 00:38:00,400
Where we're at right now tend to be much higher if we're talking about

760
00:38:00,400 --> 00:38:05,600
the most recently seen 255 characters, rather than talking about the

761
00:38:05,600 --> 00:38:09,100
very first 255 characters that we may have encountered.

762
00:38:09,700 --> 00:38:12,600
So that's why typically no matter how many bits you tend to allocate

763
00:38:12,600 --> 00:38:16,100
an LZ scheme, you oftentimes want to make them relative to the output

764
00:38:16,100 --> 00:38:19,800
position because that allows you to more likely capture the

765
00:38:19,800 --> 00:38:20,900
information, that's going to replicate it.

766
00:38:20,900 --> 00:38:24,800
Because again, one of the assumptions that we make about this,

767
00:38:25,000 --> 00:38:28,500
Data that we're trying to compress based on just the way humans, tend

768
00:38:28,500 --> 00:38:31,100
to do it in the kinds of things that we tend to value.

769
00:38:31,100 --> 00:38:33,800
In terms of information, the types of things we tend to produce.

770
00:38:34,200 --> 00:38:38,900
Usually when we say something or do something or make a color in a

771
00:38:38,900 --> 00:38:44,100
picture, the things nearby tend to be more similar than the things

772
00:38:44,100 --> 00:38:45,200
further apart.

773
00:38:45,400 --> 00:38:47,000
It doesn't have to be true.

774
00:38:47,200 --> 00:38:51,000
And that's why you could always construct things, where it would have

775
00:38:51,000 --> 00:38:53,300
been better if you did it the other way.

776
00:38:54,200 --> 00:38:59,800
But for the most part, it tends to be this way, right?

777
00:39:00,000 --> 00:39:01,000
Hopefully, that makes some sense.

778
00:39:04,100 --> 00:39:04,600
Okay.

779
00:39:07,200 --> 00:39:10,700
So, I'll say two more things about this LZ encoding.

780
00:39:14,300 --> 00:39:17,200
So LZ decoder, like I said super simple, right?

781
00:39:17,200 --> 00:39:20,100
It's just a question of coming up with exactly how you want those

782
00:39:20,100 --> 00:39:20,700
bytes to work.

783
00:39:20,700 --> 00:39:23,400
But you know if you just want to do it for as a programming, exercise,

784
00:39:23,400 --> 00:39:25,100
you don't maybe have to worry so much about.

785
00:39:25,100 --> 00:39:26,200
Are you getting good compression?

786
00:39:26,400 --> 00:39:28,300
You can just sort of think about is let me just make something that

787
00:39:28,300 --> 00:39:30,800
works and like I said we've talked about a very simple scheme that

788
00:39:30,800 --> 00:39:31,400
could work.

789
00:39:31,500 --> 00:39:34,600
Read a number of bytes to new bytes that are going to come in the

790
00:39:34,600 --> 00:39:35,100
Stream.

791
00:39:35,100 --> 00:39:39,300
So you write the number new B, then the B and then you just write a

792
00:39:39,700 --> 00:39:42,900
number of bytes you want to copy and the look-back amount, right?

793
00:39:43,400 --> 00:39:44,900
And then one more number you.

794
00:39:44,900 --> 00:39:46,100
Go back meeting one more number.

795
00:39:46,100 --> 00:39:47,500
That's how many B Nu B are coming.

796
00:39:47,500 --> 00:39:48,300
The new B, right?

797
00:39:48,300 --> 00:39:49,100
And just go on forever.

798
00:39:49,100 --> 00:39:50,800
It's exactly like a gnarly encoder.

799
00:39:52,600 --> 00:39:54,100
But now it's an LZ encoder.

800
00:39:54,500 --> 00:39:56,500
I'm sorry decoder at that point, right?

801
00:39:56,500 --> 00:39:57,600
Very, very, very simple.

802
00:39:57,600 --> 00:40:00,800
Hopefully everyone who's watching would feel very comfortable doing

803
00:40:00,800 --> 00:40:02,300
that if you made it this far, and handmade hero.

804
00:40:02,300 --> 00:40:05,900
This is that's not very hard at all right.

805
00:40:07,300 --> 00:40:09,300
Well, LZ encoding.

806
00:40:09,300 --> 00:40:13,000
On the other hand, it's a little bit harder and, you know, even just

807
00:40:13,000 --> 00:40:15,900
to do, even a basic one, is a little bit harder than something like a

808
00:40:15,900 --> 00:40:18,200
gnarly encoder, which is very straightforward.

809
00:40:18,300 --> 00:40:21,200
A gnarly encoder, basically, just involves looking ahead, a few

810
00:40:21,400 --> 00:40:23,300
symbols, to CMI replicating.

811
00:40:23,300 --> 00:40:25,700
Something, if I am and code it that way, otherwise don't, that's

812
00:40:25,700 --> 00:40:27,700
really all you have to do for an early encoder, right?

813
00:40:27,900 --> 00:40:32,100
If I just want something that captures this idea, right?

814
00:40:35,400 --> 00:40:36,900
The only thing they are really encoder.

815
00:40:36,900 --> 00:40:37,900
The basic kind of Arlene.

816
00:40:37,900 --> 00:40:41,000
Cutter can do is just just capture this run, thats all it can do.

817
00:40:41,200 --> 00:40:44,500
So all you do is you just look ahead one symbol at a time and say is

818
00:40:44,500 --> 00:40:46,000
it the same as the symbol I'm on?

819
00:40:46,200 --> 00:40:48,900
If it's not I just keep stacking up my literals.

820
00:40:49,000 --> 00:40:52,600
If it is the same then I just keep a little count of how many there

821
00:40:52,600 --> 00:40:55,100
are when I get to the end of that when I see the first differing

822
00:40:55,100 --> 00:40:57,100
symbol, which would be here, right?

823
00:40:57,100 --> 00:40:57,400
I go.

824
00:40:57,400 --> 00:40:58,300
How many did I have?

825
00:40:58,300 --> 00:40:58,900
I've got five.

826
00:40:58,900 --> 00:41:00,900
Okay, encoder run five in the number, right?

827
00:41:00,900 --> 00:41:02,100
So the encoder is very easy.

828
00:41:02,100 --> 00:41:03,400
It's just all it is is just

829
00:41:03,600 --> 00:41:07,800
Looking ahead, a few symbols to see how long any individual run is.

830
00:41:07,900 --> 00:41:09,400
And when you see it, you out, put it, right?

831
00:41:09,400 --> 00:41:11,100
So very, very simple encoder.

832
00:41:11,100 --> 00:41:12,300
Not a lot of decision-making.

833
00:41:12,300 --> 00:41:15,300
They have there are places you could imagine making some decisions

834
00:41:15,300 --> 00:41:17,300
about that but you know, they're very, very simplistic.

835
00:41:17,300 --> 00:41:20,500
It's there's not a lot of complexity there in terms of getting the

836
00:41:20,500 --> 00:41:22,300
compression you would expect to get out of our leaders.

837
00:41:22,300 --> 00:41:27,600
Just did not a lot there but for llz encoding it's more difficult.

838
00:41:27,600 --> 00:41:31,500
The reason it's more difficult is because now you got this whole back

839
00:41:31,500 --> 00:41:33,100
catalog, right?

840
00:41:33,500 --> 00:41:35,700
Let's say we are doing b, b, b base.

841
00:41:35,700 --> 00:41:39,500
So let's say we have a, you know, an 8-bit look back, right?

842
00:41:39,500 --> 00:41:43,400
That's 255 positions in the output stream starting from where I am

843
00:41:43,400 --> 00:41:48,200
right now, that could be selected as a place to copy from.

844
00:41:48,200 --> 00:41:53,200
And now I have to make a decision about those 255 locations, right?

845
00:41:53,200 --> 00:41:54,500
I have to have an opinion.

846
00:41:57,400 --> 00:41:59,600
Which of those two 55 should I encode?

847
00:42:00,000 --> 00:42:02,300
At all because I also could just encode a literal.

848
00:42:02,300 --> 00:42:04,800
I could say here's new B, right?

849
00:42:06,700 --> 00:42:10,900
So, if we think about this, the question is, how do I figure out which

850
00:42:10,900 --> 00:42:11,700
of those to do?

851
00:42:11,700 --> 00:42:14,000
Well, the brute force method, right?

852
00:42:14,200 --> 00:42:16,300
You can think about, it's actually pretty easy.

853
00:42:16,700 --> 00:42:19,900
If I literally wanted to make an incredibly slow LZ encoder, I could

854
00:42:19,900 --> 00:42:24,900
just say, alright, you know, for you know, all 255, right?

855
00:42:24,900 --> 00:42:28,200
I just literally from 0 to 255, right?

856
00:42:29,200 --> 00:42:32,200
For each of those do a like while matches.

857
00:42:34,900 --> 00:42:40,100
You know, run plus plus and keep the best, right?

858
00:42:40,200 --> 00:42:42,200
So you can imagine what this kind of thing does, right?

859
00:42:42,200 --> 00:42:44,300
It's like the brute force method which is very very slow.

860
00:42:44,300 --> 00:42:45,700
It's like all right.

861
00:42:45,700 --> 00:42:49,400
You know I'm here in the input stream, go all the way back to however

862
00:42:49,400 --> 00:42:49,900
far back.

863
00:42:49,900 --> 00:42:50,400
I can go.

864
00:42:50,400 --> 00:42:53,900
If it's 255 symbols is my maximum then go back all the way to there,

865
00:42:54,100 --> 00:42:54,600
right?

866
00:42:54,800 --> 00:42:58,100
Start there and now I know I've got some symbols here, right?

867
00:42:58,100 --> 00:43:02,300
X y z w whatever they are right my new symbols are here and you know

868
00:43:02,300 --> 00:43:04,500
maybe there is an actual run so maybe the

869
00:43:04,700 --> 00:43:06,800
One is c, d, d d, right?

870
00:43:06,800 --> 00:43:09,100
So maybe there is the new symbols that are coming due.

871
00:43:09,100 --> 00:43:10,900
Match something they match right there, right?

872
00:43:12,000 --> 00:43:14,200
All right, so go way back all the way the beginning.

873
00:43:14,500 --> 00:43:16,200
See from this symbol.

874
00:43:16,400 --> 00:43:19,400
How many symbols in the input coming next, do I match?

875
00:43:19,400 --> 00:43:21,000
Well, this is an A, and that's a see.

876
00:43:21,000 --> 00:43:22,600
So none is the answer, right?

877
00:43:22,600 --> 00:43:25,500
Then I, you know, this is this four part of the for I Loop here, I

878
00:43:25,500 --> 00:43:25,800
come.

879
00:43:25,800 --> 00:43:27,500
Now I go to be right.

880
00:43:27,900 --> 00:43:30,000
Be okay, let's see how many matches I get.

881
00:43:30,000 --> 00:43:31,800
This, is this part of the loop here while matches.

882
00:43:32,000 --> 00:43:33,700
Okay, B and C, none.

883
00:43:33,800 --> 00:43:34,100
Right.

884
00:43:34,100 --> 00:43:35,600
So, again, nothing matches.

885
00:43:35,700 --> 00:43:36,200
All right.

886
00:43:36,500 --> 00:43:39,000
I come to the Sea and I say, all right, the see matches.

887
00:43:39,000 --> 00:43:39,700
Oh cool.

888
00:43:40,000 --> 00:43:41,600
Do the you know, increment this

889
00:43:41,800 --> 00:43:43,900
Count I go di di di.

890
00:43:43,900 --> 00:43:44,200
All right.

891
00:43:44,200 --> 00:43:46,800
So I actually got all the way here and maybe this is an e so this

892
00:43:46,800 --> 00:43:47,700
doesn't match.

893
00:43:47,700 --> 00:43:48,800
Oh, so I got a 4.

894
00:43:49,000 --> 00:43:49,900
Well, that's the best run.

895
00:43:49,900 --> 00:43:50,700
I've seen so far.

896
00:43:50,700 --> 00:43:53,800
So save this location as my best run so far.

897
00:43:53,900 --> 00:43:56,500
I keep going, right, I checked this location, right?

898
00:43:56,500 --> 00:43:57,200
I don't start here.

899
00:43:57,200 --> 00:44:00,200
I still check this location because maybe the Run counts or whatever.

900
00:44:00,200 --> 00:44:03,800
And again, because this is Brute Force, you could actually know that

901
00:44:03,800 --> 00:44:05,600
that wasn't true by doing some of the things, but this

902
00:44:07,100 --> 00:44:07,800
Beside the point.

903
00:44:09,200 --> 00:44:12,800
So I go through all of these and I do all of that and I find my best

904
00:44:12,800 --> 00:44:14,300
run is for and it's here.

905
00:44:14,300 --> 00:44:15,900
So that's what I encode, right?

906
00:44:18,000 --> 00:44:20,600
So that's a Brute Force, very simple, l z encoder.

907
00:44:20,600 --> 00:44:23,100
Now you can imagine that this gets pretty bad especially if you

908
00:44:23,100 --> 00:44:26,000
imagine, let's say you wanted to do a 16-bit look back.

909
00:44:26,100 --> 00:44:27,900
Well, now you've got 65535

910
00:44:31,500 --> 00:44:35,000
different positions to look at this becomes, you know, sort of this

911
00:44:35,000 --> 00:44:36,300
very bad N squared thing.

912
00:44:36,300 --> 00:44:38,900
Maybe my run count is 16 bit as well.

913
00:44:39,100 --> 00:44:43,400
Now, I've got this much work to do, potentially to do my checking, you

914
00:44:43,400 --> 00:44:45,700
know, it's not that bad because they won't all match but, you know,

915
00:44:45,800 --> 00:44:46,800
it's pretty bad.

916
00:44:47,100 --> 00:44:49,500
So you can imagine this getting extremely slow.

917
00:44:50,200 --> 00:44:54,100
So typically what people do here instead of this is they try to keep

918
00:44:54,100 --> 00:44:59,800
like a hash table as you the window slides through of like location.

919
00:45:00,400 --> 00:45:03,400
And what the first three symbols of that location.

920
00:45:03,400 --> 00:45:09,000
Let's say our so you do a hash on BCD on d d d and so on and you have

921
00:45:09,000 --> 00:45:13,100
entries into a hash table so that when you CC DD you only look up into

922
00:45:13,100 --> 00:45:17,200
the hash table and you only consider positions that started with CD,

923
00:45:17,500 --> 00:45:18,000
right?

924
00:45:19,400 --> 00:45:21,600
To keep your sort of match checking down.

925
00:45:22,600 --> 00:45:25,400
And typically, the other things you have to do is, you know, you'll

926
00:45:25,400 --> 00:45:27,400
often times get runs of just a bunch of things.

927
00:45:27,400 --> 00:45:29,800
Like, if we have that thing where we've got all these dee dee dee dee

928
00:45:29,800 --> 00:45:31,000
dee dee dee dee dee Dee Dee's.

929
00:45:31,200 --> 00:45:33,900
Well, each one of these is going to Hash right?

930
00:45:33,900 --> 00:45:37,100
Each of these dedede's just going to Hash into the same slot and

931
00:45:37,100 --> 00:45:40,500
you're going to end up with this big old hash Collision, which is not

932
00:45:40,500 --> 00:45:41,600
helping you cut it down at.

933
00:45:41,600 --> 00:45:42,300
All right?

934
00:45:42,600 --> 00:45:45,400
So the other thing you need to do oftentimes is keep sort of

935
00:45:45,400 --> 00:45:47,300
information about overlapping run.

936
00:45:47,300 --> 00:45:49,000
So you're like, okay, I know

937
00:45:49,200 --> 00:45:54,600
This DD D, this 'run and this run, right?

938
00:45:54,700 --> 00:46:00,100
I know that if I started, you know, if I checked this run and I got

939
00:46:00,100 --> 00:46:04,300
into this run somehow, then I don't need to check this run at all

940
00:46:04,700 --> 00:46:08,600
because there's no way that like, you know, once I get once I run like

941
00:46:08,600 --> 00:46:13,600
overlaps, I know that I would have kept going at that point if I could

942
00:46:13,600 --> 00:46:14,500
have and I didn't.

943
00:46:14,500 --> 00:46:17,500
So starting here is not going to help being a surly or whatever,

944
00:46:17,500 --> 00:46:17,700
right.

945
00:46:17,700 --> 00:46:18,700
You can imagine like,

946
00:46:19,200 --> 00:46:23,100
I'm passing a run at that point means that you only needed to check

947
00:46:23,100 --> 00:46:25,400
one of those runs if that makes sense.

948
00:46:25,800 --> 00:46:29,600
So yeah, anyway, I'm not stating that very well.

949
00:46:29,800 --> 00:46:33,300
What I'm trying to say here is, if you got into a run at the same

950
00:46:33,300 --> 00:46:36,300
place from two different locations, you can stop checking the run

951
00:46:36,500 --> 00:46:39,100
because you've already gone as far as you were going to go.

952
00:46:39,100 --> 00:46:41,900
And the other one would have been longer because it started earlier

953
00:46:42,500 --> 00:46:43,500
because I guess what I'm saying?

954
00:46:44,600 --> 00:46:45,700
So yeah, there you go.

955
00:46:47,700 --> 00:46:51,700
All right, so my final note on this is just talking about the entropy

956
00:46:51,700 --> 00:46:53,600
encoding backend situation, right?

957
00:46:54,600 --> 00:47:00,100
LZ is basically a technique that says let me use sort of these

958
00:47:00,300 --> 00:47:05,300
pointers back into, you know, sort of references relative references

959
00:47:05,500 --> 00:47:07,400
back into the data that I've already seen.

960
00:47:07,500 --> 00:47:11,100
As a way of pulling out common things that occur that we've already

961
00:47:11,100 --> 00:47:11,500
seen

962
00:47:15,200 --> 00:47:17,700
So that, you know, very straightforward.

963
00:47:17,700 --> 00:47:19,200
Hopefully you can kind of see how that works.

964
00:47:19,200 --> 00:47:20,300
Now that I've gone over it.

965
00:47:22,500 --> 00:47:28,800
But like I said, a lot of compressors don't just use LZ, it's possible

966
00:47:28,800 --> 00:47:33,000
that just using LZ, is your best bet that can be true.

967
00:47:33,000 --> 00:47:33,400
Right there.

968
00:47:33,400 --> 00:47:37,700
Certainly a class of classes of information, we're just using LZ,

969
00:47:37,700 --> 00:47:39,700
directly is the best thing to do.

970
00:47:40,800 --> 00:47:41,500
And off you go.

971
00:47:42,400 --> 00:47:47,100
But it's also possible that using LZ alone is not as efficient as

972
00:47:47,100 --> 00:47:51,100
using LZ with something called an entropy encoder on the back end.

973
00:47:51,100 --> 00:47:54,400
And what this is, is these are techniques like I was saying before,

974
00:47:54,400 --> 00:47:55,300
like Huffman

975
00:47:57,300 --> 00:47:58,200
Arithmetic.

976
00:48:00,800 --> 00:48:07,000
and our ins, or Tas things like these

977
00:48:09,400 --> 00:48:14,300
And what these are these are techniques that allow you to take a look

978
00:48:15,600 --> 00:48:19,500
at this, the actual information, you're encoding per symbol.

979
00:48:19,800 --> 00:48:22,800
Remember Like These Guys, these symbols here, we've kind of broken it

980
00:48:22,800 --> 00:48:22,900
up.

981
00:48:22,900 --> 00:48:26,300
Maybe that's like b or the symbol or whatever or you know maybe it's

982
00:48:26,300 --> 00:48:30,600
an 8-bit symbol per symbol or 16 bits per symbol.

983
00:48:33,700 --> 00:48:36,600
taking a look at those and saying, okay,

984
00:48:37,900 --> 00:48:39,700
After I do my l z compression.

985
00:48:41,200 --> 00:48:44,400
Maybe my output my result, right?

986
00:48:44,400 --> 00:48:46,700
So my result again, keep in mind.

987
00:48:46,700 --> 00:48:52,600
My result is the the actual encoding of, like, you know, for literals

988
00:48:52,600 --> 00:48:53,800
and here they are.

989
00:48:54,300 --> 00:48:57,700
Then our look back of to, and a rep count of eight, you know, these

990
00:48:57,700 --> 00:48:58,400
sorts of things.

991
00:48:58,400 --> 00:49:03,200
So for ABCD, 28, then some simple, you know, blah, blah, that's my

992
00:49:03,200 --> 00:49:06,500
actual thing that I'm talking about when I say my, my result,

993
00:49:07,300 --> 00:49:08,200
Not the message.

994
00:49:08,200 --> 00:49:12,200
I actually encoded or the information, encoded not that, but it's

995
00:49:12,300 --> 00:49:13,700
compressed representation.

996
00:49:13,700 --> 00:49:18,900
So the post LZ, you know, it's run through the LZ encoder and is now

997
00:49:19,000 --> 00:49:20,400
whatever that bit pattern is.

998
00:49:21,700 --> 00:49:26,600
So after I do that right after I encode my post LZ encoding

999
00:49:28,800 --> 00:49:32,300
Take a look at that and say, well I know that each one of the things

1000
00:49:32,300 --> 00:49:35,300
in here is, you know, 8 Bits, or maybe some are 8 Bits and some are 16

1001
00:49:35,300 --> 00:49:35,900
bits, whatever.

1002
00:49:36,000 --> 00:49:38,800
However, it's broken up, I know that it's broken up into these chunks

1003
00:49:38,800 --> 00:49:39,700
that I understand.

1004
00:49:40,000 --> 00:49:43,800
It's got the literal count and then the literals encoded then it's got

1005
00:49:43,800 --> 00:49:47,900
the rep count and the distance count, you know, I know what it looks

1006
00:49:47,900 --> 00:49:48,200
like.

1007
00:49:48,200 --> 00:49:51,100
And I know there are these chunks and I know how many bits I allocated

1008
00:49:51,100 --> 00:49:56,100
to each one, but here's the thing, it may be that if you look at

1009
00:49:56,100 --> 00:49:58,400
these, they are not using

1010
00:49:58,600 --> 00:50:03,000
All of the bits equally for the same purposes and the same ways,

1011
00:50:03,000 --> 00:50:03,600
right?

1012
00:50:03,800 --> 00:50:08,300
It may be that if I looked at a histogram, let's say, right, so like

1013
00:50:08,300 --> 00:50:09,400
took a chart

1014
00:50:11,300 --> 00:50:15,800
And I said, what's the frequency of seeing a particular value, right?

1015
00:50:15,800 --> 00:50:17,600
And here is all my values, right?

1016
00:50:17,600 --> 00:50:20,000
So remember in 8 Bits, I let's say, I have 8 Bits.

1017
00:50:20,200 --> 00:50:23,100
I could have 255 different values, right?

1018
00:50:23,100 --> 00:50:26,900
And then the frequency is like, okay, how long is the message, right?

1019
00:50:26,900 --> 00:50:31,200
Maybe the message is, is 50 bytes long, right?

1020
00:50:31,400 --> 00:50:34,400
So that means the maximum frequency, I can see it's 50 if I just saw

1021
00:50:34,400 --> 00:50:38,100
the same thing 50 times, if I saw the same value 50 times at the most,

1022
00:50:38,100 --> 00:50:40,000
you could be and I have to 155 values.

1023
00:50:40,000 --> 00:50:40,900
Here is my 0

1024
00:50:41,100 --> 00:50:41,400
Right.

1025
00:50:41,400 --> 00:50:44,100
And here's 255 and here is 128.

1026
00:50:44,100 --> 00:50:46,900
Those are the values that could have been coding in a bite, right?

1027
00:50:47,700 --> 00:50:51,000
Yeah, I could look at this and if it's just flat right?

1028
00:50:51,400 --> 00:50:52,000
Which it can't be.

1029
00:50:52,000 --> 00:50:53,100
Lets you know what?

1030
00:50:53,100 --> 00:50:54,200
I should make this at least more.

1031
00:50:54,200 --> 00:50:57,600
Let's say that it's five, you know, 12 or something.

1032
00:51:00,000 --> 00:51:01,300
Write something like that.

1033
00:51:01,300 --> 00:51:07,400
So right, if every symbol appeared exactly twice, then it would just

1034
00:51:07,400 --> 00:51:08,700
be a flat histogram.

1035
00:51:08,900 --> 00:51:10,100
Looks like this, right?

1036
00:51:10,200 --> 00:51:12,800
Every symbol is equally likely to occur.

1037
00:51:14,400 --> 00:51:18,700
Okay, in that case, l z was great LZ.

1038
00:51:18,700 --> 00:51:19,300
We're done.

1039
00:51:19,700 --> 00:51:20,100
Right?

1040
00:51:20,200 --> 00:51:20,600
It out.

1041
00:51:20,600 --> 00:51:24,300
Put it a stream that has completely uniform, probability, that every

1042
00:51:24,300 --> 00:51:28,400
type of value, in a bite was equally represented

1043
00:51:29,100 --> 00:51:33,400
But what if it's more lumpy to borrow a phrase from Jeff Roberts that

1044
00:51:33,400 --> 00:51:34,500
he used at handmade cond.

1045
00:51:34,500 --> 00:51:40,300
What if it's more lumpy what if 0 for some reason appeared many more

1046
00:51:40,300 --> 00:51:41,700
times than everything else.

1047
00:51:41,900 --> 00:51:46,700
So maybe zero and let's it may be, you know, zero and maybe something

1048
00:51:46,700 --> 00:51:50,400
over here, appeared a couple times, but everything else was like very,

1049
00:51:50,400 --> 00:51:52,900
very low and there were these two spikes.

1050
00:51:53,400 --> 00:51:56,800
So I'm much much more likely to encode a zero for some reason because

1051
00:51:56,800 --> 00:51:57,900
of the nature of the data.

1052
00:51:58,000 --> 00:51:58,600
Let's say

1053
00:51:58,800 --> 00:52:03,000
And I was much more likely to incur, you know, encode a 97 for some

1054
00:52:03,000 --> 00:52:03,500
reason.

1055
00:52:04,800 --> 00:52:05,300
Right.

1056
00:52:06,000 --> 00:52:12,600
Well, now if you think about it, I'm not really using all eight bits.

1057
00:52:12,900 --> 00:52:17,400
Every time I output a bite because I'm much more likely to be talking

1058
00:52:17,400 --> 00:52:22,800
about zero and 97 which would only require, you know, two values.

1059
00:52:22,800 --> 00:52:27,900
So it would only take me one bit to encode a message that was all you

1060
00:52:27,900 --> 00:52:30,300
know, zeros or 97's.

1061
00:52:30,600 --> 00:52:34,400
But I'm writing 8 Bits every time and yeah I do still need

1062
00:52:35,100 --> 00:52:40,500
Eight bits of data because I do occasionally throw in a for and I do

1063
00:52:40,500 --> 00:52:44,800
in Cajun Ali, throwing a 237, right?

1064
00:52:46,200 --> 00:52:49,500
So it's not that I could have actually used one bit, but it's that

1065
00:52:49,500 --> 00:52:51,900
most of the time I could have used one bit.

1066
00:52:51,900 --> 00:52:52,400
Right?

1067
00:52:53,400 --> 00:52:56,100
Well, that's where these entropy encoders come in.

1068
00:52:56,400 --> 00:53:01,700
These entropy encoders are ways of saying, oh, what if, we actually

1069
00:53:01,700 --> 00:53:04,000
just use bits to encode the data.

1070
00:53:04,200 --> 00:53:06,800
And we used a number of bits for each symbol.

1071
00:53:06,800 --> 00:53:10,000
That was proportional to how many times it actually shows up.

1072
00:53:10,400 --> 00:53:11,400
How might we do this?

1073
00:53:11,400 --> 00:53:14,600
Well, let's take a simple example from Huffman because arithmetic and

1074
00:53:14,600 --> 00:53:15,500
Rands are much more.

1075
00:53:15,700 --> 00:53:20,500
Kids understand but they all do the same thing, they just do it to

1076
00:53:20,500 --> 00:53:26,600
better efficacy, Huffman it gets less efficiency, it's takes its

1077
00:53:26,600 --> 00:53:27,100
larger.

1078
00:53:27,500 --> 00:53:32,000
Huffman is the best you can do at a bit granularity but arithmetic and

1079
00:53:32,000 --> 00:53:34,700
Rands allow you to do SUB B granularity.

1080
00:53:34,900 --> 00:53:37,100
So, like arithmetic, and Rands allow you to do stuff.

1081
00:53:37,100 --> 00:53:39,400
Like, use one point five bits to encode things.

1082
00:53:39,400 --> 00:53:39,600
I know.

1083
00:53:39,600 --> 00:53:40,400
It sounds like magic.

1084
00:53:40,400 --> 00:53:41,100
It's not.

1085
00:53:41,500 --> 00:53:43,400
I'd encourage you to read about it, if you care about it.

1086
00:53:43,400 --> 00:53:45,500
But, you know again, that's

1087
00:53:45,600 --> 00:53:48,500
That's, that's why these are a lot more complicated to understand, is

1088
00:53:48,500 --> 00:53:52,200
because it, it seems like a little bit of magic, but something like

1089
00:53:52,200 --> 00:53:53,700
Hoffman's, very easy, to understand.

1090
00:53:53,900 --> 00:53:57,800
Let's say that we wanted to do this exact thing that we talked about.

1091
00:53:57,800 --> 00:53:59,700
I want zero in 97 to be very

1092
00:54:00,000 --> 00:54:00,900
To encode.

1093
00:54:01,700 --> 00:54:04,700
But I want all the rest of the values to take more space because they

1094
00:54:04,700 --> 00:54:06,500
almost never occur, right?

1095
00:54:07,700 --> 00:54:11,100
So all I have to do is say like, all right, let's just say that we

1096
00:54:11,100 --> 00:54:14,900
read the input stream, one bit at a time instead of one bite at a

1097
00:54:14,900 --> 00:54:15,300
time.

1098
00:54:15,500 --> 00:54:18,400
So I'm going to grab a bite of the input stream and I'm literally

1099
00:54:18,400 --> 00:54:19,900
going to go through the bits in it.

1100
00:54:19,900 --> 00:54:22,400
One by one to actually make sense of it.

1101
00:54:23,800 --> 00:54:27,300
Rather than saying I always operate on one bite.

1102
00:54:28,000 --> 00:54:29,000
So what do I do?

1103
00:54:30,300 --> 00:54:32,400
Well, I read the first bit in the input stream.

1104
00:54:32,700 --> 00:54:38,000
Okay, so here's the first bit, here's B 0, and I say well, is it a

1105
00:54:38,000 --> 00:54:41,300
zero or is it a one which one's it going to be right?

1106
00:54:42,100 --> 00:54:45,800
And whichever one is going to be, I'm going to make a decision if it's

1107
00:54:45,800 --> 00:54:51,200
a zero, I'm going to say, oh, okay, if it's a zero, then I know that

1108
00:54:51,200 --> 00:54:56,100
I'm in my high frequency thing, maybe I'm in the, the 512 versus 97

1109
00:54:56,100 --> 00:54:58,000
thing where they're both really highly likely.

1110
00:54:58,300 --> 00:54:59,900
So then when I get,

1111
00:55:00,100 --> 00:55:04,000
You know, and let me, let me draw this maybe a little bit differently.

1112
00:55:04,200 --> 00:55:04,900
We do this way.

1113
00:55:06,500 --> 00:55:11,200
Okay, then I'm a bit one here and I'm a bit one here, right?

1114
00:55:11,500 --> 00:55:15,800
So I read a 0 and then I say, okay, read the next bit, if I'm at a 0

1115
00:55:16,000 --> 00:55:20,600
and whatever that b is right, if that b is 0, I'm going to Output a

1116
00:55:20,600 --> 00:55:21,100
zero.

1117
00:55:21,100 --> 00:55:23,900
If that bit is a 1, I'm going to Output a 97.

1118
00:55:24,000 --> 00:55:24,500
Okay.

1119
00:55:24,800 --> 00:55:30,300
Now, it's taken me exactly two bits, right to encode a zero or a 97.

1120
00:55:31,000 --> 00:55:32,600
If the bit is a 1.

1121
00:55:33,400 --> 00:55:35,900
Then, you know, that first bit was a one

1122
00:55:36,300 --> 00:55:40,200
And I have the rest of my tree and maybe that rest of my tree, if

1123
00:55:40,200 --> 00:55:43,300
these really were uniform probability, the rest of that tree is just

1124
00:55:43,300 --> 00:55:48,800
okay, put 7 B after it or 8 Bits after it to say what the actual value

1125
00:55:48,800 --> 00:55:49,800
was right.

1126
00:55:49,800 --> 00:55:50,500
Does that make sense?

1127
00:55:51,000 --> 00:55:54,900
So basically, you can think about in this is like a muffin style way

1128
00:55:54,900 --> 00:55:55,700
to encode things.

1129
00:55:56,700 --> 00:55:59,400
So, basically, if you think about it, all this is is using bit

1130
00:55:59,400 --> 00:56:04,600
encoding to say, well, you know what, almost always what I encode is

1131
00:56:04,600 --> 00:56:06,100
some is one of these two values.

1132
00:56:06,200 --> 00:56:09,900
Use, let's make it only two bits to encode one of those values and

1133
00:56:09,900 --> 00:56:12,600
then I'll make it so that everything else takes 9.

1134
00:56:12,600 --> 00:56:15,100
B, write a 0 bit.

1135
00:56:15,200 --> 00:56:19,900
I'm sorry, A 1 B, followed by the actual 8 Bits of data.

1136
00:56:20,100 --> 00:56:25,400
But if it's a 0 bit instead, then I'm just shorthand for 097.

1137
00:56:26,200 --> 00:56:30,100
Now, what I've done, if I really did have this scenario where almost

1138
00:56:30,100 --> 00:56:34,600
everything is either a 0 or a 97.

1139
00:56:34,800 --> 00:56:36,100
Now, what I've done is, I've gone

1140
00:56:36,300 --> 00:56:40,900
From a message that used to take 8 bits per cell per symbol.

1141
00:56:40,900 --> 00:56:46,000
So if it was 512 long, it's 512 times one byte per symbol right?

1142
00:56:46,500 --> 00:56:49,300
Or, you know, we'll use b, x 8 bits per symbol.

1143
00:56:49,500 --> 00:56:53,500
So I've gone from a message that took eight times 512, bytes to one.

1144
00:56:53,500 --> 00:56:58,400
I'm 512 bits to 1 that takes 512 times to bits most of the time,

1145
00:56:58,700 --> 00:56:59,100
right?

1146
00:56:59,100 --> 00:56:59,800
Because there's only a couple

1147
00:57:00,000 --> 00:57:02,500
All times when I actually need to encode these other guys.

1148
00:57:02,500 --> 00:57:03,000
Right?

1149
00:57:03,400 --> 00:57:05,100
So at that point it's like hey great.

1150
00:57:05,200 --> 00:57:10,100
This is a 1024-bit message now roughly, whereas this one right here

1151
00:57:10,500 --> 00:57:12,900
was what a 4,096-bit message.

1152
00:57:13,600 --> 00:57:14,700
That's a great savings.

1153
00:57:14,700 --> 00:57:19,200
I've just saved, you know for it it's four times smaller, right?

1154
00:57:21,500 --> 00:57:25,200
So that's all these things do they basically say they basically take a

1155
00:57:25,200 --> 00:57:30,100
histogram of the data, a frequency count of the data and they try to

1156
00:57:30,100 --> 00:57:32,200
allocate the bits of the output.

1157
00:57:32,300 --> 00:57:34,100
So that it matches that histogram.

1158
00:57:34,300 --> 00:57:39,300
And what you can sort of see here to further understand why these

1159
00:57:39,300 --> 00:57:42,000
other two, and there's probably a lot more than he's out.

1160
00:57:42,000 --> 00:57:43,500
Again, I'm not a compression person.

1161
00:57:43,500 --> 00:57:47,800
So I can't tell you all the ways in which you might back in to encode

1162
00:57:47,800 --> 00:57:48,100
something.

1163
00:57:48,100 --> 00:57:50,600
There's certainly probably a lot more than

1164
00:57:50,700 --> 00:57:51,400
Resting here.

1165
00:57:51,400 --> 00:57:56,100
But again, I'm not familiar with with that branch of programming.

1166
00:57:57,400 --> 00:58:00,300
So, if you take a look at these, right, what you see there is, it's

1167
00:58:00,300 --> 00:58:06,000
like, okay, Huffman arithmetic Rands and tans for example, Huffman

1168
00:58:06,200 --> 00:58:09,700
because it looks like one of these, you know, there's tons of ways you

1169
00:58:09,700 --> 00:58:13,700
might organize how your Huffman trees were working and all these other

1170
00:58:13,700 --> 00:58:15,800
sorts of trade-offs, who knows, again, not a compression expert,

1171
00:58:15,800 --> 00:58:17,600
couldn't talk about them intelligently.

1172
00:58:18,800 --> 00:58:21,700
But if you're organizing it on a bit tree here, where you say, like,

1173
00:58:21,700 --> 00:58:23,500
okay, there's a bit, that's a one, or a zero.

1174
00:58:23,500 --> 00:58:26,800
And I go in a direction based on that down the tree and the tree.

1175
00:58:27,000 --> 00:58:32,900
Is designed to be balanced out so that the tree is shortest, where the

1176
00:58:32,900 --> 00:58:36,200
symbols are most frequent and longest, where they're not, that's

1177
00:58:36,200 --> 00:58:40,800
Huffman it has a quantization problem, right?

1178
00:58:41,000 --> 00:58:45,800
It has the problem that whatever these frequencies were, they probably

1179
00:58:45,800 --> 00:58:49,900
weren't binary frequencies because that's what this tree will give me

1180
00:58:50,300 --> 00:58:55,100
a path to a symbol on Huffman is going to be an integer number of

1181
00:58:55,100 --> 00:58:55,600
steps.

1182
00:58:55,700 --> 00:58:56,800
It's two bits.

1183
00:58:56,900 --> 00:58:58,100
It's to get down to here.

1184
00:58:58,100 --> 00:59:00,000
It's two bits to get down to here.

1185
00:59:00,100 --> 00:59:04,100
Whatever, this is down here is 4 bits to get to or whatever, right?

1186
00:59:05,300 --> 00:59:11,200
So I can only encode integer multiple frequencies exactly in my

1187
00:59:11,200 --> 00:59:12,100
Huffman tree.

1188
00:59:12,800 --> 00:59:17,000
So if I actually have something where there's which almost all

1189
00:59:17,000 --> 00:59:20,500
histograms will not fall into that category, most histograms.

1190
00:59:20,500 --> 00:59:24,700
If I say well the total length is 512 and the number of times I saw

1191
00:59:24,700 --> 00:59:26,800
you know this particular symbol is 7.

1192
00:59:27,000 --> 00:59:27,500
Dean.

1193
00:59:27,500 --> 00:59:32,000
Well, that's not going to divide out to anything that approaches an

1194
00:59:32,000 --> 00:59:33,200
integer, right?

1195
00:59:33,200 --> 00:59:37,800
That is not an integer, but that's how many bits I wanted.

1196
00:59:37,800 --> 00:59:40,700
You know, that's how or not, how many bits, that's how, What,

1197
00:59:40,700 --> 00:59:42,500
proportion of the output bits?

1198
00:59:42,500 --> 00:59:45,000
I wanted that symbol to take, right?

1199
00:59:47,000 --> 00:59:51,400
That is not going to be in codable in an integer step tree like this.

1200
00:59:51,700 --> 00:59:56,700
And so what these other techniques do is, they devise more clever way.

1201
00:59:56,900 --> 00:59:59,800
Ways of encoding that.

1202
01:00:00,000 --> 01:00:01,500
Allow you to know.

1203
01:00:01,600 --> 01:00:02,700
Oh, okay.

1204
01:00:03,600 --> 01:00:08,400
I want to produce a fractional number of bits to encode this thing.

1205
01:00:09,300 --> 01:00:13,800
And again, I really am not comfortable enough with the math at this

1206
01:00:13,800 --> 01:00:15,500
point to try and offer an explanation.

1207
01:00:15,700 --> 01:00:18,400
Huffman is very easy for a programmer to understand.

1208
01:00:18,400 --> 01:00:21,200
I would say, who did I just lose?

1209
01:00:21,200 --> 01:00:22,800
I just lost smoothing there.

1210
01:00:23,700 --> 01:00:24,600
That's interesting.

1211
01:00:25,400 --> 01:00:29,300
Is that because there's something else that was like, right when this

1212
01:00:29,500 --> 01:00:33,300
right when it switched this thing came up, I lost smoothing, I wonder

1213
01:00:33,300 --> 01:00:37,000
if that's information for Sergio because he was wondering why he lost

1214
01:00:37,000 --> 01:00:39,300
smoothing and it seems like that's a pretty interesting.

1215
01:00:42,400 --> 01:00:45,400
A Prius and coincidence anyway doesn't matter.

1216
01:00:45,800 --> 01:00:51,000
So point being that that is what these sort of additional techniques

1217
01:00:51,000 --> 01:00:57,800
do and you know basically like arithmetic versus Rands or Tans or

1218
01:00:57,800 --> 01:00:58,300
whatever.

1219
01:00:59,700 --> 01:01:05,700
The reason that people as far as I know Huffman is never what you

1220
01:01:05,700 --> 01:01:08,900
actually want to use in terms of

1221
01:01:11,000 --> 01:01:11,500
Sighs.

1222
01:01:12,500 --> 01:01:13,500
I could be wrong about this.

1223
01:01:14,800 --> 01:01:17,100
so, please take it with a very big grain of salt, because

1224
01:01:19,200 --> 01:01:23,600
I'm not a compression person, but my understanding is that Huffman for

1225
01:01:23,600 --> 01:01:32,800
example is a is like a very inefficient way to store the data compared

1226
01:01:32,800 --> 01:01:34,000
to arithmetic.

1227
01:01:34,000 --> 01:01:34,700
For example.

1228
01:01:35,400 --> 01:01:37,500
It's not like there's a trade-off.

1229
01:01:38,000 --> 01:01:40,900
It's just worse and very inefficient, probably wrong.

1230
01:01:41,100 --> 01:01:45,100
It is inefficient right compared to arithmetic because arithmetic can

1231
01:01:45,100 --> 01:01:46,000
match the histogram.

1232
01:01:46,000 --> 01:01:46,700
Exactly.

1233
01:01:46,900 --> 01:01:48,100
Whereas, Huffman can only

1234
01:01:48,500 --> 01:01:52,100
Approximate it by an integer match of histogram, right?

1235
01:01:53,800 --> 01:01:56,800
So that's my understanding of it is that you would never use a Huffman

1236
01:01:56,800 --> 01:01:58,500
encoder instead of an arithmetic encoder.

1237
01:01:58,500 --> 01:02:01,200
If what you cared about was space, my understanding is arithmetic, is

1238
01:02:01,200 --> 01:02:01,900
always better.

1239
01:02:02,800 --> 01:02:03,700
That's just my understanding.

1240
01:02:03,700 --> 01:02:04,600
I don't know if that's true.

1241
01:02:04,800 --> 01:02:10,100
Meaning, it's not like, oh Huffman works better for these signals and

1242
01:02:10,100 --> 01:02:11,300
arithmetic, works better thesis.

1243
01:02:11,300 --> 01:02:17,500
I thought that arithmetic was always preferable, but arithmetic was a

1244
01:02:17,500 --> 01:02:18,600
lot slower.

1245
01:02:18,600 --> 01:02:22,500
It involves integer divides or crazy table, lookups, and all these

1246
01:02:22,500 --> 01:02:23,100
sorts of things.

1247
01:02:23,500 --> 01:02:28,200
And supposedly, you know, again, the people I know who do compression

1248
01:02:28,200 --> 01:02:31,400
what I gleaned from their discussions on it.

1249
01:02:32,600 --> 01:02:36,300
And again, please take it with a grain of salt or even a cube of salt,

1250
01:02:36,300 --> 01:02:37,000
like, a salt lick.

1251
01:02:37,000 --> 01:02:42,500
The size of the kind of give to a horse is that Huffman encoders are

1252
01:02:42,500 --> 01:02:44,900
encoders, where you're doing them?

1253
01:02:44,900 --> 01:02:46,300
Because it's faster.

1254
01:02:46,500 --> 01:02:49,800
You can Implement them more quickly than you can't arithmetic and

1255
01:02:49,800 --> 01:02:50,100
coders.

1256
01:02:50,100 --> 01:02:52,900
Because arithmetic, encoders, involve things like integer divides.

1257
01:02:53,300 --> 01:02:56,100
Or things like this where as Huffman and coders did not and they can

1258
01:02:56,100 --> 01:02:58,400
be done directly with bit manipulation.

1259
01:02:58,600 --> 01:02:59,600
That's much faster.

1260
01:03:00,100 --> 01:03:04,400
That's my understanding of why you see Huffman and coders because they

1261
01:03:04,400 --> 01:03:09,400
are the very fastest back-end encoders, that still do a reasonable job

1262
01:03:09,800 --> 01:03:15,700
of histogram compression, but if you had unlimited time, you would not

1263
01:03:15,900 --> 01:03:16,200
use.

1264
01:03:16,200 --> 01:03:17,200
This was my understanding.

1265
01:03:17,200 --> 01:03:19,400
There's no sighs wind for it.

1266
01:03:19,400 --> 01:03:24,500
It's always a loss in terms of size or or it's always equivalent to

1267
01:03:24,500 --> 01:03:25,700
arithmetic or worse.

1268
01:03:27,300 --> 01:03:32,900
But these are a nsta ns encoders are like a new thing.

1269
01:03:34,200 --> 01:03:39,700
The ANS thing with something that was I guess invented by or

1270
01:03:39,700 --> 01:03:43,700
discovered recently in terms of the mathematics behind it.

1271
01:03:44,100 --> 01:03:48,500
And I don't know if the the folks at rad were the first people to

1272
01:03:48,600 --> 01:03:51,200
actually figure out why it was useful.

1273
01:03:51,200 --> 01:03:55,800
I think they might have been actually, I think Charles may have been

1274
01:03:55,800 --> 01:03:56,600
the first person I do.

1275
01:03:57,100 --> 01:03:59,700
I don't want to accidentally give credit to the wrong people or

1276
01:03:59,700 --> 01:04:02,800
something like this, but I think that's actually what happened you

1277
01:04:02,800 --> 01:04:03,200
should.

1278
01:04:03,200 --> 01:04:03,600
I don't know.

1279
01:04:03,600 --> 01:04:05,100
Maybe check the history books for this.

1280
01:04:05,100 --> 01:04:08,500
I'm not sure if anyone keeps history books on this, but it turns out

1281
01:04:08,500 --> 01:04:14,000
that by using the mathematics of these a NS things, which I don't

1282
01:04:14,000 --> 01:04:15,200
really understand at this point.

1283
01:04:15,200 --> 01:04:18,300
So I can't give you any kind of insight into how they actually work,

1284
01:04:19,500 --> 01:04:22,600
but you could read Fabi and Fabien posted some articles on it and you

1285
01:04:22,600 --> 01:04:25,000
could read some of his write-ups, if you're interested.

1286
01:04:25,000 --> 01:04:26,500
I don't know if Charles posted probably on his

1287
01:04:26,700 --> 01:04:31,200
Lockheed has posted some too, but basically the way that these things

1288
01:04:31,200 --> 01:04:34,200
work is they get arithmetic compression.

1289
01:04:34,200 --> 01:04:38,400
They get, they get sub, they get fractional bit Precision on the

1290
01:04:38,400 --> 01:04:43,300
histogram just like arithmetic coding, but they can be implemented.

1291
01:04:43,300 --> 01:04:46,900
In ways that gets you significant speed improvements to arithmetic

1292
01:04:46,900 --> 01:04:47,500
encoding.

1293
01:04:48,700 --> 01:04:51,100
And because of that, right?

1294
01:04:52,400 --> 01:04:56,600
You can approach Huffman speed while still getting the

1295
01:04:56,800 --> 01:04:59,000
Smallest possible size for your entropy.

1296
01:05:01,600 --> 01:05:04,300
My understanding is they are still able to win with Huffman.

1297
01:05:04,500 --> 01:05:07,600
So, my understanding is like a Trad, the very fastest codex, they

1298
01:05:07,600 --> 01:05:11,000
have, which are like very close to look a mem copy as how fast they

1299
01:05:11,000 --> 01:05:11,100
are.

1300
01:05:11,100 --> 01:05:16,300
Now is that Huffman is still the one that they use on the very fastest

1301
01:05:16,300 --> 01:05:23,100
codex but unlike just slightly slower they have our ins or Tas and

1302
01:05:23,100 --> 01:05:23,400
coders.

1303
01:05:23,400 --> 01:05:25,400
I'm not sure exactly how they work.

1304
01:05:25,400 --> 01:05:30,200
Like I say that's that's for the experts to know and me to wonder

1305
01:05:30,200 --> 01:05:30,900
about

1306
01:05:31,600 --> 01:05:36,000
the very fastest ones are still Huffman but only slightly slower now

1307
01:05:36,000 --> 01:05:41,100
are these ones that are based on the ANS math and those are like

1308
01:05:41,500 --> 01:05:44,600
extremely fast and get arithmetic size

1309
01:05:46,000 --> 01:05:48,500
Which is kind of crazy if you think about it because a lot of I think

1310
01:05:48,500 --> 01:05:52,600
for a long time people didn't think that was possible until you know,

1311
01:05:52,800 --> 01:05:54,500
some some Saucy gentleman.

1312
01:05:54,500 --> 01:05:58,900
I don't know the specifics, but came up with the ANS stuff and then

1313
01:05:59,400 --> 01:05:59,800
either the red

1314
01:06:00,000 --> 01:06:03,400
Folks are somebody figured out that there was ways to exploit the

1315
01:06:03,400 --> 01:06:11,900
properties of that ANS style, alphabets to to beat arithmetic

1316
01:06:11,900 --> 01:06:12,400
encoding.

1317
01:06:14,000 --> 01:06:15,300
So that's pretty cool, right?

1318
01:06:16,200 --> 01:06:19,100
That's a, yeah, that's just one of those things.

1319
01:06:19,100 --> 01:06:20,400
That's like awesome.

1320
01:06:20,400 --> 01:06:23,300
Like, how did that happen at this point?

1321
01:06:23,300 --> 01:06:25,000
I feel like we're kind of off.

1322
01:06:25,000 --> 01:06:28,700
Like this has been an almost an entirely compression oriented stream,

1323
01:06:28,700 --> 01:06:29,900
so, I don't know at this.

1324
01:06:30,000 --> 01:06:30,200
The point.

1325
01:06:30,200 --> 01:06:32,900
It just seems natural that we should just just do it, right?

1326
01:06:32,900 --> 01:06:35,700
We should just like, keep it going, why stop there?

1327
01:06:36,900 --> 01:06:41,300
So, you know, I mean, let's just say that, you know, we want to do one

1328
01:06:41,300 --> 01:06:41,800
of these, right?

1329
01:06:41,800 --> 01:06:43,000
Let's, let's take a look.

1330
01:06:43,300 --> 01:06:45,500
So right now you can, you can kind of see here.

1331
01:06:45,500 --> 01:06:46,300
We are in

1332
01:06:48,600 --> 01:06:50,300
In our handmade hero director.

1333
01:06:50,300 --> 01:06:52,400
You know, I'll just, I'll just load up some code.

1334
01:06:52,400 --> 01:06:54,700
Well, you know, let me not load up quite cold just yet.

1335
01:06:54,900 --> 01:06:58,500
Let's just take a look at something that I'll just show an example of

1336
01:06:58,500 --> 01:06:59,300
how you might approach.

1337
01:06:59,300 --> 01:07:01,800
So, I think, let's say you just wanted to play around with compression

1338
01:07:01,800 --> 01:07:02,800
little bit, right?

1339
01:07:03,200 --> 01:07:04,700
Like I said, not a compression experts.

1340
01:07:04,700 --> 01:07:07,700
I'm not going to throw out any kind of great wisdom here.

1341
01:07:07,700 --> 01:07:11,200
I'm just just giving you a like, a little tiny foothold, you know,

1342
01:07:11,200 --> 01:07:14,300
here's our, here's our art files and we know that our art files are

1343
01:07:14,300 --> 01:07:14,900
not compressed at.

1344
01:07:14,900 --> 01:07:15,300
All right.

1345
01:07:15,300 --> 01:07:17,300
We know that these are the files that

1346
01:07:17,400 --> 01:07:23,600
Got all we did was just we just dumped B into the file and we didn't

1347
01:07:23,600 --> 01:07:24,300
compress them at all.

1348
01:07:24,300 --> 01:07:26,200
They're just raw data, okay?

1349
01:07:28,000 --> 01:07:29,800
And so here we are in here.

1350
01:07:30,100 --> 01:07:33,400
And maybe the first thing that we're thinking is like, well, you know,

1351
01:07:33,400 --> 01:07:34,900
you should we apply compression?

1352
01:07:34,900 --> 01:07:36,400
What kind of compression should we apply?

1353
01:07:36,900 --> 01:07:40,000
How much would be saved if we did compress our data, you know, we

1354
01:07:40,000 --> 01:07:42,000
don't know, answers to any of this, right?

1355
01:07:44,000 --> 01:07:46,500
Well, one thing we could do is obviously, you know, if we wanted to

1356
01:07:46,500 --> 01:07:49,800
know how much compression we might get out of something like testing

1357
01:07:49,800 --> 01:07:51,500
layer 0 0 dot BMP.

1358
01:07:51,700 --> 01:07:53,900
You know, one thing that we might do is say, well, if we wanted to

1359
01:07:53,900 --> 01:07:57,000
use, lossless compression on it, how

1360
01:07:57,200 --> 01:07:59,700
Small, could it get one very obvious?

1361
01:07:59,700 --> 01:08:00,700
Way to do that, right?

1362
01:08:00,700 --> 01:08:03,200
Is to say, let's use someone's existing compression.

1363
01:08:03,400 --> 01:08:07,800
So let's say, I go and I open this up with a program like gimp for

1364
01:08:07,800 --> 01:08:12,900
example, or which is freely available program that you can download to

1365
01:08:12,900 --> 01:08:15,400
play with with with files, right?

1366
01:08:17,000 --> 01:08:19,800
So, one thing I could do is say, well, alright, let's suppose that I

1367
01:08:19,800 --> 01:08:25,600
just saved the file as a PNG which I know does have compression,

1368
01:08:25,800 --> 01:08:26,100
right?

1369
01:08:26,100 --> 01:08:27,899
And it has lost less compression.

1370
01:08:28,200 --> 01:08:33,000
Let's just save it as a PNG and see what we got.

1371
01:08:36,500 --> 01:08:37,100
So there we go.

1372
01:08:38,300 --> 01:08:41,100
Now I can compare these two file sizes and go.

1373
01:08:41,800 --> 01:08:43,200
Oh look at that.

1374
01:08:43,300 --> 01:08:46,500
Like, wow compression would save me so much space.

1375
01:08:46,800 --> 01:08:48,399
This is right now.

1376
01:08:48,399 --> 01:08:52,899
A 2 megabyte file that we're using in handmade hero, but if we wanted

1377
01:08:52,899 --> 01:08:57,100
to, it would have only been 86 K, right?

1378
01:08:57,399 --> 01:08:58,800
So, a massive difference.

1379
01:08:58,899 --> 01:08:59,399
Okay?

1380
01:08:59,500 --> 01:08:59,800
Now,

1381
01:09:00,300 --> 01:09:04,399
I don't know very much about the PNG format, but I do believe it's

1382
01:09:04,399 --> 01:09:06,899
basically like an LZ with transforms kind of a thing.

1383
01:09:07,700 --> 01:09:12,100
And we just kind of talked about LZ, so it's like, okay, well, what if

1384
01:09:12,100 --> 01:09:15,300
I just compress it directly with an LZ, something that didn't even

1385
01:09:15,300 --> 01:09:15,399
know.

1386
01:09:15,399 --> 01:09:22,700
It was getting an image, but I just wanted, I just wanted it to to

1387
01:09:22,700 --> 01:09:25,399
test just a straightforward LZ style compressor.

1388
01:09:25,399 --> 01:09:29,899
Now, lz7, zippers, one, we use here, use this thing called lzma.

1389
01:09:30,100 --> 01:09:33,700
A which is sort of like a very Advanced LZ.

1390
01:09:33,700 --> 01:09:36,399
Encoder does a bunch of very specific things.

1391
01:09:36,399 --> 01:09:37,600
It's got different back-end.

1392
01:09:38,300 --> 01:09:39,899
I don't even want to go into it.

1393
01:09:39,899 --> 01:09:43,700
It's got a lot of extra stuff but let's see how that does on it and

1394
01:09:43,700 --> 01:09:45,500
that does even better, right?

1395
01:09:45,899 --> 01:09:48,899
7-Zip is actually better than paying a compressing this particular

1396
01:09:48,899 --> 01:09:49,100
file.

1397
01:09:49,100 --> 01:09:51,000
But here you can see like, okay,

1398
01:09:52,800 --> 01:09:57,000
we're not going to replicate 7z or ping necessarily our first time

1399
01:09:57,000 --> 01:09:58,900
out, because we don't know anything about compression and whatever,

1400
01:09:58,900 --> 01:10:00,800
but odds are pretty good.

1401
01:10:00,800 --> 01:10:04,300
That an LZ compressor, something very basic would probably still be

1402
01:10:04,300 --> 01:10:05,200
pretty darn good here.

1403
01:10:05,200 --> 01:10:06,800
Look at how good we can get with these.

1404
01:10:06,800 --> 01:10:10,200
So again one typical thing that you'll do if you're just going to

1405
01:10:10,200 --> 01:10:14,400
start down the compression path of things, right?

1406
01:10:14,400 --> 01:10:19,200
It's say oh well what you know, what could a different compressor jet?

1407
01:10:19,200 --> 01:10:21,800
You know what could what could compress are written by experts.

1408
01:10:21,800 --> 01:10:22,300
What could that?

1409
01:10:22,800 --> 01:10:27,900
Now, I've got a sort of a bound on it, where I know, well, if I just

1410
01:10:27,900 --> 01:10:31,500
reimplemented, if I literally just went and learned how 7-Zip worked

1411
01:10:31,500 --> 01:10:35,200
around on it, that's what I can get if I went and read about PNG, how

1412
01:10:35,200 --> 01:10:36,700
that works is a public forum at?

1413
01:10:36,700 --> 01:10:39,600
I could certainly do that, that's what I might be able to get right,

1414
01:10:40,000 --> 01:10:43,800
so that gives me a good Target to shoot for, you know, and that's

1415
01:10:43,800 --> 01:10:44,900
really handy, right?

1416
01:10:45,000 --> 01:10:48,700
Because otherwise, we might not know, otherwise we might not have

1417
01:10:48,700 --> 01:10:49,500
anything to shoot for.

1418
01:10:49,500 --> 01:10:52,300
We would have no idea if our compressor was any good or not, or

1419
01:10:52,400 --> 01:10:54,100
Or what it's sort of bound.

1420
01:10:54,100 --> 01:10:56,800
You know what to Aspire to, if we wrote a good compressor, that was

1421
01:10:56,800 --> 01:10:57,800
based on 7-Zip.

1422
01:10:58,000 --> 01:11:00,900
There's based on LZ, what would it look like right?

1423
01:11:00,900 --> 01:11:02,700
But this is great because this gives us something to shoot for it.

1424
01:11:02,700 --> 01:11:03,600
Gives us an idea.

1425
01:11:03,700 --> 01:11:05,700
Hey, that's how good it could be.

1426
01:11:05,800 --> 01:11:07,600
Let's let's take a look, right.

1427
01:11:08,800 --> 01:11:12,900
Okay, so let's say that we want to do something along those lines,

1428
01:11:13,000 --> 01:11:13,500
right?

1429
01:11:13,800 --> 01:11:16,700
Let's say that we would like to make something that does a little bit

1430
01:11:16,700 --> 01:11:17,500
of compression there.

1431
01:11:17,500 --> 01:11:24,300
Well, okay, so let me go ahead and open up our project here and I'll

1432
01:11:24,300 --> 01:11:30,100
go ahead and build it and, you know, make sure that we get the build

1433
01:11:30,100 --> 01:11:31,100
loaded here as well.

1434
01:11:31,100 --> 01:11:34,700
There's our build up at and so, you know, we've got our simple

1435
01:11:34,700 --> 01:11:35,800
preprocessor here, right?

1436
01:11:35,800 --> 01:11:37,900
This was like, our little thing that we did.

1437
01:11:37,900 --> 01:11:38,400
That kind of

1438
01:11:38,800 --> 01:11:40,500
It was a little command-line utility could use.

1439
01:11:40,800 --> 01:11:43,300
Let's go ahead and just make another one of those, right?

1440
01:11:43,300 --> 01:11:44,100
So here it is.

1441
01:11:44,100 --> 01:11:46,400
Here's our simple preprocessor thing.

1442
01:11:46,400 --> 01:11:49,200
Let's do our, like simple compressor instead, right?

1443
01:11:49,200 --> 01:11:54,500
And we'll do a little CL here, and we'll say, okay, we'll call the

1444
01:11:54,500 --> 01:11:57,700
simple compressor, and we'll go ahead and Link it the way we were

1445
01:11:57,700 --> 01:11:59,900
doing, and we don't need to run it or anything.

1446
01:12:00,000 --> 01:12:00,200
Here.

1447
01:12:00,200 --> 01:12:01,700
But we've got a simple compressor at that.

1448
01:12:01,700 --> 01:12:03,300
Now, we'll compile right?

1449
01:12:03,700 --> 01:12:05,900
And so if I go ahead and do this build, obviously it's going to give

1450
01:12:05,900 --> 01:12:06,300
us an error.

1451
01:12:06,300 --> 01:12:07,200
It's going to say that simple.

1452
01:12:07,200 --> 01:12:09,900
Compressor is not found in, there's a very good reason for that.

1453
01:12:09,900 --> 01:12:11,300
We didn't actually make it yet, right?

1454
01:12:11,700 --> 01:12:14,100
But I can go ahead and let me just copy the simple preprocessor in

1455
01:12:14,100 --> 01:12:15,600
here and call it simple compressor.

1456
01:12:16,400 --> 01:12:18,000
And you know, will

1457
01:12:19,800 --> 01:12:20,600
We'll stop that.

1458
01:12:22,100 --> 01:12:24,400
So let's go ahead and load simple compressor, here a simple

1459
01:12:24,400 --> 01:12:25,000
compressor.

1460
01:12:25,300 --> 01:12:28,200
We don't actually want pretty much most of this stuff, right?

1461
01:12:28,200 --> 01:12:32,000
We don't want the meta struct and we don't want the tokenizer or the

1462
01:12:32,000 --> 01:12:34,600
parsing, or any of these sorts of things, right?

1463
01:12:34,600 --> 01:12:38,600
So we'll get rid of those, but we do want to keep probably read entire

1464
01:12:38,600 --> 01:12:40,200
file into memory and will terminate.

1465
01:12:40,200 --> 01:12:42,300
We don't care about the null terminate so much.

1466
01:12:42,600 --> 01:12:45,600
But the read entire file into memory would probably be a good idea.

1467
01:12:45,700 --> 01:12:49,400
All that would involve is getting rid of the file size plus 1 bit.

1468
01:12:49,900 --> 01:12:51,500
And the null Terminator.

1469
01:12:51,500 --> 01:12:55,900
But everything else here is exactly what we might want for this

1470
01:12:55,900 --> 01:12:56,800
purpose, right?

1471
01:12:58,600 --> 01:12:59,700
Pretty pretty straightforward.

1472
01:13:00,400 --> 01:13:04,000
So now we get rid of this stuff here and we can do our file contents,

1473
01:13:04,000 --> 01:13:05,600
reading to our file into memory.

1474
01:13:06,100 --> 01:13:09,500
And you know, here is our file and that we're going to do.

1475
01:13:10,000 --> 01:13:11,200
Let's say we're going to do this.

1476
01:13:11,200 --> 01:13:12,800
Basic compression idea, okay.

1477
01:13:13,600 --> 01:13:17,700
And so what I can do here is you know, we can even make this be like a

1478
01:13:18,100 --> 01:13:22,700
compressor or an actual little command line compressor that would

1479
01:13:22,700 --> 01:13:23,600
actually do something, right?

1480
01:13:23,600 --> 01:13:25,500
We can we can we can certainly do that.

1481
01:13:25,600 --> 01:13:27,500
Let's just say that we want our

1482
01:13:28,500 --> 01:13:32,200
You know, three arguments and again you know the way that's see works

1483
01:13:32,200 --> 01:13:33,300
is the course it passes.

1484
01:13:33,300 --> 01:13:35,800
The command name as the first argument.

1485
01:13:35,800 --> 01:13:37,200
So we're looking for arguments here.

1486
01:13:37,600 --> 01:13:40,000
So let's just say, you know, we're going to make a little command line

1487
01:13:40,000 --> 01:13:44,000
utility, we're going to print out to the standard error output.

1488
01:13:44,300 --> 01:13:47,600
If we don't get the arguments we expected and will just say okay the

1489
01:13:47,600 --> 01:13:52,500
usage of this thing is that you have to give me the command and then

1490
01:13:52,500 --> 01:13:56,500
you have to say like compress or like maybe.

1491
01:13:58,000 --> 01:14:04,700
Us or decompress like that and then like input and output.

1492
01:14:06,100 --> 01:14:06,700
Right.

1493
01:14:10,300 --> 01:14:14,000
so basically you just you pass compress or decompress or you know,

1494
01:14:14,000 --> 01:14:15,700
maybe we could do

1495
01:14:17,200 --> 01:14:17,700
this.

1496
01:14:26,400 --> 01:14:27,400
Maybe something like that.

1497
01:14:36,600 --> 01:14:37,900
Not very good documentation there.

1498
01:14:37,900 --> 01:14:40,700
I appreciate the fact that that is not good documentation but what?

1499
01:14:40,700 --> 01:14:43,500
You know, this is a little tiny utility, you know, what's the worst?

1500
01:14:43,500 --> 01:14:44,200
Possibly happen.

1501
01:14:44,300 --> 01:14:45,800
Famous Last Words anyway.

1502
01:14:46,400 --> 01:14:50,200
So in this case, I'm just going to pass that original argument there,

1503
01:14:50,500 --> 01:14:51,000
right?

1504
01:14:51,500 --> 01:14:54,800
And then we're going to go ahead and and and go from there.

1505
01:14:54,900 --> 01:14:55,500
All right?

1506
01:14:56,000 --> 01:14:59,800
So now we should actually have a thing called Simple compressor that

1507
01:15:00,000 --> 01:15:00,300
Run it.

1508
01:15:00,300 --> 01:15:02,800
Well I guess if I'm in the build directory, we can run it right.

1509
01:15:04,400 --> 01:15:04,900
There it is.

1510
01:15:05,100 --> 01:15:08,900
And whenever I run simple compressor, I'm going to get that.

1511
01:15:08,900 --> 01:15:11,900
That message that says, oh by the way you gotta use it like this,

1512
01:15:11,900 --> 01:15:12,100
right?

1513
01:15:12,100 --> 01:15:14,500
Some question or compress or decompress and off you go.

1514
01:15:14,500 --> 01:15:14,700
Okay.

1515
01:15:14,700 --> 01:15:16,000
So that's stuck what I wanted.

1516
01:15:16,100 --> 01:15:18,800
Now what we have to do here is we just have to do a string comparison

1517
01:15:19,300 --> 01:15:22,800
to see which of the modes that we're in, right?

1518
01:15:22,900 --> 01:15:25,500
And we can now that we know that we have the four arguments, we can

1519
01:15:25,700 --> 01:15:27,300
classify them as to what they are.

1520
01:15:27,400 --> 01:15:27,700
You know what?

1521
01:15:27,700 --> 01:15:29,900
I'm gonna switch over to this side so that my head's not in the way of

1522
01:15:29,900 --> 01:15:30,300
anything.

1523
01:15:30,300 --> 01:15:31,900
It just use a little bit easier for people to see.

1524
01:15:32,300 --> 01:15:34,100
Oops, let's go here, right?

1525
01:15:34,500 --> 01:15:36,000
So what I can say here is like, all right.

1526
01:15:38,000 --> 01:15:39,200
I've got an in file name.

1527
01:15:40,300 --> 01:15:43,400
I've got an out file name and then, of course, I've got a command,

1528
01:15:44,300 --> 01:15:45,500
very, very basic, right?

1529
01:15:46,000 --> 01:15:47,700
So my command is, the first thing.

1530
01:15:47,700 --> 01:15:50,000
My in file name is the second thing in my output file.

1531
01:15:50,000 --> 01:15:51,200
Name is the third thing.

1532
01:15:51,500 --> 01:15:54,200
I can then go ahead and do my string comparison.

1533
01:15:54,500 --> 01:15:59,900
I can say, you know, well if the loops if the command is compressed,

1534
01:16:00,000 --> 01:16:04,300
then I'm going to do compression if the command is decompress.

1535
01:16:04,500 --> 01:16:06,700
Oops, wow.

1536
01:16:10,200 --> 01:16:13,800
If they compress them into decompression and otherwise, I'm going to

1537
01:16:13,800 --> 01:16:16,800
have to print out the usage again, or or rather that I don't

1538
01:16:16,800 --> 01:16:18,200
understand the command, right?

1539
01:16:19,200 --> 01:16:23,000
And so I'll just say, you know, something here, it's like,

1540
01:16:24,700 --> 01:16:26,600
Unrecognized command.

1541
01:16:30,000 --> 01:16:32,500
And whatever the command was, we don't understand, right?

1542
01:16:33,200 --> 01:16:34,000
So that should be it.

1543
01:16:34,000 --> 01:16:38,800
And again, I'm going to have to actually include some of these spaces

1544
01:16:38,800 --> 01:16:40,100
C, standard Library here.

1545
01:16:40,800 --> 01:16:41,400
There we go.

1546
01:16:41,500 --> 01:16:43,500
And again, I'm using the C standard library, for this one.

1547
01:16:43,500 --> 01:16:45,500
Unlike on handmade hero, where we don't really use it.

1548
01:16:47,800 --> 01:16:50,800
So this should be something you can compile on any Aunt CC thing.

1549
01:16:50,800 --> 01:16:52,800
We're not going to, we're not going to try and be Windows.

1550
01:16:53,400 --> 01:16:54,700
Call directly into Windows there.

1551
01:16:54,700 --> 01:16:55,500
Anything like that.

1552
01:16:57,700 --> 01:17:02,700
All right, so now if I call Simple compressor like so on, right?

1553
01:17:03,200 --> 01:17:05,700
I could do compress, and it should work in theory.

1554
01:17:05,800 --> 01:17:06,100
Ooh,

1555
01:17:07,300 --> 01:17:11,100
Oh right, I would have to do compressed Fubar and it should work.

1556
01:17:11,100 --> 01:17:13,500
In theory course we have an employee anything so it doesn't I should

1557
01:17:13,500 --> 01:17:15,800
be able to call it decompress Fubar and it would work.

1558
01:17:16,500 --> 01:17:20,800
But then if I was to call something like blah Fubar, it should say

1559
01:17:20,800 --> 01:17:22,900
that it doesn't recognize those commands, Okay?

1560
01:17:23,600 --> 01:17:27,200
Now what we would do is on compress and decompress.

1561
01:17:27,600 --> 01:17:30,600
Now we just need to actually make these things do something.

1562
01:17:31,200 --> 01:17:34,300
So let's go ahead and try to make them actually do something.

1563
01:17:37,300 --> 01:17:42,900
let's see here, if we read file to our file into memory, this will be

1564
01:17:43,200 --> 01:17:43,700
in

1565
01:17:45,500 --> 01:17:47,300
I'll and you know what?

1566
01:17:47,300 --> 01:17:48,300
I just realized this.

1567
01:17:48,800 --> 01:17:51,800
I want this to actually be a little bit better than it is right.

1568
01:17:51,900 --> 01:17:52,900
File Contents.

1569
01:17:53,400 --> 01:17:55,300
I want to know that sighs.

1570
01:17:55,300 --> 01:17:56,800
Whatever that size is there.

1571
01:17:57,200 --> 01:17:59,800
So I feel like I also feel like this

1572
01:18:00,000 --> 01:18:01,300
Wouldn't work for anything.

1573
01:18:01,300 --> 01:18:06,900
That's greater than 4 gigabytes here because I feel like f tell

1574
01:18:07,500 --> 01:18:08,500
doesn't actually.

1575
01:18:08,500 --> 01:18:09,800
Give me a size T.

1576
01:18:10,000 --> 01:18:11,300
Is that true?

1577
01:18:11,800 --> 01:18:13,000
Let me, let me see here.

1578
01:18:13,200 --> 01:18:14,000
I feel like f.

1579
01:18:14,000 --> 01:18:15,900
Tell doesn't give you a size.

1580
01:18:15,900 --> 01:18:17,700
T, it gives you an ant, right?

1581
01:18:18,500 --> 01:18:22,800
I wish it gave you a size T, but you know, it doesn't.

1582
01:18:23,700 --> 01:18:25,100
So I don't think it's 64 bit.

1583
01:18:25,200 --> 01:18:28,700
That's all right, it's not the end of the world, but, you know,

1584
01:18:38,900 --> 01:18:41,000
Oh, the Aging, C++ Library.

1585
01:18:41,700 --> 01:18:45,200
Anyway, so we'll have the file size here, and we'll have the contents

1586
01:18:45,200 --> 01:18:51,200
here, like, so and so, you know, and maybe I'll do them Care on sign

1587
01:18:51,200 --> 01:18:51,500
here.

1588
01:18:51,500 --> 01:18:54,100
And I might even just to make life a little bit easier on myself, I

1589
01:18:54,100 --> 01:18:59,700
might go ahead and say that Karen signed is going to be, uh, so I

1590
01:18:59,700 --> 01:19:00,800
don't have to keep typing it.

1591
01:19:01,600 --> 01:19:04,700
All right, so there's my you ate and there's my file contents.

1592
01:19:04,700 --> 01:19:07,300
And so what I'm going to do is say, okay, you know, we'll get back a

1593
01:19:07,300 --> 01:19:08,400
file contents here.

1594
01:19:08,900 --> 01:19:11,600
Rather than just a raw pointer.

1595
01:19:12,000 --> 01:19:14,200
And that way, when I come through here, and I say, oh, what's the

1596
01:19:14,200 --> 01:19:14,600
result?

1597
01:19:14,600 --> 01:19:19,500
Well, I can say, oh the resulting file size is blah and the resulting

1598
01:19:19,500 --> 01:19:23,400
contents is is this see there.

1599
01:19:23,500 --> 01:19:26,300
And that way, it's all kind of bundled together and off we go, right?

1600
01:19:27,000 --> 01:19:28,200
So hopefully,

1601
01:19:30,700 --> 01:19:31,400
That's all we need.

1602
01:19:31,400 --> 01:19:33,300
Okay, so real contents result, file size?

1603
01:19:34,900 --> 01:19:35,200
Oops,

1604
01:19:37,900 --> 01:19:40,200
And just replacing that everywhere.

1605
01:19:41,600 --> 01:19:42,400
And then

1606
01:19:45,100 --> 01:19:48,100
I will read the in file here, right?

1607
01:19:48,800 --> 01:19:50,200
Let's see.

1608
01:19:50,300 --> 01:19:55,300
The file name is in file name, I forget, okay.

1609
01:19:55,500 --> 01:19:59,300
And the other thing that I need to do is I need to open the output

1610
01:19:59,300 --> 01:20:00,300
file as well.

1611
01:20:01,200 --> 01:20:06,800
And so, let's go ahead and do file out, file equals.

1612
01:20:11,800 --> 01:20:12,800
Well, actually, I guess do.

1613
01:20:12,800 --> 01:20:13,800
I really need to do that yet?

1614
01:20:13,800 --> 01:20:14,000
I guess.

1615
01:20:14,000 --> 01:20:14,500
I don't want to do that.

1616
01:20:14,500 --> 01:20:15,600
I think I left the other guy.

1617
01:20:15,600 --> 01:20:16,700
The other ones do that.

1618
01:20:17,400 --> 01:20:18,200
So, off we go.

1619
01:20:18,600 --> 01:20:22,100
So from here I would also like to probably put a

1620
01:20:23,500 --> 01:20:23,800
Hey.

1621
01:20:25,600 --> 01:20:26,300
Error message out.

1622
01:20:26,300 --> 01:20:29,900
If you can't believe the file, you know, why not been able to read

1623
01:20:29,900 --> 01:20:34,100
file % s and there's the file name, right?

1624
01:20:34,500 --> 01:20:38,500
So at least know that there was some kind of problem there and off we

1625
01:20:38,500 --> 01:20:38,700
go.

1626
01:20:39,400 --> 01:20:42,900
So now we just need something that does compress and decompress and

1627
01:20:42,900 --> 01:20:44,000
then we've actually got a compressor.

1628
01:20:44,000 --> 01:20:47,300
So we've got like a little infrastructure here for it and off we go.

1629
01:20:47,700 --> 01:20:53,500
So let's actually say that we've got that and and then figure out how

1630
01:20:53,500 --> 01:20:54,300
we're going to do it.

1631
01:20:55,500 --> 01:20:57,000
If we want to do compression.

1632
01:20:58,600 --> 01:20:59,800
We're just going to have a thing called.

1633
01:21:00,000 --> 01:21:01,900
Yes, let's say we'll pass it.

1634
01:21:01,900 --> 01:21:06,300
The in file file size of the in file contents.

1635
01:21:06,900 --> 01:21:09,700
And then we want to look an output buffer here, right?

1636
01:21:09,700 --> 01:21:13,100
And so the question would be how big does the output buffer need to be

1637
01:21:13,200 --> 01:21:13,700
right?

1638
01:21:13,800 --> 01:21:16,400
We need, we want to compress maybe from one piece of memory to another

1639
01:21:16,400 --> 01:21:16,900
piece of memory.

1640
01:21:16,900 --> 01:21:18,500
Let's say it's in memory compressor.

1641
01:21:19,000 --> 01:21:23,700
So, we want to compress this way, where we taken an input file, and

1642
01:21:23,700 --> 01:21:26,800
then we took an output file, we need an out buffer here.

1643
01:21:27,000 --> 01:21:29,800
And so we need some way of knowing how big the

1644
01:21:30,000 --> 01:21:32,700
Output, buffer is going to have to be right?

1645
01:21:34,400 --> 01:21:37,900
So when we do our Malik, we need some maximum size here.

1646
01:21:38,500 --> 01:21:42,500
And usually the way compressors do this is they have some idea of how

1647
01:21:42,500 --> 01:21:46,400
much they might inflate the thing to write how big it would happen.

1648
01:21:46,600 --> 01:21:49,800
It might become when they're processing it, right?

1649
01:21:50,600 --> 01:21:55,900
And so, you know, will also pass maybe the out buffer size as well

1650
01:21:55,900 --> 01:22:00,100
here, but we'll just say, Okay, so we've got an out buffer size and

1651
01:22:00,100 --> 01:22:03,400
then up over sizes, get maximum output side.

1652
01:22:03,600 --> 01:22:07,300
as for whatever this input size is,

1653
01:22:09,700 --> 01:22:10,200
Right?

1654
01:22:10,300 --> 01:22:12,900
So we're just going to say hey, one of the properties of our

1655
01:22:12,900 --> 01:22:16,900
compressor is getting the maximum output size.

1656
01:22:21,800 --> 01:22:27,000
Yeah, it's getting the maximum output size and maybe I could, like I

1657
01:22:27,000 --> 01:22:33,600
said, get compressed output size for some given input size.

1658
01:22:36,600 --> 01:22:39,200
So the input size and the output size.

1659
01:22:39,700 --> 01:22:43,200
We're just going to say we can, this compressor can tell you ahead of

1660
01:22:43,200 --> 01:22:44,800
time, this is what's going to happen.

1661
01:22:45,200 --> 01:22:50,100
And so what we could do is say, well, you know, maybe the the maximum

1662
01:22:50,100 --> 01:22:53,000
it could ever be is like twice as big or something, right?

1663
01:22:53,000 --> 01:22:55,200
And we'll be able to know what that actually is.

1664
01:22:55,200 --> 01:22:59,100
Once we write the compressor in a second here, but we'd basically said

1665
01:22:59,100 --> 01:23:02,900
like, oh yeah, it can't ever be, you know, more than that, or

1666
01:23:02,900 --> 01:23:04,300
something right to do.

1667
01:23:05,200 --> 01:23:11,300
Actually figure out the equation for our compressor.

1668
01:23:15,700 --> 01:23:18,700
But that's really all we're talking about here is just like hey you

1669
01:23:18,700 --> 01:23:21,500
know output size, we need something right?

1670
01:23:22,100 --> 01:23:24,900
So we'll say okay whatever the output whatever the compressor says the

1671
01:23:24,900 --> 01:23:29,700
maximum size is thing could be will actually do that and if we do so

1672
01:23:29,700 --> 01:23:34,000
then will now lock the out buffer size and you know off we go.

1673
01:23:34,500 --> 01:23:37,800
So at that point we've got the at buffer and we're ready to compress.

1674
01:23:37,800 --> 01:23:38,600
And here we go.

1675
01:23:39,300 --> 01:23:43,800
Similarly, in this case, we would have when we go to do our

1676
01:23:43,800 --> 01:23:45,400
decompress, right?

1677
01:23:47,200 --> 01:23:48,900
We need to do the opposite thing.

1678
01:23:49,100 --> 01:23:52,600
So we would have something here that's like decompress and that's

1679
01:23:52,600 --> 01:23:54,800
again going to be the in file size and file contents.

1680
01:23:54,800 --> 01:23:57,300
And then the out buffer size out by over again.

1681
01:23:57,300 --> 01:23:59,800
The problem is, what is

1682
01:24:00,000 --> 01:24:04,100
Maximum output size and again, in this case, let's just say that.

1683
01:24:04,100 --> 01:24:04,500
All right.

1684
01:24:04,500 --> 01:24:11,800
Whatever the Apple precise is here, is get output size or get

1685
01:24:11,800 --> 01:24:16,500
decompressed output size, and what we'll do is, we'll just say, oh,

1686
01:24:16,700 --> 01:24:17,900
hey compressor.

1687
01:24:17,900 --> 01:24:21,400
I'm assuming that you put something into the stream that lets you know

1688
01:24:21,500 --> 01:24:24,100
how big this thing expands to because that's just the property of the

1689
01:24:24,100 --> 01:24:26,500
thing that we want, for example.

1690
01:24:27,200 --> 01:24:29,900
And so, you know, you go ahead and you

1691
01:24:30,000 --> 01:24:33,400
Tell me how big this thing should be now I don't always actually like

1692
01:24:33,400 --> 01:24:33,600
that.

1693
01:24:33,600 --> 01:24:36,300
In fact you know to be honest maybe I don't really like that at all.

1694
01:24:36,700 --> 01:24:39,000
So what I might do is say let's do that slightly differently.

1695
01:24:39,100 --> 01:24:43,000
Let's say that's a property of the out the the sort of the, the outer

1696
01:24:43,000 --> 01:24:43,500
layer.

1697
01:24:44,300 --> 01:24:50,000
So maybe what we'd say here is like, okay yeah let's just say that we

1698
01:24:50,700 --> 01:24:53,000
this this file contents here.

1699
01:24:53,200 --> 01:24:56,700
Let's just say that the five the input the output content.

1700
01:24:56,700 --> 01:24:57,400
So he's

1701
01:25:00,900 --> 01:25:04,100
A size baked into it, right?

1702
01:25:04,700 --> 01:25:12,800
So, you know, since we can only do 32-bit wide things in here anyway,

1703
01:25:12,800 --> 01:25:14,100
because of RF teller, whatever.

1704
01:25:14,300 --> 01:25:18,300
Let's just say that in the in the outer area of the code, we remember

1705
01:25:18,300 --> 01:25:20,000
that particular piece of information.

1706
01:25:20,200 --> 01:25:22,300
So what we do is we say like, okay,

1707
01:25:25,000 --> 01:25:31,000
We know in here that we want to Malik the output buffer size, + 4 B.

1708
01:25:32,600 --> 01:25:36,800
And when we do the output buffer, we tell it to compress 24 bytes in.

1709
01:25:37,200 --> 01:25:39,300
That means at the end, right?

1710
01:25:39,400 --> 01:25:46,200
When we get our size T, like compressed size here, what we can do is

1711
01:25:46,200 --> 01:25:49,800
just store the compressed size into the output buffer.

1712
01:25:49,800 --> 01:25:54,200
So here is the output buffer, let's just say that the first pointer to

1713
01:25:54,200 --> 01:25:54,500
it.

1714
01:25:55,500 --> 01:25:58,600
Is an intern signed first thing there.

1715
01:25:59,100 --> 01:26:02,400
So I'm just going to write the compressed size in there.

1716
01:26:03,000 --> 01:26:07,200
Okay so what that means here is we can also say, all right, let's

1717
01:26:07,200 --> 01:26:14,100
assume that the file size here is greater than than 4 bytes, right?

1718
01:26:14,300 --> 01:26:17,400
Or it's got to be at least that if it's not that then it probably

1719
01:26:17,400 --> 01:26:21,900
wasn't our file because we know that we always output the size first

1720
01:26:22,900 --> 01:26:23,900
invalid.

1721
01:26:24,800 --> 01:26:26,700
Input file something like this.

1722
01:26:28,400 --> 01:26:29,000
Right?

1723
01:26:29,800 --> 01:26:32,800
And so we take a look and we say, hey this thing's got to be greater

1724
01:26:33,300 --> 01:26:34,900
than 4 B.

1725
01:26:34,900 --> 01:26:37,800
If it's not, then we should warn the user that, hey, this is probably

1726
01:26:37,800 --> 01:26:39,100
not a file that we output.

1727
01:26:39,400 --> 01:26:41,200
We don't output 3, B, long files.

1728
01:26:41,900 --> 01:26:44,300
So, you know, we take a look at the file size and we say, okay, the

1729
01:26:44,300 --> 01:26:50,600
output buffer size in this case is just, you know, whatever the in

1730
01:26:50,600 --> 01:26:55,100
file contents say that it is right because we out, you know, we're

1731
01:26:55,100 --> 01:26:58,100
just reading this we wrote out this 30

1732
01:26:58,200 --> 01:26:58,900
Two bit value here.

1733
01:26:58,900 --> 01:26:59,900
And now we're reading this 32

1734
01:27:00,000 --> 01:27:04,700
All you back in that we wrote out and then we say that's how big the

1735
01:27:04,700 --> 01:27:07,200
output buffer is that we wanted off, we go.

1736
01:27:07,800 --> 01:27:12,500
So we out, we allocate, we allocate that for our output buffer size

1737
01:27:14,300 --> 01:27:15,500
and there you can see that happening.

1738
01:27:15,800 --> 01:27:17,600
And when we come in here, we say well.

1739
01:27:17,600 --> 01:27:21,600
Alright, now when we pass in the contents, we just want to skip that

1740
01:27:21,600 --> 01:27:24,000
for B value that we had there, right?

1741
01:27:24,800 --> 01:27:25,500
And off we go.

1742
01:27:25,800 --> 01:27:28,000
So that's all we need to do, then we can decompress.

1743
01:27:28,000 --> 01:27:29,800
And of course, when we actually do the decompress,

1744
01:27:30,000 --> 01:27:36,300
Yes, we want in both these cases to actually write to the output file

1745
01:27:36,300 --> 01:27:36,800
as well.

1746
01:27:37,200 --> 01:27:40,400
And so, what we can do here is we could actually say if we wanted to

1747
01:27:40,800 --> 01:27:43,000
we could have a thing here that's like output.

1748
01:27:46,300 --> 01:27:52,800
Final output size and I guess that actually could be right here and

1749
01:27:52,800 --> 01:27:54,400
output buffer.

1750
01:27:59,100 --> 01:28:02,700
And so in this case, we just say, all right, our final output size is

1751
01:28:02,700 --> 01:28:08,200
whatever the compressed size is plus the 4, right?

1752
01:28:10,100 --> 01:28:10,300
Right?

1753
01:28:10,300 --> 01:28:16,300
Because we allocate the maximum, we would need plus the space for the

1754
01:28:16,300 --> 01:28:16,800
number.

1755
01:28:16,900 --> 01:28:20,900
But then after it's compressed, we only actually now need the

1756
01:28:20,900 --> 01:28:23,000
compressed size plus the 4, right?

1757
01:28:23,000 --> 01:28:24,900
We don't need to write out the whole buffer.

1758
01:28:25,000 --> 01:28:27,700
So our final output size is just a compressed size, plus our header

1759
01:28:27,700 --> 01:28:29,800
size, and we're done, right?

1760
01:28:30,100 --> 01:28:31,500
And our final output,

1761
01:28:35,600 --> 01:28:39,200
Buffer in this case is just the app up.

1762
01:28:41,100 --> 01:28:41,300
Same.

1763
01:28:41,300 --> 01:28:42,500
Exact thing is true.

1764
01:28:42,500 --> 01:28:46,000
In this case we know exactly what the output buffer size is it's going

1765
01:28:46,000 --> 01:28:46,400
to be this.

1766
01:28:46,400 --> 01:28:49,700
It's not going to have any adjustment to it and the output buffer is

1767
01:28:49,700 --> 01:28:50,700
here and that's it.

1768
01:28:51,200 --> 01:28:51,700
I think.

1769
01:28:52,100 --> 01:28:55,200
All right so now we've just got a case of like.

1770
01:28:55,200 --> 01:28:59,500
Alright let's go ahead and finish the scaffolding.

1771
01:29:00,500 --> 01:29:02,300
So we've got a thing that's like compress.

1772
01:29:03,400 --> 01:29:05,900
We've got a thing that's like decompress.

1773
01:29:08,600 --> 01:29:12,200
And now we just need to actually fill these in with some actual logic.

1774
01:29:12,600 --> 01:29:18,800
So we have the in size and the n, and then we have the outside eyes,

1775
01:29:19,000 --> 01:29:20,500
you know, and the out.

1776
01:29:21,200 --> 01:29:24,700
And then for the decompress, we've got same thing.

1777
01:29:29,000 --> 01:29:34,900
Okay, so obviously if we wanted to, we could just start by making this

1778
01:29:35,400 --> 01:29:39,700
an on compressor, something that literally is worse than a compressor

1779
01:29:39,700 --> 01:29:41,400
because it actually stores the size as well.

1780
01:29:42,200 --> 01:29:45,900
But just for our own testing purposes, make sure that our scaffolding

1781
01:29:45,900 --> 01:29:46,700
works, okay?

1782
01:29:46,700 --> 01:29:54,400
Let's just go ahead and say that we copy the in size from the into the

1783
01:29:54,400 --> 01:29:57,400
out and then we just return that size, right?

1784
01:29:57,900 --> 01:29:58,700
So, in both

1785
01:29:58,800 --> 01:29:59,900
both cases here and I guess our

1786
01:30:00,000 --> 01:30:02,700
Professor, you know, doesn't need to store anything because it's just

1787
01:30:02,700 --> 01:30:04,400
already again it, right?

1788
01:30:05,600 --> 01:30:10,100
So you know, this is now our the entirety of our

1789
01:30:16,500 --> 01:30:17,000
right.

1790
01:30:21,200 --> 01:30:24,000
We just want to do something very simple here where we do a copy.

1791
01:30:28,600 --> 01:30:30,600
So, if that's the entirety of our compressor, right?

1792
01:30:30,600 --> 01:30:31,600
It's not doing anything.

1793
01:30:31,600 --> 01:30:35,000
It's literally, you know, just a direct copy.

1794
01:30:36,000 --> 01:30:41,100
So, in this case, again, we are sort of saying we're limited to two

1795
01:30:42,000 --> 01:30:45,100
kind of files that are smaller than we might like care.

1796
01:30:45,100 --> 01:30:46,900
But that's because of the C runtime Library.

1797
01:30:46,900 --> 01:30:50,300
We can't actually get a 64-bit size out of everything.

1798
01:30:51,000 --> 01:30:54,900
So what you going to do, that's just just the way it goes, but anyway,

1799
01:31:00,100 --> 01:31:04,000
At this point, we should be able to now just use that final output to

1800
01:31:04,000 --> 01:31:06,600
actually write the output file and then we should be done.

1801
01:31:06,700 --> 01:31:09,000
So assuming that we got to here, right?

1802
01:31:09,200 --> 01:31:17,000
We could say if there's a final output size or rather buffer, then

1803
01:31:17,000 --> 01:31:20,200
what we can do is say, all right, let's try to open the out file

1804
01:31:21,300 --> 01:31:25,000
again, we'll just you know, do a standard, you know what I should

1805
01:31:25,000 --> 01:31:26,700
mention when we read this.

1806
01:31:26,900 --> 01:31:30,300
We want to read and binary, we don't want to read an ASCII otherwise

1807
01:31:30,300 --> 01:31:33,700
we'll get it'll the see runtime Library will do weird like translation

1808
01:31:33,700 --> 01:31:34,000
to the data.

1809
01:31:34,000 --> 01:31:36,700
So we're trying to read raw data here so we can press binary files.

1810
01:31:37,000 --> 01:31:38,700
Not just ask if I'll certainly.

1811
01:31:39,900 --> 01:31:42,500
So what I want to do here is open an output file for writing.

1812
01:31:43,100 --> 01:31:45,500
Hopefully we can load that output file.

1813
01:31:47,700 --> 01:31:53,100
And then I just want to do one giant F right to the output file where

1814
01:31:53,100 --> 01:31:54,700
we write that output buffer.

1815
01:31:54,700 --> 01:31:56,100
So the final output buffer.

1816
01:31:56,300 --> 01:31:59,200
I never remember which of these

1817
01:32:00,900 --> 01:32:05,000
Is the one we actually want because there's it has two parameters

1818
01:32:05,100 --> 01:32:07,300
rights and considers writing in chunks.

1819
01:32:07,300 --> 01:32:11,000
So it's like this, this times, this is the actual size and it doesn't

1820
01:32:11,000 --> 01:32:14,300
really matter which one you put in which position, but it has to do

1821
01:32:14,300 --> 01:32:17,800
with how it reports, the right, if there was an error which we don't

1822
01:32:17,800 --> 01:32:18,500
care about the moment.

1823
01:32:18,500 --> 01:32:20,700
But like I said, it's always a little bit weird.

1824
01:32:21,100 --> 01:32:23,800
Anyway, so when we do the fprintf here, we just want to say like

1825
01:32:23,800 --> 01:32:27,200
unable to open output file this.

1826
01:32:28,100 --> 01:32:29,600
And we just say,

1827
01:32:29,700 --> 01:32:30,700
Oh, that's out.

1828
01:32:30,700 --> 01:32:33,400
File name, okay?

1829
01:32:38,200 --> 01:32:41,800
So in theory, that's a complete simple compressor, right?

1830
01:32:42,500 --> 01:32:46,300
And so here's our simple compressor that we can run now and it doesn't

1831
01:32:46,300 --> 01:32:47,800
actually do any compression yet.

1832
01:32:48,000 --> 01:32:52,600
So let's go back to our data directory here.

1833
01:32:52,600 --> 01:32:55,300
I'm going to say oh well you know, we could do actually well, you

1834
01:32:55,300 --> 01:32:55,400
know.

1835
01:32:55,400 --> 01:32:55,700
No.

1836
01:32:55,700 --> 01:32:59,800
I'll go ahead and just copy something from the handmade.

1837
01:33:00,100 --> 01:33:04,300
Dana directory, the I don't know.

1838
01:33:04,300 --> 01:33:09,200
Let's see test 1 .hh a for example and will copy it here, right?

1839
01:33:09,700 --> 01:33:15,700
So there is test one that ha it's 1.5 MB long and so if I do simple

1840
01:33:15,800 --> 01:33:22,700
compressor on it and I say a want to compress just one .hh a test one.

1841
01:33:23,000 --> 01:33:25,600
Like simple compressor, I don't know.

1842
01:33:26,800 --> 01:33:27,700
Compressor.

1843
01:33:27,700 --> 01:33:28,400
Something like that.

1844
01:33:30,300 --> 01:33:31,800
Oops and I've got a command.

1845
01:33:31,800 --> 01:33:32,100
There we go.

1846
01:33:32,100 --> 01:33:37,100
Compress in theory now it should write out a file for this and that

1847
01:33:37,100 --> 01:33:40,500
file should be exactly 4 B longer and hey take a look, that's exactly

1848
01:33:40,500 --> 01:33:41,100
what it is, right?

1849
01:33:41,100 --> 01:33:44,300
Because remember we suck the length on the beginning and then we wrote

1850
01:33:44,300 --> 01:33:46,400
out the data exactly as it occurred.

1851
01:33:46,900 --> 01:33:52,600
Now, I should also be able to do a decompress on that from test-1 SCP

1852
01:33:53,100 --> 01:33:56,200
to test one, like let's say out right.

1853
01:33:56,500 --> 01:33:59,900
And now I should get back the exact same file size and I do and we

1854
01:33:59,900 --> 01:34:03,300
should verify as well that I can actually have.

1855
01:34:03,300 --> 01:34:08,500
Like, any kind of Dipping utility on here by any chance Beyond Compare

1856
01:34:08,500 --> 01:34:10,900
their, it is so beyond.

1857
01:34:10,900 --> 01:34:11,900
Compare should be on here.

1858
01:34:11,900 --> 01:34:17,800
I guess wind if I would prefer wind if I don't think it's on here so

1859
01:34:17,800 --> 01:34:18,100
it is.

1860
01:34:18,100 --> 01:34:20,700
There we go because this one is freely available.

1861
01:34:21,400 --> 01:34:22,100
It's in the wind.

1862
01:34:22,100 --> 01:34:23,200
It's from the windows SDK.

1863
01:34:23,200 --> 01:34:26,300
If you want to try and get it, although it gets increasingly harder to

1864
01:34:26,400 --> 01:34:27,000
Get these things.

1865
01:34:27,000 --> 01:34:29,400
They move them around and I don't know where they are anymore, a lot

1866
01:34:29,400 --> 01:34:33,100
of times, but let's take a look and see if there.

1867
01:34:33,200 --> 01:34:35,100
I think this can do binary files.

1868
01:34:35,100 --> 01:34:36,500
We can't we'll use Beyond Compare.

1869
01:34:37,100 --> 01:34:39,400
But anyway we want to make sure that these two files are the same.

1870
01:34:39,400 --> 01:34:43,900
So we want to do test 12th a and then test one doubt and we can see

1871
01:34:43,900 --> 01:34:46,300
that the files are identical and that's what we wanted, right?

1872
01:34:47,500 --> 01:34:48,100
So good.

1873
01:34:48,400 --> 01:34:51,400
So now we know that our compressor can do a round trip.

1874
01:34:51,500 --> 01:34:55,400
Now, the question is, can we actually add some some compression,

1875
01:34:55,500 --> 01:34:56,200
right?

1876
01:34:56,800 --> 01:34:58,300
And we've got some time here, right?

1877
01:34:58,300 --> 01:35:00,400
I think you know what?

1878
01:35:00,400 --> 01:35:03,000
I don't, I don't know when we started 30.

1879
01:35:03,000 --> 01:35:04,500
We got we got a few minutes here.

1880
01:35:04,800 --> 01:35:05,900
I'm do very simple compressing.

1881
01:35:05,900 --> 01:35:10,900
So let's say, here in our compressor, let's say that we want to do

1882
01:35:11,300 --> 01:35:13,500
like a gnarly compressor, right?

1883
01:35:14,400 --> 01:35:17,000
And what I can do here is actually make a couple of different kinds of

1884
01:35:17,200 --> 01:35:21,200
Of compression, even if I wanted to, I could do something here where

1885
01:35:21,200 --> 01:35:25,700
we said, like, which kind of compression we were using, which maybe I

1886
01:35:25,700 --> 01:35:28,500
should have put in a little bit more of a concession to that at the

1887
01:35:28,500 --> 01:35:28,800
outset.

1888
01:35:28,800 --> 01:35:31,500
But let's just say we're going to do our early compression for now.

1889
01:35:32,100 --> 01:35:35,100
So what we'll do is we'll say static, I'm just going to copy this

1890
01:35:35,100 --> 01:35:35,600
thing.

1891
01:35:37,600 --> 01:35:45,200
Really compress and Charlie decompress.

1892
01:35:45,600 --> 01:35:49,100
So we've got these two now and what I'll say is like okay we're just

1893
01:35:49,100 --> 01:35:55,200
going to forward these for now, or we can press in size and outsize

1894
01:35:56,100 --> 01:35:59,800
out and rle decompress in.

1895
01:36:00,200 --> 01:36:02,200
Skin that's eyes out.

1896
01:36:02,800 --> 01:36:05,400
And that way when we actually do this compression, we can actually

1897
01:36:05,400 --> 01:36:09,800
have something that sort of does you know, different kinds, what we

1898
01:36:09,800 --> 01:36:13,200
can try by just swapping out and probably I should put a little format

1899
01:36:13,200 --> 01:36:15,700
code in there that says oh here's what the compression is and so we

1900
01:36:15,700 --> 01:36:19,100
can pick between them or something, we'll do that later.

1901
01:36:19,400 --> 01:36:23,500
All right, so if I do our Ally compress here, this is the thing that

1902
01:36:23,500 --> 01:36:24,400
may blow is working on

1903
01:36:25,400 --> 01:36:27,900
For example, let's see how we might do that.

1904
01:36:27,900 --> 01:36:32,400
Okay, so what I want to do here is say, okay, I'm going to go through

1905
01:36:32,400 --> 01:36:36,500
my stream and I'm just going to write this the simplest possible way,

1906
01:36:36,500 --> 01:36:36,800
right?

1907
01:36:36,800 --> 01:36:38,000
Nothing fancy at all.

1908
01:36:38,300 --> 01:36:45,600
And I'm just going to say, like, okay, I've got my my string pointer,

1909
01:36:45,600 --> 01:36:51,000
so, you know, this is, this is my where I'm at in the Stream and I

1910
01:36:51,000 --> 01:36:54,300
want to iterate through all of the characters in the Stream.

1911
01:36:54,300 --> 01:36:54,900
Let's say,

1912
01:36:55,500 --> 01:37:00,600
And for every character in the Stream, I want to see how long of a

1913
01:37:00,600 --> 01:37:04,200
run, I have for a particular value, right?

1914
01:37:04,400 --> 01:37:05,900
So I want to early compress this.

1915
01:37:05,900 --> 01:37:09,400
I'm just going to say like, okay, I'm then going to say, you know,

1916
01:37:09,500 --> 01:37:15,000
size T offset or something like this and start at zero.

1917
01:37:15,000 --> 01:37:18,400
And then my offset is going to be less than whatever.

1918
01:37:18,400 --> 01:37:19,700
The inside is - the at.

1919
01:37:19,700 --> 01:37:21,100
So, I'm going to basically say, like,

1920
01:37:23,000 --> 01:37:26,300
You know, let's run through every character and for every character

1921
01:37:26,300 --> 01:37:28,300
I'm going to run from that character all the way to the end of the

1922
01:37:28,300 --> 01:37:28,700
stream.

1923
01:37:29,000 --> 01:37:30,800
Now, I'm not actually going to do that, right?

1924
01:37:30,800 --> 01:37:33,600
I'm just going to sort of say, hey, let's set up the loops to do that.

1925
01:37:33,600 --> 01:37:37,700
I'm going to break out early, so it's not actually a problem if you

1926
01:37:37,700 --> 01:37:38,000
will.

1927
01:37:39,900 --> 01:37:41,900
And then the other thing I'm going to do is say, well, this plus plus

1928
01:37:41,900 --> 01:37:44,800
at I probably need to work with that a little bit more specifically,

1929
01:37:44,800 --> 01:37:47,200
some it was going to move that down here for the moment, right?

1930
01:37:48,300 --> 01:37:48,700
Okay.

1931
01:37:48,900 --> 01:37:51,300
So I'm going to go through these streams here.

1932
01:37:51,400 --> 01:37:52,600
And what I'm going to do is

1933
01:37:52,800 --> 01:37:56,000
Really what I sort of said before, I'm just going to look to see how

1934
01:37:56,000 --> 01:38:00,600
many of the same value I have in a row, right?

1935
01:38:00,800 --> 01:38:04,300
So let's say I'm at this particular location, okay.

1936
01:38:05,000 --> 01:38:09,300
So I've got my value, you know, my starting value let's say, that's

1937
01:38:09,300 --> 01:38:12,200
whatever is in the input at this location.

1938
01:38:13,200 --> 01:38:13,400
Right.

1939
01:38:13,400 --> 01:38:14,100
That's all it is.

1940
01:38:15,400 --> 01:38:19,000
Whatever is at the input in this location, I'm going to go through

1941
01:38:19,000 --> 01:38:24,300
here and I'm just going to say, I want to count up how many of these

1942
01:38:24,300 --> 01:38:25,900
things there actually are.

1943
01:38:26,000 --> 01:38:30,300
So I want to say something like and I probably you know, let's let's

1944
01:38:30,300 --> 01:38:32,200
say we do something here.

1945
01:38:32,800 --> 01:38:40,500
In fact, we could just make this run and then just say while you know,

1946
01:38:40,500 --> 01:38:43,500
the offset is less than this.

1947
01:38:46,600 --> 01:38:48,400
And the starting value.

1948
01:38:54,500 --> 01:38:56,200
Sorry, just for organizing this here.

1949
01:38:59,400 --> 01:38:59,700
So,

1950
01:39:00,000 --> 01:39:01,300
Offset is within range.

1951
01:39:01,300 --> 01:39:05,000
So I haven't exceeded the end of the buffer or anything like that, and

1952
01:39:05,200 --> 01:39:06,600
whatever I'm at right now.

1953
01:39:06,600 --> 01:39:09,800
So, at plus offset, while it equals the starting value.

1954
01:39:10,100 --> 01:39:15,200
So, meaning I'm still seeing the same value that I was singing, then I

1955
01:39:15,200 --> 01:39:17,300
want to increase my run, right?

1956
01:39:17,300 --> 01:39:20,600
And and I can just make run be the variable here if you will, right.

1957
01:39:23,000 --> 01:39:24,900
Okay, so I start with a particular value.

1958
01:39:24,900 --> 01:39:27,200
That's whatever at the input stream at this point I say I'm going to

1959
01:39:27,200 --> 01:39:28,300
see how much of a run.

1960
01:39:28,300 --> 01:39:30,500
I could encode here if I want to encode a run.

1961
01:39:30,800 --> 01:39:34,500
I say while I haven't hit the end of the buffer, let's just see how

1962
01:39:34,500 --> 01:39:35,900
many times I see the starting value.

1963
01:39:35,900 --> 01:39:39,000
And I increment my run count right now, when I get to the end here,

1964
01:39:39,000 --> 01:39:42,600
now I know how long my run is and I could say, all right,

1965
01:39:45,800 --> 01:39:47,300
This includes the Run of zero.

1966
01:39:47,300 --> 01:39:50,900
So basically my run, I know my run has to be at least one, right?

1967
01:39:51,400 --> 01:39:54,300
In fact, I could just do this, right?

1968
01:39:54,300 --> 01:39:57,800
I could just say, hey, I know the first time it's going to be equal,

1969
01:39:58,000 --> 01:39:58,300
right?

1970
01:39:58,300 --> 01:40:03,400
I mean, duh, you know, and so all I really want to know.

1971
01:40:03,400 --> 01:40:09,500
Here is, how long, you know, how many can I go beyond just the one and

1972
01:40:09,500 --> 01:40:13,000
so then what I could do here is say like, okay, let's see what

1973
01:40:13,000 --> 01:40:13,700
happens.

1974
01:40:13,800 --> 01:40:14,400
Whenever

1975
01:40:14,800 --> 01:40:16,000
Is greater.

1976
01:40:17,800 --> 01:40:20,700
Then some value will think about that what that should be in a second

1977
01:40:20,700 --> 01:40:23,700
but let's say as long as it's greater than 1 will just encode every

1978
01:40:23,700 --> 01:40:23,900
run.

1979
01:40:23,900 --> 01:40:27,500
Let's say as long as the run is greater than one.

1980
01:40:27,500 --> 01:40:35,000
Then I want to you know encode a run otherwise I want to encode

1981
01:40:35,000 --> 01:40:36,900
literals right.

1982
01:40:38,300 --> 01:40:42,800
Okay, so let's think about what has to happen here, right?

1983
01:40:42,800 --> 01:40:45,100
Because we're going to start, we're going to kind of work this Loop

1984
01:40:45,100 --> 01:40:45,900
through a little bit.

1985
01:40:46,800 --> 01:40:49,200
So if I was going to encode a run,

1986
01:40:51,400 --> 01:40:54,400
Or if I was going to encode literals, I kind of have a little bit of a

1987
01:40:54,400 --> 01:40:55,300
problem here.

1988
01:40:55,700 --> 01:41:03,500
I need to know a little bit more about what I need to know a little

1989
01:41:03,500 --> 01:41:06,900
bit more about how I'm going to actually buffer these literals up

1990
01:41:06,900 --> 01:41:09,700
because if you think about it, if I encode a run, well, I could just

1991
01:41:09,700 --> 01:41:13,200
output a run right here, I'd say here's the run value, which I know.

1992
01:41:13,400 --> 01:41:16,800
And here is the value that I'm trying to encode, which I also know, no

1993
01:41:16,800 --> 01:41:20,700
problem, but if I'm trying to encode, literals, I need to

1994
01:41:20,900 --> 01:41:22,900
Buffer them up, right?

1995
01:41:22,900 --> 01:41:25,900
Because I need to like know that I'm putting literals into the stream

1996
01:41:25,900 --> 01:41:26,300
here.

1997
01:41:27,000 --> 01:41:29,700
So what I need to do if I'm encoding, literals is I need like a

1998
01:41:29,700 --> 01:41:33,600
buffer, I need something that's like my literals buffer, right?

1999
01:41:34,200 --> 01:41:38,000
And my literals buffer needs to have room to store as many literals.

2000
01:41:38,000 --> 01:41:40,900
As I might total, you know, be able to store

2001
01:41:44,000 --> 01:41:44,900
something like this.

2002
01:41:49,200 --> 01:41:49,600
Right?

2003
01:41:49,600 --> 01:41:52,400
Because the number of literals, that I might have is however many I

2004
01:41:52,400 --> 01:41:54,500
might have, and I might be able to store like 255.

2005
01:41:54,500 --> 01:41:55,200
Literals are coming.

2006
01:41:55,200 --> 01:41:58,700
I need to be able to write 205 literals into my buffer here, right?

2007
01:41:58,800 --> 01:41:59,900
So I need to have something like

2008
01:42:00,000 --> 01:42:00,900
That's where I just have.

2009
01:42:00,900 --> 01:42:01,100
Okay.

2010
01:42:01,100 --> 01:42:05,000
Here's the literal count and here's the buffer for the literals,

2011
01:42:05,800 --> 01:42:06,300
right?

2012
01:42:08,100 --> 01:42:09,200
And I could end up this.

2013
01:42:12,800 --> 01:42:16,300
Okay, so if I want to do something like that, then it's like, okay if

2014
01:42:16,300 --> 01:42:20,300
I wanted to encode a literal then all I would do is say all right when

2015
01:42:20,300 --> 01:42:25,000
I want to encode a literal I would say hey let's go ahead and put that

2016
01:42:25,000 --> 01:42:26,100
into the literal buffer.

2017
01:42:31,700 --> 01:42:33,300
Otherwise, I need to encode a run.

2018
01:42:34,300 --> 01:42:34,800
Right.

2019
01:42:35,900 --> 01:42:38,200
And we'll see how I have to go to run in a second.

2020
01:42:38,600 --> 01:42:42,500
All right, so that's really all we have to do there and I guess I need

2021
01:42:42,600 --> 01:42:43,900
another thing here.

2022
01:42:44,000 --> 01:42:45,200
Seems like out at

2023
01:42:51,000 --> 01:42:52,000
Maybe outsize.

2024
01:43:00,300 --> 01:43:04,200
Okay, so if I need to do this now, I need to start acting about the

2025
01:43:04,200 --> 01:43:04,700
encoding.

2026
01:43:04,700 --> 01:43:07,900
I need to Define how I'm going to encode this, right?

2027
01:43:08,200 --> 01:43:10,800
And for starters, let's use the simple encoding that I was talking

2028
01:43:10,800 --> 01:43:11,200
about before.

2029
01:43:11,200 --> 01:43:14,300
So let's pop over the decompressor for a second and just write it

2030
01:43:14,500 --> 01:43:18,000
because that will be the definition of how our output stream works.

2031
01:43:18,200 --> 01:43:18,700
Right?

2032
01:43:19,300 --> 01:43:24,100
And so what I'll do there is just say, okay, I know that I'm going to

2033
01:43:24,100 --> 01:43:27,600
continue going, see you

2034
01:43:27,900 --> 01:43:29,300
At zero.

2035
01:43:30,200 --> 01:43:33,500
As long as I haven't consumed into the entirety of the input.

2036
01:43:33,500 --> 01:43:35,400
I'm going to keep going, right?

2037
01:43:35,800 --> 01:43:39,800
So then all I need to do is say, all right, I want to take a look at

2038
01:43:39,800 --> 01:43:43,500
the value that comes in, whatever that value is.

2039
01:43:43,600 --> 01:43:47,600
So I'm going to say that the thing coming in is the literal count

2040
01:43:48,700 --> 01:43:49,900
Let's say so I'm going to read a value.

2041
01:43:49,900 --> 01:43:51,700
That's how many new b 1 code.

2042
01:43:52,500 --> 01:43:55,800
I'm going to go ahead and run that literal countdown.

2043
01:43:55,800 --> 01:43:58,800
I'm going to say for every literal that I was supposed to do.

2044
01:43:59,200 --> 01:44:01,200
I'm going to put something into the output stream.

2045
01:44:01,200 --> 01:44:03,500
So this is the copy right for every literal.

2046
01:44:03,500 --> 01:44:06,000
I'm going to copy from the input stream into the output screen.

2047
01:44:06,200 --> 01:44:09,900
Then I'm going to read a replication count.

2048
01:44:11,900 --> 01:44:12,500
Right?

2049
01:44:13,200 --> 01:44:15,900
And then I also need a replication value.

2050
01:44:16,800 --> 01:44:19,700
Write the value meant to replicate and then again, just going to run

2051
01:44:19,700 --> 01:44:20,300
that down.

2052
01:44:25,000 --> 01:44:25,400
Okay.

2053
01:44:26,000 --> 01:44:27,500
And there's an early to compressor, right?

2054
01:44:27,500 --> 01:44:29,000
That's that's the stupidest possible.

2055
01:44:29,000 --> 01:44:33,100
Early decompressor, could have all we're doing right.

2056
01:44:33,800 --> 01:44:36,000
Is in fact, I can even make this even simpler.

2057
01:44:36,000 --> 01:44:38,000
We don't even need in at at all right.

2058
01:44:38,000 --> 01:44:43,200
I could just say that the the end of the input is just the start of

2059
01:44:43,200 --> 01:44:46,600
the input, plus the size you told me and then I can just say keep

2060
01:44:46,600 --> 01:44:52,500
reading until in, you know, in as long as in

2061
01:44:52,700 --> 01:44:56,300
In is less than in end then we're still reading.

2062
01:44:56,500 --> 01:44:57,000
Right?

2063
01:44:57,200 --> 01:44:59,900
And assuming this was a well form stream, we're not really doing.

2064
01:45:00,000 --> 01:45:02,400
anything, we're not being, you know,

2065
01:45:05,400 --> 01:45:06,600
We're not being robust here.

2066
01:45:06,600 --> 01:45:09,700
So this is easy code to crash certainly by feeding it that data.

2067
01:45:10,500 --> 01:45:14,800
But you know, let's just start anyway for our own purposes at the end

2068
01:45:14,900 --> 01:45:18,400
that we actually consumed the right amount of input, right?

2069
01:45:18,600 --> 01:45:20,100
But there is our decompressor, right?

2070
01:45:20,100 --> 01:45:21,600
Very very simple read.

2071
01:45:21,600 --> 01:45:25,600
In how many things to copy copy that many read in how many things to

2072
01:45:25,600 --> 01:45:28,700
replicate replicate and then if we haven't hit the end of the data,

2073
01:45:28,800 --> 01:45:29,400
keep going.

2074
01:45:30,400 --> 01:45:30,700
Right.

2075
01:45:32,000 --> 01:45:35,500
Okay so off we go.

2076
01:45:35,800 --> 01:45:43,400
So every time we get a sort of a run or anything like this or literals

2077
01:45:43,400 --> 01:45:47,900
or anything like that, we always have to encode a pair, right?

2078
01:45:47,900 --> 01:45:52,500
So we're always in coding, a pair of literals and we're always

2079
01:45:52,500 --> 01:45:57,600
encoding some number of Liberty literals and some number of cop of

2080
01:45:57,600 --> 01:45:58,900
replications, right?

2081
01:45:58,900 --> 01:46:01,300
That's just how we've defined this and I'm not even saying that's a

2082
01:46:01,300 --> 01:46:02,000
good way to do it.

2083
01:46:02,000 --> 01:46:02,400
Right?

2084
01:46:02,500 --> 01:46:04,800
I'm not saying this is a good are LED compressor.

2085
01:46:04,800 --> 01:46:07,900
I'm just saying here's a gnarly compressor, right?

2086
01:46:07,900 --> 01:46:11,100
Because another way to do it would be to have these be B coated.

2087
01:46:11,200 --> 01:46:15,800
So, like, for example, we use one bit in the, in this value to say,

2088
01:46:15,800 --> 01:46:20,100
whether it's a run or a copy or whatever, right?

2089
01:46:21,500 --> 01:46:22,300
We're not gonna do that.

2090
01:46:23,200 --> 01:46:26,000
So, what we do is we say, all right values, come in.

2091
01:46:26,100 --> 01:46:27,400
We see how many there are.

2092
01:46:27,700 --> 01:46:29,900
If what we're on is a run.

2093
01:46:30,200 --> 01:46:31,900
Then we need to encode the Run.

2094
01:46:31,900 --> 01:46:34,300
Otherwise, we just buffer the literals, right?

2095
01:46:34,700 --> 01:46:38,800
And so, all I'm going to do here is actually have this be the encode

2096
01:46:39,300 --> 01:46:39,700
flush.

2097
01:46:39,700 --> 01:46:41,600
Basically, I'm just is going to be the thing that actually does the

2098
01:46:41,600 --> 01:46:42,200
encoding.

2099
01:46:42,700 --> 01:46:45,900
So what I need to do is I need to match whatever I was doing in this

2100
01:46:45,900 --> 01:46:46,900
output, right?

2101
01:46:47,000 --> 01:46:50,000
So I need to do a thing that basically says, alright, the output

2102
01:46:52,800 --> 01:46:54,900
Is going to literally be exactly this thing.

2103
01:46:55,400 --> 01:46:56,700
So, I need to

2104
01:47:07,800 --> 01:47:09,100
Maybe I'll do a little index.

2105
01:47:13,300 --> 01:47:17,600
I need to go over my buffer and I need to Output it, right?

2106
01:47:17,600 --> 01:47:20,800
So what I would do is I'd say let's output the literal account,

2107
01:47:20,800 --> 01:47:24,100
however, many literal literals there were and then I need to

2108
01:47:26,900 --> 01:47:31,400
I'll put the literals, I know once I've done that, my literal count

2109
01:47:31,400 --> 01:47:37,000
will be 0 because there's nothing left in the buffer, and then I need

2110
01:47:37,000 --> 01:47:37,900
to Output my run.

2111
01:47:38,000 --> 01:47:41,300
So then I say, okay, whatever the Run length is, is the run.

2112
01:47:41,400 --> 01:47:44,300
And the starting value, I know, is whatever the starting value is

2113
01:47:44,300 --> 01:47:45,400
right here, right?

2114
01:47:52,000 --> 01:47:52,500
Right.

2115
01:47:54,700 --> 01:47:55,500
So that's it.

2116
01:47:56,000 --> 01:47:59,100
That's all I have to do there and then encoding literals, I just kind

2117
01:47:59,100 --> 01:47:59,500
of go ahead.

2118
01:48:00,000 --> 01:48:00,500
Little scent.

2119
01:48:00,500 --> 01:48:03,400
Now there's one more thing we have to deal with here but yeah that's

2120
01:48:03,400 --> 01:48:04,300
basically the way it goes.

2121
01:48:04,500 --> 01:48:10,000
Okay, so let's go ahead and deal with are at handling here are at

2122
01:48:10,000 --> 01:48:10,900
handling like kind of.

2123
01:48:10,900 --> 01:48:15,500
As we're going through our in buffer, basically, when we look at these

2124
01:48:15,500 --> 01:48:16,100
runs

2125
01:48:18,500 --> 01:48:22,100
When we're kind of looking at how how far we've gone, run wise, all we

2126
01:48:22,100 --> 01:48:26,400
want to do there is say, well, okay, if we encoded a run, then we

2127
01:48:26,400 --> 01:48:29,300
obviously moved that far in the input.

2128
01:48:29,400 --> 01:48:33,700
If we encoded a literal, we only moved one right.

2129
01:48:34,100 --> 01:48:35,000
Does that make sense?

2130
01:48:35,900 --> 01:48:39,200
So we want to kind of Advance the input differently depending on which

2131
01:48:39,200 --> 01:48:40,100
one we did here.

2132
01:48:40,500 --> 01:48:44,000
Okay, so there's one more thing we have to take care of here and that

2133
01:48:44,000 --> 01:48:46,800
is that we don't have unlimited size, right?

2134
01:48:46,800 --> 01:48:48,000
When we go tear or two,

2135
01:48:48,700 --> 01:48:49,600
Encode a literal.

2136
01:48:49,600 --> 01:48:53,200
We can only actually encode a literal if there's room left in the

2137
01:48:53,200 --> 01:48:53,900
literal buffer.

2138
01:48:54,200 --> 01:48:56,500
So when we're going to encode a run,

2139
01:48:57,700 --> 01:49:00,700
really, what we mean here is, we need to out, we need to flush the

2140
01:49:00,700 --> 01:49:01,600
literal buffer.

2141
01:49:02,900 --> 01:49:05,200
Both in the case, where we want to encode a run.

2142
01:49:06,200 --> 01:49:10,500
And in the case, we have no space left even if there is no run, right?

2143
01:49:11,300 --> 01:49:14,900
So, what we want to do here is say more like, well, if the run is

2144
01:49:14,900 --> 01:49:21,900
greater than whatever, our run length value is or the literal count is

2145
01:49:21,900 --> 01:49:25,200
equal to the max literal count, because we couldn't put a single more,

2146
01:49:25,600 --> 01:49:29,200
one more, we couldn't fit anymore in the buffer, we have to flush,

2147
01:49:29,600 --> 01:49:30,400
then off again.

2148
01:49:33,000 --> 01:49:34,200
Hopefully, that makes some sense.

2149
01:49:35,000 --> 01:49:37,800
I'll cannot go over it one more time in case it doesn't.

2150
01:49:37,800 --> 01:49:38,300
But anyway,

2151
01:49:39,900 --> 01:49:42,100
So, in this case, again, we have to Output the little cap.

2152
01:49:42,300 --> 01:49:47,000
What we want to do here is probably a cert if the literal counts, I

2153
01:49:47,000 --> 01:49:47,700
guess we could say.

2154
01:49:47,700 --> 01:49:54,100
Like, literal count, eight equals, uh, literal count and then just

2155
01:49:54,100 --> 01:49:57,800
assert that literal count, eight equals literal count, like meaning

2156
01:49:57,900 --> 01:49:59,800
guarantee that we can fit it in the space.

2157
01:49:59,800 --> 01:50:01,900
We're actually trying to fit it, right.

2158
01:50:04,400 --> 01:50:08,600
We go and then the same thing would be true for the Run length, right?

2159
01:50:08,700 --> 01:50:09,400
Same thing here.

2160
01:50:09,700 --> 01:50:10,600
Drooping around length.

2161
01:50:10,900 --> 01:50:12,300
Run 8, equals U 8.

2162
01:50:13,500 --> 01:50:17,100
Run assert, run eight.

2163
01:50:18,100 --> 01:50:18,600
Let's run.

2164
01:50:20,800 --> 01:50:21,200
Right.

2165
01:50:27,700 --> 01:50:28,800
I guess it's just a buffer.

2166
01:50:28,800 --> 01:50:29,300
Literals

2167
01:50:30,800 --> 01:50:33,200
All right, so last thing we have to do again.

2168
01:50:33,200 --> 01:50:36,300
So this this part right here is designed to make sure that hey, we can

2169
01:50:36,300 --> 01:50:39,600
only store a value from 0 to 255 for how many literals are, so we

2170
01:50:39,600 --> 01:50:44,600
can't go above that number and similarly, exact.

2171
01:50:44,600 --> 01:50:48,000
Same thing is true for a run, so if you take a look at what happens

2172
01:50:48,000 --> 01:50:51,900
here, we've got this run is less than in sighs - at that's assuming we

2173
01:50:51,900 --> 01:50:55,000
can get to the end of the buffer, but we can't necessarily get to the

2174
01:50:55,000 --> 01:50:59,600
in the buffer because we could only encode a run of 255 at maximum.

2175
01:51:00,000 --> 01:51:01,800
So we can, we can adjust this value.

2176
01:51:01,800 --> 01:51:04,100
I'm going to be lazy and not even bother adjusting that value.

2177
01:51:04,100 --> 01:51:09,100
I'm just going to say and the run is less than Max run count, right?

2178
01:51:09,400 --> 01:51:16,400
Which again, is exactly the same Max, run, count to five and on this

2179
01:51:16,400 --> 01:51:18,100
is a less than or equal to their, right?

2180
01:51:18,100 --> 01:51:20,100
Because we could actually encode 255.

2181
01:51:21,300 --> 01:51:25,000
So then we'll come in here and just undef those two next one.

2182
01:51:25,900 --> 01:51:28,200
Okay, so there you go.

2183
01:51:28,200 --> 01:51:29,800
And that's just again to

2184
01:51:30,000 --> 01:51:31,900
Make it so that we don't end up with a value.

2185
01:51:31,900 --> 01:51:33,300
That's too big for us, right?

2186
01:51:34,400 --> 01:51:37,600
So hey yeah, I did I type that in extremely quickly.

2187
01:51:37,600 --> 01:51:38,400
Yes, I did.

2188
01:51:38,700 --> 01:51:42,100
So, you know probably got some bugs in there somewhere but let's just

2189
01:51:42,100 --> 01:51:46,400
go ahead and sort of take a look at how that's working in the

2190
01:51:46,400 --> 01:51:46,700
debugger.

2191
01:51:46,700 --> 01:51:52,400
So I'm going to open up Ms, Dev on simple compressor, .exe.

2192
01:51:55,700 --> 01:52:00,500
Give it a second because as we know Visual Studio takes many years to

2193
01:52:00,500 --> 01:52:03,300
load, it has to do all kinds of wonderful things.

2194
01:52:03,300 --> 01:52:05,000
I'm sure they're really important.

2195
01:52:05,700 --> 01:52:09,100
So let's go ahead and open up the properties for simple compressor.

2196
01:52:09,500 --> 01:52:12,500
Here, the X computer the executable, we need to pass it.

2197
01:52:13,100 --> 01:52:15,300
That information that we were passing it before, right?

2198
01:52:15,300 --> 01:52:21,200
We need to give it a valid compression rule, whereas that not

2199
01:52:21,200 --> 01:52:21,800
decompress.

2200
01:52:21,800 --> 01:52:23,600
I want compress, there we go.

2201
01:52:24,700 --> 01:52:25,100
Okay.

2202
01:52:26,400 --> 01:52:28,400
And so paste those in there.

2203
01:52:31,700 --> 01:52:36,000
So you want to pass compress and these two values, we want to be in

2204
01:52:36,000 --> 01:52:36,600
the bill directory.

2205
01:52:36,600 --> 01:52:37,800
That's where we were doing this.

2206
01:52:37,800 --> 01:52:38,800
So that's fine too.

2207
01:52:39,400 --> 01:52:41,500
So let's go ahead and step into this, right.

2208
01:52:41,500 --> 01:52:42,700
Let's go ahead and see how this works.

2209
01:52:43,100 --> 01:52:45,200
So it's exactly all this stuff is kind of wrote.

2210
01:52:45,200 --> 01:52:47,000
You've seen it many times before so we're going to go through.

2211
01:52:47,000 --> 01:52:50,500
We say, okay, what's the command the command in this case is compress,

2212
01:52:50,500 --> 01:52:51,100
right?

2213
01:52:51,400 --> 01:52:52,700
So let's load everything in.

2214
01:52:53,700 --> 01:52:55,000
I didn't mean to go that far.

2215
01:52:55,500 --> 01:52:56,800
Don't mean to go that far.

2216
01:52:57,000 --> 01:53:00,300
Stop meant to jump in here.

2217
01:53:03,900 --> 01:53:04,600
So here we go.

2218
01:53:04,600 --> 01:53:06,200
We start out in the compressor.

2219
01:53:06,200 --> 01:53:08,800
And now we have to go ahead and it looks like we had a bug there.

2220
01:53:08,800 --> 01:53:12,100
So I know we're going to get to debug this thing, but I just want to

2221
01:53:12,100 --> 01:53:12,800
kind of Step through it.

2222
01:53:12,800 --> 01:53:15,700
First wants to kind of see how we were doing with it, right?

2223
01:53:19,000 --> 01:53:22,400
Yeah, this one could actually also be done exactly the same way to

2224
01:53:22,400 --> 01:53:23,200
decompress with the fact.

2225
01:53:23,200 --> 01:53:26,100
I might go ahead and just do that because might as well have them look

2226
01:53:26,100 --> 01:53:27,200
a little bit more symmetric.

2227
01:53:27,500 --> 01:53:30,300
That's basically like this sort of thing.

2228
01:53:44,500 --> 01:53:50,300
So that's basically just again like we just always want to read from

2229
01:53:50,500 --> 01:53:52,000
that particular location.

2230
01:53:52,000 --> 01:53:58,300
So in this case, we can sort of, we can take our rats there and we can

2231
01:53:58,300 --> 01:53:59,800
just use just the actual

2232
01:54:00,000 --> 01:54:01,900
Station without having to do this, right?

2233
01:54:02,100 --> 01:54:05,300
So we can basically just say like, all right, the starting value is

2234
01:54:05,300 --> 01:54:08,800
always going to be, you know, wherever we are within, right?

2235
01:54:08,800 --> 01:54:13,600
So this is in 0, and then here, we're just going to be looking ahead,

2236
01:54:13,700 --> 01:54:16,900
run, you know, run numbers of things.

2237
01:54:18,000 --> 01:54:21,500
And and then when we actually increment will just increment the actual

2238
01:54:21,500 --> 01:54:23,000
in pointer, right?

2239
01:54:23,500 --> 01:54:25,300
So that seems reasonable

2240
01:54:28,300 --> 01:54:28,600
Okay.

2241
01:54:28,800 --> 01:54:31,500
And so then again this also becomes just a subtraction where it's

2242
01:54:31,500 --> 01:54:33,800
like, hey make sure we're not looking at the end of the buffer.

2243
01:54:37,200 --> 01:54:42,600
What are you complaining about, which one are you complaining about

2244
01:54:42,600 --> 01:54:50,200
signed, unsigned mismatch, okay, is that because size?

2245
01:54:50,200 --> 01:54:51,700
T is unsigned.

2246
01:54:51,800 --> 01:54:55,800
I guess it's okay because we know these things should never invert.

2247
01:54:56,900 --> 01:55:00,700
But yes, all right, so let's go ahead and go in here.

2248
01:55:04,000 --> 01:55:04,800
So here we go.

2249
01:55:05,400 --> 01:55:08,300
And let's just take a look at where we are in value.

2250
01:55:08,500 --> 01:55:10,700
So, here's some information.

2251
01:55:11,400 --> 01:55:14,800
So it just so happens that the first bite happens to be replicated,

2252
01:55:14,900 --> 01:55:15,200
right?

2253
01:55:15,200 --> 01:55:19,700
Because HAF, that's actually the data in our HHA file.

2254
01:55:19,700 --> 01:55:22,200
Remember, that was, I guess, what was actually there.

2255
01:55:22,600 --> 01:55:23,700
And then there were some zeros.

2256
01:55:23,900 --> 01:55:27,900
Let's take a look in memory actually, so we can actually see what this

2257
01:55:27,900 --> 01:55:28,400
is.

2258
01:55:28,900 --> 01:55:29,500
There you go.

2259
01:55:30,300 --> 01:55:32,700
So you can see the HF and then there's some zeros and other

2260
01:55:32,700 --> 01:55:33,200
information.

2261
01:55:33,200 --> 01:55:33,700
This is the

2262
01:55:33,900 --> 01:55:35,100
Stuff for actually compressing.

2263
01:55:36,000 --> 01:55:37,600
So hey it looks like the first thing.

2264
01:55:37,600 --> 01:55:39,100
There is actually a run count of two.

2265
01:55:39,300 --> 01:55:44,700
Now we break out of here because the next thing is an A so we could we

2266
01:55:44,700 --> 01:55:49,500
could encode the H as a run of 2 but we cant encode the a as a run so

2267
01:55:49,500 --> 01:55:51,400
that would have to switch to a literal, right?

2268
01:55:52,400 --> 01:55:55,000
Alright, so off we go, we look in here and right now we're in coding

2269
01:55:55,000 --> 01:55:59,100
runs of any length, right just as a test and we'll talk about that

2270
01:55:59,100 --> 01:55:59,500
later.

2271
01:55:59,500 --> 01:56:03,600
But you know, if you think about it, a run of too long might not be

2272
01:56:03,600 --> 01:56:03,700
worth.

2273
01:56:03,800 --> 01:56:06,700
With encoding because it requires a flush of the literal buffer.

2274
01:56:06,700 --> 01:56:09,800
And you didn't save any space because you had to encode the count for

2275
01:56:09,800 --> 01:56:10,600
the run as well.

2276
01:56:10,600 --> 01:56:14,000
So, you know that number might be more like for, let's say to actually

2277
01:56:14,000 --> 01:56:15,900
talk about more optimal encoding.

2278
01:56:15,900 --> 01:56:18,400
But anyway, ignoring that for a second, here we come in.

2279
01:56:18,700 --> 01:56:20,300
We take a look at the literal count,

2280
01:56:21,500 --> 01:56:22,500
And we see that it's zero.

2281
01:56:23,200 --> 01:56:27,500
So we store that 0 as the output right and then we don't actually

2282
01:56:27,500 --> 01:56:29,500
encode any literals because hey there was nothing in the buffer.

2283
01:56:30,000 --> 01:56:34,500
We then say hey there's a run count of two so we output that run count

2284
01:56:34,500 --> 01:56:37,100
of 2 and then we output the value.

2285
01:56:37,100 --> 01:56:40,400
We're actually trying to do, which is the H we then move forward by

2286
01:56:40,400 --> 01:56:42,700
two things in the input because we consume those.

2287
01:56:42,700 --> 01:56:44,800
So, now we're on the, the AF, right?

2288
01:56:45,300 --> 01:56:46,900
And then we go back to the beginning.

2289
01:56:48,100 --> 01:56:49,700
Again, in this case, there's no run.

2290
01:56:49,700 --> 01:56:51,000
It's just an A, so,

2291
01:56:51,200 --> 01:56:54,400
we buffer up the A and we say in our literal buffer and we can see

2292
01:56:54,400 --> 01:56:58,700
that getting an extra thing here you can see the a there it adds that

2293
01:56:58,700 --> 01:56:59,800
a to the literal buffer and

2294
01:57:00,000 --> 01:57:01,500
Got a literal count of one.

2295
01:57:01,500 --> 01:57:01,800
Now.

2296
01:57:03,400 --> 01:57:03,900
Right?

2297
01:57:04,700 --> 01:57:07,300
We advance the input by one because now we've consumed that literal

2298
01:57:07,300 --> 01:57:12,400
and we start again right there, we buffer another one and and we just

2299
01:57:12,400 --> 01:57:13,000
keep going.

2300
01:57:13,300 --> 01:57:15,700
Now there's some zeros right there was a bunch of zeros.

2301
01:57:15,700 --> 01:57:19,400
40's we say oh okay let's take a look at the literal Count, Their the

2302
01:57:19,400 --> 01:57:20,300
literal count.

2303
01:57:22,000 --> 01:57:23,300
In this case is 4.

2304
01:57:23,900 --> 01:57:24,500
So

2305
01:57:27,000 --> 01:57:27,500
Wait.

2306
01:57:28,400 --> 01:57:29,200
Oh no.

2307
01:57:31,400 --> 01:57:31,700
Oh wait.

2308
01:57:31,700 --> 01:57:32,100
No, that's fine.

2309
01:57:32,100 --> 01:57:32,800
That's a literal count.

2310
01:57:32,800 --> 01:57:33,200
Never mind.

2311
01:57:33,200 --> 01:57:34,100
I was like what's going on now?

2312
01:57:34,100 --> 01:57:35,100
The little count, that's fine.

2313
01:57:35,400 --> 01:57:38,300
So we encode the to then we encode the two literals, right?

2314
01:57:38,700 --> 01:57:41,800
There's the first one, there's the second one, and then we reset the

2315
01:57:41,800 --> 01:57:43,800
little counter 0, so that's what we want.

2316
01:57:44,000 --> 01:57:47,000
We then look at the run count, which is for we encode that run count

2317
01:57:47,000 --> 01:57:49,200
of four and we would encode the starting value.

2318
01:57:51,400 --> 01:57:52,700
Of 0, right?

2319
01:57:52,800 --> 01:57:55,200
Because it's just a 0 that were copied.

2320
01:57:55,600 --> 01:57:58,200
We then Advance the input to skip all the zeros and we get to the next

2321
01:57:58,200 --> 01:58:00,000
thing and off we go.

2322
01:58:00,200 --> 01:58:00,800
Right?

2323
01:58:01,200 --> 01:58:03,400
So now let's see where we were getting the problem.

2324
01:58:03,600 --> 01:58:06,400
We hit an assertion, I'm assuming it's this one, but it could be

2325
01:58:06,400 --> 01:58:07,200
another one of these in here.

2326
01:58:07,200 --> 01:58:08,100
Let's see which one it is.

2327
01:58:08,800 --> 01:58:10,300
We provided to bug.

2328
01:58:11,500 --> 01:58:13,100
What is this?

2329
01:58:15,100 --> 01:58:17,100
Where are we in the call stack?

2330
01:58:17,200 --> 01:58:18,000
Early compress

2331
01:58:20,700 --> 01:58:26,300
So it looks like we ended up with a run value of 256 so oh, that's

2332
01:58:26,300 --> 01:58:26,700
good.

2333
01:58:26,900 --> 01:58:28,000
Yeah, that was a mistake.

2334
01:58:28,200 --> 01:58:30,100
That's just a really simple mistake.

2335
01:58:30,100 --> 01:58:33,400
So this run count here, you can see, I did a less than or equal to

2336
01:58:33,700 --> 01:58:36,400
maximum count and I was dumb, it wasn't letting you go because we're

2337
01:58:36,400 --> 01:58:39,500
about to increment the value and we can't increment the value once it

2338
01:58:39,500 --> 01:58:41,200
hits 255, right?

2339
01:58:41,500 --> 01:58:42,900
So that's actually wrong.

2340
01:58:43,800 --> 01:58:44,300
That's good.

2341
01:58:44,300 --> 01:58:45,000
Thank you mr.

2342
01:58:45,000 --> 01:58:48,000
Assertion for catching that for us.

2343
01:58:48,300 --> 01:58:48,700
There we go.

2344
01:58:50,600 --> 01:58:51,700
Let's try that one more time.

2345
01:58:55,400 --> 01:58:58,100
And so here's our output size 0, right?

2346
01:58:58,100 --> 01:59:01,100
And our output size we need to actually compute that

2347
01:59:03,300 --> 01:59:04,900
Again, this is best done with pointers.

2348
01:59:05,200 --> 01:59:10,500
So what we can do here is we can say oh let's just remember where we

2349
01:59:10,500 --> 01:59:15,000
start, and we'll just do our output so that the end we can say instead

2350
01:59:15,000 --> 01:59:18,600
of like tracking the output size, which we don't want to have to keep

2351
01:59:18,600 --> 01:59:19,800
an extra thing around.

2352
01:59:19,900 --> 01:59:24,800
Let's just say, okay, we'll take the output size of the output size

2353
01:59:25,200 --> 01:59:30,600
will be equal to the out, wherever we were in the output - the out

2354
01:59:30,600 --> 01:59:30,900
base.

2355
01:59:30,900 --> 01:59:32,600
And then, we'll also assert that the

2356
01:59:33,100 --> 01:59:35,700
Is less than or equal to the max that size.

2357
01:59:36,800 --> 01:59:39,300
So, we didn't overrun the buffer because that just means we have a

2358
01:59:39,300 --> 01:59:40,600
bug, right?

2359
01:59:41,500 --> 01:59:41,700
All right.

2360
01:59:41,700 --> 01:59:42,900
So let's go ahead and run it.

2361
01:59:43,200 --> 01:59:44,100
We ran it.

2362
01:59:44,500 --> 01:59:46,800
And that's actually doing our compression.

2363
01:59:47,300 --> 01:59:52,500
So here you can see the actual results of the compression, right?

2364
01:59:53,000 --> 01:59:57,800
And it looks like, wait, there's no way that could be right.

2365
01:59:57,800 --> 01:59:59,000
It couldn't possibly have.

2366
02:00:00,200 --> 02:00:05,300
Hold on a second, couldn't possibly have outputted the exact same size

2367
02:00:05,500 --> 02:00:06,900
with a totally different compressor.

2368
02:00:06,900 --> 02:00:07,500
Could it have?

2369
02:00:09,900 --> 02:00:16,800
Are we not using the output size accidentally compressed size, plus 4?

2370
02:00:18,600 --> 02:00:20,500
Looks like we are, is that really true?

2371
02:00:20,500 --> 02:00:22,000
Let's take a look what happened there.

2372
02:00:23,100 --> 02:00:24,400
Compressed size.

2373
02:00:26,300 --> 02:00:27,100
How is that?

2374
02:00:27,300 --> 02:00:29,600
Okay, am I am I nuts?

2375
02:00:30,400 --> 02:00:31,800
I must have done something stupid.

2376
02:00:34,700 --> 02:00:38,300
It seems impossible couldn't happen to end up at exactly the same.

2377
02:00:38,600 --> 02:00:40,000
That's that's insane.

2378
02:00:40,000 --> 02:00:40,900
There's just no way.

2379
02:00:42,700 --> 02:00:45,100
This is one of those like hey I'm on stream so I'm not paying close

2380
02:00:45,100 --> 02:00:45,700
enough attention.

2381
02:00:45,700 --> 02:00:47,700
Kind of things got to be right.

2382
02:00:50,000 --> 02:00:53,500
So there's the output size right out - out base.

2383
02:00:54,700 --> 02:00:58,300
So let's see here in size out sighs.

2384
02:00:58,800 --> 02:01:02,700
So the in size and the outside eyes are like, no, we're closed, right?

2385
02:01:02,700 --> 02:01:05,400
They're not even remotely, similar to each other, right?

2386
02:01:05,500 --> 02:01:06,000
Okay.

2387
02:01:06,000 --> 02:01:07,500
So we're going to return that value.

2388
02:01:10,700 --> 02:01:11,400
Right.

2389
02:01:13,300 --> 02:01:16,100
Yeah, when I did my forwarding I forgot to actually

2390
02:01:19,000 --> 02:01:20,000
Use the value.

2391
02:01:28,300 --> 02:01:31,700
Okay, now we're a little bit better there.

2392
02:01:32,100 --> 02:01:34,400
All right, so okay.

2393
02:01:34,400 --> 02:01:36,100
Now if I actually run this

2394
02:01:39,000 --> 02:01:40,400
We have our compressed output.

2395
02:01:40,400 --> 02:01:43,800
You can see now that it's much much smaller, right?

2396
02:01:43,900 --> 02:01:47,500
It's about a tenth the size so that's great.

2397
02:01:47,700 --> 02:01:49,900
And now the question is well did it work?

2398
02:01:50,100 --> 02:01:50,700
Right.

2399
02:01:50,900 --> 02:01:54,500
And so let me delete test one that out here.

2400
02:01:55,200 --> 02:02:00,400
So there's our HHA again it's one point five mags, we went down 2.2

2401
02:02:00,400 --> 02:02:04,200
mags, little less than so that's great.

2402
02:02:04,400 --> 02:02:06,200
But one point.

2403
02:02:06,500 --> 02:02:08,300
Well, you can see the numbers yourself.

2404
02:02:08,300 --> 02:02:08,500
I wouldn't

2405
02:02:08,600 --> 02:02:10,400
Right to English, translate them.

2406
02:02:11,200 --> 02:02:14,600
So if we go ahead and write simple compressor, and we do decompress,

2407
02:02:14,600 --> 02:02:15,100
right?

2408
02:02:15,600 --> 02:02:18,800
Then I take my test one that SCP and my test one doubt.

2409
02:02:18,800 --> 02:02:21,900
And now it does the decompression and oh, and good.

2410
02:02:21,900 --> 02:02:23,300
And my decompressor doesn't work at all.

2411
02:02:23,300 --> 02:02:24,400
So that's always good.

2412
02:02:24,600 --> 02:02:29,100
So maybe now's a good time to switch over to actually to bug the

2413
02:02:29,100 --> 02:02:29,900
decompressor.

2414
02:02:31,300 --> 02:02:32,300
Hold on for a second.

2415
02:02:33,200 --> 02:02:35,500
So let me go ahead and switch to the decompressor.

2416
02:02:36,200 --> 02:02:41,100
So let's do decompress test one that is CP to test one.

2417
02:02:41,200 --> 02:02:42,100
Got out.

2418
02:02:42,400 --> 02:02:44,400
There we go, right.

2419
02:02:46,900 --> 02:02:50,500
Let's step in there and let's go ahead and take a look here.

2420
02:02:50,500 --> 02:02:52,900
So we step over to the file size with a look at the output buffer

2421
02:02:52,900 --> 02:02:53,500
size.

2422
02:02:56,800 --> 02:02:58,500
That's not right at all.

2423
02:02:58,500 --> 02:02:58,900
Ah,

2424
02:03:00,400 --> 02:03:01,300
That's another bug.

2425
02:03:02,900 --> 02:03:05,500
You can always find bugs when you step through your code.

2426
02:03:06,500 --> 02:03:10,100
So I said I was going to store the output size in here but I didn't do

2427
02:03:10,100 --> 02:03:11,000
that, right?

2428
02:03:11,300 --> 02:03:12,900
So I need to store.

2429
02:03:13,300 --> 02:03:16,500
This is I stored how big the file was when we don't need to store how

2430
02:03:16,500 --> 02:03:17,100
big the file was.

2431
02:03:17,100 --> 02:03:18,500
We already know how big the file was.

2432
02:03:18,600 --> 02:03:22,500
I need to store how big the original file was, so that's supposed to

2433
02:03:22,500 --> 02:03:22,900
look.

2434
02:03:23,600 --> 02:03:24,900
Oh, sorry about that.

2435
02:03:29,800 --> 02:03:33,100
I need to store this piece of information.

2436
02:03:33,100 --> 02:03:37,200
I need to store how big we're going to produce, not how big we ended

2437
02:03:37,200 --> 02:03:38,000
up being.

2438
02:03:38,300 --> 02:03:42,400
So that's just a compressor bug or rather, the wrapper for the

2439
02:03:42,400 --> 02:03:44,300
compressor was just wrong.

2440
02:03:45,100 --> 02:03:47,000
All right, so let's try a simple compressor.

2441
02:03:47,900 --> 02:03:54,300
Test one that ha to test the CP will do compress.

2442
02:03:56,700 --> 02:04:00,800
There we go, and then we'll do simple.

2443
02:04:01,200 --> 02:04:09,000
Presser decompress test one that is CP test1 dot out and we're still

2444
02:04:09,000 --> 02:04:09,500
not good.

2445
02:04:09,700 --> 02:04:12,400
Okay, let's try this one more time out, buffer size.

2446
02:04:12,700 --> 02:04:15,300
Now the app, buffer size weight, that's still wrong.

2447
02:04:19,200 --> 02:04:20,400
Did I did I not come?

2448
02:04:20,600 --> 02:04:21,500
We compile that

2449
02:04:23,800 --> 02:04:24,800
what just happened?

2450
02:04:42,300 --> 02:04:47,500
Well, I thought we wrote to the out buffer.

2451
02:04:52,600 --> 02:04:54,000
Oh god, wow.

2452
02:04:54,000 --> 02:04:58,100
How many you know the type of situation here is is interesting.

2453
02:04:59,500 --> 02:05:00,600
Supposed to be file size.

2454
02:05:00,700 --> 02:05:02,000
I need to pay closer attention here.

2455
02:05:02,400 --> 02:05:03,700
Let's try this one more time.

2456
02:05:24,500 --> 02:05:27,700
Okay, so I'm going to step in here and see what actually happened.

2457
02:05:28,000 --> 02:05:30,900
Okay, so we go ahead and we do our compressor, we produce the

2458
02:05:30,900 --> 02:05:34,000
compressed size which is this, we have the in file file size which is

2459
02:05:34,000 --> 02:05:36,900
that and I'm trying to write to the output buffer which is what I'm

2460
02:05:36,900 --> 02:05:38,000
going to Output here.

2461
02:05:38,000 --> 02:05:39,600
Is my output buffer.

2462
02:05:40,900 --> 02:05:41,500
Right.

2463
02:05:43,900 --> 02:05:48,000
And let's just see what the size is that we actually stuck in there.

2464
02:05:48,200 --> 02:05:50,400
So there's what's in the output buffer right now?

2465
02:05:50,400 --> 02:05:52,200
Which I believe it should just be garbage, right?

2466
02:05:52,200 --> 02:05:54,300
Because we didn't actually write anything to it, yet.

2467
02:05:54,300 --> 02:05:57,700
We right in there and there's our actual value, 1.5 MB, which is what

2468
02:05:57,700 --> 02:05:58,500
we want.

2469
02:05:58,600 --> 02:05:59,800
And we basically say that the output

2470
02:06:00,000 --> 02:06:04,900
Is what, you know what we used plus the four byte header bit there and

2471
02:06:04,900 --> 02:06:08,500
then we say the output buffer is the is the out buffer, right?

2472
02:06:08,700 --> 02:06:11,700
So here we come into final output buffer and we're going to write this

2473
02:06:11,700 --> 02:06:12,200
thing.

2474
02:06:12,500 --> 02:06:15,800
So we should be able to verify that the exact same thing as in there.

2475
02:06:15,800 --> 02:06:20,000
So here's final output buffer, right there it is and then we go ahead

2476
02:06:20,000 --> 02:06:21,200
and do our F, right?

2477
02:06:21,400 --> 02:06:24,300
I should I should have probably check that return value but it didn't.

2478
02:06:24,600 --> 02:06:25,400
So that's fine.

2479
02:06:25,400 --> 02:06:26,000
We're get.

2480
02:06:26,800 --> 02:06:27,100
You can see.

2481
02:06:27,100 --> 02:06:28,300
We actually did return it there.

2482
02:06:30,200 --> 02:06:31,000
Or x to the F right.

2483
02:06:31,000 --> 02:06:32,100
Looks like it's seated.

2484
02:06:32,500 --> 02:06:34,400
And so, then we're done, right?

2485
02:06:34,500 --> 02:06:39,000
And that should have written to our our output file, right?

2486
02:06:40,100 --> 02:06:43,200
Then if I step in here for the

2487
02:06:45,200 --> 02:06:46,200
The decompress.

2488
02:06:47,500 --> 02:06:47,900
Right?

2489
02:06:47,900 --> 02:06:49,100
Which I should be able to do.

2490
02:06:50,100 --> 02:06:54,400
Let's go ahead and, you know, I should have a decompressed.

2491
02:06:54,500 --> 02:06:56,700
I should have something that does decompression and compression so I

2492
02:06:56,700 --> 02:06:57,600
don't have to keep doing it.

2493
02:06:58,000 --> 02:06:59,900
I have to type keep typing these things in

2494
02:07:02,700 --> 02:07:03,200
but,

2495
02:07:04,400 --> 02:07:07,800
So, we do, if I step into the decompress and now I do like all right,

2496
02:07:07,800 --> 02:07:14,000
if anybody can press the, the content should show me here and there it

2497
02:07:14,000 --> 02:07:14,300
is.

2498
02:07:14,300 --> 02:07:16,000
All right, so I don't know why that was working before.

2499
02:07:16,000 --> 02:07:19,600
I guess I must not have actually compiled or something like this, but

2500
02:07:19,600 --> 02:07:23,400
I must not have actually run it properly, but, alright, so there we

2501
02:07:23,400 --> 02:07:23,700
go.

2502
02:07:23,700 --> 02:07:25,300
And now our decompressor works just fine.

2503
02:07:25,300 --> 02:07:26,200
That we actually pass it.

2504
02:07:26,200 --> 02:07:31,100
The correct size and then we have our output buffer and we write it,

2505
02:07:31,300 --> 02:07:31,700
okay?

2506
02:07:32,100 --> 02:07:33,900
All right so don't know what I did wrong there but

2507
02:07:34,100 --> 02:07:37,800
It's something wrong in terms of running the program, not in, not the

2508
02:07:37,800 --> 02:07:38,600
program itself.

2509
02:07:39,300 --> 02:07:40,500
And so, let's see what we got.

2510
02:07:40,800 --> 02:07:44,200
So here's our test 10th, a, here's our test of one dot out and now I

2511
02:07:44,200 --> 02:07:45,800
should be able to do our wind if no.

2512
02:07:45,800 --> 02:07:49,200
I don't know why I can't run wind, if it's not in the path, I guess.

2513
02:07:49,200 --> 02:07:52,900
So, let's just take a look at where it actually is, okay.

2514
02:07:52,900 --> 02:07:53,600
So it's in

2515
02:07:55,200 --> 02:07:56,600
This longest path here.

2516
02:08:08,400 --> 02:08:08,800
There we go.

2517
02:08:11,300 --> 02:08:14,700
So let me go ahead and copy that and then I will go ahead and paste

2518
02:08:14,700 --> 02:08:15,100
it.

2519
02:08:16,900 --> 02:08:17,400
And here.

2520
02:08:18,400 --> 02:08:23,900
And so now I should be able to do test one, two, Aha and test1.ogv out

2521
02:08:23,900 --> 02:08:26,000
and see if the same, right?

2522
02:08:27,000 --> 02:08:28,400
And it looks like

2523
02:08:33,300 --> 02:08:36,900
The fact that it was loaded would suggest that it wasn't the same, but

2524
02:08:36,900 --> 02:08:37,400
let's see.

2525
02:08:37,400 --> 02:08:39,000
Oh no, they are identical, right?

2526
02:08:39,200 --> 02:08:39,600
Okay.

2527
02:08:40,100 --> 02:08:41,600
Hey, so congratulations.

2528
02:08:42,100 --> 02:08:44,400
We have a compressor now, right?

2529
02:08:44,400 --> 02:08:46,900
It's not a very good compressor, but you can see it gets a lot of

2530
02:08:46,900 --> 02:08:47,800
compression on that file.

2531
02:08:48,100 --> 02:08:51,800
Let's see how it does with the whole HHA, right?

2532
02:08:52,800 --> 02:08:53,900
So, that's our simple compressor.

2533
02:08:54,100 --> 02:08:58,300
Let's say we went over and copied out of handmade hero.

2534
02:09:00,800 --> 02:09:01,600
The intro art.

2535
02:09:01,600 --> 02:09:02,400
That ha.

2536
02:09:02,600 --> 02:09:09,900
So that's a much bigger file right into our th a, that's about half a

2537
02:09:09,900 --> 02:09:10,500
gigabyte.

2538
02:09:11,800 --> 02:09:14,300
And so let's do simple compressor.

2539
02:09:16,900 --> 02:09:22,800
Compress intro, art HHA, intro art SCP, right?

2540
02:09:23,300 --> 02:09:27,200
And this, you know, probably in, you know, if we were actually trying

2541
02:09:27,200 --> 02:09:29,700
to make something real, we'd want to print out a little, like percent

2542
02:09:29,700 --> 02:09:31,400
on indicator, but there we go.

2543
02:09:31,400 --> 02:09:35,400
So we take a look at it and we see like, okay, the intro art, even

2544
02:09:35,400 --> 02:09:40,000
with are really, you know, are super simple, very basic, not

2545
02:09:40,000 --> 02:09:41,200
particularly distinct compressor.

2546
02:09:41,400 --> 02:09:46,100
You can see the intro, art, aha intro art, SCP intro, artists,

2547
02:09:46,400 --> 02:09:48,300
SCP got much better.

2548
02:09:48,500 --> 02:09:55,500
We saved you know entire hundred what hundred and forty megabytes

2549
02:09:55,500 --> 02:09:57,200
there, right?

2550
02:09:57,300 --> 02:10:00,600
A hundred and forty megabytes just by rle compressing this thing right

2551
02:10:00,600 --> 02:10:02,200
which is you know extremely stupid.

2552
02:10:02,200 --> 02:10:06,200
We didn't even do anything really to make our Ally compressor, be

2553
02:10:06,200 --> 02:10:08,900
particularly well tuned in any way but hey, that's really great,

2554
02:10:08,900 --> 02:10:09,400
right?

2555
02:10:10,200 --> 02:10:12,600
So, 100 extra MB, awesome.

2556
02:10:13,200 --> 02:10:15,900
And we could probably do much better than this, like I said, by doing

2557
02:10:15,900 --> 02:10:16,500
something better.

2558
02:10:16,500 --> 02:10:19,800
So maybe tomorrow, I'll show you how to do l z which would should

2559
02:10:19,800 --> 02:10:24,900
again save us even more space but you know, it it's still not really.

2560
02:10:24,900 --> 02:10:30,700
The kind of thing we would necessarily use on this but all right, so

2561
02:10:34,600 --> 02:10:41,800
Let's go ahead and go to the Q&A and like I said, this is just that's

2562
02:10:41,800 --> 02:10:44,800
like the dumbest possible compressor we could make right.

2563
02:10:44,800 --> 02:10:49,600
It's like it's it's not we have done nothing right?

2564
02:10:49,900 --> 02:10:54,500
But it just so happens that this data that we have here is very very

2565
02:10:54,500 --> 02:10:57,400
easy to compress because hey it had a lots of empty space right?

2566
02:10:57,500 --> 02:10:59,100
Like why is this compressor what?

2567
02:10:59,100 --> 02:11:02,500
You know I say it's a bad compressor but you see look at how much it

2568
02:11:02,500 --> 02:11:03,100
compresses file.

2569
02:11:03,100 --> 02:11:04,200
Well keep in mind.

2570
02:11:04,600 --> 02:11:07,700
That's because this file probably had hardly anything in it of

2571
02:11:08,400 --> 02:11:09,600
consequence, right?

2572
02:11:10,300 --> 02:11:14,500
So, you know, it's a bad compressor because you take a look at

2573
02:11:17,300 --> 02:11:18,100
Where was that?

2574
02:11:22,600 --> 02:11:23,300
Test 19th.

2575
02:11:23,300 --> 02:11:26,600
A let's see what happens if a real compressor comes in here, right?

2576
02:11:26,600 --> 02:11:32,300
And we add it to 7z and you can see like okay you know 7-Zip took our

2577
02:11:32,300 --> 02:11:35,900
output and it like made it twice it.

2578
02:11:35,900 --> 02:11:37,900
Then did another 2x on top of that, right?

2579
02:11:38,000 --> 02:11:40,800
So we'd only took out the low-hanging fruit but you can still do a lot

2580
02:11:40,800 --> 02:11:45,700
better and similarly on anything that wasn't so regular 7-Zip would

2581
02:11:45,700 --> 02:11:46,700
crush us, right?

2582
02:11:46,700 --> 02:11:49,700
Like we're only happening to benefit here and

2583
02:11:49,800 --> 02:11:53,400
You know what, we could probably demonstrate that because here's our

2584
02:11:53,400 --> 02:11:54,100
output file.

2585
02:11:54,100 --> 02:11:54,400
I bet.

2586
02:11:54,400 --> 02:11:57,200
If we compress, even this one with 7-Zip, it'll probably crush us.

2587
02:11:57,200 --> 02:11:57,500
Right?

2588
02:11:57,500 --> 02:11:58,300
So here we go.

2589
02:12:00,300 --> 02:12:04,300
Well let 7-Zip do it here and we'll see how big 7-Zip manage this to

2590
02:12:04,300 --> 02:12:06,200
get this file with the same thing.

2591
02:12:06,200 --> 02:12:08,100
And it'll it should just annihilate us, right?

2592
02:12:08,100 --> 02:12:09,900
It should just absolutely trance us.

2593
02:12:38,800 --> 02:12:39,800
Or it's questions here.

2594
02:12:39,800 --> 02:12:41,200
Midlow says, awesome stuff.

2595
02:12:41,200 --> 02:12:44,300
I hadn't been making the distinction between literals and runs in my

2596
02:12:44,300 --> 02:12:44,500
thing.

2597
02:12:44,500 --> 02:12:47,300
My test stuff has just been zeros and ones mine.

2598
02:12:47,300 --> 02:12:50,400
So I was just storing the first token and then the counter values.

2599
02:12:50,600 --> 02:12:52,800
Ah, okay, yeah.

2600
02:12:52,800 --> 02:12:55,200
So that's that's an interesting point.

2601
02:12:55,300 --> 02:13:01,300
So yeah, basically, this kind of our Li is the kind that I grew up

2602
02:13:01,300 --> 02:13:02,200
with again.

2603
02:13:02,500 --> 02:13:04,100
So that's why I did it first.

2604
02:13:04,100 --> 02:13:04,700
But yeah.

2605
02:13:06,300 --> 02:13:09,300
Either we could do it is just or account, and then a value account and

2606
02:13:09,300 --> 02:13:10,600
in value, and accountant value.

2607
02:13:10,700 --> 02:13:18,000
And in that case, your literal, your literals become, just a one.

2608
02:13:18,000 --> 02:13:20,600
And then the value, a 1 and then a value of 1 and the value.

2609
02:13:20,600 --> 02:13:23,400
The problem with that is a lot of times you have a group of values

2610
02:13:23,600 --> 02:13:26,900
that you want that are all different and you keep inserting all these

2611
02:13:26,900 --> 02:13:29,100
ones you like double the size of that, right?

2612
02:13:29,600 --> 02:13:32,300
So what this allows you to do is kind of take advantage of the fact

2613
02:13:32,300 --> 02:13:35,900
that typically, if you see new values that aren't runs, they

2614
02:13:36,100 --> 02:13:37,700
Be a bunch together, right?

2615
02:13:37,700 --> 02:13:40,700
And so that just, it just helps, it tends to be a little bit better.

2616
02:13:41,200 --> 02:13:44,900
Like I said, the other ways you can do this are you could have a one

2617
02:13:44,900 --> 02:13:49,600
bit in the Run encoding says whether it's literals or regular, so then

2618
02:13:49,600 --> 02:13:54,000
you can only do 127 of them right?

2619
02:13:54,000 --> 02:13:58,100
You divide your number in half and then but but you can say for each

2620
02:13:58,100 --> 02:14:01,400
one which kind it is, literals are runs.

2621
02:14:14,300 --> 02:14:15,600
Oh Magic.

2622
02:14:15,600 --> 02:14:17,400
603 what I was saying is tomorrow.

2623
02:14:17,400 --> 02:14:20,900
I will show you how to do simple l z instead of

2624
02:14:25,300 --> 02:14:26,600
Instead of rle.

2625
02:14:26,700 --> 02:14:28,300
So just just a different type of compression.

2626
02:14:28,500 --> 02:14:29,800
So, did 7-Zip finished yet.

2627
02:14:30,500 --> 02:14:35,400
So take a look here, you can see, here's the aha, that's our data file

2628
02:14:35,400 --> 02:14:36,900
for the intro cutscenes.

2629
02:14:37,100 --> 02:14:40,000
Here's the SCP file, which is what we did with our.

2630
02:14:40,100 --> 02:14:42,700
This is a gnarly encoded version, right?

2631
02:14:43,000 --> 02:14:46,700
And here is intro, art dot 7-Zip, intro art dot 7-Zip.

2632
02:14:46,700 --> 02:14:51,200
Look at how much smaller that is right, then hours.

2633
02:14:51,800 --> 02:14:52,600
You know what I'm saying?

2634
02:14:53,100 --> 02:14:54,700
It's like it's way better.

2635
02:14:54,800 --> 02:14:54,900
Better.

2636
02:14:54,900 --> 02:14:59,500
It's only a team eggs, whereas we're

2637
02:15:00,000 --> 02:15:03,400
20 Meg's from an original of foreign 262 Meg's, right?

2638
02:15:03,400 --> 02:15:05,300
So 7-Zip just absolutely crushed us.

2639
02:15:05,300 --> 02:15:05,900
Right?

2640
02:15:06,300 --> 02:15:09,700
So, you know, I just wanted to make that point because it made it look

2641
02:15:09,800 --> 02:15:13,800
test one that ha has so much giant blocks of zeros, and it probably

2642
02:15:14,000 --> 02:15:15,300
that it made our compressor.

2643
02:15:15,300 --> 02:15:16,700
Look are bad, compressor.

2644
02:15:16,700 --> 02:15:18,100
Look a lot better than it should have.

2645
02:15:18,100 --> 02:15:18,900
This looks amazing.

2646
02:15:18,900 --> 02:15:21,400
When you look at it, you're like, oh my God and 7-Zip.

2647
02:15:21,400 --> 02:15:22,500
Can only SS from there.

2648
02:15:22,500 --> 02:15:23,500
It's like, no, no.

2649
02:15:23,800 --> 02:15:28,100
Most data 7-Zip is way better than double, right?

2650
02:15:28,100 --> 02:15:29,800
What we would do with in our Ellie

2651
02:15:30,700 --> 02:15:31,100
so,

2652
02:15:36,500 --> 02:15:39,200
Tt b, JM, R, Hardware, image, D compressors.

2653
02:15:39,200 --> 02:15:40,600
Still a thing.

2654
02:15:44,600 --> 02:15:45,600
So I guess, I'm not sure.

2655
02:15:45,600 --> 02:15:46,700
I understand.

2656
02:15:48,400 --> 02:15:50,500
What you're asking though?

2657
02:16:04,000 --> 02:16:05,400
I guess I don't understand the question.

2658
02:16:05,700 --> 02:16:10,200
So the first thing I'll say is most 3D games anyway,

2659
02:16:11,900 --> 02:16:14,200
In 2D games may not for various reasons.

2660
02:16:14,200 --> 02:16:20,300
But for most 3D games because you're using Textures in a way that

2661
02:16:20,300 --> 02:16:24,400
tends to end up being like filtered and it's with lots of shaders

2662
02:16:24,400 --> 02:16:30,600
layered on top of it and all this stuff you tend to not need lossless

2663
02:16:31,000 --> 02:16:31,700
compression.

2664
02:16:32,700 --> 02:16:34,100
You can be a little bit lossy.

2665
02:16:35,500 --> 02:16:42,200
So most games nowadays that are in 3D and some that are into D,

2666
02:16:42,299 --> 02:16:46,500
depending on, again, the circumstances do use very simple texture

2667
02:16:46,500 --> 02:16:51,100
compression that is implemented in the hardware, which is essentially

2668
02:16:51,100 --> 02:16:56,799
a way of encoding, usually 4 by 4 pixel blocks, but that's not the

2669
02:16:56,799 --> 02:17:02,400
only kind but usually including 4 by 4 pixel blocks, by encoding them.

2670
02:17:02,400 --> 02:17:04,900
As something along the lines of let's say,

2671
02:17:05,799 --> 02:17:07,200
Two base colors.

2672
02:17:07,600 --> 02:17:13,100
And then each pixel just says somewhere between one and the other base

2673
02:17:13,100 --> 02:17:17,400
colors in like increments of like 25% or something like this, those

2674
02:17:17,400 --> 02:17:18,200
sorts of things.

2675
02:17:19,600 --> 02:17:23,500
And hey, if the value can't be encoded that way, then it just is

2676
02:17:23,500 --> 02:17:23,900
wrong.

2677
02:17:24,400 --> 02:17:26,500
It's lossy, it's totally lossy.

2678
02:17:26,700 --> 02:17:30,299
You're absolutely in no way guaranteed to get anything close to the

2679
02:17:30,299 --> 02:17:31,500
original image back.

2680
02:17:32,200 --> 02:17:39,100
But it's just like, you know, it's an approximation, right?

2681
02:17:39,100 --> 02:17:41,900
It's a way of storing taking.

2682
02:17:43,500 --> 02:17:49,100
It's a way of putting textures into a smaller space that is reliably.

2683
02:17:49,400 --> 02:17:55,700
Codable on a GPU that tends to have not to objection will artifacts

2684
02:17:55,900 --> 02:17:59,299
when the textures are being used in 3D for.

2685
02:18:00,000 --> 02:18:02,700
multiple Shooters layering, and that sort of stuff, there's enough

2686
02:18:02,700 --> 02:18:05,200
other things on top of that, you don't tend to notice the artifacts,

2687
02:18:07,000 --> 02:18:07,600
Right.

2688
02:18:11,700 --> 02:18:16,100
So if that's what you mean by Harvard Hardware, image D compressors

2689
02:18:16,200 --> 02:18:16,400
then.

2690
02:18:16,400 --> 02:18:22,299
Yes, if what you're talking about is more like jpeg or something like

2691
02:18:22,299 --> 02:18:26,500
this, with a discrete cosine, transform and stuff like that, then the

2692
02:18:26,500 --> 02:18:28,799
answer is more like, yes, and no.

2693
02:18:31,799 --> 02:18:32,299
Games.

2694
02:18:32,299 --> 02:18:35,799
Generally speaking aren't doing anything like that.

2695
02:18:36,600 --> 02:18:42,799
Games aren't speaking aren't compressing their textures with like DCT

2696
02:18:42,799 --> 02:18:44,700
that gets decompress and Hardware something like that.

2697
02:18:44,700 --> 02:18:46,400
That's not really a thing.

2698
02:18:47,400 --> 02:18:51,799
And the reason that that's not really a thing is because games,

2699
02:18:51,799 --> 02:18:52,799
typically don't care.

2700
02:18:52,799 --> 02:18:58,299
So much about how much space textures take up in main memory, they

2701
02:18:58,299 --> 02:18:59,100
tear care to.

2702
02:18:59,299 --> 02:19:01,299
They tend to care more about how

2703
02:19:01,500 --> 02:19:06,700
How much they take up on graphics card memory and since the graphics

2704
02:19:06,700 --> 02:19:11,299
card needs the textures to not be DCT encoded in order to use them,

2705
02:19:11,900 --> 02:19:13,500
you tend to not care, right?

2706
02:19:13,500 --> 02:19:17,100
So you tend to have to store the textures on the card in the format,

2707
02:19:17,100 --> 02:19:21,200
the card can read, which it can't do DCT in real time yet.

2708
02:19:21,700 --> 02:19:25,200
Meaning in at the speed, it needs to do it to texture from that.

2709
02:19:25,900 --> 02:19:28,700
Now I guess I don't know how true that really is because I don't know

2710
02:19:28,700 --> 02:19:31,000
if there's maybe some cards that are made of that sort of thing now.

2711
02:19:31,000 --> 02:19:31,200
But

2712
02:19:31,400 --> 02:19:32,200
Uno in general.

2713
02:19:35,000 --> 02:19:42,000
So, you know, if you were storing, those as 8x8 DCT blocks or

2714
02:19:42,000 --> 02:19:45,799
something like that, in main memory, you could just have the DCT done

2715
02:19:46,600 --> 02:19:49,500
by the CPU in the background before uploading the textures or stuff

2716
02:19:49,500 --> 02:19:49,900
like that.

2717
02:19:49,900 --> 02:19:52,000
Stuff like that might be happening.

2718
02:19:52,300 --> 02:19:55,500
But typically speaking, you don't store, you don't send down the

2719
02:19:55,500 --> 02:19:57,900
things as DCT and then have the hardware.

2720
02:19:57,900 --> 02:20:00,400
Do the undies ET typically?

2721
02:20:01,700 --> 02:20:05,600
Again, not to say you couldn't write, it may be that a game at some

2722
02:20:05,600 --> 02:20:09,200
point, and I don't know, I'm not up to date on what, you know, maybe

2723
02:20:09,200 --> 02:20:12,300
Battlefield one or some of, you know, Advanced engines these days are

2724
02:20:12,300 --> 02:20:12,800
doing.

2725
02:20:13,100 --> 02:20:16,600
But you could imagine implementing something like a DCT with a compute

2726
02:20:16,600 --> 02:20:20,700
Shader and then having doing your uploads in, like something like a

2727
02:20:20,700 --> 02:20:25,300
JPEG format and having the card, do the undie CT into the dxt format.

2728
02:20:25,500 --> 02:20:27,500
But that involves all sorts of other things and blah, blah, blah,

2729
02:20:27,500 --> 02:20:28,500
blah, blah, blah, right.

2730
02:20:29,000 --> 02:20:31,200
So there's a bunch of things you could imagine doing there, which one

2731
02:20:31,200 --> 02:20:31,300
is he?

2732
02:20:31,500 --> 02:20:35,300
Pilar in aren't doing, I'm not comfortable with saying, so that's the

2733
02:20:35,300 --> 02:20:36,300
know, part of the answer.

2734
02:20:36,300 --> 02:20:42,400
The, yes, part of the answer is for a bunch of stuff like video, where

2735
02:20:42,400 --> 02:20:45,700
you're just talking about one thing that's being round-trip, decoded

2736
02:20:45,700 --> 02:20:46,600
or encoded.

2737
02:20:47,000 --> 02:20:48,400
So like mpeg-4,

2738
02:20:49,500 --> 02:20:55,900
Or thing is like this, there still is a bunch of stuff in hardware for

2739
02:20:55,900 --> 02:20:56,300
that.

2740
02:20:56,300 --> 02:20:57,700
Oftentimes right?

2741
02:20:57,900 --> 02:20:59,700
So certain parts of the

2742
02:21:00,000 --> 02:21:05,500
The decompress for things like the mpeg-4 like you know the DCT or the

2743
02:21:05,500 --> 02:21:06,800
mo comp or whatever.

2744
02:21:07,100 --> 02:21:09,000
Depending whether you're compressing or decompressing, blah, blah,

2745
02:21:09,000 --> 02:21:12,300
blah, that sort of thing, maybe being done in hardware for video

2746
02:21:12,800 --> 02:21:14,400
depending on again, the circumstances.

2747
02:21:15,400 --> 02:21:18,900
And I'm not again up to date on what everyone's doing everywhere.

2748
02:21:18,900 --> 02:21:22,300
So I'm not comfortable saying who is and isn't using that and when and

2749
02:21:22,300 --> 02:21:26,500
when it isn't being used and blah, blah blah, but it's definitely the

2750
02:21:26,500 --> 02:21:26,800
case.

2751
02:21:26,800 --> 02:21:29,300
That that sort of thing is still happening in Hardware, depending on

2752
02:21:29,300 --> 02:21:29,900
the circumstances.

2753
02:21:30,000 --> 02:21:31,700
Has so.

2754
02:21:31,700 --> 02:21:32,500
Absolutely.

2755
02:21:33,600 --> 02:21:39,500
And so, depending on what you mean by Hardware image decompressor, the

2756
02:21:39,500 --> 02:21:43,100
answer is yes or no to varying degrees and it depends on who you're

2757
02:21:43,100 --> 02:21:43,600
talking about.

2758
02:21:43,600 --> 02:21:47,700
And so on so forth but keep in mind that basically there's a wide

2759
02:21:47,700 --> 02:21:50,400
spectrum there and I think pretty much everywhere on the Spectrum

2760
02:21:50,400 --> 02:21:56,900
there's probably someone somewhere doing something right and you know

2761
02:21:58,300 --> 02:22:02,500
To, to what extent that fits, what you were mentally thinking of when

2762
02:22:02,500 --> 02:22:06,500
you said, Hardware image decompressor the answer may be yes or no.

2763
02:22:06,500 --> 02:22:06,700
Right?

2764
02:22:06,700 --> 02:22:07,800
Because there's different.

2765
02:22:07,800 --> 02:22:11,200
You know, when someone says that they may be thinking of something

2766
02:22:11,200 --> 02:22:14,400
more or less Advanced or more and less less complex, or you know

2767
02:22:14,400 --> 02:22:15,100
what's happening there.

2768
02:22:15,100 --> 02:22:15,400
So

2769
02:22:17,900 --> 02:22:20,200
I don't know if anything, that was it for our questions, right?

2770
02:22:54,400 --> 02:22:55,600
Alright, I think that's it for questions.

2771
02:22:55,600 --> 02:22:57,000
So I'm going to go ahead and conclude

2772
02:23:00,900 --> 02:23:01,600
Or try to.

2773
02:23:06,800 --> 02:23:09,300
Okay, there we go.

2774
02:23:09,800 --> 02:23:11,900
All right, thank you, everyone for joining me for another episode of

2775
02:23:11,900 --> 02:23:12,500
handmade here.

2776
02:23:12,500 --> 02:23:13,800
It's been a pleasure coding with you.

2777
02:23:13,800 --> 02:23:17,800
As always, if you would like to follow along with the series at home,

2778
02:23:17,800 --> 02:23:20,900
you can always pre-order the game on handmade here at org and it comes

2779
02:23:20,900 --> 02:23:21,600
to the source code.

2780
02:23:21,600 --> 02:23:24,900
So you can follow along and play around with it.

2781
02:23:25,400 --> 02:23:26,400
We also have Forum site.

2782
02:23:26,400 --> 02:23:29,200
Go to ask question a patreon page.

2783
02:23:29,200 --> 02:23:31,900
You can go to file export the video series, a schedule bot, which on

2784
02:23:31,900 --> 02:23:36,200
the moment is needs to be upgraded because it used to be weekday.

2785
02:23:36,500 --> 02:23:37,400
Other weekend stream.

2786
02:23:37,400 --> 02:23:40,200
So soon, that will be back to telling you what the schedule is.

2787
02:23:40,500 --> 02:23:44,600
But at the moment, it's a little bit, not upgraded yet.

2788
02:23:44,600 --> 02:23:51,300
And we have a past episodes guide, you can use to catch up on older

2789
02:23:51,300 --> 02:23:52,700
episodes that you may have missed.

2790
02:23:53,000 --> 02:23:54,500
That's about it for today.

2791
02:23:54,500 --> 02:23:57,500
I will be back tomorrow and I'll just show you how to put an LZ

2792
02:23:57,500 --> 02:23:58,500
compressor in there.

2793
02:23:58,500 --> 02:23:59,900
So we'll kind of

2794
02:24:00,000 --> 02:24:02,400
Take our little compression framework and we'll just put an LZ

2795
02:24:02,400 --> 02:24:05,000
compressor in there and then you can kind of see like, okay, so now

2796
02:24:05,000 --> 02:24:08,400
you kind of get the basics of the really simple part of compression.

2797
02:24:09,000 --> 02:24:14,900
And then how kind of leave it up to, to you, folks, to figure out how

2798
02:24:14,900 --> 02:24:18,300
to do more compression stuff on your own by reading and stuff like

2799
02:24:18,300 --> 02:24:18,500
that.

2800
02:24:18,500 --> 02:24:20,900
Because I'm not going to go too much into it because like I said, I'm

2801
02:24:20,900 --> 02:24:23,500
not a compression person, so I'm kind of the wrong person to teach

2802
02:24:23,500 --> 02:24:26,900
anything beyond the very, very basic parts of it.

2803
02:24:27,100 --> 02:24:29,800
I really don't feel qualified in sort of

2804
02:24:30,500 --> 02:24:34,200
Going down any sort of deeper paths into compression.

2805
02:24:34,900 --> 02:24:35,700
So that's about it.

2806
02:24:35,800 --> 02:24:40,500
I hope everyone has a great Saturday until tomorrow, take it easy and

2807
02:24:40,500 --> 02:24:42,300
I'll see y'all on the internet.

2808
02:24:42,300 --> 02:24:43,200
Take it easy, everybody.

