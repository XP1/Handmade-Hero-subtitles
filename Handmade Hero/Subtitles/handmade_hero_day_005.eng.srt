1
00:00:00,000 --> 00:00:03,600
In, there we go.

2
00:00:05,700 --> 00:00:06,200
Okay.

3
00:00:06,200 --> 00:00:06,800
Hello everyone.

4
00:00:06,800 --> 00:00:08,300
Welcome to handmade hero.

5
00:00:08,500 --> 00:00:13,600
This is day 5 of programming, and I was very excited to see everyone

6
00:00:13,600 --> 00:00:14,100
here.

7
00:00:14,200 --> 00:00:17,800
We have done a tremendous amount of work this week actually despite

8
00:00:17,800 --> 00:00:19,100
only having an hour a night.

9
00:00:19,100 --> 00:00:24,000
We now have our very own animated graphics on the screen in Windows

10
00:00:24,000 --> 00:00:27,500
that we wrote in tireli our self, which kind of opens the door for us,

11
00:00:27,500 --> 00:00:29,700
doing absolutely anything we want to do.

12
00:00:29,700 --> 00:00:33,600
So, for those of you joining us, who may be new, this is handmade

13
00:00:33,600 --> 00:00:33,900
hero.

14
00:00:33,900 --> 00:00:35,200
This is the

15
00:00:36,300 --> 00:00:40,300
The weeknight series, you can go to handmade hero dot org and see this

16
00:00:40,300 --> 00:00:40,900
is a weeknight Series.

17
00:00:40,900 --> 00:00:43,900
Where we code a complete game from scratch.

18
00:00:43,900 --> 00:00:44,900
No libraries.

19
00:00:45,000 --> 00:00:47,000
No engine, just us.

20
00:00:47,200 --> 00:00:50,400
And we see how absolutely everything works, which has been a lot of

21
00:00:50,400 --> 00:00:53,700
fun and I am looking forward to doing even more of it.

22
00:00:53,700 --> 00:00:56,600
So you can go up here and handmade here at dot org to find more

23
00:00:56,600 --> 00:00:58,400
information about it if you would like to.

24
00:00:58,400 --> 00:01:00,500
And if you have questions or anything for me, there's an email a

25
00:01:00,500 --> 00:01:01,100
question button.

26
00:01:01,100 --> 00:01:03,200
And if you would like the source code, you can always pre-order the

27
00:01:03,200 --> 00:01:05,300
game and it comes with the source code that

28
00:01:05,400 --> 00:01:07,100
we upload every night.

29
00:01:07,100 --> 00:01:08,500
Alright, so let's get started.

30
00:01:08,500 --> 00:01:09,300
Today is a Friday.

31
00:01:09,300 --> 00:01:13,200
So we are going to be doing some recap about the things that happened

32
00:01:13,200 --> 00:01:14,300
this week.

33
00:01:14,300 --> 00:01:20,100
And basically we spent the first day Monday was not a very, very

34
00:01:20,100 --> 00:01:20,500
interesting day.

35
00:01:20,500 --> 00:01:23,500
We basically just set up our development environment and Tuesday

36
00:01:23,500 --> 00:01:24,800
through Thursday.

37
00:01:25,000 --> 00:01:28,000
We got animated graphics on the screen, which was pretty cool.

38
00:01:28,200 --> 00:01:30,200
And so let's open up that file here.

39
00:01:30,200 --> 00:01:31,700
We basically put it all in one file.

40
00:01:31,800 --> 00:01:34,300
And one thing I'd like to point out is there is not very much code

41
00:01:34,300 --> 00:01:35,300
here it

42
00:01:35,600 --> 00:01:38,700
Really pretty straightforward which I think is pretty great.

43
00:01:39,100 --> 00:01:41,600
Because one of the things that often intimidates people as they think

44
00:01:41,600 --> 00:01:43,600
that, if they write everything from scratch, it's going to just be a

45
00:01:43,600 --> 00:01:47,200
huge, huge, huge amount of work, but it's not, there is very little

46
00:01:47,200 --> 00:01:49,600
code here and we have done it in three nights with, mostly me

47
00:01:49,600 --> 00:01:50,400
explaining things.

48
00:01:50,600 --> 00:01:52,900
So if you were to do this yourself, I think it would take you 10 20

49
00:01:52,900 --> 00:01:54,100
minutes to put in some code like this.

50
00:01:54,100 --> 00:01:56,300
It is really not much code.

51
00:01:56,700 --> 00:01:59,800
What I'd like to do tonight is I'd like to kind of Step through this

52
00:02:00,000 --> 00:02:02,700
and just really emphasize how every last little thing works.

53
00:02:02,700 --> 00:02:05,200
So everyone can be on board with that and maybe we'll try

54
00:02:05,400 --> 00:02:08,000
I to start questioning answers a little bit early if we do have time

55
00:02:08,000 --> 00:02:10,800
for that so people can get drilled down to the things that they want.

56
00:02:10,800 --> 00:02:15,400
But before I get started, I wanted to clear up just a few things from

57
00:02:15,400 --> 00:02:16,900
emails during the week.

58
00:02:16,900 --> 00:02:20,400
So first of all, I wanted to thank some.

59
00:02:20,700 --> 00:02:21,900
I don't even know how to pronounce your name.

60
00:02:21,900 --> 00:02:22,400
I'm sorry.

61
00:02:22,400 --> 00:02:27,500
It's something like Kurt cartel, to pay for writing in because we did

62
00:02:27,500 --> 00:02:29,200
not need to order a capture card.

63
00:02:29,300 --> 00:02:30,100
At the end of the day.

64
00:02:30,100 --> 00:02:34,500
It turned out that really all we needed to do was change OBS from

65
00:02:34,500 --> 00:02:35,300
monitor capture.

66
00:02:35,400 --> 00:02:39,800
To the secret other monitor capture option and I tested this and it

67
00:02:39,800 --> 00:02:40,400
turns out that.

68
00:02:40,400 --> 00:02:43,700
Yeah, if you if you switch it into this other mode, where instead of

69
00:02:43,700 --> 00:02:47,700
capturing monitor, it's capturing a game but you select the monitor as

70
00:02:47,700 --> 00:02:50,600
the game suddenly everything works and I didn't have any more

71
00:02:50,600 --> 00:02:51,000
problems.

72
00:02:51,000 --> 00:02:53,000
Like I was having like the disaster that happened last dream.

73
00:02:53,000 --> 00:02:55,000
So thank you very much for solving that problem for us.

74
00:02:55,300 --> 00:02:57,700
That is way better than getting capture card because the capture cards

75
00:02:57,700 --> 00:02:59,800
was looking like they were a bit of a nightmare and had a bunch of

76
00:03:00,000 --> 00:03:01,200
Backside and want to deal with.

77
00:03:01,400 --> 00:03:02,300
So this is perfect.

78
00:03:02,300 --> 00:03:04,900
We are running smoothly and I think everything will go well from now

79
00:03:04,900 --> 00:03:05,000
on.

80
00:03:05,000 --> 00:03:10,700
Hopefully, anyway, I also wanted to thank Martin vladek from, for

81
00:03:10,700 --> 00:03:11,700
writing in again.

82
00:03:11,700 --> 00:03:13,000
Don't know how to pronounce your name sometimes.

83
00:03:13,000 --> 00:03:16,500
Because I wrote a thing here, which, which was saying, let's check if

84
00:03:16,500 --> 00:03:19,400
H, redraw the redraw and own DC still matter.

85
00:03:19,700 --> 00:03:22,700
And if you remember from the original part of the stream, we were

86
00:03:22,700 --> 00:03:24,300
filling out a wind class structure here.

87
00:03:24,700 --> 00:03:27,900
And if you go back to the documentation and you look at the wind class

88
00:03:27,900 --> 00:03:29,800
structure, although we deleted

89
00:03:30,000 --> 00:03:32,900
Because we were just seeing if it would do anything in here.

90
00:03:32,900 --> 00:03:36,000
You can see that there is a style field and the style field.

91
00:03:36,200 --> 00:03:37,500
We had put some stuff in it.

92
00:03:38,100 --> 00:03:39,000
We had put in up.

93
00:03:39,000 --> 00:03:40,000
That's a lowercase style.

94
00:03:40,000 --> 00:03:40,700
Not a capital.

95
00:03:41,200 --> 00:03:44,800
We had put this in there and basically they were a bunch of styles.

96
00:03:44,800 --> 00:03:48,700
We ordered them together to set them all and I was sort of

97
00:03:48,700 --> 00:03:50,800
hypothesizing is like, what exactly do.

98
00:03:50,800 --> 00:03:52,700
We need these 4-H redraw.

99
00:03:52,700 --> 00:03:55,600
It's basically saying that says redraw the window when you when you

100
00:03:55,600 --> 00:03:58,700
size it horizontally and this is redraw the window and you sides

101
00:03:58,700 --> 00:03:59,900
vertically and this is whether

102
00:04:00,100 --> 00:04:00,900
You have your own DC.

103
00:04:00,900 --> 00:04:01,800
We pretty much determine.

104
00:04:01,800 --> 00:04:02,800
We don't eat our own d.c.

105
00:04:02,800 --> 00:04:05,800
Because we didn't really amount to anything that we would need to do,

106
00:04:05,800 --> 00:04:09,300
but it turns out that H, redraw and V, redraw are actually pretty good

107
00:04:09,500 --> 00:04:12,000
Martin's a decoding and tested them for us, just to verify.

108
00:04:12,400 --> 00:04:16,200
But basically what they what it does is it's really just a flag that

109
00:04:16,200 --> 00:04:20,800
says, I need to repaint the whole window when I resize it.

110
00:04:20,800 --> 00:04:22,500
Not just the section, that's new.

111
00:04:22,500 --> 00:04:25,600
So, if I make the window a little bit bigger, instead of just painting

112
00:04:25,600 --> 00:04:28,300
the new section, I want you to have to repaint the whole thing.

113
00:04:28,400 --> 00:04:29,800
And what he pointed out was just like

114
00:04:29,900 --> 00:04:32,600
Well, if we're going to be stretching our image to fit the window or

115
00:04:32,600 --> 00:04:34,900
anything like that, we're going to have to redraw the whole thing.

116
00:04:34,900 --> 00:04:37,000
So we probably do want those in there and you test it to make sure

117
00:04:37,000 --> 00:04:37,400
they work.

118
00:04:37,600 --> 00:04:38,300
That was great work.

119
00:04:38,300 --> 00:04:39,600
Thank you for doing that exploration.

120
00:04:39,600 --> 00:04:41,400
And I think you are totally right on the money.

121
00:04:41,800 --> 00:04:44,200
So I'm going to consider that matter clothes and say that we do want

122
00:04:44,200 --> 00:04:44,900
these two flags.

123
00:04:44,900 --> 00:04:47,200
So we are going to leave them in there.

124
00:04:47,800 --> 00:04:48,200
All right.

125
00:04:48,200 --> 00:04:49,900
That is it for my thank yous.

126
00:04:50,400 --> 00:04:50,700
Now.

127
00:04:50,700 --> 00:04:57,100
I want to address just a quick, a quick little optimization thing, and

128
00:04:57,100 --> 00:04:59,800
maybe a little bit early to talk about this, but I'm going to talk

129
00:04:59,800 --> 00:04:59,800
about

130
00:05:00,000 --> 00:05:00,300
It.

131
00:05:00,300 --> 00:05:03,900
Anyway, one of the things that I did, when I wrote this function win32

132
00:05:03,900 --> 00:05:07,300
update window is I I passed a pointer.

133
00:05:07,700 --> 00:05:09,100
So, basically, we had a clot.

134
00:05:09,100 --> 00:05:10,100
We had a rectangle.

135
00:05:10,400 --> 00:05:13,900
When we called win32 update window, and if you see, if you go look at

136
00:05:13,900 --> 00:05:16,700
where we actually called that, you can see that I got the rectangle.

137
00:05:16,700 --> 00:05:19,400
It was on the stack here inside the WM paint message.

138
00:05:19,500 --> 00:05:21,900
And I went ahead and passed a pointer to it.

139
00:05:21,900 --> 00:05:22,000
Now.

140
00:05:22,000 --> 00:05:24,900
The reason I pass a pointer to it was a bit of a habit.

141
00:05:25,000 --> 00:05:27,700
Usually I tend to pass Porter's two things if the structure is get

142
00:05:27,700 --> 00:05:29,800
large and this is a four-element structure, so maybe.

143
00:05:29,900 --> 00:05:30,700
It's not that large.

144
00:05:30,700 --> 00:05:32,300
So it's a little bit weird that I did it.

145
00:05:32,300 --> 00:05:35,900
But, you know, for us, I have it sometimes, old habits, die hard, and

146
00:05:35,900 --> 00:05:38,000
one of the things that someone pointed out when they wrote in and it's

147
00:05:38,000 --> 00:05:41,700
a good point is that typically one of the things that you want to try

148
00:05:41,700 --> 00:05:45,700
to avoid is passing pointers to things that are on the stack.

149
00:05:45,900 --> 00:05:50,000
If you can't avoid it because the compiler now, no longer really knows

150
00:05:50,300 --> 00:05:51,200
what's going on here.

151
00:05:51,200 --> 00:05:53,600
Because, basically what happens is, if the compiler see, something

152
00:05:53,600 --> 00:05:56,500
like this, where it's going to get the whole rectangle, the whole

153
00:05:56,500 --> 00:05:59,800
thing will be passed fresh to the to.

154
00:06:00,000 --> 00:06:00,200
Action.

155
00:06:00,200 --> 00:06:01,200
That is going to use it.

156
00:06:01,500 --> 00:06:04,100
There's a bunch of assumptions that can make it can it can start to

157
00:06:04,100 --> 00:06:07,400
assume that nobody else is going to need to touch that thing.

158
00:06:07,500 --> 00:06:11,000
It can assume basically that it is just a private copy.

159
00:06:11,000 --> 00:06:12,600
That this thing is going to use itself.

160
00:06:12,600 --> 00:06:14,400
There is no possibility for aliasing.

161
00:06:14,400 --> 00:06:15,900
There's no possibility for anything.

162
00:06:16,200 --> 00:06:18,500
What aliasing is basically something we'll get to a little bit later

163
00:06:18,500 --> 00:06:20,100
and it's something you probably don't need to worry about too much

164
00:06:20,100 --> 00:06:20,500
right now.

165
00:06:20,500 --> 00:06:23,400
But basically it's just saying whether I have two pointers that might

166
00:06:23,400 --> 00:06:24,500
point to the same memory.

167
00:06:25,100 --> 00:06:27,500
And the reason that is important is because when the compiler is

168
00:06:27,500 --> 00:06:29,800
compiling your code, you can imagine

169
00:06:30,000 --> 00:06:33,200
If I have something like this where I've got a two pointers, let's

170
00:06:33,200 --> 00:06:34,200
say, right?

171
00:06:34,200 --> 00:06:37,900
A and B, if I was and these are pointing to something, this is

172
00:06:37,900 --> 00:06:38,700
pointing to memory.

173
00:06:38,700 --> 00:06:41,300
Both of these are pointing somewhere in memory, and we don't actually

174
00:06:41,300 --> 00:06:42,100
know where they are.

175
00:06:42,200 --> 00:06:43,700
Let's say, and neither does the compiler.

176
00:06:43,700 --> 00:06:44,600
They're just some pointers.

177
00:06:44,600 --> 00:06:45,900
Maybe they were passed into this function.

178
00:06:45,900 --> 00:06:47,100
We don't know where they came from.

179
00:06:47,600 --> 00:06:49,900
So if we add these pointers and I'll take them out of the function

180
00:06:49,900 --> 00:06:51,600
just so we're not thinking about it in this cost function.

181
00:06:51,600 --> 00:06:53,200
We're just saying somewhere somewhere in our code.

182
00:06:53,200 --> 00:06:56,600
We end up with pointers and be well, one of the things that can happen

183
00:06:56,600 --> 00:06:59,400
is I may want to write to a I may want to go ahead and write something

184
00:06:59,400 --> 00:06:59,800
to a

185
00:07:00,000 --> 00:07:00,600
Right.

186
00:07:01,000 --> 00:07:01,800
And similarly.

187
00:07:01,800 --> 00:07:03,800
I may want to read something from be right.

188
00:07:03,800 --> 00:07:06,000
I may say that, you know, I don't know.

189
00:07:06,000 --> 00:07:10,300
Some other thing here in Texas, Equal star b, or into y, equals star

190
00:07:10,300 --> 00:07:12,100
be right now.

191
00:07:12,100 --> 00:07:14,400
If you take a look at this code for a minute, it looks pretty obvious.

192
00:07:14,400 --> 00:07:15,100
What's going on?

193
00:07:15,100 --> 00:07:15,800
I'm going to.

194
00:07:16,300 --> 00:07:18,900
Well, you know, I should probably even read out the values that they

195
00:07:18,900 --> 00:07:21,000
are, but I think I can upcast to ensure that's fine, too.

196
00:07:21,100 --> 00:07:22,400
Anyway, I'm going to read out of here.

197
00:07:22,400 --> 00:07:25,600
Eight bits and shove it into these 32 bits of why it's going to look

198
00:07:25,600 --> 00:07:28,900
at whatever is in the location Rhett pointed to by B.

199
00:07:29,000 --> 00:07:29,700
That's going to put it in.

200
00:07:29,700 --> 00:07:29,800
Why?

201
00:07:29,900 --> 00:07:30,100
Why?

202
00:07:30,100 --> 00:07:33,400
And then I'm going to go ahead and I'm going to write five out, just

203
00:07:33,400 --> 00:07:36,000
the 8 Bits that represent five.

204
00:07:36,000 --> 00:07:38,300
I'm going to write those out to wherever a is pointing to.

205
00:07:38,500 --> 00:07:40,200
And then I'm going to reread be right?

206
00:07:40,200 --> 00:07:41,400
Just going to reread the same thing.

207
00:07:41,400 --> 00:07:44,900
So at the end of this, we are all looking at it and we say well,

208
00:07:44,900 --> 00:07:47,000
obviously, right?

209
00:07:47,700 --> 00:07:49,600
Y and X are the same, right?

210
00:07:49,600 --> 00:07:51,800
Because here is here is the pointer to be?

211
00:07:52,200 --> 00:07:53,200
We're reading it twice.

212
00:07:53,400 --> 00:07:54,300
It should be the same.

213
00:07:54,600 --> 00:07:55,700
So, duh.

214
00:07:55,900 --> 00:07:59,600
The compiler should just load it once, right.

215
00:08:00,000 --> 00:08:02,900
Just turn that into this so it doesn't have to go out to memory two

216
00:08:02,900 --> 00:08:04,900
times to find out what that is.

217
00:08:04,900 --> 00:08:05,600
It should be efficient.

218
00:08:05,600 --> 00:08:06,100
Right?

219
00:08:06,200 --> 00:08:06,800
Well, the answer is.

220
00:08:06,800 --> 00:08:08,000
It cannot do that?

221
00:08:08,000 --> 00:08:10,200
And the reason it cannot do that is because we have not given the

222
00:08:10,200 --> 00:08:14,500
compiler enough information to know that a does not point to the same

223
00:08:14,500 --> 00:08:15,500
location as be.

224
00:08:15,600 --> 00:08:18,900
So it could be that this right to a right here, this right of 5 over

225
00:08:18,900 --> 00:08:21,600
wrote the previous value, that was in Star B.

226
00:08:21,600 --> 00:08:25,900
Because if the pointer, I mean, if somewhere outside of here, before

227
00:08:25,900 --> 00:08:29,600
we got here, before we got to hear, if someone had done

228
00:08:29,900 --> 00:08:30,800
A equals B.

229
00:08:31,000 --> 00:08:34,000
Well, then this code just reads and writes from the same location.

230
00:08:34,000 --> 00:08:37,000
So this will equal 5, right?

231
00:08:37,000 --> 00:08:38,200
But this will equal.

232
00:08:38,200 --> 00:08:43,400
Whatever was actually there, before we wrote the five, right?

233
00:08:43,400 --> 00:08:45,000
Make sense everyone on board with that.

234
00:08:45,000 --> 00:08:46,100
I hope so.

235
00:08:46,100 --> 00:08:47,300
That is called aliasing.

236
00:08:47,400 --> 00:08:48,500
It is a situation.

237
00:08:48,800 --> 00:08:50,000
Well, is one type of aliasing.

238
00:08:50,000 --> 00:08:52,100
There are actually a lot of types of aliasing, but that is pointer

239
00:08:52,100 --> 00:08:52,600
aliasing.

240
00:08:53,200 --> 00:08:53,900
That is what happens.

241
00:08:53,900 --> 00:08:56,600
When you have two pointers that could point to the same thing and the

242
00:08:56,600 --> 00:08:57,500
compiler does not know.

243
00:08:57,500 --> 00:08:59,800
So there are ways you can actually mark up your code.

244
00:09:00,000 --> 00:09:03,000
Now, the compiler things about the fact that there is no aliasing and

245
00:09:03,000 --> 00:09:03,900
its various stuff like this.

246
00:09:03,900 --> 00:09:06,700
But one of the easiest way to do it is to just not use any pointers.

247
00:09:06,700 --> 00:09:10,600
So if you can get pointers out of the equation entirely, sometimes

248
00:09:10,600 --> 00:09:12,000
that's more effective.

249
00:09:12,200 --> 00:09:14,700
And one of the things that you'll notice about this function is, it is

250
00:09:14,700 --> 00:09:15,300
small.

251
00:09:15,400 --> 00:09:16,600
It is a very small function.

252
00:09:17,200 --> 00:09:20,200
It is a classic candidate for what's called in lining, which is where

253
00:09:20,200 --> 00:09:21,100
the compiler will go.

254
00:09:21,100 --> 00:09:24,600
Hey, there is not much work being done here, maybe instead of actually

255
00:09:24,600 --> 00:09:26,100
generating a whole function for it.

256
00:09:26,100 --> 00:09:28,700
I will just go to the place that it's called and I will just shove the

257
00:09:28,700 --> 00:09:29,300
code, right?

258
00:09:29,300 --> 00:09:29,900
Actually, in

259
00:09:30,000 --> 00:09:30,200
There.

260
00:09:30,600 --> 00:09:33,300
And if it's going to do that, that's pretty handy.

261
00:09:33,300 --> 00:09:35,700
It can go ahead and look at this and know that it's not.

262
00:09:36,000 --> 00:09:39,500
It can inline it and know that it's not actually a problem to go ahead

263
00:09:39,500 --> 00:09:43,000
and assume that this client wreck stuff is all the same and you may be

264
00:09:43,000 --> 00:09:43,600
asking

265
00:09:45,400 --> 00:09:48,500
It's totally illegitimate Casey if it's going to do that.

266
00:09:48,500 --> 00:09:51,000
If I just have a star here, why isn't the compiler smart enough to

267
00:09:51,000 --> 00:09:51,600
figure out that?

268
00:09:51,600 --> 00:09:53,000
Hey, it's just a pointer.

269
00:09:53,100 --> 00:09:54,000
We're not changing the pointer.

270
00:09:54,000 --> 00:09:55,100
There aren't two pointers.

271
00:09:55,400 --> 00:09:56,100
What's going on?

272
00:09:56,100 --> 00:09:57,600
Why do you think there's aliasing there?

273
00:09:58,000 --> 00:10:01,200
Well, the answer and you should definitely defer to to people who work

274
00:10:01,200 --> 00:10:02,400
on compilers for this sort of thing.

275
00:10:03,600 --> 00:10:05,800
The answer is that actually what the compiler ends up seeing at the

276
00:10:05,800 --> 00:10:07,600
end of the day, isn't something quite this simple.

277
00:10:07,600 --> 00:10:11,300
Oftentimes, oftentimes the optimizer happens at the end of a bunch of

278
00:10:11,300 --> 00:10:13,100
things that occur inside a compiler.

279
00:10:13,300 --> 00:10:16,700
It basically turns things into stuff like bytecode or pseudocode

280
00:10:16,700 --> 00:10:20,000
different things called IRS intermediate, representations.

281
00:10:20,200 --> 00:10:20,800
The code goes through.

282
00:10:20,800 --> 00:10:21,800
A bunch of Transformations.

283
00:10:23,200 --> 00:10:27,100
Comes out the other side and the optimizer gets this big goopy mess.

284
00:10:27,300 --> 00:10:28,600
That's just the way the compilers work.

285
00:10:28,600 --> 00:10:30,000
There's a number of reasons for it, you might argue.

286
00:10:30,000 --> 00:10:33,300
It's a bad idea or or you may say that it's a good idea, but either.

287
00:10:33,400 --> 00:10:35,200
Way that is, what's going on a lot of compilers.

288
00:10:35,200 --> 00:10:38,500
And so at the end of the day, this will probably not actually look so

289
00:10:38,500 --> 00:10:40,000
clean to the optimizer.

290
00:10:40,000 --> 00:10:41,700
It'll look like a bunch of different things.

291
00:10:41,700 --> 00:10:45,300
It'll actually look like four different memory, locations left top,

292
00:10:45,500 --> 00:10:48,600
right and bottom that all came in here at the top of this code, and it

293
00:10:48,600 --> 00:10:50,700
has to sort of go back and do memory partitioning to go.

294
00:10:50,700 --> 00:10:51,700
Oh, that's what's going on.

295
00:10:52,000 --> 00:10:53,500
There's a whole bunch of stuff that happens.

296
00:10:53,900 --> 00:10:56,800
So, I don't want to belabor that point too much largely, because I am

297
00:10:56,800 --> 00:10:59,400
not an expert on optimizing compilers by any stretch of the

298
00:10:59,400 --> 00:11:02,100
imagination and Iowa, probably going to explain them poorly.

299
00:11:02,100 --> 00:11:03,200
If I try to give you specifics,

300
00:11:03,300 --> 00:11:03,400
X.

301
00:11:03,600 --> 00:11:06,600
But point being one thing you can do to help the compiler out is if

302
00:11:06,600 --> 00:11:10,900
you are passing relatively small things and you can pass them by value

303
00:11:11,000 --> 00:11:11,600
nowadays.

304
00:11:11,600 --> 00:11:13,000
It is probably a good idea to do that.

305
00:11:13,000 --> 00:11:15,100
Whereas in the old days of probably wasn't because there wasn't as

306
00:11:15,100 --> 00:11:15,900
much compiler.

307
00:11:15,900 --> 00:11:18,800
Optimization stuff going on nowadays, there is so probably we should

308
00:11:18,800 --> 00:11:21,700
have just done that someone wrote in to suggest that we do that.

309
00:11:21,700 --> 00:11:23,300
And I think that's probably a good suggestion.

310
00:11:23,300 --> 00:11:27,300
I oftentimes past things by value, a lot of times and that is probably

311
00:11:27,300 --> 00:11:27,700
a good one.

312
00:11:27,700 --> 00:11:29,300
So I say, we go ahead and make that.

313
00:11:29,500 --> 00:11:32,100
But one thing that we could do in the future, as we could look at the

314
00:11:32,100 --> 00:11:33,200
code to see,

315
00:11:33,400 --> 00:11:34,900
What the difference was in this case?

316
00:11:34,900 --> 00:11:36,000
It's not performance-critical.

317
00:11:36,000 --> 00:11:37,600
So I don't think we really need to do that.

318
00:11:37,800 --> 00:11:38,900
But it's just something to consider.

319
00:11:39,200 --> 00:11:39,700
Okay.

320
00:11:40,800 --> 00:11:42,700
Now that we've gotten rid of that.

321
00:11:42,700 --> 00:11:44,300
Sorry, go ahead and do that.

322
00:11:44,800 --> 00:11:46,800
Now that we've gotten gotten that out of the way.

323
00:11:47,000 --> 00:11:50,300
I have one more email that I thought was good to go over it something

324
00:11:50,500 --> 00:11:51,900
someone sent in.

325
00:11:52,400 --> 00:11:55,400
Basically what they were asking, they were following along at home,

326
00:11:55,400 --> 00:11:56,100
which is awesome.

327
00:11:56,200 --> 00:11:58,700
The number of people following this areas along at home has been

328
00:11:58,900 --> 00:11:59,800
surprisingly.

329
00:12:00,000 --> 00:12:00,400
Charge.

330
00:12:00,400 --> 00:12:03,800
And that is awesome to all of you out there who are typing while I am

331
00:12:03,800 --> 00:12:06,400
typing, that is just totally cool.

332
00:12:06,400 --> 00:12:07,200
And I love all the stuff.

333
00:12:07,200 --> 00:12:08,900
You guys have been trying and sending me questions.

334
00:12:08,900 --> 00:12:09,900
It's been awesome.

335
00:12:10,700 --> 00:12:14,300
Anyway, what they mentioned is they said, hey when I was following

336
00:12:14,300 --> 00:12:17,600
along I accidentally put this definition, the MSG, the message

337
00:12:17,600 --> 00:12:18,100
structure.

338
00:12:18,100 --> 00:12:22,300
I put it out here instead of putting it inside the, the actual run

339
00:12:22,300 --> 00:12:22,600
loop.

340
00:12:22,600 --> 00:12:26,800
I put it out here and what he was asking is essentially what is the

341
00:12:26,800 --> 00:12:29,900
difference like we're what what difference does it?

342
00:12:30,000 --> 00:12:32,900
Make to the actual code that gets generated where I put this.

343
00:12:32,900 --> 00:12:34,500
And again, that is an awesome thing to ask.

344
00:12:34,500 --> 00:12:36,500
That is exactly the kind of thing that I hope people are thinking

345
00:12:36,500 --> 00:12:39,400
about, because that is the kind of minutiae that you want to learn.

346
00:12:39,400 --> 00:12:42,500
Because once you learn it, you know, it forever and now, you just have

347
00:12:42,500 --> 00:12:45,300
so much better idea of what kind of code is getting generated and

348
00:12:45,300 --> 00:12:48,000
nowadays, people are very detached from the actual stuff.

349
00:12:48,000 --> 00:12:48,900
The CPU is doing.

350
00:12:49,100 --> 00:12:52,200
And again, one of things I really want to hammer home is, it's great

351
00:12:52,200 --> 00:12:56,400
to stop that to actually go and reach down and really figure out

352
00:12:56,400 --> 00:12:56,900
what's going on.

353
00:12:56,900 --> 00:12:58,800
It makes you such a much better program or just to know.

354
00:12:59,300 --> 00:12:59,700
Anyway.

355
00:13:00,300 --> 00:13:03,200
The difference is essentially nothing.

356
00:13:05,500 --> 00:13:08,200
You will be heartened to know that most compilers, as far as I'm aware

357
00:13:08,500 --> 00:13:11,400
are pretty smart about, how they lay out things on the stack.

358
00:13:11,400 --> 00:13:14,600
Now, basically what happens is when we come into this function again,

359
00:13:14,700 --> 00:13:18,400
if you saw the intro to see stream, there is a stack and the stack is

360
00:13:18,400 --> 00:13:21,500
basically something that is a block of memory that is reserved for our

361
00:13:21,500 --> 00:13:26,500
program as it runs and it grows on the top and shrinks every time we

362
00:13:26,500 --> 00:13:27,600
call and return from a function.

363
00:13:27,600 --> 00:13:29,700
So we call into a function, it pushes.

364
00:13:29,900 --> 00:13:33,100
Onto the stack, it basically puts on the values that we pass the

365
00:13:33,100 --> 00:13:35,800
function and it puts on the values that that function needs for its

366
00:13:35,800 --> 00:13:36,400
local variables.

367
00:13:36,400 --> 00:13:38,700
So when we declare something like a local variable, like this wind

368
00:13:38,700 --> 00:13:42,000
class here, like these integers and like that message structure is

369
00:13:42,000 --> 00:13:45,600
basically just growing the stack out to make room to store that.

370
00:13:46,000 --> 00:13:47,700
So instead of actually doing an allocation.

371
00:13:47,800 --> 00:13:50,400
Remember we did a virtual Alec up there to Alec a block of memory

372
00:13:51,000 --> 00:13:52,800
instead of doing an allocation, which is something that will sit

373
00:13:52,800 --> 00:13:53,500
around for a while.

374
00:13:53,500 --> 00:13:56,300
It's just putting it on that stack the stack kind of grows and shrinks

375
00:13:56,300 --> 00:13:58,200
and it's just memory that ends up being reused.

376
00:13:58,200 --> 00:13:59,400
You can think of it almost

377
00:14:00,500 --> 00:14:02,800
You know, like a watermark, you know, it's like a we've got, we've got

378
00:14:02,800 --> 00:14:03,600
this pool.

379
00:14:03,700 --> 00:14:06,300
You know, we got this big old swimming pool and it's empty.

380
00:14:06,300 --> 00:14:08,700
When we start the program in the water level rises and the water will

381
00:14:08,700 --> 00:14:11,600
strengthen the water level rises again, and we're just using that big

382
00:14:11,600 --> 00:14:12,200
empty space.

383
00:14:12,200 --> 00:14:14,100
We're using the same space over and over again.

384
00:14:14,200 --> 00:14:17,500
So when you call into a function, it uses space on the stack store,

385
00:14:17,500 --> 00:14:19,600
the local variables, throw the parameters that it uses that sort of

386
00:14:19,600 --> 00:14:20,000
thing.

387
00:14:20,400 --> 00:14:23,800
When you return from that function, it backs up the stack to the

388
00:14:23,800 --> 00:14:28,600
point, you know, it no longer is using that area, but then the very

389
00:14:28,600 --> 00:14:30,000
next function you call Will reuse.

390
00:14:30,200 --> 00:14:32,300
That same area that was used by the previous function, right?

391
00:14:32,300 --> 00:14:34,300
So it's constantly getting reuse the stuff on the stack.

392
00:14:34,800 --> 00:14:39,200
So the question of what happens when I declare a new thing.

393
00:14:39,300 --> 00:14:42,300
Like, this is basically that it's largely for your convenience where

394
00:14:42,300 --> 00:14:45,800
you put it when you put something inside a while loop, what that means

395
00:14:45,800 --> 00:14:47,800
is nobody can reference it outside the while loop.

396
00:14:47,800 --> 00:14:49,900
So the reason that I put it there was because basically, I didn't want

397
00:14:49,900 --> 00:14:50,700
people out here.

398
00:14:51,200 --> 00:14:52,800
I don't want people, maybe who are going to be.

399
00:14:52,800 --> 00:14:54,100
Let's say, let's say someone right here.

400
00:14:54,200 --> 00:14:55,500
I didn't want them touching this.

401
00:14:55,500 --> 00:14:57,400
I didn't want them doing stuff to message in here.

402
00:14:57,500 --> 00:14:58,300
That's no good.

403
00:14:58,400 --> 00:14:59,800
Because messages is is

404
00:15:00,000 --> 00:15:01,900
Supposed to be something that's used as a result.

405
00:15:02,200 --> 00:15:02,700
Basically.

406
00:15:02,800 --> 00:15:05,400
The only reason we have in the first place is to get a result from

407
00:15:05,400 --> 00:15:06,300
Peak message.

408
00:15:06,400 --> 00:15:08,300
So I certainly don't want them using it out there and I definitely

409
00:15:08,300 --> 00:15:11,100
don't want them using it down here, which they could also do because

410
00:15:11,100 --> 00:15:12,000
it was declared up here.

411
00:15:12,000 --> 00:15:14,500
Remember, it is in this outer scope, the scope right here.

412
00:15:14,500 --> 00:15:16,400
So anyone in that block could use it.

413
00:15:16,600 --> 00:15:19,700
And so basically what I'm doing, when I put things inside particular,

414
00:15:19,700 --> 00:15:23,800
blocks and functions is really, I'm just trying to make sure that they

415
00:15:23,800 --> 00:15:25,700
are sort of lexically scoped.

416
00:15:25,800 --> 00:15:28,800
Meaning the people who can refer to them, lexically scoped, as

417
00:15:28,800 --> 00:15:29,700
narrowly as possible.

418
00:15:30,000 --> 00:15:33,700
To avoid people, accidentally referring to things that they should not

419
00:15:33,700 --> 00:15:33,900
be.

420
00:15:33,900 --> 00:15:36,700
And while it seems like, that's an odd thing to protect against.

421
00:15:36,700 --> 00:15:39,200
It actually is kind of useful because oftentimes code gets moved

422
00:15:39,200 --> 00:15:40,700
around and cut and paste it.

423
00:15:40,700 --> 00:15:43,900
In various ways, inside a function and you may accidentally leave

424
00:15:43,900 --> 00:15:46,800
something that kind of moves to some place, it shouldn't, and you've

425
00:15:46,800 --> 00:15:47,300
got a bug.

426
00:15:47,300 --> 00:15:48,700
So it's just helpful to kind of put that in there.

427
00:15:48,700 --> 00:15:49,300
Helps compiler.

428
00:15:49,300 --> 00:15:50,900
Catch a few mistakes for you.

429
00:15:51,000 --> 00:15:51,100
No.

430
00:15:51,100 --> 00:15:51,600
Big deal.

431
00:15:51,600 --> 00:15:54,500
If not, a lot of people who program and Street see put all their

432
00:15:54,500 --> 00:15:58,500
variable declarations at the top because that, you know, C does not

433
00:15:58,500 --> 00:15:59,800
have declare anywhere until C90.

434
00:16:00,000 --> 00:16:02,600
That's a habit, some people got into and so on so forth and that's

435
00:16:02,600 --> 00:16:03,100
totally fine.

436
00:16:03,100 --> 00:16:06,700
So you can certainly be a very productive programmer without doing

437
00:16:06,700 --> 00:16:08,400
that, but it's something to consider.

438
00:16:11,500 --> 00:16:15,400
So when you put it anywhere doesn't matter where you put it.

439
00:16:15,800 --> 00:16:19,400
Basically all that's going to happen is the compiler at its discretion

440
00:16:19,400 --> 00:16:21,900
at some point during the execution of this function.

441
00:16:22,000 --> 00:16:23,700
Whether it's at the beginning or right?

442
00:16:23,700 --> 00:16:27,400
When it sees it, or any time like that is going to enlarge the stack

443
00:16:27,400 --> 00:16:28,200
to hold it.

444
00:16:28,300 --> 00:16:30,700
That is the only real requirement as far as I'm aware.

445
00:16:30,900 --> 00:16:34,400
That the compiler has to adhere to, it has to be able to do that, but

446
00:16:34,400 --> 00:16:37,800
it can do basically anything it wants to do to optimize it, so you

447
00:16:37,800 --> 00:16:40,500
don't have to put it out here to prevent it from like basically

448
00:16:40,500 --> 00:16:41,200
growing and shrinking.

449
00:16:41,400 --> 00:16:42,400
Stack all the time in here.

450
00:16:42,500 --> 00:16:43,700
An optimizing compiler.

451
00:16:44,000 --> 00:16:46,700
I should think would be plenty smart enough to make sure that it can

452
00:16:46,700 --> 00:16:49,300
always just do that allocation knowing that it's always going to have

453
00:16:49,300 --> 00:16:49,900
to happen.

454
00:16:50,300 --> 00:16:53,200
Do that stack grow up at the top and and and make it nice and

455
00:16:53,200 --> 00:16:55,700
efficient so you can put it in there and I don't think there's really

456
00:16:55,700 --> 00:16:59,200
any penalty now, it's worth noting that in C++.

457
00:16:59,300 --> 00:17:02,700
If you are going crazy with your C++ - there is another thing to watch

458
00:17:02,700 --> 00:17:03,100
out for.

459
00:17:03,100 --> 00:17:07,300
And what that thing is, is that individual structures classes, those

460
00:17:07,300 --> 00:17:08,000
sorts of things.

461
00:17:08,500 --> 00:17:11,200
They can have Constructors and destructors and what?

462
00:17:11,300 --> 00:17:12,200
Instructors and D structures.

463
00:17:12,200 --> 00:17:15,200
Are things that happen when something comes into existence and when

464
00:17:15,200 --> 00:17:18,400
something goes out of existence, they're basically function calls that

465
00:17:18,400 --> 00:17:20,700
are triggered on those boundaries.

466
00:17:20,700 --> 00:17:24,300
And if you had something in here like the message structure, if that

467
00:17:24,300 --> 00:17:27,000
had a Constructor a Destructor, the definition of what the compiler

468
00:17:27,000 --> 00:17:29,700
has to do, is it has to call the Constructor when it is created and it

469
00:17:29,700 --> 00:17:33,000
has to call the destructor when it is eliminated.

470
00:17:34,700 --> 00:17:37,100
So in that case, there would be something additional think about

471
00:17:37,200 --> 00:17:40,200
putting it inside this while loop means that every time through the

472
00:17:40,200 --> 00:17:42,600
while loop, it would call The Constructor right here.

473
00:17:42,600 --> 00:17:45,800
And it would call the destructor right here at the end of the scope.

474
00:17:46,300 --> 00:17:47,700
That is the compilers responsibility.

475
00:17:47,700 --> 00:17:50,000
It does not have the flexibility to do anything else, unless it can

476
00:17:50,000 --> 00:17:51,100
determine that.

477
00:17:51,100 --> 00:17:54,100
It can safely, defer that destruction in some way it pretty much has

478
00:17:54,100 --> 00:17:54,700
to do it.

479
00:17:54,800 --> 00:17:55,900
That is the specification.

480
00:17:56,400 --> 00:17:59,800
And so there is a real difference, potentially, even performance-wise.

481
00:18:00,200 --> 00:18:03,500
Between that and this if there was a Constructor call because that

482
00:18:03,500 --> 00:18:06,400
Constructor called could be expensive and the compiler is now doing

483
00:18:06,400 --> 00:18:07,800
something else in the loop.

484
00:18:07,800 --> 00:18:10,800
It is not just a case of it having to reserve space for this somewhere

485
00:18:10,800 --> 00:18:13,700
up here, and just using it when it gets down here is not just lexical

486
00:18:13,700 --> 00:18:14,200
scoping.

487
00:18:14,300 --> 00:18:16,200
That is actually creating real program Behavior.

488
00:18:16,200 --> 00:18:17,600
So that's something to be aware of.

489
00:18:17,600 --> 00:18:20,900
We will almost never be using anything like that in this stream, but a

490
00:18:20,900 --> 00:18:22,800
lot of programmers do use those sorts of things.

491
00:18:22,800 --> 00:18:24,200
So be aware of it.

492
00:18:24,400 --> 00:18:24,700
Okay.

493
00:18:24,700 --> 00:18:28,400
Hopefully, that answer that question pretty well and we are done with

494
00:18:28,400 --> 00:18:29,900
the questions from

495
00:18:30,000 --> 00:18:30,600
Um, the email.

496
00:18:30,600 --> 00:18:35,900
Now one more thing for those of you who are following along in my DOT

497
00:18:35,900 --> 00:18:40,300
e Max file, if you look in my daddy, Max file in here, we've got dot e

498
00:18:40,300 --> 00:18:41,500
Max in the Mist, directory.

499
00:18:41,800 --> 00:18:44,700
I set my font to Liberation mono.

500
00:18:45,300 --> 00:18:49,300
That is that is the font that I load and it turns out that that is not

501
00:18:49,300 --> 00:18:52,200
a font that is often on machines by default.

502
00:18:52,200 --> 00:18:54,800
So if you would like to get it, if you're, if you're trying to follow

503
00:18:54,800 --> 00:18:59,200
along with my emacs file directly, you want to type Liberation mono

504
00:18:59,300 --> 00:18:59,900
into your

505
00:19:00,000 --> 00:19:02,800
We'll search and you can go on here to the red hat page and you can

506
00:19:02,800 --> 00:19:05,500
download it that will prevent you from getting an error in the dot e,

507
00:19:05,500 --> 00:19:06,200
Max file.

508
00:19:06,500 --> 00:19:09,400
So, I would redistribute the font, but I don't know if that's

509
00:19:09,400 --> 00:19:10,200
technically allowed.

510
00:19:10,200 --> 00:19:13,600
I want everything in this package to be distributable in the public

511
00:19:13,600 --> 00:19:13,900
domain.

512
00:19:13,900 --> 00:19:17,200
So I am not going to include it, but you can go get it yourself.

513
00:19:17,900 --> 00:19:23,000
All righty, all that said, that is the entire cleanup for the week

514
00:19:23,000 --> 00:19:23,800
that I can remember.

515
00:19:26,100 --> 00:19:29,100
So now is the time for us to kind of look at this code and go a little

516
00:19:29,100 --> 00:19:32,900
more in-depth from what we were able to do when we were actually

517
00:19:32,900 --> 00:19:33,400
implementing.

518
00:19:33,400 --> 00:19:36,100
So first thing I want to do is I want to look at these Global

519
00:19:36,100 --> 00:19:36,600
variables.

520
00:19:37,100 --> 00:19:39,400
These Global variables are not something that I really like to have

521
00:19:39,400 --> 00:19:42,300
around, like I was saying the reason for that is they kind of get a

522
00:19:42,300 --> 00:19:45,800
little it gets a little confusing to know who and when and where and

523
00:19:45,800 --> 00:19:49,500
so on, they're being accessed and you can do that, you know, if you

524
00:19:49,500 --> 00:19:51,700
want to you can work around that.

525
00:19:51,700 --> 00:19:53,800
Actually, if you have Global variables and you like to use them, there

526
00:19:53,800 --> 00:19:54,900
are ways to work around that you

527
00:19:55,100 --> 00:19:56,200
You things like coming here?

528
00:19:56,200 --> 00:20:00,000
If you have a cleanly compiling program, you can add some random

529
00:20:00,000 --> 00:20:02,200
character to the end of a variable and hit compile.

530
00:20:02,200 --> 00:20:06,200
Again, and that will show you all of the places that it was used

531
00:20:06,200 --> 00:20:10,200
because you will generate errors in all the functions that reference

532
00:20:10,200 --> 00:20:10,200
that.

533
00:20:10,200 --> 00:20:11,200
So that is one way.

534
00:20:11,200 --> 00:20:12,300
You can figure that out.

535
00:20:12,300 --> 00:20:15,300
But I would rather go ahead and bundle these things up into a

536
00:20:15,300 --> 00:20:16,700
something that's a little bit more concise.

537
00:20:16,700 --> 00:20:17,400
Again.

538
00:20:17,400 --> 00:20:18,900
This is not for performance or anything like that.

539
00:20:18,900 --> 00:20:22,900
This is strictly because I would like to keep the code in something in

540
00:20:22,900 --> 00:20:23,100
a way.

541
00:20:23,100 --> 00:20:24,600
That's a little more clean way.

542
00:20:24,600 --> 00:20:25,000
That's a little

543
00:20:25,100 --> 00:20:28,400
It'll more manageable so that we can see easily, no matter who is

544
00:20:28,400 --> 00:20:32,400
looking at the code exactly what had to happen for these bitmaps.

545
00:20:32,800 --> 00:20:35,600
For this off-screen buffer that we created that were drawing the

546
00:20:35,600 --> 00:20:37,200
screen every time to exist.

547
00:20:37,200 --> 00:20:38,800
And so, basically, what I'm going to do is, I'm just going to open a

548
00:20:38,800 --> 00:20:41,300
struct and I'm going to go ahead and put the stuff in there.

549
00:20:41,600 --> 00:20:43,300
All the stuff that we actually needed.

550
00:20:43,400 --> 00:20:46,000
So we knew we needed a bit map info to describe our bitmap.

551
00:20:46,000 --> 00:20:49,300
We know we needed a pointer to the actual bits of that bitmap.

552
00:20:49,500 --> 00:20:51,800
We know that we needed the width and the height.

553
00:20:51,800 --> 00:20:53,900
And I'm going to go ahead and remove bitmap from these because since

554
00:20:53,900 --> 00:20:54,900
they're in a structure now,

555
00:20:55,100 --> 00:20:58,200
we've got to know that so I'm going to go ahead and remove bitmap from

556
00:20:58,200 --> 00:20:58,400
those.

557
00:20:58,400 --> 00:20:59,900
We're going to have the width and the height there and

558
00:21:00,000 --> 00:21:03,000
Also going to have the bytes per pixel and one of the things that's

559
00:21:03,000 --> 00:21:05,000
nice about this, you can see bundle this all up together.

560
00:21:05,000 --> 00:21:07,300
And now we know that anyone needs to operate on this bitmap.

561
00:21:07,300 --> 00:21:10,600
We can just pass this structure and we're going to call this our

562
00:21:10,600 --> 00:21:16,000
off-screen win32 off-screen buffer for now because I don't have a

563
00:21:16,000 --> 00:21:16,900
better idea for a name.

564
00:21:16,900 --> 00:21:18,000
So that's what we're going to use.

565
00:21:18,300 --> 00:21:21,700
So basically if I just bundle those things up, now anyone who have to

566
00:21:21,700 --> 00:21:25,700
use this can just get a pointer to one of these off-screen buffers or

567
00:21:25,700 --> 00:21:28,800
pass by value, as the case may be, and they're not going to modify it

568
00:21:29,000 --> 00:21:29,900
and then they can go to

569
00:21:30,000 --> 00:21:32,000
town and they know they have all the information, they need, the

570
00:21:32,000 --> 00:21:33,800
width, the height, the bytes per pixel and so on.

571
00:21:34,000 --> 00:21:36,500
So I'm going to go ahead and change our functions here to actually

572
00:21:36,500 --> 00:21:37,000
work on that.

573
00:21:37,000 --> 00:21:39,200
And you can notice this surrender, weird gradient.

574
00:21:39,400 --> 00:21:42,200
It will now take an off-screen buffer and it knows to write to it and

575
00:21:42,200 --> 00:21:43,800
you can see that we're kind of Levering up.

576
00:21:44,000 --> 00:21:45,500
We've got a little bit more power here.

577
00:21:45,900 --> 00:21:48,400
The reason that we have a little bit more power is actually because

578
00:21:48,600 --> 00:21:51,300
now we can have multiple off-screen buffers before we don't we have

579
00:21:51,300 --> 00:21:52,500
those global variables.

580
00:21:52,500 --> 00:21:54,400
Well, if you did render read gradient, it was always going to go in

581
00:21:54,400 --> 00:21:55,300
and saying buffer, right?

582
00:21:55,300 --> 00:21:55,900
Same buffer.

583
00:21:55,900 --> 00:21:58,100
You could never have multiple buffers, but maybe we wanted multiple

584
00:21:58,100 --> 00:21:59,100
buffers for some reason.

585
00:21:59,200 --> 00:21:59,800
Who knows.

586
00:22:00,000 --> 00:22:02,300
Now we have the flexibility to do that, because every time you call

587
00:22:02,300 --> 00:22:04,900
render weird gradient, we're going to pass at the buffer to use and we

588
00:22:04,900 --> 00:22:06,700
could have tons of different buffers if we wanted to.

589
00:22:08,600 --> 00:22:11,200
So again, that's a lot of the reason for pulling things out, a global

590
00:22:11,200 --> 00:22:13,200
variables for pulling things together.

591
00:22:13,200 --> 00:22:15,400
It makes it clearer, and it also makes it more flexible.

592
00:22:16,000 --> 00:22:19,900
So, the width and the height here, I'm just going to dereference into

593
00:22:19,900 --> 00:22:20,600
that buffer.

594
00:22:20,800 --> 00:22:22,000
And again, I don't know.

595
00:22:22,000 --> 00:22:23,300
This is a pretty giant guy.

596
00:22:23,500 --> 00:22:24,800
I don't actually know if I want to pass.

597
00:22:24,800 --> 00:22:25,700
This guy by value.

598
00:22:26,000 --> 00:22:28,000
We could pass them by Bali because we're not really going to change

599
00:22:28,000 --> 00:22:28,300
him.

600
00:22:28,300 --> 00:22:29,700
So we could actually do it this way.

601
00:22:29,800 --> 00:22:31,200
And I don't know, which one's better.

602
00:22:31,300 --> 00:22:32,400
You know, what, let's do this.

603
00:22:32,400 --> 00:22:34,500
Let's actually go ahead and do that since the nineties, an exploration

604
00:22:34,500 --> 00:22:34,900
screen.

605
00:22:35,100 --> 00:22:37,700
Let's see what the optimizer does.

606
00:22:37,800 --> 00:22:38,300
Let's actually

607
00:22:38,500 --> 00:22:41,500
Take a look and see what the optimizer does.

608
00:22:41,500 --> 00:22:44,800
If you pass this by value to see whether or not it does the right

609
00:22:44,800 --> 00:22:45,600
thing in either case.

610
00:22:45,900 --> 00:22:48,200
Okay, so I'm gonna go ahead and pass that buffer in here at the buffer

611
00:22:48,200 --> 00:22:51,600
that supposed to write to and I will go ahead and change all of these

612
00:22:51,600 --> 00:22:52,600
things that have to happen.

613
00:22:52,600 --> 00:22:54,600
Bytes per pixel, also coming out of the buffer.

614
00:22:54,600 --> 00:22:59,000
Now, the memory also coming out of the buffer and that looks like just

615
00:22:59,000 --> 00:23:02,100
about everything.

616
00:23:02,100 --> 00:23:03,800
Let's see here.

617
00:23:03,800 --> 00:23:05,100
Yes, that is now clean.

618
00:23:05,100 --> 00:23:05,800
Looks like it's doing it now.

619
00:23:05,800 --> 00:23:08,000
The pitch was computed.

620
00:23:08,400 --> 00:23:09,600
And this thing is operating off.

621
00:23:09,600 --> 00:23:12,100
That one thing that we could do here is the side that the pitch is

622
00:23:12,100 --> 00:23:12,800
also variable.

623
00:23:12,800 --> 00:23:15,400
So we can have a little bit more flexibility with how we actually

624
00:23:15,400 --> 00:23:16,300
allocate that.

625
00:23:16,300 --> 00:23:18,200
So we I'm going to go ahead and put that in there.

626
00:23:18,600 --> 00:23:21,000
And then I'm going to move the pitch computation down into here

627
00:23:21,000 --> 00:23:23,500
because we're going to need that in a second.

628
00:23:23,600 --> 00:23:24,200
All right.

629
00:23:24,700 --> 00:23:26,400
So here is our off-screen buffer.

630
00:23:26,400 --> 00:23:28,300
We're going to render our weird gradient to it.

631
00:23:28,500 --> 00:23:30,100
And it looks like that's pretty clean.

632
00:23:30,100 --> 00:23:30,800
Let me compile.

633
00:23:30,800 --> 00:23:32,400
That should compile that cleanly.

634
00:23:32,700 --> 00:23:33,000
Oops.

635
00:23:33,000 --> 00:23:33,300
Nope.

636
00:23:33,300 --> 00:23:35,300
Gotta get that out of the buffer as well.

637
00:23:35,700 --> 00:23:38,300
There's really no reason to for me too, dear.

638
00:23:38,400 --> 00:23:40,700
Reference those buffer, widths and Heights here for referencing by

639
00:23:40,700 --> 00:23:41,000
value.

640
00:23:41,000 --> 00:23:42,600
We can just go ahead and do that.

641
00:23:42,700 --> 00:23:44,600
So that should be fine as well.

642
00:23:44,900 --> 00:23:48,300
And so that looks like a totally reasonable compiled.

643
00:23:48,300 --> 00:23:48,500
Yes.

644
00:23:48,500 --> 00:23:49,500
So that is nice and clean.

645
00:23:49,500 --> 00:23:53,300
Now, takes the win32 off-screen buffer and drawers to it.

646
00:23:53,300 --> 00:23:54,100
Now, win32.

647
00:23:54,100 --> 00:23:55,200
Resize, dip section.

648
00:23:55,600 --> 00:23:59,500
That is going to take our win32 off-screen, buffer as well.

649
00:23:59,500 --> 00:23:59,800
But this

650
00:24:00,000 --> 00:24:03,900
Kind of interesting and something to note what we have to do here

651
00:24:04,000 --> 00:24:05,900
since we are changing this thing in place.

652
00:24:06,000 --> 00:24:08,900
We have two options, ladies and gentlemen, to options that we can do.

653
00:24:11,500 --> 00:24:15,900
If we were to pass this by value, that basically means that we have

654
00:24:15,900 --> 00:24:16,900
our own private copy of it.

655
00:24:16,900 --> 00:24:17,200
Yes.

656
00:24:17,400 --> 00:24:20,500
It means that when this function is called, we are getting a copy of

657
00:24:20,500 --> 00:24:23,000
an entire buffer that someone else was doing not the buffer memory

658
00:24:23,000 --> 00:24:23,300
itself.

659
00:24:23,300 --> 00:24:25,600
Because remember that as just a pointer that's inside here and a

660
00:24:25,600 --> 00:24:29,200
pointer is just 32 or 64 bits depending on how we're compiling, but we

661
00:24:29,200 --> 00:24:31,200
get a copy at least of this entire structure.

662
00:24:31,500 --> 00:24:33,400
So that means, excuse me.

663
00:24:34,100 --> 00:24:35,000
I'm still sick today.

664
00:24:35,500 --> 00:24:39,200
That means basically, any changes that we make will not stick.

665
00:24:39,200 --> 00:24:40,900
So you notice we're changing a bunch of things.

666
00:24:41,000 --> 00:24:41,100
We're

667
00:24:41,300 --> 00:24:43,400
Change a bunch of things in the buffer here, right?

668
00:24:43,400 --> 00:24:45,200
We are writing to all sorts of things.

669
00:24:45,300 --> 00:24:46,100
In this buffer.

670
00:24:46,100 --> 00:24:47,200
We are changing the width.

671
00:24:47,300 --> 00:24:48,400
We are changing the height.

672
00:24:48,500 --> 00:24:50,500
We are changing the bit map info structure.

673
00:24:50,800 --> 00:24:53,400
We are changing the memory that it points to.

674
00:24:53,500 --> 00:24:54,700
And we are Computing.

675
00:24:55,100 --> 00:24:57,300
The pitch, we are doing all kinds of stuff.

676
00:24:57,300 --> 00:24:57,800
Right?

677
00:24:57,900 --> 00:25:02,100
And since that is the case, that means that when this buffer comes

678
00:25:02,100 --> 00:25:04,900
into us and we get a copy if we go change that copy.

679
00:25:05,200 --> 00:25:08,000
Well, the person who called us is never going to see those changes.

680
00:25:08,100 --> 00:25:10,400
They're just gonna disappear because this is a local variable that's

681
00:25:10,400 --> 00:25:11,100
on our stack now.

682
00:25:11,200 --> 00:25:12,500
Basically, it's a parameter to us.

683
00:25:12,800 --> 00:25:15,400
So what we could do is we could if we were in functional programming

684
00:25:15,400 --> 00:25:19,600
style, we could return basically a new buffer to them, so we could

685
00:25:19,600 --> 00:25:20,800
just return buffer here.

686
00:25:20,900 --> 00:25:24,100
So that's a local variable and we could return it and they would have

687
00:25:24,100 --> 00:25:25,200
to capture that return.

688
00:25:25,400 --> 00:25:26,700
That's a little bit error prone.

689
00:25:26,800 --> 00:25:29,300
So this is not a particularly performance sensitive function.

690
00:25:29,300 --> 00:25:32,300
So, even if the compiler was going to have an easier time, optimizing

691
00:25:32,300 --> 00:25:33,100
something like this.

692
00:25:33,200 --> 00:25:34,600
I don't think I would prefer that.

693
00:25:34,700 --> 00:25:37,700
What I would prefer is a situation where basically it gets a pointer

694
00:25:37,700 --> 00:25:39,800
to a buffer and just modifies that buffer in place.

695
00:25:39,800 --> 00:25:40,900
That is much much more.

696
00:25:40,900 --> 00:25:41,100
What?

697
00:25:41,200 --> 00:25:46,100
I would prefer now really what we want to do is We Wish Chandler qarth

698
00:25:46,100 --> 00:25:49,100
was watching this stream and he could tell us if that was a terrible

699
00:25:49,100 --> 00:25:49,900
idea or not.

700
00:25:49,900 --> 00:25:52,500
We basically need some optimizing compiler author to come in here and

701
00:25:52,500 --> 00:25:55,500
tell us how bad it is that we're doing stuff like this.

702
00:25:57,700 --> 00:26:00,000
But at the end of the day, like I said, this function is called so

703
00:26:00,000 --> 00:26:00,600
infrequently.

704
00:26:00,600 --> 00:26:03,200
That we really just don't have to think about the performance

705
00:26:03,200 --> 00:26:06,300
implications of this because it is called once whenever you resize the

706
00:26:06,300 --> 00:26:09,300
window and that is also, it is not even called every frame of our

707
00:26:09,300 --> 00:26:09,800
game.

708
00:26:10,000 --> 00:26:12,300
It is not going to be on the critical path in any way.

709
00:26:12,800 --> 00:26:14,200
So I'm a little more comfortable running that way.

710
00:26:14,200 --> 00:26:15,400
I'm going to write it that way for now.

711
00:26:15,800 --> 00:26:18,700
But yes, if some day for some reason Chandler ever does, watch this

712
00:26:18,700 --> 00:26:22,500
stream, please tell us if we are being stupid, because that would be

713
00:26:22,700 --> 00:26:24,400
excellent information to have.

714
00:26:24,400 --> 00:26:27,300
So I'm going to go ahead and change these dots to the arrow reference.

715
00:26:27,600 --> 00:26:29,700
We have a pointer to a buffer, not an actual buffer.

716
00:26:30,100 --> 00:26:31,200
So I'm going to do that.

717
00:26:31,400 --> 00:26:33,700
And the other thing that I will note is we actually store the width

718
00:26:33,700 --> 00:26:35,100
and height in here.

719
00:26:35,200 --> 00:26:37,800
So if we were being super conscious about space, we would get rid of

720
00:26:37,800 --> 00:26:38,100
these.

721
00:26:38,300 --> 00:26:39,300
I don't think that's necessary.

722
00:26:39,300 --> 00:26:41,900
Because again, we've got so much memory to play with this point, and

723
00:26:41,900 --> 00:26:44,700
that is a tiny, little tiny little bit of that concern.

724
00:26:44,700 --> 00:26:47,500
So I'm going to go ahead and just finish up the porting here.

725
00:26:47,900 --> 00:26:50,500
We got to go ahead and free the memory out of that.

726
00:26:50,800 --> 00:26:52,900
We have to allocate the memory out of that.

727
00:26:52,900 --> 00:26:53,800
Yes, indeed.

728
00:26:53,800 --> 00:26:57,300
All of that is good and we have

729
00:26:57,400 --> 00:26:58,000
Have.

730
00:26:58,000 --> 00:26:58,400
Oh, right.

731
00:26:58,400 --> 00:26:59,600
We change that just to.

732
00:27:00,000 --> 00:27:02,500
So I'm going to go ahead and change.

733
00:27:02,500 --> 00:27:03,000
Do you know what?

734
00:27:03,000 --> 00:27:04,900
Everyone loves this so much in the streaming to do it again?

735
00:27:05,100 --> 00:27:06,700
Kill rectangle.

736
00:27:06,700 --> 00:27:07,900
I do not know why they like that.

737
00:27:07,900 --> 00:27:09,600
So much, ladies and gentlemen, but they do.

738
00:27:09,600 --> 00:27:10,800
So we need to do it.

739
00:27:11,100 --> 00:27:13,400
You have to give the people what they want.

740
00:27:13,400 --> 00:27:15,200
That's my opinion on that.

741
00:27:15,200 --> 00:27:18,000
It's got to actually change that buffer as well.

742
00:27:18,000 --> 00:27:21,000
And here we go, buffer width, buffer Heights again.

743
00:27:21,000 --> 00:27:22,800
I am doing absolutely nothing to the code right now.

744
00:27:22,800 --> 00:27:26,100
I'm just changing it to read out of that structure and that is a

745
00:27:26,100 --> 00:27:27,200
little bit of an artist process.

746
00:27:27,200 --> 00:27:29,300
I probably should have used a search and replace for this if I was

747
00:27:29,300 --> 00:27:29,800
smart.

748
00:27:30,200 --> 00:27:33,500
But what can you do you think of things after they would have been

749
00:27:33,500 --> 00:27:33,800
good?

750
00:27:33,800 --> 00:27:35,400
Sometimes the programming it happens.

751
00:27:35,400 --> 00:27:35,700
All right.

752
00:27:35,700 --> 00:27:39,200
So now we've got our resize set and it will take a buffer to resize as

753
00:27:39,200 --> 00:27:39,400
well.

754
00:27:39,400 --> 00:27:41,500
And now we're going to go down here to win, win through the update

755
00:27:41,500 --> 00:27:45,400
window and that as well should now, basically be instead of update

756
00:27:45,400 --> 00:27:45,700
window.

757
00:27:45,700 --> 00:27:51,300
I think we're going to call that win32 copy buffer to window, because

758
00:27:51,300 --> 00:27:54,900
that is what it is actually doing, or maybe you had will say display

759
00:27:54,900 --> 00:27:57,300
buffer in window, something like that.

760
00:27:57,300 --> 00:27:58,900
I don't know, whatever you like to call it.

761
00:27:58,900 --> 00:27:59,900
Is your code if

762
00:28:00,000 --> 00:28:00,900
Are typing in at home.

763
00:28:01,200 --> 00:28:05,200
And you have a, the control, you have all the control over.

764
00:28:05,200 --> 00:28:06,200
What is going to go on?

765
00:28:06,200 --> 00:28:10,500
Do not let me brainwash you into typing in the names that I like.

766
00:28:10,500 --> 00:28:11,000
All right.

767
00:28:11,000 --> 00:28:13,700
So this guy again, we're not going to change the buffer so we could go

768
00:28:13,700 --> 00:28:15,000
ahead and pass by value there.

769
00:28:15,000 --> 00:28:16,600
So maybe we'll go ahead and do that.

770
00:28:17,100 --> 00:28:22,600
And let's go ahead and change the width and height to come out of the

771
00:28:22,600 --> 00:28:23,200
buffer.

772
00:28:23,700 --> 00:28:29,800
Let's change the memory and the info that looks good to me.

773
00:28:29,900 --> 00:28:34,400
Me and that should be everything except the calls themselves.

774
00:28:34,400 --> 00:28:37,200
Yes, does look like that is the case.

775
00:28:37,300 --> 00:28:37,800
All right.

776
00:28:37,800 --> 00:28:40,300
So now we are not going to get rid of our Global variables entirely

777
00:28:40,300 --> 00:28:41,000
just yet.

778
00:28:41,100 --> 00:28:42,600
Maybe we will later.

779
00:28:42,600 --> 00:28:46,400
But what I'm going to do is I am going to actually just declare now a

780
00:28:46,400 --> 00:28:50,300
global version of this thing just to go ahead and quickly replace

781
00:28:50,400 --> 00:28:52,400
those places where we call it and then we'll think about whether we

782
00:28:52,400 --> 00:28:53,500
want to replace it.

783
00:28:54,700 --> 00:28:56,100
We're going to call this the back buffer.

784
00:28:56,500 --> 00:28:57,700
The global black buffer for now.

785
00:28:57,700 --> 00:28:59,800
Let's say because we are only going to have one

786
00:29:00,000 --> 00:29:05,300
I'm so it doesn't seem like a particularly important thing to actually

787
00:29:05,300 --> 00:29:06,800
have that be any local to anyone.

788
00:29:07,000 --> 00:29:08,000
Let's take a look here.

789
00:29:08,000 --> 00:29:08,500
Okay.

790
00:29:08,500 --> 00:29:11,400
I don't remember what order I even said that those things were in a

791
00:29:11,400 --> 00:29:12,800
didn't mean to actually create a new file.

792
00:29:12,800 --> 00:29:14,500
They're not my intention.

793
00:29:14,600 --> 00:29:17,500
Sometimes the emacs keyboard shortcuts get away from you.

794
00:29:17,500 --> 00:29:18,600
It is totally true.

795
00:29:19,300 --> 00:29:22,000
Alright, so this is the new function prototype that I made.

796
00:29:22,300 --> 00:29:23,600
We've got the device context.

797
00:29:23,600 --> 00:29:25,100
We've got the client wrecked.

798
00:29:25,100 --> 00:29:26,500
We have got the buffer.

799
00:29:26,500 --> 00:29:26,700
Now.

800
00:29:26,700 --> 00:29:28,200
This is global back buffer.

801
00:29:28,700 --> 00:29:29,800
We have got the

802
00:29:29,900 --> 00:29:31,200
Parameters that used to be there.

803
00:29:31,200 --> 00:29:32,300
And that is everything.

804
00:29:32,300 --> 00:29:34,500
And the last one is render weird gradient.

805
00:29:34,500 --> 00:29:36,800
That just had to take the global back buffer as well.

806
00:29:36,800 --> 00:29:41,500
So, let's take a look at that and just make sure that everything is

807
00:29:41,500 --> 00:29:45,700
copacetic with our code.

808
00:29:47,000 --> 00:29:49,300
Oops, change the name of that display, buffer window.

809
00:29:49,600 --> 00:29:50,300
Good to go.

810
00:29:50,600 --> 00:29:51,100
All right.

811
00:29:51,100 --> 00:29:54,800
So now here is the part where we see whether I was correct about the

812
00:29:54,800 --> 00:29:58,100
fact that the capture in OBS should be working correctly.

813
00:29:58,100 --> 00:29:59,800
Now if I hit F5, let's see.

814
00:30:00,000 --> 00:30:00,400
Do.

815
00:30:00,900 --> 00:30:02,000
Oh my goodness.

816
00:30:02,000 --> 00:30:03,900
That is not a good situation as well.

817
00:30:04,200 --> 00:30:05,000
That is a good.

818
00:30:05,000 --> 00:30:05,900
That is definitely good.

819
00:30:05,900 --> 00:30:07,500
This is our first access violation.

820
00:30:07,600 --> 00:30:09,800
One of the things I did when I pulled that off, was obviously a

821
00:30:09,800 --> 00:30:10,700
complete mistake.

822
00:30:10,800 --> 00:30:13,000
Probably something that was pretty simple.

823
00:30:15,400 --> 00:30:16,800
But instead of going fishing right now.

824
00:30:16,800 --> 00:30:18,700
I just want to talk a little bit about what just happened.

825
00:30:18,800 --> 00:30:20,600
In fact, let's run the code again so you can see it.

826
00:30:21,800 --> 00:30:22,200
All right.

827
00:30:22,200 --> 00:30:25,000
So whenever you remember when I talked about virtual memory, a lot,

828
00:30:25,200 --> 00:30:29,500
when I talk about virtual address spaces, I said that by default we do

829
00:30:29,500 --> 00:30:33,100
not actually have any pages in our virtual memory space reserved or

830
00:30:33,100 --> 00:30:33,800
committed.

831
00:30:34,000 --> 00:30:36,600
And so, basically, what happens is, if we go touch some memory, if we,

832
00:30:36,600 --> 00:30:40,500
if we have a pointer basically that we try to write to and that

833
00:30:40,500 --> 00:30:42,400
pointer points to an invalid page.

834
00:30:42,400 --> 00:30:45,900
Then we know that the that the operating system will will basically

835
00:30:45,900 --> 00:30:48,000
get that exception you will basically cause the CPU to go.

836
00:30:48,000 --> 00:30:48,900
Hey, wait a minute.

837
00:30:49,100 --> 00:30:51,400
That page is not something I

838
00:30:51,600 --> 00:30:53,700
It should not actually be touched by anyone.

839
00:30:54,000 --> 00:30:56,800
So, it'll go ahead and raise a flag to the operating system the

840
00:30:56,800 --> 00:30:57,500
operating system ago.

841
00:30:57,500 --> 00:31:00,900
Oops, and it will say, hey, you are, you are touching invalid, memory.

842
00:31:00,900 --> 00:31:03,700
You are trying to write in this case, right?

843
00:31:03,700 --> 00:31:04,700
It could be read as well.

844
00:31:04,800 --> 00:31:08,500
You're trying to write to a page that I have not actually put in

845
00:31:08,500 --> 00:31:11,600
physical memory and that I do not think is supposed to actually be

846
00:31:12,100 --> 00:31:13,000
ready for writing.

847
00:31:13,000 --> 00:31:15,700
Now, it could be when those exceptions are raised that they're totally

848
00:31:15,700 --> 00:31:16,000
normal.

849
00:31:16,000 --> 00:31:18,900
Could be like remember I saying you can basically Reserve memory and

850
00:31:18,900 --> 00:31:21,000
then it will only actually get committed to physical memory when you

851
00:31:21,000 --> 00:31:21,400
actually.

852
00:31:21,500 --> 00:31:21,800
To use it.

853
00:31:21,800 --> 00:31:23,500
So it could be the operating system wakes up and goes.

854
00:31:23,500 --> 00:31:25,000
Oh, he is supposed to be able to write to that memory.

855
00:31:25,000 --> 00:31:27,900
So I'm going to go ahead and actually back it into physical memory now

856
00:31:27,900 --> 00:31:28,700
and that's going to be good.

857
00:31:28,800 --> 00:31:30,600
But that's not what happened in this case.

858
00:31:30,700 --> 00:31:36,000
So we got what's called a segmentation fault Linux.

859
00:31:36,000 --> 00:31:37,700
Sometimes Sig Sig V.

860
00:31:37,700 --> 00:31:42,500
You'll see sometimes signal segmentation violation basically or on

861
00:31:42,500 --> 00:31:42,800
Windows.

862
00:31:42,800 --> 00:31:46,000
It's called an unhandled access UAE.

863
00:31:46,300 --> 00:31:48,300
I don't actually know what they call themselves - but anyway, it'll

864
00:31:48,300 --> 00:31:50,800
give you a basic something that looks like this where it says access

865
00:31:50,800 --> 00:31:51,400
violation.

866
00:31:51,600 --> 00:31:54,200
Writing location and then this is the pointer that you tried to write

867
00:31:54,200 --> 00:31:54,300
to.

868
00:31:54,300 --> 00:31:56,200
Now if you notice this pointer is awfully suspicious.

869
00:31:56,400 --> 00:31:57,800
It's all zeros.

870
00:31:58,200 --> 00:32:00,900
And basically what that means is we were trying to write to a pointer

871
00:32:01,200 --> 00:32:02,400
that we never initialize.

872
00:32:02,400 --> 00:32:04,500
So I probably just mess something up real quickly when I was changing

873
00:32:04,500 --> 00:32:07,800
the code to be using the buffer and so we can go in and see now.

874
00:32:07,800 --> 00:32:08,500
It's pretty obvious.

875
00:32:08,500 --> 00:32:09,000
What happened here.

876
00:32:09,000 --> 00:32:11,500
We're in the pixel at the pixel pointer was Zero.

877
00:32:11,700 --> 00:32:13,800
Well, that means that our buffer pointer was probably zero because

878
00:32:13,800 --> 00:32:14,700
there's no other way.

879
00:32:15,000 --> 00:32:15,900
The fact that happened.

880
00:32:15,900 --> 00:32:17,500
So let's take a look and see.

881
00:32:17,500 --> 00:32:19,400
Yes, the memory is set to 0 0 0.

882
00:32:19,400 --> 00:32:20,500
So what happened there?

883
00:32:20,700 --> 00:32:21,300
Why did we?

884
00:32:21,500 --> 00:32:25,100
We not initialize that the way we thought that we did.

885
00:32:25,100 --> 00:32:26,100
So let's take a look.

886
00:32:27,400 --> 00:32:30,100
We come here to win32 resize dip section.

887
00:32:30,200 --> 00:32:30,300
Here.

888
00:32:30,300 --> 00:32:31,100
We are back out.

889
00:32:31,100 --> 00:32:32,400
This is the WM / call.

890
00:32:32,400 --> 00:32:35,400
It's passing a pointer to the global back buffer, which at this point

891
00:32:35,400 --> 00:32:37,500
should have absolutely nothing in, and it should be completely

892
00:32:37,500 --> 00:32:39,300
uninitialized and it is.

893
00:32:39,300 --> 00:32:43,200
So, let's go ahead and, and step into this code.

894
00:32:43,200 --> 00:32:46,800
We're going to Virtual free, but we didn't have to, because the memory

895
00:32:46,800 --> 00:32:47,500
was empty.

896
00:32:47,500 --> 00:32:49,000
We're going to set our header.

897
00:32:49,000 --> 00:32:51,200
That's all the stuff that we actually wanted to do.

898
00:32:51,200 --> 00:32:52,700
That's all perfectly good.

899
00:32:52,700 --> 00:32:54,800
We're going to try and allocate memory here.

900
00:32:55,100 --> 00:32:56,300
The bitmap memory size.

901
00:32:56,300 --> 00:32:57,000
Oh,

902
00:32:57,600 --> 00:32:58,400
well, there it is.

903
00:32:58,400 --> 00:32:59,800
Ladies and gentlemen, there is the problem.

904
00:33:00,000 --> 00:33:04,100
There that that bytes per pixel, huh?

905
00:33:04,500 --> 00:33:05,000
Awesome.

906
00:33:05,400 --> 00:33:08,500
Well, I hope you guys caught that that was a pretty simple mistake,

907
00:33:09,000 --> 00:33:11,800
but just to be completely clear on what happens, remember, I had B 4

908
00:33:11,800 --> 00:33:15,000
pixel in here and I moved it out and I did not actually set it to

909
00:33:15,000 --> 00:33:15,500
anything.

910
00:33:15,900 --> 00:33:17,600
So that's a, that's our problem.

911
00:33:17,600 --> 00:33:20,000
We got to said by special equals equals for their.

912
00:33:20,400 --> 00:33:22,400
This would probably be a good time to talk a little bit about

913
00:33:22,400 --> 00:33:22,900
assertions.

914
00:33:23,200 --> 00:33:26,100
I'd want to put them off a little bit till later, but the so I have

915
00:33:26,100 --> 00:33:27,400
not been putting them in the code at all.

916
00:33:29,300 --> 00:33:31,500
Assertions are things that probably would have caught that Air Force.

917
00:33:32,100 --> 00:33:34,400
But at the end of the day, one of the things you have to remember,

918
00:33:34,400 --> 00:33:36,000
it's not that important to catch all errors.

919
00:33:36,500 --> 00:33:38,400
Basically, that is an error that will manifest itself.

920
00:33:38,400 --> 00:33:40,200
Very cleanly, if we have an allocation failure.

921
00:33:40,200 --> 00:33:42,000
We will immediately have an access violation.

922
00:33:42,200 --> 00:33:44,100
So, those are not the kinds of errors that we really need to guard

923
00:33:44,100 --> 00:33:45,200
against that much.

924
00:33:45,400 --> 00:33:46,700
Basically, there's two kinds of Errors.

925
00:33:46,900 --> 00:33:49,300
There are areas that are very Insidious and difficult to find.

926
00:33:49,300 --> 00:33:53,500
There are errors that don't manifest themselves very often and there

927
00:33:53,500 --> 00:33:54,200
are ones that will happen.

928
00:33:54,200 --> 00:33:55,200
Every time you run the program.

929
00:33:55,200 --> 00:33:57,600
If you have an error that happens, every time you run the program,

930
00:33:57,600 --> 00:33:58,400
that is not an error.

931
00:33:58,400 --> 00:33:59,000
You have to be

932
00:33:59,100 --> 00:33:59,500
Not at all.

933
00:33:59,500 --> 00:34:02,400
You do not have to worry about preventing that kind of an error

934
00:34:02,400 --> 00:34:04,600
because you will always find it before you ship.

935
00:34:04,900 --> 00:34:07,300
The kind of error that you do have to worry about, is the kind of

936
00:34:07,300 --> 00:34:09,699
error that does not happen on every run through the program so that

937
00:34:09,699 --> 00:34:14,000
you may not find it until you ship and that is bad news.

938
00:34:14,199 --> 00:34:16,500
And so this is probably not the kind that you should be too concerned

939
00:34:16,500 --> 00:34:16,800
about.

940
00:34:16,800 --> 00:34:19,400
But even so that is the kind of thing that if I was putting assertions

941
00:34:19,400 --> 00:34:20,800
in this code probably would have found it.

942
00:34:21,199 --> 00:34:24,600
And so that is something that we will probably cover it is 8:30.

943
00:34:24,600 --> 00:34:25,900
Right now, there's more stuff I want to do.

944
00:34:25,900 --> 00:34:28,900
So we're going to leave assertions until about two or three weeks.

945
00:34:29,100 --> 00:34:32,500
Now, but so I will not quite do that, yet point being, that was the

946
00:34:32,500 --> 00:34:32,900
problem.

947
00:34:33,100 --> 00:34:34,100
If you didn't catch it.

948
00:34:34,199 --> 00:34:34,699
What happened is?

949
00:34:34,699 --> 00:34:38,100
We used to have B 4 pixel in here set to 4 and then I change it to

950
00:34:38,100 --> 00:34:41,000
being in the buffer, but I neglected to initialize it before, that was

951
00:34:41,000 --> 00:34:44,000
just a stupid stupid thing to do on my part.

952
00:34:44,100 --> 00:34:46,500
And so, what ended up happening is when we went in here to compute the

953
00:34:46,500 --> 00:34:47,600
size of the bitmap.

954
00:34:47,600 --> 00:34:49,800
Well, we multiply the width times the height and got the number of

955
00:34:49,800 --> 00:34:50,699
pixels that we needed.

956
00:34:50,699 --> 00:34:52,600
And then we wanted to see how much memory we need for all those

957
00:34:52,600 --> 00:34:52,900
pixels.

958
00:34:52,900 --> 00:34:55,400
We multiplied it by zero, being guess what?

959
00:34:55,400 --> 00:34:58,900
You don't need any memory to store pixels, that have no sir.

960
00:34:59,100 --> 00:35:03,200
I so it ended up generating a zero, which past 02 virtual Alec and

961
00:35:03,200 --> 00:35:06,600
when you pass 02 virtual allocate passage is 0 right back because hey,

962
00:35:06,700 --> 00:35:09,900
it does not have to reserve any pages to store nothing.

963
00:35:12,600 --> 00:35:13,600
Not a surprise.

964
00:35:13,900 --> 00:35:17,300
So we should be back in good working order unless I made another

965
00:35:17,300 --> 00:35:18,100
stupid mistake.

966
00:35:18,800 --> 00:35:20,200
Let's go ahead and double check that.

967
00:35:21,700 --> 00:35:22,000
Excuse me.

968
00:35:22,000 --> 00:35:22,200
Again.

969
00:35:22,200 --> 00:35:22,900
I apologize.

970
00:35:23,200 --> 00:35:25,000
Hopefully, I'll my sore throat will be gone by next week.

971
00:35:25,000 --> 00:35:26,500
That is a much better looking size.

972
00:35:26,700 --> 00:35:27,700
We are in much better shape.

973
00:35:27,700 --> 00:35:27,900
Now.

974
00:35:27,900 --> 00:35:29,200
I think we should be good to go.

975
00:35:29,300 --> 00:35:32,400
So I'm gonna go ahead and remove that break point, and there is our

976
00:35:32,400 --> 00:35:33,200
beautiful pattern.

977
00:35:33,200 --> 00:35:35,600
Now, you will notice how silky smooth that is tonight.

978
00:35:35,600 --> 00:35:36,800
Hopefully, it's silky smooth on stream.

979
00:35:36,800 --> 00:35:37,800
It's silky smooth for me.

980
00:35:38,100 --> 00:35:39,900
And again, that is thanks to Kurt.

981
00:35:39,900 --> 00:35:40,900
Thank you for writing in.

982
00:35:41,300 --> 00:35:42,200
We would have been in

983
00:35:42,300 --> 00:35:44,300
Dire Straits without you my friend.

984
00:35:44,300 --> 00:35:44,900
Okay.

985
00:35:45,000 --> 00:35:49,400
So now that that is working, that is basically a very, very simple

986
00:35:49,600 --> 00:35:50,900
thing that you can do that.

987
00:35:50,900 --> 00:35:53,200
I have shown, which is basically just taking something that was a

988
00:35:53,200 --> 00:35:54,000
bunch of little variables.

989
00:35:54,000 --> 00:35:57,400
Pulling them into a structure and now you have code that operates on

990
00:35:57,400 --> 00:35:59,500
that structure, which means you can have as many of those

991
00:36:00,000 --> 00:36:03,500
As you want to and you also have a much easier time, reading things

992
00:36:03,500 --> 00:36:07,300
because everything that you need is in one place, so that's always a

993
00:36:07,300 --> 00:36:07,800
good thing.

994
00:36:08,100 --> 00:36:08,200
Now.

995
00:36:08,200 --> 00:36:10,700
If you want to take this one step further, we could even get rid of

996
00:36:10,700 --> 00:36:11,600
this Global variable.

997
00:36:11,700 --> 00:36:14,200
There really isn't much reason to do that because even though it makes

998
00:36:14,200 --> 00:36:16,100
it a little bit cleaner sometimes to do stuff like that.

999
00:36:16,100 --> 00:36:19,600
You don't want to go crazy and start doing things that you don't

1000
00:36:19,600 --> 00:36:23,100
really need to do because doing things that you make the code cleaner

1001
00:36:23,100 --> 00:36:26,300
and some conceptual sense, but that don't actually have any real

1002
00:36:26,300 --> 00:36:29,800
payoff for you is just making busy work and that is a bad idea.

1003
00:36:30,000 --> 00:36:32,400
There's a lot of that that goes on in programming, a lot of people who

1004
00:36:32,400 --> 00:36:35,100
do things because conceptually they believe something is cleaner, but

1005
00:36:35,100 --> 00:36:38,300
really at the end of the day, it's just what produces good bug-free

1006
00:36:38,300 --> 00:36:41,200
code in the least possible amount of programmer time.

1007
00:36:41,200 --> 00:36:42,500
That is what you're looking to do.

1008
00:36:42,500 --> 00:36:45,800
Oh, and it should be performing obviously that goes without saying.

1009
00:36:45,900 --> 00:36:48,500
So if you are doing something that is strictly for some kind of

1010
00:36:48,500 --> 00:36:52,300
conceptual cleanliness, you are actually doing something wrong because

1011
00:36:52,300 --> 00:36:54,700
if that claim this doesn't ever does not pay off for you if it's

1012
00:36:54,700 --> 00:36:57,700
purely conceptual and not practical, that is a waste of time.

1013
00:36:59,900 --> 00:37:02,100
And time is of the essence, especially here on the stream because we

1014
00:37:02,100 --> 00:37:02,900
only get an hour, a night.

1015
00:37:02,900 --> 00:37:03,500
Ladies and gentlemen.

1016
00:37:03,500 --> 00:37:07,700
All right, where to now, what I would like to do.

1017
00:37:07,700 --> 00:37:10,300
I think this program is relatively good so far.

1018
00:37:10,300 --> 00:37:12,400
I don't have a lot of complaints about it, to be honest with you.

1019
00:37:12,600 --> 00:37:15,300
But there's one more thing I wanted to pull out and that is that we do

1020
00:37:15,300 --> 00:37:15,500
this.

1021
00:37:15,500 --> 00:37:17,200
Get client wreck thing a lot.

1022
00:37:17,300 --> 00:37:21,800
I was thinking maybe I would go in here and do something that that

1023
00:37:21,800 --> 00:37:23,800
basically made this a little bit easier for us.

1024
00:37:23,800 --> 00:37:26,400
So I'm going to go ahead and make a little helper function.

1025
00:37:26,400 --> 00:37:27,300
It's very simple.

1026
00:37:27,500 --> 00:37:28,500
It is just going to be called.

1027
00:37:28,900 --> 00:37:30,500
To window dimensions.

1028
00:37:30,600 --> 00:37:31,800
That's all it's going to do.

1029
00:37:31,900 --> 00:37:35,600
It's going to return a width and a height, just a very simple pair and

1030
00:37:35,600 --> 00:37:39,300
you will notice the reason that I'm doing that is you see this in a

1031
00:37:39,300 --> 00:37:42,500
number of places, get client rekt, get client wrecked.

1032
00:37:42,500 --> 00:37:45,800
And then it has to do stuff with the width and height that sort of

1033
00:37:45,800 --> 00:37:46,500
thing right there.

1034
00:37:46,500 --> 00:37:49,500
So what I'd like to do is just get rid of that redundant code a little

1035
00:37:49,500 --> 00:37:52,500
bit because it's kind of looking a little ugly and I don't love it.

1036
00:37:52,500 --> 00:37:55,300
I don't love calling doing the same thing multiple times like that.

1037
00:37:55,300 --> 00:37:58,700
So I am just going to make a very simple call just for

1038
00:37:58,800 --> 00:38:02,600
my own sanity and convenience that is called get window Dimension, and

1039
00:38:02,600 --> 00:38:06,000
it'll take that window handle and give that back to us.

1040
00:38:06,000 --> 00:38:06,800
So there it is.

1041
00:38:07,200 --> 00:38:09,400
That is the entirety of what we actually want to do.

1042
00:38:09,500 --> 00:38:10,500
So, I'm just going to Claire.

1043
00:38:10,500 --> 00:38:11,200
One of these.

1044
00:38:11,300 --> 00:38:14,400
This is going to be the result and it is just going to instead of

1045
00:38:14,400 --> 00:38:15,800
creating local variables with the height.

1046
00:38:15,800 --> 00:38:18,700
It's going to write that result and then it is going to return it.

1047
00:38:19,700 --> 00:38:20,400
That is it.

1048
00:38:20,400 --> 00:38:21,500
That is all I wanted to do.

1049
00:38:21,500 --> 00:38:24,400
And so now I can go down to the places that we did get client wrecked.

1050
00:38:25,500 --> 00:38:26,800
And instead of doing that.

1051
00:38:26,800 --> 00:38:28,700
I can do win32 window dimension.

1052
00:38:29,100 --> 00:38:32,600
I can ask for the dimension, get window Dimension and I can pass that

1053
00:38:32,600 --> 00:38:34,500
window now that will clean up nicely.

1054
00:38:34,700 --> 00:38:40,400
And here, we can just go ahead and pass those Dimensions to our resize

1055
00:38:40,400 --> 00:38:40,900
call.

1056
00:38:40,900 --> 00:38:42,000
That looks good to me.

1057
00:38:42,200 --> 00:38:46,600
We can come down here to the same thing that was happening and and

1058
00:38:46,600 --> 00:38:50,400
actually do the exact same thing and I'm going to change this display

1059
00:38:50,400 --> 00:38:54,700
buffer in window call because instead of taking a client rekt, I would

1060
00:38:54,700 --> 00:38:57,600
prefer that it actually took the window Dimension because that is what

1061
00:38:57,600 --> 00:38:58,300
it actually needed.

1062
00:38:58,300 --> 00:38:58,700
So I'm

1063
00:38:58,800 --> 00:38:59,900
To actually pass the window.

1064
00:39:00,300 --> 00:39:03,300
And the window height here, so that it doesn't have to deal with those

1065
00:39:03,300 --> 00:39:03,900
wrecks structures.

1066
00:39:03,900 --> 00:39:07,100
And that makes that code go through the exact same path as the

1067
00:39:07,100 --> 00:39:08,800
previous code, which is always good.

1068
00:39:08,800 --> 00:39:10,300
So, it's good to have the less code pass.

1069
00:39:10,300 --> 00:39:14,800
The better if you can avoid having multiple ways of doing the same

1070
00:39:14,800 --> 00:39:18,000
thing for no reason, just means it's easier to change later.

1071
00:39:18,300 --> 00:39:19,900
And more likely to find bugs.

1072
00:39:20,200 --> 00:39:22,800
Because if there's bugs in each individual place, you do something.

1073
00:39:22,800 --> 00:39:24,000
Well, if you find and fix one.

1074
00:39:24,200 --> 00:39:26,300
Now, you gotta go and remember, to find a fix all the others.

1075
00:39:26,300 --> 00:39:26,700
All right.

1076
00:39:26,700 --> 00:39:30,000
So what I basically did there is, I said that when we're going,

1077
00:39:30,100 --> 00:39:31,700
Back to the screen and start taking that client record.

1078
00:39:31,700 --> 00:39:34,600
It's going to take a window within a window height and you can see

1079
00:39:34,600 --> 00:39:35,400
that all that had happened.

1080
00:39:35,400 --> 00:39:38,500
There is actually I move that window width and height computation that

1081
00:39:38,500 --> 00:39:39,600
used to happen into here.

1082
00:39:39,600 --> 00:39:40,800
So that's going to go away as well.

1083
00:39:40,800 --> 00:39:43,400
So now we have it all done in exactly one place.

1084
00:39:43,400 --> 00:39:44,400
That is pretty awesome.

1085
00:39:44,600 --> 00:39:45,100
And I love it.

1086
00:39:45,100 --> 00:39:46,600
When code comes together like that.

1087
00:39:46,700 --> 00:39:48,000
You really can't argue with it course.

1088
00:39:48,000 --> 00:39:49,500
This is this is child's.

1089
00:39:49,500 --> 00:39:50,500
Play with training wheels here.

1090
00:39:50,500 --> 00:39:52,900
Obviously, we're just cleaning up some really simple clothes so I

1091
00:39:52,900 --> 00:39:56,700
wouldn't get too excited about it necessarily, but honestly, you know,

1092
00:39:56,700 --> 00:39:57,300
what can I say?

1093
00:39:57,400 --> 00:39:59,300
It makes you happy, it makes you happy.

1094
00:40:00,100 --> 00:40:00,400
Know what?

1095
00:40:00,400 --> 00:40:01,200
I forgot to prefix.

1096
00:40:01,200 --> 00:40:01,600
That thing.

1097
00:40:01,600 --> 00:40:03,200
Why do I keep hitting that hotkey?

1098
00:40:03,800 --> 00:40:06,100
Is that is a hotkey that I should not be hitting.

1099
00:40:06,200 --> 00:40:06,700
OK.

1100
00:40:06,900 --> 00:40:09,600
What I want to do is just add that win32 there because I was, I was

1101
00:40:09,600 --> 00:40:12,200
kind of following that convention, and I'd like to do that.

1102
00:40:12,200 --> 00:40:15,200
Just so we know that things that are in our win32 platform layer.

1103
00:40:15,300 --> 00:40:16,500
Have a win32 in the front.

1104
00:40:16,500 --> 00:40:19,100
I'm just makes it a little nicer, makes it a little easier for me to

1105
00:40:19,100 --> 00:40:19,400
see.

1106
00:40:19,600 --> 00:40:22,400
So we are going to go ahead and get the window Dimension, here of that

1107
00:40:22,400 --> 00:40:23,000
window.

1108
00:40:23,100 --> 00:40:24,800
We are going to go ahead and delete this.

1109
00:40:24,900 --> 00:40:29,900
And then we can pass the past the dimension like that.

1110
00:40:30,600 --> 00:40:31,300
There we go.

1111
00:40:31,600 --> 00:40:32,100
Okay.

1112
00:40:32,500 --> 00:40:33,700
Yeah.

1113
00:40:33,900 --> 00:40:34,300
Yeah.

1114
00:40:34,900 --> 00:40:35,300
Okay.

1115
00:40:35,300 --> 00:40:37,100
Well, you know what, I call the full Dimension there.

1116
00:40:37,100 --> 00:40:39,800
Let's let's let's be consistent for desistance sake.

1117
00:40:40,100 --> 00:40:42,700
It is the hobgoblin of small minds, they say.

1118
00:40:43,200 --> 00:40:44,100
But you know what?

1119
00:40:44,100 --> 00:40:46,000
Maybe our mind is small tonight?

1120
00:40:46,000 --> 00:40:48,600
You know what, that could just be the case.

1121
00:40:48,600 --> 00:40:51,300
All right, we are done with that.

1122
00:40:51,900 --> 00:40:53,800
If I just can clean up the fun up.

1123
00:40:53,800 --> 00:40:54,200
That's right.

1124
00:40:54,200 --> 00:40:54,700
Casey.

1125
00:40:54,800 --> 00:40:55,300
Nice.

1126
00:40:55,500 --> 00:40:56,500
Gotta love the typos.

1127
00:40:56,700 --> 00:40:58,900
Okay, and here we go.

1128
00:40:58,900 --> 00:40:59,900
Dimension with

1129
00:41:00,100 --> 00:41:02,700
With and dimension .height.

1130
00:41:02,800 --> 00:41:03,300
Okay.

1131
00:41:03,300 --> 00:41:05,500
Now you may ask why I'm cleaning that up.

1132
00:41:05,500 --> 00:41:08,500
Why do I keep passing Dimension, width and height instead of just

1133
00:41:08,500 --> 00:41:10,900
passing the dimension itself?

1134
00:41:11,100 --> 00:41:13,300
And the reason is because one thing that you want to make sure that

1135
00:41:13,300 --> 00:41:16,500
you do is you don't go overboard with your type rapping.

1136
00:41:18,700 --> 00:41:21,700
So the reason that I created that structure, the reason I created this

1137
00:41:21,700 --> 00:41:24,500
structure right here is because I can't return to values from AC

1138
00:41:24,500 --> 00:41:25,000
function.

1139
00:41:25,300 --> 00:41:26,600
You can only return 1.

1140
00:41:26,900 --> 00:41:30,100
And so when I want to return to, I go ahead and make a structure that

1141
00:41:30,100 --> 00:41:31,100
bundles, those two together.

1142
00:41:31,100 --> 00:41:32,100
That's why this is here.

1143
00:41:32,200 --> 00:41:34,600
Otherwise, I just returned to integers and there's languages that

1144
00:41:34,600 --> 00:41:35,600
support that kind of thing.

1145
00:41:35,600 --> 00:41:38,300
And if you're using one of those, that is what you should do, there's

1146
00:41:38,300 --> 00:41:41,200
no need to actually name this it is not important, but

1147
00:41:42,500 --> 00:41:45,900
When I actually start passing things, if I was to go down here and

1148
00:41:45,900 --> 00:41:48,500
let's say, change this to taking you to mention or change this ticket

1149
00:41:48,500 --> 00:41:48,900
to mention.

1150
00:41:48,900 --> 00:41:52,300
What I have basically done is I have forced everyone who is ever going

1151
00:41:52,300 --> 00:41:55,400
to call these functions in the future to bundle those things two

1152
00:41:55,400 --> 00:41:56,000
together.

1153
00:41:56,000 --> 00:41:59,600
Again, they are now forced to create one of those structures in order

1154
00:41:59,600 --> 00:41:59,800
to call.

1155
00:42:00,000 --> 00:42:03,100
Function even if they already had the width and height from something

1156
00:42:03,100 --> 00:42:05,100
else and that is not something that I want to do.

1157
00:42:05,100 --> 00:42:07,800
Because basically, when I make a function, I want the most number of

1158
00:42:07,800 --> 00:42:10,500
people to be able to call it in the most number of circumstances

1159
00:42:10,500 --> 00:42:12,800
because that is what gives me leverage.

1160
00:42:12,800 --> 00:42:15,700
And that is what allows me to reuse code, the most often.

1161
00:42:15,700 --> 00:42:19,100
So you don't want to get carried away with wrapping up your types.

1162
00:42:19,100 --> 00:42:22,400
The only time you really want to force people to pass types of

1163
00:42:22,400 --> 00:42:25,300
something, is when those types literally have to all go together.

1164
00:42:25,300 --> 00:42:28,200
Now, for example, in this Austrian buffer, that is a good cake, making

1165
00:42:28,200 --> 00:42:29,300
a good case for that.

1166
00:42:29,300 --> 00:42:29,900
Because all of

1167
00:42:30,000 --> 00:42:32,500
These things are related, the pitch, the height, the width, the bytes

1168
00:42:32,500 --> 00:42:36,000
per pixel, the memory in the info all go together and they cannot be

1169
00:42:36,200 --> 00:42:38,900
used separately because there are all interdependent.

1170
00:42:39,000 --> 00:42:42,300
Basically, this memory has to be a size that's dependent on the width

1171
00:42:42,300 --> 00:42:44,200
and the pitch in the height and the bytes per pixel.

1172
00:42:44,400 --> 00:42:46,900
And this info is set up to be specifically this layout.

1173
00:42:47,000 --> 00:42:49,800
You cannot arbitrarily combine these things together, but win32,

1174
00:42:49,800 --> 00:42:51,900
window Dimension is just an arbitrary width and a height that could

1175
00:42:51,900 --> 00:42:52,600
have come from anywhere.

1176
00:42:52,600 --> 00:42:53,700
It could have been from any window.

1177
00:42:53,700 --> 00:42:57,100
You may have gotten it not from calling this and so I don't want to

1178
00:42:57,100 --> 00:42:59,800
force people to pack things into some structure.

1179
00:43:00,100 --> 00:43:01,000
Just to do it.

1180
00:43:02,900 --> 00:43:04,200
So, I didn't.

1181
00:43:05,200 --> 00:43:07,400
Let's double-check to make sure that we have not introduced any

1182
00:43:07,400 --> 00:43:08,700
heinous Errors By typos.

1183
00:43:08,700 --> 00:43:10,800
We have not, that looks pretty good.

1184
00:43:10,800 --> 00:43:12,400
Our resize is still working.

1185
00:43:12,700 --> 00:43:13,900
So that's good as well.

1186
00:43:14,400 --> 00:43:16,100
And that is all good.

1187
00:43:16,100 --> 00:43:16,700
Now.

1188
00:43:16,700 --> 00:43:22,600
I think that probably, at this point, what I would like to do is go

1189
00:43:22,600 --> 00:43:25,700
ahead and see, you know what?

1190
00:43:25,700 --> 00:43:29,400
I might make one more thing before we drill down in the queue a little

1191
00:43:29,400 --> 00:43:33,300
bit because we've got about 17 minutes left.

1192
00:43:33,300 --> 00:43:34,900
So there is one more thing that I think I'd like.

1193
00:43:35,000 --> 00:43:35,500
Try.

1194
00:43:35,500 --> 00:43:35,800
Maybe.

1195
00:43:35,800 --> 00:43:38,300
This is a bad idea at the at this point in the Stream, but I'm gonna

1196
00:43:38,300 --> 00:43:38,500
try it.

1197
00:43:38,500 --> 00:43:41,200
Anyway, what I would like to do is I would like to start using our

1198
00:43:41,200 --> 00:43:44,100
stretch flick called to actually stretch our bitmap.

1199
00:43:44,300 --> 00:43:47,200
I want to basically allocate this bitmap instead of allocating in the

1200
00:43:47,200 --> 00:43:48,300
WM size command.

1201
00:43:48,300 --> 00:43:49,800
I am going to stop doing that entirely.

1202
00:43:49,800 --> 00:43:52,000
I'm just going to go ahead and say we're not doing that anymore.

1203
00:43:52,000 --> 00:43:52,400
Instead.

1204
00:43:52,400 --> 00:43:55,000
We are going to resize our bitmap right here.

1205
00:43:55,000 --> 00:43:57,500
We're basically just going to go ahead and say that when we start up,

1206
00:43:57,700 --> 00:44:00,500
we are going to make our bitmap, a particular size.

1207
00:44:00,500 --> 00:44:01,600
We are going to make our bitmap.

1208
00:44:01,600 --> 00:44:04,800
Let's say 1280 by 720 that is going to be the size of

1209
00:44:04,900 --> 00:44:06,100
of our back buffer.

1210
00:44:06,600 --> 00:44:08,200
That is the way that I want that to work.

1211
00:44:08,500 --> 00:44:12,800
And so now when we go in and we do resize dip section, we will do

1212
00:44:12,800 --> 00:44:13,000
that.

1213
00:44:13,000 --> 00:44:15,500
Just once we will not do it on the double size and that bump back

1214
00:44:15,500 --> 00:44:17,900
buffer will just sit around and get updated by us.

1215
00:44:17,900 --> 00:44:22,500
Now, when we actually call Winter display buffer in window that will

1216
00:44:22,700 --> 00:44:25,000
stretch it for us, because remember, we're passing the buffer width

1217
00:44:25,000 --> 00:44:26,600
and height with will now be always be the same.

1218
00:44:26,600 --> 00:44:29,500
They won't be changing, but we will be passing a different window with

1219
00:44:29,500 --> 00:44:31,000
and different window height.

1220
00:44:31,000 --> 00:44:34,800
So if we go in here and run this you will now see

1221
00:44:35,500 --> 00:44:38,700
That basically, as we, as we stretch, oh, that does not look good at

1222
00:44:38,700 --> 00:44:39,000
all.

1223
00:44:39,100 --> 00:44:41,600
Well, when I said, you will now see, as you will now, see a bug is

1224
00:44:41,600 --> 00:44:42,300
what you will see.

1225
00:44:42,600 --> 00:44:44,600
So that means, we are passing some incorrect things here.

1226
00:44:44,900 --> 00:44:45,800
What did we do wrong?

1227
00:44:45,800 --> 00:44:47,600
Oh, that's fantastic.

1228
00:44:48,000 --> 00:44:51,400
I I just assumed I know that the bug is here because I feel like I

1229
00:44:51,400 --> 00:44:54,400
remember, I feel like we've typed the wrong things in there, even

1230
00:44:54,400 --> 00:44:56,600
though we read the manual, ladies and gentlemen, we've read the

1231
00:44:56,600 --> 00:44:57,000
manual.

1232
00:44:57,000 --> 00:44:59,000
But we must have ignored it because I am pretty sure those are in the

1233
00:44:59,000 --> 00:44:59,400
wrong order.

1234
00:44:59,400 --> 00:44:59,800
Let's take a

1235
00:45:00,300 --> 00:45:01,500
It is the destination first.

1236
00:45:01,500 --> 00:45:02,100
Well, guess what?

1237
00:45:02,100 --> 00:45:02,500
People?

1238
00:45:02,800 --> 00:45:04,000
That is not the destination.

1239
00:45:04,000 --> 00:45:05,200
The buffer is our source.

1240
00:45:05,200 --> 00:45:06,200
The window is the destination.

1241
00:45:06,200 --> 00:45:07,300
Those are in the wrong order.

1242
00:45:07,300 --> 00:45:08,000
That is no good.

1243
00:45:08,000 --> 00:45:08,700
That has been a bug.

1244
00:45:08,700 --> 00:45:12,000
That's been lurking in there before they were both the same so it did

1245
00:45:12,000 --> 00:45:13,000
not matter and that is true.

1246
00:45:13,000 --> 00:45:14,300
But now we have fixed it.

1247
00:45:14,500 --> 00:45:15,200
And there we go.

1248
00:45:15,200 --> 00:45:15,900
So there we are.

1249
00:45:15,900 --> 00:45:18,000
We're stretching, and that's totally fine.

1250
00:45:18,000 --> 00:45:19,400
That's what we wanted to have happen.

1251
00:45:19,700 --> 00:45:21,900
But I would point out that, that is not a particularly good stretch.

1252
00:45:21,900 --> 00:45:24,200
Ladies and gentlemen, that is not a fantastic stretch.

1253
00:45:24,400 --> 00:45:26,600
It is certainly not doing a lot of filtering and help us out there.

1254
00:45:26,600 --> 00:45:29,100
So that's something to be a little bit concerned about something to

1255
00:45:29,100 --> 00:45:29,800
think about.

1256
00:45:30,100 --> 00:45:32,300
So we'll have to play with that a little bit for the time being

1257
00:45:32,300 --> 00:45:32,400
though.

1258
00:45:32,400 --> 00:45:36,000
That means we do have a back buffer that size the same and that is

1259
00:45:36,000 --> 00:45:37,500
something that I want to start out with.

1260
00:45:37,700 --> 00:45:39,800
And we will have to think about how we're going to deal with some of

1261
00:45:39,800 --> 00:45:43,200
those things because stretch stretch TI B, may not be enough.

1262
00:45:43,300 --> 00:45:45,400
When I mean, not be industrial-strength enough for us, but we'll think

1263
00:45:45,400 --> 00:45:46,300
about that as we go.

1264
00:45:46,500 --> 00:45:47,500
It's totally fine for now.

1265
00:45:47,500 --> 00:45:50,800
So one of the thing that's going to happen here is if we stretch in

1266
00:45:50,800 --> 00:45:53,100
some kind of way that that actually does something bad.

1267
00:45:53,100 --> 00:45:53,600
They're right.

1268
00:45:53,600 --> 00:45:54,400
We're stretching like this.

1269
00:45:54,400 --> 00:45:57,300
We're stretching like that we end up basically distorting the aspect

1270
00:45:57,300 --> 00:45:59,000
ratio of our image, right?

1271
00:45:59,000 --> 00:45:59,900
We are drastically.

1272
00:46:00,000 --> 00:46:00,700
The aspect ratio.

1273
00:46:00,700 --> 00:46:03,300
So if this was our little handmade hero, he would be squashed, you

1274
00:46:03,300 --> 00:46:06,000
would be squashed horizontally or he would be squashed vertically.

1275
00:46:06,100 --> 00:46:10,300
So what I want to do here is, I want to just take a second to go ahead

1276
00:46:10,400 --> 00:46:14,100
and actually correct the aspect ratio when we do the split.

1277
00:46:16,000 --> 00:46:17,600
Because I want to show you a little bit of math for that.

1278
00:46:17,600 --> 00:46:18,600
It's very simple math.

1279
00:46:18,700 --> 00:46:20,200
Nothing really too too much.

1280
00:46:21,000 --> 00:46:23,500
So basically what we're going to do here is we're going to try and

1281
00:46:23,500 --> 00:46:25,900
figure out basically how.

1282
00:46:28,300 --> 00:46:31,800
All right I got think about this carefully, 15 minutes left.

1283
00:46:31,900 --> 00:46:33,600
These are the kind of decisions that are hard to make.

1284
00:46:33,600 --> 00:46:34,200
You know, what?

1285
00:46:34,500 --> 00:46:36,500
No, we're going to say the aspect ratio for later.

1286
00:46:36,600 --> 00:46:38,700
The reason why I stayed the aspect ratio for later is because it's

1287
00:46:38,700 --> 00:46:41,200
probably true that we will want to do this.

1288
00:46:41,200 --> 00:46:42,100
In floating Point.

1289
00:46:42,100 --> 00:46:44,000
Maybe not, maybe we want to do it, integer.

1290
00:46:44,000 --> 00:46:44,600
I don't know.

1291
00:46:46,200 --> 00:46:47,200
It's such a tough decision.

1292
00:46:47,200 --> 00:46:49,600
Sometimes the decisions I face on the stream.

1293
00:46:50,000 --> 00:46:53,700
When the time is, when the clock hits the clock that makes a decision

1294
00:46:53,700 --> 00:46:54,400
difficult.

1295
00:46:54,400 --> 00:46:57,400
I don't always know whether we should go for it or not.

1296
00:46:57,400 --> 00:46:57,900
Well.

1297
00:46:59,500 --> 00:47:01,100
The answer is no we're not going to go for it.

1298
00:47:01,100 --> 00:47:02,500
So I'm just gonna drop it to do in there.

1299
00:47:02,700 --> 00:47:06,700
I'm going to say aspect ratio correction, and we will have a thing

1300
00:47:06,700 --> 00:47:09,000
where we actually make sure we do that early in the Stream so we can

1301
00:47:09,000 --> 00:47:12,500
take the time to talk about how we're going to do it and do it 100%

1302
00:47:12,600 --> 00:47:12,900
correctly.

1303
00:47:12,900 --> 00:47:15,600
So for now we're going to get a squash and that is totally fine.

1304
00:47:15,900 --> 00:47:17,600
But otherwise we are totally good to go.

1305
00:47:17,600 --> 00:47:21,100
Alright, so last thing I wanted to do before the Q&A is we are going

1306
00:47:21,100 --> 00:47:24,300
to go ahead and step through our code and make sure we understand what

1307
00:47:24,300 --> 00:47:25,500
all of it does.

1308
00:47:26,200 --> 00:47:28,800
So that everyone who followed us for this week.

1309
00:47:29,000 --> 00:47:33,000
Can make sure they really solidify their understanding of how the code

1310
00:47:33,000 --> 00:47:33,400
goes.

1311
00:47:33,500 --> 00:47:37,300
So, let's go ahead down here and let's just set a breakpoint.

1312
00:47:37,300 --> 00:47:37,500
Again.

1313
00:47:37,500 --> 00:47:38,200
That's F9.

1314
00:47:38,200 --> 00:47:38,700
Ladies and gentleman.

1315
00:47:38,700 --> 00:47:40,200
Let's set a breakpoint right at the beginning.

1316
00:47:40,600 --> 00:47:42,900
This is the first time that it enters our code.

1317
00:47:42,900 --> 00:47:43,000
Now.

1318
00:47:43,000 --> 00:47:45,600
Remember, we are not the first thing that happened.

1319
00:47:45,900 --> 00:47:49,500
The C runtime library has already done a bunch of stuff, but there's

1320
00:47:49,500 --> 00:47:51,000
not much we can do about that at the moment.

1321
00:47:51,000 --> 00:47:53,100
There are ways to compile without it, but I don't know if we

1322
00:47:53,100 --> 00:47:54,100
necessarily want to go there.

1323
00:47:54,800 --> 00:47:58,600
We may try to some point and when we are feeling brave, anyway, we go

1324
00:47:58,600 --> 00:47:58,800
through.

1325
00:47:58,900 --> 00:47:59,900
here, and we are basically

1326
00:48:00,000 --> 00:48:04,100
Going to start by putting this window class initialize, it to 0 that

1327
00:48:04,100 --> 00:48:05,700
again, is going to initialize the window class.

1328
00:48:05,700 --> 00:48:08,700
20 basically, because we have not put anything in the little brackets.

1329
00:48:08,700 --> 00:48:11,300
That is the clue to the compiler to initialize it to zero.

1330
00:48:11,400 --> 00:48:12,400
And where is that going to go?

1331
00:48:12,400 --> 00:48:13,400
Where is any of this stuff?

1332
00:48:13,400 --> 00:48:16,700
Go, all of this stuff goes on the stack, all the stuff goes on the

1333
00:48:16,700 --> 00:48:17,600
stack, these parameters.

1334
00:48:17,600 --> 00:48:20,000
Go on the stack, the window class, one on the stack, and just to

1335
00:48:20,000 --> 00:48:23,200
reinforce that lets go ahead and take a look at that memory window.

1336
00:48:23,200 --> 00:48:23,600
Shall we?

1337
00:48:24,200 --> 00:48:25,100
Here is the memory window?

1338
00:48:25,100 --> 00:48:27,400
This is the memory in the computer.

1339
00:48:27,700 --> 00:48:28,700
And actually, you know what, I get.

1340
00:48:28,700 --> 00:48:29,800
I think I want that in different places.

1341
00:48:30,000 --> 00:48:32,300
I'm going to go ahead and just drag the memory window and I'm going to

1342
00:48:32,300 --> 00:48:35,300
go ahead and drag it down here so that it ends up down in here.

1343
00:48:35,600 --> 00:48:36,900
That is not what I wanted.

1344
00:48:37,300 --> 00:48:40,800
Ladies and gentlemen, I need to be a little more precise with my drop.

1345
00:48:40,800 --> 00:48:41,400
There we go.

1346
00:48:41,500 --> 00:48:42,700
Okay, that is the memory window.

1347
00:48:42,700 --> 00:48:43,800
That is what I wanted.

1348
00:48:43,800 --> 00:48:46,500
I'm going to go to the watch window and I'm going to take the address

1349
00:48:46,600 --> 00:48:49,200
of that window class and so I can see where it is.

1350
00:48:49,200 --> 00:48:50,300
So I'm going to take that address.

1351
00:48:50,300 --> 00:48:51,500
There is the address right there.

1352
00:48:51,500 --> 00:48:52,200
You can see it.

1353
00:48:52,300 --> 00:48:54,700
It is a 64-bit address because we're in 64-bit mode.

1354
00:48:54,700 --> 00:48:56,200
So we have big memory space.

1355
00:48:56,400 --> 00:48:58,200
I'm gonna go ahead and paste that in here and hit return.

1356
00:48:58,400 --> 00:48:59,800
So this is where that window class.

1357
00:49:00,000 --> 00:49:00,900
As you can see, it.

1358
00:49:01,400 --> 00:49:03,000
It is not all zeros right now.

1359
00:49:03,000 --> 00:49:04,200
It is got stuff in it.

1360
00:49:04,300 --> 00:49:04,700
Right?

1361
00:49:04,800 --> 00:49:07,500
And I'm going to go ahead and hit F5 to step over.

1362
00:49:07,500 --> 00:49:09,300
I'm sorry to hit F10, to step over this line.

1363
00:49:09,500 --> 00:49:12,600
And you can see that it all got cleared 20 down there, right?

1364
00:49:12,700 --> 00:49:13,700
So that is what's happening.

1365
00:49:13,800 --> 00:49:15,000
This is the stack right here.

1366
00:49:15,600 --> 00:49:19,000
And I just want to point out that if you look at where that is to c f

1367
00:49:19,000 --> 00:49:20,300
5 F 0, right?

1368
00:49:20,300 --> 00:49:23,200
To see F 5 F 0.

1369
00:49:23,200 --> 00:49:24,000
Where did you go?

1370
00:49:24,000 --> 00:49:24,600
Right there?

1371
00:49:25,400 --> 00:49:29,600
Let's take a look at those parameters, instance, prevent students.

1372
00:49:29,900 --> 00:49:33,900
And command line just so we can see where they live as well.

1373
00:49:34,300 --> 00:49:35,000
There you go.

1374
00:49:35,100 --> 00:49:36,000
You can see that they are.

1375
00:49:36,000 --> 00:49:38,400
All right next to each other, which is what we would have expected.

1376
00:49:38,400 --> 00:49:40,800
Because it looks like compiler has pushed them onto the stack and push

1377
00:49:40,800 --> 00:49:41,400
them on the stack.

1378
00:49:41,400 --> 00:49:41,800
Sequentially.

1379
00:49:41,800 --> 00:49:45,100
We can see what order it put them on in the stack as well.

1380
00:49:45,100 --> 00:49:45,200
Right?

1381
00:49:45,200 --> 00:49:49,600
You can see they go in order here, 30, 38, 40, and 48.

1382
00:49:50,200 --> 00:49:54,800
And if we go ahead and look at where that is, we can see there at to

1383
00:49:54,800 --> 00:49:56,200
CF7.

1384
00:49:56,200 --> 00:49:57,900
They are a little bit further down.

1385
00:49:57,900 --> 00:49:59,700
I will widen this out.

1386
00:50:00,000 --> 00:50:05,800
So basically here is the one that we were talking about before 5, F 0.

1387
00:50:05,800 --> 00:50:06,900
It is right there.

1388
00:50:07,000 --> 00:50:10,600
That is that one and the sevens were over here.

1389
00:50:10,600 --> 00:50:12,000
If I remember correctly.

1390
00:50:12,000 --> 00:50:13,000
Yes, they were.

1391
00:50:13,200 --> 00:50:13,800
Okay.

1392
00:50:14,100 --> 00:50:17,500
And so what that leads me to believe, although I do not actually know

1393
00:50:17,900 --> 00:50:20,600
that would suggest that it is pushing these.

1394
00:50:20,600 --> 00:50:21,900
That the stack is growing downwards.

1395
00:50:21,900 --> 00:50:25,600
I don't actually know if that's true, that may not be true.

1396
00:50:25,700 --> 00:50:27,400
It seems odd that it would push them in that order.

1397
00:50:27,400 --> 00:50:29,300
So I'm not sure what order the stack is growing in.

1398
00:50:29,500 --> 00:50:29,700
So

1399
00:50:29,900 --> 00:50:33,200
Let's go ahead and see if we can figure that out.

1400
00:50:33,200 --> 00:50:34,100
Let's take jump up.

1401
00:50:34,100 --> 00:50:35,100
The call stack one.

1402
00:50:35,100 --> 00:50:37,100
I just want to know where the stock is going up or down because

1403
00:50:37,400 --> 00:50:39,500
honestly, it's been so long said, look at anything like that.

1404
00:50:39,500 --> 00:50:42,000
I have no idea on x64, which is what we're doing.

1405
00:50:42,000 --> 00:50:42,300
Now.

1406
00:50:42,800 --> 00:50:45,400
I have no idea at this track gets bigger off, the bottom of the stack

1407
00:50:45,400 --> 00:50:46,200
or off the top of Stack.

1408
00:50:46,200 --> 00:50:46,900
Let's find out.

1409
00:50:47,600 --> 00:50:51,800
All right, so see here's a here's a variable in it Rhett.

1410
00:50:52,200 --> 00:50:53,200
Let's see where that is.

1411
00:50:53,200 --> 00:50:54,800
Oh, it was optimized away.

1412
00:50:54,800 --> 00:50:55,200
All right.

1413
00:50:55,200 --> 00:50:56,900
Well, alright so much for that.

1414
00:50:56,900 --> 00:50:59,800
Let's call into one of our functions then and

1415
00:51:00,000 --> 00:51:01,000
See where it is.

1416
00:51:01,000 --> 00:51:02,700
So let's go down here real quick.

1417
00:51:03,200 --> 00:51:03,500
Actually.

1418
00:51:03,500 --> 00:51:03,900
You know, what?

1419
00:51:03,900 --> 00:51:04,600
No, we can do.

1420
00:51:04,700 --> 00:51:05,600
I do that.

1421
00:51:05,800 --> 00:51:07,100
We can actually do that right here.

1422
00:51:07,100 --> 00:51:08,900
Now that we're allocating our back buffer.

1423
00:51:09,500 --> 00:51:12,000
All right, let's take a look window class.

1424
00:51:12,200 --> 00:51:14,900
That is where window class was placed on the stack.

1425
00:51:14,900 --> 00:51:18,500
That is this location in memory, 1 FF C a0 and all I want to know is

1426
00:51:18,500 --> 00:51:21,500
whether it's that grows downward or upward meaning, when you push new

1427
00:51:21,500 --> 00:51:24,300
things on the stack, do they go at higher addresses or do they go at

1428
00:51:24,300 --> 00:51:25,100
lower addresses?

1429
00:51:25,100 --> 00:51:25,500
That's all.

1430
00:51:25,500 --> 00:51:26,100
I wanted to know.

1431
00:51:26,100 --> 00:51:28,000
Just wanted to get that out in the open.

1432
00:51:28,000 --> 00:51:29,000
So let's take a look.

1433
00:51:30,200 --> 00:51:31,600
At where some of this stuff goes.

1434
00:51:31,600 --> 00:51:33,200
So here, we are bitmap memory size.

1435
00:51:33,200 --> 00:51:34,200
That is a local variable.

1436
00:51:34,200 --> 00:51:35,700
It should be on the stack here.

1437
00:51:36,100 --> 00:51:37,200
Let's see where it is.

1438
00:51:37,500 --> 00:51:43,000
And so one, FF C a0 and we have one FF bf0.

1439
00:51:43,000 --> 00:51:44,500
That looks a lot to me.

1440
00:51:44,700 --> 00:51:47,400
Like we are growing downwards, ladies and Gentlemen.

1441
00:51:47,400 --> 00:51:49,000
Let's just verify that that's true.

1442
00:51:49,300 --> 00:51:52,300
That does not necessarily surprised me, but I just want to make sure

1443
00:51:52,700 --> 00:51:53,600
that that is true.

1444
00:51:53,600 --> 00:51:54,700
That is the wrong way to go.

1445
00:51:54,700 --> 00:51:56,400
So this is the value that is lower.

1446
00:51:56,700 --> 00:51:59,300
This is the one that's further down in the function, basically.

1447
00:51:59,600 --> 00:52:00,700
In the depth of the function.

1448
00:52:00,700 --> 00:52:03,300
This was the one bitmap memory size.

1449
00:52:03,500 --> 00:52:06,700
And so this was a function that we called the most, the deepest nested

1450
00:52:06,700 --> 00:52:07,200
function.

1451
00:52:07,500 --> 00:52:10,400
And here's the one from the function that called it hit return.

1452
00:52:10,500 --> 00:52:11,600
It is 176.

1453
00:52:11,600 --> 00:52:11,800
Yes.

1454
00:52:11,800 --> 00:52:16,000
So our stack is growing downwards with that means, is that every time

1455
00:52:16,000 --> 00:52:17,700
something new is pushed on the stack.

1456
00:52:18,000 --> 00:52:20,700
It goes at lower and lower memory addresses, which is a little odd

1457
00:52:20,700 --> 00:52:22,900
because normally you think of things is growing and getting higher and

1458
00:52:22,900 --> 00:52:24,700
higher but it looks like the stack is going downwards.

1459
00:52:24,700 --> 00:52:27,800
Just something is good to know, does not really affect anything in any

1460
00:52:27,800 --> 00:52:29,300
particular way, but just something interesting too.

1461
00:52:29,500 --> 00:52:33,400
Think about also, I guess that means, and those of you who are

1462
00:52:33,400 --> 00:52:35,700
hardcore assembly guys, correct me if I'm wrong on this.

1463
00:52:35,700 --> 00:52:36,800
I don't want to speak out of turn.

1464
00:52:36,800 --> 00:52:40,200
But I guess that means that if this is the value that the stack is

1465
00:52:40,200 --> 00:52:42,300
that now that's the entirety of the stack size.

1466
00:52:42,300 --> 00:52:43,700
We actually get.

1467
00:52:43,900 --> 00:52:49,400
So basically we can only add about 2 megabytes to the stack before we

1468
00:52:49,400 --> 00:52:51,300
would get to the null page best.

1469
00:52:51,300 --> 00:52:52,500
So it can't be any more than that.

1470
00:52:52,500 --> 00:52:54,900
Our stack must be less than 2, MB.

1471
00:52:54,900 --> 00:52:56,100
I don't know if that's actually true.

1472
00:52:56,400 --> 00:52:58,300
But that's what that would seem to suggest to me.

1473
00:52:58,300 --> 00:52:59,000
Do you understand that?

1474
00:52:59,000 --> 00:52:59,300
Do you guys

1475
00:52:59,500 --> 00:53:00,100
Stand that at all.

1476
00:53:00,100 --> 00:53:02,900
Basically, what I'm saying is if I've got a local variable in this

1477
00:53:02,900 --> 00:53:06,200
function right here and I say, where is that, right?

1478
00:53:06,200 --> 00:53:07,200
I say, where is it tells me?

1479
00:53:07,200 --> 00:53:07,900
It's right here.

1480
00:53:08,000 --> 00:53:08,800
Well, that's where in memory.

1481
00:53:08,800 --> 00:53:09,800
The stack is at.

1482
00:53:09,900 --> 00:53:12,600
And every time we go ahead and push things on the stack, the stack is

1483
00:53:12,600 --> 00:53:14,700
usually continuous continuous rather.

1484
00:53:15,200 --> 00:53:17,600
It does not use disparate addresses in memory.

1485
00:53:17,600 --> 00:53:19,400
It uses contiguous addresses memory.

1486
00:53:19,600 --> 00:53:22,100
If we are subtracting from the stock every time, if those numbers are

1487
00:53:22,100 --> 00:53:24,900
getting lower than that, number certainly can't go any lower than zero

1488
00:53:24,900 --> 00:53:26,300
because we know that 0 is a null pointer.

1489
00:53:26,300 --> 00:53:29,300
And that would cause a an access violation and that whole page,

1490
00:53:29,400 --> 00:53:31,900
Age would be an access violation at least 4096.

1491
00:53:31,900 --> 00:53:35,700
So somewhere down, there is access violation territory, which means

1492
00:53:35,700 --> 00:53:40,100
that this pointer basically represents the max amount of stuff we can

1493
00:53:40,100 --> 00:53:43,700
push on the stack that value is the maximum number of stuff that we

1494
00:53:43,700 --> 00:53:45,000
could push on the stack.

1495
00:53:45,300 --> 00:53:47,600
I hope that makes some sense to people and I'm not just rambling.

1496
00:53:47,600 --> 00:53:51,100
But that basically means to me that says, you know, if you go ahead

1497
00:53:51,100 --> 00:53:56,300
here and said, well that divided by 1024, that is to, that is, that is

1498
00:53:56,300 --> 00:53:57,000
KB.

1499
00:53:57,100 --> 00:53:59,300
And if I went ahead and did 1024 x times.

1500
00:53:59,500 --> 00:53:59,900
24.

1501
00:54:00,000 --> 00:54:04,000
Just looking at at how many megabytes and it's only one megabyte.

1502
00:54:04,000 --> 00:54:06,300
It's a little more like it's almost 2 megabytes.

1503
00:54:06,300 --> 00:54:09,000
Basically, if I if I actually did this, in floating Point math, I'd

1504
00:54:09,000 --> 00:54:11,600
see a little bit more but that is kind of scary.

1505
00:54:11,800 --> 00:54:15,800
All right, so you have a 2 MB back to work with I guess that's just

1506
00:54:15,800 --> 00:54:16,900
how much you get by default.

1507
00:54:16,900 --> 00:54:18,800
Now, there are things that control how big the stack is.

1508
00:54:18,800 --> 00:54:22,200
Certainly you can change the stack size if you think you need more

1509
00:54:22,200 --> 00:54:24,200
than that, but that's just something to understand that.

1510
00:54:24,200 --> 00:54:27,000
Basically as you are calling functions, when you call functions, if

1511
00:54:27,000 --> 00:54:29,900
you were to put gigantic things on here, you might in run into

1512
00:54:30,000 --> 00:54:33,900
To a problem just because we are being kind of strange tonight.

1513
00:54:33,900 --> 00:54:37,800
I guess we could sort of see how big that default stack size actually

1514
00:54:37,800 --> 00:54:38,100
is.

1515
00:54:38,300 --> 00:54:42,000
Let's go ahead and just be, just be a little rascal, just be someone

1516
00:54:42,000 --> 00:54:45,000
who's who's just screwing around for fun because it is Friday.

1517
00:54:45,000 --> 00:54:45,900
And that is our prerogative.

1518
00:54:46,400 --> 00:54:48,900
Let's go ahead and see what happens at the five-minute warning.

1519
00:54:48,900 --> 00:54:53,400
No less if we just told this thing to allocate a bunch of memory, big

1520
00:54:53,400 --> 00:54:56,100
old block of memory, right?

1521
00:54:56,100 --> 00:54:56,700
On the stack.

1522
00:54:57,000 --> 00:55:00,000
I don't know how it will fare, but I'm going to

1523
00:55:00,000 --> 00:55:03,600
Go ahead and say go ahead and allocate 2 megabytes right on the stack.

1524
00:55:03,700 --> 00:55:04,500
What do you think about that?

1525
00:55:04,500 --> 00:55:04,700
Mr.

1526
00:55:04,700 --> 00:55:05,400
Compiler?

1527
00:55:05,600 --> 00:55:06,800
What are you going to do?

1528
00:55:06,800 --> 00:55:08,000
Well, it worked fine.

1529
00:55:08,400 --> 00:55:09,600
So I don't know what happened there.

1530
00:55:09,600 --> 00:55:10,700
This is a little puzzling.

1531
00:55:10,800 --> 00:55:13,200
This must be one of those things where I'm going to look at the stream

1532
00:55:13,200 --> 00:55:16,200
afterwards and you guys are going to say you're an idiot and that may

1533
00:55:16,200 --> 00:55:16,800
be true.

1534
00:55:16,800 --> 00:55:19,600
Ladies and gentlemen, I may well be an idiot.

1535
00:55:19,600 --> 00:55:22,700
So, let's take a look at big old block of memory, where that points

1536
00:55:22,700 --> 00:55:23,000
to.

1537
00:55:24,300 --> 00:55:24,900
There we go.

1538
00:55:24,900 --> 00:55:26,000
It is, uh, noops.

1539
00:55:27,000 --> 00:55:27,900
What did I do?

1540
00:55:27,900 --> 00:55:29,000
It is undefined.

1541
00:55:29,900 --> 00:55:31,900
Oh, well, the optimizer optimized it out.

1542
00:55:32,000 --> 00:55:34,300
I guess I didn't think we were compiling an optimized mode.

1543
00:55:34,300 --> 00:55:35,600
So I'm surprised at that.

1544
00:55:35,700 --> 00:55:36,500
Is that really true?

1545
00:55:36,500 --> 00:55:39,800
Well, see if we go ahead and clear that maybe let's see what happens

1546
00:55:39,800 --> 00:55:43,100
if we clear that and then maybe we'll do something ridiculous.

1547
00:55:44,900 --> 00:55:46,100
Since the optimizers not on.

1548
00:55:46,100 --> 00:55:46,700
Is that going to work?

1549
00:55:46,700 --> 00:55:47,800
I don't know what's going to work.

1550
00:55:48,100 --> 00:55:50,600
I don't know how we're going to get it to do that.

1551
00:55:50,600 --> 00:55:51,200
Ladies and Gentlemen.

1552
00:55:51,200 --> 00:55:51,900
Let's take a look.

1553
00:55:52,300 --> 00:55:52,900
There it is.

1554
00:55:52,900 --> 00:55:55,300
That's what I was looking for stackoverflow.

1555
00:55:55,300 --> 00:55:55,800
Thank you.

1556
00:55:55,800 --> 00:55:58,300
Ladies and gentlemen, we have done exactly what we tried to do.

1557
00:55:59,200 --> 00:56:00,700
That is great.

1558
00:56:01,100 --> 00:56:04,200
That is what I was hoping for now that it has not been optimized out.

1559
00:56:04,200 --> 00:56:05,600
Maybe I just didn't recompile.

1560
00:56:05,700 --> 00:56:06,500
Maybe that's what happened.

1561
00:56:06,500 --> 00:56:08,800
I don't really no point being basically.

1562
00:56:08,800 --> 00:56:11,700
What I did is I forced the compiler to make a 2 MB thing on the stack.

1563
00:56:11,700 --> 00:56:15,400
And since I noticed that, that particular time to the program, it had

1564
00:56:15,600 --> 00:56:18,600
given us an address, that was less than 2 MB away from the bottom of

1565
00:56:18,600 --> 00:56:18,900
memory.

1566
00:56:18,900 --> 00:56:22,500
I figured that the default stack size couldn't be any more than that.

1567
00:56:22,900 --> 00:56:26,100
Now remember in Windows first to security concerns.

1568
00:56:26,100 --> 00:56:28,400
Our stack will be at randomized locations.

1569
00:56:28,500 --> 00:56:28,700
So

1570
00:56:28,800 --> 00:56:31,400
It will not always be there but just noticing that I figured well,

1571
00:56:31,400 --> 00:56:35,700
that means that if it has to allocate stack for us to run, it could

1572
00:56:35,700 --> 00:56:37,200
not have been trying.

1573
00:56:37,200 --> 00:56:37,300
It.

1574
00:56:37,700 --> 00:56:40,600
It's there's obviously no way that the default stack size could have

1575
00:56:40,600 --> 00:56:43,500
been any bigger than that because it obviously thought it was okay to

1576
00:56:43,500 --> 00:56:45,600
give us, give us the memory down that low.

1577
00:56:46,200 --> 00:56:48,800
So what I did is I just made something to megabytes large to see,

1578
00:56:48,800 --> 00:56:50,300
whether it would just roll over and die.

1579
00:56:50,500 --> 00:56:51,800
And the answer is it did.

1580
00:56:51,800 --> 00:56:53,100
Now you could take a look at that error.

1581
00:56:53,500 --> 00:56:54,700
It basically is the same kind of thing.

1582
00:56:54,700 --> 00:56:56,400
We got when we were writing to invalid memory.

1583
00:56:56,400 --> 00:56:57,900
But this time instead of access violation.

1584
00:56:57,900 --> 00:56:58,700
It is a stack.

1585
00:56:58,800 --> 00:56:59,400
Overflow.

1586
00:56:59,500 --> 00:56:59,900
And that.

1587
00:57:00,000 --> 00:57:00,400
Exactly.

1588
00:57:00,400 --> 00:57:00,900
What we did.

1589
00:57:00,900 --> 00:57:02,300
We overflowed the stack.

1590
00:57:02,300 --> 00:57:05,500
We asked it to put too much stuff on there and we got this error and

1591
00:57:05,500 --> 00:57:08,000
that was what I was hoping to show you because I just wanted to

1592
00:57:08,000 --> 00:57:09,900
underscore the point that memory is not free.

1593
00:57:09,900 --> 00:57:13,700
It does not come from some sort of little magical memory pixie dust

1594
00:57:13,700 --> 00:57:15,900
Fairy Who sprinkles it on us and gives us as much as we need.

1595
00:57:15,900 --> 00:57:16,900
That is not what happens.

1596
00:57:17,100 --> 00:57:20,000
Even the stack, which is managed for us automatically by the compiler.

1597
00:57:20,100 --> 00:57:25,100
And by windows in some sense does not actually give us carte blanche.

1598
00:57:25,100 --> 00:57:26,400
We still have to be totally aware of.

1599
00:57:26,400 --> 00:57:29,700
How much of it we have and every time we call a function, we have to

1600
00:57:29,700 --> 00:57:29,800
know.

1601
00:57:30,000 --> 00:57:33,000
Know how much stack space were using so that we do not get too out of

1602
00:57:33,000 --> 00:57:33,400
control.

1603
00:57:33,400 --> 00:57:35,600
Now, we should never really be using something that's going to

1604
00:57:35,600 --> 00:57:39,200
allocate to Meg, suspect space, but you may be surprised if you were

1605
00:57:39,200 --> 00:57:41,200
to do something that's called a recursive function, which is a

1606
00:57:41,200 --> 00:57:44,000
function that calls itself and uses the stack is temporary memory,

1607
00:57:44,200 --> 00:57:45,500
something that we might do in the future.

1608
00:57:45,500 --> 00:57:46,900
Just to illustrate the point.

1609
00:57:47,100 --> 00:57:50,100
You can easily get in a situation where maybe you call yourself 40

1610
00:57:50,100 --> 00:57:54,000
times and all of a sudden each one of those things if it's just using

1611
00:57:54,000 --> 00:57:56,700
maybe 50 k of memory, let's say on the stack which is still a huge

1612
00:57:56,700 --> 00:57:59,800
amount or maybe you know, 10 K of memory that

1613
00:58:00,000 --> 00:58:01,400
Up to half a megabyte right there.

1614
00:58:01,500 --> 00:58:03,100
And that's a pretty big step a commitment.

1615
00:58:03,100 --> 00:58:04,700
When you know, it's less than 2 MB.

1616
00:58:05,000 --> 00:58:05,200
I guess.

1617
00:58:05,200 --> 00:58:08,700
One thing we could do is we could be a little bit more investigative

1618
00:58:08,700 --> 00:58:08,900
here.

1619
00:58:08,900 --> 00:58:11,400
And just start, instead of just looking, you know, we could always

1620
00:58:11,400 --> 00:58:13,500
just go look up how big the stack is right?

1621
00:58:13,500 --> 00:58:14,500
But what fun is that?

1622
00:58:14,700 --> 00:58:15,100
Why not?

1623
00:58:15,100 --> 00:58:21,300
Just go ahead and figure out how big it is by trial and error, right?

1624
00:58:21,600 --> 00:58:23,600
Okay, so we're down to two.

1625
00:58:23,600 --> 00:58:27,000
Let's let's go to a half, half a megabyte.

1626
00:58:27,300 --> 00:58:29,800
Let's see how that does half a megabyte work just fine.

1627
00:58:29,900 --> 00:58:32,900
Fine, so maybe we'll go up a little bit higher.

1628
00:58:33,400 --> 00:58:34,500
I don't know what to do here.

1629
00:58:34,700 --> 00:58:36,100
Maybe, something like that.

1630
00:58:36,200 --> 00:58:36,500
Let's see.

1631
00:58:36,500 --> 00:58:37,400
How that does.

1632
00:58:37,800 --> 00:58:38,600
We are still.

1633
00:58:38,600 --> 00:58:42,700
Okay, so I don't know how close we can get to one megabyte of stock in

1634
00:58:42,700 --> 00:58:46,200
our first function before we cause a problem, looks like we can get

1635
00:58:46,200 --> 00:58:47,500
real darn close to it.

1636
00:58:47,500 --> 00:58:47,900
Huh?

1637
00:58:48,200 --> 00:58:48,500
Really.

1638
00:58:48,500 --> 00:58:49,200
Darn close.

1639
00:58:49,200 --> 00:58:54,300
So let's go a little bit closer and still not stack overflowing yet.

1640
00:58:54,500 --> 00:58:56,400
This is going to be interesting is going to be tight.

1641
00:58:56,500 --> 00:58:58,500
Are you as excited as I am to find this out?

1642
00:58:58,500 --> 00:58:59,800
Where are we at?

1643
00:59:00,000 --> 00:59:00,700
All righty.

1644
00:59:00,800 --> 00:59:02,100
We have stack overflowed.

1645
00:59:02,200 --> 00:59:03,300
So we're real close.

1646
00:59:03,300 --> 00:59:05,600
And when I say stackoverflow, I mean the interesting kind not, the

1647
00:59:05,600 --> 00:59:08,200
website that has weird answers to questions that are sometimes wrong.

1648
00:59:08,600 --> 00:59:09,800
All right, there we go.

1649
00:59:10,400 --> 00:59:11,600
We are almost there.

1650
00:59:11,600 --> 00:59:14,900
Will binary search this down a little bit closer.

1651
00:59:15,300 --> 00:59:16,800
A little bit closer.

1652
00:59:16,800 --> 00:59:20,000
That is real real close right now.

1653
00:59:20,300 --> 00:59:21,700
There we go.

1654
00:59:21,700 --> 00:59:25,700
Okay, so we know we are basically like something like this.

1655
00:59:26,400 --> 00:59:27,500
Something like this.

1656
00:59:28,200 --> 00:59:29,800
We are really close something like,

1657
00:59:29,900 --> 00:59:32,400
Thousand 1000 K.

1658
00:59:32,900 --> 00:59:33,600
Okay.

1659
00:59:33,600 --> 00:59:39,200
Alright, so we know that it's somewhere between 999 and 1000 K or

1660
00:59:39,200 --> 00:59:41,300
maybe not what's going on there.

1661
00:59:43,100 --> 00:59:45,600
He'll exception during user call back.

1662
00:59:46,300 --> 00:59:47,400
Wait a minute.

1663
00:59:47,900 --> 00:59:50,800
Oh ha ha, that's pretty funny.

1664
00:59:51,200 --> 00:59:55,000
So we have actually started stock faulting down somewhere else because

1665
00:59:55,000 --> 00:59:57,400
we gave just enough stack for us to exist.

1666
00:59:57,900 --> 00:59:59,500
But as soon as we start calling down into

1667
01:00:00,300 --> 01:00:01,900
We first Windows to fault.

1668
01:00:01,900 --> 01:00:03,400
That is excellent.

1669
01:00:03,600 --> 01:00:04,400
That is excellent.

1670
01:00:04,400 --> 01:00:05,100
So, we know.

1671
01:00:05,300 --> 01:00:07,800
Yeah, we know we have something like a megabyte of snack.

1672
01:00:08,000 --> 01:00:08,900
That was kind of fun.

1673
01:00:09,000 --> 01:00:10,800
We know, we have something like a megabyte of stock.

1674
01:00:10,900 --> 01:00:12,900
When we enter our first function.

1675
01:00:13,200 --> 01:00:16,000
If we don't tell the compiler to give us more, I think there is a flag

1676
01:00:16,200 --> 01:00:18,100
that basically tells the compiler to give us more.

1677
01:00:18,300 --> 01:00:23,900
If we were to go in here and look at that, we could search for stack

1678
01:00:24,000 --> 01:00:26,100
and we would probably find something.

1679
01:00:27,100 --> 01:00:27,800
Let's see.

1680
01:00:27,800 --> 01:00:29,900
Let's see, Forest parameters.

1681
01:00:30,100 --> 01:00:34,000
That's xi's /f numb and I said assume that.

1682
01:00:34,000 --> 01:00:36,900
Basically, if we did a /f we could allocate.

1683
01:00:36,900 --> 01:00:38,500
We could have our cake and eat it too.

1684
01:00:38,900 --> 01:00:42,100
Remember, we cannot make something this big we tried to make something

1685
01:00:42,100 --> 01:00:42,900
that big.

1686
01:00:42,900 --> 01:00:43,900
It was two megabytes.

1687
01:00:44,700 --> 01:00:46,600
Let's go ahead and run that and that totally faulted.

1688
01:00:46,700 --> 01:00:49,700
So now let's ask for a giant stack, ladies and gentlemen, let us just

1689
01:00:49,700 --> 01:00:51,700
see what we can get away with.

1690
01:00:51,700 --> 01:00:54,400
Let's do ten, twenty four, four times, ten.

1691
01:00:54,400 --> 01:00:55,600
What is going on?

1692
01:00:55,600 --> 01:00:56,400
That is no good.

1693
01:00:56,400 --> 01:00:58,300
I'm in the wrong mode all together.

1694
01:00:58,600 --> 01:00:59,000
There we go.

1695
01:00:59,000 --> 01:00:59,900
Four times.

1696
01:01:00,000 --> 01:01:03,000
1024 x 1024, we will just copy.

1697
01:01:03,000 --> 01:01:05,200
That value will get a nice 4.

1698
01:01:05,200 --> 01:01:11,100
MB stack in theory will go back in here and we'll go to the build

1699
01:01:11,900 --> 01:01:14,200
build dot bat Bill, Dot bat.

1700
01:01:14,300 --> 01:01:16,800
And we will do what this thing said to do.

1701
01:01:16,800 --> 01:01:18,000
Where was that again?

1702
01:01:18,000 --> 01:01:20,500
Starts ffffff.

1703
01:01:20,500 --> 01:01:21,600
Where was that?

1704
01:01:21,700 --> 01:01:22,600
Where are you?

1705
01:01:22,600 --> 01:01:22,900
Mr.

1706
01:01:22,900 --> 01:01:27,900
F f numb, so just slash F and then that value.

1707
01:01:27,900 --> 01:01:29,900
Okay, let's do that.

1708
01:01:30,400 --> 01:01:32,500
- F and that value.

1709
01:01:32,500 --> 01:01:35,200
And let's see if that gives us a bigger stack.

1710
01:01:36,000 --> 01:01:36,700
Look at that.

1711
01:01:37,100 --> 01:01:38,400
We can have all the step size.

1712
01:01:38,400 --> 01:01:39,400
We want ladies and gentleman.

1713
01:01:39,400 --> 01:01:44,000
That is a very very generous stack indeed.

1714
01:01:44,000 --> 01:01:45,300
Hopefully we will not be anything like that.

1715
01:01:45,300 --> 01:01:47,100
So I'm gonna go ahead and delete that but just for the sake of

1716
01:01:47,100 --> 01:01:48,900
completeness, I want to show you that.

1717
01:01:48,900 --> 01:01:49,900
We had control over it.

1718
01:01:49,900 --> 01:01:53,000
All right, I'm gonna go into the Q&A a little bit today, just because

1719
01:01:53,000 --> 01:01:55,800
I want to step through these things and this is basically an entire

1720
01:01:55,800 --> 01:01:58,700
day, essentially up to you a maybe, let the Q&A run a little bit long

1721
01:01:58,700 --> 01:01:59,300
if we have to.

1722
01:02:00,100 --> 01:02:00,300
All right.

1723
01:02:00,300 --> 01:02:00,900
Here we are.

1724
01:02:01,400 --> 01:02:02,900
We basically clear these things on the stack.

1725
01:02:02,900 --> 01:02:06,100
We are going to go ahead and initialize our Global buffer back by 4.

1726
01:02:06,100 --> 01:02:07,300
So we're going to claw back in here.

1727
01:02:07,400 --> 01:02:08,600
We're going to pass it a pointer.

1728
01:02:08,700 --> 01:02:08,900
Now.

1729
01:02:08,900 --> 01:02:09,600
Where is this thing?

1730
01:02:09,600 --> 01:02:10,600
Where is This Global buffer?

1731
01:02:10,600 --> 01:02:10,700
Will?

1732
01:02:10,700 --> 01:02:13,300
That's basically something that was created at the initialization of

1733
01:02:13,300 --> 01:02:13,700
the program.

1734
01:02:13,700 --> 01:02:16,200
So that's just memory and that's not on the stack.

1735
01:02:16,200 --> 01:02:16,700
That's memory.

1736
01:02:16,700 --> 01:02:17,500
That's permanent.

1737
01:02:17,600 --> 01:02:18,600
We do not have to worry about.

1738
01:02:18,600 --> 01:02:18,700
You.

1739
01:02:18,700 --> 01:02:20,300
See that's in a totally different location.

1740
01:02:20,500 --> 01:02:21,900
Nowhere near the stock, right?

1741
01:02:22,000 --> 01:02:23,900
If you look at where the window class is, that's very low.

1742
01:02:24,300 --> 01:02:27,900
And if we look at where this back buffer is that's that's very high in

1743
01:02:27,900 --> 01:02:28,800
memory by comparison.

1744
01:02:28,800 --> 01:02:29,900
So there are nowhere near each other.

1745
01:02:30,000 --> 01:02:32,800
Oh, and that is kind of what you'd expect because this is not on the

1746
01:02:32,800 --> 01:02:33,300
stack.

1747
01:02:33,600 --> 01:02:36,900
This is, this is data memory of our program static data memory.

1748
01:02:36,900 --> 01:02:37,800
That was basically created.

1749
01:02:37,800 --> 01:02:39,700
When we launched, the executable said that.

1750
01:02:39,700 --> 01:02:42,300
We basically said, we needed that memory to run all of our Global

1751
01:02:42,300 --> 01:02:43,700
variables, go into it.

1752
01:02:44,000 --> 01:02:44,600
All right.

1753
01:02:45,300 --> 01:02:46,700
So we going to resize dip section.

1754
01:02:47,000 --> 01:02:50,300
We are going to allow this call to be called as many times as we want

1755
01:02:50,300 --> 01:02:50,600
to.

1756
01:02:50,700 --> 01:02:53,300
So what we do first is we check to see whether we already allocated

1757
01:02:53,300 --> 01:02:56,200
memory for our buffer and if we did we will get rid of it.

1758
01:02:56,200 --> 01:02:56,800
If we didn't.

1759
01:02:56,800 --> 01:02:59,400
We basically just fill out a bunch of fields that we will need to

1760
01:02:59,400 --> 01:02:59,800
remember.

1761
01:03:00,000 --> 01:03:02,300
In height, in the bits per pixel would bite for Pixel, which is

1762
01:03:02,300 --> 01:03:03,200
things, we want to know.

1763
01:03:03,800 --> 01:03:07,200
And then we are going to go ahead and fill out that that information

1764
01:03:07,200 --> 01:03:10,200
that Windows needed basically, to do the blind later on.

1765
01:03:10,200 --> 01:03:12,200
And you'll notice we have to pass that later on.

1766
01:03:12,200 --> 01:03:14,200
So that's basically just basically description to Windows.

1767
01:03:14,200 --> 01:03:16,700
That says, we are going to pass you a bunch of memory and here is how

1768
01:03:16,700 --> 01:03:17,200
you interpret it.

1769
01:03:17,200 --> 01:03:17,300
Now.

1770
01:03:17,300 --> 01:03:18,700
Remember, we had this negative here.

1771
01:03:18,800 --> 01:03:19,400
In fact, you know what?

1772
01:03:19,400 --> 01:03:21,200
I'm going to go ahead and add a comment to that because a little

1773
01:03:21,200 --> 01:03:22,800
confusing to people who don't know what's going on.

1774
01:03:22,900 --> 01:03:25,500
I'm just going to add a comment there that basically says,

1775
01:03:27,500 --> 01:03:35,200
Note when the bi height field is - this is the clue to Windows to

1776
01:03:35,200 --> 01:03:40,000
treat this bitmap as top-down not bottom-up.

1777
01:03:40,900 --> 01:03:49,600
Meaning that the first bite of the image, is the top left, right?

1778
01:03:49,600 --> 01:03:54,000
So, I guess, I should say, the first three bytes of the image are the

1779
01:03:54,000 --> 01:03:57,000
color for the top left pixel.

1780
01:03:57,200 --> 01:04:01,900
In the bitmap, not the bottom left, right?

1781
01:04:02,200 --> 01:04:02,800
Make sense.

1782
01:04:03,000 --> 01:04:05,600
Okay, so that is all that is and I just want to get that out there.

1783
01:04:05,700 --> 01:04:08,600
All right, we compile that have really changed any code.

1784
01:04:08,600 --> 01:04:10,000
So, we come back down in here.

1785
01:04:10,900 --> 01:04:13,600
We basically compute how big we need, because we are going to ask for

1786
01:04:13,600 --> 01:04:14,800
a permanent chunk of memory.

1787
01:04:15,100 --> 01:04:17,900
And you may ask, well, why didn't we just do what we did up here?

1788
01:04:18,200 --> 01:04:20,200
Why don't we just declare the chunk of memory up here and we could

1789
01:04:20,200 --> 01:04:20,700
have done that.

1790
01:04:20,700 --> 01:04:21,800
That is totally valid.

1791
01:04:21,900 --> 01:04:24,100
The reason I didn't want to do that is because I wanted to make the

1792
01:04:24,100 --> 01:04:26,100
size of this bitmap bi parametric meaning.

1793
01:04:26,100 --> 01:04:27,000
We could change it at any time.

1794
01:04:27,100 --> 01:04:28,400
Time in the code.

1795
01:04:28,600 --> 01:04:31,600
And if we had put it up here, it would have to be known at compile

1796
01:04:31,600 --> 01:04:31,900
time.

1797
01:04:31,900 --> 01:04:32,900
We could not change it.

1798
01:04:33,300 --> 01:04:36,600
We could still do it up there by just doing the one that was so big

1799
01:04:36,600 --> 01:04:38,900
that we knew it was always as big as the biggest one we could possibly

1800
01:04:38,900 --> 01:04:39,500
ever need.

1801
01:04:39,900 --> 01:04:40,800
We could totally do that.

1802
01:04:40,800 --> 01:04:43,500
Maybe we will do that eventually, but for now, I want to show you how

1803
01:04:43,500 --> 01:04:44,500
to use Virtual lock as well.

1804
01:04:44,500 --> 01:04:47,100
So we went ahead and did virtual Alec which, of course, ask the

1805
01:04:47,100 --> 01:04:48,900
operating system to reserve memory Pages for us.

1806
01:04:49,200 --> 01:04:53,300
It asks us to reserve this many basically, however, many memory Pages

1807
01:04:53,300 --> 01:04:57,000
it needs to take this much to hold this much data to hold.

1808
01:04:57,200 --> 01:04:59,800
Many bytes, and the thing that you have to remember is this will

1809
01:04:59,800 --> 01:05:02,500
allocate in increments of the page size.

1810
01:05:02,700 --> 01:05:03,400
The page size.

1811
01:05:03,400 --> 01:05:05,500
I believe, on Windows is normally 4096.

1812
01:05:05,500 --> 01:05:09,600
If you are not using large pages, in which case it is 64k, what that

1813
01:05:09,600 --> 01:05:13,100
means is we probably will not use exactly the right amount of memory.

1814
01:05:13,100 --> 01:05:13,500
Here.

1815
01:05:13,700 --> 01:05:16,400
We will get back more memory than we needed, just a little bit more

1816
01:05:16,400 --> 01:05:17,300
than we needed.

1817
01:05:17,800 --> 01:05:21,200
So if you look here, this is the actual size we're asking for, if I am

1818
01:05:21,200 --> 01:05:27,000
to go ahead and divide that by 4096 and then multiply it back by 4:00.

1819
01:05:27,100 --> 01:05:28,100
1096.

1820
01:05:28,400 --> 01:05:29,500
Let's see what we get there.

1821
01:05:29,700 --> 01:05:31,300
Well, that looks like it actually lifted up my eyes.

1822
01:05:31,300 --> 01:05:31,500
It out.

1823
01:05:31,500 --> 01:05:34,300
Looks like we are actually right on a page boundary, if that is

1824
01:05:34,300 --> 01:05:35,000
actually true.

1825
01:05:35,300 --> 01:05:37,400
Let's double-check that just to make sure it's not doing something

1826
01:05:37,400 --> 01:05:38,200
fancy thing here.

1827
01:05:38,500 --> 01:05:42,600
So, excuse me, apologize, again for the cold.

1828
01:05:42,900 --> 01:05:43,400
Okay.

1829
01:05:43,500 --> 01:05:44,400
This is the size we had.

1830
01:05:44,400 --> 01:05:46,800
This is the page size that I believe Windows using.

1831
01:05:46,800 --> 01:05:48,900
There's a way to get that page size and we could do that a little bit

1832
01:05:48,900 --> 01:05:49,400
later too.

1833
01:05:49,600 --> 01:05:50,700
Maybe we'll do that right now.

1834
01:05:51,000 --> 01:05:52,200
If that's the page size.

1835
01:05:52,200 --> 01:05:56,000
Then we know we are asking for at least nine, hundred Pages, possibly

1836
01:05:56,000 --> 01:05:57,000
more and I just want to see

1837
01:05:57,100 --> 01:05:59,800
See if 900 Pages basically time.

1838
01:06:00,000 --> 01:06:03,000
Page size comes out exact and it turns out it does.

1839
01:06:03,000 --> 01:06:06,600
So it turns out we are asking for exactly an even number page sizes.

1840
01:06:06,600 --> 01:06:09,500
So we are not wasting any memory ladies and gentlemen, how about that?

1841
01:06:09,600 --> 01:06:10,500
Totally accidental?

1842
01:06:10,700 --> 01:06:13,000
Normally, what happens with virtual Alec is you will waste a little

1843
01:06:13,000 --> 01:06:14,100
bit memory at the end of it.

1844
01:06:14,100 --> 01:06:16,900
And so the thing that you typically use Virtual a look for is not to

1845
01:06:16,900 --> 01:06:19,400
allocate little chunks of memory used virtual allocate.

1846
01:06:19,400 --> 01:06:21,900
I like to get a bunch of memory that you then subdivide and that is

1847
01:06:21,900 --> 01:06:23,000
exactly what we'll be doing with it.

1848
01:06:23,000 --> 01:06:25,700
But right now we only have one allocation, our entire program.

1849
01:06:25,800 --> 01:06:28,400
So there's really no way we can do anything more optimal there.

1850
01:06:28,500 --> 01:06:29,800
So we just go ahead and call it.

1851
01:06:30,000 --> 01:06:34,400
It anyway, we store the bytes per pixel back here.

1852
01:06:34,500 --> 01:06:36,900
And when we multiply the width times, the height for Pixel to

1853
01:06:36,900 --> 01:06:40,200
basically get the pitch or the stride depending on what you want to

1854
01:06:40,200 --> 01:06:43,200
call that and basically what that is is how many bytes pointer has to

1855
01:06:43,200 --> 01:06:45,500
move to go from one row to the next row.

1856
01:06:45,500 --> 01:06:47,300
And of course, that is the width.

1857
01:06:47,300 --> 01:06:51,700
The number of pixels across that the bitmap is times, the bytes per

1858
01:06:51,700 --> 01:06:55,500
pixel because we need to remember that each pixel itself is actually 4

1859
01:06:55,500 --> 01:06:56,000
B.

1860
01:06:56,100 --> 01:06:57,400
Since each pixel is 4.

1861
01:06:57,400 --> 01:06:57,900
Bytes.

1862
01:06:58,200 --> 01:06:59,900
That means that we could not just go.

1863
01:07:00,400 --> 01:07:05,100
With number of bytes, we have to go with times for number of bytes

1864
01:07:05,300 --> 01:07:06,800
because we have to skip the RG.

1865
01:07:06,800 --> 01:07:09,600
The are the G, the B, and the pad for each individual one.

1866
01:07:09,900 --> 01:07:10,400
All right.

1867
01:07:10,400 --> 01:07:14,800
So when we finish, we then fill out our window class remember window

1868
01:07:14,800 --> 01:07:17,400
class is just something we register with windows, that tells it where

1869
01:07:17,400 --> 01:07:20,900
to call back when a window needs to do to actually feel the message.

1870
01:07:21,100 --> 01:07:24,700
We fill out an instance because Windows needs to know who to call as

1871
01:07:24,700 --> 01:07:25,100
well.

1872
01:07:25,400 --> 01:07:29,600
So if you imagine basically, when I talked about the fact that we have

1873
01:07:29,600 --> 01:07:29,800
a virtual,

1874
01:07:29,900 --> 01:07:30,400
No memory.

1875
01:07:30,700 --> 01:07:32,800
We have a virtual memory address space for our program, right?

1876
01:07:33,500 --> 01:07:36,100
Well that virtual memory address space contains our code as well.

1877
01:07:36,300 --> 01:07:39,500
So if you want to call us back, you have to know which virtual address

1878
01:07:39,500 --> 01:07:39,800
space.

1879
01:07:39,800 --> 01:07:41,400
You are calling back, right?

1880
01:07:41,400 --> 01:07:45,700
Windows needs to know which process is actually holding the function

1881
01:07:45,700 --> 01:07:48,400
because if I just say, here is the address of a function.

1882
01:07:48,700 --> 01:07:52,400
Well, that address is in my processes virtual memory space.

1883
01:07:52,800 --> 01:07:55,700
If you didn't know which process you are calling back.

1884
01:07:55,900 --> 01:07:59,300
You wouldn't know what that address actually refers to, because every

1885
01:07:59,300 --> 01:07:59,800
address space.

1886
01:08:00,000 --> 01:08:01,700
Every process is different.

1887
01:08:01,900 --> 01:08:06,900
So in a pointer does not uniquely identify memory in the system, it

1888
01:08:06,900 --> 01:08:09,500
uniquely identifies memory in one process.

1889
01:08:09,600 --> 01:08:12,600
And so, without the process handle Windows would have no idea who it

1890
01:08:12,600 --> 01:08:13,300
was even calling.

1891
01:08:13,400 --> 01:08:17,100
So basically, what this is, is that handle, this is the instance that

1892
01:08:17,100 --> 01:08:21,600
says this is the actual process that contains this pointers memory.

1893
01:08:21,600 --> 01:08:26,800
So interpret this pointer in its address space and then it can do the

1894
01:08:26,800 --> 01:08:28,100
disa dispatch.

1895
01:08:28,200 --> 01:08:29,800
We give our window classic.

1896
01:08:29,899 --> 01:08:33,000
A meaningless name because we need to do that because we are going to

1897
01:08:33,000 --> 01:08:34,600
pass that name to create window EXO.

1898
01:08:34,600 --> 01:08:38,000
It knows what window class our window is using.

1899
01:08:38,100 --> 01:08:40,300
Of course, we only have one so it's a real waste of time.

1900
01:08:40,300 --> 01:08:41,300
But that's just something I have to do.

1901
01:08:41,500 --> 01:08:44,300
We register the class with Windows by passing a pointer to this stack

1902
01:08:44,300 --> 01:08:45,300
variable that we have here.

1903
01:08:45,800 --> 01:08:48,000
Now, we don't have to worry about that ever going out of scope because

1904
01:08:48,000 --> 01:08:49,899
we won't exit this function, but we don't have to worry about it.

1905
01:08:49,899 --> 01:08:52,700
Going a scope period because windows will actually snap a copy of it.

1906
01:08:52,700 --> 01:08:54,200
It does not rely on our copy.

1907
01:08:54,200 --> 01:08:56,600
So we don't have to keep we don't have to make sure that that copy

1908
01:08:56,600 --> 01:08:58,100
stays around for as long as we use anything.

1909
01:08:58,100 --> 01:08:59,800
It is just going to use it to read them.

1910
01:09:00,000 --> 01:09:02,000
It out and then it is going to return.

1911
01:09:03,200 --> 01:09:05,000
And we don't have to worry about keeping it around anymore.

1912
01:09:05,300 --> 01:09:06,100
You need to remember that.

1913
01:09:06,100 --> 01:09:08,399
Sometimes you do, sometimes when you pass an address into Windows, you

1914
01:09:08,399 --> 01:09:10,800
have to make sure that the thing you pass the address to stays around

1915
01:09:10,800 --> 01:09:12,600
for the lifetime of the things that might use it.

1916
01:09:12,700 --> 01:09:13,600
This is not that case.

1917
01:09:13,600 --> 01:09:14,300
So you don't have to worry about it.

1918
01:09:14,300 --> 01:09:14,600
Here.

1919
01:09:14,899 --> 01:09:16,800
We then go ahead and do a create window e^x.

1920
01:09:16,800 --> 01:09:19,200
And basically, all we do is pass the window class that we wanted.

1921
01:09:19,200 --> 01:09:20,800
And that's so that our window knows.

1922
01:09:21,399 --> 01:09:24,700
So that Windows knows that our window is going to call this call back.

1923
01:09:24,899 --> 01:09:26,200
Anytime it gets an event.

1924
01:09:26,300 --> 01:09:28,800
We told that we want to be visible right away so that it shows up on

1925
01:09:28,800 --> 01:09:31,300
Startup and that it was a WS overlapped window, which is basically

1926
01:09:31,300 --> 01:09:32,700
just a

1927
01:09:32,800 --> 01:09:36,200
It set of flags composite set of bits in this bit field.

1928
01:09:36,200 --> 01:09:37,399
This is just a 32-bit value.

1929
01:09:37,399 --> 01:09:38,399
That's got a bunch of bit set.

1930
01:09:38,399 --> 01:09:41,200
That windows will look at each individual bit to determine a bunch of

1931
01:09:41,200 --> 01:09:42,000
things about the window.

1932
01:09:42,300 --> 01:09:44,700
It is basically just a composite that says, it has things like a title

1933
01:09:44,700 --> 01:09:49,000
bar and a closed box, and things like that, or resizable frame.

1934
01:09:50,000 --> 01:09:52,600
And we also pass the answer to this as well because again, Windows

1935
01:09:52,600 --> 01:09:54,700
wants to know what instance is calling it.

1936
01:09:54,700 --> 01:09:56,900
I think those are probably somewhat inaccurate Mystic these days.

1937
01:09:56,900 --> 01:09:59,200
I don't actually know if you actually really need to pass those to I

1938
01:09:59,200 --> 01:10:02,000
mean, I think you do need to pass my windows will be upset with you,

1939
01:10:02,300 --> 01:10:04,200
but I don't know how much they need because they know which instance

1940
01:10:04,200 --> 01:10:04,900
is actually calling it.

1941
01:10:04,900 --> 01:10:06,900
So I'm not sure how important that is.

1942
01:10:06,900 --> 01:10:09,800
I think those may be somewhat anachronistic but ignore that for now,

1943
01:10:09,800 --> 01:10:10,800
we create our window.

1944
01:10:10,800 --> 01:10:12,900
Our window is created, assuming that we got back a handle that was

1945
01:10:12,900 --> 01:10:13,200
valid.

1946
01:10:13,200 --> 01:10:16,900
We assume that we are ready to run, we go ahead and enter a loop.

1947
01:10:16,900 --> 01:10:17,900
That is infinite.

1948
01:10:17,900 --> 01:10:19,700
It will not exit until running a set.

1949
01:10:19,900 --> 01:10:22,100
False by someone else in the program running again is a global

1950
01:10:22,100 --> 01:10:24,400
variable and maybe one of the things I will do is change that to have

1951
01:10:24,400 --> 01:10:26,900
a prefix Global just so everyone knows it's Global.

1952
01:10:26,900 --> 01:10:28,300
I don't often prefix things.

1953
01:10:28,600 --> 01:10:33,500
But for Global's I often will will change that rule just because I

1954
01:10:33,500 --> 01:10:36,100
think it's important to be able to see when something is global.

1955
01:10:36,100 --> 01:10:37,400
So that's a good habit to get into.

1956
01:10:37,400 --> 01:10:39,400
I think something that's worth thinking about.

1957
01:10:39,400 --> 01:10:42,700
If you are thinking about code Styles something that's not bad to do.

1958
01:10:43,600 --> 01:10:43,900
Yes.

1959
01:10:45,000 --> 01:10:47,700
So anyway, we go ahead and enter our Loop.

1960
01:10:47,800 --> 01:10:51,700
We create some space on the stack for Windows to store its message

1961
01:10:51,800 --> 01:10:53,500
because it needs a place to write it.

1962
01:10:53,600 --> 01:10:54,500
We call Peak message.

1963
01:10:54,500 --> 01:10:57,100
And again, what Peak message will do is it will look at our Windows

1964
01:10:57,100 --> 01:10:59,100
window Q for our process.

1965
01:10:59,100 --> 01:11:02,000
It will see if there are any messages in there for us.

1966
01:11:02,000 --> 01:11:03,600
And if there are because we pass p.m.

1967
01:11:03,600 --> 01:11:06,100
Remove it, we'll go ahead and give it back to us.

1968
01:11:06,100 --> 01:11:06,300
Now.

1969
01:11:06,300 --> 01:11:08,700
I passed all zeros here, which means it will filter the messages.

1970
01:11:08,700 --> 01:11:10,200
It will not do anything.

1971
01:11:10,500 --> 01:11:13,400
Like only give us ones for a certain window or only give us ones that

1972
01:11:13,400 --> 01:11:14,600
fall into a certain message range.

1973
01:11:15,000 --> 01:11:17,900
It will then see whether or not or rather.

1974
01:11:17,900 --> 01:11:20,400
We will then check whether or not it was WM quit message.

1975
01:11:20,400 --> 01:11:21,700
Just in case Windows sent us one.

1976
01:11:21,700 --> 01:11:22,000
Now.

1977
01:11:22,000 --> 01:11:23,000
It should never send this one.

1978
01:11:23,000 --> 01:11:26,800
I don't think, but just in case it did, we will go ahead and set

1979
01:11:26,800 --> 01:11:27,500
running to false.

1980
01:11:27,500 --> 01:11:27,800
There.

1981
01:11:28,200 --> 01:11:28,400
We will.

1982
01:11:28,400 --> 01:11:31,000
Then ask Windows to translate message and translate message canceling

1983
01:11:31,000 --> 01:11:32,400
that just translates key codes.

1984
01:11:32,800 --> 01:11:35,700
I don't actually know how much we actually really care about that, but

1985
01:11:35,700 --> 01:11:38,200
it's a something that you typically do, and then we dispatch message

1986
01:11:38,200 --> 01:11:41,600
which will again call our window class as necessary.

1987
01:11:41,600 --> 01:11:44,500
Now remember Windows call our window call back anytime.

1988
01:11:45,200 --> 01:11:47,000
It does not need to only do it in this past message.

1989
01:11:47,000 --> 01:11:49,100
That's a little bit of a gotcha, you would think.

1990
01:11:49,100 --> 01:11:50,200
But that is not the case.

1991
01:11:50,200 --> 01:11:51,000
So we have to be ready.

1992
01:11:51,000 --> 01:11:51,600
Actually, anytime.

1993
01:11:51,600 --> 01:11:52,700
We call the windows call.

1994
01:11:52,700 --> 01:11:54,300
Just keep in mind, it could call you back.

1995
01:11:54,300 --> 01:11:58,300
Now after we Loop through there and pull off all the messages that

1996
01:11:58,300 --> 01:11:59,900
Windows has for us to pull off we go.

1997
01:12:00,100 --> 01:12:02,900
Head and call render weird gradient and render weird, gradient goes

1998
01:12:02,900 --> 01:12:06,800
through and it snaps the pointer to the beginning of our back buffer.

1999
01:12:07,000 --> 01:12:11,200
If then steps through every row of that back buffer and grabs a

2000
01:12:11,200 --> 01:12:12,800
pointer to the beginning of the row.

2001
01:12:12,800 --> 01:12:14,300
Remember, we are advancing row.

2002
01:12:14,300 --> 01:12:14,800
Each time.

2003
01:12:14,800 --> 01:12:17,500
We advance it by pitch each time through this outer loop to get to the

2004
01:12:17,500 --> 01:12:18,000
next row.

2005
01:12:18,000 --> 01:12:20,200
Because when we said the pitch was the thing that moves us from one

2006
01:12:20,200 --> 01:12:20,900
row to the next.

2007
01:12:21,200 --> 01:12:24,100
We then grab an individual pixel pointer by basically saying, okay,

2008
01:12:24,100 --> 01:12:25,100
let's take a look at row.

2009
01:12:26,000 --> 01:12:28,000
Now remember the pitch isn't B.

2010
01:12:28,200 --> 01:12:30,600
We said the pitch was going to be in B, how do we know the pitches

2011
01:12:30,600 --> 01:12:31,000
invites?

2012
01:12:31,000 --> 01:12:33,300
Well, if we look at where we computed it, you'll notice that we

2013
01:12:33,300 --> 01:12:34,900
multiplied it by bytes per pixel.

2014
01:12:35,200 --> 01:12:35,700
Right?

2015
01:12:35,900 --> 01:12:38,800
So we are we are looking at a value that is in B.

2016
01:12:38,900 --> 01:12:43,800
So when we add to the row, the row had better, be a pointer to B,

2017
01:12:44,000 --> 01:12:44,600
which it is.

2018
01:12:44,600 --> 01:12:48,300
Otherwise c will do that silent multiplication for us and we will add

2019
01:12:48,300 --> 01:12:52,700
too much ladies and gentleman if this preparing to a un 32, we would

2020
01:12:52,700 --> 01:12:54,800
actually move four times.

2021
01:12:54,800 --> 01:12:55,600
The amount we were supposed to

2022
01:12:56,100 --> 01:12:57,300
And that would be bad.

2023
01:12:57,300 --> 01:12:59,400
So just that's why that's a, uh, very important.

2024
01:12:59,400 --> 01:12:59,700
There.

2025
01:12:59,900 --> 01:13:01,500
We are, then going to go by pixels here.

2026
01:13:01,500 --> 01:13:03,200
So we cast to a un 32.

2027
01:13:03,300 --> 01:13:03,500
Again.

2028
01:13:03,500 --> 01:13:04,400
These are the same pointer.

2029
01:13:04,400 --> 01:13:06,400
Now, we've just copied it in here, but then, we're going to advance

2030
01:13:06,400 --> 01:13:09,000
this pointer for each individual pixel.

2031
01:13:09,100 --> 01:13:11,500
So we come in, here we go for each pixel in a row.

2032
01:13:12,500 --> 01:13:15,600
We basically used a little faux value here to just say, hey, we'll

2033
01:13:15,600 --> 01:13:18,800
assign the X&Y just to give us a little bit of a gradient so that X

2034
01:13:18,800 --> 01:13:20,700
increments here and it will wrap remember.

2035
01:13:20,700 --> 01:13:21,600
This is a un 8.

2036
01:13:21,600 --> 01:13:25,600
So, it means that when the, when the x value gets plus, whatever, the

2037
01:13:25,700 --> 01:13:28,300
It is that we passed in to make an animate, but that'll be 0.

2038
01:13:28,300 --> 01:13:30,300
The first time through these will both be zero and they'll just kind

2039
01:13:30,300 --> 01:13:32,100
of increment to make us get that animation.

2040
01:13:32,500 --> 01:13:35,900
But basically every time we overflow 8-bit, so every time we get to

2041
01:13:35,900 --> 01:13:39,400
255, when we add one, we will go back to zero because we've only got

2042
01:13:39,400 --> 01:13:43,300
you an 8 here and that's what creates that 256 by 256 block pattern

2043
01:13:43,600 --> 01:13:44,600
that you see in our gradient.

2044
01:13:44,600 --> 01:13:47,800
It's those it's those eight bits wrapping rolling over every time.

2045
01:13:48,700 --> 01:13:50,400
We then go ahead and write that out to fix the pointer.

2046
01:13:50,400 --> 01:13:53,300
We use a nice little notation here, which is basically very concise.

2047
01:13:53,600 --> 01:13:55,200
That is C shorthand.

2048
01:13:55,200 --> 01:13:57,300
I'll just say it again because I think everyone should probably know

2049
01:13:57,300 --> 01:13:59,100
by now, but I've never really explained on the stream.

2050
01:13:59,100 --> 01:14:01,000
So we will make it clear star.

2051
01:14:01,000 --> 01:14:02,100
Pixel means.

2052
01:14:02,100 --> 01:14:04,900
I am trying to write to the location of pixel that dereferences.

2053
01:14:04,900 --> 01:14:08,900
Pixel, basically says, okay, pixel is a pointer, but I now want to

2054
01:14:08,900 --> 01:14:09,600
talk about the thing.

2055
01:14:09,600 --> 01:14:10,800
That's at that pointer, right?

2056
01:14:10,800 --> 01:14:13,300
So if I put it on the left-hand side, I am writing to it.

2057
01:14:13,300 --> 01:14:14,900
If I was to put it on the right hand side.

2058
01:14:14,900 --> 01:14:16,500
I am reading from it in a sense.

2059
01:14:16,800 --> 01:14:17,900
You could think of it that way.

2060
01:14:18,700 --> 01:14:21,100
If I was going to write to it, I could write to the pixel here, right?

2061
01:14:21,100 --> 01:14:22,100
Some value into it.

2062
01:14:22,900 --> 01:14:24,800
And so that is what the star does.

2063
01:14:25,000 --> 01:14:27,300
The plus plus is the post increment operator.

2064
01:14:27,300 --> 01:14:29,200
It says, after this line.

2065
01:14:30,200 --> 01:14:34,000
After this statement, I should say after this statement.

2066
01:14:34,000 --> 01:14:36,600
I want you to increment this value by 1, right.

2067
01:14:36,600 --> 01:14:37,800
I want you to increment it once.

2068
01:14:37,900 --> 01:14:40,900
So basically, this is the same as saying star, pixel, equals

2069
01:14:40,900 --> 01:14:43,800
something, plus plus pixel, right?

2070
01:14:43,800 --> 01:14:45,900
Or pixel equals pixel plus 1.

2071
01:14:46,000 --> 01:14:46,900
Right now.

2072
01:14:46,900 --> 01:14:49,200
It's a little deceptive again because it is a un 32 pointer.

2073
01:14:49,200 --> 01:14:52,400
So really what will happen here is that is the compiler will silently

2074
01:14:52,800 --> 01:14:53,600
do that.

2075
01:14:53,700 --> 01:14:55,400
So it will really add 4 to it.

2076
01:14:55,400 --> 01:14:59,300
But that is exactly what we want, what it increments pixel because

2077
01:14:59,300 --> 01:14:59,800
each

2078
01:15:00,000 --> 01:15:01,400
So is 4, bytes long?

2079
01:15:01,400 --> 01:15:02,500
So that is exactly what we want.

2080
01:15:02,500 --> 01:15:04,000
And see is just save me some time there.

2081
01:15:04,000 --> 01:15:05,100
That is what it is doing.

2082
01:15:05,300 --> 01:15:06,400
Now, in here.

2083
01:15:06,400 --> 01:15:07,500
We need to pack our pixel.

2084
01:15:07,500 --> 01:15:10,400
As we know, inside our registers.

2085
01:15:10,400 --> 01:15:13,300
We have a thing that looks like x x RR.

2086
01:15:13,300 --> 01:15:15,500
GG BB in memory order.

2087
01:15:15,600 --> 01:15:18,500
That is V VG.

2088
01:15:18,500 --> 01:15:19,500
R RX X.

2089
01:15:20,500 --> 01:15:24,700
So in order to pack these into the register, we go ahead and do a blue

2090
01:15:24,700 --> 01:15:27,400
in the bottom B, because we know that that is the least significant

2091
01:15:27,600 --> 01:15:29,700
byte and we pack green one above it.

2092
01:15:29,700 --> 01:15:29,800
We

2093
01:15:30,000 --> 01:15:30,700
Don't have any red.

2094
01:15:30,700 --> 01:15:31,900
We don't have any pad to, right.

2095
01:15:31,900 --> 01:15:34,200
So those stay 0 that produces our new pixel value.

2096
01:15:34,200 --> 01:15:37,600
And when the CPU, remember, again, that's in there.

2097
01:15:37,900 --> 01:15:43,600
It's in our register looking like x x RR, GG BB right.

2098
01:15:43,700 --> 01:15:46,300
When that goes to be written out since Intel is little-endian.

2099
01:15:46,300 --> 01:15:47,800
It will reverse, the order.

2100
01:15:47,800 --> 01:15:49,700
It will write the BB to the lowest one.

2101
01:15:49,700 --> 01:15:51,600
It will write the GG to the next one.

2102
01:15:51,600 --> 01:15:55,500
So that will basically do that reversal into memory to make the memory

2103
01:15:55,500 --> 01:15:56,900
or to go like this first bite.

2104
01:15:56,900 --> 01:15:58,600
Second bite, third bite, fourth bite.

2105
01:15:58,700 --> 01:15:59,500
Just something to remember.

2106
01:16:00,500 --> 01:16:02,400
Okay, that is a little endian at work.

2107
01:16:02,500 --> 01:16:04,900
This basically produces our gradient, that lovely thing on the screen

2108
01:16:04,900 --> 01:16:08,600
that animates for us and that is the way that works.

2109
01:16:08,600 --> 01:16:09,200
Okay.

2110
01:16:09,500 --> 01:16:11,900
That is the end of our helper functions.

2111
01:16:13,700 --> 01:16:14,500
What is going on here?

2112
01:16:14,500 --> 01:16:16,400
Why can I not on set that break point?

2113
01:16:16,400 --> 01:16:18,200
F9 is not behaving tonight.

2114
01:16:18,200 --> 01:16:20,200
Ladies and gentlemen, I do not know why there it goes.

2115
01:16:20,300 --> 01:16:21,100
Okay, that's good.

2116
01:16:21,500 --> 01:16:24,700
Anyway, let's go ahead and recompile that now, there we go.

2117
01:16:25,000 --> 01:16:27,400
One thing you should be aware of is that if you have a program stopped

2118
01:16:27,400 --> 01:16:29,900
in the debugger, like this, and you go,

2119
01:16:30,100 --> 01:16:34,500
Can you try to compile something it will say this cannot open win32

2120
01:16:34,500 --> 01:16:35,800
handmade .exe for writing.

2121
01:16:35,800 --> 01:16:38,100
And that is because the debugger actually holds it open.

2122
01:16:38,500 --> 01:16:40,000
So basically, well, it's not really the butter.

2123
01:16:40,000 --> 01:16:40,400
Holds it open.

2124
01:16:40,400 --> 01:16:41,400
It's that it's running.

2125
01:16:41,400 --> 01:16:42,700
So Windows is kind of holding it open.

2126
01:16:42,700 --> 01:16:44,700
You could think that is a downside to Windows.

2127
01:16:44,700 --> 01:16:46,200
It does not happen on Linux machines.

2128
01:16:46,200 --> 01:16:47,800
Unix uses a different system.

2129
01:16:47,800 --> 01:16:49,300
It's got inodes and they get reference.

2130
01:16:49,300 --> 01:16:51,800
So you do not have to worry about that on units, but on Windows you

2131
01:16:51,800 --> 01:16:52,200
do.

2132
01:16:52,900 --> 01:16:55,400
I'm assuming on Mac you don't either because it's Unix under the hood,

2133
01:16:55,400 --> 01:16:58,000
but I don't actually know if that's true because I don't use Macintosh

2134
01:16:58,000 --> 01:16:59,900
very often, but at least on Windows.

2135
01:17:00,000 --> 01:17:01,100
You do have to worry about it.

2136
01:17:01,200 --> 01:17:05,000
So, always make sure you hit shift F5 to kill that debug before you

2137
01:17:05,000 --> 01:17:08,900
come back here and hit alt M to build, if you are building an external

2138
01:17:08,900 --> 01:17:09,200
editor.

2139
01:17:09,200 --> 01:17:12,100
All right, so we come back in here, read your are weird.

2140
01:17:12,100 --> 01:17:12,800
Gradient.

2141
01:17:13,200 --> 01:17:14,600
Oops, didn't mean to do that.

2142
01:17:14,900 --> 01:17:15,400
There we go.

2143
01:17:15,500 --> 01:17:17,000
Render, our render, our word gradient.

2144
01:17:17,000 --> 01:17:20,500
We get a handle to the window, which is basically just a way of us

2145
01:17:20,500 --> 01:17:21,200
asking Windows.

2146
01:17:21,200 --> 01:17:22,200
We're trying to do some drawing now.

2147
01:17:22,200 --> 01:17:24,100
Can you please give us back handle?

2148
01:17:24,100 --> 01:17:27,000
That allows us to issue draw calls purely, artificial construct.

2149
01:17:27,000 --> 01:17:29,700
Windows just wants to bound those because those Save State

2150
01:17:30,000 --> 01:17:31,200
Actually, you can later on.

2151
01:17:32,000 --> 01:17:32,600
Well, not later on.

2152
01:17:32,600 --> 01:17:35,200
Probably if you did your own investigation, you would see that you can

2153
01:17:35,200 --> 01:17:37,800
do things with Device context like draw lines and stuff like this.

2154
01:17:37,800 --> 01:17:41,100
And you can select things into them like brushes and patterns and

2155
01:17:41,100 --> 01:17:41,300
stuff.

2156
01:17:41,300 --> 01:17:43,700
So they're they're a whole state tracking mechanism.

2157
01:17:43,700 --> 01:17:46,500
Basically that we don't really need, but all drawing stuff has to go

2158
01:17:46,500 --> 01:17:47,900
through it when we're on this path.

2159
01:17:47,900 --> 01:17:48,900
So, that's the case.

2160
01:17:48,900 --> 01:17:53,600
We use the helper function that we called to basically get the width

2161
01:17:53,600 --> 01:17:54,300
and height of a window.

2162
01:17:54,300 --> 01:17:57,400
We did that by asking win Windows to give us back a client wreck,

2163
01:17:57,400 --> 01:17:59,800
which is the writable region of a window.

2164
01:18:00,100 --> 01:18:01,200
In Windows space.

2165
01:18:01,200 --> 01:18:05,200
So basically left and top are always zero and right.

2166
01:18:05,200 --> 01:18:08,300
And bottom are always the actual width and height, but just in case

2167
01:18:08,300 --> 01:18:09,500
they should change that someday.

2168
01:18:09,600 --> 01:18:12,800
We actually went through and we're a little more diligent and subtract

2169
01:18:12,800 --> 01:18:13,600
the left and top.

2170
01:18:13,600 --> 01:18:16,300
But pretty much always, every time you go through there.

2171
01:18:16,600 --> 01:18:18,400
As far as I know, that is redundant.

2172
01:18:18,400 --> 01:18:21,200
As you can see, the left and top is always zero, so that subtraction

2173
01:18:21,200 --> 01:18:22,600
basically does nothing the right?

2174
01:18:22,600 --> 01:18:25,500
And bottom is basically the width and the height, just right there.

2175
01:18:25,500 --> 01:18:27,600
Okay, when we step out of that, we've got it.

2176
01:18:27,800 --> 01:18:29,700
We asked Windows to display it by calling.

2177
01:18:30,000 --> 01:18:33,400
SGI B, which is just a function, which stretches a are off-screen

2178
01:18:33,400 --> 01:18:37,500
buffer up into or down into the windows side.

2179
01:18:37,500 --> 01:18:38,100
So we pass it.

2180
01:18:38,100 --> 01:18:40,300
The window size and we pass it, our buffer size.

2181
01:18:41,000 --> 01:18:43,500
We also passed it that bitmap description that it needed.

2182
01:18:43,500 --> 01:18:44,500
So it knows how to copy.

2183
01:18:44,500 --> 01:18:46,400
It, knows what it's looking at.

2184
01:18:46,400 --> 01:18:48,200
And we pass it, the memory.

2185
01:18:48,200 --> 01:18:50,200
We also gave it some Flags to tell us how to do the copy.

2186
01:18:50,200 --> 01:18:50,600
Nothing big.

2187
01:18:50,600 --> 01:18:52,100
They're just says, wasn't palletized.

2188
01:18:52,100 --> 01:18:54,000
So it doesn't look up a color palette or anything like that.

2189
01:18:54,000 --> 01:18:57,000
It's just they're straight RGB values right in the pixels and we

2190
01:18:57,000 --> 01:18:59,900
passed its source copy, which tells it don't do any

2191
01:19:00,000 --> 01:19:01,900
The best bits just copy them.

2192
01:19:02,200 --> 01:19:03,000
That's about it.

2193
01:19:03,200 --> 01:19:04,600
Alright, so we come back out here.

2194
01:19:04,600 --> 01:19:07,200
We release the DC because this is a getting release mechanism.

2195
01:19:07,600 --> 01:19:09,500
When we get one, we have to give it back.

2196
01:19:09,700 --> 01:19:15,300
And so then we increment our our gradient offset, which allows it to

2197
01:19:15,300 --> 01:19:15,800
look like.

2198
01:19:15,800 --> 01:19:18,400
It is animating because we update it and we will just come back

2199
01:19:18,400 --> 01:19:21,100
through here and this Loop will happen in at infinitum, pull off the

2200
01:19:21,100 --> 01:19:23,600
messages re-render, the gradient, pull off the messages rear-ended,

2201
01:19:23,600 --> 01:19:26,200
the gradient, and that is our program.

2202
01:19:26,700 --> 01:19:29,800
It will not stop until we get a window message.

2203
01:19:30,100 --> 01:19:34,500
And the window message is the the close message at which point we will

2204
01:19:34,500 --> 01:19:34,800
stop.

2205
01:19:34,800 --> 01:19:39,800
So if we are running and we closed that we hit here now that will set

2206
01:19:39,800 --> 01:19:42,300
Global writing false break out of that Loop down at the bottom of the

2207
01:19:42,300 --> 01:19:44,700
program because you can see that it only goes as long as Global

2208
01:19:44,700 --> 01:19:46,700
running is true and it won't be true anymore.

2209
01:19:46,700 --> 01:19:47,800
So it will exit.

2210
01:19:47,800 --> 01:19:48,700
That is what that will do.

2211
01:19:48,700 --> 01:19:48,800
Now.

2212
01:19:48,800 --> 01:19:51,600
There is one of the things that our program does we have this window

2213
01:19:51,600 --> 01:19:55,000
call back, but besides just Fielding the clothes message and the

2214
01:19:55,000 --> 01:19:57,400
destroy message and so on, and some of these other ones, we can get

2215
01:19:57,400 --> 01:19:58,200
rid of that one now.

2216
01:19:58,300 --> 01:19:59,800
And this one, we're going to handle it later.

2217
01:20:00,300 --> 01:20:02,700
Basically, we have this WM painting here.

2218
01:20:03,000 --> 01:20:06,200
And what WM paint is remember, basically, one of the things that we're

2219
01:20:06,200 --> 01:20:09,800
doing is we are forced, painting, the window to make an anime.

2220
01:20:09,800 --> 01:20:11,400
So we're just flat-out going.

2221
01:20:11,400 --> 01:20:11,800
Anytime.

2222
01:20:11,800 --> 01:20:15,400
We are done processing messages as fast as we can, using all available

2223
01:20:15,400 --> 01:20:18,800
CPU resources, just blit pass, the message blit, plus the message.

2224
01:20:18,800 --> 01:20:21,300
We're just gonna, you know, we're like a little we're a Chihuahua on

2225
01:20:21,300 --> 01:20:21,700
speed.

2226
01:20:21,700 --> 01:20:22,100
Here.

2227
01:20:22,100 --> 01:20:24,100
We are just bleeding and bleeding, and bleeding, and bleeding, and

2228
01:20:24,100 --> 01:20:25,800
bleeding and bleeding, and that is fine.

2229
01:20:26,300 --> 01:20:29,200
But Windows also, sometimes will call us back.

2230
01:20:29,200 --> 01:20:29,800
And though, time is it.

2231
01:20:29,900 --> 01:20:32,500
Cause back is when it suspends the running of our process.

2232
01:20:33,000 --> 01:20:36,500
Basically, it blocks the running or a process to do a size.

2233
01:20:36,900 --> 01:20:40,000
So, basically, when we go into this, when we go into this, you'll

2234
01:20:40,000 --> 01:20:41,700
notice we are no longer running.

2235
01:20:41,700 --> 01:20:44,600
We are blocked in that message, queue, Windows, is not letting us

2236
01:20:45,200 --> 01:20:48,500
continue that as something that happens when you resize a window like

2237
01:20:48,500 --> 01:20:49,000
that.

2238
01:20:49,000 --> 01:20:53,200
And so while that is happening, Windows is actually telling us to

2239
01:20:53,200 --> 01:20:57,200
repaint and so we are actually Fielding that message in here.

2240
01:20:57,200 --> 01:20:59,800
And so if you if you look at what's

2241
01:21:00,100 --> 01:21:00,600
Down here.

2242
01:21:00,900 --> 01:21:04,400
We are just going ahead and we are asking it to do.

2243
01:21:04,400 --> 01:21:07,000
The same blit was doing outside, but we're doing it inside the paint.

2244
01:21:07,000 --> 01:21:09,700
Now, one thing that you might notice is this begin paint and paint?

2245
01:21:09,800 --> 01:21:12,800
That is basically something you need to do in the WM paint message to

2246
01:21:12,800 --> 01:21:14,400
tell windows that you have updated.

2247
01:21:14,400 --> 01:21:17,100
The dirty region that it is asking you to repaint.

2248
01:21:17,200 --> 01:21:21,500
Some people ask me about validate region or validate wrecked.

2249
01:21:21,700 --> 01:21:23,800
They were reading the documentation and they said, don't I have to

2250
01:21:23,800 --> 01:21:24,600
call validate Rex?

2251
01:21:24,600 --> 01:21:27,300
So, Windows knows, I finished painting in the answer is no, you don't

2252
01:21:27,400 --> 01:21:29,900
and paint automatically tells windows, that the

2253
01:21:30,000 --> 01:21:31,300
Ain't that you asked it to do that.

2254
01:21:31,300 --> 01:21:33,100
It asked you to do was done.

2255
01:21:33,200 --> 01:21:34,400
So that is really all you need.

2256
01:21:34,400 --> 01:21:35,400
Is that in pain?

2257
01:21:35,700 --> 01:21:38,400
You don't have to do anything else and paint, implicitly will validate

2258
01:21:38,400 --> 01:21:38,800
the region.

2259
01:21:38,800 --> 01:21:40,900
And if you're wondering what validating regions are, you can go read

2260
01:21:40,900 --> 01:21:44,400
the docs to, or give you the quick capsule summary, and that is

2261
01:21:44,400 --> 01:21:50,000
basically that Windows remembers where on your window has it needs to

2262
01:21:50,000 --> 01:21:50,500
repaint.

2263
01:21:50,500 --> 01:21:54,700
So basically, if you actually run the program here, if I run this and

2264
01:21:54,700 --> 01:21:57,400
I do something like move it off, so it gets obscured and then move it

2265
01:21:57,400 --> 01:21:59,900
back on, Windows, remembers that area that

2266
01:22:00,000 --> 01:22:03,100
Scared and calls you back with, WM paint, asking you to paint that

2267
01:22:03,100 --> 01:22:03,700
area.

2268
01:22:03,800 --> 01:22:07,700
And it wants you to tell it at some point that you actually repainted

2269
01:22:07,700 --> 01:22:10,400
it, so that it knows that can stop asking you to repaint it.

2270
01:22:10,400 --> 01:22:14,300
If you don't, it'll keep sending UWM paint messages until you do, and

2271
01:22:14,300 --> 01:22:16,000
that will flood your message queue with extraneous.

2272
01:22:16,000 --> 01:22:16,800
WM paint messages.

2273
01:22:16,800 --> 01:22:17,900
And you don't want that.

2274
01:22:17,900 --> 01:22:19,700
So, you always want to make sure you do something either.

2275
01:22:19,700 --> 01:22:22,100
Begin paint and paint or validate the wreck yourself, but I would

2276
01:22:22,100 --> 01:22:22,800
recommend doing this way.

2277
01:22:22,800 --> 01:22:23,800
This is the right way to do it.

2278
01:22:23,800 --> 01:22:28,200
I think, basically, to make sure that Windows knows what happened now,

2279
01:22:28,500 --> 01:22:28,900
anytime.

2280
01:22:28,900 --> 01:22:29,800
We got a message.

2281
01:22:29,900 --> 01:22:30,700
That we didn't handle.

2282
01:22:30,700 --> 01:22:32,400
That's a default case of our switch statement.

2283
01:22:32,400 --> 01:22:35,200
We just let Windows handle it for us by calling the default window

2284
01:22:35,200 --> 01:22:36,700
procedure, which is basically just a catch-all.

2285
01:22:36,800 --> 01:22:38,000
It's a thing to find by Windows.

2286
01:22:38,000 --> 01:22:41,600
It just does the right thing by default for any message that we don't

2287
01:22:41,600 --> 01:22:42,200
want to handle.

2288
01:22:42,700 --> 01:22:44,500
And ladies and gentlemen, I think we have come to the end of our

2289
01:22:44,500 --> 01:22:44,900
program.

2290
01:22:44,900 --> 01:22:45,900
It was a good program.

2291
01:22:46,800 --> 01:22:50,200
I've seen a lot of people email me, who said they had a lot of fun

2292
01:22:50,200 --> 01:22:51,500
playing around with this buffer.

2293
01:22:51,700 --> 01:22:54,100
Making weird patterns, doing all sorts of stuff like that.

2294
01:22:54,100 --> 01:22:57,200
And I am absolutely delighted about that because this is really the

2295
01:22:57,200 --> 01:22:58,400
joy of programming right here.

2296
01:22:58,500 --> 01:22:59,800
Once you can actually start poking, right?

2297
01:22:59,900 --> 01:23:01,600
In the B and seeing that happen in your.

2298
01:23:01,600 --> 01:23:04,900
Basically, it's you and the CPU and it's just, you're just having a

2299
01:23:04,900 --> 01:23:08,300
ball that is really some of the that's that's programming being fun.

2300
01:23:08,300 --> 01:23:08,700
Again.

2301
01:23:09,000 --> 01:23:11,800
You don't have to worry about 800,000 libraries that you're using.

2302
01:23:11,800 --> 01:23:14,800
And they're not working in only Linker, Arabs, and try to go to stack,

2303
01:23:14,800 --> 01:23:16,600
Overflow to find the compiler switch, that makes it.

2304
01:23:16,600 --> 01:23:17,800
So does none of that.

2305
01:23:18,100 --> 01:23:21,200
It's just a simple build file and everything is under your control.

2306
01:23:21,200 --> 01:23:22,300
And that is what I love.

2307
01:23:22,300 --> 01:23:22,400
It.

2308
01:23:22,400 --> 01:23:23,100
Makes programming fun.

2309
01:23:23,100 --> 01:23:23,500
Again.

2310
01:23:23,600 --> 01:23:27,000
It's like booting up an old Apple to and and hitting that control

2311
01:23:27,000 --> 01:23:27,900
breaker, whatever it was.

2312
01:23:27,900 --> 01:23:28,700
I got it's been so long.

2313
01:23:28,700 --> 01:23:29,800
I can't remember but you could go.

2314
01:23:29,900 --> 01:23:32,600
In there and just start typing in basic code and doing all kinds of

2315
01:23:32,600 --> 01:23:33,200
weird stuff.

2316
01:23:33,700 --> 01:23:34,800
It's that kind of fun again.

2317
01:23:35,300 --> 01:23:38,400
All right, ladies and gentlemen, we have come to the end of handmade

2318
01:23:38,400 --> 01:23:42,200
hero for the day, but I didn't want to take up all the Q&A time.

2319
01:23:42,400 --> 01:23:44,000
So I am still going to do a bunch of QA.

2320
01:23:44,000 --> 01:23:46,400
Maybe we will go a little bit longer because I had to take a little

2321
01:23:46,400 --> 01:23:49,100
extra time there just to essentially do Q&A, which is to go through

2322
01:23:49,100 --> 01:23:52,000
and really try to solidify a bunch of stuff that people might be

2323
01:23:52,000 --> 01:23:53,900
asking about, but you may still have some questions.

2324
01:23:54,500 --> 01:23:59,400
So let's go ahead and go to the stream, the twitch chat.

2325
01:24:07,400 --> 01:24:09,600
Would it be a good or bad idea to get one device context of the

2326
01:24:09,600 --> 01:24:13,200
beginning of the program and use that for every iteration of the main

2327
01:24:13,200 --> 01:24:13,800
Loop?

2328
01:24:14,100 --> 01:24:18,400
So interestingly enough that is not really allowed.

2329
01:24:19,100 --> 01:24:20,000
I do not believe

2330
01:24:20,800 --> 01:24:26,300
By Windows, usually unless you ask for it specifically and that is

2331
01:24:26,300 --> 01:24:32,300
actually ironically enough specifically what this flag that I said,

2332
01:24:32,300 --> 01:24:34,000
we'd probably don't need does.

2333
01:24:34,000 --> 01:24:40,600
And if we say CS own to see DC basically that, that means that every

2334
01:24:40,600 --> 01:24:44,300
window in this window class will get its own device context, that it

2335
01:24:44,300 --> 01:24:45,300
no longer needs to return.

2336
01:24:45,300 --> 01:24:48,800
And so you could argue that maybe that is a good idea.

2337
01:24:48,800 --> 01:24:50,700
I mean, you know, because why not and

2338
01:24:50,900 --> 01:24:53,500
What we would do is we would just specify that own DC.

2339
01:24:53,700 --> 01:24:57,100
And then I'm quite, I'm pretty sure that it's completely legal at that

2340
01:24:57,100 --> 01:24:59,900
point to just say, as soon as I get the window, I'm just going to snap

2341
01:24:59,900 --> 01:25:02,800
the DC and then I never have to give it back again.

2342
01:25:03,000 --> 01:25:03,600
Right?

2343
01:25:03,900 --> 01:25:06,900
And I'm pretty sure that that just works.

2344
01:25:07,300 --> 01:25:08,500
I could be wrong about that.

2345
01:25:08,500 --> 01:25:12,700
If someone at Microsoft right now is having an absolute conniption

2346
01:25:12,700 --> 01:25:15,300
because I am telling people to do things that are going to make their

2347
01:25:15,300 --> 01:25:15,800
life harder.

2348
01:25:15,800 --> 01:25:17,300
I do apologize for that.

2349
01:25:17,700 --> 01:25:20,500
But that is just, that is just my understanding.

2350
01:25:20,800 --> 01:25:22,500
Of how the DC system works.

2351
01:25:22,900 --> 01:25:25,800
Now, of course, there are other times when we use a device context,

2352
01:25:26,000 --> 01:25:28,000
but I think they're pretty much only in the paint.

2353
01:25:28,000 --> 01:25:30,600
And since Windows is already giving us back, the device, kind of sit

2354
01:25:30,600 --> 01:25:31,200
wants to use.

2355
01:25:31,200 --> 01:25:32,400
I don't think that's a problem.

2356
01:25:32,800 --> 01:25:34,600
So, I think this would be totally fine.

2357
01:25:35,000 --> 01:25:40,500
I'm going to go ahead and say note Casey, since we specified CS own

2358
01:25:40,500 --> 01:25:48,600
DC, we can just get one device context and use it forever, because we

2359
01:25:48,700 --> 01:25:50,700
are not sharing.

2360
01:25:51,000 --> 01:25:52,200
With anyone.

2361
01:25:52,600 --> 01:25:53,100
Yeah.

2362
01:25:58,500 --> 01:26:00,000
Let's see.

2363
01:26:02,100 --> 01:26:03,600
Do do, do do.

2364
01:26:06,700 --> 01:26:11,000
Can we please add a Chihuahua on speed as a sidekick or enemy monster?

2365
01:26:11,000 --> 01:26:13,700
Yes, we can choa.

2366
01:26:16,300 --> 01:26:20,800
On speed will definitely be written down in the notes.

2367
01:26:20,900 --> 01:26:21,800
That becomes.

2368
01:26:22,300 --> 01:26:24,100
Why do you tell Windows you handle messages?

2369
01:26:24,100 --> 01:26:27,300
You don't really handle and default is good.

2370
01:26:29,300 --> 01:26:30,800
And default is good.

2371
01:26:30,800 --> 01:26:32,200
I don't know what the an default is.

2372
01:26:32,200 --> 01:26:34,300
Good means.

2373
01:26:36,600 --> 01:26:37,200
Hmm.

2374
01:26:37,400 --> 01:26:40,200
Well, so I guess the first part of that which is why do we tell

2375
01:26:40,200 --> 01:26:40,500
windows?

2376
01:26:40,500 --> 01:26:43,400
We handle messages, which we don't really handle and the answer to

2377
01:26:43,400 --> 01:26:49,600
that is the concept of of handling, a message is a little bit fuzzy.

2378
01:26:50,300 --> 01:26:54,300
What it means to handle a message is really whether or not you want

2379
01:26:54,300 --> 01:26:57,800
Windows to do anything at all in response to that message.

2380
01:26:57,900 --> 01:26:59,800
And so, basically, you know, yeah, I can

2381
01:27:00,200 --> 01:27:03,300
Delete that WM size and nothing really is going to change in the

2382
01:27:03,300 --> 01:27:03,700
program.

2383
01:27:03,700 --> 01:27:03,900
Right?

2384
01:27:03,900 --> 01:27:06,500
It's going to be basically exactly the same and so that's fine.

2385
01:27:07,300 --> 01:27:10,200
The reason for that is that there really isn't anything by default

2386
01:27:10,200 --> 01:27:13,700
Windows needs to do in response to those messages now, destroy and

2387
01:27:13,700 --> 01:27:14,000
close.

2388
01:27:14,000 --> 01:27:16,500
There are things that might do in response to their default and I

2389
01:27:16,500 --> 01:27:17,600
don't want it to do them.

2390
01:27:17,800 --> 01:27:21,100
So I'm not letting it have a chance to do that activate app.

2391
01:27:21,100 --> 01:27:21,800
Same thing.

2392
01:27:21,800 --> 01:27:23,500
I actually have stuff that I want to do there.

2393
01:27:23,500 --> 01:27:29,400
Now, you can usually check inside the WM the documentation for

2394
01:27:29,400 --> 01:27:29,800
whatever thing.

2395
01:27:30,000 --> 01:27:33,200
That you want to see whether it recommends that you still call

2396
01:27:33,200 --> 01:27:35,300
Windows, even if you don't do it.

2397
01:27:35,500 --> 01:27:35,900
Anything.

2398
01:27:35,900 --> 01:27:38,800
If you don't do certain things, it'll say like you have to do these

2399
01:27:38,800 --> 01:27:40,200
things response to the message.

2400
01:27:40,400 --> 01:27:43,600
But usually there isn't a return value if an opt-in process image, it

2401
01:27:43,600 --> 01:27:45,900
should return 0, so, it doesn't, it doesn't.

2402
01:27:46,100 --> 01:27:50,600
If the if the windows message isn't documented as requiring certain

2403
01:27:50,600 --> 01:27:54,200
things to occur, and there's nothing that we want to occur, then it is

2404
01:27:54,200 --> 01:27:57,800
equivalent essentially, to having a case or calling death window.

2405
01:27:57,800 --> 01:27:59,900
Proctor's no difference, but there are

2406
01:28:00,100 --> 01:28:03,700
Window messages in response to which you do have to do things.

2407
01:28:03,800 --> 01:28:06,700
And so if we were going to feel those messages,

2408
01:28:07,800 --> 01:28:12,800
And we did something like this, where we didn't actually do the things

2409
01:28:12,800 --> 01:28:14,800
that were required, that would be bad.

2410
01:28:14,900 --> 01:28:18,200
So, really, the only thing you're trying to avoid by having this

2411
01:28:18,200 --> 01:28:22,500
default here, is that, for those windows messages that require

2412
01:28:22,500 --> 01:28:25,000
mandatory work on your part.

2413
01:28:25,800 --> 01:28:26,600
You have to call them.

2414
01:28:26,600 --> 01:28:27,000
Now.

2415
01:28:27,000 --> 01:28:29,800
I can give you an example of one of those right off the bat because we

2416
01:28:29,800 --> 01:28:31,700
already said it, WM pain.

2417
01:28:31,800 --> 01:28:35,900
If you don't do a begin paint and paint inside, WM paint, your dirty

2418
01:28:35,900 --> 01:28:37,500
region will never get validated.

2419
01:28:37,700 --> 01:28:40,100
That means windows will continue to think it's dirty and it will flood

2420
01:28:40,100 --> 01:28:41,400
you with WM paint messages.

2421
01:28:41,400 --> 01:28:44,900
So if we were going to do something like this, that would be bad.

2422
01:28:44,900 --> 01:28:46,100
You don't want to do that.

2423
01:28:46,200 --> 01:28:49,000
You would want to delete the case entirely and make sure that you're

2424
01:28:49,000 --> 01:28:52,200
calling deaf window proc because that will do a basically a null paint

2425
01:28:52,200 --> 01:28:55,300
right there for you and make sure that it up considers the region

2426
01:28:55,300 --> 01:28:57,500
validated and there will be no further problems.

2427
01:29:04,600 --> 01:29:06,300
Let's see.

2428
01:29:07,600 --> 01:29:10,200
I believe set stretch, blind mode will allow you to get better quality

2429
01:29:10,200 --> 01:29:10,600
stretching.

2430
01:29:10,600 --> 01:29:12,100
I believe you want half tone.

2431
01:29:12,200 --> 01:29:14,500
Yes, I think there are some settings we can set.

2432
01:29:14,500 --> 01:29:15,400
We will look at that little later.

2433
01:29:15,400 --> 01:29:16,500
What I really want is filtering.

2434
01:29:16,500 --> 01:29:20,000
We may not get that so we may read our own filtering code, but I will

2435
01:29:20,000 --> 01:29:23,400
add a note in here or to do I should say when we do that aspect ratio

2436
01:29:23,400 --> 01:29:28,800
correction, we can play with stretch modes.

2437
01:29:29,200 --> 01:29:29,600
Yeah.

2438
01:29:38,600 --> 01:29:40,500
Let's see.

2439
01:29:40,700 --> 01:29:41,500
Okay.

2440
01:29:41,900 --> 01:29:42,300
Hi Casey.

2441
01:29:42,300 --> 01:29:44,000
Can you please explain pointer aliasing again?

2442
01:29:44,000 --> 01:29:46,400
I didn't understand how passing by reference would cause a problem.

2443
01:29:46,600 --> 01:29:49,300
And someone else asked when you're talking about passing by value

2444
01:29:49,300 --> 01:29:50,200
versus passing by reference.

2445
01:29:50,200 --> 01:29:51,600
You mentioned there are modern observations.

2446
01:29:51,600 --> 01:29:51,800
Okay.

2447
01:29:51,800 --> 01:29:54,400
So let me, let me handle these two stream has ended.

2448
01:29:54,800 --> 01:29:55,500
Don't look at that.

2449
01:29:55,500 --> 01:29:57,600
Ladies and gentlemen, do do not look at the little thing that this

2450
01:29:57,600 --> 01:29:58,200
dream has ended.

2451
01:29:58,200 --> 01:29:59,800
We will go a little bit longer tonight because I

2452
01:30:00,000 --> 01:30:02,300
I was kind of in the mood to talk about stuff.

2453
01:30:02,300 --> 01:30:05,800
So we'll go a little bit longer here on Friday, will be all be up late

2454
01:30:05,800 --> 01:30:06,500
at night, partying.

2455
01:30:06,500 --> 01:30:07,500
Anyway, I am sure.

2456
01:30:07,500 --> 01:30:09,500
So, there is no harm done.

2457
01:30:09,800 --> 01:30:11,400
So what?

2458
01:30:11,400 --> 01:30:12,800
What, basically happens here?

2459
01:30:14,100 --> 01:30:15,400
I'll try to give an example.

2460
01:30:16,100 --> 01:30:19,300
And basically, I want you to take this example with a grain of salt

2461
01:30:19,300 --> 01:30:22,700
because like I said, I am not a compiler author and because I am not

2462
01:30:22,700 --> 01:30:23,500
compiler author.

2463
01:30:23,500 --> 01:30:27,600
My examples may be wrong in ways that are actually important.

2464
01:30:27,700 --> 01:30:31,300
So, what I would highly recommend, you do, is go watch some lectures

2465
01:30:31,300 --> 01:30:32,800
by Chandler Caruth.

2466
01:30:32,800 --> 01:30:36,700
I believe his name is spelled Chandler para like that.

2467
01:30:36,800 --> 01:30:39,900
He's one of the guys who does optimizations on llvm, which is a

2468
01:30:39,900 --> 01:30:43,600
really, really good compiler compared to all the other compilers out.

2469
01:30:43,800 --> 01:30:47,400
At the moment, I would go watch some lectures by him and watch him,

2470
01:30:47,400 --> 01:30:49,700
explain some stuff because it is true.

2471
01:30:50,300 --> 01:30:55,700
I found about out about him through Fabien, at rigorous him on

2472
01:30:55,700 --> 01:30:56,200
Twitter.

2473
01:30:56,500 --> 01:30:58,400
It's a friend of mine works at rad.

2474
01:30:58,700 --> 01:31:00,000
Really, really awesome coder.

2475
01:31:00,000 --> 01:31:03,100
I think I mentioned this feeling before and he had been posting some

2476
01:31:03,100 --> 01:31:06,700
links to some of these lectures cetera like maybe a year ago or more.

2477
01:31:07,100 --> 01:31:10,000
And basically, they're just really, really good down to earth.

2478
01:31:10,000 --> 01:31:12,400
Like here's what happens in the optimizer when I were trying to

2479
01:31:12,400 --> 01:31:13,600
optimize your code, so please

2480
01:31:13,700 --> 01:31:14,500
Stan these things.

2481
01:31:15,300 --> 01:31:15,700
All right.

2482
01:31:15,700 --> 01:31:17,000
So here's basically what happens.

2483
01:31:18,400 --> 01:31:19,100
Aliasing.

2484
01:31:20,000 --> 01:31:21,500
There are multiple kinds of aliasing.

2485
01:31:22,400 --> 01:31:24,500
There's basically aliasing that happens.

2486
01:31:24,500 --> 01:31:26,000
There's there's cash aliasing.

2487
01:31:26,000 --> 01:31:27,500
I think there's tlb aliasing.

2488
01:31:27,500 --> 01:31:29,100
There's all kinds of aliasing that happened.

2489
01:31:29,300 --> 01:31:32,500
Most of them have to do with the CPU and most of them have to do with

2490
01:31:32,500 --> 01:31:33,300
optimization.

2491
01:31:33,400 --> 01:31:36,100
So, when you're talking about aliasing, you're usually talking about a

2492
01:31:36,100 --> 01:31:42,400
CPU performance problem, that occurs, because you have had some

2493
01:31:42,400 --> 01:31:47,500
unfortunate coincidences with the, with the actual addresses, where

2494
01:31:47,500 --> 01:31:47,800
things are.

2495
01:31:48,000 --> 01:31:49,200
In memory, okay.

2496
01:31:49,300 --> 01:31:51,500
So when you see aliasing, that's usually what that means.

2497
01:31:51,600 --> 01:31:55,800
But in this case when we talk about aliasing, we're actually talking

2498
01:31:55,800 --> 01:31:56,900
about something totally different.

2499
01:31:56,900 --> 01:31:59,400
So I understand why can be confusing because the word aliasing gets

2500
01:31:59,400 --> 01:32:02,000
used a lot of context, and those are not the context that we mean.

2501
01:32:04,200 --> 01:32:07,700
What we're talking about is we're talking about very specifically,

2502
01:32:08,100 --> 01:32:09,200
pointer aliasing.

2503
01:32:10,500 --> 01:32:11,800
Which is a language problem.

2504
01:32:12,200 --> 01:32:15,200
It isn't as nothing to do with the CPU at all.

2505
01:32:15,300 --> 01:32:17,400
It is completely unrelated to the CPU in this case.

2506
01:32:17,400 --> 01:32:20,400
Although I mean you could talk about things that happen in the CPU

2507
01:32:20,400 --> 01:32:22,700
that might be relevant to thing.

2508
01:32:22,700 --> 01:32:24,800
You know, that might have similar things like this, but we're actually

2509
01:32:24,800 --> 01:32:28,400
talking about strictly during the compilation of your program pointer

2510
01:32:28,400 --> 01:32:29,000
aliasing.

2511
01:32:29,900 --> 01:32:33,700
So what that means is when you define a function

2512
01:32:34,800 --> 01:32:38,100
You need to think in terms of what the compiler actually sees.

2513
01:32:38,400 --> 01:32:43,500
So let's say the compiler sees a function called do the stuff, right?

2514
01:32:44,000 --> 01:32:49,700
And it is going to take a pointer that you call in star from, right.

2515
01:32:49,700 --> 01:32:52,100
And it's going to take another one that you call in Star 2.

2516
01:32:52,300 --> 01:32:55,700
And now because you're one of these C++ Fanatics, who likes to put

2517
01:32:55,700 --> 01:32:57,300
const everywhere in your code.

2518
01:32:57,300 --> 01:32:59,800
You even tried your best to tell the compiler.

2519
01:33:00,400 --> 01:33:01,900
That from is const.

2520
01:33:02,000 --> 01:33:02,900
It's constant.

2521
01:33:03,000 --> 01:33:06,100
I'm not having a talk about what cost means really, because I never

2522
01:33:06,100 --> 01:33:09,900
use it, but let's say you even were somebody who is, who is really,

2523
01:33:09,900 --> 01:33:11,100
really into const.

2524
01:33:11,100 --> 01:33:13,000
So you put constant everywhere in the code.

2525
01:33:14,200 --> 01:33:14,600
All right.

2526
01:33:14,600 --> 01:33:17,500
So you've got this, you're saying I'm going to read a from and then

2527
01:33:17,500 --> 01:33:19,700
your code does some stuff.

2528
01:33:19,800 --> 01:33:22,400
Now, the example I gave in fact, it's called do this stuff.

2529
01:33:22,400 --> 01:33:22,900
Right?

2530
01:33:22,900 --> 01:33:28,200
The example I gave was let's say that we did something like, you know,

2531
01:33:29,900 --> 01:33:35,800
star star to equal star from right like this.

2532
01:33:36,000 --> 01:33:36,900
That's what that does.

2533
01:33:37,400 --> 01:33:40,300
Let's say, I do that a few times, right?

2534
01:33:40,500 --> 01:33:43,600
So I, you know, add some values here.

2535
01:33:44,000 --> 01:33:46,200
These pointers, I'm moving them around.

2536
01:33:46,300 --> 01:33:48,800
However, I want to that sort of stuff.

2537
01:33:48,800 --> 01:33:49,200
Whatever.

2538
01:33:49,200 --> 01:33:51,700
Dot dot dot, you know, stuff happens, right?

2539
01:33:52,200 --> 01:33:53,200
So here's my function.

2540
01:33:54,400 --> 01:34:01,100
So basically what what's going to happen here is when the compiler is

2541
01:34:01,100 --> 01:34:04,700
actually generating code and this is not really the best example.

2542
01:34:04,700 --> 01:34:07,400
I really need, I really need one other thing here that's going to

2543
01:34:07,400 --> 01:34:07,900
happen.

2544
01:34:08,600 --> 01:34:11,300
You know what this this is better.

2545
01:34:11,800 --> 01:34:13,000
This is better than that.

2546
01:34:14,000 --> 01:34:14,500
There you go.

2547
01:34:18,200 --> 01:34:19,100
So what's going to happen here?

2548
01:34:19,100 --> 01:34:22,000
When the compiler sees this code is the car is going to go?

2549
01:34:22,000 --> 01:34:24,600
Okay, the first thing I need to do, right?

2550
01:34:25,700 --> 01:34:27,100
When I'm actually compiling this code.

2551
01:34:28,400 --> 01:34:30,200
I'm going to actually try to put her right out.

2552
01:34:30,200 --> 01:34:32,100
The compilers thought process here, right?

2553
01:34:32,600 --> 01:34:38,600
I have to load from the memory pointed to by from, right?

2554
01:34:38,700 --> 01:34:41,100
It's got to go get that right.

2555
01:34:41,200 --> 01:34:42,500
It's got to actually fetch it.

2556
01:34:42,600 --> 01:34:44,900
So it's got a generate instruction that says go load this memory.

2557
01:34:45,400 --> 01:34:47,800
Then it has to write that fetch.

2558
01:34:49,400 --> 01:34:54,300
Into the memory pointed to by 2, right?

2559
01:34:54,300 --> 01:34:55,600
That's what we told it to do.

2560
01:34:55,600 --> 01:34:58,400
We told to load out of this and right into this.

2561
01:34:58,400 --> 01:35:02,300
That's all we're trying to do right now.

2562
01:35:02,300 --> 01:35:05,500
You tell the compiler basically.

2563
01:35:08,600 --> 01:35:10,100
Wait, did I do this wrong?

2564
01:35:10,900 --> 01:35:11,800
Yes, I did this wrong.

2565
01:35:11,900 --> 01:35:12,400
Sorry.

2566
01:35:15,600 --> 01:35:16,100
There we go.

2567
01:35:16,700 --> 01:35:18,000
Like I said, not a compiler Optimizer.

2568
01:35:18,000 --> 01:35:19,400
So I don't think about these things very often.

2569
01:35:19,700 --> 01:35:20,000
Now.

2570
01:35:20,000 --> 01:35:23,800
We're going to say, let's go ahead and load.

2571
01:35:23,800 --> 01:35:25,800
Well even even that's not right.

2572
01:35:27,700 --> 01:35:28,900
This is such a simple example.

2573
01:35:28,900 --> 01:35:31,400
You think I'd be able to do it by now, but some reason, when I'm

2574
01:35:31,400 --> 01:35:34,500
trying to explain things, it's hard for me to think in my head,

2575
01:35:34,500 --> 01:35:36,100
exactly how the things are going.

2576
01:35:38,000 --> 01:35:38,400
Yes.

2577
01:35:38,400 --> 01:35:41,400
It's so, it's always, it's always a bit of a nightmare.

2578
01:35:41,400 --> 01:35:42,100
Ladies and gentlemen.

2579
01:35:42,200 --> 01:35:42,700
Oh, no.

2580
01:35:42,700 --> 01:35:43,300
No, I'm right.

2581
01:35:43,300 --> 01:35:43,600
I'm right.

2582
01:35:43,600 --> 01:35:43,800
Okay.

2583
01:35:43,800 --> 01:35:44,000
Okay.

2584
01:35:44,000 --> 01:35:44,600
Okay, good.

2585
01:35:44,600 --> 01:35:44,900
Yeah.

2586
01:35:45,100 --> 01:35:46,100
Bit of a brain fart.

2587
01:35:46,100 --> 01:35:46,900
It's getting late.

2588
01:35:47,100 --> 01:35:47,700
What can I say?

2589
01:35:47,700 --> 01:35:50,200
Okay, so now we're going to go ahead and say advance.

2590
01:35:52,000 --> 01:35:56,900
The pointer to buy how much and you should all know this.

2591
01:35:56,900 --> 01:35:59,900
My now it's not to write it.

2592
01:36:00,000 --> 01:36:04,000
Actually, two times the size of an integer, right?

2593
01:36:04,000 --> 01:36:07,100
So it's actually going to advance it by eight, right?

2594
01:36:07,500 --> 01:36:09,300
And then it's going to say, okay.

2595
01:36:09,600 --> 01:36:13,500
I have to load from the memory pointed to buy from.

2596
01:36:14,200 --> 01:36:20,600
And then I have to write that fetch into the memory pointed to by and

2597
01:36:21,000 --> 01:36:23,700
at this point will start to introduce maybe a little compiler.

2598
01:36:24,700 --> 01:36:25,300
Stuff here.

2599
01:36:26,500 --> 01:36:28,100
This is really not to anymore.

2600
01:36:28,100 --> 01:36:28,800
In some sense.

2601
01:36:28,800 --> 01:36:31,000
The compiler thinks of these things that separate values because we

2602
01:36:31,000 --> 01:36:32,200
moved it, right?

2603
01:36:32,200 --> 01:36:34,700
So it really thinks of it more like a new thing.

2604
01:36:35,000 --> 01:36:43,300
It basically says to, to write a second to becomes the pointer to +8,

2605
01:36:44,000 --> 01:36:44,500
right?

2606
01:36:44,500 --> 01:36:47,600
And so then it's going to write the fetch in the memory pointed to by

2607
01:36:47,600 --> 01:36:49,200
22, right?

2608
01:36:49,400 --> 01:36:52,100
So we've got to, this is an extremely simple function.

2609
01:36:53,200 --> 01:36:57,600
And what is happening is we write into two different memory locations.

2610
01:36:57,600 --> 01:36:58,600
That is what the compiler sees.

2611
01:36:58,600 --> 01:36:59,000
It thinks.

2612
01:36:59,000 --> 01:37:02,700
There are two total rights 1 to 2 and 1/2 to 2.

2613
01:37:03,000 --> 01:37:03,900
And that's a bad thing.

2614
01:37:04,500 --> 01:37:06,100
One two, let's call other.

2615
01:37:07,400 --> 01:37:10,300
Or first and second and be.

2616
01:37:10,600 --> 01:37:11,200
There we go.

2617
01:37:12,200 --> 01:37:13,400
That's that's that's good.

2618
01:37:16,200 --> 01:37:17,800
Just to avoid it, getting completely out of control.

2619
01:37:17,900 --> 01:37:20,800
Okay, so it's going to load the memory planner to buy from.

2620
01:37:21,200 --> 01:37:25,000
It's going to write what it loaded into a.

2621
01:37:25,500 --> 01:37:28,500
It's going to make a new pointer called be conceptually.

2622
01:37:28,500 --> 01:37:29,600
It's not really doing these things.

2623
01:37:29,600 --> 01:37:32,200
It's just this is what thinks it has to do and it's a new pointer

2624
01:37:32,200 --> 01:37:34,200
called be that is a plus 8.

2625
01:37:34,200 --> 01:37:34,700
Bytes.

2626
01:37:35,900 --> 01:37:39,400
It's going to load the memory point of to buy from again and it's

2627
01:37:39,400 --> 01:37:43,600
going to write whatever it loaded into what's for you to buy be right.

2628
01:37:44,000 --> 01:37:45,600
Does that all make good sense to people?

2629
01:37:46,000 --> 01:37:47,100
Hopefully, that is true.

2630
01:37:47,100 --> 01:37:49,900
Hopefully people are following me so far, pretty simple.

2631
01:37:50,300 --> 01:37:54,500
Now, what you want the optimizer to do here, right?

2632
01:37:54,700 --> 01:37:57,300
That is sort of like if we just think of these as instructions, you

2633
01:37:57,300 --> 01:37:59,100
know, that is five instructions, right?

2634
01:37:59,100 --> 01:38:01,700
I mean, you know, who knows exactly what they translate into depending

2635
01:38:01,700 --> 01:38:04,400
on the circumstances, but, you know, there's five logical things that

2636
01:38:04,400 --> 01:38:05,500
have to happen here at us.

2637
01:38:05,700 --> 01:38:08,200
Load a right that's to do an increment.

2638
01:38:08,300 --> 01:38:09,600
Another load and then a right.

2639
01:38:10,600 --> 01:38:13,400
Now, what you want an Optimizer to do, and the whole point of an

2640
01:38:13,400 --> 01:38:15,800
Optimizer is to look for things.

2641
01:38:16,300 --> 01:38:16,500
Oops.

2642
01:38:16,500 --> 01:38:18,100
That did a very odd thing.

2643
01:38:18,100 --> 01:38:22,700
Look for things like These Guys, these two guys right here, right?

2644
01:38:22,900 --> 01:38:25,100
Do you see how both of these are the same thing?

2645
01:38:25,200 --> 01:38:26,500
They are both loading.

2646
01:38:26,500 --> 01:38:30,100
The memory pointed to by from and since from hasn't changed.

2647
01:38:30,200 --> 01:38:33,700
What's the contents of that memory has not changed, right?

2648
01:38:35,900 --> 01:38:41,400
And so basically, what happens in circumstances like this is you want

2649
01:38:41,400 --> 01:38:42,300
the optimizer to go.

2650
01:38:42,300 --> 01:38:45,700
Well, the second load I can just eliminate because I know what the

2651
01:38:45,700 --> 01:38:48,500
value of from actually was right?

2652
01:38:48,500 --> 01:38:53,400
I know what it was so I can just rewrite I can replace this by saying

2653
01:38:53,600 --> 01:38:54,300
right?

2654
01:38:55,300 --> 01:38:59,800
The previous fetch the one from up here into the memory.

2655
01:39:00,000 --> 01:39:01,600
To buy B.

2656
01:39:01,800 --> 01:39:05,100
And now I have saved one instruction, essentially one conceptual

2657
01:39:05,100 --> 01:39:05,500
instruction.

2658
01:39:05,500 --> 01:39:08,600
At least possibly even more instructions in the actual CPU, depending

2659
01:39:08,600 --> 01:39:10,200
on how many it would need to do that thing.

2660
01:39:11,400 --> 01:39:13,800
It has now saved those instructions.

2661
01:39:15,300 --> 01:39:16,400
That is an optimization.

2662
01:39:16,400 --> 01:39:18,100
That is what the optimizer does.

2663
01:39:18,100 --> 01:39:21,700
It takes the literal thing that has to happen in your code and turns

2664
01:39:21,700 --> 01:39:24,300
it into something more compact that does the same thing.

2665
01:39:25,200 --> 01:39:28,700
Now, the compiler can't do that to this function.

2666
01:39:28,800 --> 01:39:32,300
And again, when I say that, what I really mean is, this is a simple

2667
01:39:32,300 --> 01:39:35,700
example designed to show the kinds of ways that that can happen.

2668
01:39:36,000 --> 01:39:38,300
And maybe the compiler actually can do it to this function.

2669
01:39:38,300 --> 01:39:41,000
And like I said, you want to go talk to a real Kappa expert to

2670
01:39:41,100 --> 01:39:43,800
Are you the real intricate ways that this all plays out?

2671
01:39:43,800 --> 01:39:47,800
But this is basically the idea the reason it can't do that is because

2672
01:39:47,800 --> 01:39:52,000
it doesn't know if from into might point to the same place.

2673
01:39:52,200 --> 01:39:56,700
So let's suppose that the shenanigans outside of this that we're

2674
01:39:56,700 --> 01:39:57,800
calling the function.

2675
01:39:58,900 --> 01:39:59,400
Right.

2676
01:39:59,400 --> 01:40:02,700
Had an integer star blah, right?

2677
01:40:03,200 --> 01:40:04,200
Let's say it did that.

2678
01:40:04,700 --> 01:40:10,700
Let's say it goes ahead and passes the same pointer to do this stuff

2679
01:40:10,700 --> 01:40:12,800
for both of these, right?

2680
01:40:13,000 --> 01:40:17,100
Well now what's going to happen is when it when it over rights to it's

2681
01:40:17,100 --> 01:40:19,700
actually over writing from right?

2682
01:40:19,700 --> 01:40:20,400
Does that make sense?

2683
01:40:20,700 --> 01:40:26,000
Now in this particular case, you're still okay, I believe because

2684
01:40:26,000 --> 01:40:28,500
since you read read and wrote from

2685
01:40:28,700 --> 01:40:30,200
The exact same location.

2686
01:40:30,600 --> 01:40:31,800
You're probably fine.

2687
01:40:31,900 --> 01:40:35,300
But you have to imagine the compiler doesn't actually know like let's

2688
01:40:35,300 --> 01:40:37,000
say this continues on, right?

2689
01:40:37,000 --> 01:40:43,300
It continues on and goes for four more cycle, to keeps going and

2690
01:40:43,300 --> 01:40:44,500
incrementing further.

2691
01:40:45,200 --> 01:40:48,800
So, basically, you do something like that, right?

2692
01:40:49,400 --> 01:40:50,800
So that it, in this case.

2693
01:40:50,800 --> 01:40:52,900
Like I said, it wouldn't matter if it was, literally just doing it

2694
01:40:52,900 --> 01:40:55,800
one, because this would be the same value, as it was going to

2695
01:40:55,800 --> 01:40:58,100
overwrite, it would overwrite itself, the same value, but let's say it

2696
01:40:58,100 --> 01:40:58,500
was just

2697
01:40:58,600 --> 01:41:00,500
One ahead of itself, right?

2698
01:41:00,500 --> 01:41:02,300
So it was reading or to write.

2699
01:41:02,300 --> 01:41:05,100
So it was reading and writing right ahead of itself.

2700
01:41:05,200 --> 01:41:07,600
So it's going to overwrite the value.

2701
01:41:07,600 --> 01:41:10,400
It was about to read and just to make that a little bit more explicit.

2702
01:41:10,400 --> 01:41:12,300
I realized I kind of pulled a fast one on you there.

2703
01:41:12,700 --> 01:41:16,800
I will actually do it 100% accurate here for you that the full on real

2704
01:41:16,800 --> 01:41:17,300
case.

2705
01:41:17,900 --> 01:41:18,200
Again.

2706
01:41:18,200 --> 01:41:20,200
There's probably a simpler case, but I'm just, I'm having trouble

2707
01:41:20,200 --> 01:41:22,700
thinking it through because I don't think about these things very

2708
01:41:22,700 --> 01:41:24,400
often from the compilers perspective.

2709
01:41:24,500 --> 01:41:27,100
So some and when I'm talking out loud, it's kind of hard for me to

2710
01:41:27,400 --> 01:41:28,500
actually do them all 100.

2711
01:41:28,700 --> 01:41:29,000
Correctly.

2712
01:41:29,000 --> 01:41:29,400
Okay.

2713
01:41:30,100 --> 01:41:33,600
So basically I'm going to do this, right.

2714
01:41:37,100 --> 01:41:41,600
Like that, I am then going to go ahead and increment.

2715
01:41:41,600 --> 01:41:47,700
Let's say to like this and then I'm going to increment from like this

2716
01:41:48,000 --> 01:41:50,900
and then I'm going to go ahead and do the same copy again.

2717
01:41:51,300 --> 01:41:52,100
I think this would do it.

2718
01:41:52,100 --> 01:41:52,600
Right.

2719
01:41:52,600 --> 01:41:53,900
Let's double-check that that's true.

2720
01:41:54,200 --> 01:41:58,200
So now let's say I come in here and this is the memory that I actually

2721
01:41:58,200 --> 01:41:58,500
have.

2722
01:41:58,500 --> 01:41:59,400
This is blah.

2723
01:42:00,000 --> 01:42:03,500
Block is pointing to something like 10, 20, right?

2724
01:42:03,500 --> 01:42:06,400
And I don't even need, why did I even bother with the to get rid of

2725
01:42:06,400 --> 01:42:06,500
that?

2726
01:42:06,500 --> 01:42:07,500
We can make it even simpler.

2727
01:42:11,400 --> 01:42:12,100
All right, there we are.

2728
01:42:12,900 --> 01:42:14,900
So basically what I'm doing now, if you can see

2729
01:42:16,700 --> 01:42:18,400
is I am creating something.

2730
01:42:18,700 --> 01:42:22,400
That's basically, let's say I have a pointer to a pointer blog here

2731
01:42:22,400 --> 01:42:23,700
and block is pointing.

2732
01:42:23,800 --> 01:42:25,900
You know, it's pointing for whatever reason at this point in the

2733
01:42:25,900 --> 01:42:27,900
program to two integers, right?

2734
01:42:28,000 --> 01:42:28,800
The first integer is 10.

2735
01:42:28,800 --> 01:42:29,900
The second integer is 20.

2736
01:42:30,200 --> 01:42:32,100
Let's just say that's what happens, right?

2737
01:42:33,100 --> 01:42:35,000
So, let's see what happens when we actually run this and hopefully I

2738
01:42:35,000 --> 01:42:35,800
did it correctly.

2739
01:42:36,300 --> 01:42:40,700
When I do the first star to star from will, what is Star from start

2740
01:42:40,700 --> 01:42:46,300
from is 0 and and we want this way, right?

2741
01:42:47,300 --> 01:42:48,300
Is that correct?

2742
01:42:48,800 --> 01:42:50,000
So complicated.

2743
01:42:50,100 --> 01:42:50,700
Why am I?

2744
01:42:50,700 --> 01:42:54,400
This is this is, this is this is basically the problem with the with

2745
01:42:54,400 --> 01:42:55,700
streaming live is man.

2746
01:42:55,700 --> 01:42:57,400
You don't get a chance to think about these beforehand, you're trying

2747
01:42:57,400 --> 01:42:58,600
to talk it through at the same time.

2748
01:42:59,400 --> 01:43:01,600
So I'm going to read from a value in that.

2749
01:43:01,600 --> 01:43:02,600
I want to overwrite that.

2750
01:43:02,800 --> 01:43:04,200
Will you write?

2751
01:43:04,200 --> 01:43:04,600
This is.

2752
01:43:04,600 --> 01:43:06,300
This is actually the way to do it.

2753
01:43:06,300 --> 01:43:06,700
Okay.

2754
01:43:06,900 --> 01:43:07,300
Okay.

2755
01:43:08,100 --> 01:43:09,900
Yeah, we're written.

2756
01:43:09,900 --> 01:43:12,800
Yeah, so it's like, you know what?

2757
01:43:14,100 --> 01:43:15,400
This has been a disaster, ladies and gentleman.

2758
01:43:15,400 --> 01:43:17,400
This is the worst example that I've ever given.

2759
01:43:19,000 --> 01:43:19,500
Basically.

2760
01:43:19,500 --> 01:43:22,200
This should be a really, really thing, really, really easy.

2761
01:43:22,200 --> 01:43:25,100
Thing to demonstrate how the pointers Alias.

2762
01:43:25,200 --> 01:43:29,100
And for some reason it is like impossible for me to construct a simple

2763
01:43:29,100 --> 01:43:32,100
case because every time I try to simplify it, I realized that I write

2764
01:43:32,100 --> 01:43:35,900
something that technically should still execute properly because the

2765
01:43:35,900 --> 01:43:39,100
copied value is actually going to be the same.

2766
01:43:39,400 --> 01:43:43,100
So again, my Penance for this is I really pretty much just have to

2767
01:43:43,100 --> 01:43:43,700
stay here.

2768
01:43:44,300 --> 01:43:46,500
And actually give you a valid case.

2769
01:43:46,500 --> 01:43:50,500
So bear with me for a second while I unclog my brain and actually try

2770
01:43:50,700 --> 01:43:52,600
to write something that's going to be valid.

2771
01:43:52,700 --> 01:43:56,300
So I'm going to try writing something called move.

2772
01:43:57,400 --> 01:44:01,900
Let's say and move is going to take two pointers.

2773
01:44:01,900 --> 01:44:05,200
It's going to take an into a and it be well, I guess I'll just stick

2774
01:44:05,200 --> 01:44:07,500
with my from in my to even though it was going so poorly.

2775
01:44:08,000 --> 01:44:08,600
We'll do it that way.

2776
01:44:08,600 --> 01:44:11,700
And we'll say one of them was was const and so what this is going to

2777
01:44:11,700 --> 01:44:16,700
do is it's just going to literally do the copy, right?

2778
01:44:16,800 --> 01:44:20,400
So it's going to do yeah, it's going to do this.

2779
01:44:20,400 --> 01:44:23,600
It's going to do basically this it's just a copy function.

2780
01:44:24,000 --> 01:44:27,000
So let's say it does this and let's say it copies for

2781
01:44:27,200 --> 01:44:27,800
Integers.

2782
01:44:28,000 --> 01:44:30,600
So it copies, it reads an integer rights.

2783
01:44:30,600 --> 01:44:31,900
It reads, an integer rights.

2784
01:44:31,900 --> 01:44:34,300
It reads, an integer rights.

2785
01:44:34,300 --> 01:44:40,100
It does something like this and maybe when it does that, it writes the

2786
01:44:40,100 --> 01:44:40,500
same.

2787
01:44:40,500 --> 01:44:44,300
So it's kind of like a thing that yeah, something like this.

2788
01:44:44,500 --> 01:44:47,300
It's kind of a thing that actually duplicates the value out.

2789
01:44:47,400 --> 01:44:49,300
In fact, I'll do this a little make this a little clearer.

2790
01:44:49,500 --> 01:44:50,000
We'll do it that way.

2791
01:44:50,000 --> 01:44:51,700
Let's see if this can actually work.

2792
01:44:52,100 --> 01:44:55,200
So basically I am kind of over writing the values there.

2793
01:44:55,200 --> 01:44:57,000
That is what I expect to happen.

2794
01:44:57,100 --> 01:44:57,700
Have happen.

2795
01:44:58,100 --> 01:44:59,800
So I will overwrite that and I'll

2796
01:45:00,000 --> 01:45:02,200
Mint from Once, I think this will be enough to do it.

2797
01:45:02,300 --> 01:45:04,800
But maybe I just did the exact same stupid mistake.

2798
01:45:04,800 --> 01:45:05,200
Again.

2799
01:45:05,600 --> 01:45:06,300
We'll find out.

2800
01:45:06,300 --> 01:45:10,400
So now I have my pointer and it's got one, two, three, four in it.

2801
01:45:10,500 --> 01:45:13,000
Let's say some pointer in memory.

2802
01:45:13,000 --> 01:45:14,200
That's pointing to these things.

2803
01:45:14,500 --> 01:45:18,400
So, in blah points to those integers and memory, right?

2804
01:45:18,500 --> 01:45:22,100
And then I call move and I'm going to call move with blah.

2805
01:45:22,100 --> 01:45:25,000
So I pass blah and blah.

2806
01:45:25,500 --> 01:45:29,600
And what I want to do here is I want it to eventually over right from

2807
01:45:29,600 --> 01:45:29,800
Sophie.

2808
01:45:30,000 --> 01:45:32,200
From is going to be.

2809
01:45:33,400 --> 01:45:33,900
Let's see.

2810
01:45:33,900 --> 01:45:37,000
It's going to write to it's going to write two one.

2811
01:45:37,200 --> 01:45:40,500
That's right to to then it's going to write, two three.

2812
01:45:41,200 --> 01:45:42,000
Yes.

2813
01:45:42,000 --> 01:45:46,300
Oh, so I'm going to say that it is going to point to blah plus 1 and

2814
01:45:46,300 --> 01:45:47,400
let's see what this does.

2815
01:45:47,600 --> 01:45:49,800
If I have finally actually done it.

2816
01:45:51,100 --> 01:45:54,300
You know what, I just realized to this is definitely an owl of Shame

2817
01:45:54,300 --> 01:45:54,900
moment.

2818
01:45:55,000 --> 01:45:58,100
That should have been a really easy thing for me to write and the fact

2819
01:45:58,100 --> 01:45:59,900
that it isn't just shows that the

2820
01:46:00,000 --> 01:46:05,200
Of Shame needs to make an appearance to let everyone know that this is

2821
01:46:05,200 --> 01:46:06,800
not something that should have taken this long.

2822
01:46:06,800 --> 01:46:08,400
This should have been like a five-minute thing.

2823
01:46:09,400 --> 01:46:11,500
And that is just basically, yeah.

2824
01:46:11,500 --> 01:46:16,200
The shame Owl makes its first appearance and I strongly suspect, there

2825
01:46:16,200 --> 01:46:19,800
will be a lot more shame else coming out in the future.

2826
01:46:19,800 --> 01:46:21,300
As we get more and more complicated code.

2827
01:46:21,300 --> 01:46:23,700
It will only be harder for me to think it through live like this.

2828
01:46:24,400 --> 01:46:24,900
Yeah.

2829
01:46:24,900 --> 01:46:27,900
I hope you will stick with relays and gentlemen, I do apologize for

2830
01:46:27,900 --> 01:46:28,800
the delay anyway.

2831
01:46:29,900 --> 01:46:30,700
Off we go.

2832
01:46:31,300 --> 01:46:35,300
What will actually do here is to is currently pointing to blah the

2833
01:46:35,300 --> 01:46:36,300
first element of blah.

2834
01:46:36,300 --> 01:46:40,500
So if we look in here after this instruction, right, this instruction

2835
01:46:40,500 --> 01:46:42,700
is going to read from from from as pointing to the to.

2836
01:46:42,700 --> 01:46:46,900
So this reads A to and writes out a 2.

2837
01:46:46,900 --> 01:46:50,800
So that's going to be two to three four, right?

2838
01:46:51,800 --> 01:46:53,100
Let's see what this does.

2839
01:46:53,700 --> 01:46:57,200
This is going to read.

2840
01:46:58,300 --> 01:46:59,600
Let's see.

2841
01:46:59,900 --> 01:47:03,100
See from from again.

2842
01:47:06,100 --> 01:47:09,200
Oh, you know what?

2843
01:47:09,900 --> 01:47:10,900
Let's do that.

2844
01:47:11,700 --> 01:47:12,900
I'm gonna pass both the same ones.

2845
01:47:13,100 --> 01:47:13,300
Okay.

2846
01:47:13,300 --> 01:47:17,000
So this reads, a one and writes a one.

2847
01:47:17,000 --> 01:47:17,500
No, this isn't.

2848
01:47:17,500 --> 01:47:18,400
It still doesn't work.

2849
01:47:25,100 --> 01:47:27,300
I'm trying to think of the appropriate punishment for not being able

2850
01:47:27,300 --> 01:47:27,500
to write.

2851
01:47:27,500 --> 01:47:28,300
Simple point to ice.

2852
01:47:28,300 --> 01:47:31,300
Keep putting wanted to do it with a copy, but I can't seem to do it

2853
01:47:31,300 --> 01:47:31,900
with the copy.

2854
01:47:32,100 --> 01:47:32,800
So, you know what?

2855
01:47:32,900 --> 01:47:35,100
Maybe we just need to not do that case.

2856
01:47:35,100 --> 01:47:37,100
So that I guess maybe whatever my blade.

2857
01:47:37,300 --> 01:47:37,600
Why don't?

2858
01:47:37,600 --> 01:47:39,100
Why does my brain even think that that would happen?

2859
01:47:39,100 --> 01:47:40,700
Because it should always actually work.

2860
01:47:40,800 --> 01:47:41,200
I don't know.

2861
01:47:41,200 --> 01:47:42,300
I'm just being stupid today.

2862
01:47:42,800 --> 01:47:44,000
We'll try it one more way.

2863
01:47:44,100 --> 01:47:46,800
And if we can't figure it out, then we will just call it for the night

2864
01:47:46,900 --> 01:47:50,700
and we will say that someday, somebody who is thinking a little more

2865
01:47:50,700 --> 01:47:51,000
clearly.

2866
01:47:51,000 --> 01:47:52,300
Well or R actually will just be me.

2867
01:47:52,300 --> 01:47:54,600
I'll sit down for 10 seconds after the stream is over.

2868
01:47:54,600 --> 01:47:54,700
I'll be

2869
01:47:54,900 --> 01:47:55,800
Oh, right, duh.

2870
01:47:56,400 --> 01:47:57,300
That is how that works.

2871
01:47:57,600 --> 01:47:59,700
Anyway, let's say that we go ahead and do something with

2872
01:48:00,000 --> 01:48:01,900
Pointer is maybe something like that.

2873
01:48:01,900 --> 01:48:10,000
And we say something like Star a equals star, B Star C equals star, be

2874
01:48:10,000 --> 01:48:10,900
that kind of thing.

2875
01:48:10,900 --> 01:48:13,900
So, we're going to write two things in there.

2876
01:48:13,900 --> 01:48:20,600
And then maybe some interceding thing will just get some more pointer

2877
01:48:20,600 --> 01:48:23,900
reads in here so that we can we can check it out.

2878
01:48:23,900 --> 01:48:29,900
So, star D equals 5, the funny thing is

2879
01:48:30,000 --> 01:48:32,600
As I think my example that I gave earlier in the Stream by just typed

2880
01:48:32,600 --> 01:48:34,100
out in the middle of like the hyperness.

2881
01:48:34,800 --> 01:48:35,900
I think just worked.

2882
01:48:36,000 --> 01:48:38,000
So it's kind of hilarious that of having this much trouble with

2883
01:48:38,000 --> 01:48:42,000
something that really should not have been a problem.

2884
01:48:42,000 --> 01:48:44,100
But anyway, so this.

2885
01:48:45,000 --> 01:48:45,300
Yeah.

2886
01:48:45,300 --> 01:48:46,600
And looking at this, this just works.

2887
01:48:46,800 --> 01:48:49,400
Why did I over complicate things so much?

2888
01:48:50,900 --> 01:48:55,800
I don't know, ladies and gentlemen, you are free to basically Point

2889
01:48:55,800 --> 01:48:58,700
your own Al of Shame at me if you have one at home because this is

2890
01:48:58,700 --> 01:49:00,200
simple and I believe this one just works.

2891
01:49:00,200 --> 01:49:03,300
So it's kind of ridiculous that it took me that long to explain it.

2892
01:49:03,300 --> 01:49:04,000
Here we go.

2893
01:49:04,200 --> 01:49:05,500
We've got four pointers here.

2894
01:49:06,200 --> 01:49:07,600
We are reading out of be twice.

2895
01:49:08,000 --> 01:49:10,600
So this is load be right?

2896
01:49:10,600 --> 01:49:15,500
A this is load five, right d which you can probably do with the

2897
01:49:15,500 --> 01:49:15,900
immediate.

2898
01:49:15,900 --> 01:49:20,600
So it's probably just write D and this is going to be load, be rights.

2899
01:49:21,100 --> 01:49:21,600
Right.

2900
01:49:21,900 --> 01:49:26,100
Right to load from like that, right?

2901
01:49:26,600 --> 01:49:27,700
So that's all good.

2902
01:49:27,700 --> 01:49:28,800
That's all well and good.

2903
01:49:29,500 --> 01:49:32,200
And the only thing, this is the only thing you need to understand,

2904
01:49:32,200 --> 01:49:32,800
poetry aliasing.

2905
01:49:32,800 --> 01:49:36,800
And yet I spent probably 15 minutes of your valuable time trying to

2906
01:49:36,800 --> 01:49:37,700
make a stupid copy.

2907
01:49:37,700 --> 01:49:39,800
Do it for no apparent reason, other than for some reason I really

2908
01:49:39,800 --> 01:49:40,900
wanted to write it as copy.

2909
01:49:41,300 --> 01:49:41,600
So.

2910
01:49:41,600 --> 01:49:42,000
Yep.

2911
01:49:42,100 --> 01:49:43,200
Well, you know, there you go.

2912
01:49:43,200 --> 01:49:45,900
It takes five seconds to write the right thing and 15 minutes to write

2913
01:49:45,900 --> 01:49:46,400
the wrong thing.

2914
01:49:46,400 --> 01:49:48,600
I don't know how to explain that, but here you go.

2915
01:49:49,300 --> 01:49:50,500
If now we have

2916
01:49:50,800 --> 01:49:54,100
In memory, we're going to call this move function, right?

2917
01:49:54,600 --> 01:49:57,000
And we have some things that we can point to.

2918
01:49:57,000 --> 01:50:04,700
So, we have a int X into y, + NZ, and an NT W, and I will just set

2919
01:50:04,700 --> 01:50:07,900
these two one, two, three, and four.

2920
01:50:08,200 --> 01:50:10,900
Okay, hopefully, that is pretty understandable.

2921
01:50:10,900 --> 01:50:12,700
Nothing particularly odd going on there.

2922
01:50:13,400 --> 01:50:18,800
And so, I am going to go ahead and pass this function, x y z w, right.

2923
01:50:19,900 --> 01:50:22,600
And it will should work 100% properly.

2924
01:50:22,600 --> 01:50:24,500
There's nothing odd about that.

2925
01:50:24,600 --> 01:50:26,800
It will go ahead and do the right thing, right?

2926
01:50:26,800 --> 01:50:30,000
It will, if you look at what will happen to this program, it'll load

2927
01:50:30,200 --> 01:50:31,800
from B, which is set to Y.

2928
01:50:31,800 --> 01:50:33,400
So, it'll load a to out of there.

2929
01:50:33,400 --> 01:50:33,900
Right?

2930
01:50:34,000 --> 01:50:37,400
And it will write the two back to what is basically X.

2931
01:50:37,400 --> 01:50:38,500
So X will become 2.

2932
01:50:39,000 --> 01:50:41,800
It will write to me, straight up.

2933
01:50:41,800 --> 01:50:46,700
It will write 52w, which is fine and then it will write to see, it

2934
01:50:46,700 --> 01:50:47,500
will write C.

2935
01:50:48,200 --> 01:50:49,300
It will write whatever.

2936
01:50:49,400 --> 01:50:51,000
Was in B, which is 2.

2937
01:50:51,000 --> 01:50:54,400
So you'll end up doing all that and it will work totally properly.

2938
01:50:54,600 --> 01:50:59,300
Now, in that circumstance, you could also see that if I wanted to I

2939
01:50:59,300 --> 01:50:59,800
could just load.

2940
01:51:00,000 --> 01:51:03,200
Be once because the value that you load from B is always going to be

2941
01:51:03,200 --> 01:51:04,000
to correct.

2942
01:51:04,000 --> 01:51:05,400
It's always going to be up to.

2943
01:51:05,600 --> 01:51:08,300
So when it loads from be, it gets to get loads.

2944
01:51:08,300 --> 01:51:08,900
From be.

2945
01:51:09,000 --> 01:51:09,900
It will get to it.

2946
01:51:09,900 --> 01:51:14,400
Could just fold those out and say right to see the same value you

2947
01:51:14,400 --> 01:51:16,200
wrote to a right?

2948
01:51:16,200 --> 01:51:18,100
That is basically what the optimizer is going to do.

2949
01:51:18,100 --> 01:51:19,400
The optimizer is going to say.

2950
01:51:19,400 --> 01:51:23,600
Hey look, all I need you to do is load from be once because since

2951
01:51:23,600 --> 01:51:27,100
you're loading from be twice and the value isn't going to change.

2952
01:51:27,900 --> 01:51:29,800
It's just be the whole time, right?

2953
01:51:30,000 --> 01:51:33,200
I can just save that, and that is the optimization that it wants to

2954
01:51:33,200 --> 01:51:33,500
make.

2955
01:51:33,500 --> 01:51:37,000
Now, the point is, it cannot make that optimization.

2956
01:51:37,200 --> 01:51:40,000
The reason, it cannot make that optimization is because there's other

2957
01:51:40,000 --> 01:51:40,900
pointers here.

2958
01:51:41,100 --> 01:51:41,600
Right?

2959
01:51:41,600 --> 01:51:42,700
And that is a problem.

2960
01:51:42,900 --> 01:51:48,000
What it doesn't know is whether two of these pointers Alias, and if

2961
01:51:48,000 --> 01:51:51,800
two pointers point to the same memory, they are called aliasing.

2962
01:51:52,200 --> 01:51:54,600
So, let's say, I go up here, right?

2963
01:51:54,700 --> 01:51:59,800
And because I am being mean I set B, and D to point to the same place.

2964
01:52:00,700 --> 01:52:03,700
Well, now, when you read out of be here, right?

2965
01:52:03,800 --> 01:52:07,400
You will get a 2 but when you read out of be here, you should have

2966
01:52:07,400 --> 01:52:10,000
gotten the 5 because the interceding, right?

2967
01:52:10,000 --> 01:52:15,300
2D wrote a 5 into the location that used to contain a to.

2968
01:52:16,400 --> 01:52:19,900
So the compiler cannot optimize this away.

2969
01:52:20,000 --> 01:52:24,700
It cannot write to see the same value at wrote to a it has to.

2970
01:52:24,800 --> 01:52:32,600
It must always load from be it must and then right to see so pointer

2971
01:52:32,600 --> 01:52:33,300
aliasing.

2972
01:52:33,500 --> 01:52:41,700
Right pointer aliasing is basically a pointer aliasing is when two

2973
01:52:41,700 --> 01:52:42,500
pointers.

2974
01:52:43,800 --> 01:52:48,800
point to the same memory or rather two pointers could

2975
01:52:50,100 --> 01:52:56,400
Point to the same memory and the compiler doesn't know if a right to

2976
01:52:56,400 --> 01:53:01,800
one of those pointers might affect a read from the other pointer,

2977
01:53:02,400 --> 01:53:02,900
right?

2978
01:53:03,500 --> 01:53:04,400
That is the key.

2979
01:53:04,600 --> 01:53:09,500
It doesn't know whether it can optimize out that second load from be

2980
01:53:09,900 --> 01:53:12,700
because it doesn't know if you might have just written a 5 in there.

2981
01:53:13,300 --> 01:53:16,700
So really there's two ways to interpret this code depending on whether

2982
01:53:16,700 --> 01:53:19,800
the pointers Alias one is that you can load from be once and

2983
01:53:20,000 --> 01:53:20,500
It twice.

2984
01:53:20,500 --> 01:53:25,100
And one is that you can load from be twice or rather load from be once

2985
01:53:25,300 --> 01:53:28,100
and then write a five because you would know that, the only thing the

2986
01:53:28,100 --> 01:53:28,900
optimizer would know.

2987
01:53:28,900 --> 01:53:31,000
The only thing that could happen was the five, but it doesn't even

2988
01:53:31,000 --> 01:53:32,200
know how to make a determination.

2989
01:53:32,200 --> 01:53:34,600
But he doesn't have to actually compare the pointers and that would be

2990
01:53:34,600 --> 01:53:39,100
slower than just probably just doing it than just actually doing the

2991
01:53:39,100 --> 01:53:41,200
load potentially because it still has to do the load.

2992
01:53:41,300 --> 01:53:42,700
Well, maybe not, I don't know, could do that.

2993
01:53:42,700 --> 01:53:43,200
It was really smart.

2994
01:53:43,300 --> 01:53:45,200
I'm not sure, probably possibly not.

2995
01:53:45,300 --> 01:53:47,500
But anyway, you get the idea there, right?

2996
01:53:48,000 --> 01:53:49,200
Hopefully, that makes some sense.

2997
01:53:49,900 --> 01:53:53,500
So basically what you need to understand is any time you pass

2998
01:53:53,500 --> 01:53:54,200
pointers.

2999
01:53:54,200 --> 01:53:57,000
The compiler, can't really do any optimizations with those pointers.

3000
01:53:57,000 --> 01:53:59,800
If you write to them, if you only ever read from them.

3001
01:54:00,000 --> 01:54:03,400
You're usually fine because it's only the writing that creates

3002
01:54:03,400 --> 01:54:05,300
something that could happen if this right.

3003
01:54:05,300 --> 01:54:09,500
2D weren't here then no other there's no other reason that be could

3004
01:54:09,500 --> 01:54:12,300
get changed now in a threaded environment.

3005
01:54:12,400 --> 01:54:15,400
You may see things like this where people put volatile on something

3006
01:54:15,600 --> 01:54:18,700
and that's a way of telling it that some other thread could be

3007
01:54:18,700 --> 01:54:19,700
modifying stuff.

3008
01:54:20,600 --> 01:54:23,100
But assuming that you're working with code, that is guaranteed to be

3009
01:54:23,100 --> 01:54:25,200
single-threaded, which is what you're doing when you don't put

3010
01:54:25,200 --> 01:54:27,000
volatile, when you're just telling the compiler.

3011
01:54:27,000 --> 01:54:29,800
Hey, these are just regular variables that only might.

3012
01:54:30,000 --> 01:54:33,400
Thread touches or I know that all the threads are locked from.

3013
01:54:33,400 --> 01:54:36,200
Not touching those variables at this point in time.

3014
01:54:36,800 --> 01:54:40,200
Then it goes ahead and assumes it can optimize those out so long as it

3015
01:54:40,200 --> 01:54:41,400
can tell the missing out.

3016
01:54:41,400 --> 01:54:45,000
So basically in this circumstance, what you want to do right?

3017
01:54:45,000 --> 01:54:49,200
Is you you want to pass be by value so that you can tell the compiler.

3018
01:54:49,200 --> 01:54:51,200
Very clearly look.

3019
01:54:51,200 --> 01:54:54,900
You don't have to worry about reading from be as an address.

3020
01:54:55,000 --> 01:54:57,600
I'm telling you what the value of B is upfront and so, you know that

3021
01:54:57,600 --> 01:54:59,800
it can't be changed by this interview.

3022
01:55:00,100 --> 01:55:00,600
Interesting.

3023
01:55:00,600 --> 01:55:04,700
Right to D because there's no way to get an address to this parameter,

3024
01:55:04,900 --> 01:55:05,100
right?

3025
01:55:05,100 --> 01:55:06,100
That's not possible.

3026
01:55:06,500 --> 01:55:07,300
Does that make sense?

3027
01:55:07,600 --> 01:55:08,600
Hopefully that makes some sense.

3028
01:55:08,600 --> 01:55:11,800
I apologize for the long winded and completely useless copy example,

3029
01:55:11,800 --> 01:55:13,600
that I was trying to construct for you that I thought was gonna be

3030
01:55:13,600 --> 01:55:14,100
more fun.

3031
01:55:14,300 --> 01:55:17,300
It was just a world of hurt, but that is basically all we're talking

3032
01:55:17,300 --> 01:55:17,800
about here.

3033
01:55:18,700 --> 01:55:20,600
There is really nothing more to it than that.

3034
01:55:20,900 --> 01:55:22,600
It is extremely extremely basic.

3035
01:55:23,000 --> 01:55:26,900
Now, basically, the kinds of optimizations that happen are obviously

3036
01:55:26,900 --> 01:55:29,300
much more complicated than this and the kinds of pointer Ellison that

3037
01:55:29,300 --> 01:55:29,800
happens can be.

3038
01:55:29,900 --> 01:55:30,700
Much more complicated this.

3039
01:55:30,700 --> 01:55:34,000
So this is a very, very simple example, but that sort of thing can

3040
01:55:34,000 --> 01:55:34,900
happen all the time.

3041
01:55:34,900 --> 01:55:37,600
As you're passing pointers around the compiler constantly has to be

3042
01:55:37,600 --> 01:55:39,100
aware of what could happen there.

3043
01:55:39,300 --> 01:55:42,100
And so that's a very important thing to understand when you're

3044
01:55:42,100 --> 01:55:43,100
actually trying to optimization.

3045
01:55:43,100 --> 01:55:44,600
So, I'm sorry that took so long.

3046
01:55:44,600 --> 01:55:46,600
That should not taken that long, but that's just the way it goes

3047
01:55:46,600 --> 01:55:47,100
sometimes.

3048
01:56:05,100 --> 01:56:07,500
So it looks like we are done with questions.

3049
01:56:08,100 --> 01:56:09,300
So that is good.

3050
01:56:09,600 --> 01:56:13,200
We are down here at the end of The Stream So that is pretty cool.

3051
01:56:14,900 --> 01:56:15,700
Let's see here.

3052
01:56:16,600 --> 01:56:17,700
And there's anything else.

3053
01:56:20,400 --> 01:56:21,400
Yes, and I'm terribly.

3054
01:56:21,400 --> 01:56:21,900
Sorry for that.

3055
01:56:21,900 --> 01:56:23,000
Such a long word, exhalation.

3056
01:56:23,200 --> 01:56:24,900
Again, like I said, you gotta bear with me on this dream.

3057
01:56:24,900 --> 01:56:28,600
Sometimes it's also a learning process for me, in terms of trying to

3058
01:56:28,600 --> 01:56:31,800
keep my train of thought, correct and talk at the same time.

3059
01:56:31,800 --> 01:56:34,500
It's actually really pretty difficult because talking and coding kind

3060
01:56:34,500 --> 01:56:35,600
of use the same part of your brain.

3061
01:56:35,600 --> 01:56:36,500
So it's a little bit difficult.

3062
01:56:36,500 --> 01:56:38,700
So sometimes my explanations go a little bit long-winded.

3063
01:56:38,700 --> 01:56:41,000
I will stick them out every damn time.

3064
01:56:41,600 --> 01:56:42,500
So I just ask that.

3065
01:56:42,500 --> 01:56:43,700
Maybe you stick them out with me.

3066
01:56:43,700 --> 01:56:46,000
I realized a little frustrating because way better if someone can just

3067
01:56:46,000 --> 01:56:48,500
give you at real concise example, and not have to muddle through it,

3068
01:56:48,900 --> 01:56:49,700
which we have done number.

3069
01:56:49,800 --> 01:56:50,400
Times on the stream.

3070
01:56:50,400 --> 01:56:53,200
So we've been getting better at it is totally true, but we got a long

3071
01:56:53,200 --> 01:56:54,700
ways to go because that was pretty rough.

3072
01:56:54,700 --> 01:56:56,300
That should not have taken 10 minutes or whatever.

3073
01:56:56,300 --> 01:56:58,800
It took that should have been a quick quick one.

3074
01:57:02,400 --> 01:57:03,400
Let's see here.

3075
01:57:04,400 --> 01:57:06,400
Is anyone posting notes from these casts?

3076
01:57:06,600 --> 01:57:10,000
Yes, we will be putting up a website very shortly with notes from the

3077
01:57:10,000 --> 01:57:10,600
casts.

3078
01:57:11,300 --> 01:57:13,900
And so I hope that you will take a look at that.

3079
01:57:13,900 --> 01:57:15,200
I will be announcing on the livestream.

3080
01:57:15,200 --> 01:57:16,800
As soon as it is ready is not quite ready yet.

3081
01:57:16,800 --> 01:57:19,200
So hopefully we will have some of that going.

3082
01:57:23,600 --> 01:57:26,000
I was under the impression that the stack always grows downwards on

3083
01:57:26,000 --> 01:57:27,000
Lily and little-endian.

3084
01:57:27,000 --> 01:57:27,900
Is that not true?

3085
01:57:27,900 --> 01:57:29,700
I thought that it did as well.

3086
01:57:30,100 --> 01:57:31,200
That was my assumption.

3087
01:57:31,600 --> 01:57:34,500
But to be honest with you, I have done very little.

3088
01:57:35,100 --> 01:57:41,000
I have never written a single Assembly Language only program in x64,

3089
01:57:41,600 --> 01:57:44,500
which is what we're compiling in like an x86.

3090
01:57:44,500 --> 01:57:46,900
I believe it always grew downward, but an x 64 for all.

3091
01:57:46,900 --> 01:57:47,800
I know they could have changed it.

3092
01:57:47,800 --> 01:57:48,900
I mean, I had no idea.

3093
01:57:49,100 --> 01:57:50,900
So, I figured well, I might as well check.

3094
01:57:51,700 --> 01:57:53,300
I'm, yeah, I've never had

3095
01:57:53,500 --> 01:57:54,900
To actually think about that.

3096
01:57:55,400 --> 01:57:57,300
And so, I just felt like it was kind of fun check.

3097
01:57:57,300 --> 01:58:00,200
So, yes, I think it always does grow downward and it continues to grow

3098
01:58:00,200 --> 01:58:02,100
downward in x64.

3099
01:58:02,100 --> 01:58:02,800
So that is good.

3100
01:58:02,800 --> 01:58:05,800
You don't have to remember that it switches or anything like that, but

3101
01:58:05,800 --> 01:58:06,900
I wanted to verify that.

3102
01:58:09,100 --> 01:58:09,800
Let's see.

3103
01:58:11,300 --> 01:58:12,800
Can you post interesting emails to get to the site?

3104
01:58:12,800 --> 01:58:13,900
Yes, I will try to.

3105
01:58:13,900 --> 01:58:16,400
I don't, I don't necessarily want to post emails exactly because

3106
01:58:16,700 --> 01:58:19,600
people probably don't want their emails posted.

3107
01:58:19,600 --> 01:58:21,400
If they haven't actually said that are okay with that.

3108
01:58:21,400 --> 01:58:23,700
But what I will do is I will comb back through the entry males.

3109
01:58:23,700 --> 01:58:26,200
I have received and make sort of a fact from them that sort of

3110
01:58:26,600 --> 01:58:28,700
discusses things that people have asked me what I've answered.

3111
01:58:32,200 --> 01:58:35,400
Clemens bound, the compiler is allowed to, and actually does assume

3112
01:58:35,400 --> 01:58:37,200
that two pointers two different types never Alias.

3113
01:58:37,200 --> 01:58:39,100
Unless one of the types of care or unsigned care.

3114
01:58:39,100 --> 01:58:40,100
That is correct.

3115
01:58:40,300 --> 01:58:42,800
Basically, there are modes that you can put the compiler in.

3116
01:58:44,600 --> 01:58:47,300
And so there are there are optimization modes.

3117
01:58:47,300 --> 01:58:50,700
You can put the compiler, any that make it assume a bunch of things

3118
01:58:50,700 --> 01:58:56,000
about aliasing, and I find affect a lot of people.

3119
01:58:56,000 --> 01:58:59,400
In fact, I think even rad does this now, by default turn those modes

3120
01:58:59,400 --> 01:59:02,700
off and the reason is because they are bugs, waiting to happen.

3121
01:59:02,800 --> 01:59:07,200
Compilers are now assuming more and more stuff about aliasing

3122
01:59:07,500 --> 01:59:11,000
sometimes in situations where you really, really don't want them to

3123
01:59:11,300 --> 01:59:13,400
and so assume no aliasing.

3124
01:59:13,500 --> 01:59:16,400
A really bad thing in compilers and I think we want to kind of get rid

3125
01:59:16,400 --> 01:59:16,800
of it.

3126
01:59:16,800 --> 01:59:21,000
What you'd much rather do is Mark up your stuff to say when things

3127
01:59:21,000 --> 01:59:21,900
don't Alias.

3128
01:59:23,300 --> 01:59:24,800
Honestly, I think that should have been the default.

3129
01:59:24,800 --> 01:59:28,200
Unfortunately, the language support for it is a bit spotty, but there

3130
01:59:28,200 --> 01:59:32,300
are things like the restrict keyword and the assumed keyword that you

3131
01:59:32,300 --> 01:59:32,900
can use.

3132
01:59:33,000 --> 01:59:37,300
And so that is kind of a it's kind of a bit of a messy messy

3133
01:59:37,300 --> 01:59:40,200
situation, and we will definitely probably deal with that a little bit

3134
01:59:40,500 --> 01:59:41,000
later.

3135
01:59:47,100 --> 01:59:50,200
Win32, displayed by friend window is taking for unused for a WMA is

3136
01:59:50,200 --> 01:59:52,000
the only part where we pass those, but we never used them.

3137
01:59:52,000 --> 01:59:53,000
Will that change?

3138
01:59:54,800 --> 01:59:55,800
You know, I'll be honest with you.

3139
01:59:55,800 --> 01:59:59,100
I don't know if we really need to worry about jury wrecked, updating.

3140
01:59:59,200 --> 01:59:59,800
It seems like kind.

3141
02:00:00,000 --> 02:00:00,800
Waste of time.

3142
02:00:01,000 --> 02:00:04,400
So we could easily just go ahead and say that we are not going to do

3143
02:00:04,400 --> 02:00:04,900
that.

3144
02:00:05,100 --> 02:00:08,200
We could basically say that we just don't care about what the dirty

3145
02:00:08,200 --> 02:00:11,000
rectangle is because for the most part, since we're going to have to

3146
02:00:11,000 --> 02:00:12,300
update the whole screen every frame.

3147
02:00:12,300 --> 02:00:15,000
Anyway, we must be able to do that quickly.

3148
02:00:15,200 --> 02:00:20,300
So we could easily just say this is the new thing for the program and

3149
02:00:20,300 --> 02:00:22,100
that would be fine.

3150
02:00:22,100 --> 02:00:22,800
I think.

3151
02:00:23,100 --> 02:00:25,200
So, let's go ahead and double check that.

3152
02:00:25,200 --> 02:00:26,200
That's all good.

3153
02:00:26,600 --> 02:00:28,400
So I think that's probably fine.

3154
02:00:29,400 --> 02:00:29,900
Those are just

3155
02:00:30,000 --> 02:00:34,600
just we had passed those because WM paint does actually give us back

3156
02:00:34,600 --> 02:00:36,300
the rectangle that we need to refresh.

3157
02:00:36,300 --> 02:00:38,600
So you could save a little time by only refreshing that region.

3158
02:00:38,600 --> 02:00:41,700
But since we know, we have to put the whole screen 30 frames a second

3159
02:00:42,000 --> 02:00:43,700
to make a game feel good.

3160
02:00:43,700 --> 02:00:48,000
Anyway, we can pretty much assume that we don't need to do that and

3161
02:00:48,000 --> 02:00:50,700
simplify that code because obviously, we don't need to just worry

3162
02:00:50,700 --> 02:00:51,100
about it.

3163
02:00:51,400 --> 02:00:52,700
Small wrecked on paint.

3164
02:00:52,700 --> 02:00:54,600
If every frame, we have to repaint the whole thing.

3165
02:00:54,600 --> 02:00:57,100
Anyway, yeah, so that's why it's good point.

3166
02:00:57,200 --> 02:00:59,300
And the answer is no, you don't have to worry about those.

3167
02:01:02,700 --> 02:01:04,400
Wouldn't it be better to keep comments in the code about the

3168
02:01:04,400 --> 02:01:04,800
explorations?

3169
02:01:04,800 --> 02:01:06,500
You do sometimes?

3170
02:01:06,500 --> 02:01:07,400
Yes, sometimes not.

3171
02:01:07,400 --> 02:01:09,800
I'd rather maybe pull those out to the forum's because, honestly, if

3172
02:01:09,800 --> 02:01:12,700
the code gets too cluttered up with comments that are explanations and

3173
02:01:12,700 --> 02:01:14,800
especially if those explanations are no longer pertaining.

3174
02:01:14,800 --> 02:01:16,900
Exactly the thing because we change the code a little bit, that's

3175
02:01:16,900 --> 02:01:17,500
going to get annoying.

3176
02:01:17,500 --> 02:01:20,000
So, I'm going to try not to do that, probably.

3177
02:01:21,000 --> 02:01:21,300
All right.

3178
02:01:21,300 --> 02:01:22,300
It is 10 p.m.

3179
02:01:22,300 --> 02:01:22,500
Here.

3180
02:01:22,500 --> 02:01:24,800
Ladies and gentlemen, so let's go ahead and wrap this up.

3181
02:01:24,900 --> 02:01:26,600
Let's do one last code question.

3182
02:01:28,500 --> 02:01:30,100
Why have B 4 pixel as a variable?

3183
02:01:30,100 --> 02:01:31,600
Do you expect it to have different values?

3184
02:01:31,600 --> 02:01:32,300
Why not put it as

3185
02:01:32,500 --> 02:01:35,500
Acosta, fine, or even replace it with BMI header, dot bi bit.

3186
02:01:35,500 --> 02:01:36,800
Count divided by 8.

3187
02:01:36,900 --> 02:01:38,300
Those are all good suggestions.

3188
02:01:39,600 --> 02:01:42,800
I totally, I would be okay with all of that.

3189
02:01:43,800 --> 02:01:45,700
Every last one of those is totally viable.

3190
02:01:46,500 --> 02:01:51,000
I just found that it was kind of a nicer thing to put there because

3191
02:01:51,000 --> 02:01:54,100
it's kind of all the stuff that actually you need to know about the

3192
02:01:54,100 --> 02:01:54,900
on-screen buffer.

3193
02:01:54,900 --> 02:01:57,800
So I just felt it was kind of a nice thing to put there so I don't see

3194
02:01:57,800 --> 02:02:02,300
any real reason to remove it, but we could, we could

3195
02:02:02,400 --> 02:02:04,400
Could just change that back to a local variable.

3196
02:02:04,400 --> 02:02:06,500
So, you know, we could totally do it this way.

3197
02:02:07,700 --> 02:02:10,500
We could say this, right?

3198
02:02:11,000 --> 02:02:14,100
Go back to the way that we have before and just say that it's always

3199
02:02:14,100 --> 02:02:17,100
that because really we're not going to handle anything else.

3200
02:02:17,100 --> 02:02:18,700
So that might be the right way to go.

3201
02:02:19,300 --> 02:02:22,600
I do not know we could totally do that.

3202
02:02:22,900 --> 02:02:24,200
We could totally do that.

3203
02:02:25,100 --> 02:02:26,100
Let's think about it.

3204
02:02:26,300 --> 02:02:27,500
Yeah, let's go ahead and do that.

3205
02:02:27,600 --> 02:02:30,300
Let's just go ahead and say for now because we can always change our

3206
02:02:30,300 --> 02:02:30,800
mind.

3207
02:02:31,000 --> 02:02:32,000
Let's just always say,

3208
02:02:32,800 --> 02:02:36,200
Pixels are always 32 bits wide.

3209
02:02:37,400 --> 02:02:38,300
Little endian.

3210
02:02:43,800 --> 02:02:44,500
Like that.

3211
02:02:48,200 --> 02:02:52,200
Although maybe I'll say memory order BB G RX X.

3212
02:02:57,100 --> 02:02:58,000
Alright everyone.

3213
02:02:58,000 --> 02:02:59,000
Thank you for joining me.

3214
02:03:00,000 --> 02:03:03,500
That cleared up everything that we were doing.

3215
02:03:05,100 --> 02:03:06,000
Let's see here.

3216
02:03:06,200 --> 02:03:10,000
Yeah, that looks good to the person who said, ugh, make it const

3217
02:03:10,300 --> 02:03:10,500
though.

3218
02:03:10,500 --> 02:03:11,900
Maybe we should take one more thing.

3219
02:03:11,900 --> 02:03:13,700
Someone was grumpy that it wasn't const.

3220
02:03:14,000 --> 02:03:15,900
I never like to use const.

3221
02:03:15,900 --> 02:03:20,700
Constant is a is basically, the only thing constant is does is it

3222
02:03:20,700 --> 02:03:25,200
basically allows the programmer to potentially not make mistakes if

3223
02:03:25,200 --> 02:03:25,900
they were to assign to it.

3224
02:03:25,900 --> 02:03:28,700
So basically, if you type in constant, just means that you can't type

3225
02:03:29,100 --> 02:03:29,800
B 4 pixels.

3226
02:03:30,000 --> 02:03:30,900
Equals eight here, right?

3227
02:03:30,900 --> 02:03:32,100
It will give you an error.

3228
02:03:32,100 --> 02:03:35,300
It'll say that you can't assign to a const variable.

3229
02:03:35,900 --> 02:03:37,400
I don't find that to be useful at all.

3230
02:03:37,400 --> 02:03:41,500
I have never had a bug in the 15 years since I stopped using const.

3231
02:03:41,500 --> 02:03:44,000
I have literally never had a single bug that would have been caught by

3232
02:03:44,000 --> 02:03:44,300
it.

3233
02:03:44,300 --> 02:03:46,100
So it is just a waste of typing for me.

3234
02:03:46,200 --> 02:03:48,600
It may not be a waste of typing for you if you make that mistake off

3235
02:03:48,600 --> 02:03:50,800
and otherwise, it is completely useless in the reason that it is

3236
02:03:50,800 --> 02:03:54,900
completely useless except for a small number of cases where you're

3237
02:03:54,900 --> 02:03:57,400
defining Global variables and need to say and you don't want to use a

3238
02:03:57,400 --> 02:03:59,900
pound to find for example, the

3239
02:03:59,900 --> 02:04:04,000
This completely useless is because the compiler cannot actually assume

3240
02:04:04,000 --> 02:04:04,100
that.

3241
02:04:04,100 --> 02:04:06,800
Something that is called constant is actually const.

3242
02:04:06,800 --> 02:04:10,800
In any case, constant is actually, so meaningless, that constant has

3243
02:04:10,800 --> 02:04:13,300
not even exist in the optimizer.

3244
02:04:13,300 --> 02:04:16,300
In fact, if you don't believe me, Chandler, Caruth, who I mentioned

3245
02:04:16,300 --> 02:04:19,500
before, go watch one of his lectures, you will find him.

3246
02:04:19,500 --> 02:04:21,600
Explain the fact that Constance completely useless and does not even

3247
02:04:21,600 --> 02:04:23,900
exist in the optimizer.

3248
02:04:23,900 --> 02:04:25,200
It does not even use cost.

3249
02:04:25,200 --> 02:04:28,900
And the reason for that is because in C++, they allowed you to Cast

3250
02:04:28,900 --> 02:04:29,900
Away constant, which means

3251
02:04:29,900 --> 02:04:33,800
means that something that is constant does not actually have to be

3252
02:04:33,800 --> 02:04:35,000
constant at all.

3253
02:04:35,000 --> 02:04:38,700
And so basically what happens is you get into situations that looks

3254
02:04:38,700 --> 02:04:39,500
something like this.

3255
02:04:40,400 --> 02:04:45,600
Basically, you have somebody who's doing, you know do the stuff right.

3256
02:04:45,600 --> 02:04:51,000
And it's got in constant A and N star B, and it could just as well be

3257
02:04:51,000 --> 02:04:54,100
the case just because you said that these were constant well for all

3258
02:04:54,100 --> 02:04:58,100
it knows be could also point to a right.

3259
02:04:58,100 --> 02:04:59,800
It's that aliasing thing all over again.

3260
02:05:00,000 --> 02:05:02,700
So the fact that this is called cost is meaningless because the

3261
02:05:02,700 --> 02:05:04,400
optimizer has no idea.

3262
02:05:04,400 --> 02:05:08,000
Whether it be actually secretly does point to a and, you know, so if

3263
02:05:08,000 --> 02:05:12,300
there's a right to be here, that could be mutating a so constant

3264
02:05:12,300 --> 02:05:13,400
literally useless.

3265
02:05:14,000 --> 02:05:16,800
It has absolutely no use whatsoever to the compiler and if you don't

3266
02:05:16,800 --> 02:05:20,800
believe me, go ask Chandler, go ask someone who works on Optimizer.

3267
02:05:20,800 --> 02:05:23,300
It does not help, it cannot be propagated down.

3268
02:05:23,700 --> 02:05:24,800
So, constant is useless.

3269
02:05:24,800 --> 02:05:28,700
But if you find it, useful for your own coding practices, you can go

3270
02:05:28,700 --> 02:05:29,800
ahead and use it that

3271
02:05:29,900 --> 02:05:32,900
Is fine, but just don't think you're making better code by adding

3272
02:05:32,900 --> 02:05:34,800
kant's because that is not true.

3273
02:05:35,200 --> 02:05:36,200
It does not help you.

3274
02:05:49,100 --> 02:05:51,800
All right, guys, that is the end of the stream.

3275
02:05:51,800 --> 02:05:53,600
Thank you all for joining us.

3276
02:05:54,000 --> 02:05:56,700
It was a bit of a man during Friday, but I wanted to go through all

3277
02:05:56,700 --> 02:05:58,900
this stuff with you, make sure everyone was comfortable with

3278
02:05:58,900 --> 02:05:59,800
everything we did during the week.

3279
02:06:00,300 --> 02:06:01,000
Next week.

3280
02:06:01,000 --> 02:06:04,000
We'll be starting again on Monday at 8 p.m.

3281
02:06:04,500 --> 02:06:06,000
Pacific Standard time.

3282
02:06:06,300 --> 02:06:06,800
Next week.

3283
02:06:06,800 --> 02:06:09,600
We will try to move Friday to an early time so that people in other

3284
02:06:09,600 --> 02:06:10,700
time zones can watch.

3285
02:06:10,700 --> 02:06:13,400
So we will do Monday through Thursday at 8 p.m.

3286
02:06:13,400 --> 02:06:16,100
As usual and then on Friday, we will try to do something perhaps in

3287
02:06:16,100 --> 02:06:20,000
the morning or something that will be at a time when other people in

3288
02:06:20,000 --> 02:06:22,500
other time zones can tune in live because a lot of people been asking

3289
02:06:22,500 --> 02:06:23,100
about that.

3290
02:06:23,200 --> 02:06:24,900
So we will go ahead and do that.

3291
02:06:24,900 --> 02:06:27,400
I will try to post a schedule for you and hopefully, we'll have that

3292
02:06:27,400 --> 02:06:28,200
website up to.

3293
02:06:28,200 --> 02:06:29,900
So I can have a place where the schedule always.

3294
02:06:30,100 --> 02:06:33,600
Is and you can find out ahead of time when this will be aired.

3295
02:06:34,200 --> 02:06:36,500
So thank you all for joining us next week.

3296
02:06:36,500 --> 02:06:40,300
We will tackle input and sound assuming that we can get through them.

3297
02:06:40,300 --> 02:06:40,600
Both.

3298
02:06:40,600 --> 02:06:44,000
We will try to tackle sound first and if that takes all week, then we

3299
02:06:44,000 --> 02:06:47,700
will do input the week after it is Thanksgiving week, but I still plan

3300
02:06:47,700 --> 02:06:48,500
to be streaming.

3301
02:06:48,500 --> 02:06:50,500
So I hope you guys can tune in and join me.

3302
02:06:51,000 --> 02:06:54,600
If not have an excellent Thanksgiving, those of you who are in the

3303
02:06:54,600 --> 02:06:55,300
u.s., I guess.

3304
02:06:55,300 --> 02:06:57,200
I don't know all the countries that celebrate Thanksgiving, but we

3305
02:06:57,200 --> 02:06:58,000
celebrate it here.

3306
02:06:58,400 --> 02:07:00,000
Obviously, it's kind of an American holiday.

3307
02:07:00,100 --> 02:07:02,700
Day, so it probably isn't celebrated much outside of America.

3308
02:07:02,700 --> 02:07:06,100
But for those of you in the US, have a Happy Thanksgiving next week.

3309
02:07:06,100 --> 02:07:09,600
If I don't see on the stream, if I do Willie took you together and

3310
02:07:09,600 --> 02:07:11,100
program, sound on Windows.

3311
02:07:11,200 --> 02:07:13,900
Thanks everyone for joining us and I will catch you next week.

