1
00:00:02,300 --> 00:00:05,600
Okay, hello everyone, and welcome to handmade hero.

2
00:00:05,600 --> 00:00:07,200
Although today we're actually doing handmade here.

3
00:00:07,200 --> 00:00:10,100
We're doing handmade Ray because this is another test stream

4
00:00:10,100 --> 00:00:10,800
yesterday.

5
00:00:10,800 --> 00:00:13,700
We think everything went fine with our 1080p test stream.

6
00:00:15,000 --> 00:00:18,100
We're not 100% sure those, some people thought there were some pauses

7
00:00:18,100 --> 00:00:22,500
in it but we weren't sure if those were pauses because of the capture

8
00:00:22,500 --> 00:00:26,200
or pauses because of twitch and rather than having to scrub through

9
00:00:26,200 --> 00:00:30,700
the entire video and find out what we wanted to do today, was just go

10
00:00:30,700 --> 00:00:37,100
ahead and actually have people write down what time they get pauses if

11
00:00:37,100 --> 00:00:37,900
they get any pauses.

12
00:00:37,900 --> 00:00:42,400
So we're starting here at 3:15 PST, 316 PST, right around there.

13
00:00:43,700 --> 00:00:47,400
If you could just write down what time and time zone, you saw the

14
00:00:47,400 --> 00:00:48,000
pause.

15
00:00:48,000 --> 00:00:49,200
We can back figure that out.

16
00:00:49,200 --> 00:00:51,900
Look at the video and make sure that it was entirely clear.

17
00:00:51,900 --> 00:00:55,600
And after that, I think we can be relatively certain that we've gotten

18
00:00:55,600 --> 00:00:56,800
everything else working.

19
00:00:56,800 --> 00:01:03,200
So here's one more handmade Ray day today where we will finish, what

20
00:01:03,200 --> 00:01:04,300
we did yesterday.

21
00:01:04,500 --> 00:01:07,000
And hopefully, at the end of this, we will not only have a finished

22
00:01:07,000 --> 00:01:13,000
Cindy, Ray Tracer, that's ready to have some more

23
00:01:13,200 --> 00:01:17,200
Of light propagation algorithm is put into it for example and we will

24
00:01:17,200 --> 00:01:19,900
also know that our video is working or not working definitively.

25
00:01:19,900 --> 00:01:20,800
One way or the other.

26
00:01:21,600 --> 00:01:25,000
So if everyone could help me with that, I'd really appreciate it and

27
00:01:25,000 --> 00:01:25,600
off we go.

28
00:01:26,000 --> 00:01:29,900
So if you remember where we left off yesterday, we had done the work,

29
00:01:30,100 --> 00:01:35,500
which is the majority of the sort of structural work to make sure that

30
00:01:35,500 --> 00:01:36,500
are handmade.

31
00:01:37,200 --> 00:01:40,600
Oops, I want to go to the river a project that we go to make sure that

32
00:01:40,600 --> 00:01:43,000
our handmade re-program was compiling in.

33
00:01:43,100 --> 00:01:49,500
Essentially a structure that admitted itself to Cindy optimization the

34
00:01:49,500 --> 00:01:50,100
way we did.

35
00:01:50,100 --> 00:01:53,500
This was when we were casting raise per pixel, what we did is we

36
00:01:53,500 --> 00:01:57,300
changed all of our variables to things that were could be custom

37
00:01:57,300 --> 00:01:59,300
structures that could be cleared wide.

38
00:01:59,300 --> 00:02:03,300
And then we took any if statements that we had in the code because

39
00:02:03,300 --> 00:02:05,700
week since we're doing multiple things at a time, we can't actually

40
00:02:05,700 --> 00:02:07,400
ever execute a real branch.

41
00:02:07,900 --> 00:02:10,400
And what we did is we turn this into a conditional assignments.

42
00:02:11,300 --> 00:02:14,400
So that we would only ever modify our state variables.

43
00:02:15,100 --> 00:02:20,400
If we actually got hits in the correct Lanes, those Lanes of the state

44
00:02:20,400 --> 00:02:22,700
variables would be the ones that get modified, and you can see that

45
00:02:22,700 --> 00:02:24,000
we've got it working here.

46
00:02:24,700 --> 00:02:27,500
And this is using no actual Cindy.

47
00:02:27,500 --> 00:02:33,900
This is just using the SIM dstyle code, which can be, which could be

48
00:02:33,900 --> 00:02:36,700
implanted, 70, but currently turned.

49
00:02:36,900 --> 00:02:38,500
So that it's still using scalar.

50
00:02:38,500 --> 00:02:40,700
You can see here is we have a lane with

51
00:02:41,000 --> 00:02:44,600
Find the limit is defined as 1, and then we've got some pound gifts

52
00:02:44,600 --> 00:02:49,600
here that are going to put in different pieces of code, depending on

53
00:02:49,600 --> 00:02:53,800
whether we want assumed Elaine with of Oneness, in dealing, with the

54
00:02:53,800 --> 00:02:55,400
four or simulations of a simulated.

55
00:02:55,400 --> 00:02:59,900
If the one is just the neutral running without any actual.

56
00:03:00,000 --> 00:03:03,800
MD stimulating with the four is SSE instructions.

57
00:03:05,100 --> 00:03:07,600
Those are instructions that can do for floats.

58
00:03:08,900 --> 00:03:11,200
In a single vector and single operation.

59
00:03:12,900 --> 00:03:16,900
And then we've got eight wide which is the we didn't put a 16 wide in

60
00:03:16,900 --> 00:03:20,100
here because I don't have a machine that can do 16 wide 16.

61
00:03:20,300 --> 00:03:25,500
Why does avx-512 this machine can do 8 wide which is a v x 2 and so on

62
00:03:26,300 --> 00:03:30,800
I believe that's all going to work on the core i7 just fine so we can

63
00:03:30,900 --> 00:03:32,800
actually do 1/8 wide as well.

64
00:03:33,200 --> 00:03:38,800
We just can't do a 16 wide because that's avx-512 it's only available

65
00:03:38,800 --> 00:03:42,200
on zeon's and core I nines and apparently Koreans can't

66
00:03:42,400 --> 00:03:43,100
Run it anyway.

67
00:03:43,300 --> 00:03:46,600
So you're better off, just still using 8 wide on those.

68
00:03:46,600 --> 00:03:51,100
It sounds like so, but in the future, in the future, in a few years,

69
00:03:51,100 --> 00:03:56,500
for example, when AMD start shipping it, and when Intel gets it,

70
00:03:56,600 --> 00:04:02,800
working better on the desktop cores, then we all you could imagine

71
00:04:02,800 --> 00:04:06,200
upgrading this program quite simply to have a lane width of 16 and

72
00:04:06,200 --> 00:04:07,200
that would be the goal, right?

73
00:04:07,200 --> 00:04:08,600
So that's all we're really doing here.

74
00:04:11,800 --> 00:04:13,700
All right, this is my little coffee.

75
00:04:13,700 --> 00:04:15,000
I made some espresso this morning.

76
00:04:16,600 --> 00:04:19,000
Alright so here we go.

77
00:04:19,300 --> 00:04:21,500
We're going to ignore the lane with the vase for now or we're just

78
00:04:21,500 --> 00:04:23,600
going to go straight to the Lane with the for and we're just going to

79
00:04:23,600 --> 00:04:24,600
implement it directly.

80
00:04:24,600 --> 00:04:26,300
There's not going to be a lot of magic to it.

81
00:04:26,400 --> 00:04:28,800
Pretty much everything you need to know you seen on handmade hero.

82
00:04:29,800 --> 00:04:35,700
So here you can kind of see us doing a bunch of operations on things

83
00:04:35,700 --> 00:04:38,500
that are lean and before these were defined as scalar, right?

84
00:04:38,500 --> 00:04:40,500
When we do Lane width equals 1, these are all scalars.

85
00:04:40,500 --> 00:04:40,900
So it

86
00:04:41,000 --> 00:04:45,200
An ex or that scalar, it does a shift with scalar Etc.

87
00:04:45,300 --> 00:04:47,900
We need to now change these into things that do the equivalent

88
00:04:47,900 --> 00:04:50,400
operations but that do them to all of the lanes.

89
00:04:50,600 --> 00:04:54,700
And so the way we're going to do that again is to use as I always say.

90
00:04:54,800 --> 00:04:58,100
There's only a few features of C++ that I actually use an operator

91
00:04:58,100 --> 00:05:00,800
overloading is one of them, we're going to use operator overloading to

92
00:05:00,800 --> 00:05:04,800
make it so that you can write this, it equation in a nice concise easy

93
00:05:04,800 --> 00:05:07,700
to read form, like it is right now that everyone could understand, but

94
00:05:07,700 --> 00:05:10,800
such that it can work on Lanes or not, depending on which way that

95
00:05:11,000 --> 00:05:12,100
Pound Define and goes.

96
00:05:12,300 --> 00:05:14,200
And so you can see us starting out with this here.

97
00:05:14,400 --> 00:05:18,000
What we need to do is we need to grab this equation, we need to bring

98
00:05:18,000 --> 00:05:21,900
it over into our lane definition here, where we've got our four wide

99
00:05:21,900 --> 00:05:25,900
Ops and we need to start taking a look at which ones we have so you

100
00:05:25,900 --> 00:05:26,500
can see here.

101
00:05:26,500 --> 00:05:28,200
We've got two of them, right?

102
00:05:28,400 --> 00:05:33,800
We've got an Annex or equals and we have a left shift at.

103
00:05:33,800 --> 00:05:36,900
These are both ones that we can Define ourselves.

104
00:05:37,100 --> 00:05:39,000
So if we have a lane youth or YouTube,

105
00:05:40,500 --> 00:05:44,600
That we want to do our shift to we can just take in whatever the

106
00:05:44,900 --> 00:05:48,900
actual Lane is that we're going to do and then we take in an immediate

107
00:05:48,900 --> 00:05:49,600
here right?

108
00:05:49,600 --> 00:05:52,300
Which is the shift amount, right?

109
00:05:52,700 --> 00:05:56,100
And I can put a u-32 in here, actually, let me go ahead and switch

110
00:05:56,100 --> 00:05:57,200
this over to the other side.

111
00:05:58,900 --> 00:05:59,800
I can put a u-32.

112
00:06:00,000 --> 00:06:05,500
Actually because shifts are not allowed to be - at least in x64.

113
00:06:05,500 --> 00:06:09,000
As far as I remember, you always have to shift by an immediate and

114
00:06:09,000 --> 00:06:10,600
that immediate have to be positive.

115
00:06:10,600 --> 00:06:14,300
So if you wanted to shift the other direction, you have to specify a

116
00:06:14,400 --> 00:06:17,000
positive shift in the other direction, not a negative shift in this

117
00:06:17,000 --> 00:06:17,400
Direction.

118
00:06:17,400 --> 00:06:20,500
That's just the way this chip is defined to work and how its

119
00:06:20,500 --> 00:06:21,400
instructions work.

120
00:06:22,800 --> 00:06:24,200
So we would be looking at an operator.

121
00:06:24,200 --> 00:06:25,500
That looks something like this.

122
00:06:26,300 --> 00:06:30,200
Where we now need to perform this shift amount on this Lane variable

123
00:06:30,200 --> 00:06:33,600
and you can see that we have this Lane variable here is designed such

124
00:06:33,600 --> 00:06:33,700
that.

125
00:06:33,700 --> 00:06:36,200
It has an M 128, i in it.

126
00:06:36,200 --> 00:06:39,200
And what we need to do is produce a result here, right?

127
00:06:39,500 --> 00:06:40,400
A result one of these.

128
00:06:40,400 --> 00:06:44,700
So we can say that the result value is going to equal the input value

129
00:06:45,200 --> 00:06:47,400
and, you know, something is going to happen here, but we don't know

130
00:06:47,400 --> 00:06:48,000
what.

131
00:06:48,200 --> 00:06:50,900
So, what we need to do again, is now start.

132
00:06:51,500 --> 00:06:52,200
As you remember Pope,

133
00:06:52,400 --> 00:06:53,000
From handmade here.

134
00:06:53,000 --> 00:06:54,500
Up start.

135
00:06:54,500 --> 00:06:57,800
Going back to our old friend, the Intel intrinsics guide.

136
00:06:59,600 --> 00:07:01,800
Because these men monix, you may remember.

137
00:07:01,800 --> 00:07:04,400
Some, like, I happen to remember the one for this.

138
00:07:05,300 --> 00:07:12,000
Like, I remember SLI and srl, I and these sorts of things, but if you

139
00:07:12,000 --> 00:07:13,200
don't happen to remember, that's okay.

140
00:07:13,200 --> 00:07:14,800
You don't need to remember any of these.

141
00:07:15,200 --> 00:07:18,500
The Intel in terms of God is like a very good piece of documentation

142
00:07:18,500 --> 00:07:21,900
until I don't know who was responsible for this but they did a very

143
00:07:21,900 --> 00:07:22,800
good job on it.

144
00:07:23,200 --> 00:07:28,700
So whoever put this up, thank you very much and until I should send

145
00:07:28,700 --> 00:07:28,900
Kim.

146
00:07:29,100 --> 00:07:31,600
After a note saying, whoever put this up was a very good person and

147
00:07:31,600 --> 00:07:32,900
hopefully they got a promotion.

148
00:07:34,000 --> 00:07:37,500
So anyway, what you want to do on this intentions, got again, if you

149
00:07:37,500 --> 00:07:39,500
have if you don't remember from handmade Heroes, you've got the

150
00:07:39,500 --> 00:07:44,500
Technologies on the side, these Technologies, they correspond to

151
00:07:44,500 --> 00:07:48,900
revisions of the instruction set for x86 and x64.

152
00:07:49,400 --> 00:07:55,000
And what we tend to Target is right in this area here, you could

153
00:07:55,000 --> 00:07:58,900
probably these days go all the way up to here even, but you probably,

154
00:07:59,000 --> 00:08:00,200
We wouldn't go past that.

155
00:08:00,200 --> 00:08:05,800
So when you start to require things like a VX or avx2 or heaven

156
00:08:05,800 --> 00:08:09,400
forbid, avx-512, you start to really limit the number of CPUs that

157
00:08:09,400 --> 00:08:10,400
something can be run on.

158
00:08:10,400 --> 00:08:11,600
That's out in the wild.

159
00:08:12,800 --> 00:08:14,900
Anything that's MX2 sse2.

160
00:08:15,400 --> 00:08:16,900
Pretty much anything.

161
00:08:16,900 --> 00:08:18,300
You're going to ship to a game.

162
00:08:18,700 --> 00:08:21,400
A gamer audience, which is what we focus on and made here are right

163
00:08:21,400 --> 00:08:25,500
people who play games on a PC or are using a console like a

164
00:08:25,500 --> 00:08:28,800
PlayStation 4 or an Xbox One.

165
00:08:29,500 --> 00:08:31,900
This is exactly what they've got in there, right?

166
00:08:31,900 --> 00:08:33,600
It's these, contests, these instructions.

167
00:08:34,500 --> 00:08:38,100
Once you go up here, you're still targeting any modern machine.

168
00:08:38,100 --> 00:08:43,200
Once you go up here, SSE 4.2 is certainly like an Xbox One or a pay

169
00:08:43,200 --> 00:08:46,200
station for have basically, you know, support for this kind of

170
00:08:46,200 --> 00:08:48,100
struction set, just fine.

171
00:08:48,400 --> 00:08:51,500
But you start to limit the number of PCS, there are some older PCS

172
00:08:51,500 --> 00:08:55,400
that won't have these instructions in them, so you're making a little

173
00:08:55,400 --> 00:08:56,200
bit more limited.

174
00:08:56,200 --> 00:08:59,000
Still not that much, you're talking with 10 20 % of PCS or not.

175
00:08:59,200 --> 00:08:59,900
You out there that?

176
00:09:00,000 --> 00:09:02,600
Probably playing games on once you get up into here.

177
00:09:02,600 --> 00:09:03,800
It's nice here, right?

178
00:09:03,800 --> 00:09:07,200
A lot of people who might play your games or might use your ray

179
00:09:07,200 --> 00:09:07,600
Tracer.

180
00:09:07,600 --> 00:09:10,000
In this case, they might not have these.

181
00:09:10,000 --> 00:09:12,900
So we're going to stay away from these in the lane for stuff.

182
00:09:14,600 --> 00:09:17,400
I think I'm going to stick have the lane for Stuff.

183
00:09:17,600 --> 00:09:20,500
Honestly, I'm just going to pick sse2 is the break point there.

184
00:09:20,700 --> 00:09:24,300
The reason for that is because we're going to do a lane 8 version the

185
00:09:24,300 --> 00:09:27,400
lane eight versions going to be the really, you know, the, the 8 wide

186
00:09:27,400 --> 00:09:28,500
one that will correct x 2.

187
00:09:28,800 --> 00:09:29,900
So I think we can safely say

188
00:09:30,000 --> 00:09:32,900
Say look if you're using the link for version, that's sort of the more

189
00:09:32,900 --> 00:09:35,400
Legacy path, that's only going to go up to us to see, to something to

190
00:09:35,400 --> 00:09:39,300
run on, just about any machine that still kicking, and then the avx2

191
00:09:40,600 --> 00:09:42,600
path, that does the the 8 wide.

192
00:09:42,600 --> 00:09:45,600
There's the one that will use all the instructions we've got at the

193
00:09:45,600 --> 00:09:48,500
moment and then some day in the future, we can even do the avx-512 on

194
00:09:48,500 --> 00:09:49,100
which would be yet.

195
00:09:49,100 --> 00:09:50,700
Another sort of bleeding edge 1.

196
00:09:51,000 --> 00:09:53,300
If I had a z on machine, we could even do that now.

197
00:09:53,400 --> 00:09:54,700
But I'm, you know, I don't

198
00:09:55,600 --> 00:09:56,000
Okay.

199
00:09:57,100 --> 00:10:02,900
So that's what we're doing here and let me just go ahead and sort of

200
00:10:03,300 --> 00:10:04,200
show you how this works.

201
00:10:04,400 --> 00:10:07,900
So I want to be able to shift this, you can actually just search for

202
00:10:07,900 --> 00:10:11,300
shift and it actually finds it in the description which is really

203
00:10:11,300 --> 00:10:11,500
nice.

204
00:10:11,500 --> 00:10:14,300
So if you didn't know what these instructions were going to be, you

205
00:10:14,300 --> 00:10:15,900
can start to see what they all are.

206
00:10:16,300 --> 00:10:21,000
We've got an M1 28i and we want to shift it by account SLL, right?

207
00:10:21,000 --> 00:10:22,800
And if you didn't know what these where you could just look in here.

208
00:10:22,800 --> 00:10:25,200
And it says you what it says to you, what it's going to be

209
00:10:25,800 --> 00:10:29,500
So, that's actually pretty easy, but just, I'll explain them here.

210
00:10:30,100 --> 00:10:36,900
These slls are a, it's a so on these are shift left, logical shift,

211
00:10:36,900 --> 00:10:37,500
right?

212
00:10:37,500 --> 00:10:39,700
Logical and shift, right arithmetic.

213
00:10:39,700 --> 00:10:42,700
And the reason that you have these sort of different

214
00:10:45,000 --> 00:10:50,000
for lack of a better term mnemonics for them is the shifting left is

215
00:10:50,000 --> 00:10:53,900
an unambiguous operation when you shift something left.

216
00:10:54,100 --> 00:10:57,000
There's only one thing that could possibly be meant by that, and that

217
00:10:57,000 --> 00:10:59,100
is to fill the other side with zeros really.

218
00:10:59,800 --> 00:11:01,200
There's no other possible thing.

219
00:11:01,200 --> 00:11:04,700
You might mean, however, when you shift, right?

220
00:11:04,700 --> 00:11:09,400
You're shifting down the B towards the lower end, right?

221
00:11:09,400 --> 00:11:09,900
You're shifting.

222
00:11:09,900 --> 00:11:11,700
Hi B towards low bits, right?

223
00:11:11,900 --> 00:11:13,600
And if a number is negative,

224
00:11:14,400 --> 00:11:17,000
It's going to be in two's complement which means the high B going to

225
00:11:17,000 --> 00:11:17,500
be set.

226
00:11:17,500 --> 00:11:23,000
If you were trying to emulate a mathematical operation by this shift.

227
00:11:23,000 --> 00:11:27,400
For example, if you are trying to divide by a power of 2, you would

228
00:11:27,400 --> 00:11:34,400
want to keep the - so what shift writes often have is they have a

229
00:11:34,400 --> 00:11:36,200
arithmetic and a logical version.

230
00:11:36,200 --> 00:11:40,400
The lot, The Logical version just moves the bits and put 0 in the end.

231
00:11:40,400 --> 00:11:44,200
So that would fill the top of zeros, the arithmetic version shifts.

232
00:11:44,200 --> 00:11:44,400
And

233
00:11:44,400 --> 00:11:49,400
Puts ones in the end and that keeps the sign of the value as it shifts

234
00:11:49,400 --> 00:11:50,400
across, right?

235
00:11:51,400 --> 00:11:53,300
We don't have any such concerns here.

236
00:11:54,100 --> 00:11:59,700
We are talking about a purely logical operation and this is on you 32.

237
00:11:59,700 --> 00:11:59,800
So

238
00:12:00,000 --> 00:12:01,000
Unsigned values.

239
00:12:01,500 --> 00:12:04,600
So for us, we don't care about that distinction but just so, you know,

240
00:12:04,600 --> 00:12:05,900
that's what's going on there.

241
00:12:06,600 --> 00:12:09,900
So we need to do two different kinds, there's our shift left, I

242
00:12:09,900 --> 00:12:12,000
believe we need to shift right as well.

243
00:12:12,500 --> 00:12:14,700
That's going to come up in a second here because there it is.

244
00:12:15,300 --> 00:12:17,100
So we really have two of these, right.

245
00:12:17,100 --> 00:12:21,500
We've got we've got two of these so we have to do a shift left in a

246
00:12:21,500 --> 00:12:22,300
shift, right?

247
00:12:22,300 --> 00:12:25,700
And in this case, what we want to do here is use those intrinsic.

248
00:12:25,700 --> 00:12:29,700
So here's the one that actually the I stands for immediate, so you can

249
00:12:29,700 --> 00:12:29,800
see

250
00:12:30,000 --> 00:12:31,900
Here, this takes a parameter for the count.

251
00:12:31,900 --> 00:12:37,200
This takes the immediate, the epi32 is the 32-bit value, sort of

252
00:12:37,200 --> 00:12:37,600
moniker.

253
00:12:37,600 --> 00:12:41,200
So it knows you're shifting four lanes of 32 bits, right?

254
00:12:41,300 --> 00:12:46,700
The epi16 would be eight Lanes of, of, of 16 bits.

255
00:12:47,100 --> 00:12:49,000
So, here is that intrinsic you want?

256
00:12:49,300 --> 00:12:51,600
It's MMS lli.

257
00:12:51,700 --> 00:12:52,200
Right?

258
00:12:52,800 --> 00:12:53,800
Epi32.

259
00:12:55,000 --> 00:12:59,100
And that shift left logical immediate here is the value.

260
00:12:59,100 --> 00:13:02,400
We're shifting by which is the value were shifting which is a.

261
00:13:02,500 --> 00:13:06,600
And here is the amount we're shifting by which is the shift there and

262
00:13:06,600 --> 00:13:09,000
here's that immediate that's being taken.

263
00:13:09,200 --> 00:13:11,900
Now it's taking a sign to mediate even though assigned immediate

264
00:13:11,900 --> 00:13:13,800
doesn't actually work as far as I know.

265
00:13:14,400 --> 00:13:16,700
So I think I don't know why they just decided to make it an instead of

266
00:13:16,700 --> 00:13:18,300
an unsigned that was just their choice.

267
00:13:18,400 --> 00:13:19,400
I couldn't tell you why.

268
00:13:20,200 --> 00:13:21,800
But anyway, that's all that's happening there.

269
00:13:21,800 --> 00:13:23,600
And the same exact thing will work here.

270
00:13:23,600 --> 00:13:24,600
So very, very simple.

271
00:13:25,400 --> 00:13:27,300
It's just rough shift, right?

272
00:13:27,300 --> 00:13:28,500
Logical immediate.

273
00:13:29,000 --> 00:13:31,000
And again, you don't even have to look that up because now, you know,

274
00:13:31,000 --> 00:13:34,300
how those mnemonics work, you can just know, oh, right?

275
00:13:34,300 --> 00:13:36,000
It's going to be shift, right?

276
00:13:36,000 --> 00:13:39,400
Logical immediate, and off you go and epi32.

277
00:13:39,400 --> 00:13:46,500
Again is saying, for 32-bit Lanes of of integers, so that's all we

278
00:13:46,500 --> 00:13:50,300
really need to do to implement those operator X or equals.

279
00:13:50,700 --> 00:13:52,300
We're going to need something else for it.

280
00:13:52,300 --> 00:13:53,400
That's the xor.

281
00:13:53,800 --> 00:13:54,800
And so we need something.

282
00:13:54,900 --> 00:13:56,600
Here, that will actually do an xor.

283
00:13:57,000 --> 00:13:59,600
And you can see here, there's a little it's a little bit different and

284
00:13:59,600 --> 00:14:01,100
you may be wondering why it's a little bit different.

285
00:14:01,100 --> 00:14:03,600
Again, if you don't remember, the hand of my hero episodes, this might

286
00:14:03,600 --> 00:14:04,900
be throwing you for a little bit of a loop here.

287
00:14:04,900 --> 00:14:05,700
What's going on?

288
00:14:06,600 --> 00:14:07,400
We were doing these.

289
00:14:07,400 --> 00:14:09,700
Epi instructions for the 32-bit Lanes.

290
00:14:09,700 --> 00:14:12,100
We're still trying to operate on 32-bit Lanes, if you want to do next

291
00:14:12,100 --> 00:14:17,200
or equals and yet we've sort of got this weird.

292
00:14:17,200 --> 00:14:21,000
This this wonky situation here, where there is no epi32.

293
00:14:21,000 --> 00:14:23,700
There's only an si128, what's going on with that?

294
00:14:24,200 --> 00:14:24,500
Well, the

295
00:14:24,800 --> 00:14:31,500
And for that is that unlike most operations that happen inside these

296
00:14:31,500 --> 00:14:36,200
Lanes in the processor and xor is bitwise.

297
00:14:36,200 --> 00:14:41,300
So, you know, adds subtracts, divides, multiplies shifts, all of these

298
00:14:41,300 --> 00:14:45,200
operations, they deal with more than one bit, right?

299
00:14:45,700 --> 00:14:49,300
A shift takes a bunch of bits and moves them to a whole nother set.

300
00:14:49,300 --> 00:14:53,300
So, you know, the bit in Lane 0 moves to the bit in Lane 3 or

301
00:14:53,300 --> 00:14:54,200
something like this, right?

302
00:14:54,200 --> 00:14:54,700
I should say Lane.

303
00:14:54,900 --> 00:14:58,100
The b in slot 0 in B 0 moves to B 3.

304
00:14:58,100 --> 00:14:58,500
Right.

305
00:14:58,500 --> 00:14:59,500
Whatever the value is.

306
00:15:00,900 --> 00:15:03,500
And all of those have to be clamped to the lanes, right?

307
00:15:03,500 --> 00:15:07,400
They have to be clamped to the area in which the lane is supposed to

308
00:15:07,400 --> 00:15:10,400
operate, because if you were trying to shift a 32-bit value that's

309
00:15:10,400 --> 00:15:14,900
packed in for, you know, for why'd you don't want one of the four wide

310
00:15:14,900 --> 00:15:17,400
Lanes shifting into the other Lane, right?

311
00:15:17,400 --> 00:15:19,400
You don't want that cross-contamination.

312
00:15:19,600 --> 00:15:23,400
So, you need to tell the processor by which instruction, you choose,

313
00:15:23,900 --> 00:15:28,800
you know, how to gasket up, is it 8:16 wide things and that's how

314
00:15:28,800 --> 00:15:29,900
we're, you know, clipping it.

315
00:15:30,300 --> 00:15:32,500
Is it 4:30 to why things?

316
00:15:32,500 --> 00:15:38,500
Is it to 64y things, but in bitwise operations xor, and or those sorts

317
00:15:38,500 --> 00:15:43,300
of things not, it's just doing an operation to every bit.

318
00:15:43,400 --> 00:15:45,000
So, the result would be the same.

319
00:15:45,000 --> 00:15:49,200
Whether you had 8-bit Lane, 16-bit lengths, 32-bit Lane 64-bit lanes,

320
00:15:49,200 --> 00:15:52,100
128-bit lanes, 256-bit lanes, 512-bit lanes.

321
00:15:52,700 --> 00:15:56,900
So basically, when you operate on a register type, using one of these

322
00:15:57,000 --> 00:15:57,700
operations.

323
00:15:57,700 --> 00:15:58,400
It's bitwise.

324
00:15:58,600 --> 00:16:00,000
You just operate the whole register at

325
00:16:00,300 --> 00:16:03,200
It doesn't need to know how you're trying to slice it up, because

326
00:16:03,200 --> 00:16:04,500
there is no difference.

327
00:16:04,500 --> 00:16:06,900
It would be the same no matter how you did it, so they just provide a

328
00:16:06,900 --> 00:16:09,100
single instruction to do it.

329
00:16:09,200 --> 00:16:11,600
Now, you may ask, why do they have these other ones here?

330
00:16:12,300 --> 00:16:14,900
And the answer is just because they did the stupid thing of having

331
00:16:14,900 --> 00:16:15,400
types.

332
00:16:15,700 --> 00:16:17,100
Having types in these sorts of things.

333
00:16:17,100 --> 00:16:20,000
The stupid, the processor doesn't have a difference, there's only one

334
00:16:20,000 --> 00:16:25,900
X or, but because they introduced M 128 D, which is the the the 64-bit

335
00:16:25,900 --> 00:16:26,200
ones.

336
00:16:27,100 --> 00:16:30,800
And 128, which is the 32-bit floats and m-28.

337
00:16:30,800 --> 00:16:35,200
I which is the integer registers they had to have different ones.

338
00:16:35,200 --> 00:16:37,900
So you didn't have to keep casting its really frustrating.

339
00:16:38,300 --> 00:16:41,000
So these should have all just been em 128 and they should have just

340
00:16:41,000 --> 00:16:43,000
had an MX or that's how the process actually works.

341
00:16:43,000 --> 00:16:48,300
But, you know, people love their crazy C++ typing going nuts, and

342
00:16:48,300 --> 00:16:50,700
someone told them that was a good idea once when they were in

343
00:16:50,700 --> 00:16:52,100
kindergarten and they never forgot.

344
00:16:52,200 --> 00:16:53,800
So anyway, here we go.

345
00:16:53,800 --> 00:16:56,800
We're going to use this X or here and we need to do an

346
00:16:57,000 --> 00:17:02,400
Operator x r equals my C++ days are long behind me.

347
00:17:02,400 --> 00:17:06,599
I don't ever do them anymore, and so one of the problems that I often

348
00:17:06,599 --> 00:17:09,700
have is I forget exactly how to declare an out of line, operator

349
00:17:09,700 --> 00:17:10,300
equals.

350
00:17:10,800 --> 00:17:12,000
I think you can do it.

351
00:17:12,000 --> 00:17:13,200
I just can't remember.

352
00:17:13,800 --> 00:17:17,700
I may be wrong about that but point being, we may have to make this a

353
00:17:17,700 --> 00:17:18,300
member function.

354
00:17:18,300 --> 00:17:20,400
That's the part that I don't remember whether they allow you to do it

355
00:17:20,400 --> 00:17:21,200
as a non-member function.

356
00:17:21,200 --> 00:17:23,599
Not if I were in charge, of course, you'll be able to but you know, I

357
00:17:23,599 --> 00:17:24,000
don't know.

358
00:17:24,400 --> 00:17:26,800
So anyway, what we need to do here is again

359
00:17:26,900 --> 00:17:29,200
Then exactly that same thing we were doing before.

360
00:17:31,200 --> 00:17:33,600
We're we're just going to take and this time instead of declaring the

361
00:17:33,600 --> 00:17:36,600
result was going to do it in place because again it's an xor equals.

362
00:17:37,200 --> 00:17:41,700
So what we want to do here is to an M xor of the si128, right?

363
00:17:41,700 --> 00:17:42,700
The whole register.

364
00:17:43,700 --> 00:17:47,300
And we're going to take the two values that we got past XR them

365
00:17:47,300 --> 00:17:50,900
together and overwrite the previous value of a with that because it's

366
00:17:50,900 --> 00:17:51,700
an operator equals.

367
00:17:51,700 --> 00:17:53,600
Now I'm going to compare that because I don't remember if you can

368
00:17:53,600 --> 00:17:56,600
actually do that, but I think you can and it does look like you in

369
00:17:56,600 --> 00:17:59,800
fact, can so that's really all

370
00:18:00,000 --> 00:18:01,100
All were doing today.

371
00:18:01,300 --> 00:18:04,400
This is all we have to do is just go through and it's a little bit

372
00:18:04,400 --> 00:18:04,900
laborious.

373
00:18:04,900 --> 00:18:07,700
But as you can see, once you do this, once you could reread could

374
00:18:07,700 --> 00:18:09,200
reuse this as a library, right?

375
00:18:09,200 --> 00:18:10,300
You don't have to write it.

376
00:18:10,300 --> 00:18:13,500
Every time, once you get one of these, that works the way you want and

377
00:18:13,500 --> 00:18:16,600
that you're comfortable with, you can use these lean, F32 Lane, you

378
00:18:16,600 --> 00:18:18,900
three, Tulane v3's anywhere you want.

379
00:18:18,900 --> 00:18:24,200
Just like we use our vectors and stuff like V3 is regularly.

380
00:18:24,400 --> 00:18:25,300
You can reuse these.

381
00:18:25,300 --> 00:18:27,200
So that's one of the nice things about this is.

382
00:18:27,200 --> 00:18:29,900
Yeah, it's kind of some busy work here to write this but

383
00:18:30,000 --> 00:18:33,300
But once you've got one that you like, you don't have to fuss with it

384
00:18:33,300 --> 00:18:34,100
ever again.

385
00:18:34,100 --> 00:18:36,500
If you can find someone's out there on the internet that you like as

386
00:18:36,500 --> 00:18:39,700
well, then you could just use that and be fine as long as you know how

387
00:18:39,700 --> 00:18:42,800
it works and you're happy with it and it's not doing anything

388
00:18:42,800 --> 00:18:43,500
deleterious.

389
00:18:43,800 --> 00:18:45,400
So let's keep going here.

390
00:18:45,400 --> 00:18:47,200
We've got Lane F32 from you 32.

391
00:18:47,200 --> 00:18:50,000
And what that is is you can see is we're going to be taking some

392
00:18:50,000 --> 00:18:53,800
things here where we've got integer values and we want to load them

393
00:18:53,800 --> 00:18:54,900
in, right?

394
00:18:55,300 --> 00:18:58,900
So in this case we want to return Elaine F32 but we're getting a lame,

395
00:18:58,900 --> 00:18:59,700
you 32.

396
00:19:00,100 --> 00:19:00,500
Right?

397
00:19:00,600 --> 00:19:01,700
And we need to convert them.

398
00:19:02,300 --> 00:19:07,100
So here we want an egg-laying, F32 result value, and that result value

399
00:19:07,100 --> 00:19:08,400
is going to have to in

400
00:19:10,000 --> 00:19:12,100
Should I put it?

401
00:19:12,100 --> 00:19:13,300
It's got a load right?

402
00:19:13,300 --> 00:19:15,400
It's got its got to do a conversion, right?

403
00:19:15,400 --> 00:19:20,700
And in this case it's go ahead and and show you another thing to do

404
00:19:20,700 --> 00:19:20,800
here.

405
00:19:20,800 --> 00:19:24,000
In this case, it's kind of note hard to know what to search for a

406
00:19:24,000 --> 00:19:24,300
right?

407
00:19:24,300 --> 00:19:25,300
Like convert.

408
00:19:25,300 --> 00:19:28,400
Maybe would be one of them, but it's kind of a little bit, you know,

409
00:19:28,400 --> 00:19:29,400
maybe you don't know here.

410
00:19:29,400 --> 00:19:32,500
So if you're kind of confused about where these sorts of things would

411
00:19:32,500 --> 00:19:34,600
be the other nice thing about the intrinsic guide, right?

412
00:19:34,600 --> 00:19:39,100
Is you can find them in here and they're categorized under things so

413
00:19:39,100 --> 00:19:39,700
you can actually

414
00:19:40,000 --> 00:19:44,700
Kind of see what's available for various different kinds of things,

415
00:19:45,000 --> 00:19:45,400
right?

416
00:19:46,900 --> 00:19:48,900
So if you just want conversion instructions, you can look at

417
00:19:48,900 --> 00:19:49,800
conversion instructions here.

418
00:19:49,800 --> 00:19:51,800
And the other thing you could do is scan really quickly.

419
00:19:52,100 --> 00:19:58,000
You know that the epi32 is the 32-bit wide integers and PS is 32-bit

420
00:19:58,000 --> 00:20:00,600
wide floats, right pack scalars with that.

421
00:20:00,600 --> 00:20:04,100
Stands for epi32 is packed.

422
00:20:04,100 --> 00:20:05,200
Integer 32.

423
00:20:05,400 --> 00:20:08,100
I don't know what the key is though.

424
00:20:10,000 --> 00:20:11,100
Extended.

425
00:20:11,300 --> 00:20:13,000
What does the E stand for?

426
00:20:16,000 --> 00:20:17,100
You know, I don't really know.

427
00:20:18,400 --> 00:20:19,800
I I don't know.

428
00:20:20,400 --> 00:20:22,000
Yeah, I'm sure it says somewhere.

429
00:20:25,400 --> 00:20:26,100
But I do remember.

430
00:20:27,500 --> 00:20:30,500
So anyway, what we want to do here is we want to convert

431
00:20:32,200 --> 00:20:36,200
We want to be able to convert in between these pack integers and

432
00:20:36,200 --> 00:20:36,800
packed.

433
00:20:37,700 --> 00:20:41,500
We won't be able to convert between packagers and packed floats and

434
00:20:41,500 --> 00:20:42,900
probably vice versa as well.

435
00:20:42,900 --> 00:20:43,100
Right?

436
00:20:43,100 --> 00:20:44,500
Look, we want both of those two things.

437
00:20:45,700 --> 00:20:49,500
So what we're looking for here is something like it's going to return

438
00:20:49,500 --> 00:20:53,100
an M1 28 and take it in 128 I and vice versa, right?

439
00:20:53,100 --> 00:20:54,200
That's just what we want.

440
00:20:54,200 --> 00:20:58,800
So you can see here convert epi32 PS, that takes an integer in and

441
00:20:58,800 --> 00:20:59,500
returns.

442
00:21:00,000 --> 00:21:01,100
Load out, right?

443
00:21:01,100 --> 00:21:03,000
And that's exactly what we wanted here.

444
00:21:03,600 --> 00:21:07,700
And you can see that the name is exactly what respect to the PS.

445
00:21:07,700 --> 00:21:13,200
It returns a floating packed packed scalars, it takes epi32 convert

446
00:21:13,200 --> 00:21:14,900
those to pack scalars, right?

447
00:21:14,900 --> 00:21:17,000
So you can kind of see that the name actually says it as well.

448
00:21:18,100 --> 00:21:20,600
Anyway, and remember this is different than casting.

449
00:21:20,600 --> 00:21:22,500
We're not casting were actually converting here.

450
00:21:22,600 --> 00:21:26,700
We're not, we're not changing the interpretation of the bits into

451
00:21:26,700 --> 00:21:28,000
floating point from integer.

452
00:21:28,700 --> 00:21:29,500
It's got a cast.

453
00:21:29,500 --> 00:21:29,800
Its

454
00:21:30,000 --> 00:21:30,700
Actual conversion.

455
00:21:30,700 --> 00:21:33,700
So it's actually taking integers converting them to floating quick

456
00:21:33,700 --> 00:21:35,200
format and putting them in the register.

457
00:21:35,200 --> 00:21:36,600
So you know, that's important to remember.

458
00:21:36,600 --> 00:21:37,900
Those are two different operations.

459
00:21:37,900 --> 00:21:40,100
There one is take an existing pattern of bits.

460
00:21:40,100 --> 00:21:43,300
Start interpreting it as an integer or certain touring is a quote in

461
00:21:43,300 --> 00:21:46,600
this interaction talk about take the integer and create the float.

462
00:21:46,600 --> 00:21:49,600
That means the same thing as this integer by putting that into the

463
00:21:49,600 --> 00:21:52,200
mantissa and setting the exponent correctly and whatever, right?

464
00:21:54,400 --> 00:21:56,900
So we need to do convert a pi32 PS here.

465
00:21:57,700 --> 00:22:00,300
And by the way, I don't remember most of these intrinsics when I'm not

466
00:22:00,300 --> 00:22:02,200
actively programming, they kind of flush out.

467
00:22:02,200 --> 00:22:04,500
And I look them up like this every time as well.

468
00:22:04,800 --> 00:22:08,200
Sometimes I remember some of them and sometimes, I don't when I'm

469
00:22:08,200 --> 00:22:10,200
actively doing a bunch of work with them, they tend to stick in my

470
00:22:10,200 --> 00:22:12,000
head but after that not so much.

471
00:22:12,800 --> 00:22:14,600
So anyway, that's what we want to do here.

472
00:22:14,600 --> 00:22:15,700
And that will convert this for us.

473
00:22:15,700 --> 00:22:19,900
So we can take our lane u-32 here and convert it to our land F32.

474
00:22:19,900 --> 00:22:20,600
And that's

475
00:22:22,000 --> 00:22:25,600
really all we need to do cannot convert.

476
00:22:25,600 --> 00:22:26,400
What does it say?

477
00:22:27,000 --> 00:22:28,100
Can I cover argument?

478
00:22:28,100 --> 00:22:30,600
One from you 3D to Tulane.

479
00:22:30,600 --> 00:22:32,100
You 32.

480
00:22:38,200 --> 00:22:39,200
Here it is right here.

481
00:22:41,100 --> 00:22:43,200
So this is something that we probably want to be able to do for

482
00:22:43,200 --> 00:22:43,800
shorthand.

483
00:22:44,000 --> 00:22:46,600
You can see here that I've done laying after you to from you 30 and I

484
00:22:46,600 --> 00:22:47,900
just put a constant in here.

485
00:22:48,200 --> 00:22:50,600
We probably want to support that, right?

486
00:22:51,300 --> 00:22:54,400
We want to support that because sometimes we're going to just want to

487
00:22:54,400 --> 00:22:56,700
replicate a constant across all the lanes.

488
00:22:56,900 --> 00:22:59,100
And so that's exactly what I've done here, right?

489
00:22:59,400 --> 00:23:03,100
So here's like a replication value and if I want to create one of

490
00:23:03,100 --> 00:23:05,500
these, there's actually a function specifically for that.

491
00:23:08,100 --> 00:23:09,100
It's called Step 1.

492
00:23:12,300 --> 00:23:15,500
And if I pass it a single value there, you can see in the intrinsics

493
00:23:15,500 --> 00:23:18,700
guide, let me go ahead and do M&M's at once you can see it.

494
00:23:21,100 --> 00:23:24,600
You can see set one epi32 that would take an integer and replicate the

495
00:23:24,600 --> 00:23:26,900
integer across all four lanes set one.

496
00:23:26,900 --> 00:23:30,500
PSL take a floating-point fire up that it again against I all four

497
00:23:30,500 --> 00:23:30,900
lanes.

498
00:23:31,200 --> 00:23:36,000
And so that's all I'm trying to do is take this constant and Loft it

499
00:23:36,000 --> 00:23:37,200
up into four wide.

500
00:23:37,200 --> 00:23:38,400
So there's a copy of it everywhere.

501
00:23:38,400 --> 00:23:41,700
Because again, we have for actual values that are being exercised

502
00:23:41,700 --> 00:23:44,300
here, we want to divide all of them by the same value.

503
00:23:44,300 --> 00:23:45,000
That's a scalar.

504
00:23:45,300 --> 00:23:46,900
And so that's what that's happening here.

505
00:23:47,000 --> 00:23:48,900
Right now, we could do something else.

506
00:23:48,900 --> 00:23:50,200
There, we could just try to do

507
00:23:50,300 --> 00:23:53,400
Thing else if we didn't want to do that kind of upconversion, we could

508
00:23:53,400 --> 00:23:55,800
also make that up conversion, sort of semi implicit.

509
00:23:55,900 --> 00:23:56,800
Let's go ahead and do that.

510
00:23:56,800 --> 00:23:57,600
Now, just for fun.

511
00:23:57,800 --> 00:23:59,100
If we actually just said

512
00:24:00,400 --> 00:24:01,300
Something like this.

513
00:24:01,400 --> 00:24:04,000
Like we would normally do cast this to a floating point value and then

514
00:24:04,000 --> 00:24:07,100
divided we could also just have that are out on.

515
00:24:07,300 --> 00:24:07,900
We don't

516
00:24:10,100 --> 00:24:11,600
What is what?

517
00:24:11,600 --> 00:24:12,600
What are you saying?

518
00:24:12,600 --> 00:24:12,900
Mmm.

519
00:24:13,200 --> 00:24:13,900
Oh whoops.

520
00:24:16,700 --> 00:24:18,200
This has to have the actual casting it.

521
00:24:18,200 --> 00:24:22,300
Yeah, we would just get an error that would tell us that we didn't

522
00:24:22,300 --> 00:24:24,700
have a operator divided.

523
00:24:24,800 --> 00:24:27,800
And so, all we have to do then is produce that operator divided,

524
00:24:27,800 --> 00:24:28,200
right?

525
00:24:28,200 --> 00:24:32,800
So much, like we did the operator shift, here we would just make one

526
00:24:32,800 --> 00:24:38,100
of these for F32 s like so that takes a divided value.

527
00:24:40,600 --> 00:24:42,800
What's up in order to do this again?

528
00:24:42,800 --> 00:24:45,300
All we need to do is have an instruction that's going to do this,

529
00:24:45,500 --> 00:24:45,700
right?

530
00:24:45,700 --> 00:24:49,100
So we it it happens to be that all of the the floating Point numbers

531
00:24:49,100 --> 00:24:49,900
are pretty easy to understand.

532
00:24:49,900 --> 00:24:52,400
They're just mmv operation name and then PS.

533
00:24:52,500 --> 00:24:55,500
So like div Mall add sub, right?

534
00:24:56,300 --> 00:24:58,000
I'll bring them up here just so you can see them.

535
00:25:01,500 --> 00:25:02,700
Here's GPS, right?

536
00:25:02,700 --> 00:25:03,500
Just takes one thing.

537
00:25:03,500 --> 00:25:04,700
Divides by another thing.

538
00:25:05,000 --> 00:25:07,300
And what you can see here is, this has to be a wide value, right?

539
00:25:07,300 --> 00:25:10,800
So, it's a lane F, 32 divided by another Lane F32, right?

540
00:25:11,500 --> 00:25:14,000
But in this case, we know that we don't have one.

541
00:25:14,400 --> 00:25:15,000
That's okay.

542
00:25:15,000 --> 00:25:18,400
Because again, just like we were doing here, we can just do a set 1,

543
00:25:18,400 --> 00:25:22,200
PS to get that value, Loft it up and then do the divide and it's that

544
00:25:22,200 --> 00:25:22,800
simple, right?

545
00:25:22,800 --> 00:25:23,700
Not much to it.

546
00:25:24,600 --> 00:25:24,900
Okay.

547
00:25:27,000 --> 00:25:32,900
Now what's worth noting here is in some cases, these things can come

548
00:25:32,900 --> 00:25:34,200
out to be duplicated.

549
00:25:34,300 --> 00:25:39,000
So if you look at what we've got the set 1, PS in this case is

550
00:25:39,000 --> 00:25:40,200
duplicated in two places, right?

551
00:25:40,200 --> 00:25:44,200
We've got it here and here and this divided you know you can see this

552
00:25:44,400 --> 00:25:46,300
being a thing that would happen again, right?

553
00:25:46,300 --> 00:25:50,000
If we had a divided here we had an A and A B and we wanted to do a

554
00:25:50,000 --> 00:25:50,900
wide divide.

555
00:25:50,900 --> 00:25:54,400
So each lane divided separately, what we would write.

556
00:25:54,400 --> 00:25:56,000
And we probably want to have this, right?

557
00:25:56,000 --> 00:25:56,500
So that we can

558
00:25:56,800 --> 00:25:59,700
Divides, it would do a and b.

559
00:26:01,700 --> 00:26:02,300
Like this, right?

560
00:26:02,300 --> 00:26:06,000
We would divide in the exact way that it's written here, and

561
00:26:06,000 --> 00:26:06,900
everything would be fine.

562
00:26:07,100 --> 00:26:07,800
What that means is.

563
00:26:07,800 --> 00:26:10,800
If you look at this operator here, this operator /.

564
00:26:11,200 --> 00:26:14,600
It's actually very redundant because what we could have written

565
00:26:14,600 --> 00:26:19,300
instead is we could have written a v divided by laying F32 from u-32

566
00:26:19,300 --> 00:26:20,000
divisor.

567
00:26:21,100 --> 00:26:21,600
Right?

568
00:26:22,600 --> 00:26:25,500
Because we know that both of these two things are defined.

569
00:26:25,500 --> 00:26:28,700
We don't actually need to ever know what we're working with here.

570
00:26:29,000 --> 00:26:30,100
Why do I point this out?

571
00:26:30,100 --> 00:26:33,900
Well, I point this out because we could move this down to the bottom.

572
00:26:35,600 --> 00:26:42,400
like so and basically any time we don't have a scalar Lane so

573
00:26:42,400 --> 00:26:47,300
basically if the lane width is not equal to 1,

574
00:26:49,400 --> 00:26:50,000
Right.

575
00:26:50,300 --> 00:26:53,900
So we know we're dealing with some kind of Ops, then we can just put

576
00:26:53,900 --> 00:26:58,000
all of our generic things in here and now that we know that these will

577
00:26:58,000 --> 00:26:59,800
both happen in person went to the

578
00:27:00,000 --> 00:27:01,000
Clean things up here.

579
00:27:02,600 --> 00:27:07,900
It means that we don't have to worry anymore about.

580
00:27:08,100 --> 00:27:08,700
Did I just

581
00:27:10,300 --> 00:27:10,800
that's right.

582
00:27:10,800 --> 00:27:11,200
I was looking for.

583
00:27:11,200 --> 00:27:14,100
I think it means that we don't have to worry about implementing this

584
00:27:14,100 --> 00:27:17,700
divided for each of our lane, with 416 8 and 4.

585
00:27:17,700 --> 00:27:20,800
It can always be just this one function because it's basically using

586
00:27:20,800 --> 00:27:23,600
the two functions that were defined in those Lane with, right.

587
00:27:23,800 --> 00:27:26,600
So that will cut down on the amount of duplication that we have to do

588
00:27:26,800 --> 00:27:29,400
so that we won't have to do as many things.

589
00:27:30,800 --> 00:27:33,500
The same thing can happen with some of these operations here.

590
00:27:33,700 --> 00:27:38,200
Let's say we took this and said, okay, here's the operator xor.

591
00:27:43,100 --> 00:27:47,700
And the operator X or is just going to do the lanyard that you 32

592
00:27:47,700 --> 00:27:48,300
result.

593
00:27:48,300 --> 00:27:56,600
It's going to be result V MMX or si128 a.vb .v return result.

594
00:27:56,600 --> 00:27:57,000
Right?

595
00:27:57,000 --> 00:28:02,900
If I do that, I can then take this operator, this stuff here, right?

596
00:28:02,900 --> 00:28:05,500
Where I'm doing the the xor equals.

597
00:28:05,500 --> 00:28:07,400
I can just change that to be.

598
00:28:07,400 --> 00:28:12,200
Well if I want to do x 4 equals, I know I can just do a VX or BV like

599
00:28:12,200 --> 00:28:13,100
so and

600
00:28:13,200 --> 00:28:16,800
It will go find the right thing that takes this out of the knowledge,

601
00:28:16,900 --> 00:28:18,800
having to have the knowledge of which one is working with.

602
00:28:18,900 --> 00:28:22,200
So again, it can come down here and be kind of generic relative to

603
00:28:22,200 --> 00:28:23,000
those definitions.

604
00:28:24,500 --> 00:28:24,900
Right?

605
00:28:25,700 --> 00:28:30,000
So all of our functions that work that way can happen basically like

606
00:28:30,000 --> 00:28:30,300
this.

607
00:28:30,400 --> 00:28:32,500
You can imagine, it's just doing them all here, right?

608
00:28:32,600 --> 00:28:35,400
So you could do a plus equals, right?

609
00:28:36,800 --> 00:28:37,900
- equals.

610
00:28:40,300 --> 00:28:41,500
X equals.

611
00:28:44,600 --> 00:28:47,100
Divide equals and all of those.

612
00:28:47,100 --> 00:28:48,100
Now, we'll just work.

613
00:28:48,200 --> 00:28:49,600
Same with these guys, right?

614
00:28:49,600 --> 00:28:55,600
We could do and equals or equals, right?

615
00:28:59,600 --> 00:29:01,100
Any of the things that we might need?

616
00:29:01,100 --> 00:29:05,200
I think we've got all the equals is that we've every would use

617
00:29:06,800 --> 00:29:10,200
Divide Ranch, I mean I guess the shifts but we don't really need

618
00:29:10,200 --> 00:29:10,500
those.

619
00:29:12,100 --> 00:29:12,600
so,

620
00:29:14,700 --> 00:29:15,200
Excuse me.

621
00:29:16,100 --> 00:29:18,000
So that's really all there is to that, right?

622
00:29:18,100 --> 00:29:21,400
And similarly, you know, these things can be reversed.

623
00:29:24,600 --> 00:29:25,100
As well.

624
00:29:25,700 --> 00:29:27,000
So if we wanted to put

625
00:29:28,700 --> 00:29:29,800
Something like this in there.

626
00:29:31,400 --> 00:29:35,000
And you know, I maybe should just keep it the correct naming scheme

627
00:29:35,000 --> 00:29:35,300
here.

628
00:29:44,800 --> 00:29:45,300
Right.

629
00:29:45,900 --> 00:29:48,300
So if we want to, we can also flip the orientation.

630
00:29:48,300 --> 00:29:50,200
So we can do a divide in either direction.

631
00:29:50,200 --> 00:29:55,800
By a scalar, like a scalar /, a multi-lane and a multi-lane divided by

632
00:29:55,800 --> 00:29:57,600
a scalar, both of those would work.

633
00:29:58,400 --> 00:29:59,700
And again, we don't have to write any new.

634
00:30:00,000 --> 00:30:00,800
Pearline with.

635
00:30:01,000 --> 00:30:05,000
So we can just Define all of these here once and then they multiply

636
00:30:05,400 --> 00:30:07,700
they sort of distribute over all of those.

637
00:30:08,100 --> 00:30:12,100
Again, same thing with with basically all of our operators, if we want

638
00:30:12,100 --> 00:30:16,400
to do an operator plus the same way, again, it's pretty much the same

639
00:30:16,400 --> 00:30:16,900
thing.

640
00:30:17,300 --> 00:30:18,900
Nothing weird happening here, right?

641
00:30:18,900 --> 00:30:22,800
It's just pluses and then same thing with minuses

642
00:30:26,500 --> 00:30:27,000
Right.

643
00:30:29,100 --> 00:30:31,500
And finally times.

644
00:30:38,600 --> 00:30:43,600
And so all of those things again with just kind of worked as fine and

645
00:30:43,600 --> 00:30:48,300
in this case it looks like these are these are F32 so we can get rid

646
00:30:48,300 --> 00:30:50,100
of this part as well, right?

647
00:30:50,300 --> 00:30:54,500
The if everything's an F32, then it nope.

648
00:30:54,500 --> 00:30:55,900
Sorry, that's not what I meant to do.

649
00:30:59,700 --> 00:31:03,600
We just need to Loft up an F32 instead of a u-32.

650
00:31:03,800 --> 00:31:06,700
So we just need some equivalent of that.

651
00:31:06,700 --> 00:31:07,700
You 32 1?

652
00:31:11,500 --> 00:31:15,800
For loading things that are F instead of instead of you, right?

653
00:31:16,200 --> 00:31:16,600
Yeah.

654
00:31:17,500 --> 00:31:19,300
So that's it, right?

655
00:31:20,000 --> 00:31:22,400
That's really all we need to do and we have both of these

656
00:31:31,800 --> 00:31:34,100
I'm in the wrong set of functions here.

657
00:31:35,200 --> 00:31:38,200
Yeah, sorry, I lost it there for a second.

658
00:31:38,400 --> 00:31:38,800
There it is.

659
00:31:40,200 --> 00:31:41,500
Should I put these into different files?

660
00:31:45,100 --> 00:31:48,900
So in this case right we've got one that casts this way when the cast

661
00:31:48,900 --> 00:31:50,800
that way we just need one here.

662
00:31:50,800 --> 00:31:54,400
That's going to I shouldn't say cast converts one that converts this

663
00:31:54,400 --> 00:31:54,800
way.

664
00:31:56,200 --> 00:31:59,500
Like so, and I think that's everything we really needed.

665
00:32:00,100 --> 00:32:01,700
Now in this case.

666
00:32:02,400 --> 00:32:04,000
Oops, got to take actual F32 there.

667
00:32:05,000 --> 00:32:07,300
In this case, we still have a bunch of operations.

668
00:32:07,300 --> 00:32:10,100
We haven't actually defined though, like, plus and minus, and divide

669
00:32:10,100 --> 00:32:11,000
in those sorts of things.

670
00:32:11,500 --> 00:32:13,900
So, we just need to find those operations.

671
00:32:13,900 --> 00:32:15,100
Just like, we defined everything else.

672
00:32:15,100 --> 00:32:17,200
So, like, we've got our operator / here.

673
00:32:17,700 --> 00:32:21,600
Let me just make one of those for each of our operations for add,

674
00:32:21,600 --> 00:32:22,000
right?

675
00:32:22,000 --> 00:32:24,300
We just have an ad for sub.

676
00:32:24,300 --> 00:32:25,900
We've got a sub and again, you can

677
00:32:26,100 --> 00:32:28,600
Please let me introduce this guy, but they're really just exactly what

678
00:32:28,600 --> 00:32:34,000
you expect floating-point versions of add subtract multiply and

679
00:32:34,000 --> 00:32:35,000
divide, right?

680
00:32:35,000 --> 00:32:35,600
And that's it.

681
00:32:36,700 --> 00:32:39,700
So, let's see what else we got here.

682
00:32:44,000 --> 00:32:44,900
No operator.

683
00:32:44,900 --> 00:32:47,400
Which takes a left hand?

684
00:32:47,600 --> 00:32:48,600
Oh, right?

685
00:32:48,800 --> 00:32:51,100
These all want to stay as their types.

686
00:32:51,100 --> 00:32:54,000
They don't want to actually pull out the V anymore.

687
00:32:54,600 --> 00:32:55,200
That's my bad.

688
00:32:55,200 --> 00:32:55,600
Sorry.

689
00:33:01,300 --> 00:33:01,800
Here we go.

690
00:33:15,000 --> 00:33:15,600
There we go.

691
00:33:19,000 --> 00:33:25,700
And so no particular right-hand Lane F32 there should be.

692
00:33:25,700 --> 00:33:29,700
Now an operator + 4.

693
00:33:31,200 --> 00:33:32,600
That's all we really need there, right?

694
00:33:33,000 --> 00:33:33,300
Yeah.

695
00:33:33,500 --> 00:33:34,700
Again got to get rid of these.

696
00:33:35,000 --> 00:33:36,300
In fact, I could just make this

697
00:33:38,100 --> 00:33:38,900
redirect now,

698
00:33:44,000 --> 00:33:44,900
if these a lot cleaner,

699
00:33:47,000 --> 00:33:47,500
there we go.

700
00:33:53,100 --> 00:33:58,800
And this is one case also, where a lot of people on Hammer hero, ask

701
00:33:58,800 --> 00:34:01,200
me all the time about unit testing.

702
00:34:01,300 --> 00:34:04,700
I don't know why everyone asked me about unit testing all the time.

703
00:34:05,600 --> 00:34:08,900
It's one of like the least relevant things in programming and relative

704
00:34:08,900 --> 00:34:10,300
to the number of questions I get.

705
00:34:11,000 --> 00:34:14,900
But this would be a case where if you were planning, if you're making

706
00:34:14,900 --> 00:34:16,600
one of these and you want to use it.

707
00:34:16,600 --> 00:34:19,800
A lot unit, testing is not a bad idea, right?

708
00:34:20,000 --> 00:34:21,199
Because, you know, you're going to

709
00:34:21,400 --> 00:34:24,100
Right this Library once and you're going to use it for everything.

710
00:34:24,300 --> 00:34:26,199
You could write a series of math tests.

711
00:34:26,400 --> 00:34:29,400
That verify that it's doing something reasonable, right?

712
00:34:31,100 --> 00:34:33,699
You know, exactly what the inputs are supposed to be.

713
00:34:33,699 --> 00:34:35,800
It's math, it's floating point.

714
00:34:35,800 --> 00:34:39,900
It's rigorously defined, you can easily write a sort of unit test.

715
00:34:40,100 --> 00:34:44,100
That make sure that what you're doing makes sense, right?

716
00:34:45,000 --> 00:34:50,100
And so, you know, that's just something to think about there, all

717
00:34:50,100 --> 00:34:50,500
right?

718
00:34:50,900 --> 00:34:51,300
So

719
00:34:51,400 --> 00:34:51,600
Way.

720
00:34:51,800 --> 00:34:53,800
Let's take a look at which ones I defined here.

721
00:34:53,800 --> 00:34:55,199
So we yeah.

722
00:34:55,199 --> 00:35:00,200
We've got a bunch of sort of Ops here, the integer Ops.

723
00:35:00,200 --> 00:35:02,200
I don't think we really care about that much.

724
00:35:02,200 --> 00:35:04,100
So, really, honestly, these should be

725
00:35:06,800 --> 00:35:09,000
These should really be defined for the f30 twos.

726
00:35:12,900 --> 00:35:15,000
Because we're not going to be dividing integers and stuff.

727
00:35:15,000 --> 00:35:18,100
So I think I really want these to only BF3 Jews

728
00:35:20,700 --> 00:35:26,800
All right, so and that means they return if ages.

729
00:35:27,800 --> 00:35:30,600
So all we're going to do now is just go through and fill out all of

730
00:35:30,600 --> 00:35:32,400
the ones of these that we needed.

731
00:35:40,100 --> 00:35:43,800
Did I accidentally do it for carrot?

732
00:35:43,800 --> 00:35:44,700
Where is carrot?

733
00:35:56,700 --> 00:35:57,100
Here we go.

734
00:36:00,000 --> 00:36:02,800
Specifically, those little like clumsy areas like the one I just

735
00:36:02,800 --> 00:36:06,300
corrected there where you know it was missing the 14 karat was labeled

736
00:36:06,300 --> 00:36:10,500
and or whatever else right that's exactly what you would.

737
00:36:10,600 --> 00:36:17,300
Hopefully catch in a in a situation where you wrote some unit testing

738
00:36:17,300 --> 00:36:19,900
right you just and it's worth doing because you know you're going to

739
00:36:19,900 --> 00:36:23,800
reuse this a bunch of times and so presumably it's all good.

740
00:36:23,900 --> 00:36:24,200
Okay?

741
00:36:26,000 --> 00:36:27,300
Like you're not wasting your time.

742
00:36:27,300 --> 00:36:30,900
Looking for bugs that aren't really hard to find or whatever, and it's

743
00:36:30,900 --> 00:36:32,500
good to be able to trust your math Library.

744
00:36:32,500 --> 00:36:36,200
So putting some extra testing, they're usually a good idea anyway.

745
00:36:36,600 --> 00:36:40,400
So let me go ahead and Define the rest of these binary operators as

746
00:36:40,400 --> 00:36:40,800
well.

747
00:36:40,800 --> 00:36:43,900
Let's get an and let's get an or right.

748
00:36:44,800 --> 00:36:47,600
These are literally the exact thing you would think.

749
00:36:49,700 --> 00:36:50,900
And that's really about it.

750
00:36:51,800 --> 00:36:55,500
So now we just have to go ahead and finish up the rest of this stuff

751
00:36:55,500 --> 00:36:56,700
and make sure it works properly.

752
00:36:56,900 --> 00:36:59,700
It looks like random bilateral supposed to return an F32 and never

753
00:36:59,700 --> 00:37:00,100
did.

754
00:37:00,100 --> 00:37:02,600
And that just in the scalar version worked because they were defined

755
00:37:02,600 --> 00:37:05,900
to be the same in here.

756
00:37:05,900 --> 00:37:11,200
We've got, we've, we're initializing these with values that come from

757
00:37:11,200 --> 00:37:12,000
single scalars.

758
00:37:12,300 --> 00:37:17,700
I think if I'm not mistaken, we can add some ways to automatically

759
00:37:17,700 --> 00:37:19,100
convert those together.

760
00:37:19,400 --> 00:37:23,800
I don't know if operator equals will actually work.

761
00:37:26,300 --> 00:37:28,600
Here, I'm going to try it again.

762
00:37:28,600 --> 00:37:33,100
This is my haven't programmed to C++ but much in a long time, so it's

763
00:37:33,100 --> 00:37:35,300
a little bit tough for me, to remember, Sometimes some of these

764
00:37:35,300 --> 00:37:38,900
things, but I think we can just do something like this.

765
00:37:42,400 --> 00:37:46,600
and I think during construction it will pick that up but you may not

766
00:37:46,600 --> 00:37:48,800
be able to use operate equals during construction like this, it may be

767
00:37:48,800 --> 00:37:53,800
that you have to do an actual Constructor again, these sorts of

768
00:37:53,800 --> 00:37:54,400
things, very

769
00:37:57,600 --> 00:38:00,400
okay, so in this case, we know we've got an A

770
00:38:01,800 --> 00:38:07,400
I think we can just do a thing where we do a equals lane from you,

771
00:38:07,400 --> 00:38:09,500
three to be returned a.

772
00:38:09,500 --> 00:38:13,100
And if that works, I don't know if it is, no, it doesn't.

773
00:38:13,200 --> 00:38:15,300
Operator equals must be a non-static member.

774
00:38:23,100 --> 00:38:24,000
Why though?

775
00:38:26,600 --> 00:38:27,700
Why must it be?

776
00:38:30,200 --> 00:38:31,100
Can you tell me?

777
00:38:39,400 --> 00:38:39,600
Yeah.

778
00:38:39,600 --> 00:38:41,100
That's a little bit weird though because

779
00:38:44,500 --> 00:38:45,600
Why can we do?

780
00:38:45,600 --> 00:38:47,700
Operator x equals that way.

781
00:38:48,600 --> 00:38:52,300
It doesn't have a problem with that, but we can't do operator equals

782
00:38:52,300 --> 00:38:54,800
that way, right?

783
00:38:55,100 --> 00:38:57,200
It seems a little odd, doesn't it?

784
00:39:00,100 --> 00:39:01,900
We go through this in handmade hero, too.

785
00:39:04,200 --> 00:39:05,000
I thought we did.

786
00:39:05,000 --> 00:39:08,000
But anyway, what I was going to say is assuming that you could Define

787
00:39:08,000 --> 00:39:11,200
it, that way, if you could Define operator goes that way, you could do

788
00:39:11,200 --> 00:39:14,600
it down here because it wouldn't actually depend on anything else

789
00:39:14,600 --> 00:39:17,000
either write, it would be able to use the function.

790
00:39:17,000 --> 00:39:20,700
We've already defined and we wouldn't have to do it per Lane with

791
00:39:21,100 --> 00:39:21,500
right.

792
00:39:27,200 --> 00:39:31,600
So I really just don't know how to convince it to let us do that.

793
00:39:39,700 --> 00:39:41,100
I feel like we went over this before.

794
00:39:41,300 --> 00:39:42,300
Hold on one second.

795
00:39:46,400 --> 00:39:47,900
Let's take a look.

796
00:39:58,100 --> 00:40:00,200
So, it looks like we did not do that ever.

797
00:40:02,300 --> 00:40:05,800
Well, that's that's poop sauce if you ask me.

798
00:40:08,300 --> 00:40:09,700
It's just plain poop sauce.

799
00:40:10,400 --> 00:40:15,600
That's all right, we can make it, you know, if that's, it's really for

800
00:40:15,600 --> 00:40:16,100
some reason.

801
00:40:16,100 --> 00:40:17,100
We've got to make it that way.

802
00:40:17,100 --> 00:40:23,600
I have no idea why that would be the case but if we have to, we have

803
00:40:23,600 --> 00:40:25,900
to because I assume that it wouldn't matter if we got rid of that.

804
00:40:25,900 --> 00:40:30,400
Yeah, so if we have to make it that way, then I guess we have to make

805
00:40:30,400 --> 00:40:32,300
it that way but that's okay.

806
00:40:32,300 --> 00:40:33,700
It's not the end of the world.

807
00:40:34,300 --> 00:40:37,900
So in this case we would just say, all right, if it's if

808
00:40:38,100 --> 00:40:39,700
Got an operator equals here.

809
00:40:40,100 --> 00:40:42,200
We can just say star this, right?

810
00:40:42,200 --> 00:40:44,800
Whatever the thing is here, equals that

811
00:40:46,900 --> 00:40:48,900
Equals the Lincoln version.

812
00:40:49,200 --> 00:40:52,100
And then we just make sure that everybody who defines one of these

813
00:40:52,100 --> 00:40:52,700
here.

814
00:40:53,800 --> 00:40:57,300
Who do you know, who each one of the lane things that defines one of

815
00:40:57,300 --> 00:41:00,000
these just has to stick a lane F32.

816
00:41:02,800 --> 00:41:06,600
Definition in here so that the compiler knows is coming, right?

817
00:41:07,000 --> 00:41:13,000
So long enough for you to operator equals, F 32, right?

818
00:41:14,800 --> 00:41:20,100
And as much as that's dumb, I mean, it's okay, right?

819
00:41:22,900 --> 00:41:25,800
I don't think there's anything particularly bad about it, right?

820
00:41:25,800 --> 00:41:26,500
So that should work.

821
00:41:30,900 --> 00:41:36,600
This has to be in Acts go and presumably this will work for floats as

822
00:41:36,600 --> 00:41:36,800
well.

823
00:41:36,800 --> 00:41:37,500
Just fine.

824
00:41:38,200 --> 00:41:39,000
So, here we go.

825
00:41:42,400 --> 00:41:43,100
And that's it.

826
00:41:44,300 --> 00:41:48,300
So yeah, I think that's mostly all we need.

827
00:41:50,000 --> 00:41:53,600
No operator found, which takes a right hand side of Lane F32.

828
00:41:54,300 --> 00:41:55,100
That's correct.

829
00:41:55,100 --> 00:41:58,000
So, we actually need the other kind here, which is lofting up just a

830
00:41:58,000 --> 00:41:59,800
straight u-32 because we want to be able to

831
00:42:00,000 --> 00:42:03,500
You 32s from you 32s, so that's fine.

832
00:42:03,800 --> 00:42:06,500
And the way that we would do that again is exactly the way we were

833
00:42:06,500 --> 00:42:07,300
doing it before.

834
00:42:07,800 --> 00:42:12,400
So we've got a lane f82 from you 32 Elaine after you to from F32.

835
00:42:12,500 --> 00:42:14,700
And so we just need Lane you 32 from you 32.

836
00:42:14,700 --> 00:42:16,200
And again that's just a set one.

837
00:42:16,400 --> 00:42:21,300
Exactly the same thing but we just need to do a set one from an Epi 32

838
00:42:21,300 --> 00:42:22,500
instead, right?

839
00:42:24,400 --> 00:42:27,000
Where we're going to be instead of casting it to a float.

840
00:42:27,000 --> 00:42:29,800
We're just going to set it as as it is and we're going to replicate it

841
00:42:29,800 --> 00:42:29,900
to

842
00:42:30,000 --> 00:42:31,200
All the links, right?

843
00:42:32,600 --> 00:42:33,200
All right.

844
00:42:33,200 --> 00:42:33,600
So let's see.

845
00:42:33,600 --> 00:42:33,800
It.

846
00:42:33,800 --> 00:42:35,300
Cannot convert u-32 two-lane.

847
00:42:35,300 --> 00:42:36,600
You 3D to

848
00:42:39,100 --> 00:42:42,600
Yeah, so I this is the part that I was worried about before.

849
00:42:45,700 --> 00:42:47,900
Apparently, during construction, you can't do that.

850
00:42:47,900 --> 00:42:49,600
So let's see if this works, for example.

851
00:42:50,400 --> 00:42:50,800
Yeah.

852
00:42:51,200 --> 00:42:55,200
So for whatever reason, see and it's infinitesimal wisdom forces you

853
00:42:55,200 --> 00:43:01,400
to have a Constructor, I guess declared to do the equals here, which

854
00:43:01,400 --> 00:43:03,500
is super, super duper lame.

855
00:43:04,700 --> 00:43:08,300
It's like so incredibly lame because you know why, right?

856
00:43:08,300 --> 00:43:11,500
There's no reason why that would be the case, but you would have to

857
00:43:11,500 --> 00:43:14,900
write it like that if you wanted to do it or and we don't want to

858
00:43:14,900 --> 00:43:15,300
create an

859
00:43:15,400 --> 00:43:19,000
Operator, B Construction operate or anything like that because we just

860
00:43:19,000 --> 00:43:20,300
want these things to be flat types.

861
00:43:21,400 --> 00:43:25,900
So what I can do here again is just two lane, you 32 from you 32,

862
00:43:25,900 --> 00:43:26,400
right?

863
00:43:26,600 --> 00:43:30,000
So I can do that and then that'll work just fine but it's just kind of

864
00:43:30,000 --> 00:43:31,300
stupid that I have to do that.

865
00:43:31,300 --> 00:43:33,100
But that's the plus plus for you, right?

866
00:43:33,300 --> 00:43:36,500
Like they would then go like, oh yeah, but you know what you should do

867
00:43:36,500 --> 00:43:39,700
is Define a Constructor for every type that's going to take and then a

868
00:43:39,700 --> 00:43:43,700
default Constructor is like, it's like no just make your programming

869
00:43:43,700 --> 00:43:46,500
language actually work for the programmer instead of making the

870
00:43:46,500 --> 00:43:49,200
programmer work for your language, you know.

871
00:43:49,200 --> 00:43:51,000
But they've you know they've

872
00:43:51,200 --> 00:43:51,800
Ed fastly.

873
00:43:51,800 --> 00:43:55,700
Refuse that they're always like oh but no, you don't understand.

874
00:43:55,800 --> 00:43:58,600
If you just type these extra hundred thousand lines of code,

875
00:43:58,600 --> 00:44:02,200
everything works cleanly and you're like, you don't really understand

876
00:44:02,200 --> 00:44:03,100
programming, do you.

877
00:44:03,800 --> 00:44:06,000
So anyway, let's just finish this up.

878
00:44:10,000 --> 00:44:12,200
We are forced to have these conversion types, and that's just

879
00:44:12,200 --> 00:44:13,700
unfortunate, but that's the way it is.

880
00:44:24,800 --> 00:44:27,000
And that is that.

881
00:44:31,200 --> 00:44:34,200
Now, we're going to have to do the lane V3 ones as well.

882
00:44:34,700 --> 00:44:36,400
Oops are these are F 32s.

883
00:44:37,500 --> 00:44:38,200
We're loading here.

884
00:44:38,200 --> 00:44:40,300
These are all actual floating Point values, right?

885
00:44:41,200 --> 00:44:41,600
Yeah.

886
00:44:44,100 --> 00:44:50,200
Okay, so what we want to do here is, what can I convert argument f30?

887
00:44:58,400 --> 00:44:59,800
Those are f30.

888
00:45:00,400 --> 00:45:01,200
Two's though.

889
00:45:01,200 --> 00:45:01,600
Aren't they?

890
00:45:01,600 --> 00:45:02,200
What was that?

891
00:45:02,200 --> 00:45:03,200
What was the complaint here?

892
00:45:04,200 --> 00:45:07,400
Cannot groups cannot convert.

893
00:45:08,900 --> 00:45:10,800
Argument one from Lane after 2:00.

894
00:45:10,800 --> 00:45:12,600
So these already are laying in Futures.

895
00:45:12,600 --> 00:45:18,100
So these are fine because, right, because film dubbed film State, film

896
00:45:18,100 --> 00:45:18,900
X and state film.

897
00:45:18,900 --> 00:45:24,000
Y, plus half x with these are F32 is already, so they will up convert

898
00:45:24,000 --> 00:45:25,800
the film X automatically, so that's cool.

899
00:45:27,800 --> 00:45:30,400
All right, we need to add that function that function doesn't exist

900
00:45:30,400 --> 00:45:30,900
yet.

901
00:45:33,700 --> 00:45:34,500
And so off we go.

902
00:45:34,800 --> 00:45:39,000
Okay, so in here, now, I want to inside the four wide float.

903
00:45:39,000 --> 00:45:45,600
I want to do a lane V3, that's Lane V3 from B3, and it takes the thing

904
00:45:45,600 --> 00:45:47,500
to replicate right?

905
00:45:48,100 --> 00:45:49,400
So here's my result.

906
00:45:50,800 --> 00:45:55,700
And I think I can't say for sure, but just I feel like this should

907
00:45:55,700 --> 00:45:57,800
just work right?

908
00:45:58,500 --> 00:46:02,800
What I should be able to do here is say if we just do this again

909
00:46:02,800 --> 00:46:08,500
completely blind in theory, this should work for all the different

910
00:46:08,500 --> 00:46:09,500
widths, right?

911
00:46:09,500 --> 00:46:14,600
So this should work for 4 8 and 16 so it should be something that can

912
00:46:14,600 --> 00:46:15,600
just come down.

913
00:46:18,100 --> 00:46:22,500
And work here furthermore I think and I could be wrong about that.

914
00:46:22,700 --> 00:46:26,700
But if you take a look at this, if we just said that each of these was

915
00:46:26,700 --> 00:46:31,100
a lane F32, I think we might just be able to not pass it eclair.

916
00:46:31,100 --> 00:46:34,200
This type month multiple times either, right?

917
00:46:34,400 --> 00:46:40,700
Because in theory it can just lean on the F32 and work that way,

918
00:46:41,200 --> 00:46:41,700
right?

919
00:46:43,100 --> 00:46:49,300
So I think we can just do this and then off we go, right?

920
00:46:50,300 --> 00:46:51,600
So I'm going to try that as well.

921
00:46:52,800 --> 00:46:57,000
All right, so again, this is just going to be a lane you through to,

922
00:46:57,000 --> 00:46:59,200
from you 32, where we lost that up.

923
00:47:02,400 --> 00:47:07,200
Here, we've got a divided, raise per pixel, / Lane width.

924
00:47:08,100 --> 00:47:10,400
That's a you 32 divided by another 32.

925
00:47:10,600 --> 00:47:14,100
In this case, I don't want to use the lofted version, so I'm just

926
00:47:14,100 --> 00:47:15,500
going to go ahead and do it like this.

927
00:47:15,500 --> 00:47:19,700
So it's still in scalar because we're just trying to compute a scalar

928
00:47:19,700 --> 00:47:21,400
on the way out, right?

929
00:47:22,100 --> 00:47:25,800
For the contribute value, we've got the race for Pixel again that

930
00:47:25,800 --> 00:47:29,200
contribute value can also remain a scalar for the most part.

931
00:47:29,800 --> 00:47:32,000
So I'm going to use this part of the raise per pixel.

932
00:47:32,100 --> 00:47:35,800
Again, right, and let me see here.

933
00:47:35,800 --> 00:47:38,500
If we've got a phrase, per pixel is never used wide.

934
00:47:39,700 --> 00:47:43,100
It's never used white anyway, so actually we can just do this.

935
00:47:46,800 --> 00:47:47,600
Let's take a look at Max.

936
00:47:47,600 --> 00:47:48,600
Bounce count.

937
00:47:50,000 --> 00:47:51,400
That's never used by either.

938
00:47:51,600 --> 00:47:53,700
So, these were really a little bit premature there.

939
00:47:53,700 --> 00:47:56,400
I just kind of got carried away when I was converting them, so we

940
00:47:56,400 --> 00:47:59,000
don't really need those to work like that, right?

941
00:47:59,200 --> 00:47:59,900
We can just have

942
00:48:00,000 --> 00:48:03,800
He's stay like this for now and we can anything else we want to do?

943
00:48:03,800 --> 00:48:04,600
We can do later.

944
00:48:09,000 --> 00:48:12,600
So, one thing that we're counting on here, which we should probably,

945
00:48:12,600 --> 00:48:16,100
also assert is that the lane re-count times, the lane with is going to

946
00:48:16,100 --> 00:48:20,000
equal the raise per pixel afterwards, if Lane width and raised for

947
00:48:20,000 --> 00:48:24,000
Pixel, we're not, if rates per pixel was not an even multiple of Lane

948
00:48:24,000 --> 00:48:26,300
with, we would be cheating here and not doing all the Rays.

949
00:48:26,500 --> 00:48:28,700
So we probably want to do an assertion here just to make sure that we

950
00:48:28,700 --> 00:48:30,100
don't get into that scenario.

951
00:48:30,900 --> 00:48:34,500
All right, so let's go ahead and take a look here.

952
00:48:34,700 --> 00:48:35,200
What else?

953
00:48:35,200 --> 00:48:38,100
We've got now, we've got a x operator.

954
00:48:38,500 --> 00:48:41,300
That's taking a left hand, type of laying F32.

955
00:48:43,100 --> 00:48:46,400
So we've got like, probably this is RV.

956
00:48:46,400 --> 00:48:46,800
Yeah.

957
00:48:46,900 --> 00:48:52,100
So this is, we need to start implementing our lane V3 stuff, right?

958
00:48:52,600 --> 00:48:55,200
So let's go ahead and start implementing your lane V3 stuff because we

959
00:48:55,200 --> 00:48:57,300
have a bunch of things we want to do there.

960
00:48:58,100 --> 00:49:03,300
So four lane v3's, we need to do a operator Plus

961
00:49:09,300 --> 00:49:11,000
so, we need to open, I guess I should probably

962
00:49:13,100 --> 00:49:17,500
So these are basically to be the exact same operations as our normal,

963
00:49:17,500 --> 00:49:19,300
handmade math operations, right?

964
00:49:23,900 --> 00:49:25,000
In fact.

965
00:49:27,600 --> 00:49:32,600
T', I'm wondering if we can just use this stuff directly.

966
00:49:43,300 --> 00:49:46,000
Because all of these are just going to be correct.

967
00:49:46,100 --> 00:49:50,500
I think for the most part, pretty much all of this stuff so we can

968
00:49:50,500 --> 00:49:54,100
actually take Ray math and just turn it into Ray Lane here.

969
00:50:05,300 --> 00:50:08,300
I mean, really all this stuff, you know, I hate to cut and paste it.

970
00:50:08,400 --> 00:50:09,200
Exactly.

971
00:50:09,400 --> 00:50:12,700
Because I mean, can we get away with just having the lane version?

972
00:50:13,900 --> 00:50:16,600
The only problem about that is anywhere in the code that just wants to

973
00:50:16,600 --> 00:50:17,500
be scalar.

974
00:50:19,700 --> 00:50:20,700
Couldn't really be.

975
00:50:25,200 --> 00:50:26,600
But at the same time, I don't know.

976
00:50:34,700 --> 00:50:37,900
Because you can always just use the bottom part, right?

977
00:50:38,500 --> 00:50:43,000
You could always just do it in lanes and then just not use all of it.

978
00:50:48,800 --> 00:50:50,100
I'm kind of tempted to do that.

979
00:50:50,500 --> 00:50:54,300
So I think what we could do here is just not have any Lane stuff in

980
00:50:54,300 --> 00:50:56,100
here at all, right?

981
00:50:58,400 --> 00:50:59,500
Just leave this out.

982
00:51:00,000 --> 00:51:01,800
Then anything that was a V3.

983
00:51:01,900 --> 00:51:05,500
We could just get rid of the V3 type entirely, I think and just use

984
00:51:05,500 --> 00:51:08,000
the lane V3 type, I think.

985
00:51:09,600 --> 00:51:10,200
Let's try it.

986
00:51:13,400 --> 00:51:14,800
And let's just see how it how we do.

987
00:51:38,900 --> 00:51:41,600
yeah, I mean, I'm just looking at this code and I'm thinking

988
00:51:42,900 --> 00:51:44,100
I think that just works.

989
00:51:47,600 --> 00:51:49,200
I mean, there's because really

990
00:51:50,500 --> 00:51:51,700
all of this stuff.

991
00:51:53,100 --> 00:51:56,400
Doesn't really care if there's a couple things like the normalizer

992
00:51:56,400 --> 00:51:59,400
zero, this needs to be done with the conditional.

993
00:52:01,000 --> 00:52:06,700
But other than that, it doesn't really seem to be a problem, right?

994
00:52:09,000 --> 00:52:09,800
So I don't know.

995
00:52:10,400 --> 00:52:12,000
Do we use v4s anywhere?

996
00:52:16,500 --> 00:52:19,200
The only place we use, it is in this bitmap color, right?

997
00:52:19,200 --> 00:52:19,900
That's it.

998
00:52:20,200 --> 00:52:21,600
So, I'm getting rid of that as well.

999
00:52:26,300 --> 00:52:28,800
And I'm going to get rid of all the V for stuff to just simplify

1000
00:52:28,800 --> 00:52:29,500
things down.

1001
00:52:41,500 --> 00:52:43,000
So okay.

1002
00:52:44,400 --> 00:52:49,400
So in order to do the stuff that we need here, I got to see how our

1003
00:52:49,400 --> 00:52:51,000
dependency order is stacking up here.

1004
00:52:51,000 --> 00:52:53,600
So is there anything that's actually happening?

1005
00:52:53,600 --> 00:52:55,000
I don't think there is

1006
00:52:58,800 --> 00:53:01,000
So I think what we can do is just reverse this order.

1007
00:53:04,800 --> 00:53:05,300
Here we go.

1008
00:53:08,900 --> 00:53:10,800
And so lean V3 from V3.

1009
00:53:10,800 --> 00:53:13,800
Now would no longer exist because there is no such thing as a V3.

1010
00:53:16,800 --> 00:53:20,200
And then we just have to implement the lean operations that we don't

1011
00:53:20,200 --> 00:53:20,700
have.

1012
00:53:21,200 --> 00:53:26,800
So right now, if we don't have a way to do a unary minus yet and so we

1013
00:53:26,800 --> 00:53:28,000
need that right?

1014
00:53:28,000 --> 00:53:33,800
We need a unary minus on here now, I don't know.

1015
00:53:38,600 --> 00:53:41,500
I don't think there's a way to do a unary minus in SSE.

1016
00:53:42,400 --> 00:53:45,100
I think you just have to do some PS with zero.

1017
00:53:46,500 --> 00:53:47,700
Don't quote me on that.

1018
00:53:47,700 --> 00:53:52,400
Someone can check me on the stream who wants to double check, but I

1019
00:53:52,400 --> 00:53:54,000
that just, I don't think you can.

1020
00:53:54,200 --> 00:53:56,200
I don't remember, but I just don't think you can.

1021
00:53:57,200 --> 00:53:58,700
So the

1022
00:54:00,000 --> 00:54:03,200
Ra - operation here.

1023
00:54:05,600 --> 00:54:08,500
Where I'm going to go ahead and take a value and make us negative

1024
00:54:08,500 --> 00:54:08,900
value.

1025
00:54:09,000 --> 00:54:14,100
I think the only way that you do that in as a see that are the most

1026
00:54:14,100 --> 00:54:19,300
expedient way to do it is to load a 0 and subtract maybe you would xor

1027
00:54:20,200 --> 00:54:23,900
with a pattern but I think sub would be the same speed.

1028
00:54:23,900 --> 00:54:26,200
I don't know there's because obviously it's a floating point value.

1029
00:54:26,200 --> 00:54:30,100
So you can just twiddle the sign bit and that would work as well but

1030
00:54:30,100 --> 00:54:32,900
I'm not sure which way would be faster or whether there is a fast,

1031
00:54:32,900 --> 00:54:34,900
whether either of them is faster or not.

1032
00:54:37,300 --> 00:54:40,900
I couldn't say so anyway so what we want to do here is we just want to

1033
00:54:40,900 --> 00:54:47,000
take that a value and we want to do a lane F32 from F32, we want to

1034
00:54:47,000 --> 00:54:52,200
just load 0 and then we want to subtract a from from that because that

1035
00:54:52,200 --> 00:54:53,500
will negate it right?

1036
00:54:54,400 --> 00:54:56,800
So pretty straightforward.

1037
00:54:57,000 --> 00:54:58,500
The result is just that

1038
00:54:59,800 --> 00:55:00,800
And that's the negation.

1039
00:55:02,200 --> 00:55:03,800
So let's keep going.

1040
00:55:04,400 --> 00:55:08,700
So we've got the inner product here and the inner product of Lane v3s

1041
00:55:08,700 --> 00:55:13,300
is going to have to be a lane F32 obviously because, you know, we're

1042
00:55:13,300 --> 00:55:16,500
going to need to take the scalars here and they're going to get added

1043
00:55:16,500 --> 00:55:17,300
together and all that stuff.

1044
00:55:17,300 --> 00:55:22,700
So we're not going to end up with a straight up 32 anymore.

1045
00:55:23,700 --> 00:55:25,000
Let's see what else we've got here.

1046
00:55:25,200 --> 00:55:27,900
Same thing with the length squared, right?

1047
00:55:29,000 --> 00:55:29,500
And then when we

1048
00:55:29,600 --> 00:55:32,100
The third Square rooting these things Square rooting.

1049
00:55:32,100 --> 00:55:35,000
These things is again going to produce something here.

1050
00:55:35,200 --> 00:55:40,900
That's going to be in a lane form form and in order for us to be able

1051
00:55:40,900 --> 00:55:43,900
to do that, we need some kind of square root operation.

1052
00:55:44,500 --> 00:55:47,100
Fortunately for us, we have a square root operation.

1053
00:55:47,700 --> 00:55:49,400
It's actually provided directly.

1054
00:55:49,700 --> 00:55:50,700
It's called em em squirt.

1055
00:55:50,700 --> 00:55:51,300
Yes.

1056
00:55:52,300 --> 00:55:56,600
And there's actually two different ways that you can do this and it

1057
00:55:56,600 --> 00:55:57,900
depends on which one you want.

1058
00:55:57,900 --> 00:55:59,400
Now you can kind of see there's some

1059
00:55:59,500 --> 00:56:01,900
Weird anomalies with this.

1060
00:56:03,700 --> 00:56:06,700
And what you can see here is, there's a pretty high latency on square

1061
00:56:06,700 --> 00:56:10,100
root operations, but actually a very high throughput on them.

1062
00:56:11,500 --> 00:56:14,900
So what's weird is that you can do a square root, if you're doing

1063
00:56:14,900 --> 00:56:19,500
them, they actually pipeline very well and you can do lots of them at

1064
00:56:19,500 --> 00:56:19,800
once.

1065
00:56:19,800 --> 00:56:23,000
If you want to there's only a 3 cycle through put on them.

1066
00:56:23,200 --> 00:56:26,300
I so that's actually kind of insane on sky, like right.

1067
00:56:27,300 --> 00:56:31,100
But either or the cycle counts on, this are actually pretty low, but

1068
00:56:31,100 --> 00:56:34,500
there's certainly nothing compared to some of the other operations

1069
00:56:34,600 --> 00:56:39,100
such as mul PS, which is, you know, if you see how much lower these

1070
00:56:39,100 --> 00:56:42,700
are three cycle latency on some and a half cycle, throughput, right?

1071
00:56:42,900 --> 00:56:44,500
Lots of multiplies in this thing.

1072
00:56:45,000 --> 00:56:48,300
So there's another thing you can do which is called reciprocal square

1073
00:56:48,300 --> 00:56:51,600
root and this one has a much better performance profile.

1074
00:56:51,600 --> 00:56:56,300
You can see it here and what that does is that approximate it doesn't

1075
00:56:56,300 --> 00:56:56,900
give you a very good.

1076
00:56:57,000 --> 00:56:57,500
Good answer.

1077
00:56:57,500 --> 00:56:59,600
It doesn't approximation to the square root.

1078
00:57:00,300 --> 00:57:03,300
And does one over the approximation it's made specifically for

1079
00:57:03,300 --> 00:57:04,200
normalizing things.

1080
00:57:04,700 --> 00:57:09,500
We're not going to use this yet but be aware that it is here because

1081
00:57:09,500 --> 00:57:12,600
if we find that we're spine spending too much time in our square

1082
00:57:12,600 --> 00:57:15,200
roots, this is a way to speed them up.

1083
00:57:15,200 --> 00:57:16,600
So it's good to know that they're there.

1084
00:57:16,600 --> 00:57:21,100
If you want approximate Sprite it's especially good for normalization

1085
00:57:21,300 --> 00:57:23,600
where you have something that looks like this, which is 1 over the

1086
00:57:23,600 --> 00:57:24,400
square root.

1087
00:57:24,400 --> 00:57:26,500
This is specifically designed to calculate that.

1088
00:57:26,500 --> 00:57:29,800
And if you don't care about the exact answer, that might be something.

1089
00:57:30,100 --> 00:57:30,700
For you.

1090
00:57:38,900 --> 00:57:44,200
Okay, so what we need to do is Define a square root in the side of our

1091
00:57:44,200 --> 00:57:48,700
array Lane stuff and that is going to be dependent on which one of

1092
00:57:48,700 --> 00:57:51,500
them we have, because there's actually going to be two different kinds

1093
00:57:51,500 --> 00:57:54,800
depending on whether it's for wider, 8 wide.

1094
00:57:54,800 --> 00:57:58,700
So if we go to the square root operation here.

1095
00:57:58,700 --> 00:58:07,300
So we take a an input Lane and we want to produce an output Lane.

1096
00:58:07,300 --> 00:58:08,900
Then what we're going.

1097
00:58:09,000 --> 00:58:13,200
Do is we're going to say result dot V equals a top V here.

1098
00:58:14,800 --> 00:58:15,500
Result.

1099
00:58:18,600 --> 00:58:20,200
And we're just going to do this work.

1100
00:58:20,500 --> 00:58:21,400
We're going to do the full one.

1101
00:58:40,000 --> 00:58:41,300
So that's it, right?

1102
00:58:41,300 --> 00:58:44,600
And now this will vary work properly and off we go.

1103
00:58:45,000 --> 00:58:52,900
So, now we have to take a look here, we've got our, our lane V3 here

1104
00:58:53,900 --> 00:58:58,100
is getting multiplied by 1 over the length of a.

1105
00:58:58,100 --> 00:59:02,100
That should give us back another Lane F32.

1106
00:59:02,100 --> 00:59:08,400
So, this would be a lane V3 x, a lane F32, right?

1107
00:59:09,100 --> 00:59:10,300
and,

1108
00:59:11,700 --> 00:59:15,400
I think we need to define those specially, right?

1109
00:59:15,400 --> 00:59:18,900
Because we don't have I think we don't have any of those.

1110
00:59:21,600 --> 00:59:24,600
I don't think we have anything like that at the moment, right?

1111
00:59:25,000 --> 00:59:25,600
So oops.

1112
00:59:27,800 --> 00:59:31,000
So, what I want to do here is I want to start defining those as well.

1113
00:59:31,000 --> 00:59:35,200
I think those are ones that can be defined out here, right?

1114
00:59:35,900 --> 00:59:37,600
So a lane F32

1115
00:59:43,200 --> 00:59:45,400
Operation set for Lane V3 s.

1116
00:59:46,200 --> 00:59:48,500
So this is would just be X and divide really.

1117
00:59:48,500 --> 00:59:50,100
That would be supported I guess by this.

1118
00:59:50,500 --> 00:59:53,800
So you would be saying both versions of this

1119
01:00:03,800 --> 01:00:08,300
We would need both the, the scalar on both sides of this, and then the

1120
01:00:08,300 --> 01:00:10,000
divided on one side of this, I guess.

1121
01:00:11,500 --> 01:00:14,700
But so anyway, so the multiply here, what we'd want to do is say well

1122
01:00:14,700 --> 01:00:24,600
result dot X, you know, time equals a job x times x beat up V.

1123
01:00:28,000 --> 01:00:28,500
Right.

1124
01:00:30,500 --> 01:00:32,200
And this is just the standard multiplied.

1125
01:00:32,200 --> 01:00:36,200
We want to support that on either side and we could to support this on

1126
01:00:36,200 --> 01:00:39,700
either side if we don't want to write this twice, we can also just do

1127
01:00:40,700 --> 01:00:41,500
it like this.

1128
01:00:49,100 --> 01:00:54,100
So this will just call back into that and you know, off we go, let's

1129
01:00:54,100 --> 01:00:54,900
take a look here.

1130
01:00:54,900 --> 01:00:56,900
Oops, we've made a lowercase V.

1131
01:00:57,000 --> 01:00:57,900
I don't know why I want you.

1132
01:00:57,900 --> 01:00:59,900
That probably because we did lowercase x y z.

1133
01:01:04,000 --> 01:01:08,500
Let's see, and I meant to do that.

1134
01:01:12,600 --> 01:01:14,800
All right, so let's make sure we got the sense of that.

1135
01:01:14,800 --> 01:01:15,600
Correct.

1136
01:01:15,700 --> 01:01:16,800
So we have a lien V3.

1137
01:01:16,800 --> 01:01:20,800
It's got an x y and a z in it, and it's actually three different ones

1138
01:01:20,800 --> 01:01:21,300
of these.

1139
01:01:21,300 --> 01:01:22,600
And we have three different.

1140
01:01:22,800 --> 01:01:23,200
I'm sorry.

1141
01:01:23,200 --> 01:01:26,100
It's actually four different ones of these pack together and we have

1142
01:01:26,100 --> 01:01:29,300
four different floats back together and we want to do a multiply where

1143
01:01:29,300 --> 01:01:30,800
each lane multiplies, each lane.

1144
01:01:30,800 --> 01:01:33,100
So that that looks like the sense is correct there as well.

1145
01:01:34,000 --> 01:01:35,300
Alright, so let's take a look here.

1146
01:01:35,800 --> 01:01:39,100
Normalizer 0 is going to be the same way here where we have to set

1147
01:01:39,100 --> 01:01:41,500
something to 0 in the case, where we're trying to normalize it.

1148
01:01:42,200 --> 01:01:45,800
I think what we want to do is again, do that conditional assignment

1149
01:01:45,800 --> 01:01:46,200
here.

1150
01:01:46,400 --> 01:01:49,200
So this right here is going to produce a mask

1151
01:01:50,500 --> 01:01:51,100
Right?

1152
01:01:51,500 --> 01:01:55,100
Where we are taking a length squared value, that's coming back to the

1153
01:01:55,100 --> 01:01:55,300
Lane.

1154
01:01:55,300 --> 01:01:59,400
32, we want to compare it against a squared value here, whatever that

1155
01:01:59,400 --> 01:02:01,700
comes out to be, which can be locked to Lane as well.

1156
01:02:02,500 --> 01:02:05,800
And then, we're going to go ahead and say, let's do a conditional

1157
01:02:05,800 --> 01:02:10,900
assignments where we take results and conditionally assign it based on

1158
01:02:10,900 --> 01:02:12,800
the mask too.

1159
01:02:15,100 --> 01:02:16,000
To this value here.

1160
01:02:17,000 --> 01:02:23,600
So it'll be set to 0 by default and anything that isn't set to zero.

1161
01:02:23,600 --> 01:02:25,900
We something that past the mask, right?

1162
01:02:27,000 --> 01:02:27,700
And off we go.

1163
01:02:28,400 --> 01:02:30,800
So now we should get to the part where we don't have comparison

1164
01:02:30,800 --> 01:02:33,700
operators because we don't have comparison operators yet.

1165
01:02:33,900 --> 01:02:36,800
So we need to go ahead and put those comparison operators in again,

1166
01:02:36,800 --> 01:02:41,200
that's not too bad and and then we're sort of, you know, we're getting

1167
01:02:41,200 --> 01:02:41,900
we're getting closer.

1168
01:02:43,100 --> 01:02:46,500
And again, if it seems like a lot of work, it's really not.

1169
01:02:46,500 --> 01:02:48,700
As you can see, it's pretty easy work to do.

1170
01:02:48,700 --> 01:02:51,800
But the other important thing to remember is again, you really only

1171
01:02:51,800 --> 01:02:52,400
have to do this.

1172
01:02:52,400 --> 01:02:56,300
Once you can do one of these and make a nice little Library, once the

1173
01:02:56,300 --> 01:02:59,700
library is done, you can just use it and library is a strong term.

1174
01:03:00,000 --> 01:03:02,900
The H file, you can include this h-file anywhere you want.

1175
01:03:02,900 --> 01:03:06,900
And then once you have this h-file, you can just do scalar operations

1176
01:03:07,700 --> 01:03:11,000
on what looked like scalar operations in your code and have them be

1177
01:03:11,000 --> 01:03:12,300
actual Cindy operations.

1178
01:03:12,300 --> 01:03:14,300
And you really don't have to think about it ever again.

1179
01:03:15,000 --> 01:03:18,800
So anyway, so what I want to do now is put those comparison operators

1180
01:03:18,800 --> 01:03:21,700
in here again, those are going to be special operators because they

1181
01:03:23,200 --> 01:03:26,100
They are specific to the Lane width because they're going to call

1182
01:03:26,100 --> 01:03:28,300
different intrinsic, depending on what that lane with is.

1183
01:03:28,700 --> 01:03:31,400
So we've basically got, you know, a set of things here that look like

1184
01:03:31,400 --> 01:03:35,400
this right lane, F 32 x, right?

1185
01:03:35,400 --> 01:03:36,700
This is gonna produce a mask.

1186
01:03:38,500 --> 01:03:41,700
We played 32 result result is going to equal something.

1187
01:03:43,300 --> 01:03:44,900
With these two things.

1188
01:03:47,900 --> 01:03:51,300
And we're going to have just a series of something happening here.

1189
01:03:51,900 --> 01:03:54,100
So let's take a look at what that what has to happen here.

1190
01:03:54,700 --> 01:03:58,300
When we look at the these These are comparison structions again if you

1191
01:03:58,300 --> 01:04:00,300
did not know what you were looking for.

1192
01:04:00,700 --> 01:04:02,900
Again, you can come through here and click the compare button.

1193
01:04:03,100 --> 01:04:05,100
You can see you got all your comparison instructions.

1194
01:04:05,100 --> 01:04:06,000
Listen here.

1195
01:04:06,000 --> 01:04:07,000
There's quite a few of them.

1196
01:04:07,500 --> 01:04:09,800
A lot of them have some confusing mnemonics, but we'll go over what

1197
01:04:09,800 --> 01:04:10,200
that means.

1198
01:04:10,200 --> 01:04:13,600
Now, again, the last part of the mnemonic telling you, specifically

1199
01:04:13,600 --> 01:04:17,100
what's working on 16-bit Lanes, 32-bit Lanes, 8-bit Lanes,

1200
01:04:17,600 --> 01:04:21,000
64-bit doubles 32-bit floats.

1201
01:04:21,400 --> 01:04:24,000
So that ending is always pretty consistent.

1202
01:04:24,000 --> 01:04:25,000
Includes you into what?

1203
01:04:25,000 --> 01:04:26,400
It's actually operating on.

1204
01:04:26,400 --> 01:04:29,200
Again, you can also use sort of this to give you a clue, is whether

1205
01:04:29,200 --> 01:04:32,000
it's integer or not, because L have the eye or not in the parameters.

1206
01:04:32,900 --> 01:04:34,600
So we are trying to compare float.

1207
01:04:34,600 --> 01:04:37,500
So, you know, we're looking at things like this instruction here, copy

1208
01:04:37,500 --> 01:04:38,200
QPS.

1209
01:04:38,500 --> 01:04:40,800
As you might have guessed, EQ is equal to.

1210
01:04:41,100 --> 01:04:44,400
And if you look at what else, we've got, g e is greater than or equal

1211
01:04:44,400 --> 01:04:47,100
to GT is greater than not.

1212
01:04:47,300 --> 01:04:48,800
Greater than equal to, right?

1213
01:04:49,200 --> 01:04:54,600
Ellie is less than or equal to l t is less than any Q is not equal to

1214
01:04:55,200 --> 01:04:58,400
0 and N GE is not greater than not.

1215
01:04:59,000 --> 01:05:02,800
I'm sorry not not greater than equal to naught greater than a lot of

1216
01:05:02,800 --> 01:05:06,700
these are actually just mnemonics that all come out to the same in

1217
01:05:06,700 --> 01:05:07,900
actual instruction.

1218
01:05:08,600 --> 01:05:12,300
You can see here, for example, you end up with things where like

1219
01:05:12,300 --> 01:05:16,800
you've got, you know, not greater or equal to write, for example.

1220
01:05:18,200 --> 01:05:19,800
Is doing comp ss.

1221
01:05:20,400 --> 01:05:23,500
But so is this doing Compass s right?

1222
01:05:24,400 --> 01:05:24,700
I'm sorry.

1223
01:05:24,700 --> 01:05:24,900
Cop.

1224
01:05:24,900 --> 01:05:25,400
P.s.

1225
01:05:25,400 --> 01:05:29,400
I clicked on the SS one accidentally there whereas it's right there,

1226
01:05:29,400 --> 01:05:32,100
right comp PS and comp PS.

1227
01:05:32,100 --> 01:05:35,300
There's similar instructions that are doing basically the same things

1228
01:05:35,300 --> 01:05:37,900
and they take immediate to say which one of the comparisons they're

1229
01:05:37,900 --> 01:05:41,900
doing, and they just make mnemonics that are easy for you to pick out

1230
01:05:41,900 --> 01:05:44,000
which one you wanted.

1231
01:05:44,000 --> 01:05:46,400
So that you don't have to remember what the immediate tsar and all

1232
01:05:46,400 --> 01:05:47,200
these sorts of things.

1233
01:05:49,000 --> 01:05:51,600
So in this case, we've got a pretty simple and straightforward thing.

1234
01:05:51,600 --> 01:05:54,400
We want to do, what we're going to do here is say well it's a less

1235
01:05:54,400 --> 01:05:54,700
than.

1236
01:05:54,700 --> 01:05:56,100
So we want to be able to do

1237
01:05:57,600 --> 01:05:59,000
A comp operation.

1238
01:06:00,000 --> 01:06:00,800
I do.

1239
01:06:02,700 --> 01:06:06,900
Compare less than these two values.

1240
01:06:06,900 --> 01:06:10,000
And what we're going to get back is we're going to get back an actual

1241
01:06:10,000 --> 01:06:10,700
unfortunately.

1242
01:06:10,700 --> 01:06:11,000
Right?

1243
01:06:11,000 --> 01:06:18,500
If we do, mmm, less than we're actually going to get back a float

1244
01:06:18,500 --> 01:06:19,200
value, right?

1245
01:06:19,200 --> 01:06:22,500
We're going to get that complex than PS and generally speaking.

1246
01:06:22,500 --> 01:06:30,400
We were sort of, treating our, our masks as you 32s, maybe we

1247
01:06:30,400 --> 01:06:32,600
shouldn't do that, maybe we should treat our masks.

1248
01:06:32,700 --> 01:06:35,600
As lean F32 is, I don't really know.

1249
01:06:38,100 --> 01:06:41,300
We're gonna have to do a conversion here if we don't, right?

1250
01:06:42,900 --> 01:06:45,300
Because generally, it's not a conversion, it's a cast.

1251
01:06:45,300 --> 01:06:49,100
But generally speaking, these are not like

1252
01:06:50,900 --> 01:06:56,600
as clean as we would want them to because they yeah I don't think so.

1253
01:06:57,100 --> 01:07:01,900
If you take a look at these, there's actual or versions of the PS ones

1254
01:07:01,900 --> 01:07:07,200
as well as the Epi other si128, we could instead choose to do is

1255
01:07:07,200 --> 01:07:11,800
mostly Lane F32 s and use you 32s only sparingly for very specific

1256
01:07:11,800 --> 01:07:12,100
things.

1257
01:07:13,200 --> 01:07:14,600
I had thought about that.

1258
01:07:14,600 --> 01:07:15,900
We were originally doing this.

1259
01:07:16,000 --> 01:07:19,300
Let me see where we actually have Lain 32s here.

1260
01:07:23,400 --> 01:07:25,500
In most cases.

1261
01:07:29,500 --> 01:07:36,400
In most cases, we are all of our masking could just if we wanted to it

1262
01:07:36,400 --> 01:07:39,700
could actually stay as you 32 as F32.

1263
01:07:40,200 --> 01:07:40,700
Um,

1264
01:07:42,500 --> 01:07:44,200
I'm not going to do that yet.

1265
01:07:44,900 --> 01:07:47,600
I'm going to let these always phase you 32s.

1266
01:07:48,600 --> 01:07:52,800
And so what I'm going to do here is just do a cast instruction.

1267
01:07:53,100 --> 01:07:56,800
So what you can see here is, if I do a cast, you can convert one of

1268
01:07:56,800 --> 01:07:59,100
these to the other without changing the bit values.

1269
01:07:59,300 --> 01:08:03,300
So, for example, if I do a cast, si128 PSI can take an integer in and

1270
01:08:03,300 --> 01:08:04,400
return a float out.

1271
01:08:04,500 --> 01:08:07,300
Or in the case, we're talking about here, I can do a cast PSS.

1272
01:08:07,300 --> 01:08:09,700
I went to me and do the opposite, right?

1273
01:08:11,200 --> 01:08:15,400
And what that'll do is, that'll just take the B directly, right?

1274
01:08:15,400 --> 01:08:20,899
So it'll take a was a PS and turn it into an SI, which is what I want,

1275
01:08:20,899 --> 01:08:21,399
right?

1276
01:08:22,100 --> 01:08:24,399
So I'm going to do that because I just want to keep these as laying

1277
01:08:24,399 --> 01:08:27,399
you 32s for now, that may be a dumb decision but that's what I'm going

1278
01:08:27,399 --> 01:08:28,000
to do for now.

1279
01:08:28,000 --> 01:08:31,800
Just because it's clearer and we are not super focused on weird

1280
01:08:31,800 --> 01:08:34,899
performance things yet or anything where we might actually care one

1281
01:08:34,899 --> 01:08:35,600
way or the other.

1282
01:08:37,399 --> 01:08:41,500
So I'm going to go ahead and and spam these out here so that we can

1283
01:08:41,600 --> 01:08:43,500
have a couple different ones of these.

1284
01:08:44,100 --> 01:08:49,899
You can see that I'm just doing the exact function multiple times.

1285
01:08:50,100 --> 01:08:53,800
And all I'm doing is taking, you know, these and saying, well we've

1286
01:08:53,800 --> 01:08:58,800
got greater than is greater than equal to is equal to, you know, not

1287
01:08:58,800 --> 01:08:59,700
equal to is

1288
01:09:00,000 --> 01:09:03,600
Not equal to less than is less than and so on.

1289
01:09:04,399 --> 01:09:07,500
And you know that's that's it and we can do

1290
01:09:09,500 --> 01:09:12,700
these versions as well, without

1291
01:09:13,800 --> 01:09:15,399
Much Ado.

1292
01:09:18,000 --> 01:09:18,500
There we go.

1293
01:09:20,500 --> 01:09:21,600
So I think that's it.

1294
01:09:21,800 --> 01:09:22,800
Let's take a look here.

1295
01:09:22,800 --> 01:09:24,600
What are we talking about?

1296
01:09:25,899 --> 01:09:27,800
There were times takes right hand.

1297
01:09:27,899 --> 01:09:31,100
Yeah and so these right here are just ones that want to take a scalar

1298
01:09:31,100 --> 01:09:34,600
on either side so that you can automatically do the upconvert there.

1299
01:09:35,200 --> 01:09:38,399
And again, that's something that we don't have to do per Lane so we

1300
01:09:38,399 --> 01:09:39,700
can put that down in here.

1301
01:09:39,700 --> 01:09:44,500
So if we want to, we can have a lane u-32 operator and we can make

1302
01:09:44,500 --> 01:09:45,000
each of these.

1303
01:09:45,000 --> 01:09:47,300
Where we take Elaine F32.

1304
01:09:48,500 --> 01:09:53,600
on one side and a scalar on the other side Hoops be

1305
01:09:57,700 --> 01:09:58,200
What?

1306
01:09:58,700 --> 01:09:59,500
Why did we?

1307
01:09:59,700 --> 01:10:00,000
Yeah.

1308
01:10:00,000 --> 01:10:01,200
Well I guess it doesn't really matter.

1309
01:10:02,100 --> 01:10:05,800
This should really be a be right?

1310
01:10:05,900 --> 01:10:11,400
And this should be say yeah, for being for being salty about it.

1311
01:10:12,300 --> 01:10:16,100
So anyway, in this case these are all just, you know, wrote sort of

1312
01:10:16,100 --> 01:10:20,700
conversions, where we take the result and we say, well, we know that

1313
01:10:20,700 --> 01:10:24,300
we wanted to up convert one of them, so we'll just say a greater than

1314
01:10:24,400 --> 01:10:26,900
Lane if they to from

1315
01:10:27,300 --> 01:10:30,000
32 of B and then we return the result, right?

1316
01:10:30,000 --> 01:10:32,800
So this is just a little quick thing to make sure that it will

1317
01:10:32,800 --> 01:10:35,900
automatically take that one and convert it.

1318
01:10:35,900 --> 01:10:36,700
In this case.

1319
01:10:36,900 --> 01:10:39,300
Now, there's other ways we could do stuff like this, we could have

1320
01:10:39,300 --> 01:10:41,900
implicit conversion that would do.

1321
01:10:41,900 --> 01:10:44,100
It implicit conversion up to Elaine you 32.

1322
01:10:44,300 --> 01:10:48,200
I don't always like to do that unless I really have to the reason for

1323
01:10:48,200 --> 01:10:53,500
that is just because I don't love having surprise conversions, so I'd

1324
01:10:53,500 --> 01:10:54,200
rather have it.

1325
01:10:54,200 --> 01:10:57,100
Only do the conversion for operators that I've actually thought about

1326
01:10:57,100 --> 01:10:57,100
before.

1327
01:10:57,200 --> 01:10:59,200
Before if that makes sense.

1328
01:11:00,700 --> 01:11:06,600
Oops, so sometimes I like to just deal with the fact that c is kind of

1329
01:11:06,600 --> 01:11:08,500
annoying and makes you go through all these hoops.

1330
01:11:09,200 --> 01:11:12,800
But just deal with that fact and type it in once and then have it and

1331
01:11:12,800 --> 01:11:15,400
I know that it's only going to do the exact things that I specified,

1332
01:11:15,500 --> 01:11:15,900
right?

1333
01:11:17,000 --> 01:11:18,500
So that's just one thing to think about.

1334
01:11:18,500 --> 01:11:20,500
But, you know, that's the choice that you can make yourself.

1335
01:11:20,500 --> 01:11:23,500
If you would rather just put in some implicit conversions there, you

1336
01:11:23,500 --> 01:11:26,800
can to find implicit conversions in the type itself.

1337
01:11:26,800 --> 01:11:29,600
That would always be able to compute convert an F32.

1338
01:11:29,700 --> 01:11:32,300
You to Elena 42 like every time, right?

1339
01:11:34,400 --> 01:11:34,700
All right.

1340
01:11:34,700 --> 01:11:38,500
So now I'm just going to spam these out for each version, right?

1341
01:11:39,000 --> 01:11:41,700
Let me just make sure that I've got this compelling properly here.

1342
01:11:41,700 --> 01:11:48,800
There's an extra parentheses that you don't need there with that one.

1343
01:11:51,300 --> 01:11:55,800
And so now I'm just going to go ahead and did I get sling squared

1344
01:11:55,800 --> 01:11:59,900
greater than equal to square cannot convert Lane through?

1345
01:12:00,200 --> 01:12:01,500
F32.

1346
01:12:01,500 --> 01:12:01,800
Yes.

1347
01:12:01,800 --> 01:12:07,000
So this mask should really do that and then we've just got to make

1348
01:12:07,000 --> 01:12:09,000
that actual conditional assignment.

1349
01:12:09,300 --> 01:12:12,100
We know that we have a conditional assign operator there.

1350
01:12:13,500 --> 01:12:15,500
This actually needs an and in front of as well.

1351
01:12:16,200 --> 01:12:18,300
So now we actually have to implement that conditional sign and that

1352
01:12:18,300 --> 01:12:18,600
conditional.

1353
01:12:18,600 --> 01:12:20,000
The sign is not

1354
01:12:22,600 --> 01:12:26,100
Is not particularly difficult to implement either, so we can actually

1355
01:12:26,100 --> 01:12:26,400
write it.

1356
01:12:26,400 --> 01:12:28,500
I think we might actually be able to write it out here.

1357
01:12:29,200 --> 01:12:30,400
So for conditional assign.

1358
01:12:30,400 --> 01:12:36,500
We've got a lane, F32 d'Este, a lane u-32 mask, and Elaine, F32

1359
01:12:36,500 --> 01:12:38,700
Source, like so.

1360
01:12:39,200 --> 01:12:43,000
And in this case, what we want to do here is we want to actually

1361
01:12:43,000 --> 01:12:44,000
doesn't produce results.

1362
01:12:44,000 --> 01:12:44,400
All right?

1363
01:12:44,600 --> 01:12:46,100
Overwrites the destination, right?

1364
01:12:50,100 --> 01:12:52,900
So what we want to do here is we want to say that whatever the

1365
01:12:52,900 --> 01:13:00,800
destination is it's going to be equal to you know, itself anded with

1366
01:13:01,500 --> 01:13:03,200
the inverse of the Mask.

1367
01:13:03,700 --> 01:13:04,700
In fact, you know, we

1368
01:13:07,400 --> 01:13:10,300
We already sort of wrote it here, right?

1369
01:13:11,000 --> 01:13:13,800
You can see what we ended up with.

1370
01:13:16,800 --> 01:13:18,300
And you can see how we wrote it, right.

1371
01:13:18,400 --> 01:13:21,200
It's a little bit different in the scalar version because the masks

1372
01:13:21,200 --> 01:13:24,000
get computed wrong in the scalar version compared to what we want.

1373
01:13:24,600 --> 01:13:26,200
But otherwise, it's basically the same.

1374
01:13:26,400 --> 01:13:30,000
And the other thing that's interesting about it is we can take the

1375
01:13:30,100 --> 01:13:33,200
vector version again and that can be the same for all of them.

1376
01:13:33,200 --> 01:13:35,900
This this will work in all cases, right?

1377
01:13:36,600 --> 01:13:40,800
But the point is, the conditional assign that we wrote above, which is

1378
01:13:40,800 --> 01:13:41,700
this one here.

1379
01:13:41,800 --> 01:13:46,000
This is actually exactly what we want, right there is nothing more to

1380
01:13:46,000 --> 01:13:46,200
it.

1381
01:13:46,500 --> 01:13:51,200
As long as we've defined all of these operators, we're good to go.

1382
01:13:51,600 --> 01:13:54,300
Now, one of the things that's a little bit odd is that we could have

1383
01:13:54,300 --> 01:13:59,100
actually done this one a little bit more, a little bit more Saucy.

1384
01:13:59,400 --> 01:14:03,300
The reason that I say that is because if you look there's an and not

1385
01:14:03,300 --> 01:14:09,000
here so there's an and not PS and that allows us to do an and with a

1386
01:14:09,000 --> 01:14:11,700
mask that we haven't actually

1387
01:14:14,300 --> 01:14:15,100
Phrases.

1388
01:14:15,100 --> 01:14:18,900
So, in see, there's no such thing as like that.

1389
01:14:18,900 --> 01:14:24,400
Operator, you can't do an and with a knotted, whoa, there's something.

1390
01:14:24,400 --> 01:14:31,400
And, and with a knotted version of the operand, but in the intrinsic,

1391
01:14:31,400 --> 01:14:35,900
in the SSE instruction set, we can so, rather than first knotting,

1392
01:14:35,900 --> 01:14:39,800
something and then ending it together, what we can do is roll that

1393
01:14:39,800 --> 01:14:43,000
into one, and we do want to do that because we don't want to sit here

1394
01:14:43,000 --> 01:14:44,200
wasting time.

1395
01:14:44,300 --> 01:14:49,000
Hi, so if you see in psss completely bitwise, not of packs, a 20-foot,

1396
01:14:49,000 --> 01:14:54,100
putting those in a and then and with b and store the results invest.

1397
01:14:54,100 --> 01:14:58,200
So you can see that that first one is going to get knotted, which is

1398
01:14:58,200 --> 01:14:59,800
exactly what we want in this case.

1399
01:15:00,000 --> 01:15:01,300
Um, and off it goes.

1400
01:15:02,900 --> 01:15:06,700
So what we really want to do is introduce an and not operation here,

1401
01:15:06,700 --> 01:15:07,400
right?

1402
01:15:07,800 --> 01:15:11,200
And that and not operation is going to be

1403
01:15:15,600 --> 01:15:20,700
what we do on this side and then the regular and operation is what we

1404
01:15:20,700 --> 01:15:22,600
do on the source side.

1405
01:15:22,600 --> 01:15:26,400
And like I said, one nice thing about this is this will actually work.

1406
01:15:28,600 --> 01:15:32,700
Regardless of which one of these we happen to be using, right?

1407
01:15:32,700 --> 01:15:35,300
It can work for both both Lane versions.

1408
01:15:35,900 --> 01:15:39,500
This actually to I guess and I think about this guy can be outside

1409
01:15:39,500 --> 01:15:41,100
because this works for scalar.

1410
01:15:41,200 --> 01:15:43,300
It this works for everything, right?

1411
01:15:44,800 --> 01:15:49,400
And and so does this, I guess right?

1412
01:15:51,000 --> 01:15:51,600
In fact.

1413
01:15:54,600 --> 01:15:57,100
Why were these necessary?

1414
01:15:59,700 --> 01:16:02,400
Why weren't these already in the math?

1415
01:16:03,700 --> 01:16:05,400
Library.

1416
01:16:08,500 --> 01:16:12,100
Oh, because those were scalars that were happening there and these are

1417
01:16:12,100 --> 01:16:12,500
at the Jews.

1418
01:16:12,500 --> 01:16:13,000
That's fine.

1419
01:16:13,300 --> 01:16:14,800
All right, anyway, we'll get to that later.

1420
01:16:16,600 --> 01:16:19,900
All right, so in conditional assignment.

1421
01:16:20,100 --> 01:16:25,400
We've got these two versions here, both of which we want to have work.

1422
01:16:26,400 --> 01:16:30,500
So what we can do, if we want to is we can go to find this and not

1423
01:16:30,500 --> 01:16:33,500
operation and then that will give us the extra thing that we actually

1424
01:16:33,500 --> 01:16:34,000
needed.

1425
01:16:34,500 --> 01:16:36,800
So I'm going to go ahead up here and put that in.

1426
01:16:37,000 --> 01:16:41,300
So right where we've got this sort of and between two different

1427
01:16:41,300 --> 01:16:41,700
things.

1428
01:16:43,300 --> 01:16:47,300
I'm going to go ahead and take that and and I'm going to make a and

1429
01:16:47,300 --> 01:16:52,900
not and the and not is just going to look like that, right?

1430
01:16:53,200 --> 01:16:54,500
And that's that's all it's going to do.

1431
01:16:55,400 --> 01:16:57,800
Now, the other thing that I need to be able to do is I need to be able

1432
01:16:57,800 --> 01:17:02,000
to have these operations work even if it was an F32 that was there

1433
01:17:02,000 --> 01:17:03,300
instead, right?

1434
01:17:03,800 --> 01:17:05,300
So I need to be able to do it.

1435
01:17:05,300 --> 01:17:07,600
Where if I, if I

1436
01:17:09,900 --> 01:17:13,600
I'm going to perform one of these functions the and or the and not and

1437
01:17:13,600 --> 01:17:16,900
the or actually all three of those have to work.

1438
01:17:17,200 --> 01:17:20,500
Whether if there's an F32 on the other side of it as well, just see

1439
01:17:20,500 --> 01:17:23,200
what's going to happen here is we're going to get into a situation

1440
01:17:23,200 --> 01:17:29,300
where we need the the and not to take an F32 as well.

1441
01:17:29,500 --> 01:17:31,200
Now we could cast these here.

1442
01:17:33,600 --> 01:17:35,600
And that might be the easier way to go.

1443
01:17:35,600 --> 01:17:38,700
So we could we could do is introduce a Cast Operation that cast, the

1444
01:17:38,700 --> 01:17:44,100
the mask from a youth of you to an F32 directly and you know, that

1445
01:17:44,100 --> 01:17:48,000
seems like that might be the right way to go, probably a little

1446
01:17:48,000 --> 01:17:50,400
simpler than introducing, or is between all of them.

1447
01:17:51,500 --> 01:17:56,000
So, maybe I would just introduce one thing here, which would be like,

1448
01:17:56,000 --> 01:17:56,700
cast.

1449
01:17:59,200 --> 01:17:59,700
F 30.

1450
01:18:00,500 --> 01:18:03,300
Sorry, cast u-32 to F32.

1451
01:18:04,700 --> 01:18:05,300
Like that.

1452
01:18:10,600 --> 01:18:17,200
Something like this where we would then only have to do the do those

1453
01:18:17,200 --> 01:18:18,000
operations.

1454
01:18:22,200 --> 01:18:24,800
Where the types were equivalent.

1455
01:18:27,200 --> 01:18:30,600
I don't really know so you can do it either way.

1456
01:18:30,600 --> 01:18:31,700
It's again just kind of.

1457
01:18:31,700 --> 01:18:37,000
This is why I generally don't love having this idea in the first

1458
01:18:37,000 --> 01:18:37,300
place.

1459
01:18:37,300 --> 01:18:40,500
Like I generally, don't love saying oh, you know, sometimes we've got

1460
01:18:40,500 --> 01:18:42,400
a lane f42 sometimes got linear 32.

1461
01:18:42,900 --> 01:18:45,100
In fact, the way that I've done these in the past is I've actually

1462
01:18:45,100 --> 01:18:47,500
made it so that they're the same type and you're just a union of the

1463
01:18:47,500 --> 01:18:54,500
two and you know honestly I tend to like that better so maybe I should

1464
01:18:54,500 --> 01:18:56,400
have done that here but you know

1465
01:18:57,700 --> 01:18:58,300
The lake now.

1466
01:18:58,700 --> 01:19:01,500
Anyway, so if you take a look at that, we would need to have a cast

1467
01:19:01,500 --> 01:19:02,000
temperature.

1468
01:19:02,000 --> 01:19:06,700
And we'd also need to have the and operation here or we could just say

1469
01:19:06,700 --> 01:19:07,600
that the

1470
01:19:10,400 --> 01:19:13,800
I mean the other thing we could do is just say this could be a

1471
01:19:13,800 --> 01:19:18,000
specific operation that we only code that we hand code per one, we

1472
01:19:18,000 --> 01:19:21,600
could make the conditional assignment, just be hand coded, right?

1473
01:19:24,400 --> 01:19:30,400
I don't know the u-32 one will just work because that one is just the

1474
01:19:30,400 --> 01:19:31,500
same all throughout.

1475
01:19:31,700 --> 01:19:34,400
So maybe the right thing to do is just have the float conditional sign

1476
01:19:34,400 --> 01:19:35,800
because it is a little wonky.

1477
01:19:36,000 --> 01:19:37,600
Maybe that one we just code specially.

1478
01:19:37,600 --> 01:19:40,200
So we don't because we really don't need the rest of that stuff too

1479
01:19:40,200 --> 01:19:42,700
much in here anyway.

1480
01:19:43,500 --> 01:19:47,000
So if we were going to code that when specially right then it's just

1481
01:19:48,300 --> 01:19:48,900
Mmm.

1482
01:19:52,100 --> 01:19:53,600
And not PS.

1483
01:19:54,700 --> 01:19:58,300
Mmm, convert epi32.

1484
01:19:58,300 --> 01:19:59,100
PS.

1485
01:20:00,400 --> 01:20:01,400
Stardust.

1486
01:20:05,900 --> 01:20:06,300
Mmm.

1487
01:20:06,300 --> 01:20:07,500
4ps

1488
01:20:15,000 --> 01:20:16,200
And PS.

1489
01:20:18,400 --> 01:20:21,500
and I guess right here we would also say like, okay so there's an M&M

1490
01:20:22,200 --> 01:20:27,700
128 that's you know, the mask converted

1491
01:20:32,100 --> 01:20:32,600
So on.

1492
01:20:36,600 --> 01:20:41,100
Right, sweetie, or the and not in the and together and off we go now

1493
01:20:41,100 --> 01:20:44,500
it's worth noting that this is a very common operation and it's kind

1494
01:20:44,500 --> 01:20:46,800
of weird that they didn't put it in there to begin with but I think

1495
01:20:46,800 --> 01:20:49,500
it's because it would have to be ternary and some weird way probably

1496
01:20:50,800 --> 01:20:52,700
and they don't always love that.

1497
01:20:54,900 --> 01:20:59,800
but once they added turnery Ops, I believe,

1498
01:21:05,700 --> 01:21:06,800
That got in here.

1499
01:21:09,600 --> 01:21:12,000
Don't remember what it's called.

1500
01:21:24,100 --> 01:21:28,200
Because I've never actually used it because I always do it manually

1501
01:21:28,200 --> 01:21:30,900
because I don't have access to the instruction normally on things that

1502
01:21:30,900 --> 01:21:31,600
I ship.

1503
01:21:41,000 --> 01:21:42,800
I'm pretty sure got outed.

1504
01:21:59,000 --> 01:22:00,300
It's not extract.

1505
01:22:15,500 --> 01:22:16,700
I don't know what it's called.

1506
01:22:17,100 --> 01:22:19,000
I'm trying to look for it now but

1507
01:22:20,700 --> 01:22:24,900
The point is this operation right here where you do an or of the Ann's

1508
01:22:24,900 --> 01:22:31,600
not in the and is basically selecting Lanes, based on a mask that is

1509
01:22:31,600 --> 01:22:40,600
an actual operation that is, you know, is widely used and eventually

1510
01:22:40,600 --> 01:22:43,300
became part of the instruction set, if I remember correctly.

1511
01:22:54,100 --> 01:22:54,700
All right.

1512
01:23:00,100 --> 01:23:01,700
okay, so, back to our program,

1513
01:23:03,700 --> 01:23:07,800
So clamp 01 is something that we can Implement actually much more

1514
01:23:07,800 --> 01:23:09,000
efficiently now than we used to.

1515
01:23:09,700 --> 01:23:13,200
So if you take a look at what clamps are one was doing back here in

1516
01:23:13,200 --> 01:23:17,400
the old days, you can see how it was operating in scalar form here,

1517
01:23:17,400 --> 01:23:17,900
right?

1518
01:23:18,700 --> 01:23:23,300
And it's not very good involves sumifs and and garbage like this and

1519
01:23:23,300 --> 01:23:26,300
we can do much better than that now that we've got sort of a better

1520
01:23:26,300 --> 01:23:27,000
instruction set.

1521
01:23:27,000 --> 01:23:27,900
So, for example,

1522
01:23:30,600 --> 01:23:35,400
if you come in here and Implement Elaine F32 clamp like so

1523
01:23:38,200 --> 01:23:39,000
What we can do.

1524
01:23:40,500 --> 01:23:43,700
Is say, well, if you want to clamp something between 0 and 1, really

1525
01:23:43,700 --> 01:23:50,200
all that is is that saying, well, we want to take the, we want to do a

1526
01:23:50,200 --> 01:23:52,600
Min and a Max pass, right?

1527
01:23:52,800 --> 01:23:59,600
We first want to take the maximum value, right between whatever the

1528
01:23:59,600 --> 01:23:59,800
the

1529
01:24:00,000 --> 01:24:03,000
It is and 0, right?

1530
01:24:03,900 --> 01:24:06,000
And then we want to take a Min value.

1531
01:24:06,000 --> 01:24:10,200
I'll clamp it on here between that and one, right?

1532
01:24:11,700 --> 01:24:15,300
I mean, that's that's really all we're doing, right?

1533
01:24:17,800 --> 01:24:21,300
And so, one of the things is that if we write it like that, we can

1534
01:24:21,300 --> 01:24:26,300
then leverage the fact that those instructions unlike x64 in the

1535
01:24:26,300 --> 01:24:29,900
actual SSE instructions, those actually exist.

1536
01:24:30,200 --> 01:24:32,000
So we can actually do

1537
01:24:33,700 --> 01:24:35,600
Min and Max instructions directly.

1538
01:24:41,100 --> 01:24:44,100
And so if we actually Implement those, this becomes much simpler,

1539
01:24:44,400 --> 01:24:44,900
right?

1540
01:24:45,400 --> 01:24:46,400
So we can take

1541
01:25:05,100 --> 01:25:09,000
These two here and now we would have an actual Min and Max, right?

1542
01:25:09,100 --> 01:25:10,000
And you can see

1543
01:25:12,700 --> 01:25:18,100
And here very fast just as a quick selection where it picks whichever

1544
01:25:18,700 --> 01:25:21,100
the minimum or maximum value values.

1545
01:25:21,100 --> 01:25:25,200
Are at that point, we can Implement a nice clamp.

1546
01:25:25,200 --> 01:25:29,300
That's actually just two instructions long that does exactly what we

1547
01:25:29,300 --> 01:25:30,400
want, right?

1548
01:25:30,500 --> 01:25:34,000
And again, that's something that we can use irrespective of the lane

1549
01:25:34,000 --> 01:25:37,200
with because as long as we Implement a minute, Max function, we can

1550
01:25:37,200 --> 01:25:40,000
get our clamps for free and they're quite fast.

1551
01:25:40,000 --> 01:25:42,300
They're going to be better than the clamps we were using before.

1552
01:25:42,700 --> 01:25:47,400
We'll get four clamps done in less time than it would have taken

1553
01:25:47,400 --> 01:25:48,700
before for us to do the ifs.

1554
01:25:48,700 --> 01:25:49,800
Unless the compiler was smart.

1555
01:25:49,800 --> 01:25:53,100
And turn them into min-max, has like that itself.

1556
01:25:55,100 --> 01:25:57,900
okay, so let's go ahead and

1557
01:25:59,500 --> 01:26:00,300
keep going here.

1558
01:26:02,800 --> 01:26:03,100
Yep.

1559
01:26:03,100 --> 01:26:10,300
So these are just plain from convert these values up here.

1560
01:26:11,400 --> 01:26:12,000
There we go.

1561
01:26:12,600 --> 01:26:13,800
What was the problem?

1562
01:26:13,800 --> 01:26:16,100
Can I convert argument one?

1563
01:26:16,500 --> 01:26:17,600
That's a good point.

1564
01:26:18,700 --> 01:26:19,500
Sorry about that.

1565
01:26:25,800 --> 01:26:30,200
Okay, so now we've got these V4 operations which I don't actually

1566
01:26:30,200 --> 01:26:30,800
wants.

1567
01:26:31,400 --> 01:26:34,400
I don't want any V4 is in the program now because I just don't want to

1568
01:26:34,400 --> 01:26:35,300
deal with them, right?

1569
01:26:36,000 --> 01:26:38,000
So we're going to get rid of all these.

1570
01:26:41,300 --> 01:26:47,300
And then we're just going to implement the, the srgb stuff.

1571
01:26:47,500 --> 01:26:53,300
We're going to take that and put that in its own, sort of special

1572
01:26:53,800 --> 01:26:56,000
thing that we're going to do separately, right?

1573
01:27:00,000 --> 01:27:00,300
Okay.

1574
01:27:02,200 --> 01:27:02,800
All right.

1575
01:27:03,600 --> 01:27:06,800
So now in these cases where we've got sort of things in here that

1576
01:27:06,800 --> 01:27:10,200
we're still sort of using V3 is in some way.

1577
01:27:10,400 --> 01:27:15,000
I'm just going to Loft those up to be v3s, just by default.

1578
01:27:15,300 --> 01:27:18,700
And what that will mean is that when we load them, we can load them

1579
01:27:18,700 --> 01:27:21,700
directly and we don't have to replicate them anymore.

1580
01:27:22,400 --> 01:27:25,700
That might not be the greatest thing cache size wise when we start to

1581
01:27:25,700 --> 01:27:29,200
blow these things out into bigger things, but the other thing that's

1582
01:27:29,200 --> 01:27:31,200
interesting about that is, we could in the future.

1583
01:27:33,300 --> 01:27:36,800
we can in the future, just have these, the three floating Point values

1584
01:27:36,800 --> 01:27:38,200
that we then you know,

1585
01:27:40,100 --> 01:27:42,900
That we then deal with slightly differently or something right?

1586
01:27:43,600 --> 01:27:47,600
But for the moment I'm going to go ahead and make those people own out

1587
01:27:47,600 --> 01:27:49,400
just because why not, right?

1588
01:27:53,700 --> 01:27:54,500
And we'll go from there.

1589
01:27:56,100 --> 01:28:00,000
All right, so we don't actually need to do this anymore because these

1590
01:28:00,000 --> 01:28:00,900
are going to be

1591
01:28:06,500 --> 01:28:08,400
Well you know what I could do actually I didn't take that.

1592
01:28:08,400 --> 01:28:11,400
I'm gonna take that back just for a second for a quick second.

1593
01:28:14,100 --> 01:28:17,000
What we could do is Define that as a storage only thing.

1594
01:28:18,200 --> 01:28:18,700
Right.

1595
01:28:19,100 --> 01:28:21,300
I could see that being the case.

1596
01:28:22,200 --> 01:28:25,100
So we could do something like a V3.

1597
01:28:27,100 --> 01:28:28,300
Is for storage only.

1598
01:28:35,800 --> 01:28:38,400
And we never do anything else with it, right?

1599
01:28:40,500 --> 01:28:42,000
So I'd be okay with that potentially.

1600
01:28:43,500 --> 01:28:47,400
And it looks like, oh, sorry, that guess that has to be.

1601
01:28:49,700 --> 01:28:50,200
Taste.

1602
01:28:56,200 --> 01:28:57,000
And that seems okay.

1603
01:28:58,500 --> 01:29:02,300
Alright, so in this case we still can implement this function and

1604
01:29:02,300 --> 01:29:03,400
that's totally fine.

1605
01:29:08,000 --> 01:29:14,100
And we've sort of going to have to re backport it for the for the

1606
01:29:22,700 --> 01:29:26,300
I feel scalar version which will do but all this is going to do is

1607
01:29:26,300 --> 01:29:30,800
just load one of these from the storage format, right?

1608
01:29:40,000 --> 01:29:41,500
Stick with my ninja convention there.

1609
01:29:48,000 --> 01:29:48,400
All right.

1610
01:29:48,400 --> 01:29:51,800
And so that's just going to replicate the values across which is all

1611
01:29:51,800 --> 01:29:53,300
we really needed them to do anyway.

1612
01:29:54,600 --> 01:29:58,100
And there's not a lot more to it than that we will need to Define

1613
01:29:58,100 --> 01:29:58,600
that.

1614
01:30:00,800 --> 01:30:02,500
Up with the lanes stuff.

1615
01:30:04,800 --> 01:30:08,500
And that's just going to be defined right here because everyone uses

1616
01:30:08,500 --> 01:30:10,000
the same one, no matter what you're doing.

1617
01:30:11,400 --> 01:30:19,300
Okay, so this is Elena 3242 shows this.

1618
01:30:23,500 --> 01:30:27,000
So is this just lofting?

1619
01:30:46,500 --> 01:30:50,000
Plus equals is not implemented for the you 32s.

1620
01:30:50,100 --> 01:30:53,100
And we do want to, because we need to do this for statistics tracking.

1621
01:30:53,100 --> 01:30:56,400
That's really the only place that we use such a thing, but we do want

1622
01:30:56,400 --> 01:30:57,100
it to be there.

1623
01:30:57,100 --> 01:30:58,500
So let's go ahead and grab that.

1624
01:31:01,900 --> 01:31:03,400
So for you 32s?

1625
01:31:05,600 --> 01:31:10,600
Just going to look like this, and I'm going to grab the operator +

1626
01:31:10,600 --> 01:31:11,100
appear.

1627
01:31:11,100 --> 01:31:13,500
So we don't have one, right?

1628
01:31:13,500 --> 01:31:18,000
You can see us doing the plus operator.

1629
01:31:18,000 --> 01:31:20,700
Therefore, playing F 32 plus looking at food to.

1630
01:31:21,300 --> 01:31:24,800
We're going to need one of those for laying you 32 as well.

1631
01:31:26,600 --> 01:31:27,900
And again, that's really simple.

1632
01:31:27,900 --> 01:31:30,200
It's the same exact destruction just for integers.

1633
01:31:30,200 --> 01:31:32,100
It's epi32 instead of PS.

1634
01:31:32,100 --> 01:31:33,300
Exactly as you would expect.

1635
01:31:33,300 --> 01:31:35,300
So nothing, weird going on there, right?

1636
01:31:37,300 --> 01:31:38,300
What are you saying?

1637
01:31:38,900 --> 01:31:41,200
And yes, that's true.

1638
01:31:41,200 --> 01:31:42,500
It's going to return a u-32.

1639
01:31:42,500 --> 01:31:43,300
Now, I'm at 42.

1640
01:31:46,300 --> 01:31:48,500
Cannot convert from Lane u-32.

1641
01:31:48,500 --> 01:31:51,900
Same, same is true here, got to change the return type.

1642
01:31:54,700 --> 01:31:56,200
And so here again, we're loading.

1643
01:31:59,300 --> 01:32:01,300
Elaine V3 from a regular V3.

1644
01:32:02,200 --> 01:32:04,700
And here, we're loading a lane at 3:57.

1645
01:32:06,200 --> 01:32:09,100
My 32 and I really wish you didn't have to type that I don't

1646
01:32:09,100 --> 01:32:11,800
understand why you can't tell it.

1647
01:32:11,800 --> 01:32:16,400
To use, operator equals there, it's just C++ being stupid as it always

1648
01:32:16,400 --> 01:32:16,600
is.

1649
01:32:16,600 --> 01:32:20,000
There's probably some ridiculous Incarnation, you can do to make it

1650
01:32:20,000 --> 01:32:22,400
work and then if you do that, a bunch of other stuff in your program

1651
01:32:22,400 --> 01:32:24,200
will break because that's C++.

1652
01:32:24,900 --> 01:32:29,000
So I'm just not going to bother right now but so we've got

1653
01:32:29,200 --> 01:32:32,500
Logical or and a logical end here.

1654
01:32:34,300 --> 01:32:39,600
And I think in this case, since we know that these masks produce the

1655
01:32:39,600 --> 01:32:48,300
correct values we should be able to use a binary and an or again

1656
01:32:48,300 --> 01:32:52,000
because we know that these less than and greater than will produce

1657
01:32:52,000 --> 01:32:53,400
zeros or one masks.

1658
01:32:53,400 --> 01:32:58,300
Predictably, the only thing I don't know is whether the scalar version

1659
01:32:58,300 --> 01:32:59,000
will still work.

1660
01:32:59,100 --> 01:32:59,600
Properly.

1661
01:33:00,500 --> 01:33:05,500
Because I'm not sure what C is required to do in the case where you do

1662
01:33:05,500 --> 01:33:06,300
something less.

1663
01:33:06,300 --> 01:33:07,300
Something else.

1664
01:33:10,300 --> 01:33:11,500
Let me see.

1665
01:33:19,000 --> 01:33:20,600
Just what one of them does.

1666
01:33:28,400 --> 01:33:31,700
This is not what I wanted at all.

1667
01:33:32,100 --> 01:33:34,100
I wanted what the values have to be.

1668
01:33:45,700 --> 01:33:47,000
What are the values, please?

1669
01:33:54,900 --> 01:33:57,600
So, it looks like they have to be 1 and 0.

1670
01:33:59,400 --> 01:33:59,900
Right.

1671
01:34:00,600 --> 01:34:05,500
So in that case, in these two circumstances, we should be able to do

1672
01:34:05,500 --> 01:34:06,100
that.

1673
01:34:06,400 --> 01:34:06,900
Right.

1674
01:34:07,400 --> 01:34:10,300
Which is good because we don't want to have to have logical operators

1675
01:34:10,300 --> 01:34:10,700
as well.

1676
01:34:10,700 --> 01:34:13,600
If we can avoid it because they would involve doing extra conditioning

1677
01:34:13,600 --> 01:34:18,600
work on the values themselves to make sure that they conform and we

1678
01:34:18,600 --> 01:34:20,500
would rather not have to do that extra work.

1679
01:34:22,200 --> 01:34:25,700
We want we want to, you know, do it as efficiently as possible when

1680
01:34:25,700 --> 01:34:28,400
we're inside this part of the thing.

1681
01:34:37,000 --> 01:34:37,400
So yeah.

1682
01:34:38,700 --> 01:34:39,400
Same here.

1683
01:34:46,100 --> 01:34:47,500
And I think that should be okay.

1684
01:34:50,100 --> 01:34:52,000
So no blood upward, okay?

1685
01:34:52,000 --> 01:34:55,400
So now we've gotten to the place where we actually have to do the

1686
01:34:55,400 --> 01:34:56,200
loads here.

1687
01:34:56,700 --> 01:35:00,600
And these are annoying because obviously we have to load each

1688
01:35:00,600 --> 01:35:03,200
individual one of these separately, right?

1689
01:35:03,400 --> 01:35:06,200
So what we're going to do is we have a lane V3 here

1690
01:35:07,800 --> 01:35:11,100
Right and an F32.

1691
01:35:13,000 --> 01:35:14,800
I don't know why that's not a lane F32.

1692
01:35:16,200 --> 01:35:22,200
So these have to be lofted up from slices so that that material index

1693
01:35:22,200 --> 01:35:26,800
is going to load out of out of a couple different places, right?

1694
01:35:27,500 --> 01:35:32,300
So we need to actually do a scattered load here and that's actually

1695
01:35:32,300 --> 01:35:33,700
kind of tricky to do.

1696
01:35:37,900 --> 01:35:41,600
I'm not sure how we want to write this, exactly.

1697
01:35:41,600 --> 01:35:43,500
So that it works on all the platforms,

1698
01:35:46,800 --> 01:35:48,900
Scalar, as well as a separate.

1699
01:35:48,900 --> 01:35:51,500
And there are no instructions that you do scattered loads.

1700
01:35:51,700 --> 01:35:57,300
So probably what we'd want to do here is a load V3 and a load F32 that

1701
01:35:57,300 --> 01:35:59,800
take sort of a stride and an index.

1702
01:36:00,000 --> 01:36:00,600
Of a thing.

1703
01:36:03,100 --> 01:36:04,300
And I think that's the only way.

1704
01:36:04,300 --> 01:36:05,800
We're going to really be able to do it.

1705
01:36:10,700 --> 01:36:16,000
So I'm going to do a thing here called gather V3, which is just going

1706
01:36:16,000 --> 01:36:17,100
to take a pointer.

1707
01:36:19,500 --> 01:36:25,700
The thing to load and then the offset of the thing, right?

1708
01:36:26,000 --> 01:36:29,300
So what I'm the way I'm actually going to do that is I'm actually

1709
01:36:29,300 --> 01:36:33,800
going to sort of do it a little bit so it's just slightly differently

1710
01:36:34,400 --> 01:36:36,100
which is I'm going to sort of say

1711
01:36:38,000 --> 01:36:43,300
That the the part of it that you're loading is actually just

1712
01:36:43,300 --> 01:36:47,100
specified, like the member that's being loaded as specified at the end

1713
01:36:48,400 --> 01:36:52,000
and the so it's the pointer, then the member at the end.

1714
01:37:05,700 --> 01:37:09,900
So this admit killer has to be has to return zero on Lane mask.

1715
01:37:10,100 --> 01:37:14,600
So I think that what that means is in here, we would want to mask this

1716
01:37:15,400 --> 01:37:16,200
this off.

1717
01:37:16,800 --> 01:37:21,100
So when we return this mat emit color, and we put that we made sure,

1718
01:37:21,100 --> 01:37:24,300
we put that note in there that has to get masked off, right?

1719
01:37:30,800 --> 01:37:34,100
I guess what that means is in here, we would have to actually do the

1720
01:37:34,100 --> 01:37:35,200
mask, right?

1721
01:37:35,300 --> 01:37:44,200
So we'd have to do laying mask and to make sure that we wouldn't we

1722
01:37:44,200 --> 01:37:48,300
wouldn't ever load an Omission in a case where array was dead, right?

1723
01:37:50,800 --> 01:37:52,500
But I think that's all we would have to do their.

1724
01:37:52,500 --> 01:37:58,100
There's our ref color and here's our gather F32 World materials,

1725
01:37:58,500 --> 01:37:59,900
Hitman Index, right?

1726
01:38:02,800 --> 01:38:06,100
And so, what this does is The Gather operation is the thing that we

1727
01:38:06,100 --> 01:38:06,900
need to do.

1728
01:38:06,900 --> 01:38:09,100
That will basically load in

1729
01:38:11,300 --> 01:38:18,400
You know, it will load in each of the value sets that we need by

1730
01:38:18,400 --> 01:38:21,400
grabbing from multiple indices and pulling them in.

1731
01:38:21,400 --> 01:38:25,500
This is one of the worst operations you can do, it's really good that

1732
01:38:25,500 --> 01:38:26,400
we only do it.

1733
01:38:26,400 --> 01:38:30,200
After all of the work has been done basically So that's its infrequent

1734
01:38:30,200 --> 01:38:35,300
and it's basically the the it's the thing that that group gpus do the

1735
01:38:35,300 --> 01:38:40,800
best that CPUs do the worst right now, which is gpus have great gather

1736
01:38:40,800 --> 01:38:41,100
they.

1737
01:38:41,300 --> 01:38:43,500
Oh, do texture fetches and all these other sorts things and they have

1738
01:38:43,500 --> 01:38:46,200
special purpose Hardware to gather it right where you've got.

1739
01:38:46,200 --> 01:38:50,100
You know, if you've got a 4x4 grid of 16 pixels in each, one of them

1740
01:38:50,100 --> 01:38:54,800
used to fetch or different texture thing, they can just do that.

1741
01:38:54,900 --> 01:38:58,600
The CPUs have horrible options for this and it's basically all manual

1742
01:38:58,600 --> 01:38:59,500
and really slow.

1743
01:39:00,000 --> 01:39:03,900
This is a nasty part and it is generally a nasty part, it's not just

1744
01:39:03,900 --> 01:39:06,800
nasty for us, it's nasty period.

1745
01:39:07,200 --> 01:39:13,700
In x64 land, neon has some scattered stuff, satyr gather stuff and

1746
01:39:13,700 --> 01:39:16,700
avx-512 I think may have some scatter gather stuff although I don't

1747
01:39:16,700 --> 01:39:17,900
know if that's even implemented yet.

1748
01:39:17,900 --> 01:39:18,900
It's sort of been the spec.

1749
01:39:18,900 --> 01:39:21,900
I don't remember if it ever got in to the latest tips or not, there's

1750
01:39:21,900 --> 01:39:23,600
those word, caps bits of crap, like that.

1751
01:39:23,600 --> 01:39:24,100
So I don't know.

1752
01:39:24,900 --> 01:39:25,300
Anyway,

1753
01:39:26,900 --> 01:39:28,200
So here comes our nway load.

1754
01:39:28,200 --> 01:39:31,100
We need these gather instructions, so let's go ahead and put them in.

1755
01:39:33,200 --> 01:39:37,500
First of all, gather V3 is again something that I think we can write.

1756
01:39:37,500 --> 01:39:38,700
I don't know why these are in lines.

1757
01:39:38,700 --> 01:39:41,100
I didn't accidentally just cut and paste it.

1758
01:39:41,100 --> 01:39:42,400
I think I typed in line for no reason.

1759
01:39:43,600 --> 01:39:49,500
So for example, The Gather V3 should be something that we can do

1760
01:39:50,500 --> 01:39:55,000
automatically in terms of The Gather F32, right?

1761
01:39:55,800 --> 01:39:58,100
So it's really only The Gather F32 that we're going to have to write

1762
01:39:58,100 --> 01:40:00,900
and we want to write these in terms of the macro why we want them

1763
01:40:00,900 --> 01:40:02,800
right between the macro because we want the title.

1764
01:40:03,500 --> 01:40:06,700
To be known to us so that we can figure out what the strides going to

1765
01:40:06,700 --> 01:40:07,700
be, right.

1766
01:40:09,400 --> 01:40:11,800
So, we're going to have the base pointer.

1767
01:40:13,100 --> 01:40:13,300
Right?

1768
01:40:13,300 --> 01:40:14,500
That's the materials array.

1769
01:40:15,100 --> 01:40:18,000
We're going to have the index, which is packed for a wide and we're

1770
01:40:18,000 --> 01:40:20,500
going to have the number right, which we're going to add, which are

1771
01:40:20,500 --> 01:40:24,300
going to address off of that's going to, then call our actual

1772
01:40:24,300 --> 01:40:28,200
function, which will pass the base pointer as just a raw pointer.

1773
01:40:28,400 --> 01:40:33,500
It will pass the size of whatever the base pointer is pointing to, so

1774
01:40:33,500 --> 01:40:35,800
that will let us know how wide The Stride is.

1775
01:40:36,500 --> 01:40:38,500
It will pass the offset of

1776
01:40:41,400 --> 01:40:44,200
The that member.

1777
01:40:44,600 --> 01:40:46,700
So basically I guess I don't have to do it that way.

1778
01:40:47,100 --> 01:40:50,300
What I could do is say, all right, so the base pointer member

1779
01:40:55,200 --> 01:40:58,200
Here, I just want to know how far I have to go to get the base pointer

1780
01:40:58,200 --> 01:40:58,600
member.

1781
01:40:58,600 --> 01:41:01,500
In fact, I guess, you know what, I don't even have to do that, take it

1782
01:41:01,500 --> 01:41:01,800
back.

1783
01:41:04,200 --> 01:41:06,000
I'll just Advance the base pointer.

1784
01:41:08,500 --> 01:41:11,000
To that member and take the address.

1785
01:41:11,000 --> 01:41:13,400
Now, we know are pointing directly at that member and we know what the

1786
01:41:13,400 --> 01:41:15,300
stride is, as well, right.

1787
01:41:18,800 --> 01:41:23,300
And then, all I have to do is specify what that again with that index

1788
01:41:23,300 --> 01:41:24,600
is that we're loading from?

1789
01:41:26,900 --> 01:41:30,100
So then our actual function after the macro has kind of cracked out

1790
01:41:30,100 --> 01:41:31,100
those values for it.

1791
01:41:31,300 --> 01:41:34,000
For us is going to take the bait.

1792
01:41:34,000 --> 01:41:37,900
The, the base pointer the stride

1793
01:41:41,400 --> 01:41:45,100
This is actually just a, do we have a memory size value here?

1794
01:41:46,800 --> 01:41:49,700
You 64, I guess would be fine.

1795
01:41:53,500 --> 01:41:56,800
it's going to take the stride, it would really it should really and we

1796
01:41:56,800 --> 01:41:59,800
can we can do it, you 32 doesn't have to be, we know that these

1797
01:42:00,000 --> 01:42:05,300
Just can't be that big and then it's going to take a lane, you 32 for

1798
01:42:05,300 --> 01:42:08,100
the index in the Seas, right?

1799
01:42:09,500 --> 01:42:14,800
And then what we want this to do is we want to have, you know, I'll

1800
01:42:14,800 --> 01:42:18,400
make both of these and we'll cut paste the other one up above, but we

1801
01:42:18,400 --> 01:42:19,800
want to have both of these, right?

1802
01:42:20,100 --> 01:42:24,300
So our gather F32 is going to do the exact same thing.

1803
01:42:24,300 --> 01:42:27,500
In fact, both of these can be defined sort of outside, right?

1804
01:42:27,800 --> 01:42:31,200
These are going to be the same no matter what in either case.

1805
01:42:33,300 --> 01:42:35,900
Everything's no matter who's doing, what those are going to be the

1806
01:42:35,900 --> 01:42:36,300
same.

1807
01:42:37,500 --> 01:42:38,400
So that's all fine.

1808
01:42:47,100 --> 01:42:51,200
And as I believe all we have to do here is we'll have to implement the

1809
01:42:51,200 --> 01:42:57,100
gather F50 21, but the gather v31 can just be implemented in terms of

1810
01:42:57,100 --> 01:42:58,800
the F32 one, right?

1811
01:43:00,700 --> 01:43:02,900
So here, we got our lane V3 that we're going to gather.

1812
01:43:05,200 --> 01:43:07,000
Result X, the result?

1813
01:43:07,000 --> 01:43:07,500
Why?

1814
01:43:10,000 --> 01:43:11,000
And there's a z.

1815
01:43:15,400 --> 01:43:16,800
And in this case, right?

1816
01:43:16,800 --> 01:43:20,700
We know that the thing that we're pointing at is itself and x, y, z

1817
01:43:20,700 --> 01:43:21,300
value.

1818
01:43:21,600 --> 01:43:24,900
So we know that we just have to take our base pointer, whatever that

1819
01:43:24,900 --> 01:43:32,000
base pointer is and turn it into a floating point value, right?

1820
01:43:32,700 --> 01:43:37,100
And then, we can just Advance it one floating point value for every

1821
01:43:37,100 --> 01:43:40,200
time we wanted to do a gather and we're done.

1822
01:43:46,300 --> 01:43:49,500
Now this is not the most efficient way we could gather these.

1823
01:43:49,700 --> 01:43:53,100
We could do a load and then do some bit operations to gather them.

1824
01:43:54,000 --> 01:43:55,400
So I'm just going to put to do here.

1825
01:44:09,900 --> 01:44:15,000
We could do better than this by special casing it for each lane with.

1826
01:44:21,000 --> 01:44:22,400
But at the moment, we're not going to do that.

1827
01:44:23,500 --> 01:44:26,300
Alright, so now I'm going to do an F32 load.

1828
01:44:27,300 --> 01:44:28,600
I'm going to an F32 load.

1829
01:44:31,400 --> 01:44:34,500
Using these indices here and so what we have is we've got a base

1830
01:44:34,500 --> 01:44:35,800
pointer Jimmy.

1831
01:44:37,100 --> 01:44:40,000
And we've got sorry.

1832
01:44:40,000 --> 01:44:44,600
This is Lena 32 and we've got you three, two indices here at that are

1833
01:44:44,600 --> 01:44:46,900
four different indices that we want to load from.

1834
01:44:46,900 --> 01:44:47,300
Right?

1835
01:44:47,300 --> 01:44:51,800
And so what we can do here is we could just say, all right you know

1836
01:44:51,800 --> 01:44:54,900
what here is a pointer to the indices, right?

1837
01:44:54,900 --> 01:44:58,300
We know that if we just targeted this this part of it, right?

1838
01:44:58,300 --> 01:44:59,800
That we

1839
01:45:00,000 --> 01:45:02,100
I would look at each one individually.

1840
01:45:03,500 --> 01:45:05,200
So maybe that's just what we're going to do.

1841
01:45:05,800 --> 01:45:07,700
So here is our V pointer.

1842
01:45:10,000 --> 01:45:13,800
We can now look at each of the UN 32s they're there and we can grab

1843
01:45:13,800 --> 01:45:16,800
off of the base pointer exactly what we actually want here.

1844
01:45:18,100 --> 01:45:21,800
So let's put together a lane F32

1845
01:45:23,500 --> 01:45:24,500
That is the result.

1846
01:45:24,500 --> 01:45:27,100
We're going to do an M&M set PS.

1847
01:45:27,100 --> 01:45:32,200
I think we want to set our PS because I like to do it in the other

1848
01:45:32,200 --> 01:45:34,200
order I normally like

1849
01:45:37,000 --> 01:45:42,700
Me show you I'm saying here, and I think, Fabian for pointing out the

1850
01:45:42,700 --> 01:45:44,400
fact that they already have one of these.

1851
01:45:45,000 --> 01:45:50,300
You can see that there's like a least significant value to most.

1852
01:45:50,300 --> 01:45:52,900
This goes in the order you normally see them going in.

1853
01:45:53,000 --> 01:45:56,300
So, I find that much more intuitive than set PS, which goes in the

1854
01:45:56,300 --> 01:45:58,100
opposite order, right?

1855
01:45:59,500 --> 01:46:00,700
I believe set PS.

1856
01:46:00,700 --> 01:46:01,600
Actually sets them in.

1857
01:46:01,600 --> 01:46:04,000
Yeah, you can see wait.

1858
01:46:06,300 --> 01:46:07,200
What's going on there?

1859
01:46:07,900 --> 01:46:08,700
These are not

1860
01:46:15,600 --> 01:46:16,800
Okay, I take it back.

1861
01:46:18,700 --> 01:46:19,400
That's right.

1862
01:46:19,500 --> 01:46:22,200
So set RPS, puts the first one.

1863
01:46:22,200 --> 01:46:24,100
He's just weird that they named them III.

1864
01:46:24,100 --> 01:46:28,600
In this case, it puts the least significant one first.

1865
01:46:28,600 --> 01:46:34,100
So if you think in terms of memory order, right rgba for example, this

1866
01:46:34,100 --> 01:46:37,500
one goes in the least significant, it just looks weird because of the

1867
01:46:37,500 --> 01:46:41,000
way it's written here, but it's actually easy row is what it actually

1868
01:46:41,000 --> 01:46:41,300
is.

1869
01:46:41,300 --> 01:46:42,300
It's just called III.

1870
01:46:42,300 --> 01:46:43,300
It's getting a little confused there.

1871
01:46:45,100 --> 01:46:47,200
So depending on, which one you want to do it, we can do it that way.

1872
01:46:47,200 --> 01:46:50,300
So if I want to do 0 1, 2 3, which is what I want to do, or you do set

1873
01:46:50,300 --> 01:46:54,700
RPS, because you want the least insignificant one to go in, to be

1874
01:46:54,700 --> 01:46:57,500
specified first, and the most going to be specified last.

1875
01:46:58,400 --> 01:47:03,600
So, if I set this to you eight, star base pointer, I add 0 times, the

1876
01:47:03,600 --> 01:47:06,100
stride, because we're right at the value right now,

1877
01:47:10,300 --> 01:47:14,800
I'm sorry, now's your time to strive indices 0 times.

1878
01:47:14,800 --> 01:47:19,700
The stride right then I'm going to get the value that I actually

1879
01:47:19,700 --> 01:47:23,700
expected here and I need to cast that to the thing that I'm expecting

1880
01:47:23,700 --> 01:47:26,500
it to be, which is of course an F32, right?

1881
01:47:29,200 --> 01:47:29,600
So there you go.

1882
01:47:29,600 --> 01:47:31,700
It's kind of a cryptic sequence but it's pretty straightforward, was

1883
01:47:31,700 --> 01:47:33,800
doing I'm saying I've got these four packed.

1884
01:47:33,800 --> 01:47:37,300
Indices, I want the first index times the strides, which is however,

1885
01:47:37,300 --> 01:47:38,800
far I have to go for each index.

1886
01:47:39,300 --> 01:47:42,800
I want to add that to whatever the base pointer was and then and I

1887
01:47:42,800 --> 01:47:44,500
want to do that in actual bytes.

1888
01:47:44,800 --> 01:47:48,500
Then I want to say that, whatever I'm pointing at take that F32 and

1889
01:47:48,500 --> 01:47:50,200
load it, right?

1890
01:47:51,700 --> 01:47:58,000
I want to do this four times once for every index.

1891
01:48:00,000 --> 01:48:01,500
Then I've done a striated load, right?

1892
01:48:01,500 --> 01:48:04,000
I've gathered from a couple different places.

1893
01:48:04,400 --> 01:48:06,500
Again this really should be an instruction.

1894
01:48:07,100 --> 01:48:09,600
It's an instruction that kind of completes the set.

1895
01:48:09,800 --> 01:48:12,300
The fact that there is no strided gather basically means that you

1896
01:48:12,300 --> 01:48:14,900
can't do array offsetting and Gathering and stuff like that in the

1897
01:48:14,900 --> 01:48:17,000
instruction set and you always have to downshift.

1898
01:48:17,000 --> 01:48:21,400
It's rough but that's just the way it is unfortunately.

1899
01:48:22,300 --> 01:48:24,700
So you know what you gonna do anyway?

1900
01:48:25,100 --> 01:48:25,700
So

1901
01:48:26,900 --> 01:48:30,000
I'm not sure why it says I didn't phrase not find for Gather F32, did

1902
01:48:30,000 --> 01:48:31,300
I put it in the wrong place?

1903
01:48:31,300 --> 01:48:32,000
I did.

1904
01:48:33,700 --> 01:48:37,300
Basically, up more, and one thing we could do is break these out into

1905
01:48:37,300 --> 01:48:39,800
separate files, that might be a nice thing to do, so that we don't

1906
01:48:39,800 --> 01:48:43,200
keep getting confused between them multiple ones of these.

1907
01:48:43,200 --> 01:48:43,600
Right?

1908
01:48:45,600 --> 01:48:48,300
Which I am occasionally want to do, so that might be fun to do as

1909
01:48:48,300 --> 01:48:48,400
well.

1910
01:48:48,400 --> 01:48:49,900
Maybe we could do that a little bit later on.

1911
01:48:50,800 --> 01:48:52,600
So, anyway, off we go.

1912
01:48:52,600 --> 01:48:53,600
We got the set RPS.

1913
01:48:53,600 --> 01:48:54,100
I don't know why.

1914
01:48:54,100 --> 01:48:55,700
I've got an extra parentheses there.

1915
01:48:57,200 --> 01:48:57,500
Oh wait.

1916
01:48:57,500 --> 01:48:57,600
No.

1917
01:48:57,600 --> 01:48:58,300
I do need that.

1918
01:48:58,300 --> 01:48:59,100
I do need that.

1919
01:49:00,200 --> 01:49:01,400
That's the parentheses on this.

1920
01:49:01,400 --> 01:49:02,600
So each one of those there you go.

1921
01:49:04,200 --> 01:49:04,900
So that's correct.

1922
01:49:04,900 --> 01:49:10,900
Cannot convert em 128.

1923
01:49:10,900 --> 01:49:11,900
Oh that's okay too.

1924
01:49:11,900 --> 01:49:12,500
Actually

1925
01:49:23,000 --> 01:49:27,400
And so this here is no longer going to happen, right?

1926
01:49:27,400 --> 01:49:28,200
That goes away.

1927
01:49:30,500 --> 01:49:32,400
And the lane mask.

1928
01:49:32,400 --> 01:49:37,400
Here again, is sort of doing a mask operation on on this gather V3.

1929
01:49:38,000 --> 01:49:43,000
We don't, that's something that we don't quite have yet.

1930
01:49:44,400 --> 01:49:45,900
So, yeah.

1931
01:49:45,900 --> 01:49:50,700
If we take a look at the emit color here, it's just getting used there

1932
01:49:50,700 --> 01:49:51,700
in the hadamard.

1933
01:49:51,800 --> 01:49:53,500
What I could do is say

1934
01:49:56,000 --> 01:49:59,300
Yeah, I think we just want to implement that actual and operation.

1935
01:49:59,600 --> 01:49:59,900
Right.

1936
01:49:59,900 --> 01:50:03,400
I think that's something we actually want to do there so let's just go

1937
01:50:03,400 --> 01:50:04,300
ahead and do that.

1938
01:50:06,000 --> 01:50:06,600
All right.

1939
01:50:07,100 --> 01:50:10,700
So in re Lane how we doing on time here, we're not doing too bad on

1940
01:50:10,700 --> 01:50:11,100
time.

1941
01:50:11,800 --> 01:50:14,900
So in re Lane, I've got the

1942
01:50:18,300 --> 01:50:22,300
I've got to do one thing here which is that and operation operator and

1943
01:50:23,100 --> 01:50:28,900
we need to be able to do an operator and between two of these that are

1944
01:50:29,000 --> 01:50:36,200
you know I want if I want to be able to mask one of the F32 s by, you

1945
01:50:36,200 --> 01:50:40,500
know I want to be able to do like an F32 mask in this in this order,

1946
01:50:40,700 --> 01:50:41,200
right?

1947
01:50:43,400 --> 01:50:46,200
Then what I want to do here is say like, okay I'm going to do an end

1948
01:50:46,200 --> 01:50:49,000
PS, and I'm going to just do a conversion of the Mask variable.

1949
01:50:54,400 --> 01:50:56,800
And now that I think about it, I think.

1950
01:51:02,800 --> 01:51:04,600
Well, alright, I'll leave it this way for now.

1951
01:51:05,800 --> 01:51:08,400
So again I want to do a Cat cast.

1952
01:51:12,400 --> 01:51:13,400
Epi32.

1953
01:51:13,400 --> 01:51:14,500
Don't we have one of these.

1954
01:51:18,900 --> 01:51:19,300
I want.

1955
01:51:19,300 --> 01:51:21,300
Well, I want to do the other way around, right?

1956
01:51:21,300 --> 01:51:27,600
I want to do a cask si128 PS kind of thing, right?

1957
01:51:28,000 --> 01:51:28,800
I want to do a

1958
01:51:30,200 --> 01:51:31,100
I want to do with that.

1959
01:51:34,700 --> 01:51:36,800
Before I do my end there, right?

1960
01:51:46,300 --> 01:51:47,300
Yes, I went to meet ups.

1961
01:51:47,300 --> 01:51:47,900
That's what I want.

1962
01:51:51,400 --> 01:51:51,900
All right?

1963
01:51:52,400 --> 01:51:54,300
And so four-lane.

1964
01:51:54,300 --> 01:51:55,100
V3's.

1965
01:51:55,200 --> 01:51:56,200
Now that I've got one of those.

1966
01:51:56,200 --> 01:51:57,600
I can just do that.

1967
01:51:57,600 --> 01:52:00,800
Operation defined for the lean be 3.

1968
01:52:07,500 --> 01:52:13,400
Put that down at the bottom here, so an and operation for a lane V3

1969
01:52:15,300 --> 01:52:16,000
like so.

1970
01:52:24,100 --> 01:52:26,900
Where I'm going to take one of these and mask it off, it's just going

1971
01:52:26,900 --> 01:52:32,500
to be like you would expect it's just going to be an x equals b and a

1972
01:52:32,500 --> 01:52:33,700
tedx kind of a thing.

1973
01:52:33,700 --> 01:52:41,600
It's going to be this I guess I should do a D and B and it just

1974
01:52:41,600 --> 01:52:44,700
replicates across the various parts of it update.

1975
01:52:49,700 --> 01:52:55,200
So, it looks like we don't have a not equals to, for our hit mask, for

1976
01:52:55,200 --> 01:52:57,500
our, for our comparison operators there.

1977
01:52:58,200 --> 01:53:02,300
And I'm not sure why we skipped that one.

1978
01:53:07,400 --> 01:53:11,000
Looks like we've got a not equals 2 but only for f 32s and it looks

1979
01:53:11,000 --> 01:53:13,100
like we need one for you 32s as well.

1980
01:53:14,100 --> 01:53:16,100
That looks about about it right.

1981
01:53:24,700 --> 01:53:26,900
So again, just using the exact same thing here.

1982
01:53:26,900 --> 01:53:29,200
I don't know what the correct thing is.

1983
01:53:29,200 --> 01:53:31,300
So not equals to 4 epi32.

1984
01:53:31,300 --> 01:53:35,200
Do we have that comp equal to

1985
01:53:38,100 --> 01:53:39,400
so, it looks like

1986
01:53:44,000 --> 01:53:46,900
Looks like I'm gonna have to take a quick look at what they've got for

1987
01:53:46,900 --> 01:53:47,800
comparisons.

1988
01:53:47,800 --> 01:53:49,500
Let's restrict are set to stuff.

1989
01:53:49,500 --> 01:53:54,300
We actually do so it looks like we've got comp equal to

1990
01:53:57,600 --> 01:53:59,800
But not comp not equal to.

1991
01:54:02,100 --> 01:54:05,500
And the reason for that is probably just that they want us to just not

1992
01:54:05,500 --> 01:54:07,400
it after we're done, right?

1993
01:54:07,600 --> 01:54:13,000
They probably didn't want to provide a separate one for for integers

1994
01:54:13,000 --> 01:54:14,000
at that point.

1995
01:54:14,000 --> 01:54:18,900
So we have to probably use a cop equal to epi32, which would be this

1996
01:54:18,900 --> 01:54:24,000
one here and then do a not but that's okay, right?

1997
01:54:34,300 --> 01:54:36,000
I assume you've got an operation.

1998
01:54:40,100 --> 01:54:40,900
Maybe we don't.

1999
01:54:41,000 --> 01:54:43,000
Whoops, we have only compared selected.

2000
01:54:46,500 --> 01:54:49,300
So in order to do a not, we would have to do a next door with a mask.

2001
01:54:49,300 --> 01:54:51,400
It looks like, man, this is annoying.

2002
01:54:52,300 --> 01:54:55,000
I wonder is there a faster way to do it than what I'm thinking of?

2003
01:54:57,600 --> 01:55:00,700
Because if we do a cam PQ epi32, we say they're equal.

2004
01:55:00,900 --> 01:55:03,400
We then need to flip the mask, right?

2005
01:55:03,700 --> 01:55:10,200
And in order to flip the mask, we would want a not operation but a not

2006
01:55:10,200 --> 01:55:11,200
operation.

2007
01:55:13,700 --> 01:55:14,800
Is an available to us.

2008
01:55:15,500 --> 01:55:17,600
There's an and not operation.

2009
01:55:31,800 --> 01:55:33,700
But that doesn't really help us in this case.

2010
01:55:34,300 --> 01:55:36,600
So I'm going to do the stupid thing here, but it might be, I have to

2011
01:55:36,600 --> 01:55:39,600
think about that a little bit, there might be a smarter way to do that

2012
01:55:40,000 --> 01:55:42,600
without having to load a constant, right?

2013
01:55:44,000 --> 01:55:47,400
But if we just said, like, if we wanted to flip it, right?

2014
01:55:48,200 --> 01:55:54,100
We could do an xor with, you know, with zero or something, right?

2015
01:55:54,100 --> 01:55:56,300
Because then if it was, if it was a 0, it is 0.

2016
01:55:56,300 --> 01:55:57,300
It would become a 1.

2017
01:55:57,500 --> 01:56:00,700
If it was a one and a zero become a zero, right?

2018
01:56:03,300 --> 01:56:06,000
So we could just do something like this.

2019
01:56:20,500 --> 01:56:23,600
I don't know if they have an mm0, they have an M 0, PS, but I don't

2020
01:56:23,600 --> 01:56:25,100
know if they have any mm0.

2021
01:56:28,600 --> 01:56:29,800
Set zero.

2022
01:56:31,300 --> 01:56:37,500
Yeah, they do set zero si128 so they have a like a built-in for

2023
01:56:37,500 --> 01:56:38,700
saying, I want to use zero.

2024
01:56:41,700 --> 01:56:43,000
So I think

2025
01:56:45,700 --> 01:56:50,700
Operand actually Nursery too late and you're through to write six

2026
01:56:50,700 --> 01:56:55,600
left-hand, operand of type laying new 32, but there should be now

2027
01:56:56,000 --> 01:56:58,000
right hit Matt index.

2028
01:56:59,300 --> 01:56:59,800
Is itself.

2029
01:57:00,000 --> 01:57:02,000
Letting you through to right hit met index.

2030
01:57:02,400 --> 01:57:03,800
So Lane you 32.

2031
01:57:06,700 --> 01:57:10,000
And I guess this is just blamed YouTube from YouTube.

2032
01:57:13,700 --> 01:57:20,000
Hilarious not equal to 0 is actually we could just say yeah that that

2033
01:57:20,000 --> 01:57:21,900
would have been a simpler thing if you'd actually special case of

2034
01:57:21,900 --> 01:57:22,100
that.

2035
01:57:22,100 --> 01:57:24,100
But we don't really I don't think we want to go that far.

2036
01:57:25,300 --> 01:57:28,000
Alright so we've got our Max here again.

2037
01:57:28,000 --> 01:57:34,100
I'll just do Lane F32 from F32 to load that to up to a thing.

2038
01:57:35,600 --> 01:57:42,700
And now we've got ya, we've got a random bilateral, we're

2039
01:57:42,800 --> 01:57:45,600
In to pack those into a lane V3.

2040
01:57:46,400 --> 01:57:49,500
So, what I want to do here is probably just have a way to assign a

2041
01:57:49,500 --> 01:57:53,000
lane V3, from three independent components, right?

2042
01:57:53,600 --> 01:57:58,500
So, that's something that we could do outside, always, you know, we

2043
01:57:58,500 --> 01:58:01,300
can have, in fact, I guess we already have that.

2044
01:58:01,300 --> 01:58:01,800
It's

2045
01:58:06,500 --> 01:58:11,100
we really should probably just have that in here, where we've got

2046
01:58:13,800 --> 01:58:21,000
One of these, these themselves should probably just support Elaine V3

2047
01:58:21,000 --> 01:58:21,600
version.

2048
01:58:22,600 --> 01:58:27,100
But I'll I think what I'll probably do is just say, okay, let's make

2049
01:58:27,100 --> 01:58:27,800
the special one.

2050
01:58:27,800 --> 01:58:31,500
So we know when we're doing it, specifically, that just seems a little

2051
01:58:31,500 --> 01:58:35,600
bit nicer and in this case, that should just work, right?

2052
01:58:40,800 --> 01:58:47,400
In lerp here, it looks like we need one that takes a lane V3 as well,

2053
01:58:48,200 --> 01:58:51,800
and that's also fine, just put that in here.

2054
01:58:53,900 --> 01:58:57,900
Against exact same code, and that's all good.

2055
01:59:00,900 --> 01:59:02,700
The plus operator here.

2056
01:59:02,800 --> 01:59:04,000
What's that trying to add?

2057
01:59:04,000 --> 01:59:08,500
Is it trying to add a it's just Lane V3 on either side and we don't

2058
01:59:08,500 --> 01:59:09,300
have one of those yet.

2059
01:59:09,300 --> 01:59:12,300
So again that's something that we could put in here.

2060
01:59:15,300 --> 01:59:16,500
I'm not sure why there.

2061
01:59:16,500 --> 01:59:18,900
Shouldn't we have had an operator Plus in here somewhere.

2062
01:59:25,400 --> 01:59:30,000
yeah, so there's the lane V3 so it must be because it's

2063
01:59:33,000 --> 01:59:37,400
I don't quite understand where, okay, it's because I know why, it's

2064
01:59:37,400 --> 01:59:39,200
because these are not

2065
01:59:41,800 --> 01:59:45,300
This needs to come after the math stuff, right?

2066
01:59:45,700 --> 01:59:48,300
So these actually have to kind of come after the math.

2067
01:59:48,300 --> 01:59:52,400
Stuff has been defined so that's fine as well.

2068
01:59:52,400 --> 01:59:54,800
You know, that's that's a reasonable place to put them.

2069
01:59:55,700 --> 01:59:56,800
I'm fine with that.

2070
01:59:58,300 --> 01:59:58,600
Okay.

2071
02:00:00,000 --> 02:00:01,300
Now we have a few other things here.

2072
02:00:01,300 --> 02:00:04,400
We've got horizontal ad and mask is zero.

2073
02:00:05,000 --> 02:00:06,900
Let me see what else we've got here.

2074
02:00:07,200 --> 02:00:09,500
Yeah, so most of this other stuff we're basically done now.

2075
02:00:09,500 --> 02:00:14,700
So that's good because we're out of time but we're basically done with

2076
02:00:14,700 --> 02:00:16,300
our conversion and our implementation.

2077
02:00:17,100 --> 02:00:20,300
So let's go ahead and and just finish up a few more of these.

2078
02:00:21,100 --> 02:00:23,200
So in here, we've kind of got a couple other things.

2079
02:00:23,200 --> 02:00:29,900
We've got masked is zeroed this guy is actually I think this is

2080
02:00:30,000 --> 02:00:33,500
Is going to be something that has to be implemented per Lane, mask is

2081
02:00:33,500 --> 02:00:33,900
zero.

2082
02:00:34,200 --> 02:00:39,500
Horizontal add will have to be for will happen.

2083
02:00:40,000 --> 02:00:44,300
That will have to be done for the F32 s / Lane, but not for V3, is

2084
02:00:44,300 --> 02:00:46,400
because that's just again going to multiply out.

2085
02:00:47,400 --> 02:00:51,600
So if we take something like this, it's going to have to produce an

2086
02:00:51,600 --> 02:00:52,500
F32.

2087
02:00:52,800 --> 02:00:55,100
I'm sorry, this is a you through to that actually does this here,

2088
02:00:55,100 --> 02:00:55,600
right?

2089
02:00:58,900 --> 02:01:04,500
but the lien b31, which would just take an actual V3 in this case,

2090
02:01:08,900 --> 02:01:10,400
Yeah, that final color.

2091
02:01:13,000 --> 02:01:19,600
Yeah, but actually comes out as a V3, that's going to be totally fine,

2092
02:01:19,800 --> 02:01:20,300
right?

2093
02:01:21,500 --> 02:01:22,000
So, yeah.

2094
02:01:22,000 --> 02:01:22,700
So

2095
02:01:30,300 --> 02:01:35,900
if we go ahead here and say we have a result, the result X is going to

2096
02:01:35,900 --> 02:01:37,000
be equal to

2097
02:01:39,400 --> 02:01:43,100
The horizontal ad of a DOT x value.

2098
02:01:47,200 --> 02:01:47,700
Right.

2099
02:01:48,600 --> 02:01:51,000
And that just at sums up the components of it.

2100
02:01:52,400 --> 02:01:56,500
And so in this case where we've got these guys here, these are all

2101
02:01:56,500 --> 02:01:59,600
going to have to be done pearline.

2102
02:01:59,600 --> 02:02:04,200
So these are additional values that have to be additional functions.

2103
02:02:04,200 --> 02:02:06,800
Have to be implemented in the actual Lane stuff itself.

2104
02:02:08,800 --> 02:02:09,800
But again, no big deal.

2105
02:02:09,800 --> 02:02:10,300
These are pretty.

2106
02:02:10,300 --> 02:02:12,200
Oops, these are pretty easy functions.

2107
02:02:13,500 --> 02:02:14,900
Let's go ahead up and write them.

2108
02:02:18,400 --> 02:02:19,400
Right here.

2109
02:02:20,200 --> 02:02:23,900
So mask is zeroed, in this case, we've actually got

2110
02:02:26,200 --> 02:02:29,900
I think it's called mask.

2111
02:02:29,900 --> 02:02:31,400
Move, something like this.

2112
02:02:32,800 --> 02:02:33,500
Let's see here.

2113
02:02:34,000 --> 02:02:37,800
Conditionally start 8-bit integer elements from a into memory using

2114
02:02:37,800 --> 02:02:41,400
masks elements are not stored when the highest bit is not set in the

2115
02:02:41,400 --> 02:02:41,600
court.

2116
02:02:41,700 --> 02:02:42,900
No, it's not that

2117
02:02:45,800 --> 02:02:49,200
I don't actually need to move anything, so it's

2118
02:02:52,300 --> 02:02:54,100
Is it extract mess?

2119
02:02:59,200 --> 02:02:59,800
It's move.

2120
02:03:00,200 --> 02:03:03,100
Mask move mask, right?

2121
02:03:03,900 --> 02:03:05,600
Yeah, this is what we're talking about.

2122
02:03:07,400 --> 02:03:11,700
So yeah, I think we want something like this, create a mass from the

2123
02:03:11,700 --> 02:03:15,500
most significant bit of each 8-bit element and store the result in

2124
02:03:15,500 --> 02:03:17,700
dest, right?

2125
02:03:18,700 --> 02:03:24,200
So what we should be able to do here is just say, mmm, move, mass,

2126
02:03:24,900 --> 02:03:29,800
epi8 of this value and it will give us back.

2127
02:03:31,900 --> 02:03:32,900
A mask.

2128
02:03:33,300 --> 02:03:38,000
We can just say if the mask is zero, then nothing was there, right?

2129
02:03:39,500 --> 02:03:40,600
So that's very simple, right?

2130
02:03:40,600 --> 02:03:44,500
This this thing just takes those High bits and puts them into a value.

2131
02:03:44,500 --> 02:03:47,800
The processor can actually use as a general purpose register, which is

2132
02:03:47,800 --> 02:03:49,400
exactly what we want to do.

2133
02:03:49,400 --> 02:03:56,600
Our testing horizontal ads here, in this case we again want to do sort

2134
02:03:56,600 --> 02:04:00,900
of the extraction process which is unsavory but you know you have to

2135
02:04:00,900 --> 02:04:01,600
do it at the end.

2136
02:04:01,600 --> 02:04:04,000
You want to avoid how many times you're doing something like this,

2137
02:04:04,000 --> 02:04:07,600
where you're pulling stuff out of a register because it becomes it's

2138
02:04:07,600 --> 02:04:08,800
slow, right?

2139
02:04:10,400 --> 02:04:12,600
And there are sometimes instructs that faster ways to do this.

2140
02:04:12,600 --> 02:04:15,300
But this is only done at the end of all of our stuff so we don't have

2141
02:04:15,300 --> 02:04:15,900
to worry too much about it.

2142
02:04:15,900 --> 02:04:17,300
You could do it in a generic way here.

2143
02:04:18,400 --> 02:04:26,300
So here I have taken a pointer to the the values and I'm just going to

2144
02:04:26,300 --> 02:04:28,300
do the result.

2145
02:04:28,700 --> 02:04:32,100
What I could do here is return this as a you 64 as well.

2146
02:04:32,100 --> 02:04:37,500
Potentially because in this case, we could sum up more values.

2147
02:04:37,500 --> 02:04:39,800
So we could say like, cast this to you 64.

2148
02:04:40,800 --> 02:04:49,800
The 0 plus Q, 64 be 1, plus u 64, V2, plus you 64 B3.

2149
02:04:49,800 --> 02:04:53,800
And that way, we know we can't overflow it even if those values were

2150
02:04:53,800 --> 02:04:55,100
all very high.

2151
02:04:57,200 --> 02:04:58,600
We know that we can overflow.

2152
02:04:59,200 --> 02:05:01,200
If, you know, for whatever values that we had.

2153
02:05:01,400 --> 02:05:03,500
If there was an overflow, it happen beforehand, right?

2154
02:05:05,600 --> 02:05:07,000
Same thing is true for this horizontal.

2155
02:05:07,000 --> 02:05:11,600
Add only in this case we're still returning an F32 specifically and

2156
02:05:11,600 --> 02:05:13,700
that's because floats don't really overflow in that way.

2157
02:05:13,700 --> 02:05:15,000
They just get less precise.

2158
02:05:15,300 --> 02:05:17,700
And in this case we don't really care too much about that because

2159
02:05:17,700 --> 02:05:20,500
we're just using these four color values don't have to be any more

2160
02:05:20,500 --> 02:05:25,800
precise than, you know, sort of a vague 0 to 255, kind of gun value at

2161
02:05:25,800 --> 02:05:26,400
this point.

2162
02:05:26,900 --> 02:05:28,800
Although in the future, we make care more about that.

2163
02:05:29,700 --> 02:05:32,900
So anyway, here we go doing that horizontal add and then we just

2164
02:05:32,900 --> 02:05:33,700
return the value.

2165
02:05:35,900 --> 02:05:36,300
All right.

2166
02:05:37,600 --> 02:05:41,700
So yeah, the horizontal add here.

2167
02:05:43,000 --> 02:05:44,600
That should be a tedx.

2168
02:05:44,600 --> 02:05:46,700
That should be F32.

2169
02:05:51,200 --> 02:05:52,600
Coming back.

2170
02:05:55,200 --> 02:05:56,200
What is the problem here?

2171
02:05:56,200 --> 02:05:59,800
Cannot convert argument Wonder from Lena, 322 Lane V3.

2172
02:06:03,800 --> 02:06:05,200
I put these in the wrong place again.

2173
02:06:07,600 --> 02:06:08,300
Yes, I did.

2174
02:06:08,900 --> 02:06:11,800
This is why I think I need to put them into different files.

2175
02:06:18,200 --> 02:06:18,700
All right.

2176
02:06:20,500 --> 02:06:27,300
So, I think now really all we have to do here is just when we're

2177
02:06:27,300 --> 02:06:28,800
actually setting up some of this stuff.

2178
02:06:28,800 --> 02:06:32,400
We now need to deal with the fact that we've kind of got rid of some

2179
02:06:32,400 --> 02:06:33,600
of the V3 stuff.

2180
02:06:33,600 --> 02:06:35,900
And I don't really want to kind of carry around to math.

2181
02:06:35,900 --> 02:06:39,000
Libraries here, one for the unwind and one for the wide.

2182
02:06:39,000 --> 02:06:43,100
So what I want to do is try to make this stuff work relatively well

2183
02:06:43,100 --> 02:06:44,200
without that.

2184
02:06:44,200 --> 02:06:47,700
Now, what you can see here is, most of the stuff is fine.

2185
02:06:47,700 --> 02:06:50,100
The really, the only part here, we have to implement

2186
02:06:50,600 --> 02:06:53,100
The packing stuff, the V4 packing stuff.

2187
02:06:53,900 --> 02:06:57,200
This can just be done directly in here because the only place we do

2188
02:06:57,200 --> 02:06:57,400
it.

2189
02:06:57,400 --> 02:06:59,200
So I'm actually fine with that.

2190
02:07:00,200 --> 02:07:04,100
And I don't really need this to be extracted out a final color either.

2191
02:07:04,100 --> 02:07:07,000
So even that part of V3 is, doesn't really have to happen.

2192
02:07:07,400 --> 02:07:11,000
We can really just do exactly this but we don't have to pack it into

2193
02:07:11,000 --> 02:07:18,000
one of these either we can just say F 32 rf3, 2G F 32b.

2194
02:07:18,800 --> 02:07:20,200
And now we've got those

2195
02:07:20,500 --> 02:07:24,900
RGB values and we only have to implement this BGR.

2196
02:07:24,900 --> 02:07:26,600
A Pack 4 by 8.

2197
02:07:26,600 --> 02:07:31,200
We can go into the math library and find that BGR Pack 4 by 8.

2198
02:07:31,300 --> 02:07:34,400
And we can see that this is all that it does, right?

2199
02:07:36,000 --> 02:07:43,800
And so the unpacked ARG bees, those can just be put in specifically

2200
02:07:43,900 --> 02:07:48,600
actually leave the a in there in case we actually want to have a value

2201
02:07:48,600 --> 02:07:50,400
come out at some point.

2202
02:07:50,500 --> 02:07:53,500
Which is going to be, which would be some kind of a, like a

2203
02:07:53,500 --> 02:07:54,700
translucent value.

2204
02:07:58,100 --> 02:08:03,700
So I think, you know, if we just do this then the empty value.

2205
02:08:06,700 --> 02:08:10,800
Now, we don't need any of these anymore at all.

2206
02:08:10,800 --> 02:08:11,500
I don't think so.

2207
02:08:11,500 --> 02:08:13,600
I think we can kind of get rid of all this stuff.

2208
02:08:15,000 --> 02:08:18,700
We just need the one extract, linear to srgb, right?

2209
02:08:18,900 --> 02:08:22,300
I don't know where that went extract extract.

2210
02:08:23,900 --> 02:08:24,700
Where is that?

2211
02:08:34,200 --> 02:08:37,600
What's going on extract linear?

2212
02:08:41,000 --> 02:08:41,600
It's right.

2213
02:08:41,600 --> 02:08:42,900
Here is an extract.

2214
02:08:50,600 --> 02:08:52,300
Oh, exact.

2215
02:08:56,800 --> 02:08:59,000
That was funny, you have to admit.

2216
02:08:59,000 --> 02:08:59,500
That was funny.

2217
02:09:00,200 --> 02:09:03,300
Exactly near the srgb is already implemented in here.

2218
02:09:03,300 --> 02:09:05,600
So that part we don't care about at all.

2219
02:09:05,600 --> 02:09:09,100
We can go into this stuff and now I think we can just nuke all of

2220
02:09:09,100 --> 02:09:09,600
these.

2221
02:09:09,800 --> 02:09:11,100
Don't think we care about them.

2222
02:09:13,100 --> 02:09:13,700
At all.

2223
02:09:15,800 --> 02:09:18,900
Okay, so let's see here.

2224
02:09:20,300 --> 02:09:23,600
Now we just have a couple of these guys.

2225
02:09:23,600 --> 02:09:26,000
I think are just all V3 related, right?

2226
02:09:26,400 --> 02:09:29,100
So we just need to sort of finish this stuff off.

2227
02:09:29,900 --> 02:09:37,500
And so, yeah, I think if we just kind of clean up our doing our

2228
02:09:37,500 --> 02:09:41,700
initialization of some of these here, we should be fine.

2229
02:09:42,000 --> 02:09:45,400
So, the way that I would suggest doing this because

2230
02:09:45,600 --> 02:09:52,300
Have operations doing these Lane Wise is just have a way to smoosh

2231
02:09:52,300 --> 02:09:54,100
them down after the fact.

2232
02:09:55,700 --> 02:10:01,000
So, for example, if I just didn't, if I did exactly all of these

2233
02:10:01,000 --> 02:10:06,000
operations here, the way that they were being done.

2234
02:10:12,800 --> 02:10:15,700
All of this stuff should now work I believe.

2235
02:10:16,600 --> 02:10:19,700
And so then the only question is, how do we get them out here, which

2236
02:10:19,700 --> 02:10:22,100
should be a relatively simple matter?

2237
02:10:29,100 --> 02:10:32,200
And so down here, what we could do is then say all right, these are

2238
02:10:32,200 --> 02:10:35,600
just going to be taken directly from their counterparts.

2239
02:10:36,800 --> 02:10:46,100
So we'll just say like, you know, get or, you know, slice zero or

2240
02:10:46,100 --> 02:10:47,000
something like this.

2241
02:10:52,900 --> 02:10:57,200
So we can just extract the slices zero or like, you know, extract.

2242
02:11:00,300 --> 02:11:01,100
Something like that.

2243
02:11:09,000 --> 02:11:13,000
So this we can do all our computations in V3 regular v3s and then just

2244
02:11:13,000 --> 02:11:16,300
extract the 0l the 0 with one of them.

2245
02:11:18,800 --> 02:11:24,400
and that would just be something that inside the

2246
02:11:27,100 --> 02:11:32,700
inside the lane versions, We have a way to turn a lane V3 into a lane.

2247
02:11:36,300 --> 02:11:38,200
Or I should say a regular B 3.

2248
02:11:45,900 --> 02:11:48,900
So in this case, where we have this extract 0 here, we know that we've

2249
02:11:48,900 --> 02:11:53,100
got sort of sliced versions of all these and we only want the first

2250
02:11:53,100 --> 02:11:54,800
one of each of them.

2251
02:11:55,200 --> 02:11:59,900
So we've got a result here, the result X y&z.

2252
02:12:04,300 --> 02:12:11,900
We're just going to take an F32 pointer to the to the X here and and

2253
02:12:11,900 --> 02:12:14,100
look at the very first one of it, right?

2254
02:12:22,000 --> 02:12:23,100
That's really it.

2255
02:12:23,300 --> 02:12:26,600
And and that would pull out the first Vector in the set.

2256
02:12:29,200 --> 02:12:34,900
So, let's take a look here, we've got film centers that camera p- film

2257
02:12:34,900 --> 02:12:36,400
to start State camera Z.

2258
02:12:36,800 --> 02:12:40,000
This is again, I guess the same sort of situation.

2259
02:12:40,000 --> 02:12:43,500
Although, wait, what is the film distance is 1 point 0?

2260
02:12:43,500 --> 02:12:47,000
Is this just a case of us not having the F32 version here?

2261
02:12:50,700 --> 02:12:56,100
It seems like we are kind of missing the, our operators are laying

2262
02:12:56,100 --> 02:12:57,400
operators, right?

2263
02:12:58,200 --> 02:13:04,500
For operator times like some of those operators are not in the

2264
02:13:13,800 --> 02:13:14,600
Like these guys.

2265
02:13:14,600 --> 02:13:15,400
All right.

2266
02:13:18,300 --> 02:13:21,500
But that should have been there because Steve, oh, I see never mind.

2267
02:13:21,500 --> 02:13:22,700
Nope, I'm dumb.

2268
02:13:24,500 --> 02:13:27,500
The problem is, we just can't use the state ones because they are not

2269
02:13:27,500 --> 02:13:28,200
actually correct.

2270
02:13:28,200 --> 02:13:29,300
So we want we want to do.

2271
02:13:29,300 --> 02:13:33,300
Here, is do extract, zero Film Center.

2272
02:13:36,300 --> 02:13:38,200
And just do this up here.

2273
02:13:48,400 --> 02:13:49,100
All right.

2274
02:13:49,600 --> 02:13:52,600
So these are just have to be x y and z now because we don't have our G

2275
02:13:52,600 --> 02:13:54,300
and Beyond those anymore and that's fine.

2276
02:13:55,500 --> 02:14:02,400
And yeah, these guys are all just packing these V3 downs and these

2277
02:14:02,400 --> 02:14:03,800
are, this is sort of a

2278
02:14:07,600 --> 02:14:08,800
This is sort of an acronym stick.

2279
02:14:08,800 --> 02:14:11,300
Like what we really want to do here is probably have something that

2280
02:14:11,300 --> 02:14:16,300
fills out an actual material for us and similarly, for spirits and

2281
02:14:16,300 --> 02:14:17,100
that sort of stuff.

2282
02:14:17,400 --> 02:14:22,000
But what we could do as well is just make these be actual initializer

2283
02:14:22,000 --> 02:14:22,500
lists.

2284
02:14:23,700 --> 02:14:26,000
That seems the easiest thing to do for now.

2285
02:14:26,000 --> 02:14:28,800
So I'm going to do is just go to material, right?

2286
02:14:29,200 --> 02:14:30,400
Where we've got sort of

2287
02:14:33,500 --> 02:14:34,300
Scatter value.

2288
02:14:34,300 --> 02:14:37,800
I'm going to put that last and then I'm just going to come through

2289
02:14:37,800 --> 02:14:42,900
here and say like, okay, we've got, you know, and admit color, don't

2290
02:14:42,900 --> 02:14:43,200
give up.

2291
02:14:43,200 --> 02:14:44,200
Now me, open it first

2292
02:14:48,600 --> 02:14:50,000
Let's do scatter.

2293
02:14:50,000 --> 02:14:51,400
Graph, color emit color.

2294
02:14:57,200 --> 02:14:57,700
Just for now.

2295
02:15:01,000 --> 02:15:06,700
Okay, so then we've got our rough color here.

2296
02:15:14,300 --> 02:15:15,500
Rough color again.

2297
02:15:20,900 --> 02:15:24,300
Ruff color again, down to size is a bit cooler.

2298
02:15:30,700 --> 02:15:32,000
Rough color and Scatter.

2299
02:15:54,500 --> 02:15:55,600
Victor slightly prettier.

2300
02:16:06,600 --> 02:16:07,100
Yeah.

2301
02:16:07,100 --> 02:16:08,000
So we've got

2302
02:16:17,700 --> 02:16:23,200
0 1, 2 3 4, a 5.

2303
02:16:40,100 --> 02:16:40,799
Here's six.

2304
02:16:50,400 --> 02:16:52,000
And that is about it.

2305
02:17:04,400 --> 02:17:07,000
There we go, for planes.

2306
02:17:13,200 --> 02:17:13,799
Same deal.

2307
02:17:21,400 --> 02:17:24,400
We've only got one so it's just n.

2308
02:17:28,600 --> 02:17:29,100
D.

2309
02:17:31,900 --> 02:17:34,200
And the material spheres.

2310
02:17:36,200 --> 02:17:37,000
Got a bunch.

2311
02:17:39,500 --> 02:17:40,299
But then, that's it.

2312
02:17:47,600 --> 02:17:51,000
So, there's the pr and the mat index.

2313
02:17:58,400 --> 02:17:59,000
P.

2314
02:18:01,700 --> 02:18:02,200
R.

2315
02:18:03,799 --> 02:18:04,799
Madden decks.

2316
02:18:07,299 --> 02:18:07,900
He?

2317
02:18:09,400 --> 02:18:12,000
Are not index.

2318
02:18:33,299 --> 02:18:35,299
And pee.

2319
02:18:38,799 --> 02:18:39,400
R.

2320
02:18:41,299 --> 02:18:42,000
At index.

2321
02:18:48,000 --> 02:18:52,400
So now we are down to the very ends of the end here.

2322
02:18:53,299 --> 02:18:58,700
And if we want to have this entropy stuff work properly here, we have

2323
02:18:58,700 --> 02:19:00,700
to double-check how we're actually loading.

2324
02:19:00,700 --> 02:19:05,000
And using this, I think we want each of these to be its own separate

2325
02:19:05,299 --> 02:19:07,100
piece of entropic information.

2326
02:19:07,500 --> 02:19:11,500
So I would expect that what we actually need to do here when we're

2327
02:19:11,900 --> 02:19:13,799
loading up one of these entropy values.

2328
02:19:14,799 --> 02:19:20,200
It's since the seed value is going to be a couple different.

2329
02:19:20,200 --> 02:19:20,900
You 32s.

2330
02:19:20,900 --> 02:19:24,600
What I'd like to do here is take that

2331
02:19:26,700 --> 02:19:33,100
The entropy value and say, Lane you 32 from you 32.

2332
02:19:33,100 --> 02:19:35,200
And in this case, I'm going to make one of these.

2333
02:19:35,200 --> 02:19:39,100
That actually takes four values and loads all four values, right?

2334
02:19:39,100 --> 02:19:46,200
So we have like, one of these for each, and this is also the place

2335
02:19:46,200 --> 02:19:50,400
where we could do our dear and intrinsic.

2336
02:19:50,400 --> 02:19:52,100
We could have the processor.

2337
02:19:52,100 --> 02:19:55,000
Give us that information.

2338
02:19:55,000 --> 02:19:56,300
I don't know if

2339
02:19:56,800 --> 02:20:02,100
She has one of those for our dear and probably does, I don't think

2340
02:20:02,100 --> 02:20:03,000
I've ever used it.

2341
02:20:19,400 --> 02:20:24,100
So here's our dear and so we could actually use this as well at the

2342
02:20:24,100 --> 02:20:24,900
moment.

2343
02:20:25,200 --> 02:20:29,900
I don't really know how widely supported that is though.

2344
02:20:29,900 --> 02:20:35,100
So I'm not going to do it at the at the moment but

2345
02:20:57,800 --> 02:20:59,600
I always seem to start with to

2346
02:21:02,600 --> 02:21:04,800
When I'm typing in a quote-unquote random number.

2347
02:21:07,000 --> 02:21:12,100
All right, so these is these are just kind of dies at the moment and

2348
02:21:12,100 --> 02:21:12,800
that's fine.

2349
02:21:12,800 --> 02:21:18,600
But let's go in here and add our actual Lane U2 u3 to from you 32.

2350
02:21:18,600 --> 02:21:21,100
So all I want to do here is make it so that if I wanted to initialize

2351
02:21:21,100 --> 02:21:23,100
one of these with separate values like could.

2352
02:21:24,500 --> 02:21:26,300
So basically something like this.

2353
02:21:30,100 --> 02:21:34,100
And then what I would do is just use one of these.

2354
02:21:38,200 --> 02:21:41,000
Ought to succeed it with each individual value, right?

2355
02:21:43,300 --> 02:21:49,200
All right, so we now have the ability to run this sort of in theory as

2356
02:21:49,200 --> 02:21:54,300
a bunch of slices, we don't actually yeah like you can see that's not

2357
02:21:54,300 --> 02:21:57,700
a very good result there we don't want to actually start debugging it

2358
02:21:57,700 --> 02:21:58,200
like this though.

2359
02:21:58,200 --> 02:22:01,700
We want to flip back now that we've done all these changes, we want to

2360
02:22:01,700 --> 02:22:09,200
flip back to doing these in a in a sort of more about this.

2361
02:22:11,200 --> 02:22:14,800
We want to flip back to doing this in scalar form and we want to be

2362
02:22:14,800 --> 02:22:17,700
able to yeah we want to do a bunch of stuff, right?

2363
02:22:18,400 --> 02:22:23,300
So let's start by fixing a couple obvious things and going from there,

2364
02:22:23,500 --> 02:22:27,100
first of all, when we print out what we're printing out, we want to

2365
02:22:27,100 --> 02:22:30,600
do, we want to specify a couple things like what the lane with was so

2366
02:22:30,600 --> 02:22:33,700
that we can remember that when we're sort of playing with it.

2367
02:22:34,100 --> 02:22:37,800
So you can see here we say like eight cores with 240 slices blah blah

2368
02:22:37,800 --> 02:22:38,300
blah.

2369
02:22:44,400 --> 02:22:46,500
So we can put in what the lane with this here.

2370
02:22:47,800 --> 02:22:51,200
That way when we print, when we do one of these we can say four wide

2371
02:22:51,200 --> 02:22:51,700
Lanes.

2372
02:22:52,200 --> 02:22:57,600
So we know that we're doing bundles of for when we sort of push

2373
02:22:57,600 --> 02:23:00,300
through our nonsense here, right?

2374
02:23:01,500 --> 02:23:05,700
So let's go ahead and start by flipping the lien with back so that we

2375
02:23:05,700 --> 02:23:07,300
can kind of see what's going on here.

2376
02:23:09,800 --> 02:23:13,800
Let's flip it, back to 1 and let's make sure that we have the sort of

2377
02:23:13,800 --> 02:23:17,700
stuff that we need to hear where we can.

2378
02:23:20,700 --> 02:23:22,800
Where we can compile and scalar mode as well.

2379
02:23:24,400 --> 02:23:29,300
I don't know where the horizontal add four-lane V3 would have been at

2380
02:23:29,300 --> 02:23:32,000
the moment so it looks like we do have one of those.

2381
02:23:35,100 --> 02:23:37,200
So I guess that should be gone.

2382
02:23:38,800 --> 02:23:39,200
Yeah.

2383
02:23:41,000 --> 02:23:46,900
We've got the lerp already having a body that's because in this case

2384
02:23:46,900 --> 02:23:52,200
yeah these are all going to be the same so I guess yeah that's

2385
02:23:52,200 --> 02:23:54,000
something that really should only be done.

2386
02:23:54,000 --> 02:23:59,900
We don't ever want this to actually occur in any sort of situation.

2387
02:24:00,000 --> 02:24:06,200
Nations where we already defined the lerp for having a single scalar

2388
02:24:06,200 --> 02:24:06,700
there.

2389
02:24:10,600 --> 02:24:13,100
Yeah, I'm not sure how to really get around that problem.

2390
02:24:13,100 --> 02:24:15,200
Let's take a look at that a little bit later.

2391
02:24:15,700 --> 02:24:17,600
I'm going to Define these guys first.

2392
02:24:22,800 --> 02:24:29,700
So when we have a lane width of of exactly one, we need to have some

2393
02:24:29,700 --> 02:24:31,400
of these other values specified.

2394
02:24:40,900 --> 02:24:42,300
And this is kind of a dummy function.

2395
02:24:42,300 --> 02:24:48,100
Again, it's just to make it work, Lane, V3 from V3, same thing.

2396
02:24:59,600 --> 02:25:03,200
And I think that actually should just work everywhere though.

2397
02:25:03,200 --> 02:25:06,900
I don't think this needs to be specified uniquely.

2398
02:25:06,900 --> 02:25:11,600
I think that can just be something that's the same for everybody would

2399
02:25:11,600 --> 02:25:12,500
be my assumption.

2400
02:25:14,100 --> 02:25:18,700
Lane you 32 from u-32 as well.

2401
02:25:21,400 --> 02:25:23,200
Again, that's just going to be a dummy function.

2402
02:25:24,100 --> 02:25:24,700
See here.

2403
02:25:36,600 --> 02:25:46,000
So this is going to be laying F32 from you, 32 Lane, you 32 from you

2404
02:25:46,000 --> 02:25:46,800
32.

2405
02:25:53,500 --> 02:25:57,200
And then we've got sort of the gather and expect zero stuff extract

2406
02:25:57,200 --> 02:25:58,000
zero.

2407
02:26:02,800 --> 02:26:06,300
I feel like that is also one that will just work.

2408
02:26:06,400 --> 02:26:08,600
I don't think there's any magic to that one.

2409
02:26:09,200 --> 02:26:10,100
That should be fine.

2410
02:26:13,100 --> 02:26:15,900
We need the The Pact one of those.

2411
02:26:16,900 --> 02:26:21,600
So in this case, one of the things that's confusing about this guy is

2412
02:26:21,600 --> 02:26:25,800
that we'd be throwing away information here in this case.

2413
02:26:27,100 --> 02:26:30,100
I think that's probably fine, though.

2414
02:26:30,300 --> 02:26:32,700
This is really, the only case where we're doing something.

2415
02:26:32,700 --> 02:26:35,400
In the reason we're doing it this way, is because it is a random

2416
02:26:36,500 --> 02:26:37,100
Number.

2417
02:26:38,100 --> 02:26:40,000
So I think that's probably fine.

2418
02:26:44,100 --> 02:26:47,500
It's kind of hard to say right, but I think that's probably fine.

2419
02:26:48,600 --> 02:26:53,300
So I'll let that slide and I like I said, I think that's okay.

2420
02:26:54,500 --> 02:26:57,400
But yeah, if that comes back to bite us, well, you know, who to blame,

2421
02:26:57,700 --> 02:26:58,200
it was me.

2422
02:27:09,300 --> 02:27:13,100
So yeah, in this case, we'll just use the lower one and that should be

2423
02:27:13,100 --> 02:27:13,500
fine.

2424
02:27:14,400 --> 02:27:17,300
So now we just need sort of the gather and lerp stuff.

2425
02:27:17,600 --> 02:27:19,400
The Gather stuff is

2426
02:27:21,100 --> 02:27:23,500
Is actually pretty straightforward, right?

2427
02:27:23,500 --> 02:27:25,500
It's really just not going to do any Gathering.

2428
02:27:25,500 --> 02:27:28,900
It's just going to do a single, it's going to do a single grab.

2429
02:27:29,500 --> 02:27:35,300
So if we take a look at gather F32, which I think is the primary one

2430
02:27:35,300 --> 02:27:40,100
we need here, when the lane width equals 1, we still have to do that,

2431
02:27:40,600 --> 02:27:41,200
right?

2432
02:27:42,200 --> 02:27:44,900
And so it's going to give us the same things, really?

2433
02:27:44,900 --> 02:27:45,700
All that's happening.

2434
02:27:45,700 --> 02:27:47,900
Here is

2435
02:27:51,400 --> 02:27:56,200
This right here, this Lane you 32 is obviously only one thing so it's

2436
02:27:56,200 --> 02:27:58,700
really just Index, right?

2437
02:27:59,200 --> 02:28:03,700
And it's so it's just index time stride with base pointer and that's

2438
02:28:04,000 --> 02:28:07,200
you know, equal directly to the result.

2439
02:28:08,100 --> 02:28:12,200
So you're really just talking about doing one of the multi lookups

2440
02:28:12,900 --> 02:28:13,500
that's in there.

2441
02:28:15,800 --> 02:28:16,600
If that makes sense.

2442
02:28:24,800 --> 02:28:27,000
Lerp gather V3.

2443
02:28:27,000 --> 02:28:29,000
So does V3.

2444
02:28:30,400 --> 02:28:32,700
Can that be generalized gathered B3?

2445
02:28:38,600 --> 02:28:39,800
I think it can.

2446
02:28:43,500 --> 02:28:46,900
So I think that one as well, just should have been written outside.

2447
02:28:48,200 --> 02:28:48,600
All right.

2448
02:28:56,700 --> 02:28:59,400
No Globe operator found, which takes type.

2449
02:29:03,400 --> 02:29:04,400
Blaine V3.

2450
02:29:06,200 --> 02:29:07,300
so, last one here,

2451
02:29:14,500 --> 02:29:17,300
So yes, this can this just be moved out?

2452
02:29:19,800 --> 02:29:22,100
Right after and has Type F32.

2453
02:29:22,400 --> 02:29:26,300
So, I guess that one can't really be done that way because of the, and

2454
02:29:29,000 --> 02:29:30,900
So that kind of needs to be done.

2455
02:29:32,800 --> 02:29:35,800
Yeah, we allow that that operator there.

2456
02:29:35,800 --> 02:29:38,900
I don't, we're not allowed to overload, operators between primary

2457
02:29:38,900 --> 02:29:39,500
types like that.

2458
02:29:39,500 --> 02:29:44,100
I don't think so we're not allowed to add the correct type in there

2459
02:29:45,000 --> 02:29:47,300
for our situations which is unfortunate.

2460
02:29:48,500 --> 02:29:52,400
So what I would say is that probably has to be something that's done

2461
02:29:52,400 --> 02:29:54,300
special case in this case, right?

2462
02:29:55,900 --> 02:29:57,600
Oops, nope, not that.

2463
02:30:11,000 --> 02:30:13,100
so this right here where we're doing the sands,

2464
02:30:18,400 --> 02:30:19,600
I'm not really sure.

2465
02:30:19,600 --> 02:30:20,000
Yeah.

2466
02:30:20,000 --> 02:30:23,000
How to deal with that since we're doing that.

2467
02:30:23,000 --> 02:30:23,600
Yeah.

2468
02:30:23,600 --> 02:30:24,100
Okay.

2469
02:30:24,100 --> 02:30:24,500
Okay.

2470
02:30:25,100 --> 02:30:28,700
So the way we'll do that is operator and

2471
02:30:30,000 --> 02:30:35,300
We'll just go ahead and make one of those in the actual Lane with one,

2472
02:30:36,700 --> 02:30:39,600
and we'll just make it do the cast appropriately, right?

2473
02:30:42,400 --> 02:30:46,600
So what we'll do here is we'll say, all right, do the and operation

2474
02:30:46,600 --> 02:30:50,100
with this as if it were you 32, right?

2475
02:31:06,200 --> 02:31:09,000
So in this case, right to the end with it, as if it were, you 32,

2476
02:31:09,000 --> 02:31:09,600
please.

2477
02:31:10,300 --> 02:31:12,700
And then you know, when you're done with that,

2478
02:31:15,400 --> 02:31:18,400
Give me back a value, which I can then.

2479
02:31:19,900 --> 02:31:21,900
You know, make equal to a float.

2480
02:31:24,000 --> 02:31:27,200
And it's just, you know, why can't you do an end of the float?

2481
02:31:27,200 --> 02:31:33,200
I don't know, like you the processor can so I don't know why you

2482
02:31:33,200 --> 02:31:33,600
can't.

2483
02:31:33,600 --> 02:31:38,800
But you know oh well that's just the way it goes sometimes.

2484
02:31:39,700 --> 02:31:43,800
All right, so now we've got our parlor problem and this is really just

2485
02:31:43,800 --> 02:31:48,700
an order of deck, order of like, where these are declared for now.

2486
02:31:48,700 --> 02:31:49,900
I'm going to put to do here.

2487
02:31:56,100 --> 02:31:59,000
and just say, if the lane width is not equal to 1,

2488
02:32:00,700 --> 02:32:04,000
Because we can't, we can only have that in the case, for the lane

2489
02:32:04,000 --> 02:32:05,400
width is not equal to 1, right?

2490
02:32:08,300 --> 02:32:13,300
So now, we've got this running scalar wise, exactly.

2491
02:32:13,300 --> 02:32:18,100
With, with all the same stuff that would be running in the wide case,

2492
02:32:18,400 --> 02:32:20,200
so we can freely switch between them.

2493
02:32:20,500 --> 02:32:24,100
And so, what I'd like to do is just take a minute, see if we can debug

2494
02:32:24,700 --> 02:32:25,400
the

2495
02:32:27,800 --> 02:32:32,100
Debug the scalar version first and get that producing a reasonable

2496
02:32:32,100 --> 02:32:32,700
image.

2497
02:32:35,500 --> 02:32:40,100
And then, once we've got that going, then switch back over to the wide

2498
02:32:40,100 --> 02:32:47,000
version and yeah, try to make that produce a reasonable image as well,

2499
02:32:47,600 --> 02:32:48,100
right?

2500
02:32:53,100 --> 02:32:55,200
Of course, the other problem is here is, I don't know if we're

2501
02:32:55,200 --> 02:32:57,700
actually getting stuck in like this, this could just be slow because

2502
02:32:57,700 --> 02:32:58,900
of the changes that we made.

2503
02:33:00,000 --> 02:33:02,300
I also don't know if this is just, we should probably

2504
02:33:03,800 --> 02:33:06,800
Yeah, so you can see that we've got a bug here, right?

2505
02:33:07,200 --> 02:33:09,600
The scalar version, no longer works correctly.

2506
02:33:10,300 --> 02:33:14,100
So in all those changes that we did, we do have some sort of problem,

2507
02:33:15,100 --> 02:33:18,000
which is fine, we were kind of expecting that.

2508
02:33:18,700 --> 02:33:20,900
So, let's go ahead and take a look.

2509
02:33:24,000 --> 02:33:25,200
At what's going on in the code.

2510
02:33:33,600 --> 02:33:34,000
Sue.

2511
02:33:37,500 --> 02:33:40,100
Start by coming through here and checking out what our values actually

2512
02:33:40,100 --> 02:33:40,400
are.

2513
02:33:41,300 --> 02:33:47,100
And okay, that's doesn't look like a a no decompile to me.

2514
02:33:52,600 --> 02:33:55,100
was that actually, you know, decompile because it sure didn't seem

2515
02:33:55,100 --> 02:33:55,600
like one

2516
02:33:59,100 --> 02:34:02,700
Oh sorry we're still threaded.

2517
02:34:03,300 --> 02:34:05,100
Let's go ahead and stop that.

2518
02:34:19,700 --> 02:34:20,000
Okay.

2519
02:34:24,900 --> 02:34:25,800
And now we can jump in.

2520
02:34:26,800 --> 02:34:30,200
So, here is US getting all of our values out.

2521
02:34:30,200 --> 02:34:32,500
And I'm going to take a look at what they all are.

2522
02:34:32,500 --> 02:34:33,900
So the Rays per pixel.

2523
02:34:33,900 --> 02:34:35,200
Let's go ahead and switch out of hex.

2524
02:34:35,800 --> 02:34:37,300
The raise per pixel is 1024.

2525
02:34:37,300 --> 02:34:38,100
That's what we expect.

2526
02:34:38,100 --> 02:34:42,200
The bounce count is eight also expect the film width and height look

2527
02:34:42,200 --> 02:34:44,800
pretty reasonable to me, certainly nothing too out of the ordinary

2528
02:34:44,800 --> 02:34:45,300
there.

2529
02:34:45,600 --> 02:34:50,300
Same with the pixel stuff, and the film location and the center looks

2530
02:34:50,300 --> 02:34:51,100
okay.

2531
02:34:53,100 --> 02:34:53,900
All of that stuff.

2532
02:34:53,900 --> 02:34:56,200
Looks pretty reasonable Acts.

2533
02:34:58,600 --> 02:34:59,200
Why?

2534
02:35:00,500 --> 02:35:03,100
Z and position.

2535
02:35:06,600 --> 02:35:08,100
The random series looks fine.

2536
02:35:10,200 --> 02:35:12,100
That's computed is initialized to 0.

2537
02:35:12,200 --> 02:35:18,400
Final color is all zeros as we expect the lane with is now set to 1

2538
02:35:18,900 --> 02:35:19,800
the line.

2539
02:35:19,800 --> 02:35:24,400
Ray count is 1024, which is correct and we are verifying that it

2540
02:35:24,400 --> 02:35:29,600
multiplies back out the contribution for Pixel is 1 over 10 24, right?

2541
02:35:31,700 --> 02:35:33,100
Which is exactly right.

2542
02:35:35,500 --> 02:35:37,000
And then we start looping through.

2543
02:35:37,700 --> 02:35:42,500
We produce our offsets here, those look pretty good.

2544
02:35:43,300 --> 02:35:46,600
We go through our way origin redirection and we know that the hit

2545
02:35:46,600 --> 02:35:47,400
stuff seems to work.

2546
02:35:47,400 --> 02:35:47,700
Okay.

2547
02:35:47,700 --> 02:35:50,300
So it's really the emission stuff that's probably wrong.

2548
02:35:51,000 --> 02:35:53,900
We'll go because that's exactly the bug we had before, where the

2549
02:35:53,900 --> 02:35:57,300
emitter wasn't going such that masking operation looks wrong.

2550
02:35:58,900 --> 02:35:59,800
we started out, but I'm just

2551
02:36:00,000 --> 02:36:00,700
I'm through discussing.

2552
02:36:00,700 --> 02:36:01,600
We made a lot of changes.

2553
02:36:01,600 --> 02:36:05,400
Let's let's make sure that everything is roughly coherently.

2554
02:36:05,400 --> 02:36:09,800
Mass looks good going through these and introducing the initial

2555
02:36:09,800 --> 02:36:12,200
startup setup looks good.

2556
02:36:12,200 --> 02:36:16,900
There, the lane increment looks good, that's the computer.

2557
02:36:16,900 --> 02:36:18,300
Got incremented properly.

2558
02:36:20,600 --> 02:36:25,300
We're pulling out the various clean informations, and those look

2559
02:36:25,300 --> 02:36:26,200
pretty good.

2560
02:36:31,600 --> 02:36:33,400
Distance, hit mask.

2561
02:36:36,000 --> 02:36:37,500
That looks pretty good.

2562
02:36:38,400 --> 02:36:40,300
Looks pretty good to me.

2563
02:36:42,500 --> 02:36:47,300
So that looks like that operated properly sphere index.

2564
02:36:51,600 --> 02:36:52,900
Looks pretty good.

2565
02:37:01,100 --> 02:37:03,900
That looks less good.

2566
02:37:07,500 --> 02:37:11,400
Oh, but that's okay because those can be Nan's because they're

2567
02:37:11,400 --> 02:37:14,100
actually not the mask is not going to let them assign.

2568
02:37:14,900 --> 02:37:16,300
So that's actually fine.

2569
02:37:16,800 --> 02:37:17,500
No worries there.

2570
02:37:18,600 --> 02:37:20,200
So those look pretty good.

2571
02:37:23,000 --> 02:37:25,100
Now let's see what happens when we do our gather.

2572
02:37:25,100 --> 02:37:28,100
We know that the material index that we hit was one.

2573
02:37:29,300 --> 02:37:33,200
And so let's take a look at what we gather out for are three values.

2574
02:37:33,200 --> 02:37:35,100
Are emission color is 0.

2575
02:37:35,700 --> 02:37:38,200
Our rough color is grey.

2576
02:37:38,600 --> 02:37:44,100
Our scatter is zero is that similar to what we would have expected?

2577
02:37:44,100 --> 02:37:44,800
Yes, it is.

2578
02:37:44,800 --> 02:37:45,300
So that's good.

2579
02:37:45,300 --> 02:37:47,100
At least that gather worked properly.

2580
02:37:48,400 --> 02:37:52,100
We're going to add our, you know, whatever week.

2581
02:37:52,300 --> 02:37:52,500
Here.

2582
02:37:52,500 --> 02:37:56,300
We're going to add that in the lane masking should have masked this

2583
02:37:56,300 --> 02:37:59,700
off to zero if it was out, but it's in.

2584
02:37:59,700 --> 02:38:01,200
So it wouldn't have done anything there.

2585
02:38:02,200 --> 02:38:06,600
So we go ahead and add this emit color which is already zero in.

2586
02:38:06,900 --> 02:38:11,100
We then mask off, anywhere the hit Jimmy.

2587
02:38:12,700 --> 02:38:15,500
We then mask off from the lane mask anywhere, where we didn't hit.

2588
02:38:15,600 --> 02:38:16,700
Now we did.

2589
02:38:17,400 --> 02:38:18,800
So we keep going.

2590
02:38:18,800 --> 02:38:19,500
And that's fine.

2591
02:38:20,300 --> 02:38:26,500
We compute our stuff and our next bounce here looks pretty reasonable

2592
02:38:26,900 --> 02:38:28,200
normalizer 0.

2593
02:38:28,400 --> 02:38:29,700
Everything seems fine.

2594
02:38:31,000 --> 02:38:32,400
We are not zero.

2595
02:38:32,400 --> 02:38:33,300
So we keep going.

2596
02:38:35,500 --> 02:38:37,700
Jimmy, Here Comes our bounce.

2597
02:38:38,700 --> 02:38:41,200
So the lane increment is still one our bounces.

2598
02:38:41,200 --> 02:38:41,700
Computed.

2599
02:38:41,700 --> 02:38:43,500
We've now, computed the second bounce.

2600
02:38:44,400 --> 02:38:45,400
We're taking a look here.

2601
02:38:45,400 --> 02:38:50,000
We do not hit here so we should expect you to stay at its current

2602
02:38:50,000 --> 02:38:50,400
value.

2603
02:38:51,100 --> 02:38:51,700
What

2604
02:38:55,600 --> 02:38:57,500
Is happening here.

2605
02:39:02,900 --> 02:39:05,400
It's because the yeah, the denominator probably didn't.

2606
02:39:07,600 --> 02:39:08,700
This isn't going to hit right?

2607
02:39:08,700 --> 02:39:09,100
Yeah.

2608
02:39:09,400 --> 02:39:11,700
Okay so it's not gonna hit, that's fine.

2609
02:39:12,300 --> 02:39:15,100
So now we're going to go through here, we're going to find a hit

2610
02:39:15,100 --> 02:39:17,600
probably right hit mask zero.

2611
02:39:20,100 --> 02:39:22,500
Actually, we may not be finding it remade, just hit the sky.

2612
02:39:25,500 --> 02:39:26,000
Right.

2613
02:39:37,800 --> 02:39:38,300
Oops.

2614
02:39:38,400 --> 02:39:39,200
That crap.

2615
02:39:39,300 --> 02:39:40,200
I went too fast.

2616
02:39:41,200 --> 02:39:47,600
Well, so the metal color here that we loaded is just garbage.

2617
02:39:48,400 --> 02:39:52,200
So, it looks like our gather is not working properly, either that or a

2618
02:39:52,200 --> 02:39:54,100
mask is not working properly, right?

2619
02:39:55,400 --> 02:39:59,500
So it looks like when we went to grab this, that's our culprit.

2620
02:39:59,500 --> 02:40:02,600
Now I may be able to just go back up here.

2621
02:40:04,900 --> 02:40:06,100
And do a sit next statement.

2622
02:40:06,100 --> 02:40:08,100
I don't know if that'll actually work or not.

2623
02:40:08,400 --> 02:40:12,700
It may very well not but let's take a quick look here and see if we

2624
02:40:12,700 --> 02:40:15,300
can see if that actually would work or not.

2625
02:40:18,500 --> 02:40:21,700
So the base pointer in this case we are expecting it to be pointing to

2626
02:40:21,700 --> 02:40:25,900
a material right but we're spending to be pointing to a particular

2627
02:40:25,900 --> 02:40:27,600
index off of particular material.

2628
02:40:28,500 --> 02:40:34,400
So right, if we go back to the Lane stuff where we do like a gathering

2629
02:40:34,500 --> 02:40:38,800
Are the base pointer, we're taking the address of a particular member

2630
02:40:38,800 --> 02:40:39,700
of the base pointer.

2631
02:40:40,200 --> 02:40:43,700
So, where we do our gather V3 in here.

2632
02:40:47,400 --> 02:40:54,700
We're looking at World materials Arrow emit color, right?

2633
02:40:57,400 --> 02:40:58,600
and if we take a look at,

2634
02:40:59,900 --> 02:41:01,200
Where am it color is?

2635
02:41:01,200 --> 02:41:03,700
It's the bottom of this guy, right?

2636
02:41:05,600 --> 02:41:09,200
We also are going to look at what the stride is.

2637
02:41:09,200 --> 02:41:10,000
Let me see.

2638
02:41:10,200 --> 02:41:12,800
So base pointer should be pointing to the emit color.

2639
02:41:12,800 --> 02:41:15,600
If I do this,

2640
02:41:18,000 --> 02:41:25,200
I should see the color there 345 of whatever the material, the first

2641
02:41:25,200 --> 02:41:26,100
material is.

2642
02:41:26,900 --> 02:41:31,500
So let's verify that I'm actually seeing that first right.

2643
02:41:32,300 --> 02:41:37,800
So inside, right out, CPP, where we set those colors 3, 4 5 is

2644
02:41:37,800 --> 02:41:38,900
actually exactly what it is.

2645
02:41:38,900 --> 02:41:39,700
So that's all fine.

2646
02:41:39,700 --> 02:41:42,100
You got the floating-point rounding error there that's which is fine.

2647
02:41:42,100 --> 02:41:45,300
It just can't represent exact exactly 3, for example.

2648
02:41:46,900 --> 02:41:47,100
That's right.

2649
02:41:47,100 --> 02:41:47,500
Exactly.

2650
02:41:47,500 --> 02:41:48,000
Point 3.

2651
02:41:50,000 --> 02:41:52,800
So looking at that, that looks okay.

2652
02:41:53,000 --> 02:41:54,600
What does the stride equal?

2653
02:41:55,000 --> 02:41:59,700
And let's take a look at the material here is 28 and

2654
02:42:00,000 --> 02:42:01,000
Indices.

2655
02:42:01,200 --> 02:42:02,100
In this case.

2656
02:42:05,300 --> 02:42:07,600
He just sees zero.

2657
02:42:07,900 --> 02:42:17,300
All right, um so yeah in this case that all looks pretty good.

2658
02:42:20,600 --> 02:42:24,400
And I'm not sure why the result would be borked, but let's keep going.

2659
02:42:25,100 --> 02:42:28,900
So maybe the bug is in gather F32.

2660
02:42:29,800 --> 02:42:32,200
So let's taste step in and take a look.

2661
02:42:32,200 --> 02:42:35,100
We know that this should gather a three for us.

2662
02:42:35,900 --> 02:42:36,700
So let's see.

2663
02:42:37,100 --> 02:42:38,600
So we're going to take the base pointer.

2664
02:42:38,600 --> 02:42:41,300
We're going to add the index times, a stride, which should just add

2665
02:42:41,300 --> 02:42:41,800
nothing.

2666
02:42:41,800 --> 02:42:44,800
We're going to use that as an F32, and we're going to get a result

2667
02:42:44,800 --> 02:42:45,700
out, right?

2668
02:42:45,900 --> 02:42:48,300
So, there's that result of 3, which is what we expected.

2669
02:42:48,300 --> 02:42:49,600
There's the result of three

2670
02:42:50,400 --> 02:42:53,500
The result of Y for result of x 5.

2671
02:42:53,900 --> 02:42:55,300
So back we come to here.

2672
02:42:55,900 --> 02:42:57,500
Let's step into the lane mask.

2673
02:42:57,500 --> 02:43:00,600
Oh, so it looks like this is where we messed up perhaps.

2674
02:43:02,200 --> 02:43:03,000
So here we go.

2675
02:43:03,700 --> 02:43:04,800
We have a lien V3.

2676
02:43:04,800 --> 02:43:07,200
We're trying to mask off or trying to mask it by a.

2677
02:43:08,000 --> 02:43:13,800
We treat the X y&z as ah, I know what the problem is here.

2678
02:43:14,300 --> 02:43:20,400
Yeah, this is again, the same problem that we were having before with

2679
02:43:20,400 --> 02:43:24,900
masks is that the processor just produced that unitary mask.

2680
02:43:25,400 --> 02:43:29,500
So, we actually already faced this problem before, right?

2681
02:43:30,700 --> 02:43:31,800
It's this guy right here,

2682
02:43:32,400 --> 02:43:37,800
So we need to convert The Mask first before we use it into something

2683
02:43:38,100 --> 02:43:39,300
that's proper, right?

2684
02:43:39,300 --> 02:43:44,200
So we need to do like a equals a like that so that when the masking

2685
02:43:44,200 --> 02:43:48,100
happens that happens in the way we would expect, right?

2686
02:43:51,300 --> 02:43:58,500
So, that's a little bit trickier because again, it's sort of cheating

2687
02:43:58,500 --> 02:44:03,400
on what the operators supposed to do and I don't actually love it.

2688
02:44:16,500 --> 02:44:23,500
So, yeah, so that looks better now, and that may have been the only

2689
02:44:23,500 --> 02:44:25,300
problem we were having with that.

2690
02:44:25,300 --> 02:44:28,900
So, let's, let's just see for a second.

2691
02:44:29,400 --> 02:44:35,100
Let me see what happens if we actually run this now, so I can get a

2692
02:44:35,100 --> 02:44:37,800
sense for what's going on.

2693
02:44:44,600 --> 02:44:47,700
Off we go and men were so much slower.

2694
02:44:47,700 --> 02:44:49,600
Now I don't know exactly what we did.

2695
02:44:49,600 --> 02:44:50,800
That was so much slower.

2696
02:44:50,900 --> 02:44:56,800
It'd be interesting to go see, but something that we did with when we

2697
02:44:56,800 --> 02:44:59,200
were going to wider things.

2698
02:45:00,000 --> 02:45:00,300
Facts.

2699
02:45:00,300 --> 02:45:03,900
You know what I could do to is I could change the re Camp something we

2700
02:45:03,900 --> 02:45:06,000
did was real bad, right?

2701
02:45:08,900 --> 02:45:12,800
I'm not sure it's the what he was, but something we did was real bad.

2702
02:45:13,400 --> 02:45:18,900
So let's go ahead and go back to the re-cap here.

2703
02:45:19,100 --> 02:45:20,300
Oh, you know what it was?

2704
02:45:20,300 --> 02:45:21,600
We turned off the CPU.

2705
02:45:21,600 --> 02:45:24,300
Multiplier never mind.

2706
02:45:34,400 --> 02:45:40,100
Yeah, so still a lot slower than it used to be obviously, but not

2707
02:45:40,100 --> 02:45:41,500
nearly as slow as all that.

2708
02:45:42,300 --> 02:45:44,200
So because I would expect to slow down again.

2709
02:45:44,200 --> 02:45:47,500
I expect a slow down from running scalar with code, that can't take

2710
02:45:47,500 --> 02:45:49,700
advantage of any of the scale Earnest of it.

2711
02:45:50,300 --> 02:45:53,700
Because again, it's just, you know, it's now it's doing all these

2712
02:45:53,700 --> 02:45:56,800
sorts of operations that are because it has to be Lane wide.

2713
02:45:57,800 --> 02:46:03,000
And you know, that's that's not what scalar code wants to do scalar

2714
02:46:03,000 --> 02:46:03,300
code.

2715
02:46:03,600 --> 02:46:08,000
Doesn't, you know, can do use real ifs and avoid Computing things, and

2716
02:46:08,000 --> 02:46:09,500
all those other sorts of things.

2717
02:46:12,300 --> 02:46:16,100
Whereas we can't, you know, we can't get away with that once we sort

2718
02:46:16,100 --> 02:46:19,500
of have to do it generically that works across any Lane with, right?

2719
02:46:21,000 --> 02:46:25,700
So off we go and now we can see whether that produced and it's not

2720
02:46:25,700 --> 02:46:26,400
that much lower.

2721
02:46:26,400 --> 02:46:31,000
I mean it's significant because you know, we were getting nine mil

2722
02:46:31,300 --> 02:46:38,100
point, you know, we were getting we're getting .002 more milliseconds,

2723
02:46:38,100 --> 02:46:39,700
more per bounce, right?

2724
02:46:40,600 --> 02:46:41,900
So it's definitely bad.

2725
02:46:42,600 --> 02:46:44,800
But it's, you know, it's four times slower three times, slower

2726
02:46:44,800 --> 02:46:49,300
something like that in scalar form, which we probably could figure out

2727
02:46:49,300 --> 02:46:53,400
how to improve, but at least when we look at it now we're getting the

2728
02:46:53,400 --> 02:46:55,000
correct results, right?

2729
02:46:57,100 --> 02:46:58,100
So that's good.

2730
02:46:58,800 --> 02:47:01,800
So now if we go ahead and set the lane with up, we at least hear that

2731
02:47:01,800 --> 02:47:05,900
the structure is correct, but we probably have bugs in our lane

2732
02:47:05,900 --> 02:47:08,800
implementation and so, we have to go now.

2733
02:47:08,800 --> 02:47:15,500
Figure out what those bugs are, because when we run it in length mode,

2734
02:47:15,500 --> 02:47:19,000
it's still wrong, actually, but we just run it this way, I suppose.

2735
02:47:19,900 --> 02:47:21,400
So, here it is in Lane mode.

2736
02:47:23,400 --> 02:47:25,800
And off it goes and it's doing its thing.

2737
02:47:27,300 --> 02:47:27,800
And

2738
02:47:32,500 --> 02:47:33,800
Yeah, and there we go.

2739
02:47:35,200 --> 02:47:40,200
So with doing these, you know, we don't really get a speed-up, which

2740
02:47:40,200 --> 02:47:40,900
is kind of weird.

2741
02:47:40,900 --> 02:47:43,300
So something's kind of odd in there and we're gonna have to go look at

2742
02:47:43,300 --> 02:47:43,500
this.

2743
02:47:43,500 --> 02:47:47,200
In more detail, we get a quite a speed up over the bad scalar version.

2744
02:47:47,400 --> 02:47:50,600
But remember our good scalar version was around this feed.

2745
02:47:50,700 --> 02:47:52,000
So it was all a wash.

2746
02:47:52,000 --> 02:47:56,500
If we don't get any more speed Improvement, then that, but before we

2747
02:47:56,500 --> 02:47:59,000
can look into that at all, we have to first figure out why we're not

2748
02:47:59,000 --> 02:47:59,800
working properly.

2749
02:48:00,200 --> 02:48:03,300
Because that's kind of a separate problem altogether, right?

2750
02:48:05,400 --> 02:48:06,100
So you can see here.

2751
02:48:06,100 --> 02:48:07,800
We're getting some really bizarre.

2752
02:48:08,100 --> 02:48:10,400
It's kind of interesting what we're seeing.

2753
02:48:11,400 --> 02:48:16,600
Honestly I am not 100% sure how to

2754
02:48:20,000 --> 02:48:26,300
what that pattern represents but you know, interested to find out.

2755
02:48:26,500 --> 02:48:29,300
So anyway, let me go ahead and compile that.

2756
02:48:29,800 --> 02:48:30,900
Let's go back to the

2757
02:48:32,500 --> 02:48:33,600
Sort of slow mode.

2758
02:48:34,300 --> 02:48:43,000
And just take a look at what's going on in the, in the wide version of

2759
02:48:43,000 --> 02:48:43,600
the code.

2760
02:48:44,600 --> 02:48:47,900
So in the wide version of the code, let's step in here.

2761
02:48:47,900 --> 02:48:51,200
And first, verify that any of these values or even correct.

2762
02:48:51,200 --> 02:48:54,300
I assume that most of them are because that image is kind of starting

2763
02:48:54,300 --> 02:48:55,700
to be close to correct, right?

2764
02:48:55,700 --> 02:48:58,400
Like things were sort of in the right place, the sky was in the right

2765
02:48:58,400 --> 02:49:02,000
place so it would be weird if any of these values.

2766
02:49:02,500 --> 02:49:04,100
We're super odd.

2767
02:49:06,200 --> 02:49:11,300
In terms of what they represented and so you can see 1000 is the

2768
02:49:11,300 --> 02:49:11,900
x-axis.

2769
02:49:11,900 --> 02:49:15,500
That's what we expect 0.065.

2770
02:49:18,100 --> 02:49:18,700
I'll be honest with you.

2771
02:49:18,700 --> 02:49:21,800
That's not what I would have expected for the Y value.

2772
02:49:21,800 --> 02:49:24,100
Wait was I oh I wasn't on the Y value.

2773
02:49:24,100 --> 02:49:24,600
That's why.

2774
02:49:25,600 --> 02:49:29,700
Now I was that that doesn't look like a right.

2775
02:49:29,700 --> 02:49:33,100
Y value to me though.

2776
02:49:34,200 --> 02:49:35,300
What happened here?

2777
02:49:41,000 --> 02:49:42,500
that, that doesn't

2778
02:49:43,900 --> 02:49:45,800
look like the Y value we had before.

2779
02:49:45,800 --> 02:49:47,200
What's, what's going on there?

2780
02:49:51,600 --> 02:49:53,600
That's obviously correct.

2781
02:50:10,100 --> 02:50:11,500
I, I don't.

2782
02:50:12,400 --> 02:50:15,100
I think that's right, though.

2783
02:50:17,400 --> 02:50:25,500
so, I'm just looking at this value and, you know,

2784
02:50:26,800 --> 02:50:28,800
These are all represented across, right?

2785
02:50:28,800 --> 02:50:33,000
So we're looking at the vector is coming down this way and that just

2786
02:50:33,000 --> 02:50:38,300
doesn't look like that would sum to 1 when squared, right?

2787
02:50:38,300 --> 02:50:38,900
I mean,

2788
02:50:41,100 --> 02:50:44,600
Those aren't sufficiently High values to some 21.

2789
02:50:44,600 --> 02:50:52,200
So I feel like this normalizer 0 cure is not doing the right thing.

2790
02:50:52,200 --> 02:50:54,400
So I'm going to kind of come in here and see what's going on.

2791
02:50:58,700 --> 02:50:59,500
So, let's see.

2792
02:50:59,500 --> 02:50:59,800
We've got

2793
02:51:00,000 --> 02:51:07,700
length squared of this vector and that's just going to be well, you

2794
02:51:07,700 --> 02:51:09,500
know what, let's just step right into it, actually,

2795
02:51:14,300 --> 02:51:15,900
So let's check a look at the.

2796
02:51:16,600 --> 02:51:20,800
Let's check a look at the inner product here and so this is just going

2797
02:51:20,800 --> 02:51:24,600
to do sort of those small pieces like multiples of those small pieces,

2798
02:51:24,600 --> 02:51:25,100
right?

2799
02:51:25,300 --> 02:51:31,700
So if you look at A and B and results, these are all actually just

2800
02:51:31,700 --> 02:51:36,500
replicated across so I should see if I look at these Lane, be threes,

2801
02:51:37,100 --> 02:51:42,100
I should see the inner product being just whatever it would be in

2802
02:51:42,100 --> 02:51:42,300
this.

2803
02:51:42,700 --> 02:51:44,100
And that's exactly what we see.

2804
02:51:44,100 --> 02:51:46,700
It's this squared plus this squared plus that squared.

2805
02:51:46,700 --> 02:51:47,100
Yep.

2806
02:51:47,800 --> 02:51:49,900
So that that looks right to me.

2807
02:51:51,600 --> 02:51:54,200
No worries there so that length Square looks.

2808
02:51:54,200 --> 02:51:55,200
Looks correct.

2809
02:51:55,600 --> 02:51:56,800
This mask value.

2810
02:51:59,200 --> 02:52:02,300
That's going to be a greater than comparison with the square here.

2811
02:52:03,000 --> 02:52:06,200
So let's take a look at that obviously a times a in this case, right?

2812
02:52:06,200 --> 02:52:07,400
That is whatever that is.

2813
02:52:08,600 --> 02:52:09,100
So

2814
02:52:11,400 --> 02:52:14,700
That's just going to produce a 1 or a 0 in this Lane.

2815
02:52:14,800 --> 02:52:17,500
You 32 should write.

2816
02:52:17,500 --> 02:52:19,500
It should just produce the mask that we want.

2817
02:52:19,500 --> 02:52:21,700
All apps are not all laughs, right?

2818
02:52:22,800 --> 02:52:26,900
So let's take a look here at like the, you three, two versions and

2819
02:52:27,600 --> 02:52:29,000
they're all positive.

2820
02:52:29,000 --> 02:52:30,700
Right, so that's good.

2821
02:52:31,700 --> 02:52:34,300
So then we go into the conditional assignment here.

2822
02:52:34,900 --> 02:52:37,600
Here is the result value that we actually wanted.

2823
02:52:37,700 --> 02:52:39,100
Oh, that's

2824
02:52:40,100 --> 02:52:41,000
No, that's right.

2825
02:52:41,100 --> 02:52:41,600
That's right.

2826
02:52:42,400 --> 02:52:44,300
So that result value should be all set to zeros.

2827
02:52:44,300 --> 02:52:46,700
We've got a mass but it's all set to ones and then we have a value

2828
02:52:46,700 --> 02:52:49,400
coming in here that's going to be whatever.

2829
02:52:49,400 --> 02:52:52,400
The a value is x 1 over the square root.

2830
02:52:52,600 --> 02:52:54,600
Let's see how that actually gets computed.

2831
02:52:55,100 --> 02:52:59,600
Here's the script PS of a so that that should be about 10 right?

2832
02:52:59,600 --> 02:53:00,900
Should be what we end up with.

2833
02:53:03,600 --> 02:53:04,400
In this case.

2834
02:53:04,600 --> 02:53:05,900
And that's exactly what we get.

2835
02:53:05,900 --> 02:53:06,600
So that's good.

2836
02:53:06,600 --> 02:53:08,000
That's all working properly.

2837
02:53:08,400 --> 02:53:11,400
So now we're going to invert that and get point one, right?

2838
02:53:12,200 --> 02:53:14,100
And that's again.

2839
02:53:15,900 --> 02:53:16,900
Looking right.

2840
02:53:17,800 --> 02:53:23,100
We then multiply by a, which was itself what did we say that was that

2841
02:53:23,100 --> 02:53:29,100
was oh, that's a vector of 010, whatever rights that's going to

2842
02:53:29,100 --> 02:53:30,300
normalize it down.

2843
02:53:31,200 --> 02:53:32,400
So let's take a look at what that is.

2844
02:53:32,400 --> 02:53:34,400
This should be our normalized Vector now.

2845
02:53:36,600 --> 02:53:37,500
There's the zero.

2846
02:53:39,100 --> 02:53:41,000
There's the one and that's looking great.

2847
02:53:41,100 --> 02:53:46,400
Right now, we go into conditional assign conditional, assign is going

2848
02:53:46,400 --> 02:53:49,800
to do the conditional assignment on each of these separately.

2849
02:53:49,800 --> 02:53:54,200
So it's going to use the source X, The Source, Y and the source is

2850
02:53:54,200 --> 02:53:56,300
easy, and it's going to use the desk decks dust.

2851
02:53:56,300 --> 02:53:59,900
Why invest Z with the masking value here we come into

2852
02:54:00,000 --> 02:54:01,100
She was assigned.

2853
02:54:01,800 --> 02:54:04,400
The first thing we're going to do is take that mass value and convert

2854
02:54:04,400 --> 02:54:06,100
it to a PS value, right?

2855
02:54:06,800 --> 02:54:10,600
And so if we take a look at the M 128 and we look at it as if it were

2856
02:54:10,600 --> 02:54:12,200
a youth or youth or D2.

2857
02:54:14,100 --> 02:54:15,200
That's our problem.

2858
02:54:15,200 --> 02:54:16,400
This is not right.

2859
02:54:16,400 --> 02:54:20,800
This is supposed to be a cast for some reason I did a convert and it's

2860
02:54:20,800 --> 02:54:22,100
supposed to be a cast.

2861
02:54:22,700 --> 02:54:27,600
So that's that's probably a huge source of a lot of bugs right there.

2862
02:54:29,400 --> 02:54:33,000
Remember convert actually takes the value.

2863
02:54:33,000 --> 02:54:35,300
That's of the integer and turns it into a floating point.

2864
02:54:35,300 --> 02:54:36,800
Value that has that same value.

2865
02:54:37,400 --> 02:54:38,500
That's not what we want here.

2866
02:54:38,500 --> 02:54:42,500
We want it to just pretend it was

2867
02:54:44,900 --> 02:54:48,600
I the exact B just stuff them in and call them afloat, whatever they

2868
02:54:48,600 --> 02:54:49,600
are, right?

2869
02:54:50,600 --> 02:54:52,100
And that's not what we were getting there.

2870
02:54:52,100 --> 02:54:53,900
So let's try that one more time.

2871
02:54:54,600 --> 02:54:58,300
Let's jump back here to the conditional assignment.

2872
02:55:00,800 --> 02:55:01,300
Whoops.

2873
02:55:01,300 --> 02:55:05,400
Well, that was not what I wanted to do.

2874
02:55:08,300 --> 02:55:12,000
How come we didn't break point here, someone's calling this, right?

2875
02:55:12,300 --> 02:55:12,800
Some point.

2876
02:55:12,800 --> 02:55:13,400
There we go.

2877
02:55:14,500 --> 02:55:16,700
So this should be called on that normalizer 0.

2878
02:55:16,700 --> 02:55:19,200
We should be an exact same place because the first one.

2879
02:55:20,300 --> 02:55:23,100
So, let's take a look at what we're passing here.

2880
02:55:23,300 --> 02:55:24,900
So the source,

2881
02:55:28,400 --> 02:55:31,200
And the dest in this case, doesn't matter.

2882
02:55:31,600 --> 02:55:32,200
Let's take a look at that.

2883
02:55:32,200 --> 02:55:32,700
Massive value.

2884
02:55:32,700 --> 02:55:35,500
Is it should be all ones, it is.

2885
02:55:36,200 --> 02:55:40,300
So now we're going to do with the and not and the and of the mask with

2886
02:55:40,300 --> 02:55:41,700
the to Source values.

2887
02:55:42,400 --> 02:55:45,000
Let's double check that we get what we expect.

2888
02:55:45,300 --> 02:55:54,000
So cures are dest excerpts, Test X desc, why dust

2889
02:55:55,600 --> 02:56:01,700
Z and we're going to step through it, and we should see these get

2890
02:56:01,700 --> 02:56:04,400
assigned to the right values now and they are okay.

2891
02:56:05,800 --> 02:56:07,000
So that's much better.

2892
02:56:07,000 --> 02:56:11,400
And now these values are going to probably look more sane to me.

2893
02:56:13,100 --> 02:56:13,600
Yep.

2894
02:56:15,600 --> 02:56:16,200
Yep.

2895
02:56:17,500 --> 02:56:18,000
Yep.

2896
02:56:18,600 --> 02:56:23,000
Okay, so let's try running this one more time so that I can see what

2897
02:56:23,000 --> 02:56:24,000
the image looks like.

2898
02:56:24,000 --> 02:56:27,300
And that will guide my debugging, probably as I look through for the

2899
02:56:27,300 --> 02:56:28,400
next set of Errors.

2900
02:56:29,400 --> 02:56:31,200
So I'm going to change this to 0-2.

2901
02:56:32,500 --> 02:56:35,400
And I'm going to return it to allowing it to use the full core count

2902
02:56:35,800 --> 02:56:39,800
so that we can quickly just run the image test.

2903
02:56:39,800 --> 02:56:40,300
Right?

2904
02:56:40,600 --> 02:56:49,800
So often goes doing its images, whatever stuff it's doing and hey we

2905
02:56:49,800 --> 02:56:53,500
got a little bit faster pronounce to so that was something but you

2906
02:56:53,500 --> 02:56:54,000
know, whatever.

2907
02:56:55,200 --> 02:56:59,800
So now here's our test bitmap and you can see we got better, right?

2908
02:57:00,200 --> 02:57:03,200
We definitely got better, but we still have a problem with that

2909
02:57:03,200 --> 02:57:04,800
Omission masking, right?

2910
02:57:04,800 --> 02:57:06,200
So we're not quite there yet.

2911
02:57:06,200 --> 02:57:10,200
We're now kind of more towards where we were when we first ran the

2912
02:57:10,200 --> 02:57:10,700
other one, right?

2913
02:57:10,700 --> 02:57:14,400
And I'll make sure that there were not seeing something deleterious

2914
02:57:14,400 --> 02:57:14,600
there.

2915
02:57:14,600 --> 02:57:17,300
We'll just run it again and it should produce exact same image.

2916
02:57:20,100 --> 02:57:22,900
But so now we knew there's something strange going on.

2917
02:57:22,900 --> 02:57:25,400
We're not really sure what it is, but there's something strange going

2918
02:57:25,400 --> 02:57:28,600
on here with the emission, tracking again, because we're clearly

2919
02:57:28,600 --> 02:57:29,900
getting the right hits on

2920
02:57:30,000 --> 02:57:31,300
On the first time through.

2921
02:57:31,500 --> 02:57:35,500
But then, as we Trace, those subsequent, raise Something That We're

2922
02:57:35,500 --> 02:57:38,500
caring for words is getting borked, right?

2923
02:57:39,600 --> 02:57:43,600
And so we need to go step through there and see there's two ways.

2924
02:57:43,600 --> 02:57:46,000
That could be going wrong again.

2925
02:57:46,000 --> 02:57:49,400
One of them is The Gather could be wrong, obviously.

2926
02:57:50,900 --> 02:57:53,100
So we could have a bug in the gather.

2927
02:57:53,400 --> 02:57:59,000
The other thing that could be wrong is we could have a bug in the the

2928
02:57:59,000 --> 02:58:02,200
masking or however that emission stuff is getting carried forward.

2929
02:58:02,500 --> 02:58:05,100
Let's take a really quick look at the gathered here.

2930
02:58:05,400 --> 02:58:10,900
Right here is our gather F32 which is really all we actually use.

2931
02:58:14,000 --> 02:58:17,600
and this gather,

2932
02:58:19,100 --> 02:58:21,000
F32 here.

2933
02:58:24,900 --> 02:58:27,800
just want to make sure that these two things are commensurate

2934
02:58:28,800 --> 02:58:31,800
or not, commensurate, but are sort of equivalent.

2935
02:58:33,100 --> 02:58:35,600
So these are the two gather functions we have.

2936
02:58:36,200 --> 02:58:39,000
We have the base pointer version which goes like baseball nurse.

2937
02:58:39,000 --> 02:58:40,600
Tried indices, right?

2938
02:58:41,000 --> 02:58:43,900
And then we have the the one that just does.

2939
02:58:43,900 --> 02:58:45,300
The Straight Ahead index here.

2940
02:58:46,300 --> 02:58:50,000
And it looks like these are basically the same, right?

2941
02:58:50,000 --> 02:58:51,000
I there's nothing.

2942
02:58:51,000 --> 02:58:52,600
I don't see anything too.

2943
02:58:52,600 --> 02:58:54,500
Wonky going on here.

2944
02:58:56,700 --> 02:58:57,400
Looks

2945
02:58:58,200 --> 02:59:00,400
Looks reasonable, right?

2946
02:59:01,700 --> 02:59:07,200
So it's Jimmy, we got a decent base pointer there, we should be able

2947
02:59:07,200 --> 02:59:09,500
to track extract those indices exactly.

2948
02:59:09,500 --> 02:59:16,800
As it's being shown there and I don't see any really particular reason

2949
02:59:16,800 --> 02:59:17,400
why.

2950
02:59:25,700 --> 02:59:29,500
I don't see anything in particular, that, that should be causing us a

2951
02:59:29,500 --> 02:59:30,600
problem with that gather.

2952
02:59:31,500 --> 02:59:34,300
So I'm going to go ahead and say, let's step through the code here.

2953
02:59:34,300 --> 02:59:35,500
Let me convert it back down.

2954
02:59:35,500 --> 02:59:36,800
I think we're almost there.

2955
02:59:37,600 --> 02:59:40,500
So, let me go ahead and convert this to an o.d.

2956
02:59:40,500 --> 02:59:46,700
and, and go back to One Core account there.

2957
02:59:49,000 --> 02:59:49,500
Like so.

2958
02:59:52,500 --> 02:59:59,700
and so, what I'm going to do here is say, let's assume that most of

2959
02:59:59,700 --> 02:59:59,800
this

2960
03:00:00,000 --> 03:00:03,200
I was working correctly for now and let's just Target our debugging

2961
03:00:03,200 --> 03:00:06,200
first at sort of that ending.

2962
03:00:06,200 --> 03:00:08,400
Part, where do we go here?

2963
03:00:08,600 --> 03:00:12,700
Right here, where we're actually trying to gather stuff up.

2964
03:00:13,300 --> 03:00:15,900
So, let's take a look at the mat emit color.

2965
03:00:17,400 --> 03:00:21,200
And let's take a look to see what we actually gathered there.

2966
03:00:21,900 --> 03:00:26,200
Madam it color, matte ref color and Matt scatter.

2967
03:00:26,600 --> 03:00:29,000
So here are what we gathered for these.

2968
03:00:31,300 --> 03:00:32,100
In this case.

2969
03:00:32,700 --> 03:00:35,000
And let's also take a look at what the index was supposed to be.

2970
03:00:35,000 --> 03:00:37,300
So hit, Matt Index, right?

2971
03:00:39,400 --> 03:00:41,400
All right, so our hit Matt index.

2972
03:00:41,400 --> 03:00:47,500
In this case, here are the what we think we hit so in this bundle of

2973
03:00:47,500 --> 03:00:52,300
rays we think we always hit sort of that ground plane I think so we're

2974
03:00:52,300 --> 03:00:55,700
probably focusing on just a little section down in the corner right

2975
03:00:55,700 --> 03:00:56,700
where there's nothing else to hit.

2976
03:00:56,700 --> 03:00:59,400
So all of our raise that went out through the pixel.

2977
03:00:59,400 --> 03:01:03,100
They all hit the same thing and that's probably going to be true most

2978
03:01:03,100 --> 03:01:05,600
of the time like because we're sampling a single Pixel.

2979
03:01:05,900 --> 03:01:08,100
Probably the first hit is going to be all

2980
03:01:08,300 --> 03:01:09,600
Same material, right?

2981
03:01:10,800 --> 03:01:14,000
That's just probably going to be true for most of the time now, right

2982
03:01:14,000 --> 03:01:18,300
on the edges, it won't be true but, you know, so we'll take a look

2983
03:01:18,300 --> 03:01:18,500
here.

2984
03:01:18,500 --> 03:01:20,400
We see that we're getting all ones.

2985
03:01:20,800 --> 03:01:23,700
So we should be gathering up the same values for the rest of the

2986
03:01:23,700 --> 03:01:24,100
stuff.

2987
03:01:24,600 --> 03:01:25,500
The scatter.

2988
03:01:27,200 --> 03:01:28,800
Where we look at what the scatter value is.

2989
03:01:28,800 --> 03:01:30,100
It should be all the same.

2990
03:01:31,000 --> 03:01:33,800
When we look at what the reflection color is that again.

2991
03:01:33,800 --> 03:01:35,300
Should also be all the same.

2992
03:01:35,300 --> 03:01:35,600
Right?

2993
03:01:35,600 --> 03:01:37,000
Here's its .5.

2994
03:01:37,000 --> 03:01:42,700
There should be 0.5 is here and it should be 0.5 is here because

2995
03:01:42,700 --> 03:01:43,700
that's that ground plane.

2996
03:01:43,700 --> 03:01:45,600
I think it's just a great reflected.

2997
03:01:45,600 --> 03:01:50,000
Plain, the emission color should be all zeros which you know, it is.

2998
03:01:50,700 --> 03:01:51,900
And that's all fine.

2999
03:01:52,700 --> 03:01:54,300
So that's all good, right?

3000
03:01:55,500 --> 03:01:56,900
So that seems pretty straightforward.

3001
03:01:56,900 --> 03:01:58,800
It looks like that gather maybe work properly.

3002
03:01:58,800 --> 03:02:00,500
It's a little artichokes, the all at the same things.

3003
03:02:00,500 --> 03:02:03,600
That could be that The Gather doesn't quite work right when you have

3004
03:02:03,600 --> 03:02:04,500
different indices.

3005
03:02:04,500 --> 03:02:08,200
So, that's sort of still leaves a little bit of, you know.

3006
03:02:08,300 --> 03:02:10,900
Well, maybe this could still be wrong happening there.

3007
03:02:11,700 --> 03:02:13,900
So, we've got the sample that we're summing.

3008
03:02:14,400 --> 03:02:18,200
Summing up here for like the Reds greens, blues, and so on the magnet

3009
03:02:18,200 --> 03:02:18,400
colors.

3010
03:02:18,400 --> 03:02:18,900
Nothing.

3011
03:02:19,100 --> 03:02:20,300
The attenuation is 1.

3012
03:02:20,700 --> 03:02:23,600
So in this case, we should just see that this sample didn't change at.

3013
03:02:23,600 --> 03:02:24,600
All right.

3014
03:02:24,800 --> 03:02:25,400
That's you know what?

3015
03:02:25,400 --> 03:02:27,400
We are going to see the lean mask.

3016
03:02:27,400 --> 03:02:31,400
On the other hand, all the hits were valid, so the lane mask should

3017
03:02:31,400 --> 03:02:32,600
stay the same right.

3018
03:02:32,600 --> 03:02:33,500
And let's verify that.

3019
03:02:33,500 --> 03:02:36,400
That's the case because that may be wrong.

3020
03:02:36,400 --> 03:02:39,000
And so it didn't, this is the kind of thing I was suspicious of.

3021
03:02:39,300 --> 03:02:44,800
You can see the hit Matt index here, not equal to 0 that was that is

3022
03:02:44,800 --> 03:02:47,800
not working and I don't know why.

3023
03:02:47,900 --> 03:02:52,500
So that's the thing that we next kind of need to to investigate

3024
03:02:53,400 --> 03:02:55,200
So let's step into that Ling mask.

3025
03:02:55,500 --> 03:02:56,200
Here we are.

3026
03:02:56,400 --> 03:02:58,500
Replicating this value out.

3027
03:02:58,600 --> 03:02:59,400
Let's see.

3028
03:02:59,600 --> 03:02:59,800
Oh,

3029
03:03:00,200 --> 03:03:04,300
So, see here.

3030
03:03:06,000 --> 03:03:08,200
So V, what is the value representing?

3031
03:03:08,200 --> 03:03:09,900
The really representing is 0.

3032
03:03:10,700 --> 03:03:14,800
So in this case we should end up with all zeros and in this case we do

3033
03:03:14,800 --> 03:03:16,100
so that looks right.

3034
03:03:16,200 --> 03:03:18,300
We've got a not equals operator.

3035
03:03:18,300 --> 03:03:22,000
Oh, and this was some nonsense that I sort of put in here.

3036
03:03:22,500 --> 03:03:25,900
So maybe I kind of did this stupidly, you know that could be.

3037
03:03:26,800 --> 03:03:27,900
That could be the problem.

3038
03:03:28,300 --> 03:03:31,600
So we've got an A and A B, right?

3039
03:03:31,700 --> 03:03:33,800
And we want to know if they're equal to each other.

3040
03:03:38,100 --> 03:03:41,300
So here's our a value in our B value, and if we're doing this as an

3041
03:03:41,300 --> 03:03:44,000
Epi, you can see that 1 is 1 and 1 is 0.

3042
03:03:44,600 --> 03:03:48,200
So what I expect to get here is the not equal to each other, should

3043
03:03:48,200 --> 03:03:49,500
actually return true.

3044
03:03:50,100 --> 03:03:51,900
And so let's see what it actually does return.

3045
03:03:51,900 --> 03:03:52,900
It returns false.

3046
03:03:53,100 --> 03:03:57,000
So this was just me being a bit of a dingus here, and it looks like

3047
03:03:57,400 --> 03:03:59,300
that is just a, not smart way to do it.

3048
03:03:59,700 --> 03:04:03,300
Now let's think this through, so when we do a comparison for equals,

3049
03:04:03,900 --> 03:04:06,200
this should have come back 0, right?

3050
03:04:07,100 --> 03:04:12,000
And so if I were to do a next-door of 0 with 0, I would have thought

3051
03:04:12,000 --> 03:04:17,500
that I would have gotten ones because it's exclusive or so, it should

3052
03:04:17,500 --> 03:04:18,000
be.

3053
03:04:19,700 --> 03:04:20,700
Oh no.

3054
03:04:22,400 --> 03:04:25,200
It's exclusive, or it has to be ones to flip it.

3055
03:04:25,400 --> 03:04:27,200
One slip zeros leaves the same.

3056
03:04:28,600 --> 03:04:32,700
Yeah, that's just, that's just a mental mental, fart right there.

3057
03:04:33,500 --> 03:04:34,700
So let's go back to that.

3058
03:04:34,700 --> 03:04:35,900
That's that's the problem.

3059
03:04:36,500 --> 03:04:37,500
Case you were wondering.

3060
03:04:40,600 --> 03:04:41,700
Let's see here.

3061
03:04:41,700 --> 03:04:42,700
Copy Q.

3062
03:04:43,400 --> 03:04:47,000
Yeah, so that was just me kind of being lost in the shuffle here,

3063
03:04:47,100 --> 03:04:48,200
doing something dumb.

3064
03:04:48,700 --> 03:04:52,600
That's not going to work at all because the exclusive art it has to be

3065
03:04:52,600 --> 03:04:53,000
exclusively.

3066
03:04:53,000 --> 03:04:56,200
Or if it's zeros I wanted to put the ones if it's ones on to put the

3067
03:04:56,200 --> 03:04:59,200
zeros which means I would have to put ones in there.

3068
03:04:59,400 --> 03:05:01,300
This would have to be right.

3069
03:05:01,900 --> 03:05:05,200
Set, one epi32

3070
03:05:07,100 --> 03:05:09,800
Of that right now.

3071
03:05:09,800 --> 03:05:14,600
Again, I don't think this is probably the best way to do this because

3072
03:05:14,600 --> 03:05:15,900
there's probably a smarter way.

3073
03:05:15,900 --> 03:05:18,500
We could get that to happen.

3074
03:05:19,000 --> 03:05:24,900
What we want to do here is we want to flip those bits and so I'm

3075
03:05:24,900 --> 03:05:29,100
trying to think of the thing that loads the least information

3076
03:05:31,500 --> 03:05:33,200
And I just don't know exactly what this going to be.

3077
03:05:33,200 --> 03:05:35,200
So I'm going to go ahead and put it to do here.

3078
03:05:41,500 --> 03:05:43,500
Because it's probably something that I thought about it for a few

3079
03:05:43,500 --> 03:05:45,000
seconds, I be like, oh yeah, it's this.

3080
03:05:45,000 --> 03:05:47,000
But you know on stream sometimes it's kind of confusing.

3081
03:05:47,000 --> 03:05:50,300
When you're talking things out, you make some dumb mistakes.

3082
03:05:50,600 --> 03:05:52,900
Anyway, and it's hard to think through little things like that, I

3083
03:05:52,900 --> 03:05:55,300
could do it on the Blackboard, probably is where we should do it.

3084
03:05:55,700 --> 03:05:58,900
So let's get back in there now and let's take a look at what happens

3085
03:05:58,900 --> 03:05:59,800
in that code.

3086
03:06:00,500 --> 03:06:02,100
So now we should be getting a result.

3087
03:06:02,100 --> 03:06:04,600
That's that's equal to one and we do.

3088
03:06:05,000 --> 03:06:07,800
So that's just that was again just being kind of dumb there.

3089
03:06:09,400 --> 03:06:15,700
Okay, so now Arlene mask should be set properly and it is and let's

3090
03:06:15,700 --> 03:06:19,300
see if that fixes our problem because I think that was a would have

3091
03:06:19,300 --> 03:06:20,400
been a big part of it, right?

3092
03:06:20,400 --> 03:06:23,600
Because then our lanes would get masked off in properly.

3093
03:06:24,100 --> 03:06:32,300
Let's go back here and we need a quick way to switch the build between

3094
03:06:32,300 --> 03:06:33,000
these two things.

3095
03:06:33,200 --> 03:06:34,800
I wonder if what we could do.

3096
03:06:37,600 --> 03:06:40,200
It's like a pragma optimize off kind of a thing.

3097
03:06:42,300 --> 03:06:47,200
I wonder if we could do a thing here where we just do well we'll look

3098
03:06:47,200 --> 03:06:47,900
at that in a second.

3099
03:06:47,900 --> 03:06:48,300
I guess.

3100
03:06:51,700 --> 03:06:52,000
Yeah.

3101
03:06:52,500 --> 03:06:55,600
Alright, so let's go ahead and try running that.

3102
03:06:58,800 --> 03:07:00,000
So off it goes.

3103
03:07:11,600 --> 03:07:14,700
And so again we've haven't proved our time but we haven't improved it

3104
03:07:14,700 --> 03:07:16,400
that much, which is kind of disappointing.

3105
03:07:16,400 --> 03:07:19,600
So even if this is correct we still a lot of work to do looking at

3106
03:07:19,600 --> 03:07:20,700
these two images.

3107
03:07:20,700 --> 03:07:26,500
It looks like we're still a little bit wrong here, right.

3108
03:07:26,500 --> 03:07:30,200
Here's our test bitmap and here's our

3109
03:07:34,100 --> 03:07:36,600
Here's our test-fit map and here's our reference bitmap.

3110
03:07:36,800 --> 03:07:41,700
It looks honestly almost like we've got some kind of like, we're not

3111
03:07:41,700 --> 03:07:45,300
using the scatter value at all, like the scatter values getting load

3112
03:07:45,300 --> 03:07:49,900
wrong loaded wrong or it was set wrong, one of the other, right?

3113
03:07:50,300 --> 03:07:53,000
Because it looks like these are getting set to sort of a more

3114
03:07:53,000 --> 03:07:56,500
reflective surfaces or something's weird.

3115
03:07:56,800 --> 03:08:01,400
So we're not quite out of the woods yet but we're a lot closer than we

3116
03:08:01,400 --> 03:08:02,500
were certainly

3117
03:08:02,600 --> 03:08:03,100
Right.

3118
03:08:04,600 --> 03:08:05,000
Okay.

3119
03:08:07,200 --> 03:08:07,600
So

3120
03:08:08,900 --> 03:08:12,900
Again looking here we're Computing roughly the same total number of

3121
03:08:12,900 --> 03:08:16,200
bounces as before we're a little bit faster than we were but we would

3122
03:08:16,200 --> 03:08:20,200
have expected to maybe get more more significantly faster like 2X or

3123
03:08:20,200 --> 03:08:20,600
something.

3124
03:08:20,600 --> 03:08:23,700
Hopefully out of this and we didn't.

3125
03:08:23,700 --> 03:08:27,100
So we're going to have to look into how how and why we're getting slow

3126
03:08:27,100 --> 03:08:27,600
down.

3127
03:08:28,100 --> 03:08:32,800
It could be that a lot of time is spent doing extra work, maybe those

3128
03:08:32,800 --> 03:08:37,100
those widths, the maybe we're not able to fill all for as often as we

3129
03:08:37,100 --> 03:08:38,600
would have liked to or something like

3130
03:08:38,800 --> 03:08:41,300
It's and we're just wasting a lot of time.

3131
03:08:41,600 --> 03:08:45,100
Loading up materials that don't actually exist or something like this.

3132
03:08:45,100 --> 03:08:45,900
You know, who knows?

3133
03:08:48,300 --> 03:08:54,100
So yeah, what I would say here is we need to kind of think this

3134
03:08:54,100 --> 03:08:58,200
through a little bit more and now we need to kind of also think about

3135
03:08:58,200 --> 03:08:59,800
where, you know, we've got some bug.

3136
03:09:00,000 --> 03:09:04,100
Math somewhere and we need to figure out exactly where that is.

3137
03:09:04,400 --> 03:09:07,200
So this can be a little bit difficult to do.

3138
03:09:07,200 --> 03:09:11,000
And one of the things that we would probably like to do at this point

3139
03:09:11,000 --> 03:09:15,800
is run these two things through sort of some kind of a set of test

3140
03:09:15,800 --> 03:09:20,100
that verifies whether they're all working properly with respect to the

3141
03:09:20,100 --> 03:09:20,900
scalar version.

3142
03:09:21,600 --> 03:09:26,400
So something that was is going to compare like a pixel to a pixel as

3143
03:09:26,400 --> 03:09:29,900
you kind of Step through it and see that they're getting the same.

3144
03:09:30,000 --> 03:09:31,500
It's in both cases, right?

3145
03:09:33,400 --> 03:09:35,400
And that is something we can actually sort of do.

3146
03:09:35,600 --> 03:09:38,700
We can compile this both ways and run them versus each other.

3147
03:09:39,700 --> 03:09:41,600
Unfortunately, this is harder to do than it.

3148
03:09:41,600 --> 03:09:44,400
Should be what you really want to be able to do is the have the

3149
03:09:44,400 --> 03:09:47,600
debugger understand this and allow you to run two versions at the same

3150
03:09:47,600 --> 03:09:50,500
time and show you the results from both of them because, you know,

3151
03:09:50,500 --> 03:09:53,500
that you'd see there as soon as they diverge, you know, you'd be like,

3152
03:09:53,500 --> 03:09:55,300
Oh, okay, that's where the bug is, right?

3153
03:09:57,600 --> 03:10:00,300
But what I'm going to do before that just in case we can do it quickly

3154
03:10:00,300 --> 03:10:04,000
and the stream early without to go too much into that stuff, is I want

3155
03:10:04,000 --> 03:10:07,000
to look really quickly at what we've got here in our four wide

3156
03:10:07,700 --> 03:10:08,100
version.

3157
03:10:08,100 --> 03:10:11,600
And just see if there's anything obviously stupid that we're doing.

3158
03:10:12,100 --> 03:10:13,800
So for R, less than operator.

3159
03:10:13,800 --> 03:10:17,100
We are doing a comp less than for a less than or equal to.

3160
03:10:17,100 --> 03:10:21,200
We are doing a less than or equal to write for greater than we are

3161
03:10:21,200 --> 03:10:23,400
doing greater than so that's nice.

3162
03:10:23,400 --> 03:10:24,400
A greater than equal to.

3163
03:10:24,400 --> 03:10:26,000
We are doing greater than or equal to

3164
03:10:27,300 --> 03:10:27,800
Four equals.

3165
03:10:27,800 --> 03:10:32,900
We've got equals 4, not equals B, but not equals and for nought equals

3166
03:10:32,900 --> 03:10:34,100
with you 32s.

3167
03:10:34,700 --> 03:10:37,800
We are doing this sort of weird thing that I messed up the first time,

3168
03:10:38,100 --> 03:10:40,000
but that it's working this time.

3169
03:10:42,000 --> 03:10:45,200
All right, for xor operator.

3170
03:10:46,100 --> 03:10:46,900
We've got

3171
03:10:48,900 --> 03:10:53,300
The xor operator properly, right done for our.

3172
03:10:53,300 --> 03:11:00,600
And we have an and for and with you 32s we have one that casts not

3173
03:11:00,600 --> 03:11:04,800
converts but casts the, a up to a PS and then does it returns a PS?

3174
03:11:04,800 --> 03:11:13,000
Which is what we want for and not we have an end not for or we have an

3175
03:11:13,000 --> 03:11:18,500
or for shift, we have a shift left immediately.

3176
03:11:18,700 --> 03:11:21,700
It and it's a logical shift that's going to kind of shift up there is,

3177
03:11:23,300 --> 03:11:25,800
and that looks proper for a shift right?

3178
03:11:25,800 --> 03:11:27,900
We have a shift, right, logical?

3179
03:11:27,900 --> 03:11:32,600
Which again, is also what I believe is supposed to happen there.

3180
03:11:33,100 --> 03:11:35,200
Now, I don't know that that's actually true.

3181
03:11:35,200 --> 03:11:39,100
It could be that they want a shift with right arithmetic.

3182
03:11:41,000 --> 03:11:45,400
Forex or shift and so I should double-check that.

3183
03:11:59,700 --> 03:11:59,800
Well.

3184
03:12:00,000 --> 03:12:00,300
Okay.

3185
03:12:00,300 --> 03:12:05,400
That's, I guess not what I wanted to know, but I guess what I would

3186
03:12:05,400 --> 03:12:09,800
say is presumably unsigned versus signed would say, which one it would

3187
03:12:09,800 --> 03:12:12,000
do in C.

3188
03:12:12,000 --> 03:12:19,600
And since we took a look at the Wikipedia code in C, if that code was

3189
03:12:19,600 --> 03:12:23,400
correct then and of course, we're just trying to match the other code.

3190
03:12:23,400 --> 03:12:28,900
Anyway then all of these were done as you 32s so it should be a

3191
03:12:28,900 --> 03:12:29,800
logical shift.

3192
03:12:30,000 --> 03:12:30,300
Left.

3193
03:12:31,600 --> 03:12:32,100
Right.

3194
03:12:34,100 --> 03:12:36,300
And so that is what it is and that's good.

3195
03:12:37,400 --> 03:12:38,100
So Arlene F.

3196
03:12:38,100 --> 03:12:40,400
32 ad is an ad Arlene.

3197
03:12:40,400 --> 03:12:44,000
F32 adieu 32 is a DPI right?

3198
03:12:44,000 --> 03:12:44,800
That looks good.

3199
03:12:45,000 --> 03:12:49,900
Our subtract and our mole or both exactly what we would expect.

3200
03:12:49,900 --> 03:12:50,600
There's a sub.

3201
03:12:50,600 --> 03:12:56,100
There's the mole right are divided is again exactly what we would

3202
03:12:56,100 --> 03:12:57,300
expect.

3203
03:12:58,000 --> 03:13:01,400
Our conversion is a conversion.

3204
03:13:02,300 --> 03:13:04,200
I r.

3205
03:13:05,600 --> 03:13:07,500
Set reverse is a set reverse.

3206
03:13:07,500 --> 03:13:09,700
This one doesn't matter really the order because it's just random it,

3207
03:13:09,700 --> 03:13:18,400
only loads Randomness anyway, are set one here, which replicates both

3208
03:13:18,400 --> 03:13:19,100
cases.

3209
03:13:19,100 --> 03:13:24,600
The replication looks right to me set 1, PS or set one epi depending

3210
03:13:24,600 --> 03:13:25,300
what you're reloading.

3211
03:13:28,400 --> 03:13:28,600
Yeah.

3212
03:13:28,600 --> 03:13:30,700
So that all looks good to me.

3213
03:13:32,500 --> 03:13:36,100
The square root is an M squared, which is exactly what we want it to

3214
03:13:36,100 --> 03:13:37,500
be the conditional, assign.

3215
03:13:37,500 --> 03:13:40,600
We checked and isn't and not, and with the cast we had messed that up

3216
03:13:40,600 --> 03:13:41,800
originally, but we fixed it.

3217
03:13:42,700 --> 03:13:49,600
The Min and the max, so Min is properly calling Min and Max is

3218
03:13:49,600 --> 03:13:51,200
properly calling Max.

3219
03:13:52,600 --> 03:13:54,700
So I think that should be fine.

3220
03:13:57,500 --> 03:14:01,800
We've got to gather F32 here that we checked and we think is working

3221
03:14:01,800 --> 03:14:02,500
properly.

3222
03:14:03,100 --> 03:14:04,400
The mask is zeroed.

3223
03:14:04,500 --> 03:14:08,300
It does the mauve mask that looked proper.

3224
03:14:08,300 --> 03:14:13,500
We could test it, we didn't test it, horizontal add, we don't have

3225
03:14:13,500 --> 03:14:16,300
much reason to suspect being wrong but you know, if it was.

3226
03:14:18,000 --> 03:14:21,400
So let's take a look here at the clamp

3227
03:14:22,900 --> 03:14:23,800
01.

3228
03:14:25,800 --> 03:14:27,900
So this we really could translate out.

3229
03:14:27,900 --> 03:14:31,400
Again, we could keep translating some of these out again, even more so

3230
03:14:31,400 --> 03:14:32,300
than they already are.

3231
03:14:32,700 --> 03:14:38,100
But if we take a look here at this, clamp 01, this is these are all

3232
03:14:38,100 --> 03:14:39,800
these in here are special as well.

3233
03:14:39,800 --> 03:14:43,700
So we probably need to verify those really quickly in addition, right?

3234
03:14:46,800 --> 03:14:48,500
Sue.

3235
03:14:49,300 --> 03:14:50,600
Yeah.

3236
03:14:56,400 --> 03:14:59,800
Why do we only Define struct Lane V?

3237
03:15:00,000 --> 03:15:04,300
Three lane with not equal to 1.

3238
03:15:12,800 --> 03:15:17,700
I guess because they happen to be the same but they don't really need

3239
03:15:17,700 --> 03:15:18,900
to do that anymore.

3240
03:15:18,900 --> 03:15:19,800
Can't we do this?

3241
03:15:19,800 --> 03:15:20,500
I'm sorry.

3242
03:15:21,000 --> 03:15:23,100
Can't we just do this universally now?

3243
03:15:23,700 --> 03:15:26,000
I guess I don't need to do it now but we should to do.

3244
03:15:34,600 --> 03:15:40,800
So in here, we've got internally an F32, and we've got operator + A

3245
03:15:40,800 --> 03:15:41,500
and B.

3246
03:15:42,300 --> 03:15:46,600
We are lofting the beat up by replicating and doing the ad, that's

3247
03:15:46,600 --> 03:15:50,000
what we would expect to do, I think, in either case.

3248
03:15:52,400 --> 03:15:57,800
So that seems fine to me in both cases.

3249
03:15:58,100 --> 03:16:03,100
Plus this plus minus is minus it all looks good.

3250
03:16:04,500 --> 03:16:08,800
Times this times, in both cases, divide is divided.

3251
03:16:10,100 --> 03:16:13,400
Plus equals does exactly what you'd expect.

3252
03:16:18,400 --> 03:16:21,000
For both, you 32s and F 32s.

3253
03:16:24,300 --> 03:16:29,900
- does what you expect x equals does as well.

3254
03:16:30,500 --> 03:16:33,200
Divide equals does to and equals

3255
03:16:35,700 --> 03:16:38,400
As well X or equals as well.

3256
03:16:40,000 --> 03:16:41,300
Or equals as well.

3257
03:16:42,300 --> 03:16:43,600
Operator equals.

3258
03:16:47,600 --> 03:16:49,300
Looks solid.

3259
03:16:51,100 --> 03:16:55,200
The negation operator, we had to implement manually, but that looks

3260
03:16:55,200 --> 03:16:56,100
reasonably, right?

3261
03:16:56,100 --> 03:16:59,500
If we want to negate something we can simply subtract it from zero,

3262
03:16:59,900 --> 03:17:01,800
and that will produce the negative value.

3263
03:17:02,900 --> 03:17:04,000
So that seems fine.

3264
03:17:05,800 --> 03:17:10,500
The multiplication operator on V3, s is just the multiplication

3265
03:17:10,500 --> 03:17:14,200
operator times, whatever the line value is there that seems

3266
03:17:14,200 --> 03:17:14,800
reasonable.

3267
03:17:16,200 --> 03:17:21,000
The operator star again the same

3268
03:17:23,800 --> 03:17:26,800
so, greater than is greater than

3269
03:17:31,500 --> 03:17:33,000
less than is less than

3270
03:17:34,800 --> 03:17:44,800
and, and is, and X, Y, and Z, XY & Z conditional assignment for you

3271
03:17:44,800 --> 03:17:46,000
32s.

3272
03:17:48,000 --> 03:17:49,800
Just uses the and not.

3273
03:17:51,100 --> 03:17:55,000
And the clamp 01 uses.

3274
03:17:55,000 --> 03:17:59,900
The Min and Max of the values of the maximum, whichever one of

3275
03:18:00,000 --> 03:18:04,000
Is higher and whichever one of these is lower.

3276
03:18:04,000 --> 03:18:05,800
That looks right too.

3277
03:18:07,200 --> 03:18:11,500
So most everything in there, looks the same to me.

3278
03:18:12,100 --> 03:18:18,100
So I'm not 100% sure why we're getting the difference and just to sort

3279
03:18:18,100 --> 03:18:20,100
of put some

3280
03:18:22,400 --> 03:18:24,100
There's the lane for version.

3281
03:18:28,600 --> 03:18:30,900
and if I go ahead and set the lane width,

3282
03:18:32,400 --> 03:18:32,800
Oops.

3283
03:18:36,000 --> 03:18:36,800
21.

3284
03:18:41,800 --> 03:18:48,200
I should now be able to run this and yeah, and get

3285
03:18:52,500 --> 03:18:55,300
Get a respective version of what it looks like when it's running

3286
03:18:55,300 --> 03:18:59,700
scalar and I thought the scalar version returned the correct result.

3287
03:19:00,300 --> 03:19:03,100
If we're lucky, this scalar version, only looks like a train the

3288
03:19:03,100 --> 03:19:06,500
crocodile and they actually return the same results so that we're

3289
03:19:06,500 --> 03:19:11,800
actually wrong in both paths, but I think the scalar version return

3290
03:19:11,800 --> 03:19:12,400
the right result.

3291
03:19:12,400 --> 03:19:13,400
I can't quite remember

3292
03:19:36,500 --> 03:19:38,100
So, there we go.

3293
03:19:38,200 --> 03:19:43,300
Let's take a look now at the two images and so you can see the scalar

3294
03:19:43,300 --> 03:19:45,600
version is definitely correct.

3295
03:19:47,600 --> 03:19:48,400
and the

3296
03:19:52,700 --> 03:19:54,600
The sliced one is not.

3297
03:19:54,600 --> 03:19:57,100
So there's Lane 4 and this is Lane one.

3298
03:19:59,400 --> 03:20:03,500
So you can see that there's just when we switch between those, it just

3299
03:20:03,500 --> 03:20:08,600
looks like for some reason we're getting like, you know, honestly, the

3300
03:20:08,600 --> 03:20:11,500
most looks like the normal is like sheared or something.

3301
03:20:14,700 --> 03:20:17,600
I'm not sure quite what to make of it.

3302
03:20:25,000 --> 03:20:27,100
It's pretty hard to guess.

3303
03:20:29,000 --> 03:20:30,900
Exactly what that is.

3304
03:20:37,800 --> 03:20:41,900
It just looks like maybe the scattering is not really doing much.

3305
03:20:46,700 --> 03:20:47,300
Maybe.

3306
03:20:52,400 --> 03:20:54,500
That's what I'm going to do here, just to see.

3307
03:20:54,500 --> 03:20:55,400
I'm just curious.

3308
03:20:57,100 --> 03:20:58,800
I want to see if my hunch is correct.

3309
03:21:00,200 --> 03:21:06,400
So I'm going to take a look at the scatter and, you know, the way the

3310
03:21:06,400 --> 03:21:12,600
scatter works right, is we take the scatter and we go from, you know I

3311
03:21:12,600 --> 03:21:16,500
got to say we picked a really unfortunate name for that because

3312
03:21:16,800 --> 03:21:21,200
scatter it really should be the other way around, instead of scatter.

3313
03:21:21,200 --> 03:21:24,200
It should have been called, it should have gone from.

3314
03:21:25,300 --> 03:21:28,600
If scatter was Zero, it should have gone from a pure bounce.

3315
03:21:28,600 --> 03:21:29,900
So these these two terms,

3316
03:21:30,000 --> 03:21:31,900
It should be inverted, right?

3317
03:21:32,300 --> 03:21:33,000
In my opinion.

3318
03:21:36,600 --> 03:21:38,900
And I kind of want to fix that, right?

3319
03:21:39,600 --> 03:21:41,600
We could call it something other than scatter.

3320
03:21:44,400 --> 03:21:45,900
So for example,

3321
03:21:49,300 --> 03:21:51,200
If zero is pure to fuse.

3322
03:21:53,100 --> 03:21:53,400
Right.

3323
03:21:53,400 --> 03:21:55,100
Like why did we do it that way?

3324
03:21:55,500 --> 03:21:56,800
Why is it called scatter?

3325
03:21:56,800 --> 03:21:57,800
Instead of specular?

3326
03:21:59,900 --> 03:22:01,500
I don't know, right?

3327
03:22:18,000 --> 03:22:19,600
Yeah, that's that's just I.

3328
03:22:19,600 --> 03:22:21,000
Yeah, I have no idea.

3329
03:22:24,700 --> 03:22:25,100
Okay.

3330
03:22:26,000 --> 03:22:29,800
So what I want to do here is say well, what would happen if we

3331
03:22:29,800 --> 03:22:34,500
forestall the specular values 21 anyway, right, is that what that

3332
03:22:34,500 --> 03:22:35,500
roughly looked like?

3333
03:22:35,600 --> 03:22:38,000
I mean, it doesn't seem like it because,

3334
03:22:44,100 --> 03:22:46,200
It doesn't seem like that's exactly what happened.

3335
03:22:47,400 --> 03:22:47,700
Right?

3336
03:22:47,700 --> 03:22:49,800
Because some of these things aren't reflective.

3337
03:22:49,800 --> 03:22:53,600
Like that doesn't look reflective, but it definitely looks like these

3338
03:22:53,600 --> 03:22:55,800
things are getting more reflective, right?

3339
03:23:06,400 --> 03:23:09,000
and I guess the other thing though, too, is, they're getting

3340
03:23:09,000 --> 03:23:11,200
reflected, but they're also getting shifted a little

3341
03:23:12,200 --> 03:23:12,900
Right?

3342
03:23:13,000 --> 03:23:15,600
Like so I want to see what the difference is there.

3343
03:23:15,600 --> 03:23:16,700
Let me, let me just see.

3344
03:23:17,300 --> 03:23:20,800
So when the mat specular comes back, what I want to do here is I'm

3345
03:23:20,800 --> 03:23:26,300
going to go into re dot CPP, and I want to go ahead and take a look.

3346
03:23:28,600 --> 03:23:32,900
In the materials, if I was to just set a bunch of these artificially

3347
03:23:33,600 --> 03:23:36,700
to be more scattery, right?

3348
03:23:37,500 --> 03:23:39,800
So our more specular, right?

3349
03:23:39,800 --> 03:23:42,000
So if I just set these up quite a bit,

3350
03:23:49,200 --> 03:23:52,600
so let's say, I just set everything to be real reflective, right?

3351
03:23:52,600 --> 03:23:55,300
And maybe that's a little too high, you know?

3352
03:23:55,300 --> 03:23:59,800
Maybe it shouldn't be one, but I'm just curious what I get out.

3353
03:24:00,900 --> 03:24:04,700
And again, this is here, I'm running the actual, the scalar version.

3354
03:24:04,700 --> 03:24:07,500
So this is the one that we believe to be correct.

3355
03:24:09,200 --> 03:24:14,900
For our purposes and you know we don't actually know if it's all that

3356
03:24:14,900 --> 03:24:15,100
correct.

3357
03:24:15,100 --> 03:24:17,000
I mean there could have been bugs the original, but we know this is at

3358
03:24:17,000 --> 03:24:19,500
least producing the same results as what we were getting before.

3359
03:24:20,200 --> 03:24:22,800
And so we'd like to get the other one producing these results and I

3360
03:24:22,800 --> 03:24:26,500
want to see what it thinks a more specular version looks like again

3361
03:24:26,500 --> 03:24:29,900
just trying to get a feel for what the bug might be in this case.

3362
03:24:30,700 --> 03:24:33,500
And so let's just go ahead and let that do its thing.

3363
03:24:38,900 --> 03:24:39,900
What's the kind of curious?

3364
03:24:42,500 --> 03:24:43,700
How much CPU usage?

3365
03:24:43,700 --> 03:24:45,600
Do we end up using?

3366
03:24:51,800 --> 03:24:54,300
So that's what we want to see, right?

3367
03:24:54,400 --> 03:24:56,600
Like we want to see our CPU, usage.

3368
03:24:56,600 --> 03:24:57,300
Maxed

3369
03:24:58,400 --> 03:25:03,100
So that's kind of nice and, you know, it doesn't mean we're doing a

3370
03:25:03,100 --> 03:25:05,700
good job, we might be wasting a lot of the Cycles, which of course we

3371
03:25:05,700 --> 03:25:09,400
are for not using 70 for example, but at least we know we're not

3372
03:25:09,400 --> 03:25:11,300
leaving anything in machine idle.

3373
03:25:12,400 --> 03:25:14,300
So let's take a look at what that looks like.

3374
03:25:14,500 --> 03:25:16,400
So here's that bitmap, right?

3375
03:25:18,900 --> 03:25:22,200
And yeah, I think you can really see that.

3376
03:25:22,200 --> 03:25:25,900
It's definitely skewing, right?

3377
03:25:25,900 --> 03:25:29,200
It's not, it's not just specular.

3378
03:25:29,800 --> 03:25:30,700
It's skewing.

3379
03:25:30,700 --> 03:25:35,500
So, I wonder if that just means our bounce computation is borked right

3380
03:25:35,500 --> 03:25:41,800
in some way because the specular, the specular does not shift like

3381
03:25:41,800 --> 03:25:42,100
that.

3382
03:25:42,100 --> 03:25:43,800
It just makes it clearer.

3383
03:25:47,800 --> 03:25:50,200
So that's good information for us, right?

3384
03:25:53,300 --> 03:26:00,200
I alright, so that tells me that I kind of want to take a look at how

3385
03:26:00,200 --> 03:26:02,000
that Loops at how

3386
03:26:05,500 --> 03:26:09,100
that bounce computation is is being done.

3387
03:26:09,800 --> 03:26:14,100
So you can see here, we've got the random by lateral stuff happening

3388
03:26:14,100 --> 03:26:14,300
here.

3389
03:26:14,300 --> 03:26:19,300
That we then convert to Elaine V3, where we take the next normal, and

3390
03:26:19,300 --> 03:26:22,500
we add it and we normalize it.

3391
03:26:22,500 --> 03:26:27,600
So, what I want to know here is are these random bilaterals being

3392
03:26:27,600 --> 03:26:28,800
computed properly.

3393
03:26:28,800 --> 03:26:33,300
A are the

3394
03:26:35,800 --> 03:26:40,600
are there is the normalizer 0 actually working properly be and then

3395
03:26:40,600 --> 03:26:43,200
the lerp is also

3396
03:26:45,900 --> 03:26:51,400
Suspect in this case, right because both lerp random.

3397
03:26:51,400 --> 03:26:55,100
Bilateral, and normalizer zero are not very heavily.

3398
03:26:55,100 --> 03:26:58,300
Used solar power, for example is used nowhere else.

3399
03:26:58,600 --> 03:26:59,800
Right random

3400
03:27:00,000 --> 03:27:04,500
Lateral is used only in one other place, which is in a place that we

3401
03:27:04,500 --> 03:27:07,500
wouldn't notice Badness in it very much.

3402
03:27:08,600 --> 03:27:11,600
Especially, because remember, that's just picking off sets within a

3403
03:27:11,600 --> 03:27:12,200
pixel.

3404
03:27:12,800 --> 03:27:15,800
And then normalizer 0 is only used in the startup code in the

3405
03:27:15,800 --> 03:27:16,600
redirection.

3406
03:27:16,900 --> 03:27:19,400
And to be fair, I think in the right direction, it wouldn't even

3407
03:27:19,400 --> 03:27:21,800
really matter very much in a lot of cases.

3408
03:27:24,400 --> 03:27:28,200
So we definitely are dealing with some highly suspect code there.

3409
03:27:28,900 --> 03:27:32,100
We want to verify each of these pieces of code.

3410
03:27:32,500 --> 03:27:36,300
Let's take a look at what they're doing so we can maybe get a better

3411
03:27:36,300 --> 03:27:38,500
feel for what's happening in them, right?

3412
03:27:38,600 --> 03:27:41,900
So I'm going to take a look at where lerp exists and one of the.

3413
03:27:42,100 --> 03:27:44,800
Again, one of the things here is that because lerp exist in multiple

3414
03:27:44,800 --> 03:27:50,000
places that's also a bit of a warning sign, in this case, I think,

3415
03:27:52,000 --> 03:27:55,900
Because it's it's also making me a little bit worried that maybe like

3416
03:27:55,900 --> 03:27:59,500
the scalar version since it doesn't have to use this particular

3417
03:27:59,500 --> 03:28:00,400
version of it.

3418
03:28:01,000 --> 03:28:05,000
Maybe this particular version of it is just kind of busted, right?

3419
03:28:05,700 --> 03:28:09,900
So in this case we're doing a 1 point 0 minus t times a plus T times

3420
03:28:09,900 --> 03:28:10,100
B.

3421
03:28:10,100 --> 03:28:14,100
That's the standard lerp that you would normally expect to see.

3422
03:28:14,600 --> 03:28:16,800
Let's just find out what that does.

3423
03:28:16,800 --> 03:28:17,100
Right?

3424
03:28:17,100 --> 03:28:19,700
Let's go take a look at what that does.

3425
03:28:20,700 --> 03:28:21,200
In this case.

3426
03:28:22,100 --> 03:28:25,900
So, let's go ahead and return ourselves to a lane width.

3427
03:28:28,000 --> 03:28:28,400
Oops.

3428
03:28:30,000 --> 03:28:40,100
A for and let's go ahead and take off the 02 and we'll put the core

3429
03:28:40,100 --> 03:28:42,300
count back to one.

3430
03:28:47,900 --> 03:28:52,400
Okay, so now I'm going to go ahead and take a look at that lerp

3431
03:28:52,400 --> 03:28:52,900
function.

3432
03:28:52,900 --> 03:28:56,400
I'm going to run to the lerp function in here, it is.

3433
03:28:57,100 --> 03:28:59,700
So I've got an a vector and a b Vector.

3434
03:29:00,800 --> 03:29:05,200
These two vectors are wide, right?

3435
03:29:07,000 --> 03:29:10,400
So they have four elements each and you know, maybe we can.

3436
03:29:10,800 --> 03:29:11,200
Oops.

3437
03:29:12,800 --> 03:29:14,200
maybe we can kind of get

3438
03:29:15,300 --> 03:29:16,600
a little more space in here.

3439
03:29:18,000 --> 03:29:18,900
Actually see these.

3440
03:29:19,900 --> 03:29:25,400
So you can see here that I've got four different values in my X, and

3441
03:29:25,400 --> 03:29:26,700
my Y in my Z.

3442
03:29:26,700 --> 03:29:32,000
Each of these is a different vowel, is a different normal Direction.

3443
03:29:33,600 --> 03:29:36,300
And so I've got two different possible answers.

3444
03:29:36,300 --> 03:29:39,500
One of these represents the bounce, one of these represents the

3445
03:29:39,500 --> 03:29:40,200
scatter.

3446
03:29:41,100 --> 03:29:44,700
And so, what I want to do here is say all right, I want to do 1, minus

3447
03:29:44,700 --> 03:29:47,200
ta + TB,

3448
03:29:47,600 --> 03:29:49,800
Let's step into the parts of that separately.

3449
03:29:52,800 --> 03:29:56,600
So here is the first operator times, it's going to be a times b.

3450
03:29:57,200 --> 03:29:59,800
A in this case, if we come back out, I think we're doing this.

3451
03:30:00,000 --> 03:30:01,000
Part right here.

3452
03:30:01,600 --> 03:30:06,100
So the T value, if we look at what T actually is T is just 0

3453
03:30:06,100 --> 03:30:09,400
everywhere so we should get none of be at, all right?

3454
03:30:09,400 --> 03:30:14,500
It should just be a, in fact, we can just quickly verify that is true.

3455
03:30:14,800 --> 03:30:19,800
So in this case, the result should just, it should be equivalent to a

3456
03:30:19,800 --> 03:30:20,500
exactly.

3457
03:30:20,500 --> 03:30:22,100
And if it's not, we've got an issue.

3458
03:30:24,300 --> 03:30:24,900
So, there we go.

3459
03:30:24,900 --> 03:30:26,200
That's exactly right.

3460
03:30:26,900 --> 03:30:28,800
No problem there, right.

3461
03:30:29,000 --> 03:30:32,500
Let's take a look again and see if we can get another T value in here.

3462
03:30:32,500 --> 03:30:36,900
Let's see if we can find a t-value where the T value is equal to

3463
03:30:36,900 --> 03:30:37,800
something else.

3464
03:30:43,500 --> 03:30:44,600
Not doing great.

3465
03:30:46,800 --> 03:30:47,900
It's run for a little while.

3466
03:30:51,900 --> 03:30:52,800
And stop again.

3467
03:30:53,700 --> 03:30:54,700
Run for a while.

3468
03:31:10,000 --> 03:31:13,700
So anytime the scatter value I'm sorry the specular value is 0, it's

3469
03:31:13,700 --> 03:31:15,300
going to be at equal zero there.

3470
03:31:15,300 --> 03:31:20,100
So it's going to take us a while to get to something that we actually

3471
03:31:20,100 --> 03:31:21,000
want to see.

3472
03:31:23,600 --> 03:31:26,500
You probably be doing this with something less than 1024 race per

3473
03:31:26,500 --> 03:31:31,800
pixel if I was smart, but apparently I'm not.

3474
03:31:42,200 --> 03:31:43,000
Let's try that.

3475
03:31:48,700 --> 03:31:49,000
Oops.

3476
03:31:53,900 --> 03:31:57,900
That's just going to do one bundle, right?

3477
03:31:59,600 --> 03:32:00,600
So let's stop here.

3478
03:32:01,000 --> 03:32:03,800
Hopefully we can eventually get a t value to something else.

3479
03:32:09,800 --> 03:32:10,300
There we go.

3480
03:32:11,100 --> 03:32:13,700
So with the T value of one, that's another good test value.

3481
03:32:14,400 --> 03:32:18,500
That is exactly what we would want to see for result to equal.

3482
03:32:18,500 --> 03:32:22,000
Be precisely so let's make sure that that works.

3483
03:32:22,000 --> 03:32:27,800
Okay 5 -1 + 4 so that looks relatively convincing to be honest.

3484
03:32:28,200 --> 03:32:30,600
So that doesn't seem like particularly suspect to me.

3485
03:32:30,600 --> 03:32:37,700
Both the min/max worked properly so I'm not so sure there's anything

3486
03:32:37,700 --> 03:32:39,400
going on wrong there.

3487
03:32:40,100 --> 03:32:41,100
Which is too bad.

3488
03:32:42,100 --> 03:32:44,100
Anyway, the redirection itself.

3489
03:32:44,100 --> 03:32:46,700
Let's see how we do in terms of normalizing.

3490
03:32:46,700 --> 03:32:47,300
That's

3491
03:32:52,000 --> 03:32:53,900
doesn't look too bad.

3492
03:32:56,900 --> 03:32:58,700
You know, we can spot check some of these

3493
03:33:00,100 --> 03:33:06,900
So if we were to take say, you know, point four times two point four

3494
03:33:06,900 --> 03:33:13,900
plus 0.9 times point nine plus 0.05 times 0.05 we do get something

3495
03:33:13,900 --> 03:33:15,000
very close to 1.

3496
03:33:15,000 --> 03:33:17,800
So the normalized version of this seems good and plus that's actually

3497
03:33:17,800 --> 03:33:25,400
point six and so I assume that if that was actually being done to full

3498
03:33:25,400 --> 03:33:26,000
Precision.

3499
03:33:26,000 --> 03:33:26,400
Yeah.

3500
03:33:27,000 --> 03:33:29,900
So those look like they are plausibly.

3501
03:33:30,000 --> 03:33:31,700
Normalized values.

3502
03:33:33,600 --> 03:33:37,200
You know, I could believe that, right?

3503
03:33:37,900 --> 03:33:41,100
So the other question here is well random bilateral, you know what's

3504
03:33:41,100 --> 03:33:42,300
going on in there.

3505
03:33:43,000 --> 03:33:44,200
I'm not really sure.

3506
03:33:48,500 --> 03:33:49,800
Let's step into this.

3507
03:33:51,900 --> 03:33:56,500
And see, here's our X or shift.

3508
03:33:57,300 --> 03:34:00,400
So we come through here and we get out one of these X values.

3509
03:34:00,400 --> 03:34:01,800
There's our x value.

3510
03:34:02,800 --> 03:34:04,800
Let's actually grab out the part.

3511
03:34:04,800 --> 03:34:07,300
We care about which is x dot V.

3512
03:34:07,300 --> 03:34:12,600
Dot M 128 I underscore u-32 really easy to remember.

3513
03:34:14,300 --> 03:34:18,000
And here's what those values actually look like those look like what

3514
03:34:18,000 --> 03:34:21,000
we want which is a bunch of random bits.

3515
03:34:21,900 --> 03:34:24,000
And we're going to shuffle them around here.

3516
03:34:24,200 --> 03:34:30,800
There's our Shuffle and now we return to our regularly scheduled

3517
03:34:30,800 --> 03:34:31,300
program.

3518
03:34:31,300 --> 03:34:34,200
So that seems like a reasonable job.

3519
03:34:34,700 --> 03:34:39,500
When we actually do one of these, we divide by the you 32, Max there.

3520
03:34:39,900 --> 03:34:40,600
So,

3521
03:34:45,600 --> 03:34:46,700
Wait, what?

3522
03:34:48,400 --> 03:34:48,600
Oh no.

3523
03:34:48,600 --> 03:34:49,400
But that's enough 32.

3524
03:34:49,400 --> 03:34:50,200
So that's correct.

3525
03:34:50,700 --> 03:34:54,400
So we had Lain 32 from you through to the converts up.

3526
03:34:54,400 --> 03:34:55,300
Both of those

3527
03:34:57,900 --> 03:34:59,000
So that's all good.

3528
03:35:01,300 --> 03:35:07,400
Our convert Epi PS should produce, basically floating Point values

3529
03:35:08,000 --> 03:35:09,800
that look like these values, right?

3530
03:35:09,800 --> 03:35:13,000
That are the same, roughly, the same.

3531
03:35:24,400 --> 03:35:28,200
so the fact that these are all exactly the same scale,

3532
03:35:36,500 --> 03:35:38,000
Seems bad.

3533
03:35:47,200 --> 03:35:52,300
Mmm-hmm, I didn't want this to be opened.

3534
03:35:52,600 --> 03:35:55,500
Nope, don't don't do that.

3535
03:35:56,500 --> 03:35:59,800
So that seems a bit odd to

3536
03:36:00,300 --> 03:36:02,700
So, here's our A.V.

3537
03:36:05,400 --> 03:36:06,900
Here are those values.

3538
03:36:08,400 --> 03:36:11,200
Here's what they actually are, right?

3539
03:36:14,200 --> 03:36:17,500
And now, if I look at the result, that the

3540
03:36:22,500 --> 03:36:25,200
And we look at what those are as F 32s.

3541
03:36:27,500 --> 03:36:30,600
That just isn't right.

3542
03:36:49,500 --> 03:36:52,600
Oh, crud poopies.

3543
03:36:54,200 --> 03:36:55,900
I know what's going on here.

3544
03:36:57,900 --> 03:37:02,500
So this is because there is no way to load a u-32.

3545
03:37:02,600 --> 03:37:06,700
It only loads signed values.

3546
03:37:07,400 --> 03:37:11,800
So, it's thinking that these values are signed and the hi B happen to

3547
03:37:11,800 --> 03:37:13,300
be set on some of them.

3548
03:37:13,300 --> 03:37:14,000
So there's slight.

3549
03:37:14,000 --> 03:37:14,500
Yeah.

3550
03:37:16,800 --> 03:37:17,900
Is that what it's doing?

3551
03:37:17,900 --> 03:37:19,600
I think that's what it's doing here.

3552
03:37:20,600 --> 03:37:25,400
So this is really not what we wanted.

3553
03:37:28,400 --> 03:37:36,300
So in the lane F32 functions here, we do lean F32 from u-32.

3554
03:37:36,300 --> 03:37:39,100
So anywhere we're doing a CVT Pi.

3555
03:37:41,900 --> 03:37:45,900
We need it to think this is an integer, I guess is the way I would put

3556
03:37:45,900 --> 03:37:48,000
it, right?

3557
03:37:49,100 --> 03:37:50,100
And

3558
03:37:51,100 --> 03:37:53,400
so when it loaded that in,

3559
03:37:56,100 --> 03:37:57,300
It loaded it.

3560
03:38:00,000 --> 03:38:02,900
It would be loading it incorrectly.

3561
03:38:11,400 --> 03:38:14,300
So, I'm not really sure what to do about that.

3562
03:38:16,300 --> 03:38:20,100
I guess we need like, is this all we really need to do so.

3563
03:38:20,200 --> 03:38:24,200
So if I were to just do pretend this as an integer,

3564
03:38:28,300 --> 03:38:29,800
Would that be sufficient?

3565
03:38:33,700 --> 03:38:34,400
Not sure.

3566
03:38:44,100 --> 03:38:45,500
So I want to take a look at this here.

3567
03:38:46,600 --> 03:38:51,200
So, when I call into random unilateral, I want to know, like, what my

3568
03:38:51,200 --> 03:38:54,100
result values are going to be now, are they going to be better?

3569
03:38:56,000 --> 03:38:57,200
yeah, that looks

3570
03:38:59,400 --> 03:38:59,800
Much better.

3571
03:39:00,000 --> 03:39:02,400
All right, all right, all right, all right.

3572
03:39:02,900 --> 03:39:05,500
So I think what was happening there is like when we were trying to

3573
03:39:05,500 --> 03:39:07,600
load up, say you 32 Max

3574
03:39:10,600 --> 03:39:13,900
Or I should say when we were trying to load up the x or shift values

3575
03:39:14,800 --> 03:39:15,900
originally?

3576
03:39:16,900 --> 03:39:18,400
Well no, that's not right either.

3577
03:39:19,000 --> 03:39:19,800
Okay, wait a minute.

3578
03:39:20,400 --> 03:39:22,000
I'm getting too far ahead of myself.

3579
03:39:22,400 --> 03:39:23,600
Let's bring this back.

3580
03:39:24,200 --> 03:39:24,700
There we go.

3581
03:39:27,900 --> 03:39:29,300
And I want to take a look at this function.

3582
03:39:36,400 --> 03:39:37,400
So it looks like that.

3583
03:39:37,400 --> 03:39:39,100
So I may have misspoke there.

3584
03:39:39,700 --> 03:39:41,900
That's actually not going to be a problem because it looks like we'd

3585
03:39:41,900 --> 03:39:42,800
already loaded those in.

3586
03:39:42,800 --> 03:39:45,800
So we were always even though we were converting, it wouldn't matter

3587
03:39:46,100 --> 03:39:49,900
presumably because it would treat it as a negative number.

3588
03:39:50,000 --> 03:39:50,700
Anyway.

3589
03:39:51,300 --> 03:39:52,400
Presumably

3590
03:39:56,200 --> 03:39:57,400
I may still be right.

3591
03:39:57,400 --> 03:39:58,300
I may still be right.

3592
03:39:58,300 --> 03:39:59,200
I'll complain why.

3593
03:39:59,200 --> 03:40:02,400
I think I might be right in the future, but let's just double check

3594
03:40:02,400 --> 03:40:02,700
here.

3595
03:40:06,400 --> 03:40:09,600
Do you see how this is never able to produce a value?

3596
03:40:11,200 --> 03:40:14,600
Like, let's just verify that, I'm right if I'm right about what's

3597
03:40:14,600 --> 03:40:15,200
happening.

3598
03:40:23,500 --> 03:40:27,600
Then this will never random unilateral will never be able to produce a

3599
03:40:27,600 --> 03:40:28,300
value.

3600
03:40:29,700 --> 03:40:30,700
That is

3601
03:40:31,900 --> 03:40:35,000
Greater than 0.5 ish.

3602
03:40:35,000 --> 03:40:37,500
Let's say 0.6 just to be safe, right?

3603
03:40:38,200 --> 03:40:43,500
So if I were to say result dot V Dot Oh Heaven, Help Us, what is that

3604
03:40:43,500 --> 03:40:44,200
ridiculous?

3605
03:40:44,700 --> 03:40:45,800
Well, you know what here?

3606
03:40:51,200 --> 03:40:53,500
So assert that that floating point value.

3607
03:40:55,900 --> 03:40:57,900
Is less than 0.6 F.

3608
03:40:57,900 --> 03:41:03,900
Let's say if I'm right, we're probably not able to produce values

3609
03:41:03,900 --> 03:41:04,800
higher than that.

3610
03:41:06,400 --> 03:41:07,100
And hey guess what?

3611
03:41:07,100 --> 03:41:07,600
I'm right.

3612
03:41:08,800 --> 03:41:13,900
So what I think is happening here is we are loading in a u-32 Max

3613
03:41:15,200 --> 03:41:16,500
As a floating Point number.

3614
03:41:17,500 --> 03:41:21,400
But when we're loading in these X or shift values, it's thinking of

3615
03:41:21,400 --> 03:41:23,300
them as signed values.

3616
03:41:23,500 --> 03:41:28,800
So when it's converting from the signed value to the F32, it's only

3617
03:41:28,800 --> 03:41:34,000
ever going to be able to produce a short range of negative to positive

3618
03:41:34,000 --> 03:41:37,000
which is like negative point five, two point five or something.

3619
03:41:38,200 --> 03:41:42,600
Or all the negative numbers because the high positive numbers will be

3620
03:41:42,600 --> 03:41:45,000
converted to negative numbers, right?

3621
03:41:45,900 --> 03:41:49,600
So what I really need this thing to do is I need this thing to load

3622
03:41:49,600 --> 03:41:55,600
the floating Point values as unsigned values, right?

3623
03:41:55,600 --> 03:41:59,400
And I don't know if there's a CPU, like what I need?

3624
03:41:59,400 --> 03:41:59,800
There is a

3625
03:42:00,000 --> 03:42:05,200
Vert epu and I don't know if we actually have that.

3626
03:42:13,200 --> 03:42:14,400
We don't.

3627
03:42:15,400 --> 03:42:21,400
So we can do multiplication of unsigned values.

3628
03:42:21,500 --> 03:42:24,200
We can do ads of unsigned values.

3629
03:42:25,200 --> 03:42:33,700
But we cannot unfortunately do a convert of unsigned values, until it

3630
03:42:33,700 --> 03:42:35,700
looks like we can.

3631
03:42:36,300 --> 03:42:38,900
Well, no, we can never be, can never really do that.

3632
03:42:51,600 --> 03:42:56,500
Right, so that's just unfortunately not on the table.

3633
03:43:02,900 --> 03:43:04,000
That's what I say about that.

3634
03:43:05,600 --> 03:43:06,900
So we have a problem.

3635
03:43:12,600 --> 03:43:13,700
And that is our problem.

3636
03:43:16,600 --> 03:43:17,800
And how we fix that problem?

3637
03:43:17,800 --> 03:43:18,200
I don't know.

3638
03:43:19,700 --> 03:43:20,500
We

3639
03:43:23,600 --> 03:43:25,400
have these extra shift values.

3640
03:43:25,600 --> 03:43:29,900
They're going to be values that range from 0 to 0xffff, right?

3641
03:43:31,400 --> 03:43:36,100
And we want to divide them in floating Point by ffffff as well.

3642
03:43:37,800 --> 03:43:42,200
It seems like the sanest thing to do at this point is shift off the

3643
03:43:42,200 --> 03:43:43,900
sign bit of both of them.

3644
03:43:45,900 --> 03:43:48,900
Because if I shift off the sign bit of both of them, then we don't

3645
03:43:48,900 --> 03:43:49,300
care.

3646
03:43:50,900 --> 03:43:54,600
Since I have no idea what else to do, that seems like the easiest

3647
03:43:54,600 --> 03:43:56,300
thing to do and shift off.

3648
03:43:56,300 --> 03:43:57,900
I never did what I could and off

3649
03:43:59,100 --> 03:44:02,500
Wright could do either of those two things.

3650
03:44:03,700 --> 03:44:06,000
That seems like the smartest thing to do.

3651
03:44:07,000 --> 03:44:10,700
So for example, let's suppose that I just said well I'm going to shift

3652
03:44:10,700 --> 03:44:16,800
down the you 32 Max by one and then in here where I do my ex or shift

3653
03:44:17,200 --> 03:44:19,600
I'm going to take that value before.

3654
03:44:19,600 --> 03:44:23,100
I actually try to convert it and shift that down by one as well.

3655
03:44:23,900 --> 03:44:25,400
Clearing out the top bit.

3656
03:44:27,500 --> 03:44:28,700
And crossing my fingers.

3657
03:44:29,400 --> 03:44:32,700
Now, if I run it, I should get an assertion almost immediate and I do.

3658
03:44:34,700 --> 03:44:39,900
So now we've corrected that bias that was in that part of the code and

3659
03:44:39,900 --> 03:44:46,900
hopefully now we could actually run this and get you know, a

3660
03:44:46,900 --> 03:44:48,100
reasonable result.

3661
03:44:48,300 --> 03:44:51,300
Now why it's running this fast with only one core?

3662
03:44:51,300 --> 03:44:53,500
I don't know but I guess.

3663
03:44:53,500 --> 03:44:53,800
Yeah.

3664
03:44:53,800 --> 03:44:54,400
Well anyway,

3665
03:44:58,600 --> 03:44:59,800
So, let's see what we ended up.

3666
03:45:01,300 --> 03:45:04,500
Here's our test bitmap oh right because we set, that's right.

3667
03:45:04,500 --> 03:45:08,100
We set the ray count down a lot and that's already looking a lot

3668
03:45:08,100 --> 03:45:08,500
better.

3669
03:45:08,500 --> 03:45:12,000
So let's go ahead and now return to our regularly scheduled program

3670
03:45:24,900 --> 03:45:26,500
That was a tricky bug, right?

3671
03:45:26,500 --> 03:45:29,300
That was, you know, you kind of had to be pretty Eagle Eye to find

3672
03:45:29,300 --> 03:45:29,600
that one.

3673
03:45:29,600 --> 03:45:34,100
I gotta say and it's because it was coming from an entropic Source,

3674
03:45:34,100 --> 03:45:37,300
it's hard to test, right?

3675
03:45:37,700 --> 03:45:40,000
So the only way you could really find that.

3676
03:45:40,000 --> 03:45:42,300
So, let's say you had done the unit testing route, like are saying you

3677
03:45:42,300 --> 03:45:44,800
would need to have the unit test verify that it returns.

3678
03:45:44,800 --> 03:45:46,300
Good distributions on either side.

3679
03:45:46,300 --> 03:45:48,100
So you need a really strong unit test.

3680
03:45:48,100 --> 03:45:51,200
Do you couldn't you couldn't cheese that one out because it came from

3681
03:45:51,200 --> 03:45:54,200
the entropic source which is the harder thing to test because it's in

3682
03:45:54,400 --> 03:45:56,500
Bu knows what supposed to return, right?

3683
03:45:58,000 --> 03:45:58,900
But yeah.

3684
03:45:58,900 --> 03:46:03,300
So there that's you know, if we had done the thing, where we compare

3685
03:46:03,300 --> 03:46:05,600
it against the scalar version, which I think would have been a good

3686
03:46:05,600 --> 03:46:07,500
thing to do as well, we would have found it.

3687
03:46:07,500 --> 03:46:09,700
So that would have been a test that could have found that one as well.

3688
03:46:10,300 --> 03:46:13,400
Of course, I found it by hand which is also a good way to find things.

3689
03:46:14,000 --> 03:46:16,500
Assuming you find them quick enough which in this case we did.

3690
03:46:17,500 --> 03:46:17,800
Alright?

3691
03:46:17,800 --> 03:46:20,900
So let's go ahead and see what image we produce if we run for real.

3692
03:46:20,900 --> 03:46:23,200
Now, with the full thing

3693
03:46:32,000 --> 03:46:32,400
Oops.

3694
03:46:35,600 --> 03:46:41,100
So Off to the Races for doing our little rate off, to the ray, says

3695
03:46:42,400 --> 03:46:42,900
right.

3696
03:46:43,100 --> 03:46:44,800
Well pump, well pump for you there.

3697
03:46:46,200 --> 03:46:48,200
So let's see what we get now.

3698
03:46:48,200 --> 03:46:49,200
How do we get an image?

3699
03:46:49,200 --> 03:46:50,000
That's more?

3700
03:46:50,000 --> 03:46:50,600
Sane.

3701
03:46:50,900 --> 03:46:51,300
I don't know.

3702
03:46:51,300 --> 03:46:55,900
Let's find out, so that looks real good, right?

3703
03:46:56,400 --> 03:47:01,700
So now, if we compare say this and this together,

3704
03:47:02,800 --> 03:47:04,400
Go ahead and open both of those.

3705
03:47:04,400 --> 03:47:05,200
There's one.

3706
03:47:05,200 --> 03:47:06,000
There's the other

3707
03:47:08,800 --> 03:47:10,600
I do too.

3708
03:47:15,700 --> 03:47:18,900
Those look pretty much indistinguishable to me.

3709
03:47:25,000 --> 03:47:27,700
All right, all right.

3710
03:47:27,700 --> 03:47:30,600
So I think then we can kind of get rid of these other images that we

3711
03:47:30,600 --> 03:47:31,300
had in here.

3712
03:47:34,600 --> 03:47:35,900
And just slip between these two.

3713
03:47:44,200 --> 03:47:47,500
And those look really similar to me again.

3714
03:47:47,500 --> 03:47:50,700
They're not going to be exact because they're getting computed,

3715
03:47:50,700 --> 03:47:55,000
actually in slightly different ways, but they're pretty close.

3716
03:48:17,700 --> 03:48:22,000
So that's pretty good and we managed to get our speed up a little bit.

3717
03:48:22,000 --> 03:48:26,600
But I think our speed compared to what I think we would want it to be

3718
03:48:26,600 --> 03:48:34,800
is still not great and so it seems like maybe we aren't doing as well

3719
03:48:34,800 --> 03:48:36,200
as we should be doing.

3720
03:48:37,200 --> 03:48:41,900
There's probably still we probably did some things that aren't great

3721
03:48:42,000 --> 03:48:44,800
and they might have to do with say for example this way we're doing

3722
03:48:44,800 --> 03:48:46,500
The Gather here, we may have to improve that

3723
03:48:47,800 --> 03:48:49,800
I there's a bunch of things we have to do.

3724
03:48:50,000 --> 03:48:52,900
I'm going to set a breakpoint on this, I want to know if we ever

3725
03:48:52,900 --> 03:48:55,000
actually hit this break.

3726
03:48:57,600 --> 03:48:59,700
I going to have to compile and debug mode to do it because the

3727
03:48:59,700 --> 03:49:03,800
optimized version is probably going to move stuff around so much that

3728
03:49:03,800 --> 03:49:05,400
we would be able to really Target exactly.

3729
03:49:05,700 --> 03:49:10,200
But I'm curious to know whether we ever actually zero out, Escape out

3730
03:49:10,200 --> 03:49:10,800
properly.

3731
03:49:11,900 --> 03:49:13,000
It looks like we do.

3732
03:49:13,000 --> 03:49:15,100
So that's good news, right?

3733
03:49:15,200 --> 03:49:16,100
Yeah, okay.

3734
03:49:20,000 --> 03:49:25,700
So yeah, the last thing I want to do is try doing a significantly less

3735
03:49:25,700 --> 03:49:32,300
raise per pixel with this version, just to see what it what it

3736
03:49:32,300 --> 03:49:32,900
produces.

3737
03:49:34,700 --> 03:49:35,700
And here.

3738
03:49:35,700 --> 03:49:38,800
In this case, we can also save off this, this bitmap as our as our

3739
03:49:38,800 --> 03:49:40,400
final bitmap to for the day

3740
03:49:43,900 --> 03:49:44,400
Right.

3741
03:49:53,300 --> 03:49:53,900
It is day three.

3742
03:49:53,900 --> 03:49:54,500
Yeah.

3743
03:49:56,500 --> 03:49:59,500
So we can we can turn to get that finished up.

3744
03:50:00,800 --> 03:50:05,900
and yeah, I think

3745
03:50:08,100 --> 03:50:12,600
Well, I want to do was verify that if I drop the race per pixel down

3746
03:50:12,700 --> 03:50:15,600
to something lower, I should get a Greenie image.

3747
03:50:15,600 --> 03:50:21,700
I want to make sure we're not over counting here, you know because

3748
03:50:21,700 --> 03:50:22,800
that's a thing as well.

3749
03:50:25,600 --> 03:50:28,400
So that's still pretty smooth.

3750
03:50:28,500 --> 03:50:30,000
It's not as smooth.

3751
03:50:31,600 --> 03:50:32,600
Hold on a second.

3752
03:50:49,000 --> 03:50:55,800
so, it looks like, though we're doing the right thing, looks like,

3753
03:50:55,800 --> 03:50:56,700
looks like

3754
03:51:04,000 --> 03:51:08,100
Yeah, I just want to make sure we weren't accidentally overcasting,

3755
03:51:08,500 --> 03:51:11,200
but it looks like, you know, it's correct.

3756
03:51:11,900 --> 03:51:16,100
So we are actually casting the number of rays that we said we would

3757
03:51:24,600 --> 03:51:26,100
Yeah, okay.

3758
03:51:27,400 --> 03:51:33,600
So I guess now we should probably wrap it up because that concludes

3759
03:51:33,600 --> 03:51:38,400
the symbolization of this of this code.

3760
03:51:38,700 --> 03:51:43,800
And now we would have to start in on some harder work of figuring out

3761
03:51:43,800 --> 03:51:47,300
what slow about it and how we can make it less low.

3762
03:51:48,200 --> 03:51:48,600
Right.

3763
03:51:52,400 --> 03:51:57,500
And so that's, you know, going to be a lot of sort of tricky working

3764
03:51:57,500 --> 03:51:57,900
here.

3765
03:51:58,900 --> 03:52:03,700
I am curious to know how much of it is.

3766
03:52:05,000 --> 03:52:10,300
From the N way loading because that's some ugly stuff that's happening

3767
03:52:10,300 --> 03:52:13,400
right now and I don't know.

3768
03:52:16,600 --> 03:52:20,100
To what extent that is is downshifting us.

3769
03:52:21,400 --> 03:52:22,400
I'm kind of curious.

3770
03:52:22,400 --> 03:52:24,200
So I may just before we stop here,

3771
03:52:25,800 --> 03:52:29,700
I may go ahead and take a look at just what the disassembly looks

3772
03:52:29,700 --> 03:52:30,100
like.

3773
03:52:31,100 --> 03:52:34,700
So, I can see if it's saying or if there's some obviously, really

3774
03:52:34,700 --> 03:52:35,800
weird stuff happening.

3775
03:52:37,200 --> 03:52:38,100
Inside the loop.

3776
03:52:40,200 --> 03:52:44,200
So, let's go ahead and just go to disassembly here.

3777
03:52:49,300 --> 03:52:49,900
and,

3778
03:52:54,700 --> 03:52:56,500
Just looking around.

3779
03:53:06,800 --> 03:53:07,600
You know, all that stuff.

3780
03:53:07,600 --> 03:53:09,400
Looks pretty good, just moles and ads.

3781
03:53:34,200 --> 03:53:36,700
Here, we are with our bounce count.

3782
03:54:09,800 --> 03:54:11,700
Are these all look pretty saying, right?

3783
03:54:11,700 --> 03:54:17,100
I mean, they're just Loops through doing tests.

3784
03:54:50,000 --> 03:54:53,900
So this actually doesn't look too bad.

3785
03:54:57,700 --> 03:54:59,700
It's not great but it's not too bad.

3786
03:55:07,500 --> 03:55:09,300
So I guess I'll check one more thing.

3787
03:55:18,000 --> 03:55:18,900
What I kind of want to see.

3788
03:55:18,900 --> 03:55:23,400
Here is just a measure of the waist so since we have to track the lien

3789
03:55:23,400 --> 03:55:28,300
mask anyway what I'd like to do is in addition to bounces computed

3790
03:55:28,300 --> 03:55:28,700
here.

3791
03:55:29,100 --> 03:55:32,400
What I'd like to track is just how many of these Loops we did as well.

3792
03:55:33,000 --> 03:55:39,600
So bounces computed and like, I don't know what we would call this

3793
03:55:40,800 --> 03:55:41,300
Loops.

3794
03:55:41,300 --> 03:55:42,900
Computed something like this.

3795
03:55:44,700 --> 03:55:45,200
Right?

3796
03:55:46,000 --> 03:55:47,200
And we'll just increment.

3797
03:55:47,200 --> 03:55:47,600
Value?

3798
03:55:47,600 --> 03:55:49,800
Computed and Luke's complete computable.

3799
03:55:49,800 --> 03:55:50,400
Be computed.

3800
03:55:50,400 --> 03:55:51,800
Every million current, every time.

3801
03:55:51,800 --> 03:55:53,300
This one only be computed,

3802
03:55:57,400 --> 03:56:00,800
This one will only increment per Lane when we're actually doing work

3803
03:56:00,800 --> 03:56:01,600
on that lane.

3804
03:56:02,200 --> 03:56:05,900
So when we get to the end and we do bounces computed, we can also do

3805
03:56:05,900 --> 03:56:07,100
loops computed.

3806
03:56:08,100 --> 03:56:08,800
And

3807
03:56:09,900 --> 03:56:11,500
Some that in, right?

3808
03:56:12,200 --> 03:56:15,600
So in that bounces, computed value, that comes out.

3809
03:56:16,600 --> 03:56:17,400
Wait what?

3810
03:56:29,100 --> 03:56:30,000
Okay, never mind.

3811
03:56:30,700 --> 03:56:31,600
Yeah, that's fine.

3812
03:56:34,300 --> 03:56:37,000
When this value comes out, we'll take the loops, computed, and we'll

3813
03:56:37,000 --> 03:56:40,900
sort of AD will track that value with a locked increment as well,

3814
03:56:41,200 --> 03:56:41,700
right?

3815
03:56:42,200 --> 03:56:43,800
So our bats is computed,

3816
03:56:45,100 --> 03:56:51,100
Our Loops, computed Loops, computed will will track all that stuff.

3817
03:56:55,100 --> 03:56:55,700
Like so.

3818
03:56:56,400 --> 03:56:57,600
And then, at the end,

3819
03:57:01,200 --> 03:57:03,800
In all the places that we were using that, right?

3820
03:57:08,100 --> 03:57:09,400
That's is computed.

3821
03:57:12,800 --> 03:57:18,500
Where we do state Loops computed equals 0 and we add it here.

3822
03:57:19,400 --> 03:57:23,800
Then we get down to the bottom and we're going to print it out, will

3823
03:57:23,800 --> 03:57:26,200
say total bounces, right?

3824
03:57:29,200 --> 03:57:30,300
Total loops.

3825
03:57:32,400 --> 03:57:36,500
And that way, we know how many Loops we know how much wastage we had,

3826
03:57:36,500 --> 03:57:37,200
right.

3827
03:57:39,500 --> 03:57:40,100
so, like

3828
03:57:43,100 --> 03:57:45,500
Wasted bounces.

3829
03:57:45,800 --> 03:57:50,200
Something like this would be like LL U.

3830
03:57:51,500 --> 03:57:54,600
LL U % or something like that, right?

3831
03:57:55,800 --> 03:57:56,300
Or

3832
03:57:57,600 --> 03:58:01,600
2.0 or 0.02 F %, right?

3833
03:58:01,800 --> 03:58:03,500
And so then we can do, alright?

3834
03:58:03,700 --> 03:58:08,100
We know that we wasted out of the bounces.

3835
03:58:08,100 --> 03:58:14,700
This is how many we actually got or I guess we say wasted Lanes or

3836
03:58:14,700 --> 03:58:19,000
wasted compute, I don't know what to call this.

3837
03:58:22,300 --> 03:58:24,100
What is I'll leave it as that.

3838
03:58:24,600 --> 03:58:27,300
So we know we did this many bounces, but we know we did this many

3839
03:58:27,300 --> 03:58:28,800
Loops computed, right?

3840
03:58:31,200 --> 03:58:32,900
And that should be times the lane with.

3841
03:58:32,900 --> 03:58:36,900
So when we're incrementing the superior where we do Loop computed,

3842
03:58:36,900 --> 03:58:37,300
right?

3843
03:58:38,400 --> 03:58:42,500
This should be actually plus equals the full length with because

3844
03:58:42,500 --> 03:58:45,000
that's how many were actually doing, right?

3845
03:58:46,900 --> 03:58:52,300
And so once we get this value back, we know that in fact we could

3846
03:58:52,300 --> 03:58:58,200
compute this value here which is like wasted bounces we could do like

3847
03:58:58,200 --> 03:58:58,800
this.

3848
03:59:05,700 --> 03:59:07,400
We might even say it like this.

3849
03:59:07,800 --> 03:59:15,100
Here's what we say used bounces is this total bounces, is this wasted

3850
03:59:15,100 --> 03:59:21,800
bounces is this and the wasted bounces versus total bounces.

3851
03:59:23,900 --> 03:59:26,400
Is the value we're actually looking for here, right?

3852
03:59:27,300 --> 03:59:34,700
So 100.0, f, f 32 ft to just make a little percentage out of that,

3853
03:59:34,800 --> 03:59:35,400
right?

3854
03:59:36,600 --> 03:59:37,300
And off we go.

3855
03:59:39,400 --> 03:59:40,500
So that seems fine.

3856
03:59:42,400 --> 03:59:45,900
total bounces, we could rename these

3857
03:59:50,200 --> 03:59:51,600
used bounces.

3858
03:59:53,700 --> 03:59:55,000
Turtle bounces.

3859
04:00:03,200 --> 04:00:07,100
Those total - used.

3860
04:00:19,500 --> 04:00:24,800
And that should give us an idea of how much waste we actually have in

3861
04:00:24,800 --> 04:00:25,600
there, right?

3862
04:00:27,300 --> 04:00:30,300
And we can sort of go from there.

3863
04:00:36,100 --> 04:00:36,800
So, here we go.

3864
04:00:40,700 --> 04:00:41,600
Why am I doing it out there?

3865
04:00:41,700 --> 04:00:42,300
I have no idea.

3866
04:00:45,200 --> 04:00:48,200
So now hopefully this will track both values and this will give us an

3867
04:00:48,200 --> 04:00:50,200
idea of how much Cindy Lane utilisation.

3868
04:00:50,200 --> 04:00:53,300
We're actually getting, because one thing that could be happening is

3869
04:00:53,400 --> 04:00:57,000
maybe most of the time we end up having one, Ray that bounces in a

3870
04:00:57,000 --> 04:01:00,300
bunch of them that don't inside it, inside one wide thing.

3871
04:01:00,600 --> 04:01:03,300
And maybe that's why we're not getting speed up, but it looks like

3872
04:01:03,300 --> 04:01:04,500
that's not true, right?

3873
04:01:04,500 --> 04:01:06,400
We're only wasting 10% of our bounces.

3874
04:01:06,400 --> 04:01:07,800
That's just not very many.

3875
04:01:09,100 --> 04:01:17,400
So I'm not sure why we don't see more of a speed up when we go to when

3876
04:01:17,400 --> 04:01:18,200
we go to Cindy.

3877
04:01:18,800 --> 04:01:20,600
So something's wrong with that Loop.

3878
04:01:22,000 --> 04:01:23,500
I'm think I'm done for the day.

3879
04:01:23,500 --> 04:01:24,900
It's been a long episode already.

3880
04:01:27,700 --> 04:01:28,400
So I'm done for the day.

3881
04:01:28,400 --> 04:01:31,300
Looking at that will have to be an exercise for next time.

3882
04:01:32,500 --> 04:01:38,900
And Folks at home, who want to play around with it, can can do so as

3883
04:01:38,900 --> 04:01:42,700
well, so let me go ahead and go to a brief Q&A.

3884
04:02:31,700 --> 04:02:34,200
So all right, hold on a second here.

3885
04:02:37,600 --> 04:02:39,200
We have a bunch of queues.

3886
04:02:40,900 --> 04:02:44,900
So, first of all, some of us saying, didn't replace and equals with

3887
04:02:44,900 --> 04:02:45,800
the correct method.

3888
04:02:45,800 --> 04:02:49,100
Let's, let's go take a look there and equals

3889
04:02:51,200 --> 04:02:54,900
I assume that was old.

3890
04:02:55,900 --> 04:02:57,700
That's why old I think I already fixed that.

3891
04:03:03,900 --> 04:03:04,600
Is your peer?

3892
04:03:04,600 --> 04:03:05,700
Take it grew pretty fast.

3893
04:03:05,700 --> 04:03:06,900
No, it's a real beard.

3894
04:03:11,900 --> 04:03:12,200
Oh yeah.

3895
04:03:12,200 --> 04:03:14,800
Colombian suggested we rename the file properly.

3896
04:03:14,900 --> 04:03:15,700
That's right.

3897
04:03:15,900 --> 04:03:17,600
What is today 1119.

3898
04:03:38,100 --> 04:03:39,900
Pirates, have City for samples of, very smooth.

3899
04:03:39,900 --> 04:03:42,900
Could you compare 64 samples with 4y to 64 samples, one might they're

3900
04:03:42,900 --> 04:03:43,200
the same.

3901
04:03:43,200 --> 04:03:44,500
They still do 64 samples.

3902
04:03:44,500 --> 04:03:47,500
In either case because we divide the number of samples by the width.

3903
04:03:47,900 --> 04:03:53,700
So 64 samples, one wide or use talk about the speed.

3904
04:03:55,200 --> 04:03:56,700
Pregnant stripper, just about speed.

3905
04:03:58,900 --> 04:04:00,700
Because this is Judith, floating-point, Precision.

3906
04:04:00,700 --> 04:04:03,200
Is there a significant difference between generating a random Float by

3907
04:04:03,200 --> 04:04:06,800
dividing, 32 random bits by the max 32-bit integer, but or dividing

3908
04:04:06,800 --> 04:04:09,800
24-hour random bits by the maximum 24 bit integer.

3909
04:04:14,300 --> 04:04:15,700
I don't think there would be.

3910
04:04:18,000 --> 04:04:19,800
That's why I was okay.

3911
04:04:19,800 --> 04:04:24,400
Shifting it down, there are things including Point called D, normal

3912
04:04:24,400 --> 04:04:28,400
numbers and things like this, but we're not using those and hopefully

3913
04:04:28,400 --> 04:04:29,300
those are turned off.

3914
04:04:29,800 --> 04:04:31,100
Hopefully, do you know where flush 20?

3915
04:04:31,100 --> 04:04:39,200
And so you can actually get in a straightforward IEEE to spec value,

3916
04:04:39,500 --> 04:04:46,100
you actually can get more Precision than 24 bits by using a d normal

3917
04:04:46,300 --> 04:04:46,900
number.

3918
04:04:47,400 --> 04:04:54,100
But I I don't, we're not doing that, so I'm pretty sure that as long

3919
04:04:54,100 --> 04:05:00,300
as you have 24 bits /, 24, bits, 25 B, divided by 20 is because you

3920
04:05:00,300 --> 04:05:02,000
have that the sign bit as well.

3921
04:05:03,600 --> 04:05:06,100
I suppose in there if you wanted to, if you wanted to do it, if you

3922
04:05:06,100 --> 04:05:11,300
actually wanted to do the full thing may be but we're not doing that

3923
04:05:11,300 --> 04:05:12,400
either, right?

3924
04:05:14,400 --> 04:05:16,800
We're adding the sign back in later basically.

3925
04:05:16,800 --> 04:05:22,400
So I would say, yeah, 24 by 24 should be fine, but

3926
04:05:23,400 --> 04:05:25,600
Don't quote me, I have not really thought too much about that.

3927
04:05:27,000 --> 04:05:28,900
So don't quote me on that.

3928
04:05:35,200 --> 04:05:37,800
The Lira bulk coach me, I said in a much larger screen that using

3929
04:05:37,800 --> 04:05:40,700
operator overloads, 470 could confuse compiler preferring to use

3930
04:05:40,700 --> 04:05:43,200
macros, why the change actually?

3931
04:05:43,200 --> 04:05:48,000
The I think I explained this yesterday, the reason I didn't do it that

3932
04:05:48,000 --> 04:05:50,900
way on this one is because we're still in flux.

3933
04:05:51,200 --> 04:05:54,800
So you don't want to do Cindy optimizations on a routine that, you

3934
04:05:54,800 --> 04:05:59,300
know, you're going to heavily modify which we are going to sew.

3935
04:06:01,900 --> 04:06:04,300
So that's why I have this sort of interim approach, so we can still

3936
04:06:04,300 --> 04:06:05,300
get some speed out of it.

3937
04:06:05,300 --> 04:06:06,700
I thought it would be more of a speed Improvement.

3938
04:06:06,700 --> 04:06:07,400
I have to look at, why?

3939
04:06:07,400 --> 04:06:12,700
It's not, but that's basically why it's because I want to be able to

3940
04:06:12,800 --> 04:06:17,300
change all these computations in here that when we go through and add

3941
04:06:17,300 --> 04:06:19,600
some better lighting calculations.

3942
04:06:20,700 --> 04:06:22,200
So that's the same thing.

3943
04:06:22,200 --> 04:06:25,200
I didn't handmade hero, I did overloaded operators on handmade hero in

3944
04:06:25,200 --> 04:06:28,200
the particle system because we want to be able to fuss with it.

3945
04:06:29,400 --> 04:06:31,500
And I didn't do it in the renderer because we knew that route

3946
04:06:31,700 --> 04:06:32,900
Was just what that routine was.

3947
04:06:53,800 --> 04:06:56,700
Pragma scripts to the reason that I did, that comparison, where I

3948
04:06:56,700 --> 04:07:01,200
looked at 122 6512 1024 is I was looking to see whether it does more

3949
04:07:01,200 --> 04:07:02,700
samples, but it doesn't look like it does.

3950
04:07:03,000 --> 04:07:06,800
So it looks like it does the same number of samples in both cases.

3951
04:07:09,000 --> 04:07:12,100
But yeah, if you want to try that, we certainly can.

3952
04:07:12,900 --> 04:07:15,700
So if we do raise for Pixel here,

3953
04:07:22,900 --> 04:07:26,800
if I was to set this to 64 and recompile,

3954
04:07:30,800 --> 04:07:36,700
this is the version with the with the, the lane with

3955
04:07:37,900 --> 04:07:41,400
set 24 and that produces this image.

3956
04:07:43,200 --> 04:07:47,000
and then if I go through and set the lane with back down,

3957
04:07:51,600 --> 04:07:52,200
21.

3958
04:07:54,500 --> 04:07:55,200
Here's that.

3959
04:08:01,000 --> 04:08:01,500
but,

3960
04:08:04,200 --> 04:08:08,300
So something kind of weird about that.

3961
04:08:21,700 --> 04:08:22,600
No, that's okay.

3962
04:08:22,600 --> 04:08:22,900
Never mind.

3963
04:08:22,900 --> 04:08:24,200
That's that's roughly, correct?

3964
04:08:24,400 --> 04:08:26,000
Yeah, that seems just occurred to me.

3965
04:08:27,300 --> 04:08:28,900
Alright, so here's the two versions.

3966
04:08:31,000 --> 04:08:32,900
And they look pretty similar.

3967
04:08:33,100 --> 04:08:35,600
Like, I would say the noise level looks comparable to me.

3968
04:08:47,500 --> 04:08:53,000
I would like to snap off the Run of this guy there too, as well.

3969
04:08:56,800 --> 04:08:57,200
Oops.

3970
04:09:23,800 --> 04:09:24,800
What's smaller packing?

3971
04:09:24,800 --> 04:09:28,200
Potentially be better, is the packing taking too much time.

3972
04:09:29,100 --> 04:09:32,200
So I don't think so, but we haven't profile that yet.

3973
04:09:32,200 --> 04:09:34,900
So the next thing we have to do is really profile this thing and find

3974
04:09:34,900 --> 04:09:39,800
out where we're spending the time, right?

3975
04:09:41,800 --> 04:09:46,100
And so the thing that's kind of troubling about it, right?

3976
04:09:47,500 --> 04:09:53,200
Is, if you take a look at at what's going on with the timings, we are

3977
04:09:53,300 --> 04:09:57,200
almost four times faster compared to this scalar version.

3978
04:09:57,200 --> 04:10:00,300
That's doing the same operations as we are right.

3979
04:10:00,300 --> 04:10:03,800
If you look at these two in any in any case, that's what's happening.

3980
04:10:05,400 --> 04:10:06,600
We're not faster.

3981
04:10:06,600 --> 04:10:10,300
If you compare this version to the scalar version that doesn't have to

3982
04:10:10,300 --> 04:10:11,200
do that stuff.

3983
04:10:12,100 --> 04:10:17,300
So what it looks to me like is the branching actually is important.

3984
04:10:17,300 --> 04:10:20,300
I think I mean you know so we could try here's one thing we could try.

3985
04:10:20,300 --> 04:10:23,200
For example is to see to what extent that's true.

3986
04:10:24,500 --> 04:10:29,400
Let's say we go back into re dot CPP and we come up here and we say,

3987
04:10:29,400 --> 04:10:32,000
all right, let's suppose the early outs were actually really

3988
04:10:32,000 --> 04:10:32,500
important.

3989
04:10:32,500 --> 04:10:35,500
Well, where were those early outs before, right?

3990
04:10:36,400 --> 04:10:39,300
So one of them was, you know, we knew we were going to divide by this

3991
04:10:39,300 --> 04:10:41,000
denominator, right?

3992
04:10:41,900 --> 04:10:45,900
So we don't really need any of this information at all.

3993
04:10:46,900 --> 04:10:52,500
Other than just the, the initial like we don't need the mat index, or

3994
04:10:52,500 --> 04:10:53,800
any of that stuff, right?

3995
04:10:55,800 --> 04:10:59,700
We don't need to do any of this stuff, if all of the Nam, denominators

3996
04:10:59,700 --> 04:11:01,000
are wrong, right?

3997
04:11:01,000 --> 04:11:04,700
So, if there's no way that denominator could ever actually do its

3998
04:11:04,700 --> 04:11:09,400
thing, right, then we know that that's, that's simply not feasible.

3999
04:11:09,400 --> 04:11:12,400
So let's say, we took this and we said we compute the denominator, we

4000
04:11:12,400 --> 04:11:13,900
then look at the denominator mask.

4001
04:11:14,100 --> 04:11:17,200
If, you know, if mask is zeroed

4002
04:11:19,200 --> 04:11:21,200
Just say if not mask is zeroed, right?

4003
04:11:23,100 --> 04:11:24,600
Then we're going to do the rest of this stuff.

4004
04:11:26,900 --> 04:11:30,700
I could do the same thing again down here with the hit mask, right?

4005
04:11:30,700 --> 04:11:32,500
Or the team asked, right?

4006
04:11:33,000 --> 04:11:39,000
So we compute the T, well, the team asked, I guess the team asked is

4007
04:11:39,000 --> 04:11:42,100
just the thing that says, which of the T values we actually use

4008
04:11:45,300 --> 04:11:45,700
No, no.

4009
04:11:45,700 --> 04:11:47,200
The team asked, that's true of the team s.

4010
04:11:47,700 --> 04:11:48,900
So we add these two together.

4011
04:11:48,900 --> 04:11:50,700
We don't have to do any of these assignments.

4012
04:11:50,700 --> 04:11:53,300
For example, if the hit mask is then 0, right?

4013
04:11:53,800 --> 04:11:55,400
So we could also do this one.

4014
04:11:56,400 --> 04:11:58,200
If not mask is zeroed,

4015
04:12:01,800 --> 04:12:02,300
Right.

4016
04:12:07,000 --> 04:12:10,300
And it looks like the Mad index here also doesn't have to be loaded

4017
04:12:10,300 --> 04:12:13,500
till inside of there as well, right?

4018
04:12:23,600 --> 04:12:25,900
So you could do that.

4019
04:12:25,900 --> 04:12:27,400
Same is true for the planes.

4020
04:12:27,400 --> 04:12:30,300
So when we go through testing the planes, we could say, I mean that's

4021
04:12:30,300 --> 04:12:32,500
the Spheres same exact thing.

4022
04:12:32,600 --> 04:12:35,400
So if you take a look at all the masks terms, we have, we've got the

4023
04:12:35,400 --> 04:12:36,500
root mask term.

4024
04:12:45,000 --> 04:12:45,800
And we know that.

4025
04:12:52,500 --> 04:12:53,300
We can check that one.

4026
04:12:53,300 --> 04:12:58,300
We also know, we've got the hit mask just like before, right?

4027
04:12:59,000 --> 04:12:59,700
This is wrong.

4028
04:13:01,600 --> 04:13:01,800
Yeah.

4029
04:13:11,200 --> 04:13:13,100
So, you know, maybe this branch is important.

4030
04:13:13,100 --> 04:13:16,200
Look, maybe that work that we were doing, we would just really like to

4031
04:13:16,200 --> 04:13:17,100
save, right?

4032
04:13:17,100 --> 04:13:20,500
So now we can reorganize these into two, which ones we actually need.

4033
04:13:20,700 --> 04:13:23,200
We know that the team asked and the hit mask, don't need to get

4034
04:13:23,200 --> 04:13:25,700
updated until we know that the root mask actually works.

4035
04:13:26,500 --> 04:13:35,000
The pick mask, this one only has to get updated inside as well,

4036
04:13:35,000 --> 04:13:37,000
because that's conditioning, the T value.

4037
04:13:38,300 --> 04:13:40,600
Same with the T equals t p.

4038
04:13:41,100 --> 04:13:46,700
here, the root term needs to

4039
04:13:49,100 --> 04:13:49,800
well no.

4040
04:13:49,800 --> 04:13:54,700
So these guys here, right can be inside as well because we don't need

4041
04:13:54,700 --> 04:13:56,100
to compute any of this stuff.

4042
04:13:57,100 --> 04:13:58,900
If the root mask is 0, right?

4043
04:13:58,900 --> 04:14:00,500
So it only needs the root term.

4044
04:14:03,600 --> 04:14:05,400
To start with and not the denominator.

4045
04:14:05,700 --> 04:14:10,400
So it needs B and A and C to compute the root term and it needs to do

4046
04:14:10,400 --> 04:14:12,400
the mask but that's all it really needs to do.

4047
04:14:12,600 --> 04:14:15,300
Then we come down here, we need to pick which T value, we're going to

4048
04:14:15,300 --> 04:14:17,900
use and we need to Sauce it there.

4049
04:14:18,000 --> 04:14:20,800
So this all needs to happen like that but otherwise we're fine.

4050
04:14:21,400 --> 04:14:23,400
The same is true of the mat index here.

4051
04:14:23,400 --> 04:14:28,100
That doesn't have to get pulled out until later because we don't need

4052
04:14:28,100 --> 04:14:29,100
to grab that.

4053
04:14:29,200 --> 04:14:33,200
If we, if we're not actually ever going to have,

4054
04:14:33,700 --> 04:14:35,800
Right, the compiler should have done that probably though.

4055
04:14:37,400 --> 04:14:38,100
All right.

4056
04:14:40,500 --> 04:14:42,800
So, I don't know if that's any faster I guess.

4057
04:14:48,500 --> 04:14:49,400
Probably not.

4058
04:14:49,600 --> 04:14:53,000
But you know that was something that the other code was able to do

4059
04:14:53,000 --> 04:14:53,200
that.

4060
04:14:53,200 --> 04:14:56,500
Our code that are other code wasn't able to do, right?

4061
04:14:57,700 --> 04:14:59,700
And hey I

4062
04:15:00,200 --> 04:15:03,000
That's a pretty big speed and that's like twice as fast.

4063
04:15:03,700 --> 04:15:04,700
Almost, right.

4064
04:15:04,700 --> 04:15:06,300
We were at .09.

4065
04:15:07,700 --> 04:15:09,300
We were at 09 down here, right?

4066
04:15:09,300 --> 04:15:13,500
And now we're at 05 for the same number of bounces in the same quality

4067
04:15:13,500 --> 04:15:14,500
image, right?

4068
04:15:14,500 --> 04:15:16,900
So now that Ray casting time has dropped pretty dramatically.

4069
04:15:16,900 --> 04:15:18,500
If we compare the two,

4070
04:15:21,400 --> 04:15:22,000
To where we started.

4071
04:15:22,000 --> 04:15:23,100
That's actually quite good.

4072
04:15:23,900 --> 04:15:25,700
This one is not really.

4073
04:15:25,700 --> 04:15:27,500
We should have saved the one that we did.

4074
04:15:27,500 --> 04:15:29,600
That was a more optimized version.

4075
04:15:29,600 --> 04:15:34,300
I should have saved an interim because it was .09 4.

4076
04:15:36,200 --> 04:15:41,700
For the single core, but that means we've at least sped up to X, right

4077
04:15:43,500 --> 04:15:45,700
relative to where we were at before.

4078
04:15:45,900 --> 04:15:49,000
And that's, that's a decent speed up.

4079
04:15:51,100 --> 04:15:55,900
And, you know, I'll take it right, I still think there's probably more

4080
04:15:55,900 --> 04:15:56,700
to be done here.

4081
04:15:56,700 --> 04:15:59,400
There's probably some other things that we're doing that are dumb.

4082
04:16:00,900 --> 04:16:01,200
I guess.

4083
04:16:01,200 --> 04:16:04,800
One thing that I would say is if we look at the loads here the loads

4084
04:16:04,800 --> 04:16:05,800
are pretty expensive.

4085
04:16:06,500 --> 04:16:09,400
We could choose to move the loads below.

4086
04:16:11,500 --> 04:16:12,600
sort of the

4087
04:16:15,800 --> 04:16:18,200
we could choose to keep well.

4088
04:16:19,700 --> 04:16:24,500
We could choose to not do loads on ones that haven't hit, right?

4089
04:16:26,300 --> 04:16:31,300
So if we imagine changing the way, the gather works so that we only

4090
04:16:31,300 --> 04:16:33,700
gather things that are nonzero.

4091
04:16:36,600 --> 04:16:40,700
That, that would be an example of a way to optimize this, probably

4092
04:16:40,700 --> 04:16:41,300
further.

4093
04:16:52,400 --> 04:16:53,500
But yeah.

4094
04:16:59,700 --> 04:17:03,500
So the other thing I would say is if in the mask is zeroed case here,

4095
04:17:03,500 --> 04:17:06,200
where we're going to break out, I assume the compiler was smart enough

4096
04:17:06,200 --> 04:17:09,800
to do it, but I'll also just go ahead and do it for it.

4097
04:17:10,800 --> 04:17:13,900
We don't need to compute any more things through the, through the

4098
04:17:13,900 --> 04:17:14,400
loop.

4099
04:17:15,000 --> 04:17:19,800
We do need to update anything besides the lane mask, and the sample in

4100
04:17:19,800 --> 04:17:23,000
the case, where we're not actually going to do anything else.

4101
04:17:23,400 --> 04:17:26,800
So I'm assuming the compiler was smart enough to move.

4102
04:17:29,400 --> 04:17:31,600
These things into an else Clause basically.

4103
04:17:32,200 --> 04:17:38,300
So it, you know it looks like this where if the mask is zero, you

4104
04:17:38,300 --> 04:17:39,400
know, they won't

4105
04:17:41,700 --> 04:17:43,800
If the mass is real breakout otherwise we'll do this.

4106
04:17:43,800 --> 04:17:45,400
I'm assuming it was smart to do that.

4107
04:17:45,400 --> 04:17:47,200
So don't anticipate this would make any difference.

4108
04:17:47,200 --> 04:17:53,100
But that's another example of something that, you know, we can do

4109
04:17:53,100 --> 04:17:55,500
based on checking to see whether anything is getting used.

4110
04:17:56,500 --> 04:17:57,200
But all right.

4111
04:17:57,200 --> 04:17:59,200
No, I guess it wasn't smart enough to do that.

4112
04:18:01,900 --> 04:18:02,600
So there you go.

4113
04:18:02,600 --> 04:18:07,100
So that's another one to and there's probably lots of other little

4114
04:18:07,100 --> 04:18:08,900
things like that in here that we can get.

4115
04:18:09,900 --> 04:18:11,600
So, we're getting pretty good here now.

4116
04:18:11,600 --> 04:18:14,400
Like that's that's producing an image in a pretty reasonable amount of

4117
04:18:14,400 --> 04:18:14,600
time.

4118
04:18:14,600 --> 04:18:18,700
Course, our image is also fairly simple, so you know nothing to

4119
04:18:18,700 --> 04:18:19,800
necessarily write home about.

4120
04:18:19,800 --> 04:18:24,200
But at least we're like in the ballpark of Sanity now and we can do a

4121
04:18:24,200 --> 04:18:26,600
pretty detailed image in a pretty quick amount of time.

4122
04:18:26,600 --> 04:18:26,900
Right?

4123
04:18:26,900 --> 04:18:28,300
That only took 7 Seconds.

4124
04:18:28,500 --> 04:18:29,400
That's plenty, good.

4125
04:18:29,400 --> 04:18:31,400
Turnaround for a simple or a caster.

4126
04:18:31,900 --> 04:18:34,600
If you wanted to play with it and plus it produces reasonable results

4127
04:18:34,600 --> 04:18:37,400
at lower raise per pixel which go much faster as well.

4128
04:18:37,900 --> 04:18:44,600
We also don't know how long this would be take if we went even wider,

4129
04:18:44,800 --> 04:18:45,300
right?

4130
04:18:48,500 --> 04:18:51,900
So that part I'm not sure about, I don't know how long it would take

4131
04:18:51,900 --> 04:18:52,500
to do that.

4132
04:18:52,500 --> 04:18:57,100
Maybe I'll you know, I'm kind of into it right now I have to say so I

4133
04:18:57,100 --> 04:18:58,900
kind of just wanted to keep going but

4134
04:19:02,300 --> 04:19:05,700
In here, if we look at the way these re Lane things are set up, you

4135
04:19:05,700 --> 04:19:10,900
know, I might be inclined to say if we did a re laying for x or

4136
04:19:10,900 --> 04:19:16,300
something like that and in there, we took the ray Lane stuff that was

4137
04:19:16,300 --> 04:19:21,600
44 wide, and we just kind of grabbed all that out.

4138
04:19:27,200 --> 04:19:27,900
Like so.

4139
04:19:31,000 --> 04:19:31,700
and,

4140
04:19:33,000 --> 04:19:35,300
I feel like that's sort of

4141
04:19:36,900 --> 04:19:38,800
just a nicer thing to look at.

4142
04:19:38,900 --> 04:19:42,100
So in here, we would just say, you know, pounding group include

4143
04:19:42,400 --> 04:19:45,700
railing, train for x.h.

4144
04:19:50,700 --> 04:19:57,300
like so and if we want to make an 8X wide run one, we would do

4145
04:19:59,100 --> 04:20:09,400
That and basically that's just a copy right of this stuff and railing

4146
04:20:09,600 --> 04:20:12,000
8X that H goes in here.

4147
04:20:15,000 --> 04:20:16,000
and these are just

4148
04:20:17,100 --> 04:20:18,200
256 has

4149
04:20:19,200 --> 04:20:19,700
Right.

4150
04:20:20,900 --> 04:20:24,600
And I don't know, exactly all the rest of the stuff I would have to do

4151
04:20:24,600 --> 04:20:29,600
to make this work properly but it's more or less fat with changing the

4152
04:20:29,800 --> 04:20:30,600
mnemonics, right?

4153
04:20:30,600 --> 04:20:33,000
So if we wanted to, you know, here's the four wide version.

4154
04:20:33,000 --> 04:20:37,600
Again we can pilot want to comply this one you can see that like all

4155
04:20:37,600 --> 04:20:42,200
of these mnemonics are wrong now so you know, I don't know.

4156
04:20:42,200 --> 04:20:43,500
Can I just do this?

4157
04:20:43,600 --> 04:20:46,600
I've never had the luxury, this is the first machine I've ever had.

4158
04:20:46,600 --> 04:20:48,800
That had eight wide on it in the first place, so I don't even know.

4159
04:20:53,400 --> 04:20:59,100
But let's, let's let's take a look, so comp ltps, right?

4160
04:20:59,100 --> 04:20:59,800
Is is

4161
04:21:00,000 --> 04:21:00,600
Right anymore.

4162
04:21:00,600 --> 04:21:03,900
So, what are the intrinsics for avx2?

4163
04:21:05,600 --> 04:21:11,000
Any of the X4 comp belty?

4164
04:21:11,600 --> 04:21:15,100
Like how do you compare two values with with the wider instruction

4165
04:21:15,100 --> 04:21:15,400
set?

4166
04:21:15,400 --> 04:21:16,200
I don't even know.

4167
04:21:17,200 --> 04:21:17,800
Right.

4168
04:21:19,800 --> 04:21:20,800
Am I missing something?

4169
04:21:26,200 --> 04:21:27,000
So here it is.

4170
04:21:27,000 --> 04:21:27,700
It's just

4171
04:21:29,900 --> 04:21:32,000
Mmm 256 comp PS.

4172
04:21:32,500 --> 04:21:36,100
Looks like what it is and you pass in immediate value.

4173
04:21:37,100 --> 04:21:42,400
The immediate value is the type of comparison to use put out know what

4174
04:21:42,400 --> 04:21:44,200
those media values would necessarily be.

4175
04:21:44,200 --> 04:21:45,400
Unfortunately,

4176
04:21:51,100 --> 04:21:51,900
Let me look it up.

4177
04:22:04,300 --> 04:22:05,500
That's there it is.

4178
04:22:05,900 --> 04:22:09,000
Blend V blend V.

4179
04:22:09,400 --> 04:22:11,700
That's the one that does the select.

4180
04:22:11,700 --> 04:22:14,800
Like I was talking about, I'm like, I know it's in there is can't

4181
04:22:14,800 --> 04:22:15,500
remember tonight.

4182
04:22:17,800 --> 04:22:26,000
So there's a predicate, the predicate is in IMM, intron .h, so I don't

4183
04:22:26,000 --> 04:22:26,800
know where I am.

4184
04:22:26,800 --> 04:22:28,200
Intron dot h is

4185
04:22:42,700 --> 04:22:43,600
It's in there.

4186
04:22:45,800 --> 04:22:51,200
What, what a sensible path to an include file, you know?

4187
04:22:51,200 --> 04:22:57,100
Just just like the old days you could have backslash R, sorry /usr

4188
04:22:57,100 --> 04:23:01,700
forward slash include or you can have C colon backslash program, space

4189
04:23:01,700 --> 04:23:06,400
files faceprint open parentheses x, 86 close parentheses, backslash

4190
04:23:06,400 --> 04:23:11,100
Microsoft, based visual space, Studio backslash, 2017, back-sass

4191
04:23:11,100 --> 04:23:15,400
Community backs, SVC box size, tools backs, SMS, VC, back size, 14,

4192
04:23:15,600 --> 04:23:18,600
at 11.2, 5503 backslash include

4193
04:23:22,500 --> 04:23:24,600
Please Microsoft died in a fire.

4194
04:23:25,000 --> 04:23:27,500
Alright, so let's go ahead and open that.

4195
04:23:28,700 --> 04:23:30,400
Monstrosity up.

4196
04:23:37,000 --> 04:23:38,900
And see what that file says.

4197
04:23:48,900 --> 04:23:49,500
Sure.

4198
04:23:53,300 --> 04:23:56,600
So in theory, the cops are, oh, and here, they're right at the top.

4199
04:23:56,600 --> 04:23:59,900
So here are all the comps that we might want.

4200
04:24:02,100 --> 04:24:05,800
We've got something else interesting like signaling versions, and so

4201
04:24:05,800 --> 04:24:05,900
on.

4202
04:24:05,900 --> 04:24:11,000
That's cool, compare products for scale impact compared and transfer

4203
04:24:11,000 --> 04:24:11,600
functions.

4204
04:24:16,600 --> 04:24:19,100
So equal ordered non signaling.

4205
04:24:19,900 --> 04:24:22,400
So you have all these different kinds of things.

4206
04:24:22,400 --> 04:24:25,500
I'm not even familiar with these so I guess you can choose whether or

4207
04:24:25,500 --> 04:24:27,300
not it's signaling or not.

4208
04:24:27,500 --> 04:24:29,500
I assume that's signaling.

4209
04:24:30,000 --> 04:24:37,200
If the value was like and a man or something and we don't need to do

4210
04:24:37,200 --> 04:24:40,600
that so we can do non signaling ordered.

4211
04:24:40,600 --> 04:24:44,500
I'm not quite sure what they mean by that.

4212
04:24:45,100 --> 04:24:46,100
So I would like

4213
04:24:46,300 --> 04:24:50,700
Someone to tell me what that means, this will be educational for me.

4214
04:24:56,100 --> 04:24:58,800
Do they have documentation here somewhere?

4215
04:25:02,700 --> 04:25:04,400
I kind of just want the architecture manual.

4216
04:25:04,400 --> 04:25:05,400
Probably for this.

4217
04:25:23,300 --> 04:25:26,400
Because I would like to know what they mean by ordered, in that sense.

4218
04:26:04,100 --> 04:26:05,200
Hmm.

4219
04:26:10,000 --> 04:26:10,900
My say.

4220
04:26:25,600 --> 04:26:27,300
I really just want you to tell me.

4221
04:26:29,300 --> 04:26:29,900
Thank you.

4222
04:26:32,000 --> 04:26:32,600
Oq.

4223
04:26:43,400 --> 04:26:44,800
Open up, there we go.

4224
04:26:51,600 --> 04:26:53,100
Does this sort of?

4225
04:26:54,600 --> 04:26:56,300
Elaborate at all.

4226
04:27:09,900 --> 04:27:13,800
Okay, is this to comply with three of the DirectX 10, specification,

4227
04:27:14,100 --> 04:27:14,600
okay.

4228
04:27:16,700 --> 04:27:20,600
When either a both operates, our Nanny returns, false comparisons know

4229
04:27:20,600 --> 04:27:22,900
the sine of 0 comparison.

4230
04:27:22,900 --> 04:27:24,500
Any ear was earn a return.

4231
04:27:24,500 --> 04:27:26,400
True comparisons of non-invasive.

4232
04:27:26,400 --> 04:27:29,300
The correct result do Norms are flush before comparison.

4233
04:27:30,200 --> 04:27:30,700
Okay?

4234
04:27:37,300 --> 04:27:42,400
Infinity values of either, sign are considered ordered values.

4235
04:27:44,000 --> 04:27:49,700
Okay, so basically, this is just talking about whether or not Infinity

4236
04:27:49,900 --> 04:27:52,700
Works signed or not.

4237
04:27:54,000 --> 04:27:54,700
I guess.

4238
04:27:58,100 --> 04:27:59,500
Is that what he's talking about?

4239
04:28:02,100 --> 04:28:05,800
I'm not really sure right, that's not really clear on that.

4240
04:28:05,800 --> 04:28:08,100
So I'm not sure which one of those we would want

4241
04:28:10,300 --> 04:28:11,800
That's pretty confusing to me.

4242
04:28:12,200 --> 04:28:14,200
I'm gonna have to go with the architecture mail because I've never

4243
04:28:14,200 --> 04:28:15,400
seen that terminology for.

4244
04:28:15,400 --> 04:28:17,400
I'm sure it means something obvious, right?

4245
04:28:17,400 --> 04:28:19,600
But I've never seen it before because I've never programmed this

4246
04:28:19,600 --> 04:28:20,500
instruction set.

4247
04:28:22,100 --> 04:28:22,800
So anyway.

4248
04:28:23,800 --> 04:28:30,000
So what we want here is a is a 256, right?

4249
04:28:30,500 --> 04:28:35,400
We want AV we want this to be less than, right?

4250
04:28:35,600 --> 04:28:37,900
So we don't want signaling.

4251
04:28:38,300 --> 04:28:39,000
So we just want

4252
04:28:39,100 --> 04:28:41,600
Wyatt, we don't need it to Signal not that it would matter.

4253
04:28:41,600 --> 04:28:45,600
It could if it wanted to, we don't give it any of those.

4254
04:28:45,600 --> 04:28:46,100
I don't think.

4255
04:28:46,100 --> 04:28:48,100
Oh well, we might because we're doing masking stuff like that.

4256
04:28:48,100 --> 04:28:49,900
So we want it to be to be quiet.

4257
04:28:52,500 --> 04:28:55,300
So for example, in this case we've got a list an operation so I think

4258
04:28:55,300 --> 04:28:57,600
we want compelte oq, right.

4259
04:28:59,600 --> 04:28:59,800
Oops.

4260
04:29:02,300 --> 04:29:04,800
Throughout less than ordered quiet.

4261
04:29:04,800 --> 04:29:07,100
And the only thing I don't know is whether we want ordered or

4262
04:29:07,100 --> 04:29:10,100
unordered because I don't really understand the difference between

4263
04:29:10,100 --> 04:29:14,600
those two things, I would like someone to explain to me what that

4264
04:29:14,600 --> 04:29:16,700
means and

4265
04:29:23,000 --> 04:29:26,300
Yeah I just I just don't know so we may want oqs.

4266
04:29:26,300 --> 04:29:26,800
We won't meet.

4267
04:29:26,800 --> 04:29:27,400
Want you ques?

4268
04:29:27,400 --> 04:29:28,200
I'm not sure.

4269
04:29:28,800 --> 04:29:31,000
So that's kind of yeah up in the air.

4270
04:29:31,600 --> 04:29:34,700
So again, this would be the same, this is a less than or equal to

4271
04:29:36,500 --> 04:29:39,300
So it's probably just going to be that right less than or equal to.

4272
04:29:40,000 --> 04:29:45,300
This one's going to be a comp greater than 0 Q.

4273
04:29:49,200 --> 04:29:54,600
And this one's going to be a comp greater than or equal to 0 Q.

4274
04:29:56,300 --> 04:29:58,000
this was going to be comp equal to

4275
04:30:00,800 --> 04:30:04,600
And this one's going to be a comp not equal to Q.

4276
04:30:09,900 --> 04:30:13,700
And all of these are going to have to become just comp PS.

4277
04:30:21,600 --> 04:30:21,900
Okay.

4278
04:30:23,400 --> 04:30:24,700
So I think we did that, right?

4279
04:30:26,000 --> 04:30:27,000
But I don't really know.

4280
04:30:28,000 --> 04:30:30,400
So now we need one of these.

4281
04:30:30,400 --> 04:30:31,100
I assume

4282
04:30:32,500 --> 04:30:33,400
But yep.

4283
04:30:33,700 --> 04:30:36,900
And so this, I'm just going by how the in transition named I'm just

4284
04:30:36,900 --> 04:30:42,500
guessing that's probably that to do the conversion and hey, good for

4285
04:30:42,500 --> 04:30:46,100
them, for being consistent as weird as the nominee nature is at least

4286
04:30:46,100 --> 04:30:48,400
worked and I didn't have to look it up.

4287
04:30:49,800 --> 04:30:51,700
So there's those conversions.

4288
04:30:55,500 --> 04:30:56,300
And that's pretty good.

4289
04:30:56,300 --> 04:30:59,600
Now for you 32s, I don't know what we've got here.

4290
04:30:59,600 --> 04:31:02,200
They may have a comp for that.

4291
04:31:02,300 --> 04:31:07,700
We may not have to do the weird foofy miss anymore.

4292
04:31:07,900 --> 04:31:09,900
So let's just double check.

4293
04:31:10,100 --> 04:31:13,300
So is there a

4294
04:31:14,600 --> 04:31:18,100
Mmm tuna fish comfort for 32-bit wide or not.

4295
04:31:24,800 --> 04:31:25,700
Comparisons.

4296
04:31:28,600 --> 04:31:34,900
So there's a copy Q&A comp greater than but that's it.

4297
04:31:36,300 --> 04:31:39,700
So I guess that means that you don't, you can't do other kinds of

4298
04:31:39,700 --> 04:31:43,100
comparisons, you have to like negate the values and compare them that

4299
04:31:43,100 --> 04:31:44,000
way or something.

4300
04:31:44,200 --> 04:31:45,400
There's only two.

4301
04:31:45,400 --> 04:31:45,600
Right?

4302
04:31:45,600 --> 04:31:49,400
Because you you can imagine constructing the other values, right?

4303
04:31:49,500 --> 04:31:54,600
For example, if you want to know greater than or equal to you could or

4304
04:31:54,600 --> 04:31:57,300
together a greater than and equal to comparisons,

4305
04:31:57,600 --> 04:32:00,100
And if you want to do a less than you can just do a greater than with

4306
04:32:00,100 --> 04:32:06,100
the operands reversed and an EQ or whatever, right.

4307
04:32:06,300 --> 04:32:11,300
So you could imagine these going that way and that I guess what they

4308
04:32:11,300 --> 04:32:13,800
want you to do, here it looks like right.

4309
04:32:15,200 --> 04:32:17,000
So that's probably what's going on there.

4310
04:32:18,200 --> 04:32:20,800
So let's go ahead and do that to me.

4311
04:32:22,600 --> 04:32:24,800
Well, in this case, we don't really care because that's actually the

4312
04:32:24,800 --> 04:32:26,900
only one, we really needed, right.

4313
04:32:28,600 --> 04:32:29,300
Is that right?

4314
04:32:29,400 --> 04:32:33,000
Yeah, we only really need that one anyway, so never mind.

4315
04:32:33,300 --> 04:32:37,300
So in this case, I guess it's just, it's just this

4316
04:32:39,600 --> 04:32:40,200
Probably.

4317
04:32:41,900 --> 04:32:46,400
Yeah, I assume X or just translates directly across.

4318
04:32:49,600 --> 04:32:52,600
I assume that and translates directly across.

4319
04:32:58,700 --> 04:32:59,400
But I don't know.

4320
04:33:01,400 --> 04:33:03,400
Looks like this is like really easy, right?

4321
04:33:03,400 --> 04:33:03,900
We don't know.

4322
04:33:03,900 --> 04:33:11,099
It's gonna work, could just completely die on us here, but so far so

4323
04:33:11,099 --> 04:33:11,700
good.

4324
04:33:19,200 --> 04:33:25,500
Like some of it's a little different but the rest of it isn't, right?

4325
04:33:29,300 --> 04:33:30,900
A lot of its just doing this.

4326
04:33:40,000 --> 04:33:43,700
So yeah, this is when you've got to actually provide the right numbers

4327
04:33:43,700 --> 04:33:44,599
of values.

4328
04:33:44,599 --> 04:33:50,700
So yeah, I guess this has to take like as wide as the lane width could

4329
04:33:50,700 --> 04:33:53,300
possibly be he's worth of random stuff.

4330
04:33:55,000 --> 04:33:55,500
Right?

4331
04:33:55,599 --> 04:33:58,900
We almost want to call this like initialize to random or something.

4332
04:33:59,700 --> 04:34:02,000
Let's finish the rest of these first because it's a little bit harder.

4333
04:34:03,000 --> 04:34:06,200
So here's that mask, here's the cast operation.

4334
04:34:08,000 --> 04:34:13,300
Here are the ends and Knots and oars and that's really it.

4335
04:34:15,700 --> 04:34:18,700
These Min and Max should presumably just work there.

4336
04:34:18,700 --> 04:34:21,900
The same exact operations just on a wider width.

4337
04:34:25,000 --> 04:34:27,800
And then this stuff just has to gather 8 wide now.

4338
04:34:29,400 --> 04:34:31,500
Right before, 56.

4339
04:34:32,800 --> 04:34:39,599
Seven, but that's it and MOB mask.

4340
04:34:39,599 --> 04:34:46,099
Now, is going to do a bigger mouth mask, but that's it.

4341
04:34:47,000 --> 04:34:48,300
And

4342
04:34:50,500 --> 04:34:51,700
I think.

4343
04:34:53,000 --> 04:34:56,200
The only thing we have to fix is the way that this entropy thing

4344
04:34:56,200 --> 04:34:56,800
works.

4345
04:34:56,800 --> 04:35:00,200
So again, this function is kind of dumb

4346
04:35:09,599 --> 04:35:11,700
So I guess we just have to make this thing.

4347
04:35:11,700 --> 04:35:14,900
Take a bunch of these, right?

4348
04:35:15,900 --> 04:35:17,099
I always type 2.

4349
04:35:22,000 --> 04:35:24,099
Always what's going on there.

4350
04:35:25,099 --> 04:35:26,500
It's just where my fingers hit.

4351
04:35:27,099 --> 04:35:30,099
No entropy, I got no entropy in my fingers.

4352
04:35:37,500 --> 04:35:38,000
All right.

4353
04:35:59,000 --> 04:35:59,800
One, two, three.

4354
04:36:00,000 --> 04:36:00,200
Four.

4355
04:36:00,200 --> 04:36:01,599
Five, six, seven, eight.

4356
04:36:08,300 --> 04:36:10,200
So I don't know what this is going to do.

4357
04:36:10,200 --> 04:36:11,099
Maybe it'll just blue screen.

4358
04:36:11,099 --> 04:36:16,900
My machine, I don't know, probably not going to lose but you know,

4359
04:36:17,300 --> 04:36:18,700
let's let's try it.

4360
04:36:21,800 --> 04:36:22,400
There we go.

4361
04:36:24,000 --> 04:36:25,099
Immediate crashes.

4362
04:36:26,599 --> 04:36:27,500
What's the problem?

4363
04:36:36,800 --> 04:36:38,000
Render tile.

4364
04:36:39,099 --> 04:36:41,500
Image with wait, what?

4365
04:36:41,700 --> 04:36:43,599
No, let's compile and debug mode.

4366
04:36:43,599 --> 04:36:44,400
First people.

4367
04:37:08,400 --> 04:37:08,900
What?

4368
04:37:12,500 --> 04:37:18,200
so, it compiles in debug mode, but not

4369
04:37:20,200 --> 04:37:21,000
What am I missing?

4370
04:37:28,700 --> 04:37:35,400
So, it compiles in debug mode, but not in release mode doesn't work.

4371
04:37:36,700 --> 04:37:37,900
We sure about that.

4372
04:37:39,599 --> 04:37:40,500
What's going on here?

4373
04:37:42,500 --> 04:37:43,900
Tell me what's going on.

4374
04:37:43,900 --> 04:37:46,900
First of all, who faulted, are we sure?

4375
04:37:46,900 --> 04:37:49,099
We know who faulted is this one of those things where you're showing

4376
04:37:49,099 --> 04:37:50,099
me the wrong thread?

4377
04:37:51,400 --> 04:37:52,000
Folks.

4378
04:37:53,800 --> 04:37:55,800
I don't want this to be one of those things where you throw me the

4379
04:37:55,800 --> 04:37:56,700
wrong thread.

4380
04:38:10,000 --> 04:38:11,099
So, we're on.

4381
04:38:12,800 --> 04:38:14,200
Which instruction around here.

4382
04:38:16,300 --> 04:38:20,800
I am an exception at seven of a three, four, five, six.

4383
04:38:20,800 --> 04:38:22,000
So it's this one right here.

4384
04:38:23,400 --> 04:38:24,300
Illegal instruction.

4385
04:38:24,300 --> 04:38:26,599
So, V unpack, LPS.

4386
04:38:46,900 --> 04:38:47,599
Okay.

4387
04:38:50,800 --> 04:38:52,500
So V unpack, LPS.

4388
04:39:07,599 --> 04:39:11,099
Well, okay, so here's the thing.

4389
04:39:12,700 --> 04:39:13,800
About that.

4390
04:39:18,900 --> 04:39:20,700
Does this need to be aligned?

4391
04:39:24,200 --> 04:39:26,099
Is my own my only question.

4392
04:39:28,300 --> 04:39:29,400
What's rcx?

4393
04:39:36,400 --> 04:39:37,000
and,

4394
04:39:44,700 --> 04:39:45,400
All right.

4395
04:39:54,500 --> 04:39:56,600
So that's not aligned, right?

4396
04:39:59,300 --> 04:40:03,500
so, I wonder if it doesn't like the fact that this V unpack

4397
04:40:10,900 --> 04:40:13,000
I wonder if it doesn't like the fact that that's on the line.

4398
04:40:14,900 --> 04:40:15,600
Yeah, I'm saying to you.

4399
04:40:22,200 --> 04:40:22,600
What?

4400
04:40:22,600 --> 04:40:24,400
Take a look in here.

4401
04:40:27,200 --> 04:40:29,000
This stuff is all fine.

4402
04:40:29,500 --> 04:40:35,600
So is it something unaligned stack wise in here?

4403
04:40:36,000 --> 04:40:37,200
Who are we writing too?

4404
04:40:45,200 --> 04:40:48,500
Because of all of these things should be aligned.

4405
04:40:49,500 --> 04:40:50,200
Where's casts?

4406
04:40:50,200 --> 04:40:51,800
Take a state hasn't.

4407
04:40:51,900 --> 04:40:52,900
Doesn't have any of them.

4408
04:40:57,700 --> 04:41:03,800
So that, yeah, I do wonder whether that's an alignment issue, right?

4409
04:41:03,800 --> 04:41:05,800
I don't know.

4410
04:41:10,000 --> 04:41:11,700
Because it's not aligned.

4411
04:41:12,900 --> 04:41:17,500
It is aligned to 16, but it's not aligned to 32 and I just don't know

4412
04:41:17,500 --> 04:41:19,300
if that instruction has to be aligned.

4413
04:41:19,900 --> 04:41:20,800
Let's find out.

4414
04:41:45,900 --> 04:41:47,700
This is probably what we want here.

4415
04:41:51,800 --> 04:41:53,200
I want the architecture manual.

4416
04:41:56,000 --> 04:41:57,000
Load it up.

4417
04:41:58,700 --> 04:41:59,800
Load it.

4418
04:42:01,600 --> 04:42:02,000
Thank you.

4419
04:42:10,400 --> 04:42:12,900
How come I can't jump to anything.

4420
04:42:13,500 --> 04:42:15,100
What is going on?

4421
04:42:17,500 --> 04:42:18,800
Fine, I'll go there myself.

4422
04:42:26,000 --> 04:42:28,300
Do do, do, do, do, do, do do.

4423
04:42:32,400 --> 04:42:33,800
Unpack LPS, okay.

4424
04:42:57,200 --> 04:43:01,100
Evie, exfiltration exceptions, Type e, 4, and F.

4425
04:43:03,200 --> 04:43:05,600
And what do we know of K?

4426
04:43:05,600 --> 04:43:07,600
So which which ones are these?

4427
04:43:07,600 --> 04:43:10,100
These are evx and coded.

4428
04:43:11,600 --> 04:43:13,300
These are just Vex encoded.

4429
04:43:17,500 --> 04:43:18,800
Yeah, right.

4430
04:43:27,300 --> 04:43:28,500
Now, no, no.

4431
04:43:31,300 --> 04:43:34,000
It's using this broadcast here.

4432
04:43:39,200 --> 04:43:43,900
It might be that the broadcast because that's an e VX and V ve X and

4433
04:43:43,900 --> 04:43:46,800
coded instruction, and we might not be allowed to use those.

4434
04:43:47,400 --> 04:43:50,300
So I wonder I may need to tell

4435
04:43:53,000 --> 04:43:55,800
Visual Studio, not to do a broadcast.

4436
04:43:57,100 --> 04:44:02,900
because I don't know whether that's allowed right Visual Studio

4437
04:44:03,000 --> 04:44:05,300
architecture targets, which

4438
04:44:06,200 --> 04:44:09,500
So, I'm just curious.

4439
04:44:13,900 --> 04:44:15,800
No, that's not God.

4440
04:44:16,700 --> 04:44:20,000
Visual Studio CPU architecture targets which

4441
04:44:26,000 --> 04:44:27,100
command line.

4442
04:44:31,000 --> 04:44:31,500
This one.

4443
04:44:34,400 --> 04:44:39,500
So I want Arch x64 obviously, but I need it to do.

4444
04:44:51,200 --> 04:44:52,800
I mean, I think so.

4445
04:44:52,800 --> 04:44:54,500
It should already be doing this though.

4446
04:44:54,900 --> 04:44:57,100
So I don't know if mmm.

4447
04:45:03,600 --> 04:45:08,800
I'm not sure about why it's doing that, right?

4448
04:45:13,300 --> 04:45:17,700
Let me just see what happens if I smoosh this in there a little bit,

4449
04:45:17,800 --> 04:45:18,400
right?

4450
04:45:18,600 --> 04:45:20,300
So, here's the build line.

4451
04:45:26,800 --> 04:45:28,600
I'm going to go ahead and stick this in here.

4452
04:45:35,800 --> 04:45:38,300
I don't know if you want to be x-ray, Vic's, to, in this case.

4453
04:45:47,700 --> 04:45:49,700
So maybe that was all it took.

4454
04:45:50,900 --> 04:45:54,400
Maybe it thought it could use harder core stuff.

4455
04:45:58,100 --> 04:46:02,500
And telling it not to with the arch command is sufficient.

4456
04:46:12,600 --> 04:46:15,400
Because hey guess what, it's not using that broadcast anymore.

4457
04:46:17,100 --> 04:46:17,500
Right.

4458
04:46:17,500 --> 04:46:21,100
Here is the unpack LPS and it's not using broadcast anymore.

4459
04:46:22,600 --> 04:46:24,000
So that might be it.

4460
04:46:26,100 --> 04:46:27,900
All right, so 48 wide Lanes.

4461
04:46:45,900 --> 04:46:48,000
So eight wide Lanes is awful.

4462
04:46:48,600 --> 04:46:54,400
We actually get slower using 8 wide lanes and 60% of our calculations

4463
04:46:54,400 --> 04:46:56,000
are wasted course.

4464
04:46:56,000 --> 04:46:57,800
Let's make sure we actually got an image.

4465
04:47:01,300 --> 04:47:06,300
It looks darker to be mess up a summation value 0.

4466
04:47:06,300 --> 04:47:08,000
Our horizontal ad is wrong.

4467
04:47:11,300 --> 04:47:13,200
So 8 wide is not good.

4468
04:47:13,200 --> 04:47:16,600
We don't gain anything from 8 wide, right?

4469
04:47:17,500 --> 04:47:20,700
Let's go to Lane 8.

4470
04:47:20,700 --> 04:47:23,000
X horizontal ad.

4471
04:47:27,700 --> 04:47:30,500
Just go ahead and get that in here.

4472
04:47:34,000 --> 04:47:36,100
So yeah, this is not quite right yet.

4473
04:47:36,100 --> 04:47:40,900
4 5 6 7 oops.

4474
04:47:44,300 --> 04:47:45,000
Same here.

4475
04:47:49,800 --> 04:47:55,500
So, three, four, five Loops five, six.

4476
04:47:56,700 --> 04:47:57,300
Seven.

4477
04:48:11,000 --> 04:48:13,400
Yeah, and that's just not good at all.

4478
04:48:14,400 --> 04:48:14,900
Right.

4479
04:48:16,700 --> 04:48:17,100
Oh

4480
04:48:18,500 --> 04:48:20,600
So I guess that was just a summation that was busted.

4481
04:48:21,700 --> 04:48:22,300
Never mind.

4482
04:48:23,100 --> 04:48:25,800
So actually, that's exactly what we would expect.

4483
04:48:25,800 --> 04:48:26,700
Got twice as fast.

4484
04:48:27,300 --> 04:48:27,800
Never mind.

4485
04:48:30,500 --> 04:48:31,200
Is that, right?

4486
04:48:31,200 --> 04:48:33,100
So let's let me just check that here.

4487
04:48:33,600 --> 04:48:34,500
Where's the lane with?

4488
04:48:40,300 --> 04:48:44,000
Is aligned with the four and this thing's got to throw out those

4489
04:48:44,000 --> 04:48:44,500
values.

4490
04:48:44,500 --> 04:48:44,900
Also.

4491
04:49:10,800 --> 04:49:13,600
So it's not quite twice as fast, right?

4492
04:49:14,000 --> 04:49:18,600
It's not it's a little less than that and I guess we kind of sort of

4493
04:49:19,100 --> 04:49:22,200
have one culprit here a little bit which is that the waist advances

4494
04:49:22,200 --> 04:49:26,100
number is going up a little bit so it's not really as bad as I thought

4495
04:49:26,100 --> 04:49:27,500
it was right.

4496
04:49:29,700 --> 04:49:31,200
So hey, that's kind of nice.

4497
04:49:32,100 --> 04:49:35,900
We've got day 24x.

4498
04:49:40,200 --> 04:49:40,700
Here.

4499
04:49:42,100 --> 04:49:42,500
Oops.

4500
04:49:47,300 --> 04:49:48,800
Sorry, day, 3, for X.

4501
04:49:51,200 --> 04:49:57,600
I guess it's the same, in either case, I guess, but will will do both.

4502
04:50:01,600 --> 04:50:02,200
Here we go.

4503
04:50:02,700 --> 04:50:05,800
So there's our eight core with four wide Lanes.

4504
04:50:06,500 --> 04:50:09,300
Oh, where's the worst?

4505
04:50:09,300 --> 04:50:11,700
The additional data here?

4506
04:50:15,400 --> 04:50:16,400
I won't do that again.

4507
04:50:19,900 --> 04:50:23,100
All right, so let's try this again.

4508
04:50:23,100 --> 04:50:25,000
If I do build dot rate a test

4509
04:50:36,100 --> 04:50:37,300
Now, we should have this one should?

4510
04:50:37,300 --> 04:50:37,900
Yeah, there we go.

4511
04:50:37,900 --> 04:50:39,400
This is our 4 wide Lanes.

4512
04:50:50,600 --> 04:50:54,200
Right, and now I should be able to do the 8 wide lens.

4513
04:51:14,000 --> 04:51:16,100
It has to be equivalent to me.

4514
04:51:16,400 --> 04:51:17,100
That's good.

4515
04:51:23,700 --> 04:51:24,600
There's r8x.

4516
04:51:27,200 --> 04:51:27,600
Done.

4517
04:51:29,600 --> 04:51:33,100
So there's the Forex version, there's the 8 X version.

4518
04:51:38,800 --> 04:51:40,200
And again, not bad.

4519
04:51:40,500 --> 04:51:42,700
Getting it down to pretty low / bounce.

4520
04:51:43,100 --> 04:51:46,400
Plenty of room left there, probably for improvement but you know it's

4521
04:51:46,400 --> 04:51:47,100
not awful.

4522
04:51:48,300 --> 04:51:50,600
And the raycasting time continues to go down.

4523
04:51:50,600 --> 04:51:52,300
We're down from eight seconds.

4524
04:51:52,300 --> 04:51:53,400
25 seconds.

4525
04:51:54,300 --> 04:51:56,800
I think before we were at something like 17 seconds

4526
04:52:01,300 --> 04:52:02,200
so that's pretty good.

4527
04:52:03,600 --> 04:52:04,300
That's pretty good.

4528
04:52:07,300 --> 04:52:08,600
I'm happy with that.

4529
04:52:30,000 --> 04:52:31,900
Alright, that's about it for today.

4530
04:52:32,000 --> 04:52:33,300
I'm pretty happy with that.

4531
04:52:33,400 --> 04:52:40,200
That's a fun little raytracer there and I feel like we're in good

4532
04:52:40,200 --> 04:52:41,400
shape to next time.

4533
04:52:41,600 --> 04:52:47,400
We end up doing a handmade re playing around with the light transport

4534
04:52:47,400 --> 04:52:50,300
and building some better illumination stuff, right?

4535
04:52:50,300 --> 04:52:55,700
Like just making a nicer scene to play with and try to bounce the

4536
04:52:55,700 --> 04:52:58,500
light around in a more realistic fashion using

4537
04:52:58,600 --> 04:53:02,200
Some actual surface functions that aren't completely wrong.

4538
04:53:04,700 --> 04:53:05,700
So that's about it.

4539
04:53:07,300 --> 04:53:08,600
I'm going to go ahead and close this up.

4540
04:53:11,000 --> 04:53:11,800
Like so.

4541
04:53:21,400 --> 04:53:22,800
And and but why not?

4542
04:53:22,800 --> 04:53:25,900
I can't do zvx titled now because this chip doesn't support it.

4543
04:53:29,300 --> 04:53:30,700
This chip doesn't support it.

4544
04:53:31,500 --> 04:53:35,300
I wish if x 512 have been out I wish you'd been out a long time ago.

4545
04:53:36,000 --> 04:53:37,700
I wish you did had scattered gather.

4546
04:53:39,200 --> 04:53:42,400
I wish a lot of things about the Intel instruction set, but you know,

4547
04:53:42,400 --> 04:53:43,000
what?

4548
04:53:43,000 --> 04:53:44,700
Whistling ain't silicon.

4549
04:53:45,200 --> 04:53:47,800
So you can't make silicon out of wishes.

4550
04:53:48,200 --> 04:53:49,200
I guess is the rule.

4551
04:53:49,200 --> 04:53:54,600
So, you know until we actually get desktop Hardware that has a Vicks

4552
04:53:54,600 --> 04:53:58,900
512 reliably which even I9 doesn't apparently have.

4553
04:54:01,900 --> 04:54:02,600
Off we go.

4554
04:54:04,200 --> 04:54:05,300
So that's it for today.

4555
04:54:06,800 --> 04:54:09,400
Thanks everyone for joining me for this episode of handmade hero.

4556
04:54:09,400 --> 04:54:10,400
That was handmade re-up.

4557
04:54:10,400 --> 04:54:14,100
So technically I'm going to close down asking you on the stream if

4558
04:54:14,100 --> 04:54:19,500
they had any pauses or stuff that they noticed next week will resume

4559
04:54:19,500 --> 04:54:22,000
regular handmade hero until then.

4560
04:54:22,100 --> 04:54:25,800
Please have fun programming and I'll see everyone on the internet.

4561
04:54:25,900 --> 04:54:26,900
Take it easy, everybody.

