1
00:00:00,000 --> 00:00:01,500
The start recording button.

2
00:00:01,800 --> 00:00:02,500
There we go.

3
00:00:03,200 --> 00:00:04,600
And the stream has begun.

4
00:00:04,600 --> 00:00:07,800
Okay, everyone welcome to gosh.

5
00:00:07,800 --> 00:00:09,000
I think it is day 14.

6
00:00:09,000 --> 00:00:12,000
It is day 14 of handmade hero.

7
00:00:12,400 --> 00:00:17,800
The the show, where we code and entire game from scratch live on the

8
00:00:17,800 --> 00:00:18,400
internet.

9
00:00:19,600 --> 00:00:23,700
Basically, using only using only our wits and Ingenuity which are

10
00:00:23,700 --> 00:00:26,100
sometimes lacking, you know, it can happen.

11
00:00:26,400 --> 00:00:29,900
But we do the best we can and we're making pretty good progress.

12
00:00:30,000 --> 00:00:30,700
Yes, I daresay.

13
00:00:30,700 --> 00:00:31,500
Today.

14
00:00:31,700 --> 00:00:35,800
What I want to talk about mostly is memory management, or at least the

15
00:00:35,800 --> 00:00:38,200
beginnings of a philosophy of memory management.

16
00:00:38,200 --> 00:00:40,000
We're obviously going to talk about it quite a bit throughout the

17
00:00:40,000 --> 00:00:42,700
entire stream as the need arises.

18
00:00:43,300 --> 00:00:44,800
But basically that's we're going to talk about today.

19
00:00:44,800 --> 00:00:47,600
If you have pre-ordered, the game and are following along with the

20
00:00:47,600 --> 00:00:48,400
source code.

21
00:00:48,900 --> 00:00:50,000
This is day 14.

22
00:00:50,000 --> 00:00:54,800
So you want to unzip day 13 source, and that is what you will start

23
00:00:54,800 --> 00:00:54,900
with.

24
00:00:54,900 --> 00:00:57,100
That is what I am starting with today.

25
00:00:57,100 --> 00:00:59,900
So, so let me tell

26
00:01:00,000 --> 00:01:05,500
Tell you about why I think now is the time to start talking about

27
00:01:05,500 --> 00:01:06,800
memory management.

28
00:01:07,000 --> 00:01:09,800
One of the things that you will notice so far in the Stream is we

29
00:01:09,800 --> 00:01:15,200
haven't done any memory management and that is a good thing.

30
00:01:15,500 --> 00:01:21,400
So basically, if you look in here, this is actually kind of a typical

31
00:01:21,400 --> 00:01:25,800
nowadays, you know, most programs, most programming, languages, most

32
00:01:25,800 --> 00:01:28,400
anything you cannot.

33
00:01:29,000 --> 00:01:29,800
You cannot really.

34
00:01:29,900 --> 00:01:33,800
We get into Maine without allocating a ton of memory crazy garbage

35
00:01:33,800 --> 00:01:34,300
collection.

36
00:01:34,300 --> 00:01:38,700
God knows what's going on, you know, you fire up a PG pH sorry, PHP

37
00:01:38,700 --> 00:01:41,600
program, which I was having to deal with over the weekend.

38
00:01:41,600 --> 00:01:44,900
In fact, for the forums, you fire up a PHP programming, God only knows

39
00:01:44,900 --> 00:01:47,200
how much memory is getting allocated and freed on every line.

40
00:01:47,200 --> 00:01:49,000
I mean, it's just crazy town, right?

41
00:01:49,000 --> 00:01:49,300
Memory.

42
00:01:49,300 --> 00:01:51,500
Allocation is just a willy nilly thing these days.

43
00:01:52,100 --> 00:01:53,800
It's just it's just full banana cakes.

44
00:01:54,100 --> 00:01:56,400
And so, one of the things I'd like to point out is we have done no

45
00:01:56,400 --> 00:01:57,500
memory management so far.

46
00:01:57,500 --> 00:01:59,800
Basically, all we did was we needed a sounding

47
00:02:00,000 --> 00:02:03,400
Buffer and we needed a bitmap buffer.

48
00:02:03,400 --> 00:02:06,200
So we just ask the operating system for to flatbuffers.

49
00:02:06,200 --> 00:02:07,100
We never free them.

50
00:02:07,200 --> 00:02:10,500
They're just there forever and they're used but our program is

51
00:02:10,500 --> 00:02:13,800
completely stable in the memory sense because of that.

52
00:02:13,800 --> 00:02:15,200
There, it just runs forever.

53
00:02:15,200 --> 00:02:17,300
You're never worried about if you, there's no such thing as running

54
00:02:17,300 --> 00:02:19,400
out of memory in this program, for the most part.

55
00:02:19,700 --> 00:02:22,400
If it starts at all, it's good to go.

56
00:02:22,400 --> 00:02:23,000
Right?

57
00:02:23,300 --> 00:02:25,600
And that's a pretty interesting thing to think about, for a second.

58
00:02:28,800 --> 00:02:34,100
Because technically any time you do a memory allocation, you have

59
00:02:34,100 --> 00:02:37,300
introduced a failure Point into your program, right?

60
00:02:37,300 --> 00:02:38,800
Memory is a limited resource.

61
00:02:39,400 --> 00:02:43,200
And basically every time you do a memory a lock it could fail and so

62
00:02:43,200 --> 00:02:46,600
if the result of that memory allocation was important to you you

63
00:02:46,600 --> 00:02:50,400
basically have to handle that or just acknowledge the fact that your

64
00:02:50,400 --> 00:02:54,000
program better run on essentially an infinite memory device now.

65
00:02:54,300 --> 00:02:58,000
Fortunately these days a lot of times you are on what is effectively

66
00:02:58,000 --> 00:02:58,400
an infinite.

67
00:02:58,600 --> 00:02:59,900
Memory device for all intents and purposes.

68
00:03:00,000 --> 00:03:02,800
Is you probably won't be able to allocate enough memory to force

69
00:03:02,800 --> 00:03:07,000
Windows to run out of its own virtual backing store, but you certainly

70
00:03:07,000 --> 00:03:10,100
can hit circumstances where you will, you know, start thrashing and

71
00:03:10,100 --> 00:03:12,700
stuff as the virtual memory starts paging and all these other sorts of

72
00:03:12,700 --> 00:03:13,100
things.

73
00:03:13,200 --> 00:03:14,900
There's all sorts of masses involved there.

74
00:03:14,900 --> 00:03:17,300
And also, what can I say?

75
00:03:17,700 --> 00:03:20,800
This is an old school programming stream and in my mind, I kind of

76
00:03:20,800 --> 00:03:25,500
like to think about what it means to have programs that that don't

77
00:03:25,500 --> 00:03:26,600
have those failure cases.

78
00:03:26,600 --> 00:03:29,800
That just then just aren't going to fail if they start.

79
00:03:30,000 --> 00:03:32,200
They will run to completion and they will never fail.

80
00:03:32,200 --> 00:03:33,800
I like that idea.

81
00:03:34,000 --> 00:03:35,200
It's fun for me.

82
00:03:35,400 --> 00:03:39,600
And in case you haven't noticed, a lot about what the stream, a lot of

83
00:03:39,600 --> 00:03:42,900
what this stream is about, is making programming fun again for people

84
00:03:42,900 --> 00:03:48,000
who really like to kind of get in there and, and sort of do the real

85
00:03:48,300 --> 00:03:51,300
sort of work of like coding, something, meticulously, and doing

86
00:03:51,300 --> 00:03:52,200
something interesting.

87
00:03:52,700 --> 00:03:56,800
And so to me, I really like thinking about things that a cot different

88
00:03:56,800 --> 00:03:59,700
level than what a most people like to think about.

89
00:04:00,000 --> 00:04:03,200
I tend to like to think about it is, can we just never do any mail and

90
00:04:03,200 --> 00:04:04,000
memory allocation at?

91
00:04:04,000 --> 00:04:04,300
All?

92
00:04:04,600 --> 00:04:04,900
Right.

93
00:04:04,900 --> 00:04:08,000
Can we just never actually allocate any memory?

94
00:04:08,400 --> 00:04:11,600
And so one of the things that I guess might be slightly surprising to

95
00:04:11,600 --> 00:04:17,500
people as we go forward here is, I don't really anticipate us doing

96
00:04:17,600 --> 00:04:18,800
memory allocation.

97
00:04:19,100 --> 00:04:23,300
Basically, what we are going to do is we are going to do sort of an

98
00:04:23,300 --> 00:04:27,400
old-school flat partition where we just grab a chunk of memory.

99
00:04:27,400 --> 00:04:28,100
At the beginning.

100
00:04:28,700 --> 00:04:29,800
We pre decided.

101
00:04:29,900 --> 00:04:30,300
Side.

102
00:04:30,300 --> 00:04:34,400
How much space we're going to allow each thing to use each subsystem

103
00:04:34,400 --> 00:04:37,700
to use and then those subsystems are going to be written such that

104
00:04:37,700 --> 00:04:39,800
they must run in that space.

105
00:04:39,900 --> 00:04:43,600
So it is not a question of memory, allocation down the road.

106
00:04:43,600 --> 00:04:44,800
It is just a question of.

107
00:04:44,800 --> 00:04:50,000
They are hard written to never be able to go outside of a boundary

108
00:04:50,000 --> 00:04:50,900
that you give them.

109
00:04:51,000 --> 00:04:51,900
Does that make sense.

110
00:04:53,000 --> 00:04:55,100
I know that might sound a little odd for people, aren't used to it.

111
00:04:55,100 --> 00:04:58,100
People who are used to it old school, arcade, programmers and stuff

112
00:04:58,100 --> 00:04:59,300
are like, yeah, that's what we do.

113
00:05:00,200 --> 00:05:02,200
Obviously these days, that's not typical.

114
00:05:02,200 --> 00:05:04,700
So anyway, I'm going to go that route.

115
00:05:04,700 --> 00:05:06,700
And so the techniques that I'll be showing you are going to be very

116
00:05:06,700 --> 00:05:10,400
different from what you're used to seeing in most.

117
00:05:10,400 --> 00:05:13,100
I would say programming literature these days, but I think that's a

118
00:05:13,100 --> 00:05:16,500
good thing because yeah, I like to I like to show kind of different

119
00:05:16,500 --> 00:05:17,300
ways to do things.

120
00:05:17,600 --> 00:05:19,400
I'm not trying to tell you to do it this way.

121
00:05:19,500 --> 00:05:20,800
Like I say on a lot of streams.

122
00:05:20,800 --> 00:05:25,500
I'm just telling you how I like to do it and certainly almost every

123
00:05:25,500 --> 00:05:27,800
game that shifts today doesn't do it this way.

124
00:05:28,100 --> 00:05:29,400
Most of them are allocation.

125
00:05:29,900 --> 00:05:33,800
Eels, but, you know, it's good to have different perspectives.

126
00:05:36,000 --> 00:05:37,300
So, let's jump into things here.

127
00:05:38,800 --> 00:05:41,600
Why do I even think we need to start talking about memory allocation.

128
00:05:41,600 --> 00:05:43,900
Now, we had this little program running, it essentially doesn't really

129
00:05:43,900 --> 00:05:45,800
do any memory allocation doesn't ever free.

130
00:05:45,800 --> 00:05:48,300
Anything and doesn't really need to allocate anything on any given

131
00:05:48,300 --> 00:05:48,700
frame.

132
00:05:49,200 --> 00:05:51,100
So why am I saying now is the time?

133
00:05:51,300 --> 00:05:52,700
Why do I think that's true?

134
00:05:53,100 --> 00:05:54,800
Well, it's because of this stuff right here.

135
00:05:55,100 --> 00:05:58,000
Basically what I did is to get this working while we were sort of

136
00:05:59,100 --> 00:05:59,800
playing around.

137
00:06:00,000 --> 00:06:03,700
Your platform API is, I said, well, we've got these local persists

138
00:06:03,700 --> 00:06:06,100
here, which remember is just static and see, it's something I've

139
00:06:06,100 --> 00:06:09,800
defined so we can see what it is when we grep for things, because

140
00:06:09,800 --> 00:06:12,100
static has three meanings at least in.

141
00:06:12,100 --> 00:06:14,700
See, if not more, especially when you consider C++.

142
00:06:14,700 --> 00:06:15,600
There's even more meanings.

143
00:06:15,600 --> 00:06:17,400
It's just a keyword that's really overloaded.

144
00:06:17,400 --> 00:06:20,200
And so what I like to do is kind of get that down so you can rap for

145
00:06:20,200 --> 00:06:20,300
it.

146
00:06:20,300 --> 00:06:23,300
So local persist just means that this is essentially a global

147
00:06:23,300 --> 00:06:23,700
variable.

148
00:06:23,700 --> 00:06:26,100
It's you know, it's more or less like I put it out here.

149
00:06:26,400 --> 00:06:28,800
The only thing that's different is its scope just to this function.

150
00:06:28,800 --> 00:06:29,800
So it's kind of like a less.

151
00:06:30,000 --> 00:06:33,200
Less obtrusive Global variable but it's still basically that and I

152
00:06:33,200 --> 00:06:36,300
don't really like to have that sort of thing lying around.

153
00:06:36,300 --> 00:06:36,800
Certainly.

154
00:06:36,800 --> 00:06:40,200
I'm not going to be able to do that for all the stuff we need because

155
00:06:40,200 --> 00:06:42,100
that would be kind of a little bit absurd.

156
00:06:42,100 --> 00:06:46,600
You know, I'm trying to think if what you would, what would happen if

157
00:06:46,600 --> 00:06:51,100
I just typed in to see right here, a local, persist persistent local

158
00:06:51,100 --> 00:06:51,600
variable.

159
00:06:51,600 --> 00:06:54,100
That was like, you know, four gigabytes of memory.

160
00:06:54,300 --> 00:06:56,800
I have no idea what would happen there, but I don't expect it would be

161
00:06:56,800 --> 00:06:57,200
good.

162
00:06:58,800 --> 00:07:04,900
So point being, if we want this game to have some stuff like say a

163
00:07:04,900 --> 00:07:09,900
large backing store for for images that are getting loaded off disk

164
00:07:09,900 --> 00:07:12,200
our stuff and we're talking about allocating like a gigabyte of memory

165
00:07:12,200 --> 00:07:13,800
to store stuff in or any of that sort of stuff.

166
00:07:13,800 --> 00:07:16,200
We actually need to get ourselves some memory here.

167
00:07:16,200 --> 00:07:21,200
And so I figured, I might as well go get to that point now where we're

168
00:07:21,200 --> 00:07:24,700
actually storing our game State because we do have some game state

169
00:07:24,700 --> 00:07:26,900
blue offset green and offset and tone hurt.

170
00:07:26,900 --> 00:07:28,700
So let's just pretend that that's

171
00:07:28,800 --> 00:07:32,900
Real game State, and not some tests game State and start to see how,

172
00:07:32,900 --> 00:07:33,900
where are we going to put that?

173
00:07:33,900 --> 00:07:35,200
How's that going to get stored?

174
00:07:35,200 --> 00:07:36,100
How's that going to work?

175
00:07:36,100 --> 00:07:36,500
Now?

176
00:07:36,700 --> 00:07:37,100
I'll show you.

177
00:07:37,100 --> 00:07:40,800
Basically, what would normally happen in a normal scenario?

178
00:07:41,200 --> 00:07:44,200
That is not being coded in the way that I'm advocating coding.

179
00:07:44,200 --> 00:07:45,900
Because I like to show you kind of the other way first.

180
00:07:45,900 --> 00:07:48,700
So what would normally happen in a lot of circumstances is you would

181
00:07:48,700 --> 00:07:51,200
see something that looks a lot like this.

182
00:07:51,200 --> 00:07:57,000
Let's say, say game startup, so there might be a call like game

183
00:07:57,000 --> 00:07:58,300
startup that we call.

184
00:07:58,800 --> 00:08:01,200
It's got a game state that it returns.

185
00:08:01,200 --> 00:08:01,800
Right?

186
00:08:01,900 --> 00:08:05,600
And what it's going to do is it's going to allocate one of these so

187
00:08:05,600 --> 00:08:07,500
it's going to call an allocation function.

188
00:08:07,500 --> 00:08:08,800
So maybe that's Malik.

189
00:08:08,800 --> 00:08:11,800
Maybe that's a lot of in a lot of cases that would be because it's be

190
00:08:11,800 --> 00:08:15,600
C++ code, it would call new which allocates memory.

191
00:08:19,700 --> 00:08:21,000
If not told to do otherwise.

192
00:08:22,500 --> 00:08:24,500
Basically, what would happen is, it would new the game state?

193
00:08:24,500 --> 00:08:25,200
It would check here.

194
00:08:25,200 --> 00:08:28,000
Hopefully to see whether the game State actually got allocated

195
00:08:28,000 --> 00:08:28,600
properly.

196
00:08:28,900 --> 00:08:30,700
It would fill out some stuff in the game state.

197
00:08:30,700 --> 00:08:31,800
So it would do something like this.

198
00:08:31,800 --> 00:08:34,400
Let's say, we have blue offset here.

199
00:08:34,799 --> 00:08:36,100
We'd have green offset here.

200
00:08:36,100 --> 00:08:39,500
And you have to imagine if this is a real game, which this will be in

201
00:08:39,500 --> 00:08:40,200
a couple months.

202
00:08:40,200 --> 00:08:43,400
We will have a lot of serious stuff going on in here.

203
00:08:43,700 --> 00:08:46,100
So you have to imagine if this were the real game already, there would

204
00:08:46,100 --> 00:08:47,500
be a lot of stuff in here.

205
00:08:47,500 --> 00:08:50,100
Not just these three things, but point being it would start up and it

206
00:08:50,100 --> 00:08:52,100
would initialize anything that in need to initialize.

207
00:08:52,300 --> 00:08:55,200
Is to whatever a need to initialize it to then.

208
00:08:55,200 --> 00:08:57,200
At the end, it would return this game State structure.

209
00:08:57,200 --> 00:08:59,900
And that would basically be sort of like creating.

210
00:09:00,000 --> 00:09:02,000
A game, it's like, the Constructor for the game.

211
00:09:02,000 --> 00:09:05,000
And if you were a C++ person this way, actually would be a Constructor

212
00:09:05,000 --> 00:09:06,100
for the gamestate object.

213
00:09:06,100 --> 00:09:09,100
For example, you could go many layers, deep into this.

214
00:09:09,100 --> 00:09:11,300
And then later, they'd be something like this.

215
00:09:11,300 --> 00:09:13,700
We'd have something called game shut down.

216
00:09:13,700 --> 00:09:17,100
Probably it would take the game state right in here.

217
00:09:17,100 --> 00:09:17,300
Right?

218
00:09:17,300 --> 00:09:21,200
And then, we would go ahead and we would, we would delete the game

219
00:09:21,200 --> 00:09:22,300
state, right?

220
00:09:22,300 --> 00:09:25,800
Like that, something like this and then game update, and render would

221
00:09:25,800 --> 00:09:29,000
take the game State as a pointer like this, right?

222
00:09:29,000 --> 00:09:30,000
And then, from then,

223
00:09:30,000 --> 00:09:30,300
N on.

224
00:09:30,300 --> 00:09:33,500
It would basically be fine because we would just use those things.

225
00:09:33,800 --> 00:09:37,600
Basically, we use the game State like this, so you can kind of see how

226
00:09:37,600 --> 00:09:38,600
I pulled that out there.

227
00:09:38,600 --> 00:09:41,700
You can see how I kind of got rid of those global variables by just

228
00:09:41,700 --> 00:09:45,800
pulling them out into a struct basically and that strut, you know, we

229
00:09:45,800 --> 00:09:48,700
would Define out here as like, the game State thing, right?

230
00:09:48,700 --> 00:09:52,800
So we'd say something, I'm actually not going to separate that to do

231
00:09:52,800 --> 00:09:53,700
from its thing there.

232
00:09:53,800 --> 00:09:58,100
So basically, we would have something that looks like this and it

233
00:09:58,100 --> 00:09:59,700
would have our variables in there.

234
00:09:59,700 --> 00:09:59,800
Are

235
00:10:00,000 --> 00:10:04,300
No, one hurts our green offset and our blue offset, right?

236
00:10:04,300 --> 00:10:06,300
That's that's all that I'm talking about here.

237
00:10:06,600 --> 00:10:07,500
So that's it.

238
00:10:07,500 --> 00:10:12,100
That's like how that would normally go will compile that there and

239
00:10:12,100 --> 00:10:13,600
then this guy would have to pass it.

240
00:10:13,900 --> 00:10:20,800
So what I want you to see about this method is basically and and to

241
00:10:20,800 --> 00:10:23,800
extend it a little further, everything in the game would look like

242
00:10:23,800 --> 00:10:24,300
this.

243
00:10:24,400 --> 00:10:27,300
Whenever you wanted to do something like you wanted to create a game

244
00:10:27,300 --> 00:10:29,800
asset, you would do something like this you'd have

245
00:10:29,900 --> 00:10:32,500
Game asset equals new game assets.

246
00:10:32,500 --> 00:10:33,600
Not kind of a thing, right?

247
00:10:33,600 --> 00:10:34,400
Something like this.

248
00:10:34,500 --> 00:10:38,000
You'd pass maybe a filename to load it from this would do some stuff.

249
00:10:38,000 --> 00:10:40,800
It would allocate that game asset, right?

250
00:10:40,800 --> 00:10:41,800
It's game assert.

251
00:10:41,800 --> 00:10:44,200
That's a nice typo, game asset.

252
00:10:44,400 --> 00:10:47,200
It would allocate that here, you know, this sort of thing.

253
00:10:47,300 --> 00:10:49,800
It would return it, right?

254
00:10:49,800 --> 00:10:53,000
Like this, and then you have a corresponding free call that would

255
00:10:53,000 --> 00:10:53,800
release it.

256
00:10:54,000 --> 00:10:57,500
So you're basically our your code just it would be littered with news

257
00:10:57,500 --> 00:10:59,400
and deletes and this is very typical.

258
00:10:59,900 --> 00:11:02,800
I don't know what the status is of, say Unreal, Engine 4, but I

259
00:11:02,800 --> 00:11:04,400
remember like with, at least with Unreal Engine 3.

260
00:11:04,400 --> 00:11:06,000
It's like, news and deletes are everywhere.

261
00:11:06,000 --> 00:11:08,700
There's all kinds of this sort of memory allocation going on.

262
00:11:08,800 --> 00:11:11,400
It's crazy town in an inside, a given frame.

263
00:11:11,400 --> 00:11:14,400
There's tons of news and deletes and all of those are technically,

264
00:11:14,400 --> 00:11:17,300
failure points and most of them probably wouldn't get handled

265
00:11:17,300 --> 00:11:17,800
properly.

266
00:11:17,800 --> 00:11:20,400
Maybe they would, maybe they wouldn't, but it's just kind of assumed

267
00:11:20,500 --> 00:11:22,900
for the most part that they aren't going to fail.

268
00:11:22,900 --> 00:11:26,400
Because either, you know, you've kind of, you know, roughly how much

269
00:11:26,400 --> 00:11:27,200
memory you need.

270
00:11:27,200 --> 00:11:29,400
And, you know, you kind of know that you're running in that much

271
00:11:29,400 --> 00:11:29,800
memory.

272
00:11:29,900 --> 00:11:33,000
Or stuff like this, or they start to do things like they overload new

273
00:11:33,000 --> 00:11:35,900
to like, you know, handle allocations in special ways.

274
00:11:35,900 --> 00:11:36,900
All these are the sorts of things.

275
00:11:36,900 --> 00:11:40,700
So basically like that's just typical and it's typical even in

276
00:11:40,700 --> 00:11:41,300
high-end code.

277
00:11:41,300 --> 00:11:44,300
So I'm not I'm not trying to say that this is something not to do.

278
00:11:44,300 --> 00:11:47,600
I'm just, I'm just gonna say this is not what we're going to do.

279
00:11:48,500 --> 00:11:53,400
So that's basically what what tends to happen in a lot of typical game

280
00:11:53,600 --> 00:11:55,100
code these days, right?

281
00:11:55,700 --> 00:11:57,800
So reasons why I don't love this.

282
00:12:01,200 --> 00:12:04,100
The first reason is because you got to have a strategy for the failure

283
00:12:04,100 --> 00:12:04,900
cases, right?

284
00:12:06,200 --> 00:12:08,300
Either, you going to have to handle it.

285
00:12:08,300 --> 00:12:14,100
Somehow one way is basically, you just say, all right, everywhere that

286
00:12:14,100 --> 00:12:17,700
we do a new or an A, like we check for failure and we actually handle

287
00:12:17,700 --> 00:12:19,600
the failure, propagating all the way out.

288
00:12:19,900 --> 00:12:21,200
That's difficult.

289
00:12:21,200 --> 00:12:21,500
Right?

290
00:12:21,500 --> 00:12:25,600
That is, that is tricky in a lot of cases, because now you got all

291
00:12:25,600 --> 00:12:28,400
these paths that can both fail and succeed and you got to know how

292
00:12:28,400 --> 00:12:29,100
each of them Works.

293
00:12:29,100 --> 00:12:29,900
What happens if I

294
00:12:30,000 --> 00:12:31,400
Didn't get a game asset and I needed to.

295
00:12:31,400 --> 00:12:34,100
In this case, what happens if the this particular system couldn't

296
00:12:34,100 --> 00:12:36,000
start up because of memory, whatever do I just do?

297
00:12:36,000 --> 00:12:36,400
I panic?

298
00:12:36,400 --> 00:12:37,200
What do I do there?

299
00:12:37,300 --> 00:12:38,400
But you got to have a story.

300
00:12:39,100 --> 00:12:40,100
Another story might be.

301
00:12:40,100 --> 00:12:42,000
Oh, well, we ran the game, lots of times.

302
00:12:42,000 --> 00:12:44,400
I mean, look at how much it used and we always make sure we get that

303
00:12:44,400 --> 00:12:47,700
much on Startup and we use our own allocator that's of allocates out

304
00:12:47,700 --> 00:12:48,000
of there.

305
00:12:48,000 --> 00:12:51,900
And we just know from having ran it multiple times, that we know that

306
00:12:51,900 --> 00:12:53,800
it just doesn't overrun this much memory.

307
00:12:54,200 --> 00:12:54,900
We hope.

308
00:12:54,900 --> 00:12:57,200
And we just hope the player doesn't do something that we didn't think

309
00:12:57,200 --> 00:12:58,000
of, who knows?

310
00:12:58,200 --> 00:12:59,100
But you gotta have a story.

311
00:12:59,100 --> 00:12:59,800
There's some story

312
00:13:00,100 --> 00:13:02,600
Sometimes the story and there's plenty of games that ship and this is

313
00:13:02,600 --> 00:13:03,200
the story.

314
00:13:03,200 --> 00:13:04,700
The story is, we have no idea.

315
00:13:04,900 --> 00:13:07,900
The story is just, we just don't know, it doesn't seem to run out of

316
00:13:07,900 --> 00:13:09,800
memory when we've tested it.

317
00:13:09,800 --> 00:13:11,000
So that's all we've got.

318
00:13:13,300 --> 00:13:17,100
And those are all not my favorite answers so so I don't really love

319
00:13:17,100 --> 00:13:17,500
that.

320
00:13:17,600 --> 00:13:18,700
That's one downside.

321
00:13:19,300 --> 00:13:23,600
But there's another downside that even people who who think that I'm

322
00:13:23,600 --> 00:13:27,500
crazy about memory might agree with in a separate context as nothing

323
00:13:27,500 --> 00:13:29,100
to do with that at all.

324
00:13:29,300 --> 00:13:33,900
And basically, what that is, is it adds another loop back to your

325
00:13:33,900 --> 00:13:34,900
platform abstraction.

326
00:13:34,900 --> 00:13:37,200
And one of the things that I was talking about before is like one of

327
00:13:37,200 --> 00:13:40,100
the reasons that I like doing the platform attraction this way and

328
00:13:40,100 --> 00:13:41,700
like I said, almost nobody

329
00:13:41,900 --> 00:13:42,400
Does it this way.

330
00:13:42,400 --> 00:13:45,600
But the basically the way where it's just, it's to data pipes in and

331
00:13:45,600 --> 00:13:45,800
out.

332
00:13:45,800 --> 00:13:51,200
And you're trying to, basically minimize the cases where you ever do a

333
00:13:51,200 --> 00:13:52,500
round trip through the game.

334
00:13:52,600 --> 00:13:55,600
You pretty much just want the game to be a service to the platform or

335
00:13:55,600 --> 00:13:58,200
the platform just says, I need the, I need the video frame.

336
00:13:58,200 --> 00:13:59,000
I need the audio.

337
00:13:59,000 --> 00:14:02,000
That's like what you're looking for, and it pushes down the input to

338
00:14:02,000 --> 00:14:02,200
it.

339
00:14:02,200 --> 00:14:03,500
Just as here's the input.

340
00:14:03,700 --> 00:14:05,100
So, there isn't called.

341
00:14:05,100 --> 00:14:08,900
There isn't like any time when the platform calls the game calls the

342
00:14:08,900 --> 00:14:11,700
platform again, just to get rid it to completely get rid.

343
00:14:11,800 --> 00:14:16,200
Rid of that round tripping because again, that round-tripping is what

344
00:14:16,200 --> 00:14:19,200
creates complexity in terms of understanding how the platform and the

345
00:14:19,200 --> 00:14:22,100
game layer relate to each other, and it means that if you want to do

346
00:14:22,100 --> 00:14:25,700
some more advanced things like say, recording the entire session of a

347
00:14:25,700 --> 00:14:28,400
game and playing it back for debugging purposes.

348
00:14:29,100 --> 00:14:32,000
If you know that you have one defined input stream and one defined

349
00:14:32,000 --> 00:14:33,200
output stream kind of a thing.

350
00:14:33,500 --> 00:14:36,300
It's a lot easier to do that sort of thing.

351
00:14:36,300 --> 00:14:36,900
Right?

352
00:14:37,500 --> 00:14:41,700
And so unfortunately that argument is a lot weaker these days now,

353
00:14:41,800 --> 00:14:43,100
Multi-core is such a thing.

354
00:14:43,100 --> 00:14:46,500
It becomes extremely difficult to do playback systems properly because

355
00:14:46,500 --> 00:14:47,400
of all the threading stuff.

356
00:14:47,400 --> 00:14:49,600
So it's the least of your worries.

357
00:14:49,600 --> 00:14:51,800
The thing I just said about but in the old days when things were

358
00:14:51,800 --> 00:14:54,900
single-threaded, this was definitely a huge win in terms of playback.

359
00:14:57,800 --> 00:14:59,800
Not so much anymore because you got yellow.

360
00:15:00,000 --> 00:15:02,600
Headaches, you got to worry about in that situation.

361
00:15:02,600 --> 00:15:03,100
So

362
00:15:04,200 --> 00:15:05,400
What's the alternative to this?

363
00:15:05,400 --> 00:15:08,200
What do I propose if I don't think this is good idea.

364
00:15:08,800 --> 00:15:13,400
Well, what I'm going to do instead is I'm going to do exactly the same

365
00:15:13,400 --> 00:15:13,700
tack.

366
00:15:13,700 --> 00:15:17,500
I took before and just say, well, if the game wants memory, then the

367
00:15:17,500 --> 00:15:20,700
game gets memory from the platform layer in a big old chunk at startup

368
00:15:20,700 --> 00:15:23,100
and the game is responsible for doing everything else.

369
00:15:23,100 --> 00:15:23,600
Right?

370
00:15:23,800 --> 00:15:26,800
Basically, I'm just going to say, you know what, we just pass in a big

371
00:15:26,800 --> 00:15:28,400
ol thing here called game memory.

372
00:15:29,000 --> 00:15:32,400
And that's just a, that's just a struct, right?

373
00:15:32,400 --> 00:15:33,600
And that struct is going to

374
00:15:34,600 --> 00:15:39,800
Basically stuff in it that allows us to allocate what we need.

375
00:15:39,900 --> 00:15:42,600
Dude, are partitioning on the game side and then all that's going to

376
00:15:42,600 --> 00:15:43,100
happen.

377
00:15:44,600 --> 00:15:47,900
Is the platform layer is going to call one, or it can cause major

378
00:15:47,900 --> 00:15:53,100
wants really virtual Alex at startup to get our memory space set up.

379
00:15:53,300 --> 00:15:55,000
And then once it is set up, that's it.

380
00:15:55,100 --> 00:15:56,300
It just gets passed to the game.

381
00:15:56,300 --> 00:15:59,100
The game is responsible for sub partitioning that memory and it is

382
00:15:59,100 --> 00:16:01,200
responsible for ensuring that all of its systems.

383
00:16:02,000 --> 00:16:07,300
Always operate inside a fixed space so they can be pre partitioned at

384
00:16:07,300 --> 00:16:08,000
startup.

385
00:16:08,000 --> 00:16:11,900
And you know that if that if the game started up at all, it will run

386
00:16:11,900 --> 00:16:14,200
to completion period and

387
00:16:14,400 --> 00:16:16,300
Is and and will be also seeing that.

388
00:16:16,300 --> 00:16:19,700
I will take the same tack with disk I/O which I realize is a little

389
00:16:19,700 --> 00:16:21,700
odd, but I'll be taking the same track with disk I/O.

390
00:16:21,700 --> 00:16:25,800
So the goal here is like there's zero failure states in the game.

391
00:16:27,000 --> 00:16:30,200
The platform layer obviously can have all kinds of failure States

392
00:16:30,400 --> 00:16:33,600
because the operating system is not built with a similar philosophy.

393
00:16:33,600 --> 00:16:35,400
The operating system is built poorly.

394
00:16:35,800 --> 00:16:36,600
It is Windows.

395
00:16:36,600 --> 00:16:39,800
It does not do a good job on any of the fronts that I'm talking about.

396
00:16:40,200 --> 00:16:43,600
And so once we get down to the platform layer, we can't create

397
00:16:43,600 --> 00:16:44,100
something that is

398
00:16:44,300 --> 00:16:44,800
Reliable.

399
00:16:44,800 --> 00:16:45,400
That's true.

400
00:16:45,600 --> 00:16:49,200
But we certainly can create the game in such a way that is 100%

401
00:16:49,200 --> 00:16:49,600
reliable.

402
00:16:49,600 --> 00:16:51,300
And that is what we will be striving for.

403
00:16:51,400 --> 00:16:55,000
We will definitely be looking as we go to hitting the highest

404
00:16:55,000 --> 00:16:55,500
Benchmark.

405
00:16:55,500 --> 00:16:57,100
We can in terms of making the game.

406
00:16:57,100 --> 00:16:59,800
So that once it starts up, it does not fail.

407
00:17:00,300 --> 00:17:03,500
And if things like disk IO fails, that just means there's Sprites

408
00:17:03,500 --> 00:17:05,800
missing but the game works, right?

409
00:17:06,099 --> 00:17:07,900
That's, that's sort of what we're going for.

410
00:17:08,300 --> 00:17:11,200
And the, you know, we'll sort of have a like gold silver bronze

411
00:17:11,200 --> 00:17:13,900
standard there and we'll see kind of How High we can hit.

412
00:17:13,900 --> 00:17:14,200
Depending.

413
00:17:14,400 --> 00:17:14,900
Circumstance.

414
00:17:14,900 --> 00:17:18,300
Different games can hit that standard different levels depending on

415
00:17:18,300 --> 00:17:19,099
what they need to do.

416
00:17:20,800 --> 00:17:24,200
Basically it's a, it has to do with with space, but we'll get into

417
00:17:24,200 --> 00:17:24,700
that later.

418
00:17:24,900 --> 00:17:28,500
All right, anyway, so basically, all I want to do is I want to pass

419
00:17:28,500 --> 00:17:33,900
memory here and I'm going to say a couple things about my memory.

420
00:17:33,900 --> 00:17:37,600
Basically, what I want to do is I want to sort of subdivide this

421
00:17:37,600 --> 00:17:42,300
memory into a few different partitions.

422
00:17:42,600 --> 00:17:44,200
Basically, I want to have

423
00:17:44,300 --> 00:17:49,200
Have scratch space sort of space that is not really about storing the

424
00:17:49,200 --> 00:17:53,300
game and then in theory could kind of go away at any given time.

425
00:17:53,300 --> 00:17:59,500
So it's kind of like space that is transient and and then permanent

426
00:17:59,500 --> 00:17:59,800
stuff.

427
00:18:00,000 --> 00:18:03,600
So basically stuff that stores, the actual state of the game such that

428
00:18:04,000 --> 00:18:09,400
it definitely needs to persist as is from from one frame to the next

429
00:18:09,500 --> 00:18:12,000
because it's what holds sort of the game together.

430
00:18:12,400 --> 00:18:12,900
Right?

431
00:18:13,000 --> 00:18:16,400
And so basically what will happen here is I want to be able to store

432
00:18:16,400 --> 00:18:17,000
these things.

433
00:18:17,000 --> 00:18:19,900
The blue off, set the tone hurts, the green offset.

434
00:18:19,900 --> 00:18:22,000
Those are examples, right?

435
00:18:22,100 --> 00:18:24,700
Of things that need to be stored in the permanent store.

436
00:18:24,700 --> 00:18:26,500
And so that's really all I have right now.

437
00:18:26,900 --> 00:18:29,400
And so, basically, what I've got is I've got

438
00:18:31,000 --> 00:18:35,200
I've got a I guess I'm going to use it in 64 in case we ever want to

439
00:18:35,200 --> 00:18:36,700
be absolutely giant.

440
00:18:37,000 --> 00:18:40,600
So I'm going to say we have a un 64 which is are essentially our

441
00:18:40,600 --> 00:18:45,600
permanent storage space and then we've got a void star which is our

442
00:18:45,600 --> 00:18:46,900
permanent storage, right?

443
00:18:46,900 --> 00:18:52,800
So all I'm doing here is, I'm basically saying, well, I, I'm going to

444
00:18:52,800 --> 00:18:55,300
have some place to store.

445
00:18:55,500 --> 00:18:57,500
Well, I'm a spelling genius tonight.

446
00:18:58,000 --> 00:18:58,600
Basically.

447
00:18:59,400 --> 00:18:59,900
I'm going to

448
00:19:00,000 --> 00:19:02,600
Some place to store things that have to persist from frame to frame

449
00:19:02,600 --> 00:19:03,800
because that's what I want here.

450
00:19:04,000 --> 00:19:07,700
So all I'm going to do is I'm going to basically say, well that game

451
00:19:07,700 --> 00:19:10,500
State thing that I had, right, that I'd find before.

452
00:19:10,800 --> 00:19:11,000
Did.

453
00:19:11,000 --> 00:19:12,300
I just go ahead and delete that.

454
00:19:12,300 --> 00:19:13,000
I'm an idiot.

455
00:19:13,600 --> 00:19:14,700
That's not good at all.

456
00:19:14,700 --> 00:19:15,700
I wanted to keep that.

457
00:19:15,700 --> 00:19:16,800
I just wanted to move it.

458
00:19:16,900 --> 00:19:18,100
I didn't want to delete it.

459
00:19:18,200 --> 00:19:18,700
There we go.

460
00:19:19,500 --> 00:19:21,400
So anyway, let's get that back there.

461
00:19:21,700 --> 00:19:24,100
Game memory memory.

462
00:19:24,800 --> 00:19:25,400
There we are.

463
00:19:26,000 --> 00:19:28,900
So basically what I want to do is I'm going to take this game State

464
00:19:28,900 --> 00:19:29,800
here, right?

465
00:19:29,900 --> 00:19:32,600
Right, and I'm just going to put that inside the game memory.

466
00:19:32,600 --> 00:19:33,400
Now, I can put that here.

467
00:19:33,400 --> 00:19:36,100
I don't know if this doesn't really need to be in the the stuff that

468
00:19:36,100 --> 00:19:37,000
defines a platform.

469
00:19:37,000 --> 00:19:38,300
So I'm just going to separate that out for now.

470
00:19:38,300 --> 00:19:41,100
We'll see where I want to live later because this is not something

471
00:19:41,100 --> 00:19:44,500
that the this is not something that the winter to layer needs to know

472
00:19:44,500 --> 00:19:44,600
about.

473
00:19:44,600 --> 00:19:46,200
So think about it a little differently.

474
00:19:46,200 --> 00:19:50,100
But point being this guy is going to come in here and basically all

475
00:19:50,100 --> 00:19:52,800
I'm going to do is I'm going to say that my game state, right?

476
00:19:52,800 --> 00:19:55,800
Whatever this game state is, that's just going to equal for now.

477
00:19:55,800 --> 00:19:59,200
I'm just going to go ahead and cold-cast straight to the actual.

478
00:20:00,100 --> 00:20:02,200
That I've got for my permanent store, right?

479
00:20:03,100 --> 00:20:04,400
My permanent storage right there.

480
00:20:05,100 --> 00:20:08,000
And then what I'm going to do is I'm going to basically introduce a

481
00:20:08,000 --> 00:20:13,300
notion here and that notion is essentially, let the game memory will

482
00:20:13,300 --> 00:20:15,500
have some concept of whether or not.

483
00:20:15,500 --> 00:20:18,900
This is the first time around because obviously there's initialization

484
00:20:18,900 --> 00:20:21,500
that has to be done that initialization, that was going to have a call

485
00:20:21,500 --> 00:20:22,100
before.

486
00:20:24,200 --> 00:20:25,500
That did the round trip Alec.

487
00:20:25,500 --> 00:20:27,500
I still want to do the initialization.

488
00:20:28,000 --> 00:20:29,700
I just don't want the round tripping.

489
00:20:29,700 --> 00:20:35,000
So I'm going to say for now, I'm going to say is initialized and

490
00:20:35,000 --> 00:20:38,000
basically that's going to be false the first time through and true

491
00:20:38,000 --> 00:20:39,900
every time thereafter.

492
00:20:39,900 --> 00:20:45,600
So basically, I'm going to do here is I'm going to say if the memory

493
00:20:45,700 --> 00:20:47,500
is initialized, I should say.

494
00:20:47,500 --> 00:20:51,600
If not, then I am going to go ahead and initialize it.

495
00:20:51,900 --> 00:20:53,800
I'm going to go ahead here and say that the

496
00:20:54,100 --> 00:20:58,900
A the game State tone hurts are 256.

497
00:20:58,900 --> 00:20:59,900
And then the other

498
00:21:00,000 --> 00:21:01,300
Is let's see.

499
00:21:01,300 --> 00:21:05,600
Green offset, equals zero game state blue offset equals zero.

500
00:21:06,100 --> 00:21:08,000
And that's really all I needed to do.

501
00:21:08,000 --> 00:21:08,600
Right.

502
00:21:08,700 --> 00:21:10,500
So now, we've gotten rid of our local position.

503
00:21:10,500 --> 00:21:11,000
Those are in there.

504
00:21:11,000 --> 00:21:15,000
So now all I need to do is I actually need to pass this this memory

505
00:21:15,500 --> 00:21:17,000
out to, to the game.

506
00:21:17,200 --> 00:21:18,800
So I'm going to call that game memory.

507
00:21:19,000 --> 00:21:20,600
I'm gonna go ahead and say, game memory.

508
00:21:21,200 --> 00:21:25,300
And then I've got to actually do those allocations here to actually

509
00:21:25,300 --> 00:21:25,900
get it.

510
00:21:26,000 --> 00:21:27,300
Something that it can use.

511
00:21:27,500 --> 00:21:29,300
So where's my virtual a?

512
00:21:29,300 --> 00:21:29,900
Like, I've got

513
00:21:30,000 --> 00:21:30,500
It in here somewhere.

514
00:21:30,500 --> 00:21:32,100
There's for the, there we go.

515
00:21:32,100 --> 00:21:34,000
There's the 14 sound.

516
00:21:34,000 --> 00:21:37,900
So I'm going to still do separate virtual Alex for now, even though in

517
00:21:37,900 --> 00:21:42,200
the future we may well, we may well pull those guys together because

518
00:21:42,200 --> 00:21:43,200
that's something I wanted to do.

519
00:21:43,400 --> 00:21:44,000
All right.

520
00:21:44,000 --> 00:21:47,500
So the game memory, I'm going to wipe that 20 first and I'm going to

521
00:21:47,500 --> 00:21:49,000
say the permanent storage size.

522
00:21:49,200 --> 00:21:51,300
I don't know how big the permanent storage size for.

523
00:21:51,300 --> 00:21:52,700
Our game is either going to be constants.

524
00:21:52,700 --> 00:21:57,700
We're going to tune, but I'm going to say something like 64, MB.

525
00:21:57,700 --> 00:21:57,900
Maybe.

526
00:21:57,900 --> 00:21:58,800
I don't know.

527
00:21:58,800 --> 00:22:00,000
Let's let's pretend that.

528
00:22:00,000 --> 00:22:01,300
It's going to be 64 megabytes.

529
00:22:03,700 --> 00:22:04,400
Just for now.

530
00:22:04,400 --> 00:22:05,800
We'll see how much we actually need later.

531
00:22:07,300 --> 00:22:10,200
And then I'm going to say that the permanent storage, right?

532
00:22:10,200 --> 00:22:14,000
Like this is going to equal another one of these nice virtual Alex

533
00:22:14,000 --> 00:22:17,500
here and that's going to be however much.

534
00:22:17,500 --> 00:22:20,100
I just said storage size was so there it is.

535
00:22:20,400 --> 00:22:23,000
We're going to men commit that because we're going to use it.

536
00:22:23,400 --> 00:22:27,400
And then all I'm going to do is I'm going to go up in here into into

537
00:22:27,400 --> 00:22:30,700
this guy and I'm going to define a couple more macros for me here.

538
00:22:31,000 --> 00:22:31,500
These are ones.

539
00:22:31,500 --> 00:22:32,900
I just like to hold around.

540
00:22:33,000 --> 00:22:36,800
Basically kilobytes megabytes and gigabytes.

541
00:22:36,900 --> 00:22:38,900
It's just in case you ever want to use those.

542
00:22:39,100 --> 00:22:43,300
So basically whatever you pass in here, whatever the value is is going

543
00:22:43,300 --> 00:22:46,300
to be the value, right x?

544
00:22:46,300 --> 00:22:49,800
1024, that makes sense, basically, like, so if you said four

545
00:22:49,800 --> 00:22:54,200
kilobytes, you're going to x 1024 and then basically, each one of

546
00:22:54,200 --> 00:22:57,000
these, is just going to be the exact same thing.

547
00:22:57,300 --> 00:22:58,000
You could think about it.

548
00:22:58,000 --> 00:23:00,800
It's doing it this way, if you wanted to, it's a macro, so it'll

549
00:23:00,800 --> 00:23:01,200
expand.

550
00:23:01,200 --> 00:23:02,600
So it's kind of free for us to do this.

551
00:23:02,600 --> 00:23:06,700
We do have to worry about any kind of a penalty there, anything like

552
00:23:06,700 --> 00:23:06,700
that.

553
00:23:06,800 --> 00:23:07,200
That.

554
00:23:07,400 --> 00:23:12,300
So, we're basically going to say, oops, MB value x, 24 and 24.

555
00:23:12,300 --> 00:23:13,500
So basically, you can see it there.

556
00:23:13,500 --> 00:23:14,300
That's just a shorthand.

557
00:23:14,300 --> 00:23:18,600
So if I wanted to allocate 64 gigabytes for some reason, I could do

558
00:23:18,600 --> 00:23:20,300
that, but I'm just going to do that.

559
00:23:20,300 --> 00:23:20,600
Right?

560
00:23:20,600 --> 00:23:21,300
Does that make sense?

561
00:23:21,300 --> 00:23:22,300
Hopefully that makes some sense.

562
00:23:23,000 --> 00:23:26,900
So what we need to do here is just pass the pointer.

563
00:23:27,400 --> 00:23:28,600
Then I think that's good to go.

564
00:23:28,600 --> 00:23:29,100
Okay.

565
00:23:29,600 --> 00:23:33,600
So basically what we're going to do is we're going to we have the is

566
00:23:33,600 --> 00:23:34,500
initialized thing.

567
00:23:34,500 --> 00:23:34,700
Here.

568
00:23:34,700 --> 00:23:36,700
It will be set to 0 by default first time through.

569
00:23:37,700 --> 00:23:40,800
And of course if I were just to run it now is initialized, will never

570
00:23:40,800 --> 00:23:41,900
get set to true.

571
00:23:42,200 --> 00:23:42,500
Now.

572
00:23:42,500 --> 00:23:45,200
The question is coo sets is initialized to True.

573
00:23:45,300 --> 00:23:50,400
Is it the game, or is it the platform layer for for the moment?

574
00:23:50,600 --> 00:23:54,400
I'm going to say and I'm not 100% comfortable with this decision.

575
00:23:54,800 --> 00:23:56,500
But I'm going to say that's the game.

576
00:23:56,800 --> 00:23:59,200
The reason I'm going to say that is because it's one less thing the

577
00:23:59,200 --> 00:23:59,800
platform layer.

578
00:24:00,000 --> 00:24:02,400
To do and the game is always going to do in here.

579
00:24:02,400 --> 00:24:06,600
So I'm gonna just say that it says to enter service is true here, but

580
00:24:06,600 --> 00:24:11,600
I'm going to say this may be more appropriate to do in the platform

581
00:24:11,600 --> 00:24:12,600
layer and will think.

582
00:24:13,000 --> 00:24:16,600
Think about it later if it ever comes up, something to think about, we

583
00:24:16,600 --> 00:24:17,200
will do that.

584
00:24:17,200 --> 00:24:23,200
And so now in theory, we should be able to step through here and see

585
00:24:23,200 --> 00:24:24,400
what goes on.

586
00:24:24,600 --> 00:24:26,300
Now, basically, what happens,

587
00:24:27,800 --> 00:24:34,300
Is when we get to that point in the code, I keep zooming right past

588
00:24:34,300 --> 00:24:34,400
it.

589
00:24:34,400 --> 00:24:34,800
People.

590
00:24:35,000 --> 00:24:35,500
There we go.

591
00:24:36,200 --> 00:24:38,200
So, we come in here, right?

592
00:24:38,300 --> 00:24:42,600
And we've got our game memory, and it is just initialize to zero.

593
00:24:42,600 --> 00:24:48,400
We then sticks how much we want to put on the, how much actual memory

594
00:24:48,400 --> 00:24:48,700
want there.

595
00:24:48,700 --> 00:24:49,600
So that's 64.

596
00:24:49,600 --> 00:24:51,300
Megabytes is exactly what we wanted.

597
00:24:51,700 --> 00:24:54,600
We're then going to do our virtual Alec and hope to get that space.

598
00:24:55,100 --> 00:24:56,200
It looks like we did.

599
00:24:56,200 --> 00:24:56,700
So we're all

600
00:24:57,100 --> 00:25:00,300
There and basically what I want to do, you know, I forgot to do this

601
00:25:00,300 --> 00:25:01,700
and we might as well do this.

602
00:25:01,700 --> 00:25:02,500
Now.

603
00:25:02,500 --> 00:25:06,600
I want to actually also check those because obviously there's going to

604
00:25:06,600 --> 00:25:10,300
be another if here somewhere which is basically like hey if the

605
00:25:10,300 --> 00:25:15,500
samples, you know, and the game memory are both valid then do the

606
00:25:15,500 --> 00:25:16,300
game, right?

607
00:25:16,300 --> 00:25:20,300
And that'll we're not really going to do it quite like that at the end

608
00:25:20,300 --> 00:25:23,300
of the day, but it's sort of the same thing.

609
00:25:23,300 --> 00:25:26,600
So basically if we can't get the memory, we're not going to run

610
00:25:26,600 --> 00:25:27,000
because if we

611
00:25:27,100 --> 00:25:28,100
Can't allocate the memory.

612
00:25:28,100 --> 00:25:29,000
We need to run.

613
00:25:29,300 --> 00:25:33,100
Well, there's not gonna be much of a game if it can't store anything,

614
00:25:33,100 --> 00:25:33,600
right?

615
00:25:33,800 --> 00:25:35,000
So we come through here.

616
00:25:35,000 --> 00:25:37,300
And then we're going to go ahead and the first time through when we

617
00:25:37,300 --> 00:25:40,300
call this guy game update and render, we step in there.

618
00:25:40,300 --> 00:25:46,200
We take a look, we get back the game State, and that's just set to

619
00:25:46,200 --> 00:25:48,000
point to that first bit of memory there.

620
00:25:48,700 --> 00:25:51,900
And then we go ahead and do the initialization of it.

621
00:25:51,900 --> 00:25:52,600
There it is.

622
00:25:52,600 --> 00:25:54,600
And then we set the memory initialized to true.

623
00:25:54,600 --> 00:25:57,000
So the next time through here when we

624
00:25:57,100 --> 00:25:58,000
Back through again.

625
00:25:58,400 --> 00:25:59,300
We won't initialize.

626
00:25:59,300 --> 00:26:00,600
It will just skip right over it.

627
00:26:00,600 --> 00:26:01,400
So off we go.

628
00:26:02,500 --> 00:26:04,400
So basically what's going to happen is?

629
00:26:04,600 --> 00:26:07,200
We should expect to see everything tracked.

630
00:26:07,800 --> 00:26:09,000
It is tracked.

631
00:26:09,200 --> 00:26:10,200
That's all good.

632
00:26:10,200 --> 00:26:11,100
Everyone's happy.

633
00:26:11,100 --> 00:26:12,100
At least, I'm happy.

634
00:26:12,600 --> 00:26:15,400
And sometimes it's about making me happy most of the time, it's about

635
00:26:15,400 --> 00:26:16,800
making the viewers happy.

636
00:26:16,800 --> 00:26:18,300
Honestly, I'm here for you guys.

637
00:26:18,600 --> 00:26:21,000
But sometimes, you know, you got to make yourself happy as well.

638
00:26:21,000 --> 00:26:21,900
If you're not happy.

639
00:26:21,900 --> 00:26:23,100
How are you making your stream happy?

640
00:26:23,100 --> 00:26:24,900
That's that's the way I like to think about it.

641
00:26:24,900 --> 00:26:26,200
We should all be happy together.

642
00:26:26,300 --> 00:26:26,900
Ideally.

643
00:26:27,300 --> 00:26:28,300
Someone has to be miserable.

644
00:26:28,300 --> 00:26:31,400
It might as well be me rather than you, but if we can all be happy,

645
00:26:31,400 --> 00:26:32,400
that's the best of both worlds.

646
00:26:32,400 --> 00:26:36,800
So the next thing I wanted to ask about basically because I know this

647
00:26:36,800 --> 00:26:37,800
is a little ridiculous.

648
00:26:37,800 --> 00:26:41,400
I don't pretend that it isn't, but I'm just going to go ahead and say,

649
00:26:41,800 --> 00:26:45,700
I'm gonna go ahead and I'm just going to, I'm just going to go out on

650
00:26:45,700 --> 00:26:46,300
a limb here.

651
00:26:46,400 --> 00:26:49,700
I'm gonna go out on a limb and say, what, what if Santa Claus is sort

652
00:26:49,700 --> 00:26:53,400
of real, you know, I'm one of those people who who didn't believe in

653
00:26:53,400 --> 00:26:56,300
Santa Claus, even when they were little, basically thought it was all

654
00:26:57,100 --> 00:26:58,900
Big old big ol.

655
00:26:58,900 --> 00:26:59,800
I was true.

656
00:27:00,000 --> 00:27:01,700
It turned out that I was right about that.

657
00:27:01,700 --> 00:27:02,300
It's unfortunate.

658
00:27:02,300 --> 00:27:05,900
But what if I was actually wrong and Santa Claus, Santa Claus is real

659
00:27:05,900 --> 00:27:07,700
and we can get everything we want for Christmas.

660
00:27:08,000 --> 00:27:15,100
The thing I want to basically know is, is this memory allocated by

661
00:27:15,100 --> 00:27:18,300
this function is automatically initialized to 0.

662
00:27:18,500 --> 00:27:20,700
Do you see what that says now?

663
00:27:21,000 --> 00:27:24,800
That is like, that is like the sleigh with the Reindeer and the

664
00:27:24,800 --> 00:27:26,200
blinking red nose.

665
00:27:27,200 --> 00:27:29,800
The only thing that's not in this leg, yet is the presence but we're

666
00:27:30,000 --> 00:27:33,900
to get the goes to because what that says to me is basically the thing

667
00:27:33,900 --> 00:27:36,500
that I always ask for the thing that I was like, I like having

668
00:27:36,500 --> 00:27:40,500
initialization be clear to 0 so the basically just like as much as

669
00:27:40,500 --> 00:27:41,200
possible.

670
00:27:41,300 --> 00:27:42,700
You don't do any initialization.

671
00:27:42,700 --> 00:27:44,900
You just clear 20 and things are initialized.

672
00:27:45,700 --> 00:27:47,200
Well how happy am I?

673
00:27:47,400 --> 00:27:49,900
Because basically that's exactly what happened here.

674
00:27:50,000 --> 00:27:53,200
I don't even need to do those two things because now I'm just

675
00:27:53,200 --> 00:27:57,000
guaranteed that basically the permanent storage is always going to be

676
00:27:57,000 --> 00:27:59,800
cleared to zero on this platform and probably any other platform.

677
00:28:00,000 --> 00:28:00,700
A security.

678
00:28:00,900 --> 00:28:03,500
And it's not that expensive to clear 64 megabytes 20.

679
00:28:03,500 --> 00:28:05,500
It sounds like a lot, but it's just, it's instant, it start up.

680
00:28:05,500 --> 00:28:06,800
Its you don't even notice it mean.

681
00:28:06,800 --> 00:28:08,100
You didn't see it happen, right?

682
00:28:08,200 --> 00:28:08,300
Neither.

683
00:28:08,300 --> 00:28:08,800
Did I.

684
00:28:09,400 --> 00:28:14,800
So basically what that means is I can just go ahead and Define that.

685
00:28:14,800 --> 00:28:15,800
I want this for Christmas.

686
00:28:15,800 --> 00:28:22,300
I can basically just say permanent storage is basically required to be

687
00:28:22,300 --> 00:28:24,200
cleared to zero at startup.

688
00:28:24,200 --> 00:28:27,600
It just if the platform doesn't already do that, then we'll write the

689
00:28:27,600 --> 00:28:29,800
code to do it in that in that particular.

690
00:28:29,900 --> 00:28:30,400
Form layer.

691
00:28:33,400 --> 00:28:34,200
So, that's good.

692
00:28:35,500 --> 00:28:37,300
That is what we want to see.

693
00:28:37,400 --> 00:28:40,800
So, that's that present one for Christmas.

694
00:28:40,800 --> 00:28:43,400
But, but I'm sorry, that's, that's, I guess, that's I say it was.

695
00:28:43,400 --> 00:28:44,700
I was my metaphor.

696
00:28:44,700 --> 00:28:45,700
That was the reindeer.

697
00:28:45,900 --> 00:28:47,200
I want the sleigh with the presents.

698
00:28:47,200 --> 00:28:51,400
Now, the sleigh with the presence is this guy right here.

699
00:28:51,600 --> 00:29:01,400
So basically that zero is, is that zero is is a is a sack of like as

700
00:29:01,400 --> 00:29:04,100
the Santa Claus's sack ready to be filled with presents.

701
00:29:04,100 --> 00:29:05,100
And I apologize for the

702
00:29:05,900 --> 00:29:08,400
The young children on the stream for using the word sack like that,

703
00:29:08,400 --> 00:29:10,600
but I meant it in a good way something that carries presence.

704
00:29:11,000 --> 00:29:12,500
Basically what we're talking about here.

705
00:29:12,500 --> 00:29:16,000
Is this parameter that we have been ignoring this LP address.

706
00:29:16,500 --> 00:29:18,700
Basically, if you pass 02 LP address.

707
00:29:18,700 --> 00:29:21,400
What that means is that the the address you're going to get back from

708
00:29:21,400 --> 00:29:21,800
virtual.

709
00:29:21,800 --> 00:29:25,500
Alec is going to be whatever the operating system wants to give you

710
00:29:25,800 --> 00:29:27,400
and that is fine for most purposes.

711
00:29:27,400 --> 00:29:29,600
We don't care where the sound output went.

712
00:29:29,600 --> 00:29:33,900
We don't care where the bitmap is, but I'm going to argue for the

713
00:29:33,900 --> 00:29:35,200
moment that we actually

714
00:29:35,300 --> 00:29:38,000
Do perhaps care where the game memory is?

715
00:29:38,000 --> 00:29:41,500
And so we're going to do a permanent storage I said before as well we

716
00:29:41,500 --> 00:29:43,100
were going to do a transient storage.

717
00:29:43,100 --> 00:29:46,100
Remember I said that I wanted to do a transient storage size as well.

718
00:29:46,400 --> 00:29:49,100
Basically, something that's that's kind of just like ephemeral.

719
00:29:49,200 --> 00:29:52,800
It's used for doing work, but it doesn't have to persist necessarily

720
00:29:52,800 --> 00:29:53,600
those sorts of things.

721
00:29:54,900 --> 00:29:56,600
I'm going to say that for those things.

722
00:29:56,900 --> 00:29:59,700
We may well want to actually have a way.

723
00:30:00,100 --> 00:30:07,500
To sort of, you know, you know, to, to make these be at fixed

724
00:30:07,500 --> 00:30:08,300
locations.

725
00:30:08,300 --> 00:30:11,800
In memory, when we're running on our machine.

726
00:30:12,000 --> 00:30:15,400
Now, in the wild, it would be foolish of us to expect that.

727
00:30:15,400 --> 00:30:19,300
We can always ensure that no matter what platform wherever running on

728
00:30:19,300 --> 00:30:23,700
the future that we can mandate the location of an allocation.

729
00:30:24,800 --> 00:30:28,700
If the world work, the way I wanted it to you absolutely would be able

730
00:30:28,700 --> 00:30:29,300
to do that.

731
00:30:29,300 --> 00:30:32,200
As far as I'm concerned, that should have just been locked down.

732
00:30:32,300 --> 00:30:34,800
Like all addressing should have been totally locked.

733
00:30:34,800 --> 00:30:37,900
So that you actually say, just where you want your stuff and that's

734
00:30:37,900 --> 00:30:38,400
it.

735
00:30:38,400 --> 00:30:39,100
Unfortunately.

736
00:30:39,100 --> 00:30:42,200
I do not rule the world or maybe you think that's, fortunately,

737
00:30:42,200 --> 00:30:45,700
because everyone would have to eat to katsu and lobster all day or

738
00:30:45,700 --> 00:30:46,300
stuff like this.

739
00:30:46,300 --> 00:30:49,500
But ignoring things like that, that are a little weird and the almond

740
00:30:49,500 --> 00:30:53,000
milk situation that would probably result that, I think would have

741
00:30:53,000 --> 00:30:54,400
been a much better way to go, and

742
00:30:54,600 --> 00:30:55,700
Would have gotten a lot simpler.

743
00:30:55,700 --> 00:30:57,100
And there would have been a lot things we could do.

744
00:30:57,100 --> 00:30:58,200
That would be a lot more powerful.

745
00:30:58,200 --> 00:31:01,700
But short of getting that present down the chimney.

746
00:31:02,200 --> 00:31:06,300
This Christmas we can get something else and that something else is on

747
00:31:06,300 --> 00:31:06,900
our machine.

748
00:31:06,900 --> 00:31:11,100
When we run we can have the same memory location every time we run.

749
00:31:14,300 --> 00:31:15,400
That means two things.

750
00:31:15,500 --> 00:31:15,900
One.

751
00:31:15,900 --> 00:31:19,500
It means all of our pointers will be the same every run until we

752
00:31:19,500 --> 00:31:22,500
actually change code so that they, you know, are allocating more stuff

753
00:31:22,500 --> 00:31:25,500
for something like this and that really helps for debugging things.

754
00:31:25,500 --> 00:31:28,000
So that basically means that if you look at a pointer in one run of

755
00:31:28,000 --> 00:31:30,500
the program, you can know that it's going to be that same pointer.

756
00:31:30,700 --> 00:31:33,800
Assuming you do this, a deterministic set of steps in the next run of

757
00:31:33,800 --> 00:31:34,500
the program.

758
00:31:34,600 --> 00:31:37,600
Whereas normally with Windows where it does its address randomization

759
00:31:37,600 --> 00:31:38,700
stuff for security.

760
00:31:39,200 --> 00:31:40,500
That's not going to be true.

761
00:31:40,500 --> 00:31:43,800
If we were just allocating off the Heap, it be wherever it was and I

762
00:31:43,800 --> 00:31:43,900
see

763
00:31:44,000 --> 00:31:46,700
Virtual Alec also returns random addresses as well.

764
00:31:46,700 --> 00:31:49,400
I don't actually know because we haven't tested that, but I assume

765
00:31:49,400 --> 00:31:50,800
that they're going to be different every time.

766
00:31:50,900 --> 00:31:53,200
In fact, I think we may have seen them di different every time we step

767
00:31:53,200 --> 00:31:53,700
through before.

768
00:31:53,700 --> 00:31:56,800
I don't know, doesn't matter point being, we want to lock that down

769
00:31:56,900 --> 00:31:59,600
and make sure that we know that we're always in the same place for a

770
00:31:59,600 --> 00:32:00,700
number of reasons to buggies.

771
00:32:00,700 --> 00:32:03,500
One of them, other things will come later that where it's like.

772
00:32:03,500 --> 00:32:04,600
Hey, did you see how I did that?

773
00:32:04,600 --> 00:32:05,600
Well, that was because of this.

774
00:32:06,000 --> 00:32:08,400
So, basically, what I'm going to say is that basically are transient

775
00:32:08,400 --> 00:32:08,800
storage.

776
00:32:08,800 --> 00:32:12,400
Let's say is going to be bigger than that are transient storage.

777
00:32:12,600 --> 00:32:13,800
I think, on the PC.

778
00:32:14,000 --> 00:32:15,500
See realistically speaking.

779
00:32:15,500 --> 00:32:17,400
I think we want at least two gigabytes.

780
00:32:17,400 --> 00:32:20,200
I mean cuz basically PCS have a ton of memory these days and we're

781
00:32:20,200 --> 00:32:22,000
going to want to use it on win32.

782
00:32:22,000 --> 00:32:25,000
I don't think anyone's going to be running this game in less than 2

783
00:32:25,000 --> 00:32:26,800
gigabytes on the bigger side.

784
00:32:26,800 --> 00:32:30,000
Now, we could will shrink that will basically make that shrink down on

785
00:32:30,000 --> 00:32:33,000
Lower platforms obviously, but when we're talking about running, the

786
00:32:33,000 --> 00:32:35,200
big high-res Graphics, we're going to want that to be big.

787
00:32:35,200 --> 00:32:38,100
So, certainly during development to gigs for gigs.

788
00:32:38,100 --> 00:32:41,800
Let's say four gigs, just so it pushes us up to the Ford to the oops.

789
00:32:41,800 --> 00:32:42,400
That's no good.

790
00:32:42,400 --> 00:32:43,300
That's four terabytes.

791
00:32:44,000 --> 00:32:47,700
So for gigs would be good because that actually gets us up to full

792
00:32:47,700 --> 00:32:48,800
64-bit address range.

793
00:32:48,800 --> 00:32:51,000
So it's make sure we didn't screw anything up with are Pointers.

794
00:32:51,300 --> 00:32:56,100
So let's let's try this and just see and then later we'll make a low

795
00:32:56,100 --> 00:32:58,900
profile version where these things are much smaller.

796
00:32:59,200 --> 00:32:59,800
So let's let's

797
00:33:00,000 --> 00:33:04,500
That let's go ahead and try that and see what we can do there.

798
00:33:04,500 --> 00:33:08,000
And then I'm going to I'm going to specify these memory allocation

799
00:33:08,200 --> 00:33:09,300
locations as well.

800
00:33:09,500 --> 00:33:11,400
Alright, so um handmade here.

801
00:33:11,800 --> 00:33:14,000
I'm going to go ahead and make another one of these.

802
00:33:14,000 --> 00:33:16,700
This is going to be basically a minute replace permanent with

803
00:33:16,700 --> 00:33:17,300
transient.

804
00:33:17,300 --> 00:33:18,900
That's about the only thing that's going to happen.

805
00:33:19,500 --> 00:33:23,000
And since we can will just require to be clear, 20 again.

806
00:33:23,000 --> 00:33:23,500
Why not?

807
00:33:23,500 --> 00:33:24,700
Let's just see what happens.

808
00:33:25,100 --> 00:33:28,300
You know, I mean if it's going to do, it's going to do it.

809
00:33:29,600 --> 00:33:31,300
I assume to I should mention.

810
00:33:31,300 --> 00:33:32,000
I mean, I don't know.

811
00:33:32,000 --> 00:33:32,600
I'm guessing.

812
00:33:33,000 --> 00:33:33,400
Hmm.

813
00:33:34,200 --> 00:33:35,700
Yeah, so that just work.

814
00:33:35,800 --> 00:33:36,200
No, it didn't.

815
00:33:36,200 --> 00:33:36,600
Work.

816
00:33:36,700 --> 00:33:38,700
Did that just that did not allow me to what?

817
00:33:38,700 --> 00:33:40,900
Why don't know what why not.

818
00:33:40,900 --> 00:33:43,200
Why can't I why can't I allocate the memory?

819
00:33:43,500 --> 00:33:47,200
So it did not like it that large apparently apparently.

820
00:33:47,200 --> 00:33:47,700
Oh.

821
00:33:50,200 --> 00:33:50,600
Awesome.

822
00:33:51,300 --> 00:33:53,400
That's that's that's fantastic.

823
00:33:53,600 --> 00:33:58,800
Well, you know, I guess you should just expect these sorts of things.

824
00:33:59,400 --> 00:34:02,300
So what happened there was kind of it and it's good that this

825
00:34:02,300 --> 00:34:02,600
happened.

826
00:34:02,600 --> 00:34:04,100
Some point in the Stream so I can explain it.

827
00:34:04,600 --> 00:34:05,600
This is annoying.

828
00:34:06,100 --> 00:34:09,100
So basically what happened there, as we wrapped the exact thing I just

829
00:34:09,100 --> 00:34:11,600
said to make sure that we don't have any bugs is exactly what we did.

830
00:34:11,600 --> 00:34:12,000
Have.

831
00:34:14,199 --> 00:34:18,900
The problem here is that c has decided in its infinite decimal wisdom

832
00:34:19,400 --> 00:34:23,300
that it wants to do this in 32 bits this computation.

833
00:34:23,300 --> 00:34:29,100
So, when I said, four gigabytes, it proceeded to take 1024 and

834
00:34:29,100 --> 00:34:34,000
multiply it by 1024 and multiply it by 1024 and multiply it by 4

835
00:34:34,000 --> 00:34:38,699
gigabytes, which perfectly gets to 4 gigabytes, but perfectly gets to

836
00:34:38,699 --> 00:34:43,100
the four billion number that wraps a Unit 32 around 20.

837
00:34:43,800 --> 00:34:48,300
Now I wanted it to do it in 64-bit, which I can't actually tell it to

838
00:34:48,300 --> 00:34:49,400
do in any other way.

839
00:34:49,600 --> 00:34:55,600
So basically, what I have to do here is I have to give it something.

840
00:34:56,699 --> 00:35:00,900
I have to, I have to sort of poison the pot, if you will because the

841
00:35:00,900 --> 00:35:05,000
way see does things is it will promote numbers up to higher bit

842
00:35:05,000 --> 00:35:05,500
depths.

843
00:35:05,700 --> 00:35:08,800
If something in the expression is requiring that, right.

844
00:35:09,400 --> 00:35:13,400
So what I can do is try to convince it that I need this.

845
00:35:13,600 --> 00:35:19,400
Be done in 64 bit by saying that that for is really a 64-bit for

846
00:35:19,400 --> 00:35:20,000
please.

847
00:35:20,700 --> 00:35:26,300
And then when I come in here and Theory, I will get yeah, there we go.

848
00:35:26,500 --> 00:35:28,800
I'll get the actual number that I wanted.

849
00:35:29,100 --> 00:35:30,300
That is really annoying.

850
00:35:30,300 --> 00:35:31,300
I hate stuff like that.

851
00:35:31,300 --> 00:35:32,500
It doesn't make any sense.

852
00:35:32,500 --> 00:35:33,800
I don't like the way he does.

853
00:35:33,800 --> 00:35:34,400
That sort of stuff.

854
00:35:34,400 --> 00:35:37,700
I believe that's technically called integral promotion, and you can

855
00:35:37,900 --> 00:35:42,300
read more about that nonsense, intradural promotion.

856
00:35:43,500 --> 00:35:46,800
Let's take a look here and come on.

857
00:35:46,800 --> 00:35:47,400
Hello.

858
00:35:47,400 --> 00:35:48,000
There we go.

859
00:35:48,300 --> 00:35:51,300
So, basically, this this old Ridiculousness.

860
00:35:52,000 --> 00:35:56,100
This is kind of the Annoying stuff where it's just like, you know, if

861
00:35:56,100 --> 00:35:59,700
this is actually it might not be all this point being.

862
00:35:59,700 --> 00:35:59,800
I'm

863
00:36:00,000 --> 00:36:02,600
I'm going to belabor it because first of all, I don't even know what

864
00:36:02,600 --> 00:36:05,200
all the rules are like, at one point.

865
00:36:05,200 --> 00:36:07,700
I probably read them, but I don't even know.

866
00:36:07,700 --> 00:36:10,100
Like, if you gave me an expression with something complicated and I

867
00:36:10,100 --> 00:36:12,200
wouldn't necessarily know what it decided to promote things to

868
00:36:12,200 --> 00:36:15,200
unsigned, or signed, and, and bigger and smaller, and all this other

869
00:36:15,200 --> 00:36:15,600
stuff.

870
00:36:16,600 --> 00:36:17,100
Basically.

871
00:36:17,100 --> 00:36:18,100
It's just really annoying.

872
00:36:18,100 --> 00:36:20,300
It's one of those things where see has all these rules.

873
00:36:20,300 --> 00:36:20,600
It does.

874
00:36:20,600 --> 00:36:23,800
It should have just been explicit or had some way of saying, you know,

875
00:36:23,800 --> 00:36:27,300
if it's all constants, then it just produces the result in constant

876
00:36:27,300 --> 00:36:28,500
and if it's not that is something else.

877
00:36:28,500 --> 00:36:29,000
I don't know.

878
00:36:30,000 --> 00:36:31,700
His desires should have, worked something better.

879
00:36:31,800 --> 00:36:34,200
Hopefully, when John does his language, they'll be something awesome

880
00:36:34,200 --> 00:36:34,500
in there.

881
00:36:34,500 --> 00:36:35,000
I don't know.

882
00:36:35,100 --> 00:36:36,500
But point being, that's what we hit.

883
00:36:38,700 --> 00:36:41,000
Now that we've taken care of that, it should be fine.

884
00:36:41,300 --> 00:36:42,100
Yeah, there we go.

885
00:36:42,800 --> 00:36:45,300
And so like, you see, there's no penalty, therefore, clearing, 20,

886
00:36:45,300 --> 00:36:45,800
really?

887
00:36:46,100 --> 00:36:48,600
Because what, I believe happens and like I was saying before, I don't

888
00:36:48,600 --> 00:36:51,300
know this, for sure, but I believe happens is, I don't even know if

889
00:36:51,300 --> 00:36:54,900
Windows ever bothers to actually clear all that memory, right?

890
00:36:54,900 --> 00:36:55,300
Then.

891
00:36:55,300 --> 00:36:58,300
I think what it might do is just mark it as needing to be cleared.

892
00:36:58,300 --> 00:37:00,900
And then when we actually go to access the page, the first time, it

893
00:37:00,900 --> 00:37:02,000
does the clear right there.

894
00:37:03,100 --> 00:37:03,600
I don't know.

895
00:37:04,500 --> 00:37:05,100
I don't know which it does.

896
00:37:05,100 --> 00:37:05,800
I don't care.

897
00:37:05,900 --> 00:37:08,900
It's fine with me as long as we don't see any kind of performance

898
00:37:08,900 --> 00:37:09,500
weirdness from it.

899
00:37:09,500 --> 00:37:10,100
We should be fine.

900
00:37:10,100 --> 00:37:12,300
As soon as we start using the memory will take that hit and we'll be

901
00:37:12,300 --> 00:37:12,700
fine.

902
00:37:13,200 --> 00:37:15,900
If we if it turns out that we don't like the in particular that hit,

903
00:37:15,900 --> 00:37:18,600
we could just write here, sweep through the whole thing reading

904
00:37:19,300 --> 00:37:23,100
values, and writing to it arbitrarily or something like that, but we

905
00:37:23,100 --> 00:37:24,900
don't really need to do that yet.

906
00:37:25,000 --> 00:37:29,600
So anyway, that basically gives us everything we needed and now, you

907
00:37:29,600 --> 00:37:32,500
know, not to be anticlimactic but

908
00:37:32,800 --> 00:37:38,400
You have now seen probably all of the allocations were ever going to

909
00:37:38,400 --> 00:37:38,900
do.

910
00:37:40,900 --> 00:37:42,000
That that was it.

911
00:37:42,500 --> 00:37:44,400
Maybe we'll chunk those up a little bit more.

912
00:37:44,400 --> 00:37:48,100
We may also do a thing for debug allocation where we where we do some

913
00:37:48,100 --> 00:37:50,300
stuff that doesn't quite work that way.

914
00:37:50,300 --> 00:37:52,700
But I mean, that's really what we're talking about here.

915
00:37:53,100 --> 00:37:56,500
That is that is really that's that's it.

916
00:37:57,000 --> 00:38:04,200
And so we know that basically if we get here we're ready the game will

917
00:38:04,200 --> 00:38:04,400
run.

918
00:38:04,400 --> 00:38:08,400
It will never fail to it will never run out of memory it like the

919
00:38:08,400 --> 00:38:10,400
operating system has to fail at that point.

920
00:38:10,400 --> 00:38:10,500
Not

921
00:38:10,700 --> 00:38:11,000
Us.

922
00:38:11,600 --> 00:38:12,300
So we're good.

923
00:38:12,700 --> 00:38:13,700
So that's kind of cool.

924
00:38:14,300 --> 00:38:16,300
And basically what we're going to do from now on is we're always going

925
00:38:16,300 --> 00:38:17,900
to use stuff in there.

926
00:38:18,300 --> 00:38:21,300
So I know it's a little anticlimactic.

927
00:38:21,300 --> 00:38:24,900
Like I said, very anticlimactic but the basic reason is that

928
00:38:24,900 --> 00:38:25,400
everything else?

929
00:38:25,400 --> 00:38:28,300
All the other systems we're going to do the other interesting memory,

930
00:38:28,500 --> 00:38:31,200
allocation stuff that we're going to do is all just going to be part

931
00:38:31,200 --> 00:38:32,700
of the systems that we write.

932
00:38:32,900 --> 00:38:36,300
So there's really nothing to cover other than what we just did.

933
00:38:36,400 --> 00:38:37,000
That was it?

934
00:38:37,100 --> 00:38:38,200
We now have memory for our game.

935
00:38:38,200 --> 00:38:40,000
We have all the memory we're ever going to need for our game.

936
00:38:40,000 --> 00:38:40,500
We are going to run.

937
00:38:40,600 --> 00:38:41,700
The entire game in that memory.

938
00:38:41,700 --> 00:38:44,100
And so, yeah, party time.

939
00:38:44,500 --> 00:38:48,500
So I think that's basically all we needed to do.

940
00:38:48,900 --> 00:38:52,400
Let me double-check to make sure that we actually show that we have

941
00:38:52,400 --> 00:38:55,600
gotten that memory and we have what we think we have.

942
00:38:56,000 --> 00:38:58,200
Just to make sure there's nothing weird going on here.

943
00:38:58,400 --> 00:38:58,600
There.

944
00:38:58,600 --> 00:38:59,000
We are.

945
00:38:59,000 --> 00:38:59,900
There's our four.

946
00:39:00,000 --> 00:39:01,200
It's just like we thought.

947
00:39:01,500 --> 00:39:03,100
So it looks pretty good.

948
00:39:03,800 --> 00:39:05,500
And that is that is it?

949
00:39:05,700 --> 00:39:07,700
That is, that is really all there is to it.

950
00:39:08,300 --> 00:39:09,800
That's, that's, that's all.

951
00:39:10,100 --> 00:39:14,400
So, that is basically it what we want to do eventually.

952
00:39:14,400 --> 00:39:17,900
Like I said, when we start to play around with this a little bit more,

953
00:39:18,300 --> 00:39:21,300
we're going to want different profiles here because basically what

954
00:39:21,300 --> 00:39:24,100
we're going to want to do is say okay on 32-bit platforms.

955
00:39:24,100 --> 00:39:29,000
We're going to allocate like one gigabyte of transient and we might

956
00:39:29,000 --> 00:39:29,900
also take a look at how much memory

957
00:39:30,000 --> 00:39:30,800
Memories in the machine.

958
00:39:30,800 --> 00:39:32,400
We might allocate 8 GB.

959
00:39:32,400 --> 00:39:35,300
If the Muse has got a ton of memory because you can always use more

960
00:39:35,300 --> 00:39:38,900
backing store to make the game more performant and stuff like that.

961
00:39:38,900 --> 00:39:39,900
So, so we'll see.

962
00:39:40,000 --> 00:39:42,600
So basically this is the, this is basically what's going to happen,

963
00:39:42,600 --> 00:39:47,600
but you know will fine-tune how much we allocate and how a little more

964
00:39:47,600 --> 00:39:48,300
in the future.

965
00:39:48,600 --> 00:39:48,900
Of course.

966
00:39:48,900 --> 00:39:52,400
The other thing that we can do is just do these two as as one

967
00:39:52,400 --> 00:39:55,200
allocation, if you wanted to pull them together, you just make this

968
00:39:55,200 --> 00:39:59,100
pointer point to you Dad the two sizes together.

969
00:39:59,100 --> 00:39:59,800
And then you'd make this

970
00:40:00,000 --> 00:40:01,300
Point a little further up.

971
00:40:01,500 --> 00:40:02,800
We could totally do that.

972
00:40:02,800 --> 00:40:03,000
Right?

973
00:40:03,000 --> 00:40:06,700
We could totally just do that ourselves, but I'm going to leave them

974
00:40:06,700 --> 00:40:07,800
as separate pages for now.

975
00:40:07,800 --> 00:40:10,100
Just in case, one of them over rights their boundaries.

976
00:40:10,300 --> 00:40:11,700
We had a better chance of catching that.

977
00:40:11,800 --> 00:40:12,500
We may do.

978
00:40:12,500 --> 00:40:15,200
Men protects on either side of them, the future to actually guarantee.

979
00:40:15,200 --> 00:40:16,500
We kissed that that sort of thing.

980
00:40:17,000 --> 00:40:23,900
All righty, that's that was 40 minutes for two virtual out.

981
00:40:23,900 --> 00:40:26,800
So I had to basically explain things but really that was it, that's

982
00:40:26,800 --> 00:40:27,700
the memory management.

983
00:40:27,700 --> 00:40:29,800
So what I wanted to do the

984
00:40:29,900 --> 00:40:31,200
other things I wanted to do today.

985
00:40:31,700 --> 00:40:34,000
Well, so maybe now is a good time.

986
00:40:34,000 --> 00:40:37,000
I don't know if we should really dive into keyboard input today.

987
00:40:37,000 --> 00:40:40,400
So what I think I'd rather do is, I'd rather spend a little bit of

988
00:40:40,400 --> 00:40:44,000
time talking about something that I would want to do in this

989
00:40:44,000 --> 00:40:48,000
particular circumstance, which is I'd like to start having the ability

990
00:40:48,000 --> 00:40:49,200
to assert things.

991
00:40:49,800 --> 00:40:53,700
Basically what an assert is isn't assert is a thing that you can put

992
00:40:53,700 --> 00:40:54,200
in your code.

993
00:40:54,200 --> 00:40:55,600
That's just for debugging purposes.

994
00:40:55,600 --> 00:40:59,800
That lets you know, whether or not something worked that

995
00:41:00,000 --> 00:41:02,700
You assume will always work if that makes sense.

996
00:41:03,400 --> 00:41:08,700
And so what I want to do is I basically want to Define in handmade

997
00:41:08,700 --> 00:41:09,600
CPP.

998
00:41:09,700 --> 00:41:13,700
I want to Define an assertion function that basically takes something,

999
00:41:13,700 --> 00:41:17,200
it takes an expression and then it is going to assert that if that

1000
00:41:17,200 --> 00:41:19,500
expression is or is not true.

1001
00:41:20,200 --> 00:41:22,900
Basically, if it's false we want to Halt the program.

1002
00:41:23,600 --> 00:41:25,000
So we want to do something.

1003
00:41:25,700 --> 00:41:29,200
Let's say like this, we want to do something where we go.

1004
00:41:29,300 --> 00:41:29,800
Okay.

1005
00:41:29,900 --> 00:41:33,600
If expression right is not true.

1006
00:41:33,700 --> 00:41:35,300
So the expression is not true.

1007
00:41:35,900 --> 00:41:39,600
Then I'm just going to like write 20 or something, right?

1008
00:41:40,000 --> 00:41:40,900
Something like this.

1009
00:41:41,100 --> 00:41:43,400
I don't know, just making this up as I go along here.

1010
00:41:44,000 --> 00:41:47,900
So basically what I'm going to do now is I'm going to come in here,

1011
00:41:47,900 --> 00:41:49,700
and this is the thing I wanted to do before.

1012
00:41:50,800 --> 00:41:52,900
I wanted to say, all right.

1013
00:41:53,400 --> 00:41:55,200
I have a requirement here.

1014
00:41:55,300 --> 00:41:59,800
And that requirement, is that the game State structure, right?

1015
00:42:00,000 --> 00:42:06,400
Has to fit obviously, inside the the permanent storage size.

1016
00:42:06,700 --> 00:42:07,300
Right?

1017
00:42:07,900 --> 00:42:08,200
Right.

1018
00:42:08,200 --> 00:42:09,400
That's just the kind of a given.

1019
00:42:09,900 --> 00:42:12,100
So I just wanted to say that that was some.

1020
00:42:12,100 --> 00:42:15,800
I just wanted to point out to the the program at this point.

1021
00:42:15,900 --> 00:42:19,100
And so what I'm doing is I'm putting in an expression that we would

1022
00:42:19,100 --> 00:42:22,900
normally if on but I don't actually need to do anything based on it.

1023
00:42:22,900 --> 00:42:26,000
I'm just trying to tell you this has to be true.

1024
00:42:26,300 --> 00:42:27,600
I expect this to be true.

1025
00:42:27,600 --> 00:42:28,700
If it's not true.

1026
00:42:28,800 --> 00:42:29,800
I want you to stop the

1027
00:42:30,000 --> 00:42:30,900
Program immediately.

1028
00:42:30,900 --> 00:42:32,400
So I can find out why not.

1029
00:42:32,500 --> 00:42:33,400
Does that make sense?

1030
00:42:33,800 --> 00:42:37,000
So, basically like if I run this, nothing happens, which is what I

1031
00:42:37,000 --> 00:42:37,800
expect.

1032
00:42:38,000 --> 00:42:40,200
But, if for some reason, right?

1033
00:42:40,200 --> 00:42:43,400
We were in the, the win32 handmade stuff here.

1034
00:42:43,500 --> 00:42:47,500
I went in and I just, you know, I was just being dumb, and I like, I

1035
00:42:47,500 --> 00:42:51,900
made this b 1 B long or something like this, right?

1036
00:42:52,600 --> 00:42:56,600
Then when I came through here, I would get a break right, right on

1037
00:42:56,600 --> 00:42:57,400
this assertion.

1038
00:42:57,500 --> 00:42:59,800
That just tells me, hey, you know,

1039
00:43:01,500 --> 00:43:04,600
You said this was supposed to be true and it's false.

1040
00:43:05,000 --> 00:43:05,600
Right?

1041
00:43:05,900 --> 00:43:08,800
And so what I did is I just made it a macro, right?

1042
00:43:08,800 --> 00:43:09,800
That I can drop in there.

1043
00:43:09,800 --> 00:43:13,500
My assertion micro and the macro just says, hey, if the expression, I

1044
00:43:13,500 --> 00:43:13,900
don't even know.

1045
00:43:13,900 --> 00:43:14,800
I put it on a separate line.

1046
00:43:15,100 --> 00:43:19,400
If the expression that you passed into it, for some reason isn't true

1047
00:43:19,400 --> 00:43:21,500
just flat-out right to the null pointer.

1048
00:43:21,500 --> 00:43:24,300
Just right straight to null because you know, if you write to the null

1049
00:43:24,300 --> 00:43:25,700
pointer, you're going to crash the code.

1050
00:43:25,800 --> 00:43:26,700
So crash it.

1051
00:43:26,800 --> 00:43:27,200
Boom.

1052
00:43:27,200 --> 00:43:27,800
It's done.

1053
00:43:29,100 --> 00:43:29,800
Why do I do that?

1054
00:43:29,900 --> 00:43:33,700
That because that was the quickest way to do it, platform-independent,

1055
00:43:33,700 --> 00:43:35,300
and I just wanted to put that up there.

1056
00:43:35,300 --> 00:43:35,800
Why not?

1057
00:43:35,800 --> 00:43:36,000
Now?

1058
00:43:36,000 --> 00:43:37,200
You've got other options.

1059
00:43:39,000 --> 00:43:40,200
Here's a, here's one of them.

1060
00:43:42,000 --> 00:43:47,200
You can just if you want to have a platform independent way of doing a

1061
00:43:47,200 --> 00:43:50,200
debug break and that would be this guy.

1062
00:43:50,200 --> 00:43:53,500
And that is just basically going to do a thing that launch the

1063
00:43:53,500 --> 00:43:57,100
debugger, all that kind of stuff, but I don't really care about that

1064
00:43:57,100 --> 00:43:57,800
too much right now.

1065
00:43:57,800 --> 00:44:00,300
So all I did is I just need something to stop the program and that

1066
00:44:00,300 --> 00:44:01,200
will stop the program.

1067
00:44:01,700 --> 00:44:02,300
So,

1068
00:44:03,700 --> 00:44:08,300
I like that because that basically, I like using asserts because it

1069
00:44:08,300 --> 00:44:13,000
basically allows me to put stuff in my code that should that, that in

1070
00:44:13,000 --> 00:44:17,000
general should always be validated.

1071
00:44:17,100 --> 00:44:20,400
So that I know that I didn't miss something in case, like I change

1072
00:44:20,400 --> 00:44:25,300
something later on and and, you know, and don't realize the

1073
00:44:25,300 --> 00:44:27,100
consequences that that change has.

1074
00:44:27,100 --> 00:44:30,000
There's a search, might catch it for me and save me some work.

1075
00:44:30,100 --> 00:44:31,000
So, I like that.

1076
00:44:31,000 --> 00:44:32,100
I like to put that in there.

1077
00:44:32,100 --> 00:44:33,200
It's a good thing.

1078
00:44:33,700 --> 00:44:37,600
Now, what you may be wondering is don't they incur performance penalty

1079
00:44:37,600 --> 00:44:39,000
and the answer is yes, they do.

1080
00:44:39,100 --> 00:44:42,400
So usually, what we do is we do something like this.

1081
00:44:42,700 --> 00:44:46,000
We typically decide that we have something called the debug build,

1082
00:44:46,100 --> 00:44:46,600
right?

1083
00:44:46,600 --> 00:44:51,300
And we say that, if you have a debug, you know, if you're in a

1084
00:44:51,300 --> 00:44:56,100
debugging scenario, then you will, you know, actually expand to

1085
00:44:56,100 --> 00:44:56,400
something.

1086
00:44:56,400 --> 00:44:59,400
But if you're not in a debug scenario, then you'll just make it expand

1087
00:44:59,400 --> 00:44:59,800
to nothing.

1088
00:45:00,000 --> 00:45:03,700
There's no cost to doing this if you're not debugging.

1089
00:45:04,100 --> 00:45:07,200
Now this brings up something which we have, which we've been dancing

1090
00:45:07,200 --> 00:45:08,500
around, which is right.

1091
00:45:08,500 --> 00:45:11,200
Now, we just have a straightforward bill that doesn't do any.

1092
00:45:11,200 --> 00:45:13,500
There's no differentiation, but there's no way to switch different

1093
00:45:13,500 --> 00:45:13,700
things.

1094
00:45:13,700 --> 00:45:15,800
We have the handmade win32, but that's about all.

1095
00:45:15,800 --> 00:45:17,100
We've got right.

1096
00:45:21,400 --> 00:45:23,200
So, what we want to do now.

1097
00:45:24,600 --> 00:45:28,400
Is basically defined some a couple pound defines like this debug thing

1098
00:45:28,900 --> 00:45:34,400
that basically allow us to toggle certain aspects of our code.

1099
00:45:34,800 --> 00:45:43,700
And so basically, I typically like to have debug is kind of, I find

1100
00:45:43,700 --> 00:45:45,400
that debugger not debug.

1101
00:45:45,800 --> 00:45:47,300
It's just too ambiguous.

1102
00:45:47,300 --> 00:45:48,900
It's like, what does that really mean?

1103
00:45:48,900 --> 00:45:50,800
Like do I want debugging code?

1104
00:45:50,800 --> 00:45:52,000
Or does it mean that I'm debugging?

1105
00:45:52,000 --> 00:45:52,800
I don't really know.

1106
00:45:53,600 --> 00:45:54,300
So I tend

1107
00:45:54,400 --> 00:45:59,000
Like to have some other sorts of things that make a little more sense

1108
00:45:59,000 --> 00:46:00,200
as to what you're doing.

1109
00:46:00,900 --> 00:46:04,000
Like, do you care about whether performance is happening right now or

1110
00:46:04,000 --> 00:46:05,400
not kinds of things?

1111
00:46:05,400 --> 00:46:08,200
You care about whether size is happening now or not, those sorts of

1112
00:46:08,200 --> 00:46:08,600
things.

1113
00:46:09,200 --> 00:46:13,100
So I tend to like stuff like is this a build that's going to be

1114
00:46:13,100 --> 00:46:14,900
released publicly or not?

1115
00:46:15,400 --> 00:46:16,500
That's that's like one thing.

1116
00:46:16,500 --> 00:46:18,300
Like is it only running on my machine?

1117
00:46:18,400 --> 00:46:21,300
So things like specifying The Base address that we're going to do in a

1118
00:46:21,300 --> 00:46:21,900
second here.

1119
00:46:22,600 --> 00:46:24,200
That's like one thing that might happen.

1120
00:46:24,300 --> 00:46:26,500
Only in debug things.

1121
00:46:26,500 --> 00:46:31,000
Like try to think about the other things are like, so internal build

1122
00:46:31,000 --> 00:46:31,600
or external.

1123
00:46:31,600 --> 00:46:35,100
Build would be one of them whether or not I'm testing performance

1124
00:46:35,100 --> 00:46:37,500
right now or not, those sorts of things.

1125
00:46:38,000 --> 00:46:41,200
And so basically if I'm testing performance I need asserts to go away,

1126
00:46:41,400 --> 00:46:42,000
right?

1127
00:46:42,200 --> 00:46:47,200
So basically I would like to do handmade performance, right?

1128
00:46:48,300 --> 00:46:54,100
So basically, if you know, if let's say maybe speed, let's call it

1129
00:46:54,100 --> 00:46:54,800
handmade speed.

1130
00:46:54,800 --> 00:46:55,900
Is it a speed build or not?

1131
00:46:55,900 --> 00:46:56,800
A speed build?

1132
00:46:56,800 --> 00:46:57,900
How about slow?

1133
00:46:58,100 --> 00:47:00,300
Let's call it slow, that works for me.

1134
00:47:00,600 --> 00:47:04,200
So if, if we have defined slow, we can do our assertions.

1135
00:47:04,200 --> 00:47:05,700
If we haven't this find slow.

1136
00:47:05,700 --> 00:47:07,000
We can't write.

1137
00:47:07,000 --> 00:47:10,100
So I'm going to say that we're building in slow mode now and that's

1138
00:47:10,100 --> 00:47:10,900
going to be fine.

1139
00:47:10,900 --> 00:47:11,400
Right?

1140
00:47:12,000 --> 00:47:14,700
And that that works for me and then we're going to have the other one

1141
00:47:14,700 --> 00:47:17,700
which is handmade internal and

1142
00:47:18,000 --> 00:47:20,200
Is going to be defined to one as well.

1143
00:47:20,400 --> 00:47:25,000
So then what I'm going to do is basically say, you know, you know what

1144
00:47:25,000 --> 00:47:26,000
we can also do here.

1145
00:47:26,000 --> 00:47:27,800
We can even say by default.

1146
00:47:28,000 --> 00:47:29,500
What we would build, although Apple.

1147
00:47:29,500 --> 00:47:29,900
Yeah.

1148
00:47:30,700 --> 00:47:30,900
Yeah.

1149
00:47:30,900 --> 00:47:32,000
Yeah, that's good enough for me.

1150
00:47:32,300 --> 00:47:34,600
But what I will do here is I'll put these in here.

1151
00:47:34,700 --> 00:47:45,800
I'll basically say handmade internal is basically zero means a build

1152
00:47:45,800 --> 00:47:47,500
for public release.

1153
00:47:47,900 --> 00:47:52,300
One is billed for developer only, right?

1154
00:47:52,800 --> 00:47:55,100
And then we're going to have handmade slow.

1155
00:47:55,400 --> 00:47:56,900
That is zero.

1156
00:47:57,600 --> 00:47:59,700
No slow code allowed.

1157
00:48:00,000 --> 00:48:03,300
One is slow code, welcome.

1158
00:48:04,100 --> 00:48:05,400
So that's what I'm going to do.

1159
00:48:05,400 --> 00:48:07,500
So if handmade slows to find we got a surgeon's.

1160
00:48:07,500 --> 00:48:11,300
If not, then we're not and then I'm going to go ahead and say that

1161
00:48:11,300 --> 00:48:12,300
internal build.

1162
00:48:12,400 --> 00:48:14,600
I'm going to turn right around and use it in the place that I wanted

1163
00:48:14,600 --> 00:48:15,700
to, which is down here.

1164
00:48:16,300 --> 00:48:20,000
We're basically say if this is a handmade internal build, then we are

1165
00:48:20,000 --> 00:48:22,000
going to try and set our base addresses.

1166
00:48:22,700 --> 00:48:25,600
And if not, then not that makes sense.

1167
00:48:25,900 --> 00:48:29,800
So I'm going to say that we've basically got what is, what is virtual?

1168
00:48:30,000 --> 00:48:33,200
I want their, what does virtual aliquot as that first parameter for an

1169
00:48:33,200 --> 00:48:34,900
LP address virtual Alla.

1170
00:48:36,000 --> 00:48:39,800
Why don't you tell me an LP void?

1171
00:48:40,300 --> 00:48:42,000
So we're going to have an LP void.

1172
00:48:42,700 --> 00:48:45,500
We're going to have an LP void Base address.

1173
00:48:47,200 --> 00:48:50,400
And That Base address is basically going to be zero when we don't have

1174
00:48:50,400 --> 00:48:53,800
an internal build, or it's going to be some magical value that we hope

1175
00:48:53,800 --> 00:48:56,300
we can get when we have an external build.

1176
00:48:56,300 --> 00:49:00,200
Now, if I remember correctly, and I probably don't, but if I remember,

1177
00:49:00,200 --> 00:49:06,600
I remember correctly in x64 on Windows 64-bit, the first 8, terabytes

1178
00:49:06,600 --> 00:49:07,100
of address.

1179
00:49:07,100 --> 00:49:09,200
Space are reserved for the application.

1180
00:49:10,000 --> 00:49:16,100
So, so basically, if I wanted to, I could do something like, say,

1181
00:49:16,400 --> 00:49:22,300
That's, I don't know, you know, this thing gets one more guy, which is

1182
00:49:22,300 --> 00:49:24,300
terabytes, right?

1183
00:49:25,100 --> 00:49:29,700
And that's GB x 1024 and I basically say that the Base address.

1184
00:49:30,000 --> 00:49:34,000
It's that one terabyte or two terabytes, who cares?

1185
00:49:34,100 --> 00:49:36,100
And of course we got to do our cast again.

1186
00:49:36,600 --> 00:49:38,000
Probably with terabytes.

1187
00:49:38,200 --> 00:49:41,000
We could just flat out say that you needed to cast it in here.

1188
00:49:41,000 --> 00:49:42,800
But yeah.

1189
00:49:46,200 --> 00:49:47,000
Yeah, I don't know.

1190
00:49:47,000 --> 00:49:49,800
We yeah, it's so hard to tell sometimes.

1191
00:49:57,900 --> 00:50:02,300
You see the thing is if I make it 64-bit that it always has to be done

1192
00:50:02,300 --> 00:50:02,900
a 64-bit.

1193
00:50:02,900 --> 00:50:05,600
Even if you knew that didn't need to be done a 64-bit.

1194
00:50:08,000 --> 00:50:09,100
I don't know.

1195
00:50:09,800 --> 00:50:13,000
I don't know, ladies and gentlemen, I do not know.

1196
00:50:13,500 --> 00:50:18,200
Should these always use 64 bits question, mark.

1197
00:50:18,400 --> 00:50:20,600
It has that total rise at the end.

1198
00:50:20,600 --> 00:50:23,800
That tells you that you don't know what you're coding.

1199
00:50:23,800 --> 00:50:27,300
You're just flat-out making stuff up as you go along, and

1200
00:50:27,500 --> 00:50:31,500
Gentlemen, that is a lot about what coding is.

1201
00:50:31,500 --> 00:50:34,600
So I'm going to basically say we're going to pull these guys.

1202
00:50:34,600 --> 00:50:38,100
First of all I'm going to do it like this and that way we just have

1203
00:50:38,100 --> 00:50:40,800
one Base address and we always try to get that Base address.

1204
00:50:41,500 --> 00:50:46,100
I'm going to say that we basically put the put the permanent storage

1205
00:50:46,100 --> 00:50:46,700
first.

1206
00:50:46,800 --> 00:50:47,600
Why not?

1207
00:50:48,000 --> 00:50:49,500
I don't see any reason why not.

1208
00:50:49,700 --> 00:50:53,500
So I'm going to say we wanted we want to take the the total size.

1209
00:50:53,900 --> 00:50:55,900
So let's say that we've got that value.

1210
00:50:55,900 --> 00:50:57,300
We've got total size.

1211
00:50:57,400 --> 00:50:57,800
Size.

1212
00:50:58,000 --> 00:50:59,800
And total size is just equal to the

1213
00:51:00,000 --> 00:51:00,800
Mm in size.

1214
00:51:01,400 --> 00:51:05,000
Plus, the transient size should be fun.

1215
00:51:05,100 --> 00:51:06,900
I don't see any reason why it wouldn't be fine.

1216
00:51:07,500 --> 00:51:12,800
And then I will allocate total size after we are done allocating total

1217
00:51:12,800 --> 00:51:13,300
size.

1218
00:51:13,300 --> 00:51:17,100
I will assign the transient store is to just be the permanent storage.

1219
00:51:17,600 --> 00:51:22,200
Basically bumped up by the permanent storage size.

1220
00:51:22,200 --> 00:51:22,800
There we go.

1221
00:51:23,200 --> 00:51:23,900
So I'm going to do it.

1222
00:51:23,900 --> 00:51:24,200
That way.

1223
00:51:24,200 --> 00:51:27,400
I said I wasn't going to but I wanted to anyway just like at That Base

1224
00:51:27,400 --> 00:51:28,100
address in there.

1225
00:51:28,100 --> 00:51:29,400
Alright, so there we go.

1226
00:51:30,400 --> 00:51:32,500
So that in theory should do it.

1227
00:51:32,500 --> 00:51:35,300
I allocate the total size, ask for it, the Base address, then I go

1228
00:51:35,300 --> 00:51:39,000
ahead and make the transient storage, be where the permanent storage

1229
00:51:39,000 --> 00:51:40,900
is plus, the permanent sort of size.

1230
00:51:41,200 --> 00:51:43,600
Seems pretty good.

1231
00:51:43,700 --> 00:51:45,200
Seems pretty good.

1232
00:51:45,200 --> 00:51:46,100
Okay.

1233
00:51:48,900 --> 00:51:52,600
Yeah, let's take a look at that virtual Alec.

1234
00:51:53,100 --> 00:51:54,100
So here we go.

1235
00:51:54,500 --> 00:51:55,200
Come in here.

1236
00:51:55,200 --> 00:51:56,400
What's our total size?

1237
00:51:56,800 --> 00:51:58,800
Make sure that this is a nice big old number.

1238
00:51:58,800 --> 00:51:59,600
Yes, it is.

1239
00:52:00,200 --> 00:52:01,600
We're going to allocate that.

1240
00:52:01,900 --> 00:52:02,800
Did we get it?

1241
00:52:03,100 --> 00:52:04,500
We did get it.

1242
00:52:04,600 --> 00:52:05,700
And what is that?

1243
00:52:05,700 --> 00:52:06,700
Number come out to be.

1244
00:52:06,700 --> 00:52:07,800
That looks about right?

1245
00:52:07,800 --> 00:52:10,200
64 Meg's across.

1246
00:52:10,300 --> 00:52:12,100
Where's Great?

1247
00:52:12,100 --> 00:52:12,500
Can't?

1248
00:52:12,500 --> 00:52:12,800
Yeah.

1249
00:52:13,000 --> 00:52:13,700
Yeah, of course.

1250
00:52:13,700 --> 00:52:16,300
It doesn't want to play that I wanted you to play it in decimal.

1251
00:52:16,300 --> 00:52:17,300
You didn't do it.

1252
00:52:17,300 --> 00:52:18,500
I don't know why you didn't do it.

1253
00:52:18,800 --> 00:52:20,600
I could force it to but I don't really want to.

1254
00:52:20,600 --> 00:52:25,200
Alright, so off we go and let's take a look here at whether game

1255
00:52:25,200 --> 00:52:29,400
memory actually gave us the address that we actually asked for.

1256
00:52:29,400 --> 00:52:29,800
So we

1257
00:52:29,900 --> 00:52:32,900
We asked for Base address.

1258
00:52:33,200 --> 00:52:35,300
All right, that's what we asked for.

1259
00:52:35,800 --> 00:52:38,200
What what's going on here?

1260
00:52:38,800 --> 00:52:39,700
Oh, great.

1261
00:52:40,100 --> 00:52:42,100
So does that mean we actually do?

1262
00:52:42,100 --> 00:52:45,500
We actually have to force it to be inside the other thing because we

1263
00:52:45,500 --> 00:52:47,300
couldn't we didn't coerce it in time.

1264
00:52:47,300 --> 00:52:49,500
Basically, fantastic.

1265
00:52:49,500 --> 00:52:51,600
Ladies and gentlemen, so, I guess that answers our question.

1266
00:52:51,900 --> 00:52:54,300
We're basically going to have to force this to do it this way.

1267
00:52:54,300 --> 00:52:57,200
I assume, I don't actually know if that's a good way or not.

1268
00:52:58,400 --> 00:52:59,600
But it answers our question.

1269
00:52:59,600 --> 00:53:01,900
I guess, unless I'm wrong about what's going on there.

1270
00:53:02,000 --> 00:53:02,800
Let's take a look.

1271
00:53:04,000 --> 00:53:05,100
Let's take a look.

1272
00:53:07,700 --> 00:53:11,100
But still wrong, I know what's going on.

1273
00:53:11,100 --> 00:53:11,400
What am I?

1274
00:53:11,500 --> 00:53:13,900
Oh, do I have a?

1275
00:53:13,900 --> 00:53:14,900
Yeah, that's great.

1276
00:53:15,000 --> 00:53:15,900
I flipped the cases.

1277
00:53:16,800 --> 00:53:17,300
That's dumb.

1278
00:53:17,700 --> 00:53:19,400
So I never assume.

1279
00:53:19,400 --> 00:53:20,500
You know what the problem is.

1280
00:53:20,500 --> 00:53:20,900
Really?

1281
00:53:20,900 --> 00:53:23,800
That's the thing, you think something is Trivial, you know what the

1282
00:53:23,800 --> 00:53:27,200
problem is, but you don't write you just pretend.

1283
00:53:27,200 --> 00:53:27,900
You know what the problem is.

1284
00:53:27,900 --> 00:53:30,000
The problem is actually that I have this case reversed.

1285
00:53:30,000 --> 00:53:32,600
It was always initialize them to 0 instead of my terabytes value.

1286
00:53:33,200 --> 00:53:36,500
So I actually need to do this at least I don't think I did.

1287
00:53:36,600 --> 00:53:37,000
There we go.

1288
00:53:39,100 --> 00:53:39,500
Oops.

1289
00:53:41,300 --> 00:53:43,400
Cannot convert to LP void.

1290
00:53:43,400 --> 00:53:45,800
That is fine because we're just going to cast that.

1291
00:53:46,400 --> 00:53:47,100
There we go.

1292
00:53:47,900 --> 00:53:48,500
Let's take a look.

1293
00:53:48,500 --> 00:53:48,900
Now.

1294
00:53:48,900 --> 00:53:50,800
If I actually got my Base address, there we go.

1295
00:53:50,800 --> 00:53:51,600
That's what I wanted.

1296
00:53:51,600 --> 00:53:53,200
So does virtual Alex exceed.

1297
00:53:53,200 --> 00:53:53,600
Oops?

1298
00:53:54,100 --> 00:53:54,600
Awesome.

1299
00:53:55,400 --> 00:53:57,200
The Perils of undue as well.

1300
00:53:57,200 --> 00:53:57,400
Boy.

1301
00:53:57,400 --> 00:53:59,700
This is just this is just not going my way here.

1302
00:53:59,700 --> 00:53:59,800
These

1303
00:54:00,000 --> 00:54:03,600
Last few minutes, it was going so well, there and then I just kind of

1304
00:54:03,600 --> 00:54:04,400
spazzed out on you.

1305
00:54:04,400 --> 00:54:05,500
I apologize for that.

1306
00:54:05,800 --> 00:54:07,200
I don't know why I wrote the code.

1307
00:54:07,200 --> 00:54:08,900
Right the first time at least.

1308
00:54:08,900 --> 00:54:09,900
Well, I assume you read it right?

1309
00:54:09,900 --> 00:54:10,600
Maybe it was wrong.

1310
00:54:10,600 --> 00:54:15,500
The first time as well and then we can feel better about ourselves for

1311
00:54:15,700 --> 00:54:16,800
for being wrong.

1312
00:54:16,800 --> 00:54:17,200
I guess.

1313
00:54:17,200 --> 00:54:18,000
Let's see here.

1314
00:54:18,000 --> 00:54:18,600
Okay.

1315
00:54:18,900 --> 00:54:21,900
I'm going to add the permanent storage size in their cast.

1316
00:54:21,900 --> 00:54:23,400
This to a bite pointer.

1317
00:54:23,400 --> 00:54:25,400
So that we are advancing by B.

1318
00:54:25,600 --> 00:54:28,500
Add the number of bytes the permanent storage takes up, which gives me

1319
00:54:28,500 --> 00:54:29,800
the rest that.

1320
00:54:30,000 --> 00:54:30,900
It should do it there.

1321
00:54:31,000 --> 00:54:31,600
There we go.

1322
00:54:31,800 --> 00:54:33,000
And let's take a look.

1323
00:54:33,200 --> 00:54:34,000
See what we got.

1324
00:54:35,000 --> 00:54:35,700
All right.

1325
00:54:35,800 --> 00:54:40,500
So the transient storage size, the permanent storage size, both set

1326
00:54:40,500 --> 00:54:40,900
properly.

1327
00:54:40,900 --> 00:54:42,300
The total size looks right.

1328
00:54:42,300 --> 00:54:43,700
Base address looks right.

1329
00:54:44,000 --> 00:54:45,900
Let's see if we got our permanent storage.

1330
00:54:45,900 --> 00:54:46,500
We did.

1331
00:54:46,500 --> 00:54:47,300
It's at the location.

1332
00:54:47,300 --> 00:54:48,000
We want.

1333
00:54:48,000 --> 00:54:52,300
Even better is the transient storage up above where it should be.

1334
00:54:52,300 --> 00:54:52,600
Yes.

1335
00:54:52,600 --> 00:54:53,600
It is.

1336
00:54:54,100 --> 00:54:57,100
Everything is coming up roses Now ladies and gentlemen, it is

1337
00:54:57,100 --> 00:54:57,600
beautiful.

1338
00:54:57,800 --> 00:55:00,900
All right, so that's all well and good.

1339
00:55:00,900 --> 00:55:02,400
That looks fantastic.

1340
00:55:02,900 --> 00:55:04,200
I don't see anything wrong.

1341
00:55:04,300 --> 00:55:05,300
Wrong with that.

1342
00:55:06,100 --> 00:55:07,400
I think we're all good.

1343
00:55:07,700 --> 00:55:11,800
I think that was everything that I wanted to do today, even accept

1344
00:55:11,800 --> 00:55:15,300
keyboard, which I guess we'll save for tomorrow, but that is it.

1345
00:55:15,600 --> 00:55:18,700
That is all there is we can now have a full on party.

1346
00:55:19,500 --> 00:55:22,100
I'm trying to think if there's anything else we need to do here.

1347
00:55:22,500 --> 00:55:25,000
But really we are getting down to the last of it.

1348
00:55:25,000 --> 00:55:27,500
Ladies and gentlemen, we are getting down to the last of it.

1349
00:55:27,900 --> 00:55:30,500
There is not a lot left that we have to do.

1350
00:55:32,000 --> 00:55:35,500
Now, one of the interesting things here is the win32 resize dip

1351
00:55:35,500 --> 00:55:36,400
section Guy.

1352
00:55:37,300 --> 00:55:38,400
This is pretty interesting.

1353
00:55:38,600 --> 00:55:40,800
We could actually pull that allocation as well.

1354
00:55:41,100 --> 00:55:42,600
We could actually just have one Alec.

1355
00:55:42,700 --> 00:55:45,700
I don't know that we really need to do that, but we could that's all

1356
00:55:45,700 --> 00:55:46,200
I'm saying.

1357
00:55:49,300 --> 00:55:51,600
You know, I like I said, I think I think I'm out.

1358
00:55:51,600 --> 00:55:52,500
I'm out of stuff.

1359
00:55:52,500 --> 00:55:54,600
I would have to start on something, totally new.

1360
00:55:55,100 --> 00:55:56,400
We may go to the Q&A early.

1361
00:55:56,400 --> 00:55:57,600
That's how well that went.

1362
00:55:57,900 --> 00:55:59,100
That's how well that went.

1363
00:55:59,500 --> 00:56:00,800
Mmm-hmm.

1364
00:56:03,000 --> 00:56:03,600
Yeah.

1365
00:56:03,900 --> 00:56:04,200
Yeah.

1366
00:56:04,200 --> 00:56:07,700
I don't have, I don't have a lot to say other than to basically say

1367
00:56:07,700 --> 00:56:11,300
that that that looks like trying to think a lot through your did.

1368
00:56:11,300 --> 00:56:11,600
I'll eat?

1369
00:56:11,600 --> 00:56:14,700
Did I say like, oh, I'm going to talk about something and then not

1370
00:56:14,700 --> 00:56:15,500
talk about it.

1371
00:56:16,000 --> 00:56:18,100
So tomorrow we'll just clean up the input.

1372
00:56:18,300 --> 00:56:19,400
I think that'll be it.

1373
00:56:20,000 --> 00:56:21,400
That's looking pretty good.

1374
00:56:21,800 --> 00:56:23,700
Lookin pretty good here.

1375
00:56:24,200 --> 00:56:25,900
Yeah, I guess we could.

1376
00:56:25,900 --> 00:56:27,900
We could have tried to pass the timer.

1377
00:56:29,300 --> 00:56:31,800
I don't know if we really want to do that, but we could have done it,

1378
00:56:31,800 --> 00:56:32,000
right?

1379
00:56:32,000 --> 00:56:36,200
We could we got time I guess we might as well might as well past the

1380
00:56:36,200 --> 00:56:36,700
timer.

1381
00:56:37,900 --> 00:56:40,200
Yeah, I don't know some kind of seconds elapsed thing.

1382
00:56:40,400 --> 00:56:43,000
So we basically I could guess I'll just have to pass it and say we're

1383
00:56:43,000 --> 00:56:44,300
going to we're going to find it later.

1384
00:56:44,700 --> 00:56:47,000
So basically the last thing we need, right?

1385
00:56:47,300 --> 00:56:48,000
Is a game.

1386
00:56:48,200 --> 00:56:50,700
Clocks, you know, kind of thing, right?

1387
00:56:51,000 --> 00:56:52,600
And we don't know what's going to be in here.

1388
00:56:52,600 --> 00:56:53,800
Something's going to be in here.

1389
00:56:53,900 --> 00:56:54,400
Right?

1390
00:56:54,700 --> 00:56:58,300
And at the very least we know samples elapsed is kind of in here.

1391
00:56:58,600 --> 00:56:59,800
We're kind of passing that up.

1392
00:57:00,000 --> 00:57:02,900
Here, so I guess we don't need that that clock.

1393
00:57:03,200 --> 00:57:05,200
So really, all we need is the wall clock.

1394
00:57:05,400 --> 00:57:09,800
The wall clock is probably in some kind of ambiguous ticks per second.

1395
00:57:09,900 --> 00:57:11,700
So I don't know that we want to do that.

1396
00:57:11,800 --> 00:57:15,900
We may just want to do a straight ahead seconds elapsed since last

1397
00:57:15,900 --> 00:57:18,100
time kind of clock, that sort of thing.

1398
00:57:18,800 --> 00:57:21,600
So maybe we'll think about that for next time.

1399
00:57:22,000 --> 00:57:24,300
Let's just say this is a to do Casey.

1400
00:57:25,300 --> 00:57:26,500
What do you want to pass?

1401
00:57:26,800 --> 00:57:29,600
What do we want to pass here?

1402
00:57:30,100 --> 00:57:33,000
We could also pass like what we think our frame update hurts.

1403
00:57:33,000 --> 00:57:35,400
Is that sort of thing, but point being we know we're going to need

1404
00:57:35,400 --> 00:57:35,800
this.

1405
00:57:36,200 --> 00:57:39,000
So we might, as well, say, clocks here.

1406
00:57:39,300 --> 00:57:39,600
You know what?

1407
00:57:39,600 --> 00:57:40,700
The other thing we could do.

1408
00:57:41,400 --> 00:57:44,800
I might like this even better is, since that's technically input.

1409
00:57:45,000 --> 00:57:46,900
We could basically put it here, right?

1410
00:57:46,900 --> 00:57:47,800
We could do something here.

1411
00:57:48,000 --> 00:57:48,800
So, uh, you know what?

1412
00:57:48,800 --> 00:57:49,600
That's what we're going to do.

1413
00:57:49,900 --> 00:57:55,300
We're going to say to do Casey insert clock value here.

1414
00:57:55,300 --> 00:57:56,900
And we'll pass that in tomorrow.

1415
00:57:57,300 --> 00:57:57,700
Yeah.

1416
00:57:58,200 --> 00:57:58,500
Yeah.

1417
00:57:58,600 --> 00:57:59,800
That looks good to me because basically, I

1418
00:58:00,000 --> 00:58:00,800
Here, what we did.

1419
00:58:01,000 --> 00:58:02,000
We had a timer.

1420
00:58:02,000 --> 00:58:03,100
We did in our dtsc.

1421
00:58:03,100 --> 00:58:04,500
We did a query performance counters.

1422
00:58:04,500 --> 00:58:08,500
So we know how long the last frame took to complete.

1423
00:58:08,600 --> 00:58:10,500
And so let's, let's let's think about that.

1424
00:58:10,500 --> 00:58:13,600
Well, we'll put that in here, insert clock values here.

1425
00:58:13,700 --> 00:58:15,100
Those will be part of the input.

1426
00:58:15,200 --> 00:58:19,200
We could even consider making the sample, the sample counts as like.

1427
00:58:19,200 --> 00:58:22,500
How many, how far the audio clock Advanced be part of this as well.

1428
00:58:22,500 --> 00:58:23,800
We'll think about that a little bit later.

1429
00:58:24,100 --> 00:58:24,700
All right.

1430
00:58:24,700 --> 00:58:26,500
I'm reasonably happy with where this is.

1431
00:58:26,600 --> 00:58:27,900
I think that's about it.

1432
00:58:28,100 --> 00:58:29,800
So I'm going to say it is time.

1433
00:58:29,900 --> 00:58:31,900
I'm for the Q&A.

1434
00:58:33,200 --> 00:58:36,700
So please remember to put seem your atory.

1435
00:58:36,700 --> 00:58:38,000
In your question.

1436
00:58:39,000 --> 00:58:43,800
And please keep the questions to being about code.

1437
00:58:43,800 --> 00:58:48,800
We've already done as much as possible because otherwise we're

1438
00:58:48,800 --> 00:58:51,200
answering questions about speculative code in the future.

1439
00:58:51,200 --> 00:58:53,300
Like how do you do the physics thing?

1440
00:58:53,300 --> 00:58:55,800
Where it bounces off the wall, but we're going to get to all that

1441
00:58:55,800 --> 00:58:58,600
stuff and there's really no way for me to answer questions about that.

1442
00:58:58,600 --> 00:58:59,800
Now that are good aren't going.

1443
00:59:00,000 --> 00:59:03,400
Vastly inferior to when I actually show you how to do it for reals.

1444
00:59:03,600 --> 00:59:06,500
So please try to keep your stuff that we've done today or in previous

1445
00:59:06,500 --> 00:59:10,200
day's unless we literally run out of questions in which case, then we

1446
00:59:10,200 --> 00:59:13,700
can go Hog Wild, but for now, let's try and keep it under control.

1447
00:59:13,700 --> 00:59:15,100
Okay, let's take a look.

1448
00:59:19,300 --> 00:59:21,100
Let's take a look.

1449
00:59:21,200 --> 00:59:23,800
Can you go over the benefits and reasoning of a main memory pool

1450
00:59:23,800 --> 00:59:25,300
versus Dynamic allocation?

1451
00:59:25,300 --> 00:59:26,400
Yes, I can.

1452
00:59:26,500 --> 00:59:27,500
I certainly can.

1453
00:59:28,000 --> 00:59:29,300
So basically.

1454
00:59:31,500 --> 00:59:36,200
I don't like lying to myself when I'm programming is I guess how I

1455
00:59:36,200 --> 00:59:41,300
would say it and dynamic allocation is like lying to yourself because

1456
00:59:41,600 --> 00:59:47,300
they're either is or isn't a hard limit to the amount of memory in the

1457
00:59:47,300 --> 00:59:47,900
machine.

1458
00:59:48,100 --> 00:59:51,400
If there's no limit to the memory in the machine, then you don't need

1459
00:59:51,400 --> 00:59:52,400
memory management, right?

1460
00:59:52,400 --> 00:59:54,700
You just just allocate and never free.

1461
00:59:54,700 --> 00:59:59,600
You just you'd allocate Infinity GB and all your allocator would do is

1462
00:59:59,600 --> 00:59:59,800
just

1463
01:00:00,000 --> 01:00:04,500
Use the next contiguous b as you went to make stuff, right, but if

1464
01:00:04,500 --> 01:00:07,600
there is a limited amount of memory in the machine, which is actually

1465
01:00:07,600 --> 01:00:11,900
a real source, which is actually a hard limit that you think about on

1466
01:00:11,900 --> 01:00:14,100
something, like a mobile phone or a console, actually, right?

1467
01:00:14,100 --> 01:00:17,700
There aren't virtual memory systems on those, on those platforms.

1468
01:00:17,700 --> 01:00:20,500
Sometimes, depending on which one you're talking about.

1469
01:00:21,200 --> 01:00:25,500
If there is a hard limit, then Dynamic allocation is essentially lying

1470
01:00:25,500 --> 01:00:26,200
to yourself.

1471
01:00:26,300 --> 01:00:29,800
It's saying you think that there's

1472
01:00:30,000 --> 01:00:35,700
Some way for an alligator to to make this program run without

1473
01:00:35,700 --> 01:00:37,200
overflowing its memory bound.

1474
01:00:37,400 --> 01:00:41,300
But you never actually proved that for all, you know, your pattern of

1475
01:00:41,300 --> 01:00:44,400
allocation may leave holes in the memory that can't be refilled.

1476
01:00:44,400 --> 01:00:48,700
So you've got fragmentation and it can't fix that or you've got some

1477
01:00:48,700 --> 01:00:51,900
situation where you actually need more memory than you thought you did

1478
01:00:51,900 --> 01:00:52,700
and you don't.

1479
01:00:52,700 --> 01:00:55,900
And so you're running on 206 Meg, platform and it turns out you need

1480
01:00:55,900 --> 01:00:59,700
257 MB sometimes but you never realize that

1481
01:01:00,000 --> 01:01:02,300
So I don't like lying to myself in that way.

1482
01:01:02,800 --> 01:01:06,800
I like to say you have a certain amount of memory that your game runs

1483
01:01:06,800 --> 01:01:10,100
in and it is guaranteed to run in that.

1484
01:01:10,100 --> 01:01:16,400
So we actually wrote the code knowing provably that it does run in

1485
01:01:16,400 --> 01:01:18,200
that amount of memory, right?

1486
01:01:18,500 --> 01:01:20,500
That's that's what I prefer.

1487
01:01:21,200 --> 01:01:26,000
And so the reason that I don't like Dynamic allocation is because if

1488
01:01:26,000 --> 01:01:29,400
your allocations are truly Dynamic, then you can't make that

1489
01:01:29,400 --> 01:01:29,800
statement.

1490
01:01:29,900 --> 01:01:33,100
You have no idea actually, whether your game works or not.

1491
01:01:33,300 --> 01:01:38,100
You're just hoping that it does and on a PC most of the time it does,

1492
01:01:38,200 --> 01:01:40,300
because there aren't any hard memory constraints.

1493
01:01:40,300 --> 01:01:43,500
The operating system, just steps in and takes care of things for you.

1494
01:01:45,100 --> 01:01:47,100
So that's really why I do it.

1495
01:01:47,100 --> 01:01:53,100
I just like to know that I design systems that have hard guarantees on

1496
01:01:53,100 --> 01:01:54,200
the fact that they will run.

1497
01:01:54,700 --> 01:01:57,200
If you don't care about that, then there's nothing wrong with Dynamic

1498
01:01:57,200 --> 01:01:58,000
allocation, right?

1499
01:01:58,000 --> 01:02:00,600
You can just go Hog Wild and hey if the game runs it runs have done.

1500
01:02:00,600 --> 01:02:01,200
It doesn't.

1501
01:02:06,400 --> 01:02:07,700
That's really all there is to it.

1502
01:02:07,900 --> 01:02:10,100
So I don't necessarily think it's a pro/con thing.

1503
01:02:10,300 --> 01:02:14,300
It's just I like to design systems that that are guaranteed to work.

1504
01:02:14,700 --> 01:02:18,000
When I am talking about things that ship to an end user, who is not a

1505
01:02:18,000 --> 01:02:20,900
technical person, like, you know, a person who's playing game.

1506
01:02:22,500 --> 01:02:26,400
I want to basically say if this game starts up, if it can allocate the

1507
01:02:26,400 --> 01:02:28,600
memory that is required on Startup, then it will run.

1508
01:02:29,100 --> 01:02:31,200
And if it can't, it will tell you and it will print out an error.

1509
01:02:31,200 --> 01:02:34,100
Message that says, you need at least four gigabytes to run this game.

1510
01:02:35,200 --> 01:02:40,400
That's how I would prefer the world worked and not I got to the point

1511
01:02:40,400 --> 01:02:44,800
where I was holding down the button and it made too many shells fire

1512
01:02:44,800 --> 01:02:49,300
out of the gun and that overflowed, how many things there were.

1513
01:02:49,300 --> 01:02:52,200
And it crashed because I like was shooting for a really long time and

1514
01:02:52,200 --> 01:02:55,600
they're too many shells piled up in one place and and whatever, right?

1515
01:02:55,600 --> 01:02:56,800
I just, I just don't like that.

1516
01:02:57,000 --> 01:02:59,800
So I want to know that the game has hardbound.

1517
01:03:00,000 --> 01:03:02,500
On its runtime and its memory usage.

1518
01:03:04,200 --> 01:03:05,100
I hope that answered the question.

1519
01:03:05,100 --> 01:03:11,900
If it didn't ask again, Matt because I will, I will elaborate on a

1520
01:03:11,900 --> 01:03:14,500
different part if that was not the part you were asking about.

1521
01:03:19,700 --> 01:03:20,700
Are there, good?

1522
01:03:20,800 --> 01:03:26,800
Whoa, wait, okay.

1523
01:03:27,700 --> 01:03:30,100
I need a better system for tracking which questions I've answered in.

1524
01:03:30,500 --> 01:03:34,900
Okay, why use the void star instruct game memory?

1525
01:03:36,400 --> 01:03:38,100
Well, because we don't know what's going in there.

1526
01:03:38,900 --> 01:03:40,700
We could we don't know what's.

1527
01:03:40,700 --> 01:03:42,200
It's just a big old block of memory.

1528
01:03:42,200 --> 01:03:44,500
So we can't give it a type because we don't know what the type is.

1529
01:03:44,500 --> 01:03:46,400
It's just a huge block of memory that the game's going to treat

1530
01:03:46,400 --> 01:03:47,200
however, at once.

1531
01:03:47,500 --> 01:03:48,000
So The Voice.

1532
01:03:48,200 --> 01:03:49,800
As the saying we don't know what this is.

1533
01:03:49,800 --> 01:03:52,800
It's a glob of memory, do whatever you want with it, have a party.

1534
01:03:52,900 --> 01:03:54,200
It's not our problem anymore.

1535
01:03:54,300 --> 01:03:54,800
Right?

1536
01:03:55,200 --> 01:03:58,300
And then basically what the game's going to do is the game and it

1537
01:03:58,300 --> 01:04:00,800
already does this to a limited degree, right?

1538
01:04:00,800 --> 01:04:03,300
It just flat out cold, casts it, right.

1539
01:04:03,300 --> 01:04:07,400
It just goes, you know, I'm going to cold cast it to a game State and

1540
01:04:07,400 --> 01:04:09,900
now it's all typed from now on, right?

1541
01:04:09,900 --> 01:04:12,300
Because the game's kadel Point into it and whatever.

1542
01:04:14,500 --> 01:04:15,500
Can you elaborate on your screen?

1543
01:04:15,500 --> 01:04:19,600
Print permanent and transient storage with gameobject examples?

1544
01:04:19,800 --> 01:04:21,100
Yes, I can.

1545
01:04:21,700 --> 01:04:29,400
Basically, so the reason I wanted to separate those two was just

1546
01:04:29,400 --> 01:04:35,800
because the permanent store is non-negotiable, but the transient store

1547
01:04:35,800 --> 01:04:36,400
is.

1548
01:04:39,000 --> 01:04:42,800
The permanent store is basically what the game needs to run.

1549
01:04:43,000 --> 01:04:47,100
So basically that is like the entity states where the player is like

1550
01:04:47,100 --> 01:04:49,200
what the unlocks are like, all that stuff.

1551
01:04:49,600 --> 01:04:50,100
Right?

1552
01:04:50,500 --> 01:04:53,100
And I wanted to differentiate between that.

1553
01:04:54,400 --> 01:04:58,600
And like the render stack, the like cached version of all the

1554
01:04:58,600 --> 01:05:03,200
textures, the sounds that are playing at the moment, like all that

1555
01:05:03,200 --> 01:05:07,500
stuff that can be recreated and loaded off disk again, whatever.

1556
01:05:08,000 --> 01:05:09,700
I want to distinguish between those two.

1557
01:05:10,900 --> 01:05:13,500
There's a couple reasons for distinguishing, those two that are maybe

1558
01:05:13,500 --> 01:05:14,300
not obvious.

1559
01:05:14,800 --> 01:05:19,800
One of them is that we could flush the transient store and leave the

1560
01:05:19,800 --> 01:05:20,700
permanent store.

1561
01:05:21,200 --> 01:05:24,400
And that would be like if our app needed to minimize its footprint for

1562
01:05:24,400 --> 01:05:27,900
some reason, which was a real thing on iPhones, for example, but

1563
01:05:27,900 --> 01:05:32,600
another circumstance might be the transient store got wiped out by an

1564
01:05:32,600 --> 01:05:33,600
oh&s event.

1565
01:05:33,600 --> 01:05:37,800
Like, you know, I don't I mean I this is not realistic.

1566
01:05:39,400 --> 01:05:44,600
I mean, you could think of it, sort of like, mentally preparing for

1567
01:05:44,600 --> 01:05:48,000
things, like direct3d lost your surfaces, or stuff like this, that

1568
01:05:48,000 --> 01:05:48,700
used to happen.

1569
01:05:48,700 --> 01:05:49,000
I don't know.

1570
01:05:49,000 --> 01:05:51,500
So it's, it's really not that necessary.

1571
01:05:51,500 --> 01:05:54,100
I like to do it because it kind of, it's a little bit of mental

1572
01:05:54,100 --> 01:05:56,000
discipline, but we could throw it all in one place.

1573
01:05:56,000 --> 01:05:57,900
There are some things I might do later.

1574
01:05:58,400 --> 01:05:59,600
We're else I'll show you.

1575
01:05:59,600 --> 01:05:59,800
I'll be

1576
01:06:00,500 --> 01:06:02,300
Do you see why I wanted to separate them?

1577
01:06:02,300 --> 01:06:05,200
Because I pulled this little trick and the trick wouldn't have been

1578
01:06:05,200 --> 01:06:08,000
possible without it, but honestly, like is it a big deal?

1579
01:06:08,000 --> 01:06:09,300
No, it's not.

1580
01:06:12,100 --> 01:06:13,200
And oh, and another thing is

1581
01:06:14,700 --> 01:06:15,400
the always right?

1582
01:06:15,400 --> 01:06:16,000
The usage code.

1583
01:06:16,000 --> 01:06:18,400
First thing is still in effect here.

1584
01:06:18,900 --> 01:06:23,000
I may want more Arenas than three or two rather.

1585
01:06:23,200 --> 01:06:26,100
So this is the bare minimum that I needed.

1586
01:06:26,100 --> 01:06:28,700
I just I threw the transient storage in there because I knew I was

1587
01:06:28,700 --> 01:06:29,500
going to need it.

1588
01:06:29,600 --> 01:06:32,200
But really like, we haven't finished, writing the usage code.

1589
01:06:32,200 --> 01:06:35,100
The game will dictate what those actual things are.

1590
01:06:35,100 --> 01:06:38,000
How many partitions there are the outer thing.

1591
01:06:38,000 --> 01:06:41,300
So those aren't final either, we may we may decide we want three

1592
01:06:41,300 --> 01:06:43,700
different things in there or something like that.

1593
01:06:43,700 --> 01:06:44,300
So the right.

1594
01:06:44,500 --> 01:06:44,800
Is code.

1595
01:06:44,800 --> 01:06:46,600
First is still in an effect here.

1596
01:06:46,800 --> 01:06:49,500
We just haven't gotten to a point in the game where we actually can

1597
01:06:49,500 --> 01:06:53,600
write the usage goes first, but when we can will back change the API

1598
01:06:53,600 --> 01:06:56,300
to fit our needs not the other way around.

1599
01:06:59,700 --> 01:07:01,400
Let's see.

1600
01:07:04,400 --> 01:07:07,600
Is the code going to be posted on GitHub know, the code is commercial.

1601
01:07:08,900 --> 01:07:10,900
It's not, you can't post it on GitHub.

1602
01:07:10,900 --> 01:07:13,000
It's you have to, if that's part of the pre-order.

1603
01:07:13,000 --> 01:07:13,900
It's part of the like bonus.

1604
01:07:13,900 --> 01:07:16,300
You get for pre-ordering the game as you get to the source code.

1605
01:07:16,400 --> 01:07:21,000
So no, you're not supposed to release the source code, its commercial

1606
01:07:21,200 --> 01:07:22,300
at the moment.

1607
01:07:22,300 --> 01:07:24,200
Eventually, you can read down here.

1608
01:07:24,200 --> 01:07:28,300
It's got a license that eventually it will be released in the public

1609
01:07:28,300 --> 01:07:28,800
domain.

1610
01:07:28,900 --> 01:07:30,300
But until then, it's commercial.

1611
01:07:34,000 --> 01:07:35,200
Let's see.

1612
01:07:38,600 --> 01:07:42,200
Could you briefly explain what you meant by avoiding round trips for

1613
01:07:42,200 --> 01:07:43,200
memory allocation.

1614
01:07:43,700 --> 01:07:48,000
So basically a round trip is when the platform layer calls the game

1615
01:07:48,000 --> 01:07:50,800
and the game calls back to the platform layer, right?

1616
01:07:51,000 --> 01:07:56,100
So basically what that looks like is is this let's say I wanted to do

1617
01:07:56,100 --> 01:07:57,000
virtual a lock.

1618
01:07:57,100 --> 01:07:58,100
I want to do a virtual.

1619
01:07:58,100 --> 01:08:04,800
Alright, so I've got internal void platform, allocate write void, star

1620
01:08:05,000 --> 01:08:07,300
size, T size or something, like this.

1621
01:08:08,100 --> 01:08:08,300
I go.

1622
01:08:08,500 --> 01:08:08,700
Had.

1623
01:08:08,700 --> 01:08:10,600
And that this is I mean, we don't even need the size T.

1624
01:08:10,600 --> 01:08:12,600
We could say it 64 or something like that.

1625
01:08:12,600 --> 01:08:12,800
Size.

1626
01:08:12,800 --> 01:08:13,800
T is another type.

1627
01:08:13,800 --> 01:08:16,000
That's guaranteed to be the memory size, blah blah, blah.

1628
01:08:16,200 --> 01:08:16,899
You can ignore that.

1629
01:08:16,899 --> 01:08:18,899
It's not relevant and we're not going to use it.

1630
01:08:18,899 --> 01:08:23,100
But point being, you would have something like this where you did

1631
01:08:23,200 --> 01:08:28,500
result equals virtual Alec and then virtual Alec would take, you know,

1632
01:08:28,500 --> 01:08:32,700
the size and the other parameters here and then we return it, right.

1633
01:08:33,700 --> 01:08:36,200
And so, basically what would happen in game update and render, if it

1634
01:08:36,200 --> 01:08:37,899
didn't have memory passed into it.

1635
01:08:37,899 --> 01:08:39,600
It would call platform allocate here.

1636
01:08:40,100 --> 01:08:43,200
So basically, the platform layer called the game game update and

1637
01:08:43,200 --> 01:08:46,200
render, then the game turned right around and call the platform layer

1638
01:08:46,200 --> 01:08:46,800
back.

1639
01:08:46,899 --> 01:08:48,000
So, we've got a stack.

1640
01:08:48,000 --> 01:08:50,600
We've got a stack platform layer game platform layer.

1641
01:08:51,399 --> 01:08:54,899
The reason that I don't like that, is it creates this sort of?

1642
01:08:56,200 --> 01:08:57,500
I don't know what you want to call it.

1643
01:08:57,500 --> 01:08:59,800
It creates sort of a

1644
01:09:00,200 --> 01:09:05,800
Spiderweb sort of a feel of stuff if you loud that sort of thing to

1645
01:09:05,800 --> 01:09:07,700
happen and everyone does it.

1646
01:09:07,700 --> 01:09:11,500
So, like I said, this is just something I don't do but everyone else

1647
01:09:11,500 --> 01:09:14,300
does so you don't have to do this.

1648
01:09:14,300 --> 01:09:17,200
This is just how I'm doing things so you can see.

1649
01:09:18,200 --> 01:09:22,200
But basically creates this nasty spider web that looks like this here

1650
01:09:22,200 --> 01:09:23,899
is the platform, right?

1651
01:09:25,700 --> 01:09:26,600
Here's the game.

1652
01:09:27,800 --> 01:09:28,300
Okay.

1653
01:09:29,399 --> 01:09:33,800
This was written by Casey, but this may have been written by Bob,

1654
01:09:33,800 --> 01:09:34,000
right?

1655
01:09:34,000 --> 01:09:36,500
Because maybe I hired someone to Port the platform layer.

1656
01:09:36,500 --> 01:09:37,500
Now, in this particular case.

1657
01:09:37,500 --> 01:09:40,500
I'm going to be showing you all the platforms, but we've already had

1658
01:09:40,800 --> 01:09:41,399
David gasps.

1659
01:09:41,399 --> 01:09:42,300
Ow, right?

1660
01:09:42,399 --> 01:09:42,700
David.

1661
01:09:42,700 --> 01:09:46,500
Gal made an SD L version of handmade here, already.

1662
01:09:46,500 --> 01:09:49,700
He posts a sdl version that you can.

1663
01:09:49,700 --> 01:09:52,200
You can swap in if you want to follow at home, right?

1664
01:09:52,399 --> 01:09:56,700
So this may be written by someone who is not this guy, right?

1665
01:09:57,200 --> 01:09:58,400
It could be written by anybody.

1666
01:09:58,400 --> 01:09:59,000
It could be like the

1667
01:09:59,200 --> 01:10:00,900
Anyhow, that you hired to Port it, who knows.

1668
01:10:02,000 --> 01:10:06,900
So basically, if you set yourself up for Success, what it looks like

1669
01:10:06,900 --> 01:10:13,800
is it looks like this basically one call, right?

1670
01:10:13,900 --> 01:10:15,200
And that's what we've got.

1671
01:10:15,200 --> 01:10:17,300
We have one call.

1672
01:10:17,400 --> 01:10:17,600
This.

1673
01:10:17,600 --> 01:10:18,200
Is it?

1674
01:10:18,400 --> 01:10:19,400
The game runs.

1675
01:10:19,400 --> 01:10:22,000
If you call this call that is it.

1676
01:10:22,400 --> 01:10:25,300
All you have to know is that you have to pass these things to it and

1677
01:10:25,300 --> 01:10:26,600
it works, right?

1678
01:10:26,800 --> 01:10:28,700
This makes Bob's life.

1679
01:10:29,100 --> 01:10:30,000
So easy.

1680
01:10:30,200 --> 01:10:35,000
The only way that Bob can screw up is if Bob is just incompetent,

1681
01:10:35,000 --> 01:10:35,500
right?

1682
01:10:35,500 --> 01:10:40,200
But if Bob is any good at all, you have made his life wonderful and he

1683
01:10:40,200 --> 01:10:42,300
can write a perfect platform layer.

1684
01:10:42,300 --> 01:10:43,500
That doesn't need any Jank.

1685
01:10:43,500 --> 01:10:47,300
Enos that perfectly Services the operating system exactly the way it

1686
01:10:47,300 --> 01:10:50,100
needs to and knows that it just goes and gets the stuff from the game

1687
01:10:50,100 --> 01:10:54,200
when necessary on the other hand, if it looks like this.

1688
01:10:59,400 --> 01:11:05,400
It will take Bob a few weeks just to figure out what the actual thing

1689
01:11:05,400 --> 01:11:10,000
is that the game even needs, because the API is no longer one called

1690
01:11:10,000 --> 01:11:12,300
anyone can read, who knows anything about programming?

1691
01:11:12,900 --> 01:11:13,500
Instead.

1692
01:11:13,500 --> 01:11:17,100
It's now this, this giant sequence of operations.

1693
01:11:17,200 --> 01:11:19,300
The API is actually a sequence.

1694
01:11:19,500 --> 01:11:23,400
It's all these calls in a row that went back and forth.

1695
01:11:23,400 --> 01:11:25,800
It's like looking at a log, right?

1696
01:11:25,800 --> 01:11:28,500
It's like all these things happened in an order and the

1697
01:11:28,900 --> 01:11:32,500
I'm layer has to know that it needs to be able to expect to get a load

1698
01:11:32,500 --> 01:11:34,400
call after this call after that.

1699
01:11:34,400 --> 01:11:35,400
Blah, blah, blah, blah blah.

1700
01:11:35,500 --> 01:11:39,300
And it's just this huge nightmare of, like, learning what all that has

1701
01:11:39,300 --> 01:11:42,400
to be like, handling it properly.

1702
01:11:42,400 --> 01:11:45,300
And, oh, I didn't realize that in this case.

1703
01:11:45,300 --> 01:11:48,200
I would have needed to tell the game to refresh that thing and then it

1704
01:11:48,200 --> 01:11:50,600
would call me back and I wasn't ready for the call back yet.

1705
01:11:50,600 --> 01:11:51,500
So it crashed.

1706
01:11:52,400 --> 01:11:53,800
Just like no, no.

1707
01:11:53,800 --> 01:11:54,700
No, I don't like it.

1708
01:11:54,700 --> 01:11:58,800
It's it makes me unhappy and I'm unhappy about when I come into work

1709
01:11:58,800 --> 01:11:59,800
and it's bad, right?

1710
01:12:00,000 --> 01:12:01,800
We just we just cross that out.

1711
01:12:02,100 --> 01:12:04,100
And we do this, right?

1712
01:12:04,700 --> 01:12:05,400
And it's fine.

1713
01:12:05,600 --> 01:12:05,800
Now.

1714
01:12:05,800 --> 01:12:08,300
There's one thing you have to do, additionally, that we're going to do

1715
01:12:08,300 --> 01:12:14,100
later for asset loading, which is basically there is one Q, right?

1716
01:12:14,100 --> 01:12:16,000
And the Q is for disk I/O.

1717
01:12:16,500 --> 01:12:20,500
And if you want Network, you've got a second Q so you can never really

1718
01:12:20,500 --> 01:12:21,700
make it be just one call.

1719
01:12:21,700 --> 01:12:25,900
I mean, you could, you could make it be literally just one call.

1720
01:12:26,800 --> 01:12:28,800
But you still have the Q.

1721
01:12:28,800 --> 01:12:33,500
So you still have a little, you have a little bit of non one calmness

1722
01:12:34,400 --> 01:12:36,600
but that is the minimum you can get away with.

1723
01:12:36,900 --> 01:12:41,300
And so it is what I get away with if I can, because it's so nice and

1724
01:12:41,300 --> 01:12:42,000
clean and easy.

1725
01:12:42,000 --> 01:12:45,200
And then it makes everything just super-clean on either side.

1726
01:12:45,200 --> 01:12:46,500
There's no cruft.

1727
01:12:48,000 --> 01:12:48,900
Yeah, it's good.

1728
01:12:49,700 --> 01:12:50,100
Good thing.

1729
01:12:54,800 --> 01:12:56,100
Let's see.

1730
01:12:56,900 --> 01:12:59,200
Are you going to keep the sound before allocation to separate?

1731
01:12:59,500 --> 01:13:02,600
Probably just I'm defined as going to allocate that in the bitmap

1732
01:13:02,600 --> 01:13:07,100
buffer together with applies, do one big virtual Alec but I might do

1733
01:13:07,100 --> 01:13:09,700
two separate ones one for the platform memory, like the sound buffer,

1734
01:13:09,700 --> 01:13:10,500
and the bitmap buffer.

1735
01:13:10,500 --> 01:13:12,000
And one, for the game memory.

1736
01:13:12,400 --> 01:13:12,800
I don't know.

1737
01:13:12,800 --> 01:13:13,200
We'll see.

1738
01:13:13,200 --> 01:13:14,200
We'll see how it shakes out.

1739
01:13:15,100 --> 01:13:16,000
Why didn't you use lips?

1740
01:13:16,000 --> 01:13:17,900
He's a certain macro because we're not using any minute.

1741
01:13:17,900 --> 01:13:19,100
Any libraries.

1742
01:13:19,200 --> 01:13:21,900
I already had to use sign F because I didn't want to show you how to

1743
01:13:21,900 --> 01:13:23,100
make a sine wave right there.

1744
01:13:23,100 --> 01:13:24,800
I'd want to keep that stuff to a minimum.

1745
01:13:24,800 --> 01:13:25,500
So no more.

1746
01:13:25,500 --> 01:13:26,500
No more of that.

1747
01:13:26,500 --> 01:13:29,500
If we can avoid, it will use only the ones we have to because we don't

1748
01:13:29,500 --> 01:13:33,200
have time to study to get to it to do them in test code.

1749
01:13:33,200 --> 01:13:35,400
But when we actually everything that we ship, we should write

1750
01:13:35,400 --> 01:13:36,000
ourselves.

1751
01:13:38,100 --> 01:13:39,200
Let's see.

1752
01:13:39,300 --> 01:13:41,600
Let's see.

1753
01:13:44,200 --> 01:13:47,100
Dyslexic deity was pointing out that the assert has a couple issues.

1754
01:13:47,100 --> 01:13:49,400
Well if that's true, but that's because we haven't really written it

1755
01:13:49,400 --> 01:13:49,800
yet.

1756
01:13:50,000 --> 01:13:52,600
So the thing is I can put it to do in there.

1757
01:13:52,600 --> 01:13:53,800
If you're nervous about it.

1758
01:13:54,300 --> 01:13:58,100
I can put to Do complete a search in macro.

1759
01:13:58,500 --> 01:14:00,000
But really this, this is

1760
01:14:01,700 --> 01:14:04,600
The thing about this is this is not actually the assertion macro that

1761
01:14:04,600 --> 01:14:05,500
we're going to want.

1762
01:14:05,700 --> 01:14:09,900
We will actually want an else case in ours because we're actually

1763
01:14:09,900 --> 01:14:14,200
going to, we're actually going to have a way to get a dialog box that

1764
01:14:14,200 --> 01:14:16,100
says whether do ignore the assert and all that stuff.

1765
01:14:16,100 --> 01:14:20,700
So so just don't worry everyone.

1766
01:14:21,500 --> 01:14:22,900
It's coming later.

1767
01:14:30,000 --> 01:14:32,300
Let's see.

1768
01:14:32,600 --> 01:14:33,700
Let's see here.

1769
01:14:38,300 --> 01:14:39,500
Why did you pick an address?

1770
01:14:39,500 --> 01:14:40,400
Super high up?

1771
01:14:40,400 --> 01:14:41,300
Two terabytes?

1772
01:14:42,300 --> 01:14:43,000
No reason.

1773
01:14:43,500 --> 01:14:44,200
It's just what?

1774
01:14:44,200 --> 01:14:45,800
I just on a whim.

1775
01:14:46,200 --> 01:14:49,500
I want to make sure it wasn't something already taken.

1776
01:14:49,500 --> 01:14:49,900
I don't know.

1777
01:14:49,900 --> 01:14:52,300
I didn't have a reason that's just where I put it.

1778
01:14:53,600 --> 01:14:56,000
I miss the stuff where you coated the permanent and transient memory.

1779
01:14:56,000 --> 01:14:57,700
Can you go over it Again?

1780
01:14:58,400 --> 01:14:59,300
Guitar, 87.

1781
01:14:59,300 --> 01:14:59,800
Before?

1782
01:15:00,300 --> 01:15:00,900
Run out of time.

1783
01:15:00,900 --> 01:15:02,000
Can you clarify that question?

1784
01:15:02,300 --> 01:15:03,300
What do you mean by coded?

1785
01:15:03,300 --> 01:15:03,400
It?

1786
01:15:03,400 --> 01:15:06,000
Do you mean just where I allocated it or how I used it?

1787
01:15:07,100 --> 01:15:11,000
Just clarify that slightly and then I will do exactly that when you

1788
01:15:11,000 --> 01:15:12,000
were in task manager.

1789
01:15:12,000 --> 01:15:14,900
What exactly was the difference between each type of memory size.

1790
01:15:14,900 --> 01:15:15,800
Oh, yeah.

1791
01:15:15,800 --> 01:15:17,100
Well, you know what?

1792
01:15:17,100 --> 01:15:18,700
I'm the wrong person to ask these days.

1793
01:15:18,700 --> 01:15:21,900
I used to know the answer to that but they've changed it.

1794
01:15:22,100 --> 01:15:23,600
So now I don't.

1795
01:15:24,400 --> 01:15:28,300
So you want to ask like Mark russinovich or somebody who actually

1796
01:15:28,300 --> 01:15:29,500
knows or Raymond Chen.

1797
01:15:30,100 --> 01:15:31,300
What it really means.

1798
01:15:31,300 --> 01:15:36,000
But basically, so, let's see here.

1799
01:15:36,200 --> 01:15:38,800
So when you open the task manager, normally, I don't think it has this

1800
01:15:38,800 --> 01:15:39,100
stuff.

1801
01:15:39,100 --> 01:15:42,500
What you have to do is you have to go, there's like a select columns,

1802
01:15:42,700 --> 01:15:44,500
that sucked column view, select columns.

1803
01:15:44,500 --> 01:15:48,000
And then you can turn on all this stuff and you can turn on a bunch of

1804
01:15:48,000 --> 01:15:49,400
memory stuff, right?

1805
01:15:49,600 --> 01:15:50,100
Like this.

1806
01:15:51,500 --> 01:15:52,200
That makes sense.

1807
01:15:52,900 --> 01:15:58,200
So basically what these things will show you is is all of the sort of

1808
01:15:58,800 --> 01:16:00,300
memory stats that Windows.

1809
01:16:00,300 --> 01:16:04,200
Well, not all of them, but some of the memories that counters that

1810
01:16:04,200 --> 01:16:07,700
window has for your application, right?

1811
01:16:08,100 --> 01:16:14,000
So, basically, I believe I'm gonna give the wrong explanation and then

1812
01:16:14,000 --> 01:16:16,400
someone else can come in and correct it hopefully later, because like

1813
01:16:16,400 --> 01:16:17,500
I said, I don't know anymore.

1814
01:16:18,200 --> 01:16:21,100
I believe that basically what you have.

1815
01:16:21,300 --> 01:16:26,700
Is the working set is like well, no, you know what?

1816
01:16:26,700 --> 01:16:29,200
I'm not even going to try and give this because I'm going to mess it

1817
01:16:29,200 --> 01:16:29,500
up.

1818
01:16:29,900 --> 01:16:32,700
Basically what these are you should go read about them for yourselves

1819
01:16:32,700 --> 01:16:33,700
in a modern dock.

1820
01:16:34,000 --> 01:16:38,400
Basically, what they are is they're different versions of how much

1821
01:16:38,400 --> 01:16:41,600
memory your app has versus how much it asked for.

1822
01:16:42,700 --> 01:16:46,400
How much it is actually touched, right?

1823
01:16:47,400 --> 01:16:49,600
How much is resident in memory?

1824
01:16:50,100 --> 01:16:52,400
How much is not resident in memory, right?

1825
01:16:52,400 --> 01:16:57,200
Like those sorts of things and it's trying to give you sort of a

1826
01:16:59,100 --> 01:17:05,200
A snapshot of of that, sort of residency, allocation touch it, NE sort

1827
01:17:05,200 --> 01:17:06,000
of thing.

1828
01:17:06,800 --> 01:17:10,600
And like I said, I used to know I don't anymore because they changed

1829
01:17:10,600 --> 01:17:13,300
these things at some point and now I'm like, I don't even know what

1830
01:17:13,300 --> 01:17:16,600
they're reporting anymore to make matters worse.

1831
01:17:16,800 --> 01:17:21,100
If you really want to learn this stuff and if you're curious about it,

1832
01:17:21,100 --> 01:17:22,400
I highly recommend that you do.

1833
01:17:22,500 --> 01:17:24,600
I wish I knew like, maybe I'll go read about it tonight.

1834
01:17:24,600 --> 01:17:27,000
I just, it never comes up for me these days.

1835
01:17:27,000 --> 01:17:28,700
I just don't listen, especially

1836
01:17:28,900 --> 01:17:31,300
Do like what I do, where you just allocate a block of memory.

1837
01:17:31,500 --> 01:17:36,500
You never have like really concerns about it just kind of works, but

1838
01:17:36,500 --> 01:17:37,000
you should know.

1839
01:17:37,000 --> 01:17:38,600
These are things that we be good to know.

1840
01:17:39,200 --> 01:17:44,300
So so yeah, basically I would say it gets even weirder than just the

1841
01:17:44,300 --> 01:17:50,300
things that are shown in here because you can also go to perfmon.

1842
01:17:50,800 --> 01:17:53,000
I believe, still ships with things.

1843
01:17:53,000 --> 01:17:56,000
I think, I don't know if ships with Windows 8, but ships with Windows

1844
01:17:56,000 --> 01:17:58,700
7, at the very least perfmon.

1845
01:17:58,800 --> 01:17:59,800
on you, can, you can

1846
01:18:00,000 --> 01:18:03,900
And you go in and you can do this stuff where you go add counter,

1847
01:18:04,200 --> 01:18:08,300
right and you can pick like an application.

1848
01:18:08,800 --> 01:18:10,300
You can go to process.

1849
01:18:10,300 --> 01:18:12,400
I think is usually where it is process.

1850
01:18:12,600 --> 01:18:16,500
You can drop down process and then I think there's just a all this

1851
01:18:16,500 --> 01:18:18,300
stuff in here.

1852
01:18:18,300 --> 01:18:22,900
There's even more like virtual B is a good one that I think that's,

1853
01:18:22,900 --> 01:18:24,500
that's how much memory total.

1854
01:18:24,500 --> 01:18:25,100
For example.

1855
01:18:25,100 --> 01:18:28,300
I want to say and you can go pick your thing.

1856
01:18:28,300 --> 01:18:29,800
So like let's say we look at

1857
01:18:30,000 --> 01:18:31,500
At the open broadcast thing.

1858
01:18:31,500 --> 01:18:34,600
The thing I use for Twitch streaming, you can go ahead and say the

1859
01:18:34,600 --> 01:18:35,700
virtual B of OBS.

1860
01:18:35,700 --> 01:18:39,300
I want to add that as a counter and then, that'll just it shows you

1861
01:18:39,400 --> 01:18:43,100
like what that value is over time and that sort of stuff.

1862
01:18:43,600 --> 01:18:46,400
So, basically that's virtual B down there.

1863
01:18:46,400 --> 01:18:47,500
You can see, it's still pegs.

1864
01:18:47,500 --> 01:18:50,300
So, you got actually, it's kind of janky the way the graphing is

1865
01:18:50,300 --> 01:18:50,800
terrible.

1866
01:18:51,300 --> 01:18:54,800
You basically have to go find the right scale yourself for the thing.

1867
01:18:54,900 --> 01:18:55,600
It's really annoying.

1868
01:18:55,700 --> 01:18:56,300
Let's see.

1869
01:18:56,900 --> 01:18:58,200
Drop that scale down a little more.

1870
01:18:58,200 --> 01:18:58,800
There it is.

1871
01:18:59,300 --> 01:18:59,900
So basically.

1872
01:19:00,000 --> 01:19:00,500
And see there.

1873
01:19:00,500 --> 01:19:02,200
That's the that's the memory footprint.

1874
01:19:02,200 --> 01:19:04,900
I can change the color to so you can you can take a look at it.

1875
01:19:04,900 --> 01:19:05,500
There we go.

1876
01:19:05,600 --> 01:19:05,900
Great.

1877
01:19:05,900 --> 01:19:10,100
Yeah, and basically what that'll do is that'll if I click on it.

1878
01:19:10,100 --> 01:19:12,100
It'll also show us what the virtual B is.

1879
01:19:12,100 --> 01:19:14,500
That's like one point, three gigabytes or something that's got

1880
01:19:14,500 --> 01:19:17,700
allocated and that'll change over time.

1881
01:19:17,700 --> 01:19:20,000
You can see the processor time is also there for that.

1882
01:19:20,600 --> 01:19:23,500
I guess that's the not for the application, that's for everything.

1883
01:19:23,800 --> 01:19:26,500
But if I wanted to write, I could get rid of this thing I could.

1884
01:19:27,900 --> 01:19:28,600
Delete it.

1885
01:19:28,800 --> 01:19:31,100
And then I could go into that, right?

1886
01:19:31,100 --> 01:19:35,400
Click add counters again and then go down to process and add other

1887
01:19:35,400 --> 01:19:36,400
things to the process.

1888
01:19:36,400 --> 01:19:42,800
So, maybe I want something like, you know, the the percent sent

1889
01:19:42,800 --> 01:19:47,100
processor time used by this process, so that open broadcasting system.

1890
01:19:47,300 --> 01:19:49,400
I want to graph how much it's using over time.

1891
01:19:50,100 --> 01:19:51,900
I can add that as well.

1892
01:19:51,900 --> 01:19:54,000
So there we go, and that's on there now.

1893
01:19:54,300 --> 01:19:57,100
So basically, that just, yeah.

1894
01:19:57,600 --> 01:20:01,800
Perfmon, it's a thing that basically tells you that doesn't look

1895
01:20:01,800 --> 01:20:02,100
right.

1896
01:20:02,100 --> 01:20:03,400
Is that scale drawing again?

1897
01:20:03,700 --> 01:20:04,300
Yeah, it is.

1898
01:20:04,300 --> 01:20:05,100
So you can see it there.

1899
01:20:05,100 --> 01:20:07,200
So I got to scale it down to like that.

1900
01:20:08,000 --> 01:20:08,800
It's all right.

1901
01:20:09,600 --> 01:20:10,400
No.

1902
01:20:10,900 --> 01:20:12,200
The scale is just the worst.

1903
01:20:12,200 --> 01:20:15,400
I wish this just like, automatically scaled the things for you because

1904
01:20:15,400 --> 01:20:18,700
it's so annoying because I don't even know what I guess percent.

1905
01:20:18,700 --> 01:20:20,200
So that should be a clue, it's percent.

1906
01:20:20,200 --> 01:20:21,800
So it should be out of 100, right?

1907
01:20:21,900 --> 01:20:22,500
So there you go.

1908
01:20:23,300 --> 01:20:25,800
So basically, this is just a little weird application.

1909
01:20:25,800 --> 01:20:27,200
You can use for monitoring stuff and it's

1910
01:20:27,300 --> 01:20:28,600
got all kinds of stuff in there.

1911
01:20:28,700 --> 01:20:31,500
So that's another way you can get memory information for your app.

1912
01:20:31,500 --> 01:20:34,700
If you want a secondary source to tell you what's going on.

1913
01:20:35,400 --> 01:20:36,000
Let's see here.

1914
01:20:38,700 --> 01:20:39,400
Let's see.

1915
01:20:40,600 --> 01:20:43,600
Ryan riess has tell people to watch Mark, russinovich has he's the guy

1916
01:20:43,600 --> 01:20:47,400
just mentioned videos on msdn Channel 9 entitled mysteries of Windows

1917
01:20:47,400 --> 01:20:48,500
memory management.

1918
01:20:48,700 --> 01:20:50,400
So I've never seen that.

1919
01:20:50,400 --> 01:20:55,100
But yeah, that would be if Mark russinovich has a thing talking about

1920
01:20:55,100 --> 01:20:56,200
Windows memory management.

1921
01:20:56,300 --> 01:20:59,800
You should probably watch it because he knows that stuff like that is.

1922
01:21:00,000 --> 01:21:02,700
That is definitely a guy, you would ask.

1923
01:21:04,100 --> 01:21:05,300
Let's see.

1924
01:21:05,700 --> 01:21:08,200
Are there any guidelines for choosing a safe first argument address to

1925
01:21:08,200 --> 01:21:08,800
Virtual Alec?

1926
01:21:08,800 --> 01:21:09,900
I don't know.

1927
01:21:10,700 --> 01:21:13,300
You know, I would love to know the answer to that question.

1928
01:21:13,500 --> 01:21:16,200
Like I said, I'm only doing it on my machine.

1929
01:21:16,200 --> 01:21:18,200
That's why it's an internal build only thing.

1930
01:21:18,500 --> 01:21:22,000
So I don't care as long as you find one that works.

1931
01:21:22,000 --> 01:21:22,900
You're good to go.

1932
01:21:23,400 --> 01:21:29,700
But yeah, I would love to know if there was a way to just say, oh, you

1933
01:21:29,700 --> 01:21:33,200
know, when you start up that, you know, I'm marked executable to have

1934
01:21:33,500 --> 01:21:34,200
Range reserved.

1935
01:21:34,200 --> 01:21:34,700
I don't know.

1936
01:21:34,900 --> 01:21:35,800
So that'd be something interesting.

1937
01:21:35,800 --> 01:21:38,700
If someone does know that definitely right in because we can talk

1938
01:21:38,700 --> 01:21:40,900
about it later and put in some code here to handle it.

1939
01:21:43,900 --> 01:21:49,200
Let's see what happens if we try to allocate 4 gigabytes and users

1940
01:21:49,200 --> 01:21:50,400
does not have that much RAM.

1941
01:21:51,000 --> 01:21:53,800
Basically, the allocation will just fail, it'll just return 0 and we

1942
01:21:53,800 --> 01:21:54,800
will print out an error.

1943
01:21:55,200 --> 01:21:58,600
Now, what we will do in the future and I can put it to do here if you

1944
01:21:58,600 --> 01:22:00,000
want as well.

1945
01:22:00,000 --> 01:22:03,600
But I already kind of said this to do handle, various memory

1946
01:22:03,600 --> 01:22:04,300
Footprints.

1947
01:22:04,500 --> 01:22:08,000
Basically, what we'll be doing in the future is will have a few

1948
01:22:08,000 --> 01:22:11,800
different configurations are getting can run in 256.

1949
01:22:11,800 --> 01:22:12,800
Meg's a gig.

1950
01:22:13,000 --> 01:22:16,400
Two gigs for digs let's say, and each one will basically determine

1951
01:22:16,400 --> 01:22:17,200
what art assets.

1952
01:22:17,200 --> 01:22:19,800
You get, whether you get the high res or the low as our assets and

1953
01:22:19,800 --> 01:22:21,000
sound and that sort of stuff.

1954
01:22:21,400 --> 01:22:24,100
And so, so we'll be handling, what will actually be doing in the

1955
01:22:24,100 --> 01:22:28,400
future is seeing, whether the system has that memory and if it does,

1956
01:22:28,400 --> 01:22:29,500
we'll use the higher amounts.

1957
01:22:29,500 --> 01:22:31,700
And if it doesn't, we'll use the lower amounts and we'll also use the

1958
01:22:31,700 --> 01:22:34,100
speed of the processor and stuff like that to determine, as well.

1959
01:22:35,400 --> 01:22:36,500
Let's take a look here.

1960
01:22:41,900 --> 01:22:45,000
Is it worrying about the OS, not being able to allocate memory kind of

1961
01:22:45,000 --> 01:22:47,000
like worrying about huge meteors hitting the Earth?

1962
01:22:47,300 --> 01:22:51,000
No, because like on an iPhone, that's why most of those apps crash,

1963
01:22:51,000 --> 01:22:51,300
right?

1964
01:22:51,300 --> 01:22:54,100
It's because they they just treat memory like it's free and it ain't

1965
01:22:54,100 --> 01:22:57,200
it's very limited amount of memory on on a lot of iPhones out there

1966
01:22:57,200 --> 01:23:00,900
and it just always it always just pooped out and when we port to the

1967
01:23:00,900 --> 01:23:06,700
Raspberry Pi 256, Meg's my friend, no virtual backing store, so don't

1968
01:23:06,700 --> 01:23:09,100
come crying to me when the operating system can allocate any more

1969
01:23:09,100 --> 01:23:09,900
memory for you.

1970
01:23:10,400 --> 01:23:11,100
So that's going to

1971
01:23:11,200 --> 01:23:11,600
Crucial.

1972
01:23:11,600 --> 01:23:12,800
Like, we're going to be very happy.

1973
01:23:12,800 --> 01:23:15,800
We did what we did when we go to run on a real memory constrained

1974
01:23:15,800 --> 01:23:17,100
platform, which we will be doing.

1975
01:23:19,300 --> 01:23:20,000
Let's see.

1976
01:23:20,300 --> 01:23:21,300
Same is true of consoles.

1977
01:23:21,300 --> 01:23:24,500
By the way, obviously, like all game consoles, have very fixed memory.

1978
01:23:26,400 --> 01:23:29,300
Why are using memory pools instead of static allocation, for many

1979
01:23:29,300 --> 01:23:30,100
permanent structures?

1980
01:23:30,100 --> 01:23:32,400
I find static allocations easier to use.

1981
01:23:33,500 --> 01:23:36,800
Because we wanted to add a known Base address unless I'm

1982
01:23:36,800 --> 01:23:38,300
misunderstanding your question.

1983
01:23:38,800 --> 01:23:42,600
Basically, like, static allocation wouldn't allow us to give a to

1984
01:23:42,600 --> 01:23:45,300
specify where the Base address of the memory was and virtual lock

1985
01:23:45,300 --> 01:23:45,700
does.

1986
01:23:45,800 --> 01:23:46,900
So that's why we're calling that.

1987
01:23:53,700 --> 01:23:55,500
What mechanism will be used to hand out the memory to different

1988
01:23:55,500 --> 01:23:56,400
subsystems.

1989
01:23:56,400 --> 01:23:56,800
Well.

1990
01:23:58,300 --> 01:23:59,800
That's spoiler warning.

1991
01:24:00,300 --> 01:24:02,800
Where we can't say that that would give away the whole stream.

1992
01:24:02,800 --> 01:24:06,400
Why would you come back and watch tomorrow, you know, and well, it's

1993
01:24:06,400 --> 01:24:08,400
not going to be tomorrow, but when we do it in future, so you'll be

1994
01:24:08,400 --> 01:24:09,400
seeing how we do that.

1995
01:24:09,400 --> 01:24:10,800
That is one of the things that we'll be doing.

1996
01:24:12,800 --> 01:24:13,400
Let's see.

1997
01:24:19,200 --> 01:24:21,900
Having human a der.

1998
01:24:21,900 --> 01:24:23,800
After cooking session is kind of like a code review.

1999
01:24:23,800 --> 01:24:25,500
Was this your intention or just Serendipity?

2000
01:24:27,100 --> 01:24:27,200
No.

2001
01:24:27,200 --> 01:24:30,500
I just wanted to make sure that people could ask questions live as

2002
01:24:30,500 --> 01:24:32,800
opposed to having to always ask them on the forums or something.

2003
01:24:33,200 --> 01:24:35,500
But yeah, it is nice to have a code review because it means that if

2004
01:24:35,500 --> 01:24:37,200
anyone caught something on the stream, they can say it.

2005
01:24:37,200 --> 01:24:37,900
That's happened.

2006
01:24:37,900 --> 01:24:42,200
Like twice already 44, pretty cool things.

2007
01:24:42,200 --> 01:24:45,200
So yeah, it's been it's been awesome and we will keep doing it this

2008
01:24:45,200 --> 01:24:47,000
way because it does have a fringe benefit, but that

2009
01:24:47,100 --> 01:24:49,100
Wasn't my thought was not, oh, this will be good.

2010
01:24:49,100 --> 01:24:51,500
People catch things on the stream because I know if they're even would

2011
01:24:51,500 --> 01:24:53,000
be any experts on the stream.

2012
01:24:53,000 --> 01:24:55,200
So, it might have been all people who were learning for the first time

2013
01:24:55,200 --> 01:24:57,600
in probably wouldn't be able to catch stuff, but it turns out we have

2014
01:24:57,600 --> 01:25:01,300
a lot of experts who do come just are just enjoying the stream, you

2015
01:25:01,300 --> 01:25:02,100
know, for other reasons.

2016
01:25:02,100 --> 01:25:04,600
I just want to, you know, hang out in code or whatever.

2017
01:25:05,000 --> 01:25:07,900
And so, that's been pretty awesome, but I didn't know that we would

2018
01:25:07,900 --> 01:25:09,900
have experts on the stream ever, right?

2019
01:25:09,900 --> 01:25:10,300
So,

2020
01:25:15,800 --> 01:25:17,400
Let's see.

2021
01:25:17,900 --> 01:25:19,800
What about for example, modding support.

2022
01:25:19,800 --> 01:25:22,500
You can't tell if an in advance, if you allocate enough money for some

2023
01:25:22,500 --> 01:25:24,600
else's mod, right, know that it's not true.

2024
01:25:24,900 --> 01:25:29,900
So, all all the game needs to work in a certain footprint and if you

2025
01:25:29,900 --> 01:25:32,700
want to support modding, you still have a footprint requirement.

2026
01:25:32,800 --> 01:25:35,100
Now, you can allow mods to change what the footprint is.

2027
01:25:35,100 --> 01:25:37,500
If you want, you could say this mod requires eight gigs, set of four

2028
01:25:37,500 --> 01:25:37,700
gigs.

2029
01:25:37,700 --> 01:25:41,600
And then all we would do on Startup is we just have a way of going.

2030
01:25:41,800 --> 01:25:43,700
What mods do we want to support?

2031
01:25:43,800 --> 01:25:44,600
Because assuming they

2032
01:25:44,700 --> 01:25:47,600
Into the directory or whatever that they're installed.

2033
01:25:47,700 --> 01:25:49,400
We basically would do that allocation.

2034
01:25:49,500 --> 01:25:50,000
Right?

2035
01:25:50,300 --> 01:25:53,000
And so, you know, it's not it's not really a problem.

2036
01:25:53,000 --> 01:25:57,300
But also I don't think mods to change the memory footprint mod should

2037
01:25:57,300 --> 01:25:58,700
still work in the same memory.

2038
01:25:58,700 --> 01:26:03,300
Footprint would be my preference and so like I don't love having mods.

2039
01:26:03,300 --> 01:26:04,100
Expand it.

2040
01:26:04,800 --> 01:26:07,600
Maybe if you want to do a mob that comes like two years later, some

2041
01:26:07,600 --> 01:26:09,300
machines have more memory and that's fine.

2042
01:26:09,300 --> 01:26:12,000
But the way I would probably

2043
01:26:13,000 --> 01:26:15,100
Yeah, the way I would probably do that is I'd rather ship a new

2044
01:26:15,100 --> 01:26:18,100
executable later that expands what can be done.

2045
01:26:18,400 --> 01:26:19,800
I like that version better.

2046
01:26:19,800 --> 01:26:21,500
I think of it more like z-machine.

2047
01:26:21,600 --> 01:26:24,900
Like the old infocomm way of doing things there was like this was the

2048
01:26:24,900 --> 01:26:25,500
small version.

2049
01:26:25,500 --> 01:26:27,200
Now, we've got the bigger version or something.

2050
01:26:27,200 --> 01:26:30,100
I like that better than having be flexible.

2051
01:26:33,900 --> 01:26:35,500
Let's see.

2052
01:26:35,600 --> 01:26:39,400
Will our new 64-bit get GB break on Raspberry Pi.

2053
01:26:40,400 --> 01:26:44,000
Well, you have to understand Raspberry Pi won't be calling the win32

2054
01:26:44,000 --> 01:26:48,300
code because there's no word 32 on Raspberry Pi, right?

2055
01:26:48,800 --> 01:26:52,000
So on Raspberry Pi, we will always be in small memory mode.

2056
01:26:52,100 --> 01:26:55,400
So basically, the game memory that's passed in will always be like 64

2057
01:26:55,400 --> 01:26:59,000
megabytes and 120, Mega Twenty, Eight megabytes or something.

2058
01:26:59,000 --> 01:26:59,900
Depending on how much we have.

2059
01:27:00,700 --> 01:27:03,400
So that's just Raspberry Pi will be in a more constrained memory

2060
01:27:03,400 --> 01:27:03,800
footprint.

2061
01:27:03,800 --> 01:27:05,400
But remember this code never runs a measure by.

2062
01:27:05,400 --> 01:27:06,600
This is the win32 code.

2063
01:27:09,700 --> 01:27:10,700
Let's see here.

2064
01:27:14,600 --> 01:27:15,900
How do you ask the memory pool?

2065
01:27:15,900 --> 01:27:17,700
We allocated for unused available space.

2066
01:27:17,700 --> 01:27:20,000
For any given data or object again.

2067
01:27:20,100 --> 01:27:21,000
Got to wait till later.

2068
01:27:21,500 --> 01:27:23,600
We have once we allocate stuff from it.

2069
01:27:23,600 --> 01:27:29,400
We will see will the transient storage be freed or will you just take

2070
01:27:29,400 --> 01:27:31,500
memory off of its free end until it's gone?

2071
01:27:31,500 --> 01:27:31,900
In other words.

2072
01:27:31,900 --> 01:27:33,400
How are the married be managed again?

2073
01:27:33,500 --> 01:27:36,000
Wait, wait on those because we're going to see how that works.

2074
01:27:36,000 --> 01:27:39,200
The answer is, they'll be at least three ways that we do stuff.

2075
01:27:39,800 --> 01:27:40,700
You'll see them.

2076
01:27:45,100 --> 01:27:46,300
Let's see.

2077
01:27:46,300 --> 01:27:49,100
Is it better if we keep track of the size of the memory that is freed

2078
01:27:49,100 --> 01:27:50,200
instead of the total size.

2079
01:27:50,200 --> 01:27:51,700
No, not in this case.

2080
01:27:51,700 --> 01:27:52,800
We're trying to pass to the game.

2081
01:27:52,800 --> 01:27:54,800
So the game needs to see how much memory there is.

2082
01:28:07,600 --> 01:28:11,500
Can you explain your reluctance to have those constants be unsigned

2083
01:28:11,500 --> 01:28:12,300
long, long as?

2084
01:28:12,300 --> 01:28:16,000
Yeah, I just, I was worried that you wouldn't be able to do 32-bit

2085
01:28:16,000 --> 01:28:17,500
computations in it anymore.

2086
01:28:19,200 --> 01:28:27,200
I was all like, you know, I mean, I'll be more concrete so I compile

2087
01:28:27,200 --> 01:28:27,900
this, right?

2088
01:28:34,700 --> 01:28:36,000
Oh, alright, nevermind.

2089
01:28:36,000 --> 01:28:36,900
I guess it's okay.

2090
01:28:37,100 --> 01:28:38,200
I was worried.

2091
01:28:38,300 --> 01:28:39,600
I was worried about this.

2092
01:28:39,900 --> 01:28:42,700
But if it's always going to work okay with long long if I can always

2093
01:28:42,700 --> 01:28:43,500
just assign them.

2094
01:28:43,500 --> 01:28:44,100
That's fine.

2095
01:28:44,600 --> 01:28:45,600
So that may be fine.

2096
01:28:45,600 --> 01:28:46,700
If that's the case.

2097
01:28:47,000 --> 01:28:48,200
I'm happy to do it.

2098
01:28:48,200 --> 01:28:51,000
That was my only concern is I was worried that it wouldn't that I have

2099
01:28:51,000 --> 01:28:54,700
to start casting but if that's the case, then I'm okay with this.

2100
01:28:54,700 --> 01:28:56,100
If that's if that's what that'll do.

2101
01:28:57,100 --> 01:28:57,900
So thanks for that.

2102
01:28:57,900 --> 01:28:58,300
Yeah.

2103
01:28:58,300 --> 01:29:01,600
I just I was just a little nervous that it would, it would start

2104
01:29:01,600 --> 01:29:02,500
restricting me.

2105
01:29:02,900 --> 01:29:03,800
But if it's not then

2106
01:29:04,100 --> 01:29:05,100
Then that's okay.

2107
01:29:05,200 --> 01:29:08,600
If it's if it's able to cast down on the constant, that's probably

2108
01:29:08,600 --> 01:29:08,900
fine.

2109
01:29:09,100 --> 01:29:12,600
Now if I pass in it, well, the thing is though if I pass in a variable

2110
01:29:12,600 --> 01:29:14,400
there, of course, will I ever be passing in a variable?

2111
01:29:14,400 --> 01:29:15,300
Probably not.

2112
01:29:15,500 --> 01:29:17,800
I'm okay with that because because those are four constants really?

2113
01:29:17,800 --> 01:29:18,700
I'm okay with it.

2114
01:29:18,700 --> 01:29:19,500
I'm okay with it.

2115
01:29:19,700 --> 01:29:20,100
I'm okay.

2116
01:29:20,100 --> 01:29:21,800
Now I wasn't okay maybe before.

2117
01:29:24,200 --> 01:29:25,900
Let's see.

2118
01:29:29,000 --> 01:29:33,500
No, I did not pass any different flags to Virtual a luck for permanent

2119
01:29:33,500 --> 01:29:35,200
versus transient blocks of memory.

2120
01:29:36,100 --> 01:29:37,300
The I'm just allocating.

2121
01:29:37,300 --> 01:29:39,200
Just the memory the same for both.

2122
01:29:39,200 --> 01:29:43,400
In fact now we only call virtual Alec once and all we're doing is just

2123
01:29:43,400 --> 01:29:46,800
take committing the whole range and it'll clear 20 for us because it's

2124
01:29:46,800 --> 01:29:49,700
defined it has to do that, virtual lock will clear 20.

2125
01:29:51,200 --> 01:29:52,000
Let's see here.

2126
01:29:56,300 --> 01:29:56,900
Oh, yes.

2127
01:29:56,900 --> 01:29:57,200
Sorry.

2128
01:29:57,400 --> 01:29:59,800
When I say someone asked what the other reasons were.

2129
01:30:00,000 --> 01:30:01,800
Specifying a memory Base address.

2130
01:30:02,500 --> 01:30:03,900
I don't want to show you yet.

2131
01:30:04,500 --> 01:30:06,000
That's, that's a little surprise.

2132
01:30:06,000 --> 01:30:06,800
We'll get to later.

2133
01:30:07,100 --> 01:30:09,200
So, so the only one right now is debug ability.

2134
01:30:09,200 --> 01:30:11,400
That's the one we're focusing on that, but we may do other things with

2135
01:30:11,400 --> 01:30:13,200
it later that are kind of fun weird.

2136
01:30:16,000 --> 01:30:18,000
Can you please play The Base address being so large?

2137
01:30:18,200 --> 01:30:19,700
I don't have a reason for it.

2138
01:30:19,700 --> 01:30:21,100
It's just where I picked.

2139
01:30:21,800 --> 01:30:24,200
I don't know a good way to get to pick something.

2140
01:30:24,200 --> 01:30:26,200
That's always going to be available.

2141
01:30:26,200 --> 01:30:28,500
I figured the two terabyte location.

2142
01:30:28,900 --> 01:30:31,100
Probably there isn't stuff sitting up there.

2143
01:30:31,900 --> 01:30:32,900
So that's why I picked it.

2144
01:30:32,900 --> 01:30:33,600
That's it.

2145
01:30:33,700 --> 01:30:34,500
That's all I got.

2146
01:30:34,600 --> 01:30:35,600
I had no better idea.

2147
01:30:36,300 --> 01:30:37,200
Maybe later on.

2148
01:30:37,200 --> 01:30:41,300
We'll do some research and figure out what the most recent safest way

2149
01:30:41,300 --> 01:30:41,700
to put that.

2150
01:30:41,700 --> 01:30:41,800
Again.

2151
01:30:41,800 --> 01:30:42,500
We're not shipping.

2152
01:30:42,500 --> 01:30:44,000
This this never ships.

2153
01:30:44,800 --> 01:30:45,500
We let

2154
01:30:45,700 --> 01:30:48,600
As a sign or address range when we ship which is the safe way.

2155
01:30:49,000 --> 01:30:51,200
So technically we could have picked anything we wanted in as long as

2156
01:30:51,200 --> 01:30:52,300
it works on our machine.

2157
01:30:52,300 --> 01:30:53,800
That's all we care about and it did.

2158
01:30:53,800 --> 01:30:54,300
So we're done.

2159
01:31:03,000 --> 01:31:06,800
So, it's possible even on Windows, that there isn't contiguous space

2160
01:31:06,800 --> 01:31:10,700
available for the pool and two different program, instances, end up

2161
01:31:10,700 --> 01:31:13,900
using different assets, even though on the same machine.

2162
01:31:13,900 --> 01:31:15,000
No, not really.

2163
01:31:15,900 --> 01:31:16,500
So,

2164
01:31:18,200 --> 01:31:21,900
You have to understand, there's a difference between virtual memory

2165
01:31:21,900 --> 01:31:23,100
and physical memory.

2166
01:31:23,400 --> 01:31:24,600
We've just started up.

2167
01:31:24,600 --> 01:31:29,300
So our virtual address space is not fragmented when we virtual a lot,

2168
01:31:29,300 --> 01:31:30,400
continuous memory.

2169
01:31:30,900 --> 01:31:34,200
It does not have to be contiguous in physical memory.

2170
01:31:34,200 --> 01:31:36,100
It can be arbitrarily scattered.

2171
01:31:36,100 --> 01:31:38,600
And in fact, will be pretty much.

2172
01:31:39,000 --> 01:31:42,900
It's highly unlikely that the whole thing will always be perfectly

2173
01:31:42,900 --> 01:31:43,400
continuous.

2174
01:31:43,400 --> 01:31:43,700
I don't know.

2175
01:31:43,700 --> 01:31:46,600
Maybe Windows does try to do that for some reason, but I don't think

2176
01:31:46,600 --> 01:31:47,900
it does and it certainly

2177
01:31:48,000 --> 01:31:49,000
Doesn't guarantee it.

2178
01:31:49,400 --> 01:31:51,100
So, there is no reason.

2179
01:31:51,700 --> 01:31:53,400
Our memory hasn't been fragmented at all.

2180
01:31:53,400 --> 01:31:53,900
At this point.

2181
01:31:53,900 --> 01:31:57,200
So we should always get that if the machine has enough physical

2182
01:31:57,200 --> 01:32:00,700
memory, or even virtual memory to give it to us at will as far as I

2183
01:32:00,700 --> 01:32:04,300
know, so, we're not even going to use just to be clear here.

2184
01:32:07,300 --> 01:32:09,100
We are not even going to use this.

2185
01:32:09,400 --> 01:32:12,200
We're not going to use Virtual Alex failing to tell us that we don't

2186
01:32:12,200 --> 01:32:15,700
have enough memory because virtual Aqua almost never fail when we ask

2187
01:32:15,700 --> 01:32:18,600
for the 4 GB because it'll give us virtual memory.

2188
01:32:18,600 --> 01:32:19,700
Even if it doesn't have the physical memory.

2189
01:32:19,700 --> 01:32:22,500
What we'll be doing is asking how much physical memory there are is

2190
01:32:22,800 --> 01:32:26,700
and we'll be trying to use a subset of the physical memory size.

2191
01:32:27,200 --> 01:32:27,700
But yeah.

2192
01:32:31,000 --> 01:32:32,400
So I think that's it.

2193
01:32:33,700 --> 01:32:34,700
Let's see.

2194
01:32:34,700 --> 01:32:36,500
I think that's all the questions.

2195
01:32:36,800 --> 01:32:39,600
There are questions in here that we're not pertaining to the code that

2196
01:32:39,600 --> 01:32:40,200
we've already written.

2197
01:32:40,200 --> 01:32:41,400
So I did not answer them.

2198
01:32:41,600 --> 01:32:44,700
If you want to talk about those come to a pre stream, sometimes show

2199
01:32:44,700 --> 01:32:49,200
up 5 or 10 minutes before the stream starts, and that's usually when I

2200
01:32:49,200 --> 01:32:53,700
answer kind of random questions, like what we're going to be using for

2201
01:32:53,700 --> 01:32:56,700
physics and stuff like that that I see on stream or what I've

2202
01:32:56,700 --> 01:32:57,600
programmed before.

2203
01:32:58,000 --> 01:32:59,800
So those are two things I do, answer on the free.

2204
01:33:00,000 --> 01:33:00,100
Mm.

2205
01:33:00,100 --> 01:33:03,800
So if you want those come come five minutes or ten minutes before and

2206
01:33:03,800 --> 01:33:05,200
ask them sometimes.

2207
01:33:05,200 --> 01:33:08,700
I might even more before that, but basically come come early and

2208
01:33:08,700 --> 01:33:09,700
that's when we do that.

2209
01:33:10,100 --> 01:33:11,400
All right, everyone.

2210
01:33:11,400 --> 01:33:13,900
I think that is a wrap for today.

2211
01:33:14,300 --> 01:33:17,600
Very simple stuff we did today, but we're totally good to go now on

2212
01:33:17,600 --> 01:33:18,200
memory.

2213
01:33:18,500 --> 01:33:21,700
So we're closing in on the homestretch of platform stuff.

2214
01:33:21,700 --> 01:33:25,900
I would say that it is not an exaggeration to say that probably next

2215
01:33:25,900 --> 01:33:29,900
week, will be our very last week where we really think about.

2216
01:33:30,000 --> 01:33:32,600
Too much at all with the exception of the May.

2217
01:33:32,600 --> 01:33:35,400
Well, you know, probably for a long time, probably until we do

2218
01:33:35,400 --> 01:33:36,600
streaming asset loading.

2219
01:33:37,100 --> 01:33:40,700
So we're closing in here on actually getting to some really fun stuff

2220
01:33:40,700 --> 01:33:41,200
too.

2221
01:33:41,700 --> 01:33:43,200
Although I kind of like some of the stuff.

2222
01:33:43,200 --> 01:33:43,600
So, to be honest.

2223
01:33:43,600 --> 01:33:44,600
It's kind of all fun to me.

2224
01:33:44,600 --> 01:33:46,100
But stuff, that's a little flashier.

2225
01:33:46,100 --> 01:33:46,900
Let's put it that way.

2226
01:33:47,700 --> 01:33:50,900
As always, if you do want access to the source code, you can pre-order

2227
01:33:50,900 --> 01:33:52,900
here on handmade hero dot-org.

2228
01:33:53,200 --> 01:33:57,600
If you want to discuss what you saw tonight, or anytime you can go to

2229
01:33:57,600 --> 01:33:59,900
news and forums, where there is a bunch of

2230
01:34:00,000 --> 01:34:00,500
Stuff on there.

2231
01:34:00,500 --> 01:34:02,800
There's coding waste, where you can ask questions.

2232
01:34:02,800 --> 01:34:05,500
There's a bunch of resources that other people have made that help you

2233
01:34:05,500 --> 01:34:06,300
study the series.

2234
01:34:06,300 --> 01:34:07,100
If you want to.

2235
01:34:07,300 --> 01:34:10,800
There's all kinds of good stuff up there as well as a schedule so you

2236
01:34:10,800 --> 01:34:14,300
can tell when the series is going to air which is helpful as well.

2237
01:34:14,300 --> 01:34:15,400
So all that stuff is up there.

2238
01:34:15,400 --> 01:34:16,700
I encourage you to check it out.

2239
01:34:16,800 --> 01:34:18,400
Of course, there's the video archive on YouTube.

2240
01:34:18,400 --> 01:34:21,100
If you missed episodes, you can go on there and there's also an

2241
01:34:21,100 --> 01:34:25,100
episode guide on news and forums that has the videos plus a with time

2242
01:34:25,100 --> 01:34:25,700
jumps on them.

2243
01:34:25,700 --> 01:34:26,000
Now.

2244
01:34:26,100 --> 01:34:28,900
I might make this link directly to that in the future because it's

2245
01:34:28,900 --> 01:34:29,800
pretty darn sweet.

2246
01:34:29,900 --> 01:34:32,200
Eat and also, of course, you can follow the Twitter feed which always

2247
01:34:32,200 --> 01:34:35,000
announce the streams the day of and what time they're going to be.

2248
01:34:35,100 --> 01:34:36,800
So everything you needs up on handmade hero.

2249
01:34:36,800 --> 01:34:41,800
Dot-org tomorrow is Friday if I'm not very much in error.

2250
01:34:41,800 --> 01:34:42,700
It is a Friday tomorrow.

2251
01:34:42,700 --> 01:34:42,900
Is it?

2252
01:34:42,900 --> 01:34:43,100
Not?

2253
01:34:43,100 --> 01:34:45,000
Which means is an early stream tomorrow.

2254
01:34:45,100 --> 01:34:46,600
Fridays are early stream.

2255
01:34:46,700 --> 01:34:49,000
So, Friday will be, I think it's 11:00 a.m.

2256
01:34:49,000 --> 01:34:50,100
Tomorrow on schedule.

2257
01:34:50,400 --> 01:34:53,700
So for those of you who can join us, I would love to see you tomorrow

2258
01:34:53,700 --> 01:34:54,500
morning, 11:00 a.m.

2259
01:34:54,500 --> 01:34:55,500
Pacific Standard time.

2260
01:34:55,500 --> 01:34:58,400
I typically see all the folks from Europe at that time, who can make

2261
01:34:58,400 --> 01:34:59,800
it because it's not in the middle of

2262
01:35:00,100 --> 01:35:01,200
The night there anymore.

2263
01:35:01,700 --> 01:35:05,900
So hope to see some of you tomorrow and that is it for tonight.

2264
01:35:05,900 --> 01:35:08,000
So thanks for joining us and I will see you then.

