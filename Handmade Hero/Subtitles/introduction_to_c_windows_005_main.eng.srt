1
00:00:00,100 --> 00:00:01,500
Okay, here we go.

2
00:00:03,300 --> 00:00:09,100
So, someone asked a question in the beginning of that sort of the

3
00:00:09,100 --> 00:00:13,100
pre-chat here on the stream and they kind of wanted me to go back over

4
00:00:13,100 --> 00:00:15,800
where, everything lives they said.

5
00:00:15,800 --> 00:00:18,800
They said, like, we're destructs live and where two variables live and

6
00:00:18,800 --> 00:00:20,700
stuff like that and where two functions live.

7
00:00:21,300 --> 00:00:25,500
And the reason that I want to address that question specifically is

8
00:00:25,500 --> 00:00:28,600
because I am very glad someone asked, we have sort of said, where

9
00:00:28,600 --> 00:00:32,100
these things live, but it's hard to kind of take a lot of this stuff

10
00:00:32,100 --> 00:00:32,900
in when I say it.

11
00:00:33,300 --> 00:00:37,800
And I really do want people to constantly be thinking about that where

12
00:00:37,800 --> 00:00:38,600
things live.

13
00:00:38,700 --> 00:00:41,800
So I would like to mention again where everything lives.

14
00:00:42,900 --> 00:00:47,000
Code, which is like the, you know, the things that we write here code

15
00:00:47,000 --> 00:00:49,300
lives first in the executable file.

16
00:00:49,300 --> 00:00:52,800
So when we compile everything and we get a DOT exe file, the code is

17
00:00:52,800 --> 00:00:55,100
in there and the code is encoded.

18
00:00:56,500 --> 00:00:57,400
Code is encoded.

19
00:00:57,600 --> 00:00:59,900
The code is encoded in a format.

20
00:00:59,900 --> 00:01:03,400
That is defined by Intel that basically says well.

21
00:01:03,500 --> 00:01:07,100
And it's, there's also defined by AMD now, because I think they were

22
00:01:07,100 --> 00:01:10,200
the ones who officially did the x64 spec for 64-bit Computing.

23
00:01:10,200 --> 00:01:13,700
But Arc, this code is being compiled for 32-bit Computing.

24
00:01:14,200 --> 00:01:18,800
So, defined by Intel and encoding in binary that basically says, what

25
00:01:18,800 --> 00:01:21,400
the instructions are that the CPU supposed to do.

26
00:01:21,400 --> 00:01:24,700
So, we have an executable, and the executable has that in it.

27
00:01:24,700 --> 00:01:25,400
And, oh,

28
00:01:26,000 --> 00:01:27,700
Wait, you know, what?

29
00:01:28,000 --> 00:01:28,900
Do you guys think?

30
00:01:28,900 --> 00:01:31,000
I don't know if you're feeling this.

31
00:01:31,300 --> 00:01:35,900
Like I'm feeling this but I think this could be a place where we could

32
00:01:35,900 --> 00:01:36,700
bring out the Gimp.

33
00:01:36,700 --> 00:01:37,500
I don't know what you guys.

34
00:01:37,500 --> 00:01:38,800
I don't know if you guys feel it.

35
00:01:38,900 --> 00:01:42,000
You know, I don't want to, I don't want to tell you how you're

36
00:01:42,000 --> 00:01:42,500
feeling.

37
00:01:42,500 --> 00:01:43,000
Okay?

38
00:01:43,100 --> 00:01:47,400
I want you to be in touch with your own feelings, but I feel like this

39
00:01:47,400 --> 00:01:50,100
is a place where I could get out, the Wacom drawing tablet.

40
00:01:50,100 --> 00:01:53,300
I got this little tab, but I've had it for a long time and I could

41
00:01:53,300 --> 00:01:55,500
just go ahead and draw a diagram.

42
00:01:55,700 --> 00:01:57,600
Right, let's do that.

43
00:01:57,600 --> 00:01:58,800
Let's diagram this.

44
00:01:59,000 --> 00:02:00,100
Let's just go crazy.

45
00:02:02,000 --> 00:02:03,100
Out of this, could be a big mistake.

46
00:02:03,100 --> 00:02:05,800
Like I said, Sunday, stream, Sunday, stream, anything goes.

47
00:02:05,800 --> 00:02:07,100
I think you just have to say that.

48
00:02:07,100 --> 00:02:09,699
That's, I mean, you know, people have standards and standards are

49
00:02:09,699 --> 00:02:09,800
good.

50
00:02:09,800 --> 00:02:11,500
But sometimes you just got to go nuts.

51
00:02:12,100 --> 00:02:13,000
So, let's see here.

52
00:02:13,100 --> 00:02:13,600
So, let's see.

53
00:02:13,600 --> 00:02:16,100
Can I get a smaller pen about us about?

54
00:02:16,100 --> 00:02:17,500
Oh God what has happened?

55
00:02:18,500 --> 00:02:21,800
Yeah, my gimp skills are not the best game skills in the world.

56
00:02:21,800 --> 00:02:22,500
Let's see here.

57
00:02:22,700 --> 00:02:23,200
There we go.

58
00:02:23,300 --> 00:02:24,600
That seems that seems reasonable.

59
00:02:25,000 --> 00:02:27,700
So basically what happens is we have all our code.

60
00:02:28,000 --> 00:02:29,900
Oh God, this is going to be awful.

61
00:02:30,600 --> 00:02:31,100
Oh, man.

62
00:02:31,100 --> 00:02:31,100
I

63
00:02:31,300 --> 00:02:34,100
Gonna have to learn to use the Gimp better or learn how to use a Wacom

64
00:02:34,100 --> 00:02:35,300
drawing tablet better, I guess.

65
00:02:35,500 --> 00:02:35,900
All right.

66
00:02:35,900 --> 00:02:36,600
Let's see here.

67
00:02:36,800 --> 00:02:37,800
So we have code.

68
00:02:39,400 --> 00:02:41,300
That we right, right?

69
00:02:41,600 --> 00:02:44,200
And the compiler and the Linker.

70
00:02:44,400 --> 00:02:44,700
Well.

71
00:02:46,200 --> 00:02:49,000
So, the code goes into the compiler, right?

72
00:02:49,100 --> 00:02:49,600
The compiler.

73
00:02:49,600 --> 00:02:50,100
Spits out.

74
00:02:50,100 --> 00:02:52,400
Actually what's called an obj file and we'll be looking at those in

75
00:02:52,400 --> 00:02:53,500
the mainstream a little bit.

76
00:02:53,600 --> 00:02:55,300
The obj files go into the Linker.

77
00:02:57,100 --> 00:02:58,900
And they're joined with things called Libs.

78
00:02:59,700 --> 00:02:59,800
And

79
00:03:00,000 --> 00:03:03,300
Ribs are basically a bunch of obj's that have been compiled together

80
00:03:03,300 --> 00:03:04,700
into a, into a group.

81
00:03:04,800 --> 00:03:08,700
So there are things like the system libraries and stuff that that sort

82
00:03:08,700 --> 00:03:09,900
of allows you to pay for the system.

83
00:03:10,000 --> 00:03:13,600
These all go in to the Linker this time.

84
00:03:13,800 --> 00:03:14,500
You know what guys?

85
00:03:14,600 --> 00:03:15,500
This diagram is turning out.

86
00:03:15,500 --> 00:03:16,100
Awesome.

87
00:03:16,400 --> 00:03:17,100
Look at this.

88
00:03:17,300 --> 00:03:18,700
This is awesome.

89
00:03:19,400 --> 00:03:20,700
Tell me, you don't love this diagram.

90
00:03:20,700 --> 00:03:21,600
This is amazing.

91
00:03:22,200 --> 00:03:23,100
I mean, look at it already.

92
00:03:23,100 --> 00:03:26,000
Look at the Majesty anyway, so the code gets goes in the compiler.

93
00:03:26,000 --> 00:03:29,600
Sit down obj, file lives and obj is go into the Linker and the linkers

94
00:03:29,600 --> 00:03:29,800
fix.

95
00:03:30,000 --> 00:03:32,500
Us out an executable, right?

96
00:03:33,200 --> 00:03:34,200
And that sits on disk.

97
00:03:34,200 --> 00:03:39,100
And this is actually, this is in basically a Microsoft slat.

98
00:03:39,100 --> 00:03:40,800
Well, wow, that's good.

99
00:03:41,500 --> 00:03:46,500
Microsoft Intel format, and what that means is basically Microsoft

100
00:03:46,500 --> 00:03:47,900
because it's Windows defined.

101
00:03:47,900 --> 00:03:51,800
The format of this executable, which is basically the layout on disk

102
00:03:51,800 --> 00:03:53,500
and the layout involves stuff like.

103
00:03:53,500 --> 00:03:55,700
And this is not the actual layout of an egg, see because I don't even

104
00:03:55,700 --> 00:03:58,300
remember the actual there that's recent years since I've looked at it,

105
00:03:58,500 --> 00:03:59,800
but it's basically something that's like, you know,

106
00:04:00,000 --> 00:04:02,300
Header that says, this is an executable file.

107
00:04:02,400 --> 00:04:03,900
This is, this is the XE on disk.

108
00:04:03,900 --> 00:04:05,500
This is on disk, right?

109
00:04:05,600 --> 00:04:08,100
It's got like a fix-up table, right?

110
00:04:08,100 --> 00:04:11,000
So there's a thing in here, which basically a bunch of data that says,

111
00:04:11,100 --> 00:04:15,700
where we called system calls, like, where we called all the stuff that

112
00:04:15,700 --> 00:04:19,100
needs to go to the opportunism, and then it's got Intel format code,

113
00:04:19,200 --> 00:04:19,600
right?

114
00:04:19,700 --> 00:04:22,200
It's got its got the operands for the CPU, all the stuff that's got

115
00:04:22,200 --> 00:04:26,300
all the CPU code that we actually generated all bound up in here,

116
00:04:26,600 --> 00:04:27,200
right?

117
00:04:27,400 --> 00:04:29,700
So, then what's going to happen is 0.

118
00:04:29,900 --> 00:04:30,800
And feel this.

119
00:04:30,900 --> 00:04:31,700
Are you ready for this?

120
00:04:31,700 --> 00:04:32,900
This is going to be insane.

121
00:04:33,000 --> 00:04:34,100
You're not, you're not ready for it.

122
00:04:34,100 --> 00:04:36,600
I know you're not but dig it, right.

123
00:04:37,200 --> 00:04:38,200
Are you feeling that?

124
00:04:39,600 --> 00:04:40,100
Insane.

125
00:04:40,100 --> 00:04:40,700
Right?

126
00:04:41,000 --> 00:04:43,200
You didn't think I could do it, but I did.

127
00:04:43,500 --> 00:04:43,900
Right?

128
00:04:44,100 --> 00:04:44,800
All right.

129
00:04:44,800 --> 00:04:48,500
So what basically happens is, you know, you can, you can go look this

130
00:04:48,500 --> 00:04:48,900
up there.

131
00:04:48,900 --> 00:04:51,800
If you look up, Windows, executable or something on, Wikipedia, you

132
00:04:51,800 --> 00:04:54,500
can go look up the actual structure of this if you're curious about it

133
00:04:55,400 --> 00:04:57,400
because it's not that complicated, pretty straightforward.

134
00:04:57,600 --> 00:04:59,500
But basically what happens is Windows, then comes along.

135
00:04:59,500 --> 00:05:01,900
It's like, you know, in the Shell, you say, I want to run this

136
00:05:01,900 --> 00:05:03,000
executable, right?

137
00:05:03,000 --> 00:05:04,500
You're just like I got to run this executable.

138
00:05:04,700 --> 00:05:07,200
So what it's going to do is it's going to load up this code, right?

139
00:05:07,200 --> 00:05:09,200
It's going to take this code and it's going to put this code.

140
00:05:09,400 --> 00:05:10,100
To memory somewhere.

141
00:05:10,100 --> 00:05:11,000
So, here's the memory.

142
00:05:11,000 --> 00:05:12,700
Now of the machine, right?

143
00:05:12,900 --> 00:05:15,500
And it's going to take the Intel code stuff.

144
00:05:15,500 --> 00:05:16,500
It's going to put it in here.

145
00:05:17,000 --> 00:05:19,000
Then when it's going to do is going to look at this Fickett up this

146
00:05:19,000 --> 00:05:22,600
fix-up table, which basically tells it a bunch of places in this code,

147
00:05:22,600 --> 00:05:24,000
where we called system calls.

148
00:05:24,200 --> 00:05:27,300
Because remember when I said one of the streams, I'm like, we don't

149
00:05:27,300 --> 00:05:29,100
actually compile the whole thing together.

150
00:05:29,100 --> 00:05:31,800
We, there's always a little bit of linking left to be done because any

151
00:05:31,800 --> 00:05:33,300
place we call a system call.

152
00:05:33,600 --> 00:05:37,300
Well, the system Windows is outside of our executable.

153
00:05:37,400 --> 00:05:39,200
So, we basically have to call Windows is

154
00:05:39,300 --> 00:05:40,500
Executable code somehow.

155
00:05:40,500 --> 00:05:41,300
And how are we gonna do that?

156
00:05:41,300 --> 00:05:44,000
We can't compile all of Windows into our thing, because then you'd

157
00:05:44,000 --> 00:05:47,100
have to start Windows with our code in it somehow, right?

158
00:05:47,100 --> 00:05:48,100
That doesn't make any sense.

159
00:05:50,400 --> 00:05:52,600
We'd have to write the operating system for that to be true.

160
00:05:53,100 --> 00:05:55,700
Wouldn't that be a nice World by the way, that's how things used to

161
00:05:55,700 --> 00:05:56,800
work on like the Amiga and stuff.

162
00:05:56,800 --> 00:05:58,500
Used to actually have kind of when you wrote a game.

163
00:05:58,500 --> 00:05:59,600
It would boot right into the game.

164
00:06:00,000 --> 00:06:03,800
No or c64 as well, but ignoring all that so many, what happens is, it

165
00:06:03,800 --> 00:06:07,600
goes in here, the OS goes in this fix up table, basically, and I'm

166
00:06:07,600 --> 00:06:10,300
skipping a lot of kind of minutiae, but base is going to read a fix-up

167
00:06:10,300 --> 00:06:10,500
table.

168
00:06:10,500 --> 00:06:13,700
That says, here's a places, they called system calls, so, go right

169
00:06:13,700 --> 00:06:16,900
into the memory and patch over, like overwrite.

170
00:06:16,900 --> 00:06:20,800
The the sort of blank area that's talking about the the system call

171
00:06:20,800 --> 00:06:24,100
with an actual pointer to Windows, right?

172
00:06:25,400 --> 00:06:26,300
Windows code.

173
00:06:27,000 --> 00:06:29,200
So, you know, and I'm going to draw this a little more sanely because

174
00:06:29,200 --> 00:06:30,400
this I can actually do a little more.

175
00:06:31,800 --> 00:06:33,000
So, here's Windows code.

176
00:06:35,300 --> 00:06:39,700
Okay, and the question is, how does Windows could get there this?

177
00:06:39,700 --> 00:06:42,500
If you remember I talked about virtual memory and virtual address

178
00:06:42,500 --> 00:06:43,500
spaces, right?

179
00:06:43,700 --> 00:06:47,000
And I said that when you run your program you get your own virtual

180
00:06:47,000 --> 00:06:49,200
address space and I'm like, it's your own address space.

181
00:06:49,200 --> 00:06:51,900
It's all your own memory and windows behind the scenes.

182
00:06:52,000 --> 00:06:54,000
It's kind of mapping that memory to Ram.

183
00:06:54,400 --> 00:06:57,300
So this is our virtual address space basically and it doesn't

184
00:06:57,300 --> 00:06:59,100
necessarily correspond to the physical memory that machine.

185
00:06:59,100 --> 00:07:01,400
It just Maps it in and out as it's necessary, right?

186
00:07:01,800 --> 00:07:05,000
So what happens actually, is that in your virtual?

187
00:07:05,200 --> 00:07:09,000
Memory space Windows actually goes ahead and Maps.

188
00:07:09,000 --> 00:07:13,900
A copy of the stuff that you need to call into your virtual address

189
00:07:13,900 --> 00:07:14,100
space.

190
00:07:14,100 --> 00:07:16,200
So it takes it from its space, right?

191
00:07:16,200 --> 00:07:19,900
Here's the actual Windows code that's actually running in its own, you

192
00:07:19,900 --> 00:07:21,200
know, address space and doing whatever.

193
00:07:21,200 --> 00:07:25,000
The, you know, it wants to do and basically it goes ahead map that

194
00:07:25,000 --> 00:07:28,700
into your address space then it patches up your code to point into

195
00:07:28,700 --> 00:07:29,500
that code.

196
00:07:29,600 --> 00:07:33,100
So any time you called like when we had our code on of still in there,

197
00:07:33,200 --> 00:07:33,800
I think it is.

198
00:07:35,000 --> 00:07:37,900
Yeah, so we would have this output debug string call.

199
00:07:38,000 --> 00:07:39,600
Right, and we need to call Windows.

200
00:07:39,800 --> 00:07:40,800
That's what was going on.

201
00:07:40,800 --> 00:07:44,100
It was basically, when the code was loaded, it was finding that call

202
00:07:44,200 --> 00:07:47,100
using the fix-up table that the Linker output and it was patching, a

203
00:07:47,100 --> 00:07:50,100
call to the actual location of output debug string, which was

204
00:07:50,100 --> 00:07:51,900
somewhere in here, right?

205
00:07:52,100 --> 00:07:55,400
That's roughly, how Lincoln goes when all of that fix up is done.

206
00:07:55,800 --> 00:07:59,800
Then it uses one final piece of information in.

207
00:07:59,800 --> 00:08:00,600
It's not really called.

208
00:08:00,700 --> 00:08:01,800
It wouldn't be called a fix-up in.

209
00:08:01,800 --> 00:08:04,000
It wouldn't be in a fix of table quote-unquote, but it would be the

210
00:08:04,000 --> 00:08:04,700
entry point.

211
00:08:04,800 --> 00:08:08,500
Which is basically the location in this code to start running and it

212
00:08:08,500 --> 00:08:11,400
just jumps right into that and then goes right.

213
00:08:11,500 --> 00:08:15,700
That is how basically something gets running on an operating system.

214
00:08:15,700 --> 00:08:18,700
And like I said, I skipped a lot of minutiae there and every operating

215
00:08:18,700 --> 00:08:21,700
system has all kinds of crazy wacky stuff that's going on.

216
00:08:21,700 --> 00:08:24,200
That's, you know, probably a little different from from this but that

217
00:08:24,200 --> 00:08:28,500
is a reasonable conceptual model of what's happening when you actually

218
00:08:28,500 --> 00:08:29,000
do stuff.

219
00:08:29,800 --> 00:08:33,299
So when you ask where code lives, that is where code lives.

220
00:08:33,299 --> 00:08:34,600
It first lives in the executable.

221
00:08:34,799 --> 00:08:38,500
In here, it then gets loaded into memory and mind you.

222
00:08:38,500 --> 00:08:40,799
It can often be demand, paged into memory.

223
00:08:40,799 --> 00:08:44,900
So it will be virtually mapped into memory, but it may not actually

224
00:08:44,900 --> 00:08:47,500
get copied into memory until you actually hit the part of the code

225
00:08:47,500 --> 00:08:50,100
that you actually need to run it which case it'll load that in the

226
00:08:50,100 --> 00:08:51,900
starting to look like a John Madden.

227
00:08:51,900 --> 00:08:53,100
Kind of diagram, you know what I mean?

228
00:08:53,700 --> 00:08:58,300
Anyway, so basically, what happens is that code, get lives in us in a

229
00:08:58,300 --> 00:08:59,900
space in memory that

230
00:09:00,000 --> 00:09:04,700
Windows allocated and windows map it in now against it's a Sunday

231
00:09:04,700 --> 00:09:06,900
stream and we're just going all out in the Sunday stream.

232
00:09:06,900 --> 00:09:11,100
I mean, look, you came to the stream on Sunday.

233
00:09:11,100 --> 00:09:12,700
I get to do whatever I want on Sunday.

234
00:09:12,800 --> 00:09:13,600
Okay, that's just weird.

235
00:09:13,600 --> 00:09:14,700
Making a new rule.

236
00:09:14,800 --> 00:09:18,800
I know we don't have rules on this this stream yet, but it's like

237
00:09:18,800 --> 00:09:19,900
that's just the way things are.

238
00:09:19,900 --> 00:09:20,100
Okay.

239
00:09:20,100 --> 00:09:23,700
It's like it's anything goes on a Sunday stuff, just goes nuts.

240
00:09:24,100 --> 00:09:27,800
So basically what happens is the virtual memory system.

241
00:09:28,400 --> 00:09:29,800
You'll remember I talked about

242
00:09:30,000 --> 00:09:31,100
Pages, right.

243
00:09:31,200 --> 00:09:34,500
So if I have an address space, if I have a virtual memory address

244
00:09:34,500 --> 00:09:37,500
space, will call that a beam as virtual memory address space, right?

245
00:09:37,600 --> 00:09:41,700
And it starts at 0, and it goes up to like high number, very high

246
00:09:41,700 --> 00:09:42,200
number.

247
00:09:42,300 --> 00:09:46,200
Many gigabytes of memory potentially, especially on 64-bit on 32-bit.

248
00:09:46,200 --> 00:09:46,600
The highest number.

249
00:09:46,600 --> 00:09:49,700
You can represent is 4 billion, so it can only go up to 4 billion.

250
00:09:50,200 --> 00:09:53,100
But in, you know, 64 bit and go up much higher than that, because

251
00:09:53,100 --> 00:09:54,300
64-bit is huge.

252
00:09:54,400 --> 00:09:57,300
Anyway, I have a virtual memory address space and it's divided up into

253
00:09:57,300 --> 00:09:57,800
Pages.

254
00:09:58,000 --> 00:09:59,200
These things are called Pages.

255
00:09:59,400 --> 00:09:59,900
This is a

256
00:10:00,000 --> 00:10:00,700
Age.

257
00:10:00,700 --> 00:10:01,900
This is a page.

258
00:10:01,900 --> 00:10:02,800
This is a page.

259
00:10:02,900 --> 00:10:03,500
Right?

260
00:10:03,700 --> 00:10:08,600
And these pages are typically like 4096 bytes, right?

261
00:10:08,600 --> 00:10:10,800
Or sixty, four thousand bytes.

262
00:10:11,200 --> 00:10:13,600
Well, 65536 64k.

263
00:10:13,800 --> 00:10:14,800
It's time to 1024.

264
00:10:15,400 --> 00:10:17,400
These pages are usually sizes like that.

265
00:10:17,400 --> 00:10:18,400
So they're pretty granular.

266
00:10:18,400 --> 00:10:22,100
But, you know, they store a fair bit, you know, 64k is a fair bit of

267
00:10:22,100 --> 00:10:22,600
data in there.

268
00:10:22,600 --> 00:10:24,300
There's will there's, you know, reason why stuff in there.

269
00:10:25,100 --> 00:10:28,400
So the virtual memory address space is divided up into pages and those

270
00:10:28,400 --> 00:10:29,100
pages.

271
00:10:29,600 --> 00:10:31,700
There's basically like a table, right?

272
00:10:32,100 --> 00:10:35,000
There's going to be a table in the operating system, that is, you

273
00:10:35,000 --> 00:10:36,500
know, think it's usually called a page table.

274
00:10:36,500 --> 00:10:38,000
I don't really know what they call it in Windows.

275
00:10:38,200 --> 00:10:41,300
But anyway, there's usually a table and what that table does is that

276
00:10:41,300 --> 00:10:44,000
table records like what's going on with these Pages.

277
00:10:44,000 --> 00:10:48,300
Just like, okay this page, you know is actually stored on disk

278
00:10:48,300 --> 00:10:49,500
somewhere because we paged it out.

279
00:10:49,500 --> 00:10:51,600
So this is this page is out in disk.

280
00:10:51,600 --> 00:10:53,700
So, you know, it's not actually in memory.

281
00:10:53,700 --> 00:10:54,800
There's no physical memory back.

282
00:10:54,800 --> 00:10:57,800
But this page right here, you know, that is in physical memory.

283
00:10:57,800 --> 00:11:00,100
That's that's over here in the actual memory of the machine or

284
00:11:00,100 --> 00:11:00,700
something like this.

285
00:11:00,700 --> 00:11:03,000
And like I said, I don't know how they implemented this on window.

286
00:11:03,000 --> 00:11:04,500
So I'm not trying to tell you anything.

287
00:11:04,500 --> 00:11:07,400
Specific about how Windows works.

288
00:11:07,400 --> 00:11:09,000
I'm just saying, conceptually, it's good.

289
00:11:09,000 --> 00:11:11,700
Going to kind of understand the opposite of knows where these things

290
00:11:11,700 --> 00:11:11,800
are.

291
00:11:11,800 --> 00:11:19,000
Now, the processor, the Intel processor basically has ways it has

292
00:11:19,000 --> 00:11:20,400
support for this in the hardware.

293
00:11:20,400 --> 00:11:24,800
We're basically each page can have flag set on it and those flags.

294
00:11:24,800 --> 00:11:27,100
I have to do with what can happen that page.

295
00:11:27,100 --> 00:11:29,100
It's like, can you read this page?

296
00:11:29,500 --> 00:11:30,900
Can you write this page?

297
00:11:31,200 --> 00:11:32,700
Can you executive this page?

298
00:11:32,700 --> 00:11:34,600
Can you execute code basically in this page?

299
00:11:34,900 --> 00:11:35,500
Right?

300
00:11:35,900 --> 00:11:37,800
And those flags are set on the page?

301
00:11:37,800 --> 00:11:41,300
So what windows will do is it'll go, I am running low on physical

302
00:11:41,300 --> 00:11:42,300
memory of the moment.

303
00:11:42,300 --> 00:11:46,200
I need to make some space in the physical memory and this page is like

304
00:11:46,200 --> 00:11:47,100
in the physical memory.

305
00:11:47,200 --> 00:11:49,500
So what I'll do is I'll grab what's in this page.

306
00:11:49,500 --> 00:11:53,500
I'll write it out to disk and then I'm going to unset the read and

307
00:11:53,500 --> 00:11:54,700
write flags for this.

308
00:11:54,800 --> 00:11:56,000
Page or something like this, right?

309
00:11:56,000 --> 00:11:56,800
And the exact page.

310
00:11:56,800 --> 00:11:58,000
I'll so I'll just it's guarded.

311
00:11:58,000 --> 00:11:59,900
The page is now completely off your

312
00:12:00,000 --> 00:12:01,100
Can't do anything to it.

313
00:12:01,200 --> 00:12:01,800
Right?

314
00:12:02,200 --> 00:12:06,800
What will then happen is when your code goes to do something on that

315
00:12:06,800 --> 00:12:08,900
page, whether it's happens to be a code page.

316
00:12:08,900 --> 00:12:11,300
So it's going to try to execute code, you know, and the as it's

317
00:12:11,300 --> 00:12:13,500
exiting through the instructions, that eventually gets into this page

318
00:12:13,500 --> 00:12:16,000
and tries to execute something, or if it's memory in your trying to

319
00:12:16,000 --> 00:12:17,100
read from it, or right to it.

320
00:12:17,100 --> 00:12:19,400
Like you would just variables or in there whatever and you're

321
00:12:19,400 --> 00:12:20,100
accessing them.

322
00:12:20,400 --> 00:12:23,600
What will happen is your process will just grind to an immediate Halt

323
00:12:23,600 --> 00:12:26,100
and you'll have what's called a page fault, right?

324
00:12:26,100 --> 00:12:29,500
You will basically cause a fault, they'll be an interrupt and the

325
00:12:29,500 --> 00:12:29,900
operating

326
00:12:30,000 --> 00:12:32,000
Some will wake back up and the Intel processor.

327
00:12:32,000 --> 00:12:34,400
Basically gives the op, you know, gives the operating system, the

328
00:12:34,400 --> 00:12:37,600
option to do something at that time, and what the operating system

329
00:12:37,600 --> 00:12:38,700
will do is we'll go.

330
00:12:38,700 --> 00:12:41,400
Oh, somebody needs this page now.

331
00:12:41,500 --> 00:12:43,500
Okay, I'll go back out to disk.

332
00:12:43,500 --> 00:12:44,300
I'll get it.

333
00:12:44,300 --> 00:12:45,600
I'll shove it back in here.

334
00:12:45,800 --> 00:12:49,200
And once it's loaded, I'll restart that process where it left off.

335
00:12:49,200 --> 00:12:53,100
So basically freezes what you're doing, does the operation necessary

336
00:12:53,100 --> 00:12:54,700
to put it back in there and then keeps going.

337
00:12:54,900 --> 00:12:58,200
So hopefully that makes some sense and that's true of code Pages as

338
00:12:58,200 --> 00:12:59,500
well as data pages and everything else.

339
00:12:59,500 --> 00:12:59,800
That's what

340
00:13:00,000 --> 00:13:02,600
Virtual memory system basically is, it's a system where the operating

341
00:13:02,600 --> 00:13:04,400
system wakes up anytime.

342
00:13:04,500 --> 00:13:05,600
Somebody needs a page.

343
00:13:05,600 --> 00:13:08,300
That's not there and does something to make that work.

344
00:13:08,300 --> 00:13:11,600
Now what can happen if the program is just bad.

345
00:13:11,600 --> 00:13:14,700
If the program is written wrong and we'll have this happen during our

346
00:13:14,700 --> 00:13:15,000
stream.

347
00:13:15,000 --> 00:13:17,600
I'm sure because it's easy to have bugs in your code.

348
00:13:17,600 --> 00:13:21,600
Obviously you might accidentally right to a page that's off-limits.

349
00:13:21,700 --> 00:13:23,800
Like for example, you never allocated anything.

350
00:13:23,800 --> 00:13:24,600
In this page.

351
00:13:24,600 --> 00:13:26,200
This page is not even a thing.

352
00:13:26,200 --> 00:13:29,400
You just wrote to an address some random address in memory.

353
00:13:29,400 --> 00:13:29,800
You tried to

354
00:13:29,900 --> 00:13:30,400
Right to it.

355
00:13:30,400 --> 00:13:33,100
And you never even told the opportunism, something was there?

356
00:13:33,100 --> 00:13:35,600
Because all these Pages before, the operating system, is going to

357
00:13:35,600 --> 00:13:37,200
start tracking them, all the pages.

358
00:13:37,400 --> 00:13:39,800
They have to actually be known to operate system.

359
00:13:39,800 --> 00:13:40,900
So you have to make calls to operation.

360
00:13:40,900 --> 00:13:43,900
To say, I'm going to use memory in this page now, right?

361
00:13:44,400 --> 00:13:47,900
So what happens then is you get a page fault and the operating system

362
00:13:47,900 --> 00:13:50,700
wakes up and goes, I don't know that page.

363
00:13:50,700 --> 00:13:51,700
What, what is that page?

364
00:13:51,700 --> 00:13:52,800
That doesn't make any sense?

365
00:13:52,800 --> 00:13:55,900
You're obviously messed up and I'm going to stop you.

366
00:13:56,000 --> 00:13:59,000
And that's when you get that little box, that's like this system has

367
00:13:59,000 --> 00:13:59,800
caused an access.

368
00:14:00,000 --> 00:14:01,000
Station, right?

369
00:14:01,100 --> 00:14:02,900
And you've all seen this, you've all been playing the game and have

370
00:14:02,900 --> 00:14:03,400
that happen.

371
00:14:03,400 --> 00:14:06,100
I guarantee if you've played PC games, you've had an access violation

372
00:14:06,100 --> 00:14:07,400
pop up in your like, wah, wah, wah,

373
00:14:09,700 --> 00:14:10,700
Well, that's what happened.

374
00:14:10,700 --> 00:14:12,500
Basically, someone had a pointer pointing somewhere.

375
00:14:12,500 --> 00:14:15,600
It shouldn't they rode into it or God knows what something bad

376
00:14:15,600 --> 00:14:17,100
happened and off you went.

377
00:14:17,800 --> 00:14:19,600
Okay, so that's kind of a conceptual model for it.

378
00:14:19,600 --> 00:14:20,100
Right?

379
00:14:20,800 --> 00:14:25,400
So basically the first answer to where code code and data and all that

380
00:14:25,400 --> 00:14:29,000
stuff lives is it lives in that virtual address space and basically

381
00:14:29,000 --> 00:14:31,700
that virtual address space is broken up into pages.

382
00:14:31,700 --> 00:14:32,700
So here are my pages.

383
00:14:33,600 --> 00:14:34,200
Right?

384
00:14:34,300 --> 00:14:37,200
And each page is basically stored somewhere.

385
00:14:37,200 --> 00:14:39,000
It's either in the physical memory.

386
00:14:40,200 --> 00:14:40,600
Right.

387
00:14:40,700 --> 00:14:42,600
So each page is either in there.

388
00:14:44,400 --> 00:14:45,800
Or it's on disk somewhere.

389
00:14:46,600 --> 00:14:47,100
Right.

390
00:14:47,100 --> 00:14:52,200
And so what will happen is for efficiency sake, when Windows goes to

391
00:14:52,200 --> 00:14:56,600
load your code, which is on disk the executable, what it might choose

392
00:14:56,600 --> 00:14:59,900
to do because there's no reason it can't what it might.

393
00:15:00,000 --> 00:15:03,800
To do is not ever actually load the code.

394
00:15:03,800 --> 00:15:07,600
It might just map the pages, right?

395
00:15:08,900 --> 00:15:13,500
It'll map these pages to the spot on the drive, where your code

396
00:15:13,500 --> 00:15:18,600
actually is, then it'll just start executing the code right in the

397
00:15:18,600 --> 00:15:22,000
main memory, that doesn't exist, and let the page faulting bring the

398
00:15:22,000 --> 00:15:23,100
code actually in.

399
00:15:23,300 --> 00:15:25,100
It could decide to do that, right.

400
00:15:25,200 --> 00:15:27,200
And for efficiency, maybe that's a good idea.

401
00:15:27,200 --> 00:15:29,900
Because now if there's code that you don't ever really execute very

402
00:15:29,900 --> 00:15:31,900
often, it never has to get loaded.

403
00:15:32,300 --> 00:15:34,400
Might not be a great idea for a performance because it means when you

404
00:15:34,400 --> 00:15:37,000
go to exit this piece of code, the first time it's like, oh puis hit,

405
00:15:37,000 --> 00:15:38,600
you know, we got to go page out to disk that set.

406
00:15:38,800 --> 00:15:42,200
Cetera, so the smarter thing would probably be to start this loading

407
00:15:42,200 --> 00:15:45,300
all the pages, but you could start executing beforehand.

408
00:15:45,300 --> 00:15:48,300
And that way, if you didn't beat, if the disk didn't beat the code to

409
00:15:48,300 --> 00:15:49,900
the execution, it could do, blah, blah, blah.

410
00:15:49,900 --> 00:15:50,800
There's all sorts of sit here.

411
00:15:51,100 --> 00:15:51,800
It's good.

412
00:15:52,500 --> 00:15:53,300
It's all good.

413
00:15:53,400 --> 00:15:57,400
Anyway, that is some fun diagramming of where the code lives.

414
00:15:57,600 --> 00:15:58,100
So,

415
00:15:59,700 --> 00:16:01,200
I'm going to rearrange this here.

416
00:16:01,900 --> 00:16:02,100
Now.

417
00:16:02,100 --> 00:16:03,600
Let's talk about where everything else lives.

418
00:16:03,700 --> 00:16:04,700
So functions.

419
00:16:04,700 --> 00:16:05,600
They all live in there.

420
00:16:05,600 --> 00:16:06,800
They all live in the executable.

421
00:16:06,800 --> 00:16:09,500
Then they get paged into distant page, into the memory as a need to

422
00:16:09,500 --> 00:16:10,800
get executed in the CPU.

423
00:16:11,000 --> 00:16:12,100
Pulls them in execute them.

424
00:16:12,300 --> 00:16:15,600
Now since we're being banana cakes, there's one more thing.

425
00:16:15,600 --> 00:16:16,500
You should be aware of.

426
00:16:16,600 --> 00:16:17,500
Here's the CPU.

427
00:16:18,900 --> 00:16:21,000
This is my x86.

428
00:16:21,400 --> 00:16:24,600
It's actually an x 64 in this machine, but it has an x86 has the

429
00:16:24,600 --> 00:16:26,700
ability to execute x86 code.

430
00:16:27,000 --> 00:16:33,700
So, typically in a CPU, you know, we've got code here and I said it

431
00:16:33,700 --> 00:16:36,900
was in, you know, the Intel encoded format, right?

432
00:16:37,000 --> 00:16:40,200
And I showed this, I actually showed you this encoding, right?

433
00:16:40,200 --> 00:16:42,000
If you remember, I showed it to you.

434
00:16:43,000 --> 00:16:48,300
We did something where I went in here and I did like, you know, I

435
00:16:48,300 --> 00:16:48,500
don't know.

436
00:16:48,700 --> 00:16:49,000
Something.

437
00:16:49,000 --> 00:16:49,900
I don't know what we're doing.

438
00:16:49,900 --> 00:16:54,000
Who knows what we were doing at the time, but I went in here and I did

439
00:16:54,000 --> 00:16:58,500
go to disassembly, and there is this button here is show code bites.

440
00:16:59,500 --> 00:17:00,000
Right?

441
00:17:00,000 --> 00:17:03,500
And I did show code B on and off and basically what happened there was

442
00:17:03,500 --> 00:17:07,800
I just turned on the ability to see what the actual encoding was the

443
00:17:07,800 --> 00:17:08,200
instruction.

444
00:17:08,200 --> 00:17:10,599
So this is what's actually stored in the executable and what's

445
00:17:10,599 --> 00:17:12,700
actually going to run on disk.

446
00:17:13,099 --> 00:17:14,700
What's actually in a run in memory when it's loaded.

447
00:17:14,800 --> 00:17:16,500
This is the actual encoding.

448
00:17:16,500 --> 00:17:17,300
That's what stored.

449
00:17:17,300 --> 00:17:18,500
It's these bites right here.

450
00:17:18,500 --> 00:17:20,800
Right here is the location in memory where the bite is stored.

451
00:17:20,800 --> 00:17:22,800
And here's the B, and this is each instruction.

452
00:17:22,800 --> 00:17:26,400
So, here's a function call in the function, call is encoded this way,

453
00:17:26,500 --> 00:17:27,000
right?

454
00:17:28,400 --> 00:17:32,100
So that stuff is in memory somewhere.

455
00:17:32,100 --> 00:17:35,100
So it got loaded into memory and the CPU is trying to access it.

456
00:17:35,100 --> 00:17:38,100
So the CPU comes and grabs it as it needs to.

457
00:17:38,100 --> 00:17:39,400
So, as it's executing instructions.

458
00:17:39,400 --> 00:17:40,500
It's going to the next instruction.

459
00:17:40,500 --> 00:17:42,100
The next instruction hasn't been loaded yet.

460
00:17:42,100 --> 00:17:43,300
It goes off to get it.

461
00:17:43,400 --> 00:17:48,000
And what happens is it brings it into the to to the CPU but not

462
00:17:48,000 --> 00:17:49,000
necessarily directly.

463
00:17:49,200 --> 00:17:52,600
There's a thing typically called an eye cash, right?

464
00:17:53,000 --> 00:17:54,000
And that's an called.

465
00:17:54,100 --> 00:17:54,400
I cash.

466
00:17:54,400 --> 00:17:57,100
I believe because it stands for instruction cache and basically what

467
00:17:57,100 --> 00:17:58,000
happens is the sea.

468
00:17:58,100 --> 00:17:59,800
EP, you may not.

469
00:18:00,000 --> 00:18:04,400
Like to directly execute stuff out of memory because that stuff may

470
00:18:04,400 --> 00:18:08,000
need to be sort of further munged for the CPU to use it.

471
00:18:08,000 --> 00:18:11,600
It may need to expand some things that may need to microcode certain

472
00:18:11,600 --> 00:18:12,300
think, I mean, who knows?

473
00:18:12,300 --> 00:18:12,900
What does I like?

474
00:18:12,900 --> 00:18:14,000
I said not a hardware designer.

475
00:18:14,000 --> 00:18:16,200
I'm not going to try and pretend I know exactly why they have all

476
00:18:16,200 --> 00:18:21,400
these things but point being it becomes more efficient for the CPU to

477
00:18:21,400 --> 00:18:27,500
basically cash the instructions that it executes in like in its cache,

478
00:18:28,500 --> 00:18:29,800
you know, it's local cache on the seat.

479
00:18:30,000 --> 00:18:32,500
EU so that it can quickly access code that it's running.

480
00:18:32,500 --> 00:18:35,200
So, for example, if you have a loop and that Loop is going to execute

481
00:18:35,200 --> 00:18:39,700
tons of times or something, you're running all this code, it wants to

482
00:18:39,700 --> 00:18:42,700
do a bunch of work on that code first and then be able to just execute

483
00:18:42,700 --> 00:18:45,100
that code straight out of its cash instead of going to memory every

484
00:18:45,100 --> 00:18:46,200
time to kind of pull it back in.

485
00:18:46,200 --> 00:18:50,400
So, there is this thing called an eye cash and it does exist on most

486
00:18:50,400 --> 00:18:50,600
CPUs.

487
00:18:50,600 --> 00:18:54,700
Now that basically preps the code for use, by the CPU, in some way

488
00:18:54,700 --> 00:18:58,200
that the CPU understands and it's used as a local sort of way of

489
00:18:58,200 --> 00:18:59,000
storing that code.

490
00:18:59,000 --> 00:19:00,000
Now, you may think

491
00:19:00,000 --> 00:19:01,800
That's complete minutiae.

492
00:19:01,800 --> 00:19:03,100
That's uninteresting.

493
00:19:03,100 --> 00:19:04,300
And you never need to know it.

494
00:19:04,500 --> 00:19:08,400
I have actually seen times on projects where the I cash was the

495
00:19:08,400 --> 00:19:09,000
problem.

496
00:19:09,600 --> 00:19:14,700
I think I even may have created and I cash problem one time I think on

497
00:19:14,700 --> 00:19:19,900
Bink to I did a bunch of stuff with code generation that later on a

498
00:19:19,900 --> 00:19:25,600
certain platform Fabi and end up having to optimize by just making the

499
00:19:25,600 --> 00:19:29,600
code smaller because the I cash was actually a penalty like filling

500
00:19:29,600 --> 00:19:29,800
the eye.

501
00:19:29,900 --> 00:19:33,300
Cash was actually problem, don't quote me on that ask Bobby about it.

502
00:19:33,300 --> 00:19:38,100
But anyway, so that's basically what happens with with code now with

503
00:19:38,100 --> 00:19:39,500
data, right?

504
00:19:39,800 --> 00:19:40,300
You'll remember.

505
00:19:40,300 --> 00:19:41,800
So I've got these pages, right?

506
00:19:41,800 --> 00:19:44,000
We keep going back to this page has thing, but I have Pages Pages

507
00:19:44,000 --> 00:19:44,400
pages.

508
00:19:44,400 --> 00:19:47,300
So here's my virtual memory address space and I've got all these pages

509
00:19:47,300 --> 00:19:47,800
in there.

510
00:19:48,300 --> 00:19:51,300
Well, what happens when I start executing my code, right?

511
00:19:51,400 --> 00:19:53,600
And you know, you look back here and you got, you know, we came into

512
00:19:53,600 --> 00:19:54,200
in Maine.

513
00:19:54,400 --> 00:19:58,100
So we were in Maine, having a good old time and I try to declare this

514
00:19:58,100 --> 00:19:58,700
local variable.

515
00:19:58,700 --> 00:19:59,800
It's a projectile, right?

516
00:20:00,000 --> 00:20:03,500
This big, it's a 16 byte structure or something that we've got here.

517
00:20:03,700 --> 00:20:04,000
Right?

518
00:20:04,000 --> 00:20:04,400
It's this thing.

519
00:20:04,400 --> 00:20:07,600
I wanted to Claire and I talked about the fact that it goes on the

520
00:20:07,600 --> 00:20:08,000
stack.

521
00:20:08,000 --> 00:20:09,200
Well, what is the stack?

522
00:20:10,100 --> 00:20:12,500
And I sort of showed, you know, I showed how you could go look at

523
00:20:12,500 --> 00:20:14,000
where the memory was and that sort of stuff.

524
00:20:16,700 --> 00:20:19,700
But I also said that someone has to allocate everything and so the

525
00:20:19,700 --> 00:20:22,900
person who is doing that was actually the startup code.

526
00:20:23,500 --> 00:20:25,400
I think it's hmm.

527
00:20:25,800 --> 00:20:28,700
I think it's actually the startup code in Windows that sets up the

528
00:20:28,700 --> 00:20:29,600
stack for you.

529
00:20:29,900 --> 00:20:31,400
I'm pretty sure I'm about it.

530
00:20:31,400 --> 00:20:32,400
I'm pretty sure that's true.

531
00:20:32,800 --> 00:20:35,600
Not the C runtime library because I've compiled without the C runtime

532
00:20:35,600 --> 00:20:37,600
library and didn't have to set up the stack myself.

533
00:20:37,600 --> 00:20:39,700
So I think Windows actually sets up the stack for you.

534
00:20:40,200 --> 00:20:43,100
And what the stack is is it's basically it Maps a page and it

535
00:20:43,100 --> 00:20:47,600
basically says, okay this first page here at some address for this

536
00:20:47,600 --> 00:20:52,900
particular thread of execution of your code is going to be this page.

537
00:20:53,100 --> 00:20:56,400
And what I'm going to do is I'm going to set a guard page right after

538
00:20:56,400 --> 00:20:58,100
that page that basically says.

539
00:20:58,100 --> 00:20:59,800
As soon as somebody tries to write

540
00:21:00,000 --> 00:21:03,100
To this page, right assume when something gets to this page.

541
00:21:03,100 --> 00:21:04,300
This page is protected.

542
00:21:04,300 --> 00:21:07,900
So that will cause a fault that will actually allow me to go map a new

543
00:21:07,900 --> 00:21:08,700
page in here.

544
00:21:08,900 --> 00:21:12,600
So, there's basically a reserved, there's basically a step a bunch of

545
00:21:12,600 --> 00:21:15,800
memory that's reserved for us to keep growing.

546
00:21:15,800 --> 00:21:18,300
This thing down further and further.

547
00:21:18,300 --> 00:21:20,400
So, the stack can just get bigger and bigger and bigger.

548
00:21:20,900 --> 00:21:24,500
And so that every time we call a function, it gets bigger, growing the

549
00:21:24,500 --> 00:21:25,100
stack.

550
00:21:25,100 --> 00:21:28,100
And then whenever we return from a function, it kind of moves the

551
00:21:28,100 --> 00:21:28,800
other direction.

552
00:21:28,900 --> 00:21:29,800
So Stacks grow.

553
00:21:30,000 --> 00:21:32,800
Do you know, they get bigger and then they shrink and then they grow

554
00:21:32,800 --> 00:21:34,600
and then they shrink, and then they grow, and I talked about that

555
00:21:34,600 --> 00:21:35,200
procedure.

556
00:21:35,400 --> 00:21:36,200
But basically, what's happening.

557
00:21:36,200 --> 00:21:38,600
There's Windows is mapping memory for us to use the stack.

558
00:21:38,600 --> 00:21:42,600
And when we grow out of the size of memory that we needed for our

559
00:21:42,600 --> 00:21:47,500
local variables and stuff, as we call deeper down into the, into the

560
00:21:47,600 --> 00:21:49,000
functions of our program.

561
00:21:49,300 --> 00:21:52,400
It's just, you know, basically allocating pages on demand as we need

562
00:21:52,400 --> 00:21:52,700
them.

563
00:21:52,800 --> 00:21:55,700
And then when we come back through it, we are just using less of the

564
00:21:55,700 --> 00:21:56,200
stack.

565
00:21:56,200 --> 00:21:58,600
So this kind of it's basically like a water level that rises and

566
00:21:58,600 --> 00:21:59,000
flows.

567
00:21:59,000 --> 00:21:59,800
And like I said, the reason

568
00:22:00,000 --> 00:22:03,700
I can do that is because there's never a need in a program to free

569
00:22:03,700 --> 00:22:05,300
something out of the middle of the stack.

570
00:22:05,500 --> 00:22:07,900
It never has to free some middle page here.

571
00:22:08,000 --> 00:22:08,200
Right?

572
00:22:08,200 --> 00:22:09,100
It doesn't have to do that.

573
00:22:09,100 --> 00:22:13,200
It's always going to free off the back because functions Nest, right?

574
00:22:13,200 --> 00:22:14,200
I call a function.

575
00:22:14,300 --> 00:22:15,800
I've got a function Foo, right?

576
00:22:15,800 --> 00:22:16,800
It calls bar.

577
00:22:17,000 --> 00:22:19,100
And then that function calls blah, right.

578
00:22:19,100 --> 00:22:20,700
So I've got three functions here.

579
00:22:20,800 --> 00:22:23,800
Well the top function, all of its local variables are going to have to

580
00:22:23,800 --> 00:22:24,700
stay in memory.

581
00:22:24,900 --> 00:22:27,500
While bar is executing and all of its are gonna have to remember while

582
00:22:27,500 --> 00:22:28,300
blahs executing.

583
00:22:28,300 --> 00:22:29,800
So until it returns back here.

584
00:22:29,900 --> 00:22:30,600
Here, right.

585
00:22:30,600 --> 00:22:33,800
You can't just free the local variables of bars, right out the middle

586
00:22:33,800 --> 00:22:35,700
because you're going to return from blot to Bar.

587
00:22:35,800 --> 00:22:38,400
It's going to access local variables, and all hell would break loose,

588
00:22:38,600 --> 00:22:39,100
right.

589
00:22:39,100 --> 00:22:43,100
So the stack always grows and shrinks from the from the top of it.

590
00:22:43,200 --> 00:22:45,200
You know, it goes bigger smaller bigger.

591
00:22:45,200 --> 00:22:46,600
It never has to free up the middle.

592
00:22:46,600 --> 00:22:50,400
So it is not what is called the Heap, which is something that can be

593
00:22:50,400 --> 00:22:53,300
freed out of the middle is not that we will talk about that later.

594
00:22:53,300 --> 00:22:56,400
It is a stack and it is a very clean data structure that lets you

595
00:22:56,400 --> 00:22:57,400
implement that cleanly.

596
00:22:57,900 --> 00:22:59,800
So, all the rest of the stuff we talked about

597
00:23:00,200 --> 00:23:03,000
So far our lives on their everything else lives on there.

598
00:23:03,000 --> 00:23:03,700
That's where it lives.

599
00:23:03,900 --> 00:23:07,700
So all this other stuff, projectile stack test everything, all of the

600
00:23:07,700 --> 00:23:10,400
functions that are all of the stuff that's passed to our function.

601
00:23:10,700 --> 00:23:13,800
Also either lives on the stack or is passed directly and CPU

602
00:23:13,800 --> 00:23:14,400
registers.

603
00:23:15,100 --> 00:23:16,700
That's just how that that works.

604
00:23:16,800 --> 00:23:19,300
So hopefully that's a pretty complete answer to where everything lives

605
00:23:19,400 --> 00:23:19,700
or at least.

606
00:23:19,700 --> 00:23:22,700
Has you thinking about the complete answer and you can go research

607
00:23:22,700 --> 00:23:24,800
couple of those things if you'd like to find out more about them,

608
00:23:25,000 --> 00:23:25,500
okay?

609
00:23:29,200 --> 00:23:30,700
Good deal.

610
00:23:32,000 --> 00:23:33,300
So off we go.

611
00:23:34,400 --> 00:23:39,100
And let's take a look at the twitch chat quickly just to make sure

612
00:23:39,100 --> 00:23:40,100
everything's going fine.

613
00:23:40,100 --> 00:23:41,600
Looks good to me.

614
00:23:41,600 --> 00:23:44,600
Everything seems everyone is talking amongst themselves.

615
00:23:44,600 --> 00:23:45,300
That is good.

616
00:23:45,500 --> 00:23:48,900
Okay, so what I wanted to cover today and this is going to be a long

617
00:23:48,900 --> 00:23:51,400
stream because we went on a long diversion and we may go on other

618
00:23:51,400 --> 00:23:51,600
ones.

619
00:23:51,600 --> 00:23:53,500
Like I said, Sunday stream is out of control.

620
00:23:53,700 --> 00:23:54,900
It's fully fully bananas.

621
00:23:56,200 --> 00:23:58,100
I wanted to talk about operators today.

622
00:23:58,800 --> 00:23:59,900
So what I wanted to do is kind.

623
00:24:00,000 --> 00:24:01,500
Talk to you about the stuff that you can do.

624
00:24:01,500 --> 00:24:07,300
Once you actually have sort of, you know, variables and stuff like we

625
00:24:07,300 --> 00:24:08,700
were declaring and you understand where they are.

626
00:24:08,700 --> 00:24:11,000
But now you want to kind of do some interesting things with them.

627
00:24:11,000 --> 00:24:14,400
Which obviously, you know, if you're making code, the whole point of

628
00:24:14,400 --> 00:24:16,700
it is to do interesting things with a memory that you've allocated.

629
00:24:16,700 --> 00:24:19,400
So I'm going to talk about operated a and I'm just going to sort of

630
00:24:19,400 --> 00:24:22,300
spam some operators out there and then we're going to talk about how

631
00:24:22,300 --> 00:24:22,600
they work.

632
00:24:22,600 --> 00:24:27,800
So first of all, there's obviously, if I have things like this, where

633
00:24:27,800 --> 00:24:29,700
I've got a bunch of variables that I've defined,

634
00:24:30,000 --> 00:24:31,400
And we all know how these work.

635
00:24:31,400 --> 00:24:32,500
Now they go on the stack.

636
00:24:32,500 --> 00:24:35,300
So these are all living on the stack and I want to start operating on

637
00:24:35,300 --> 00:24:36,000
them to do stuff.

638
00:24:36,000 --> 00:24:39,500
I have basically all of the math operators that I would normally

639
00:24:39,500 --> 00:24:44,800
expect to find - a few perhaps can be represented directly in C with

640
00:24:44,800 --> 00:24:47,500
operators so I can basically say something like.

641
00:24:47,800 --> 00:24:48,400
Okay.

642
00:24:48,400 --> 00:24:51,300
I want to make X now equal to Y plus Z, right?

643
00:24:51,300 --> 00:24:51,900
I can do that.

644
00:24:51,900 --> 00:24:53,900
I could say that I want to be y, plus, Z Plus X.

645
00:24:53,900 --> 00:24:57,000
And again, equals is not like mathematical equals.

646
00:24:57,000 --> 00:24:59,800
It's an assignment operator, which means it computes this side first.

647
00:25:00,000 --> 00:25:03,600
And then assigns it to this side again, that caused me no end of

648
00:25:03,600 --> 00:25:06,100
consternation since I learned programming before I learned to math,

649
00:25:06,400 --> 00:25:08,900
and when they started using equals to mean that both sides were

650
00:25:08,900 --> 00:25:15,500
equivalent, I had no idea was going on was horrible, but hopefully,

651
00:25:15,500 --> 00:25:18,200
you guys all can remember that difference easily enough.

652
00:25:18,200 --> 00:25:20,400
The equals in see, always means a sign.

653
00:25:20,400 --> 00:25:24,200
So it takes the right hand side, called an RH s, right hand side, and

654
00:25:24,200 --> 00:25:25,400
assigned it to the left hand side.

655
00:25:25,400 --> 00:25:27,800
LHS, and it does that assignment.

656
00:25:27,900 --> 00:25:29,600
So after this statement is done it.

657
00:25:29,900 --> 00:25:33,200
As these things and we can use all kinds of operators here.

658
00:25:33,200 --> 00:25:35,000
We can do this kind of thing.

659
00:25:35,000 --> 00:25:36,700
We can divide which is a /.

660
00:25:36,700 --> 00:25:41,200
So it uses / because there is no convenient way to make sort of a like

661
00:25:41,300 --> 00:25:45,300
actual, an actual visual like thing over another thing like you would

662
00:25:45,300 --> 00:25:47,000
see in real math notation.

663
00:25:47,000 --> 00:25:49,200
So they just use the slash to sort of make it look a little bit.

664
00:25:49,200 --> 00:25:50,200
Like why is over Z?

665
00:25:50,800 --> 00:25:52,100
We can do that sort of thing.

666
00:25:52,700 --> 00:25:56,800
We can also do - obviously, we can also do what's called a unitary -

667
00:25:56,800 --> 00:25:58,600
which means we can put a minus before something.

668
00:25:58,600 --> 00:25:59,600
And it makes it -

669
00:26:00,000 --> 00:26:03,200
Like it would in math so you can type most mathy sorts of things in

670
00:26:03,200 --> 00:26:03,600
here.

671
00:26:03,700 --> 00:26:05,800
Things that you can't do is power of.

672
00:26:05,800 --> 00:26:09,900
So, for example, if I wanted to say x to the second power that is not

673
00:26:09,900 --> 00:26:13,100
what that would mean because that is not an operation that was built

674
00:26:13,100 --> 00:26:13,800
in to see.

675
00:26:14,200 --> 00:26:14,700
Instead.

676
00:26:14,700 --> 00:26:16,300
You have to call a function to do that.

677
00:26:16,300 --> 00:26:18,600
There is a function called Powell, which will cover, maybe later

678
00:26:18,600 --> 00:26:21,100
that's in the C, runtime Library if you wanted to do that.

679
00:26:21,600 --> 00:26:23,600
But yeah, that's that's a separate issue.

680
00:26:23,900 --> 00:26:26,800
So you can put most math operators in there and they work how you

681
00:26:26,800 --> 00:26:29,300
would expect star is times.

682
00:26:29,900 --> 00:26:31,700
Instead of X because X would be a variable name.

683
00:26:31,700 --> 00:26:34,500
So they use star four times just like most computer things and they

684
00:26:34,500 --> 00:26:36,300
use / 4 divided.

685
00:26:37,000 --> 00:26:40,400
Now the thing that to that you want to remember is that much like in

686
00:26:40,400 --> 00:26:44,700
mathematics in see operators have what's called a precedence, which

687
00:26:44,700 --> 00:26:47,500
means that some operators happen before other operators.

688
00:26:48,100 --> 00:26:51,600
Now, this is not since this is exactly like how you think of them in

689
00:26:51,600 --> 00:26:51,900
math.

690
00:26:51,900 --> 00:26:52,400
Really?

691
00:26:52,600 --> 00:26:55,100
I'm not going to belabor that point at all or even show a demo, but

692
00:26:55,100 --> 00:26:55,800
I'm simply going to say.

693
00:26:55,800 --> 00:26:59,300
It works very much like you would expect multiplication binds first.

694
00:26:59,400 --> 00:26:59,800
So if I

695
00:27:00,000 --> 00:27:03,800
A x times Z and then I have a Plus on either side of it.

696
00:27:03,800 --> 00:27:07,500
No matter what it's doing the x times e will happen before the plus

697
00:27:07,500 --> 00:27:08,000
happens.

698
00:27:08,100 --> 00:27:11,800
So this the Z Plus X will not magically happen MN times.

699
00:27:11,800 --> 00:27:15,800
Z it will do the x times e first replace that with the quantity and

700
00:27:15,800 --> 00:27:18,700
then continue to compute the pluses so much like math.

701
00:27:18,800 --> 00:27:21,700
You do exactly that sort of precedents order evaluation.

702
00:27:21,700 --> 00:27:26,300
So, you know divides and and times will happen first just like they do

703
00:27:26,300 --> 00:27:27,000
in math.

704
00:27:27,100 --> 00:27:29,600
Adds and subtracts will happen s that sort of thing.

705
00:27:30,000 --> 00:27:33,100
It's not super important to remember the exact precedence rules,

706
00:27:33,300 --> 00:27:36,300
because actually the best thing to do is if you're ever unsure about

707
00:27:36,300 --> 00:27:39,000
them is just too, just like in math, use parentheses.

708
00:27:39,100 --> 00:27:43,100
So if you wanted z+ X to happen, first, put it in parentheses and you

709
00:27:43,100 --> 00:27:45,300
can always do that just like you can in math.

710
00:27:45,300 --> 00:27:49,000
Now the thing you can't do in math is infer a multiplication where

711
00:27:49,000 --> 00:27:49,800
there wasn't one.

712
00:27:49,900 --> 00:27:53,600
So I can't write that if I want a z plus x times E.

713
00:27:53,700 --> 00:27:55,600
I cannot write that it is not allowed in.

714
00:27:55,600 --> 00:27:59,600
See, you must always actually specify the operator in mathematics you

715
00:27:59,600 --> 00:27:59,800
can.

716
00:28:00,000 --> 00:28:03,100
Just put something next to something else and it means X not the case

717
00:28:03,100 --> 00:28:03,500
here.

718
00:28:03,800 --> 00:28:04,900
Same thing.

719
00:28:04,900 --> 00:28:08,900
I could not just use a space to say x times e, can't do that.

720
00:28:08,900 --> 00:28:11,500
You have to always actually say what it is.

721
00:28:11,500 --> 00:28:12,500
You actually want to do.

722
00:28:12,700 --> 00:28:16,200
Now you'll notice that I've used spacing here to creatively kind of

723
00:28:16,400 --> 00:28:19,400
show you what the operator precedence might be.

724
00:28:19,600 --> 00:28:21,300
And I find that that's a good thing to do.

725
00:28:21,400 --> 00:28:21,700
I find that?

726
00:28:21,700 --> 00:28:24,700
It's usually a pretty good thing to do to leave spaces between pluses,

727
00:28:25,200 --> 00:28:28,400
sometimes too kind of spaced out the equations and let it be clear to

728
00:28:28,400 --> 00:28:29,700
the person reading the code.

729
00:28:29,900 --> 00:28:32,300
What happens in what order or at the very least, what order you

730
00:28:32,300 --> 00:28:33,300
thought they were happening in?

731
00:28:33,300 --> 00:28:36,000
Because hey, maybe you had a bug in that code.

732
00:28:36,000 --> 00:28:38,700
It would be nice at least to see what the person thought they were

733
00:28:38,700 --> 00:28:39,500
doing and you go up.

734
00:28:39,500 --> 00:28:40,600
So that's not going to work.

735
00:28:40,600 --> 00:28:44,800
You know, for example, if I came into some code and I saw it looking

736
00:28:44,800 --> 00:28:48,500
like this, I might be like that guy didn't realize what's going to

737
00:28:48,500 --> 00:28:51,400
happen because Z times x will actually happen first, but it's pretty

738
00:28:51,400 --> 00:28:51,900
clear.

739
00:28:52,000 --> 00:28:54,500
He thought that this was going to happen, right?

740
00:28:55,400 --> 00:28:57,700
And so, you know, all of this stuff.

741
00:28:57,700 --> 00:28:59,500
Like I said, it kind of comes with practice.

742
00:28:59,500 --> 00:28:59,800
It's not

743
00:29:00,100 --> 00:29:01,900
Complicated, it's pretty easy to understand.

744
00:29:01,900 --> 00:29:03,800
I'm not going to spend a lot of time talking about that.

745
00:29:03,800 --> 00:29:07,000
I just want you to be aware of the fact that all of the stuff that's

746
00:29:07,000 --> 00:29:09,900
at play and math is also at play and see, including operator

747
00:29:09,900 --> 00:29:10,400
precedence.

748
00:29:10,400 --> 00:29:13,000
And it's a good to kind of get yourself familiar with it.

749
00:29:13,000 --> 00:29:16,000
It's really easy to look up if you want the exact rules and want to

750
00:29:16,000 --> 00:29:19,100
get yourself a little more familiar with them, but that is basically

751
00:29:19,400 --> 00:29:20,200
how that works.

752
00:29:20,600 --> 00:29:21,200
So

753
00:29:23,100 --> 00:29:28,300
Moving on to some things that are not going to be familiar to you from

754
00:29:28,300 --> 00:29:28,700
math.

755
00:29:29,500 --> 00:29:33,300
Those are mathematical operators, but there are also binary like

756
00:29:33,300 --> 00:29:36,900
bitwise operators because since we are working with memory, we

757
00:29:36,900 --> 00:29:40,000
sometimes want to do things that just have to do with the actual bits

758
00:29:40,200 --> 00:29:44,000
that are actually in the variables that we are talking about.

759
00:29:44,100 --> 00:29:48,800
And so if you remember we did a thing where we learned hexadecimal and

760
00:29:48,800 --> 00:29:51,400
I said that one of the big reasons why you use hexadecimal.

761
00:29:51,400 --> 00:29:52,600
Like, in fact, one of the only

762
00:29:52,900 --> 00:29:56,600
Reasons really that I ever use hexadecimal is because it lines up with

763
00:29:56,600 --> 00:29:57,100
binary.

764
00:29:57,300 --> 00:29:59,200
So it's every

765
00:30:00,100 --> 00:30:04,800
Every, every digit if you will in a hexadecimal number corresponds to

766
00:30:04,800 --> 00:30:09,300
4 bits, which means that you can easily see how the number breaks down

767
00:30:09,300 --> 00:30:12,300
that you couldn't, if you look the decimal, because any given thing,

768
00:30:12,500 --> 00:30:15,200
any given digit in a decimal number doesn't line up with binary at

769
00:30:15,200 --> 00:30:15,300
all.

770
00:30:15,300 --> 00:30:16,400
They're all mixed together.

771
00:30:16,400 --> 00:30:17,200
So, you look at the number.

772
00:30:17,200 --> 00:30:18,500
You're like, I have no idea, right?

773
00:30:18,500 --> 00:30:22,800
If I see 65536, I have, no, I can't break that at the six and say, oh,

774
00:30:22,800 --> 00:30:25,500
that was the bottom bit or that was the bottom three bits for

775
00:30:25,500 --> 00:30:25,900
something.

776
00:30:25,900 --> 00:30:27,900
That's not, you know, you can't do that.

777
00:30:28,300 --> 00:30:29,400
So I'm going to start to use

778
00:30:30,000 --> 00:30:33,300
here, which means you're all going to have to put on your hexadecimal

779
00:30:33,300 --> 00:30:36,500
hat to sort of show you a little bit more how this works.

780
00:30:36,500 --> 00:30:40,700
So let's say, I make something equal to 0 XA, right?

781
00:30:40,800 --> 00:30:45,900
And now, if you remember, a is the first letter after the digits in

782
00:30:45,900 --> 00:30:50,100
hexadecimal so 0 through 9 and then a, so that's 10, right?

783
00:30:50,100 --> 00:30:51,200
We're all on board with that.

784
00:30:51,200 --> 00:30:53,700
In fact, we can can just go verify that, right?

785
00:30:53,700 --> 00:30:57,600
We can look in here and the watch window and hit there and I get my 10

786
00:30:57,700 --> 00:30:59,900
right and then I can see a hexadecimal.

787
00:31:00,400 --> 00:31:01,100
There it is.

788
00:31:01,200 --> 00:31:04,600
It's 32-bit number because I said it was an ENT and there's the a

789
00:31:04,700 --> 00:31:05,200
right.

790
00:31:06,100 --> 00:31:14,800
Well, what happens if I want to start sliding the a around, it sounds

791
00:31:14,800 --> 00:31:17,000
like a weird thing to do, but I want to, you know, basically, I want

792
00:31:17,000 --> 00:31:19,000
to move bits left or right in the variable.

793
00:31:19,000 --> 00:31:20,300
I just want to shift them around.

794
00:31:21,100 --> 00:31:24,100
Well, there is a shift operator, right?

795
00:31:25,100 --> 00:31:29,100
And what the shift operator does is it basically says I want you to

796
00:31:29,200 --> 00:31:29,800
rotate you too.

797
00:31:29,900 --> 00:31:35,500
To shift the bits either to the left or the right in this number by a

798
00:31:35,500 --> 00:31:37,500
certain amount that I tell you, right?

799
00:31:37,700 --> 00:31:42,200
So I want to shift the B by say for which would be one hexadecimal

800
00:31:42,200 --> 00:31:42,800
digit, right?

801
00:31:42,800 --> 00:31:46,900
It'll move them one place to the left.

802
00:31:46,900 --> 00:31:50,000
So I go in here and I have my number, right?

803
00:31:50,200 --> 00:31:53,900
It's a, like we said, I'm going to shift it by 4 and boom.

804
00:31:54,300 --> 00:31:55,800
They moved right?

805
00:31:56,100 --> 00:31:56,700
Right to thing.

806
00:31:56,900 --> 00:31:57,300
Now.

807
00:31:57,400 --> 00:31:59,000
What if I want to do that a few more times, right?

808
00:31:59,000 --> 00:31:59,800
What if I shift it some more?

809
00:32:00,000 --> 00:32:01,700
Or we'll just shift.

810
00:32:01,700 --> 00:32:02,400
It shift it shift.

811
00:32:02,400 --> 00:32:03,100
It shift, it shift.

812
00:32:03,100 --> 00:32:03,900
It shift it.

813
00:32:04,100 --> 00:32:04,900
Let's keep on shifting.

814
00:32:04,900 --> 00:32:06,200
It by 4, right?

815
00:32:06,200 --> 00:32:07,300
So we'll watch it go.

816
00:32:07,400 --> 00:32:11,700
There's the a right goes shifts, shifts, shifts, shifts shifts.

817
00:32:11,800 --> 00:32:11,900
Now.

818
00:32:11,900 --> 00:32:18,800
The question is, what happens when I shift it and it's already at the

819
00:32:18,800 --> 00:32:19,300
end.

820
00:32:20,300 --> 00:32:24,200
Now, the answer to this is actually that it's just sees Define

821
00:32:24,200 --> 00:32:25,000
behavior.

822
00:32:25,000 --> 00:32:28,600
What actually happens when you shift this because in Hardware, there's

823
00:32:28,600 --> 00:32:30,500
actually a lot of different answers.

824
00:32:30,700 --> 00:32:34,400
There are things called Barrel shifters, which actually can do kind of

825
00:32:34,400 --> 00:32:35,000
different things.

826
00:32:35,000 --> 00:32:38,900
Like, for example, they can do what's called a rotate where it comes

827
00:32:38,900 --> 00:32:40,100
back on the other side.

828
00:32:40,100 --> 00:32:43,800
So if I were to shift out the left side, comes back on the other side,

829
00:32:43,900 --> 00:32:44,300
right?

830
00:32:45,100 --> 00:32:50,000
there are things which do shift to carry which basically shifts out

831
00:32:50,000 --> 00:32:54,000
and replaces what you shipped it out with zeros, but it sets a special

832
00:32:54,000 --> 00:32:59,000
flag on the processor that tells you whether or not there were any

833
00:32:59,000 --> 00:32:59,800
ones that got

834
00:33:00,000 --> 00:33:02,400
If the doubt and stuff like that, so there's a lot of different things

835
00:33:02,400 --> 00:33:05,500
but what happens in C and someone unfortunately because it's a bit

836
00:33:05,500 --> 00:33:07,700
limiting, but it only has this one way.

837
00:33:07,800 --> 00:33:09,600
What happens in C is it just clears?

838
00:33:09,600 --> 00:33:13,800
If I shift B out, it just goes to 0, the bits that get shifted out.

839
00:33:13,900 --> 00:33:15,400
They don't come back in anywhere.

840
00:33:15,800 --> 00:33:18,500
And so that's just how that works and you could keep on shifting and

841
00:33:18,500 --> 00:33:20,200
they ain't never going to come back in again.

842
00:33:20,200 --> 00:33:20,800
They're gone.

843
00:33:20,900 --> 00:33:21,500
Goodbye.

844
00:33:22,200 --> 00:33:26,000
And even if I tried to shift back in like they don't go out to the

845
00:33:26,000 --> 00:33:27,000
next value in memory.

846
00:33:27,000 --> 00:33:28,800
It's entirely just in that one value.

847
00:33:29,400 --> 00:33:29,900
So you can never

848
00:33:30,000 --> 00:33:34,600
Get them back again, but I can certainly intermix my shifts obviously

849
00:33:34,800 --> 00:33:36,800
with shift in the other direction, right?

850
00:33:37,200 --> 00:33:41,000
You can shift by putting in the opposite version.

851
00:33:41,000 --> 00:33:42,900
So I did two less than symbols is the shift.

852
00:33:42,900 --> 00:33:45,900
Left 2, greater than symbols is the shift, right?

853
00:33:46,300 --> 00:33:49,600
And you can see now, I can kind of do those shifts.

854
00:33:50,400 --> 00:33:52,000
Shift.

855
00:33:52,000 --> 00:33:55,100
You can see it wiggle back and forth, shifting back shifting back.

856
00:33:55,100 --> 00:33:59,800
Now, let's shift it up a few times and then shift it back down, and

857
00:33:59,800 --> 00:34:00,800
the same thing would happen.

858
00:34:00,800 --> 00:34:03,800
If I shift it out the bottom, it would get clear but zeros as well.

859
00:34:03,800 --> 00:34:04,600
So that's shifting.

860
00:34:04,600 --> 00:34:08,199
And you may think that shifting isn't particularly interesting yet,

861
00:34:08,199 --> 00:34:10,699
but you will see us do it a fair bit.

862
00:34:10,699 --> 00:34:12,600
There's a number of reasons why we might do it.

863
00:34:12,600 --> 00:34:16,199
I won't try to demo them today because what we've been sort of just

864
00:34:16,199 --> 00:34:18,000
trying to cover the low level stuff and I won't turn it.

865
00:34:18,000 --> 00:34:20,300
Try to get into the reasons why you might use it, but

866
00:34:20,500 --> 00:34:23,100
Suffice to say it's more useful than you might think and you will see

867
00:34:23,100 --> 00:34:24,300
us use it in the mainstream.

868
00:34:25,100 --> 00:34:29,600
Furthermore, in addition to, in addition to the shifting.

869
00:34:31,000 --> 00:34:31,400
Excuse me.

870
00:34:31,400 --> 00:34:32,199
I gotta get it there.

871
00:34:32,199 --> 00:34:32,800
No cat here.

872
00:34:37,600 --> 00:34:39,300
It's delicious anyway.

873
00:34:40,699 --> 00:34:43,800
So in addition to the shifting, when we're shifting these things, you

874
00:34:43,800 --> 00:34:45,300
know, shifting these things all over the place.

875
00:34:45,300 --> 00:34:46,100
You may ask.

876
00:34:46,100 --> 00:34:47,699
Well, what does that actually do with the number?

877
00:34:48,000 --> 00:34:52,600
Well, if you are a superstar which may be some of you out there are

878
00:34:53,100 --> 00:34:56,199
and you only just learned binary and hexadecimal and stuff like that

879
00:34:56,199 --> 00:35:02,100
from this stream, but somehow you have a gigantic brain and you think

880
00:35:02,100 --> 00:35:03,700
about what happens when you shift it.

881
00:35:04,200 --> 00:35:09,000
Now, what I said was every time we shift something, it basically moves

882
00:35:09,000 --> 00:35:10,300
the bits down in the

883
00:35:10,700 --> 00:35:11,600
That we shifted it.

884
00:35:11,700 --> 00:35:15,800
So if I have say one bit set at the very bottom, so I've got a number,

885
00:35:15,900 --> 00:35:16,100
right?

886
00:35:16,100 --> 00:35:18,500
And it's like, 000000 it.

887
00:35:18,500 --> 00:35:20,600
Let's say we, let's say it's a unsigned care.

888
00:35:20,700 --> 00:35:22,100
So it's only 8 Bits long.

889
00:35:22,100 --> 00:35:25,000
I've got one bit the bottom one little bit there.

890
00:35:26,100 --> 00:35:27,400
What does that represent?

891
00:35:27,500 --> 00:35:30,800
Well, we know that a 1 in that place represents a 1 and we know that a

892
00:35:30,800 --> 00:35:31,200
bit in.

893
00:35:31,200 --> 00:35:34,300
The next place would be a 2 and then a 4 and then an 8, right?

894
00:35:34,300 --> 00:35:35,400
And then 16 and so on.

895
00:35:35,900 --> 00:35:39,600
So if I'm to shift this bit, bit upwards, so if I go ahead and shift

896
00:35:39,600 --> 00:35:40,400
that to the

897
00:35:40,500 --> 00:35:41,100
At once.

898
00:35:41,400 --> 00:35:42,300
What does that do to the number?

899
00:35:42,300 --> 00:35:43,600
Well, it was one now.

900
00:35:43,600 --> 00:35:44,200
It's too.

901
00:35:44,400 --> 00:35:48,900
If I shift it up again now it's for and what I hope you can see is

902
00:35:48,900 --> 00:35:53,300
basically all that's doing is it's essentially moving up in the powers

903
00:35:53,300 --> 00:35:54,700
of two, what the number was.

904
00:35:54,800 --> 00:35:58,800
So essentially when you shift by one to the left you are multiplying

905
00:35:59,000 --> 00:35:59,700
by 2.

906
00:36:00,000 --> 00:36:03,700
When you shift to the right by 1, you are dividing by 2.

907
00:36:03,900 --> 00:36:09,800
So a shift is really just a multiply or divide by the power of two

908
00:36:09,800 --> 00:36:11,000
that you specified.

909
00:36:11,000 --> 00:36:14,000
So if I specify a one it's by 2, right?

910
00:36:14,000 --> 00:36:16,700
Its I multiply by 2 or if I was going the other way, that's a divided

911
00:36:16,700 --> 00:36:17,300
by 2.

912
00:36:17,400 --> 00:36:22,700
Right, but if I specify to to, well, that would be shifting to places,

913
00:36:22,700 --> 00:36:25,200
which is multiplying by what for right?

914
00:36:25,200 --> 00:36:28,800
Because I had something here and it went right to there in one ship so

915
00:36:28,800 --> 00:36:29,800
that was multiplying by 4.

916
00:36:30,000 --> 00:36:33,300
Or not 2 which is 2 to the 2nd, right?

917
00:36:33,800 --> 00:36:34,500
Same thing would happen.

918
00:36:34,500 --> 00:36:38,000
If I shift it by three, I'd start with one but I'd get 8 which is 2 to

919
00:36:38,000 --> 00:36:38,800
the 3rd.

920
00:36:38,900 --> 00:36:40,100
So that is a shift by 3.

921
00:36:40,200 --> 00:36:43,700
So all you're doing when you shift is just multiplying by a power of 2

922
00:36:43,700 --> 00:36:47,000
and the Power of 2 is in this place, makes sense.

923
00:36:49,600 --> 00:36:50,400
Hopefully it does.

924
00:36:51,400 --> 00:36:55,200
Okay onto more fun things.

925
00:36:55,200 --> 00:36:57,300
Although actually, let's watch it.

926
00:36:57,400 --> 00:36:58,100
Let's watch it happen.

927
00:36:58,100 --> 00:37:01,800
Ladies and gentlemen, we are in an IDE for a reason.

928
00:37:02,500 --> 00:37:04,200
Let us see in action show.

929
00:37:04,200 --> 00:37:06,400
Don't tell is the way things go.

930
00:37:07,500 --> 00:37:09,800
Here on handmade hero.

931
00:37:12,200 --> 00:37:16,500
Probably got a not have this bunch of numbers in the middle of the

932
00:37:16,500 --> 00:37:17,800
supposedly, valid code.

933
00:37:18,100 --> 00:37:20,000
Okay, we're gonna switch out a hexadecimal mode.

934
00:37:20,200 --> 00:37:20,500
There you go.

935
00:37:20,500 --> 00:37:21,100
You got 10.

936
00:37:21,200 --> 00:37:23,300
So if you shift it up, what do we expect to get 20?

937
00:37:23,900 --> 00:37:25,500
There's our 20 sets it up again.

938
00:37:25,600 --> 00:37:26,700
We would select yet 40.

939
00:37:26,900 --> 00:37:28,200
Got it 80.

940
00:37:28,300 --> 00:37:28,800
Etc.

941
00:37:28,900 --> 00:37:29,100
Right.

942
00:37:29,100 --> 00:37:31,100
Just multiplying by 2 each individual time.

943
00:37:31,300 --> 00:37:32,200
That's all that happens.

944
00:37:32,300 --> 00:37:34,300
And that's just it's sliding up the hexadecimal.

945
00:37:34,400 --> 00:37:37,700
Now if we watched it happen in the hexadecimal like we did before,

946
00:37:37,700 --> 00:37:38,700
it's still the same right.

947
00:37:38,700 --> 00:37:41,900
Just sliding up sliding up thing and so on and so,

948
00:37:42,300 --> 00:37:43,500
Anyway, oh, well.

949
00:37:43,500 --> 00:37:44,100
No, it's not.

950
00:37:44,200 --> 00:37:45,700
We change it to one now, right?

951
00:37:45,700 --> 00:37:46,800
So we're not going by 4.

952
00:37:46,800 --> 00:37:49,800
We're going by one bit, so you can actually see the hexadecimal change

953
00:37:49,800 --> 00:37:50,400
as well.

954
00:37:50,500 --> 00:37:53,200
So it takes four steps to go up.

955
00:37:53,200 --> 00:37:54,300
Just kind of cool, right?

956
00:37:54,300 --> 00:37:55,300
You can watch it go.

957
00:37:55,400 --> 00:37:57,100
It's at a right now.

958
00:37:57,100 --> 00:38:02,200
It's 14:28 50 and now it's going to be back to a again as it slides in

959
00:38:02,400 --> 00:38:05,600
to one hexadecimal digit over computers are great.

960
00:38:05,800 --> 00:38:10,200
Really, you know, how do you not just love them anyway, so that's

961
00:38:10,200 --> 00:38:12,000
basically what happens with shifting which

962
00:38:12,200 --> 00:38:15,500
One of our bitwise operators, we have other bitwise operators.

963
00:38:15,600 --> 00:38:19,800
I'm Missy x equal to 0 and I'm going to show you some other operators.

964
00:38:19,800 --> 00:38:23,400
I'm going to use the shift that I just showed you to demonstrate these

965
00:38:23,400 --> 00:38:24,000
operators.

966
00:38:25,200 --> 00:38:26,600
And so, here we go.

967
00:38:28,100 --> 00:38:30,400
I'm going to say shifted Up by 4 for that one.

968
00:38:31,000 --> 00:38:37,500
I am going to say shifted up by, let's say eight.

969
00:38:37,500 --> 00:38:43,900
But this one then I'm going to again use a shift by 4 and then I am

970
00:38:43,900 --> 00:38:47,200
going to use a shift by.

971
00:38:48,700 --> 00:38:56,100
Kate mmm, you know, we're not gonna do that one yet.

972
00:38:56,200 --> 00:38:58,600
I'm gonna do that one in a second pass because you know what?

973
00:38:58,600 --> 00:38:59,900
That one gets that one gets a

974
00:39:00,000 --> 00:39:04,700
Little bit more fun and I want to savor that.

975
00:39:04,800 --> 00:39:05,600
So let's do that.

976
00:39:06,000 --> 00:39:06,900
Okay, here we go.

977
00:39:07,300 --> 00:39:11,200
So what I have done is I have written two, more bitwise, operators or

978
00:39:11,900 --> 00:39:15,300
and and and this is the sort of pipe symbol.

979
00:39:15,300 --> 00:39:16,200
If you're familiar with that.

980
00:39:16,200 --> 00:39:20,100
It's the vertical bar on your keyboard is how you do or and the

981
00:39:20,100 --> 00:39:21,500
Ampersand is how you do.

982
00:39:21,500 --> 00:39:25,800
And so I initialized X20 and you can see it here, right?

983
00:39:26,300 --> 00:39:28,500
And then what I'm going to do, you know what it is?

984
00:39:28,500 --> 00:39:29,800
There any way to make this be by

985
00:39:30,000 --> 00:39:34,200
Binary, can I just see binary, does anyone know if that's possible?

986
00:39:34,200 --> 00:39:37,100
I would love to be able to just show you the binary here instead of

987
00:39:37,100 --> 00:39:39,600
the hexadecimal because it would be so much nicer.

988
00:39:39,800 --> 00:39:43,700
Is there some way that I can just say Visual Studio?

989
00:39:43,700 --> 00:39:45,800
Watch window binary?

990
00:39:46,500 --> 00:39:47,400
Does it happen?

991
00:39:47,900 --> 00:39:54,300
I don't know more stock exchange code Guru, using the watch window.

992
00:39:54,300 --> 00:39:59,400
Does this actually have to do binary in it?

993
00:39:59,400 --> 00:39:59,800
Of course, it

994
00:40:00,000 --> 00:40:01,200
Then Google.

995
00:40:01,500 --> 00:40:02,500
Why do you do this?

996
00:40:02,500 --> 00:40:04,900
Binary Stock Exchange.

997
00:40:05,400 --> 00:40:08,600
Do do, mmm.

998
00:40:11,600 --> 00:40:13,200
Oh, come on people.

999
00:40:13,200 --> 00:40:14,800
I'm not getting any satisfaction here.

1000
00:40:14,900 --> 00:40:18,000
All right, ladies and gentlemen, how you implement, a debugger?

1001
00:40:18,000 --> 00:40:20,500
That doesn't have an obvious way to show you binary.

1002
00:40:20,500 --> 00:40:22,600
I have no idea, but that is the way it goes.

1003
00:40:22,600 --> 00:40:25,700
I suspect there's some kind of common syntax maybe that I could do,

1004
00:40:26,800 --> 00:40:28,100
but I don't actually know.

1005
00:40:28,500 --> 00:40:29,900
So we'll try one more time.

1006
00:40:29,900 --> 00:40:32,200
Again, Sunday streamer allowed to be a Meandering.

1007
00:40:32,900 --> 00:40:34,700
I never have to do this anymore because I'm used to doing the

1008
00:40:34,700 --> 00:40:38,000
hexadecimal, but like I feel like for educational purposes, come on

1009
00:40:38,000 --> 00:40:41,200
people like, wouldn't you have that in there and and even

1010
00:40:41,400 --> 00:40:43,400
Like people who are not so familiar with it.

1011
00:40:43,400 --> 00:40:43,700
I don't know.

1012
00:40:43,700 --> 00:40:44,500
It just seems like the thing.

1013
00:40:44,500 --> 00:40:45,100
You would have.

1014
00:40:45,400 --> 00:40:51,800
Let's say, watch window comma syntax visual studio and roll the dice.

1015
00:40:52,900 --> 00:40:58,100
Can you say the C D and H?

1016
00:40:58,100 --> 00:40:58,900
4 hexadecimal?

1017
00:40:58,900 --> 00:40:59,700
Maybe the isn't there?

1018
00:40:59,700 --> 00:41:03,600
Like, you know how to watch an expression in the debugger.

1019
00:41:03,800 --> 00:41:04,300
Come on.

1020
00:41:04,300 --> 00:41:04,600
Come on.

1021
00:41:04,600 --> 00:41:05,300
Msdn.

1022
00:41:05,400 --> 00:41:06,300
Hook us up here.

1023
00:41:06,400 --> 00:41:10,200
This is a high quality stream and we want we want your help.

1024
00:41:11,700 --> 00:41:12,400
Let's see.

1025
00:41:12,900 --> 00:41:17,400
Did you do most valid language expressions used context operators

1026
00:41:18,100 --> 00:41:18,800
access control?

1027
00:41:18,800 --> 00:41:21,600
And because I'm going to my services in here conductors, numeric

1028
00:41:21,600 --> 00:41:22,500
constants?

1029
00:41:25,200 --> 00:41:25,700
Okay.

1030
00:41:25,700 --> 00:41:26,300
Okay.

1031
00:41:26,400 --> 00:41:27,200
Can we do it?

1032
00:41:27,700 --> 00:41:29,300
No, we can't.

1033
00:41:30,400 --> 00:41:34,100
You can prefix or suffix symbols represent numbers in another base,

1034
00:41:34,100 --> 00:41:36,400
but it looks like you can actually do it stream.

1035
00:41:36,400 --> 00:41:37,300
Am I right?

1036
00:41:38,400 --> 00:41:39,200
Let's see.

1037
00:41:39,800 --> 00:41:41,400
Printf percent be in value.

1038
00:41:41,400 --> 00:41:43,000
You can just use Pro mode and calc.

1039
00:41:43,000 --> 00:41:43,800
Yeah, I know I can use calc.

1040
00:41:43,800 --> 00:41:45,400
I want it in the actual to butter though.

1041
00:41:46,300 --> 00:41:47,400
That's not looking good.

1042
00:41:47,500 --> 00:41:49,800
Even the stream, if the stream doesn't know you probably can't do it.

1043
00:41:49,800 --> 00:41:50,600
So, all right.

1044
00:41:51,300 --> 00:41:54,300
All right, we'll have to just do it the translation ourself.

1045
00:41:54,300 --> 00:41:54,900
But anyway.

1046
00:41:56,000 --> 00:41:59,400
So what we're going to do here is we're going to try and look at this.

1047
00:42:00,000 --> 00:42:01,000
Just using it in.

1048
00:42:01,200 --> 00:42:01,900
Well, you know what?

1049
00:42:01,900 --> 00:42:04,400
Here's what I'll do since I, in fact, I already kind of did it.

1050
00:42:04,400 --> 00:42:06,400
I lined them with hexadecimal digits.

1051
00:42:06,600 --> 00:42:10,500
So we should just see ones appear almost as if it was binary because I

1052
00:42:10,500 --> 00:42:11,400
line them that way being with.

1053
00:42:11,400 --> 00:42:13,800
So this will this will be as good as we're gonna get.

1054
00:42:13,800 --> 00:42:17,000
I guess what, the or operator does which is the first operator.

1055
00:42:17,000 --> 00:42:17,700
I want to show you?

1056
00:42:17,700 --> 00:42:25,100
Is it basically sets bits in the value if either of its two operands

1057
00:42:25,100 --> 00:42:26,500
happen to have that bit set.

1058
00:42:28,700 --> 00:42:33,000
It's saying set this set, the B, if either of the two inputs are true,

1059
00:42:33,100 --> 00:42:34,700
so I have X, which is 0.

1060
00:42:34,800 --> 00:42:39,400
So, no bits are set in X and I have one shifted up for which means

1061
00:42:39,400 --> 00:42:41,900
there's a 1 in the fourth bit of this one.

1062
00:42:42,100 --> 00:42:46,100
So when I or these two together, I should just get that one bit set,

1063
00:42:46,100 --> 00:42:49,200
which is the one shifted up for and I step and see there.

1064
00:42:49,200 --> 00:42:49,600
It is.

1065
00:42:49,700 --> 00:42:50,200
Right.

1066
00:42:50,200 --> 00:42:51,600
So it's for the two of them.

1067
00:42:52,000 --> 00:42:55,600
Now, what I'm going to do is I'm going to or again with one shifted up

1068
00:42:55,600 --> 00:42:55,900
eight.

1069
00:42:55,900 --> 00:42:57,300
So that's a one in this place.

1070
00:42:57,300 --> 00:42:58,300
So I'm going to order these.

1071
00:42:58,500 --> 00:42:58,800
Gather it.

1072
00:42:58,800 --> 00:43:02,300
So, what I'm going to do is we'll keep the X, which is set.

1073
00:43:02,400 --> 00:43:05,600
It'll keep that bit set and it'll set the next bit as well.

1074
00:43:06,100 --> 00:43:06,600
Right?

1075
00:43:06,600 --> 00:43:07,900
And now, you can see there's two ones.

1076
00:43:07,900 --> 00:43:09,000
They both got set.

1077
00:43:09,700 --> 00:43:13,300
So, or basically is just combines all of the set B.

1078
00:43:13,600 --> 00:43:18,700
NE B that is set in either of its two operands, it sets in the result.

1079
00:43:18,800 --> 00:43:21,300
So it's just, it's a way of combining things together.

1080
00:43:21,300 --> 00:43:22,100
It's an or

1081
00:43:23,100 --> 00:43:28,800
This or this now end does sort of the the I don't know what the

1082
00:43:28,800 --> 00:43:31,500
correct set theory Terminus for the operation, you know, the inverse

1083
00:43:31,500 --> 00:43:35,300
the contrapositive of whatever it basically does a similar operation,

1084
00:43:35,300 --> 00:43:39,700
but instead of setting the result when either of its operands have a

1085
00:43:39,700 --> 00:43:44,100
bit set, it requires both of them to have that bit set.

1086
00:43:44,100 --> 00:43:47,100
So I've got this coming in as x 2 B that here.

1087
00:43:47,600 --> 00:43:51,800
But the thing I'm adding it with only has this one bit set the for a

1088
00:43:51,800 --> 00:43:52,500
bit set.

1089
00:43:53,000 --> 00:43:57,700
So when I add them together, it essentially clears out that other bit

1090
00:43:57,700 --> 00:43:59,700
that we set the one shifted up by 8.

1091
00:43:59,800 --> 00:44:01,700
That one gets knocked out by the.

1092
00:44:01,700 --> 00:44:06,500
And so and is often used to do what's called masking, which is to say,

1093
00:44:06,500 --> 00:44:11,800
I have some bit pattern and I want to remove all the other bits from

1094
00:44:11,800 --> 00:44:15,100
some value, and just leave the ones that were set in these positions,

1095
00:44:15,100 --> 00:44:15,500
right?

1096
00:44:15,600 --> 00:44:18,000
So you could imagine me doing something like that.

1097
00:44:18,000 --> 00:44:22,400
Where I said, okay, I've got some value that is full banana cakes,

1098
00:44:22,400 --> 00:44:22,700
right?

1099
00:44:22,800 --> 00:44:25,900
Let's say I set a bunch of bits in here.

1100
00:44:26,400 --> 00:44:29,800
Okay, so I set the three bit.

1101
00:44:29,800 --> 00:44:32,000
I set the 14-bit.

1102
00:44:32,000 --> 00:44:33,500
I set the 19 bit.

1103
00:44:33,600 --> 00:44:35,100
I set the 23rd bit.

1104
00:44:35,200 --> 00:44:36,700
I set the 30th bit.

1105
00:44:37,000 --> 00:44:39,800
I set the first bit and I still set the 8-Bit.

1106
00:44:39,800 --> 00:44:41,700
So I just said a ton of bits, right?

1107
00:44:41,700 --> 00:44:48,300
But now I want to know, I just want to see basically what bit whether

1108
00:44:48,300 --> 00:44:52,500
the bits were set in the fourth position or the third.

1109
00:44:53,000 --> 00:44:54,000
Those are the only B i--.

1110
00:44:54,100 --> 00:44:55,900
Well, that's big little bit or the 30th.

1111
00:44:55,900 --> 00:44:58,500
I want to see if either of those two bits per set, right?

1112
00:45:00,400 --> 00:45:00,600
Thank you.

1113
00:45:00,600 --> 00:45:01,000
Mr.

1114
00:45:01,000 --> 00:45:02,000
31st bit.

1115
00:45:02,200 --> 00:45:05,000
All right, and so I'll sign those two separate variables so we can

1116
00:45:05,000 --> 00:45:05,700
look at them ahead of time.

1117
00:45:05,700 --> 00:45:07,300
So that's our mask.

1118
00:45:07,300 --> 00:45:13,400
Basically, our mask is the fourth bit and the 31st bit are set in y

1119
00:45:13,700 --> 00:45:17,900
and then we set all these other ones 4314, 1923 30 18.

1120
00:45:18,000 --> 00:45:20,000
And now we just want to see what B.

1121
00:45:20,000 --> 00:45:21,800
They have set in common.

1122
00:45:22,200 --> 00:45:24,300
That is what the and operator will do for us.

1123
00:45:24,400 --> 00:45:25,500
So we go in here.

1124
00:45:26,300 --> 00:45:27,000
Look at X.

1125
00:45:27,300 --> 00:45:28,200
We'll look at why.

1126
00:45:29,100 --> 00:45:32,000
And we go through set B setting bit setting B.

1127
00:45:32,000 --> 00:45:32,900
Look at them all fill in.

1128
00:45:32,900 --> 00:45:36,100
They're all filling in our X is full of bits, ladies and gentlemen,

1129
00:45:36,600 --> 00:45:39,500
and now we're going to set our Mass, which is why and the, why only

1130
00:45:39,500 --> 00:45:43,900
has two bits that it's got that that top bit the 31st bit set the very

1131
00:45:43,900 --> 00:45:49,100
last bit in the value and it's got the, the fourth bit set.

1132
00:45:49,100 --> 00:45:50,000
So that one right there.

1133
00:45:50,000 --> 00:45:52,900
And now we and them together and Bam, right?

1134
00:45:52,900 --> 00:45:55,900
We get back, just that for bit because that was the

1135
00:45:56,100 --> 00:45:57,500
Only bit that they had in common.

1136
00:45:57,500 --> 00:46:02,400
You can see that there's the 4-bit, there's the for bit and this 31st

1137
00:46:02,400 --> 00:46:03,900
bit never appeared in here.

1138
00:46:03,900 --> 00:46:06,500
It was never set so it isn't set in the result.

1139
00:46:06,500 --> 00:46:06,900
Right?

1140
00:46:07,000 --> 00:46:10,100
So that is basically what we mean when programmers say, we're masking

1141
00:46:10,100 --> 00:46:12,700
we mask out of value because you sort of have a mask, what you would

1142
00:46:12,700 --> 00:46:13,500
put on your face.

1143
00:46:14,100 --> 00:46:16,900
That only shows a little bit through, right?

1144
00:46:16,900 --> 00:46:17,600
That makes sense.

1145
00:46:17,700 --> 00:46:18,400
Hopefully, that's clear.

1146
00:46:18,400 --> 00:46:18,800
What's happening?

1147
00:46:18,800 --> 00:46:19,100
There.

1148
00:46:22,600 --> 00:46:27,700
Or in and are the very most frequently used bitwise operators in C.

1149
00:46:27,700 --> 00:46:28,900
At least when I'm programming.

1150
00:46:29,900 --> 00:46:30,400
Those are ones.

1151
00:46:30,400 --> 00:46:36,300
I use most often, but there is another bitwise, operator one a

1152
00:46:36,300 --> 00:46:36,900
bitwise.

1153
00:46:37,700 --> 00:46:38,000
Yeah.

1154
00:46:38,100 --> 00:46:40,400
Well, there's two more actually will show you what they are.

1155
00:46:41,100 --> 00:46:44,300
So one more bitwise operator that's that's fairly easy to understand

1156
00:46:44,400 --> 00:46:48,900
is the not operator basically bitwise.

1157
00:46:48,900 --> 00:46:50,500
Not it's a little tilde.

1158
00:46:50,900 --> 00:46:52,300
It's kind of like when you put a negative in front.

1159
00:46:52,400 --> 00:46:54,000
Something it changes the value of that.

1160
00:46:54,000 --> 00:46:58,500
Something, in the expression tilde, in front of something means take

1161
00:46:58,500 --> 00:47:01,200
all the bits that were 0 and turn them into one and turn, all the ones

1162
00:47:01,200 --> 00:47:01,800
in 2008.

1163
00:47:01,900 --> 00:47:04,300
Inverts the value, right?

1164
00:47:04,300 --> 00:47:06,100
So basically, if I run in here.

1165
00:47:07,800 --> 00:47:09,500
Hello, what did I say?

1166
00:47:09,500 --> 00:47:10,200
Oh, I had a warning.

1167
00:47:10,200 --> 00:47:11,000
What was my warning?

1168
00:47:11,000 --> 00:47:11,500
Just Wyatt?

1169
00:47:11,500 --> 00:47:12,900
Just that something isn't used.

1170
00:47:13,000 --> 00:47:14,700
I like to be aware when I have mornings.

1171
00:47:15,700 --> 00:47:16,700
Yeah, just one reference variables.

1172
00:47:16,700 --> 00:47:17,300
That's fine.

1173
00:47:17,300 --> 00:47:18,600
I don't care if I'm nervous.

1174
00:47:18,600 --> 00:47:22,200
All right, so I got nothing set in x.

1175
00:47:22,300 --> 00:47:24,300
Yes, I do the inversion operator out.

1176
00:47:24,300 --> 00:47:26,800
The did not operator and all the bits are now set.

1177
00:47:26,800 --> 00:47:27,100
Every.

1178
00:47:27,100 --> 00:47:27,900
Last thing is set.

1179
00:47:28,000 --> 00:47:29,500
It's the maximum possible thing.

1180
00:47:29,600 --> 00:47:30,200
Right?

1181
00:47:30,800 --> 00:47:33,700
And and that is basically Works no matter what you do.

1182
00:47:33,700 --> 00:47:37,400
So if I make X be some combination of bits, right?

1183
00:47:38,400 --> 00:47:44,600
I do say a couple bits set here to do.

1184
00:47:48,100 --> 00:47:53,300
Oops, ladies and gentlemen, so I go in here and I set some bits, I now

1185
00:47:53,300 --> 00:47:54,500
have some bit set.

1186
00:47:54,500 --> 00:47:57,500
I do the inversion and it gives me exactly the opposite.

1187
00:47:57,500 --> 00:47:59,800
Everything that was set is now not set.

1188
00:48:00,000 --> 00:48:02,800
Damn, it is isn't and now someone brought this up in the chat.

1189
00:48:02,800 --> 00:48:05,000
It's a good thing to remember, too.

1190
00:48:05,000 --> 00:48:07,900
If you're struggling with these little bit, it is true that if you

1191
00:48:07,900 --> 00:48:08,900
load calc, right?

1192
00:48:08,900 --> 00:48:12,300
So if you go in here and you just type calc, you'll get this

1193
00:48:12,300 --> 00:48:13,200
calculator thing.

1194
00:48:14,300 --> 00:48:16,600
Basically that's built into windows inside.

1195
00:48:16,600 --> 00:48:20,600
There's a view that can turn to programmer mode and there's these

1196
00:48:20,600 --> 00:48:24,700
things that you can set hexadecimal decimal octal, binary, right?

1197
00:48:24,900 --> 00:48:28,200
So, if you set it to hexadecimal, I believe this will work, you can

1198
00:48:28,200 --> 00:48:29,900
cut and paste just

1199
00:48:30,000 --> 00:48:33,100
Just not the 0x part, but just the just the part that you want to see,

1200
00:48:33,100 --> 00:48:37,300
you can paste that in there and then it will show you the binary down

1201
00:48:37,300 --> 00:48:38,100
here, right?

1202
00:48:38,100 --> 00:48:43,100
You can sort of see 1 1 1 1 0 1 1 1 1 0 1, 1 1 right and you can see

1203
00:48:43,100 --> 00:48:46,300
this the inverse the exact inverse so you don't have to translate that

1204
00:48:46,300 --> 00:48:47,200
in your head.

1205
00:48:47,200 --> 00:48:48,000
You can do it here.

1206
00:48:48,000 --> 00:48:50,100
We you'd want to do that in the debugger.

1207
00:48:50,200 --> 00:48:51,400
That's where it should be.

1208
00:48:51,600 --> 00:48:55,100
But it for the meat, you know, it's the poor man's way of having a

1209
00:48:55,100 --> 00:48:57,100
debugger that actually works at all.

1210
00:48:57,200 --> 00:48:57,600
Okay.

1211
00:48:57,900 --> 00:48:58,700
Alright, so there you go.

1212
00:49:00,100 --> 00:49:04,800
So that is the not operated, the binary not and basically it turns B

1213
00:49:04,800 --> 00:49:08,300
to what they're not, hence the name, but there's one more operator.

1214
00:49:08,300 --> 00:49:10,000
And this one is a doozy.

1215
00:49:10,000 --> 00:49:12,700
I do not expect people to understand this one right away because it's

1216
00:49:12,700 --> 00:49:14,000
just a little confusing.

1217
00:49:14,400 --> 00:49:18,500
It is no different than or, and it's exactly the same conceptually,

1218
00:49:19,400 --> 00:49:22,800
but it's just a little bit harder for people to get because or an and

1219
00:49:22,800 --> 00:49:26,900
a very logical it's like is this for this set in and is like, is this

1220
00:49:26,900 --> 00:49:29,700
and this set it's very easy to kind of understand what those do.

1221
00:49:30,200 --> 00:49:35,100
It's called exclusive or and what exclusive or it does is exclusive or

1222
00:49:35,100 --> 00:49:36,400
if I have two variables.

1223
00:49:36,400 --> 00:49:41,200
So let's say I have this where I've got one shifted up for and I've

1224
00:49:41,200 --> 00:49:43,100
got Y is one shifted up eight.

1225
00:49:43,300 --> 00:49:43,800
Right?

1226
00:49:44,200 --> 00:49:48,600
And what I want to do is I want to do exclusive or of these two

1227
00:49:49,100 --> 00:49:49,600
values.

1228
00:49:49,600 --> 00:49:53,600
In fact, let's make this a little bit more interesting by setting a

1229
00:49:53,600 --> 00:49:56,100
few just a few more bits.

1230
00:49:58,200 --> 00:49:59,100
Do do do.

1231
00:50:00,800 --> 00:50:01,300
There we go.

1232
00:50:02,000 --> 00:50:02,500
All right.

1233
00:50:06,100 --> 00:50:09,900
Okay, so I've got some bits that now, you can see I've got two bits

1234
00:50:09,900 --> 00:50:13,800
set in x + 2, B 7 Y and only one of the bits lines up.

1235
00:50:13,800 --> 00:50:17,700
So if we were to do an and on this, right, we would expect to just get

1236
00:50:18,000 --> 00:50:19,800
the 8-Bit because both of them have 8.

1237
00:50:19,800 --> 00:50:22,600
So the things that they both have in common, we starting to get if we

1238
00:50:22,600 --> 00:50:24,800
were to do an or we were expecting to have all of these write.

1239
00:50:24,800 --> 00:50:26,600
The result would have the four bits set.

1240
00:50:26,600 --> 00:50:28,800
The 8-Bit set and the 16 bits that right.

1241
00:50:29,300 --> 00:50:32,400
Well, what exclusive or it does is it does something similar to the or

1242
00:50:32,400 --> 00:50:35,500
operation meaning that if either of the B is set?

1243
00:50:35,800 --> 00:50:40,800
It will the result will have it set but if both of the bits are set,

1244
00:50:41,100 --> 00:50:42,100
then it won't be.

1245
00:50:42,300 --> 00:50:46,200
So it's exactly the same as an or except for the one case which is

1246
00:50:46,200 --> 00:50:48,500
when both bits are set and that goes to 0.

1247
00:50:48,800 --> 00:50:53,100
So the reason it's called exclusive or is because it's set to or it's

1248
00:50:53,100 --> 00:50:56,600
exclusively and or it excludes the case where they're both set.

1249
00:50:56,600 --> 00:50:57,900
It's only the aura case.

1250
00:50:58,000 --> 00:50:59,800
It's never the and case you can't.

1251
00:51:00,000 --> 00:51:02,800
It when there and you could only do it when they're or and that's

1252
00:51:02,800 --> 00:51:03,800
exclusive or so.

1253
00:51:03,800 --> 00:51:06,300
When I run this, what do we expect to see right?

1254
00:51:06,300 --> 00:51:10,800
We expect to see that eight get cleared out, right?

1255
00:51:12,200 --> 00:51:12,800
And it is.

1256
00:51:13,000 --> 00:51:16,500
So the result has the bit set where they were where each of them had a

1257
00:51:16,500 --> 00:51:16,800
bit set.

1258
00:51:16,800 --> 00:51:19,800
But the other one didn't but the one where they both had it, set got

1259
00:51:19,800 --> 00:51:22,900
cleared and I realize that's just a weird thing to think of

1260
00:51:22,900 --> 00:51:26,500
conceptually, but it is something that happens in in programming.

1261
00:51:26,500 --> 00:51:30,200
It's just another tool you can use to achieve results that you want.

1262
00:51:32,300 --> 00:51:34,700
So it's something to be aware of and it is built into the language.

1263
00:51:34,800 --> 00:51:39,600
Now, the thing that's interesting about X or is that it's kind of

1264
00:51:39,600 --> 00:51:42,300
symmetric in a weird way.

1265
00:51:42,400 --> 00:51:43,400
So, for example,

1266
00:51:44,500 --> 00:51:47,700
If I was to do this twice, sorry, some things here.

1267
00:51:48,400 --> 00:51:49,900
So let's say I ex or something.

1268
00:51:51,500 --> 00:51:54,500
Where I xor m xor x with Y, right?

1269
00:51:54,600 --> 00:51:56,800
So, I get the thing that I said before, it cleared out that bit.

1270
00:51:56,900 --> 00:51:58,900
But now I X or x with Y again.

1271
00:51:59,200 --> 00:52:01,400
And what you'll notice is, I got ex back.

1272
00:52:02,200 --> 00:52:07,300
So one of the most common things that xor is used to do is in things

1273
00:52:07,300 --> 00:52:10,900
where you want to be able to invert what you did because it's an

1274
00:52:10,900 --> 00:52:13,500
operation that inverts properly.

1275
00:52:13,500 --> 00:52:14,100
If I exit.

1276
00:52:14,400 --> 00:52:16,100
Or something, with something in the next road.

1277
00:52:16,100 --> 00:52:16,900
Again, with the same thing.

1278
00:52:16,900 --> 00:52:18,800
I get the original value back.

1279
00:52:19,100 --> 00:52:22,800
Things like cryptography, tend to use this because you can X or values

1280
00:52:22,800 --> 00:52:26,700
together in ways that are invertible fact, really bad.

1281
00:52:26,700 --> 00:52:31,200
Cryptography is basically just xoring things with some key, right?

1282
00:52:31,200 --> 00:52:34,500
It's just like X or the the data that I'm trying to quote unquote

1283
00:52:34,500 --> 00:52:39,100
encrypt with some key and then when I want to decrypt it, I just X or

1284
00:52:39,100 --> 00:52:42,800
it with the same key again, and I believe like it was Microsoft Excel.

1285
00:52:43,300 --> 00:52:44,100
It's encrypted.

1286
00:52:44,200 --> 00:52:45,700
Stood file format for a while.

1287
00:52:45,700 --> 00:52:48,900
In the old days was just X or it was like we explored with something

1288
00:52:49,700 --> 00:52:52,800
the times have changed, we don't do that anymore, but that, that was

1289
00:52:53,700 --> 00:52:58,700
That was something anyway, so that's X or and that pretty much wraps

1290
00:52:58,700 --> 00:53:01,400
up The bitwise Operators that I wanted to cover.

1291
00:53:01,900 --> 00:53:07,100
So that again you have for you have and you have exclusive or and you

1292
00:53:07,100 --> 00:53:11,500
have not and between those you can do quite a bit of damage.

1293
00:53:11,500 --> 00:53:14,200
Ladies and gentlemen, that's that's quite a lot of bitwise operators

1294
00:53:14,200 --> 00:53:17,000
you can do and we'll be seeing those in the Stream.

1295
00:53:17,000 --> 00:53:21,200
You will not have to wait long to see me use those I suspect so you

1296
00:53:21,200 --> 00:53:23,200
will get to see how those are in.

1297
00:53:23,500 --> 00:53:28,700
Action basically, anyway, so let's move on to some other operators

1298
00:53:28,900 --> 00:53:29,300
there.

1299
00:53:29,300 --> 00:53:32,400
In addition to bitwise logical operators.

1300
00:53:32,400 --> 00:53:34,700
They're called logical because they're like, or or and like, it's

1301
00:53:34,700 --> 00:53:37,800
like, kind of like, logic doing logic circuitry, right?

1302
00:53:37,900 --> 00:53:42,400
There are, what are called straightforward, logical operators.

1303
00:53:42,400 --> 00:53:44,800
Just just, I think they're just called the regular logical operators.

1304
00:53:45,000 --> 00:53:47,000
So, there's bitwise operators and logical operators.

1305
00:53:47,000 --> 00:53:48,100
I think are the typical ways.

1306
00:53:48,100 --> 00:53:52,300
They're called one of the problems with teaching C-Class after you've

1307
00:53:52,300 --> 00:53:53,300
known C4.

1308
00:53:53,500 --> 00:53:54,400
Don't even know when I learned it.

1309
00:53:54,400 --> 00:53:58,700
But many multiple decades is, you forget the proper names for a lot of

1310
00:53:58,700 --> 00:53:59,900
things because it's, like, I don't,

1311
00:54:00,100 --> 00:54:01,800
It's just the thing that I use.

1312
00:54:01,800 --> 00:54:06,000
I've never been a particularly High falutin programmer, who reads

1313
00:54:06,000 --> 00:54:09,100
like, you know, Lambda the ultimate or something.

1314
00:54:09,300 --> 00:54:12,200
So, I'm not the kind of guy who's like all about the nomenclature.

1315
00:54:12,200 --> 00:54:12,800
It's like what?

1316
00:54:12,800 --> 00:54:13,500
You don't know.

1317
00:54:13,500 --> 00:54:14,400
That's the set theory.

1318
00:54:14,400 --> 00:54:18,200
The Third Way of representing the logical set theory, operation of

1319
00:54:18,200 --> 00:54:23,100
closure division, ring, / the thing produces stuff and it's like, no I

1320
00:54:23,100 --> 00:54:24,800
don't, I have absolutely no idea.

1321
00:54:24,800 --> 00:54:29,900
I would love to know but I don't know anyway, so there is also

1322
00:54:30,000 --> 00:54:35,600
So operators, you can use that deal with whether values are 0 or not,

1323
00:54:36,900 --> 00:54:40,200
and I wanted to cover these first because I was going to talk about

1324
00:54:40,200 --> 00:54:44,300
conditionals and conditionals are things, basically, where you can

1325
00:54:44,700 --> 00:54:47,700
change what code is executed based on the values of things and that is

1326
00:54:47,700 --> 00:54:49,900
obviously a very fundamental thing that you have to do in programming.

1327
00:54:50,200 --> 00:54:53,100
It is how the basis of all control flow which is the thing we're gonna

1328
00:54:53,100 --> 00:54:53,600
look at next.

1329
00:54:53,600 --> 00:54:56,700
But in order to understand how any of that works, you have to first be

1330
00:54:56,700 --> 00:54:59,900
able to compute something you can use for a control flow and that is

1331
00:55:00,000 --> 00:55:01,400
These logical operators come in.

1332
00:55:05,600 --> 00:55:07,400
So, if I have a value?

1333
00:55:09,400 --> 00:55:10,400
I'm going to talk about this.

1334
00:55:13,400 --> 00:55:14,600
I've defined three things here.

1335
00:55:15,700 --> 00:55:17,900
And what I want you to think about is each of these things.

1336
00:55:17,900 --> 00:55:20,900
If actually know what I'm gonna, I'm gonna get totally wild here.

1337
00:55:21,200 --> 00:55:23,600
Just full-on, even though I haven't talked about two's complement or

1338
00:55:23,600 --> 00:55:24,100
anything.

1339
00:55:24,300 --> 00:55:28,100
I'm going to Define for things and when we gummy - I like that, that's

1340
00:55:28,100 --> 00:55:28,600
right.

1341
00:55:28,600 --> 00:55:29,200
I did it.

1342
00:55:29,400 --> 00:55:30,300
I put a negative in there.

1343
00:55:31,700 --> 00:55:34,400
So I defined for things and when I want you to think about right now

1344
00:55:35,000 --> 00:55:39,200
is what each of these has as a Boolean value meaning, I'm going to

1345
00:55:39,200 --> 00:55:44,600
talk about a Boolean value which means is something true or false.

1346
00:55:45,300 --> 00:55:49,700
I need to bake things down into whether something is basically true or

1347
00:55:49,700 --> 00:55:51,800
false on or off.

1348
00:55:51,900 --> 00:55:56,600
Let's say, you know, is it set or not?

1349
00:55:56,600 --> 00:55:58,900
Whatever, however, you want to look at it, but it's basically I'm

1350
00:55:58,900 --> 00:56:00,900
going to boil things down into two categories.

1351
00:56:01,400 --> 00:56:02,900
And only two.

1352
00:56:03,600 --> 00:56:07,900
And the way that see makes this distinction for variables and we'll

1353
00:56:07,900 --> 00:56:11,100
see kind of why it does this in a second.

1354
00:56:11,100 --> 00:56:15,500
But the way that it makes this distinction is by saying, if something

1355
00:56:15,500 --> 00:56:17,600
is 0, it is false.

1356
00:56:17,900 --> 00:56:19,400
It is not true.

1357
00:56:19,500 --> 00:56:21,500
It is not set.

1358
00:56:21,700 --> 00:56:22,600
It is whatever.

1359
00:56:22,600 --> 00:56:23,600
However, you want to look at it.

1360
00:56:23,600 --> 00:56:29,000
It is the not thing and if something is 1, then it is true, right?

1361
00:56:29,000 --> 00:56:31,100
It is set it, is it?

1362
00:56:31,200 --> 00:56:32,200
It has a value.

1363
00:56:32,200 --> 00:56:32,500
It is.

1364
00:56:32,500 --> 00:56:33,200
It is the thing?

1365
00:56:34,400 --> 00:56:40,100
So what C defines are a set of operators that can produce these things

1366
00:56:40,100 --> 00:56:43,400
for you as well, that can that can use this sort of thing.

1367
00:56:43,400 --> 00:56:46,600
And this trueness happens for anything.

1368
00:56:46,600 --> 00:56:47,600
That is not 0.

1369
00:56:47,700 --> 00:56:49,700
It doesn't matter if the number is negative, doesn't matter.

1370
00:56:49,700 --> 00:56:50,900
If the number is huge.

1371
00:56:51,000 --> 00:56:54,100
It is simply matters that it is not zero.

1372
00:56:54,200 --> 00:56:59,800
So basically what happens is in see things are either zero or they are

1373
00:57:00,500 --> 00:57:04,200
And that is how it thinks about Boolean asst.

1374
00:57:04,600 --> 00:57:07,800
So when we get into things, like, if statements and conditionals,

1375
00:57:07,800 --> 00:57:14,700
those sorts of things, that is really the property of of, of an, if of

1376
00:57:14,700 --> 00:57:18,200
a true or false, is it 0 or is it not 0?

1377
00:57:18,900 --> 00:57:22,600
So C gives you operators that can produce these values out of things

1378
00:57:22,600 --> 00:57:23,500
that you want.

1379
00:57:23,500 --> 00:57:28,100
So for example, I may want to know for, let's say, I'm going to call

1380
00:57:28,800 --> 00:57:29,500
like a

1381
00:57:30,300 --> 00:57:31,000
I'll just do.

1382
00:57:32,100 --> 00:57:37,800
I'll do less stable, do less than x is less than y, right.

1383
00:57:37,900 --> 00:57:44,200
I'm going to compute that X is greater than y x is equal to Y.

1384
00:57:44,900 --> 00:57:47,400
Okay, and I'm going to put these in parentheses because I like to be

1385
00:57:47,400 --> 00:57:53,800
very clear about sort of how things are computed order wise, not equal

1386
00:57:53,800 --> 00:57:54,200
to Y.

1387
00:57:54,800 --> 00:57:59,200
So now we've got a bunch of comparisons here and we will see how they

1388
00:57:59,200 --> 00:57:59,600
work.

1389
00:58:00,800 --> 00:58:05,300
Okay, so obviously between x and y, x is 0, Y is 1, right.

1390
00:58:05,500 --> 00:58:09,600
So if I start comparing these values, if I compare them to each other,

1391
00:58:10,300 --> 00:58:13,100
what see will do is it will do exactly what you would have done in

1392
00:58:13,100 --> 00:58:13,300
math.

1393
00:58:13,300 --> 00:58:16,400
It'll do the mathematical comparison is greater than thing.

1394
00:58:16,400 --> 00:58:19,200
This is how they do equals to K naught so that you don't confuse it

1395
00:58:19,200 --> 00:58:20,000
with assignment.

1396
00:58:20,000 --> 00:58:24,300
They put 2 equals to see if values are the same and they put a knot in

1397
00:58:24,300 --> 00:58:26,000
n equals to see if they're not the same.

1398
00:58:26,300 --> 00:58:29,200
See will do the comparison between, whatever the values are, doesn't

1399
00:58:29,200 --> 00:58:30,000
matter what they are.

1400
00:58:30,600 --> 00:58:34,700
Whatever integer values they are and it will put a 0 here if it is not

1401
00:58:34,700 --> 00:58:41,300
true and it will put a nonzero value but not necessarily one if they

1402
00:58:41,500 --> 00:58:42,200
if it is true.

1403
00:58:42,900 --> 00:58:51,100
So we go down here and we compute less do less greater equal not equal

1404
00:58:52,000 --> 00:58:56,300
rights groups, not equal spelling so you can see we did the

1405
00:58:56,300 --> 00:59:00,400
combination of less and it gave us a 1 which is what we expected.

1406
00:59:00,500 --> 00:59:01,300
Because it is less.

1407
00:59:01,400 --> 00:59:04,000
We computed the value of Greater it gave us a 0, which is what we

1408
00:59:04,000 --> 00:59:06,300
expected because it is not excess, not greater.

1409
00:59:06,600 --> 00:59:08,600
We check for equal also, not true.

1410
00:59:08,700 --> 00:59:10,600
We check for not equal and it is true.

1411
00:59:10,900 --> 00:59:11,400
Right.

1412
00:59:11,600 --> 00:59:14,300
So now that's so that should be hopefully really easy to understand

1413
00:59:14,300 --> 00:59:14,400
it.

1414
00:59:14,400 --> 00:59:18,400
Basically produces zero or not zero depending on the circumstance, but

1415
00:59:19,000 --> 00:59:19,900
let's see what happens.

1416
00:59:19,900 --> 00:59:24,300
Just so we're clear on everything if we compared it, why let's say Z

1417
00:59:24,300 --> 00:59:25,600
and W, right?

1418
00:59:25,900 --> 00:59:27,700
So we put some other values in here.

1419
00:59:27,800 --> 00:59:28,400
You do.

1420
00:59:28,400 --> 00:59:29,500
Do, do, do.

1421
00:59:29,800 --> 00:59:30,400
There we go.

1422
00:59:31,000 --> 00:59:31,600
Off we go.

1423
00:59:32,800 --> 00:59:36,000
So now we compute less and we say Z less than W.

1424
00:59:36,000 --> 00:59:39,500
Well Z is much higher than W, so obviously that's zero didn't happen.

1425
00:59:39,800 --> 00:59:42,500
So now we say is z greater than W, right?

1426
00:59:42,800 --> 00:59:46,100
And it turns out that Z is in fact greater than W still write someone

1427
00:59:46,100 --> 00:59:48,200
in their equals, right?

1428
00:59:48,300 --> 00:59:49,100
They are not equal.

1429
00:59:49,300 --> 00:59:49,900
Not equals.

1430
00:59:49,900 --> 00:59:51,200
They are, in fact, not equal.

1431
00:59:51,700 --> 00:59:54,900
And so basically any values that you put in there, no matter what they

1432
00:59:54,900 --> 00:59:57,200
are, will still produce a zero or nonzero value?

1433
00:59:57,200 --> 00:59:59,500
Now, it is worth noting.

1434
01:00:00,300 --> 01:00:05,300
That the compiler at least as far as I remember, the spec is under no

1435
01:00:05,300 --> 01:00:10,500
particular obligation to actually produce a one there.

1436
01:00:10,800 --> 01:00:15,600
I think it just has to produce some nonzero value and I don't know if

1437
01:00:15,600 --> 01:00:16,500
that's true or not.

1438
01:00:16,500 --> 01:00:17,500
Check the spec.

1439
01:00:17,800 --> 01:00:21,600
It may even differ between C and C++ for all I know because in C++

1440
01:00:21,600 --> 01:00:25,300
they have an actual type called Bool and it may be that these things

1441
01:00:25,300 --> 01:00:26,200
are defined to produce.

1442
01:00:26,400 --> 01:00:27,600
You know, I don't even know.

1443
01:00:27,800 --> 01:00:29,900
I don't care at all about it.

1444
01:00:30,000 --> 01:00:34,200
All I want to do is just make you aware that the compiler may not be

1445
01:00:34,200 --> 01:00:36,100
required to actually produce a one there.

1446
01:00:36,100 --> 01:00:39,900
It's just required to produce something that is not 0.

1447
01:00:40,000 --> 01:00:43,600
If the thing was true, I know that for a fact but check the spec if

1448
01:00:43,600 --> 01:00:46,200
you want to know if it access or producer one, but anyway, we can do

1449
01:00:46,200 --> 01:00:48,100
that for any variables that we want to.

1450
01:00:48,100 --> 01:00:50,900
We can always compare them like that and then get back what we need.

1451
01:00:51,400 --> 01:00:54,300
And those are called The Logical operators, and that is what they look

1452
01:00:54,300 --> 01:00:54,500
like.

1453
01:00:54,500 --> 01:00:54,900
Now.

1454
01:00:55,100 --> 01:00:56,300
Why do we want those?

1455
01:00:56,400 --> 01:00:59,800
The reason that we want those is so that we can do control flow.

1456
01:01:00,000 --> 01:01:02,100
Which is the next thing that I want to talk about.

1457
01:01:02,700 --> 01:01:07,400
So control flow the way that works is basically saying, okay.

1458
01:01:07,400 --> 01:01:11,700
I might have some code and here is where maybe we'll bring our output

1459
01:01:11,700 --> 01:01:15,700
debug string back into the mix because I know everyone really loved

1460
01:01:15,700 --> 01:01:16,100
output.

1461
01:01:16,100 --> 01:01:16,700
Debug string.

1462
01:01:16,800 --> 01:01:19,100
I know they were a fan of output debug string.

1463
01:01:19,100 --> 01:01:20,200
They thought it was awesome.

1464
01:01:20,900 --> 01:01:24,000
And so maybe I just want to do something like print out, which one of

1465
01:01:24,000 --> 01:01:24,700
these is greater.

1466
01:01:24,800 --> 01:01:29,200
So I want to print out like Z is less than W, right?

1467
01:01:29,500 --> 01:01:29,900
Or I

1468
01:01:30,000 --> 01:01:34,500
A printout W is less than Z or I want to print out.

1469
01:01:34,600 --> 01:01:37,200
W is equal to Z.

1470
01:01:37,500 --> 01:01:38,000
Right?

1471
01:01:38,200 --> 01:01:39,700
I want to print those things out.

1472
01:01:40,200 --> 01:01:43,300
And so what I have to do, you know, obviously if I'm to run this

1473
01:01:43,300 --> 01:01:44,100
program, right?

1474
01:01:44,100 --> 01:01:48,400
I run the program and I print out all three of them and that's not

1475
01:01:48,400 --> 01:01:49,000
what I want.

1476
01:01:49,000 --> 01:01:52,200
You know, I want it only print the one of those that is true because

1477
01:01:52,200 --> 01:01:54,800
they can only one of them can be true.

1478
01:01:55,200 --> 01:01:58,300
And so what I'm going to do is I'm going to introduce control flow

1479
01:01:58,500 --> 01:01:59,800
control flow is a way.

1480
01:02:00,000 --> 01:02:01,700
A of preventing code from running.

1481
01:02:01,700 --> 01:02:07,200
Unless something is true basically and you have a lot of options to do

1482
01:02:07,200 --> 01:02:12,300
that in C and I'm going to show you the first and most basic one right

1483
01:02:12,300 --> 01:02:12,500
now.

1484
01:02:12,500 --> 01:02:15,200
So I am going to do this test.

1485
01:02:15,200 --> 01:02:17,400
I'm going to say Z is less than W.

1486
01:02:17,400 --> 01:02:18,700
That is z less than W.

1487
01:02:18,700 --> 01:02:22,700
And I'm going to say if that is true then print this out.

1488
01:02:22,700 --> 01:02:25,800
And so what you do is you start with the if you open a parenthesis and

1489
01:02:25,800 --> 01:02:29,100
close the parentheses and then you put the actual value, you want to

1490
01:02:29,100 --> 01:02:29,600
test in there.

1491
01:02:29,600 --> 01:02:29,800
Now.

1492
01:02:30,000 --> 01:02:32,000
Value can actually just be a variable.

1493
01:02:32,000 --> 01:02:34,300
So if I want to I can just I already computed it, right.

1494
01:02:34,300 --> 01:02:38,000
I already computed Z lesson wi can just go right on the Val variable.

1495
01:02:38,000 --> 01:02:41,900
It's just a value and I can put the expression in as well, that could

1496
01:02:41,900 --> 01:02:43,900
produce that value and it will evaluate here.

1497
01:02:43,900 --> 01:02:45,300
So it's all it's whatever you want.

1498
01:02:45,300 --> 01:02:49,300
You just have to be something that evaluates to 0 or not 0, and then

1499
01:02:49,300 --> 01:02:51,300
it's going to be able to do the thing in there.

1500
01:02:51,800 --> 01:02:52,200
Now.

1501
01:02:52,400 --> 01:02:55,700
If if that wasn't true now I can just leave it like that.

1502
01:02:55,700 --> 01:02:58,800
If I want to write I can make that be all that's going to happen,

1503
01:02:58,800 --> 01:02:59,000
right?

1504
01:02:59,000 --> 01:02:59,800
That could be the end of it.

1505
01:03:00,200 --> 01:03:03,200
And now, I could run that and basically, Oops.

1506
01:03:03,300 --> 01:03:08,600
Why I gotta get rid of my to do people test.

1507
01:03:08,600 --> 01:03:09,700
I want to get rid of These Warnings.

1508
01:03:09,700 --> 01:03:11,300
I'm sorry, that there are some warnings in here.

1509
01:03:11,500 --> 01:03:16,100
So this we will just sort of expand our comment out to there you go.

1510
01:03:16,400 --> 01:03:17,600
So, no warnings down.

1511
01:03:17,800 --> 01:03:20,800
So I run this and you'll notice it did not actually print out.

1512
01:03:20,800 --> 01:03:23,600
It did not print out this thing and why didn't print it out well

1513
01:03:23,700 --> 01:03:26,800
because less, as we know as we stepped in here before and saw

1514
01:03:27,500 --> 01:03:28,700
Less is equal to 0.

1515
01:03:29,300 --> 01:03:32,900
Now, if I want to, I'm going to print out this other things, so I

1516
01:03:32,900 --> 01:03:36,100
could, if I want to, I could also just do well.

1517
01:03:36,100 --> 01:03:36,700
Let's see.

1518
01:03:36,700 --> 01:03:38,200
Let's do greater, right?

1519
01:03:42,400 --> 01:03:44,800
I'm off of this editor is true.

1520
01:03:45,000 --> 01:03:45,900
I don't deny it.

1521
01:03:48,100 --> 01:03:55,000
So this is z is greater than W, run it right unsurprisingly.

1522
01:03:55,200 --> 01:03:57,600
We now get that because that is a value that we actually knew to be

1523
01:03:57,600 --> 01:03:58,100
one.

1524
01:03:58,100 --> 01:03:58,600
Right?

1525
01:03:58,700 --> 01:03:59,300
And furthermore.

1526
01:03:59,300 --> 01:04:01,000
I could also test for equals, right?

1527
01:04:01,000 --> 01:04:03,100
I could see what the equal one is.

1528
01:04:03,100 --> 01:04:03,400
I fight.

1529
01:04:03,400 --> 01:04:04,500
I can do all of these, right?

1530
01:04:04,500 --> 01:04:05,300
I can put them in here.

1531
01:04:05,700 --> 01:04:06,400
Doodoo.

1532
01:04:17,300 --> 01:04:18,500
and,

1533
01:04:19,800 --> 01:04:20,200
Done.

1534
01:04:21,900 --> 01:04:22,400
Right.

1535
01:04:23,100 --> 01:04:26,700
So that is the way to make some conditional execution.

1536
01:04:26,700 --> 01:04:29,400
And basically what happens is when we look at in the in the actual

1537
01:04:29,400 --> 01:04:31,300
debugger, you will note that any time.

1538
01:04:31,300 --> 01:04:32,500
The condition is not true.

1539
01:04:32,600 --> 01:04:34,800
It just goes ahead and full-on skips.

1540
01:04:34,800 --> 01:04:35,200
Everything.

1541
01:04:35,200 --> 01:04:36,800
That is within the curly braces.

1542
01:04:37,000 --> 01:04:38,900
Those curly braces are called a block.

1543
01:04:38,900 --> 01:04:42,100
We will talk about them in the mainstream more, but basically

1544
01:04:42,100 --> 01:04:45,000
everything inside the block gets executed, if the if statement

1545
01:04:45,000 --> 01:04:50,200
evaluates to true or not zero and everything out outside.

1546
01:04:50,200 --> 01:04:51,500
I'm sorry everything inside.

1547
01:04:51,700 --> 01:04:53,500
Skipped, if it does not.

1548
01:04:53,500 --> 01:04:55,400
And you can see, that's exactly what happens.

1549
01:04:55,400 --> 01:04:55,600
Right?

1550
01:04:55,600 --> 01:04:56,200
No big mystery.

1551
01:04:56,200 --> 01:04:58,300
They're very, very straight forward.

1552
01:04:58,800 --> 01:05:04,500
And what you will notice is if, for example, you already did a test on

1553
01:05:04,500 --> 01:05:08,900
something, it is often the case that you may want to do the opposite

1554
01:05:08,900 --> 01:05:10,100
thing as well.

1555
01:05:10,100 --> 01:05:13,400
You may want to have some code that executes when it is not the case.

1556
01:05:13,700 --> 01:05:15,900
And so instead of testing for not equal as well.

1557
01:05:16,000 --> 01:05:19,400
Well, equal is basically the same as testing for not equal because

1558
01:05:19,400 --> 01:05:20,800
it's just the opposite case.

1559
01:05:21,000 --> 01:05:21,500
So what

1560
01:05:21,700 --> 01:05:26,500
See also allows you to do is at the end of your if you can put an else

1561
01:05:26,500 --> 01:05:30,500
statement and the else statement can basically contain what to do when

1562
01:05:30,500 --> 01:05:31,400
the things fail.

1563
01:05:31,400 --> 01:05:35,000
So when this is zero, instead of one it will do it, right?

1564
01:05:35,000 --> 01:05:37,400
And what we get there is we get a base of the same behavior of the

1565
01:05:37,400 --> 01:05:38,000
program.

1566
01:05:38,100 --> 01:05:39,700
It's just a more concise way of writing it.

1567
01:05:39,700 --> 01:05:41,100
I don't have to check the separate value.

1568
01:05:41,100 --> 01:05:41,600
It just goes.

1569
01:05:41,600 --> 01:05:43,100
Okay, it wasn't true.

1570
01:05:43,100 --> 01:05:44,800
So execute the else Clause, right?

1571
01:05:44,800 --> 01:05:47,000
And that's basically why I'm just saying I'm going to execute one

1572
01:05:47,000 --> 01:05:47,600
either way.

1573
01:05:47,800 --> 01:05:49,600
Now you can stack these up.

1574
01:05:49,600 --> 01:05:51,500
If you would like to, as I started to write down here.

1575
01:05:51,700 --> 01:05:53,500
Then I figured it would be better to explain them in a slightly

1576
01:05:53,500 --> 01:05:54,100
different way.

1577
01:05:54,400 --> 01:05:55,400
You can stack these up.

1578
01:05:55,400 --> 01:05:59,800
So let's say I'm on here and I do if less well, I know that if

1579
01:06:00,000 --> 01:06:01,900
Less then it can't be anything else.

1580
01:06:02,000 --> 01:06:04,300
So I'm just going to put everything else in the else Clause.

1581
01:06:04,300 --> 01:06:07,600
I'm going to say okay, you know, well then then I'll test for if it's

1582
01:06:07,600 --> 01:06:09,000
greater right?

1583
01:06:09,100 --> 01:06:10,600
And then I'll test for if it's equal.

1584
01:06:13,300 --> 01:06:14,700
In here, right?

1585
01:06:14,800 --> 01:06:15,800
It's going to do these tests.

1586
01:06:15,800 --> 01:06:17,100
I'm not going to bother testing.

1587
01:06:17,200 --> 01:06:20,400
If it's not equal to because if it's not equal to it, it will have hit

1588
01:06:20,600 --> 01:06:21,300
these things.

1589
01:06:22,400 --> 01:06:24,500
It will hit one of those things because it'll either be greater than

1590
01:06:24,500 --> 01:06:25,000
or less than.

1591
01:06:25,000 --> 01:06:25,100
So.

1592
01:06:25,100 --> 01:06:27,000
We'll just do it this way for now, right?

1593
01:06:27,700 --> 01:06:31,500
And when I run this particular program, you will note that it does

1594
01:06:31,500 --> 01:06:32,600
exactly get when I thought.

1595
01:06:32,600 --> 01:06:33,400
It said it would do it.

1596
01:06:33,400 --> 01:06:34,500
Will this is not true.

1597
01:06:34,500 --> 01:06:35,600
So we'll evaluate these.

1598
01:06:35,700 --> 01:06:36,400
This is true.

1599
01:06:36,400 --> 01:06:37,400
So evaluate that one.

1600
01:06:37,600 --> 01:06:38,300
This is not true.

1601
01:06:38,300 --> 01:06:42,000
So it will skip it right, but if I know that these things are

1602
01:06:42,200 --> 01:06:43,300
All mutually exclusive.

1603
01:06:43,400 --> 01:06:45,900
So I only want to ever do one of them.

1604
01:06:46,100 --> 01:06:49,100
I can actually stack the ifs inside the else as well.

1605
01:06:49,100 --> 01:06:52,600
Like right on the same line and that will basically allow me to keep

1606
01:06:52,600 --> 01:06:58,300
cascading ifs, as long as I actually want to like as many as I want to

1607
01:06:58,500 --> 01:07:00,100
like this, right?

1608
01:07:00,700 --> 01:07:03,800
And even at the end I can have a final pass through else which is

1609
01:07:03,800 --> 01:07:06,900
like, I don't know what happened, something something went wrong.

1610
01:07:07,100 --> 01:07:09,000
What, right?

1611
01:07:09,400 --> 01:07:11,400
And now when we run it, basically what happens is?

1612
01:07:11,400 --> 01:07:12,100
It will only

1613
01:07:12,200 --> 01:07:13,500
Pick one of these guys.

1614
01:07:13,500 --> 01:07:14,100
It will test them.

1615
01:07:14,100 --> 01:07:16,800
Each does that one as soon as it finds when it's true?

1616
01:07:16,800 --> 01:07:20,000
It stops evaluating anybody else's because they're all predicated on

1617
01:07:20,000 --> 01:07:22,700
the fact that the previous one didn't occur.

1618
01:07:23,200 --> 01:07:23,800
So

1619
01:07:25,300 --> 01:07:28,600
That is the simplest kind of control flow.

1620
01:07:28,600 --> 01:07:31,700
It's basically do something, or don't do something based on the value

1621
01:07:31,700 --> 01:07:32,400
of a variable.

1622
01:07:32,600 --> 01:07:35,900
Now that value like I said can be built up out of something.

1623
01:07:35,900 --> 01:07:37,900
Extremely complicated, right?

1624
01:07:38,000 --> 01:07:39,800
We could have done a ton of math here.

1625
01:07:39,900 --> 01:07:42,700
We could have used all kinds of comparisons that got compared with

1626
01:07:42,700 --> 01:07:43,700
each other and so on.

1627
01:07:44,400 --> 01:07:48,100
But we may want to do is test a couple things together.

1628
01:07:48,100 --> 01:07:48,600
Right?

1629
01:07:48,600 --> 01:07:51,500
So let's say that we wanted to do and this is basically just a

1630
01:07:51,500 --> 01:07:52,600
glorified, not equals test.

1631
01:07:52,600 --> 01:07:54,100
But let's say we want to do something.

1632
01:07:54,200 --> 01:07:54,900
It's less.

1633
01:07:55,200 --> 01:07:56,900
And greater, we're both true.

1634
01:07:57,200 --> 01:07:58,700
Well, you know, how we had those?

1635
01:07:58,700 --> 01:08:01,200
Oars and Anne's that we used before, right?

1636
01:08:01,200 --> 01:08:02,400
That used bitwise.

1637
01:08:02,800 --> 01:08:05,800
We basically have the same or as Ann Ann's that we can use for

1638
01:08:05,800 --> 01:08:06,400
logical.

1639
01:08:06,500 --> 01:08:09,900
We can actually double if you just put two of the operator, you're

1640
01:08:09,900 --> 01:08:13,900
going to use like logical or or logical.

1641
01:08:13,900 --> 01:08:18,800
And like that we can actually do tests that test for multiple things

1642
01:08:18,800 --> 01:08:19,300
at once.

1643
01:08:19,399 --> 01:08:22,800
So this will do if it is less or greater, right?

1644
01:08:22,800 --> 01:08:24,899
So when I run to this, it's going to actually

1645
01:08:25,000 --> 01:08:26,000
Really look and see.

1646
01:08:26,800 --> 01:08:27,700
How do I get this to go?

1647
01:08:27,700 --> 01:08:28,100
There you go.

1648
01:08:28,399 --> 01:08:30,899
It's going to look and see this guy is 0.

1649
01:08:31,000 --> 01:08:32,000
This guy is one.

1650
01:08:32,000 --> 01:08:35,300
He did an or so he wants to do this case.

1651
01:08:35,399 --> 01:08:38,800
If either of these two things are true and that is one of them is

1652
01:08:38,800 --> 01:08:39,399
true.

1653
01:08:39,399 --> 01:08:41,600
So it goes ahead and does the case, right?

1654
01:08:41,600 --> 01:08:45,100
And the same thing would happen with, and right, I can double the and

1655
01:08:45,100 --> 01:08:46,399
and it's saying logically.

1656
01:08:46,399 --> 01:08:48,300
If both of these things are true.

1657
01:08:48,500 --> 01:08:50,100
Do what's inside, right?

1658
01:08:50,200 --> 01:08:52,399
So, it goes ahead and does that right?

1659
01:08:52,800 --> 01:08:53,600
One of them was true.

1660
01:08:53,600 --> 01:08:54,899
One of them wasn't, which isn't it?

1661
01:08:55,000 --> 01:08:57,800
In case so it skips it and continues on now.

1662
01:08:57,800 --> 01:08:59,600
Those are just operators like anything else.

1663
01:08:59,600 --> 01:08:59,800
So

1664
01:09:00,000 --> 01:09:01,600
Can again, do them outside.

1665
01:09:01,700 --> 01:09:06,000
I can make this an and operator and take this guy out right like that.

1666
01:09:06,500 --> 01:09:08,899
And then just test on the and does that make sense?

1667
01:09:09,000 --> 01:09:11,300
These are all just these are just operations.

1668
01:09:11,300 --> 01:09:14,100
There's nothing magical happening inside the if the, if just wants a

1669
01:09:14,100 --> 01:09:14,600
value.

1670
01:09:14,700 --> 01:09:17,100
So we do all our computation outside with it.

1671
01:09:17,399 --> 01:09:19,200
And there is even a logical extra.

1672
01:09:19,200 --> 01:09:24,200
I believe, I've almost never typed that in, but I believe you can even

1673
01:09:24,200 --> 01:09:26,300
do this, right?

1674
01:09:26,700 --> 01:09:27,600
If that makes sense.

1675
01:09:27,700 --> 01:09:29,899
You can say, I want to do the thing, but I don't even remember.

1676
01:09:30,000 --> 01:09:30,700
Member if that's true.

1677
01:09:31,000 --> 01:09:32,200
No, apparently it's not true.

1678
01:09:32,399 --> 01:09:35,000
I've said never type that in but I was like wonder if you can do a

1679
01:09:35,000 --> 01:09:36,600
logical X or apparently you can't.

1680
01:09:37,500 --> 01:09:38,300
So never mind.

1681
01:09:38,800 --> 01:09:44,899
Anyway, that is essentially all there is to predication and control to

1682
01:09:44,899 --> 01:09:49,100
and and predicated execution and see that's basically the if statement

1683
01:09:49,200 --> 01:09:51,300
and the else statement are all you really need for that.

1684
01:09:51,300 --> 01:09:54,700
Now it's worth noting that you don't actually need these little braces

1685
01:09:54,700 --> 01:09:55,000
here.

1686
01:09:55,000 --> 01:09:58,400
If you only have one thing that you're going to execute meaning, you

1687
01:09:58,400 --> 01:09:59,900
may have seen in other languages, you'll do.

1688
01:10:00,000 --> 01:10:03,700
Being like like this and then you'll have the code just right here.

1689
01:10:03,900 --> 01:10:04,400
Right?

1690
01:10:04,900 --> 01:10:10,300
And that is something you can do, but it's very misleading.

1691
01:10:10,300 --> 01:10:14,000
I find because there's a number of cases that include like macros and

1692
01:10:14,000 --> 01:10:14,400
stuff.

1693
01:10:14,700 --> 01:10:18,000
Where like, if for example the thing that's in here accidentally

1694
01:10:18,000 --> 01:10:20,900
becomes two statements somehow like you type a second one in there.

1695
01:10:21,200 --> 01:10:27,100
It's really going to look visually like only these are only happening

1696
01:10:27,100 --> 01:10:29,200
if the if is true, right?

1697
01:10:29,200 --> 01:10:29,600
But

1698
01:10:29,900 --> 01:10:30,400
Ali.

1699
01:10:30,400 --> 01:10:35,300
See only does the very next thing as part of the if so, this being on

1700
01:10:35,300 --> 01:10:38,000
the same line ends up being very misleading, because it looks like

1701
01:10:38,000 --> 01:10:38,900
it's going to be true.

1702
01:10:39,200 --> 01:10:44,000
And so I always prefer to actually just really show what is going to

1703
01:10:44,000 --> 01:10:47,500
happen by enclosing them in braces and making it a separate block.

1704
01:10:47,500 --> 01:10:51,300
So it's obvious what happens in the if and even with macro expansions

1705
01:10:51,300 --> 01:10:52,700
and all kinds of other crazy stuff.

1706
01:10:52,800 --> 01:10:57,600
This will always be a pretty solid reliable visual indication of

1707
01:10:57,600 --> 01:10:58,300
what's going to happen.

1708
01:11:00,600 --> 01:11:04,900
Same is true on the else if you want to put the code right there, but

1709
01:11:04,900 --> 01:11:05,800
I never do that.

1710
01:11:05,900 --> 01:11:10,100
I always do that and that is really just a personal preference.

1711
01:11:10,100 --> 01:11:13,800
But I think it's a more solid and more reliable way to keep things

1712
01:11:13,800 --> 01:11:15,000
from accidentally.

1713
01:11:15,000 --> 01:11:15,800
Spiraling out of control.

1714
01:11:15,800 --> 01:11:17,900
If you happen to be using macros or other things like that.

1715
01:11:18,800 --> 01:11:19,400
Okay.

1716
01:11:19,800 --> 01:11:22,200
How is everyone doing on the stream is the question.

1717
01:11:22,200 --> 01:11:23,700
This has been a crazy Sunday.

1718
01:11:23,700 --> 01:11:24,500
We've just been going.

1719
01:11:24,600 --> 01:11:26,000
Absolutely crazy.

1720
01:11:26,800 --> 01:11:28,400
It's full on.

1721
01:11:28,600 --> 01:11:32,700
Banana cakes, but you know, that's just how that's just how things go

1722
01:11:32,700 --> 01:11:33,400
sometimes.

1723
01:11:33,500 --> 01:11:34,000
Are we doing?

1724
01:11:34,000 --> 01:11:34,300
Okay?

1725
01:11:34,300 --> 01:11:35,700
On the stream is everyone happy.

1726
01:11:35,700 --> 01:11:40,100
I need to wait a little bit because the amount of time it takes before

1727
01:11:40,100 --> 01:11:42,900
the stream actually gets that's on there.

1728
01:11:46,200 --> 01:11:47,300
Did you do?

1729
01:11:50,200 --> 01:11:51,100
I guess that's true.

1730
01:11:51,100 --> 01:11:53,100
So Clemens bound, did have a good point there.

1731
01:11:54,000 --> 01:11:55,300
He, that was a good point.

1732
01:11:55,300 --> 01:11:56,500
He basically pointed out that.

1733
01:11:56,500 --> 01:11:56,900
Well.

1734
01:11:57,100 --> 01:11:58,500
Yeah, there's no, there's no.

1735
01:11:59,500 --> 01:11:59,800
I was saying

1736
01:12:00,000 --> 01:12:04,500
About X or there's no xor operator like that, but it's true.

1737
01:12:04,500 --> 01:12:07,400
You don't really need it because this is essentially, the xor operator

1738
01:12:07,600 --> 01:12:09,800
saying something is not equal to something else.

1739
01:12:10,400 --> 01:12:14,600
Does effectively give you the xor operator because that's what that

1740
01:12:14,600 --> 01:12:14,900
is.

1741
01:12:15,400 --> 01:12:16,100
So that's a good point.

1742
01:12:16,100 --> 01:12:20,900
So why bother like I mean basically this would have just been C CI

1743
01:12:20,900 --> 01:12:23,100
adding syntax that wasn't really necessary.

1744
01:12:23,100 --> 01:12:24,200
So it's probably better that.

1745
01:12:24,200 --> 01:12:27,200
They just didn't bother right, and you just know, well, if you wanted

1746
01:12:27,200 --> 01:12:29,800
X or yeah, you can't type it to look like an X or but

1747
01:12:30,000 --> 01:12:31,700
It is an X or that's what it is.

1748
01:12:32,200 --> 01:12:34,300
That would explain why I've never typed this or never even thought

1749
01:12:34,300 --> 01:12:36,900
that I needed it because you just kind of know like okay, I can do

1750
01:12:36,900 --> 01:12:37,200
that.

1751
01:12:40,200 --> 01:12:41,300
B for binary watch.

1752
01:12:41,300 --> 01:12:44,200
Okay, someone the stream has spoken.

1753
01:12:44,500 --> 01:12:45,500
I'm hoping this is true.

1754
01:12:45,700 --> 01:12:46,900
Let's see if that's true.

1755
01:12:48,800 --> 01:12:53,800
And okay to do, can we get a binary watch?

1756
01:12:54,200 --> 01:12:55,300
Let's, let's do it.

1757
01:13:00,800 --> 01:13:01,300
All right.

1758
01:13:01,300 --> 01:13:02,100
Sorry man.

1759
01:13:02,300 --> 01:13:03,900
I thank you for the suggestion on binary watch.

1760
01:13:03,900 --> 01:13:06,200
It doesn't look like it worked that maybe because we are still in

1761
01:13:06,200 --> 01:13:07,700
Visual Studio 2008.

1762
01:13:08,000 --> 01:13:13,000
Maybe, when we switch to, to the thing, it'll work.

1763
01:13:14,500 --> 01:13:15,200
But I don't know.

1764
01:13:15,600 --> 01:13:18,400
Like I said, it's maybe it might be a feature that they added.

1765
01:13:18,600 --> 01:13:20,800
So yeah, that's good.

1766
01:13:21,400 --> 01:13:22,900
All right, it's a stream going.

1767
01:13:22,900 --> 01:13:23,200
Okay.

1768
01:13:23,200 --> 01:13:24,400
Everyone's okay on the stream.

1769
01:13:24,400 --> 01:13:25,600
We're going to assume.

1770
01:13:25,900 --> 01:13:26,900
We are going to assume that it's going.

1771
01:13:26,900 --> 01:13:27,300
Okay.

1772
01:13:27,300 --> 01:13:30,100
We'll try like we'll try it on the

1773
01:13:31,100 --> 01:13:34,000
On the 2013, when we go to the mainstream and hopefully that'll work.

1774
01:13:34,300 --> 01:13:35,100
So that'll be good.

1775
01:13:35,600 --> 01:13:38,100
Alright, so we're going to keep going here because it's Sunday and

1776
01:13:38,100 --> 01:13:39,000
we're just going nuts.

1777
01:13:39,300 --> 01:13:41,300
We're just going to go into the remaining control flow.

1778
01:13:41,300 --> 01:13:43,500
Structure is just so we can show you what they are.

1779
01:13:43,800 --> 01:13:48,400
So sometimes, you know, before I wrote this thing out, I did a little

1780
01:13:48,400 --> 01:13:50,900
thing where I'm like, hey guys, you know what?

1781
01:13:51,500 --> 01:13:53,600
Let's set this thing equal to 0 XA.

1782
01:13:53,800 --> 01:13:58,900
And then let's just go ahead and shift that up by, for all the time

1783
01:13:58,900 --> 01:14:00,200
doo-doo-doo-doo doo-doo-doo-doo.

1784
01:14:00,800 --> 01:14:03,500
Right, and then I showed, you know, I went in here and I was like,

1785
01:14:03,500 --> 01:14:04,600
okay, you know.

1786
01:14:06,800 --> 01:14:08,100
We got this value.

1787
01:14:08,400 --> 01:14:09,700
We look at it in hexadecimal.

1788
01:14:09,700 --> 01:14:11,300
We can see the a we shift it up.

1789
01:14:11,300 --> 01:14:12,000
It's moving there.

1790
01:14:12,000 --> 01:14:13,400
It's going, it's like it's going crazy.

1791
01:14:13,400 --> 01:14:16,700
It's shifting shifting shifting and it's fun, but it is kind of

1792
01:14:16,700 --> 01:14:18,000
annoying that the write all this stuff.

1793
01:14:18,000 --> 01:14:22,400
So if there is something that I want to do repeatedly, we have things

1794
01:14:22,500 --> 01:14:25,800
called basically Loops, if that makes sense.

1795
01:14:26,400 --> 01:14:31,400
And Loops are things that allow you to go through and repeat some code

1796
01:14:31,400 --> 01:14:33,900
that you've written once, so that you can do it multiple times.

1797
01:14:33,900 --> 01:14:36,000
So if I want to do this, a bunch of times,

1798
01:14:36,100 --> 01:14:36,600
Times.

1799
01:14:36,600 --> 01:14:40,600
What I can do is, I can basically say, well, let me do this, until

1800
01:14:40,600 --> 01:14:41,600
something is true.

1801
01:14:41,800 --> 01:14:43,700
And that is called a while statement.

1802
01:14:43,700 --> 01:14:46,200
You can say while, and you can say something is true.

1803
01:14:46,200 --> 01:14:48,700
So I'm going to say well X is not equal to 0, right?

1804
01:14:48,700 --> 01:14:52,300
Because if x is equal to 0 that means we shifted the a all the way off

1805
01:14:52,300 --> 01:14:53,000
the end.

1806
01:14:53,100 --> 01:14:55,900
So while X is not equal to 0, I'm going to shift it.

1807
01:14:55,900 --> 01:14:57,200
I'm just going to keep on shifting.

1808
01:14:57,200 --> 01:14:59,800
It and shifting it and shifting it till it gets off the end, right?

1809
01:15:00,000 --> 01:15:04,100
I run this, I go into my while loop X is obviously not equal to 0 yet.

1810
01:15:04,100 --> 01:15:07,500
So I go in here and I shift it, and you'll notice it just keeps on

1811
01:15:07,500 --> 01:15:08,000
going.

1812
01:15:08,100 --> 01:15:12,300
Keeps on executing keeps on executing, until we finally shift it all

1813
01:15:12,300 --> 01:15:12,900
the way off.

1814
01:15:12,900 --> 01:15:14,400
And now that's not true, and Bam.

1815
01:15:14,500 --> 01:15:15,900
I'm out, right?

1816
01:15:16,300 --> 01:15:20,900
So, a while, a while, loop is really trivial.

1817
01:15:20,900 --> 01:15:25,700
It's just one conditional and again, that can be a variable as well.

1818
01:15:25,700 --> 01:15:28,500
So I could do this is the condition, right?

1819
01:15:30,600 --> 01:15:31,200
Right?

1820
01:15:31,500 --> 01:15:32,900
And then I can say, wow, condition.

1821
01:15:33,100 --> 01:15:33,600
Now.

1822
01:15:34,000 --> 01:15:35,700
It's only can execute the code in the loop.

1823
01:15:35,700 --> 01:15:37,500
So it's condition was set up here.

1824
01:15:37,600 --> 01:15:39,300
It would never reach ech.

1825
01:15:39,300 --> 01:15:41,500
So I would have to again set it.

1826
01:15:41,500 --> 01:15:45,700
I would have to test it each time after as well, right Turi.

1827
01:15:45,700 --> 01:15:48,300
Keep re-upping it but now you can see explicitly.

1828
01:15:48,300 --> 01:15:49,100
What's going on.

1829
01:15:51,300 --> 01:15:51,700
Hello?

1830
01:15:51,900 --> 01:15:52,100
Okay.

1831
01:15:52,100 --> 01:15:52,600
There we go.

1832
01:15:53,500 --> 01:15:55,700
You can see so let's see what's going on condition.

1833
01:15:56,300 --> 01:15:59,100
I bring it up here you can see is 1 because that is true.

1834
01:15:59,700 --> 01:16:00,300
I go.

1835
01:16:00,500 --> 01:16:02,700
And I shift it up and I reset Condition.

1836
01:16:02,700 --> 01:16:07,900
It's still true, still true, still true, still true as we shift and

1837
01:16:07,900 --> 01:16:11,600
then finally, this time through I shift and it becomes zero and now

1838
01:16:11,600 --> 01:16:15,200
condition becomes zero and I'm out right.

1839
01:16:16,400 --> 01:16:18,000
Loops are incredibly simple.

1840
01:16:18,100 --> 01:16:19,100
That's all they are.

1841
01:16:19,200 --> 01:16:22,200
The only other thing you really need to know about.

1842
01:16:22,200 --> 01:16:26,700
Loops is that the loop can contain an escape.

1843
01:16:26,900 --> 01:16:30,300
So, if I was to do this, right, basically,

1844
01:16:30,400 --> 01:16:33,200
Ali, if we look at this, you'll see that there is no way to ever get

1845
01:16:33,200 --> 01:16:34,300
out of this Loops.

1846
01:16:34,700 --> 01:16:39,400
Sorry, let's say well one that's just true, right?

1847
01:16:39,400 --> 01:16:40,300
It's just full on true.

1848
01:16:40,700 --> 01:16:43,500
So I had to do this and it's just going to do it and it's going to do

1849
01:16:43,500 --> 01:16:44,100
it forever.

1850
01:16:44,200 --> 01:16:46,700
And there's no way to ever get out of this Loop because one is a

1851
01:16:46,700 --> 01:16:49,500
constant and it's true and it's not ever changing.

1852
01:16:49,500 --> 01:16:52,800
So we just go and go and go, and go, and go, and go, and go, and go,

1853
01:16:53,400 --> 01:16:55,800
and go, and go, and go, some more, right?

1854
01:16:56,200 --> 01:17:00,100
So one thing that is true though, is any time we can actually just

1855
01:17:00,500 --> 01:17:04,000
Hand code essentially the escape from the loop by using what's called,

1856
01:17:04,000 --> 01:17:05,100
a break statement.

1857
01:17:05,100 --> 01:17:08,700
So what I can do is I can put the conditional in here and say, oh,

1858
01:17:08,700 --> 01:17:09,300
okay.

1859
01:17:09,400 --> 01:17:11,800
Well if x equals 0, right?

1860
01:17:11,800 --> 01:17:15,400
Which is the time that I want to stop doing this Loop, like I said, I

1861
01:17:15,400 --> 01:17:18,000
can just put this break statement in and what the break statement will

1862
01:17:18,000 --> 01:17:21,500
do is it will jump straight out of the loop immediately like right at

1863
01:17:21,500 --> 01:17:23,200
that time without doing anything else.

1864
01:17:23,400 --> 01:17:26,800
So as I go through here as I shift it up and up and up and up and up

1865
01:17:26,800 --> 01:17:30,200
and up and up, right when I get to the end and I'm about to shift it

1866
01:17:30,200 --> 01:17:30,300
off.

1867
01:17:30,400 --> 01:17:33,100
At the end, I get to the point where x equals 0.

1868
01:17:33,400 --> 01:17:35,300
I'm there, I break out.

1869
01:17:35,300 --> 01:17:36,500
And that's the end of the loop.

1870
01:17:36,500 --> 01:17:37,700
And we're out right.

1871
01:17:38,600 --> 01:17:40,900
There are two more kinds of Loops.

1872
01:17:41,600 --> 01:17:44,000
You can actually, they're there for convenience.

1873
01:17:44,100 --> 01:17:46,700
You can write any loop with any other loop.

1874
01:17:46,700 --> 01:17:49,500
There isn't like some kind of weird thing where like you have to use

1875
01:17:49,500 --> 01:17:51,400
one kind of loop or the other because they do something differently.

1876
01:17:51,500 --> 01:17:56,200
They are all basically just shorthand notation for essentially.

1877
01:17:56,200 --> 01:17:57,300
What is a conditional go-to.

1878
01:17:57,300 --> 01:17:59,100
It's basically saying when you get to the end go back to the

1879
01:17:59,100 --> 01:17:59,800
beginning, they're all

1880
01:18:00,000 --> 01:18:01,900
Shorthand for doing that in different ways.

1881
01:18:02,200 --> 01:18:05,700
There is a do while loop which is basically you take the while and you

1882
01:18:05,700 --> 01:18:08,400
put it at the end with a semicolon after it.

1883
01:18:08,400 --> 01:18:11,600
And then you put a do at the front and the only difference between

1884
01:18:11,600 --> 01:18:14,700
those two is whether it executes the loop the first time.

1885
01:18:15,000 --> 01:18:19,600
So, for example, if I was here and I did x equals 0, right.

1886
01:18:19,700 --> 01:18:23,900
So now I'm saying, only do the loop when X is equal to 0.

1887
01:18:24,000 --> 01:18:25,100
Well, what's going to happen.

1888
01:18:25,100 --> 01:18:28,500
Well, we're never going to do the loop because X is equal to a right

1889
01:18:28,500 --> 01:18:29,800
oxa, so

1890
01:18:30,000 --> 01:18:30,700
It's not equal to 0.

1891
01:18:30,700 --> 01:18:33,900
So now we're gonna do the loop, but maybe I wanted my Loop to, at

1892
01:18:33,900 --> 01:18:35,200
least always run.

1893
01:18:35,200 --> 01:18:37,300
Once I didn't want to check the first time.

1894
01:18:37,300 --> 01:18:40,400
I always want to do at least one shift, but then I just want it to

1895
01:18:40,400 --> 01:18:41,600
stop doing shifts.

1896
01:18:41,600 --> 01:18:43,400
When X finally does.

1897
01:18:44,500 --> 01:18:45,600
I want to stop doing shifts.

1898
01:18:45,600 --> 01:18:47,700
If x was not equal to 0, right.

1899
01:18:47,800 --> 01:18:49,700
Well, when I do this, that's exactly what happens.

1900
01:18:49,700 --> 01:18:51,300
It'll do the shift, right?

1901
01:18:51,300 --> 01:18:54,500
Once it'll get to the while and then it'll end right there.

1902
01:18:54,600 --> 01:18:58,900
So do is just a way of moving the test till after the first one.

1903
01:18:59,000 --> 01:18:59,800
So, if you want to

1904
01:19:00,000 --> 01:19:03,500
Always do at least one that is where to do it.

1905
01:19:03,500 --> 01:19:04,900
And again, it's just shorthand.

1906
01:19:05,000 --> 01:19:06,200
It's just the same.

1907
01:19:06,700 --> 01:19:09,900
I could do the exact same transformation using the while loop by

1908
01:19:09,900 --> 01:19:10,400
saying.

1909
01:19:10,600 --> 01:19:14,900
Oh, it's really just wild one and then I do the if here right and the

1910
01:19:14,900 --> 01:19:20,200
break that's that's all I did essentially and so, oh sorry not equal

1911
01:19:20,200 --> 01:19:22,000
to right.

1912
01:19:22,000 --> 01:19:24,600
So whatever the while condition would have been I can just test the

1913
01:19:24,600 --> 01:19:27,300
not of that while condition and do the break.

1914
01:19:27,400 --> 01:19:29,000
So basically these are all just shorthand.

1915
01:19:29,000 --> 01:19:29,600
There's nothing.

1916
01:19:29,900 --> 01:19:31,100
Really fancy to them.

1917
01:19:31,100 --> 01:19:32,500
They're not particularly interesting.

1918
01:19:32,600 --> 01:19:34,700
It's just different ways of writing the conditions.

1919
01:19:37,700 --> 01:19:40,100
Finally, because it is very common.

1920
01:19:41,200 --> 01:19:44,300
There's a thing called a for Loop and what a for Loop does.

1921
01:19:44,300 --> 01:19:45,200
Oops, almost wrote it.

1922
01:19:45,200 --> 01:19:46,200
My standard way.

1923
01:19:46,600 --> 01:19:50,800
What a for Loop does is a for Loop allows you to basically go ahead

1924
01:19:50,800 --> 01:19:55,700
and move a variables declar initialization, right?

1925
01:19:56,000 --> 01:19:57,000
It's test.

1926
01:20:01,300 --> 01:20:07,300
And its operation all in to a single concise form.

1927
01:20:07,300 --> 01:20:08,600
That can be pretty easily read.

1928
01:20:09,100 --> 01:20:11,500
And in this case, we don't even have anything to do in the body.

1929
01:20:11,500 --> 01:20:14,600
But this is where, you know, more stuff would happen here, right?

1930
01:20:14,600 --> 01:20:17,500
If you were doing a more complex for Loop, the for Loop is basically

1931
01:20:17,500 --> 01:20:18,600
kind of like the Uber Loop.

1932
01:20:18,600 --> 01:20:21,400
The thing that packs the most into a small space.

1933
01:20:21,400 --> 01:20:23,600
You can see what happens if I run here.

1934
01:20:24,800 --> 01:20:29,700
I will actually do three different things separated by semicolons.

1935
01:20:30,000 --> 01:20:34,000
This is the first one and this happens once at the beginning.

1936
01:20:35,200 --> 01:20:36,400
It has the conditional.

1937
01:20:36,500 --> 01:20:38,900
This is the condition for the loop.

1938
01:20:38,900 --> 01:20:44,800
So as long as this is true, it will keep going and then it has the

1939
01:20:44,900 --> 01:20:47,400
thing to do every iteration of the loop.

1940
01:20:47,500 --> 01:20:52,200
So every time, every time it repeats it will do this thing here,

1941
01:20:52,300 --> 01:20:52,800
right?

1942
01:20:52,900 --> 01:20:57,600
So what happens is it goes and it does oops, there's that conditional

1943
01:20:57,600 --> 01:20:58,200
compilation.

1944
01:20:58,800 --> 01:20:59,800
Don't know why it always wants to do.

1945
01:21:00,200 --> 01:21:00,900
It always does.

1946
01:21:01,500 --> 01:21:04,500
So I've got my x max equal to 0, first time through the loop.

1947
01:21:04,500 --> 01:21:08,100
It sets x equal to x a which is this line right here.

1948
01:21:08,700 --> 01:21:11,400
The next thing it does is it does the test to see whether it should

1949
01:21:11,400 --> 01:21:14,600
execute the loop, which is X not equal to 0 X is not equal to 0.

1950
01:21:14,800 --> 01:21:17,700
So then it would do the body of the loop normally, but since we have

1951
01:21:17,700 --> 01:21:20,000
nobody, it's just going to go ahead and do the one thing that we told

1952
01:21:20,000 --> 01:21:23,700
to do every iteration x equals x just add up, it does the shift right?

1953
01:21:23,800 --> 01:21:26,800
End of the loop keeps going testing.

1954
01:21:27,000 --> 01:21:29,300
Testing testing, testing testing.

1955
01:21:30,300 --> 01:21:32,100
Until it fails, right?

1956
01:21:32,100 --> 01:21:33,000
And then it goes out.

1957
01:21:33,300 --> 01:21:35,600
Now, it would be nice that it butter actually showed it doing the

1958
01:21:35,600 --> 01:21:35,900
test.

1959
01:21:35,900 --> 01:21:40,200
But what, it actually puts the, it puts the little green yellow arrow

1960
01:21:40,200 --> 01:21:41,700
here on the test.

1961
01:21:41,700 --> 01:21:45,000
Usually, which is kind of annoying because you'd rather see it

1962
01:21:45,200 --> 01:21:46,700
actually pointing here and evaluating it.

1963
01:21:46,700 --> 01:21:50,100
But yeah, so, anyway, to make it a little more explicit.

1964
01:21:50,200 --> 01:21:52,500
I'll put the output debug string that we were using.

1965
01:21:54,000 --> 01:21:57,800
I'll go ahead and put that there so you can see when that executes in

1966
01:21:57,800 --> 01:21:58,900
the grand scheme of things.

1967
01:21:59,200 --> 01:21:59,600
Right?

1968
01:22:00,000 --> 01:22:03,100
So we're going to put the a book, debug string here and say.

1969
01:22:05,200 --> 01:22:06,500
We are in the loop.

1970
01:22:09,500 --> 01:22:10,800
Okay, and here we go.

1971
01:22:11,000 --> 01:22:16,000
So we go through and our first time through X gets initialized to a it

1972
01:22:16,000 --> 01:22:16,400
tested.

1973
01:22:16,400 --> 01:22:17,100
It's not equal to zero.

1974
01:22:17,100 --> 01:22:17,700
It's not.

1975
01:22:17,800 --> 01:22:20,500
So now it's going to do output debug string, right?

1976
01:22:21,000 --> 01:22:22,500
So it does that put debug string?

1977
01:22:22,800 --> 01:22:27,600
And well, we don't have the, I got actually put up the output window

1978
01:22:27,700 --> 01:22:30,100
if you want to see this, but here we go.

1979
01:22:31,700 --> 01:22:32,000
Curtis.

1980
01:22:32,300 --> 01:22:36,200
We are in the loop it now goes and does the thing to do on each

1981
01:22:36,200 --> 01:22:38,600
iteration at the end which is to shift it up.

1982
01:22:38,600 --> 01:22:40,100
It, shifts it up it.

1983
01:22:40,100 --> 01:22:40,500
Now does that.

1984
01:22:40,500 --> 01:22:45,400
But debug string right now does the test again shift up, test, shift

1985
01:22:45,400 --> 01:22:50,300
up, shift up keeps going, do do do and then we're out and we end up in

1986
01:22:50,300 --> 01:22:54,100
of course, Windows code C, runtime Library.

1987
01:22:54,600 --> 01:22:56,700
All right, so that's about it for Loops.

1988
01:22:56,700 --> 01:22:59,700
They're not very interesting for is the hardest one to understand out

1989
01:22:59,700 --> 01:23:01,200
of them because it packs everything.

1990
01:23:01,400 --> 01:23:05,000
Here and really these things, essentially get expanded.

1991
01:23:05,000 --> 01:23:09,500
So if you want here is a more concise way of looking at what a for

1992
01:23:09,500 --> 01:23:10,800
Loop actually does a.

1993
01:23:10,800 --> 01:23:14,800
For Loop actually does my ntx go.

1994
01:23:17,500 --> 01:23:23,900
Anyway, so basically what this for Loop, exactly translates to is this

1995
01:23:23,900 --> 01:23:24,900
while loop down here.

1996
01:23:25,100 --> 01:23:29,100
It translates into this, if that makes sense.

1997
01:23:29,400 --> 01:23:33,900
So these two things - obviously the part here, although I can show you

1998
01:23:33,900 --> 01:23:34,600
where that would happen is.

1999
01:23:34,600 --> 01:23:35,300
Well, there you go.

2000
01:23:35,300 --> 01:23:36,500
Now, they're exactly equivalent.

2001
01:23:37,100 --> 01:23:40,000
So basically the way these work is they're just kind of they could all

2002
01:23:40,000 --> 01:23:41,400
be transformed into each other.

2003
01:23:41,400 --> 01:23:43,300
They're all exactly equivalent.

2004
01:23:43,300 --> 01:23:45,600
They just have different sort of shapes and stuff to them.

2005
01:23:45,800 --> 01:23:46,200
So basically,

2006
01:23:46,400 --> 01:23:49,600
What happens is a for Loop that looks like this will basically just do

2007
01:23:49,600 --> 01:23:50,700
you'll do this thing.

2008
01:23:50,700 --> 01:23:51,500
So, there it is.

2009
01:23:52,000 --> 01:23:54,900
It'll then do a while loop on this.

2010
01:23:55,200 --> 01:23:58,600
And each time to the while loop at the end of the while loop, before

2011
01:23:58,600 --> 01:23:59,500
it does anything else.

2012
01:23:59,500 --> 01:23:59,900
It'll do.

2013
01:24:00,300 --> 01:24:03,600
The thing that you put last year and again, it's a little hard to see

2014
01:24:03,600 --> 01:24:06,500
that in the de butter because it a better kind of didn't really move

2015
01:24:06,500 --> 01:24:08,100
the line thing to where it should have moved.

2016
01:24:08,100 --> 01:24:09,800
But this is conceptually.

2017
01:24:09,800 --> 01:24:11,500
This is what the code actually is.

2018
01:24:11,500 --> 01:24:14,700
So these two Loops do substantively the exact same thing.

2019
01:24:14,900 --> 01:24:18,700
It's just they're written in a different notation and you may find one

2020
01:24:18,700 --> 01:24:21,200
or the other Mark more easy to read.

2021
01:24:21,200 --> 01:24:21,500
Now.

2022
01:24:21,500 --> 01:24:25,600
The reason a lot of people prefer for Loops is because it's not really

2023
01:24:25,600 --> 01:24:27,500
because they're more flexible or do anything really all that

2024
01:24:27,500 --> 01:24:29,800
interesting over like say just

2025
01:24:30,000 --> 01:24:31,200
eating as a while loop like this.

2026
01:24:31,200 --> 01:24:34,000
Usually the reason they do it is because it makes it easier for people

2027
01:24:34,000 --> 01:24:39,700
reading the code to see what the main sort of reason for the loop is

2028
01:24:39,900 --> 01:24:44,000
because it puts out in it sort of the person who's the loop

2029
01:24:44,000 --> 01:24:47,200
controller, the the variable that's going to be tested and initialize

2030
01:24:47,200 --> 01:24:50,100
and tested and changed typically goes in here.

2031
01:24:50,100 --> 01:24:51,900
So it's just an easier way for people to see.

2032
01:24:51,900 --> 01:24:53,900
Oh, this is a loop that shifts X.

2033
01:24:53,900 --> 01:24:56,600
I can see, I can see that's basically what this Loop is doing.

2034
01:24:56,700 --> 01:24:58,700
And then I know that everything in the body of the loop is just stuff

2035
01:24:58,700 --> 01:24:59,800
that has to happen.

2036
01:25:00,000 --> 01:25:02,900
On every one of those, that's like kind of stuff that happens with the

2037
01:25:02,900 --> 01:25:03,700
x or whatever.

2038
01:25:04,000 --> 01:25:07,600
So that is why people often prefer for Loops is because they just they

2039
01:25:07,600 --> 01:25:10,000
give, you know, you can see that these are kind of spread out and not

2040
01:25:10,000 --> 01:25:11,400
really all that related in the code.

2041
01:25:11,400 --> 01:25:12,100
When you look at it here.

2042
01:25:12,100 --> 01:25:13,100
It's not that obvious.

2043
01:25:13,200 --> 01:25:16,600
Especially if you imagine, you know, you're typically looking at code

2044
01:25:16,600 --> 01:25:21,000
that has like all this other crap, sort of strewn all throughout it.

2045
01:25:21,100 --> 01:25:25,300
And in that particular case, it gets pretty hard to see necessarily

2046
01:25:25,300 --> 01:25:26,200
what the loop is.

2047
01:25:26,300 --> 01:25:29,200
Whereas if you know, you look at it here, the for Loops going to have

2048
01:25:29,200 --> 01:25:29,800
that stuff.

2049
01:25:29,900 --> 01:25:34,700
We all sort of mixed like this, but the x is still, it's really clear.

2050
01:25:34,700 --> 01:25:36,000
What's happening here, right?

2051
01:25:36,000 --> 01:25:39,700
So it's pretty easy to kind of kind of isolate it so it's usually like

2052
01:25:39,700 --> 01:25:42,400
a legibility concern and that's mostly what a forest for.

2053
01:25:43,000 --> 01:25:47,700
Okay, so that is pretty much it for flow control except for one that

2054
01:25:47,700 --> 01:25:49,700
I'm probably going to end up using it in the Stream of bunch.

2055
01:25:49,700 --> 01:25:50,800
So I just want to mention it.

2056
01:25:51,400 --> 01:25:54,200
If you're tired of writing a statements a lot.

2057
01:25:54,200 --> 01:25:56,900
There's a thing called a switch statement and what a switch statement

2058
01:25:56,900 --> 01:25:57,100
is.

2059
01:25:57,100 --> 01:25:59,800
Is it something that basically allows you to put many?

2060
01:26:00,000 --> 01:26:04,700
If together assuming that they obey a couple quick rules, so if I have

2061
01:26:04,700 --> 01:26:09,300
something like okay, I've got some value its X its equal to 3 and I

2062
01:26:09,300 --> 01:26:12,900
want to do something on like a ton of different, you know, sort of

2063
01:26:12,900 --> 01:26:14,800
things that X could be, right?

2064
01:26:14,800 --> 01:26:19,600
X could be 0, x could be 1, x could be 2, whatever, right?

2065
01:26:19,600 --> 01:26:22,100
So, I've got all sorts of things this editor.

2066
01:26:22,400 --> 01:26:23,900
I do not get along with very well.

2067
01:26:23,900 --> 01:26:25,000
Why are you doing these things?

2068
01:26:25,000 --> 01:26:29,800
Okay, so I want to test a bunch of things and basically like I kept,

2069
01:26:29,900 --> 01:26:33,900
Doing this and I wrote, you know, the X test over and over and over

2070
01:26:33,900 --> 01:26:35,800
and over and over and over again, right?

2071
01:26:36,500 --> 01:26:39,500
And so what a switch statement really allows you to do most of the

2072
01:26:39,500 --> 01:26:41,700
time these days are some other uses for it, but they're kind of a

2073
01:26:41,700 --> 01:26:44,000
little janky like Duff's device and these are the sorts of weird

2074
01:26:44,000 --> 01:26:46,900
things, but for the most part, what a switch statement is if you are

2075
01:26:46,900 --> 01:26:49,800
going to compare a variable to a bunch of constants.

2076
01:26:51,000 --> 01:26:54,800
you can put the variable or the expression, whatever something that

2077
01:26:54,800 --> 01:26:59,700
evaluates to a number, you can put a switch statement in and then you

2078
01:26:59,700 --> 01:26:59,800
can

2079
01:27:00,000 --> 01:27:02,000
Use what are called case labels.

2080
01:27:02,400 --> 01:27:06,200
And these case labels basically just have the different values that

2081
01:27:06,200 --> 01:27:06,900
you wanted case.

2082
01:27:06,900 --> 01:27:14,600
One case, two case three case for case, 5 and case 6.

2083
01:27:15,600 --> 01:27:15,900
All right.

2084
01:27:15,900 --> 01:27:17,600
So this has all the different ones, right?

2085
01:27:17,600 --> 01:27:18,300
That I have here.

2086
01:27:18,700 --> 01:27:22,100
Now, you'll notice there's actually a final thing that I could do

2087
01:27:22,100 --> 01:27:22,500
here.

2088
01:27:22,700 --> 01:27:23,200
Right?

2089
01:27:23,500 --> 01:27:24,800
I could put an else.

2090
01:27:24,800 --> 01:27:27,500
That was like, if none of these were true, it finally does this one

2091
01:27:27,500 --> 01:27:30,800
thing over here right now, and of course, I need to actually type the

2092
01:27:30,800 --> 01:27:31,200
if

2093
01:27:33,100 --> 01:27:34,100
Don't forget that.

2094
01:27:37,600 --> 01:27:40,400
Okay, so assuming you've got that set up this test them.

2095
01:27:40,400 --> 01:27:41,700
All right, it's going to do something here.

2096
01:27:41,700 --> 01:27:43,400
Here, here, here here, here here.

2097
01:27:43,600 --> 01:27:45,200
And I want to write this little more concisely.

2098
01:27:45,200 --> 01:27:49,700
I can write this as a switch statement and I can even do the the final

2099
01:27:49,700 --> 01:27:50,100
else.

2100
01:27:50,200 --> 01:27:53,200
There's a thing called a default case, which is basically the case,

2101
01:27:53,200 --> 01:27:55,700
when none of the things are true.

2102
01:27:56,300 --> 01:27:58,100
And what this basically does is the switch statement.

2103
01:27:58,100 --> 01:28:02,000
Basically jumps to whichever one of these case labels is true.

2104
01:28:02,300 --> 01:28:04,800
And if none of them are true, it jumps to the default, right?

2105
01:28:04,900 --> 01:28:07,200
So it's basically just a more concise way of writing this, but

2106
01:28:07,800 --> 01:28:13,800
It's important to remember that it only does the jump for you only the

2107
01:28:13,800 --> 01:28:14,300
jump.

2108
01:28:14,700 --> 01:28:17,400
So for example, if the thing that I was trying to do is this

2109
01:28:22,600 --> 01:28:23,100
Right.

2110
01:28:23,400 --> 01:28:24,300
This is what I've got.

2111
01:28:24,900 --> 01:28:26,200
I'm going to print out.

2112
01:28:31,600 --> 01:28:33,000
So, I basically got all the cases here.

2113
01:28:33,000 --> 01:28:38,500
I've got six, five, four, three, two, and one, right?

2114
01:28:38,500 --> 01:28:42,200
And X is equal to 3, so we would expect to do our x equals three test.

2115
01:28:42,200 --> 01:28:44,400
We'd expect to print that out, right?

2116
01:28:44,800 --> 01:28:45,500
Well.

2117
01:28:46,800 --> 01:28:50,700
If I go in here and do exactly the same thing with my switch

2118
01:28:50,700 --> 01:28:51,600
statement, right?

2119
01:28:51,600 --> 01:28:53,800
You can see it is definitely more concise.

2120
01:28:53,800 --> 01:28:58,900
But if I do this and expect it to work, I will be in for a little bit

2121
01:28:58,900 --> 01:28:59,700
of a surprise.

2122
01:28:59,900 --> 01:29:03,000
So we run this code will compile it first.

2123
01:29:03,100 --> 01:29:04,300
Make sure we don't got any errors.

2124
01:29:04,300 --> 01:29:06,400
Okay, so I jump in here.

2125
01:29:06,400 --> 01:29:09,100
I've got x equal to 3 test, it zero.

2126
01:29:09,100 --> 01:29:09,900
It's not zero.

2127
01:29:09,900 --> 01:29:10,700
I test it, 21.

2128
01:29:10,700 --> 01:29:11,900
It's not one tested to to.

2129
01:29:11,900 --> 01:29:13,200
It's not to adjust the 3.

2130
01:29:13,400 --> 01:29:14,200
It is 3.

2131
01:29:14,400 --> 01:29:16,200
It outputs three ifs work just

2132
01:29:16,400 --> 01:29:18,300
We thought they were just the way I describe them really in the

2133
01:29:18,300 --> 01:29:18,700
Stream.

2134
01:29:18,700 --> 01:29:19,800
Everybody's happy.

2135
01:29:20,300 --> 01:29:22,600
I come down to the switch statement X.

2136
01:29:22,800 --> 01:29:25,800
Of course, I can look at Exit still three right?

2137
01:29:25,800 --> 01:29:26,400
There it is.

2138
01:29:26,800 --> 01:29:30,300
And if I do my switch jump, I jump right to case 3 and I'm super

2139
01:29:30,300 --> 01:29:30,600
happy.

2140
01:29:30,600 --> 01:29:33,000
It's going to print case 3 every with everything's great.

2141
01:29:33,700 --> 01:29:36,800
But what happens now it prints case for it.

2142
01:29:36,800 --> 01:29:40,000
Prints case, 5, it creates cayde-6 and it prints the default case.

2143
01:29:41,000 --> 01:29:41,600
What's going on?

2144
01:29:42,100 --> 01:29:45,600
Well, the answer is, like I said, switch is just a jump.

2145
01:29:45,800 --> 01:29:48,800
It just jumps to the case that it was supposed to do.

2146
01:29:48,800 --> 01:29:52,900
It doesn't stop executing after it does, the jump.

2147
01:29:52,900 --> 01:29:54,700
So it'll just keep on keeping on.

2148
01:29:54,800 --> 01:29:58,100
So You Again, you've got this break statement, but I was talking about

2149
01:29:58,100 --> 01:29:59,800
the exits Loops break can.

2150
01:30:00,000 --> 01:30:01,700
Will be used to break out of a switch.

2151
01:30:01,700 --> 01:30:06,200
And what that does is it jumps out to after the controlling block of

2152
01:30:06,200 --> 01:30:09,300
the switch after the sort of the curly braces that in closed the

2153
01:30:09,300 --> 01:30:10,400
switch, right?

2154
01:30:11,400 --> 01:30:14,000
So what I want to do is I want to put a break statement in each of

2155
01:30:14,000 --> 01:30:17,900
these so that after it's done it will actually go out.

2156
01:30:17,900 --> 01:30:21,300
So now if I run my code it'll do the same in both cases.

2157
01:30:21,500 --> 01:30:22,500
It'll come through here.

2158
01:30:22,500 --> 01:30:26,200
It'll execute the case 3 and we'll jump to case three, execute.

2159
01:30:26,200 --> 01:30:26,900
It'll jump out.

2160
01:30:26,900 --> 01:30:29,900
So both of my things from case 3, which is what I

2161
01:30:30,000 --> 01:30:30,600
I wanted.

2162
01:30:30,600 --> 01:30:31,000
Okay.

2163
01:30:31,400 --> 01:30:32,000
So there you go.

2164
01:30:32,800 --> 01:30:34,400
So it's pretty simple, switch statement.

2165
01:30:34,400 --> 01:30:37,200
And you can even use this to your advantage if you want to.

2166
01:30:37,200 --> 01:30:40,600
Let's say, you want to do something in case one like, let's say, case

2167
01:30:40,600 --> 01:30:44,100
one actually looked like this for some reason, or actually shoots a

2168
01:30:44,100 --> 01:30:46,100
case 3, because that's what we're on right now.

2169
01:30:46,300 --> 01:30:50,000
So, let's say case, three, actually also did the stuff from case for

2170
01:30:50,300 --> 01:30:50,900
right?

2171
01:30:51,100 --> 01:30:54,600
Well, if that was the case, I could just eliminate this break and now

2172
01:30:54,600 --> 01:30:56,000
we're good to go often times.

2173
01:30:56,000 --> 01:30:58,500
People will put a comment in here so that, you know, that was

2174
01:30:58,500 --> 01:30:59,800
intentional, this false.

2175
01:31:00,000 --> 01:31:00,400
True.

2176
01:31:00,900 --> 01:31:03,400
Because it is kind of common for people to forget to put the break

2177
01:31:03,400 --> 01:31:04,800
statement in as a bug.

2178
01:31:05,800 --> 01:31:08,600
And so you kind of typically want to let people know, but in that

2179
01:31:08,600 --> 01:31:11,700
case, you get sort of the drop through for free.

2180
01:31:11,700 --> 01:31:12,500
So, here we go.

2181
01:31:12,500 --> 01:31:13,100
We present.

2182
01:31:13,100 --> 01:31:14,300
We do three and four.

2183
01:31:14,300 --> 01:31:17,700
We jump in produce, three produce for and then we break out, right?

2184
01:31:17,900 --> 01:31:18,700
So that's what

2185
01:31:19,800 --> 01:31:20,000
What?

2186
01:31:20,000 --> 01:31:20,600
You'd expect?

2187
01:31:20,800 --> 01:31:22,400
So that is the switch statement.

2188
01:31:22,600 --> 01:31:23,000
Okay.

2189
01:31:23,400 --> 01:31:24,500
Final thing.

2190
01:31:24,900 --> 01:31:29,400
I want to talk about on this stream, I think and this is going to be

2191
01:31:29,400 --> 01:31:30,800
the last dream since the main cast.

2192
01:31:30,800 --> 01:31:33,200
So, there's a couple things I didn't get to, I didn't really get to

2193
01:31:33,200 --> 01:31:36,600
dereference operator, which is we sort of kind of did a little bit but

2194
01:31:36,600 --> 01:31:39,800
not much and I didn't get to two's complement.

2195
01:31:39,800 --> 01:31:41,400
So maybe we'll try to do them in the Q&A.

2196
01:31:41,400 --> 01:31:41,700
I don't know.

2197
01:31:41,700 --> 01:31:42,200
We'll see.

2198
01:31:42,400 --> 01:31:45,100
But in the mainstream, I think I mean I think in this dream we're

2199
01:31:45,100 --> 01:31:46,100
going to wrap it up soon.

2200
01:31:47,600 --> 01:31:49,500
The last thing I want to talk about is I haven't

2201
01:31:49,600 --> 01:31:51,900
Really discussed blocks out, right?

2202
01:31:51,900 --> 01:31:55,200
I just kind of introduced them at the beginning and kind of showed you

2203
01:31:55,200 --> 01:31:55,800
them here.

2204
01:31:55,800 --> 01:31:58,200
We did a bunch of them with the loop bodies and stuff and you've seen

2205
01:31:58,200 --> 01:32:02,500
all these curly braces, but I never really outright said what goes on

2206
01:32:02,500 --> 01:32:07,400
with a block and the answer is a block, is basically a logical part of

2207
01:32:07,400 --> 01:32:10,800
the program that does have flow control implications.

2208
01:32:10,800 --> 01:32:13,800
Usually, if there's something preceding it, like, an, if because like

2209
01:32:13,800 --> 01:32:17,400
within AF, this logical block, here doesn't get executed, if the, if

2210
01:32:17,400 --> 01:32:17,900
isn't true.

2211
01:32:17,900 --> 01:32:19,400
So, oftentimes, there's an attached

2212
01:32:19,500 --> 01:32:21,900
Piece of control flow or like a function, right?

2213
01:32:21,900 --> 01:32:25,500
This is an attached piece of control that says this block only occurs

2214
01:32:25,500 --> 01:32:29,000
when this function is called so blocks encapsulate code.

2215
01:32:29,500 --> 01:32:32,500
They sort of bundle it up in a way that it only gets run.

2216
01:32:32,500 --> 01:32:36,900
If a particular piece of code, control flow is true, but they have

2217
01:32:36,900 --> 01:32:37,800
some other properties.

2218
01:32:37,800 --> 01:32:41,100
One is that variables, declared inside them, right?

2219
01:32:41,100 --> 01:32:43,500
And I'm going to go ahead and actually Vape all this right now.

2220
01:32:44,800 --> 01:32:47,900
Goodbye, variables declared inside them.

2221
01:32:47,900 --> 01:32:52,400
So if I say it, y equals 5 and then I open a block because I don't

2222
01:32:52,400 --> 01:32:54,900
even have to put control flow there, but I could, let's say this way.

2223
01:32:54,900 --> 01:32:59,700
If I can assign variables declare inside them, do not exist outside

2224
01:32:59,700 --> 01:32:59,800
it.

2225
01:33:00,000 --> 01:33:00,200
Right.

2226
01:33:00,200 --> 01:33:04,100
So if I do this, I will get a big old nasty War an error.

2227
01:33:04,300 --> 01:33:07,000
And basically what it says is X is an Undeclared.

2228
01:33:07,000 --> 01:33:07,600
Identifier.

2229
01:33:07,700 --> 01:33:08,200
Well, what do you mean?

2230
01:33:08,200 --> 01:33:09,000
I declared it right here.

2231
01:33:09,000 --> 01:33:10,100
Well, no, you didn't.

2232
01:33:10,100 --> 01:33:14,400
Because a block basically captures all of its variables for only

2233
01:33:14,400 --> 01:33:14,900
itself.

2234
01:33:14,900 --> 01:33:19,200
Nothing can come outside of this nested blocks blocks that are inside

2235
01:33:19,300 --> 01:33:21,200
can reference X just fine, right?

2236
01:33:21,200 --> 01:33:21,800
That's fine.

2237
01:33:22,000 --> 01:33:27,700
So anything that I do in an outside block will totally work, but oh

2238
01:33:27,700 --> 01:33:28,900
well guess I got to delete

2239
01:33:29,600 --> 01:33:32,800
This guy first that will totally work, and that's fine.

2240
01:33:32,900 --> 01:33:36,600
But things outside, if that block occurs somewhere else outside in the

2241
01:33:36,600 --> 01:33:37,200
program.

2242
01:33:37,400 --> 01:33:39,300
That is an error and that's no good.

2243
01:33:40,000 --> 01:33:41,000
So, yeah, so there you go.

2244
01:33:41,300 --> 01:33:44,600
And again, the indentation doesn't actually matter here that

2245
01:33:44,600 --> 01:33:47,000
indentation is just syntax syntactic.

2246
01:33:47,500 --> 01:33:48,300
It's not syntactic sugar.

2247
01:33:48,300 --> 01:33:49,800
It's just formatting.

2248
01:33:50,000 --> 01:33:51,400
That is C, programmers use.

2249
01:33:51,400 --> 01:33:54,300
So they can see what's inside but block, but it's really only the

2250
01:33:54,300 --> 01:33:55,200
blocks that matter.

2251
01:33:55,300 --> 01:33:58,800
So, for example, I could easily just write the code, like this, if I

2252
01:33:58,800 --> 01:33:59,300
wanted to force.

2253
01:33:59,400 --> 01:34:02,300
Amazing, that could just be my code.

2254
01:34:02,400 --> 01:34:04,700
It doesn't matter where the in, it's not like python where you have to

2255
01:34:04,700 --> 01:34:07,000
have indents in a certain way or anything like that.

2256
01:34:07,000 --> 01:34:08,600
It just it doesn't care at all.

2257
01:34:08,600 --> 01:34:09,400
It's fine.

2258
01:34:10,000 --> 01:34:11,800
So what happens with blocks?

2259
01:34:12,900 --> 01:34:15,300
Is there basically like the stack thing that I was talking about

2260
01:34:15,300 --> 01:34:16,200
before where I sang?

2261
01:34:16,200 --> 01:34:18,600
That's where variables live and they get pushed on the stack and then

2262
01:34:18,600 --> 01:34:19,600
pulled off the stack.

2263
01:34:19,600 --> 01:34:23,500
Well, you can basically think of blocks as sort of being having their

2264
01:34:23,500 --> 01:34:28,600
own sort of Stack implication when I enter a block by the time that I

2265
01:34:28,600 --> 01:34:31,000
get into that block and start doing stuff.

2266
01:34:31,300 --> 01:34:35,300
It is incumbent upon the compiler, to have pushed the space to have

2267
01:34:35,300 --> 01:34:38,800
made space, on the stack, for these variables that are in the block.

2268
01:34:38,800 --> 01:34:42,000
So, if I start doing stuff with variables in this block, by the time I

2269
01:34:42,000 --> 01:34:42,500
start executing

2270
01:34:42,700 --> 01:34:46,500
Code in there or doing whatever this stuff needs to be on the stack

2271
01:34:46,500 --> 01:34:48,800
and live and I can do stuff with it.

2272
01:34:48,900 --> 01:34:53,300
But once I get to the end it is no longer incumbent upon the compiler

2273
01:34:53,300 --> 01:34:56,400
or the operating system to keep those things valid.

2274
01:34:56,400 --> 01:35:00,700
So, as soon as you exit a block, it is entirely legal for the stuff

2275
01:35:00,700 --> 01:35:02,900
that you were working with to just disappear, right?

2276
01:35:02,900 --> 01:35:03,900
It can just be gone.

2277
01:35:04,100 --> 01:35:06,800
Now, oftentimes it's not actually gone because you could still access

2278
01:35:06,800 --> 01:35:09,400
it because it still the memory is still there and hasn't gotten like

2279
01:35:09,400 --> 01:35:12,100
overwritten or trash or anything yet, but the but if you were to use

2280
01:35:12,100 --> 01:35:12,500
it,

2281
01:35:12,600 --> 01:35:16,100
That would be a big source of potential bugs because the compiler is

2282
01:35:16,100 --> 01:35:21,000
no longer under any any restriction to keep that space used for what

2283
01:35:21,000 --> 01:35:21,600
you told it to be.

2284
01:35:21,600 --> 01:35:24,300
So it could just go use it for something else and then you got a bad

2285
01:35:24,300 --> 01:35:25,800
bug because you're trying to use something.

2286
01:35:26,000 --> 01:35:27,200
Now, you may ask me.

2287
01:35:27,400 --> 01:35:29,900
Well, Casey you just said that you can't refer to it.

2288
01:35:29,900 --> 01:35:31,200
I just saw you.

2289
01:35:31,400 --> 01:35:31,800
Right?

2290
01:35:31,800 --> 01:35:33,100
Basically do this.

2291
01:35:33,400 --> 01:35:37,700
Okay, and when you did it, you couldn't even compile the program.

2292
01:35:38,000 --> 01:35:39,600
So the question is, what are you talking about?

2293
01:35:39,600 --> 01:35:40,300
What do you mean?

2294
01:35:40,300 --> 01:35:41,500
I could reference it.

2295
01:35:41,500 --> 01:35:42,400
Well remember,

2296
01:35:42,700 --> 01:35:45,400
He allows you to do a lot of direct stuff with memory.

2297
01:35:45,400 --> 01:35:48,900
So maybe I Define a pointer, right?

2298
01:35:48,900 --> 01:35:50,900
And that pointer doesn't point to anything at first.

2299
01:35:50,900 --> 01:35:55,000
But in here, this pointer equals the address of X, right.

2300
01:35:55,800 --> 01:35:59,100
Well, now, when I get out here, I can actually do stuff with that.

2301
01:35:59,300 --> 01:35:59,800
Oh, and hey, this

2302
01:36:00,000 --> 01:36:03,000
The opportunity to talk about that dereference operator, actually, who

2303
01:36:03,000 --> 01:36:03,700
this is going to be good.

2304
01:36:03,700 --> 01:36:04,400
This is gonna be good.

2305
01:36:04,400 --> 01:36:05,500
This is good Sunday stream.

2306
01:36:06,500 --> 01:36:07,700
We'll talk about that in one second.

2307
01:36:07,800 --> 01:36:11,200
So, if I were to take the address of X, like, we've been doing for

2308
01:36:11,200 --> 01:36:14,300
this whole stream, right, to take the address where and memory X is

2309
01:36:14,600 --> 01:36:17,500
this pointer was declared in the outer scope.

2310
01:36:18,200 --> 01:36:20,500
These blocks typically are often referred to as scope.

2311
01:36:20,500 --> 01:36:23,600
It's like basically where you can, you know where variables are valid

2312
01:36:23,600 --> 01:36:25,900
to reference and where they're not is often called scope.

2313
01:36:26,300 --> 01:36:29,100
I don't actually know why, but it often is so, but anyway, it's in

2314
01:36:29,100 --> 01:36:29,800
declared in the outer.

2315
01:36:30,000 --> 01:36:33,000
I block this pointer is clear and the other block, which means I can

2316
01:36:33,000 --> 01:36:36,000
reference it anywhere in the outer block, right?

2317
01:36:36,000 --> 01:36:39,100
So if I want to, I can snap the address of X, I can find out what the

2318
01:36:39,100 --> 01:36:40,100
address of X is while.

2319
01:36:40,100 --> 01:36:43,000
I'm in this Scope, when I get out of the scope, when I got to the

2320
01:36:43,000 --> 01:36:47,900
block X goes away potentially, but I've still got its address so I can

2321
01:36:47,900 --> 01:36:50,400
go ahead and write to it all I want, right?

2322
01:36:50,500 --> 01:36:54,200
And so when I go ahead and compile this, it compiles just fine, right?

2323
01:36:54,200 --> 01:36:57,800
And what happens is when I go in here, you will see I will take the

2324
01:36:57,800 --> 01:36:59,400
address of X, right.

2325
01:37:00,200 --> 01:37:01,800
And now I know where X is.

2326
01:37:02,000 --> 01:37:04,900
I know exactly where Exodus goes, wherever it was pointed to write.

2327
01:37:05,000 --> 01:37:06,600
That is the actually value of x.

2328
01:37:06,600 --> 01:37:07,400
It was set to 6.

2329
01:37:07,400 --> 01:37:08,800
It's still set to 6, right?

2330
01:37:08,800 --> 01:37:12,500
Even though the compiler is not under any obligation to keep that

2331
01:37:12,500 --> 01:37:14,400
space available, can use it for something else.

2332
01:37:14,700 --> 01:37:15,500
I can write to it.

2333
01:37:15,500 --> 01:37:16,100
And Bam.

2334
01:37:16,300 --> 01:37:18,600
I just wrote 2x, even though it's out of the scope.

2335
01:37:19,000 --> 01:37:20,200
Totally not.

2336
01:37:20,200 --> 01:37:21,300
You should never do it.

2337
01:37:21,300 --> 01:37:23,700
It's just asking for disaster.

2338
01:37:24,000 --> 01:37:28,100
But like I said, everything in C is just happening in the memory.

2339
01:37:28,100 --> 01:37:29,800
It's direct their you.

2340
01:37:30,000 --> 01:37:30,900
Go to town on it.

2341
01:37:30,900 --> 01:37:35,000
And if you want to create bad bugs, waiting to happen for yourself,

2342
01:37:35,000 --> 01:37:35,700
you can.

2343
01:37:36,200 --> 01:37:39,700
So I just wanted to kind of underscore the fact that this is sort of

2344
01:37:39,700 --> 01:37:41,200
stuff that helps to protect you.

2345
01:37:42,300 --> 01:37:45,800
This sort of scoping where you were, you wrapped variables inside

2346
01:37:45,800 --> 01:37:49,700
Scopes and they go out of scope is to help you not make mistakes.

2347
01:37:49,900 --> 01:37:52,700
And when you're doing stuff like this, you're basically just asking

2348
01:37:52,700 --> 01:37:53,400
for trouble.

2349
01:37:53,500 --> 01:37:57,200
There's almost never any reason to do what I am showing you here, but

2350
01:37:57,200 --> 01:37:59,800
the point is, it is possible because it's all about memory.

2351
01:37:59,900 --> 01:38:03,100
And this got some memory at some point and that memory hasn't been

2352
01:38:03,100 --> 01:38:06,300
freed yet or marked as inaccessible by the operating system so we can

2353
01:38:06,300 --> 01:38:08,200
just keep on writing to it and it works.

2354
01:38:08,900 --> 01:38:12,500
So the thing that I wasn't going to cover today, it turns out that I

2355
01:38:12,500 --> 01:38:14,200
am because I just used it to show you something.

2356
01:38:14,400 --> 01:38:17,200
Super naughty is this star.

2357
01:38:17,800 --> 01:38:19,900
So, like I said, star is normally math.

2358
01:38:20,000 --> 01:38:21,800
If I do x times y, right?

2359
01:38:21,800 --> 01:38:23,000
That just means multiplication.

2360
01:38:23,100 --> 01:38:27,100
So, if I do, you know, y equals x times y, I want to do x times Y and

2361
01:38:27,100 --> 01:38:29,700
I want to assign it to why that's all fine, right?

2362
01:38:30,000 --> 01:38:32,900
The star has another meaning when it appears as just a prefix.

2363
01:38:33,100 --> 01:38:36,600
So when it isn't x times pointer, if it's just pointer, right?

2364
01:38:36,600 --> 01:38:39,200
And I can even wrap it in parentheses, to make sure that even if there

2365
01:38:39,200 --> 01:38:41,300
was an X out here, it wasn't going to do anything or whatever.

2366
01:38:41,300 --> 01:38:41,700
Right?

2367
01:38:42,100 --> 01:38:46,400
So I've got, you know, this thing, what that means is I'm talking

2368
01:38:46,400 --> 01:38:51,100
about the thing that this points to, it's a pointer.

2369
01:38:51,300 --> 01:38:54,700
So I want you to do the operation as if you have the thing.

2370
01:38:54,700 --> 01:38:56,000
It was pointing to here.

2371
01:38:56,200 --> 01:38:59,200
So this is pointing to X and I want to operate on X.

2372
01:38:59,200 --> 01:38:59,600
So,

2373
01:39:00,000 --> 01:39:03,800
Turns it into X essentially, it turns it into the memory location that

2374
01:39:03,800 --> 01:39:05,100
X was, right.

2375
01:39:05,300 --> 01:39:08,800
So basically if I have n star pointer and then I refer to Star

2376
01:39:08,800 --> 01:39:12,600
pointer, it's essentially the same as taking the Declaration of what

2377
01:39:12,600 --> 01:39:16,400
star pointer was removing the star from it and then, whatever that is

2378
01:39:16,400 --> 01:39:17,100
is what you have left.

2379
01:39:17,100 --> 01:39:18,300
So in this case, it's an ENT.

2380
01:39:18,300 --> 01:39:23,800
So star pointer is the nth at the address contained in pointer, right?

2381
01:39:23,900 --> 01:39:26,900
So if I took an address of an INT and stick it in pointer, which is

2382
01:39:26,900 --> 01:39:29,800
what I did, I took the address of X then from then on.

2383
01:39:30,000 --> 01:39:33,900
Star pointer refers to what's in that location, and so for example, if

2384
01:39:33,900 --> 01:39:36,100
I wanted to get it out, right?

2385
01:39:37,200 --> 01:39:38,000
So, I do this.

2386
01:39:40,800 --> 01:39:41,200
Right.

2387
01:39:41,300 --> 01:39:42,700
I want to know what was the next?

2388
01:39:42,800 --> 01:39:45,000
Well, I can't refer to X because it's out of the scope.

2389
01:39:45,000 --> 01:39:46,200
The block we left that block.

2390
01:39:46,200 --> 01:39:46,700
It's gone.

2391
01:39:46,900 --> 01:39:49,800
Well, I can still, just go ahead and get it and I can put it in y

2392
01:39:49,800 --> 01:39:50,500
because y.

2393
01:39:50,500 --> 01:39:54,000
Right is set to 5 right now but X was set to six, bam.

2394
01:39:54,100 --> 01:39:55,100
I just accessed it.

2395
01:39:55,300 --> 01:39:58,700
There's a six and so all that's doing is basically the stack.

2396
01:39:58,700 --> 01:40:00,600
It's just going into the stack and do a location.

2397
01:40:00,600 --> 01:40:01,900
That's not supposed to be used anymore.

2398
01:40:01,900 --> 01:40:03,700
But I know it the value still in there.

2399
01:40:03,900 --> 01:40:06,200
I know it's in there because the program hasn't done anything else.

2400
01:40:06,200 --> 01:40:06,700
Right?

2401
01:40:06,900 --> 01:40:07,700
So I know it's still in there.

2402
01:40:07,700 --> 01:40:09,600
So I just grabbed it out and I can do that.

2403
01:40:09,600 --> 01:40:10,400
That's totally legal.

2404
01:40:11,300 --> 01:40:13,000
And the dereference operator can get nuts.

2405
01:40:13,000 --> 01:40:14,400
If you want to write.

2406
01:40:14,500 --> 01:40:16,800
I could do something that's like a pointer to a pointer.

2407
01:40:17,000 --> 01:40:17,500
Right?

2408
01:40:18,300 --> 01:40:21,200
It's a pointer pointer and I can take that and make the pointer

2409
01:40:21,200 --> 01:40:23,100
pointer be equal to the address of the pointer.

2410
01:40:23,100 --> 01:40:26,000
So now I'm pointing to the pointer that's pointing to X.

2411
01:40:26,100 --> 01:40:26,700
Right?

2412
01:40:26,900 --> 01:40:28,900
And I can go ahead and get it out.

2413
01:40:28,900 --> 01:40:29,500
That way.

2414
01:40:29,500 --> 01:40:32,000
I can dereference it twice right again.

2415
01:40:32,000 --> 01:40:33,700
Full banana cakes for a Sunday stream.

2416
01:40:33,800 --> 01:40:34,600
Why not?

2417
01:40:34,700 --> 01:40:36,500
Bam got it out.

2418
01:40:36,500 --> 01:40:40,600
And so the dereference operator basically chases the pointer it says

2419
01:40:40,800 --> 01:40:44,100
Go to where this pointer points and I'm talking about that now.

2420
01:40:44,300 --> 01:40:46,600
And if I do that and I want to do it again, I can just go.

2421
01:40:46,600 --> 01:40:49,100
Okay, that thing you were pointing to that's a pointer.

2422
01:40:49,100 --> 01:40:52,000
So go find with that was pointing to and it all just works.

2423
01:40:52,000 --> 01:40:52,500
Right?

2424
01:40:52,500 --> 01:40:53,100
So you can do that.

2425
01:40:53,100 --> 01:40:54,100
You can have as many as you want.

2426
01:40:54,100 --> 01:40:56,000
You can have pointers to pointers to pointers to pointers.

2427
01:40:56,200 --> 01:40:57,800
You can have pointers to structure with pointers in them.

2428
01:40:57,800 --> 01:40:59,500
The point to other structs that more pointers in them.

2429
01:40:59,500 --> 01:41:00,700
You can chase them all day long.

2430
01:41:00,800 --> 01:41:03,100
That's how you build data structures often linked list or pointers

2431
01:41:03,100 --> 01:41:05,300
that point to structure that pointers that point to the next one.

2432
01:41:05,300 --> 01:41:06,000
The point to the next one.

2433
01:41:06,000 --> 01:41:07,200
That point, the next one to bite the next one.

2434
01:41:07,200 --> 01:41:10,100
You want to walk the list, you go through all the pointers just point.

2435
01:41:10,100 --> 01:41:10,600
Point point point.

2436
01:41:10,700 --> 01:41:11,700
Point right.

2437
01:41:14,900 --> 01:41:16,000
So, that syntax.

2438
01:41:17,400 --> 01:41:19,900
That I used in a previous stream right?

2439
01:41:20,200 --> 01:41:23,000
Where I had a struct and I said, oh, there was a pointer and I

2440
01:41:23,000 --> 01:41:27,200
referenced some member of the struct essentially that is just the same

2441
01:41:27,200 --> 01:41:28,200
as dereferencing.

2442
01:41:28,200 --> 01:41:30,900
The pointer, the way that I just showed you how to do it and then

2443
01:41:30,900 --> 01:41:31,800
putting the dot.

2444
01:41:32,300 --> 01:41:34,700
And so another way to look at that whole dot, arrow thing that I

2445
01:41:34,700 --> 01:41:39,300
saying is like it's kind of janky is basically like The Arrow is sort

2446
01:41:39,300 --> 01:41:42,100
of like saying dereference the pointer first.

2447
01:41:42,100 --> 01:41:43,600
Then do the dot thing.

2448
01:41:44,600 --> 01:41:45,400
That makes sense.

2449
01:41:46,300 --> 01:41:46,900
So, there you go.

2450
01:41:49,000 --> 01:41:55,100
Last thing when you open a new scope, you can Shadow a variable and I

2451
01:41:55,100 --> 01:41:57,500
snuck it in here, but I don't know if anyone caught it.

2452
01:41:57,700 --> 01:41:59,300
There's some eagle eyes on the stream.

2453
01:41:59,600 --> 01:41:59,800
So

2454
01:42:00,100 --> 01:42:01,800
I assume that they probably did.

2455
01:42:02,500 --> 01:42:06,300
But basically, what happens is if you have two variables called why

2456
01:42:06,800 --> 01:42:07,300
normally?

2457
01:42:07,300 --> 01:42:08,800
That'd be an error, right?

2458
01:42:08,900 --> 01:42:11,200
Normally if I did this, that's not going to compile.

2459
01:42:11,300 --> 01:42:17,000
It says you have redefinitions of why, but you can always Shadow a

2460
01:42:17,000 --> 01:42:21,000
variable by declaring a new one in a scope inside the outer scope.

2461
01:42:21,000 --> 01:42:23,300
So if I make a new block, inside an old block,

2462
01:42:24,400 --> 01:42:27,700
That block can define y again and it's a different.

2463
01:42:27,800 --> 01:42:28,300
Why?

2464
01:42:29,900 --> 01:42:30,400
What if you didn't know?

2465
01:42:30,400 --> 01:42:30,900
It was a different.

2466
01:42:30,900 --> 01:42:31,300
Why?

2467
01:42:31,600 --> 01:42:35,000
I just told you how you could determine that actually, right?

2468
01:42:35,100 --> 01:42:35,800
Let's do it.

2469
01:42:36,500 --> 01:42:39,200
Here is why pointer zero?

2470
01:42:40,400 --> 01:42:42,800
And here is why pointer one.

2471
01:42:44,300 --> 01:42:46,900
Let's go ahead and make y pointer zero.

2472
01:42:48,200 --> 01:42:50,000
Equal to the address of this Y.

2473
01:42:50,300 --> 01:42:54,300
And we'll make why pointer 1 equal to the address of this y.

2474
01:42:54,600 --> 01:42:56,800
Now, if they were the same, that means that the same why, if they're

2475
01:42:56,800 --> 01:42:58,500
different, their means are plenty of different memory locations.

2476
01:42:58,500 --> 01:42:59,100
So they're different.

2477
01:42:59,100 --> 01:42:59,500
Why?

2478
01:42:59,800 --> 01:43:00,000
Right?

2479
01:43:00,000 --> 01:43:02,400
Because it's all about memory, if these things are in different

2480
01:43:02,400 --> 01:43:02,800
places.

2481
01:43:02,800 --> 01:43:03,500
They're not the same.

2482
01:43:03,500 --> 01:43:03,900
Why?

2483
01:43:03,900 --> 01:43:05,400
They're just two names that point.

2484
01:43:05,400 --> 01:43:07,400
A different memory locations such as happen to both of you.

2485
01:43:07,400 --> 01:43:08,900
I well, let's see what they are.

2486
01:43:09,600 --> 01:43:10,600
So what do we got?

2487
01:43:11,600 --> 01:43:12,500
Why point is 0?

2488
01:43:13,100 --> 01:43:15,200
Y pointer one different.

2489
01:43:15,500 --> 01:43:15,800
Right?

2490
01:43:15,800 --> 01:43:16,600
Not the same value.

2491
01:43:16,600 --> 01:43:17,800
Fa e 4f a

2492
01:43:18,000 --> 01:43:21,300
Before, and that's how you know that they are actually in different

2493
01:43:21,300 --> 01:43:21,600
places.

2494
01:43:21,600 --> 01:43:26,600
So this made a new Y and that is the only time it is legal to do that.

2495
01:43:26,600 --> 01:43:27,100
Shadowing.

2496
01:43:27,100 --> 01:43:28,300
You have to open a new block.

2497
01:43:28,300 --> 01:43:32,900
Like I said, you can't Shadow a variable by declaring a new y, in the

2498
01:43:32,900 --> 01:43:36,000
same block as someone already declared Ally, right?

2499
01:43:36,100 --> 01:43:36,900
That's not allowed.

2500
01:43:38,200 --> 01:43:39,800
So let me look over my list.

2501
01:43:39,800 --> 01:43:41,000
Really briefly here.

2502
01:43:41,000 --> 01:43:42,600
Is there anything else I want to go over?

2503
01:43:42,600 --> 01:43:44,200
I think I'm going to skip, two's complement.

2504
01:43:44,200 --> 01:43:44,800
Sorry, guys.

2505
01:43:46,000 --> 01:43:48,300
Looks like looks like I got just about everything.

2506
01:43:48,800 --> 01:43:52,200
So I think that is it for our test streaming.

2507
01:43:52,600 --> 01:43:54,900
It has been very productive.

2508
01:43:55,200 --> 01:43:56,900
This was a crazy Sunday stream.

2509
01:43:57,700 --> 01:44:02,500
I am going to stop the stream now and we are going to go on to the Q&A

2510
01:44:02,500 --> 01:44:05,800
in a section in a session in a second here.

2511
01:44:06,600 --> 01:44:07,800
But first, let me say thank

2512
01:44:07,900 --> 01:44:09,400
You so much everyone for showing up.

2513
01:44:09,400 --> 01:44:10,800
We've had so many people on the stream.

2514
01:44:10,800 --> 01:44:14,500
We had 300 people today almost 400 at one point looked like to, that's

2515
01:44:14,500 --> 01:44:16,100
a lot of people watching the stream.

2516
01:44:16,300 --> 01:44:19,300
So thank you so much for helping me test out the streaming.

2517
01:44:19,800 --> 01:44:22,100
I think it'll, it's going to make a huge difference when we actually

2518
01:44:22,100 --> 01:44:25,500
start the proper stream on Monday having the having a me practice

2519
01:44:25,500 --> 01:44:26,200
doing this.

2520
01:44:26,300 --> 01:44:30,300
But be we've also had like a ton of people who have, you know, sort of

2521
01:44:31,100 --> 01:44:33,100
written in and told me things to do that.

2522
01:44:33,100 --> 01:44:36,200
We're really beneficial like for example, stuff that I need to set on

2523
01:44:36,200 --> 01:44:37,700
Twitch and how

2524
01:44:37,900 --> 01:44:40,300
How to you know, like making the font size bigger, all that sort of

2525
01:44:40,300 --> 01:44:41,200
stuff would have been stuff.

2526
01:44:41,200 --> 01:44:44,000
We'd have to work out in the middle of the mainstream and we've gotten

2527
01:44:44,000 --> 01:44:44,800
a lot of that stuff.

2528
01:44:45,000 --> 01:44:48,300
Sort of squared away now which makes a huge huge difference.

2529
01:44:48,300 --> 01:44:51,400
I think when we actually start on Monday, so thank you everyone for

2530
01:44:51,400 --> 01:44:52,300
all that help.

2531
01:44:52,500 --> 01:44:54,000
I will see you in the Q&A.

2532
01:44:54,100 --> 01:44:59,700
If you are interested, and if not, I will see you on Monday for the

2533
01:44:59,700 --> 01:45:03,400
very first actual game coding stream, which I think will be a lot of

2534
01:45:03,400 --> 01:45:03,800
fun.

2535
01:45:03,900 --> 01:45:07,700
So, thanks very much for joining us and I will see you in a second.

2536
01:45:07,900 --> 01:45:08,100
and,

