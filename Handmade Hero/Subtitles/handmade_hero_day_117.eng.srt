1
00:00:01,000 --> 00:00:01,500
There we go.

2
00:00:02,100 --> 00:00:03,900
Hello, everyone and welcome to handmade hero.

3
00:00:03,900 --> 00:00:06,300
The show where we code to complete game live on Twitch.

4
00:00:06,300 --> 00:00:07,900
No Engines new libraries.

5
00:00:08,400 --> 00:00:11,800
This is designed to show the complete process of making a game from

6
00:00:11,800 --> 00:00:15,600
start to finish with every single component and peace.

7
00:00:16,200 --> 00:00:19,600
You know, talked about and shown how we develop it in detail.

8
00:00:19,700 --> 00:00:22,900
And the reason for that is we don't presuppose what kind of a

9
00:00:22,900 --> 00:00:25,400
programmer you are or what kind of thing you're building or what

10
00:00:25,400 --> 00:00:27,600
you're interested in, we show everything.

11
00:00:27,800 --> 00:00:29,800
So if you want to be an engine developer, we do that.

12
00:00:29,800 --> 00:00:30,600
You want to be a gain of

13
00:00:30,700 --> 00:00:32,299
/, we do that.

14
00:00:32,299 --> 00:00:35,000
If you want to, you know, concern yourself, primarily with animation,

15
00:00:35,000 --> 00:00:35,500
we do that.

16
00:00:35,500 --> 00:00:36,900
We try to cover, absolutely everything.

17
00:00:36,900 --> 00:00:41,300
It's sort of like the general generalists course, to game development

18
00:00:41,300 --> 00:00:44,900
and right now we're on a particularly important part of the

19
00:00:44,900 --> 00:00:47,500
programming, which is optimization.

20
00:00:47,500 --> 00:00:50,500
It's the first time we sort of delved into how we make code run

21
00:00:50,500 --> 00:00:54,000
faster, when it doesn't run fast enough and we did a bunch of work

22
00:00:54,000 --> 00:00:57,700
last week and actually made quite a bit of an improvement to the speed

23
00:00:57,700 --> 00:00:58,200
of things.

24
00:00:58,200 --> 00:01:00,600
It's roughly about three times faster, I think

25
00:01:00,700 --> 00:01:03,700
think now than it was when we started even though we haven't really

26
00:01:03,700 --> 00:01:07,400
finished doing the optimizations that we had set out to do, we only

27
00:01:07,400 --> 00:01:11,600
sort of introduced some of the concepts and showed how to do the first

28
00:01:11,600 --> 00:01:15,600
basic part of it and so the more advanced part of it, it's coming a

29
00:01:15,600 --> 00:01:16,100
little later.

30
00:01:16,100 --> 00:01:21,800
But right now we have some some parts that we were trying to do Cindy

31
00:01:21,800 --> 00:01:25,000
optimization to our teen and we have some parts of the routine that we

32
00:01:25,000 --> 00:01:26,100
had not symbolized yet.

33
00:01:26,100 --> 00:01:29,600
Because as I said last week, they are much more complicated to do in

34
00:01:29,600 --> 00:01:30,600
Cindy compared to the

35
00:01:30,800 --> 00:01:31,800
Is that we were doing.

36
00:01:31,900 --> 00:01:35,300
And so what I wanted to start on today is showing you how to do those

37
00:01:35,300 --> 00:01:39,200
more complicated things so that you can start to write the entire

38
00:01:39,200 --> 00:01:42,600
routines and Cindy, not just the interior Math logic.

39
00:01:42,600 --> 00:01:44,000
So that's what we're going to do today.

40
00:01:44,100 --> 00:01:47,300
If you'd like to follow along at home, you can, of course, always

41
00:01:47,300 --> 00:01:48,900
pre-order the game on handmade hero dot-org.

42
00:01:49,300 --> 00:01:52,500
So if you've done that, please make sure you download the source code

43
00:01:52,500 --> 00:01:55,000
and unpack day, 117 Source, zip.

44
00:01:55,000 --> 00:01:56,500
Because that is what I am starting with today.

45
00:01:56,500 --> 00:01:58,500
So, you'll be right in the right place.

46
00:01:58,800 --> 00:02:00,600
If you start with that looks like,

47
00:02:00,700 --> 00:02:02,000
I've already got one of these up.

48
00:02:02,200 --> 00:02:02,900
I guess I did.

49
00:02:03,300 --> 00:02:04,800
CLS that.

50
00:02:04,800 --> 00:02:10,800
All right, so let's load up the code and let's take a look at exactly

51
00:02:10,800 --> 00:02:12,300
what I am talking about.

52
00:02:12,300 --> 00:02:16,500
Here, we have our new routine draw rectangle, hopefully quickly.

53
00:02:16,500 --> 00:02:21,100
And you can see in here that we have done a bunch of Cindy

54
00:02:21,100 --> 00:02:22,600
optimizations on this essentially.

55
00:02:22,600 --> 00:02:26,700
And I'm saying that their optimizations is kind of a hard thing to

56
00:02:26,700 --> 00:02:27,900
say, because it's a little ambiguous.

57
00:02:27,900 --> 00:02:28,800
Yes, it did.

58
00:02:28,800 --> 00:02:29,900
Make our code run a lot faster.

59
00:02:29,900 --> 00:02:33,300
But actually, we didn't really think much about

60
00:02:33,400 --> 00:02:35,100
About optimizing the code really.

61
00:02:35,100 --> 00:02:38,200
All we're doing is we're taking our code for operating on one pixel at

62
00:02:38,200 --> 00:02:40,400
a time and making it optimizes on four pixels at a time.

63
00:02:40,400 --> 00:02:44,600
So it's almost just a translation if you will which is kind of it's

64
00:02:44,600 --> 00:02:46,000
hard to think of it as an optimization.

65
00:02:46,000 --> 00:02:48,400
Now, it happens to make things run a lot faster because operating on

66
00:02:48,400 --> 00:02:51,400
four things at once it fast enough, any one thing it wants but it's

67
00:02:51,400 --> 00:02:54,900
not quite the same as some other concepts of optimization, may think

68
00:02:54,900 --> 00:02:58,200
of where you save some operations operations by, like, not doing

69
00:02:58,200 --> 00:02:59,800
something that you didn't have to do, which

70
00:03:00,200 --> 00:03:03,600
You know, an efficiency gain or reflect changing the way that you're

71
00:03:03,600 --> 00:03:07,000
doing the math, to try to, you know, optimize how the processor is

72
00:03:07,000 --> 00:03:08,000
doing its stuff like that.

73
00:03:08,100 --> 00:03:10,400
We haven't really done anything like that but we're already getting

74
00:03:11,000 --> 00:03:13,600
significantly faster just by doing this translation.

75
00:03:13,600 --> 00:03:18,300
So in some sense, it is optimization just translating it from scalar,

76
00:03:18,300 --> 00:03:21,600
C code to the simply intrinsics that were using

77
00:03:24,900 --> 00:03:30,200
So what I'd like to do today is focus on one part that we have not 70

78
00:03:30,200 --> 00:03:31,700
is now you remember this routine here.

79
00:03:31,700 --> 00:03:35,200
Basically, all of the work is done in this interior Loop here and what

80
00:03:35,200 --> 00:03:39,400
we've done is we symptom Sim deed almost everything except for the

81
00:03:39,400 --> 00:03:44,400
part where we load in textiles and then the part where we write out

82
00:03:44,400 --> 00:03:45,900
pixels, right?

83
00:03:46,400 --> 00:03:50,000
And so what I'd like to do today is take a look at just this part here

84
00:03:50,100 --> 00:03:52,700
where we write out the pixels because as you can see, we then

85
00:03:52,700 --> 00:03:54,100
downshift very dramatic.

86
00:03:54,500 --> 00:03:59,100
From doing everything for wide into doing things in an ugly Loop and

87
00:03:59,100 --> 00:04:01,900
that's not the way we want to do it because we actually have the

88
00:04:01,900 --> 00:04:06,100
option in 70 of doing this in a much smarter way.

89
00:04:06,100 --> 00:04:07,300
So let's go ahead and do that.

90
00:04:10,000 --> 00:04:13,800
Alright, so the first thing that I'm going to do to make it a little

91
00:04:13,800 --> 00:04:17,100
easier on us to start with is I'm going to eliminate part of the

92
00:04:17,100 --> 00:04:21,600
problem so that I can just talk about one of aspect of it and show you

93
00:04:21,600 --> 00:04:24,100
how we're going to solve that and then later we'll

94
00:04:24,200 --> 00:04:24,900
I'll show you.

95
00:04:25,100 --> 00:04:27,700
I'll explain how to solve the rest of it, right?

96
00:04:28,200 --> 00:04:29,100
So here we are.

97
00:04:31,100 --> 00:04:33,400
I'm going to go ahead and comment out this should fill.

98
00:04:34,100 --> 00:04:38,100
And what this is going to do is it's going to always draw to the

99
00:04:38,100 --> 00:04:43,000
buffer even if it is outside the bounds of the, you know, of the

100
00:04:43,000 --> 00:04:46,000
region that should actually have been filled and what you can see

101
00:04:46,000 --> 00:04:50,000
Happening Here, is that depending on that alignment, depending on how

102
00:04:50,000 --> 00:04:53,900
many of the four pixels spill over the edge of the operation, that

103
00:04:53,900 --> 00:04:54,800
supposed to happen.

104
00:04:55,000 --> 00:04:57,700
We get a nice old black bar there.

105
00:04:57,700 --> 00:04:59,900
As we write out stuff that we actually should.

106
00:05:00,000 --> 00:05:00,800
Not have been touching.

107
00:05:00,800 --> 00:05:01,300
Okay.

108
00:05:01,700 --> 00:05:02,600
Now that's totally fine.

109
00:05:02,600 --> 00:05:06,000
Like I said, we will put that back in and fix that little bit later

110
00:05:06,000 --> 00:05:09,200
but what I want to do is take out that aspect of it just for a second

111
00:05:09,600 --> 00:05:14,500
so that you can concentrate on the different sort of the other part of

112
00:05:14,500 --> 00:05:16,800
it, which is just this, right, right.

113
00:05:17,500 --> 00:05:21,100
So what we want to do is we want to concentrate on just this one part

114
00:05:21,100 --> 00:05:23,900
here where we write things out and we want to figure out how to do

115
00:05:23,900 --> 00:05:25,600
that in non-scalar.

116
00:05:25,700 --> 00:05:28,400
Because what we're doing right now is We're looping over this four

117
00:05:28,400 --> 00:05:29,800
times and for each time

118
00:05:29,900 --> 00:05:33,400
we're building out our pixel manually and we don't want to do that

119
00:05:33,400 --> 00:05:33,900
anymore.

120
00:05:34,300 --> 00:05:37,300
All right, so let's flip over to the Blackboard for a second and I'm

121
00:05:37,300 --> 00:05:39,400
going to talk about what the strategy is for.

122
00:05:39,400 --> 00:05:42,300
When you hit something like this, in some decode because this is

123
00:05:42,300 --> 00:05:45,300
typically the part of the Sim decode, that is nastiest.

124
00:05:45,300 --> 00:05:48,900
Okay, the part that we did before was always, I said and I said it

125
00:05:48,900 --> 00:05:52,100
when we did this is much easier because as you can see it looks almost

126
00:05:52,100 --> 00:05:54,200
exactly the same as the code did beforehand.

127
00:05:54,200 --> 00:05:57,900
The only difference is we have changed the mathematical operators in C

128
00:05:57,900 --> 00:05:58,900
into these intrinsic.

129
00:05:58,900 --> 00:05:59,500
So if there is a

130
00:06:00,000 --> 00:06:02,000
We changed it to a function called mul PS.

131
00:06:02,500 --> 00:06:05,100
That just passes the two parameters and that is sufficient to tell the

132
00:06:05,100 --> 00:06:08,600
compiler what to do and we just get our four wide operations happening

133
00:06:08,600 --> 00:06:08,900
for free.

134
00:06:08,900 --> 00:06:12,200
We literally didn't have to think about any of this and you saw when I

135
00:06:12,200 --> 00:06:14,000
did it, it was pretty much a wrote translation.

136
00:06:15,000 --> 00:06:17,400
Well, this part, especially if you've never done it before, but even

137
00:06:17,400 --> 00:06:20,600
if you have, if you're not particularly facile with it, this part is

138
00:06:20,600 --> 00:06:21,800
not a wrote translation.

139
00:06:22,000 --> 00:06:25,200
It's much more difficult than that, because you have to start thinking

140
00:06:25,200 --> 00:06:27,800
about the Cindy lanes and where they go.

141
00:06:28,100 --> 00:06:29,800
So, if you think about what happens,

142
00:06:30,200 --> 00:06:34,600
we have something coming down, are the pipeline, right?

143
00:06:35,800 --> 00:06:38,000
Which looks like this, okay?

144
00:06:38,700 --> 00:06:44,500
It is a sort of a set, you know, Cindy register or a Cindy value, we

145
00:06:44,500 --> 00:06:45,100
should say.

146
00:06:45,300 --> 00:06:48,400
We have a SIM devalue, its 128 bits long.

147
00:06:48,900 --> 00:06:51,000
All right, so this is 128 bits.

148
00:06:51,000 --> 00:06:52,600
Each of these is 32 bits, right?

149
00:06:52,600 --> 00:06:56,700
So, it's, it's 32 times for 128 bits long, right?

150
00:06:57,300 --> 00:06:59,600
And each of these is a 32-bit floating point value.

151
00:06:59,600 --> 00:06:59,900
So we

152
00:07:00,000 --> 00:07:02,700
For 32-bit floating Point values and it's like red.

153
00:07:02,800 --> 00:07:07,300
Zero red one, red to Red 3 in our Cindy, right?

154
00:07:07,700 --> 00:07:11,300
And then we're going to have one of these for each of the channels

155
00:07:11,500 --> 00:07:13,300
that we might need to write out, right?

156
00:07:13,300 --> 00:07:17,300
So we also have, you know, a 4 wide one of G's, right?

157
00:07:17,300 --> 00:07:20,900
We've got a 4 wide one of bees and a for y1 of A's, okay?

158
00:07:21,000 --> 00:07:22,600
And you can see those in the code.

159
00:07:22,700 --> 00:07:23,500
They're right here.

160
00:07:23,500 --> 00:07:24,300
We actually have them.

161
00:07:24,300 --> 00:07:28,500
Exactly Blended are Blended, G Blended, be Blended a right.

162
00:07:28,500 --> 00:07:29,700
So you already see

163
00:07:29,900 --> 00:07:32,000
Us having these.

164
00:07:32,000 --> 00:07:35,500
But remember each one of these is for pixels worth.

165
00:07:36,800 --> 00:07:41,900
Now, our problem is that the destination does not look like this at,

166
00:07:41,900 --> 00:07:43,200
all right?

167
00:07:43,400 --> 00:07:46,700
What the destination in memory order looks like, right?

168
00:07:46,900 --> 00:07:51,300
Is R 0, g 0, B 0, a 0 or 1 g.

169
00:07:51,300 --> 00:07:53,600
1 b, 1 a 1, right?

170
00:07:53,600 --> 00:07:59,400
And so on, these are 8 Bits, right?

171
00:07:59,700 --> 00:08:03,300
So each of these is 8 Bits, long 888, right?

172
00:08:03,300 --> 00:08:06,100
88 and so on now what

173
00:08:06,300 --> 00:08:12,500
Notice is we have the same number of actual bits total in flight, so

174
00:08:12,500 --> 00:08:13,300
that's fine.

175
00:08:13,300 --> 00:08:20,300
We have 128 bits of r128 of G, 128 of be and 128 of a, right?

176
00:08:20,400 --> 00:08:23,200
So overall we have four times 128 bits.

177
00:08:23,700 --> 00:08:27,000
Yeah, so that's all fine, right?

178
00:08:28,200 --> 00:08:30,600
When we convert these, we know that.

179
00:08:30,600 --> 00:08:35,900
Each one of them is going to be Smackdown from 32 bits right down to

180
00:08:35,900 --> 00:08:36,100
eight.

181
00:08:36,200 --> 00:08:39,000
It's so this is going to become an 8-bit value, right?

182
00:08:39,200 --> 00:08:45,600
So our for by 128, effectively becomes a, and I guess this is, this is

183
00:08:45,600 --> 00:08:47,400
a little bit misleading.

184
00:08:47,400 --> 00:08:49,000
I should, I should probably write it differently.

185
00:08:49,100 --> 00:08:50,900
It's not really, for by 128.

186
00:08:50,900 --> 00:08:54,500
It's sort of 4 by 4 by 32, right?

187
00:08:55,100 --> 00:08:59,800
So our 32 is going to go 32-bit float, is going to become eight.

188
00:09:00,000 --> 00:09:02,800
And what we have down here is exactly the same thing, right?

189
00:09:02,800 --> 00:09:05,600
We have four of these wide, right?

190
00:09:05,600 --> 00:09:06,200
Four pixels.

191
00:09:06,200 --> 00:09:06,800
This is pixel.

192
00:09:06,800 --> 00:09:10,200
0, pixel, one pixel to pixel three, right?

193
00:09:10,200 --> 00:09:13,000
So if four of these wide, each one of them has four components.

194
00:09:13,000 --> 00:09:14,200
Each one of them has 8 Bits.

195
00:09:14,400 --> 00:09:18,500
So once we do our conversion from 32 bit floating point two, eight

196
00:09:18,500 --> 00:09:21,000
bit, we will have the exact same number of bits total.

197
00:09:21,000 --> 00:09:24,200
So, we're not talking about doing anything where you have to increase

198
00:09:24,500 --> 00:09:28,800
amplifier, or sort of change the total amount of data.

199
00:09:28,800 --> 00:09:29,900
We have, we have the right amount of data.

200
00:09:30,000 --> 00:09:34,300
The problem is that it's simply in the wrong format and the wrong

201
00:09:34,300 --> 00:09:35,000
interleaving.

202
00:09:35,500 --> 00:09:35,900
Okay?

203
00:09:36,600 --> 00:09:39,500
So what we want to do, if we were to look at how this would actually

204
00:09:39,500 --> 00:09:40,300
be loaded, right?

205
00:09:40,300 --> 00:09:42,100
So remember this is memory order.

206
00:09:44,200 --> 00:09:45,100
This is in memory.

207
00:09:45,100 --> 00:09:47,000
So this is the zero with B.

208
00:09:47,000 --> 00:09:48,100
This would be like B 0.

209
00:09:48,100 --> 00:09:52,700
This would be b 1 b, 2, B, 3, B, 4 B, 5, b, 6, B 7, right?

210
00:09:53,000 --> 00:10:00,200
And so here is our, our GBA rgba of all the different components,

211
00:10:00,600 --> 00:10:01,100
right?

212
00:10:02,500 --> 00:10:07,200
And so how many bits wide is this actual guy, right?

213
00:10:07,600 --> 00:10:12,200
Well, this guy is going to be, like I said, four times, four times

214
00:10:12,200 --> 00:10:13,400
eight, right?

215
00:10:13,500 --> 00:10:13,800
And for it.

216
00:10:14,000 --> 00:10:14,400
4 times.

217
00:10:14,400 --> 00:10:16,900
8 is 16 times 8, right?

218
00:10:17,400 --> 00:10:23,100
Which unfortunately as we can see up here, when we had our four times

219
00:10:23,100 --> 00:10:28,400
128, write the actual amount that we're writing out is going to be

220
00:10:28,400 --> 00:10:30,700
smaller than the amount that's coming in.

221
00:10:31,700 --> 00:10:34,300
But again, it doesn't really necessarily matter.

222
00:10:37,400 --> 00:10:40,300
As long as we can do that conversion from 32-bit float down to eight

223
00:10:40,300 --> 00:10:41,700
but it's all fine.

224
00:10:41,700 --> 00:10:44,500
So, that's not really that big of a deal, all right.

225
00:10:45,700 --> 00:10:48,200
So how big is four times four times eight?

226
00:10:48,300 --> 00:10:51,400
Right, how big is is 16 times 8, right?

227
00:10:52,600 --> 00:10:56,000
Well, 16 times 8 is 128, right?

228
00:10:56,000 --> 00:10:58,700
It's one of these registers.

229
00:10:58,700 --> 00:11:02,800
It's the size of one register, and you can imagine why that is.

230
00:11:02,800 --> 00:11:08,000
Because in each one of these 32, 32 bit floating Point values here, we

231
00:11:08,000 --> 00:11:12,200
could have imagined fitting for 8-bit values, right?

232
00:11:12,200 --> 00:11:14,900
Because 32 is 4 times 8, so we can imagine segmenting this

233
00:11:15,000 --> 00:11:15,300
Mr.

234
00:11:15,300 --> 00:11:18,700
Up into four pieces and storing them that way, right?

235
00:11:19,000 --> 00:11:24,100
So if we look in memory and this is our frame, buffer rgba rgba, rgba

236
00:11:24,100 --> 00:11:25,900
rgba for four pixels.

237
00:11:26,200 --> 00:11:30,100
If we imagine what happens when we load that into an Intel register,

238
00:11:30,100 --> 00:11:30,400
right?

239
00:11:30,400 --> 00:11:36,600
If we were to load this sort of this aspect of the frame buffer, if we

240
00:11:36,600 --> 00:11:40,500
were to load this piece of the frame buffer into one of the registers?

241
00:11:41,300 --> 00:11:44,900
Well, we would, you know, it's a until little-endian.

242
00:11:45,000 --> 00:11:46,400
An ordering, right?

243
00:11:46,400 --> 00:11:48,900
So it would take the first date and it would put it here.

244
00:11:49,100 --> 00:11:51,800
It would take the next date and it would put it here, right?

245
00:11:51,900 --> 00:11:55,500
And so on and we would get a register that looks like this.

246
00:11:56,900 --> 00:11:57,200
Right.

247
00:11:57,200 --> 00:11:58,200
This is what we would see.

248
00:12:02,900 --> 00:12:03,800
Does that make sense?

249
00:12:04,500 --> 00:12:05,800
Hopefully, that makes sense to everyone.

250
00:12:06,400 --> 00:12:08,800
So this is what it looks like in memory is zeroth.

251
00:12:08,800 --> 00:12:09,500
B, blah, blah, blah.

252
00:12:09,500 --> 00:12:10,900
But again, Intel loads.

253
00:12:10,900 --> 00:12:12,300
This is what little-endian means.

254
00:12:12,300 --> 00:12:13,900
We talked about this long ago, right?

255
00:12:14,500 --> 00:12:15,600
Little endian means.

256
00:12:15,700 --> 00:12:19,000
When you start reading from memory, it goes into the least significant

257
00:12:19,000 --> 00:12:20,700
portion of the register, right?

258
00:12:20,700 --> 00:12:23,400
So it loads it in here and then continues for words.

259
00:12:24,400 --> 00:12:29,200
What this means is that if we wanted to prepare a register for writing

260
00:12:29,200 --> 00:12:31,100
out right to the

261
00:12:32,500 --> 00:12:33,400
To the frame buffer.

262
00:12:33,500 --> 00:12:38,000
If we wanted to write out one sim deregister, we would want it to look

263
00:12:38,000 --> 00:12:39,400
like this or a 0.

264
00:12:39,400 --> 00:12:44,100
G 0, B 0, a 0, r, 1 g, 1 b, 1 a 1, R 2, g 2, right?

265
00:12:44,200 --> 00:12:45,500
That's what we'd want to look like.

266
00:12:46,000 --> 00:12:49,200
Because if we had it like that, we just store that register directly

267
00:12:49,200 --> 00:12:51,100
to the memory and that would do it, right?

268
00:12:51,100 --> 00:12:52,600
We wouldn't need this Loop anymore.

269
00:12:52,700 --> 00:12:56,200
We would just have one one giant store, right?

270
00:12:56,200 --> 00:13:00,500
We could just say, you know, whatever the pixel is, we could sort of

271
00:13:00,500 --> 00:13:01,200
say, you know,

272
00:13:01,700 --> 00:13:04,200
And that's am one 28, right?

273
00:13:04,200 --> 00:13:07,900
We could just say that equals, you know, whatever the thing is that

274
00:13:07,900 --> 00:13:11,100
we've got whatever that value is that we produced whatever this thing

275
00:13:11,100 --> 00:13:11,400
is.

276
00:13:11,400 --> 00:13:13,700
We could just write it out and we wouldn't have to do this Loop

277
00:13:13,700 --> 00:13:14,000
anymore.

278
00:13:14,000 --> 00:13:15,300
We just write out the whole register.

279
00:13:16,800 --> 00:13:20,400
All right, so if that's the case, really, what we're talking about

280
00:13:20,400 --> 00:13:21,100
here, right?

281
00:13:21,100 --> 00:13:26,900
Our problem is we have to figure out a way to essentially turn a four

282
00:13:26,900 --> 00:13:30,800
registers each with like ours, gsb's and A's in them, we need to

283
00:13:30,800 --> 00:13:35,600
figure out how to turn those into this style of register interleaved.

284
00:13:35,800 --> 00:13:39,700
So we need to take something that's effectively rrrr, right?

285
00:13:40,100 --> 00:13:46,300
Gggg bbbb, loops and a, a

286
00:13:46,600 --> 00:13:50,200
We need to figure out how to turn that into something.

287
00:13:50,200 --> 00:13:52,000
That's interleaved, right?

288
00:13:52,000 --> 00:13:56,500
So we need to grab like one thing from each of the registers, okay?

289
00:13:58,100 --> 00:14:00,500
And so, in order to do that, what I want to focus on first.

290
00:14:00,500 --> 00:14:01,800
Let's just focus on this first.

291
00:14:01,800 --> 00:14:05,000
Actually, this is, this is this is going to be probably the easiest

292
00:14:05,000 --> 00:14:05,400
way to do it.

293
00:14:05,400 --> 00:14:07,500
Then we'll take a look at doing a little bit differently later.

294
00:14:08,300 --> 00:14:11,300
So let's talk about that isolated problem.

295
00:14:11,600 --> 00:14:14,800
Let's just first talk about how would we do it?

296
00:14:15,300 --> 00:14:20,000
So we could take for Cindy values that we're looking like this and

297
00:14:20,000 --> 00:14:23,800
turn them into 470 values that look the other way, right?

298
00:14:23,800 --> 00:14:25,600
That look interleaved, right?

299
00:14:25,600 --> 00:14:27,500
So you want to do it this way, okay?

300
00:14:27,900 --> 00:14:30,500
Now, remember this again, is the memory order, so really?

301
00:14:30,500 --> 00:14:33,900
This is the kind of the annoying part of being on little endian

302
00:14:33,900 --> 00:14:34,600
architectures.

303
00:14:34,800 --> 00:14:38,100
Really, it doesn't look that way in the registers were really looking

304
00:14:38,200 --> 00:14:40,300
at making it look like this, right?

305
00:14:41,700 --> 00:14:42,300
And so on.

306
00:14:43,400 --> 00:14:44,000
Right?

307
00:14:44,300 --> 00:14:47,500
And I guess now that I think about it I should probably caveat this.

308
00:14:47,600 --> 00:14:50,200
I'm actually I'm slightly wrong in what I'm saying?

309
00:14:51,200 --> 00:14:55,600
These are windows frame buffers not like opengl texture so actually

310
00:14:55,600 --> 00:14:56,800
they're not even this way.

311
00:14:57,100 --> 00:14:59,800
I should caveat what I'm saying here in memory or

312
00:15:00,000 --> 00:15:04,200
On Windows, we actually are be gra, right?

313
00:15:04,300 --> 00:15:07,700
Because remember Windows has the weird thing where they swapped the

314
00:15:07,700 --> 00:15:11,200
are in the G values, right for how the frame buffer was stored.

315
00:15:11,300 --> 00:15:14,700
So really this is if it was a standard like opengl texture or

316
00:15:14,700 --> 00:15:16,900
something like this, that's the order for that which is kind of where

317
00:15:16,900 --> 00:15:19,400
my head was but that's not what we actually want.

318
00:15:19,400 --> 00:15:21,200
So really we need to produce.

319
00:15:21,200 --> 00:15:27,800
We need to take these and we need to produce until ordered stuff that

320
00:15:27,800 --> 00:15:29,800
looks like B gr, right?

321
00:15:30,000 --> 00:15:31,600
So this is inside the register.

322
00:15:31,600 --> 00:15:34,200
It should look like this B gra, right?

323
00:15:34,200 --> 00:15:37,500
Be gra, be gra, right?

324
00:15:37,500 --> 00:15:39,300
So we want four registers that look like that.

325
00:15:39,600 --> 00:15:40,600
So that's what we want.

326
00:15:40,900 --> 00:15:45,300
Okay, so let's focus on that first.

327
00:15:46,700 --> 00:15:49,000
So we have our Blended RGB and a here.

328
00:15:49,500 --> 00:15:56,000
And what I want to do is make essentially rgba 0, 0 and rgba one and

329
00:15:56,000 --> 00:15:59,000
rgba to and an rgba three.

330
00:15:59,100 --> 00:15:59,700
Right?

331
00:16:00,200 --> 00:16:01,200
That's what I want to do.

332
00:16:01,600 --> 00:16:07,300
So that's the hard part, but once we get to that, you will notice that

333
00:16:07,300 --> 00:16:10,500
there is actually not a lot there.

334
00:16:11,000 --> 00:16:15,400
There actually isn't much more that we would have to do to finish

335
00:16:15,400 --> 00:16:16,100
things off.

336
00:16:16,300 --> 00:16:17,800
So maybe what we'll do.

337
00:16:18,100 --> 00:16:21,800
Well let's let's do that first, let's just do it and we have to do

338
00:16:21,900 --> 00:16:25,100
there's a couple things that we have to do essentially in order to

339
00:16:25,100 --> 00:16:26,000
actually finish things off.

340
00:16:26,000 --> 00:16:27,800
So we'll just we'll just do it.

341
00:16:28,000 --> 00:16:31,600
All right, so let's open up the Intel intrinsic side again.

342
00:16:31,600 --> 00:16:35,400
As we have relied on many times, which is Handy and what I want to

343
00:16:35,400 --> 00:16:36,600
call your attention to.

344
00:16:37,000 --> 00:16:39,700
Again, we're only using sse2 and SSE right now.

345
00:16:40,600 --> 00:16:44,500
What I want to call your attention to is, is this odd?

346
00:16:44,600 --> 00:16:46,000
Oddly named,

347
00:16:46,400 --> 00:16:51,600
Set of functions called unpack now, they're called unpack because they

348
00:16:51,600 --> 00:16:52,800
interleaf things.

349
00:16:53,000 --> 00:16:57,600
And so if you were to unpack something with say a 0, Vector 0

350
00:16:57,600 --> 00:17:02,800
register, it would expand it in the number of bytes that it takes up.

351
00:17:02,900 --> 00:17:04,300
I'll show you what that means in a second here.

352
00:17:04,300 --> 00:17:07,500
But if we take a look at say unpack, hi epi32.

353
00:17:08,900 --> 00:17:13,000
Then what this does is it unpacks and there's, and there's two flavors

354
00:17:13,000 --> 00:17:13,300
each of these.

355
00:17:13,300 --> 00:17:17,000
You'll notice there's an unpacked high and for every unpack, hi, I'm

356
00:17:17,000 --> 00:17:17,800
kind of getting in the way.

357
00:17:17,800 --> 00:17:20,200
They're my heads, getting in the way for every unpack High.

358
00:17:20,200 --> 00:17:22,500
There's also a nun a'course, wanting unpacked low.

359
00:17:22,800 --> 00:17:23,200
Okay.

360
00:17:23,800 --> 00:17:29,400
Now, what unpack high and unpacked low do is they take registers such

361
00:17:29,400 --> 00:17:30,700
as these guys, right?

362
00:17:30,900 --> 00:17:33,900
And if you call unpack higher, unpack low, and then what it does, is

363
00:17:33,900 --> 00:17:34,500
it Target.

364
00:17:34,500 --> 00:17:37,900
So, let's say I have my arse and my G's here, right?

365
00:17:39,000 --> 00:17:45,100
And I've got 0, 0, 1, 2, 3 0, 1 2 3.

366
00:17:45,700 --> 00:17:48,200
So let's say I have my arse in my, my cheese here.

367
00:17:48,200 --> 00:17:52,800
If I was to do an unpack, there's two kinds unpack, low and unpack

368
00:17:52,800 --> 00:17:53,000
high.

369
00:17:53,000 --> 00:17:57,000
If I was to do it unpack low, what that would do is, it would pick

370
00:17:57,000 --> 00:17:59,800
first one from the are

371
00:18:00,000 --> 00:18:03,700
It would put that into the first slot, right?

372
00:18:03,700 --> 00:18:07,000
Because remember, we've got four slots for 32-bit values, right?

373
00:18:07,300 --> 00:18:10,100
It would take the 32 bit and put that in the first slot.

374
00:18:10,200 --> 00:18:13,700
It would then take the G and put that in the second slot.

375
00:18:13,700 --> 00:18:16,700
Then it would take the our and put that in the next slot and then it

376
00:18:16,700 --> 00:18:19,600
would take the G and put that in the next slot, right?

377
00:18:19,800 --> 00:18:23,900
So you can see that this does that interleaving operation that we want

378
00:18:23,900 --> 00:18:24,900
it to do, right?

379
00:18:24,900 --> 00:18:26,700
It kind of does that expansion.

380
00:18:27,800 --> 00:18:30,400
It's getting closer to this format that we want over here.

381
00:18:31,400 --> 00:18:35,400
And so, the reason there's a low and a high is because it to, it

382
00:18:35,400 --> 00:18:38,400
depends, you know, there's only enough room for four values when we do

383
00:18:38,400 --> 00:18:39,300
the unpack here.

384
00:18:39,500 --> 00:18:43,400
So, it's going to use either this for, or this for it, the highwomen

385
00:18:43,400 --> 00:18:44,500
done.

386
00:18:44,500 --> 00:18:47,900
The corresponding thing, starting with this guy, it would have

387
00:18:47,900 --> 00:18:52,600
produced our 2, g, 2 are 3 G3.

388
00:18:52,600 --> 00:18:53,000
Right?

389
00:18:53,000 --> 00:18:56,600
So the unpacks basically Target, a certain width.

390
00:18:56,600 --> 00:18:57,400
In this case, 30

391
00:18:57,700 --> 00:19:02,800
B and a certain higher low portion to do that kind of interleave,

392
00:19:02,900 --> 00:19:03,400
right?

393
00:19:04,600 --> 00:19:08,800
So what we want to do is we want to use these unpack operations to

394
00:19:09,000 --> 00:19:11,200
take all this data and interleave it.

395
00:19:11,300 --> 00:19:14,400
So we want to see it, look like this, right?

396
00:19:14,600 --> 00:19:17,900
And there's a problem, which is that since the interleave can only be

397
00:19:17,900 --> 00:19:19,400
between two things, right?

398
00:19:19,400 --> 00:19:22,200
I'm only going to be able to interleave two things with an unpack

399
00:19:22,200 --> 00:19:22,900
operation.

400
00:19:23,300 --> 00:19:27,200
What that means is we're going to need more than one unpack.

401
00:19:27,600 --> 00:19:27,800
Ation.

402
00:19:27,800 --> 00:19:31,300
And the question is, how do we structure those unpack operations so

403
00:19:31,300 --> 00:19:32,800
that we can actually do?

404
00:19:35,300 --> 00:19:39,600
The unpack, the took to get this, this actual result.

405
00:19:40,100 --> 00:19:43,600
Now, what you can see is if I actually Target Two values that need to

406
00:19:43,600 --> 00:19:45,300
be next to each other, right?

407
00:19:46,100 --> 00:19:50,400
So let's say, I wanted to concentrate on producing this GB, right?

408
00:19:50,800 --> 00:19:52,000
Well, the GB.

409
00:19:52,000 --> 00:19:54,300
If I want to just use the unpack 32-bit, right?

410
00:19:54,300 --> 00:19:55,900
And I want to Target that GB.

411
00:19:56,300 --> 00:19:59,800
Well, that's pretty easy right to produce that GB, okay?

412
00:20:00,100 --> 00:20:03,300
Because if I've got a vector of G's, and I've got a vector of bees,

413
00:20:03,400 --> 00:20:05,400
Like so right?

414
00:20:08,000 --> 00:20:09,400
So there's my two Cindy registers.

415
00:20:09,600 --> 00:20:13,500
If I do the interlude between these two, then what I can do is I can

416
00:20:13,500 --> 00:20:17,200
just pick the first parameter to be the bee and the second parameter

417
00:20:17,200 --> 00:20:18,000
to be the G.

418
00:20:18,200 --> 00:20:22,700
And what that would produce is that would produce a b 0, g 0, right?

419
00:20:22,700 --> 00:20:22,900
B.

420
00:20:22,900 --> 00:20:23,700
1 g 1.

421
00:20:24,400 --> 00:20:27,400
And then I could do the same thing with the high to get the other

422
00:20:27,400 --> 00:20:29,000
one's right b2g to

423
00:20:30,300 --> 00:20:31,300
B3, G 3.

424
00:20:31,700 --> 00:20:35,400
And now I've successfully produced that bottom value, right?

425
00:20:35,700 --> 00:20:40,400
Similarly, I could Target the A and are right if I have the A's.

426
00:20:40,500 --> 00:20:40,900
Oops.

427
00:20:43,600 --> 00:20:45,600
and the RS like so,

428
00:20:48,300 --> 00:20:52,500
If I have a an RS, I can do the unpack, their the exact same way.

429
00:20:53,100 --> 00:20:55,000
So that I can end up with a vector.

430
00:20:55,000 --> 00:20:56,100
That's like our 0.

431
00:20:56,100 --> 00:20:58,100
A 0 or 1, a 1.

432
00:21:00,200 --> 00:21:03,500
R 2 a 2, R 3, a 3.

433
00:21:04,100 --> 00:21:09,600
But what you'll notice is, when I go to now combine those results, I

434
00:21:09,600 --> 00:21:12,400
want to produce something that's be gra.

435
00:21:13,100 --> 00:21:18,000
What I find is this the second, the cascading unpack, the next unpack,

436
00:21:18,600 --> 00:21:19,500
there is no way.

437
00:21:19,500 --> 00:21:24,800
I can still use a 32-bit unpack to actually produce the vector that I

438
00:21:24,800 --> 00:21:25,900
want right?

439
00:21:26,000 --> 00:21:29,600
Which is a RGB, right?

440
00:21:29,600 --> 00:21:29,900
Because

441
00:21:30,000 --> 00:21:31,000
As whatever I do.

442
00:21:31,000 --> 00:21:36,600
If I was to whoever I pick, I'm going to have a be right followed by

443
00:21:36,600 --> 00:21:38,900
an R, which is not what I want, right?

444
00:21:38,900 --> 00:21:41,600
Because going to pick one from this one, from this one, from this one

445
00:21:41,600 --> 00:21:42,200
from this.

446
00:21:42,400 --> 00:21:44,900
What I want to do is pick two from this and then to from this, and

447
00:21:44,900 --> 00:21:45,900
that would give it to me, right?

448
00:21:45,900 --> 00:21:48,200
If I if I had one that picked you from this into from this.

449
00:21:48,500 --> 00:21:51,800
Now, there are unpack instructions that unpack wider, right?

450
00:21:52,300 --> 00:21:54,900
I don't know if they actually included that in sse2.

451
00:21:56,600 --> 00:21:57,900
They did, right?

452
00:21:58,100 --> 00:22:03,700
So one way we could do it is we could use an unpack 64-bit, right?

453
00:22:03,700 --> 00:22:06,800
And do the unpack that way, and then that would that would do it.

454
00:22:06,900 --> 00:22:10,500
But what I wanted to show you is actually and this comes into play,

455
00:22:10,500 --> 00:22:13,400
sometimes on when you have architecture that don't have multiple

456
00:22:13,400 --> 00:22:16,600
widths of the unpacking or you want to do other stuff, we'll kind of

457
00:22:16,600 --> 00:22:17,500
see things a little bit later.

458
00:22:18,600 --> 00:22:22,800
Is that if we don't do it that way, if we instead mix the other two

459
00:22:22,800 --> 00:22:25,900
values in the first step, we can actually just use this.

460
00:22:26,000 --> 00:22:30,000
Same with to do all of our interleaving, right?

461
00:22:30,300 --> 00:22:31,200
So let's say that.

462
00:22:31,200 --> 00:22:33,600
Instead of doing it this way, right?

463
00:22:33,700 --> 00:22:36,100
We actually do it slightly differently.

464
00:22:37,100 --> 00:22:42,900
Let's say that instead, we mix the ours and the bees together, and the

465
00:22:42,900 --> 00:22:45,500
A's, and the geez together, right?

466
00:22:45,800 --> 00:22:48,400
So we pick B and our right?

467
00:22:48,400 --> 00:22:53,600
So we end up with B 0, R 0, b 1 r 1, right?

468
00:22:54,000 --> 00:22:55,100
We pick that first.

469
00:22:56,000 --> 00:22:59,400
And then we pick the the the A's and the g.

470
00:22:59,400 --> 00:23:02,700
So we have G 0, a 0 g, 1 a 1.

471
00:23:03,100 --> 00:23:03,600
Okay.

472
00:23:04,400 --> 00:23:09,400
Now if I wanted to do the mixing on these two, if I pick this as the

473
00:23:09,400 --> 00:23:11,200
first parameter and this is the second parameter.

474
00:23:11,200 --> 00:23:12,200
I get B 0.

475
00:23:12,400 --> 00:23:14,000
G-- 0, right.

476
00:23:14,300 --> 00:23:16,000
R 0 a 0.

477
00:23:16,200 --> 00:23:16,800
Right?

478
00:23:17,200 --> 00:23:18,200
That makes sense here.

479
00:23:18,200 --> 00:23:19,500
Here here here.

480
00:23:20,500 --> 00:23:23,900
And so what you can see is as long as you pick your mixing order

481
00:23:23,900 --> 00:23:25,800
correctly, using a

482
00:23:26,000 --> 00:23:29,800
Single with you can actually go ahead and do the complete Shuffle that

483
00:23:29,800 --> 00:23:32,600
you actually wanted to do all with one type of instruction.

484
00:23:33,800 --> 00:23:37,200
Now, is there any real reason for us to do that here necessarily not

485
00:23:37,200 --> 00:23:40,500
necessarily, but it's an important thing to understand how these

486
00:23:40,500 --> 00:23:42,000
shuttles kind of work like that.

487
00:23:42,100 --> 00:23:46,400
It's just an important thing to sort of think about because you know,

488
00:23:48,700 --> 00:23:50,800
When you start working with these things and you never worked with

489
00:23:50,800 --> 00:23:54,100
them before stuff, like that may not be clear to you, right?

490
00:23:54,100 --> 00:23:56,800
It may not be clear that you can always get the shuffle you want by

491
00:23:56,800 --> 00:23:58,100
picking the order properly.

492
00:23:58,200 --> 00:23:59,800
So I'm going to show how to do it that way.

493
00:24:00,800 --> 00:24:04,300
Just first, and I guess I already sort of did, so you can see what we

494
00:24:04,300 --> 00:24:05,300
essentially said.

495
00:24:05,400 --> 00:24:09,400
We needed to do one unpack with bees and ours, one unpack with G's in

496
00:24:09,400 --> 00:24:11,500
days and then we need to unpack the result.

497
00:24:11,600 --> 00:24:13,200
So let's just go ahead and do that.

498
00:24:13,900 --> 00:24:15,600
Not very difficult.

499
00:24:15,600 --> 00:24:20,200
But essentially what we have here right is, we've got that BR sorry.

500
00:24:20,200 --> 00:24:23,500
I guess I should say, I'll name them in registered or register order.

501
00:24:24,000 --> 00:24:27,100
So really what these are going to be just just so we can keep our

502
00:24:27,100 --> 00:24:27,800
naming scheme.

503
00:24:27,900 --> 00:24:30,100
Oops, are GB, so we can keep our name.

504
00:24:30,300 --> 00:24:33,800
Scheme kind of clear here so that Anyone who reads the code knows

505
00:24:34,500 --> 00:24:35,100
what's going on.

506
00:24:35,100 --> 00:24:35,700
We'll keep them all in.

507
00:24:35,700 --> 00:24:38,000
Register order, consistently throughout.

508
00:24:38,700 --> 00:24:42,900
So we need to do here is produced the B 0, R 0, b 1 r, one vector,

509
00:24:43,000 --> 00:24:43,600
right?

510
00:24:43,900 --> 00:24:46,400
And so we're just going to say that exact thing.

511
00:24:46,400 --> 00:24:50,300
This is r 1 b 1 or a 0 B 0, right?

512
00:24:50,600 --> 00:24:55,800
And then the next one is the the a g, a g.

513
00:24:55,800 --> 00:24:58,400
Like so right, hopefully, that makes some sense.

514
00:24:59,000 --> 00:25:02,500
And then all I need to do here is do that that unpack

515
00:25:04,700 --> 00:25:07,200
And again, these are both going to be low on packs because they're in

516
00:25:07,200 --> 00:25:10,000
packing the 0 and 1's not the twos and threes.

517
00:25:10,700 --> 00:25:13,300
So these are both going to be mmm, unpacked clothes and they're going

518
00:25:13,300 --> 00:25:15,100
to unpack exactly what they said they were.

519
00:25:15,100 --> 00:25:18,100
Now we have to double check because again, like I say, parameter order

520
00:25:18,100 --> 00:25:20,200
is always a little weird in these things.

521
00:25:20,200 --> 00:25:21,600
So I always have to check to make sure.

522
00:25:21,600 --> 00:25:23,500
I know which one it's considering the low.

523
00:25:24,200 --> 00:25:26,700
So the a in this case, right?

524
00:25:28,000 --> 00:25:28,300
Sorry.

525
00:25:28,300 --> 00:25:29,500
This is unpack.

526
00:25:29,500 --> 00:25:31,200
Hi, they're the same parameter.

527
00:25:31,200 --> 00:25:33,600
But with look lift least read the correct one.

528
00:25:33,800 --> 00:25:34,200
So

529
00:25:34,300 --> 00:25:36,700
Chloe pi32, right?

530
00:25:36,700 --> 00:25:37,200
Just gonna

531
00:25:39,300 --> 00:25:41,500
that in, at least type it incorrectly.

532
00:25:42,200 --> 00:25:44,600
So unpack, low epi32 here.

533
00:25:46,400 --> 00:25:50,800
what we need to do now, is just take a look at who actually is, is the

534
00:25:54,200 --> 00:25:56,100
the person who goes in the low slot,

535
00:25:57,600 --> 00:25:58,600
And let's see.

536
00:25:59,100 --> 00:26:00,300
So that is

537
00:26:02,300 --> 00:26:03,400
Do you words?

538
00:26:03,400 --> 00:26:05,500
02:31 comes from Source.

539
00:26:05,500 --> 00:26:07,600
One of course.

540
00:26:07,700 --> 00:26:11,700
It's awesome that they they use a and then say Source One.

541
00:26:13,500 --> 00:26:17,200
Alright well we'll assume that a is Source One for now.

542
00:26:17,200 --> 00:26:22,600
So Source, One is low and since we want in low to be be will do it

543
00:26:22,600 --> 00:26:25,800
this way, but we can step through the code and verify that, that's

544
00:26:25,800 --> 00:26:27,600
true I suppose.

545
00:26:28,800 --> 00:26:31,100
That seems like a reasonable thing to do.

546
00:26:31,700 --> 00:26:36,000
And so we want be and are so there's be there's our and then here we

547
00:26:36,000 --> 00:26:38,700
want G and a.

548
00:26:39,100 --> 00:26:40,100
So there they go.

549
00:26:40,600 --> 00:26:44,800
And for now I'm just going to get zero these out this and leave the

550
00:26:44,800 --> 00:26:45,500
code running.

551
00:26:45,900 --> 00:26:50,300
Otherwise as is opened, this is a force and mmm 128.

552
00:26:52,900 --> 00:26:53,300
Sorry.

553
00:26:53,600 --> 00:26:56,000
All right, so one of the things we have to address here which I did

554
00:26:56,000 --> 00:26:59,500
not address, is the fact that again and this actually brings up a

555
00:26:59,500 --> 00:26:59,800
point.

556
00:27:00,000 --> 00:27:01,400
Fabien mentioned the other day to me.

557
00:27:02,900 --> 00:27:04,100
So mm, 128.

558
00:27:04,100 --> 00:27:04,500
I

559
00:27:05,800 --> 00:27:09,400
Is of course, like I was saying when I first introduced this, it's

560
00:27:09,400 --> 00:27:13,400
whether or not, it's treating it as integer or floating-point and

561
00:27:13,400 --> 00:27:17,000
Fabien actually pointed out something that I did not know because I am

562
00:27:17,000 --> 00:27:21,000
not, I don't really like, I've never had to really do any hardcore,

563
00:27:21,000 --> 00:27:23,100
sse2 optimization to be honest with you.

564
00:27:24,200 --> 00:27:26,600
Like I said, the only time I've ever really done super hardcore stuff,

565
00:27:26,600 --> 00:27:27,800
was on the Xbox 360.

566
00:27:30,300 --> 00:27:31,700
Which was not in any way essay.

567
00:27:32,600 --> 00:27:38,800
What he said because I thought the mmm 128 I versus em, 128 was purely

568
00:27:38,800 --> 00:27:43,600
a typing thing for see that the intrinsics introduced but it's not

569
00:27:43,600 --> 00:27:49,000
quite, it's actually a hint to the compiler or a guide to the compiler

570
00:27:49,000 --> 00:27:52,700
in terms of picking the instructions that you're trying to do.

571
00:27:52,700 --> 00:27:58,100
Because it turns out that there actually is a different unit in the in

572
00:27:58,100 --> 00:28:02,300
the CPU for doing the integer operations versus the ones.

573
00:28:02,300 --> 00:28:02,500
That

574
00:28:02,600 --> 00:28:07,200
The floating Point operations, and sometimes you will lose a cycle

575
00:28:07,200 --> 00:28:12,400
here and there, if you move between the two types, so it is worth at

576
00:28:12,400 --> 00:28:16,600
the limit and probably not in anything that we're doing, but if you

577
00:28:16,600 --> 00:28:21,000
really care, it is worth paying attention at the limit to how often

578
00:28:21,000 --> 00:28:23,600
you have to move between an M1 28.

579
00:28:23,600 --> 00:28:28,100
And an M1 28i because it actually may not be free and Fabien said it

580
00:28:28,100 --> 00:28:31,300
changes depending on the architecture as well.

581
00:28:31,700 --> 00:28:32,500
It's just something to keep

582
00:28:32,600 --> 00:28:34,500
Keep in mind, that's what Fabien said.

583
00:28:35,600 --> 00:28:38,500
And he is usually right about these sorts of things.

584
00:28:39,200 --> 00:28:44,200
So, what we need to do here is we just need to change the type of

585
00:28:44,200 --> 00:28:47,100
this, and you can see that there is actually cast for this, right?

586
00:28:47,800 --> 00:28:50,200
There's basically like a cast that converts one of the other, it's

587
00:28:50,200 --> 00:28:52,300
called cast pssi 128.

588
00:28:52,300 --> 00:28:55,900
And there's the same one, which is cast, cast, is I 128 PS?

589
00:28:56,800 --> 00:28:58,900
So, basically, it's, it's free for us.

590
00:28:59,200 --> 00:29:02,500
Sort of, at least namik, lecture wise to switch between these at any

591
00:29:02,500 --> 00:29:02,900
time.

592
00:29:03,000 --> 00:29:05,200
So, if we want to use integer instructions,

593
00:29:05,300 --> 00:29:07,400
And we can do so right.

594
00:29:08,300 --> 00:29:12,800
All right, so let's do the cast here.

595
00:29:13,300 --> 00:29:14,000
We want.

596
00:29:14,500 --> 00:29:16,200
We want this one, right?

597
00:29:16,500 --> 00:29:17,500
Oops, sorry we want.

598
00:29:17,600 --> 00:29:18,300
Where is it?

599
00:29:18,300 --> 00:29:19,300
This one, right.

600
00:29:19,300 --> 00:29:22,700
So we want to turn a floating point value into the integer value.

601
00:29:22,900 --> 00:29:23,500
Like I said,

602
00:29:25,200 --> 00:29:26,500
So let's go ahead and do that.

603
00:29:26,800 --> 00:29:28,400
Let's do what it's Cass.

604
00:29:28,400 --> 00:29:29,900
Pssi 128.

605
00:29:30,900 --> 00:29:31,400
There we go.

606
00:29:33,500 --> 00:29:34,400
And we'll do it here.

607
00:29:36,400 --> 00:29:37,000
And again.

608
00:29:39,000 --> 00:29:39,400
There we go.

609
00:29:40,300 --> 00:29:40,900
All right.

610
00:29:43,100 --> 00:29:43,800
So there we go.

611
00:29:44,300 --> 00:29:48,100
And what you can see here, when I compile this, what I'm going to do,

612
00:29:48,100 --> 00:29:49,600
I want to show you how this works.

613
00:29:49,800 --> 00:29:52,700
What I'm going to do is again we've talked about structured art many

614
00:29:52,700 --> 00:29:55,800
times before, what I'm going to do you do is use essentially

615
00:29:55,800 --> 00:29:59,000
structured art here to make it easy for us to see.

616
00:29:59,000 --> 00:29:59,800
This is almost like when you

617
00:30:00,000 --> 00:30:03,000
Like a medical procedure and you inject, like radioactive dye in the

618
00:30:03,000 --> 00:30:04,500
person to see where things are going.

619
00:30:04,900 --> 00:30:06,700
We're going to do exactly that.

620
00:30:06,700 --> 00:30:11,600
So what I'm going to do is I'm going to overwrite basically the the

621
00:30:11,600 --> 00:30:13,200
stuff that's in these registers.

622
00:30:13,300 --> 00:30:16,100
So I'm going to use a set PS, right?

623
00:30:17,400 --> 00:30:17,900
Like so.

624
00:30:18,500 --> 00:30:21,100
And what I want to do is I want to basically set it up so that it's

625
00:30:21,100 --> 00:30:26,200
really trivial for us to see what's going on in the registers as we do

626
00:30:26,200 --> 00:30:26,700
our shuttles.

627
00:30:26,700 --> 00:30:28,500
So I'm going to do a set PS.

628
00:30:29,900 --> 00:30:35,000
In fact, I think I might actually do it as a cast here as well, so

629
00:30:35,000 --> 00:30:37,400
I'll do it this way where we actually.

630
00:30:37,700 --> 00:30:41,600
I think I want to actually do it as a set epi.

631
00:30:46,200 --> 00:30:50,900
sorry, my bravest banking asset Epi want to actually set basically a

632
00:30:53,000 --> 00:30:58,000
What, what amounts to hexadecimal values because they'll be easy to

633
00:30:58,000 --> 00:30:59,000
see in the debugger.

634
00:30:59,000 --> 00:31:01,300
In fact, I guess I could even do this in a way.

635
00:31:01,300 --> 00:31:03,300
That's, that's even a little chunkier than that.

636
00:31:03,600 --> 00:31:08,700
What I could do is something like this, you know, the ours.

637
00:31:09,300 --> 00:31:12,700
And they're going to basically be something that looks like a five

638
00:31:12,700 --> 00:31:13,000
kind of.

639
00:31:13,000 --> 00:31:14,500
Looks like an are maybe.

640
00:31:15,000 --> 00:31:21,300
So I'm going to set this up to be like r0 R1 R2, R3, right?

641
00:31:21,300 --> 00:31:22,200
You can kind of see.

642
00:31:22,700 --> 00:31:25,800
The R value is like that, does that kind of?

643
00:31:25,800 --> 00:31:27,100
Does that make any sense to anyone?

644
00:31:27,600 --> 00:31:32,000
I feel like that's that's sort of makes makes at least some sense.

645
00:31:32,400 --> 00:31:38,900
So I'm just going to do it that way to basically just make it really

646
00:31:38,900 --> 00:31:41,700
clear where the values are.

647
00:31:42,600 --> 00:31:49,200
And so I'm going to do that and then say eight RS 60.

648
00:31:49,800 --> 00:31:52,400
So basically just going to load in those those

649
00:31:52,500 --> 00:31:56,900
Small values into the RS and I want to do that with absolutely

650
00:31:56,900 --> 00:31:57,400
everybody.

651
00:31:57,400 --> 00:32:02,800
So I want to make, you know, basically, you know, a GS BS and an as

652
00:32:03,000 --> 00:32:06,500
and the nice thing about that is the a is actually can be A's and the

653
00:32:06,500 --> 00:32:08,700
B's can be B's, right?

654
00:32:10,200 --> 00:32:11,600
It going through here, right?

655
00:32:21,700 --> 00:32:24,800
And I guess since this is actually memory order here, now that I think

656
00:32:24,800 --> 00:32:28,800
about it, I've actually got these guys not quite right.

657
00:32:35,600 --> 00:32:36,000
Yeah.

658
00:32:41,500 --> 00:32:43,900
Switching between memory order and register order is always kind of a

659
00:32:43,900 --> 00:32:45,300
little bit of mental gymnastics.

660
00:32:48,600 --> 00:32:49,100
Anyway.

661
00:32:53,300 --> 00:32:54,100
Rectangle.

662
00:32:56,500 --> 00:32:57,100
That's how I go.

663
00:32:57,200 --> 00:32:57,700
There we go.

664
00:32:59,000 --> 00:32:59,400
So yeah.

665
00:32:59,400 --> 00:32:59,900
And also,

666
00:33:00,000 --> 00:33:04,400
The geez again can't quite do it's unfortunate hexadecimal drops a

667
00:33:04,400 --> 00:33:04,900
deaf.

668
00:33:05,400 --> 00:33:11,000
I'm not sure what is a good thing that kind of looks like a gee.

669
00:33:14,200 --> 00:33:19,800
Maybe see let's say it's almost a GU just you know it needs just a

670
00:33:19,800 --> 00:33:23,400
little these that little extra curl at the end and then it would be

671
00:33:23,400 --> 00:33:24,800
one maybe.

672
00:33:25,000 --> 00:33:25,600
I don't know.

673
00:33:27,100 --> 00:33:29,500
I think it's the best we're going to get so we're just have to accept

674
00:33:29,500 --> 00:33:29,800
it for now.

675
00:33:30,000 --> 00:33:33,400
Now, anyway and let's move that last rectangle.

676
00:33:36,600 --> 00:33:39,000
Okay, so

677
00:33:40,500 --> 00:33:43,300
Again, just finishing up here, making all these days, making all these

678
00:33:43,300 --> 00:33:45,500
bees, making all these seas.

679
00:33:46,100 --> 00:33:48,200
And those guys up top already 5S.

680
00:33:48,700 --> 00:33:53,200
Last time, c, b, a b, c d.

681
00:33:53,200 --> 00:33:55,300
Be a ABC.

682
00:33:55,300 --> 00:33:59,200
It's almost The Alphabet Song and then each of these guys again, I'm

683
00:33:59,200 --> 00:34:03,100
just going to override what's actually supposed to be in there.

684
00:34:04,900 --> 00:34:09,699
So that I can use that as sort of our little radioactive tracer so we

685
00:34:09,699 --> 00:34:14,100
can see what's going on and and just, you know, be sure of how the

686
00:34:14,100 --> 00:34:16,199
sort of shuffling Works.

687
00:34:16,600 --> 00:34:17,900
Alright, so

688
00:34:20,199 --> 00:34:21,100
I guess it doesn't need.

689
00:34:21,100 --> 00:34:21,900
This is in a race.

690
00:34:23,000 --> 00:34:26,500
Yeah, so let's go ahead and set a breakpoint there.

691
00:34:26,500 --> 00:34:30,100
I want to switch us back to debug mode for the moment, so that we

692
00:34:30,100 --> 00:34:31,900
don't have the compiler doing anything at all.

693
00:34:31,900 --> 00:34:37,000
I we want it to be completely, we want to completely stock, right?

694
00:34:37,000 --> 00:34:40,000
So I'm going to get rid of that 02, should probably put the O2 at the

695
00:34:40,000 --> 00:34:40,400
beginning.

696
00:34:40,400 --> 00:34:41,600
So it's easy for us to change.

697
00:34:41,600 --> 00:34:44,400
So that's the only parameter we ever modify.

698
00:34:45,400 --> 00:34:45,900
Anyway.

699
00:34:48,100 --> 00:34:49,000
so, coming in here,

700
00:34:50,300 --> 00:34:56,000
I'm going to stop here and when we load those guys, in essentially,

701
00:34:56,000 --> 00:35:02,300
what I want you to be able to see is when I go into the watch here and

702
00:35:02,300 --> 00:35:04,600
I've got Blended are

703
00:35:07,000 --> 00:35:17,200
oops, when dude are Blended e and dude be Blended a, is that if I want

704
00:35:17,200 --> 00:35:18,600
to I don't actually

705
00:35:20,300 --> 00:35:25,000
I love the way these guys get displayed to be honest with you because

706
00:35:25,100 --> 00:35:29,100
it's hard to actually see exactly what the register value actually

707
00:35:29,100 --> 00:35:29,400
does.

708
00:35:29,400 --> 00:35:33,400
I don't know if there's a way to nowadays in Visual Studio give it

709
00:35:33,400 --> 00:35:37,100
kind of an extended register thing but we can look at it in kind of a

710
00:35:37,100 --> 00:35:38,000
couple different ways.

711
00:35:38,400 --> 00:35:43,100
One way would be to just look at the M 128, u-32 value of it which you

712
00:35:43,100 --> 00:35:47,000
can see has the values in there so that they're pretty easy for us to

713
00:35:47,000 --> 00:35:48,800
see exactly where they are.

714
00:35:50,900 --> 00:35:54,100
And again, this is just a little bit easier than trying to use at

715
00:35:54,100 --> 00:35:58,100
least in my book is that then trying to actually use like one, two,

716
00:35:58,100 --> 00:35:59,800
three or four, but that would be the other way.

717
00:36:00,000 --> 00:36:02,700
It is if we try to use like, you know, some kind of number coded

718
00:36:02,700 --> 00:36:03,000
thing.

719
00:36:03,700 --> 00:36:05,900
So anyway, what I'm going to do is I'm going to tell the compiler to

720
00:36:05,900 --> 00:36:06,800
just I'm excited.

721
00:36:06,800 --> 00:36:10,200
Tell the debugger to just look at that value so we can see 128, you

722
00:36:10,200 --> 00:36:10,800
32.

723
00:36:11,000 --> 00:36:14,700
And so just on one line, we can see what's in that register right.

724
00:36:14,700 --> 00:36:15,400
There, it is.

725
00:36:16,200 --> 00:36:17,800
And and I guess I shouldn't say register.

726
00:36:17,800 --> 00:36:20,100
Just that value, we don't know if it's in a register at the moment or

727
00:36:20,100 --> 00:36:20,600
not.

728
00:36:23,200 --> 00:36:23,600
Yeah.

729
00:36:27,500 --> 00:36:27,900
Oops.

730
00:36:30,300 --> 00:36:30,900
Right?

731
00:36:31,100 --> 00:36:34,000
So there's our values and you can see, we've got our quote unquote,

732
00:36:34,000 --> 00:36:37,200
our are quote, unquote G&R be an RA, and we've got the different ones

733
00:36:37,200 --> 00:36:38,000
for different pixels.

734
00:36:38,000 --> 00:36:40,000
So this is the zeroth pixel.

735
00:36:40,000 --> 00:36:43,100
This is the first, the second, the third, right now, what we're going

736
00:36:43,100 --> 00:36:45,800
to do is we're going to come in here and build our hybrid values.

737
00:36:45,900 --> 00:36:50,100
So here is our 1 b 1 are 0 B 0, right?

738
00:36:50,400 --> 00:36:51,600
And what we want to see

739
00:36:53,300 --> 00:36:58,400
Because we want to see that value actually produced, right?

740
00:36:58,400 --> 00:36:59,900
So let's let's do that here.

741
00:37:00,500 --> 00:37:00,900
What is this?

742
00:37:00,900 --> 00:37:02,100
What is this saying?

743
00:37:08,100 --> 00:37:08,900
Sorry about that.

744
00:37:08,900 --> 00:37:10,900
It's a 128, I right?

745
00:37:11,100 --> 00:37:11,800
Of course.

746
00:37:11,800 --> 00:37:15,200
Because since they had to yeah they had to rename the member.

747
00:37:16,000 --> 00:37:16,700
Alright?

748
00:37:17,700 --> 00:37:22,500
So now that we've produced this, we can actually see whether this is

749
00:37:22,500 --> 00:37:23,000
what we've got.

750
00:37:23,200 --> 00:37:26,400
And unfortunately, it's listing these now in memory order, of course,

751
00:37:27,300 --> 00:37:32,300
again things it's always a struggle with the, with the little endian,

752
00:37:32,300 --> 00:37:34,200
because you always have to remember, which order they're actually

753
00:37:34,200 --> 00:37:34,800
doing things in.

754
00:37:34,800 --> 00:37:37,200
But when they list things and see arrays, they always list them in

755
00:37:37,200 --> 00:37:37,800
memory order.

756
00:37:38,400 --> 00:37:40,900
So, we can't actually see the register by itself.

757
00:37:40,900 --> 00:37:44,500
If we were to look at the register, of course, here is the register,

758
00:37:44,700 --> 00:37:47,800
and you can see it in register order, which of course, is going the

759
00:37:47,800 --> 00:37:48,700
other direction.

760
00:37:48,900 --> 00:37:50,300
It's all fantastic, right?

761
00:37:50,600 --> 00:37:51,600
That's just the way it goes.

762
00:37:52,000 --> 00:37:52,900
But anyway, you can see

763
00:37:53,100 --> 00:37:54,000
R that we got what we wanted.

764
00:37:54,000 --> 00:37:59,800
Be zeros in the bottom are zeros in the next be ones, following that

765
00:37:59,800 --> 00:38:01,100
in our ones following Matt.

766
00:38:01,100 --> 00:38:04,700
And so again, I just all I did here was, I used the structured art

767
00:38:04,700 --> 00:38:07,800
technique to make sure that we knew what we were actually doing,

768
00:38:07,800 --> 00:38:08,600
right?

769
00:38:08,600 --> 00:38:12,200
And especially when you're first working with these to get comforter

770
00:38:12,200 --> 00:38:12,600
with them.

771
00:38:12,800 --> 00:38:16,100
It helps to have very clear value because if these were just random

772
00:38:16,100 --> 00:38:17,700
floating-point things, we'd be like, I don't know.

773
00:38:17,700 --> 00:38:18,400
Okay.

774
00:38:18,400 --> 00:38:18,600
Wait.

775
00:38:18,600 --> 00:38:19,500
What was the Aragon?

776
00:38:19,500 --> 00:38:23,100
It was point zero three nine five, or everything was zero so we can

777
00:38:23,100 --> 00:38:25,700
Until what move where you never know, right.

778
00:38:25,800 --> 00:38:27,000
And so, in this case, it's much easier.

779
00:38:27,000 --> 00:38:29,400
Here we can see we did get our G zeros.

780
00:38:29,400 --> 00:38:32,200
A zero, g one's a one's right, so we've got it.

781
00:38:33,500 --> 00:38:36,700
And so, basically, all I've done there is just verified that we got

782
00:38:36,700 --> 00:38:40,100
the exact unpack that we actually wanted, right?

783
00:38:40,200 --> 00:38:43,800
And similarly I can go ahead and do this for any arbitrary number of

784
00:38:43,800 --> 00:38:44,000
these.

785
00:38:44,000 --> 00:38:47,000
But what I'm going to do is I'm just going to produce one final value

786
00:38:47,000 --> 00:38:47,400
here.

787
00:38:47,500 --> 00:38:51,300
I'm going to do the unpack low on these guys.

788
00:38:52,200 --> 00:38:55,700
Choose me to unpack that zeroth pixel, right.

789
00:38:56,200 --> 00:38:59,800
Like so so here's our 1 b 1 are 0 B 0 and here's

790
00:39:00,000 --> 00:39:05,000
1 g 1, a 0, g 0, like so and similarly we could actually produce

791
00:39:05,300 --> 00:39:08,000
number one here as well just by doing an unpack.

792
00:39:08,200 --> 00:39:09,400
Hi, right?

793
00:39:10,600 --> 00:39:14,400
So here we go and off we go.

794
00:39:17,700 --> 00:39:21,800
So let's take a look at what we actually produced a RGB 0, right?

795
00:39:22,400 --> 00:39:25,400
And you can see, if I take a look at the value that we produce their

796
00:39:25,400 --> 00:39:29,500
after this next Shuffle, we got exactly what we want.

797
00:39:30,300 --> 00:39:36,000
We got d, g are a, which is the memory order that we wanted, our gp1

798
00:39:36,000 --> 00:39:36,800
and 128.

799
00:39:36,800 --> 00:39:40,100
I use 32 same thing but now it's the first pixel.

800
00:39:40,300 --> 00:39:44,300
So what we've essentially done here is produced to correct packed

801
00:39:44,300 --> 00:39:46,300
pixel values unfortunately.

802
00:39:48,000 --> 00:39:51,800
We still, quite haven't quite gotten to where we need to go, not just

803
00:39:51,800 --> 00:39:54,000
because we haven't produced the rest of the values yet but also

804
00:39:54,000 --> 00:39:57,500
because they're still in 32-bit floating-point, right?

805
00:39:57,500 --> 00:40:01,000
But let's finish just so we can see exactly what's going on here.

806
00:40:01,100 --> 00:40:04,200
What we would need to do essentially is unpack the High bits of these

807
00:40:04,200 --> 00:40:05,400
guys, right?

808
00:40:05,700 --> 00:40:08,900
And by unpacking the high B, what we do is we change from extracting

809
00:40:08,900 --> 00:40:13,800
those low pixels to attracting the to high pixels and then we would do

810
00:40:13,800 --> 00:40:17,000
exactly the same unpack here for two and

811
00:40:17,100 --> 00:40:18,100
Really right.

812
00:40:18,700 --> 00:40:19,400
That's it.

813
00:40:19,500 --> 00:40:21,200
It's literally the exact same thing.

814
00:40:26,200 --> 00:40:26,700
There you go.

815
00:40:28,600 --> 00:40:32,100
And although it's kind of meticulous and fussy, really, there's not

816
00:40:32,100 --> 00:40:36,000
much to it, you know, that's that's really all there is and if you

817
00:40:36,000 --> 00:40:37,000
come through here, you can see.

818
00:40:37,000 --> 00:40:40,600
Now we have actually produced all the pixel values that we actually

819
00:40:40,600 --> 00:40:41,300
wanted.

820
00:40:41,400 --> 00:40:45,500
The problem is that they are just in the wrong format.

821
00:40:45,500 --> 00:40:48,200
They're still 32 bit float, but there they all are right.

822
00:40:48,200 --> 00:40:51,200
There's the interleaved pixels, and off you go.

823
00:40:51,200 --> 00:40:52,500
Now, you can see that already.

824
00:40:52,500 --> 00:40:54,700
It's kind of annoying, like, look at how many instructions and took us

825
00:40:54,700 --> 00:40:55,500
to do that.

826
00:40:55,600 --> 00:40:56,800
It's kind of grumpy, right?

827
00:40:56,800 --> 00:40:58,100
But that's just the way it goes.

828
00:40:58,300 --> 00:41:01,900
Cindy, sometimes, when you have to take things that were in the nice,

829
00:41:01,900 --> 00:41:04,900
70 format, you're working on, and shuffle them around, to put them off

830
00:41:04,900 --> 00:41:08,600
into an interleaved source that is always kind of annoying and so you

831
00:41:08,600 --> 00:41:12,400
can kind of see it happening here but we can you know, we might be

832
00:41:12,400 --> 00:41:14,800
able to do some mitigation of that as you'll see as we go a little bit

833
00:41:14,800 --> 00:41:15,100
forward.

834
00:41:15,100 --> 00:41:17,500
So I'm going to leave the structured art stuff in here so you can see.

835
00:41:18,000 --> 00:41:20,100
But now let's talk about the second part of this problem.

836
00:41:20,100 --> 00:41:22,500
So you saw how we did interleaving, hopefully that's pretty clear.

837
00:41:22,600 --> 00:41:24,600
Again, it's very fussy but it's pretty straightforward.

838
00:41:24,600 --> 00:41:28,000
All we were doing is using one sort of set.

839
00:41:28,200 --> 00:41:32,100
Get one pair of instructions, low and high unpack of 32-bit values to

840
00:41:32,100 --> 00:41:36,400
do, basically that's wrestling in what we had to do is essentially to

841
00:41:36,400 --> 00:41:37,800
produce four pixels.

842
00:41:37,800 --> 00:41:40,900
We had to use eight unpacks, right?

843
00:41:42,100 --> 00:41:42,800
That was that.

844
00:41:43,500 --> 00:41:47,600
Alright, so now we have to talk about another thing which is how do we

845
00:41:47,900 --> 00:41:51,400
generate values that are actually going to be what we needed them to

846
00:41:51,400 --> 00:41:55,300
be, which is eight bits instead of 32 bit floating point.

847
00:41:55,300 --> 00:41:58,400
And so, in order to do that, well, we've got some things that we can

848
00:41:58,400 --> 00:41:59,900
just do, right?

849
00:42:00,800 --> 00:42:03,600
We can certainly do a plus point five.

850
00:42:03,800 --> 00:42:06,100
That's something that we know how to do, right?

851
00:42:06,200 --> 00:42:09,200
We can certainly do a times 255.

852
00:42:09,200 --> 00:42:11,100
That's something that we know how to do, right?

853
00:42:11,100 --> 00:42:12,100
So we know all these sorts of things.

854
00:42:12,100 --> 00:42:14,900
So, you can see, we already are doing the time to T5 up here.

855
00:42:14,900 --> 00:42:18,000
So, we've already converted it to that range.

856
00:42:18,000 --> 00:42:21,100
So, all we really need to do to finish off, what was happening down

857
00:42:21,100 --> 00:42:25,900
here, is to take that plus 0.5 and translate that up here, so that's

858
00:42:25,900 --> 00:42:27,700
something we can just do, right?

859
00:42:27,900 --> 00:42:29,800
That's something that we could have just added.

860
00:42:30,000 --> 00:42:30,900
Add to this, right?

861
00:42:30,900 --> 00:42:32,400
We could do an M&M, add PS.

862
00:42:32,400 --> 00:42:33,600
So if we need to do that, we can.

863
00:42:33,700 --> 00:42:38,800
But let's quickly take a look first to see at what's going to happen

864
00:42:39,300 --> 00:42:42,700
when we need to actually produce integers instead of floats.

865
00:42:43,200 --> 00:42:46,200
So what we have for that is there's conversion instructions.

866
00:42:46,200 --> 00:42:48,600
You can see them here, they're called convert.

867
00:42:48,800 --> 00:42:52,700
And so like, you can take a look here, convert PS epi32 convert

868
00:42:52,700 --> 00:42:56,100
packed, single 32-bit, floating-point elements to pack, 32-bit

869
00:42:56,100 --> 00:42:59,800
integers and store the result in dest, right?

870
00:43:00,100 --> 00:43:02,200
And so that's exactly what we want to have happen.

871
00:43:02,300 --> 00:43:06,100
This is the thing that we wanted we want to have a way to convert are

872
00:43:06,100 --> 00:43:09,500
integers, but I miss our floating Point values are integers and you

873
00:43:09,500 --> 00:43:09,900
can see that.

874
00:43:09,900 --> 00:43:12,100
It's just it was a single instruction that does that, it's not

875
00:43:12,100 --> 00:43:13,000
particularly difficult.

876
00:43:13,000 --> 00:43:14,900
It's convert PS epi32.

877
00:43:15,100 --> 00:43:18,100
So what we can do here is we can actually just do that, right?

878
00:43:18,100 --> 00:43:22,900
We can make a one M&M 128, I, that's basically our into our, or

879
00:43:22,900 --> 00:43:24,600
whatever we could call it, right?

880
00:43:24,900 --> 00:43:29,500
And that's just going to be calling that intrinsic, mmm convert.

881
00:43:29,900 --> 00:43:33,300
Yes, epi32 again that naming convention is basically.

882
00:43:33,400 --> 00:43:35,000
PS is packed single.

883
00:43:35,200 --> 00:43:38,400
Epi32 is extended packed.

884
00:43:38,400 --> 00:43:40,200
Integer 32-bit right?

885
00:43:40,200 --> 00:43:41,500
I believe is what that is?

886
00:43:41,500 --> 00:43:43,600
I believe the he's for extended to be honest with you.

887
00:43:43,600 --> 00:43:45,400
I don't think I've ever actually been told what it is.

888
00:43:45,400 --> 00:43:51,300
I just I just assumed and so yeah, pack integers that are 32 bits wide

889
00:43:51,400 --> 00:43:52,700
so that's what we're going to do here.

890
00:43:52,800 --> 00:43:56,200
And again all we have to do is just do that to convert four of them at

891
00:43:56,200 --> 00:43:56,500
once.

892
00:43:56,500 --> 00:43:59,700
So we have this converting each of our

893
00:44:00,000 --> 00:44:04,300
Going to take four of those instructions to convert each of our things

894
00:44:04,300 --> 00:44:05,900
into integer, and there they are.

895
00:44:06,000 --> 00:44:09,900
Right now, the question is, when it does that conversion, what

896
00:44:09,900 --> 00:44:12,300
rounding mode is it using, is it using truncation?

897
00:44:12,500 --> 00:44:14,200
Is it using round to nearest?

898
00:44:14,300 --> 00:44:15,000
What's it doing?

899
00:44:15,100 --> 00:44:17,700
Because if it's using round to nearest, then we don't need to add the

900
00:44:17,700 --> 00:44:18,400
point five.

901
00:44:18,500 --> 00:44:21,000
If it's using truncation, then we do, right?

902
00:44:21,000 --> 00:44:25,600
And so we kind of need to know what the rounding is actually going to

903
00:44:25,600 --> 00:44:26,000
be.

904
00:44:26,100 --> 00:44:26,300
Now.

905
00:44:26,300 --> 00:44:29,800
Unfortunately, there actually is no way to know

906
00:44:29,900 --> 00:44:34,000
Know what the rounding mode is going to be, unless we set it because

907
00:44:34,000 --> 00:44:40,900
the way that the SSE registers actually work for these operations is

908
00:44:40,900 --> 00:44:45,000
they actually use a mode that says which way things should be rounded

909
00:44:45,000 --> 00:44:47,900
and that mode can be set to any number of different rounding

910
00:44:48,200 --> 00:44:49,100
methodologies.

911
00:44:49,400 --> 00:44:55,100
So what I'm going to do here is I'm going to do set the rounding mode

912
00:44:56,300 --> 00:44:59,500
to something known and we'll come back to that later for now, we'll

913
00:44:59,500 --> 00:44:59,800
Justice.

914
00:45:00,000 --> 00:45:03,200
I'm that it rounded in the way that we wanted to round, and we'll,

915
00:45:03,700 --> 00:45:05,400
we'll deal with it a little bit later, right?

916
00:45:05,400 --> 00:45:07,700
Because that's a separate a separate concern.

917
00:45:08,800 --> 00:45:13,400
All right, so once we have these into integer format, we now have

918
00:45:13,400 --> 00:45:16,900
another problem which is that there are 32 bits wide but we actually

919
00:45:16,900 --> 00:45:21,200
want them to only we actually only want to use 8 Bits out of that,

920
00:45:21,200 --> 00:45:21,600
right?

921
00:45:21,700 --> 00:45:26,400
So what we want to do is we would like to be able to you know, get

922
00:45:26,400 --> 00:45:31,200
these things together in some kind of a more useful fashion, right?

923
00:45:32,900 --> 00:45:35,400
Okay, so we covered how to do it this way.

924
00:45:35,400 --> 00:45:38,200
We covered how to do the interleaving if you were trying to delete the

925
00:45:38,200 --> 00:45:41,400
things that float, but let's take a look at what happens if there if

926
00:45:41,400 --> 00:45:43,000
we now have integers, right?

927
00:45:43,200 --> 00:45:47,800
So we have integers and we know that those integers are going to be

928
00:45:47,800 --> 00:45:50,400
eight bits because we clamped them already.

929
00:45:50,500 --> 00:45:51,100
Right?

930
00:45:51,400 --> 00:45:53,400
I believe, we already have a clamp in here.

931
00:45:53,700 --> 00:45:54,900
You can see our min-max.

932
00:45:54,900 --> 00:45:55,500
PS.

933
00:45:55,600 --> 00:45:58,200
So we know they're between 0 and 1, and then we know it's Lima 255.

934
00:45:58,200 --> 00:46:01,600
So we pretty much know what the integers are that are coming out of

935
00:46:01,600 --> 00:46:02,500
here, right?

936
00:46:03,100 --> 00:46:04,100
And the integers.

937
00:46:04,700 --> 00:46:05,100
Oops.

938
00:46:07,300 --> 00:46:12,600
Are going to be 32 bits wide, okay, but only the bottom eight bits are

939
00:46:12,600 --> 00:46:16,800
going to be used so we're going to have 88 you know eight-eight like

940
00:46:16,800 --> 00:46:17,900
so right.

941
00:46:17,900 --> 00:46:23,500
So we're going to have you know, the ours looking like this R1 R2 R3

942
00:46:23,500 --> 00:46:26,800
and then we're going to have the same thing happening.

943
00:46:28,900 --> 00:46:29,400
Right.

944
00:46:33,200 --> 00:46:37,600
With the geez g0 G1 G2 G3, right?

945
00:46:38,400 --> 00:46:43,500
So if you look at these, we may write.

946
00:46:43,500 --> 00:46:47,200
If you look at how these are lined up, we could because we know all of

947
00:46:47,200 --> 00:46:48,500
these is zero, right?

948
00:46:48,500 --> 00:46:50,000
All of this is 0 in here.

949
00:46:51,500 --> 00:46:55,000
What we could do instead of doing the kind of interleave that we had

950
00:46:55,000 --> 00:46:58,600
to do, if we were trying to produce them, actually, as floating point,

951
00:46:58,800 --> 00:46:59,400
right?

952
00:47:00,000 --> 00:47:06,000
What we could do instead is we could just shift up if we could move,

953
00:47:06,000 --> 00:47:10,100
you know this this these 8 Bits to the next 8 Bits over.

954
00:47:10,600 --> 00:47:11,500
Do you know to here?

955
00:47:12,100 --> 00:47:17,900
We could then just or these registers together to produce the correct

956
00:47:17,900 --> 00:47:19,300
values, right?

957
00:47:19,400 --> 00:47:20,500
In other words, we could do this

958
00:47:20,700 --> 00:47:24,700
Same ending and shifting operation, that we were doing here where we

959
00:47:24,700 --> 00:47:30,000
shift them up, we could do the exact same thing for the wide

960
00:47:30,000 --> 00:47:31,400
registers, right?

961
00:47:32,300 --> 00:47:34,600
So let's see if we can't do it that way, I showed you how to do it one

962
00:47:34,600 --> 00:47:35,200
way here.

963
00:47:35,800 --> 00:47:38,800
And what we could have done here is I guess convert these these two

964
00:47:38,800 --> 00:47:40,300
integers then pack them down or something.

965
00:47:40,500 --> 00:47:44,300
But let's try doing it the other way.

966
00:47:44,500 --> 00:47:49,400
All right, so I'm going to go ahead and if zero out this so, okay?

967
00:47:49,700 --> 00:47:50,500
I'm going to get rid of

968
00:47:50,600 --> 00:47:51,000
This.

969
00:47:52,400 --> 00:47:52,900
There we go.

970
00:47:54,000 --> 00:47:57,400
So if we've got these, let's see how we would do that.

971
00:47:57,400 --> 00:47:59,500
Well, we know that we want the lowest

972
00:48:00,000 --> 00:48:01,500
You to BB, right?

973
00:48:01,500 --> 00:48:05,600
So if we were to do, we already know that we can basically do all of

974
00:48:05,600 --> 00:48:10,500
our math Ops and you can see, actually I guess we haven't ever shown

975
00:48:10,500 --> 00:48:10,900
this one.

976
00:48:10,900 --> 00:48:12,200
So let me just show it here.

977
00:48:15,200 --> 00:48:15,800
Okay, ma'am.

978
00:48:16,000 --> 00:48:21,000
Or yes you can see that we have bitwise operations on these guys.

979
00:48:21,100 --> 00:48:27,300
So if we want to we can go ahead and or in to, you know, values

980
00:48:27,300 --> 00:48:28,500
together, right?

981
00:48:28,500 --> 00:48:31,900
So all we would really need is the ability to shift them around.

982
00:48:32,000 --> 00:48:32,500
Right?

983
00:48:32,600 --> 00:48:35,000
We would, you know, we can order them together but we don't have any

984
00:48:35,000 --> 00:48:36,000
way to shift them around.

985
00:48:36,200 --> 00:48:41,000
So I can if I want to produce my outgoing pixel value, like my result

986
00:48:41,000 --> 00:48:42,300
value or something like that, I don't know.

987
00:48:42,300 --> 00:48:43,200
We'll call that.

988
00:48:44,700 --> 00:48:45,500
Our out value.

989
00:48:45,500 --> 00:48:49,800
I'm not sure we could go ahead and do that by putting together.

990
00:48:49,800 --> 00:48:50,900
All of these things, right?

991
00:48:50,900 --> 00:48:56,100
Like into our inch g into the and a like so on and just ordering them

992
00:48:56,100 --> 00:48:57,100
all together.

993
00:49:01,200 --> 00:49:08,700
But what we don't know, right is how to do the shifting, right?

994
00:49:08,800 --> 00:49:12,300
So, we've got all these values, but we have absolutely no idea how we

995
00:49:12,300 --> 00:49:13,400
would shift any of them.

996
00:49:15,900 --> 00:49:16,400
Excuse me.

997
00:49:19,300 --> 00:49:21,000
All right, did I do that right?

998
00:49:21,000 --> 00:49:25,500
So this or this that or this that or this.

999
00:49:25,500 --> 00:49:27,500
I don't need four ORS.

1000
00:49:27,500 --> 00:49:28,800
I only need three.

1001
00:49:29,300 --> 00:49:29,800
There we go.

1002
00:49:31,000 --> 00:49:34,100
So the problem is how do we actually shift these guys, right?

1003
00:49:34,700 --> 00:49:38,100
So what we want to do is we want to find some operations that actually

1004
00:49:38,100 --> 00:49:39,700
do shifting.

1005
00:49:39,700 --> 00:49:43,400
So I'm going to check the bit molybdenum it manipulation when here so

1006
00:49:43,400 --> 00:49:44,500
we can take a look at them.

1007
00:49:46,300 --> 00:49:48,200
Although I don't know why, it's not actually showing me anything.

1008
00:49:48,300 --> 00:49:52,400
I guess yoq shift I guess bit manipulation of something else.

1009
00:49:52,800 --> 00:49:55,900
So here's my shifts and what you can see about the shifts is,

1010
00:49:55,900 --> 00:49:56,500
unfortunately.

1011
00:49:56,500 --> 00:49:58,900
The shifts are all.

1012
00:50:00,400 --> 00:50:01,600
Oh wait, never mind.

1013
00:50:01,900 --> 00:50:03,300
I was about to say, unfortunately.

1014
00:50:03,300 --> 00:50:04,100
But that's not true.

1015
00:50:04,400 --> 00:50:06,400
We are not actually in

1016
00:50:08,700 --> 00:50:09,600
44 in anymore.

1017
00:50:10,500 --> 00:50:12,000
Sorry, I don't know where my head is tonight.

1018
00:50:12,200 --> 00:50:12,700
My bad.

1019
00:50:13,800 --> 00:50:14,500
So, that's fine.

1020
00:50:14,600 --> 00:50:18,400
So our shifts are or Lon s eyes, which is what we want.

1021
00:50:18,400 --> 00:50:21,500
And you can see here that we have a number of different options for

1022
00:50:21,500 --> 00:50:22,400
how we shift.

1023
00:50:22,400 --> 00:50:26,900
And what they are is they're what the width is of the shift, right?

1024
00:50:27,100 --> 00:50:32,400
So, what you can see, there is essentially like some of these things

1025
00:50:32,400 --> 00:50:37,500
like shift left and so on, what they will do, is they will clip when

1026
00:50:37,500 --> 00:50:40,000
they do the shift, based on the width that you say.

1027
00:50:40,300 --> 00:50:43,500
So, if you do a 32-bit one of these, if you do the EPA,

1028
00:50:43,700 --> 00:50:48,500
32 where it's talking about 32-bit wide, then B will shift up until

1029
00:50:48,500 --> 00:50:51,000
they hit here and then they will just shift out, right?

1030
00:50:51,100 --> 00:50:55,200
They won't cross this barrier where as if you were to use the 16-bit

1031
00:50:55,200 --> 00:50:59,900
wide version you would actually start clipping out on the

1032
00:51:00,000 --> 00:51:00,200
Bit.

1033
00:51:00,200 --> 00:51:04,100
So you shift up but when you hit the 16, you would stop, right?

1034
00:51:04,200 --> 00:51:07,400
So basically, what this does is it picks the compartment, the car, the

1035
00:51:07,400 --> 00:51:10,600
compartments for the shift and you'll notice there's other, there's

1036
00:51:10,600 --> 00:51:14,500
two kinds of shifters, for shift left, it's always logical.

1037
00:51:15,900 --> 00:51:17,100
But for shift, right?

1038
00:51:17,100 --> 00:51:19,900
There's two kinds logical in their arithmetic.

1039
00:51:20,400 --> 00:51:24,400
And what that is is just a quickly say, since we haven't ever covered

1040
00:51:24,400 --> 00:51:28,800
that in handmade hero when you're shifting values left, then the bits

1041
00:51:28,800 --> 00:51:31,400
that shift in, from this side are always zero, right?

1042
00:51:31,500 --> 00:51:35,600
So if I had some value, like 1, 1 1, right or whatever and I shift

1043
00:51:35,600 --> 00:51:39,200
that left, that I know that I'm always going to fill in the spots that

1044
00:51:39,200 --> 00:51:43,300
I shifted with zeros, but when you shift, right?

1045
00:51:43,900 --> 00:51:45,700
There's two things you could fill with.

1046
00:51:46,800 --> 00:51:50,900
So let's say, I have 1, 1, 1 0, 0, 0, 0, 0, or something like this.

1047
00:51:50,900 --> 00:51:52,200
And I want to shift it.

1048
00:51:52,300 --> 00:51:56,600
If I want to shift it that way, I could fill it in with zeros, right?

1049
00:51:58,400 --> 00:52:01,800
Or I could fill it in with whatever the high bit is.

1050
00:52:02,300 --> 00:52:05,400
So if the high bit is 1, I could fill it in with that.

1051
00:52:05,500 --> 00:52:06,400
So I'd get this.

1052
00:52:06,400 --> 00:52:06,800
Oops.

1053
00:52:08,000 --> 00:52:08,700
Instead.

1054
00:52:08,700 --> 00:52:09,700
Right?

1055
00:52:09,700 --> 00:52:14,000
And the reason they do that is because two's complement the way of

1056
00:52:14,000 --> 00:52:15,800
storing negative numbers, right?

1057
00:52:15,800 --> 00:52:19,300
Always has the high bit set if the number is negative.

1058
00:52:19,300 --> 00:52:24,100
And so, if you want to use a shift to a proximate dividing, if you

1059
00:52:24,100 --> 00:52:27,300
want to use like a divided by two to do the shift, you want to keep

1060
00:52:27,300 --> 00:52:29,400
the number - if it was - originally.

1061
00:52:29,400 --> 00:52:32,400
And so, the shift does that, that arithmetic shift.

1062
00:52:32,400 --> 00:52:34,500
That's why it's called an arithmetic instead of a logical shift

1063
00:52:34,500 --> 00:52:37,900
because it's for when you're doing arithmetic, that's what

1064
00:52:38,000 --> 00:52:40,100
Is we don't care about that at all right.

1065
00:52:40,100 --> 00:52:43,300
Now I just wanted to mention as an aside, okay?

1066
00:52:44,800 --> 00:52:47,600
So to get these things lined up, all I need to do is I need to do a

1067
00:52:47,600 --> 00:52:52,000
32-bit wide shifts that, I need to shift things up by 8, 16 or 24, the

1068
00:52:52,000 --> 00:52:55,100
same exact way that I was doing it down here.

1069
00:52:55,100 --> 00:52:58,500
So we're literally going to do an exact translation of this code,

1070
00:52:58,500 --> 00:52:59,000
right?

1071
00:53:00,100 --> 00:53:03,200
So the egg gets shifted up by 24, right?

1072
00:53:03,200 --> 00:53:04,300
So I'm just going to throw that in there.

1073
00:53:04,300 --> 00:53:08,100
Mmm, I want a shift left, logical.

1074
00:53:08,300 --> 00:53:10,500
And also, I should mention one more thing.

1075
00:53:11,000 --> 00:53:14,400
So there's two things here, shift left, logical immediate,

1076
00:53:14,600 --> 00:53:18,300
And shift left, logical, shift, left, logical, immediate shifts by a

1077
00:53:18,300 --> 00:53:23,300
fixed value shift left logical without the immediate shifts by another

1078
00:53:23,300 --> 00:53:23,900
register.

1079
00:53:23,900 --> 00:53:25,100
That tells it how to shift.

1080
00:53:25,100 --> 00:53:27,600
We don't need that right now, but you can see why that might be

1081
00:53:27,600 --> 00:53:30,000
something interesting, right?

1082
00:53:30,200 --> 00:53:32,900
Okay, so we're going to do the shift left immediate.

1083
00:53:32,900 --> 00:53:36,000
We need to shift the a up by 24, so, there it is.

1084
00:53:36,500 --> 00:53:38,700
We need to do the shift left, logical.

1085
00:53:38,700 --> 00:53:44,100
Oops, I forgot the Epi 3232, we need the sheet.

1086
00:53:46,100 --> 00:53:50,600
The shift left logical, immediate 32 cure for the be well, I guess we

1087
00:53:50,600 --> 00:53:52,800
don't the be stays in the bottom, right?

1088
00:53:53,600 --> 00:53:54,900
The be doesn't actually go anywhere.

1089
00:53:55,400 --> 00:53:59,800
So for the G we need to shift that up by 8 and for the are

1090
00:54:00,000 --> 00:54:02,900
Need to shift that up by 16, right?

1091
00:54:02,900 --> 00:54:05,700
And so now we're back to doing the exact same operations we were

1092
00:54:05,700 --> 00:54:07,400
before, right?

1093
00:54:08,400 --> 00:54:10,000
And and off we go.

1094
00:54:10,000 --> 00:54:13,800
Now, I should actually point out that or is Ann Ann's.

1095
00:54:13,800 --> 00:54:16,500
Don't actually care what the width is because the B get treated,

1096
00:54:16,500 --> 00:54:18,300
there's no movement.

1097
00:54:18,300 --> 00:54:22,700
So really, I believe it's just I believe the mnemonic for or is always

1098
00:54:22,700 --> 00:54:23,100
the same.

1099
00:54:23,100 --> 00:54:26,900
You don't actually need the epi32 or to say what the width is.

1100
00:54:26,900 --> 00:54:28,800
I think it's just si128 all the time.

1101
00:54:28,800 --> 00:54:29,900
That's my recollection.

1102
00:54:30,000 --> 00:54:32,000
Election anyway, let me see if I'm right about that.

1103
00:54:34,800 --> 00:54:37,200
Mmm or Hoops for.

1104
00:54:37,600 --> 00:54:40,200
Yeah, it's always si128 because you don't care.

1105
00:54:40,200 --> 00:54:43,700
If there's no, it doesn't move bits around or carry or add or any of

1106
00:54:43,700 --> 00:54:44,300
that stuff.

1107
00:54:44,600 --> 00:54:45,700
So it's always the same.

1108
00:54:45,800 --> 00:54:49,300
Right SLI.

1109
00:54:49,300 --> 00:54:53,400
Epi32 did I use the name wrong?

1110
00:54:53,700 --> 00:54:54,500
What I do there?

1111
00:54:55,100 --> 00:54:56,600
Give us give me my shift back.

1112
00:54:57,900 --> 00:55:00,500
SLI epi32.

1113
00:55:03,800 --> 00:55:05,200
Oh, I had an extra underscoring.

1114
00:55:05,200 --> 00:55:09,400
That's all right, so let's take a look at that out value.

1115
00:55:09,400 --> 00:55:19,600
Now, if I may here after we produce it here, Oops, stop it there.

1116
00:55:20,400 --> 00:55:24,300
So let's take a look at what that out value ended up being we have our

1117
00:55:25,900 --> 00:55:28,100
Oh, my bad.

1118
00:55:28,700 --> 00:55:29,500
I take it back.

1119
00:55:29,600 --> 00:55:33,200
We don't actually have our are structured art in there.

1120
00:55:33,400 --> 00:55:36,900
So what I want to do is I want to move the structure Dart up here so I

1121
00:55:36,900 --> 00:55:40,300
can actually overwrite these after their conversion.

1122
00:55:41,100 --> 00:55:44,200
So, what I want to do is I want to say that, you know, each of our

1123
00:55:44,500 --> 00:55:52,400
print, our energy, our in, to be inch, a are all going to be loaded

1124
00:55:52,400 --> 00:55:55,100
with those sort of faux values, if you will.

1125
00:55:55,800 --> 00:55:57,600
I guess, use integers.

1126
00:55:57,800 --> 00:55:58,200
We go.

1127
00:56:00,200 --> 00:56:02,700
Okay, so off we go.

1128
00:56:04,600 --> 00:56:05,600
and,

1129
00:56:07,500 --> 00:56:08,800
Let's see what we've got here.

1130
00:56:09,400 --> 00:56:10,900
So our out value

1131
00:56:12,500 --> 00:56:15,500
well, first, let's see what our interests are and so on values are

1132
00:56:16,800 --> 00:56:18,800
Got em, 128, you 32.

1133
00:56:21,500 --> 00:56:25,500
Okay, so each of these should be the correct values here.

1134
00:56:27,000 --> 00:56:28,400
No G.

1135
00:56:30,600 --> 00:56:31,100
P.

1136
00:56:32,800 --> 00:56:34,800
A Okay.

1137
00:56:35,600 --> 00:56:39,100
So we've got all the values that are what we think they should be

1138
00:56:39,300 --> 00:56:40,000
right?

1139
00:56:40,400 --> 00:56:41,500
And then we have our out.

1140
00:56:41,500 --> 00:56:46,800
Value .m 128, I utility to and let's see what it equals.

1141
00:56:47,400 --> 00:56:50,400
So that's is not what I wanted at all.

1142
00:56:50,800 --> 00:56:51,700
What is that?

1143
00:56:52,600 --> 00:56:54,400
What are those F's doing there?

1144
00:56:55,400 --> 00:56:56,000
It's not at all.

1145
00:56:56,000 --> 00:56:59,100
Correct, our bees are correct, right?

1146
00:56:59,300 --> 00:56:59,900
But our other

1147
00:57:00,000 --> 00:57:03,400
Values are not correct, and I'm not sure why, right?

1148
00:57:04,100 --> 00:57:06,200
So, let's, let's take a look at what?

1149
00:57:06,200 --> 00:57:12,200
I'm wonder if I wonder if I use the wrong thing here.

1150
00:57:12,200 --> 00:57:12,700
Let's see.

1151
00:57:14,100 --> 00:57:18,300
Shift factories just you know left by immediate 8 while shifting in

1152
00:57:18,300 --> 00:57:22,200
zeros and store results in dest, right?

1153
00:57:23,100 --> 00:57:24,100
And so oh oh!

1154
00:57:24,100 --> 00:57:24,800
Oh oh

1155
00:57:25,900 --> 00:57:26,600
Is that?

1156
00:57:26,800 --> 00:57:28,500
No, no, I can, that's fine.

1157
00:57:29,400 --> 00:57:30,900
I can shift as many as I wanted to.

1158
00:57:31,200 --> 00:57:32,300
So what was the problem here?

1159
00:57:32,300 --> 00:57:34,700
People, let's take a look at what happened here.

1160
00:57:34,900 --> 00:57:37,300
I want to see what the actual values are, so I'm going to break out

1161
00:57:37,300 --> 00:57:40,900
this routine a little bit further and then we're pretty much done.

1162
00:57:40,900 --> 00:57:43,000
So hopefully this will be like the last thing we do.

1163
00:57:45,000 --> 00:57:49,000
So, let's let's do our shifted values here, right?

1164
00:57:51,100 --> 00:57:56,300
She be an A and then I'm going to go ahead and just grab these guys

1165
00:57:56,300 --> 00:57:57,900
out of here, right?

1166
00:58:01,800 --> 00:58:04,600
Sargi, there's our pee.

1167
00:58:05,900 --> 00:58:10,400
And there's our, a SRS G be.

1168
00:58:11,600 --> 00:58:18,400
SI and so I should be able to expect these right and see what the what

1169
00:58:18,400 --> 00:58:19,700
the Oddity is there.

1170
00:58:20,800 --> 00:58:24,500
Let's go ahead and run that and so RS are.

1171
00:58:29,100 --> 00:58:35,600
Is as follows that is 0.

1172
00:58:40,500 --> 00:58:46,100
Well, I was hoarse by my own petard there, as they say, I forgot.

1173
00:58:46,200 --> 00:58:49,400
We're expecting these values to be in the range of 0 to 255.

1174
00:58:49,400 --> 00:58:53,900
So we were expecting these to already have been zeroed out.

1175
00:58:54,500 --> 00:59:00,700
So yes, my my test case was not, particularly well constructed admit

1176
00:59:00,700 --> 00:59:01,200
that.

1177
00:59:01,400 --> 00:59:04,100
So let's go ahead and try that one more time.

1178
00:59:04,900 --> 00:59:06,000
Let's see if we can't.

1179
00:59:08,400 --> 00:59:10,800
See if we can't get more reasonable results.

1180
00:59:10,800 --> 00:59:11,100
Yes.

1181
00:59:11,100 --> 00:59:15,100
So obviously the stuff coming out of this pipeline will all Willy's B8

1182
00:59:15,100 --> 00:59:16,700
B because we clamped it.

1183
00:59:17,100 --> 00:59:22,700
So we know that we've only got eight bits in each case.

1184
00:59:23,900 --> 00:59:24,400
All right.

1185
00:59:26,200 --> 00:59:28,100
There we go, much better.

1186
00:59:28,800 --> 00:59:34,200
So now if we do this, hoping

1187
00:59:35,400 --> 00:59:39,200
yeah, we will see our stuff, much more intelligently lined up and

1188
00:59:39,200 --> 00:59:39,800
there we go.

1189
00:59:39,800 --> 00:59:46,200
So there's be gra, be gra, be gra, be gra.

1190
00:59:46,800 --> 00:59:49,800
And so, as you can see, it's essentially, you know, I taught you how

1191
00:59:49,800 --> 00:59:53,700
to do the unpacked version, which is if you needed to interleave the

1192
00:59:53,700 --> 00:59:54,800
things as float.

1193
00:59:55,300 --> 00:59:58,900
But as you saw here in the case, where you don't have to interleave

1194
00:59:58,900 --> 00:59:59,800
them as float,

1195
01:00:00,000 --> 01:00:00,900
You can actually do it.

1196
01:00:00,900 --> 01:00:04,800
Much almost exactly the same way that we were doing in here because

1197
01:00:04,800 --> 01:00:08,100
you happen to have the small values all sitting in the registers in

1198
01:00:08,100 --> 01:00:13,100
the right places, you can just shift them over and sort of do that or

1199
01:00:13,700 --> 01:00:16,000
so if I get rid of this part here,

1200
01:00:18,100 --> 01:00:18,400
Right?

1201
01:00:18,400 --> 01:00:22,400
If I click this stuff out, what you can see is that now we've set

1202
01:00:22,400 --> 01:00:25,700
ourselves up to essentially do this hole right here, right?

1203
01:00:26,100 --> 01:00:30,700
So I can take that out and I can essentially just write it to pixel,

1204
01:00:30,900 --> 01:00:31,400
right?

1205
01:00:31,500 --> 01:00:38,900
I can stay if I pretend that pixel is an M 128, I write, I can

1206
01:00:38,900 --> 01:00:42,700
essentially just assign out to it and that should write out the values

1207
01:00:42,700 --> 01:00:45,200
that I produced packed, right?

1208
01:00:46,100 --> 01:00:47,700
And so if we take a look at that,

1209
01:00:49,300 --> 01:00:53,500
We can see that we've essentially gotten exactly what we had started

1210
01:00:53,500 --> 01:00:58,100
with which is the black bar version of the blit, right?

1211
01:00:58,300 --> 01:01:00,300
But that it removes that entire thing there.

1212
01:01:00,300 --> 01:01:05,600
And if we go over 20 to right, we should also see that it you know, it

1213
01:01:05,600 --> 01:01:06,500
didn't slow us down at.

1214
01:01:06,500 --> 01:01:07,500
All right.

1215
01:01:08,200 --> 01:01:08,400
Uh-oh.

1216
01:01:10,300 --> 01:01:16,800
I know what that, okay, thank you visual studio for crashing in the

1217
01:01:16,800 --> 01:01:18,100
middle of our debug session.

1218
01:01:18,600 --> 01:01:19,600
That's not good.

1219
01:01:19,700 --> 01:01:20,200
I know what?

1220
01:01:20,200 --> 01:01:21,400
That'll at least I believe.

1221
01:01:21,400 --> 01:01:24,500
I know what that is, but that would be a topic for next time.

1222
01:01:24,500 --> 01:01:26,100
I don't want to dive into that yet.

1223
01:01:27,100 --> 01:01:30,600
I assume that's Microsoft wanting us to be aligned, but, of course, we

1224
01:01:30,600 --> 01:01:31,500
are not aligned.

1225
01:01:31,500 --> 01:01:33,300
Let me see if I can make that crash happen.

1226
01:01:33,400 --> 01:01:35,400
I was kind of hoping I could make it happen in a way that wouldn't

1227
01:01:35,400 --> 01:01:36,100
crash little studio.

1228
01:01:36,100 --> 01:01:38,600
So I could show you what we were talking about there.

1229
01:01:38,600 --> 01:01:39,900
But, you know, wish

1230
01:01:40,100 --> 01:01:40,900
Thinking perhaps.

1231
01:01:44,100 --> 01:01:48,700
So let's take a look and see if I'm correct about that.

1232
01:01:50,100 --> 01:01:51,600
See here.

1233
01:01:55,000 --> 01:01:56,300
Well, I guess this is the value.

1234
01:01:56,300 --> 01:01:58,500
So, there we go, that value.

1235
01:02:00,000 --> 01:02:00,600
So,

1236
01:02:03,100 --> 01:02:06,100
What I assume is happening here and we can take a look at the

1237
01:02:06,100 --> 01:02:10,500
disassembly is sort of next topic that we have haven't quite addressed

1238
01:02:10,500 --> 01:02:13,700
yet but I just want to mention what it is briefly.

1239
01:02:14,500 --> 01:02:16,400
Where is the instruction pointer people?

1240
01:02:16,800 --> 01:02:17,900
Show me the instruction pointer.

1241
01:02:17,900 --> 01:02:24,800
There it is I assume what is happening here is that it's trying to

1242
01:02:24,800 --> 01:02:27,400
write to something that is unaligned.

1243
01:02:27,500 --> 01:02:30,100
Well actually I can see that it's trying to like write something

1244
01:02:30,100 --> 01:02:30,900
unaligned.

1245
01:02:32,900 --> 01:02:35,700
Or well.

1246
01:02:36,200 --> 01:02:40,200
I should verify that fact first before I say that, let me see.

1247
01:02:41,800 --> 01:02:43,300
Can you show me this value?

1248
01:02:47,500 --> 01:02:49,000
RDX - 10h.

1249
01:02:49,200 --> 01:02:49,800
There we go.

1250
01:02:51,200 --> 01:02:57,200
So 21 EB4 B8, what is that value?

1251
01:02:57,800 --> 01:02:58,500
15?

1252
01:02:59,500 --> 01:02:59,900
So there

1253
01:03:00,000 --> 01:03:00,200
Yeah.

1254
01:03:00,500 --> 01:03:00,900
Yeah.

1255
01:03:03,000 --> 01:03:10,100
So I assume What's Happening Here is that move dqa is unaligned and

1256
01:03:10,100 --> 01:03:12,900
unfortunately on the Intel processors when you write to an unlined

1257
01:03:12,900 --> 01:03:19,600
address you get a crash right and so presumably in debug it was not

1258
01:03:19,600 --> 01:03:23,500
using it was not using the aligned, right?

1259
01:03:23,600 --> 01:03:26,900
But I'm going to just see if that I just want to verify that just we

1260
01:03:26,900 --> 01:03:30,800
make sure you say it if pixel and 15.

1261
01:03:33,000 --> 01:03:37,400
Zero and I'll give a little bit more of an explanation of that in a

1262
01:03:37,400 --> 01:03:37,900
second.

1263
01:03:37,900 --> 01:03:42,100
So, if what is the problem here pixel is, you don't want me to.

1264
01:03:42,200 --> 01:03:42,800
All right.

1265
01:03:42,800 --> 01:03:47,100
Well, if pixel as a unit 64, then how does that strike you?

1266
01:03:49,000 --> 01:03:54,000
All right, so here we go and what you can kind of see here is that

1267
01:03:54,000 --> 01:03:57,800
basically if we only write when we are aligned, we don't get the

1268
01:03:57,800 --> 01:03:58,500
crash.

1269
01:03:59,000 --> 01:04:02,500
But if we allow it to write always like so

1270
01:04:02,600 --> 01:04:04,600
On then we get the crash.

1271
01:04:05,300 --> 01:04:07,600
So I don't really want to belabor that topic because that was

1272
01:04:07,600 --> 01:04:09,100
something I wanted to talk about later.

1273
01:04:09,100 --> 01:04:13,900
I assumed it would do sort of a would do the safe unaligned right

1274
01:04:13,900 --> 01:04:15,700
there didn't.

1275
01:04:15,700 --> 01:04:18,100
So I'm not sure exactly how to tell it.

1276
01:04:18,100 --> 01:04:19,500
Please don't do it online, right?

1277
01:04:19,500 --> 01:04:23,100
Right now we're just doing some test code but basically what happens

1278
01:04:23,100 --> 01:04:23,500
here,

1279
01:04:24,900 --> 01:04:26,500
To give you a little perspective on that.

1280
01:04:28,100 --> 01:04:31,800
Is these things are 128 bits wide.

1281
01:04:33,000 --> 01:04:33,500
Right.

1282
01:04:34,600 --> 01:04:36,800
So 128 bits.

1283
01:04:37,200 --> 01:04:37,900
That's 16.

1284
01:04:37,900 --> 01:04:42,500
Bytes and the way that the Intel processors work is they have

1285
01:04:42,500 --> 01:04:47,200
instructions for writing aligned and writing unaligned, right?

1286
01:04:47,300 --> 01:04:50,200
So what we have is 16-byte boundaries

1287
01:04:52,200 --> 01:04:57,000
It's considered aligned if essentially, you write only to every 16.

1288
01:04:57,000 --> 01:05:00,500
Bytes exactly starting from like the zeroeth base of memory, we talked

1289
01:05:00,500 --> 01:05:00,900
about this.

1290
01:05:00,900 --> 01:05:04,300
I think a long time ago, starting from the zero point in memory

1291
01:05:04,400 --> 01:05:07,300
alignment basically means that every 16 bytes.

1292
01:05:07,400 --> 01:05:09,300
Right 1632.

1293
01:05:09,400 --> 01:05:14,500
So on right there is an alignment boundary and it never wants you to

1294
01:05:14,500 --> 01:05:17,200
write to say the third bite.

1295
01:05:17,600 --> 01:05:18,000
You know.

1296
01:05:18,000 --> 01:05:20,000
It doesn't ever want you to write like that.

1297
01:05:20,100 --> 01:05:21,100
It wants it always to

1298
01:05:21,200 --> 01:05:21,900
Aligned.

1299
01:05:21,900 --> 01:05:24,400
So, what that means is that the pointer, right?

1300
01:05:24,400 --> 01:05:28,200
The bottom part of the pointer should always be 0, right?

1301
01:05:28,200 --> 01:05:30,400
Because 16 right is 2 to the 4th.

1302
01:05:30,400 --> 01:05:35,500
So the bottom four bits of the pointer should always be 0 if you're

1303
01:05:35,500 --> 01:05:35,800
writing.

1304
01:05:35,800 --> 01:05:39,700
If you're not, then it will issue an exception.

1305
01:05:39,700 --> 01:05:43,700
Now it has ways to write, unaligned some processors, don't some

1306
01:05:43,700 --> 01:05:46,500
processors when they're doing wide rights like that, you have to write

1307
01:05:46,500 --> 01:05:49,600
a line but the Intel processor actually has the ability to write

1308
01:05:49,600 --> 01:05:50,000
unaligned.

1309
01:05:50,000 --> 01:05:51,000
And I believe by

1310
01:05:51,200 --> 01:05:52,300
Using an intrinsic.

1311
01:05:52,400 --> 01:05:54,200
We can force it to do that.

1312
01:05:54,200 --> 01:05:56,200
So let me just do that quickly so you can see.

1313
01:05:56,600 --> 01:05:58,500
So here's the store instructions.

1314
01:06:00,100 --> 01:06:02,600
And I believe M&M store you.

1315
01:06:02,600 --> 01:06:06,000
Si128 is the one we're looking for here.

1316
01:06:06,100 --> 01:06:09,300
So does not need to be to be a line on any particular boundary.

1317
01:06:09,600 --> 01:06:12,000
So if I want to, I can go ahead and do that.

1318
01:06:12,000 --> 01:06:18,300
What I can do is actually issue this intrinsic M&M store you dep iope.

1319
01:06:18,300 --> 01:06:20,400
Sorry si128, right?

1320
01:06:21,700 --> 01:06:26,400
And then I can go ahead and use that pixel pointer and that out

1321
01:06:26,400 --> 01:06:27,700
pointer like.

1322
01:06:27,700 --> 01:06:29,000
So, I'm that out value.

1323
01:06:29,000 --> 01:06:34,000
Like so, and this will cause it to issue a separate instruction.

1324
01:06:34,000 --> 01:06:36,300
So let's go ahead and take a look at that.

1325
01:06:36,300 --> 01:06:39,300
Now, if we go remember, it was using move, dqa there.

1326
01:06:39,300 --> 01:06:42,400
If we go to the disassembly, you can see

1327
01:06:44,400 --> 01:06:47,000
Now that it's actually not doing that move.

1328
01:06:47,000 --> 01:06:50,100
Dqa it's using the regular mob instruction, right?

1329
01:06:50,200 --> 01:06:54,900
And that's that does not have to be aligned, right?

1330
01:06:56,000 --> 01:06:57,500
Assuming that that's actually how did it?

1331
01:06:57,500 --> 01:07:00,200
Let's just double-check the X pixel.

1332
01:07:00,300 --> 01:07:00,600
Yeah.

1333
01:07:01,100 --> 01:07:02,500
So that's that's it.

1334
01:07:03,100 --> 01:07:07,200
And so here, we're fine now and we're back to the way we were doing it

1335
01:07:07,200 --> 01:07:07,800
before.

1336
01:07:08,400 --> 01:07:11,400
But again that that alignment thing is kind of a little bit of an SES

1337
01:07:11,400 --> 01:07:14,000
and you can see we're continuing to get actually

1338
01:07:14,200 --> 01:07:17,300
They're just by doing this translation, we were at 120 Cycles.

1339
01:07:17,400 --> 01:07:20,000
We're now down closer to 110, right?

1340
01:07:20,000 --> 01:07:21,000
So we keep going.

1341
01:07:21,500 --> 01:07:23,000
We're keep going a little bit further.

1342
01:07:23,500 --> 01:07:25,400
So that is the end of the stream.

1343
01:07:25,400 --> 01:07:27,600
We're already a little over time because I wanted to just mention

1344
01:07:27,600 --> 01:07:28,000
briefly.

1345
01:07:28,000 --> 01:07:28,800
What that was.

1346
01:07:28,800 --> 01:07:32,100
Will talk about that alignment later because the alignment is actually

1347
01:07:32,100 --> 01:07:35,500
important and it's something that when we're done doing this routine,

1348
01:07:35,500 --> 01:07:38,600
we want to step out back a little bit and look at alignment as

1349
01:07:38,600 --> 01:07:40,100
something that we actually care about.

1350
01:07:40,100 --> 01:07:41,300
We don't want to get into that just yet.

1351
01:07:41,300 --> 01:07:44,000
That's why I don't really want to talk too much more about it.

1352
01:07:44,100 --> 01:07:44,300
It.

1353
01:07:44,800 --> 01:07:48,700
But basically what we've done now, as you can see, is we've sort of

1354
01:07:48,700 --> 01:07:49,900
removed

1355
01:07:52,200 --> 01:07:54,800
All of that looping that was happening at the bottom now.

1356
01:07:54,900 --> 01:07:56,700
So there's no longer a need for any of that.

1357
01:07:56,700 --> 01:08:01,500
Looping we build directly, the 128 bits that we want right in the

1358
01:08:01,500 --> 01:08:04,600
Cindy registers and then we blast them straight out and it didn't cost

1359
01:08:04,600 --> 01:08:05,600
us that much to do it.

1360
01:08:05,600 --> 01:08:10,600
It was eight instructions to prep everything and I guess not a

1361
01:08:10,600 --> 01:08:12,700
instructions because this is a no op instruction here.

1362
01:08:12,800 --> 01:08:13,300
Right?

1363
01:08:14,000 --> 01:08:17,700
So it was seven instructions to prep everything and then three more.

1364
01:08:17,700 --> 01:08:20,500
So, ten instructions total to get it down.

1365
01:08:20,800 --> 01:08:22,200
Into The Pact format.

1366
01:08:22,200 --> 01:08:23,399
So that's not bad, right?

1367
01:08:23,399 --> 01:08:24,399
That's not bad.

1368
01:08:24,399 --> 01:08:26,600
And again, that does 4 pixels at a time.

1369
01:08:27,000 --> 01:08:29,700
So it's actually a pretty cheap.

1370
01:08:31,000 --> 01:08:37,000
All right, so let's go over to the Q&A now because I would like to

1371
01:08:37,000 --> 01:08:39,200
take some questions in case there are questions on that.

1372
01:08:41,700 --> 01:08:42,300
There we go.

1373
01:08:43,200 --> 01:08:45,300
Again I showed two ways to that interleaving.

1374
01:08:45,300 --> 01:08:48,399
One way to do the interleavings with the unpacks and that's if things

1375
01:08:48,399 --> 01:08:50,500
are staying in floating point and have to be interleaved.

1376
01:08:50,500 --> 01:08:53,000
In our case, we don't have to write out the floating point, we can

1377
01:08:53,000 --> 01:08:54,200
just write out the bits.

1378
01:08:54,200 --> 01:08:57,600
And so, we did it this other way, which is to First convert them.

1379
01:08:57,600 --> 01:08:59,800
First, two 32-bit integers,

1380
01:09:00,200 --> 01:09:03,500
And then to shift the others into place and or them just like we were

1381
01:09:03,500 --> 01:09:06,899
doing kind of the analog of what we were doing, only four at a time.

1382
01:09:07,399 --> 01:09:14,000
So that's much that's very, very straightforward compared to the, it's

1383
01:09:14,000 --> 01:09:15,500
very similar to the scalar path, right?

1384
01:09:15,500 --> 01:09:17,300
The four wide path looks almost exactly the same.

1385
01:09:17,300 --> 01:09:21,200
It's just using intrinsics instead of the infix notation

1386
01:09:34,800 --> 01:09:37,200
Also, I will put in the 2D for what we're doing tomorrow.

1387
01:09:39,100 --> 01:09:39,500
Right?

1388
01:09:39,500 --> 01:09:44,300
Only the pixels there, that should fill equals true.

1389
01:09:50,800 --> 01:09:51,300
Right.

1390
01:10:00,300 --> 01:10:04,300
Will the operations be recorded to reduce the number of Ops and load

1391
01:10:04,300 --> 01:10:04,900
stores?

1392
01:10:07,900 --> 01:10:08,600
Soap.

1393
01:10:12,700 --> 01:10:14,300
Here's what I'd say about that.

1394
01:10:16,100 --> 01:10:19,800
The compiler often does a pretty good job with that ordering.

1395
01:10:20,900 --> 01:10:25,400
So we may be able to like when we're done when we're totally done with

1396
01:10:25,400 --> 01:10:27,800
this routine and we're satisfied with everything which we're you know

1397
01:10:27,800 --> 01:10:32,800
we gotta we gotta first handle the fact that we're not obeying should

1398
01:10:32,800 --> 01:10:33,300
feel here.

1399
01:10:33,400 --> 01:10:35,900
That's pretty easy to do but you know we didn't get a chance to cover

1400
01:10:35,900 --> 01:10:40,800
today and then we need to do this part up top, which is fairly

1401
01:10:40,800 --> 01:10:41,600
complicated.

1402
01:10:43,000 --> 01:10:47,800
So we need to do those things when we do those things and we're done

1403
01:10:47,800 --> 01:10:49,600
with the routines, we have the complete routine.

1404
01:10:50,600 --> 01:10:54,600
What you're talking about is essentially you're saying, can we reorder

1405
01:10:54,700 --> 01:10:59,300
the order that we put these things to reduce the number of loads and

1406
01:10:59,300 --> 01:11:01,200
stores that have to happen or things like this?

1407
01:11:02,500 --> 01:11:06,700
And the answer is if it's algorithmic, perhaps we can, but if it's

1408
01:11:06,700 --> 01:11:10,600
simply a question of trying to schedule the assembly that way, usually

1409
01:11:10,600 --> 01:11:15,100
the answer is no because the compiler has all the information here and

1410
01:11:15,100 --> 01:11:17,600
it typically chooses how it schedules the instructions.

1411
01:11:17,900 --> 01:11:22,200
So depending on unless the optimizers really bad, there's not that

1412
01:11:22,200 --> 01:11:24,400
much we can do with reorder with reordering.

1413
01:11:24,400 --> 01:11:26,100
These things, right?

1414
01:11:26,100 --> 01:11:28,400
Because not only is the processor.

1415
01:11:28,400 --> 01:11:31,300
I started not only is the compiler going to reorder them to try and

1416
01:11:31,300 --> 01:11:31,800
schedule them.

1417
01:11:32,400 --> 01:11:34,200
But the processor, reorders them.

1418
01:11:34,200 --> 01:11:38,100
Remember, the processor has a window of several instructions that it's

1419
01:11:38,100 --> 01:11:39,100
going to reorder in.

1420
01:11:39,300 --> 01:11:42,800
So the order that we put them in is not the order, they're actually

1421
01:11:42,800 --> 01:11:44,600
going to get executed in right?

1422
01:11:45,800 --> 01:11:48,600
So there's a limited amount we can do with that scheduling, so keep

1423
01:11:48,600 --> 01:11:49,300
that in mind.

1424
01:12:01,200 --> 01:12:07,400
Momo is the code, you are calculating out or or RG be a, would it be

1425
01:12:07,400 --> 01:12:11,300
better to do it like this or or RG or be a?

1426
01:12:11,400 --> 01:12:13,700
So the first two oars are not dependent on each other.

1427
01:12:15,000 --> 01:12:19,700
Yes, I suspect that would probably be better but again, let's take a

1428
01:12:19,700 --> 01:12:20,300
look here.

1429
01:12:22,400 --> 01:12:28,700
I want to just just to underscore this point, let's let's let's see.

1430
01:12:29,600 --> 01:12:30,000
Oops.

1431
01:12:31,800 --> 01:12:32,200
Why?

1432
01:12:34,300 --> 01:12:36,400
why you no want to break my, you know, wanna

1433
01:12:37,400 --> 01:12:38,900
set a breakpoint visual studio.

1434
01:12:40,100 --> 01:12:40,500
There we go.

1435
01:12:42,100 --> 01:12:45,100
So let's take a look at the disassembly here, right?

1436
01:12:46,700 --> 01:12:48,300
And see what it was actually doing.

1437
01:12:49,000 --> 01:12:50,600
So,

1438
01:12:58,300 --> 01:13:00,700
Where are the actual ORS?

1439
01:13:05,200 --> 01:13:06,400
Mul PS.

1440
01:13:07,400 --> 01:13:09,700
My we're doing alarm multiplies.

1441
01:13:11,500 --> 01:13:21,600
and so on doing multiplies here and add PS, 6 and 0

1442
01:13:23,500 --> 01:13:25,400
Add p snps.

1443
01:13:27,800 --> 01:13:30,700
so, I feel like

1444
01:13:32,900 --> 01:13:35,300
If I'm not mistaken.

1445
01:13:38,500 --> 01:13:44,800
I feel like it is optimized out that expression entirely.

1446
01:13:44,800 --> 01:13:48,400
It's not doing it that way at all.

1447
01:13:48,900 --> 01:13:51,200
Am I right about that?

1448
01:13:55,400 --> 01:13:55,800
Oh no.

1449
01:13:55,900 --> 01:13:56,000
Okay.

1450
01:13:56,000 --> 01:13:57,600
I'm like I'm like having to do that.

1451
01:13:57,900 --> 01:13:59,400
It's just massively reordered.

1452
01:13:59,400 --> 01:14:01,000
This routine quite a bit.

1453
01:14:01,000 --> 01:14:02,900
Here's the part where you're actually talking about.

1454
01:14:04,500 --> 01:14:08,600
Alright, so here's the P or right?

1455
01:14:09,300 --> 01:14:14,000
This is where it's doing the first or here's the next door between the

1456
01:14:14,000 --> 01:14:15,500
same two registers.

1457
01:14:15,700 --> 01:14:17,300
So it's actually done.

1458
01:14:17,600 --> 01:14:20,900
It's done a bunch of sort of reordering here, right?

1459
01:14:24,100 --> 01:14:27,900
I'm not sure it's decided to load in the textile.

1460
01:14:27,900 --> 01:14:29,200
A I mean,

1461
01:14:32,100 --> 01:14:34,600
It's kind of hard to figure out exactly what it was doing.

1462
01:14:34,800 --> 01:14:38,000
The shifts are linear dependent, they happened one right after the

1463
01:14:38,000 --> 01:14:38,300
other.

1464
01:14:38,300 --> 01:14:40,400
I don't know how much again like that matters depending on how the

1465
01:14:40,400 --> 01:14:41,100
processor is working.

1466
01:14:41,100 --> 01:14:45,900
But you see that the P or here then it's doing the the reconversion

1467
01:14:47,300 --> 01:14:49,400
then it's doing the or here.

1468
01:14:49,400 --> 01:14:55,100
So you can kind of see that it already, it already spaced them out

1469
01:14:55,100 --> 01:14:56,000
quite a bit.

1470
01:14:57,800 --> 01:14:59,500
so, while it's

1471
01:15:00,000 --> 01:15:00,800
We better.

1472
01:15:02,900 --> 01:15:05,700
I would say it is probably better to write it the way that you were

1473
01:15:05,700 --> 01:15:08,400
suggesting meaning writing it this way.

1474
01:15:08,800 --> 01:15:15,300
At least makes it clear to the compiler that that we didn't really

1475
01:15:15,300 --> 01:15:17,600
care about them being done serially.

1476
01:15:18,100 --> 01:15:22,500
But I suspect that the compiler or already knew that if that makes

1477
01:15:22,500 --> 01:15:27,000
sense and won't really generate anything substantially different if

1478
01:15:27,000 --> 01:15:27,800
that makes sense.

1479
01:15:29,700 --> 01:15:30,400
But I don't know.

1480
01:15:31,000 --> 01:15:31,900
So you can see here.

1481
01:15:31,900 --> 01:15:32,500
It's issuing, the

1482
01:15:32,700 --> 01:15:33,600
Chorus together.

1483
01:15:34,500 --> 01:15:37,100
So it didn't feel the need to spread them out.

1484
01:15:37,500 --> 01:15:41,100
So, you know, maybe that gives it a little bit more flexibility like

1485
01:15:41,100 --> 01:15:43,400
it decided to do that and it couldn't have done that before.

1486
01:15:43,600 --> 01:15:44,200
I don't know.

1487
01:15:45,700 --> 01:15:49,200
I really don't, but you can see it's

1488
01:15:50,300 --> 01:15:50,700
it's

1489
01:15:53,300 --> 01:15:55,400
in fact, I guess now, I think about, that's actually bad, but that's

1490
01:15:55,400 --> 01:15:58,700
the serial or hears, it actually didn't issue the Taurus together,

1491
01:15:58,700 --> 01:16:02,100
issued the first, or up here the second or here, and then the

1492
01:16:02,100 --> 01:16:05,500
combining or it did down here, right?

1493
01:16:07,100 --> 01:16:07,900
Does that make sense?

1494
01:16:08,200 --> 01:16:11,500
So it's now issuing them back to back when before it wasn't issuing

1495
01:16:11,500 --> 01:16:12,300
them back-to-back.

1496
01:16:13,400 --> 01:16:14,000
So yeah.

1497
01:16:14,400 --> 01:16:16,000
So I don't know like

1498
01:16:20,000 --> 01:16:23,500
When you're dealing with intrinsics like this, I realize it's tempting

1499
01:16:23,500 --> 01:16:26,500
to try and think like an Assembly Language programmer and really try

1500
01:16:26,500 --> 01:16:29,800
to do Assembly Language kinds of optimizations.

1501
01:16:30,200 --> 01:16:34,400
But what you have to remember is that unless you're actually just

1502
01:16:34,400 --> 01:16:37,200
looking at what the compilers doing and trying to shuffle things in

1503
01:16:37,200 --> 01:16:39,400
intrinsics, to make the compiler do something different.

1504
01:16:40,400 --> 01:16:43,200
What you're writing here in assembly is not what's coming out in

1505
01:16:43,200 --> 01:16:44,400
assembly directly.

1506
01:16:44,900 --> 01:16:48,600
So you have to take these sorts of things with a grain of salt.

1507
01:16:48,600 --> 01:16:53,100
This may or may not produce better code when you actually run it,

1508
01:16:53,200 --> 01:16:53,800
right?

1509
01:16:54,000 --> 01:16:57,400
Just because it breaks up at what appears to be a Serial dependency.

1510
01:16:57,600 --> 01:17:00,200
It doesn't necessarily mean that it's faster, one way or the other.

1511
01:17:00,400 --> 01:17:02,900
So we can time them and see at the end of the day.

1512
01:17:04,000 --> 01:17:04,700
But you know,

1513
01:17:06,600 --> 01:17:07,500
it's a crapshoot.

1514
01:17:07,800 --> 01:17:09,800
That same thing would not necessarily be true.

1515
01:17:09,800 --> 01:17:12,600
If you were writing this humble yourself because then you may decide

1516
01:17:12,600 --> 01:17:13,700
to schedule them one way or another.

1517
01:17:14,300 --> 01:17:16,900
But the other thing there to remember is the processor again, also

1518
01:17:16,900 --> 01:17:19,500
reschedules things, so it's still pretty hard.

1519
01:17:19,500 --> 01:17:22,900
Even at that point, you probably still have to time it to see whether

1520
01:17:22,900 --> 01:17:23,700
it mattered at all.

1521
01:17:31,900 --> 01:17:33,700
Do you need to start with 32-bit floats?

1522
01:17:33,700 --> 01:17:36,700
Is there further optimization that doesn't need the casting.

1523
01:17:37,700 --> 01:17:40,800
So remember that we're not doing any casting, so there's no more

1524
01:17:40,800 --> 01:17:41,900
casting, right?

1525
01:17:41,900 --> 01:17:43,400
We got rid of the cast entirely.

1526
01:17:43,700 --> 01:17:47,800
What we are doing is conversions, that's converting between float and

1527
01:17:47,800 --> 01:17:48,900
integer separately.

1528
01:17:49,600 --> 01:17:54,700
And so the answer is, well, you could try to do this pipeline, an

1529
01:17:54,700 --> 01:17:56,200
integer, right?

1530
01:17:56,200 --> 01:17:58,400
You could choose to try to do it in integer.

1531
01:17:58,900 --> 01:17:59,700
And if you look at the

1532
01:18:00,000 --> 01:18:03,800
Things that we're doing it is not out of the question that we could

1533
01:18:03,800 --> 01:18:08,000
try to do this in integer and furthermore, although it probably

1534
01:18:08,000 --> 01:18:12,000
wouldn't be any faster to do it in integer because we constantly would

1535
01:18:12,000 --> 01:18:14,500
have to introduce shifts, right?

1536
01:18:16,900 --> 01:18:17,400
I mean.

1537
01:18:18,900 --> 01:18:20,400
Let me just make this explicit.

1538
01:18:22,300 --> 01:18:25,700
So, basically, if you think about trying to do something, where you've

1539
01:18:25,700 --> 01:18:31,800
got integer times, integer equals integer right versus float.

1540
01:18:31,800 --> 01:18:33,500
Times float equals float.

1541
01:18:34,000 --> 01:18:35,700
This path always just works.

1542
01:18:36,000 --> 01:18:37,700
Float times float equals float.

1543
01:18:37,700 --> 01:18:41,300
That's one instruction integer times integer equals integer in our

1544
01:18:41,300 --> 01:18:45,300
case is not one instruction, because what happens is, this is actually

1545
01:18:45,300 --> 01:18:47,300
a number between 0 and 255, right?

1546
01:18:47,300 --> 01:18:50,900
And 02:55, this is between 0 and 1 and 0, and 1, and we want the

1547
01:18:50,900 --> 01:18:51,900
output 0 to 1.

1548
01:18:52,300 --> 01:18:53,700
A number between 0 and 1 times.

1549
01:18:53,700 --> 01:18:57,300
Another number of t, 0 and 1 equals 0, a number between 0 and 1 in

1550
01:18:57,300 --> 01:19:00,400
floating point and the floating Point Unit, does the adjustment to

1551
01:19:00,400 --> 01:19:03,000
make sure that that remains true in integer?

1552
01:19:03,000 --> 01:19:04,100
There is no such thing.

1553
01:19:04,500 --> 01:19:08,500
So when we do a number 0, 25 times, another number 0 to 255, what we

1554
01:19:08,500 --> 01:19:12,500
get is the number 0 to 65535, right?

1555
01:19:12,500 --> 01:19:13,600
That's what we actually get.

1556
01:19:14,400 --> 01:19:15,000
Make sense.

1557
01:19:16,500 --> 01:19:20,500
So, if we do that, what that means is, in order to use this in the

1558
01:19:20,500 --> 01:19:24,500
pipeline later, we then have to shift it down to avoid blowing out the

1559
01:19:24,500 --> 01:19:25,600
Precision of the register.

1560
01:19:25,800 --> 01:19:31,600
So we need to actually follow each mole with a shift right.

1561
01:19:32,000 --> 01:19:32,800
Does that make sense?

1562
01:19:33,700 --> 01:19:37,900
So it actually becomes very expensive to do the pipeline integer so

1563
01:19:37,900 --> 01:19:41,200
typically converting to floating Point once at the head end and

1564
01:19:41,200 --> 01:19:45,200
converting to floating back to integer at the back end is actually

1565
01:19:45,200 --> 01:19:46,200
faster than

1566
01:19:46,300 --> 01:19:48,900
Trying to do everything in fixed point, if that makes sense.

1567
01:19:55,200 --> 01:19:57,300
Same for texture by linear ads together.

1568
01:19:57,800 --> 01:19:58,300
Yes.

1569
01:19:58,300 --> 01:20:01,400
Oh Jimmy.

1570
01:20:03,700 --> 01:20:06,900
For the texture by linear ads, stacking the ads.

1571
01:20:06,900 --> 01:20:12,200
This way was, is similar to the exact same thing in terms of doing

1572
01:20:12,200 --> 01:20:13,200
the, the oars.

1573
01:20:13,500 --> 01:20:17,000
So if we want to you can, you know, you can.

1574
01:20:17,000 --> 01:20:18,600
You can phrase them the opposite way.

1575
01:20:19,100 --> 01:20:22,800
It's a little bit hard to read because there's so much stuff going on

1576
01:20:22,800 --> 01:20:27,800
here but there's the ad PS of these two moles, right?

1577
01:20:27,800 --> 01:20:30,700
And then you introduce the ad PS of the other two moles

1578
01:20:31,700 --> 01:20:32,300
Like so.

1579
01:20:33,600 --> 01:20:34,100
Right.

1580
01:20:41,200 --> 01:20:41,800
There we go.

1581
01:20:42,500 --> 01:20:44,900
And that's the exact same operation.

1582
01:20:45,100 --> 01:20:48,800
Oops, I missed a parentheses there so there's one ad PS.

1583
01:20:49,300 --> 01:20:50,700
There's the other AD PS.

1584
01:20:55,400 --> 01:20:56,900
What is my syntax error?

1585
01:21:00,700 --> 01:21:02,900
What'd I do wrong there but I miss a parentheses.

1586
01:21:09,500 --> 01:21:13,200
I guess I must have accidentally cut something from this.

1587
01:21:14,500 --> 01:21:15,700
This match parentheses.

1588
01:21:17,900 --> 01:21:20,600
Did I accidentally delete something from the ad P.

1589
01:21:20,600 --> 01:21:22,200
Oh, I see what I did.

1590
01:21:22,500 --> 01:21:24,700
I preemptively deleted.

1591
01:21:24,700 --> 01:21:25,100
The ad.

1592
01:21:25,100 --> 01:21:25,900
PS is from there.

1593
01:21:26,200 --> 01:21:26,600
All right.

1594
01:21:26,800 --> 01:21:27,200
Sorry.

1595
01:21:29,000 --> 01:21:29,900
so, our

1596
01:21:31,100 --> 01:21:31,800
Ta.

1597
01:21:35,900 --> 01:21:36,500
Let's see.

1598
01:21:36,900 --> 01:21:37,600
Jeez.

1599
01:21:40,300 --> 01:21:42,500
Here's the B's A's.

1600
01:21:44,700 --> 01:21:45,200
There we go.

1601
01:21:47,300 --> 01:21:51,500
And so, that's the same operation, but not dependent Hoops.

1602
01:21:51,500 --> 01:21:52,900
I must have missed something there though.

1603
01:21:54,200 --> 01:21:55,300
So we're add PS.

1604
01:21:55,300 --> 01:21:56,100
The two ads.

1605
01:21:56,100 --> 01:22:02,000
There's the mall Texel ABCD are gggg.

1606
01:22:02,000 --> 01:22:03,300
BB hoops.

1607
01:22:07,000 --> 01:22:07,300
Yeah.

1608
01:22:13,300 --> 01:22:16,500
But again, like, you know, I don't know that that actually helps us

1609
01:22:16,500 --> 01:22:17,100
much.

1610
01:22:20,000 --> 01:22:24,200
I really don't know in practice if that you know how important that

1611
01:22:24,200 --> 01:22:25,800
actually is, right?

1612
01:22:26,400 --> 01:22:30,100
Because I don't know the compiler.

1613
01:22:30,200 --> 01:22:33,500
You know, we're already telling it that doesn't have to obey our order

1614
01:22:33,500 --> 01:22:35,000
of operations, particularly hard.

1615
01:22:35,200 --> 01:22:39,400
So I really don't know how much that really changes life for the

1616
01:22:39,400 --> 01:22:40,700
compiler in practice.

1617
01:22:42,000 --> 01:22:44,200
You really just have to time it to see if it actually made any

1618
01:22:44,200 --> 01:22:44,600
difference.

1619
01:22:44,800 --> 01:22:47,600
It certainly didn't make any difference in our particular case, right?

1620
01:22:47,600 --> 01:22:49,000
If you take a look at what's happening

1621
01:22:49,700 --> 01:22:50,800
So with that many cycles.

1622
01:22:51,400 --> 01:22:55,100
But you know, we haven't gotten down to, you know, maybe it would, it

1623
01:22:55,100 --> 01:22:58,300
would matter more if we if we had finished out everything, I'm not

1624
01:22:58,300 --> 01:22:58,600
sure.

1625
01:23:01,100 --> 01:23:03,300
Can you compile 022 compared to last week's and parts?

1626
01:23:03,300 --> 01:23:04,700
We are compiling 02.

1627
01:23:06,300 --> 01:23:09,700
So we are you know right now we're about three times faster.

1628
01:23:18,000 --> 01:23:20,800
Why did you make macros for your symbiote operations versus making

1629
01:23:20,800 --> 01:23:21,500
functions?

1630
01:23:21,900 --> 01:23:25,700
Because again, I just want to take any variability out of it.

1631
01:23:25,700 --> 01:23:29,100
Macros are a straight text substitution, I know the compiler cannot

1632
01:23:29,100 --> 01:23:31,300
mess it up whereas functions.

1633
01:23:31,300 --> 01:23:34,500
The compiler might get confused or you know, you never really know.

1634
01:23:39,400 --> 01:23:42,100
Are these intrinsic the same on other operating systems are compilers

1635
01:23:42,100 --> 01:23:44,300
as long as it's using the Intel architecture.

1636
01:23:44,300 --> 01:23:47,400
Yes, these are the same as they would be in llvm.

1637
01:23:47,500 --> 01:23:51,600
The only thing that's not the same is the part that we're actually

1638
01:23:51,700 --> 01:23:56,900
only using for testing which is this m macro so accessing.

1639
01:23:57,200 --> 01:23:58,500
Oh wait, no never mind.

1640
01:23:58,600 --> 01:23:59,900
I wrote it in the way that works.

1641
01:24:00,000 --> 01:24:05,700
Both architectures accessing these on Windows on Visual Studio.

1642
01:24:06,900 --> 01:24:08,200
Mmm, 128.

1643
01:24:08,200 --> 01:24:12,600
Have you are Union that allow you to access their components using the

1644
01:24:12,600 --> 01:24:14,600
union and on llvm.

1645
01:24:14,600 --> 01:24:18,100
They are not, but it looks like I wrote it in the way that works on

1646
01:24:18,100 --> 01:24:21,500
both platforms, to access a member, which is to cast it to a pointer

1647
01:24:21,500 --> 01:24:22,400
that works on both.

1648
01:24:22,900 --> 01:24:23,400
So yes.

1649
01:24:23,400 --> 01:24:27,900
So so this code should work the same on any intel compiler, at the

1650
01:24:27,900 --> 01:24:29,800
moment, GCC llvm or

1651
01:24:30,000 --> 01:24:31,400
Or Visual Studio.

1652
01:24:41,700 --> 01:24:43,900
Why do you say unaligned store is nasty?

1653
01:24:43,900 --> 01:24:47,000
As far as I know, for latest Intel CPUs, at least starting from Ivy,

1654
01:24:47,000 --> 01:24:50,200
Bridge unaligned store, and load is not very expensive anymore, less

1655
01:24:50,200 --> 01:24:51,300
than 5% difference.

1656
01:24:51,300 --> 01:24:53,800
Well, first of all, five percent difference is a lot of percent,

1657
01:24:53,900 --> 01:24:54,400
right?

1658
01:24:55,200 --> 01:24:57,100
When you're talking about optimization, you don't want to just go

1659
01:24:57,100 --> 01:24:59,100
like, Oh, Let's ignore that.

1660
01:24:59,100 --> 01:25:01,400
But the other thing is, it depends on the processor, right?

1661
01:25:01,400 --> 01:25:05,700
Online stores, could be very expensive in the old days and it also is

1662
01:25:05,700 --> 01:25:09,200
very important to think about because some processors such as like,

1663
01:25:09,200 --> 01:25:10,500
Xbox 360 and so on.

1664
01:25:11,000 --> 01:25:14,700
Have the ability to do online stores at all or they're extremely

1665
01:25:14,700 --> 01:25:15,100
expensive.

1666
01:25:15,100 --> 01:25:16,300
You do them stuff like this.

1667
01:25:16,700 --> 01:25:21,100
So typically it's if you're talking about writing an optimized

1668
01:25:21,100 --> 01:25:21,700
routine,

1669
01:25:22,700 --> 01:25:26,400
Most of the time you want to come at a perspective of, I'm going to

1670
01:25:26,400 --> 01:25:27,900
keep everything, aligned right?

1671
01:25:27,900 --> 01:25:30,600
Because usually you can it's not that hard to do.

1672
01:25:30,600 --> 01:25:31,000
So.

1673
01:25:31,300 --> 01:25:34,200
And so typically you want to keep everything aligned that you can keep

1674
01:25:34,200 --> 01:25:38,000
aligned, that's just tends to be good policy.

1675
01:25:38,000 --> 01:25:42,800
It also is better for cash alignment because if we run aligned, if

1676
01:25:42,800 --> 01:25:46,300
we're not aligned to a 16 byte binder boundary it means we're also not

1677
01:25:46,300 --> 01:25:47,200
cash aligned.

1678
01:25:48,000 --> 01:25:49,200
And so that's another problem.

1679
01:25:49,200 --> 01:25:51,000
Which means you probably won't get as good a casualisation.

1680
01:25:51,000 --> 01:25:52,000
So in general,

1681
01:25:52,500 --> 01:25:56,200
We probably want to take a look at that alignment stuff.

1682
01:25:56,200 --> 01:26:00,700
Now, if it turns out that under filling in overfilling, are more

1683
01:26:00,700 --> 01:26:05,700
expensive than the cash alignment, or more expensive than the store

1684
01:26:05,800 --> 01:26:10,300
alignment penalty that stuff, then by all means use online.

1685
01:26:10,300 --> 01:26:13,900
So you know if you end up in a situation where unaligned is faster you

1686
01:26:13,900 --> 01:26:15,400
use unaligned, right?

1687
01:26:15,800 --> 01:26:20,100
But in cases where you can get aligned and you probably want to check

1688
01:26:20,100 --> 01:26:22,300
to make sure that a line isn't going to give you a speed win because

1689
01:26:22,500 --> 01:26:23,100
so, you know,

1690
01:26:25,600 --> 01:26:29,700
Is scalar access to m120 element still slow on Intel.

1691
01:26:30,000 --> 01:26:36,500
Well, it's not slow, you know, it was never that slow, but it's, you

1692
01:26:36,500 --> 01:26:38,800
know, it's always a downshift, right?

1693
01:26:40,200 --> 01:26:41,800
Accessing the elements out of am.

1694
01:26:41,800 --> 01:26:46,900
128 means a, you take a 4X speed hit right off the bat because you're

1695
01:26:46,900 --> 01:26:50,800
operating on individual elements instead of all 4 elements at once.

1696
01:26:51,000 --> 01:26:54,300
So your four times slower, before you even talk about anything else.

1697
01:26:55,800 --> 01:26:58,200
well, I shouldn't say your four times slower, you lose the 4X speed

1698
01:26:58,200 --> 01:26:59,800
increase and

1699
01:27:00,200 --> 01:27:03,600
Then you're talking about how ever long, a particular processor,

1700
01:27:04,000 --> 01:27:09,200
flavor from Intel takes to move, stuff out of the, the wide registers

1701
01:27:09,200 --> 01:27:12,400
into, you know, a regular register, you know?

1702
01:27:12,800 --> 01:27:16,500
So you've got, you've got issues.

1703
01:27:19,000 --> 01:27:22,600
Bankers are says, the presser we do is 192 instructions, so, yeah, I

1704
01:27:22,600 --> 01:27:23,000
mean

1705
01:27:24,200 --> 01:27:27,700
I don't know how long the processor window is on this particular

1706
01:27:27,700 --> 01:27:28,200
posture, right?

1707
01:27:28,200 --> 01:27:30,200
It depressor, windows are not always the same size.

1708
01:27:30,200 --> 01:27:33,500
I believe, so saying it's 192 instructions, I think is not necessarily

1709
01:27:33,500 --> 01:27:36,600
accurate and plus are you sure it's under 922 instructions, not 102

1710
01:27:36,600 --> 01:27:39,100
Micro Ops because those are different as well.

1711
01:27:39,800 --> 01:27:44,000
But regardless the processor window is, is probably large enough that

1712
01:27:44,000 --> 01:27:45,700
a lot of our routine is in it.

1713
01:27:46,100 --> 01:27:50,300
And so that's why I say ordering the instructions is kind of hard to

1714
01:27:50,300 --> 01:27:53,400
think about because the processor will do you know,

1715
01:27:54,700 --> 01:27:55,900
We'll do whatever it wants to do.

1716
01:28:01,200 --> 01:28:04,500
Gaston 5 says, I don't understand how one optimizes by using the

1717
01:28:04,500 --> 01:28:06,000
intrinsic or function,

1718
01:28:08,200 --> 01:28:11,100
I'm not sure what that means but the idea behind the intrinsics is

1719
01:28:11,100 --> 01:28:14,500
just that it gives you access to operating on things for wide.

1720
01:28:14,700 --> 01:28:18,500
So right now what we've done, the reason why we got three times faster

1721
01:28:18,500 --> 01:28:21,200
already is just because we have switched to operating on four pixels

1722
01:28:21,200 --> 01:28:21,700
at once.

1723
01:28:21,700 --> 01:28:24,300
Instead of one pixel, that's all we did and that's what the intrinsics

1724
01:28:24,300 --> 01:28:25,000
allow us to do.

1725
01:28:52,500 --> 01:28:55,200
Mmm, convert, PS, epi32.

1726
01:28:55,200 --> 01:28:58,700
Always truncates, would that be better than mess around with the

1727
01:28:58,700 --> 01:28:59,600
rounding mode?

1728
01:29:07,600 --> 01:29:08,600
Is that true?

1729
01:29:13,900 --> 01:29:18,300
I actually didn't remember that if that's actually true.

1730
01:29:19,100 --> 01:29:20,600
Then yes, that's much better.

1731
01:29:20,900 --> 01:29:21,800
I didn't know that.

1732
01:29:21,800 --> 01:29:22,900
It always truncates.

1733
01:29:28,100 --> 01:29:32,800
let me see if, if we can, I can look it up, the Intel architecture

1734
01:29:32,800 --> 01:29:33,600
manual but

1735
01:29:37,500 --> 01:29:38,500
I was hoping.

1736
01:29:40,500 --> 01:29:41,700
To see.

1737
01:29:46,400 --> 01:29:48,000
Conversion intrinsics.

1738
01:29:50,000 --> 01:29:51,300
Convert PS.

1739
01:29:52,300 --> 01:29:55,000
How is it possible that they wrote all this documentation?

1740
01:29:55,000 --> 01:29:55,800
Okay, here we go.

1741
01:29:58,000 --> 01:29:59,800
Oh, convert TPS.

1742
01:30:00,700 --> 01:30:03,400
I see, okay, I see what you're saying.

1743
01:30:03,700 --> 01:30:04,100
Now.

1744
01:30:04,100 --> 01:30:05,300
I'm on the same page as you.

1745
01:30:05,600 --> 01:30:05,900
Yes.

1746
01:30:05,900 --> 01:30:07,000
Convert TPS.

1747
01:30:07,000 --> 01:30:10,400
I don't think that's sse2, is it?

1748
01:30:11,600 --> 01:30:12,900
Is that actually sse2.

1749
01:30:15,300 --> 01:30:16,300
Let's find out.

1750
01:30:33,100 --> 01:30:34,500
Wow that's actually sse2.

1751
01:30:34,500 --> 01:30:37,700
I had no idea convert packed single Precision floating pieces with

1752
01:30:37,700 --> 01:30:39,000
truncation and store.

1753
01:30:39,000 --> 01:30:39,900
The result in death.

1754
01:30:40,100 --> 01:30:42,900
I did not know that I had no idea.

1755
01:30:42,900 --> 01:30:43,500
That was true.

1756
01:30:43,700 --> 01:30:44,500
That's awesome.

1757
01:30:46,200 --> 01:30:50,600
And the answer I think is yes that is exactly what we should do and

1758
01:30:50,600 --> 01:30:54,200
thank you very much for that suggestion because that was way better

1759
01:30:54,200 --> 01:30:55,300
than what I was going to do.

1760
01:30:56,600 --> 01:30:59,900
Honestly, so that's pretty great.

1761
01:31:00,200 --> 01:31:01,900
Yes, I think that's an excellent idea.

1762
01:31:02,000 --> 01:31:04,500
That just means we do have to do extra instructions here.

1763
01:31:04,600 --> 01:31:07,300
So one might argue, maybe we should try to set the rounding mode

1764
01:31:07,300 --> 01:31:17,100
instead but let's let's should be set the rounding mode to nearest and

1765
01:31:17,100 --> 01:31:18,700
save the ads.

1766
01:31:19,400 --> 01:31:20,200
We can say that.

1767
01:31:20,200 --> 01:31:24,400
But what I'll do here is, I'll just say okay, you know, these are

1768
01:31:24,400 --> 01:31:26,200
going to be mmm, add PS.

1769
01:31:28,100 --> 01:31:34,000
And this will be like 4:30 X, like so.

1770
01:31:37,300 --> 01:31:40,900
I'm going to leave it like that for now because I think that is a good

1771
01:31:40,900 --> 01:31:42,400
idea that you had.

1772
01:31:43,500 --> 01:31:44,000
I don't know.

1773
01:31:44,000 --> 01:31:46,700
I mean, we, as it's going to cost us those four extra instructions is

1774
01:31:46,700 --> 01:31:47,500
the only thing,

1775
01:31:50,100 --> 01:31:54,800
To do that extra ad and there's not really another place we can hide

1776
01:31:54,800 --> 01:31:55,200
it.

1777
01:31:55,500 --> 01:31:57,900
I don't think so.

1778
01:31:57,900 --> 01:32:02,300
You know, it's something to think about but for now I think that's a

1779
01:32:02,300 --> 01:32:05,100
good, you know, that's a good compromise.

1780
01:32:06,000 --> 01:32:09,500
So let's do half set 1, PS 0.5,

1781
01:32:14,300 --> 01:32:16,600
So there we go, it's pretty good.

1782
01:32:16,900 --> 01:32:18,700
There's dipping around, right?

1783
01:32:20,100 --> 01:32:22,300
You remember how slow this was when we started?

1784
01:32:22,800 --> 01:32:24,500
It was like awful, right?

1785
01:32:24,700 --> 01:32:26,700
And now we're totally, we're totally rocking.

1786
01:32:30,800 --> 01:32:32,700
All right, so that's all good.

1787
01:32:34,400 --> 01:32:35,100
Good, good.

1788
01:32:36,600 --> 01:32:37,700
Let's see here.

1789
01:32:38,800 --> 01:32:41,300
So I think we're all set with that.

1790
01:32:41,600 --> 01:32:42,900
See, if there's any other questions

1791
01:32:50,500 --> 01:32:52,200
All right, click, we're all done.

1792
01:32:53,700 --> 01:32:55,300
Let us wrap up.

1793
01:32:56,000 --> 01:32:58,500
I believe you are done.

1794
01:33:01,100 --> 01:33:03,400
We got a little bit more to do tomorrow.

1795
01:33:03,400 --> 01:33:06,400
We have to obey should fill that'll be pretty easy.

1796
01:33:06,700 --> 01:33:08,900
If you want to take a crack at it yourself, you are.

1797
01:33:08,900 --> 01:33:11,300
Welcome to do so tonight to see how you do.

1798
01:33:11,900 --> 01:33:15,400
It's not it's not too hard but it isn't something that we covered

1799
01:33:15,400 --> 01:33:20,700
really how to think about necessarily so so yeah but we'll talk about

1800
01:33:20,700 --> 01:33:21,100
it tomorrow.

1801
01:33:21,100 --> 01:33:24,900
If you want to give it a shot, a crack yourself, you go for it.

1802
01:33:25,400 --> 01:33:29,000
And then tomorrow, most of I imagine what we'll spend our time doing

1803
01:33:29,200 --> 01:33:29,900
is.

1804
01:33:30,000 --> 01:33:31,300
This stuff, right?

1805
01:33:31,500 --> 01:33:33,500
So, getting in in here.

1806
01:33:34,400 --> 01:33:39,800
And starting to try and turn this into stuff that can operate for wide

1807
01:33:39,800 --> 01:33:41,500
or as close to four wide as possible.

1808
01:33:41,500 --> 01:33:44,600
That is really what what the remainder of our job is.

1809
01:33:44,600 --> 01:33:47,700
So, we'll dig into that, and then we're getting pretty close, right?

1810
01:33:47,700 --> 01:33:50,200
There's not a whole lot else in this routine that needs to be

1811
01:33:50,200 --> 01:33:50,500
converted.

1812
01:33:50,500 --> 01:33:53,300
And so we're getting close to the point where we can kind of take a

1813
01:33:53,300 --> 01:33:57,400
look at it and make an honest assessment and say how many cycles do we

1814
01:33:57,400 --> 01:34:00,500
think this could run in, you know, best case?

1815
01:34:00,500 --> 01:34:01,800
How close are we to that?

1816
01:34:01,800 --> 01:34:04,300
And more importantly how

1817
01:34:04,500 --> 01:34:09,100
This are we to our goal of of, you know, making something that could

1818
01:34:09,100 --> 01:34:13,300
run reasonably well at our resolution because we can go also kind of

1819
01:34:13,300 --> 01:34:16,300
back out and say how many cycles per pixel.

1820
01:34:17,200 --> 01:34:20,100
You know, if this routinely ran at this may cycles per pixel.

1821
01:34:20,100 --> 01:34:23,800
What would our frame rate be assuming certain Concepts about our

1822
01:34:23,800 --> 01:34:25,000
Sprites and that sort of stuff.

1823
01:34:25,700 --> 01:34:26,300
So anyway,

1824
01:34:27,500 --> 01:34:28,500
That's about it.

1825
01:34:29,200 --> 01:34:31,700
We will do that tomorrow at 5 p.m.

1826
01:34:31,700 --> 01:34:34,600
Pacific Standard time, or back to our normal time tomorrow.

1827
01:34:35,100 --> 01:34:40,700
Let me go ahead and close this stuff off and I will save our

1828
01:34:40,700 --> 01:34:41,700
Blackboard.

1829
01:34:42,800 --> 01:34:43,400
There we go.

1830
01:34:44,500 --> 01:34:47,300
So thank you, everyone for joining me for another episode of handmade

1831
01:34:47,300 --> 01:34:47,500
hero.

1832
01:34:47,500 --> 01:34:49,900
It's been a pleasure coding with you, as always, and a pleasure

1833
01:34:49,900 --> 01:34:54,200
optimizing with you as always, and we will continue our optimizations

1834
01:34:54,900 --> 01:34:55,700
stuff tomorrow.

1835
01:34:56,200 --> 01:34:57,200
When we'll tackle.

1836
01:34:57,300 --> 01:34:57,700
Two things.

1837
01:34:57,700 --> 01:34:58,900
I was just talking about.

1838
01:34:59,500 --> 01:35:02,000
If you would like to follow along at home and try your own hand at

1839
01:35:02,000 --> 01:35:05,000
some optimization, you can always pre-order the game on handmade here

1840
01:35:05,000 --> 01:35:08,300
at org and it comes with a source code, which you can download every

1841
01:35:08,300 --> 01:35:11,100
night after I finish and and sort of play around with, it's great for

1842
01:35:11,100 --> 01:35:11,600
learning.

1843
01:35:12,500 --> 01:35:15,000
You can do that on here made here at or you can also check out our

1844
01:35:15,000 --> 01:35:15,900
patreon page.

1845
01:35:15,900 --> 01:35:18,100
If you want to support the video series, you can subscribe to that.

1846
01:35:18,200 --> 01:35:21,700
You can check out our forums site where you can ask questions, or

1847
01:35:21,700 --> 01:35:23,800
check out ports to Mac and Linux, things like that.

1848
01:35:24,300 --> 01:35:26,700
And there's also of course the tweetbot with tweets the schedule it

1849
01:35:26,700 --> 01:35:26,800
you.

1850
01:35:26,800 --> 01:35:27,200
So if you

1851
01:35:27,300 --> 01:35:29,100
To catch the series live, that's the place to go.

1852
01:35:29,200 --> 01:35:31,700
It always has an update schedule on there so you can find out if a

1853
01:35:31,700 --> 01:35:34,700
stream gets rescheduled or if there's a weird schedule for the week,

1854
01:35:34,700 --> 01:35:36,000
that's the place to find out.

1855
01:35:36,300 --> 01:35:37,200
Thanks for joining me.

1856
01:35:37,500 --> 01:35:40,600
I will see you guys tomorrow until then have fun programming.

