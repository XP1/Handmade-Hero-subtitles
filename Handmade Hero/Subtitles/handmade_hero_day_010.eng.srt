1
00:00:00,000 --> 00:00:01,400
The recording here.

2
00:00:02,800 --> 00:00:09,200
Alright, hello everyone and welcome to day 10 of handmade.

3
00:00:09,200 --> 00:00:09,400
Here.

4
00:00:09,400 --> 00:00:11,400
We have made it through ten days already.

5
00:00:11,900 --> 00:00:15,400
If you are following along at home with the the source code, from the

6
00:00:15,400 --> 00:00:16,100
pre-order.

7
00:00:16,600 --> 00:00:20,300
You will want to unzip Source 9 sources.

8
00:00:20,300 --> 00:00:25,300
009 from that zip file because we are starting with Source 9 here on

9
00:00:25,300 --> 00:00:27,200
day 10 and you could follow along.

10
00:00:27,400 --> 00:00:29,800
All right, welcome to handmade hero.

11
00:00:30,300 --> 00:00:32,400
The only show currently in

12
00:00:32,600 --> 00:00:37,400
Distance that I know of, in the whole universe, where we code an

13
00:00:37,400 --> 00:00:43,300
entire game from scratch using nothing, but our own, our bare hands,

14
00:00:43,300 --> 00:00:44,600
our bear myths.

15
00:00:46,000 --> 00:00:48,800
I know it sounds improbable but we are going to do it and we have been

16
00:00:48,800 --> 00:00:51,800
doing it and everyone following at home has been doing it and it has

17
00:00:51,800 --> 00:00:52,800
been fabulous so far.

18
00:00:52,800 --> 00:00:54,800
I see no reason to stop.

19
00:00:54,800 --> 00:00:55,200
Now.

20
00:00:55,200 --> 00:00:59,200
Hopefully during the sort of warm up to the stream when the little

21
00:00:59,200 --> 00:01:00,600
countdown timer was on there.

22
00:01:00,600 --> 00:01:02,300
For those of you who joined a little early,

23
00:01:02,600 --> 00:01:03,500
you notice that?

24
00:01:03,500 --> 00:01:04,200
I left.

25
00:01:04,200 --> 00:01:10,900
I conspicuously left a particular page here up for you to read.

26
00:01:10,900 --> 00:01:11,200
I don't know.

27
00:01:11,200 --> 00:01:11,800
If you did.

28
00:01:11,800 --> 00:01:14,300
It's a little like summer reading assignment kind of thing only by

29
00:01:14,300 --> 00:01:14,600
summer.

30
00:01:14,600 --> 00:01:17,100
I mean, the 20 minutes before the stream started.

31
00:01:20,100 --> 00:01:24,400
But what you can see here is a, the first time I've actually pulled

32
00:01:24,400 --> 00:01:25,000
this up.

33
00:01:25,100 --> 00:01:28,200
It's a great reference to be aware of now.

34
00:01:28,200 --> 00:01:30,600
It's it's a little opaque.

35
00:01:30,700 --> 00:01:31,600
It's true.

36
00:01:32,000 --> 00:01:33,400
But I love having it around.

37
00:01:33,400 --> 00:01:35,400
I keep a copy on my machine at all times.

38
00:01:35,400 --> 00:01:39,300
It is called the Intel architecture reference manual and you can find

39
00:01:39,300 --> 00:01:43,100
it online just by searching on the Google.

40
00:01:43,800 --> 00:01:47,900
If you go in here and you put Intel architecture reference.

41
00:01:48,100 --> 00:01:49,600
Annual into the search box.

42
00:01:49,900 --> 00:01:53,500
You will get a link that basically has a, you know, some kind of long

43
00:01:53,500 --> 00:01:55,700
winded way that you got to fill some stuff out.

44
00:01:55,700 --> 00:01:58,800
But I don't even remember how this all works, but you can eventually

45
00:01:58,800 --> 00:02:00,100
get to download.

46
00:02:00,300 --> 00:02:01,800
I think that's this thing right here.

47
00:02:02,100 --> 00:02:03,600
That's a PDF or something.

48
00:02:03,700 --> 00:02:07,200
And then when you open it you get this nice thing.

49
00:02:07,200 --> 00:02:11,800
And what this is is basically a manual that Intel puts out that really

50
00:02:11,800 --> 00:02:16,700
meticulously goes over all of the details of their processor and you

51
00:02:16,700 --> 00:02:17,900
can look over here kind of

52
00:02:18,000 --> 00:02:19,600
Of in the in the table of contents.

53
00:02:20,000 --> 00:02:23,700
Basically, this Volume 2 one is the one that we're mostly concerned

54
00:02:23,700 --> 00:02:26,800
about but the volume 1 and volume 3 are actually interesting to look

55
00:02:26,800 --> 00:02:27,300
through as well.

56
00:02:27,300 --> 00:02:30,400
They've got all kinds of stuff about like how the virtual memory works

57
00:02:30,400 --> 00:02:34,600
and how the various virtualization features work and how systems

58
00:02:34,600 --> 00:02:36,400
programming works, all of this stuff.

59
00:02:36,400 --> 00:02:39,400
There's all kinds of good stuff in here that you can read to

60
00:02:39,400 --> 00:02:44,400
familiarize yourself with x86 and x64 processor technology, and how it

61
00:02:44,400 --> 00:02:44,700
works.

62
00:02:45,100 --> 00:02:47,900
But, in here volume to the most important,

63
00:02:48,000 --> 00:02:49,600
Part for any programmer.

64
00:02:49,600 --> 00:02:52,100
Who's just, you know, curious about how the CPU works.

65
00:02:52,300 --> 00:02:56,600
There's basically these two chapters chapter 3 and chapter 4, which

66
00:02:56,600 --> 00:02:59,800
have an alphabetical list of all of the

67
00:03:00,000 --> 00:03:04,300
Actual instructions that you can execute on an x 64 processor.

68
00:03:04,700 --> 00:03:05,300
Absolutely.

69
00:03:05,300 --> 00:03:09,500
Every every last one of them, I think is in here and so you can go

70
00:03:09,500 --> 00:03:12,600
through and if you want to know something, when you're looking at an

71
00:03:12,600 --> 00:03:15,400
assembly code, or just you're just curious about what the processor

72
00:03:15,400 --> 00:03:15,800
going to do.

73
00:03:16,000 --> 00:03:18,800
You want to know something you can go in here and say, oh we saw that

74
00:03:18,800 --> 00:03:20,000
mob and structured on the stream.

75
00:03:20,000 --> 00:03:21,200
Well, what's that?

76
00:03:21,300 --> 00:03:25,200
And they'll list every possible way that it can work.

77
00:03:25,300 --> 00:03:25,900
Right?

78
00:03:26,400 --> 00:03:29,800
It'll have comments that kind of tell you what goes on.

79
00:03:30,000 --> 00:03:33,300
On when it actually occurs and it'll have, like, sort of some

80
00:03:33,300 --> 00:03:37,200
pseudocode that says, what the processors actually doing internally.

81
00:03:37,200 --> 00:03:40,600
So it's, it's pretty darn cool and it's something that you should

82
00:03:40,600 --> 00:03:41,500
probably be familiar with.

83
00:03:41,500 --> 00:03:45,000
If you're just trying to educate yourself a little bit about the

84
00:03:45,000 --> 00:03:47,200
specifics of how the computer works, which is one of the things that

85
00:03:47,200 --> 00:03:48,600
we try to focus on here.

86
00:03:48,600 --> 00:03:52,200
So, the instruction that I had up was called our dtsc.

87
00:03:53,100 --> 00:03:54,600
Some of you may be familiar with it.

88
00:03:56,600 --> 00:04:02,900
What our dtsc is is it's basically a way of getting at a register or I

89
00:04:02,900 --> 00:04:06,500
mean, it's really a performance counter, but it's basically getting at

90
00:04:06,500 --> 00:04:13,500
a thing inside the CPU that increments by 1 every time the CPU

91
00:04:13,600 --> 00:04:15,900
effectively like retires a clock cycle.

92
00:04:16,100 --> 00:04:20,800
So, you know when you say that this is a 3.2 GHz processor.

93
00:04:20,899 --> 00:04:25,100
Well, that means 3.2, you know, billion cycles per second.

94
00:04:25,300 --> 00:04:30,400
That the processor is executing each one of those Cycles, this magical

95
00:04:30,400 --> 00:04:36,500
counter goes up by one and the our dtsc instruction, lets you actually

96
00:04:36,500 --> 00:04:40,700
access the value of that counter at any given time.

97
00:04:41,200 --> 00:04:45,200
And the reason that I wanted to introduce this today was basically,

98
00:04:45,200 --> 00:04:49,700
because we are going to look at some ways of figuring out what time it

99
00:04:49,700 --> 00:04:51,100
is in our code today.

100
00:04:51,100 --> 00:04:52,900
That's the thing that we're going to be working on.

101
00:04:53,800 --> 00:04:58,500
And this is a pretty important way that you can get that information

102
00:04:58,500 --> 00:05:03,100
because our dtsc basically tells you the cycle count at any point in

103
00:05:03,100 --> 00:05:03,500
your program.

104
00:05:03,500 --> 00:05:07,300
So by asking for the cycle count before you do something and asking

105
00:05:07,300 --> 00:05:11,900
for the cycle count after it gives you a pretty good idea of how many

106
00:05:11,900 --> 00:05:16,100
processor Cycles have elapsed during the thing that you did.

107
00:05:16,200 --> 00:05:19,800
So if you want to know how many cycles it took to do to execute a

108
00:05:19,800 --> 00:05:23,400
particular piece of code, read time stamp counter can give you a

109
00:05:23,600 --> 00:05:24,100
Good idea.

110
00:05:24,100 --> 00:05:24,400
Now.

111
00:05:24,400 --> 00:05:26,200
It's not always perfect.

112
00:05:28,400 --> 00:05:31,800
Because there's a number of factors that come into play.

113
00:05:32,600 --> 00:05:36,900
The first factor is that not all operating systems, save and restore

114
00:05:36,900 --> 00:05:42,300
the time stamp counter across basically like across tasks which has so

115
00:05:42,300 --> 00:05:45,600
if your process is running and you're trying to time it so you do in

116
00:05:45,600 --> 00:05:47,900
our dtsc at the beginning in our dtsc, at the end you're going to

117
00:05:47,900 --> 00:05:48,600
compare them.

118
00:05:49,100 --> 00:05:53,100
You won't necessarily know if the operating system woke up in the

119
00:05:53,100 --> 00:05:57,200
middle of that, swapped out your code, Ransom, other code, and then on

120
00:05:57,200 --> 00:05:58,000
the same processor,

121
00:05:58,100 --> 00:05:59,600
Sir, and then swapped in.

122
00:06:00,000 --> 00:06:02,100
It again for the ending, our dtsc.

123
00:06:02,300 --> 00:06:05,000
So when you do those are dtsc's, you have to be aware that your timing

124
00:06:05,000 --> 00:06:08,200
everything that the processor did in between those two points.

125
00:06:09,200 --> 00:06:11,200
Not just the thing, your code may have done.

126
00:06:11,600 --> 00:06:12,200
Now.

127
00:06:12,200 --> 00:06:14,500
This is, like I said, depending on the operating system, some

128
00:06:14,500 --> 00:06:18,600
operating systems actually try to save and restore the are dtsc

129
00:06:19,200 --> 00:06:20,900
depending on how you access.

130
00:06:20,900 --> 00:06:23,000
It will kind of look at that a little bit later.

131
00:06:23,000 --> 00:06:25,800
There's basically like a query cycle that there's actually a call in

132
00:06:25,800 --> 00:06:29,500
Windows, you can use, I think it's supported on Windows 7.

133
00:06:30,800 --> 00:06:33,800
Pretty sure there's a call, you can use in Windows that basically

134
00:06:33,800 --> 00:06:37,300
says, I want to know, just for my threat, like, just for this

135
00:06:37,500 --> 00:06:41,600
particular stream of execution, and that will prevent that particular

136
00:06:41,600 --> 00:06:42,300
problem for happening.

137
00:06:42,300 --> 00:06:44,000
But point being things like that can happen.

138
00:06:44,300 --> 00:06:47,500
Other things that can happen is, you don't actually necessarily know

139
00:06:47,500 --> 00:06:49,100
where those Cycles are coming from.

140
00:06:49,200 --> 00:06:50,900
They don't mean instructions.

141
00:06:50,900 --> 00:06:51,900
They mean cycle.

142
00:06:51,900 --> 00:06:55,800
So depending on how warm the cash was, how much time it took to get

143
00:06:55,800 --> 00:06:59,900
memory, all these sorts of things that are dtsc numbers are not going

144
00:06:59,900 --> 00:07:00,500
to be the same.

145
00:07:00,700 --> 00:07:02,600
All the time, they're going to be widely varied.

146
00:07:02,600 --> 00:07:04,000
So you time a particular piece of code.

147
00:07:04,000 --> 00:07:07,500
Once you're getting at one value, you time it again, even immediately

148
00:07:07,500 --> 00:07:10,200
thereafter, you're going to get different values because maybe things

149
00:07:10,200 --> 00:07:13,300
were in the cash that weren't before, all these all other sorts of

150
00:07:13,300 --> 00:07:13,600
things.

151
00:07:13,800 --> 00:07:15,900
So it's not foolproof.

152
00:07:15,900 --> 00:07:19,300
It's not a thing that magically tells you exactly what the performance

153
00:07:19,300 --> 00:07:23,500
of a piece of code is but it is a thing that gets you some pretty raw

154
00:07:23,900 --> 00:07:27,600
statistics on exactly how many cycles elapsed between two points and

155
00:07:27,600 --> 00:07:29,800
that is quite useful.

156
00:07:29,900 --> 00:07:30,500
So, we will be

157
00:07:30,600 --> 00:07:31,400
Showing how to use it.

158
00:07:33,900 --> 00:07:35,600
I just want to caveat if they're at the beginning.

159
00:07:37,100 --> 00:07:38,400
So the people wouldn't think it was.

160
00:07:38,700 --> 00:07:39,900
It was too perfect.

161
00:07:40,200 --> 00:07:43,300
So that's the first thing I'm going to talk about today and in terms

162
00:07:43,300 --> 00:07:45,900
of timing and we're also well, I don't know if that's the first one

163
00:07:46,000 --> 00:07:47,200
going to talk about two things today.

164
00:07:47,400 --> 00:07:50,100
The other one were going to talk about is query performance counter.

165
00:07:51,800 --> 00:07:54,400
This is another way of figuring out what time it is.

166
00:07:54,400 --> 00:07:55,300
Essentially again.

167
00:07:55,300 --> 00:07:59,300
This is all about clocking basically what this is, is a way of asking

168
00:07:59,300 --> 00:08:02,000
windows and saying, Hey to the

169
00:08:02,100 --> 00:08:03,200
Of your knowledge.

170
00:08:03,600 --> 00:08:06,700
What is an actual wall clock time?

171
00:08:07,100 --> 00:08:09,500
So this is the processor cycle.

172
00:08:10,200 --> 00:08:12,900
And it's in terms of the processors view of time.

173
00:08:13,300 --> 00:08:15,700
And what that means is that, if we're counting Cycles on the

174
00:08:15,700 --> 00:08:16,400
processor.

175
00:08:16,600 --> 00:08:20,600
We have no idea how that actually corresponds to wall clock time at

176
00:08:20,600 --> 00:08:21,500
all when I say.

177
00:08:21,500 --> 00:08:22,300
Well, clock time.

178
00:08:22,300 --> 00:08:24,300
I literally mean like time out in the real world.

179
00:08:24,300 --> 00:08:27,900
The real time that you and I experienced processor time does not work

180
00:08:27,900 --> 00:08:31,600
that way processors these days depending on the processor.

181
00:08:32,000 --> 00:08:36,200
Desktop processors less so, but still, but in Mobile processors by,

182
00:08:36,200 --> 00:08:41,500
you know, definitely, they do a lot of clocking changes in the clock

183
00:08:41,500 --> 00:08:45,800
speed to work around battery life and also to put perfect to manage

184
00:08:45,800 --> 00:08:47,700
heat signatures even sometimes.

185
00:08:47,900 --> 00:08:50,700
So like, for example, if only one core is running, they may boost the

186
00:08:50,700 --> 00:08:52,900
frequency of that core, but if multiple cars are running, they might

187
00:08:52,900 --> 00:08:57,600
drop it things like this, they'll drop the, the clock speed of a core

188
00:08:57,600 --> 00:08:59,900
when not much is going on to save battery life.

189
00:09:00,000 --> 00:09:02,900
Finn laptop, all of these sorts of things happen.

190
00:09:02,900 --> 00:09:07,500
Now, on main stream processors, which means that when you look at the

191
00:09:07,500 --> 00:09:14,300
cycle count, there is no constant meaning for how long that cycle may

192
00:09:14,300 --> 00:09:16,400
have taken in the real world.

193
00:09:16,400 --> 00:09:21,100
Because for some number of Cycles when you are using this, our dtsc,

194
00:09:21,100 --> 00:09:24,000
you know, you take your or DTS, Indiana, you take it, at the end of an

195
00:09:24,000 --> 00:09:24,600
area.

196
00:09:24,700 --> 00:09:28,700
You don't even know if the processor was executing at the same clock

197
00:09:28,700 --> 00:09:29,800
rate that entire time.

198
00:09:30,000 --> 00:09:30,200
Time.

199
00:09:30,200 --> 00:09:33,400
It may be that somewhere in the middle of their the processor down

200
00:09:33,400 --> 00:09:35,700
clock itself or up clocked itself.

201
00:09:36,000 --> 00:09:40,400
And so the first set of cycles, each cycle took a certain amount of

202
00:09:40,400 --> 00:09:43,000
time and then the second half of the thing.

203
00:09:43,100 --> 00:09:46,700
Each cycle took you no longer or shorter than the ones in the

204
00:09:46,700 --> 00:09:47,200
beginning.

205
00:09:47,700 --> 00:09:49,100
So Cycles, really.

206
00:09:49,100 --> 00:09:52,700
Just tells you something about how much work the processor did in some

207
00:09:52,700 --> 00:09:56,200
sense, but it doesn't really tell you about the wall clock time.

208
00:09:56,700 --> 00:09:59,600
Read query performance counter is the opposite of that.

209
00:10:01,800 --> 00:10:06,900
Query performance counter ask the operating system to please give you

210
00:10:06,900 --> 00:10:11,000
a high resolution meaning so it isn't cycle accurate perhaps but it is

211
00:10:11,000 --> 00:10:15,600
fairly accurate, you know, it's not in seconds and it's not in

212
00:10:15,600 --> 00:10:16,400
milliseconds.

213
00:10:16,400 --> 00:10:18,900
It's something more granular than Ms.

214
00:10:18,900 --> 00:10:26,800
Hopefully, excuse me, because you have to remember for running at 30

215
00:10:26,800 --> 00:10:29,000
frames a second or 60 frames a second.

216
00:10:29,200 --> 00:10:30,100
You're talking about things on.

217
00:10:30,300 --> 00:10:34,800
Order of 16 milliseconds per frame or something like this for a 60

218
00:10:34,800 --> 00:10:35,700
frames a second, right?

219
00:10:35,700 --> 00:10:39,900
Because, you know, if you, if you think about it, if you're in, you

220
00:10:39,900 --> 00:10:42,100
know, a handy Loops by to couldn't I, there we go.

221
00:10:42,200 --> 00:10:43,400
Need my little handy calculator.

222
00:10:43,800 --> 00:10:46,800
So, if you think about it, if you have 1,000, you know, Ms.

223
00:10:46,900 --> 00:10:48,700
There's 1,000 milliseconds per second.

224
00:10:48,800 --> 00:10:49,300
Right?

225
00:10:50,200 --> 00:10:53,700
So if we're running at 60 frames a second, that's only going to be

226
00:10:53,700 --> 00:10:58,100
sixteen point six six six six six six six, six repeating milliseconds

227
00:10:58,200 --> 00:11:00,100
that we have to come to do.

228
00:11:00,200 --> 00:11:01,600
Do the work for any given frame.

229
00:11:01,600 --> 00:11:07,000
Each frame will be on the screen for, you know, rounded up to 16 17.

230
00:11:07,000 --> 00:11:09,700
I suppose somewhere between 16 to 17 milliseconds.

231
00:11:10,400 --> 00:11:13,100
Each frame will only be on the screen for that amount of time.

232
00:11:13,400 --> 00:11:15,700
And so that's the amount of time we have to do the work for the next

233
00:11:15,700 --> 00:11:16,100
frame.

234
00:11:16,500 --> 00:11:20,800
So if we're trying to figure out how much performance, how a

235
00:11:20,800 --> 00:11:24,800
particular piece of code that gets improved or pesum Eyes by a

236
00:11:24,800 --> 00:11:28,900
particular code change and we're trying to time it we in general need

237
00:11:28,900 --> 00:11:30,100
things that are going to be a lot more.

238
00:11:30,300 --> 00:11:34,800
Accurate than say a millisecond because we only have 16 total of those

239
00:11:34,800 --> 00:11:38,400
roughly per frame anyway, so if it was on the order of Ms.

240
00:11:38,500 --> 00:11:42,500
Even if we sped up a particular function by 20%, we would still get

241
00:11:42,500 --> 00:11:43,400
the same time back.

242
00:11:43,400 --> 00:11:43,800
Potentially.

243
00:11:43,800 --> 00:11:45,900
It'll be like, well, it took two milliseconds, then we speed it up by

244
00:11:45,900 --> 00:11:47,900
20% and it's like it still took two milliseconds.

245
00:11:47,900 --> 00:11:48,300
Like no.

246
00:11:48,300 --> 00:11:48,500
Okay.

247
00:11:48,500 --> 00:11:51,600
We need, we need much more granular than that.

248
00:11:51,600 --> 00:11:54,900
So, hopefully, all these timers that we use are, you know, more than

249
00:11:54,900 --> 00:11:55,300
that.

250
00:11:55,400 --> 00:11:59,300
Certainly Cycles is way more granular than that, because there's 3.2

251
00:11:59,300 --> 00:11:59,900
billion of

252
00:12:00,200 --> 00:12:03,100
As per second, when the processor is running at full speed.

253
00:12:03,100 --> 00:12:03,600
Let's say,

254
00:12:04,900 --> 00:12:07,200
the query performance counter is also going to be more granular than

255
00:12:07,200 --> 00:12:07,500
that.

256
00:12:07,500 --> 00:12:10,900
It's just not perhaps going to be quite as granular as a cycle count,

257
00:12:11,100 --> 00:12:15,700
but it is basically an attempt by the operating system to use some

258
00:12:15,700 --> 00:12:16,900
aspects of the system.

259
00:12:16,900 --> 00:12:19,300
I think it used to use some kind of bus clock in your so I don't even

260
00:12:19,300 --> 00:12:21,000
know what it uses these days.

261
00:12:21,000 --> 00:12:21,600
I'm sorry.

262
00:12:21,600 --> 00:12:22,900
I just, I have absolutely no idea.

263
00:12:22,900 --> 00:12:26,400
I've never even looked into it and on a modern computer, but it

264
00:12:26,400 --> 00:12:32,000
basically uses some aspects of the system, whatever it can to give you

265
00:12:32,000 --> 00:12:34,200
back some wall clock time.

266
00:12:34,700 --> 00:12:38,300
You can see here that it's suggesting that it's resolution is actually

267
00:12:38,300 --> 00:12:40,900
better than one microsecond, right?

268
00:12:41,100 --> 00:12:42,700
So that's much better than a millisecond.

269
00:12:42,700 --> 00:12:43,000
Right?

270
00:12:43,000 --> 00:12:46,400
And just to give you something Ms.

271
00:12:47,400 --> 00:12:48,700
/, oops.

272
00:12:48,800 --> 00:12:54,200
Sorry, microseconds per millisecond there so you can see that

273
00:12:54,200 --> 00:12:59,400
basically you've essentially got something greater than 1000 of those

274
00:12:59,700 --> 00:13:00,800
per millisecond.

275
00:13:00,800 --> 00:13:02,900
We don't actually know because it just says greater than.

276
00:13:02,900 --> 00:13:04,500
So, it's something in this box.

277
00:13:04,600 --> 00:13:09,000
Ballpark, so that's in theory going to be pretty high resolution for

278
00:13:09,000 --> 00:13:10,100
us to time things with.

279
00:13:10,800 --> 00:13:14,000
But the important part about this as opposed to the cycle count is

280
00:13:14,000 --> 00:13:14,200
query.

281
00:13:14,200 --> 00:13:18,000
Performance counter actually corresponds to wall clock time.

282
00:13:18,200 --> 00:13:21,800
Meaning, when we look at to query, performance, counter times and we

283
00:13:21,800 --> 00:13:23,300
look at the difference between them.

284
00:13:23,400 --> 00:13:27,400
We will be able to actually correlate that out to a real-world time.

285
00:13:27,700 --> 00:13:30,800
And that's important because it helps with your intuition.

286
00:13:35,200 --> 00:13:39,500
If we know that we have 16 milliseconds per frame to do something.

287
00:13:40,200 --> 00:13:45,000
It helps us to kind of know how much actual time is.

288
00:13:45,100 --> 00:13:47,000
This particular piece of code taking?

289
00:13:47,000 --> 00:13:47,700
And we think about it.

290
00:13:47,700 --> 00:13:49,600
We're like, okay, takes point five milliseconds.

291
00:13:49,800 --> 00:13:55,500
So I roughly know, I could do, you know, 30, some odd of them, you

292
00:13:55,500 --> 00:13:58,700
know, thirtysomething of them per frame.

293
00:13:58,700 --> 00:14:01,000
I kind of get sort of this idea of that, right?

294
00:14:01,200 --> 00:14:02,000
Where again, with the

295
00:14:02,200 --> 00:14:05,100
Since they vary so much, it's harder for us to tie that back to a

296
00:14:05,100 --> 00:14:05,600
time.

297
00:14:05,700 --> 00:14:07,100
We always can write.

298
00:14:07,100 --> 00:14:12,100
We always could, actually we always could actually try to time the

299
00:14:12,100 --> 00:14:14,800
artist tses with the query performance counter.

300
00:14:14,800 --> 00:14:18,700
So we know how many roughly the CPU is executing every frame and then

301
00:14:18,700 --> 00:14:20,300
back out those times and stuff like that.

302
00:14:20,300 --> 00:14:22,200
But really without create performance counter.

303
00:14:22,200 --> 00:14:26,600
We'd never have a way on a running machine of really even knowing how

304
00:14:26,600 --> 00:14:31,200
those are dtsc eskom map back to wall clock time because we never

305
00:14:31,200 --> 00:14:32,000
would have any idea how

306
00:14:32,100 --> 00:14:33,800
How fast the processor was actually running.

307
00:14:33,800 --> 00:14:37,200
We always at least need something that can tell us when a second went

308
00:14:37,200 --> 00:14:41,400
by, let's say so that we could see using our dtsc, how many cycles,

309
00:14:41,400 --> 00:14:43,700
the processor had actually executed in that s, right.

310
00:14:44,000 --> 00:14:46,300
And so that's that's really where this comes in.

311
00:14:46,700 --> 00:14:49,100
So those are the two things that we're going to be talking about today

312
00:14:49,200 --> 00:14:52,000
and I'm just going to show you a little bit about how you use them.

313
00:14:52,200 --> 00:14:55,900
And this will give us a little more insight as well into how our code

314
00:14:56,000 --> 00:14:57,800
that we've already written is even working.

315
00:14:57,800 --> 00:14:59,500
Because right now, we don't even know.

316
00:14:59,500 --> 00:14:59,900
For example,

317
00:15:00,000 --> 00:15:02,800
Or how fast our program is running.

318
00:15:02,800 --> 00:15:03,400
We have no idea.

319
00:15:03,400 --> 00:15:05,500
How many frames per second were even getting right?

320
00:15:05,500 --> 00:15:08,000
And this will finally let us sign and get that information.

321
00:15:11,500 --> 00:15:17,100
Okay, so I'm going to go ahead here and open up our Command Prompt.

322
00:15:17,500 --> 00:15:22,100
I'm going to get into emacs, everyone's favorite editor.

323
00:15:25,000 --> 00:15:25,500
Excuse me.

324
00:15:25,900 --> 00:15:29,200
Still getting over the cold feeling feeling better today, but still

325
00:15:29,200 --> 00:15:30,900
throat's a little scratchy.

326
00:15:31,000 --> 00:15:31,300
Alright.

327
00:15:31,300 --> 00:15:35,200
So basically, what I want to do here is I want to just start by doing

328
00:15:35,200 --> 00:15:37,200
something extremely, extremely simple.

329
00:15:37,700 --> 00:15:41,200
I want to start by saying, well, we have a loop, right here is our

330
00:15:42,200 --> 00:15:45,400
We're going to we're going to have a while loop where we just run and

331
00:15:45,400 --> 00:15:46,800
our game is sitting in this loop.

332
00:15:46,900 --> 00:15:48,500
I just want to start by going.

333
00:15:48,600 --> 00:15:54,500
Let's print out some number that we can use to sort of see how long it

334
00:15:54,500 --> 00:15:56,300
took us to generate a frame.

335
00:15:56,600 --> 00:15:57,200
Right?

336
00:15:57,300 --> 00:15:58,300
And in order to do that.

337
00:15:58,300 --> 00:16:01,300
I'm going to use this query performance counter thing because I want

338
00:16:01,300 --> 00:16:03,100
to know the actual wall clock time.

339
00:16:03,100 --> 00:16:05,400
I want to know how many actual seconds.

340
00:16:05,700 --> 00:16:06,800
It's going to be fractional.

341
00:16:07,200 --> 00:16:09,900
It took to generate this or, you know, maybe we'll do how many

342
00:16:09,900 --> 00:16:11,400
milliseconds to make it.

343
00:16:11,600 --> 00:16:15,100
Easier to understand print out wide so it's not .00, whatever.

344
00:16:18,000 --> 00:16:21,600
Who knows but point out world, when we get to our actual output debug

345
00:16:21,600 --> 00:16:22,000
string.

346
00:16:22,400 --> 00:16:24,400
We will actually shoot me.

347
00:16:25,400 --> 00:16:26,300
Print this out.

348
00:16:26,300 --> 00:16:26,500
Okay.

349
00:16:26,500 --> 00:16:28,000
So we have query performance counter.

350
00:16:28,300 --> 00:16:31,800
We're going to go ahead and get that and we're going to call that.

351
00:16:31,800 --> 00:16:34,000
Now, the way that it works is, it's another one of these windows

352
00:16:34,000 --> 00:16:34,400
functions.

353
00:16:34,400 --> 00:16:35,400
You've seen them a lot here.

354
00:16:35,600 --> 00:16:38,100
We're basically they take something to fill out.

355
00:16:38,200 --> 00:16:39,800
In this case, a large integer.

356
00:16:40,300 --> 00:16:43,300
So basically we need a large integer and we're going to call this

357
00:16:43,300 --> 00:16:47,400
begin counter and we're going to take the address of that.

358
00:16:48,100 --> 00:16:50,700
And basically we pass an address and it fills it out.

359
00:16:50,700 --> 00:16:51,800
Now a large integer.

360
00:16:52,200 --> 00:16:54,800
I don't know where there's no way too quick jump to it.

361
00:16:54,900 --> 00:16:55,100
I was

362
00:16:55,200 --> 00:16:56,600
To show you the structure of it here.

363
00:16:56,600 --> 00:16:58,900
So I'll just cut and paste it into the search box.

364
00:16:59,700 --> 00:17:01,400
I want to actually show you the layout.

365
00:17:01,400 --> 00:17:02,400
There it is.

366
00:17:02,900 --> 00:17:07,200
So basically a large integer uses something called a union, which we

367
00:17:07,200 --> 00:17:10,200
really have not covered in this at all.

368
00:17:10,200 --> 00:17:11,400
It's a very simple concept.

369
00:17:11,400 --> 00:17:14,700
Basically, what a union is, is it's just a number of things that are

370
00:17:14,700 --> 00:17:17,000
overlaid on top of each other in memory.

371
00:17:17,200 --> 00:17:20,599
So it's basically telling you that you can access the same piece of

372
00:17:20,599 --> 00:17:22,400
memory in multiple ways.

373
00:17:22,500 --> 00:17:25,000
So when you say Union in Syria,

374
00:17:25,200 --> 00:17:30,100
C++ the then list things and each thing listed in the union occupies

375
00:17:30,100 --> 00:17:31,800
the same space in memory.

376
00:17:31,800 --> 00:17:37,400
So basically, this struct this struct and this long long, which is

377
00:17:37,400 --> 00:17:42,100
long long as 60 is, is Windows way of saying you in 64, basically or

378
00:17:42,100 --> 00:17:42,600
N64.

379
00:17:42,600 --> 00:17:46,500
I should say, since it's not you long loan and in a 64-bit integer,

380
00:17:46,500 --> 00:17:51,200
each one of these right is actually 64 bits, right?

381
00:17:51,200 --> 00:17:52,600
That's 32 bits 32 bits.

382
00:17:52,700 --> 00:17:53,500
That's 32 bits.

383
00:17:53,500 --> 00:17:54,200
32 bits.

384
00:17:54,200 --> 00:17:55,200
And this is stage.

385
00:17:55,200 --> 00:17:59,700
64-bits, basically, this this Union is just 64 bits long.

386
00:18:00,100 --> 00:18:06,100
But you can access it using any of these methods you can say, dot quad

387
00:18:06,100 --> 00:18:08,100
part to access it as 64 bits.

388
00:18:08,300 --> 00:18:13,600
You can say, Dot Low part to access it as the low 32 or high part

389
00:18:13,600 --> 00:18:14,000
taxes.

390
00:18:14,000 --> 00:18:15,100
It is the high 32.

391
00:18:15,500 --> 00:18:19,700
You can also use dot U Dot Low part and Dot U dot High part.

392
00:18:19,700 --> 00:18:21,200
Now, why they wanted to do it this way.

393
00:18:21,200 --> 00:18:21,800
I don't know.

394
00:18:22,000 --> 00:18:25,000
This is called an anonymous structure, which means that these are

395
00:18:25,000 --> 00:18:27,500
directly accessible off of the things.

396
00:18:27,500 --> 00:18:29,900
So basically, Anonymous lets

397
00:18:30,000 --> 00:18:31,500
You access them directly.

398
00:18:31,500 --> 00:18:34,500
So you like, you know, I can just say Dot Low part, right?

399
00:18:34,500 --> 00:18:38,100
Like that just with one dot that directly accesses this.

400
00:18:38,200 --> 00:18:39,200
That's why it's called an anonymous.

401
00:18:39,200 --> 00:18:40,700
There is no actual.

402
00:18:41,100 --> 00:18:43,600
It's not actually in here as a separate member this.

403
00:18:43,600 --> 00:18:47,300
You right here means that there's basically a, you know, a field

404
00:18:47,300 --> 00:18:51,600
called you inside here that is this, the type is this structure.

405
00:18:51,800 --> 00:18:55,400
So, if I wanted to access it through that, I would do, dot U Dot Low,

406
00:18:55,400 --> 00:18:56,400
part like that.

407
00:18:56,500 --> 00:18:58,600
Now, I have no idea why they have both of these in there.

408
00:18:58,600 --> 00:18:59,700
Doesn't seem like you would need them.

409
00:18:59,700 --> 00:18:59,800
There.

410
00:19:00,000 --> 00:19:02,300
Like I said, they're occupying the exact same memory.

411
00:19:02,400 --> 00:19:05,300
So it's basically just to allow you to do that or that.

412
00:19:05,300 --> 00:19:07,700
So, I have to assume that that's just for backwards compatibility

413
00:19:07,700 --> 00:19:08,200
purposes.

414
00:19:08,200 --> 00:19:10,500
Like they made this one originally and then we're like, wow, we should

415
00:19:10,500 --> 00:19:12,600
probably do it this way as well or something.

416
00:19:12,600 --> 00:19:13,300
I don't really know.

417
00:19:13,500 --> 00:19:15,100
But point being, you don't even have to worry about that.

418
00:19:15,100 --> 00:19:17,600
It's completely, it's some kind of weird anachronism.

419
00:19:17,600 --> 00:19:20,800
I would suspect since we are on a 64-bit architecture.

420
00:19:21,800 --> 00:19:23,600
We're just going to go straight for the quad part.

421
00:19:23,700 --> 00:19:25,800
The quad part is basically the part we want.

422
00:19:25,900 --> 00:19:27,100
So we're going to look at that.

423
00:19:27,200 --> 00:19:31,700
The quad part tells us basically, the whatever this value is, and we

424
00:19:31,700 --> 00:19:33,300
don't really know how to interpret this value.

425
00:19:33,600 --> 00:19:35,400
It's some 64-bit value.

426
00:19:35,800 --> 00:19:37,600
That is a clock value.

427
00:19:37,800 --> 00:19:40,400
We that we know somehow corresponds to wall clock time.

428
00:19:40,800 --> 00:19:43,300
And now we know that begin counter dot quad Park.

429
00:19:43,300 --> 00:19:48,400
Quad part, is that timestamp that value at the time that we start the

430
00:19:48,400 --> 00:19:48,900
loop.

431
00:19:48,900 --> 00:19:51,400
So as soon as we asked for this, we basically now have

432
00:19:51,600 --> 00:19:55,100
That start time is in begin counter quad park, right?

433
00:19:55,500 --> 00:19:58,000
So then we're going to do is we're going to jump down.

434
00:19:58,100 --> 00:19:59,000
Well, actually guess we don't.

435
00:19:59,000 --> 00:20:00,400
We can just we don't even need to do that.

436
00:20:00,400 --> 00:20:02,500
We're going to do it right here, basically.

437
00:20:03,700 --> 00:20:04,100
Right.

438
00:20:04,700 --> 00:20:08,300
So we're also going to say last counter, right?

439
00:20:08,700 --> 00:20:10,700
And we're going to ask for that up here.

440
00:20:11,300 --> 00:20:11,800
Excuse me.

441
00:20:15,300 --> 00:20:17,000
I figured this was a better way to structure this.

442
00:20:17,900 --> 00:20:20,900
I'll tell you why in one second, why I felt like that was a good idea.

443
00:20:21,500 --> 00:20:24,700
So basically what we're going to do is we're going to say all right at

444
00:20:24,700 --> 00:20:27,900
the beginning, we're going to snap whatever the value is then we're

445
00:20:27,900 --> 00:20:30,100
going to go through the loop and every time through the loop when we

446
00:20:30,100 --> 00:20:33,700
get to the end we're going to look at what this is and we'll call this

447
00:20:33,700 --> 00:20:34,300
and counter.

448
00:20:34,700 --> 00:20:39,100
Right encounter will give us another time stamp and that time stamp

449
00:20:39,100 --> 00:20:42,400
will be how you know, after after we've done everything essentially

450
00:20:42,400 --> 00:20:43,000
right?

451
00:20:43,700 --> 00:20:45,000
And then we'll go back down through the loop.

452
00:20:45,100 --> 00:20:46,800
Oop, and we'll get to encounter, we'll get it again.

453
00:20:47,000 --> 00:20:50,400
So, all we're going to do is every time after we actually print out

454
00:20:50,400 --> 00:20:51,000
here, right?

455
00:20:51,000 --> 00:20:53,900
We're going to actually display the value here.

456
00:20:56,900 --> 00:20:59,500
We're just going to say that the last counter, whatever that is equals

457
00:20:59,500 --> 00:20:59,800
the end.

458
00:21:00,000 --> 00:21:00,700
Her right?

459
00:21:00,700 --> 00:21:03,300
So we're going to actually store whatever the value was here.

460
00:21:03,300 --> 00:21:07,800
Back in the last counter that will let us essentially compute the

461
00:21:07,800 --> 00:21:08,500
difference.

462
00:21:08,700 --> 00:21:15,100
Every time whatever n counter dot quad, part - last counter dot quad

463
00:21:15,100 --> 00:21:16,100
part, right?

464
00:21:16,100 --> 00:21:16,800
I do this.

465
00:21:17,200 --> 00:21:20,700
And I'm going to put this in, in 64, and this was the difference time

466
00:21:20,700 --> 00:21:21,900
difference, right?

467
00:21:22,100 --> 00:21:26,400
Could say, this was the time elapsed basically, maybe I should say,

468
00:21:26,400 --> 00:21:27,500
counter elapsed.

469
00:21:29,800 --> 00:21:30,300
Excuse me.

470
00:21:31,200 --> 00:21:36,700
If you look at this, man, it isn't me so good to do this dream.

471
00:21:37,200 --> 00:21:37,700
I'm not sick.

472
00:21:37,700 --> 00:21:40,800
I've done almost the entire handmade hero sick.

473
00:21:42,700 --> 00:21:43,700
And its really annoying.

474
00:21:43,800 --> 00:21:44,400
All right.

475
00:21:47,300 --> 00:21:50,900
Interrupts me anyway, so basically all we're doing here is we're

476
00:21:50,900 --> 00:21:53,200
saying well we have this clock.

477
00:21:53,300 --> 00:21:56,800
We're going to look at the clock before we enter our Loop, right?

478
00:21:57,700 --> 00:21:58,700
Right before we enter it.

479
00:21:58,700 --> 00:22:01,300
Let's say we're going to do everything in the loop.

480
00:22:01,400 --> 00:22:02,900
We're going to look at the clock again.

481
00:22:03,200 --> 00:22:05,700
So we've looked at the clock twice and just like in the real world.

482
00:22:05,700 --> 00:22:07,400
We can now take those two times.

483
00:22:07,400 --> 00:22:11,100
The beginning in the end that we looked at the clock subtract, the X

484
00:22:11,400 --> 00:22:15,300
and we will get, how much time elapsed right by that.

485
00:22:15,500 --> 00:22:15,800
Fuck.

486
00:22:16,500 --> 00:22:19,000
So, then in order to make sure that works again for the next frame.

487
00:22:19,000 --> 00:22:20,000
We will pretend that.

488
00:22:20,000 --> 00:22:21,600
Now, that original clock.

489
00:22:21,600 --> 00:22:24,800
We took, that's just the new clock value that we got back.

490
00:22:24,800 --> 00:22:27,300
So that the next time we get back down here, will be differencing.

491
00:22:27,300 --> 00:22:28,500
It from itself will be different.

492
00:22:28,500 --> 00:22:31,200
Sing it from the last time it passed this point.

493
00:22:31,900 --> 00:22:34,400
And the reason that I wanted to do that instead of putting a big

494
00:22:34,400 --> 00:22:37,200
encounter at the top of the while loop and an encounter at the end is

495
00:22:37,200 --> 00:22:41,100
because well technically that doesn't quite capture all the time,

496
00:22:41,300 --> 00:22:41,900
right?

497
00:22:42,400 --> 00:22:45,400
If the actual Act of getting back

498
00:22:45,500 --> 00:22:48,600
Ooh, the top of this Loop, maybe the process got switched out or

499
00:22:48,600 --> 00:22:49,300
something happened.

500
00:22:49,300 --> 00:22:52,700
That took a lot more time than just doing one comp, and a jump to get

501
00:22:52,700 --> 00:22:53,500
back to the top.

502
00:22:53,500 --> 00:22:54,500
We'd miss that time.

503
00:22:54,600 --> 00:22:57,600
So I want something that's guaranteed to never miss any time.

504
00:22:57,900 --> 00:23:02,400
So by always using a single stable place, where we check the clock and

505
00:23:02,400 --> 00:23:06,400
differencing, it from that every time, we know that we've never had

506
00:23:06,400 --> 00:23:08,100
anything Escape our time, window.

507
00:23:08,100 --> 00:23:09,900
Our time, window is all-inclusive.

508
00:23:10,000 --> 00:23:12,900
There's nothing that could have happened that isn't accounted for,

509
00:23:13,000 --> 00:23:14,200
within our clock window.

510
00:23:15,500 --> 00:23:17,600
So, once we do that, we have a counter last value.

511
00:23:17,600 --> 00:23:20,100
That basically tells us how much time has elapsed.

512
00:23:20,100 --> 00:23:20,800
Unfortunately.

513
00:23:20,800 --> 00:23:23,300
We still don't know how to interpret this clock value.

514
00:23:23,300 --> 00:23:26,300
So if we want to print out how many seconds something took, how many

515
00:23:26,300 --> 00:23:31,100
milliseconds something took we don't know what we'd like to do is we'd

516
00:23:31,100 --> 00:23:35,100
like to be able to translate this back to human readable wall clock

517
00:23:35,100 --> 00:23:38,200
time instead of machine-readable clock time, which we don't even know

518
00:23:38,200 --> 00:23:41,300
what it is because we don't know how Windows is even arriving at these

519
00:23:41,300 --> 00:23:44,400
clock values, but fortunately, they give us something that does

520
00:23:44,600 --> 00:23:44,800
exactly.

521
00:23:44,900 --> 00:23:47,300
Actly that it's called query performance frequency.

522
00:23:47,300 --> 00:23:51,000
Now, what Corey performance frequency does is, it basically tells us

523
00:23:51,400 --> 00:23:58,000
how many increments this clock goes through in one second, right?

524
00:23:58,200 --> 00:23:59,800
So, basically, if we just ask for this,

525
00:24:00,600 --> 00:24:01,600
Up here, right?

526
00:24:01,600 --> 00:24:04,100
If we say, hey Corey performance frequency.

527
00:24:04,200 --> 00:24:08,600
Now the question I think I'm going to double check this.

528
00:24:09,000 --> 00:24:12,200
I think we can just ask for this once because I don't think great

529
00:24:12,200 --> 00:24:15,600
performance frequencies allowed to change but let me see if they

530
00:24:15,600 --> 00:24:18,700
actually say that for certain somewhere.

531
00:24:19,200 --> 00:24:20,200
Let's take a look.

532
00:24:22,000 --> 00:24:25,300
Yes, the frequency of the performance counter is fixed at system.

533
00:24:25,300 --> 00:24:25,800
Boot time.

534
00:24:25,800 --> 00:24:27,900
As is consistent across all processors.

535
00:24:27,900 --> 00:24:30,600
Therefore, the frequency need only be queried upon application

536
00:24:30,600 --> 00:24:32,800
initialization and the result can be cached.

537
00:24:32,900 --> 00:24:35,600
So at least, according to the documentation, which granted is

538
00:24:35,600 --> 00:24:36,600
sometimes wrong.

539
00:24:37,100 --> 00:24:41,600
We only actually have to ask once so, we can just say the performance

540
00:24:41,600 --> 00:24:48,100
frequency, or maybe I'll say the proof counter frequency, right is

541
00:24:48,100 --> 00:24:49,000
going to be something.

542
00:24:49,000 --> 00:24:51,400
We can just ask for we then know.

543
00:24:51,800 --> 00:24:54,200
Many of them happened for second, right?

544
00:24:54,600 --> 00:24:56,000
And and we are good to go.

545
00:24:56,400 --> 00:24:57,000
So, there we go.

546
00:24:57,000 --> 00:24:59,500
We now have that value and we can use it.

547
00:24:59,600 --> 00:25:05,500
So if we actually go ahead and get that, right, I'm going to put this

548
00:25:05,500 --> 00:25:10,000
up here on the unit area, if we do that.

549
00:25:11,200 --> 00:25:15,100
We can then come down here and say, well, we have a counter value that

550
00:25:15,100 --> 00:25:15,700
elapsed.

551
00:25:16,000 --> 00:25:21,300
And we also know how many of those per second, we're actually doing.

552
00:25:21,400 --> 00:25:21,900
Right?

553
00:25:21,900 --> 00:25:24,300
We know that basically up here.

554
00:25:24,300 --> 00:25:27,400
In fact, I could even stuff this into a more useful variable.

555
00:25:27,400 --> 00:25:34,700
I could say in 64 per count frequency like this and say that that was

556
00:25:35,600 --> 00:25:39,700
perfect Camp, frequency dot quad part like we did before and this will

557
00:25:39,700 --> 00:25:40,100
be

558
00:25:41,300 --> 00:25:43,800
Just a thing that uses to hold that value coming back.

559
00:25:43,800 --> 00:25:44,200
There we go.

560
00:25:44,800 --> 00:25:46,300
So now we have the perfect count frequency.

561
00:25:46,300 --> 00:25:49,800
We know that is how many counts per second that thing is doing.

562
00:25:49,900 --> 00:25:54,700
So, in here, when we have the counter elapsed, we can actually say

563
00:25:54,900 --> 00:25:59,600
well, however, many elapsed right /, how many per second there were?

564
00:26:00,300 --> 00:26:02,100
That's how many Hoops.

565
00:26:02,100 --> 00:26:04,300
That's how many seconds actually elapsed.

566
00:26:04,300 --> 00:26:06,500
I just spilled my coffee, ladies and gentlemen, it was bound to

567
00:26:06,500 --> 00:26:06,800
happen.

568
00:26:06,800 --> 00:26:09,000
Eventually, of course Frank.

569
00:26:09,000 --> 00:26:11,000
Thankfully, it kind of limits.

570
00:26:11,200 --> 00:26:12,200
Did on my Mitten.

571
00:26:12,500 --> 00:26:17,100
So it did not actually do not actually spill anywhere but almost did

572
00:26:17,300 --> 00:26:20,800
and it almost wasted valuable coffee, which is really a crime.

573
00:26:23,600 --> 00:26:29,300
So doing this divide saying the counter counts that we saw divided by

574
00:26:29,300 --> 00:26:32,300
the frequency of that counter gives us the S.

575
00:26:32,600 --> 00:26:35,500
And of course, one thing I should mention for the benefit of those of

576
00:26:35,500 --> 00:26:38,000
you who are maybe not math Stars.

577
00:26:38,200 --> 00:26:40,000
I know I'm certainly not a mass star.

578
00:26:40,600 --> 00:26:43,600
So I just want to point this out for people who don't think about

579
00:26:43,600 --> 00:26:43,800
things.

580
00:26:43,800 --> 00:26:47,600
This way to maybe get you thinking about things in this way and doing

581
00:26:47,600 --> 00:26:49,800
a little more reading in this area.

582
00:26:49,800 --> 00:26:52,700
Perhaps one thing I wanted to point out is

583
00:26:53,100 --> 00:26:55,800
Channel analysis is particularly useful.

584
00:26:55,900 --> 00:26:58,500
When you're doing these sorts of things, you know, in your head, when

585
00:26:58,500 --> 00:26:59,700
you're writing the sort of code just

586
00:27:00,000 --> 00:27:05,300
Think about if you have something like a counter and you say, well, I

587
00:27:05,300 --> 00:27:07,900
have a counter value and I know it came back.

588
00:27:07,900 --> 00:27:11,300
It was like X number of counts, right?

589
00:27:11,400 --> 00:27:12,300
Which is what we have.

590
00:27:12,300 --> 00:27:15,500
Like we got this back and we know that this is the number of counts

591
00:27:15,500 --> 00:27:18,500
that were that transpire, the number of like clocks that transpired

592
00:27:18,500 --> 00:27:18,700
right?

593
00:27:18,700 --> 00:27:21,300
Number of counts nerve counter increments.

594
00:27:22,300 --> 00:27:24,900
And then we also know that this performance frequency thing when we

595
00:27:24,900 --> 00:27:26,700
read the documentation, right?

596
00:27:27,100 --> 00:27:30,100
It says counts per second, right?

597
00:27:30,200 --> 00:27:35,100
So we also have a value that is counts right per second.

598
00:27:37,700 --> 00:27:42,200
So if you have two values one that is counts and one that is counts

599
00:27:42,200 --> 00:27:43,000
per second.

600
00:27:43,400 --> 00:27:49,200
And you want to know how many seconds something took which is this,

601
00:27:49,700 --> 00:27:50,300
right?

602
00:27:51,000 --> 00:27:52,300
But you have a value.

603
00:27:52,300 --> 00:27:56,200
That's how many counts it took the question becomes.

604
00:27:56,300 --> 00:27:58,400
How do you get that value?

605
00:27:58,600 --> 00:27:59,200
Right?

606
00:27:59,600 --> 00:28:05,200
And the answer is you can always just look at how the unit's cancel on

607
00:28:05,200 --> 00:28:06,000
the Divide.

608
00:28:06,000 --> 00:28:07,300
So let's say we were to multiply

609
00:28:07,500 --> 00:28:09,700
Apply these two things together, right?

610
00:28:09,800 --> 00:28:10,700
What would we get?

611
00:28:10,800 --> 00:28:13,500
Well, just look at what happens with the unit's counts.

612
00:28:13,600 --> 00:28:15,400
This is essentially over 1, right.

613
00:28:15,400 --> 00:28:17,900
This is X counts and counts per second.

614
00:28:17,900 --> 00:28:18,500
Right?

615
00:28:18,700 --> 00:28:23,500
If I multiply these together I would get counts squared right counts,

616
00:28:23,500 --> 00:28:25,900
times counts over s.

617
00:28:26,200 --> 00:28:26,800
Right.

618
00:28:27,500 --> 00:28:31,100
That is completely useless who I mean that is not count squared over

619
00:28:31,100 --> 00:28:31,500
s.

620
00:28:31,500 --> 00:28:31,600
Is.

621
00:28:31,600 --> 00:28:33,800
We don't even know what that is, right.

622
00:28:34,200 --> 00:28:37,000
So what you want to do is look at how do you

623
00:28:37,800 --> 00:28:42,400
Actually cancel the counts right out like this so that you're just

624
00:28:42,400 --> 00:28:43,400
left with s.

625
00:28:43,700 --> 00:28:44,200
Okay.

626
00:28:44,500 --> 00:28:46,900
And the way that you do that is you say, well X counts.

627
00:28:47,200 --> 00:28:49,900
I just need this to be inverted if s was on the top and counters on

628
00:28:49,900 --> 00:28:51,100
the bottom, the counts would cancel.

629
00:28:51,100 --> 00:28:52,500
And that's what a divide is, right.

630
00:28:52,500 --> 00:28:55,800
It divide flips, the two things in a ratio.

631
00:28:55,900 --> 00:28:58,700
So if I do counts /, right?

632
00:28:58,800 --> 00:29:04,100
Counts per second, that is the same as multiplying by seconds per

633
00:29:04,100 --> 00:29:05,500
count, right?

634
00:29:06,200 --> 00:29:07,300
So the counts.

635
00:29:07,500 --> 00:29:10,900
And we're just left with x s, which is what I wanted.

636
00:29:11,300 --> 00:29:14,200
So looking at things in terms of flipping, you know, basically

637
00:29:14,200 --> 00:29:16,900
flipping your ratios by either dividing or multiplying.

638
00:29:17,100 --> 00:29:19,300
You could line up a whole string of these things.

639
00:29:19,300 --> 00:29:22,700
If you've got them and cancel all the things that you actually need,

640
00:29:22,800 --> 00:29:23,300
right?

641
00:29:23,800 --> 00:29:24,800
It's a standard kind of thing.

642
00:29:24,800 --> 00:29:28,300
In dimensional analysis to do where you've got some number, like

643
00:29:28,300 --> 00:29:34,300
you've got x s and you want to know how many days x s is, right?

644
00:29:34,300 --> 00:29:36,100
And you can kind of just line things up.

645
00:29:36,100 --> 00:29:37,200
You can say, okay.

646
00:29:37,400 --> 00:29:38,500
Well, x s.

647
00:29:38,500 --> 00:29:42,400
I would need to multiply by how many seconds I need to cancel s.

648
00:29:42,500 --> 00:29:45,200
So there s, and I can translate S.

649
00:29:45,200 --> 00:29:48,000
I know how to translate s in two minutes, right?

650
00:29:48,600 --> 00:29:53,100
Because it's basically 60 seconds per, you know, one minute, right?

651
00:29:53,100 --> 00:29:58,400
And I know how to translate minutes right in two hours because I know

652
00:29:58,400 --> 00:29:59,800
there's 60 of those.

653
00:30:00,000 --> 00:30:00,400
Right.

654
00:30:00,500 --> 00:30:02,700
So, I can just say one hour is 60 Minutes.

655
00:30:02,800 --> 00:30:08,000
I know how to translate hours into days because there's 24 hours in

656
00:30:08,000 --> 00:30:09,400
one day, right?

657
00:30:09,900 --> 00:30:12,000
And just by literally, going well, whatever.

658
00:30:12,000 --> 00:30:14,400
This thing was, I got to put it on the bottom to translate into

659
00:30:14,400 --> 00:30:16,200
something on the top, put it on the bottom translate something the

660
00:30:16,200 --> 00:30:16,800
top.

661
00:30:17,000 --> 00:30:19,700
I made the math, exactly what it needs to be.

662
00:30:19,900 --> 00:30:22,000
It's just multiply it out.

663
00:30:22,100 --> 00:30:27,500
X times 1 times 1 times, 1 is X 60 times, 60 times 24, 60 times, 60

664
00:30:27,700 --> 00:30:29,800
times 24, these all

665
00:30:30,000 --> 00:30:33,800
All cancel minutes hours hours day, right?

666
00:30:33,800 --> 00:30:35,500
And we get this.

667
00:30:35,600 --> 00:30:36,800
And that is the answer.

668
00:30:37,200 --> 00:30:41,500
So, you would just divide X by 60 times, 60 times 24, and that is how

669
00:30:41,500 --> 00:30:42,300
many days it is.

670
00:30:42,400 --> 00:30:42,700
Again.

671
00:30:42,700 --> 00:30:47,400
If you're a math minded fellow, this is Trivial, but if you aren't,

672
00:30:47,400 --> 00:30:50,400
it's worth starting to think about things like this.

673
00:30:51,000 --> 00:30:51,400
There you go.

674
00:30:52,900 --> 00:30:53,500
Okay.

675
00:30:57,500 --> 00:31:01,400
Let's go back to the actual code, which I have not really been doing

676
00:31:01,400 --> 00:31:01,700
anything.

677
00:31:01,700 --> 00:31:04,700
Okay, so there's an encounter here and there's a last counter.

678
00:31:05,100 --> 00:31:06,600
We got the frequency here.

679
00:31:06,800 --> 00:31:08,500
I got to put that in there.

680
00:31:08,900 --> 00:31:12,800
Let's see, gotta take the semicolon there.

681
00:31:12,800 --> 00:31:13,400
Alright.

682
00:31:13,700 --> 00:31:16,100
So basically this is going to give us back that value, but the

683
00:31:16,100 --> 00:31:17,600
question is, what are we going to do with that value?

684
00:31:17,600 --> 00:31:21,700
Well, what we can do with that value certainly is we can say, well

685
00:31:21,700 --> 00:31:23,900
we've got the counter Last Ride, the performance frequency.

686
00:31:23,900 --> 00:31:26,600
The problem is, if this is an integer divided, right?

687
00:31:26,600 --> 00:31:27,200
We know that the

688
00:31:27,300 --> 00:31:30,600
Of count frequency is how many counts per second there are and we know

689
00:31:30,600 --> 00:31:33,800
that we probably didn't take a whole second to draw this Frame.

690
00:31:34,100 --> 00:31:36,700
So this is just going to come out 20, the integer divide.

691
00:31:36,700 --> 00:31:37,900
There's no fractional part.

692
00:31:38,000 --> 00:31:40,500
So something that's a large number divided by something.

693
00:31:40,500 --> 00:31:43,000
That's a smaller number is just going to give us 0.

694
00:31:43,100 --> 00:31:45,300
So s is not particularly useful.

695
00:31:45,300 --> 00:31:49,600
So what we might want to do is say well if we multiply this by 1000

696
00:31:49,800 --> 00:31:53,100
right first that would actually give us Ms.

697
00:31:53,100 --> 00:31:53,400
Now.

698
00:31:53,400 --> 00:31:56,300
So if we multiply this by 1000, then we've got some room to do our

699
00:31:56,300 --> 00:31:57,100
divide that

700
00:31:57,200 --> 00:32:00,300
That would give us how many milliseconds it took to do this Frame.

701
00:32:00,600 --> 00:32:01,100
Right?

702
00:32:01,300 --> 00:32:05,200
So this is milliseconds per frame, right?

703
00:32:05,500 --> 00:32:06,800
That is the actual value.

704
00:32:06,900 --> 00:32:10,300
So now we actually know how many milliseconds per frame, we're

705
00:32:10,300 --> 00:32:13,800
actually taking and we can just take a look at how many that actually

706
00:32:13,800 --> 00:32:17,100
was now, of course, it's going to vary preferring because like the

707
00:32:17,100 --> 00:32:21,600
first frame, we may do a lot X of extra work in the first frame.

708
00:32:21,700 --> 00:32:24,400
We may have a lot of Windows messages that come in that are like about

709
00:32:24,400 --> 00:32:26,400
initializing the window or something, right?

710
00:32:26,700 --> 00:32:27,000
So the

711
00:32:27,300 --> 00:32:28,200
This time, we do it.

712
00:32:28,400 --> 00:32:30,100
We're not necessarily going to know.

713
00:32:30,400 --> 00:32:33,000
So we want to actually look possibly later frames.

714
00:32:35,700 --> 00:32:36,200
Okay.

715
00:32:36,800 --> 00:32:40,500
So basically, what we want to do is print this value out.

716
00:32:40,500 --> 00:32:44,100
Obviously, we have output debug string which we can, we can use, but

717
00:32:44,100 --> 00:32:44,900
we don't actually know.

718
00:32:44,900 --> 00:32:48,000
We've never actually seen how to print out a value.

719
00:32:48,000 --> 00:32:50,200
Well, we're going to look at that in a little more detail.

720
00:32:50,200 --> 00:32:52,100
When we do the platform independent code.

721
00:32:52,200 --> 00:32:56,300
We're going to look at how to Output our do our own output of values.

722
00:32:56,500 --> 00:32:59,500
So what we're going to do first is we're going to use Windows is code

723
00:32:59,500 --> 00:32:59,800
much.

724
00:33:00,000 --> 00:33:03,000
We used Windows is sine function to just test our stuff.

725
00:33:03,000 --> 00:33:05,700
We're going to use Windows code to Output the variable as well.

726
00:33:05,900 --> 00:33:08,100
But later on, I want to show you how that works.

727
00:33:08,100 --> 00:33:11,400
So it's not a mystery to you how you output a number because obviously

728
00:33:11,500 --> 00:33:13,500
someone knows how to do it and it works.

729
00:33:14,300 --> 00:33:19,000
There is a thing called WS printf which you can use in Windows code,

730
00:33:19,000 --> 00:33:20,800
to quickly generate strings.

731
00:33:20,900 --> 00:33:24,200
And basically, all you have to do to use it, is you create some buffer

732
00:33:24,200 --> 00:33:25,500
that it could write into, right?

733
00:33:25,500 --> 00:33:27,200
You can create some buffer like this.

734
00:33:27,400 --> 00:33:29,800
You can basically pass this buffer to,

735
00:33:30,000 --> 00:33:34,900
W sprintf, you can then give it some thing that you want to print out

736
00:33:34,900 --> 00:33:39,200
and give it the value that you want, and it will do it.

737
00:33:39,200 --> 00:33:43,200
Now, the way that it does, this is a little wonky, and it's just the

738
00:33:43,200 --> 00:33:45,500
way sees standard Library actually did it.

739
00:33:45,500 --> 00:33:46,800
So it's the way Windows does it.

740
00:33:46,800 --> 00:33:47,000
Now?

741
00:33:47,000 --> 00:33:52,800
Basically, what happens is it takes a format string so it can actually

742
00:33:52,800 --> 00:33:54,900
be something like milliseconds per frame.

743
00:33:55,500 --> 00:33:57,400
You know:.

744
00:33:57,400 --> 00:33:59,600
That's going to actually appear in the buffer.

745
00:33:59,600 --> 00:33:59,900
It's going to

746
00:34:00,000 --> 00:34:02,300
Copy those characters to our buffer, right?

747
00:34:02,300 --> 00:34:03,500
That we've, that we've made here.

748
00:34:04,000 --> 00:34:05,700
That's 256, bytes long.

749
00:34:05,800 --> 00:34:10,000
It's going to put those in there, but then it's also excuse me.

750
00:34:11,199 --> 00:34:15,400
It's also going to go ahead and look inside the string.

751
00:34:15,400 --> 00:34:18,400
It's going to process the string as it goes and look for anything with

752
00:34:18,400 --> 00:34:19,500
a percent in it.

753
00:34:19,699 --> 00:34:24,400
If it sees a percent, it will use the next thing that comes after it

754
00:34:24,400 --> 00:34:27,300
to determine what to print out.

755
00:34:27,400 --> 00:34:32,100
Okay, and then the parameters that come after it, right after the

756
00:34:32,100 --> 00:34:38,500
comma, it will then use to fill in whatever the percent told it was

757
00:34:38,500 --> 00:34:38,900
coming.

758
00:34:39,100 --> 00:34:40,600
So if I say something,

759
00:34:41,000 --> 00:34:43,199
Want to have, I've got like a thing here.

760
00:34:43,400 --> 00:34:46,300
Once this is we don't actually need 64 bits to store this so we can

761
00:34:46,300 --> 00:34:49,400
actually do something like 32 and I'll tell you why in a second.

762
00:34:49,400 --> 00:34:51,400
Why do that % D?

763
00:34:51,400 --> 00:34:58,000
For example, is the code that says, hey, this is a, this is a 32-bit

764
00:34:58,000 --> 00:34:58,400
integer.

765
00:34:58,400 --> 00:35:00,100
Basically, that's what that does.

766
00:35:00,200 --> 00:35:02,500
So, this says, we're going to pass a 32-bit integer.

767
00:35:02,500 --> 00:35:06,100
Please replace the percent D, in the string, with the 32-bit integer

768
00:35:06,200 --> 00:35:08,000
that I point you, right?

769
00:35:08,200 --> 00:35:09,600
And we can actually put a little Ms.

770
00:35:09,600 --> 00:35:10,600
After that four milliseconds.

771
00:35:10,600 --> 00:35:10,900
Let's

772
00:35:11,000 --> 00:35:15,900
Say so in here, we can now just pass buffer and that will actually do

773
00:35:16,100 --> 00:35:17,200
the print out for us.

774
00:35:17,300 --> 00:35:17,500
Now.

775
00:35:17,500 --> 00:35:18,600
There's a bunch of other things.

776
00:35:18,600 --> 00:35:20,900
I want to talk about here, but I'm just going to see if we got this

777
00:35:20,900 --> 00:35:21,200
working.

778
00:35:21,200 --> 00:35:21,800
First.

779
00:35:21,800 --> 00:35:24,800
I got to actually launch the debugger, of course, before we do

780
00:35:24,800 --> 00:35:25,600
anything else.

781
00:35:26,900 --> 00:35:27,900
Let's go ahead and do that.

782
00:35:28,900 --> 00:35:29,500
Here we go.

783
00:35:30,900 --> 00:35:33,400
So I'll close the app.

784
00:35:33,400 --> 00:35:34,900
We can kind of see what happened here.

785
00:35:35,000 --> 00:35:35,600
Right?

786
00:35:35,900 --> 00:35:38,700
And and much, like I said, it's not particularly predictable.

787
00:35:38,700 --> 00:35:41,200
If you look through here, the first frame was long.

788
00:35:41,200 --> 00:35:44,900
Like I said, it was going to be not surprising, then each particular

789
00:35:44,900 --> 00:35:45,500
frame.

790
00:35:45,500 --> 00:35:50,000
You look at, took us something on the order of six milliseconds, which

791
00:35:50,000 --> 00:35:52,500
occasional spikes up to 10 milliseconds.

792
00:35:52,700 --> 00:35:58,600
Now, normally those spikes, you know, is that typical eye on this type

793
00:35:58,600 --> 00:35:59,000
of machine?

794
00:35:59,000 --> 00:35:59,800
I don't think it probably.

795
00:36:00,000 --> 00:36:03,300
Is but you have to remember, we are on this machine.

796
00:36:03,300 --> 00:36:08,400
All of our timings are highly suspect, because we have this fine

797
00:36:08,400 --> 00:36:10,900
fellow the open broadcasting software.

798
00:36:10,900 --> 00:36:12,900
That is allowing me to talk to you on Twitch.

799
00:36:12,900 --> 00:36:14,500
You have to remember that.

800
00:36:14,500 --> 00:36:18,300
It is doing a bunch of work to capture and compress this framing

801
00:36:18,300 --> 00:36:18,800
everything.

802
00:36:19,100 --> 00:36:24,000
And even though this this machine has an ungodly number of processors.

803
00:36:24,200 --> 00:36:26,400
I think I showed this in the intro to see stream.

804
00:36:26,600 --> 00:36:29,800
It just has an ungodly number of of course.

805
00:36:30,000 --> 00:36:32,300
So it's two processor machine.

806
00:36:32,300 --> 00:36:34,100
Each one has six cores or something like this.

807
00:36:34,100 --> 00:36:37,000
I don't or four cores and to hypothetical.

808
00:36:37,200 --> 00:36:38,100
I don't even know.

809
00:36:38,200 --> 00:36:41,000
I think it's for a course to epithets fork or two processors.

810
00:36:41,000 --> 00:36:41,900
Something like this.

811
00:36:41,900 --> 00:36:42,800
I don't even know.

812
00:36:43,300 --> 00:36:45,600
We'll have to look it up at some point when we start talking about

813
00:36:45,600 --> 00:36:49,200
multi, you know, when we talked about optimization in terms of

814
00:36:49,200 --> 00:36:51,600
processors, will start getting into stuff like, what a hyper thread is

815
00:36:51,600 --> 00:36:52,400
and why you care.

816
00:36:52,800 --> 00:36:56,100
But for right now, just say it's tons of horsepower in this machine.

817
00:36:56,100 --> 00:36:57,200
It shouldn't be a problem.

818
00:36:57,200 --> 00:36:59,800
But the point is that

819
00:37:00,000 --> 00:37:05,300
That is not necessarily the case when multiple people are contending

820
00:37:05,400 --> 00:37:09,100
for the same resources, since we are bleeding to the screen.

821
00:37:09,200 --> 00:37:13,600
We are, we are copying our image up to the screen and our runtime

822
00:37:13,600 --> 00:37:17,700
includes that effort that ability to display things.

823
00:37:17,700 --> 00:37:22,800
On the screen, OBS is trying to capture the screen from Windows.

824
00:37:23,000 --> 00:37:26,600
We may run into circumstances for all I know, where there's like a

825
00:37:26,600 --> 00:37:29,800
lockup where we have to wait for it to do something and all.

826
00:37:30,100 --> 00:37:31,100
You know, I don't know.

827
00:37:31,100 --> 00:37:35,300
I've never done any profiling of code that runs on a machine where

828
00:37:35,300 --> 00:37:36,400
video capture is running.

829
00:37:36,400 --> 00:37:41,800
Concurrently, but suffice to say, as we're doing the stream, and doing

830
00:37:41,800 --> 00:37:44,600
timings before we start doing any serious performance work.

831
00:37:44,600 --> 00:37:49,000
I will probably try to do some kind of outboard capture to get that

832
00:37:49,000 --> 00:37:52,300
out of the equation because all of the timings that I take on this

833
00:37:52,300 --> 00:37:55,500
machine are going to be highly suspect until we get OBS out of there.

834
00:37:55,500 --> 00:37:57,700
So that we know we're doing direct throughing.

835
00:37:57,700 --> 00:37:59,800
Basically, but point being

836
00:38:00,100 --> 00:38:04,000
What's interesting about this and what I hope is pretty interesting to

837
00:38:04,000 --> 00:38:04,200
you.

838
00:38:04,200 --> 00:38:07,800
Just from looking at this, is this 6 milliseconds here?

839
00:38:08,900 --> 00:38:12,600
You remember, 16 milliseconds and I can print out this value as well.

840
00:38:12,600 --> 00:38:16,200
I don't particularly love frames per second as a value that's useful

841
00:38:16,600 --> 00:38:20,000
but it helps because people quote it in the news all the time and that

842
00:38:20,000 --> 00:38:20,700
sort of stuff.

843
00:38:21,000 --> 00:38:25,200
But we can certainly put out that number how many frames per second

844
00:38:25,200 --> 00:38:27,500
there are so frames per second, right?

845
00:38:28,200 --> 00:38:32,600
Is going to be the milliseconds per frame computation.

846
00:38:32,600 --> 00:38:35,700
Basically, it's going to be the same as that FPS here.

847
00:38:35,900 --> 00:38:36,400
All right.

848
00:38:37,000 --> 00:38:38,600
Well, you know what you

849
00:38:38,700 --> 00:38:39,500
Be able to do this.

850
00:38:39,500 --> 00:38:39,800
Now.

851
00:38:40,000 --> 00:38:42,200
You should not need me to do this because I told you how to do

852
00:38:42,200 --> 00:38:44,100
Dimension analysis, dimensional analysis.

853
00:38:44,300 --> 00:38:45,000
So let's see.

854
00:38:45,000 --> 00:38:47,300
I'm going to, I'm going to do this real slow.

855
00:38:47,900 --> 00:38:50,400
So that hopefully, those of you at home, who are going ahead.

856
00:38:50,600 --> 00:38:51,200
We'll get it.

857
00:38:51,300 --> 00:38:53,300
I want you to get it before I do.

858
00:38:53,300 --> 00:38:53,800
Okay.

859
00:38:54,500 --> 00:38:56,800
So what did I say about dimensional analysis?

860
00:38:57,100 --> 00:38:59,900
I said that we want to look at what's on top and

861
00:39:00,000 --> 00:39:01,000
Bottom of the ratios.

862
00:39:01,200 --> 00:39:06,100
So our Target right is frames per second.

863
00:39:06,600 --> 00:39:12,000
Okay, and what do we now have, right, what do we actually have?

864
00:39:12,200 --> 00:39:14,200
Well, we've got two values, we could work with.

865
00:39:14,600 --> 00:39:16,200
We have counts, right?

866
00:39:16,200 --> 00:39:17,300
We have X counts.

867
00:39:17,500 --> 00:39:20,100
We also knew how to translate that to S, right.

868
00:39:21,100 --> 00:39:24,500
So, how do we get from here to here?

869
00:39:25,100 --> 00:39:29,100
I want X counts in in frames per second, right?

870
00:39:32,000 --> 00:39:33,000
Now, there's a little bit.

871
00:39:34,100 --> 00:39:35,800
There's a little bit that I'm not saying yet.

872
00:39:36,900 --> 00:39:37,800
To see if you got it.

873
00:39:40,000 --> 00:39:40,200
Okay.

874
00:39:40,200 --> 00:39:41,100
Hit number one.

875
00:39:41,800 --> 00:39:43,600
Is that this isn't just X counts.

876
00:39:43,900 --> 00:39:46,500
This is X counts per frame.

877
00:39:47,600 --> 00:39:48,100
Right.

878
00:39:49,400 --> 00:39:50,400
Because that is what we did.

879
00:39:50,400 --> 00:39:51,500
We timed one frame.

880
00:39:51,500 --> 00:39:54,100
So we know that X counts go by per frame.

881
00:39:54,200 --> 00:39:57,700
So counts on the top frame, on the bottom, right?

882
00:39:59,200 --> 00:39:59,800
Make sense.

883
00:40:07,300 --> 00:40:08,500
Does everyone have it yet?

884
00:40:09,600 --> 00:40:10,800
I don't know if everyone has it.

885
00:40:17,500 --> 00:40:19,600
See, the thing is, you can see me through the webcam, but I can't see

886
00:40:19,600 --> 00:40:21,300
you through the webcam and that's really the problem.

887
00:40:21,400 --> 00:40:23,800
So I can't see if you've got it or not, but it's okay.

888
00:40:24,200 --> 00:40:26,400
So let's, let's go ahead and take a look at this here.

889
00:40:26,500 --> 00:40:31,300
So, the first thing that I would say right is I want to be able to

890
00:40:31,300 --> 00:40:32,500
invert this, right?

891
00:40:32,500 --> 00:40:37,200
I need frames to be on the top, right because frames is on the bottom

892
00:40:37,200 --> 00:40:38,900
at the moment and that's no good.

893
00:40:39,000 --> 00:40:39,600
Right?

894
00:40:40,200 --> 00:40:42,000
I also know that I want seconds.

895
00:40:42,400 --> 00:40:44,300
So really what I could do is I could say.

896
00:40:44,300 --> 00:40:47,100
Well first of all, we know counts per second that

897
00:40:47,300 --> 00:40:48,800
Our query performance frequency.

898
00:40:49,000 --> 00:40:51,200
So if I multiply this right.

899
00:40:51,700 --> 00:40:52,900
Oops, what's going on?

900
00:40:52,900 --> 00:40:54,800
Oh, I accidentally did I hit some button there?

901
00:40:54,800 --> 00:40:57,000
That was interesting and kind of It kind of froze me out.

902
00:40:57,100 --> 00:40:57,700
Right?

903
00:40:58,300 --> 00:41:01,400
So what I want to do is I want to multiply this by something that's

904
00:41:01,400 --> 00:41:05,800
got like counts on the bottom right and S on the top like this.

905
00:41:06,000 --> 00:41:07,800
How many seconds per count, right?

906
00:41:08,100 --> 00:41:11,400
And we know that that is basically the inverse of our of our

907
00:41:11,400 --> 00:41:16,300
performance thing that would give me because our performance frequency

908
00:41:16,300 --> 00:41:17,000
was counts.

909
00:41:17,300 --> 00:41:19,600
Right counts per second.

910
00:41:19,800 --> 00:41:22,100
So the inverse of that which is obviously.

911
00:41:22,200 --> 00:41:25,300
And I guess the one thing that I didn't say in that thing was, which

912
00:41:25,300 --> 00:41:26,200
is again mathy.

913
00:41:26,200 --> 00:41:30,500
So I suppose I should have said it is that if I have some ratio 1 over

914
00:41:30,500 --> 00:41:36,000
that ratio, like if I do one over counts per second, that gives me S 4

915
00:41:36,000 --> 00:41:37,300
count, right?

916
00:41:39,000 --> 00:41:41,300
So I can always invert a ratio.

917
00:41:41,300 --> 00:41:46,400
I can flip it around by doing one divided by the value gives me the

918
00:41:46,400 --> 00:41:49,100
inverse of that value flips the to, right.

919
00:41:50,900 --> 00:41:53,900
So basically the most straightforward way to do this, right?

920
00:41:54,500 --> 00:41:55,800
Is to say, all right.

921
00:41:55,900 --> 00:41:58,900
The first thing I want to do is I want to flip this around.

922
00:41:59,000 --> 00:41:59,800
Okay, so

923
00:42:00,000 --> 00:42:01,800
Going to do 1 over this value.

924
00:42:01,800 --> 00:42:05,300
I'm going to take 1 divided by our counts per frame.

925
00:42:05,500 --> 00:42:06,000
Right?

926
00:42:06,100 --> 00:42:08,400
And if I do that, then that will give me.

927
00:42:08,400 --> 00:42:09,900
I can't figure out how to actually erase this.

928
00:42:09,900 --> 00:42:12,700
I'm trying to, but I can't do it, right.

929
00:42:12,700 --> 00:42:13,500
Okay, there we go.

930
00:42:13,900 --> 00:42:17,100
So, if I take 1 over this value, that will flip it around and that

931
00:42:17,100 --> 00:42:20,900
will give me 1 frame per X counts.

932
00:42:21,900 --> 00:42:26,300
Right, then I multiply that by how many counts?

933
00:42:26,800 --> 00:42:28,300
Right per second.

934
00:42:28,300 --> 00:42:32,900
There are, which we know this is our frequency counts per second.

935
00:42:33,000 --> 00:42:35,300
This was the performance frequency, right?

936
00:42:35,600 --> 00:42:40,200
And so, I cross out my accounts and I'm just left with frames per

937
00:42:40,200 --> 00:42:42,000
second, which is what I wanted.

938
00:42:42,200 --> 00:42:46,200
So, we need to do one over our counter, right?

939
00:42:46,200 --> 00:42:47,500
We need to do one over our counter.

940
00:42:47,500 --> 00:42:48,500
That's this step.

941
00:42:48,700 --> 00:42:51,500
And then we need to multiply by the frequency.

942
00:42:52,500 --> 00:42:56,000
And that should give us our frames per second.

943
00:42:56,300 --> 00:42:57,100
Does that make sense?

944
00:42:57,200 --> 00:42:58,500
Hopefully, that makes some sense.

945
00:42:58,600 --> 00:43:01,600
I don't know if it does, but if it does, there you go.

946
00:43:02,200 --> 00:43:06,800
So if we have 1 over the counter times the frequency.

947
00:43:06,800 --> 00:43:08,500
Well, we can just multiply that out.

948
00:43:08,500 --> 00:43:14,200
That's just the frequency divided by the counter right now.

949
00:43:14,200 --> 00:43:16,300
If you think about that, that makes them pretty good sense.

950
00:43:16,400 --> 00:43:20,400
That's basically saying we have, you know, we have our frequency

951
00:43:20,400 --> 00:43:21,100
counts.

952
00:43:21,600 --> 00:43:27,300
/ s RF counts per second, right over our accounts, right?

953
00:43:27,300 --> 00:43:31,000
And that just drops out the count values, which is sort of what we

954
00:43:31,000 --> 00:43:33,600
wanted and S, of course, moves to the bottom, because it's on the

955
00:43:33,600 --> 00:43:34,100
bottom.

956
00:43:34,800 --> 00:43:35,500
All right?

957
00:43:35,900 --> 00:43:36,200
Okay.

958
00:43:36,200 --> 00:43:40,100
So basically, you know, dimensional analysis play around with it.

959
00:43:40,200 --> 00:43:41,100
I realize it's hard.

960
00:43:41,100 --> 00:43:43,500
If you've only seen it for the first time, that's probably not the

961
00:43:43,500 --> 00:43:45,400
best explanation anyone's ever given in the world.

962
00:43:45,400 --> 00:43:46,200
I can tell you that right now.

963
00:43:46,200 --> 00:43:51,500
Like I said, I'm not the math guy, so maybe take a look.

964
00:43:52,500 --> 00:43:55,400
Excuse me online for something like that, or maybe we can find some

965
00:43:55,400 --> 00:43:56,000
links to it.

966
00:43:56,300 --> 00:43:59,500
But basically that's that's all we're trying to do here.

967
00:43:59,800 --> 00:44:01,300
So four frames per second.

968
00:44:01,500 --> 00:44:04,300
We basically just need to do our seconds per frame.

969
00:44:04,800 --> 00:44:05,300
I'm sorry.

970
00:44:06,000 --> 00:44:06,600
What's our performance?

971
00:44:06,600 --> 00:44:07,000
We can see there.

972
00:44:07,000 --> 00:44:07,300
It is.

973
00:44:07,500 --> 00:44:10,200
Our counts per second.

974
00:44:10,200 --> 00:44:12,900
Basically, right /.

975
00:44:13,200 --> 00:44:16,200
How many counts we actually had?

976
00:44:18,000 --> 00:44:18,500
Oh, there we go.

977
00:44:18,500 --> 00:44:20,600
Counter elapsed, right like that.

978
00:44:21,100 --> 00:44:21,500
And that

979
00:44:21,600 --> 00:44:23,200
It should give it to us.

980
00:44:23,200 --> 00:44:26,200
I'm not sure again like talking on the stream kind of makes.

981
00:44:26,200 --> 00:44:26,800
There we go.

982
00:44:27,600 --> 00:44:31,600
Okay, and then we close it and then you can sorta see.

983
00:44:31,900 --> 00:44:34,300
Now this number translated into something.

984
00:44:34,300 --> 00:44:36,700
That's more like what you would see reported in the Press.

985
00:44:37,000 --> 00:44:40,900
So six milliseconds per frame is 143 frames per second.

986
00:44:40,900 --> 00:44:41,500
Right?

987
00:44:41,700 --> 00:44:44,500
And we can sort of double verify that because if we already computed

988
00:44:44,500 --> 00:44:48,000
the milliseconds that it took, we know there is 1000 milliseconds in

989
00:44:48,000 --> 00:44:48,900
one second.

990
00:44:49,100 --> 00:44:51,100
So dividing by 6.

991
00:44:51,100 --> 00:44:51,500
There's

992
00:44:51,600 --> 00:44:55,800
That 166 value, of course, this is going to be more accurate than that

993
00:44:55,800 --> 00:44:57,500
because it's actually a decimal here.

994
00:44:57,600 --> 00:44:59,400
16 points something, something something.

995
00:45:00,100 --> 00:45:03,800
And then there's the seven, which is a little bit lower value.

996
00:45:03,800 --> 00:45:06,900
So that is 1000 divided by 7.

997
00:45:07,200 --> 00:45:10,100
And that's up in the 142 which is which is right accurate.

998
00:45:10,100 --> 00:45:12,500
So that was probably almost exactly seven.

999
00:45:12,900 --> 00:45:16,100
So that's that's basically, you know, I mean, that's, that's really

1000
00:45:16,100 --> 00:45:17,000
all there is to it.

1001
00:45:17,400 --> 00:45:18,800
This is how you get a counter.

1002
00:45:18,800 --> 00:45:19,900
There's pretty much.

1003
00:45:19,900 --> 00:45:21,600
I mean, yeah, I think I've said just about everything.

1004
00:45:21,600 --> 00:45:24,500
There is dimensional analysis can come in to help you a little bit.

1005
00:45:24,500 --> 00:45:26,900
If you get start getting confused about how to compute a particular

1006
00:45:26,900 --> 00:45:27,200
thing.

1007
00:45:27,200 --> 00:45:29,100
You can look, you want to look at those units.

1008
00:45:29,100 --> 00:45:29,800
Try to let the

1009
00:45:30,000 --> 00:45:31,900
The unit's help you and that's the way that goes.

1010
00:45:31,900 --> 00:45:34,700
Now this this sort of thing.

1011
00:45:36,200 --> 00:45:38,700
Is is highly problematic?

1012
00:45:38,800 --> 00:45:41,200
There's a number of reasons why this sort of thing is highly

1013
00:45:41,200 --> 00:45:41,500
problematic.

1014
00:45:41,500 --> 00:45:43,100
The printout I'm talking about here.

1015
00:45:44,300 --> 00:45:47,500
There are so many ways that this sort of style of printout can go

1016
00:45:47,500 --> 00:45:48,100
wrong.

1017
00:45:48,500 --> 00:45:51,100
The first one is you can pass a buffer that's too small.

1018
00:45:51,900 --> 00:45:53,900
There's ways of getting around that.

1019
00:45:54,000 --> 00:45:59,000
Basically, this this, if you go look up in msdn here, obviously WS

1020
00:45:59,000 --> 00:46:02,900
printf is documented here.

1021
00:46:04,400 --> 00:46:04,900
There it is.

1022
00:46:06,000 --> 00:46:09,100
Basically, there's versions of these sorts of things where you can

1023
00:46:09,100 --> 00:46:12,500
pass in the size of the buffer, to prevent it from possibly going

1024
00:46:12,500 --> 00:46:12,900
over.

1025
00:46:13,300 --> 00:46:16,700
Basically, I don't know, I guess they'd have these strings.

1026
00:46:16,700 --> 00:46:18,500
CB printf here.

1027
00:46:18,500 --> 00:46:18,900
Yeah.

1028
00:46:19,100 --> 00:46:22,000
So basically, they have newer versions, which do that, which, which do

1029
00:46:22,000 --> 00:46:22,200
it.

1030
00:46:22,300 --> 00:46:24,000
Here's a, here's an easier one, understand.

1031
00:46:24,200 --> 00:46:28,700
So here's wns printf, wns printf is the same as W is printf.

1032
00:46:28,700 --> 00:46:31,500
But instead of just taking a pointer to a buffer, it takes how long

1033
00:46:31,500 --> 00:46:33,200
the buffer is as well, right?

1034
00:46:33,200 --> 00:46:34,100
So instead you could

1035
00:46:34,200 --> 00:46:37,700
So Point here, you could say size of buffer like that.

1036
00:46:37,700 --> 00:46:41,300
And now you know that if you pass it above this too small, you won't

1037
00:46:41,300 --> 00:46:44,100
overwrite memory basically because you have to remember, basically it

1038
00:46:44,100 --> 00:46:48,200
all it sees all the original one sees, let's go ahead and

1039
00:46:49,800 --> 00:46:53,700
What wns print death there, right?

1040
00:46:55,400 --> 00:46:56,100
Not found?

1041
00:46:56,300 --> 00:46:57,100
Why are you not found?

1042
00:46:57,100 --> 00:46:58,000
It's right there.

1043
00:46:58,400 --> 00:46:59,400
What's the problem?

1044
00:46:59,900 --> 00:47:00,800
What is the problem though?

1045
00:47:00,800 --> 00:47:03,000
It's in some special H file.

1046
00:47:03,300 --> 00:47:04,000
All right?

1047
00:47:04,400 --> 00:47:06,500
And wonder if this will call this may happen cause it's linked with

1048
00:47:06,500 --> 00:47:09,100
something special as well which case I'm not going to use it.

1049
00:47:09,600 --> 00:47:10,300
Let's take a look.

1050
00:47:11,300 --> 00:47:14,500
Yeah, so I'm not actually I'm not actually going to use that.

1051
00:47:14,800 --> 00:47:17,600
I'm just going to show this old one and say the fact there is one that

1052
00:47:17,600 --> 00:47:18,600
takes the size of the buffer.

1053
00:47:18,800 --> 00:47:21,300
So basically one of the problems with this thing is you pass it a

1054
00:47:21,300 --> 00:47:23,900
buffer but it has no idea how big that buffer is.

1055
00:47:24,000 --> 00:47:26,500
So if you were to pass it, a string that doesn't fit in the buffer.

1056
00:47:26,500 --> 00:47:29,600
Now, we know this will always fit in the buffer because the number of

1057
00:47:29,800 --> 00:47:32,700
the size of these two things can never actually be enough characters

1058
00:47:32,700 --> 00:47:34,400
to make this get out to 256.

1059
00:47:34,500 --> 00:47:38,800
So this is perfectly safe, but you could imagine if you made a mistake

1060
00:47:39,000 --> 00:47:40,400
and you pass a buffer here.

1061
00:47:40,400 --> 00:47:41,000
That isn't big.

1062
00:47:41,100 --> 00:47:42,600
Enough to hold the fingerprinting.

1063
00:47:42,700 --> 00:47:45,500
You just overwrite the end of memory because it has no idea how big

1064
00:47:45,500 --> 00:47:46,100
the buffer is.

1065
00:47:46,200 --> 00:47:47,100
It assumes?

1066
00:47:47,100 --> 00:47:49,800
You gave it a buffer that was big enough, and if you didn't off, you

1067
00:47:49,800 --> 00:47:52,600
go, that's definitely a source of bugs, right there.

1068
00:47:52,700 --> 00:47:55,800
S sorts of bugs and sometimes can some compilers, like llvm will try

1069
00:47:55,800 --> 00:47:59,800
to catch these by parsing, the string print out time, basically.

1070
00:48:00,000 --> 00:48:05,100
These percentage things are sort of just like assumed to line up with

1071
00:48:05,100 --> 00:48:06,100
whatever you pass it.

1072
00:48:06,100 --> 00:48:09,300
And this is basically a thing that does what's called Vera args, which

1073
00:48:09,300 --> 00:48:13,100
says it just the compiler, just sticks, whatever you put after the

1074
00:48:13,100 --> 00:48:16,400
after the thing after the format string here.

1075
00:48:16,400 --> 00:48:19,400
It just starts sticking these things on the stack and then this

1076
00:48:19,400 --> 00:48:23,200
function will just pull things off the stack, based on what it sees

1077
00:48:23,200 --> 00:48:26,900
here, but you could just, you could say that there was a ton of stuff

1078
00:48:26,900 --> 00:48:27,600
that was never.

1079
00:48:27,600 --> 00:48:29,700
Actually, they're right and the

1080
00:48:30,100 --> 00:48:31,800
Has no idea that that happened.

1081
00:48:31,900 --> 00:48:34,300
So it starts reading shit off.

1082
00:48:34,300 --> 00:48:35,200
The sorry.

1083
00:48:35,200 --> 00:48:35,900
I stopped to use.

1084
00:48:35,900 --> 00:48:36,500
Colorful language.

1085
00:48:36,500 --> 00:48:40,700
It starts reading stuff in off the stack that it was never supposed to

1086
00:48:40,700 --> 00:48:41,100
look at.

1087
00:48:41,100 --> 00:48:42,800
That isn't even a variable potentially.

1088
00:48:42,800 --> 00:48:43,900
The who knows what it is.

1089
00:48:44,500 --> 00:48:46,300
It can do all sorts of things like that.

1090
00:48:46,300 --> 00:48:48,800
If I told it that a pointer was coming %.

1091
00:48:48,800 --> 00:48:51,400
S says that there's going to be a pointer to a string but I didn't

1092
00:48:51,400 --> 00:48:54,600
ever pass a part of string then you get into a sex thing.

1093
00:48:54,600 --> 00:48:57,200
Well, you'll do an access violation, when it goes to try and read

1094
00:48:57,200 --> 00:48:57,700
that.

1095
00:48:57,700 --> 00:48:59,300
So it's fraught with Peril.

1096
00:48:59,300 --> 00:48:59,900
It's

1097
00:49:00,000 --> 00:49:00,800
be fraught with Peril.

1098
00:49:01,300 --> 00:49:05,300
So typically I don't use this sort of code in anything.

1099
00:49:05,300 --> 00:49:09,900
I'm going to ship like this is not code that I like to see hanging

1100
00:49:09,900 --> 00:49:11,400
around in like something.

1101
00:49:11,400 --> 00:49:13,200
I'm sending you an end-user.

1102
00:49:13,500 --> 00:49:16,300
I like to write my own versions of these things and know that there's

1103
00:49:16,300 --> 00:49:19,700
some degree of accuracy to them if possible and so on.

1104
00:49:20,300 --> 00:49:28,500
But basically, if there is a, if there is debug code or profiling code

1105
00:49:28,500 --> 00:49:29,900
like this, that we know is only going to

1106
00:49:30,000 --> 00:49:33,100
Ever really be run on our machines, when we're developing it.

1107
00:49:33,100 --> 00:49:35,900
Then you can go to town because a bug in there doesn't cost you

1108
00:49:35,900 --> 00:49:36,200
anything.

1109
00:49:36,200 --> 00:49:39,300
It's like, yeah, you crashed on your machine or yeah, you had some

1110
00:49:39,300 --> 00:49:42,200
security exploit on your profiled version.

1111
00:49:42,300 --> 00:49:43,700
That's not that big of a deal.

1112
00:49:44,100 --> 00:49:47,400
But if you're going to ship this, to an end user, this sort of stuff

1113
00:49:47,400 --> 00:49:50,300
becomes becomes dicey, doesn't mean you can't do it.

1114
00:49:50,300 --> 00:49:53,200
It just means that when you do it, you gotta know.

1115
00:49:53,300 --> 00:49:54,700
You really got understand what you're doing.

1116
00:49:54,700 --> 00:49:57,300
You can't just throw it in there and be like, I saw it on handmade

1117
00:49:57,300 --> 00:49:58,400
hero and I just typed it.

1118
00:49:58,400 --> 00:49:59,900
It's like, no, that's

1119
00:50:00,000 --> 00:50:02,200
At this, this can go wrong real quick.

1120
00:50:02,200 --> 00:50:05,800
So you want to leave this kind of thing, basically, as debug code for

1121
00:50:05,800 --> 00:50:08,700
the most part until you let you really know what's going on.

1122
00:50:09,400 --> 00:50:09,800
All right.

1123
00:50:09,800 --> 00:50:13,200
So the next thing we're going to do is basically all we're doing to do

1124
00:50:13,200 --> 00:50:17,500
is augment that with that are dtsc thing that I talked about.

1125
00:50:17,500 --> 00:50:18,000
Right?

1126
00:50:18,200 --> 00:50:20,600
So we're basically going to say, alright, when we do this query

1127
00:50:20,600 --> 00:50:21,600
performance counter.

1128
00:50:23,300 --> 00:50:26,500
I'm also going to go ahead and snap the our dtsc value.

1129
00:50:26,500 --> 00:50:26,700
Now.

1130
00:50:26,700 --> 00:50:30,600
Thankfully, we can actually do that right from the compiler.

1131
00:50:30,700 --> 00:50:35,200
There's usually a intrinsic for it, which I wanted to show you the

1132
00:50:35,200 --> 00:50:38,800
documentation for by.

1133
00:50:38,800 --> 00:50:43,000
Don't see it's usually like underscore our dtsc or something like this

1134
00:50:44,100 --> 00:50:48,200
that I don't see right now.

1135
00:50:48,600 --> 00:50:51,900
Why am I not seeing it underscore our

1136
00:50:52,100 --> 00:50:52,600
ETS.

1137
00:50:52,600 --> 00:50:54,800
See what's going on here?

1138
00:50:54,800 --> 00:50:55,400
People.

1139
00:50:55,700 --> 00:50:58,900
There should be in our dtsc on llvm.

1140
00:50:58,900 --> 00:50:59,800
It's that that's why I use.

1141
00:51:00,000 --> 00:51:02,800
Recently, but see so there it is.

1142
00:51:02,800 --> 00:51:06,400
Yeah, why didn't find that underscore underscore our dtsc.

1143
00:51:06,400 --> 00:51:07,800
Oh, I'm so sorry.

1144
00:51:07,900 --> 00:51:10,900
I forgot that s underscore makes all the difference there.

1145
00:51:11,600 --> 00:51:14,400
Okay, so it looks like that's all there is to it.

1146
00:51:14,900 --> 00:51:16,300
You just get ya.

1147
00:51:16,400 --> 00:51:19,000
All right, so generates the are dtsc instruction, which returns a

1148
00:51:19,000 --> 00:51:20,100
processor time stamp.

1149
00:51:20,200 --> 00:51:21,600
That's exactly what we wanted.

1150
00:51:21,700 --> 00:51:24,700
We just want to call that function of the processor and get that value

1151
00:51:24,700 --> 00:51:25,100
back.

1152
00:51:25,900 --> 00:51:28,300
So basically, we're going to insert another thing here.

1153
00:51:28,800 --> 00:51:29,400
We're going to say that.

1154
00:51:29,400 --> 00:51:29,900
There's an

1155
00:51:30,000 --> 00:51:34,900
64, which is the last time stamp counter from the processor, right?

1156
00:51:34,900 --> 00:51:39,600
Or we can also say, last cycle count, right?

1157
00:51:39,900 --> 00:51:43,300
And basically, that would just be equal to whatever our dtsc was, and

1158
00:51:43,300 --> 00:51:44,800
that just full-on should output.

1159
00:51:44,800 --> 00:51:46,000
That instruction later.

1160
00:51:46,000 --> 00:51:49,000
When we get down here, we're going to do exactly the same thing as we

1161
00:51:49,000 --> 00:51:50,000
did before.

1162
00:51:50,100 --> 00:51:55,800
So, now we go to end cycle count and we get it again, then when we do

1163
00:51:55,800 --> 00:51:57,800
our thing and you know, what, I'm going to do that, since this is

1164
00:51:57,800 --> 00:51:59,900
cheaper, are dtsc is cheaper than query performance.

1165
00:52:00,000 --> 00:52:03,800
Armand, do that one first because that's going to be the more accurate

1166
00:52:04,000 --> 00:52:04,500
time there.

1167
00:52:04,500 --> 00:52:04,800
I guess.

1168
00:52:04,800 --> 00:52:07,200
Well, it doesn't actually matter because we're doing round-trips time.

1169
00:52:07,200 --> 00:52:07,900
So it doesn't matter.

1170
00:52:07,900 --> 00:52:09,800
You can put them in either order because we're going to it's going to

1171
00:52:09,800 --> 00:52:11,700
have to then go through this, to do the rest of it as well.

1172
00:52:11,700 --> 00:52:12,700
But point being.

1173
00:52:13,500 --> 00:52:15,600
So then we're going to actually do here as well.

1174
00:52:15,700 --> 00:52:18,000
We're going to do Cycles elapsed, right?

1175
00:52:18,000 --> 00:52:20,700
And we do exactly the same thing we did before we do the End Cycle

1176
00:52:20,700 --> 00:52:23,200
count - the last cycle.

1177
00:52:23,200 --> 00:52:24,900
Count, that gives us that.

1178
00:52:24,900 --> 00:52:29,800
And we do last cycle count - I'm sorry, right equals N Cycle cap, too.

1179
00:52:29,900 --> 00:52:30,400
Set it.

1180
00:52:30,400 --> 00:52:33,500
So that next time through the loop will be using the most recent clock

1181
00:52:33,500 --> 00:52:34,000
value.

1182
00:52:34,800 --> 00:52:36,400
And then we know how many cycles of left.

1183
00:52:36,400 --> 00:52:36,900
It was.

1184
00:52:37,300 --> 00:52:41,300
So we know that milliseconds per frame and we also now know and we can

1185
00:52:41,300 --> 00:52:44,200
we can actually get rid of this because we actually said milliseconds

1186
00:52:44,200 --> 00:52:47,100
per frame and frames per second, right?

1187
00:52:47,100 --> 00:52:52,300
We're actually pointing out those values not doing a very good job

1188
00:52:52,300 --> 00:52:56,400
separating these this do comma comma and then we want something here

1189
00:52:56,500 --> 00:52:59,800
that we're going to print out which is basically our

1190
00:53:00,000 --> 00:53:03,300
Our cycles per frame right from the processor.

1191
00:53:03,500 --> 00:53:07,100
And so the cycle is elapsed is going to be a lot, right?

1192
00:53:07,100 --> 00:53:10,900
So, maybe what we'd rather do is say like megacycles, right?

1193
00:53:11,000 --> 00:53:15,000
So maybe we'd rather do something like MHz, right, like this.

1194
00:53:15,500 --> 00:53:19,300
So we're going to say basically, this is how many megacycles per

1195
00:53:19,300 --> 00:53:22,800
frame, we're actually taking because otherwise, oops, sorry that's

1196
00:53:22,800 --> 00:53:24,300
divided there.

1197
00:53:24,600 --> 00:53:27,200
So we're actually going to divide that out so that we're not actually

1198
00:53:27,200 --> 00:53:29,800
looking at such a huge, such a huge.

1199
00:53:29,900 --> 00:53:30,300
Value.

1200
00:53:30,300 --> 00:53:33,900
So we're going to say this is megacycles per frame.

1201
00:53:34,300 --> 00:53:38,400
And we're going to grab this value out here like that.

1202
00:53:39,200 --> 00:53:44,000
And then we are going to say that this is also passed it down to 32.

1203
00:53:44,000 --> 00:53:48,000
And the reason I'm casting these down to in 32s is because percent D

1204
00:53:48,000 --> 00:53:50,200
is kind of a uniform way to print things out.

1205
00:53:50,200 --> 00:53:55,700
Whereas printing out a 64-bit integer, using a printf style thing is

1206
00:53:55,700 --> 00:53:59,800
only very recent so % D actually always works.

1207
00:54:00,000 --> 00:54:03,100
Every see that you'll ever have, whereas printing out 64-bit can be a

1208
00:54:03,100 --> 00:54:05,200
little bit dicey depending on the circumstances.

1209
00:54:05,200 --> 00:54:07,800
So I'm trying to convert these two 32-bit values before I print them

1210
00:54:07,800 --> 00:54:08,200
out.

1211
00:54:08,600 --> 00:54:11,000
So hopefully that'll give us what we wanted.

1212
00:54:11,000 --> 00:54:14,200
We can then go ahead and run this and see if that makes any sense.

1213
00:54:14,700 --> 00:54:18,800
We'll stop it and we can basically see here that you know in a given

1214
00:54:18,800 --> 00:54:24,200
frame we took 6 milliseconds and we executed somewhere around 20

1215
00:54:24,300 --> 00:54:29,200
million instructions to do that frame in the six milliseconds.

1216
00:54:29,300 --> 00:54:29,900
So, let's see if

1217
00:54:30,000 --> 00:54:30,900
That holds water.

1218
00:54:31,100 --> 00:54:32,600
Basically what we're saying there?

1219
00:54:33,100 --> 00:54:37,000
Again, if we take a look at the divider divisor, we're basically

1220
00:54:37,000 --> 00:54:40,500
saying, okay, if we had a hundred and fifty two frames per second,

1221
00:54:40,700 --> 00:54:41,200
right?

1222
00:54:41,300 --> 00:54:43,000
So that's how many frames per second we have.

1223
00:54:43,000 --> 00:54:46,500
So, 152 frames a second times, the number of instruction megahertz,

1224
00:54:46,500 --> 00:54:49,400
which is, which megacycles, which was twenty there.

1225
00:54:49,600 --> 00:54:52,000
That should come out to roughly the processor speed.

1226
00:54:52,000 --> 00:54:52,600
Right?

1227
00:54:52,600 --> 00:54:55,700
And it sort of does basically, and we don't know what this values

1228
00:54:55,700 --> 00:54:57,600
fractional is because we're not printing it out, right?

1229
00:54:57,900 --> 00:54:58,800
So there we go.

1230
00:54:58,900 --> 00:54:59,800
We've got that.

1231
00:55:00,200 --> 00:55:03,400
And if I look at the actual, I don't actually know how to get to this

1232
00:55:03,400 --> 00:55:03,700
anymore.

1233
00:55:03,700 --> 00:55:04,700
I always forget.

1234
00:55:05,200 --> 00:55:05,900
Where is it?

1235
00:55:06,000 --> 00:55:08,200
If you look at the clock, so we should see, it's like, yeah, okay, so

1236
00:55:08,200 --> 00:55:09,400
it's roughly around there, right?

1237
00:55:09,400 --> 00:55:11,100
3.19 gigahertz.

1238
00:55:11,700 --> 00:55:16,600
And so that's, that's roughly in the ballpark of where it should be.

1239
00:55:16,800 --> 00:55:19,200
And I think if we, if we have, if we did a little more Precision

1240
00:55:19,200 --> 00:55:20,600
there, it should come out.

1241
00:55:20,700 --> 00:55:24,200
In fact, we could actually do the math with the actual original values

1242
00:55:24,500 --> 00:55:26,800
and see what it actually was.

1243
00:55:26,800 --> 00:55:28,200
We could say, for example,

1244
00:55:29,400 --> 00:55:31,900
We could do the milliseconds per frame times the the cycle, so

1245
00:55:31,900 --> 00:55:32,800
laughter something like that.

1246
00:55:33,200 --> 00:55:37,200
So basically, that there tells us all the clocking information that we

1247
00:55:37,200 --> 00:55:39,700
want to know, just not to very high Precision.

1248
00:55:40,100 --> 00:55:42,500
So the next question is, could we do fractional?

1249
00:55:42,900 --> 00:55:44,500
And the answer is, yes, we can do fractional.

1250
00:55:44,500 --> 00:55:48,900
We just have to learn a little more about how you do printf.

1251
00:55:48,900 --> 00:55:53,500
Now, if you want to do fractional, you have to use the C runtime

1252
00:55:53,500 --> 00:55:56,800
library because if I remember correctly, WS, printf, the thing that's

1253
00:55:56,800 --> 00:55:58,500
built into into Windows.

1254
00:55:58,600 --> 00:55:59,000
Cannot

1255
00:55:59,100 --> 00:56:02,000
Print out floating Point values.

1256
00:56:02,100 --> 00:56:05,400
It just doesn't have the ability to do so, that's my understanding.

1257
00:56:06,800 --> 00:56:11,800
Yes, it does not because this is basically a listing in here of all

1258
00:56:11,800 --> 00:56:14,900
the things that ws printf can take with that percent thing.

1259
00:56:14,900 --> 00:56:17,800
This percent thing here and you can see all the stuff that you can

1260
00:56:17,800 --> 00:56:18,800
say, right?

1261
00:56:18,800 --> 00:56:22,900
There's like sign character is sign, decimal, integer sign shorts

1262
00:56:22,900 --> 00:56:26,100
unsigned, short blah, blah, blah blah, but floating point.

1263
00:56:26,100 --> 00:56:28,900
Value like we learned about yesterday.

1264
00:56:29,100 --> 00:56:30,300
Nowhere to be found.

1265
00:56:30,300 --> 00:56:33,200
So if you want to print out a floating point value, you're kind of out

1266
00:56:33,200 --> 00:56:33,900
of luck.

1267
00:56:34,100 --> 00:56:36,700
And if so, if we want some kind of fractional value that says that the

1268
00:56:36,700 --> 00:56:39,400
fractional milliseconds we can't actually do that.

1269
00:56:39,500 --> 00:56:43,200
Now, obviously one thing you could do is just not use the numbers that

1270
00:56:43,200 --> 00:56:45,900
you have C 4 axis for but if we want to see a nice fraction, like a

1271
00:56:45,900 --> 00:56:50,400
fractional milliseconds, so, you know, 6.23 milliseconds per frame.

1272
00:56:50,900 --> 00:56:54,700
We actually need to use the C runtime libraries version of the same

1273
00:56:54,700 --> 00:56:57,500
function which is which is just sprintf.

1274
00:56:57,900 --> 00:56:58,900
So you can see here.

1275
00:56:59,100 --> 00:56:59,700
There's w.

1276
00:57:00,000 --> 00:57:01,500
Is Windows version of the sprintf?

1277
00:57:01,700 --> 00:57:04,900
If you want to, you can use a see runtime libraries version, which is

1278
00:57:04,900 --> 00:57:05,600
sprintf.

1279
00:57:05,800 --> 00:57:06,200
Again.

1280
00:57:06,200 --> 00:57:08,700
I don't really want to start relying on libraries too much.

1281
00:57:08,700 --> 00:57:10,100
So for debug code, this is fine.

1282
00:57:10,100 --> 00:57:12,100
I'm just telling you that it's there, if you want to use it.

1283
00:57:12,300 --> 00:57:16,900
So you can if you want to do want to do that, you can use sprintf

1284
00:57:17,000 --> 00:57:22,200
instead of print, F WS printf, but you have to go add up here.

1285
00:57:22,300 --> 00:57:26,700
A reference to standard IO dot h, that's the C runtime.

1286
00:57:26,700 --> 00:57:27,400
Libraries function.

1287
00:57:27,500 --> 00:57:29,300
We're already linking with the c runtime Library.

1288
00:57:29,300 --> 00:57:29,900
So all those

1289
00:57:30,000 --> 00:57:33,000
Functions are technically in there and you can all call them.

1290
00:57:33,300 --> 00:57:35,000
That will do exactly the same thing.

1291
00:57:35,000 --> 00:57:37,300
So if you run it, now, there's no difference.

1292
00:57:37,500 --> 00:57:38,100
Right?

1293
00:57:38,200 --> 00:57:41,700
Basically, we take a look, and there is the, there is the same as I

1294
00:57:41,700 --> 00:57:45,200
printed that we saw before, but we can go in here and actually use

1295
00:57:45,200 --> 00:57:48,200
percent F, which means print out a floating point value if we want to,

1296
00:57:48,400 --> 00:57:51,600
and we can also use some things called format specifiers.

1297
00:57:51,600 --> 00:57:56,100
So if I just do % F and and change these all 2% apps, then what I can

1298
00:57:56,100 --> 00:57:59,800
do here is do all of this in basically in float.

1299
00:58:00,100 --> 00:58:04,700
I can do all of these values in floating point and I can just instead

1300
00:58:04,700 --> 00:58:09,300
of, instead of a doing them, an integer arithmetic.

1301
00:58:09,300 --> 00:58:12,700
I can do it in floating Point arithmetic and get all of that stuff

1302
00:58:12,700 --> 00:58:13,500
that we wanted here.

1303
00:58:13,500 --> 00:58:16,500
I can just go ahead and say that all of these things are floating

1304
00:58:16,500 --> 00:58:21,600
Point values and then, we will essentially have everything computed in

1305
00:58:21,600 --> 00:58:23,100
floating Point like that.

1306
00:58:23,300 --> 00:58:24,000
So there you go.

1307
00:58:25,100 --> 00:58:28,400
If you can see that, basically, if we do it this way, there's a little

1308
00:58:28,400 --> 00:58:29,300
bit of a caveat here.

1309
00:58:29,300 --> 00:58:29,800
That is that

1310
00:58:29,900 --> 00:58:32,500
I'll tell you about in one second, but when we actually print these

1311
00:58:32,500 --> 00:58:37,700
out so many things to talk about here when we actually print these out

1312
00:58:37,700 --> 00:58:40,700
now, we will actually be able to print out floating Point values.

1313
00:58:41,000 --> 00:58:44,100
So now when we see it, you will basically get something that looks

1314
00:58:44,100 --> 00:58:45,900
like that same exact print out.

1315
00:58:45,900 --> 00:58:49,600
But now you notice we've got a lot of fractional Precision there and

1316
00:58:49,700 --> 00:58:51,300
presumably like I sang before.

1317
00:58:51,500 --> 00:58:54,400
Now if we actually look at the math, it'll come out a little bit

1318
00:58:54,400 --> 00:58:59,400
better if we do 147 frames per second, right.

1319
00:58:59,400 --> 00:58:59,800
And

1320
00:59:00,000 --> 00:59:06,700
Do that times the number of cycles megacycles per frame X?

1321
00:59:07,400 --> 00:59:11,200
You see, we get almost exactly that CPU number, right?

1322
00:59:11,300 --> 00:59:15,100
Which is what we were expecting to see, 3.19, which is exactly what we

1323
00:59:15,100 --> 00:59:15,800
wanted.

1324
00:59:16,200 --> 00:59:16,500
All right.

1325
00:59:16,500 --> 00:59:21,300
So anyway, hopefully you can sort of see how that works out.

1326
00:59:21,700 --> 00:59:24,100
I don't want to belabor this too much, because like I said, these are

1327
00:59:24,100 --> 00:59:26,700
just some of these are just some standard Library functions that exist

1328
00:59:26,700 --> 00:59:29,800
and we're not really going to be using libraries much.

1329
00:59:29,900 --> 00:59:33,000
At all in this in this stream as we build the game, since we're trying

1330
00:59:33,000 --> 00:59:34,000
to build everything from scratch.

1331
00:59:34,000 --> 00:59:37,100
So I don't really want you to get hung up on how to use the C runtime

1332
00:59:37,100 --> 00:59:37,700
library.

1333
00:59:38,000 --> 00:59:41,500
But again, it is all in there for getting your debugging code running.

1334
00:59:42,400 --> 00:59:45,600
I mean, when I go to write a platform layer, even when I am writing

1335
00:59:45,600 --> 00:59:49,200
everything from scratch, I will often use something in the standard

1336
00:59:49,200 --> 00:59:53,400
library of that platform or the or the operating system to get my

1337
00:59:53,400 --> 00:59:54,200
stuff going.

1338
00:59:54,400 --> 00:59:58,500
So I basically know, you know, that that it it's some reliable code

1339
00:59:58,500 --> 00:59:59,800
that I didn't just write myself from

1340
01:00:00,000 --> 01:00:00,400
Ouch.

1341
01:00:01,400 --> 01:00:04,200
Now, the other thing you can do in here too is you can add format

1342
01:00:04,200 --> 01:00:05,000
specifiers?

1343
01:00:05,100 --> 01:00:05,600
Again.

1344
01:00:05,900 --> 01:00:09,300
If you want to in here, if you look up the definition of sprintf and

1345
01:00:09,300 --> 01:00:09,800
stuff.

1346
01:00:09,800 --> 01:00:10,600
There's a thing.

1347
01:00:10,600 --> 01:00:12,500
Usually somewhere, that okay, here it is.

1348
01:00:12,700 --> 01:00:16,100
There's a link to say format specifications and you click on that.

1349
01:00:16,100 --> 01:00:19,600
And they'll be a whole big document that says, here is the thing that

1350
01:00:19,600 --> 01:00:21,300
you use for those percent things.

1351
01:00:21,400 --> 01:00:23,500
Here's all the stuff that you can put in there.

1352
01:00:23,600 --> 01:00:26,400
You can, you can look at all these things like flag to refuse, and so

1353
01:00:26,400 --> 01:00:29,800
on, and basically what they all are, as their ways of encoding in.

1354
01:00:30,000 --> 01:00:33,100
That percent notation how you want the value printed.

1355
01:00:33,100 --> 01:00:38,300
So, for example, if I say .02, right, I can control the degree of

1356
01:00:38,300 --> 01:00:41,300
precision and how the floating-point number is printed out.

1357
01:00:41,300 --> 01:00:44,800
Remember, it was printing it out at this Precision before six decimal

1358
01:00:44,800 --> 01:00:48,300
places and that's maybe a little too verbose for me.

1359
01:00:48,300 --> 01:00:53,300
So, if I specify .02, it says, I want you to go ahead and actually

1360
01:00:53,300 --> 01:00:57,300
print out the the number to two decimal places, right?

1361
01:00:57,300 --> 01:00:58,000
You can see there.

1362
01:00:58,600 --> 01:00:59,400
You can see that.

1363
01:01:00,100 --> 01:01:04,300
So, you know, if you want to learn how to do this, it's not a waste of

1364
01:01:04,300 --> 01:01:04,800
time.

1365
01:01:05,200 --> 01:01:07,500
You can call these when you're on a platform trying to get things

1366
01:01:07,500 --> 01:01:08,000
working.

1367
01:01:08,000 --> 01:01:11,000
They exist everywhere anywhere that you have a c compiler.

1368
01:01:11,100 --> 01:01:14,400
You have this function to call with the c runtime Library.

1369
01:01:14,500 --> 01:01:17,900
Kind of like we were able to call sign, that'll work everywhere

1370
01:01:18,000 --> 01:01:20,200
because the C runtime libraries built in.

1371
01:01:20,400 --> 01:01:23,200
You know, that a compiler has to ship with it in order to be like a

1372
01:01:23,200 --> 01:01:24,700
standard compliant compiler.

1373
01:01:24,900 --> 01:01:26,600
So, you know that you have access to these when you're getting your

1374
01:01:26,600 --> 01:01:29,700
debug code working, even if you're doing everything from scratch.

1375
01:01:29,900 --> 01:01:33,300
We will be, you always have those to fall back on if you're trying to

1376
01:01:33,300 --> 01:01:35,700
test our you have bugs and you're like, what's wrong with my code.

1377
01:01:35,700 --> 01:01:39,300
You can call their sine function and find out why your sign function

1378
01:01:39,300 --> 01:01:42,000
doesn't agree with it stuff like that is very useful.

1379
01:01:42,000 --> 01:01:45,500
So again, I don't want to try to tell people never touch a library and

1380
01:01:45,500 --> 01:01:46,900
you're like a bad program or something.

1381
01:01:46,900 --> 01:01:49,400
If you use libraries, libraries are totally fine.

1382
01:01:50,000 --> 01:01:53,500
We're just, we just want to go through and show you how to build

1383
01:01:53,500 --> 01:01:53,900
everything.

1384
01:01:53,900 --> 01:01:56,400
So later we're going to actually look at how to do our own, kind of

1385
01:01:56,400 --> 01:01:59,200
print us and stuff, which are actually kind of complicated.

1386
01:01:59,300 --> 01:01:59,700
We're going to look,

1387
01:01:59,800 --> 01:02:02,400
Look at some things like that as well, just because I want to show you

1388
01:02:02,400 --> 01:02:03,000
how that does.

1389
01:02:03,000 --> 01:02:05,200
So it's not a mystery to you, how it's doing stuff like this.

1390
01:02:05,700 --> 01:02:09,400
So that's basically everything about timing and what you can do now.

1391
01:02:09,700 --> 01:02:12,000
And this is something that will do a bit later when we get to

1392
01:02:12,000 --> 01:02:16,100
profiling is in the in the platform independent layer of the code.

1393
01:02:16,100 --> 01:02:19,700
We can also build a little bit of a superstructure that calls into the

1394
01:02:19,700 --> 01:02:22,800
platform layer, the puffer independent layer, to get timing

1395
01:02:22,800 --> 01:02:24,900
information at various points in our code.

1396
01:02:24,900 --> 01:02:27,500
So we'll be able to see who is taking that time.

1397
01:02:27,800 --> 01:02:29,700
So we basically, we time

1398
01:02:29,900 --> 01:02:31,500
The whole thing, right?

1399
01:02:31,500 --> 01:02:35,000
But you could imagine us doing something a little bit different.

1400
01:02:35,100 --> 01:02:38,400
Where, for example, we could put query the performance counter right

1401
01:02:38,400 --> 01:02:39,500
here as well.

1402
01:02:39,700 --> 01:02:40,100
Right?

1403
01:02:40,100 --> 01:02:44,200
We could say, let's take another performance sample right here, called

1404
01:02:44,200 --> 01:02:45,800
mid counter, right?

1405
01:02:45,800 --> 01:02:46,500
Like this.

1406
01:02:47,100 --> 01:02:52,200
And we could take a look at how long it took us to do everything, but

1407
01:02:52,200 --> 01:02:54,400
that stretch divots, right?

1408
01:02:54,400 --> 01:02:55,700
This is where the stretch stretch.

1409
01:02:55,700 --> 01:02:56,600
TI B happens.

1410
01:02:56,900 --> 01:02:59,700
How long does it take to do everything up to that point?

1411
01:02:59,800 --> 01:02:59,900
No.

1412
01:03:00,000 --> 01:03:01,700
Right, you could do that.

1413
01:03:02,000 --> 01:03:05,400
And you could come in here and say, well, the amount of counter

1414
01:03:05,400 --> 01:03:08,500
elapsed, we could do the exact same thing and see how long that takes.

1415
01:03:08,900 --> 01:03:11,000
That is the kind of thing that will be doing when we get into

1416
01:03:11,000 --> 01:03:11,700
profiling.

1417
01:03:11,800 --> 01:03:13,400
We'll have some nice utility function.

1418
01:03:13,400 --> 01:03:17,100
We can call to just drop stuff into our code and see how long every

1419
01:03:17,100 --> 01:03:18,300
individual thing takes.

1420
01:03:18,400 --> 01:03:20,100
How long is stretched debates?

1421
01:03:20,100 --> 01:03:21,600
How long does it take us to build our gradient?

1422
01:03:21,600 --> 01:03:23,100
How long it take to fill the sound buffer?

1423
01:03:23,300 --> 01:03:24,200
Those are all the sorts of things.

1424
01:03:24,200 --> 01:03:27,600
We look at when we Act start, look at profiling but that's really all

1425
01:03:27,600 --> 01:03:28,600
there was to it.

1426
01:03:28,600 --> 01:03:29,800
Now that you have those tools you can

1427
01:03:30,000 --> 01:03:31,400
Build any kind of profile you want.

1428
01:03:31,400 --> 01:03:33,600
We'll see, you know, some interesting tricks for doing that, but

1429
01:03:33,600 --> 01:03:34,200
that's it.

1430
01:03:34,600 --> 01:03:37,500
So anyway, we've come to the end of the stream and it is time for Q&A.

1431
01:03:38,300 --> 01:03:39,000
Thank you so much.

1432
01:03:39,000 --> 01:03:42,100
Everyone for joining me for another handmade hero.

1433
01:03:42,100 --> 01:03:44,400
I hope that that was all relatively clear.

1434
01:03:45,700 --> 01:03:48,300
I know, it can be kind of confusing with all these sort of things.

1435
01:03:48,300 --> 01:03:50,800
Hopefully, the clocking stuff was clear, this guy.

1436
01:03:50,900 --> 01:03:54,300
Like I said, this is a whole topic onto itself these printf.

1437
01:03:54,300 --> 01:03:57,000
So if you're a little hazy on that, I don't blame you.

1438
01:03:57,300 --> 01:03:59,200
Like I said, I don't really want to harp on it.

1439
01:03:59,200 --> 01:03:59,900
It's basically just

1440
01:04:00,100 --> 01:04:03,700
A simple way you can use to print stuff out any tutorial you read,

1441
01:04:03,700 --> 01:04:05,500
online about how to use printf.

1442
01:04:05,800 --> 01:04:07,400
And basically there's a bunch of variance.

1443
01:04:07,400 --> 01:04:09,900
There's like printf which prints them in the console.

1444
01:04:09,900 --> 01:04:13,300
There's s printf which print something to a buffer, you know, there's

1445
01:04:13,300 --> 01:04:18,200
a v vs printf which allows you to pass through printf things.

1446
01:04:18,200 --> 01:04:20,100
There's a whole bunch of different things like that.

1447
01:04:20,200 --> 01:04:22,400
There's fprintf which prints things to a file.

1448
01:04:22,700 --> 01:04:25,200
There's the whole Suite of those in the C runtime library that

1449
01:04:25,200 --> 01:04:29,400
basically are provided courtesy of the compiler for you to call if you

1450
01:04:29,400 --> 01:04:29,800
want to

1451
01:04:29,900 --> 01:04:30,000
to.

1452
01:04:30,300 --> 01:04:31,000
So, there you go.

1453
01:04:31,500 --> 01:04:32,700
So yes with that.

1454
01:04:32,800 --> 01:04:34,900
I'd like to go to the Q&A.

1455
01:04:34,900 --> 01:04:39,200
Please remember to prefix, anything that you want to ask with at see

1456
01:04:39,200 --> 01:04:41,300
me oratory so that I will see it.

1457
01:04:47,600 --> 01:04:50,000
Somebody saying our dtsc return an unsigned integer.

1458
01:04:50,000 --> 01:04:51,200
That's what I would have thought too.

1459
01:04:51,200 --> 01:04:53,800
But I thought maybe I was just, maybe I just quickly reading.

1460
01:04:53,800 --> 01:04:55,800
I would have thought it returned an unsigned integer as well.

1461
01:04:56,200 --> 01:04:58,000
But for some reason, it looked like it didn't.

1462
01:04:58,800 --> 01:04:59,400
I don't know why.

1463
01:04:59,400 --> 01:04:59,900
Oh, it did.

1464
01:04:59,900 --> 01:05:00,200
Okay.

1465
01:05:00,200 --> 01:05:00,500
Okay.

1466
01:05:00,500 --> 01:05:00,800
Okay.

1467
01:05:00,800 --> 01:05:01,900
I just, I was asleep at the switch.

1468
01:05:01,900 --> 01:05:02,200
Yes.

1469
01:05:02,200 --> 01:05:03,100
Thank you for catching that.

1470
01:05:03,100 --> 01:05:04,700
That was odd to me as well.

1471
01:05:04,700 --> 01:05:08,100
I was like, gosh, that's weird because I don't, I have always in the

1472
01:05:08,100 --> 01:05:09,700
past started in a, you N64.

1473
01:05:09,700 --> 01:05:11,800
But I was like, well, maybe I just want to follow think.

1474
01:05:11,800 --> 01:05:11,900
Okay.

1475
01:05:11,900 --> 01:05:12,400
Good.

1476
01:05:12,500 --> 01:05:14,300
That's good cycle.

1477
01:05:14,300 --> 01:05:15,000
Count.

1478
01:05:16,000 --> 01:05:16,800
There we go.

1479
01:05:16,900 --> 01:05:17,200
You and six?

1480
01:05:17,400 --> 01:05:20,700
Were, there we go.

1481
01:05:20,800 --> 01:05:22,500
Cycles of the elapsed?

1482
01:05:22,900 --> 01:05:24,100
Yeah, are you?

1483
01:05:24,700 --> 01:05:27,400
Okay, so that's that's really all we needed there.

1484
01:05:27,800 --> 01:05:30,300
Oh, so one thing I should talk about really quickly to well.

1485
01:05:30,300 --> 01:05:31,000
We're in the Q&A.

1486
01:05:31,400 --> 01:05:33,900
You'll notice I went in here and I had to cast these things to

1487
01:05:33,900 --> 01:05:34,900
floating Point values.

1488
01:05:35,200 --> 01:05:37,900
The reason for that and we kind of glossed over it.

1489
01:05:37,900 --> 01:05:40,500
We didn't really talk about this in detail and I should just mention

1490
01:05:40,500 --> 01:05:43,100
it for people who are not as familiar with.

1491
01:05:43,100 --> 01:05:47,000
See, maybe you're coming from this to the

1492
01:05:47,300 --> 01:05:50,600
I'm from a different language and you may not understand all the

1493
01:05:50,600 --> 01:05:52,000
implicit rules that c does.

1494
01:05:52,300 --> 01:05:55,700
So, one of the things is, if I have two integers, right?

1495
01:05:55,700 --> 01:05:59,800
I have in X and Y and I say x divided by y, right.

1496
01:06:00,700 --> 01:06:03,800
It's going to use the types of those integers to determine what kind

1497
01:06:03,800 --> 01:06:04,800
of divide to do.

1498
01:06:05,100 --> 01:06:08,500
So even if I was trying to store it in a floating point value.

1499
01:06:08,700 --> 01:06:10,700
It doesn't really look yet.

1500
01:06:10,700 --> 01:06:14,600
When it does the /, it doesn't look at like, what the what it needs to

1501
01:06:14,600 --> 01:06:15,500
generate.

1502
01:06:15,900 --> 01:06:17,500
At the end of the equals.

1503
01:06:18,100 --> 01:06:20,700
It doesn't use that to determine what kind of divide to do.

1504
01:06:20,900 --> 01:06:24,400
So these are integers and memory, and their integer types and see,

1505
01:06:24,400 --> 01:06:24,900
right.

1506
01:06:25,000 --> 01:06:29,000
So C is going to do this as an integer divide and an integer divide.

1507
01:06:30,200 --> 01:06:33,800
Another integer and of course, an integer has no fractional part.

1508
01:06:33,900 --> 01:06:35,700
So, the fraction is gets thrown away.

1509
01:06:35,700 --> 01:06:36,300
It's gone.

1510
01:06:37,000 --> 01:06:41,400
So if we did float Z equals x divided by y, we will get no fraction,

1511
01:06:41,400 --> 01:06:44,000
even though this value is capable of storing a fraction.

1512
01:06:44,300 --> 01:06:48,700
So what you have to do first is tell C using the casting, notation

1513
01:06:48,700 --> 01:06:49,400
that we learned.

1514
01:06:49,800 --> 01:06:54,500
Basically, we have to tell see cast this prick, you know, convert it

1515
01:06:54,500 --> 01:06:56,700
first to a floating Point number.

1516
01:06:57,000 --> 01:06:59,700
Then do the divide and then see understands.

1517
01:06:59,800 --> 01:07:00,000
Oh,

1518
01:07:00,100 --> 01:07:01,000
Okay, I see what you're doing.

1519
01:07:01,100 --> 01:07:04,500
We're trying to move these into floating-point registers do a divide

1520
01:07:04,500 --> 01:07:07,200
in the floating Point registers and then store the result of that

1521
01:07:07,200 --> 01:07:09,700
floating-point divide out to the float.

1522
01:07:15,500 --> 01:07:17,600
Oh, yes, you know what?

1523
01:07:17,600 --> 01:07:18,900
I still need to figure out.

1524
01:07:18,900 --> 01:07:20,000
How to put a window up there.

1525
01:07:20,000 --> 01:07:21,300
I was using an index card.

1526
01:07:21,400 --> 01:07:21,800
I'm sorry.

1527
01:07:21,800 --> 01:07:23,900
I was drawing behind my window and paint.

1528
01:07:23,900 --> 01:07:24,500
There's a little.

1529
01:07:24,500 --> 01:07:27,800
I gotta, I gotta make a thing that blocks my screen just out.

1530
01:07:27,800 --> 01:07:29,500
I've been so good and I forgot.

1531
01:07:31,400 --> 01:07:34,500
So someone is asking, let's see where we going here.

1532
01:07:34,500 --> 01:07:38,600
Someone was asking if we can compile with optimizations on and see how

1533
01:07:38,600 --> 01:07:39,300
this changes.

1534
01:07:39,500 --> 01:07:40,300
So that's true.

1535
01:07:40,300 --> 01:07:44,300
If we were profiling our code, obviously we are not, we are not

1536
01:07:44,300 --> 01:07:44,500
turning.

1537
01:07:44,600 --> 01:07:45,500
Optimizer here.

1538
01:07:45,500 --> 01:07:50,100
So basically the compiler is producing the slowest possible version of

1539
01:07:50,100 --> 01:07:50,900
our code right now.

1540
01:07:50,900 --> 01:07:55,200
It's not trying to do any thinking about how to make the code fast and

1541
01:07:55,200 --> 01:07:59,200
that could matter because again, we've got some, we've got some large

1542
01:07:59,200 --> 01:08:00,500
loop things happening here.

1543
01:08:00,500 --> 01:08:03,800
Like in our thing where we render weird gradient, there is a lot.

1544
01:08:03,800 --> 01:08:08,100
This is going to be, you know, 1280 by 720 or whatever.

1545
01:08:08,100 --> 01:08:10,700
We set our window height was we're going to be operating on a lot of

1546
01:08:10,700 --> 01:08:11,800
memory here in our little Loop.

1547
01:08:11,800 --> 01:08:14,200
If the compiler were to optimize this or not.

1548
01:08:14,600 --> 01:08:15,900
Is it that could make a difference?

1549
01:08:16,500 --> 01:08:17,800
You know, that's definitely true.

1550
01:08:18,000 --> 01:08:22,700
So basically, if we take a look here, I don't really want to get into

1551
01:08:22,700 --> 01:08:24,399
performance analysis yet.

1552
01:08:24,500 --> 01:08:26,000
So I'm not really going to harp on this.

1553
01:08:26,000 --> 01:08:28,899
But since someone asked the question, we could look here and say,

1554
01:08:28,899 --> 01:08:32,700
well, here is just a poor man's quick version.

1555
01:08:32,899 --> 01:08:35,300
We could look here and say, well, alright.

1556
01:08:35,399 --> 01:08:38,800
So here's the here's the thing unoptimized, right?

1557
01:08:38,800 --> 01:08:42,100
That's the sort of typical thing that we were seeing optimized and

1558
01:08:42,100 --> 01:08:44,500
then we go into our build script.

1559
01:08:44,700 --> 01:08:49,700
Can say we wanted optimize that would be in build up bats.

1560
01:08:50,000 --> 01:08:54,899
We can pass - 02 to it and it will do some optimization for us and

1561
01:08:54,899 --> 01:08:57,800
then we'll hit the five and see what it actually is.

1562
01:08:57,800 --> 01:08:59,800
We close it and now we can see.

1563
01:09:00,600 --> 01:09:04,000
What we actually get for our frames per second and see how they

1564
01:09:04,000 --> 01:09:07,200
compare right, our milliseconds per frame and so on.

1565
01:09:07,600 --> 01:09:09,500
So this is optimized, right?

1566
01:09:09,700 --> 01:09:13,000
And as you can see, the unoptimized version is pretty consistently

1567
01:09:13,000 --> 01:09:15,800
about twice as slow as the optimized version, right?

1568
01:09:16,300 --> 01:09:20,399
And that's not perhaps a typical in a circumstance where we have not

1569
01:09:20,399 --> 01:09:21,800
optimized our code at all.

1570
01:09:22,000 --> 01:09:24,399
So it's entirely up to the optimizer to do everything.

1571
01:09:24,800 --> 01:09:26,700
That's that's totally reasonable.

1572
01:09:26,700 --> 01:09:27,200
Right.

1573
01:09:27,800 --> 01:09:29,800
If it's code that we've optimized we would probably not.

1574
01:09:30,000 --> 01:09:33,000
Be getting a 2X like that, because we've already done a bunch of work

1575
01:09:33,000 --> 01:09:35,000
to make the code sort of more optimal as it is.

1576
01:09:35,399 --> 01:09:39,100
But yeah, so hopefully you can see that's that's basically this is

1577
01:09:39,200 --> 01:09:45,000
with with - O2 and this is without, so this is that's how that works.

1578
01:09:48,899 --> 01:09:50,399
Let's take a look here.

1579
01:09:52,500 --> 01:09:57,500
Okay, do do do do.

1580
01:10:00,200 --> 01:10:01,100
Do the divide in doubles?

1581
01:10:01,100 --> 01:10:02,300
Oh, yeah, I should mention that.

1582
01:10:02,300 --> 01:10:03,300
Thank you for saying that.

1583
01:10:03,300 --> 01:10:04,700
Someone was talking about the Divide here.

1584
01:10:05,100 --> 01:10:06,500
So I wanted to mention this as well.

1585
01:10:06,500 --> 01:10:08,700
I kind of set it as we went through the screen by never actually

1586
01:10:08,700 --> 01:10:09,200
showed it.

1587
01:10:09,700 --> 01:10:12,500
So one of the things that's true here is if you really cared about the

1588
01:10:12,500 --> 01:10:17,400
last little bit of accuracy, so you like at this level of accuracy,

1589
01:10:17,400 --> 01:10:19,700
you don't care about this at all.

1590
01:10:19,900 --> 01:10:23,900
But if you were printing out a more fine if you wanted more decimal

1591
01:10:23,900 --> 01:10:27,400
places here and you actually care what the value was, it's your, you

1592
01:10:27,400 --> 01:10:29,400
know, there's you're actually trying to be more accurate and not just

1593
01:10:29,400 --> 01:10:29,900
a rough idea.

1594
01:10:30,000 --> 01:10:34,100
It the thing to remember, is basically a real, a floating, a 32-bit

1595
01:10:34,100 --> 01:10:38,800
floating point value, as we covered, has 24 bits of accuracy in it.

1596
01:10:38,900 --> 01:10:39,400
Right?

1597
01:10:39,700 --> 01:10:42,600
We said it was 24 and Tessa and then, you know, 7 B exponent or

1598
01:10:42,600 --> 01:10:43,200
something like this.

1599
01:10:43,200 --> 01:10:45,300
I don't know what we, what we actually kept that with it was.

1600
01:10:45,300 --> 01:10:51,800
But basically that so it's 24 bits of accuracy, but we've got 64 bits

1601
01:10:51,800 --> 01:10:57,800
of accuracy coming in now, technically, after this subtract.

1602
01:10:58,400 --> 01:11:00,100
There's actually not going to be that many.

1603
01:11:00,700 --> 01:11:03,400
So the person who said do the divide and 64-bit.

1604
01:11:04,000 --> 01:11:07,100
I know where you were going with that, it probably won't change the

1605
01:11:07,100 --> 01:11:12,100
result at all because you don't have 64 bits of accuracy after you do

1606
01:11:12,100 --> 01:11:17,800
the subtraction, but let's say that you time something really long,

1607
01:11:18,000 --> 01:11:18,800
right?

1608
01:11:19,400 --> 01:11:24,100
So instead of 20 million coming back, like this is 10 million coming

1609
01:11:24,100 --> 01:11:25,500
back, 10 million.

1610
01:11:25,700 --> 01:11:27,200
You're not going to really lose any accuracy.

1611
01:11:27,200 --> 01:11:28,000
Doing a floating.

1612
01:11:28,100 --> 01:11:31,400
A point divide, a 10 million, but let's say you would time something

1613
01:11:31,400 --> 01:11:33,800
that was like 50 billion cycles.

1614
01:11:33,800 --> 01:11:36,600
It was several frames long or something like this, right?

1615
01:11:37,400 --> 01:11:40,300
Then doing the divide in a 32-bit float.

1616
01:11:40,800 --> 01:11:44,300
It'll still work just fine, but you'll have a lot less Precision

1617
01:11:44,500 --> 01:11:49,200
because 50 billion is much higher than the number of decimal places

1618
01:11:49,200 --> 01:11:53,900
that you can have the number of bits that you have in your 24-bit

1619
01:11:53,900 --> 01:11:58,000
flow, 50 billion would be like, you know, 35

1620
01:11:58,100 --> 01:11:59,900
five bits to represent all the things.

1621
01:12:00,100 --> 01:12:04,100
They're right, and we only have 24, bits of mantissa in our floating

1622
01:12:04,100 --> 01:12:04,800
point value.

1623
01:12:05,000 --> 01:12:08,200
So in order to actually do the Divide out all the way, so that it was

1624
01:12:08,200 --> 01:12:10,900
actually as accurate, as the numbers that we're going in.

1625
01:12:11,300 --> 01:12:13,400
You would want to cast these two real 64's.

1626
01:12:13,400 --> 01:12:15,500
You'd want to use 64-bit floating-point values.

1627
01:12:15,800 --> 01:12:16,900
For what we're doing.

1628
01:12:17,000 --> 01:12:19,700
We're never going to have a big enough thing that we ever actually

1629
01:12:19,700 --> 01:12:20,800
really care about that.

1630
01:12:20,900 --> 01:12:23,900
But if you want to, you totally can and one of the things that's a

1631
01:12:23,900 --> 01:12:29,700
weird total anachronism Quark, weird thing about printf is they always

1632
01:12:29,700 --> 01:12:29,800
act?

1633
01:12:30,000 --> 01:12:34,400
We do the printf in double anyway, basically, they always use 64-bit

1634
01:12:34,400 --> 01:12:34,900
floats.

1635
01:12:35,000 --> 01:12:38,400
So these actually get past as 64-bit floats.

1636
01:12:38,800 --> 01:12:41,700
Anyway, they get up converted when they get passed at the end.

1637
01:12:42,000 --> 01:12:47,000
So you're actually if you want to it's more or less free to do it with

1638
01:12:47,000 --> 01:12:50,100
the actual person with the additional Precision because you're only

1639
01:12:50,100 --> 01:12:51,100
doing this once.

1640
01:12:51,300 --> 01:12:53,800
And so it's not like it's some big thing and it's only for performance

1641
01:12:53,800 --> 01:12:55,500
tuning so you're not even shipping this code.

1642
01:12:56,700 --> 01:12:58,100
So it's not really a big deal.

1643
01:12:58,200 --> 01:12:59,700
You're not doing it that often you.

1644
01:13:00,000 --> 01:13:03,500
And for free, if you want to just do it with higher Precision, now,

1645
01:13:03,500 --> 01:13:04,800
you're not going to see any difference there.

1646
01:13:04,800 --> 01:13:07,400
The going to exactly the same in this particular thing.

1647
01:13:07,400 --> 01:13:09,500
But if you were doing stuff, it might count.

1648
01:13:09,600 --> 01:13:10,100
So it's free.

1649
01:13:10,100 --> 01:13:13,100
If you want to do it with the higher Precision, that's just something

1650
01:13:13,100 --> 01:13:13,500
bad.

1651
01:13:17,400 --> 01:13:18,800
Let's see.

1652
01:13:26,400 --> 01:13:29,500
It would be nice to have a road map, so we can read ahead.

1653
01:13:29,500 --> 01:13:32,200
When you deal with string formats threading, opengl DirectX cross

1654
01:13:32,200 --> 01:13:33,400
platforms, have etcetera.

1655
01:13:34,700 --> 01:13:37,800
And what I consider doing a 24-hour shifts a day roadmap, probably

1656
01:13:37,800 --> 01:13:38,500
won't happen.

1657
01:13:38,600 --> 01:13:42,300
And the reason for that is that I don't think they're a good idea, not

1658
01:13:42,300 --> 01:13:45,500
because I don't want you to know what's happening, but more because

1659
01:13:45,700 --> 01:13:48,200
programming with a schedule never works.

1660
01:13:49,400 --> 01:13:54,300
You have to be able to sort of feel, you have to be able to build up a

1661
01:13:54,300 --> 01:13:55,300
good intuition about

1662
01:13:55,500 --> 01:13:58,400
But the thing is that needs to happen next, after you do each

1663
01:13:58,400 --> 01:13:59,300
individual thing.

1664
01:13:59,600 --> 01:14:03,000
And if you have a road map, then you're sort of saying that you're

1665
01:14:03,000 --> 01:14:06,600
going to do whatever the thing is, that was on the road map next, but

1666
01:14:06,600 --> 01:14:08,200
that may turn out to be inappropriate.

1667
01:14:08,300 --> 01:14:10,000
So there will not be a roadmap.

1668
01:14:10,200 --> 01:14:12,800
That's not going to happen at best.

1669
01:14:12,800 --> 01:14:16,600
I will start to tell you, as we go into the later parts of the code

1670
01:14:16,800 --> 01:14:18,100
and I have done this already.

1671
01:14:18,400 --> 01:14:20,000
What we're doing the next day.

1672
01:14:20,200 --> 01:14:23,700
So if you want to read up on something in during the day for the next

1673
01:14:23,700 --> 01:14:25,300
night stream or something that might happen.

1674
01:14:25,400 --> 01:14:26,400
24 hour stream.

1675
01:14:26,400 --> 01:14:27,300
Probably won't happen.

1676
01:14:31,100 --> 01:14:33,100
Will we be able to use a PlayStation 2 controller?

1677
01:14:33,100 --> 01:14:35,600
Yes, I mean, at the end, we'll make sure we work with all sorts of

1678
01:14:35,600 --> 01:14:36,100
things.

1679
01:14:36,400 --> 01:14:40,800
I don't know about PlayStation 2 controller specifically, but at least

1680
01:14:40,800 --> 01:14:44,800
a PlayStation, like, for controller or something, some PlayStation

1681
01:14:44,800 --> 01:14:46,600
controller that plugs into a PC.

1682
01:14:46,900 --> 01:14:49,700
We will test with and make sure that we get it working with that.

1683
01:14:51,800 --> 01:14:53,200
Let's see.

1684
01:14:53,300 --> 01:14:55,200
Can we expect for Jess and Casey shows in the future?

1685
01:14:55,200 --> 01:14:56,400
There's one every Monday.

1686
01:14:57,200 --> 01:14:58,300
There was one just this past Monday.

1687
01:14:58,300 --> 01:14:59,500
They'll be one this Monday as well.

1688
01:14:59,500 --> 01:14:59,900
You can always

1689
01:15:00,000 --> 01:15:03,200
Get more, just subscribe to the podcast stream and you get one every

1690
01:15:03,200 --> 01:15:03,600
Monday.

1691
01:15:05,600 --> 01:15:08,800
Is it safe to use Thrifty for but variables and functions on a 32-bit

1692
01:15:08,800 --> 01:15:09,100
PC?

1693
01:15:09,100 --> 01:15:09,600
Yes.

1694
01:15:10,100 --> 01:15:12,800
It's just not safe to assume that they are performant.

1695
01:15:13,000 --> 01:15:17,000
So basically, if you do some kind of 64-bit operation on a 32-bit PC,

1696
01:15:17,100 --> 01:15:19,700
you may end up in a situation where your emulated.

1697
01:15:19,700 --> 01:15:22,800
So, basically, the processor generates a bunch of things to do a

1698
01:15:22,800 --> 01:15:25,300
64-bit multiply or divide.

1699
01:15:26,800 --> 01:15:32,600
It may be very inefficient as long as you're doing them only in in

1700
01:15:32,600 --> 01:15:34,400
places where you don't do them a lot.

1701
01:15:34,500 --> 01:15:34,900
So this is

1702
01:15:35,400 --> 01:15:36,500
One per frame.

1703
01:15:36,800 --> 01:15:41,200
You could afford 10,000 Cycles to do this, subtraction.

1704
01:15:41,200 --> 01:15:44,500
If you wanted to write and were immediately up converting them to

1705
01:15:44,500 --> 01:15:46,500
floating Point values to do the rest of the map.

1706
01:15:46,500 --> 01:15:49,600
So, we're only really literally doing some traction of 64 bit here.

1707
01:15:50,000 --> 01:15:52,800
That's attraction, will never hurt you, no matter what processor,

1708
01:15:52,800 --> 01:15:53,900
you're on pretty much.

1709
01:15:54,000 --> 01:15:54,900
So that's okay.

1710
01:15:55,200 --> 01:15:58,200
If on the other hand, you were in some tight Loop that Opera like,

1711
01:15:58,200 --> 01:16:00,700
let's say, in our pixel Loop that we're actually filling our gradient

1712
01:16:00,700 --> 01:16:00,900
out.

1713
01:16:00,900 --> 01:16:04,700
If you started doing 64-bit math in there, that would be real bad if

1714
01:16:04,700 --> 01:16:04,800
you

1715
01:16:05,000 --> 01:16:07,600
Then tried to run it on a processor that couldn't do 64-bit math

1716
01:16:07,600 --> 01:16:08,000
natively.

1717
01:16:08,000 --> 01:16:09,100
That would be a bad scene.

1718
01:16:12,800 --> 01:16:14,300
Let's see.

1719
01:16:18,500 --> 01:16:20,800
It feels like, even though we are doing low-level programming.

1720
01:16:20,800 --> 01:16:22,900
Sometimes we have to pass things to Windows and makes difficult to

1721
01:16:22,900 --> 01:16:23,100
follow.

1722
01:16:23,100 --> 01:16:24,700
Exactly what the computer is doing.

1723
01:16:24,900 --> 01:16:27,300
Well, this change, we moved on to other platforms, but we also run

1724
01:16:27,300 --> 01:16:28,100
into the same problems.

1725
01:16:28,100 --> 01:16:32,100
Occasionally, I would say, basically that is just an endemic problem

1726
01:16:32,100 --> 01:16:33,200
with modern programming.

1727
01:16:34,000 --> 01:16:36,900
Basically, one of the reasons that I did this Windows platform layer

1728
01:16:36,900 --> 01:16:40,000
first is because now that we're basically done with it.

1729
01:16:40,300 --> 01:16:43,200
There's one of the things we'll do which before we go a little

1730
01:16:43,200 --> 01:16:44,700
further, but we'll do that next week.

1731
01:16:44,800 --> 01:16:47,300
Integrated with other things, which is file IO.

1732
01:16:48,200 --> 01:16:51,500
Basically, the reason I want to get this out the way first, it's so

1733
01:16:51,500 --> 01:16:53,800
from now on, we'll always be able to know exactly what's going on.

1734
01:16:53,800 --> 01:16:57,300
But there's always this bottom substrate that you don't know what's

1735
01:16:57,300 --> 01:16:57,600
going on.

1736
01:16:57,600 --> 01:17:03,400
And it's unfortunate when we do the Raspberry Pi Port will be able to

1737
01:17:03,400 --> 01:17:04,300
have a lot less of that.

1738
01:17:04,300 --> 01:17:08,700
But even then we'll still have like a little bit of firmware you

1739
01:17:08,700 --> 01:17:13,200
never, unless you actually built the firmware for the machine, that's

1740
01:17:13,200 --> 01:17:14,200
actually in the wrong.

1741
01:17:14,200 --> 01:17:18,000
There's always some call you eventually make which

1742
01:17:18,200 --> 01:17:22,500
Triggers some code, someone else wrote even in the dust days, you

1743
01:17:22,500 --> 01:17:24,400
like, would trigger an interrupt to do.

1744
01:17:24,400 --> 01:17:25,700
I owe or something like this.

1745
01:17:26,000 --> 01:17:29,800
You didn't actually write that exactly, you didn't burn the eeprom in

1746
01:17:29,800 --> 01:17:33,200
there, which, which talks to the, you know, the IDE controller or

1747
01:17:33,200 --> 01:17:33,700
something.

1748
01:17:34,000 --> 01:17:37,300
So, there you, you do have to, unfortunately, even though we're going

1749
01:17:37,300 --> 01:17:38,600
pretty low level in the Stream.

1750
01:17:38,800 --> 01:17:43,500
You do have to always be used to the fact that at some point, someone

1751
01:17:43,500 --> 01:17:45,000
else does take control of things.

1752
01:17:45,600 --> 01:17:48,000
Even if you were to burn the firmware yourself.

1753
01:17:48,300 --> 01:17:51,300
It's still being a circumstance where there's microcode executing on

1754
01:17:51,300 --> 01:17:53,000
the CPU and you didn't write that.

1755
01:17:53,200 --> 01:17:55,900
So there's always someone below you and you have to be comfortable

1756
01:17:55,900 --> 01:17:56,500
with that.

1757
01:17:57,200 --> 01:17:59,800
What we try to do on this stream is going.

1758
01:18:00,000 --> 01:18:01,100
As low as reasonably possible.

1759
01:18:01,100 --> 01:18:05,300
So you can see everything you might want to control and that you could

1760
01:18:05,300 --> 01:18:06,000
control.

1761
01:18:07,200 --> 01:18:11,900
But in terms of actually getting all the way down to some pure level,

1762
01:18:11,900 --> 01:18:13,700
there really isn't one.

1763
01:18:14,400 --> 01:18:17,300
So you're always going to have to draw that line somewhere.

1764
01:18:17,500 --> 01:18:21,100
We are basically trying to draw it as low as feasible, so that you

1765
01:18:21,100 --> 01:18:25,400
understand everything you might ever care about basically, but we're

1766
01:18:25,400 --> 01:18:28,100
not going to try and go down to a level of absurdity.

1767
01:18:28,100 --> 01:18:29,900
Where we're like, let's try and

1768
01:18:30,000 --> 01:18:31,200
A code, our own.

1769
01:18:31,200 --> 01:18:34,200
Let's burnt, let's make our own CPU and have it fabbed and then

1770
01:18:34,200 --> 01:18:35,100
program on that, right?

1771
01:18:35,100 --> 01:18:36,600
You could go that far.

1772
01:18:36,700 --> 01:18:38,200
We're not trying to do that.

1773
01:18:42,700 --> 01:18:43,900
Let's see.

1774
01:18:47,100 --> 01:18:50,000
Do you ever use a profiler or mostly use hand coded timer calls?

1775
01:18:50,000 --> 01:18:53,900
I mostly use hand-coded timer calls, but sometimes the profiler can be

1776
01:18:53,900 --> 01:18:54,400
useful.

1777
01:18:57,700 --> 01:18:59,500
Why do I use Pascal case for everything?

1778
01:18:59,500 --> 01:19:01,600
I just that's just how I tend to program.

1779
01:19:01,600 --> 01:19:02,500
I don't have a why?

1780
01:19:02,500 --> 01:19:03,500
I like how you name things?

1781
01:19:03,500 --> 01:19:05,600
Not really a why it's whatever is most comfortable to you.

1782
01:19:06,100 --> 01:19:08,700
Is it a violation to set one member of a union, then read from

1783
01:19:08,700 --> 01:19:09,100
another?

1784
01:19:09,100 --> 01:19:13,300
No, that's, that's totally legal, or at least it works on every

1785
01:19:13,300 --> 01:19:14,600
compiler I've ever used.

1786
01:19:16,100 --> 01:19:18,800
I was playing around the input code yesterday with a Dualshock 4.

1787
01:19:19,300 --> 01:19:21,600
And so I started thinking about when we would get around to

1788
01:19:21,600 --> 01:19:25,200
implementing raw input so we can handle those controllers natively.

1789
01:19:26,200 --> 01:19:30,500
Probably not for a long time actually because I don't really want to

1790
01:19:30,500 --> 01:19:36,000
spend a lot of your time looking at platform code especially because I

1791
01:19:36,000 --> 01:19:39,200
just I'm showing you how everything works, but I'm not like telling

1792
01:19:39,200 --> 01:19:41,300
you you have to do everything yourself.

1793
01:19:41,300 --> 01:19:44,300
Like if people want to use this simple directmedia layer, something

1794
01:19:44,300 --> 01:19:44,900
sdl.

1795
01:19:45,100 --> 01:19:45,600
Or whatever.

1796
01:19:46,000 --> 01:19:48,700
That's a totally fine decision and tons of people ship games on those

1797
01:19:48,700 --> 01:19:49,100
things.

1798
01:19:49,400 --> 01:19:52,900
So the goal here is not to teach you that you should Implement an

1799
01:19:52,900 --> 01:19:54,200
entire platform layer yourself.

1800
01:19:54,400 --> 01:19:58,600
The goal is to show you how to do that if you so that you understand

1801
01:19:58,600 --> 01:20:00,900
how everything is working, when you choose to use someone else's

1802
01:20:00,900 --> 01:20:03,800
library, and, you know that stuff or so that you can write a better

1803
01:20:03,800 --> 01:20:06,800
version of sdl yourself, if you chose to do so, right?

1804
01:20:06,800 --> 01:20:08,700
So that you have the ability to write all that stuff.

1805
01:20:09,100 --> 01:20:12,400
So I really want to focus on the game code and all that stuff more

1806
01:20:12,400 --> 01:20:14,700
because that stuff is important, no matter what you're doing.

1807
01:20:15,000 --> 01:20:18,200
Something you need to know no matter regardless of whether you how far

1808
01:20:18,200 --> 01:20:19,500
down the stack you choose to go.

1809
01:20:19,800 --> 01:20:23,500
So we won't do like raw input or something like that.

1810
01:20:23,500 --> 01:20:24,500
To wait at the end.

1811
01:20:24,500 --> 01:20:28,200
When we do the shipping version of our Windows platform layer, which

1812
01:20:28,200 --> 01:20:31,200
will have raw input and overlapped IO and all these are the sorts of

1813
01:20:31,200 --> 01:20:31,600
things.

1814
01:20:32,300 --> 01:20:33,600
But we're not going to focus on those.

1815
01:20:33,600 --> 01:20:37,000
Now, we're just doing the minimal Windows code now and we'll do the

1816
01:20:37,000 --> 01:20:40,300
hardcore Windows code way later way later.

1817
01:20:40,300 --> 01:20:41,500
Like, when the game is done.

1818
01:20:47,300 --> 01:20:52,300
Modern CPUs are DSC returns nominal clocks, not real clocks.

1819
01:20:53,100 --> 01:20:55,400
So that's Tom Forsythe.

1820
01:20:55,400 --> 01:20:59,300
Who, by the way, if people don't know, actually is someone who worked

1821
01:20:59,300 --> 01:20:59,900
on for example,

1822
01:21:00,000 --> 01:21:04,100
Larrabee project with Intel CPU team, he was at Intel for a while.

1823
01:21:04,900 --> 01:21:08,500
So he is more of a processor expert than I am certainly,

1824
01:21:09,700 --> 01:21:11,300
unfortunately, Tom.

1825
01:21:11,700 --> 01:21:18,400
I'm not the guy to try and explain how clocks get returned because I

1826
01:21:18,400 --> 01:21:19,700
have no idea.

1827
01:21:20,900 --> 01:21:22,900
Like basically, I don't know.

1828
01:21:22,900 --> 01:21:25,800
What a real clock is in the in the CPU vs.

1829
01:21:25,800 --> 01:21:28,700
A cycle in terms of what it's going to tell you.

1830
01:21:29,200 --> 01:21:29,700
So,

1831
01:21:30,000 --> 01:21:34,700
If you Tom want to point to post a good article about this because I

1832
01:21:34,700 --> 01:21:38,600
know you have a Blog, I would be delighted to point people towards it

1833
01:21:38,800 --> 01:21:39,400
tomorrow.

1834
01:21:39,400 --> 01:21:43,600
Well, not tomorrow on the next stream, on Monday, not saying you have

1835
01:21:43,600 --> 01:21:47,300
to, but if that's something you would like to clarify for people, I

1836
01:21:47,300 --> 01:21:49,400
would be happy to point to a, but I'm not the guy for that.

1837
01:21:49,400 --> 01:21:51,300
I don't know CPU architecture very well.

1838
01:21:51,300 --> 01:21:56,800
So if I tried to explain exactly what a cycle in the CPU was versus a

1839
01:21:56,800 --> 01:21:57,900
cycle in our dtsc.

1840
01:21:57,900 --> 01:21:58,900
I die.

1841
01:21:58,900 --> 01:21:59,800
I'm just going to get it wrong.

1842
01:22:02,700 --> 01:22:04,500
Plus also, the modern CPU thing.

1843
01:22:04,500 --> 01:22:06,700
I don't know where that modern change happened.

1844
01:22:06,700 --> 01:22:10,200
Like, I know the Pentium introduced the our dtsc, but I don't know

1845
01:22:10,200 --> 01:22:12,400
where the changeover happened from Rio clocks.

1846
01:22:12,400 --> 01:22:13,700
And nominal clocks, and so on.

1847
01:22:17,500 --> 01:22:19,700
Why are you avoiding doubles in your code?

1848
01:22:20,500 --> 01:22:24,200
Well, I never use doubles really, because they're much slower than,

1849
01:22:24,400 --> 01:22:25,300
than reals.

1850
01:22:25,400 --> 01:22:27,000
So, sometimes in timing I would use them.

1851
01:22:27,000 --> 01:22:29,100
But again, here, they're not necessary at all.

1852
01:22:29,500 --> 01:22:31,500
They're completely, they would be completely unnecessary for the

1853
01:22:31,500 --> 01:22:32,800
computer computation we were doing.

1854
01:22:33,600 --> 01:22:35,700
So I only use doubles if they're absolutely necessary.

1855
01:22:35,700 --> 01:22:40,000
And this case, they weren't and that's because they're half as fast,

1856
01:22:40,000 --> 01:22:40,500
usually?

1857
01:22:40,900 --> 01:22:41,400
Right.

1858
01:22:41,500 --> 01:22:44,700
You can do twice as many float operations, as you can double.

1859
01:22:45,100 --> 01:22:46,300
In the same amount of time.

1860
01:22:46,300 --> 01:22:47,800
That's just how that works.

1861
01:22:51,400 --> 01:22:54,300
Are you opposed to every using high-level languages and making games?

1862
01:22:56,100 --> 01:23:00,700
Mmm, so I'm not opposed to using high-level languages.

1863
01:23:01,200 --> 01:23:06,100
I'm not opposed to programming at a high level.

1864
01:23:06,500 --> 01:23:10,400
I'm opposed to high level languages because all the ones I've seen are

1865
01:23:10,400 --> 01:23:11,200
lousy.

1866
01:23:11,600 --> 01:23:15,100
If there was a high level language that work the way I want to

1867
01:23:15,100 --> 01:23:16,300
high-level language to work.

1868
01:23:16,300 --> 01:23:18,300
Then I would be super in favor of it.

1869
01:23:18,400 --> 01:23:20,700
But all the high-level languages I ever see are awful.

1870
01:23:20,900 --> 01:23:22,100
And I would never program in them.

1871
01:23:23,900 --> 01:23:27,500
Let's see if you want to lock the FPS at a particular number.

1872
01:23:27,500 --> 01:23:30,200
Would you just sleep or do something more complex?

1873
01:23:30,400 --> 01:23:32,800
Well, the easiest thing to do there is, if you can wait on the

1874
01:23:32,800 --> 01:23:33,200
vertical.

1875
01:23:33,200 --> 01:23:37,300
Retrace, that's the easiest way to do that.

1876
01:23:37,300 --> 01:23:41,300
And you can do that with direct with with direct.

1877
01:23:41,600 --> 01:23:45,500
Not direct2d directdraw still, you can still I think I got a handle

1878
01:23:45,500 --> 01:23:45,800
director.

1879
01:23:45,800 --> 01:23:50,700
Aw, and wait for the vertical blank when you are using direct3d or

1880
01:23:50,700 --> 01:23:51,600
opengl.

1881
01:23:51,600 --> 01:23:52,900
You can usually tell the

1882
01:23:53,000 --> 01:23:55,000
Swap command to wait for the V blank.

1883
01:23:55,000 --> 01:23:58,400
So the easiest way to lock to the monitor refresh frequency, which is

1884
01:23:58,400 --> 01:23:59,800
what you presumably were asking that question.

1885
01:24:00,000 --> 01:24:04,100
About, that's the easiest way to do it because then, you know, it's

1886
01:24:04,100 --> 01:24:06,900
actually locked to the monitor, which is what you would rather do than

1887
01:24:06,900 --> 01:24:08,200
try to fake that.

1888
01:24:08,900 --> 01:24:12,400
But if you want to lock to a particular frequency on your own, then

1889
01:24:12,400 --> 01:24:13,800
yes, you would sleep.

1890
01:24:13,800 --> 01:24:18,500
But before you can sleep, since sleep is 50, millisecond granular on a

1891
01:24:18,500 --> 01:24:21,100
lot of operating systems by default on a lot of Windows versions by

1892
01:24:21,100 --> 01:24:21,800
default.

1893
01:24:21,800 --> 01:24:25,700
You have to do a thing called setting, the you have to set the thread

1894
01:24:25,700 --> 01:24:29,800
frequent, the swed thread, the scheduler, wake up frequency, and

1895
01:24:30,000 --> 01:24:30,400
Stuff.

1896
01:24:30,600 --> 01:24:33,300
So you have to call time begin period, there's other stuff you have to

1897
01:24:33,300 --> 01:24:33,700
do.

1898
01:24:33,900 --> 01:24:37,500
So we'll look at that a little later, but it's not as easy as just

1899
01:24:37,500 --> 01:24:38,200
calling sleep.

1900
01:24:38,200 --> 01:24:41,300
I guess is what I would say, you got to do sleep and a spin lock, and

1901
01:24:41,300 --> 01:24:44,500
you got to tell windows that your sleep is most likely granular.

1902
01:24:49,700 --> 01:24:51,300
Let's see.

1903
01:24:57,200 --> 01:25:00,800
Isn't already TSE affected by variable speed Technologies in modern

1904
01:25:00,800 --> 01:25:02,400
processors like speed step.

1905
01:25:03,300 --> 01:25:05,500
So it depends what you mean by affected.

1906
01:25:05,800 --> 01:25:09,100
It's sort of is and sort of isn't like.

1907
01:25:09,100 --> 01:25:12,000
It depends what the what you were trying to get out of it.

1908
01:25:14,600 --> 01:25:18,700
So yes, the answer is definitely affected but and I think I talked

1909
01:25:18,700 --> 01:25:21,200
about that when I was talking about the fact that there was like all

1910
01:25:21,200 --> 01:25:24,800
sorts of things where like, it could change the in the middle of when

1911
01:25:24,800 --> 01:25:27,800
you retire me something could change the CPU frequency and stuff like

1912
01:25:27,800 --> 01:25:27,900
that.

1913
01:25:27,900 --> 01:25:29,300
That's what I was talking about.

1914
01:25:29,900 --> 01:25:35,500
Unfortunately again, I'm the wrong person to really say how that all

1915
01:25:35,500 --> 01:25:36,500
works out.

1916
01:25:37,200 --> 01:25:41,400
So like for example for all I know in a in in the latest CPUs, they

1917
01:25:41,400 --> 01:25:44,300
may do stuff like pretend the R&D team.

1918
01:25:44,400 --> 01:25:49,100
SC is always at 3.2, GHz, even if the processor down flat.

1919
01:25:49,100 --> 01:25:50,800
Like, I don't know what they do.

1920
01:25:50,800 --> 01:25:51,100
Now.

1921
01:25:51,100 --> 01:25:51,900
I have no idea.

1922
01:25:53,100 --> 01:25:55,600
All I know is what it says in the Intel architecture manual.

1923
01:25:55,600 --> 01:25:57,400
So, all I know is what it says here.

1924
01:25:59,300 --> 01:26:03,000
I don't know anything that's not in here.

1925
01:26:03,400 --> 01:26:06,800
So if you really want that answer and this is maybe we'll be lucky and

1926
01:26:06,800 --> 01:26:10,200
Tom Forsythe, since he piped up in the twitch chat.

1927
01:26:10,200 --> 01:26:11,000
Maybe on the hook.

1928
01:26:11,000 --> 01:26:14,200
Now you want to ask a processor expert?

1929
01:26:14,300 --> 01:26:17,800
To tell you exactly what happens there because I don't know.

1930
01:26:17,800 --> 01:26:24,600
And I don't pretend to know, I use our dtsc as a high, a high

1931
01:26:24,600 --> 01:26:29,500
frequency profiler tool because I know that I can use differences in

1932
01:26:29,500 --> 01:26:31,500
it to know if my code was getting faster.

1933
01:26:31,800 --> 01:26:33,700
I don't try to use it.

1934
01:26:34,300 --> 01:26:38,000
Most of the time for doing the kind of really precise optimization

1935
01:26:38,000 --> 01:26:41,800
work where I actually want to know how many actual Cycles really

1936
01:26:41,800 --> 01:26:42,400
happened.

1937
01:26:42,800 --> 01:26:43,500
I don't do that.

1938
01:26:43,500 --> 01:26:44,200
So I'm

1939
01:26:44,300 --> 01:26:48,900
I've never had to really go figure out on a modern like on a core i7.

1940
01:26:48,900 --> 01:26:51,100
Let's say what that actually means.

1941
01:26:55,400 --> 01:26:57,000
Have I done lu?

1942
01:26:57,000 --> 01:26:59,300
Damned ra no, I have not.

1943
01:26:59,400 --> 01:26:59,800
It's

1944
01:27:00,200 --> 01:27:02,600
And no, I probably would not be doing that.

1945
01:27:05,200 --> 01:27:06,700
Let's see.

1946
01:27:08,900 --> 01:27:11,000
Let's see here.

1947
01:27:11,100 --> 01:27:13,000
Can we do a bonus stream on azzam?

1948
01:27:13,700 --> 01:27:16,300
We will actually be doing Assembly Language in the Stream.

1949
01:27:16,300 --> 01:27:19,400
As far as intrinsics are concerned will be optimizing our code with

1950
01:27:19,400 --> 01:27:20,100
intrinsics.

1951
01:27:20,800 --> 01:27:23,100
And as I'm stream again much.

1952
01:27:23,100 --> 01:27:27,000
Like I'm the wrong person to tell you about exactly how CPU Cycles.

1953
01:27:27,000 --> 01:27:28,600
Get retired and reported.

1954
01:27:28,900 --> 01:27:31,800
I'm also the wrong person to tell you how to program Assembly

1955
01:27:31,800 --> 01:27:32,400
Language.

1956
01:27:32,700 --> 01:27:33,600
I like

1957
01:27:35,600 --> 01:27:40,100
I understood Xbox 360 Assembly Language extremely well because I wrote

1958
01:27:40,100 --> 01:27:42,200
an assembler Optimizer for it.

1959
01:27:42,800 --> 01:27:44,800
That is like the only Assembly Language.

1960
01:27:44,800 --> 01:27:46,400
I really know how to program at all.

1961
01:27:47,000 --> 01:27:51,200
Like I know how to read x86 and x64 Assembly Language because I need

1962
01:27:51,200 --> 01:27:53,800
it for debugging and I need it for like looking at what the compiler

1963
01:27:53,800 --> 01:27:54,400
did.

1964
01:27:54,600 --> 01:27:56,000
So I can sort of read it.

1965
01:27:56,000 --> 01:28:02,200
Okay, but I just I don't have the kind of experience that I would want

1966
01:28:02,200 --> 01:28:05,300
to have before I would sit up here and try to tell you how to program.

1967
01:28:05,500 --> 01:28:09,100
Exit for Assembly Language, so I would love it.

1968
01:28:09,100 --> 01:28:13,500
If someone like Jeff Roberts did a Assembly Language, programming

1969
01:28:13,500 --> 01:28:14,000
extreme.

1970
01:28:14,600 --> 01:28:18,600
I don't know if he would, probably won't, but like, I would love it if

1971
01:28:18,600 --> 01:28:21,500
someone who is a Assembly Language, programmer, who did a lot of

1972
01:28:21,500 --> 01:28:21,800
civilians.

1973
01:28:21,800 --> 01:28:25,600
Programming programming would do one, that would be fantastic and I

1974
01:28:25,600 --> 01:28:29,000
would watch that stream, probably learn a lot from it, but I'm just

1975
01:28:29,000 --> 01:28:33,100
the wrong for assembly from scratch is just not, I don't have the

1976
01:28:33,100 --> 01:28:35,300
experience for that and I it would just be

1977
01:28:35,400 --> 01:28:39,700
Be, it would not be a good quality education for anyone.

1978
01:28:45,700 --> 01:28:47,500
Let's see.

1979
01:28:52,700 --> 01:28:56,100
If you read the latency tables for sse2, float versus double, you'll

1980
01:28:56,100 --> 01:28:56,400
see that.

1981
01:28:56,400 --> 01:29:00,100
Double isn't that much slower than float on the CB it's half as fast,

1982
01:29:00,100 --> 01:29:00,600
dude.

1983
01:29:02,100 --> 01:29:05,500
You can do twice as many floats in a register, as you can doubles.

1984
01:29:07,000 --> 01:29:08,600
What, what are you talking about?

1985
01:29:08,900 --> 01:29:10,300
I'm not sure what he's talking about.

1986
01:29:10,400 --> 01:29:12,000
I'll look at the agner fog tables.

1987
01:29:13,000 --> 01:29:15,200
You're talking about that these tables, right?

1988
01:29:16,400 --> 01:29:17,700
We're let's see here.

1989
01:29:17,900 --> 01:29:18,900
This is ogner.

1990
01:29:18,900 --> 01:29:21,100
The, this is ogner fog.

1991
01:29:21,100 --> 01:29:23,600
He's a guy who posts a lot of good optimization stuff.

1992
01:29:23,600 --> 01:29:28,800
He does like performance analysis, on x86 64 processors any basically

1993
01:29:28,800 --> 01:29:32,700
post a bunch of these things here, you can see like for example,

1994
01:29:32,700 --> 01:29:35,400
there's instruction tables list of instruction latency through puts

1995
01:29:35,400 --> 01:29:36,600
and stuff and Mike.

1996
01:29:36,700 --> 01:29:37,400
Prop break down.

1997
01:29:37,400 --> 01:29:43,000
So you can jump in here and see, you know, basically, a bunch of

1998
01:29:43,000 --> 01:29:45,600
information that's not in the architecture reference manual.

1999
01:29:46,600 --> 01:29:50,000
So, you know, if you go through here, you can find, I guess those

2000
01:29:50,000 --> 01:29:51,100
would be in the P.

2001
01:29:51,800 --> 01:29:55,000
I don't remember what the double instructions are that these would be

2002
01:29:55,000 --> 01:29:57,500
in down in the pee, pee Moe.

2003
01:29:57,600 --> 01:29:58,400
So, there you go.

2004
01:30:00,100 --> 01:30:03,500
So yeah, I mean, basically, let's see here.

2005
01:30:03,500 --> 01:30:06,500
So is it actually reciprocal throughput?

2006
01:30:07,600 --> 01:30:09,000
Let's see here.

2007
01:30:09,400 --> 01:30:10,800
What are the instructions we want?

2008
01:30:10,800 --> 01:30:11,900
So that was what was that?

2009
01:30:11,900 --> 01:30:13,700
That was a divide?

2010
01:30:13,700 --> 01:30:18,300
So you're saying that the floating-point Divide should be the same

2011
01:30:18,300 --> 01:30:23,900
speed as you think it's it's the same speed as the floating or not the

2012
01:30:23,900 --> 01:30:29,100
same speed but roughly the same speed as the double with divided.

2013
01:30:29,100 --> 01:30:29,900
So let's take a look.

2014
01:30:30,000 --> 01:30:30,400
Look here.

2015
01:30:30,400 --> 01:30:33,600
Where is our P reciprocal?

2016
01:30:33,600 --> 01:30:35,600
Well, I guess we can look at multiply first.

2017
01:30:36,300 --> 01:30:38,400
So, where is our multiply?

2018
01:30:38,400 --> 01:30:44,200
It's like p-muls something soapy mall.

2019
01:30:45,600 --> 01:30:48,600
Where are you?

2020
01:30:49,100 --> 01:30:49,700
Let's move.

2021
01:30:50,300 --> 01:30:50,800
I can't.

2022
01:30:51,300 --> 01:30:52,000
There we go.

2023
01:30:53,300 --> 01:30:54,700
So, where are we here?

2024
01:30:54,700 --> 01:30:55,400
That's not.

2025
01:30:55,400 --> 01:30:56,700
That's, that's the integer.

2026
01:30:56,800 --> 01:30:58,500
You can tell the last thing I did was Bink.

2027
01:30:58,500 --> 01:30:59,300
I immediately go.

2028
01:30:59,300 --> 01:30:59,900
Look at the

2029
01:31:00,000 --> 01:31:02,800
Jury instructions, which are totally not what you actually wanted.

2030
01:31:04,300 --> 01:31:05,200
Let's see here.

2031
01:31:06,300 --> 01:31:07,600
Let's see here.

2032
01:31:08,100 --> 01:31:11,100
Sorry, we're kind of the stream is technically over at this point, but

2033
01:31:11,100 --> 01:31:12,300
it's interesting question.

2034
01:31:12,400 --> 01:31:13,000
You might as well.

2035
01:31:13,000 --> 01:31:19,000
Look it up here and see what the actual what the actual stuff is

2036
01:31:19,600 --> 01:31:22,400
instruction set for SSE.

2037
01:31:23,700 --> 01:31:25,400
What are the actual things here?

2038
01:31:26,300 --> 01:31:27,500
Those are packed integer?

2039
01:31:27,500 --> 01:31:28,000
What is do?

2040
01:31:28,000 --> 01:31:29,100
You know what the instruction is?

2041
01:31:29,300 --> 01:31:29,700
Tell me what the

2042
01:31:29,900 --> 01:31:31,000
Reduction is for double.

2043
01:31:31,900 --> 01:31:34,600
If someone on the stream, knows what the multiply instruction is for

2044
01:31:34,600 --> 01:31:35,000
double.

2045
01:31:35,200 --> 01:31:39,100
So I can, I can look it up more quickly instead of having to look it

2046
01:31:39,100 --> 01:31:41,100
up on the stream here because I don't know.

2047
01:31:41,100 --> 01:31:43,800
I don't think I've ever actually admitted that I've never asked for

2048
01:31:43,800 --> 01:31:45,700
that intrinsic in my in my whole life.

2049
01:31:46,000 --> 01:31:48,900
So I have no idea what the what the where it actually is.

2050
01:31:51,600 --> 01:31:53,200
Do do, do do.

2051
01:31:57,300 --> 01:31:58,800
Yeah, what is it?

2052
01:31:59,000 --> 01:32:00,400
Tell me who on the stream.

2053
01:32:00,400 --> 01:32:04,000
Someone must know what the intrinsic is, what the actual instruction

2054
01:32:04,000 --> 01:32:12,100
is for doing a double multiply a CMD + S es e double multiply here.

2055
01:32:12,100 --> 01:32:12,800
Oh, here we go.

2056
01:32:12,800 --> 01:32:13,500
Well, PD.

2057
01:32:13,500 --> 01:32:14,100
There we go.

2058
01:32:14,500 --> 01:32:15,200
I don't know why.

2059
01:32:15,300 --> 01:32:18,200
So, I'm used to using all the pssc ones because I have to do a bunch

2060
01:32:18,200 --> 01:32:20,800
of integer work when I was working on pink and that was the most

2061
01:32:20,800 --> 01:32:22,500
recent SEC thing that I did.

2062
01:32:22,800 --> 01:32:23,300
So, here we go.

2063
01:32:23,300 --> 01:32:23,500
So,

2064
01:32:24,200 --> 01:32:26,600
PS Mo PD, that's what we want.

2065
01:32:26,600 --> 01:32:29,100
So packed, single Precision floating Point values.

2066
01:32:29,200 --> 01:32:32,700
Pack double-precision floating-point values from 0, PS and mole PD.

2067
01:32:32,800 --> 01:32:36,700
So now, if we look those up in the table, presumably, these are still

2068
01:32:36,700 --> 01:32:38,600
at alphabetical order.

2069
01:32:38,800 --> 01:32:40,400
No, they are not in alphabetical order.

2070
01:32:40,400 --> 01:32:42,400
They are by type.

2071
01:32:42,900 --> 01:32:43,600
So let's see.

2072
01:32:43,600 --> 01:32:46,800
Arithmetic instructions, other floating point.

2073
01:32:46,800 --> 01:32:47,800
There we go.

2074
01:32:49,300 --> 01:32:52,300
Floating-point xmm instructions.

2075
01:32:52,300 --> 01:32:53,800
Where is our Mall?

2076
01:32:54,300 --> 01:32:55,400
Where you know what?

2077
01:32:55,400 --> 01:32:56,500
Maybe I'll just search for it.

2078
01:32:56,500 --> 01:32:58,900
Well PS, there we go.

2079
01:32:58,900 --> 01:32:59,800
So mopey.

2080
01:33:00,100 --> 01:33:02,300
S, this is on an AMD.

2081
01:33:02,300 --> 01:33:04,700
So that's probably not so good.

2082
01:33:05,300 --> 01:33:11,300
Where is whereas x64 ck8 K10.

2083
01:33:14,400 --> 01:33:18,900
Bulldozer Steamroller Bobcat Jaguar.

2084
01:33:19,500 --> 01:33:23,300
Pentium 2 & 3 are on God.

2085
01:33:24,500 --> 01:33:26,400
Ivy Bridge, there we go.

2086
01:33:26,600 --> 01:33:29,100
Let's look at look at like has well, for example, that's a good one.

2087
01:33:29,300 --> 01:33:31,100
So these are just basically all the cores.

2088
01:33:31,300 --> 01:33:31,700
Sorry.

2089
01:33:31,700 --> 01:33:35,300
This is, this is probably not that interesting to most of the people

2090
01:33:35,300 --> 01:33:35,700
on the stream.

2091
01:33:35,700 --> 01:33:37,900
But basically all we're doing here is we're looking up in the

2092
01:33:37,900 --> 01:33:39,900
instruction tables which takes a while.

2093
01:33:40,200 --> 01:33:45,100
We're looking up, how long it takes the CPU to do operation on a

2094
01:33:45,100 --> 01:33:49,500
double versus operation on a single floating point.

2095
01:33:49,700 --> 01:33:53,700
So basically like 32 bit floating Point versus 64-bit floating-point,

2096
01:33:53,700 --> 01:33:54,200
so,

2097
01:33:54,300 --> 01:33:57,700
These are broken down by core because obviously Intel ships a lot of

2098
01:33:57,700 --> 01:33:59,300
different versions of their CPUs.

2099
01:33:59,400 --> 01:34:04,000
So there's basically, if you think about it, there's basically lots of

2100
01:34:04,000 --> 01:34:06,600
different potential throughput values.

2101
01:34:06,600 --> 01:34:09,400
How fast the processor can do something, depending on which processor,

2102
01:34:09,400 --> 01:34:10,200
it actually is.

2103
01:34:10,600 --> 01:34:14,700
So what we want to do here is we want to take a particular core, a

2104
01:34:14,700 --> 01:34:17,400
relatively recent court like Ivy Bridge, right?

2105
01:34:17,400 --> 01:34:22,100
Which is a, you know, relatively recent Intel Core and take a look at

2106
01:34:22,100 --> 01:34:24,000
how it does a mul PS.

2107
01:34:24,300 --> 01:34:27,600
Which is a single Precision floating Point X versus a mole PD.

2108
01:34:28,300 --> 01:34:31,800
So basically what I want to do is I want to search down through here.

2109
01:34:31,800 --> 01:34:33,900
So presumably it's somewhere right here.

2110
01:34:34,700 --> 01:34:40,800
That's has well, why can't we see Mo PS MLPs mole?

2111
01:34:40,800 --> 01:34:44,800
PS mul p.s.

2112
01:34:44,800 --> 01:34:47,500
I don't know why I can't see it because I'm searching for mul PS.

2113
01:34:47,500 --> 01:34:48,400
And this is where it is.

2114
01:34:48,600 --> 01:34:49,400
For some reason.

2115
01:34:49,500 --> 01:34:50,800
It says it's there.

2116
01:34:51,200 --> 01:34:54,100
I can't actually see a mole PS there, right?

2117
01:34:54,400 --> 01:34:57,500
It's supposed to be showing on the page right now, but where I don't

2118
01:34:57,500 --> 01:35:00,400
seem oh PS anywhere on here.

2119
01:35:01,500 --> 01:35:03,000
So let's take a look more PS.

2120
01:35:03,000 --> 01:35:04,900
MLPs Mi PS.

2121
01:35:05,200 --> 01:35:06,200
Mopey.

2122
01:35:06,600 --> 01:35:07,200
S.

2123
01:35:08,000 --> 01:35:08,300
Okay.

2124
01:35:08,300 --> 01:35:09,100
Ivy Bridge.

2125
01:35:09,300 --> 01:35:10,400
Mul PS.

2126
01:35:10,700 --> 01:35:13,700
So it's one it's single cycle.

2127
01:35:14,400 --> 01:35:15,200
Is that correct?

2128
01:35:16,400 --> 01:35:21,100
Single cycle and mole PD and what's this single?

2129
01:35:21,100 --> 01:35:21,300
Wait?

2130
01:35:21,300 --> 01:35:21,700
What's this?

2131
01:35:21,700 --> 01:35:22,600
What's this column here?

2132
01:35:22,600 --> 01:35:23,300
Where it's our home?

2133
01:35:23,300 --> 01:35:24,500
S, what's, what are our columns?

2134
01:35:24,500 --> 01:35:24,900
Here?

2135
01:35:25,300 --> 01:35:26,300
The latency?

2136
01:35:26,400 --> 01:35:28,900
So if you want to do one in reciprocal, throughput is here.

2137
01:35:28,900 --> 01:35:30,300
Okay, so that's what we want to see.

2138
01:35:30,700 --> 01:35:35,400
So basically the latency is from when we issue the instruction to,

2139
01:35:35,400 --> 01:35:36,300
when we get it back.

2140
01:35:36,300 --> 01:35:37,500
How many cycles will it be?

2141
01:35:37,600 --> 01:35:40,800
So if we issue one, when do we get the result back and reciprocal?

2142
01:35:40,800 --> 01:35:44,700
Throughput is basically how long it takes to get them.

2143
01:35:45,000 --> 01:35:46,000
If how

2144
01:35:48,300 --> 01:35:49,100
How should I say it?

2145
01:35:49,600 --> 01:35:52,000
It's basically if we issue them every clock.

2146
01:35:52,000 --> 01:35:56,300
So if we just kept issuing them one right after the other, then sort

2147
01:35:56,300 --> 01:35:59,200
of how long would it take to do each incremental one.

2148
01:35:59,500 --> 01:35:59,700
So,

2149
01:36:00,000 --> 01:36:04,300
Like, if we, if we took, if it takes a latency of 5 to do it, but we

2150
01:36:04,300 --> 01:36:05,100
can issue one.

2151
01:36:05,100 --> 01:36:08,800
Every clock will start getting them back every clock that we issue.

2152
01:36:09,200 --> 01:36:13,500
So we could still have a, it's essentially an effective throughput of

2153
01:36:13,500 --> 01:36:14,000
one.

2154
01:36:14,200 --> 01:36:18,500
Even though we technically have to wait five for any given results

2155
01:36:18,500 --> 01:36:19,200
come back.

2156
01:36:19,300 --> 01:36:23,000
We haven't talked about that that has to do with CPU pipelining and so

2157
01:36:23,000 --> 01:36:25,900
that's a kind of a thing that we haven't gotten to yet.

2158
01:36:26,000 --> 01:36:29,800
But anyway, it looks like mul PS here, takes its a five Cycles.

2159
01:36:30,000 --> 01:36:35,200
Latency that looks like and a one cycle, throughput and mull.

2160
01:36:35,200 --> 01:36:37,300
PD is exactly the same.

2161
01:36:37,300 --> 01:36:37,900
Right?

2162
01:36:37,900 --> 01:36:39,800
So, basically, it's exactly what I said.

2163
01:36:39,800 --> 01:36:42,100
It's half as fast, right?

2164
01:36:42,500 --> 01:36:45,900
So I said it was half as fast and it's half as fast.

2165
01:36:47,300 --> 01:36:49,500
So I don't know, whatever the person who run the twitch chat is, I'm

2166
01:36:49,500 --> 01:36:51,900
not sure why you were saying that, it wasn't massively slower.

2167
01:36:51,900 --> 01:36:57,300
It's half as fast to do doubles as it is to do to do singles.

2168
01:36:57,500 --> 01:36:59,200
So, if half is fast, doesn't bother you.

2169
01:36:59,200 --> 01:36:59,600
I don't know.

2170
01:36:59,600 --> 01:37:01,900
What does that's like the difference between 60 frames a second and 30

2171
01:37:01,900 --> 01:37:02,700
frames a second, right?

2172
01:37:02,700 --> 01:37:06,500
That's, that's massive, but I don't know.

2173
01:37:07,300 --> 01:37:07,800
Alright.

2174
01:37:09,600 --> 01:37:12,900
Alright, so there we go.

2175
01:37:13,200 --> 01:37:13,600
Let's see.

2176
01:37:13,600 --> 01:37:16,200
We're still, you know what, it's kind of a lazy day and we kind of had

2177
01:37:16,300 --> 01:37:16,700
a

2178
01:37:16,800 --> 01:37:18,000
I'm going to keep going on the questions.

2179
01:37:18,000 --> 01:37:18,700
Why not?

2180
01:37:19,100 --> 01:37:20,000
Let's take a look.

2181
01:37:20,200 --> 01:37:21,200
What are your thoughts on Swift?

2182
01:37:21,200 --> 01:37:22,100
I've never seen it.

2183
01:37:22,600 --> 01:37:24,800
I mean, I know what it is, but I've never seen it, but I think of drop

2184
01:37:24,800 --> 01:37:26,200
them flows, programming language.

2185
01:37:26,300 --> 01:37:27,600
I think it's awesome so far.

2186
01:37:27,900 --> 01:37:32,500
I really like just to see when he actually gets something that that

2187
01:37:32,600 --> 01:37:33,700
he's willing to release.

2188
01:37:34,100 --> 01:37:35,700
I will be playing around with it.

2189
01:37:37,800 --> 01:37:46,000
Let's see what I think I should you do to try to be linked up.

2190
01:37:46,000 --> 01:37:46,900
Org.

2191
01:37:46,900 --> 01:37:49,400
I don't know what dealing dot or is but I can certainly look at it.

2192
01:37:51,000 --> 01:37:53,000
Do you have any discussions with Jonathan bonus compiler?

2193
01:37:53,000 --> 01:37:54,100
And what sort of features you'd like to see?

2194
01:37:54,100 --> 01:37:57,300
Yes, we discussed it all the time, but he and I don't have similar

2195
01:37:57,300 --> 01:37:58,800
programming Styles in some ways.

2196
01:37:58,800 --> 01:37:59,300
So

2197
01:38:00,200 --> 01:38:06,800
You know, I tell him we talked about sort of things and I you know,

2198
01:38:06,800 --> 01:38:08,500
sort of tell him what the tortoise, I would like.

2199
01:38:08,500 --> 01:38:10,200
And we also go over sort of stuff that he would like.

2200
01:38:10,200 --> 01:38:13,800
And so we definitely talked about it a lot but he has different goals

2201
01:38:13,800 --> 01:38:14,900
for language necessarily in mind.

2202
01:38:14,900 --> 01:38:17,000
Then sort of where I would necessarily go if I was doing a language,

2203
01:38:17,000 --> 01:38:19,500
so I try not to push him.

2204
01:38:19,500 --> 01:38:22,600
I don't I don't want to make his language into something.

2205
01:38:22,600 --> 01:38:26,300
That is what I would want, see necessary to language because you can't

2206
01:38:26,300 --> 01:38:29,000
make one language that does everything thing and he's going for a very

2207
01:38:29,000 --> 01:38:29,800
specific thing and I think

2208
01:38:30,000 --> 01:38:31,300
He's doing a really good job at that.

2209
01:38:31,300 --> 01:38:34,400
And so usually when we talk about it, it's less about me saying what I

2210
01:38:34,400 --> 01:38:38,000
would like to see in his language and more about brainstorming stuff

2211
01:38:38,200 --> 01:38:40,300
about how to accomplish, what he's trying to accomplish in the

2212
01:38:40,300 --> 01:38:40,900
language.

2213
01:38:41,000 --> 01:38:44,400
Because I would like to see that language be the best at that because

2214
01:38:44,400 --> 01:38:46,100
we do definitely need that as well.

2215
01:38:46,300 --> 01:38:49,900
And so I'm interested in seeing his language, go, where he wants it to

2216
01:38:49,900 --> 01:38:52,600
go, not where I want to go, if that makes sense.

2217
01:38:57,400 --> 01:38:58,400
Let's see.

2218
01:39:00,000 --> 01:39:02,800
Do I ever write functions like printf to take very large it sometimes

2219
01:39:03,200 --> 01:39:05,900
but usually only they're usually debugging functions.

2220
01:39:07,900 --> 01:39:10,700
Would you consider using a templated type safe version of printf?

2221
01:39:10,800 --> 01:39:11,600
Even though you hate templates?

2222
01:39:11,600 --> 01:39:15,900
No, templates are never worth the pain in my opinion.

2223
01:39:16,200 --> 01:39:17,500
So no matter what they do.

2224
01:39:17,500 --> 01:39:18,900
I wouldn't probably use them.

2225
01:39:21,200 --> 01:39:22,800
Let's see.

2226
01:39:22,800 --> 01:39:24,900
Let's take a look here.

2227
01:39:27,300 --> 01:39:31,200
If there is one book, you would, if it's half as fast, only, if you do

2228
01:39:31,200 --> 01:39:32,400
millions of operations.

2229
01:39:32,400 --> 01:39:33,500
Now, it's half as fast.

2230
01:39:33,500 --> 01:39:36,600
As long as you do 5 or more, right?

2231
01:39:37,400 --> 01:39:40,300
Well, it's half as fast, no matter how many you do, because it's

2232
01:39:40,300 --> 01:39:41,600
exactly the same timing.

2233
01:39:41,600 --> 01:39:44,700
So if you do any, it's half as fast, right?

2234
01:39:45,200 --> 01:39:48,500
Whatever, the piece of code was, it's half as fast in in.

2235
01:39:49,900 --> 01:39:54,800
In in float, as long as you're doing for operations or more.

2236
01:39:54,900 --> 01:39:57,800
If you're long as you're doing it on four or more floats, it happens

2237
01:39:57,800 --> 01:39:58,300
fast.

2238
01:40:02,300 --> 01:40:06,800
Okay, what low-level language would you suggest to someone new to

2239
01:40:06,800 --> 01:40:07,800
low-level programming?

2240
01:40:07,900 --> 01:40:13,300
Well, I think C is usually the one that's why I'm using it in for this

2241
01:40:13,300 --> 01:40:13,700
stream.

2242
01:40:14,100 --> 01:40:15,400
Are we using the win32 API?

2243
01:40:15,400 --> 01:40:16,900
But compiling for 64 bits.

2244
01:40:17,000 --> 01:40:19,300
Do we need to compile for 32 bits for when XP support.

2245
01:40:19,300 --> 01:40:22,000
And it looks like we have in 64 and real 64 in the CBP.

2246
01:40:22,400 --> 01:40:25,400
So, yes, we do need to compile for 32 bits for the next 50 support,

2247
01:40:25,400 --> 01:40:26,800
and we will be doing that.

2248
01:40:27,200 --> 01:40:30,000
But no, you don't have to worry about in 64 is in real 64's.

2249
01:40:30,300 --> 01:40:32,800
Those both work on 32-bit Windows as well.

2250
01:40:32,800 --> 01:40:33,800
They're just slower.

2251
01:40:35,000 --> 01:40:41,400
So as long as we don't use hardly any of those, we will be fine.

2252
01:40:41,600 --> 01:40:45,500
As long as we don't use in 64, is in real, 64 is being super critical

2253
01:40:45,500 --> 01:40:47,300
code, then we'll be fine.

2254
01:40:51,600 --> 01:40:52,500
In game development.

2255
01:40:52,500 --> 01:40:55,900
Do you follow Enterprise design patterns or do you have some different

2256
01:40:55,900 --> 01:40:57,000
design patterns?

2257
01:40:58,700 --> 01:41:02,800
No, we do not follow Enterprise design patterns, may be some people

2258
01:41:02,800 --> 01:41:03,600
game developers do.

2259
01:41:03,600 --> 01:41:06,100
I certainly don't follow any Enterprise design patterns?

2260
01:41:07,800 --> 01:41:08,600
Definitely not.

2261
01:41:09,200 --> 01:41:09,700
Sorry.

2262
01:41:10,300 --> 01:41:11,600
What do you use for collections?

2263
01:41:11,600 --> 01:41:15,700
If you do not use templates, I usually use just something hand coded

2264
01:41:15,700 --> 01:41:17,000
for whatever the situation is.

2265
01:41:19,900 --> 01:41:21,800
I didn't get the outcome of the mall PS.

2266
01:41:21,800 --> 01:41:24,000
Mopey dick a the latency packing was the same.

2267
01:41:24,000 --> 01:41:25,400
How does that end up being double time?

2268
01:41:25,500 --> 01:41:26,500
Okay, that's a good question.

2269
01:41:26,700 --> 01:41:28,700
I didn't really go into detail on this because it wasn't really, I

2270
01:41:28,700 --> 01:41:31,600
didn't really super wanna talk about it much because I was just trying

2271
01:41:31,600 --> 01:41:34,200
to make sure that the person who's writing in the twitch chat was, was

2272
01:41:35,000 --> 01:41:39,300
not correct about it, but basically because I want to correct what I

2273
01:41:39,300 --> 01:41:43,200
said if it was, but basically what I'm saying here is there's two

2274
01:41:43,200 --> 01:41:44,000
commands.

2275
01:41:45,500 --> 01:41:46,400
That you can issue.

2276
01:41:46,900 --> 01:41:48,900
Well, PS and multi D.

2277
01:41:49,000 --> 01:41:49,500
Okay.

2278
01:41:50,100 --> 01:41:55,100
Both of these commands take five Cycles to return, right?

2279
01:41:55,100 --> 01:41:58,900
So five Cycles to complete and they have one cycle throughput so you

2280
01:41:58,900 --> 01:41:59,800
can basically

2281
01:42:00,300 --> 01:42:04,800
Issue them every clock and get them back, five clocks later.

2282
01:42:05,000 --> 01:42:07,200
And so you can essentially do one per cycle.

2283
01:42:07,500 --> 01:42:08,800
If you get up to speed.

2284
01:42:08,800 --> 01:42:11,400
But we don't actually care about that at the moment.

2285
01:42:11,400 --> 01:42:14,100
And we're not going to talk about that much for purposes of what

2286
01:42:14,100 --> 01:42:14,900
you're asking.

2287
01:42:15,000 --> 01:42:19,100
All we need to know is both mul PS and mold PD have exactly the same

2288
01:42:19,100 --> 01:42:22,300
specified timings in the timing tables.

2289
01:42:22,500 --> 01:42:25,800
So, if you execute them all PS or you execute them all PD.

2290
01:42:26,000 --> 01:42:28,600
It's basically the same, right?

2291
01:42:29,500 --> 01:42:29,800
The

2292
01:42:30,000 --> 01:42:30,400
Timing.

2293
01:42:31,000 --> 01:42:34,800
So, the reason I said, it's half as fast to use doubles, which is this

2294
01:42:34,800 --> 01:42:34,900
one.

2295
01:42:34,900 --> 01:42:36,300
This is real 64.

2296
01:42:36,700 --> 01:42:38,000
And this is real 32.

2297
01:42:38,300 --> 01:42:41,900
The reason it's half as fast is these instructions are the same with

2298
01:42:42,400 --> 01:42:50,300
both instructions, operate on 128, bits worth of data, basically, and

2299
01:42:50,300 --> 01:42:57,400
128 bits /, 32 bits, right for a real 32 means you can pack for real

2300
01:42:57,400 --> 01:42:59,500
32s into

2301
01:43:00,000 --> 01:43:02,100
And register, right?

2302
01:43:02,100 --> 01:43:06,000
So basically mole PS operates on for real 32s.

2303
01:43:06,000 --> 01:43:07,000
At the same time.

2304
01:43:07,000 --> 01:43:12,200
If you call Mal PS, you can do for floating Point operation for two

2305
01:43:12,200 --> 01:43:13,200
floating Point multiplies.

2306
01:43:13,300 --> 01:43:16,600
At the same time, real 64's on the other hand.

2307
01:43:16,600 --> 01:43:20,300
It's still operating on 128 bits, but now you're dividing by 64 bit.

2308
01:43:20,300 --> 01:43:24,600
So you only have two real 64's that can fit into one register.

2309
01:43:25,100 --> 01:43:28,200
So, what I was saying is that if you're doing anything at all, like,

2310
01:43:28,200 --> 01:43:29,500
basically, if you're doing

2311
01:43:29,900 --> 01:43:34,700
Any more than three operations?

2312
01:43:35,900 --> 01:43:40,400
Then doubles are half as fast because basically, as long as you can do

2313
01:43:41,000 --> 01:43:46,100
for four of them at once, you will get twice the speed because this

2314
01:43:46,100 --> 01:43:48,300
instruction takes the same amount of time as this instruction, but

2315
01:43:48,300 --> 01:43:53,900
does twice as many multiplies, so hopefully that makes some sense.

2316
01:43:57,900 --> 01:43:59,000
Let's see.

2317
01:44:04,900 --> 01:44:05,700
Due to do.

2318
01:44:05,800 --> 01:44:08,900
So you say someone says was saying in the Stream, if you're ready some

2319
01:44:08,900 --> 01:44:09,600
because then you care.

2320
01:44:09,600 --> 01:44:11,700
Otherwise, you don't and what you're writing is not same D.

2321
01:44:11,700 --> 01:44:13,100
So no, that's not true.

2322
01:44:13,400 --> 01:44:18,800
So yes, this particular very specific example, may not be Cindy.

2323
01:44:19,100 --> 01:44:22,200
But literally the thing we will use it for is totally Cindy.

2324
01:44:22,300 --> 01:44:25,900
You will have a bunch of cycle counts from all the different places in

2325
01:44:25,900 --> 01:44:29,100
your program that you sample the performance counter, you will then

2326
01:44:29,100 --> 01:44:31,500
need to do a bunch of subtracts on them.

2327
01:44:31,700 --> 01:44:34,600
You will then need to do a bunch of divides on them.

2328
01:44:34,900 --> 01:44:37,800
You will are multiplied as on them or in stripper clothes on them and

2329
01:44:37,800 --> 01:44:41,200
you can do all of those completely Cindy because they're exactly the

2330
01:44:41,200 --> 01:44:42,300
same operations.

2331
01:44:42,500 --> 01:44:47,500
So no, this will be totally symbolized and it will be totally slower

2332
01:44:47,600 --> 01:44:48,800
if you decide to use doubles.

2333
01:44:49,000 --> 01:44:52,800
Now if I'm totally fine with someone saying that you won't have enough

2334
01:44:52,800 --> 01:44:58,100
of these to care about the fact that it's slower, but it is half as

2335
01:44:58,100 --> 01:44:58,700
fast.

2336
01:44:58,900 --> 01:44:59,500
That's just

2337
01:45:00,100 --> 01:45:01,300
That's just the truth.

2338
01:45:01,900 --> 01:45:06,600
So whenever you write code like this, unless it's literally, the only

2339
01:45:06,600 --> 01:45:10,200
time you think you will ever do it, which for performance profiling,

2340
01:45:10,200 --> 01:45:14,100
we know it won't be, will be taking hundreds of samples of our dtsc

2341
01:45:14,200 --> 01:45:16,600
and not maybe hundreds of the query performance counter, but will at

2342
01:45:16,600 --> 01:45:19,200
least be taking hundreds of our dtsc samples per frame.

2343
01:45:20,400 --> 01:45:23,200
So, if you're going to then do operations on them, if you can move it

2344
01:45:23,200 --> 01:45:28,800
down to 32-bit, those operations will be twice as fast period, but if

2345
01:45:28,800 --> 01:45:32,200
you don't care if you're like, I don't care how fast that is.

2346
01:45:32,300 --> 01:45:36,000
I just want to do it in 64-bit and I know since that we're only doing

2347
01:45:36,000 --> 01:45:37,400
like a hundred operations.

2348
01:45:37,700 --> 01:45:41,000
Maybe that doesn't matter because 100 isn't that many in processor

2349
01:45:41,000 --> 01:45:41,400
terms.

2350
01:45:41,600 --> 01:45:42,400
That's fine.

2351
01:45:42,500 --> 01:45:46,400
But understand the difference between saying you don't care and saying

2352
01:45:46,400 --> 01:45:49,600
it's not faster because those are different statements.

2353
01:45:52,500 --> 01:45:53,400
Let's see.

2354
01:45:59,700 --> 01:46:00,400
Yes, msv.

2355
01:46:00,400 --> 01:46:04,200
See, will often not pack things without intrinsics for you

2356
01:46:04,500 --> 01:46:05,100
potentially.

2357
01:46:05,100 --> 01:46:07,500
No, actually, I missed VC does have a way of doing that automatically

2358
01:46:07,500 --> 01:46:11,200
for if you want to, but yes, we will do all of our own intrinsics for

2359
01:46:11,200 --> 01:46:16,000
all of our own floating Point operations because it's just usually

2360
01:46:16,000 --> 01:46:17,100
easier to explicitly.

2361
01:46:17,100 --> 01:46:20,300
Tell the compiler, how you would like to do packed instructions, but

2362
01:46:20,300 --> 01:46:21,400
no both llvm.

2363
01:46:21,900 --> 01:46:25,200
Well, I should say, I have experience with lvm doing this.

2364
01:46:25,200 --> 01:46:28,800
I don't know about msec, but I believe it also does this.

2365
01:46:29,300 --> 01:46:32,300
You can Auto vectorize a loop just fine.

2366
01:46:32,400 --> 01:46:35,100
You don't have to msec, will totally output it for you.

2367
01:46:36,300 --> 01:46:36,500
At least.

2368
01:46:36,500 --> 01:46:37,400
That was my assumption.

2369
01:46:37,500 --> 01:46:39,500
I know llvm will llvm.

2370
01:46:39,500 --> 01:46:40,600
Will trivially output it for you.

2371
01:46:40,600 --> 01:46:42,500
You can just say that this thing is vectorized and it'll tow.

2372
01:46:42,500 --> 01:46:44,100
It has Loop vectorization built-in.

2373
01:46:44,400 --> 01:46:46,000
So, it just totally does that.

2374
01:46:47,200 --> 01:46:49,100
So I'm not sure what you're saying that it won't output that it

2375
01:46:49,100 --> 01:46:52,500
totally does that, but that maybe I'm SVC is like behind the times on

2376
01:46:52,500 --> 01:46:54,400
that, but llvm is not.

2377
01:47:00,600 --> 01:47:03,900
And and saying that the compiler won't up output vectorized code for

2378
01:47:03,900 --> 01:47:05,200
this is also not true.

2379
01:47:05,200 --> 01:47:06,400
You just have to do more of them.

2380
01:47:06,600 --> 01:47:07,500
And it totally could.

2381
01:47:07,500 --> 01:47:08,400
It totally could do that.

2382
01:47:08,400 --> 01:47:09,500
It could totally vectorize this.

2383
01:47:09,500 --> 01:47:13,400
If we were, if we had say, 20 performance counters, and we wanted to

2384
01:47:13,400 --> 01:47:13,900
vectorize them.

2385
01:47:13,900 --> 01:47:16,500
You could totally have llvm Auto vectorize the loop for you.

2386
01:47:16,600 --> 01:47:18,800
That's not, that's not hot at all or IPC.

2387
01:47:18,800 --> 01:47:19,800
If you were using that.

2388
01:47:20,000 --> 01:47:22,300
I don't know about msec because I don't use them as we see a whole lot

2389
01:47:22,300 --> 01:47:22,900
these days.

2390
01:47:23,100 --> 01:47:25,300
So whether msec will output it, I'm not sure.

2391
01:47:25,300 --> 01:47:26,400
I thought they had Auto V.

2392
01:47:26,600 --> 01:47:30,400
Relation msec, but maybe they don't because mstc does kind of tend to

2393
01:47:30,400 --> 01:47:34,100
lag behind but llvm will totally Auto vectorize that for you.

2394
01:47:36,800 --> 01:47:38,200
Let's take a look here.

2395
01:47:43,300 --> 01:47:47,600
And also Tom Forsythe, and Forsythe says, he has a rant on double

2396
01:47:47,600 --> 01:47:48,200
Precision.

2397
01:47:48,600 --> 01:47:50,600
So let's take a look at that since it's right in the Stream here.

2398
01:47:50,600 --> 01:47:51,400
Let's take a look.

2399
01:47:51,400 --> 01:47:54,500
He says it is at HTTP.

2400
01:47:55,100 --> 01:47:55,800
See here.

2401
01:47:55,800 --> 01:47:59,800
I'm going to try to decode this URL, 5T bah.

2402
01:48:00,300 --> 01:48:01,800
He posted this in the Stream.

2403
01:48:04,200 --> 01:48:07,900
This webpage is not available, Tom.

2404
01:48:09,400 --> 01:48:10,200
What's going on here?

2405
01:48:10,200 --> 01:48:10,700
Okay, there we go.

2406
01:48:10,700 --> 01:48:11,100
It's got to.

2407
01:48:11,100 --> 01:48:11,400
Okay.

2408
01:48:11,500 --> 01:48:12,500
So here is the link.

2409
01:48:12,500 --> 01:48:13,600
You can read it off here.

2410
01:48:14,700 --> 01:48:18,900
And here is his rant on double Precision.

2411
01:48:18,900 --> 01:48:20,400
So I don't know what it is.

2412
01:48:20,900 --> 01:48:21,700
Basically.

2413
01:48:23,000 --> 01:48:25,400
I don't know exactly what he's ranting about.

2414
01:48:25,400 --> 01:48:28,800
But Tom usually has interesting things to say, so if you want to read

2415
01:48:28,800 --> 01:48:30,500
about it all but certain I will go read it later.

2416
01:48:31,000 --> 01:48:31,700
Here it is.

2417
01:48:31,800 --> 01:48:33,600
I'll leave that up on the screen for people who want it.

2418
01:48:36,500 --> 01:48:37,300
Will we take msv?

2419
01:48:37,300 --> 01:48:41,000
See all the way to shipping or will you use llvm even on Windows?

2420
01:48:41,600 --> 01:48:44,700
I would already just be using llvm for everything.

2421
01:48:44,700 --> 01:48:48,100
If you could actually use it on Windows, but right now they haven't

2422
01:48:48,100 --> 01:48:50,300
gotten to the point where you really can.

2423
01:48:51,400 --> 01:48:54,000
Basically, if you want to use llvm on Windows right now.

2424
01:48:54,000 --> 01:48:57,600
You have to switch to using a GDB base to bugger, like a dwarf base to

2425
01:48:57,600 --> 01:49:01,100
bugger and the like QT Creator or something like that.

2426
01:49:01,100 --> 01:49:04,200
And those are worse than M sbc's debugger and stuff.

2427
01:49:04,200 --> 01:49:04,600
And

2428
01:49:05,600 --> 01:49:07,800
Basically, like what I would say is.

2429
01:49:09,300 --> 01:49:13,000
If llvm was at the point where I could ship Windows stuff with it, I

2430
01:49:13,000 --> 01:49:14,300
already would be doing that.

2431
01:49:14,300 --> 01:49:15,100
There would be no msv.

2432
01:49:15,100 --> 01:49:17,400
See in the picture, but it's not quite there yet.

2433
01:49:17,700 --> 01:49:19,400
Believe me, the day that it is.

2434
01:49:19,400 --> 01:49:19,900
There.

2435
01:49:19,900 --> 01:49:23,900
I am off M, SV C so fast because I don't like em SVC at all.

2436
01:49:23,900 --> 01:49:28,000
I have no interest in using it, but it's tool chain is more mature on

2437
01:49:28,000 --> 01:49:28,600
Windows.

2438
01:49:28,800 --> 01:49:32,600
And so I have to sort of stay on that on windows, for a number of

2439
01:49:32,600 --> 01:49:37,700
reasons, but when they get to the point, when you can have a totally

2440
01:49:37,700 --> 01:49:39,000
good experience using elevators,

2441
01:49:39,100 --> 01:49:42,100
On Windows, I am totally switching.

2442
01:49:42,100 --> 01:49:45,400
So yeah, if they did that in the middle of handmade hero, we just

2443
01:49:45,400 --> 01:49:45,500
read.

2444
01:49:45,500 --> 01:49:48,200
Go ahead and switch for sure, but I don't think they're going to have

2445
01:49:48,200 --> 01:49:51,100
that ready in the next year or so.

2446
01:49:51,100 --> 01:49:52,400
Maybe, you know, if we're lucky.

2447
01:49:52,400 --> 01:49:53,500
I know there's people working on it.

2448
01:49:53,500 --> 01:49:53,800
So

2449
01:49:54,900 --> 01:49:56,500
and you can, I mean, you can't actually do it.

2450
01:49:56,500 --> 01:49:58,500
You can't compile Windows code with llvm.

2451
01:49:58,500 --> 01:50:00,200
There's just a bunch of caveats, basically.

2452
01:50:04,700 --> 01:50:05,800
What's an intrinsic?

2453
01:50:05,800 --> 01:50:10,600
So an intrinsic such a thing that we will be looking at later that

2454
01:50:10,600 --> 01:50:11,200
basically is.

2455
01:50:11,200 --> 01:50:12,300
So we kind of again.

2456
01:50:12,300 --> 01:50:13,400
This is jumping the gun a bit.

2457
01:50:13,400 --> 01:50:15,200
But since we're kind of at we're way past time.

2458
01:50:15,200 --> 01:50:17,700
Now, we're just kind of having fun on the stream and I like having fun

2459
01:50:17,700 --> 01:50:18,200
on the stream.

2460
01:50:18,900 --> 01:50:23,700
Basically, an intrinsic is just something that tells the compiler.

2461
01:50:24,300 --> 01:50:28,000
It's it's something that looks like a function call.

2462
01:50:29,300 --> 01:50:31,300
And in fact, we've already used one this one.

2463
01:50:32,100 --> 01:50:35,600
It's something that looks like you're calling a function, but actually

2464
01:50:35,600 --> 01:50:36,100
what it is.

2465
01:50:36,100 --> 01:50:39,100
It's a hint to the compiler that what you want it to do is apply a

2466
01:50:39,100 --> 01:50:42,100
specific Assembly Language instruction.

2467
01:50:42,900 --> 01:50:44,500
And so we can sort of see how that works.

2468
01:50:44,500 --> 01:50:46,100
Like this looks like a function call, right?

2469
01:50:46,100 --> 01:50:48,800
It looks like we're calling a function called our dtsc and that

2470
01:50:48,800 --> 01:50:50,700
function is returning and cycle count.

2471
01:50:50,900 --> 01:50:53,800
But if you actually step into the call, right?

2472
01:50:55,000 --> 01:50:58,000
Right here and take a look at the Assembly Language.

2473
01:50:58,000 --> 01:50:58,800
That was generated.

2474
01:50:58,800 --> 01:50:59,800
You will notice that.

2475
01:51:00,000 --> 01:51:03,500
No, actual function call has been generated instead.

2476
01:51:03,500 --> 01:51:06,500
What's generated is a straight-up are TTC.

2477
01:51:07,500 --> 01:51:08,100
Pretty awesome.

2478
01:51:08,100 --> 01:51:08,700
Right.

2479
01:51:10,000 --> 01:51:14,300
So basically, an intrinsic is a thing that allows you to direct the

2480
01:51:14,300 --> 01:51:18,900
compiler to do a certain thing in Assembly Language that it can emit

2481
01:51:18,900 --> 01:51:22,500
directly in line that it doesn't have to think about a function called

2482
01:51:22,500 --> 01:51:24,700
or C programming or any of that stuff.

2483
01:51:24,700 --> 01:51:27,800
It can just know, okay, wants me to get the time stamp counter here.

2484
01:51:28,000 --> 01:51:30,000
I know how to do that directly on the CPU.

2485
01:51:30,000 --> 01:51:30,900
I'm just going to do it.

2486
01:51:30,900 --> 01:51:33,100
Right and that's what that is.

2487
01:51:33,300 --> 01:51:37,200
So the reason we were talking about them for Cindy is because see

2488
01:51:37,400 --> 01:51:42,800
Unfortunately was designed a long time before this concept of Cindy.

2489
01:51:42,900 --> 01:51:47,000
Cindy is for people who don't know, and we'll talk about this more

2490
01:51:47,000 --> 01:51:47,500
later.

2491
01:51:47,900 --> 01:51:54,200
But Cindy is basically an acronym simd.

2492
01:51:54,200 --> 01:51:58,500
It stands for single instruction comma.

2493
01:51:58,600 --> 01:52:04,100
If you will multiple data, and what it basically means is normally,

2494
01:52:04,100 --> 01:52:06,900
when CPUs were first created, they typically did.

2495
01:52:07,300 --> 01:52:09,300
Nations on one thing.

2496
01:52:09,500 --> 01:52:15,400
So if I say something like this and I then go Z equals x times y,

2497
01:52:15,500 --> 01:52:18,500
write this kind of a thing makes sense.

2498
01:52:19,300 --> 01:52:22,300
I expect to see some code outputted.

2499
01:52:22,800 --> 01:52:28,000
That is just going to do a multiply that says multiply X by y, right.

2500
01:52:28,200 --> 01:52:32,600
So there's one piece of data in Acts 1 piece of data in why I multiply

2501
01:52:32,600 --> 01:52:34,000
the two together and I get Z.

2502
01:52:34,000 --> 01:52:36,800
So it's single instruction single data, instant.

2503
01:52:38,100 --> 01:52:41,400
But modern processors have found that.

2504
01:52:41,400 --> 01:52:45,100
It's much more efficient because of the way instructions are encoded.

2505
01:52:45,200 --> 01:52:50,200
And so that it can, it can know basically because you tend to do

2506
01:52:50,300 --> 01:52:53,900
expensive things, you know, the expensive parts of your code, tend to

2507
01:52:53,900 --> 01:52:55,800
work on big batches of stuff.

2508
01:52:55,800 --> 01:52:59,000
Lots of pixels, lots of vertices that sort of thing.

2509
01:53:00,400 --> 01:53:03,800
It tends to be that you want to do the same instruction to a lot of

2510
01:53:03,800 --> 01:53:06,700
things at once, you want to multiply a lot of values, by a lot of

2511
01:53:06,700 --> 01:53:07,600
other values.

2512
01:53:07,900 --> 01:53:08,800
In a batch.

2513
01:53:09,200 --> 01:53:12,200
So you don't have to actually issue as many instructions.

2514
01:53:12,200 --> 01:53:13,800
If the processor gives you way to say.

2515
01:53:13,800 --> 01:53:16,600
Hey, look, I'm going to say one instruction, and I want you to

2516
01:53:16,600 --> 01:53:20,700
multiply these 16 things by these other 16 things just do them all

2517
01:53:20,700 --> 01:53:21,500
with one multiply.

2518
01:53:21,500 --> 01:53:24,900
So I can just basically load 16 things into register, 16 things to

2519
01:53:24,900 --> 01:53:25,500
another register.

2520
01:53:25,500 --> 01:53:26,600
That's really wide.

2521
01:53:26,700 --> 01:53:31,600
They're very wide registers, 128 bits, 26 bits, 512 bits, right?

2522
01:53:33,000 --> 01:53:37,100
Pack a bunch of different values into those registers for floating

2523
01:53:37,100 --> 01:53:37,800
Point values.

2524
01:53:37,800 --> 01:53:38,800
8 floating Point values.

2525
01:53:38,800 --> 01:53:41,200
16 floating Point values in one register.

2526
01:53:41,500 --> 01:53:44,400
So that when I say multiply this register, by this other register,

2527
01:53:44,600 --> 01:53:48,600
it's not just doing one multiply it's effectively doing.

2528
01:53:50,000 --> 01:53:52,300
For multiplies a multiplies 60 multiplies at a time.

2529
01:53:52,600 --> 01:53:55,600
So it saves on the instruction encoding and it saves on the

2530
01:53:55,600 --> 01:53:58,600
understanding of the logic that the processor has to do, but it could

2531
01:53:58,600 --> 01:53:59,800
do a lot more multiplier.

2532
01:54:00,100 --> 01:54:01,700
You're basically the arithmetic unit.

2533
01:54:01,700 --> 01:54:05,100
The thing that's doing the actual multiplies in the processor can be

2534
01:54:05,100 --> 01:54:07,700
this huge wide giant multiplier.

2535
01:54:07,700 --> 01:54:12,400
That does, you know, tons of multiplies in parallel and the the logic

2536
01:54:12,400 --> 01:54:14,300
that's actually driving can be very simple, just goes.

2537
01:54:14,300 --> 01:54:17,800
Okay, we're doing a x 60 multipliers go instead of having to go.

2538
01:54:17,900 --> 01:54:19,300
Okay, grab the two things.

2539
01:54:19,300 --> 01:54:23,100
Do a multiply grab the two things to multiply 16 times, right?

2540
01:54:24,300 --> 01:54:27,500
So what Cindy is is Cindy is that that concept that there's a single

2541
01:54:27,500 --> 01:54:29,400
instruction that operates on multiple data.

2542
01:54:30,000 --> 01:54:32,500
Multiple things at once and does a symmetric the same operation to

2543
01:54:32,500 --> 01:54:33,700
each of those pieces of data.

2544
01:54:33,800 --> 01:54:37,400
And so typically what it corresponds to is wide registers, registers

2545
01:54:37,600 --> 01:54:39,200
that you have one name for.

2546
01:54:39,300 --> 01:54:42,700
So I call this register, something XM, M, 0, or something.

2547
01:54:42,700 --> 01:54:46,100
I have one name to the register, but actually that register is

2548
01:54:46,100 --> 01:54:50,000
separated into buckets that contain multiple discrete 32-bit

2549
01:54:50,000 --> 01:54:51,000
floating-point values.

2550
01:54:51,600 --> 01:54:55,500
Now, the reason this up impacts are floating point in double situation

2551
01:54:55,600 --> 01:54:59,000
is because obviously, you can fit twice as many floats into the same

2552
01:54:59,000 --> 01:54:59,900
space as

2553
01:55:00,000 --> 01:55:00,500
I have doubles.

2554
01:55:00,500 --> 01:55:01,900
I'm gonna fit for doubles in something.

2555
01:55:01,900 --> 01:55:03,800
I can fit eight floats in there.

2556
01:55:04,500 --> 01:55:08,300
So if you're doing Cindy and assembly instructions, all took the same

2557
01:55:08,300 --> 01:55:11,200
amount of time, which as we saw, they did in the case of multiply,

2558
01:55:11,800 --> 01:55:15,000
then doing it in doubles, is half as fast as doing it in singles,

2559
01:55:15,000 --> 01:55:17,600
because you can only do half as many doubles you going to fit, have

2560
01:55:17,600 --> 01:55:18,900
some a doubles in the register.

2561
01:55:20,200 --> 01:55:21,100
Hopefully, that makes some sense.

2562
01:55:24,600 --> 01:55:25,600
Yeah, that's a good point.

2563
01:55:25,900 --> 01:55:27,500
So somebody was reminding us.

2564
01:55:27,700 --> 01:55:33,000
We stucco to in here to ask for optimized build and what we should

2565
01:55:33,000 --> 01:55:35,700
probably do is switch back to that because we're not, we're not doing

2566
01:55:35,700 --> 01:55:36,400
optimization yet.

2567
01:55:36,400 --> 01:55:39,700
So, we'd rather have a debug build because debug builds are easier to

2568
01:55:39,700 --> 01:55:40,800
understand and read.

2569
01:55:41,500 --> 01:55:45,300
Basically, they're easier to look at because the compiler hasn't

2570
01:55:45,300 --> 01:55:48,900
rearranged everything and smushed instructions and optimize things

2571
01:55:48,900 --> 01:55:49,300
out.

2572
01:55:49,400 --> 01:55:52,700
So when we're trying to learn, it's much better to work in debug mode

2573
01:55:52,900 --> 01:55:53,900
where the processor doesn't.

2574
01:55:54,100 --> 01:55:57,200
Actually, doing a better job the optimizer off so that we can see

2575
01:55:57,200 --> 01:55:58,100
everything explicitly.

2576
01:55:58,900 --> 01:56:01,000
All right, we're running up into the end of the stream here.

2577
01:56:01,000 --> 01:56:04,800
So last couple questions, isn't it?

2578
01:56:04,800 --> 01:56:05,800
A pain to work in Windows?

2579
01:56:05,800 --> 01:56:06,500
Specially the programmer?

2580
01:56:06,600 --> 01:56:08,100
No more so than anywhere else.

2581
01:56:08,600 --> 01:56:13,400
I like working in Windows, actually, the best of any platform because

2582
01:56:13,400 --> 01:56:14,600
the debugger is the best.

2583
01:56:14,700 --> 01:56:16,000
It's the best of Bugger.

2584
01:56:17,100 --> 01:56:20,900
I like working on Linux because I don't have to fuss a lot with.

2585
01:56:20,900 --> 01:56:23,200
Like, I don't have to every time I install a machine.

2586
01:56:23,200 --> 01:56:23,900
I don't have to call.

2587
01:56:24,000 --> 01:56:27,000
All Microsoft for permission and you know have it authorized my

2588
01:56:27,000 --> 01:56:28,900
machine and all this other nonsense.

2589
01:56:29,800 --> 01:56:31,600
Like I don't have to deal with all of that stuff.

2590
01:56:31,800 --> 01:56:34,300
I don't have to do, all the weird installation process, the package,

2591
01:56:34,300 --> 01:56:36,600
managers and stuff online, explain X are really good, that sort of

2592
01:56:36,600 --> 01:56:37,000
stuff.

2593
01:56:37,500 --> 01:56:39,700
So there are things I like about Linux better.

2594
01:56:40,100 --> 01:56:43,100
But the debug the debuggers are awful on the next they're just they're

2595
01:56:43,100 --> 01:56:43,600
just awful.

2596
01:56:44,100 --> 01:56:47,000
And so I do like programming on Windows, probably the best because the

2597
01:56:47,000 --> 01:56:50,400
debugger is the best if and when people come out with a really good

2598
01:56:50,400 --> 01:56:53,500
debugger for Linux, then I think there's probably nothing really that

2599
01:56:53,500 --> 01:56:53,900
I like better.

2600
01:56:54,000 --> 01:56:56,700
Better on Windows anymore, but it's so it's not really a pain on

2601
01:56:56,700 --> 01:56:57,000
Windows.

2602
01:56:57,000 --> 01:56:57,900
No, it's fine.

2603
01:57:02,300 --> 01:57:04,000
Let's see here.

2604
01:57:05,700 --> 01:57:06,900
Didn't we want to start adding wordings?

2605
01:57:06,900 --> 01:57:08,100
Yes, probably Monday.

2606
01:57:08,100 --> 01:57:11,900
I think we'll turn on a higher warning, level, and, and talk about

2607
01:57:11,900 --> 01:57:12,600
what that means.

2608
01:57:12,600 --> 01:57:13,700
And and why we care.

2609
01:57:15,700 --> 01:57:16,700
Let's see.

2610
01:57:19,300 --> 01:57:24,900
I think that's about it for questions on the Stream.

2611
01:57:29,800 --> 01:57:32,200
Yeah, so it looks like that's it for questions on the stream.

2612
01:57:32,700 --> 01:57:37,000
So, thank you so much for joining us, for a nice lazy, handmade hero,

2613
01:57:37,000 --> 01:57:38,600
and Ice to our handmade hero.

2614
01:57:38,800 --> 01:57:40,400
Sometimes, it's fun to go.

2615
01:57:40,400 --> 01:57:42,700
A little bit long, when we have the time for it.

2616
01:57:43,500 --> 01:57:44,300
Thank you so much.

2617
01:57:44,300 --> 01:57:45,700
Everyone for joining me.

2618
01:57:46,000 --> 01:57:47,600
I know that we're at not the normal time.

2619
01:57:47,600 --> 01:57:50,500
So I feel like probably it's anyone.

2620
01:57:50,500 --> 01:57:52,900
Who's on the stream is a rather dedicated handmade here.

2621
01:57:52,900 --> 01:57:54,700
We're not at our normal 8 p.m.

2622
01:57:54,700 --> 01:57:58,500
Timeslot, this hopefully this weekend.

2623
01:57:58,500 --> 01:57:58,700
Again.

2624
01:57:58,700 --> 01:57:59,400
I keep saying hopefully.

2625
01:57:59,600 --> 01:58:01,700
But I haven't quite had time to really fully wrestle.

2626
01:58:01,700 --> 01:58:06,100
All the CSS web programming is so slow, in my opinion because of all

2627
01:58:06,100 --> 01:58:07,900
the, the wrangling try and get things to look.

2628
01:58:07,900 --> 01:58:10,200
Okay, when you're using other people's code and stuff.

2629
01:58:10,600 --> 01:58:12,500
So we're still on the email.

2630
01:58:12,500 --> 01:58:14,600
So if you want to email question, got an email in here that will be

2631
01:58:14,600 --> 01:58:17,700
changing to forums at just as soon as I could finish up the CSS

2632
01:58:17,700 --> 01:58:18,300
nonsense.

2633
01:58:19,300 --> 01:58:22,100
Again, if you would like to follow a home at the source code and the

2634
01:58:22,100 --> 01:58:24,900
art assets, as we, as we start to have them, if you'd like to

2635
01:58:24,900 --> 01:58:27,500
pre-order the game, you can pre-order it here and that gives you a

2636
01:58:27,500 --> 01:58:30,000
link where you can always download the latest source code and latest

2637
01:58:30,000 --> 01:58:30,600
art assets.

2638
01:58:30,600 --> 01:58:34,100
As we start to work with art assets coming next week and so on.

2639
01:58:34,900 --> 01:58:37,500
So handmade here a.org is your source for anything that you actually

2640
01:58:37,500 --> 01:58:37,700
need.

2641
01:58:37,700 --> 01:58:37,800
You.

2642
01:58:37,800 --> 01:58:40,400
Don't get the video archive and the Twitter where we where we post

2643
01:58:40,400 --> 01:58:41,400
times and stuff like that.

2644
01:58:41,900 --> 01:58:44,900
So check that out and otherwise, thank you very much address.

2645
01:58:44,900 --> 01:58:48,400
I hope to see you here for the next ring, which will be Monday at 8

2646
01:58:48,400 --> 01:58:48,900
p.m.

2647
01:58:49,100 --> 01:58:53,500
Pacific Standard Time, hope that you have enjoyed this dream and we

2648
01:58:53,500 --> 01:58:54,300
will see you then.

2649
01:58:54,300 --> 01:58:55,600
Thanks everyone for joining us.

