1
00:00:00,500 --> 00:00:01,300
Start recording.

2
00:00:01,700 --> 00:00:02,400
Hello everyone.

3
00:00:02,400 --> 00:00:03,700
And welcome to handmade hero.

4
00:00:03,700 --> 00:00:06,600
The show recoded complete game live on Twitch.

5
00:00:06,600 --> 00:00:07,800
No engines, no libraries.

6
00:00:07,800 --> 00:00:11,700
It's just us and our little typing fingers typing away.

7
00:00:11,800 --> 00:00:16,200
And right now we are typing on sound mixing, I guess to be a little

8
00:00:16,200 --> 00:00:16,900
more specific.

9
00:00:16,900 --> 00:00:19,600
We pretty much did all of the sound mixing stuff.

10
00:00:19,600 --> 00:00:22,500
We wanted to do preliminarily and we've got Sounds playing.

11
00:00:22,500 --> 00:00:23,400
Got some streaming.

12
00:00:23,400 --> 00:00:24,600
We got Pitch changes.

13
00:00:24,600 --> 00:00:28,600
We have volume ramping and painting stuff like that, but one of the

14
00:00:28,600 --> 00:00:30,100
things that I kind of wanted to do with

15
00:00:30,200 --> 00:00:33,800
Is just drop it down to be wide Vector.

16
00:00:33,800 --> 00:00:37,200
So it's, you know, I wanted to basically have it in Cindy like our

17
00:00:37,200 --> 00:00:41,400
render is just so we could see how that affects the architecture at

18
00:00:41,400 --> 00:00:45,800
all just to make sure that there's no sort of snafus in there because

19
00:00:45,800 --> 00:00:46,800
it's pretty simple to do.

20
00:00:46,800 --> 00:00:50,400
You know, it's not a huge ownerÃ­s undertaking, so I wanted to kind of

21
00:00:50,400 --> 00:00:53,100
do that maybe today and we don't have to go overboard with it.

22
00:00:53,100 --> 00:00:55,500
We're not even I'm not really even thinking about it as us.

23
00:00:55,500 --> 00:00:58,200
Optimizing the sound mix or anything like that.

24
00:00:58,200 --> 00:00:59,400
I'm just strictly.

25
00:00:59,400 --> 00:01:00,100
Want to make sure.

26
00:01:00,200 --> 00:01:03,300
Sure that, you know, if we decide to do for sample at a time wide

27
00:01:03,400 --> 00:01:05,500
version that it's all you know kosher.

28
00:01:05,500 --> 00:01:07,500
So I'm going to go ahead and do that.

29
00:01:07,500 --> 00:01:09,500
I think today just so we can get a feel for it.

30
00:01:09,700 --> 00:01:11,900
But before I do that, let me just mention that if you have

31
00:01:11,900 --> 00:01:16,300
pre-ordered, the game on handmade hero dot-org, you can download the

32
00:01:16,300 --> 00:01:19,900
source zip and today's day 144.

33
00:01:19,900 --> 00:01:24,200
So what you want to do is take one day 143 source code and unzip that

34
00:01:24,200 --> 00:01:27,600
into a directory because if you do that, then you will be exactly

35
00:01:27,600 --> 00:01:30,100
where I am right now and you can follow

36
00:01:30,300 --> 00:01:30,700
With me.

37
00:01:30,700 --> 00:01:33,700
So, you know, maybe that's something that you like to do.

38
00:01:33,700 --> 00:01:35,200
And if it is, that's what we're doing.

39
00:01:35,200 --> 00:01:41,200
So day, 143 sort, they 143 source, code is what you want to look at

40
00:01:41,200 --> 00:01:41,400
their.

41
00:01:41,400 --> 00:01:43,600
In fact, let me just make sure that I'm right about that.

42
00:01:43,600 --> 00:01:46,400
The machine kind of logged itself out the other day, said started up.

43
00:01:46,400 --> 00:01:49,100
Yes, 01:43 was the latest Source sip, so there you go.

44
00:01:50,200 --> 00:01:53,800
All right, so let's go over here to the sound code.

45
00:01:53,800 --> 00:01:58,600
We've got it kind of isolated in its own file and this is the entirety

46
00:01:58,600 --> 00:02:00,100
really of that sound code, right?

47
00:02:00,100 --> 00:02:04,000
But we're looking at here, it's this output playing sounds function

48
00:02:04,500 --> 00:02:08,000
and it really does pretty much all the stuff that we wanted it to do.

49
00:02:08,500 --> 00:02:12,200
You know, it's basically got everything in there for now and so what

50
00:02:12,200 --> 00:02:15,900
I'd like to do here is I'd like to just take a look at making this

51
00:02:16,400 --> 00:02:18,600
into some D now if you don't know what Cindy is.

52
00:02:20,800 --> 00:02:23,600
Or what SSE is, I apologize.

53
00:02:23,600 --> 00:02:26,600
I'm not going to explain it again because I already explained it in

54
00:02:26,600 --> 00:02:28,200
detail before when we did the render.

55
00:02:28,200 --> 00:02:32,600
So if you're if you didn't see that go back and watch that in the

56
00:02:32,600 --> 00:02:35,200
video, archive, the Cindy introduction.

57
00:02:35,200 --> 00:02:38,400
If you're lost with what we're doing here, go back and watch that.

58
00:02:38,400 --> 00:02:41,500
And I explained it in quite a bit of detail, so I'm not really going

59
00:02:41,500 --> 00:02:44,200
to mention anything other than brief refreshing stuff as we go through

60
00:02:44,200 --> 00:02:44,600
it.

61
00:02:45,100 --> 00:02:48,400
I'm just going to assume everyone seen that or we'll go and see that

62
00:02:48,400 --> 00:02:49,500
if they want to know.

63
00:02:49,900 --> 00:02:53,300
So, if we come into the render group, if you remember here is sort of

64
00:02:53,300 --> 00:02:56,500
all of our Cindy intrinsics that we were doing, right.

65
00:02:56,500 --> 00:02:59,900
And the big thing about me, Cindy intrinsics is in order to

66
00:03:00,000 --> 00:03:05,200
Leverage The Sim d-unit the CMD operations on the x64 processor, which

67
00:03:05,200 --> 00:03:08,900
is what we are writing our code for or the x86 in this case as well.

68
00:03:09,200 --> 00:03:14,800
We need to be able to process things in batches of at least four at

69
00:03:14,800 --> 00:03:15,500
once, right?

70
00:03:15,500 --> 00:03:19,000
We need to be able to do things in chunks of for.

71
00:03:19,000 --> 00:03:23,000
Now some of the stuff in here will be pretty straightforward for that,

72
00:03:23,000 --> 00:03:23,500
right?

73
00:03:23,800 --> 00:03:26,200
The other thing that we need to do is we need to make sure they're

74
00:03:26,200 --> 00:03:27,300
aligned, right?

75
00:03:27,300 --> 00:03:30,000
And we can work with unaligned data if we want to.

76
00:03:30,000 --> 00:03:36,300
Too, but usually it's better for us, not to forecast reasons anyway,

77
00:03:36,300 --> 00:03:39,300
and also sometimes it's faster to do aligned reads and writes and so

78
00:03:39,300 --> 00:03:39,900
on and so forth.

79
00:03:39,900 --> 00:03:45,100
So, what we probably want to do is we probably want to make sure that

80
00:03:45,100 --> 00:03:49,000
at the very least, our are temporary buffer, here is aligned to the

81
00:03:49,000 --> 00:03:50,100
way that we would want it to.

82
00:03:50,300 --> 00:03:53,000
And remember, we've already done some work to make sure that we can

83
00:03:53,000 --> 00:03:53,400
align it.

84
00:03:53,400 --> 00:03:57,800
So, if we want to do that Cindy alignment in line things to 16, bytes

85
00:03:57,800 --> 00:03:59,900
we actually can just go ahead and

86
00:04:00,000 --> 00:04:02,800
Tell our allocator that we needed 16 by the lines.

87
00:04:02,800 --> 00:04:05,200
We already did the work for that and it should be fine.

88
00:04:05,200 --> 00:04:07,500
And so, the first thing I'm going to do is take out the take this

89
00:04:07,500 --> 00:04:09,100
clear out the mixer channels thing.

90
00:04:10,300 --> 00:04:13,500
I'm going to go ahead and see if we can go ahead and make that four

91
00:04:13,500 --> 00:04:13,800
wide.

92
00:04:13,800 --> 00:04:16,899
So what I want to do is I want to say that that we're never going to

93
00:04:16,899 --> 00:04:20,899
ask for an output sample count, right?

94
00:04:21,100 --> 00:04:24,100
That is it going to be an even multiple of four?

95
00:04:24,100 --> 00:04:25,900
So I want to say ahead of time.

96
00:04:25,900 --> 00:04:32,500
Look, I'm just, I'm just expecting you to always give me a multiple of

97
00:04:32,500 --> 00:04:37,400
four samples, so we might have to go back into the platform layer and

98
00:04:37,400 --> 00:04:39,800
ensure that it always does something.

99
00:04:40,000 --> 00:04:41,300
To round it to that.

100
00:04:41,800 --> 00:04:44,300
So I'm going to put in assertion in here to force us to go do that

101
00:04:44,300 --> 00:04:44,600
work.

102
00:04:44,600 --> 00:04:45,400
Once we're ready.

103
00:04:49,600 --> 00:04:52,300
Now, I suppose now I think about it.

104
00:04:54,300 --> 00:04:57,800
As I'm saying that in my head actually I don't care about that at all.

105
00:04:58,700 --> 00:05:00,500
I thought I cared about that but I don't really.

106
00:05:00,800 --> 00:05:02,200
These are temporary buffers.

107
00:05:02,800 --> 00:05:06,400
So really what we could do is we could just say, you know what, we

108
00:05:06,400 --> 00:05:09,900
have a sound sample count and we really just need to make sure that

109
00:05:09,900 --> 00:05:13,600
the sound sample count can fit, all the samples in there, but we don't

110
00:05:13,600 --> 00:05:17,800
really care if we get went over, right, because when we copy out at

111
00:05:17,800 --> 00:05:20,300
the end to the 16-bit values, that's the only place we would have to

112
00:05:20,300 --> 00:05:21,100
care about that.

113
00:05:21,100 --> 00:05:23,500
Overhang for the for

114
00:05:24,100 --> 00:05:24,800
For examples.

115
00:05:25,000 --> 00:05:28,000
So what we could see here is we could you know we could go ahead and

116
00:05:28,000 --> 00:05:29,300
just round this to a power of 2.

117
00:05:29,300 --> 00:05:31,300
I don't know if we ever we probably should.

118
00:05:31,400 --> 00:05:34,200
This was confusing people a little bit because I just I tend to type

119
00:05:34,200 --> 00:05:37,600
this in because it's kind of second nature to me, a lot of the times.

120
00:05:38,600 --> 00:05:45,000
So I don't know if we have it, aligned call anywhere in here II.

121
00:05:45,000 --> 00:05:46,900
Don't think that we ever wrote one.

122
00:05:48,000 --> 00:05:50,600
So, okay so we have an aligned 16, right?

123
00:05:51,400 --> 00:05:52,400
And so what?

124
00:05:52,400 --> 00:05:53,900
What I think was confusing, people a little bit.

125
00:05:54,000 --> 00:05:57,200
It was this sort of Value Plus 15 and not 15 kind of stuff.

126
00:05:57,200 --> 00:05:59,800
And someone asked question on the forums, I explained it one time.

127
00:06:00,000 --> 00:06:03,100
Basically, it was just it was just saying that this is just saying,

128
00:06:03,300 --> 00:06:08,900
okay, I'm trying to round up always to the next nearest power of two.

129
00:06:09,900 --> 00:06:12,700
I'm sorry to the next nearest, multiple of some specific power of 2.

130
00:06:12,700 --> 00:06:13,900
And this case it was 16.

131
00:06:14,400 --> 00:06:17,900
And the easiest way to do that is to add 1 - the power of 2 and then

132
00:06:17,900 --> 00:06:21,400
knock out, all the bits that are below that power of 2 and explain

133
00:06:21,400 --> 00:06:22,500
that on the stream one time.

134
00:06:23,000 --> 00:06:25,700
But really, you can think of this as a fairly generic thing.

135
00:06:25,900 --> 00:06:29,900
You can think of a line in as like if you have a value and

136
00:06:30,000 --> 00:06:31,200
Alignment right.

137
00:06:34,100 --> 00:06:37,600
Something like this, like a line power to or something.

138
00:06:37,600 --> 00:06:37,900
I don't know.

139
00:06:37,900 --> 00:06:38,600
Something like this.

140
00:06:39,300 --> 00:06:41,800
You can imagine as long as alignment is a power of 2.

141
00:06:41,800 --> 00:06:44,700
You could actually write this macro to be completely generic, right?

142
00:06:45,000 --> 00:06:49,700
All you're trying to do is take that alignment and subtract one from

143
00:06:49,700 --> 00:06:50,600
it, right?

144
00:06:51,400 --> 00:06:56,800
And and that produces the right thing in both cases, right?

145
00:06:57,400 --> 00:07:00,500
So, you can actually round to any one that you want here.

146
00:07:01,000 --> 00:07:02,200
And I tend to like, to have

147
00:07:02,400 --> 00:07:06,000
Ones that are, you know just kind of the convenient ones that I tend

148
00:07:06,000 --> 00:07:06,700
to use.

149
00:07:07,200 --> 00:07:10,500
So I tend to do stuff like that but you can you can think about it if

150
00:07:10,500 --> 00:07:11,400
you want.

151
00:07:11,500 --> 00:07:17,000
You can think about these as just being a generic way of rounding as

152
00:07:17,000 --> 00:07:20,300
long as the thing you're trying to align to happens to be a power of

153
00:07:20,300 --> 00:07:20,500
2.

154
00:07:20,500 --> 00:07:21,200
This will work.

155
00:07:21,400 --> 00:07:24,400
If it's not a power of 2, this trick does not work and you have to do

156
00:07:24,400 --> 00:07:24,700
something.

157
00:07:24,700 --> 00:07:29,400
Smarter probably actually using a mod to get it to work, but I'm not

158
00:07:29,400 --> 00:07:30,700
sure there might be fancier tricks.

159
00:07:30,700 --> 00:07:32,200
There's there's some crazy.

160
00:07:32,300 --> 00:07:34,200
Chuck tricks out there that people have figured out.

161
00:07:34,400 --> 00:07:39,300
So you never know, anyway, so if I want to take this sample count and

162
00:07:39,300 --> 00:07:43,500
produce a, you know, like a sample count that's going to be aligned

163
00:07:43,500 --> 00:07:43,900
for

164
00:07:46,700 --> 00:07:47,400
To round that up.

165
00:07:47,400 --> 00:07:48,600
I can do that, right?

166
00:07:49,400 --> 00:07:52,100
So I can say, all right, I want to do a sample county line for and

167
00:07:52,100 --> 00:07:54,500
then I also want to do a sample account for which is basically going

168
00:07:54,500 --> 00:07:57,500
to be that divided by 4, right?

169
00:07:57,700 --> 00:08:00,600
In other words, I want to, I want to actually have one that's divided

170
00:08:00,600 --> 00:08:00,900
by 4.

171
00:08:00,900 --> 00:08:04,200
So that when I come in here, what I can actually do is make the

172
00:08:04,200 --> 00:08:08,000
channels actually DMM 128, right?

173
00:08:08,000 --> 00:08:11,700
So they're actually will just be packs of four of these things to

174
00:08:11,700 --> 00:08:13,000
begin with, okay?

175
00:08:13,900 --> 00:08:15,200
And so what I'm going to do here is

176
00:08:15,300 --> 00:08:20,000
That I want to allocate the, You Know, sample count divided by four of

177
00:08:20,000 --> 00:08:23,400
these and 11th, which of course each contain four.

178
00:08:23,500 --> 00:08:26,600
So that will give me room for my mix buffer, right?

179
00:08:27,400 --> 00:08:30,500
And then if I want to clear it right, I should be able to clear it.

180
00:08:30,500 --> 00:08:32,500
Pretty trivially in here.

181
00:08:32,500 --> 00:08:35,700
I should be able to say, okay I'm just going to walk through all of

182
00:08:35,700 --> 00:08:42,100
the values and I'm just going to, you know, use mmm, set, 1, PS to

183
00:08:42,200 --> 00:08:45,100
make something that's just replicated, a bunch of zeros.

184
00:08:45,200 --> 00:08:46,000
He's right.

185
00:08:46,300 --> 00:08:47,000
You know what I'm saying?

186
00:08:47,000 --> 00:08:48,400
Just just totally zero.

187
00:08:48,400 --> 00:08:54,000
Fact, I could just do this like so and just say all right, you know

188
00:08:54,000 --> 00:08:56,200
what, we've got a zero.

189
00:08:56,500 --> 00:08:59,600
And these guys are just going to be equal to 0, 's all the time.

190
00:09:01,700 --> 00:09:03,800
So that would that would do it, right?

191
00:09:03,800 --> 00:09:07,500
And of course, I only want to Loop over the sample count for version

192
00:09:07,500 --> 00:09:08,000
of it.

193
00:09:08,500 --> 00:09:10,500
That would clear all of my stuff out.

194
00:09:10,900 --> 00:09:13,600
Now, we have to do a little bit hips.

195
00:09:14,900 --> 00:09:18,200
We have to do a little bit here because these are still, you know,

196
00:09:18,200 --> 00:09:21,900
sort of working with them as if they are in 128 or sorry.

197
00:09:21,900 --> 00:09:23,100
This is this is still think of them.

198
00:09:23,100 --> 00:09:25,300
7/28 and this is going to be real.

199
00:09:25,300 --> 00:09:28,300
So I'm just going to cast it for now since that's free for me to do

200
00:09:28,500 --> 00:09:30,100
and let these guys work in there.

201
00:09:30,300 --> 00:09:33,700
Away, so that I can just test the clear 20 and make sure that that's

202
00:09:33,700 --> 00:09:35,700
working relatively well.

203
00:09:36,100 --> 00:09:37,200
So let's take a look.

204
00:09:38,800 --> 00:09:40,600
Yeah, so that's all good.

205
00:09:40,700 --> 00:09:41,600
No problems there.

206
00:09:49,000 --> 00:09:51,100
So the clear 20 looks fine.

207
00:09:51,500 --> 00:09:54,400
Let's go down now to the to the bottom.

208
00:09:55,000 --> 00:09:57,500
And let's take a look at the conversion, right?

209
00:10:00,400 --> 00:10:02,200
And we have a clamp in here as well.

210
00:10:03,300 --> 00:10:06,400
So we actually had a little to do that was like hey remember to go

211
00:10:06,400 --> 00:10:07,500
ahead and clamp these guys.

212
00:10:07,800 --> 00:10:13,800
So what I want to do for clamping those guys is I would like to sort

213
00:10:13,800 --> 00:10:16,400
of make some clamping information here, right?

214
00:10:16,400 --> 00:10:23,800
So something like Max 16-bit or Max sign, 16-bit, and Min sign 16-bit

215
00:10:23,800 --> 00:10:24,800
or something like this.

216
00:10:26,700 --> 00:10:29,300
Maybe Mass Max s 16.

217
00:10:29,500 --> 00:10:32,500
Min s 16 something like that so that

218
00:10:32,700 --> 00:10:34,100
Can put that clamp in as well.

219
00:10:34,400 --> 00:10:38,500
So what I want to do here is I want to set these guys, to be the

220
00:10:38,500 --> 00:10:42,600
floating point because remember, all of this mixing is taking place in

221
00:10:42,600 --> 00:10:46,600
floating point, but it's taking place in floating Point versions of

222
00:10:46,600 --> 00:10:47,700
16-bit values.

223
00:10:47,700 --> 00:10:50,600
So basically, we're not even converting room in the renderer, we

224
00:10:50,600 --> 00:10:54,200
convert all our stuff to the 0 to 1 range or well, I guess, we even

225
00:10:54,200 --> 00:10:57,300
change that to start working in 0 to 255 in a bunch of places.

226
00:10:57,600 --> 00:11:00,600
We're doing that same 02:55 kind of thing here where we're letting it

227
00:11:00,600 --> 00:11:02,500
run from - 32k to positive 3.

228
00:11:02,600 --> 00:11:03,900
82 K, right?

229
00:11:04,400 --> 00:11:10,800
We're letting that actually take care of the mixing in that range

230
00:11:10,800 --> 00:11:13,100
instead of trying to bring things back to the 0 to 1 range because we

231
00:11:13,100 --> 00:11:16,200
don't really have any reason why we need to bring things back from 0

232
00:11:16,200 --> 00:11:17,000
to 1 range.

233
00:11:17,400 --> 00:11:22,300
So when we talk about clamping of the values, what we want to do is

234
00:11:22,300 --> 00:11:26,000
clamp them in six, we're clamping especially as 16-bit values, even

235
00:11:26,000 --> 00:11:26,900
though they're stored is float.

236
00:11:26,900 --> 00:11:28,100
So we want to produce some floats.

237
00:11:28,100 --> 00:11:32,100
That would be the maximum and minimum sign 16-valve.

238
00:11:32,600 --> 00:11:33,800
Use if that makes sense.

239
00:11:34,800 --> 00:11:38,600
And so I'm trying to think of what the easiest way is to get those.

240
00:11:39,500 --> 00:11:44,000
I mean really, it's just, I mean, I don't know.

241
00:11:44,400 --> 00:11:48,100
I'm thinking maybe the easiest way to do it would be to say like oh

242
00:11:48,100 --> 00:11:53,600
I've got it, I've got an s 16 of, you know, of that, right.

243
00:11:53,600 --> 00:11:55,100
That would be the minimum.

244
00:11:55,800 --> 00:11:58,700
And then I've got a Nexus teen of that that would be the maximum,

245
00:11:58,700 --> 00:11:59,300
right?

246
00:12:00,000 --> 00:12:03,300
I think that would probably give me what I wanted, but let's since

247
00:12:03,300 --> 00:12:04,600
we've never done anything like this.

248
00:12:04,600 --> 00:12:07,100
Let's let's let's do this first.

249
00:12:07,100 --> 00:12:09,200
Let me just see.

250
00:12:10,900 --> 00:12:13,800
Let's do it this way, just so you guys can see what I'm talking about

251
00:12:13,800 --> 00:12:14,800
here, right?

252
00:12:17,200 --> 00:12:17,800
There we go.

253
00:12:23,100 --> 00:12:25,400
Okay let's see.

254
00:12:25,600 --> 00:12:29,800
So can I actually make it do this?

255
00:12:29,800 --> 00:12:30,800
I don't think I can.

256
00:12:31,800 --> 00:12:38,600
Yeah, well I tried I tried and I unfortunately failed, I kind of just

257
00:12:38,600 --> 00:12:44,000
wanted it to look at these guys and do them as if they were, you know

258
00:12:44,000 --> 00:12:46,800
about 16 to tell you so I could force it.

259
00:12:47,000 --> 00:12:49,700
Look at the Min and the max without me actually having to do anything.

260
00:12:49,700 --> 00:12:51,400
But it doesn't look like that in the car.

261
00:12:51,400 --> 00:12:54,200
Unless I just am thinking about this slightly wrong.

262
00:12:56,000 --> 00:12:58,000
Basically, what I'm saying is, let's let me

263
00:13:00,600 --> 00:13:02,700
Comment these out, I'll show you what I mean.

264
00:13:03,900 --> 00:13:04,200
Okay.

265
00:13:05,900 --> 00:13:11,600
So, if I go into the sound mixer here, or if I just, I can go anywhere

266
00:13:11,600 --> 00:13:12,100
right?

267
00:13:12,600 --> 00:13:13,200
Like so.

268
00:13:14,300 --> 00:13:20,900
So if you know, I, if I take something and I want an F-16 value,

269
00:13:20,900 --> 00:13:21,200
right?

270
00:13:21,200 --> 00:13:25,600
I want a, you know, a short value.

271
00:13:26,700 --> 00:13:35,200
If I was to take the 65536 / to hear something like,

272
00:13:35,400 --> 00:13:43,000
As you can see in hexadecimal, see if that's not quite the highest.

273
00:13:43,500 --> 00:13:44,300
Why are you not?

274
00:13:44,300 --> 00:13:49,100
I want the highest value because I actually typed a to buy.

275
00:13:49,100 --> 00:13:50,200
Exactly, exactly.

276
00:13:50,400 --> 00:13:50,600
All right.

277
00:13:50,600 --> 00:13:52,500
Do that 65536.

278
00:13:53,100 --> 00:13:55,900
So, if I actually type the the

279
00:13:57,900 --> 00:13:59,400
The highest value there, right?

280
00:13:59,400 --> 00:14:02,100
That I could actually get in practice.

281
00:14:03,400 --> 00:14:04,200
Oh, that's what?

282
00:14:04,200 --> 00:14:06,300
Oh, okay.

283
00:14:08,000 --> 00:14:09,100
I just typed that wrong.

284
00:14:10,100 --> 00:14:10,600
There we go.

285
00:14:12,000 --> 00:14:16,500
So if I actually get the highest value that you can fit and I guess

286
00:14:16,500 --> 00:14:19,100
what I could do is I can also show this in binary so you can see it.

287
00:14:19,800 --> 00:14:23,700
If I wanted to get the highest value, I could possibly fit in a 16-bit

288
00:14:23,700 --> 00:14:24,100
value.

289
00:14:24,100 --> 00:14:28,100
It's going to be all of the, you know, all of the binary places are

290
00:14:28,100 --> 00:14:31,400
going to be set to one except for the final one, right?

291
00:14:31,400 --> 00:14:35,300
Because if you're talking about a signed value, then as you get, when

292
00:14:35,300 --> 00:14:36,700
once that top bit,

293
00:14:36,800 --> 00:14:42,200
It flips, 21 your value is now assigned value a negative value, right?

294
00:14:42,300 --> 00:14:45,000
So this is the maximum value actually could produce.

295
00:14:45,500 --> 00:14:49,000
So what I wanted to do right was I wanted to to make it so I could do

296
00:14:49,000 --> 00:14:52,200
7ff, I wanted to make it so that that would be the device.

297
00:14:52,200 --> 00:14:53,700
So I think that would actually work now.

298
00:14:53,700 --> 00:14:53,900
Yes.

299
00:14:53,900 --> 00:14:57,600
So I just I just that was just a stupid mistake on my part so it was

300
00:14:57,600 --> 00:14:57,900
fine.

301
00:14:58,200 --> 00:14:59,800
So if you want to make the minimum value, we

302
00:15:00,000 --> 00:15:04,700
Make it that way, making the maximum value what I actually want to do.

303
00:15:05,100 --> 00:15:07,400
Yeah, II don't actually want to do it that way.

304
00:15:07,400 --> 00:15:09,500
I don't even know why I typed it that way to begin with.

305
00:15:09,500 --> 00:15:10,800
I guess it's just a bad.

306
00:15:11,000 --> 00:15:13,400
I'm just a oops.

307
00:15:13,400 --> 00:15:15,100
Sorry, that's not the main.

308
00:15:15,200 --> 00:15:18,800
That's the max well man brains fried today.

309
00:15:18,800 --> 00:15:20,600
I don't know why I'm thinking so slowly.

310
00:15:20,600 --> 00:15:23,300
It's kind of one of those days where I don't know the brains just

311
00:15:23,300 --> 00:15:23,800
foggy.

312
00:15:24,300 --> 00:15:28,600
Anyway so yeah the maximum value which we just showed like this,

313
00:15:28,600 --> 00:15:29,200
right?

314
00:15:29,600 --> 00:15:29,900
If

315
00:15:30,000 --> 00:15:32,500
If I, if I look at that without the binary on, right?

316
00:15:32,500 --> 00:15:34,900
Then that's the seven, f f f, right?

317
00:15:35,300 --> 00:15:38,300
So that's the value that I would want for the maximum value.

318
00:15:38,300 --> 00:15:41,100
I don't know why I typed it in for the man, for the Min.

319
00:15:41,100 --> 00:15:43,800
I just want all FS, right?

320
00:15:43,800 --> 00:15:47,400
You know, I just, I just want it to be to be flipped around.

321
00:15:48,300 --> 00:15:49,900
No, sorry that be negative one.

322
00:15:50,100 --> 00:15:51,200
So that doesn't help me either.

323
00:15:52,300 --> 00:15:57,100
Well those, yeah, so I don't actually know I guess, I don't actually

324
00:15:57,100 --> 00:15:57,800
know why.

325
00:15:57,800 --> 00:15:59,800
It wouldn't let me do FFF.

326
00:16:00,000 --> 00:16:00,600
Cast.

327
00:16:00,600 --> 00:16:03,400
I guess it's because there's really no way to tell it.

328
00:16:03,400 --> 00:16:06,300
Hey I wanted this value to be negative, right?

329
00:16:07,300 --> 00:16:08,000
But that's okay.

330
00:16:08,200 --> 00:16:10,200
So what I actually want is this right?

331
00:16:10,200 --> 00:16:12,900
I actually want the highest positive negative value, which would be a

332
00:16:12,900 --> 00:16:14,400
one on the top and all zeros.

333
00:16:14,600 --> 00:16:15,200
I don't know if it will.

334
00:16:15,200 --> 00:16:16,200
Let me do that though.

335
00:16:16,300 --> 00:16:18,300
Yeah, so it won't so.

336
00:16:18,300 --> 00:16:21,100
But just to show you what that is right if I was to actually take this

337
00:16:21,100 --> 00:16:23,900
value, you know, x 8000.

338
00:16:24,500 --> 00:16:27,500
What that actually is because of two's complement, which you've never

339
00:16:27,500 --> 00:16:28,700
actually covered on the stream.

340
00:16:28,700 --> 00:16:32,600
I think so, you might have to double check that guy but because of

341
00:16:32,600 --> 00:16:36,900
two's complement, the way that they tend to work with.

342
00:16:37,100 --> 00:16:43,400
Values that are in binary on CPUs, is unlike the floating Point math,

343
00:16:43,400 --> 00:16:46,400
where you have a sign bit that literally just get set, or unset,

344
00:16:46,400 --> 00:16:50,500
whether or not, the number is negative, they integer math, they do

345
00:16:50,500 --> 00:16:54,100
this trick called tubes compliment to make it simpler on the hardware

346
00:16:54,100 --> 00:16:56,900
because basically, you can do all the operations, the same, whether

347
00:16:56,900 --> 00:16:58,400
the value is signed or unsigned.

348
00:17:00,500 --> 00:17:01,000
And the map.

349
00:17:01,000 --> 00:17:04,000
All works out exactly the same way.

350
00:17:04,200 --> 00:17:07,400
Now, this is a little bit confusing, so I'll just kind of mention it

351
00:17:07,400 --> 00:17:12,000
briefly, I don't know that now is a great time to spend a bunch of

352
00:17:12,000 --> 00:17:14,900
time talking about 2's complement, but since my brain is fried anyway,

353
00:17:14,900 --> 00:17:19,300
obviously today, maybe it wouldn't hurt, right?

354
00:17:20,500 --> 00:17:21,599
Is this the right thing?

355
00:17:23,000 --> 00:17:23,900
Hello, mischief.

356
00:17:27,700 --> 00:17:30,300
Mischief takes a while to load our giant Blackboard now.

357
00:17:30,300 --> 00:17:33,100
I don't think they were expecting people to use it quite like this,

358
00:17:33,700 --> 00:17:35,600
but we do.

359
00:17:36,900 --> 00:17:39,500
So, you know, I usually just tend to leave it running soon.

360
00:17:39,500 --> 00:17:42,000
Have to wait for this but like I said, the machine accidentally logged

361
00:17:42,000 --> 00:17:45,600
itself out the other day and so that was kind of unfortunate to say

362
00:17:45,600 --> 00:17:46,000
the least.

363
00:17:46,000 --> 00:17:48,400
But anyway, so

364
00:17:50,500 --> 00:17:53,900
Two's complement.

365
00:17:54,100 --> 00:17:54,500
You know what?

366
00:17:54,500 --> 00:17:56,100
But I always felt compliment wrong.

367
00:17:56,200 --> 00:17:58,000
So we're actually going to check that out, too.

368
00:17:58,100 --> 00:17:59,800
Is it compliment?

369
00:18:00,000 --> 00:18:01,600
And I it see.

370
00:18:01,700 --> 00:18:05,300
Okay, so I did spend I spelled it correctly, good, but that's totally.

371
00:18:05,300 --> 00:18:07,000
I always felt compliment the wrong way.

372
00:18:08,400 --> 00:18:09,200
Since there's multiple.

373
00:18:09,800 --> 00:18:14,100
So all I was saying before was, you know, if you imagine let's take

374
00:18:14,100 --> 00:18:17,700
the simplest case or a very simple case, which would be like let's

375
00:18:17,700 --> 00:18:21,200
suppose that we had a value that's only four bits long, right?

376
00:18:21,400 --> 00:18:22,700
So, it can really only.

377
00:18:23,300 --> 00:18:27,200
It can only represent values between 0 and 15.

378
00:18:27,200 --> 00:18:29,000
If it's unsigned, right?

379
00:18:29,400 --> 00:18:30,300
This is the one bit.

380
00:18:30,300 --> 00:18:33,100
This is the tube at this is the 4-bit, this is the 8-Bit, right?

381
00:18:34,000 --> 00:18:38,000
And so if it's unsigned then the maximum value that it could support

382
00:18:38,100 --> 00:18:43,300
was ones in all the places which is 1 plus 2 plus 4 plus 8, right?

383
00:18:43,500 --> 00:18:45,500
And so that's just going to give you 15, right?

384
00:18:45,500 --> 00:18:48,200
It's you know, just basic math.

385
00:18:49,100 --> 00:18:52,000
So the question is, what if I want this to be assigned value though,

386
00:18:52,000 --> 00:18:52,600
right?

387
00:18:52,800 --> 00:18:55,200
Well if I wanted to be assigned value, I need some way of telling the

388
00:18:55,200 --> 00:18:58,000
difference between whether it's signed and whether it's unsigned.

389
00:18:58,100 --> 00:19:01,400
And so what you could do is say well that top bit, right?

390
00:19:01,400 --> 00:19:03,600
Is going to tell me whether it's signed or unsigned.

391
00:19:03,800 --> 00:19:07,100
And and so what I'd like to do is make it so that I just can set that

392
00:19:07,200 --> 00:19:10,900
you know you know, if I just think about that bit if that bit is set,

393
00:19:10,900 --> 00:19:13,600
I know the value of signed if that bit is unset, that I know the value

394
00:19:13,600 --> 00:19:15,000
is unsigned, that would be pretty nice.

395
00:19:15,000 --> 00:19:16,900
And that's the way that floating Point, does it right?

396
00:19:16,900 --> 00:19:19,600
Floating Point has the high bit and it just sets it on and off

397
00:19:19,600 --> 00:19:20,200
directly.

398
00:19:20,600 --> 00:19:24,200
But what happens is if we were to actually literally make that the

399
00:19:24,200 --> 00:19:28,200
rule meaning, okay, this bit is now just the sign bit.

400
00:19:28,300 --> 00:19:31,700
But these bits still mean for two and one, right?

401
00:19:32,400 --> 00:19:33,600
If that were the case.

402
00:19:33,700 --> 00:19:37,100
Then the processor would always have two special case this bit, right?

403
00:19:37,100 --> 00:19:40,200
It would always have to go if I have a plus b where they're both these

404
00:19:40,200 --> 00:19:42,300
kind of numbers it would first have to go.

405
00:19:42,400 --> 00:19:47,400
Oh, is you know, what are the signs of these two like is the sign bit

406
00:19:47,400 --> 00:19:48,300
set in both of them?

407
00:19:48,300 --> 00:19:48,900
Or is it not setting?

408
00:19:48,900 --> 00:19:49,400
Both of them.

409
00:19:49,400 --> 00:19:49,700
Okay.

410
00:19:49,700 --> 00:19:52,500
Well if it's set in both of them or not setting both of them, then you

411
00:19:52,500 --> 00:19:55,700
can actually add the bottom together and then let's leave the science

412
00:19:55,700 --> 00:19:56,200
at the same.

413
00:19:56,200 --> 00:19:59,500
If it's not, you got to turn this from an addition into a subtraction

414
00:19:59,500 --> 00:20:01,700
and write it just gets kind of annoying.

415
00:20:02,700 --> 00:20:05,500
But it turns out that you can do a nice trick here with the way that

416
00:20:05,500 --> 00:20:06,600
you conceptualize the numbers.

417
00:20:06,900 --> 00:20:10,500
If instead of thinking of the negative numbers as the same as the

418
00:20:10,500 --> 00:20:11,200
positive numbers.

419
00:20:11,200 --> 00:20:15,100
But just with this bit set, what you can do instead is think of it as

420
00:20:15,100 --> 00:20:17,700
counting the opposite direction, right?

421
00:20:17,700 --> 00:20:21,600
So normally what happens is you have one, two, and four and the zero

422
00:20:21,600 --> 00:20:25,800
bit like Get Set, you know, on I'm sorry I should say the one bit the

423
00:20:25,800 --> 00:20:30,600
0 in the one B Place gets set to on that becomes one, right?

424
00:20:30,700 --> 00:20:32,400
So, you know, in unsigned

425
00:20:32,500 --> 00:20:34,100
And right, oops.

426
00:20:35,600 --> 00:20:36,700
In unsigned.

427
00:20:37,600 --> 00:20:41,900
I have 0 0, 0 0 equals 0, I have 0 0 0 1 equals 1.

428
00:20:41,900 --> 00:20:46,000
I have 0 0, 1 0 equals to write and I keep going, like this, this is

429
00:20:46,000 --> 00:20:47,900
how I count up, right?

430
00:20:49,900 --> 00:20:53,600
Make sense, and I can keep going like this to get all the way up,

431
00:20:54,000 --> 00:20:54,500
right?

432
00:20:54,700 --> 00:20:57,300
And so, as I go, I count up in unsigned.

433
00:20:57,300 --> 00:20:59,800
Now when I get, if I wanted to do a sign,

434
00:21:00,000 --> 00:21:01,600
Value instead, right?

435
00:21:01,700 --> 00:21:04,300
If we were doing this trick where all we did was set the sign bit, you

436
00:21:04,300 --> 00:21:07,000
would expect it to again just look you know, this would just be ones

437
00:21:07,000 --> 00:21:08,400
the whole way down, right?

438
00:21:08,500 --> 00:21:11,300
And now it would be well there'd be no such thing as negative zero

439
00:21:11,300 --> 00:21:14,000
right but you'd have negative 1 negative 2 negative 3, negative 4

440
00:21:14,000 --> 00:21:14,700
negative 5, right?

441
00:21:14,700 --> 00:21:17,100
And maybe you would have a negative zero who knows, right.

442
00:21:17,200 --> 00:21:21,600
That's what you expect to see but like I said that would produce this

443
00:21:21,600 --> 00:21:23,900
kind of nasty special casing that has to happen in the processor and

444
00:21:23,900 --> 00:21:24,100
know.

445
00:21:24,100 --> 00:21:25,300
And they just did one do that.

446
00:21:25,300 --> 00:21:26,400
They don't have to be right.

447
00:21:26,600 --> 00:21:29,600
So two's complement is a trick that says, no, don't do it this way.

448
00:21:30,000 --> 00:21:33,600
Instead of using that value for a negative 1, Let's actually use all

449
00:21:33,600 --> 00:21:36,100
ones to represent negative 1, right?

450
00:21:36,500 --> 00:21:38,000
Why would you want to do that?

451
00:21:41,100 --> 00:21:46,700
Well the reason is because now if you just Implement your addition

452
00:21:46,700 --> 00:21:48,500
operations, the same way.

453
00:21:49,500 --> 00:21:53,000
And so what you actually can do to her, as you can see, actual I'll

454
00:21:53,000 --> 00:21:54,100
take a little bit further.

455
00:21:54,700 --> 00:21:55,600
So here you go.

456
00:21:55,900 --> 00:21:56,700
There's negative 1.

457
00:21:56,700 --> 00:21:59,600
You can see it's all FS - to, right?

458
00:21:59,600 --> 00:22:04,800
- three - four - five - Six - seven - eight and what you can see is it

459
00:22:04,800 --> 00:22:08,100
just it's literally just counting down backwards, right?

460
00:22:08,700 --> 00:22:10,800
And so if you look at what happens, right?

461
00:22:10,800 --> 00:22:14,400
You'd have, if I wanted this to be a negative 2, what I would do is

462
00:22:14,400 --> 00:22:19,200
I'm doing exactly the opposite operation as I was doing, you know,

463
00:22:19,300 --> 00:22:20,700
Before on these guys, right?

464
00:22:20,700 --> 00:22:23,500
In fact, I can, I can probably do this in binary for you, too.

465
00:22:23,500 --> 00:22:26,300
You can see it a little bit better, right?

466
00:22:26,400 --> 00:22:27,500
Do you see how this is going?

467
00:22:31,900 --> 00:22:37,000
Like so and the reason that they do that is because well it doesn't

468
00:22:37,000 --> 00:22:40,600
really matter to humans because humans you know we have to write a

469
00:22:40,600 --> 00:22:43,600
routine to decode this binary to print it out in a ski for them

470
00:22:43,600 --> 00:22:44,000
anyway.

471
00:22:44,000 --> 00:22:45,700
So like who cares about that?

472
00:22:45,700 --> 00:22:47,400
Who cares about the meaning of the numbers?

473
00:22:47,600 --> 00:22:50,700
As long as there is a way to know what they mean in human form.

474
00:22:50,700 --> 00:22:51,300
That's fine.

475
00:22:51,400 --> 00:22:54,000
What we actually care about is what happens to the arithmetic in the

476
00:22:54,000 --> 00:22:54,400
computer.

477
00:22:54,400 --> 00:22:56,300
Does it produce the right results?

478
00:22:56,300 --> 00:23:00,900
Consistently and what happens is if you if you treat this as the

479
00:23:00,900 --> 00:23:01,500
encoding

480
00:23:01,600 --> 00:23:03,600
For negative numbers, right?

481
00:23:03,900 --> 00:23:08,200
Then what happens is all the arithmetic still works the exact same

482
00:23:08,300 --> 00:23:09,500
way, right?

483
00:23:09,500 --> 00:23:14,100
And I know that sounds kind of weird but that's actually just what

484
00:23:14,100 --> 00:23:14,500
happened.

485
00:23:14,500 --> 00:23:19,100
So for example, if I were to take all zeros, right?

486
00:23:19,100 --> 00:23:22,400
And let's say we're doing scientific now so that equals 0, right?

487
00:23:22,400 --> 00:23:26,200
And I were to add to it - one right?

488
00:23:27,500 --> 00:23:31,400
Then I would get negative 1 which is exactly what I would have expect.

489
00:23:31,600 --> 00:23:32,100
Right?

490
00:23:32,100 --> 00:23:33,700
What I would have expected.

491
00:23:34,100 --> 00:23:39,800
If on the other hand, I want to go ahead and add, you know, -1 and -2

492
00:23:39,800 --> 00:23:42,100
and expect to get negative 3, right?

493
00:23:42,900 --> 00:23:47,100
So I go in here and I say, well, alright, I've got negative 1 like so

494
00:23:47,200 --> 00:23:49,500
and I got well actually, yeah.

495
00:23:50,700 --> 00:23:59,800
I've got negative 1 and I want to add negative 2 right 2.

496
00:24:00,000 --> 00:24:00,800
- three.

497
00:24:01,500 --> 00:24:02,800
So what's going to happen here?

498
00:24:02,900 --> 00:24:06,400
Well, I'm going to go ahead and add these guys.

499
00:24:06,400 --> 00:24:09,300
Upright, I add these two and I just get a 1 in this position.

500
00:24:09,300 --> 00:24:12,700
I add these two and I get a 0 in this position, but I have to carry,

501
00:24:12,700 --> 00:24:13,300
right?

502
00:24:13,600 --> 00:24:17,100
I get the the I have to carry the 1 again here.

503
00:24:17,100 --> 00:24:19,500
I have to carry the 1 again here and I kept get the.

504
00:24:20,000 --> 00:24:25,200
Excuse me, I get the carry bit as well, you know, actually now I think

505
00:24:25,200 --> 00:24:25,800
about it.

506
00:24:32,500 --> 00:24:34,200
How do they do the borough's?

507
00:24:35,000 --> 00:24:39,000
I don't actually know how CPU vendors even implement this today is a

508
00:24:39,000 --> 00:24:39,900
weird stream.

509
00:24:41,900 --> 00:24:43,200
I don't even remember.

510
00:24:43,200 --> 00:24:48,400
This is like, going way back into my into my the Crusty regions of my

511
00:24:48,400 --> 00:24:48,900
brain.

512
00:24:49,600 --> 00:24:52,200
So CPU Adder

513
00:24:54,000 --> 00:24:55,500
I'll see how they actually do this.

514
00:24:57,800 --> 00:25:00,400
Because basically, what's going to happen is they need to roll the

515
00:25:00,400 --> 00:25:00,700
value.

516
00:25:00,700 --> 00:25:01,500
Needs to wrap, right?

517
00:25:01,500 --> 00:25:04,700
I mean, you can see this happen so I know what happens in practice,

518
00:25:04,700 --> 00:25:08,900
but I don't know how they actually do it in the CPU and I can actually

519
00:25:08,900 --> 00:25:09,200
remember.

520
00:25:09,200 --> 00:25:14,100
So, if we could take a care, for example, let's say, I take something

521
00:25:14,100 --> 00:25:14,700
like this.

522
00:25:16,000 --> 00:25:18,700
This is definitely turning into a ridiculously off-topic stream.

523
00:25:19,000 --> 00:25:23,600
Let's take a say, I take two unsigned integers, even right?

524
00:25:23,600 --> 00:25:26,300
So this has nothing to do with the two's complement or any of that

525
00:25:26,300 --> 00:25:26,700
stuff.

526
00:25:26,800 --> 00:25:32,300
If I just have two of these and I take 255 and I add 3 to it, right?

527
00:25:32,300 --> 00:25:34,200
Or are just even to to it, right?

528
00:25:35,800 --> 00:25:37,000
And I don't care about any of this.

529
00:25:39,500 --> 00:25:42,600
And so, I want to get the result and I do a plus b, right?

530
00:25:43,400 --> 00:25:45,500
So you can see what happens in here.

531
00:25:45,800 --> 00:25:51,700
If I actually switch over to the audio output, playing sounds

532
00:25:55,600 --> 00:25:57,200
So if I come in here, right?

533
00:25:57,500 --> 00:25:59,800
And I look at these two values, A and B

534
00:26:01,900 --> 00:26:04,200
So you can see that when I'm going to in and I'll actually put these

535
00:26:04,200 --> 00:26:05,000
in binary as well.

536
00:26:08,300 --> 00:26:12,100
When I add these two in signed, right, what I what I expect to get is

537
00:26:12,100 --> 00:26:14,100
the value to wrap around, right?

538
00:26:14,500 --> 00:26:17,300
So, when I add these two together, right?

539
00:26:17,300 --> 00:26:21,600
I'm going to get something that the equals, whatever the wraparound

540
00:26:21,600 --> 00:26:22,900
actually is, right.

541
00:26:28,400 --> 00:26:30,500
So, I should get one when that happens, right?

542
00:26:30,500 --> 00:26:33,000
And I do so

543
00:26:36,700 --> 00:26:44,400
Yeah, so I don't actually know what causes that actual wraparound to

544
00:26:44,400 --> 00:26:46,000
occur in the other case.

545
00:26:46,000 --> 00:26:46,900
Well, I guess, it doesn't.

546
00:26:46,900 --> 00:26:48,400
That just works fine, right?

547
00:26:48,700 --> 00:26:53,500
The ones add those will carry and it'll just carry all the way out.

548
00:26:54,000 --> 00:26:55,700
So that's actually fine, I guess.

549
00:26:56,000 --> 00:26:56,300
Yeah.

550
00:26:56,800 --> 00:26:57,100
Hmm.

551
00:26:58,300 --> 00:26:59,800
Well, alright so let's let's try.

552
00:27:00,000 --> 00:27:00,500
More.

553
00:27:01,100 --> 00:27:04,600
So let's suppose we add 255 and 255 together, right?

554
00:27:06,000 --> 00:27:07,500
I guess that works all the way out.

555
00:27:07,900 --> 00:27:11,300
This is turning into a Casey gets to experiment with things stream but

556
00:27:11,300 --> 00:27:11,700
you know what?

557
00:27:11,700 --> 00:27:15,300
That's just so have Friday's go sometimes and also, it is boiling hot

558
00:27:15,300 --> 00:27:15,800
in here.

559
00:27:16,700 --> 00:27:18,600
It's getting really hot in Seattle in the summer.

560
00:27:18,600 --> 00:27:22,000
So like I am so in need of some air conditioning thing.

561
00:27:22,000 --> 00:27:26,700
But anyway, so I'll if I do the, the 255 ads.

562
00:27:27,100 --> 00:27:29,600
So I think I just, I think I was just asleep at the switch here.

563
00:27:30,800 --> 00:27:31,300
Yeah.

564
00:27:31,700 --> 00:27:32,700
Oh duh.

565
00:27:33,000 --> 00:27:34,500
This is just me being dumb.

566
00:27:35,400 --> 00:27:36,200
Okay, good.

567
00:27:36,600 --> 00:27:40,800
This is just this is like stupid Casey Friday.

568
00:27:42,700 --> 00:27:44,700
Because I was going to say, I didn't think they had to do anything

569
00:27:44,700 --> 00:27:45,400
special for the wraparound.

570
00:27:45,400 --> 00:27:45,900
They do.

571
00:27:46,100 --> 00:27:47,800
This is three ones that I'm adding.

572
00:27:47,800 --> 00:27:49,200
How did I get a 0 here?

573
00:27:49,200 --> 00:27:53,200
I have no idea that just should have produced a 1 1 plus 1 plus 1.

574
00:27:53,300 --> 00:27:56,000
Right equals a 1 plus a carry one, right?

575
00:27:56,100 --> 00:27:59,600
And that carry one then makes this equal to 1 which exactly equals

576
00:27:59,600 --> 00:28:00,400
negative 3.

577
00:28:01,400 --> 00:28:01,900
Right.

578
00:28:03,600 --> 00:28:03,900
Hmm.

579
00:28:04,300 --> 00:28:04,800
Oh well.

580
00:28:05,800 --> 00:28:07,700
So yeah, this is a stupid Casey Friday.

581
00:28:07,800 --> 00:28:09,100
I'm afraid that's just the way it is.

582
00:28:09,100 --> 00:28:13,400
Sometimes you know I'm pretty old these days, you know, these are the

583
00:28:13,400 --> 00:28:14,500
kind of days when I'm pretty old.

584
00:28:14,500 --> 00:28:16,200
So the brain is not what it used to be.

585
00:28:17,100 --> 00:28:20,600
Although I feel like I probably would make kind of careless math

586
00:28:20,600 --> 00:28:23,900
errors, like that even when I was little like I was really bad at

587
00:28:23,900 --> 00:28:28,900
arithmetic in in like grade school and high school and stuff like.

588
00:28:28,900 --> 00:28:31,900
So this is actually the kind of mistake that pretty much Casey at any

589
00:28:31,900 --> 00:28:35,500
age, would do like a little baby Casey in diapers.

590
00:28:35,600 --> 00:28:37,500
You know, that's a diaper Casey.

591
00:28:37,500 --> 00:28:38,300
There's the nipples.

592
00:28:39,200 --> 00:28:42,500
And then there would also be, you know, kind of like the old Casey

593
00:28:42,600 --> 00:28:45,000
with a cane or something like this, right?

594
00:28:45,300 --> 00:28:49,200
And a long beard I guess, you know, and he well, he'd be hunched over,

595
00:28:49,200 --> 00:28:50,200
probably right?

596
00:28:50,700 --> 00:28:53,900
Some of that something like this, like that.

597
00:28:54,000 --> 00:28:54,300
I don't know.

598
00:28:54,300 --> 00:28:55,300
That's that's horrible.

599
00:28:55,400 --> 00:28:56,800
This is just don't even think about these.

600
00:28:57,000 --> 00:28:59,200
But anyway, back to the point.

601
00:28:59,900 --> 00:29:01,400
So the 2's complement stuff

602
00:29:02,500 --> 00:29:06,200
Is just an excuse for CPU vendors, to not have to do any special

603
00:29:06,200 --> 00:29:08,000
casing for the math to work out, right?

604
00:29:08,100 --> 00:29:10,800
Because what ends up happening is if you just add these values the way

605
00:29:10,800 --> 00:29:12,600
you normally would and you're a CPU.

606
00:29:12,600 --> 00:29:13,700
So you don't make mistakes.

607
00:29:13,700 --> 00:29:17,700
Like I do when you actually add the values, you end up with the right

608
00:29:17,700 --> 00:29:21,200
answer, if even, if you didn't know they were signed.

609
00:29:21,500 --> 00:29:24,900
So no one has to tell you that this is actually a signed value, you

610
00:29:24,900 --> 00:29:28,200
don't have to know that there's a special meaning for this bit, the

611
00:29:28,200 --> 00:29:30,000
arithmetic still just works out.

612
00:29:30,100 --> 00:29:32,000
And so I don't actually know who figure this out, but

613
00:29:32,200 --> 00:29:35,100
You know, somewhere way back when salsa figured out like, oh wait, if

614
00:29:35,100 --> 00:29:39,200
we just treat negative values, the same as positive values and use

615
00:29:39,200 --> 00:29:40,200
this encoding.

616
00:29:40,800 --> 00:29:43,700
Then the CPU just always works, whether it's a signed value or an

617
00:29:43,700 --> 00:29:44,400
unsigned value.

618
00:29:44,400 --> 00:29:47,600
And that's why you don't need to add instructions, you don't need one,

619
00:29:47,600 --> 00:29:50,300
add instruction for signed and one add instruction for unsigned.

620
00:29:50,300 --> 00:29:53,400
You can just use a single add instruction and it works, right?

621
00:29:55,200 --> 00:29:56,600
So the long and short of it is,

622
00:29:58,300 --> 00:29:59,800
All ones equals negative.

623
00:30:00,000 --> 00:30:03,800
Whereas a one with all zeros equals the maximum value right?

624
00:30:03,800 --> 00:30:09,400
Like - I guess 16 in this case or I should say - 15 right?

625
00:30:09,400 --> 00:30:15,800
And yeah because you can't actually so this actually also introduces

626
00:30:15,800 --> 00:30:18,800
that other dichotomy, this is kind of this, this encoding.

627
00:30:18,800 --> 00:30:24,100
This this sort of the top bit means - and we count the numbers down

628
00:30:24,100 --> 00:30:27,900
backwards thing that encoding is also why you always get one

629
00:30:27,900 --> 00:30:29,400
additional number in the negative space?

630
00:30:30,000 --> 00:30:31,300
Has the positive space, right?

631
00:30:31,300 --> 00:30:32,600
Because you look at the positive space.

632
00:30:32,600 --> 00:30:36,700
The maximum number I could have encoded was this, right?

633
00:30:38,700 --> 00:30:42,800
So if I have the 1 b 2 B, the this is not right.

634
00:30:43,400 --> 00:30:46,700
The 4-bit and 8-bit write the maximum number of that I could have been

635
00:30:46,700 --> 00:30:49,200
coded was going to be seven, right?

636
00:30:49,200 --> 00:30:52,600
Because this yeah, this is assigned 4-bit number, right?

637
00:30:52,700 --> 00:30:56,600
So it ranges from negative 8 to 7, right?

638
00:30:56,600 --> 00:30:58,500
So I don't know why this this is -8.

639
00:30:58,600 --> 00:30:59,000
Don't know why?

640
00:30:59,000 --> 00:30:59,800
I said - 15.

641
00:31:00,000 --> 00:31:01,000
Wishful thinking I guess.

642
00:31:01,900 --> 00:31:03,800
So if I look at this, right?

643
00:31:03,900 --> 00:31:08,600
The the bits here, I can't set this bit because if I set this bit, the

644
00:31:08,600 --> 00:31:10,800
number would be considered to be negative, right?

645
00:31:10,800 --> 00:31:13,300
And that's, you know, that's not what I'm trying to do.

646
00:31:13,300 --> 00:31:15,000
So I'm trying to set the maximum positive number.

647
00:31:15,100 --> 00:31:18,300
I can only do one plus two plus four which is going to be seven.

648
00:31:18,300 --> 00:31:18,900
Right.

649
00:31:18,900 --> 00:31:23,900
But I can set this bit and all the other zeros to make the maximum

650
00:31:24,000 --> 00:31:26,900
negative number and that is negative 8, right?

651
00:31:27,000 --> 00:31:28,800
Because you look at how far that has to count down.

652
00:31:28,800 --> 00:31:29,800
It has a pretty long.

653
00:31:29,900 --> 00:31:32,300
Wrong way it can count down, right?

654
00:31:32,400 --> 00:31:34,400
It's still got all of these options.

655
00:31:34,400 --> 00:31:39,500
It still has seven different options in addition, to this one to count

656
00:31:39,500 --> 00:31:40,500
down, right?

657
00:31:40,500 --> 00:31:43,400
Another way to look at it is it doesn't have to represent zero because

658
00:31:43,400 --> 00:31:47,100
zero was represent, was representing the positive case, so you get one

659
00:31:47,300 --> 00:31:50,200
additional value and that's why signed integer values.

660
00:31:50,200 --> 00:31:56,700
Are always like - n, you know, to n, minus 1, right?

661
00:31:56,800 --> 00:31:59,800
Whatever it is, whatever the range is, you can.

662
00:32:00,000 --> 00:32:03,700
Only go to one less than the maximum value in positive that you could

663
00:32:03,700 --> 00:32:04,700
have gone in negative.

664
00:32:06,200 --> 00:32:06,500
Alright.

665
00:32:06,500 --> 00:32:11,100
So that was like the dumbest possible explanation of two's complement

666
00:32:11,100 --> 00:32:13,800
because although, I guess my explanation wasn't awful.

667
00:32:13,900 --> 00:32:17,300
I managed to make so many mistakes in the actual arithmetic of it,

668
00:32:17,300 --> 00:32:20,600
that it probably confused everyone more than it helped, but that's

669
00:32:20,600 --> 00:32:22,800
okay, because two components, actually pretty simple.

670
00:32:22,800 --> 00:32:25,800
There's not a lot to it pun intended.

671
00:32:25,900 --> 00:32:29,500
So if you want to just go look at a two's complement, web page, it

672
00:32:29,500 --> 00:32:34,400
should have an example examples for you without my math errors and

673
00:32:34,400 --> 00:32:35,900
hopefully, that would be clear but the

674
00:32:36,000 --> 00:32:40,900
Point is I just wanted an easy way to generate what these are and so

675
00:32:40,900 --> 00:32:44,900
what I would like to do is be able to say oh I've got a 16 bit value.

676
00:32:45,100 --> 00:32:51,100
So what I was hoping for is I could just say 0 X8 88000 to say, why

677
00:32:51,100 --> 00:32:55,700
don't you just give me a one with with 15 zeros after it and binary so

678
00:32:55,700 --> 00:32:58,900
that I can just have the maximum negative value.

679
00:32:58,900 --> 00:32:59,800
Now I could just

680
00:33:00,000 --> 00:33:03,900
Is that value instead by, you know, thinking about what it is right?

681
00:33:03,900 --> 00:33:05,500
I know that it's going to be

682
00:33:07,900 --> 00:33:09,600
I know that it's going to be this, right?

683
00:33:09,600 --> 00:33:14,500
I know it's going to be negative, 32 768, so I could just type - 32

684
00:33:14,500 --> 00:33:15,500
768 in there.

685
00:33:15,500 --> 00:33:19,000
But since - 32 768 is somewhat hard to remember.

686
00:33:19,100 --> 00:33:22,300
I was just thinking, maybe I could do something a little bit more

687
00:33:22,300 --> 00:33:26,200
clever, but what it seems like is the case that unless I want to get

688
00:33:26,300 --> 00:33:29,300
exceedingly clever, it's not going to let me do that, because you can

689
00:33:29,300 --> 00:33:31,600
see it worries about the cash trunking their value, because it's

690
00:33:31,600 --> 00:33:35,600
thinking that I'm trying to represent an unsigned value here, right?

691
00:33:35,600 --> 00:33:36,200
It's thinking.

692
00:33:36,200 --> 00:33:36,400
Okay.

693
00:33:36,600 --> 00:33:38,500
Trying to actually represent.

694
00:33:39,900 --> 00:33:42,900
The positive version of that number and if I were to cast that to

695
00:33:42,900 --> 00:33:45,200
assigned, I wouldn't be able to record it.

696
00:33:45,200 --> 00:33:49,900
So, long story short, we can't do that, that's fine.

697
00:33:50,300 --> 00:33:54,400
So we'll just go ahead and say, 32 768 will be our value.

698
00:33:54,400 --> 00:33:58,900
So our men will be negative, 32 seven, sixty, eight, dot zero, right?

699
00:33:59,000 --> 00:34:03,500
And our positive would be not this because like I just said, you can't

700
00:34:03,500 --> 00:34:05,100
quite get there.

701
00:34:05,500 --> 00:34:07,800
This would be our positive value.

702
00:34:08,100 --> 00:34:08,600
So right?

703
00:34:08,600 --> 00:34:08,800
Two's

704
00:34:09,300 --> 00:34:10,699
And you know, what are you gonna do?

705
00:34:10,900 --> 00:34:15,500
Sometimes you just gotta sometimes the explanations on handmade here

706
00:34:15,500 --> 00:34:16,600
are better than others.

707
00:34:16,699 --> 00:34:17,400
What can I say?

708
00:34:17,800 --> 00:34:21,199
That's the the, you know, you got to take the good with the bad, the

709
00:34:21,199 --> 00:34:23,500
baby with the bathwater all those sorts of things.

710
00:34:24,000 --> 00:34:28,699
So the good news is, you know, if we, if we have these things here,

711
00:34:28,699 --> 00:34:29,000
right?

712
00:34:29,000 --> 00:34:30,699
Then clamping becomes really trivial.

713
00:34:30,699 --> 00:34:31,400
We've already done.

714
00:34:31,400 --> 00:34:31,699
It.

715
00:34:32,000 --> 00:34:33,300
It's pretty straightforward.

716
00:34:33,300 --> 00:34:36,500
So we can clamp these guys, once we are ready to do the clamping, but

717
00:34:36,500 --> 00:34:39,100
let's go ahead and work on the the other part of it first.

718
00:34:39,199 --> 00:34:39,300
Yes.

719
00:34:43,100 --> 00:34:48,199
So what I'd like to do here is I want to go ahead and read from the

720
00:34:48,199 --> 00:34:52,699
source as M 128 instead of casting down for reals and process for

721
00:34:52,699 --> 00:34:57,200
these guys at once, right now, the problem is, we don't actually know.

722
00:34:57,200 --> 00:35:02,000
Like I said that, we have a buffer that actually fits a multiple of 4

723
00:35:02,000 --> 00:35:02,400
in there.

724
00:35:03,500 --> 00:35:06,300
We know that our, you know, our Ruiz do, we don't know that our output

725
00:35:06,300 --> 00:35:10,000
does, but what we can do is we can make it so that it we know that it

726
00:35:10,000 --> 00:35:13,500
always will by forcing the platform layer to always give us a little

727
00:35:13,500 --> 00:35:16,800
extra padding so that we don't have to special case this Loop, right?

728
00:35:17,600 --> 00:35:21,000
And so that's pretty easy and that's something that we can do pretty

729
00:35:21,000 --> 00:35:23,400
easily in the handmade platform stuff, right?

730
00:35:23,400 --> 00:35:27,400
We can just say when we go to the sound output buffer and output

731
00:35:27,400 --> 00:35:27,800
buffer,

732
00:35:28,800 --> 00:35:29,300
There we go.

733
00:35:30,600 --> 00:35:33,400
We can just say something like note.

734
00:35:34,500 --> 00:35:42,800
Samples, must be padded to a multiple of four samples.

735
00:35:43,000 --> 00:35:43,900
Something like that.

736
00:35:45,400 --> 00:35:49,200
Right, we could even make it bright yellow if they wanted to.

737
00:35:53,800 --> 00:35:54,000
There.

738
00:35:54,000 --> 00:35:56,800
Yeah, yeah.

739
00:35:56,800 --> 00:35:58,500
So we can do something like that if we need to.

740
00:35:58,500 --> 00:35:59,800
So, let's take a look at writing this and

741
00:36:00,000 --> 00:36:03,900
Not really worried about over right at the moment because it may be

742
00:36:03,900 --> 00:36:06,300
that we don't really care about that at the end of the day.

743
00:36:06,700 --> 00:36:10,400
All right, so if we read in these two, these two guys here, right?

744
00:36:10,400 --> 00:36:11,400
We've got one channel here.

745
00:36:11,400 --> 00:36:14,100
When channel here, these are floating Point values.

746
00:36:14,100 --> 00:36:16,900
And so what we want to do is we want to we got to convert them down to

747
00:36:16,900 --> 00:36:17,800
16 bit, right?

748
00:36:17,800 --> 00:36:20,300
And so we were doing here as we were just rounding them and then

749
00:36:20,300 --> 00:36:20,700
converting them.

750
00:36:20,700 --> 00:36:23,500
Now we know that we already have.

751
00:36:23,900 --> 00:36:26,400
We already know how to do this for the rounding, right?

752
00:36:26,800 --> 00:36:29,800
We've got that CV, DT, pts this

753
00:36:30,000 --> 00:36:31,300
Guy right here, right?

754
00:36:32,800 --> 00:36:37,700
This is the trunk, truncating one and then there's also a rounding

755
00:36:37,700 --> 00:36:38,400
one, right?

756
00:36:38,800 --> 00:36:41,700
I don't remember which one is it this one?

757
00:36:42,000 --> 00:36:42,600
That's the rounding.

758
00:36:42,600 --> 00:36:45,800
That's the truncating 1440p.

759
00:36:45,800 --> 00:36:46,400
I know.

760
00:36:46,800 --> 00:36:47,600
Where are we?

761
00:36:47,600 --> 00:36:48,300
Where is our?

762
00:36:48,300 --> 00:36:51,300
There is a rounding once our covert PS epi32.

763
00:36:51,300 --> 00:36:56,400
I believe that is the one that would do the rounding for us.

764
00:36:56,400 --> 00:36:57,600
Am I wrong about that?

765
00:36:57,900 --> 00:36:58,900
Let's see here.

766
00:37:02,300 --> 00:37:04,100
Yeah, yeah.

767
00:37:04,100 --> 00:37:05,200
So this is the one that does.

768
00:37:05,200 --> 00:37:07,500
The rounding not the truncation, right?

769
00:37:07,900 --> 00:37:09,500
So that's the one that we would want to use.

770
00:37:09,500 --> 00:37:12,300
And so what we can do there is we can just read from the source and

771
00:37:12,300 --> 00:37:15,700
this will do that rounding for us, right?

772
00:37:15,700 --> 00:37:19,800
So this will round the values really pretty straightforward, just

773
00:37:19,800 --> 00:37:20,900
going to round the values.

774
00:37:21,000 --> 00:37:23,500
So now they become integer values, right?

775
00:37:23,500 --> 00:37:26,200
And so now what we've got here is them 128.

776
00:37:26,200 --> 00:37:29,000
I write for our source is zero,

777
00:37:30,700 --> 00:37:31,900
Are in our source, one.

778
00:37:34,300 --> 00:37:36,800
So there we go, no big deal there.

779
00:37:37,700 --> 00:37:41,400
And then what we want to do after that is these are still there going

780
00:37:41,400 --> 00:37:44,500
to be put there gonna be converted for floating 32-bit floating-point,

781
00:37:44,500 --> 00:37:47,900
32-bit integer and it will round them for us and that's fine.

782
00:37:48,500 --> 00:37:53,500
But unfortunately it won't actually convert them to 16, bit for us,

783
00:37:53,500 --> 00:37:53,700
right?

784
00:37:53,700 --> 00:37:56,800
And we need to Output interleaved 16-bit sample.

785
00:37:56,800 --> 00:38:01,400
So, what we need to do here is we need to down convert the 32-bit

786
00:38:01,400 --> 00:38:04,000
values to 16-bit values and

787
00:38:04,200 --> 00:38:09,800
I'm not, this is the place where, you know, I don't quite remember

788
00:38:09,900 --> 00:38:13,200
exactly which options we have, but this is going to be a pact, right?

789
00:38:13,200 --> 00:38:15,600
We're going to have to do one of those packs to pack down.

790
00:38:16,200 --> 00:38:20,200
So let's take a look at what we've got in terms of packing.

791
00:38:22,100 --> 00:38:23,700
We don't really want convert.

792
00:38:24,500 --> 00:38:29,300
That's see storage and compare shift set, random move electrical load

793
00:38:29,300 --> 00:38:30,800
store mask.

794
00:38:31,700 --> 00:38:33,700
I don't know if the packs where are the pac's?

795
00:38:34,500 --> 00:38:36,200
I guess I don't know where the packs even are in here.

796
00:38:36,200 --> 00:38:38,900
So I'm just going to look for mmm pack because that's what I actually

797
00:38:38,900 --> 00:38:40,900
want and I won't bother.

798
00:38:40,900 --> 00:38:44,400
I, you know what I could do, I can use the little filter pack.

799
00:38:46,000 --> 00:38:50,700
So let's see here, if we want to do convert packed 32-bit integers

800
00:38:50,700 --> 00:38:51,400
from A and B.

801
00:38:51,600 --> 00:38:56,400
Be too packed 16-bit integers, using sine saturation, and so, that is

802
00:38:56,400 --> 00:38:58,000
exactly what we want, right?

803
00:38:58,200 --> 00:38:59,700
Sign saturation.

804
00:39:00,000 --> 00:39:05,100
Means that if the values were higher than 32 bits to begin with, they

805
00:39:05,100 --> 00:39:11,400
would actually get saturated out to two 16-bit integers, right?

806
00:39:11,800 --> 00:39:14,600
And that's actually pretty awesome because that means that we won't

807
00:39:14,600 --> 00:39:17,400
even have to do a clamp if you're thinking about it, right?

808
00:39:17,900 --> 00:39:24,100
Because what if the values greater than our range of - 32k to positive

809
00:39:24,100 --> 00:39:28,000
32k, the sign saturation of the pack will just take care of it for us,

810
00:39:28,100 --> 00:39:28,400
right?

811
00:39:28,400 --> 00:39:29,800
It'll just threshold.

812
00:39:30,000 --> 00:39:31,100
It down and we'll be done.

813
00:39:31,200 --> 00:39:33,500
So I think actually, that's pretty handy.

814
00:39:34,100 --> 00:39:35,700
Much more useful than I guess.

815
00:39:35,700 --> 00:39:36,500
I would have thought

816
00:39:39,100 --> 00:39:40,100
So, that's kind of nice.

817
00:39:40,200 --> 00:39:44,100
All right, so let's go ahead and let's go ahead and make that happen.

818
00:39:45,300 --> 00:39:46,200
That sounds good.

819
00:39:47,100 --> 00:39:47,700
Like so.

820
00:39:50,100 --> 00:39:54,900
So then we've got the combination of two, but the problem now is

821
00:39:54,900 --> 00:39:56,700
they're not interleaved, right?

822
00:39:56,700 --> 00:40:00,000
The 16-bit values are not actually interleaved together.

823
00:40:00,600 --> 00:40:05,800
And so that again does not really help us because we've got now

824
00:40:05,800 --> 00:40:07,500
essentially, what we've done so far, right?

825
00:40:07,500 --> 00:40:11,300
If you think about it, we start off.

826
00:40:11,600 --> 00:40:14,800
And we've got some buffers that look like this.

827
00:40:15,900 --> 00:40:17,800
Without l0 L1 L2.

828
00:40:17,800 --> 00:40:18,500
L3.

829
00:40:19,200 --> 00:40:20,900
R0 R1 R2.

830
00:40:20,900 --> 00:40:23,000
R3 and memory order, right?

831
00:40:23,400 --> 00:40:26,100
And these are all 32-bit floats.

832
00:40:27,400 --> 00:40:29,800
And so, in memory order, not processor odor.

833
00:40:29,800 --> 00:40:34,000
But in memory order, now, once we do this pack, what we'll get is,

834
00:40:34,000 --> 00:40:38,500
will get one, you know, we'll get a nice single buffer that actually

835
00:40:38,500 --> 00:40:41,100
has eight values in it, right?

836
00:40:41,100 --> 00:40:43,900
It'll have l0 L1 L2 L3.

837
00:40:43,900 --> 00:40:46,400
R0 R1 R2 R3.

838
00:40:46,900 --> 00:40:47,800
So that's great.

839
00:40:47,800 --> 00:40:49,600
And that's exactly what we want for six.

840
00:40:49,600 --> 00:40:54,800
We got 16-bit signed values now but the problem is we actually wanted

841
00:40:54,800 --> 00:40:56,800
to it to look like this, right?

842
00:40:57,000 --> 00:41:01,800
We actually wanted the things to be internally if we wanted L 0, R 0,

843
00:41:01,800 --> 00:41:08,300
L 1, r 1, L 2, R 2 because that output buffer is expecting the samples

844
00:41:08,300 --> 00:41:09,500
to be an interleaved.

845
00:41:09,500 --> 00:41:13,100
So what we need is something that would pack these things together,

846
00:41:13,100 --> 00:41:13,700
right?

847
00:41:13,700 --> 00:41:17,400
We need something that would go, you know, take l0 first, and then an

848
00:41:17,400 --> 00:41:19,600
L1, you know, like that kind of thing, right?

849
00:41:20,600 --> 00:41:25,800
And so again, I believe we have pretty good options for that

850
00:41:26,000 --> 00:41:29,100
hilariously after calling unpack, I think.

851
00:41:29,700 --> 00:41:35,300
Uh, no, I think unpack actually would be what we would want for that.

852
00:41:36,000 --> 00:41:40,800
If I'm actually if I, well know, I guess because that would be the

853
00:41:40,800 --> 00:41:42,200
high of two things.

854
00:41:42,700 --> 00:41:44,400
So, no, we don't actually want unpack.

855
00:41:44,400 --> 00:41:48,500
Hi, I guess this would actually be some kind of a 16-bit shuffle.

856
00:41:49,300 --> 00:41:50,100
Hmm.

857
00:41:50,600 --> 00:41:51,600
How are we going to do this?

858
00:41:52,400 --> 00:41:53,300
How are we going to do this?

859
00:41:53,300 --> 00:41:59,100
I don't actually know if we've got what we would may have to do before

860
00:41:59,100 --> 00:41:59,900
we do the convert.

861
00:42:00,000 --> 00:42:03,300
You may have to do something clever to interleave these guys.

862
00:42:03,300 --> 00:42:04,600
I'm trying to think, right?

863
00:42:04,600 --> 00:42:09,400
Because the unpacks that I know of and the shuffles that I know of

864
00:42:09,400 --> 00:42:12,000
won't do a 16-bit shuffle like that.

865
00:42:12,900 --> 00:42:15,000
There just isn't a way to do.

866
00:42:15,000 --> 00:42:18,100
I can't think of any way to do that off hand.

867
00:42:20,300 --> 00:42:24,700
Yeah, because if you look at the options that we have for rearranging

868
00:42:24,700 --> 00:42:27,500
things, I'm pretty sure.

869
00:42:27,500 --> 00:42:29,800
Look, what's the shuffle Epi in

870
00:42:30,000 --> 00:42:34,000
May and service in death so we can Shuffle 32-bit values around all

871
00:42:34,000 --> 00:42:35,100
that we want.

872
00:42:35,100 --> 00:42:36,000
That's fine.

873
00:42:36,500 --> 00:42:38,700
What's pi16 Shuffle 16 inches?

874
00:42:38,700 --> 00:42:40,600
In a towing and soils, dest

875
00:42:43,200 --> 00:42:48,700
So that one does only the bottom ones they're right or does it sucked

876
00:42:49,300 --> 00:42:51,700
immediate 1032?

877
00:42:51,700 --> 00:42:59,300
Oh well actually this is kind of a bizarre instruction Shuffle, the

878
00:42:59,300 --> 00:43:03,100
16-bit integers in a using the control and IM 8 and store the results

879
00:43:03,100 --> 00:43:03,800
in dest.

880
00:43:04,400 --> 00:43:08,800
And so, it's takes a look at the source and the control.

881
00:43:09,200 --> 00:43:12,800
So the control in this case, refers to

882
00:43:13,200 --> 00:43:15,700
Though the 10.

883
00:43:15,700 --> 00:43:16,300
Okay.

884
00:43:16,500 --> 00:43:23,600
So, the, the control is the 1 and 0, B, which I of this, I guess is

885
00:43:23,600 --> 00:43:25,800
what they're trying to say to the first two bits.

886
00:43:27,300 --> 00:43:35,600
And so in the case here, I guess they're doing a temporary, they're

887
00:43:35,600 --> 00:43:39,100
putting into a temporary and then returning the temporary out.

888
00:43:39,100 --> 00:43:42,400
So it's this part that's actually getting out of control best.

889
00:43:42,400 --> 00:43:42,800
This is

890
00:43:42,900 --> 00:43:44,000
So, weird function.

891
00:43:45,200 --> 00:43:47,700
I've never called this before, but that is strange.

892
00:43:47,800 --> 00:43:51,700
So this is create, this is extruding some extraction here, that's

893
00:43:51,700 --> 00:43:52,000
fine.

894
00:43:52,900 --> 00:43:57,100
And then we have the destination, this is just doing 1616 to.

895
00:43:57,100 --> 00:44:00,200
So it's only doing the bottom part of the destination which is not

896
00:44:00,200 --> 00:44:01,100
really useful to us.

897
00:44:01,300 --> 00:44:05,700
So again don't think that's particularly great and we can do Shuffle

898
00:44:05,700 --> 00:44:07,800
high and Shuffle low.

899
00:44:08,700 --> 00:44:12,200
But again that's not that's not really what we want.

900
00:44:12,300 --> 00:44:14,900
So it doesn't super look like we have much.

901
00:44:15,100 --> 00:44:19,900
In the way of options here, unfortunately, it looks like we would have

902
00:44:19,900 --> 00:44:24,900
to shuffle things ahead of time if we wanted to make this happen.

903
00:44:25,100 --> 00:44:28,500
So I'm just going to see if that's an option for us.

904
00:44:28,700 --> 00:44:31,900
I don't know, we'll have to think about it a little bit more a little

905
00:44:31,900 --> 00:44:34,500
bit later on if there's maybe a better option.

906
00:44:35,300 --> 00:44:39,100
But I think we might have to shuffle ahead of time like, basically put

907
00:44:39,100 --> 00:44:41,600
these guys before we pack them into an order.

908
00:44:41,600 --> 00:44:42,700
That's more amenable.

909
00:44:43,100 --> 00:44:44,800
So, interleave them ahead of time.

910
00:44:44,900 --> 00:44:45,400
Right?

911
00:44:45,500 --> 00:44:50,100
We could do two shuffles and put them in the right order to basically

912
00:44:50,100 --> 00:44:53,000
do an L 0, R 0 kind of thing, right?

913
00:44:53,300 --> 00:44:55,900
And so what I'm thinking is that's probably what we need to do.

914
00:44:56,000 --> 00:44:59,800
So we do like an M 128, just at the head end where we

915
00:45:00,000 --> 00:45:07,800
Say something like okay, you know, we've got we read out the source.

916
00:45:09,700 --> 00:45:10,500
Two sources.

917
00:45:11,100 --> 00:45:15,100
And then we do sort of a shuffle where we've got, we want to do like

918
00:45:15,100 --> 00:45:20,000
a, our l0, like I'm sorry LR 0 and an LR 1.

919
00:45:23,000 --> 00:45:23,800
Where we say.

920
00:45:23,800 --> 00:45:27,600
Okay let's Shuffle these guys together.

921
00:45:28,100 --> 00:45:29,600
So we'll do an M&M.

922
00:45:29,700 --> 00:45:33,500
I think it'd be an unpacked basically where we're just going to

923
00:45:33,500 --> 00:45:34,900
interleave them right.

924
00:45:34,900 --> 00:45:37,900
Because all I want to do is I just want to take these two values and

925
00:45:37,900 --> 00:45:41,700
pick one from here, one from here, one from here, one from here, which

926
00:45:41,700 --> 00:45:43,600
is to typical pattern of an unpack.

927
00:45:43,700 --> 00:45:49,200
So we do an unpack low whereas our unpack low at or unpack.

928
00:45:49,200 --> 00:45:52,100
Low is right here, right?

929
00:45:52,400 --> 00:45:52,700
So we

930
00:45:52,900 --> 00:45:56,200
Unpacked low and I guess I can leave that conversion in there as well.

931
00:45:56,200 --> 00:46:00,200
Now that I think about it this is the conversions fine, right.

932
00:46:01,500 --> 00:46:11,100
So if I do an unpack low epi32 and I unpack the S, I guess we can call

933
00:46:11,100 --> 00:46:13,800
this L and R as well.

934
00:46:13,800 --> 00:46:16,900
These are the Left Channel samples, use the right, so we'll enter,

935
00:46:16,900 --> 00:46:21,200
leave the left and right samples there and then do the high samples as

936
00:46:21,200 --> 00:46:22,500
well, right?

937
00:46:22,600 --> 00:46:27,000
And so again that's just taking these two guys, right?

938
00:46:27,000 --> 00:46:30,700
And the unpack low will produce this part.

939
00:46:32,900 --> 00:46:33,200
Right?

940
00:46:33,200 --> 00:46:34,900
So it'll take these guys and interleave them.

941
00:46:34,900 --> 00:46:38,200
Take one from here, one from here, one from here, one from here, dude.

942
00:46:38,700 --> 00:46:40,500
And then the unpack high will do these.

943
00:46:40,500 --> 00:46:46,600
These guys right, it'll produce, you know, L to R 2 L 3 R 3, right?

944
00:46:48,300 --> 00:46:53,200
Okay, so then when I've got those then I can just do the pack and the

945
00:46:53,200 --> 00:46:55,000
pack will just work right?

946
00:46:55,000 --> 00:46:58,100
It'll just pack them down in there already in the right order and so

947
00:46:58,100 --> 00:47:02,300
then I should be able to take sample out and Sample out.

948
00:47:02,300 --> 00:47:05,000
I can now just right to it directly, right?

949
00:47:05,000 --> 00:47:10,800
And so if I did em 128, I sample out and I don't know, cast this

950
00:47:11,100 --> 00:47:12,500
directly to it, right?

951
00:47:13,300 --> 00:47:17,400
I should be able to just say, all right, sample out plus plus is now

952
00:47:17,400 --> 00:47:18,000
going to write.

953
00:47:18,100 --> 00:47:20,300
It develops.

954
00:47:21,800 --> 00:47:24,700
Is now just going to write out that S01 value, right?

955
00:47:27,700 --> 00:47:28,400
Okay.

956
00:47:29,200 --> 00:47:33,700
So yeah again we need to actually ensure that we're not going to write

957
00:47:33,700 --> 00:47:34,300
out of bounds.

958
00:47:34,300 --> 00:47:37,200
There is the only thing and we're not actually doing that yet.

959
00:47:37,600 --> 00:47:40,500
So because like I said it for if we're going at forward to time that

960
00:47:40,500 --> 00:47:41,800
means there could be some overhang.

961
00:47:42,200 --> 00:47:45,000
So we're technically illegal right now but we could try running it

962
00:47:45,000 --> 00:47:45,700
anyway.

963
00:47:45,800 --> 00:47:47,800
Maybe we'll crash, who knows.

964
00:47:53,200 --> 00:47:55,900
So not quite right?

965
00:47:56,300 --> 00:47:58,500
I'm not hearing anything in the Left Channel.

966
00:47:58,500 --> 00:47:59,900
So I made some calls

967
00:48:00,000 --> 00:48:07,500
Kind of mistake here that we need to take a look at once we do our

968
00:48:07,500 --> 00:48:08,500
packs.

969
00:48:09,400 --> 00:48:12,100
Is this the right one packs, epi32.

970
00:48:12,300 --> 00:48:14,200
Did I specify the right one?

971
00:48:14,200 --> 00:48:22,300
We looked it up, but then, I don't know if I actually pack with epi32

972
00:48:22,800 --> 00:48:26,200
or epi16 group activities assigned.

973
00:48:26,300 --> 00:48:27,800
So, that's the correct.

974
00:48:27,800 --> 00:48:29,800
That's the correct one, right?

975
00:48:30,000 --> 00:48:31,400
Saturate, intertube 16.

976
00:48:31,500 --> 00:48:31,900
Yeah.

977
00:48:33,400 --> 00:48:34,400
So that's the correct one.

978
00:48:34,800 --> 00:48:38,100
So I'm not sure exactly why I had a problem.

979
00:48:38,100 --> 00:48:40,500
There, we converted our guys to 32-bit.

980
00:48:41,300 --> 00:48:46,300
That's what we wanted, right of our sources, so that's good.

981
00:48:47,800 --> 00:48:53,700
We do our pack, down to 16-bit signed values and we've got our unpack

982
00:48:53,700 --> 00:48:59,200
lows and highs there to do the to interleave them before we use them.

983
00:48:59,200 --> 00:49:02,400
So that seems like that should have worked.

984
00:49:02,600 --> 00:49:02,700
I'm

985
00:49:02,900 --> 00:49:06,000
Sure what the problem is there.

986
00:49:06,500 --> 00:49:10,300
So I guess what I'll do is, you know, you've seen me do this trick

987
00:49:10,300 --> 00:49:11,000
before.

988
00:49:11,400 --> 00:49:17,700
So I guess what I'll do here is something like this, mmm set epi32,

989
00:49:18,000 --> 00:49:25,800
you know and I'll do something like 0 you know, 0 0 0 1 1 2 2 3 3 of

990
00:49:25,800 --> 00:49:28,400
course I always forget the reverse order things.

991
00:49:28,400 --> 00:49:30,900
I'm going to say I want to set them so that these are in memory order

992
00:49:30,900 --> 00:49:31,500
like that.

993
00:49:32,500 --> 00:49:32,700
So

994
00:49:32,800 --> 00:49:37,000
alright, let's let's see here and these are like the Left Channel so I

995
00:49:37,000 --> 00:49:39,500
guess I'll do them left channel is a

996
00:49:40,800 --> 00:49:42,600
And right channel.

997
00:49:42,700 --> 00:49:43,200
Whoops?

998
00:49:43,500 --> 00:49:45,000
Right channel will be be.

999
00:49:45,200 --> 00:49:45,900
That makes sense.

1000
00:49:47,500 --> 00:49:51,300
yeah, and now

1001
00:49:55,200 --> 00:49:58,200
All right, we should be able to see these guys.

1002
00:50:00,700 --> 00:50:03,800
And again, I'm just all I'm really doing here is, I'm structuring the

1003
00:50:03,800 --> 00:50:06,900
values in the register so that I can see them properly.

1004
00:50:07,500 --> 00:50:11,500
So that, when they get converted down, I'll be able to see which which

1005
00:50:11,500 --> 00:50:12,200
values are going.

1006
00:50:12,200 --> 00:50:15,300
We're just to make sure that we aren't doing something stupid in the

1007
00:50:15,300 --> 00:50:16,300
routine, right?

1008
00:50:17,000 --> 00:50:19,700
That that's really the only thing that I'm trying to do.

1009
00:50:20,900 --> 00:50:21,200
Okay?

1010
00:50:21,200 --> 00:50:26,700
So if we take a look at El and I want to look at it as I 16s, right?

1011
00:50:26,700 --> 00:50:30,300
I want to look at it as .m 128 II.

1012
00:50:30,400 --> 00:50:32,600
I-16, right?

1013
00:50:34,300 --> 00:50:37,000
And then I'll look at our as well.

1014
00:50:37,900 --> 00:50:42,400
Our and if we look at hexadecimal, we should be able to see there that

1015
00:50:42,400 --> 00:50:49,200
we've got, you know these values as again as 32-bit values there and

1016
00:50:49,300 --> 00:50:53,900
when we go ahead and do the unpacks, we should end up with these being

1017
00:50:53,900 --> 00:50:55,200
shuffled properly.

1018
00:50:55,200 --> 00:50:58,600
So if I, if I take a look at just one of them like LR 0,

1019
00:51:00,600 --> 00:51:04,900
We should now have a b 0, B 0, a 1, b 1, right?

1020
00:51:04,900 --> 00:51:07,300
And that does look roughly correct.

1021
00:51:07,300 --> 00:51:09,200
Their see here, be one?

1022
00:51:09,300 --> 00:51:13,000
Yeah and then lr1 and 128.

1023
00:51:13,000 --> 00:51:14,800
I I-16

1024
00:51:20,400 --> 00:51:23,500
A 2 b 2, a 3, B 3, so that all looks good.

1025
00:51:23,500 --> 00:51:27,500
And now let's take a look at what the actual value comes out to be

1026
00:51:27,500 --> 00:51:30,400
after the packing.

1027
00:51:31,200 --> 00:51:37,900
Make sure that's saying a 0, B, 0, a 1, b 1, a 2 b 2, a 3, B 3 so that

1028
00:51:37,900 --> 00:51:40,900
looks totally right to me that looks all packed up.

1029
00:51:40,900 --> 00:51:41,400
Nice.

1030
00:51:42,200 --> 00:51:46,000
So yeah, so I think we're in good shape here.

1031
00:51:46,100 --> 00:51:46,800
I've also going to

1032
00:51:47,100 --> 00:51:50,200
Just make sure we don't overwrite our bounds.

1033
00:51:56,700 --> 00:51:58,100
Not sure what's going on there.

1034
00:52:01,000 --> 00:52:02,500
What did I do?

1035
00:52:02,500 --> 00:52:03,200
What did I do?

1036
00:52:03,500 --> 00:52:03,900
Sample?

1037
00:52:03,900 --> 00:52:04,100
Count.

1038
00:52:04,100 --> 00:52:04,400
Four.

1039
00:52:04,400 --> 00:52:05,500
Minus one.

1040
00:52:07,400 --> 00:52:09,600
I guess it's possible that sample count went well.

1041
00:52:12,500 --> 00:52:14,400
Cert simple account for.

1042
00:52:17,200 --> 00:52:18,000
It is 0.

1043
00:52:22,500 --> 00:52:24,100
Why are we not hearing anything?

1044
00:52:28,600 --> 00:52:29,900
What is happening?

1045
00:52:31,900 --> 00:52:33,600
so, I feel like

1046
00:52:35,500 --> 00:52:36,900
That should be, we're up.

1047
00:52:44,200 --> 00:52:44,500
Okay.

1048
00:52:44,500 --> 00:52:47,800
So I guess the problem was just that that overwrite was probably over

1049
00:52:47,800 --> 00:52:49,600
writing something important in the puffer.

1050
00:52:50,200 --> 00:52:52,000
So all right I take it back.

1051
00:52:52,100 --> 00:52:53,700
I think our routine is probably fine.

1052
00:52:54,000 --> 00:52:58,500
We just have to make sure we actually allow that padding to be padded

1053
00:52:58,500 --> 00:52:59,000
out.

1054
00:52:59,100 --> 00:53:02,600
So let's go ahead and do that over in the win32 side of the code,

1055
00:53:02,700 --> 00:53:03,200
right?

1056
00:53:04,500 --> 00:53:09,900
And so are we do our samples when we actually go ahead and Alec those,

1057
00:53:09,900 --> 00:53:10,400
right?

1058
00:53:10,600 --> 00:53:15,700
Let's let's make sure that we actually have those samples.

1059
00:53:16,500 --> 00:53:17,000
Let's see.

1060
00:53:17,000 --> 00:53:20,900
So, what we want to do here, when we do secondary, buffer size,

1061
00:53:21,200 --> 00:53:24,100
whatever the secondary buffer sizes, we have to make sure we always

1062
00:53:24,100 --> 00:53:28,800
align it by 4, just to make sure we've got enough room there.

1063
00:53:28,800 --> 00:53:33,000
And actually, I guess that's not true, the secondary buffer size.

1064
00:53:34,100 --> 00:53:38,700
Really doesn't quite tell us what we need because the secondary buffer

1065
00:53:38,700 --> 00:53:39,400
size.

1066
00:53:39,400 --> 00:53:41,000
We don't want to line that by 4.

1067
00:53:41,000 --> 00:53:44,300
We want to make sure the number of samples could be done by 4.

1068
00:53:44,300 --> 00:53:48,100
So, what we can do there is we can just say, well for samples right

1069
00:53:48,400 --> 00:53:51,200
times the size of a sample, right?

1070
00:53:51,200 --> 00:53:53,100
Which a sample is a you 16?

1071
00:53:54,600 --> 00:53:59,800
We know that we couldn't possibly mean more than that overrun, right?

1072
00:54:00,000 --> 00:54:03,600
And so we could just spacely say we have Max possible over run or

1073
00:54:03,600 --> 00:54:08,300
something like that, we could just say that we have that and we always

1074
00:54:08,300 --> 00:54:10,800
make sure that we have that much in there, right?

1075
00:54:12,300 --> 00:54:15,500
So that would be fine and if we did that then I think we would

1076
00:54:15,500 --> 00:54:18,500
probably be okay with the overrun, right?

1077
00:54:33,600 --> 00:54:36,300
Of course, also could have just been the mouse's and I forgot we left

1078
00:54:36,300 --> 00:54:37,200
that hooked up.

1079
00:54:37,300 --> 00:54:38,800
That is bad for testing.

1080
00:54:39,000 --> 00:54:41,200
I guess if I just always remember that it sucked up.

1081
00:54:53,100 --> 00:54:54,300
So that's all good.

1082
00:54:54,700 --> 00:54:58,500
And now, I guess these clamp values, the whole thing that made me have

1083
00:54:58,500 --> 00:55:03,100
to go on the stream and realize that my brain is too crusty to

1084
00:55:03,100 --> 00:55:03,500
properly.

1085
00:55:03,500 --> 00:55:06,000
Do two's complement math without preparation.

1086
00:55:08,800 --> 00:55:09,800
Wasn't actually necessary.

1087
00:55:10,000 --> 00:55:14,200
So we do not need to clamp, the clamp will just happen during the pack

1088
00:55:14,400 --> 00:55:16,400
automatically, which is kind of crazy.

1089
00:55:17,000 --> 00:55:23,200
So this is actually totally fine with this because the convert PS

1090
00:55:23,600 --> 00:55:25,500
epi32 after the unpack.

1091
00:55:25,600 --> 00:55:30,200
When we go to this packs epi32 when that takes a room 3216, it's going

1092
00:55:30,200 --> 00:55:31,000
to do the clamp.

1093
00:55:31,100 --> 00:55:33,400
We don't even need to compare against any values.

1094
00:55:33,400 --> 00:55:34,800
It'll just do us, do it for us.

1095
00:55:35,000 --> 00:55:38,200
So that's kind of awesome, I guess.

1096
00:55:38,400 --> 00:55:40,500
It's just yeah, just the way it goes sometimes.

1097
00:55:40,900 --> 00:55:41,400
So

1098
00:55:46,000 --> 00:55:53,500
we can also, if we want to do something like this and then store it in

1099
00:55:53,500 --> 00:55:55,300
It, M&M store.

1100
00:55:57,900 --> 00:55:58,900
Is it epi32?

1101
00:55:58,900 --> 00:55:59,700
Can I do that?

1102
00:56:01,400 --> 00:56:03,300
Si128, that's what it is.

1103
00:56:04,500 --> 00:56:06,400
So if I want to store this guy out,

1104
00:56:07,400 --> 00:56:08,000
Like so.

1105
00:56:10,600 --> 00:56:12,000
I should be able to do that.

1106
00:56:12,700 --> 00:56:13,500
Just to say that.

1107
00:56:13,500 --> 00:56:20,200
Hey, these are aligned by the way, cannot G 12 pointer, right.

1108
00:56:24,700 --> 00:56:27,000
And these are o store, PS.

1109
00:56:31,200 --> 00:56:34,000
And for some reason, it always wants you to cast into a float star,

1110
00:56:34,000 --> 00:56:37,500
which makes absolutely no sense to me, because why wouldn't you want

1111
00:56:37,500 --> 00:56:38,300
them to be the other kind.

1112
00:56:38,300 --> 00:56:41,100
So there's the M&M store so that should be fine.

1113
00:56:42,800 --> 00:56:46,000
And it is and we can also do

1114
00:56:46,500 --> 00:56:51,400
Give me the same down here, where, when we're loading these guys, we

1115
00:56:51,400 --> 00:56:58,000
can actually just say, okay, we've got em em, 128 SC row and then 120

1116
00:56:58,000 --> 00:56:58,900
s 1.

1117
00:57:00,000 --> 00:57:04,200
That can be an end, load p s of this value.

1118
00:57:11,200 --> 00:57:16,000
And again, have to convert it to a float star for no reason that I'm

1119
00:57:16,000 --> 00:57:19,600
aware of and that is it.

1120
00:57:19,600 --> 00:57:22,800
Okay, so our conversion Loop now runs for a wide are clear Loop.

1121
00:57:22,800 --> 00:57:24,000
Now runs for wind.

1122
00:57:24,400 --> 00:57:27,600
So the only thing that we really have to do now is we just have to

1123
00:57:27,600 --> 00:57:28,600
make our

1124
00:57:30,200 --> 00:57:33,500
Mixing Loop here run for a wide which will be a little more so we can

1125
00:57:33,500 --> 00:57:34,400
do that on Monday.

1126
00:57:35,000 --> 00:57:37,400
And that one will be a little bit more complicated, right?

1127
00:57:37,400 --> 00:57:41,700
Because we have to actually have our mixing Loop right here.

1128
00:57:43,400 --> 00:57:45,500
I guess, what did I interesting?

1129
00:57:46,000 --> 00:57:47,600
So this is our bilinear filtering.

1130
00:57:47,600 --> 00:57:50,000
Our non, by the, I think we decided that the bi linear filter didn't

1131
00:57:50,000 --> 00:57:51,200
actually help.

1132
00:57:51,900 --> 00:57:56,300
But anyway, we have to do this, this work, right?

1133
00:57:56,300 --> 00:57:59,400
So we need to do D volume increment, ER, we need to do a decent

1134
00:57:59,600 --> 00:58:00,900
People and commentor.

1135
00:58:00,900 --> 00:58:03,600
We need to do these guys wide.

1136
00:58:05,000 --> 00:58:07,900
And more importantly, we have to make sure that samples to mix is

1137
00:58:07,900 --> 00:58:10,400
always going to also be 4 wide.

1138
00:58:13,600 --> 00:58:15,900
Also, someone mentioned a bug.

1139
00:58:16,900 --> 00:58:25,000
That we have in here, fix the, to fix the both volumes, and at the

1140
00:58:25,000 --> 00:58:27,000
same time bug.

1141
00:58:28,300 --> 00:58:28,800
So yeah.

1142
00:58:28,800 --> 00:58:31,400
So I think we, like I said, it shouldn't be too much longer.

1143
00:58:31,400 --> 00:58:32,500
We probably would have finished it today.

1144
00:58:32,500 --> 00:58:35,200
If I hadn't gone off on the 2's complement tangent, which hilariously

1145
00:58:35,200 --> 00:58:36,500
was not necessary.

1146
00:58:38,900 --> 00:58:44,000
But yeah, but I'd like to save that for Monday just so we don't eat up

1147
00:58:44,000 --> 00:58:46,500
the entire time of Q&A on it.

1148
00:58:46,900 --> 00:58:50,200
But that's basically all we would really need to do the rest of this

1149
00:58:50,200 --> 00:58:53,000
routine doesn't actually do anything with the sound sample.

1150
00:58:53,000 --> 00:58:57,000
So it's literally just that one, little interior part, that would be

1151
00:58:57,000 --> 00:58:57,600
relevant.

1152
00:58:57,600 --> 00:59:02,800
So, we would basically just be Loft and these guys up to MMM 128 and

1153
00:59:02,800 --> 00:59:06,600
then we would have each of these things, you know, just be a mole PS

1154
00:59:06,600 --> 00:59:11,700
and, you know, to multiply the master volume by the volume and then

1155
00:59:11,800 --> 00:59:14,800
another my PS2 multiply it by the sample volume value.

1156
00:59:15,400 --> 00:59:16,500
And then we would,

1157
00:59:16,600 --> 00:59:19,600
Have to do, our incrementer is would have to be for wide, so that they

1158
00:59:19,600 --> 00:59:20,400
would go the whole way.

1159
00:59:20,400 --> 00:59:23,700
So really that, you know, converting that interior of the loop

1160
00:59:24,000 --> 00:59:25,500
actually would be extremely trivial.

1161
00:59:25,500 --> 00:59:30,400
It's converting samples to mix to be always up for a wide.

1162
00:59:30,400 --> 00:59:31,800
That would be a little more complicated.

1163
00:59:36,500 --> 00:59:37,000
So there.

1164
00:59:37,300 --> 00:59:38,500
That's yeah.

1165
00:59:39,400 --> 00:59:40,500
So there's that.

1166
00:59:40,600 --> 00:59:45,400
The other thing is I mean we could just write it so that it doesn't

1167
00:59:45,400 --> 00:59:48,600
have to be for a wide and we just have a mask at the end that we use,

1168
00:59:48,600 --> 00:59:49,600
but I don't know.

1169
00:59:49,800 --> 00:59:52,100
I feel like just writing it to work for a wide is probably the right

1170
00:59:52,100 --> 00:59:55,700
way and just padding, our sample buffers out so that the sample buffer

1171
00:59:55,700 --> 00:59:59,200
is are always multiples of 4 as well, if that makes sense.

1172
01:00:00,800 --> 01:00:05,600
Yeah, and thinking about that, I think that will probably argue for

1173
01:00:05,600 --> 01:00:09,700
actually making sure that the sample buffers are always four wide.

1174
01:00:09,700 --> 01:00:14,900
So that, you know, if we go back out to the platform code, where we do

1175
01:00:14,900 --> 01:00:20,300
our output sound samples, or game output sound, or as our output

1176
01:00:20,600 --> 01:00:23,400
sound, no well, here you go.

1177
01:00:24,300 --> 01:00:27,400
So when we do our B to lock and we compute out how much we're going to

1178
01:00:27,400 --> 01:00:30,400
do and we do this sample count here, I think what we're

1179
01:00:30,600 --> 01:00:36,800
want to do is always just truncate that possibly down to whatever the

1180
01:00:36,800 --> 01:00:41,500
next size down is, that's aligned by for because if we always make

1181
01:00:41,500 --> 01:00:44,800
sure that we align the sample, count down to four

1182
01:00:46,000 --> 01:00:50,500
Then all of these routines, all of the samples can always be playing

1183
01:00:50,500 --> 01:00:52,000
in lockstep in that for.

1184
01:00:52,300 --> 01:00:55,800
So, we can always grab for a process for, and nobody has to be finicky

1185
01:00:55,800 --> 01:00:56,900
about the edges.

1186
01:00:57,200 --> 01:01:00,100
And that means, I can also always also be aligned.

1187
01:01:00,100 --> 01:01:04,000
No one would ever be doing anything unaligned, right?

1188
01:01:04,200 --> 01:01:07,600
So I feel like, that's probably what we will want to do on Monday.

1189
01:01:07,600 --> 01:01:10,200
That's just my assumption, okay?

1190
01:01:10,800 --> 01:01:13,000
That's all there is to it.

1191
01:01:13,100 --> 01:01:14,800
Let's go ahead and go to the Q&A.

1192
01:01:15,200 --> 01:01:15,600
That makes sense.

1193
01:01:26,900 --> 01:01:28,400
so, if you have questions,

1194
01:01:30,900 --> 01:01:33,400
I guess I can go while the questions are coming in.

1195
01:01:34,500 --> 01:01:37,800
Do perhaps a little bit more talking about the two's complement here

1196
01:01:37,800 --> 01:01:42,200
since I brought it up and now it's all been paged into my brain.

1197
01:01:43,300 --> 01:01:45,400
So if you want to see a complete example, right?

1198
01:01:45,400 --> 01:01:46,800
The smallest one we could possibly do.

1199
01:01:46,800 --> 01:01:50,800
That would probably look useful is 3 bits.

1200
01:01:51,300 --> 01:01:55,000
So here's the full three bit set, right?

1201
01:02:01,800 --> 01:02:03,800
So now we've got all the values here, right?

1202
01:02:04,000 --> 01:02:06,300
So in unsigned, right?

1203
01:02:06,300 --> 01:02:07,400
What are these equal to?

1204
01:02:07,400 --> 01:02:17,500
Well this is 0 1 2 3, 4 5 6 7 right in signed they're equal to 0 1 2

1205
01:02:17,500 --> 01:02:18,100
3.

1206
01:02:19,000 --> 01:02:22,800
And then when we get to for right that now it's the sign bit is set,

1207
01:02:22,800 --> 01:02:22,900
right?

1208
01:02:22,900 --> 01:02:25,600
So this is actually negative 4, right?

1209
01:02:25,600 --> 01:02:29,700
And then it counts down - three - two - one right.

1210
01:02:30,100 --> 01:02:30,800
Does that make sense?

1211
01:02:33,400 --> 01:02:36,800
And so what you can see if we pick any of these two and add them

1212
01:02:36,800 --> 01:02:37,500
together.

1213
01:02:38,400 --> 01:02:40,800
We always get the right math, right?

1214
01:02:40,800 --> 01:02:41,700
We always get the right math.

1215
01:02:41,700 --> 01:02:42,900
No matter what, no matter what you pick.

1216
01:02:42,900 --> 01:02:47,500
So if we pick this one and this one to add together, right, well I

1217
01:02:47,500 --> 01:02:49,400
guess I should fix things that stay in range.

1218
01:02:49,400 --> 01:02:52,600
May be would be, would be a little bit more.

1219
01:02:52,700 --> 01:02:55,600
Well, you know, you just have to understand that they wrap I guess is

1220
01:02:55,600 --> 01:02:56,300
what I would say.

1221
01:02:57,100 --> 01:02:59,800
So let's say that we pick these two guys to add together.

1222
01:03:00,100 --> 01:03:00,800
Right?

1223
01:03:01,300 --> 01:03:04,300
So if we want to pick these two guys to add together, I'd have 0 1 0

1224
01:03:04,300 --> 01:03:09,500
and 1 0 1 right and so if I add those together I get 1 1 1 right and

1225
01:03:09,500 --> 01:03:10,400
what's 111?

1226
01:03:10,400 --> 01:03:12,000
Well that's equal to 7 right?

1227
01:03:12,000 --> 01:03:15,800
2 plus 5 equals 7 that's definitely would think it would be and that's

1228
01:03:15,800 --> 01:03:16,300
all good.

1229
01:03:16,400 --> 01:03:20,600
Right now what happens if I do the same thing but just considering the

1230
01:03:20,600 --> 01:03:22,100
interpretation to be signed.

1231
01:03:22,200 --> 01:03:23,200
Well, same is true.

1232
01:03:23,200 --> 01:03:27,200
Two plus negative 3 equals negative 1 right?

1233
01:03:28,200 --> 01:03:31,600
And so you can kind of see that like, really the whole deal with the

1234
01:03:31,600 --> 01:03:37,000
two's complement thing is just because since we don't care what these

1235
01:03:37,000 --> 01:03:39,200
binary values represent, right?

1236
01:03:39,200 --> 01:03:42,200
We can choose the encoding to be whatever we want it to be.

1237
01:03:42,200 --> 01:03:46,100
Because the only time we actually end up, caring about that value

1238
01:03:46,100 --> 01:03:49,500
outside of the computer is when we go to print out the values and we

1239
01:03:49,500 --> 01:03:51,300
can have that routine, do whatever we want, right?

1240
01:03:51,300 --> 01:03:54,300
So it can decode them, however, it wants.

1241
01:03:54,300 --> 01:03:57,900
So, all we care about is that inside the machine, we have the most

1242
01:03:58,400 --> 01:04:00,000
Way of building the CPU.

1243
01:04:00,000 --> 01:04:03,800
And if we do it this way, it means we just build one, Adder circuit,

1244
01:04:03,800 --> 01:04:06,200
one, subtractor circuit, you know, etcetera Etc.

1245
01:04:06,700 --> 01:04:09,900
And that way we can get both positive and negative numbers with the

1246
01:04:09,900 --> 01:04:10,900
same CPU Gates.

1247
01:04:10,900 --> 01:04:11,900
And that's pretty cool.

1248
01:04:13,700 --> 01:04:14,100
Yeah.

1249
01:04:14,600 --> 01:04:17,900
And so the same, I believe is true for most opposite.

1250
01:04:17,900 --> 01:04:21,200
You would want to do like if you want to do multiplication or

1251
01:04:21,200 --> 01:04:22,100
something like this.

1252
01:04:22,500 --> 01:04:26,100
Obviously you know multiplying by 1 and 0 will always work because

1253
01:04:26,100 --> 01:04:28,100
that's going to be the same value.

1254
01:04:28,200 --> 01:04:29,200
Value in either case.

1255
01:04:29,700 --> 01:04:34,800
But multiplying by say to would also I believe be true if you take a

1256
01:04:34,800 --> 01:04:39,400
look at, you know, what happens when you when you multiply by 2, I

1257
01:04:39,400 --> 01:04:43,900
think you always get the correct values there as well.

1258
01:04:43,900 --> 01:04:50,000
So for example, if you, you know, if you were to multiply two times,

1259
01:04:50,000 --> 01:04:55,700
you know - one you would expect to get negative 2, right?

1260
01:04:56,300 --> 01:04:58,100
And so if you take a look,

1261
01:04:58,300 --> 01:05:04,600
At 111 and I want to multiply it by 0 1 0, right?

1262
01:05:04,800 --> 01:05:09,500
Well I'm going to get something that looks like this, right?

1263
01:05:11,700 --> 01:05:13,500
And this is obviously a carry.

1264
01:05:13,600 --> 01:05:17,100
So, if I take a look at the, the 110, here's my negative one.

1265
01:05:17,100 --> 01:05:22,000
Here is my to and hey, 110 is negative 2, right?

1266
01:05:22,400 --> 01:05:27,700
And the same thing, if I interpret them the other way 111 was 7, I

1267
01:05:27,700 --> 01:05:30,400
multiplied that right in.

1268
01:05:30,400 --> 01:05:33,200
I'm talking about an unsigned, I multiply that by 2.

1269
01:05:33,300 --> 01:05:35,000
I get 14 right?

1270
01:05:35,100 --> 01:05:37,200
14 is not representable here.

1271
01:05:37,500 --> 01:05:37,800
Okay.

1272
01:05:37,800 --> 01:05:41,400
That would be that would wrap around but hey guess what?

1273
01:05:41,500 --> 01:05:43,100
If I subtract.

1274
01:05:45,100 --> 01:05:49,500
if I actually look at what I would get, if I, if I were to multiply

1275
01:05:49,500 --> 01:05:52,400
multiply it and then, you know, do the wrap around

1276
01:05:54,500 --> 01:05:55,000
I guess.

1277
01:05:55,000 --> 01:05:56,000
Does that actually work out?

1278
01:05:56,000 --> 01:05:56,400
Right?

1279
01:05:56,900 --> 01:05:59,800
I get 110, which is 6, right?

1280
01:06:01,900 --> 01:06:03,000
It seems kind of odd, right?

1281
01:06:03,000 --> 01:06:07,700
Shouldn't I get if I have 7 times 2 is 14 unless I'm missing.

1282
01:06:07,700 --> 01:06:10,400
Something 14.

1283
01:06:13,800 --> 01:06:17,000
Should be 14 mod 7.

1284
01:06:19,700 --> 01:06:23,900
Let me see what this actually is that that's up to because that is

1285
01:06:23,900 --> 01:06:25,500
what the wraparound value is.

1286
01:06:25,600 --> 01:06:28,800
So let's make let's see if we can actually make that happen here.

1287
01:06:31,000 --> 01:06:33,200
Want to make sure that's actually true before I say it.

1288
01:06:36,000 --> 01:06:43,900
So, if I do two times seven, right and binary?

1289
01:06:44,500 --> 01:06:45,000
There we go.

1290
01:06:46,500 --> 01:06:53,500
And now I take 2 times 7 and I and it is, I don't actually know what

1291
01:06:53,500 --> 01:06:54,300
the rap I guess.

1292
01:06:55,700 --> 01:06:57,700
Trying to think if there's any way I can approximately because there's

1293
01:06:57,700 --> 01:06:59,900
no, there's no value obviously that would do that.

1294
01:06:59,900 --> 01:07:01,600
I guess I could do it with the 255 s.

1295
01:07:02,200 --> 01:07:03,800
So let's, I guess we could do that.

1296
01:07:04,200 --> 01:07:07,700
So if I take an unsigned care,

1297
01:07:08,800 --> 01:07:11,400
right of of

1298
01:07:14,500 --> 01:07:17,500
put this in code so it'll be a little bit easier, right?

1299
01:07:19,000 --> 01:07:24,900
So, if I take a, you ate and I set that equal to 128 and I said

1300
01:07:24,900 --> 01:07:26,500
another one, right?

1301
01:07:26,600 --> 01:07:31,400
Equal to 2 and I want to see what a times B is.

1302
01:07:31,900 --> 01:07:35,100
I'm interested to know what that will actually do, right?

1303
01:07:35,100 --> 01:07:37,100
And so let's do 255 in this case.

1304
01:07:37,100 --> 01:07:39,800
What we did is we did seven times two.

1305
01:07:39,800 --> 01:07:44,800
So, what we want to do here is take 255 times to write and see what it

1306
01:07:44,800 --> 01:07:47,400
actually produces when we do the multiplication.

1307
01:07:48,200 --> 01:07:48,600
Oops,

1308
01:07:55,900 --> 01:07:58,700
I want to make sure this actually produces something consistent.

1309
01:07:59,600 --> 01:08:02,200
All right, so let's see here.

1310
01:08:04,200 --> 01:08:07,700
So if we look at the binary,

1311
01:08:11,300 --> 01:08:11,800
there we go.

1312
01:08:13,300 --> 01:08:16,200
So it does exactly what we thought it would do.

1313
01:08:17,500 --> 01:08:23,700
And so if we take 255 times to, we actually get 510, right?

1314
01:08:24,200 --> 01:08:33,399
And so if you take 55 times 2, and you bought it, by the values, we

1315
01:08:33,399 --> 01:08:34,600
can actually represent.

1316
01:08:39,000 --> 01:08:40,000
You get to 54.

1317
01:08:41,700 --> 01:08:46,700
So that is definitely what happens with the multiplier which is

1318
01:08:46,700 --> 01:08:51,500
unsurprising but it's kind of a little non-intuitive the way that I

1319
01:08:51,500 --> 01:08:52,899
was writing that out, right?

1320
01:08:53,300 --> 01:08:57,700
Because we know what it should be equal to in that system but you end

1321
01:08:57,700 --> 01:08:58,500
up getting

1322
01:09:00,100 --> 01:09:04,800
Because they're sort of the phantom eight value that's their you end

1323
01:09:04,800 --> 01:09:07,800
up getting one less than that encoded value, right?

1324
01:09:07,800 --> 01:09:14,100
Because if you think about taking out that first seven, you actually

1325
01:09:14,100 --> 01:09:16,700
take out the first eight, right?

1326
01:09:16,800 --> 01:09:20,000
So if we look at like what happened with this 14, when we did two

1327
01:09:20,300 --> 01:09:24,399
times seven equals 14, right and then we see what the value was.

1328
01:09:24,399 --> 01:09:25,000
I was kind of thinking.

1329
01:09:25,000 --> 01:09:28,100
Well, okay, you're removing the first seven you should you should

1330
01:09:28,100 --> 01:09:29,899
still have 7 left over but really

1331
01:09:30,000 --> 01:09:34,300
Lee, when you wrap your technical removing the whole thing.

1332
01:09:34,300 --> 01:09:35,800
So it's actually two times.

1333
01:09:35,800 --> 01:09:38,700
Seven equals 14, minus 8 is the results.

1334
01:09:38,700 --> 01:09:39,700
You will get right?

1335
01:09:39,800 --> 01:09:41,800
Not 2 times 7 equals 14.

1336
01:09:41,899 --> 01:09:44,200
Minus 7, if that makes sense.

1337
01:09:44,899 --> 01:09:48,399
So it's actually the full end of your bit encoding.

1338
01:09:48,399 --> 01:09:52,399
Whatever that is, it's 2 to the M for that bid encoding.

1339
01:09:53,500 --> 01:09:54,400
So I don't know.

1340
01:09:54,800 --> 01:09:59,800
So that's kind of a little wonky but, you know,

1341
01:10:00,300 --> 01:10:00,800
What do you do?

1342
01:10:00,800 --> 01:10:02,500
Hey, man, that's binary, right.

1343
01:10:02,500 --> 01:10:05,300
That's just how that goes, but, again, that's only if you're

1344
01:10:05,300 --> 01:10:06,200
overflowing the values.

1345
01:10:06,200 --> 01:10:10,600
Anyway, so point being, yeah, two's complement.

1346
01:10:10,900 --> 01:10:13,500
That was just the unsigned case, but two's complement, and you could

1347
01:10:13,500 --> 01:10:15,600
see the negative case work just fine.

1348
01:10:16,100 --> 01:10:19,000
So all of its pretty straightforwardly, just the case.

1349
01:10:19,000 --> 01:10:23,200
That whenever you do an arithmetic up, if you encode them this way,

1350
01:10:23,300 --> 01:10:25,500
instead of encoding them in the other way, right?

1351
01:10:25,500 --> 01:10:28,300
The other way that I had talked about was if we had started doing it

1352
01:10:28,500 --> 01:10:29,900
like this, so that was - wow.

1353
01:10:30,100 --> 01:10:32,300
Um that was - 0 that's negative 1.

1354
01:10:32,300 --> 01:10:33,500
This is negative 2 negative 3.

1355
01:10:33,700 --> 01:10:36,700
That just does not help you because then you have two special case the

1356
01:10:36,700 --> 01:10:40,000
math because all of the math you were doing on unsigned is going to

1357
01:10:40,000 --> 01:10:42,700
produce the wrong results in signed, right?

1358
01:10:43,900 --> 01:10:51,400
Because hey when we did stuff like you know - when we did stuff like

1359
01:10:51,400 --> 01:10:57,700
this here, right, where we were doing two plus plus 5, right or 2 plus

1360
01:10:57,700 --> 01:10:59,600
negative 3, we're not going to get negative 1.

1361
01:10:59,600 --> 01:10:59,900
We're actually

1362
01:11:00,000 --> 01:11:03,900
- 3 4 2 plus -3 which doesn't really help us or I should say we were

1363
01:11:03,900 --> 01:11:09,100
going to get to plus that would have been 2 plus.

1364
01:11:11,800 --> 01:11:16,100
- 1 equals negative 3, right?

1365
01:11:16,100 --> 01:11:20,400
So that would have equal to plus negative 1 equals negative 3, which

1366
01:11:20,400 --> 01:11:21,500
really doesn't help anyone.

1367
01:11:21,500 --> 01:11:21,800
Right?

1368
01:11:21,800 --> 01:11:24,500
That's so you would have two special case the math.

1369
01:11:24,500 --> 01:11:27,300
If you didn't want to do it in two 2's complement, so

1370
01:11:37,900 --> 01:11:38,200
Cooper.

1371
01:11:38,200 --> 01:11:41,700
Caleb, why isn't two's complement used for floating Point numbers?

1372
01:11:41,700 --> 01:11:44,700
If it makes signed arithmetic easy.

1373
01:11:47,200 --> 01:11:47,900
Well.

1374
01:11:55,100 --> 01:11:55,900
I guess.

1375
01:11:57,700 --> 01:11:59,700
To be honest, I don't know.

1376
01:11:59,700 --> 01:11:59,900
I'm not

1377
01:12:00,100 --> 01:12:04,200
Enough of a low low level hard, very kind of guy to know the real

1378
01:12:04,200 --> 01:12:05,400
answer to that question.

1379
01:12:08,500 --> 01:12:13,800
but I would suspect that the reason is because in floating point,

1380
01:12:16,800 --> 01:12:21,800
You are never multiplying values that aren't in the range of 0 to 1,

1381
01:12:22,700 --> 01:12:24,900
so I or operating on values in that way.

1382
01:12:24,900 --> 01:12:29,900
So I don't know that it actually would help you because you already

1383
01:12:29,900 --> 01:12:31,800
have to deal with the fact.

1384
01:12:31,800 --> 01:12:32,200
Yeah.

1385
01:12:33,000 --> 01:12:34,900
So let's think about this.

1386
01:12:37,500 --> 01:12:40,600
So the way a floating-point number is typically encoded, right?

1387
01:12:40,600 --> 01:12:44,400
Is the sign bit is 1 bit always?

1388
01:12:44,800 --> 01:12:49,900
Then you have the exponent right, which is some number of bits, right?

1389
01:12:50,300 --> 01:12:51,900
And then you have the mantissa

1390
01:12:53,900 --> 01:12:56,500
which is some other number of bits, right?

1391
01:12:58,200 --> 01:13:01,700
And this is always like, usually there's an implicit one here.

1392
01:13:01,700 --> 01:13:07,000
So this, this is usually one point something is what's been coated in

1393
01:13:07,000 --> 01:13:08,400
here, right?

1394
01:13:08,700 --> 01:13:11,100
And then this is just telling you what the power is.

1395
01:13:11,100 --> 01:13:15,400
So it's like one point something times two to the whatever the

1396
01:13:15,400 --> 01:13:17,100
exponent is, right?

1397
01:13:18,900 --> 01:13:26,000
And so why you don't use two's complement here is I guess.

1398
01:13:28,600 --> 01:13:32,300
I'm trying to think, but, you know, once you have floating Point

1399
01:13:32,300 --> 01:13:36,000
values, I guess when you multiply two floating point or like, let's

1400
01:13:36,000 --> 01:13:40,000
say, you're going to add two floating Point values together, right?

1401
01:13:41,900 --> 01:13:46,100
What's going to happen is the exponent itself is what's going to

1402
01:13:46,100 --> 01:13:49,400
actually go up or down based on wrapping.

1403
01:13:50,700 --> 01:13:55,400
So if you have, I feel like if you have a negative number you've got

1404
01:13:55,400 --> 01:13:58,300
to know what to do with the exponents.

1405
01:13:58,400 --> 01:13:59,300
It's properly.

1406
01:13:59,500 --> 01:14:03,700
So I feel like, I don't know, I guess what?

1407
01:14:04,200 --> 01:14:05,200
Without

1408
01:14:07,000 --> 01:14:09,500
With the caveat that I just said which is like I'm the wrong guy to

1409
01:14:09,500 --> 01:14:10,000
ask.

1410
01:14:10,100 --> 01:14:13,400
I would suspect that the reason is because because the exponent is

1411
01:14:13,400 --> 01:14:18,700
pulled out, it's not going to just work either way, right?

1412
01:14:19,800 --> 01:14:23,100
So I feel like you probably would just

1413
01:14:25,500 --> 01:14:28,800
It's probably the exponent that actually is the thing that's going to

1414
01:14:28,800 --> 01:14:29,400
do that work.

1415
01:14:29,400 --> 01:14:33,200
And so you know, I wouldn't be surprised if you wanted to support to

1416
01:14:33,200 --> 01:14:36,600
store the exponent in two's complement.

1417
01:14:37,500 --> 01:14:38,800
Which I guess, you know, I don't even know.

1418
01:14:38,800 --> 01:14:39,900
Does that what they normally do?

1419
01:14:39,900 --> 01:14:43,400
It's been a long time since I've looked floating-point two's

1420
01:14:43,400 --> 01:14:45,800
complement exponents.

1421
01:14:55,700 --> 01:14:56,500
Let's see here.

1422
01:15:01,600 --> 01:15:06,000
That is not actually how they are stored.

1423
01:15:06,600 --> 01:15:08,200
That is something else.

1424
01:15:08,200 --> 01:15:09,600
This is not what we want.

1425
01:15:11,000 --> 01:15:12,600
Let's see, fluid numbers.

1426
01:15:12,600 --> 01:15:18,300
X1 is biased, sort of the actual value by the exponent bias because

1427
01:15:18,300 --> 01:15:20,400
they're assigned values in order to be able to represent battalions.

1428
01:15:20,400 --> 01:15:21,400
But two's complement you.

1429
01:15:21,400 --> 01:15:22,000
So yes,

1430
01:15:26,600 --> 01:15:29,700
so the problem is most manager Stuart but just against by to put with

1431
01:15:29,700 --> 01:15:32,000
the outside range so it looks like

1432
01:15:35,800 --> 01:15:39,400
Interesting, these are for a sign guys, would make comparison harder.

1433
01:15:40,400 --> 01:15:44,100
Okay, when interpreting the floating-point number, the by subtracted.

1434
01:15:44,100 --> 01:15:48,600
So it looks like at least in standard IEEE, you know, they don't store

1435
01:15:48,600 --> 01:15:51,700
that in two's complement either, but it's kind of cryptic, they just

1436
01:15:51,700 --> 01:15:53,200
say, would make comparison harder.

1437
01:15:53,200 --> 01:15:56,000
So again, we probably want to ask someone who's an expert in this

1438
01:15:56,000 --> 01:16:00,900
thing to have an opinion on it because mine is kind of not worth

1439
01:16:00,900 --> 01:16:01,300
anything.

1440
01:16:03,500 --> 01:16:09,800
So yeah, so I guess they do not do that, but I don't necessarily know

1441
01:16:09,800 --> 01:16:10,100
why.

1442
01:16:10,100 --> 01:16:13,600
So what they do instead is they just store it, you know, it goes from

1443
01:16:13,600 --> 01:16:16,200
zero to something, you know, like if it goes from 0 to 255, or

1444
01:16:16,200 --> 01:16:21,100
whatever 02 128, they're just like, oh well, the first 64 values are

1445
01:16:21,100 --> 01:16:23,800
positive in the next, ER, you know where the first 64 values are

1446
01:16:23,800 --> 01:16:27,000
negative, rather than the next ones are positive.

1447
01:16:27,000 --> 01:16:31,400
So we assume that it's always, you know, the Value Plus 64 is what we

1448
01:16:31,400 --> 01:16:32,500
actually encoded.

1449
01:16:35,800 --> 01:16:36,400
Two shoes.

1450
01:16:36,400 --> 01:16:39,300
Are you not going to profile it to see how much faster it gets?

1451
01:16:39,700 --> 01:16:42,300
No, I'm not going to profile the audio mixer not this point.

1452
01:16:42,300 --> 01:16:45,900
Anyway like I said, I'm not really thinking of optimizing and I'm just

1453
01:16:45,900 --> 01:16:48,000
trying to make sure that it's can run for wide.

1454
01:16:56,300 --> 01:16:58,400
When you implemented streaming in chunks of audio, believe the code

1455
01:16:58,400 --> 01:16:58,900
actually loads.

1456
01:16:58,900 --> 01:17:00,800
The entire file with a platform, like a virtual lock.

1457
01:17:00,800 --> 01:17:03,300
For each chunk, is this just an artifact of the debug nature that

1458
01:17:03,300 --> 01:17:03,600
code?

1459
01:17:03,600 --> 01:17:03,900
Yes.

1460
01:17:03,900 --> 01:17:09,000
So, like I said before, all of that loading code is going to be

1461
01:17:09,000 --> 01:17:13,200
replaced with just pulls out of the asset file.

1462
01:17:14,400 --> 01:17:16,000
So we don't care what that does.

1463
01:17:16,100 --> 01:17:20,700
As debug load wave, and debug load bitmap are complete, throw away,

1464
01:17:20,700 --> 01:17:22,000
they can do whatever they want.

1465
01:17:22,000 --> 01:17:24,500
They can allocate all the memory in the machine as long as they don't

1466
01:17:24,500 --> 01:17:25,300
crash our code.

1467
01:17:25,800 --> 01:17:27,800
We don't care what they do at all.

1468
01:17:28,500 --> 01:17:31,100
They just need to get us back the data for testing.

1469
01:17:35,000 --> 01:17:37,200
Does the audio make the frame rate in debug mode?

1470
01:17:37,300 --> 01:17:37,800
Yes.

1471
01:17:38,000 --> 01:17:41,600
When we don't run, it's really just the renderer.

1472
01:17:41,900 --> 01:17:44,900
That is the, that's the slow part, right?

1473
01:17:46,100 --> 01:17:51,900
So, because when the, when the renderer is running in debug mode, it's

1474
01:17:51,900 --> 01:17:52,500
much slower.

1475
01:17:52,500 --> 01:17:55,200
And that's you can see how slow it is even at the lower resolution.

1476
01:17:55,700 --> 01:17:59,800
So it makes the framerate just fine if we turn it.

1477
01:18:00,000 --> 01:18:03,400
On the resolution so you can see this is running in low res right now.

1478
01:18:03,900 --> 01:18:08,100
But when we turn it up to 1920 by 1080 that's when we in debug builds

1479
01:18:08,100 --> 01:18:10,300
it won't run fast enough and release filter runs just fine.

1480
01:18:11,300 --> 01:18:13,800
So yeah, that's just the nature of a software rasterizer it needs to

1481
01:18:13,800 --> 01:18:15,500
be optimized highly, right?

1482
01:18:16,100 --> 01:18:19,500
So one thing I was saying before and I think we could probably do this

1483
01:18:19,500 --> 01:18:20,700
pretty easily.

1484
01:18:22,200 --> 01:18:23,600
I suspect.

1485
01:18:23,600 --> 01:18:26,000
I mean I guess I don't know but like one thing that I was thinking we

1486
01:18:26,000 --> 01:18:29,900
could do pretty easily is in our build right now you

1487
01:18:30,000 --> 01:18:38,200
You could imagine pulling out a just just pulling out the compilation

1488
01:18:38,200 --> 01:18:43,200
step for just the render code if that makes sense and making that

1489
01:18:43,200 --> 01:18:45,600
compile with optimizations on.

1490
01:18:46,200 --> 01:18:51,000
And I don't know if that's, you know, the most efficacious way to do

1491
01:18:51,000 --> 01:18:54,900
it or anything like that, but you could imagine doing it so that we do

1492
01:18:54,900 --> 01:18:59,400
something like handmade optimized

1493
01:19:00,100 --> 01:19:01,300
Or something like that.

1494
01:19:01,800 --> 01:19:06,900
And then we did, you know, this sort of nonsense here, right and made

1495
01:19:06,900 --> 01:19:08,700
optimized dot CPP.

1496
01:19:10,000 --> 01:19:16,500
And we did something like, you know, don't don't actually link that

1497
01:19:16,500 --> 01:19:16,800
guy.

1498
01:19:16,800 --> 01:19:25,200
Just just do not put any of this stuff and just output in an object

1499
01:19:25,200 --> 01:19:25,700
file.

1500
01:19:26,200 --> 01:19:29,800
I think that's mine is see is usually the thing for that.

1501
01:19:30,500 --> 01:19:34,400
Let's take a look code generation.

1502
01:19:35,300 --> 01:19:36,900
Where is the actual?

1503
01:19:37,000 --> 01:19:40,200
Whereas the actual call for that now, see, is don't strip comments.

1504
01:19:40,200 --> 01:19:41,300
That's not going to help us.

1505
01:19:42,000 --> 01:19:44,500
I just want to build just an obj.

1506
01:19:46,300 --> 01:19:48,400
What would I do for that?

1507
01:19:49,500 --> 01:19:52,200
Let's see, linking LG.

1508
01:19:52,200 --> 01:19:54,200
No, no, that's not what I want.

1509
01:19:54,200 --> 01:19:59,100
Miscellaneous know, like, let's see, output files, code generation.

1510
01:20:04,100 --> 01:20:10,600
I'm not seeing it, let's see.

1511
01:20:13,000 --> 01:20:16,800
There should just be a way for me to just I haven't done this in a

1512
01:20:16,800 --> 01:20:17,700
very long time.

1513
01:20:17,700 --> 01:20:20,400
I just compile everything but there's just a there's just one flag

1514
01:20:20,400 --> 01:20:22,400
that you put which is just like hey by the way

1515
01:20:24,700 --> 01:20:26,300
Just compiled just to when I would be J.

1516
01:20:26,300 --> 01:20:29,400
Don't produce an executable, don't do anything else.

1517
01:20:29,400 --> 01:20:32,400
Fancy can I just search for it?

1518
01:20:32,900 --> 01:20:34,300
See look like to less

1519
01:20:36,000 --> 01:20:36,700
It's question.

1520
01:20:37,500 --> 01:20:38,900
And if I search for

1521
01:20:40,300 --> 01:20:41,100
Obj.

1522
01:20:42,900 --> 01:20:43,400
No.

1523
01:20:47,200 --> 01:20:51,500
Maybe if I just do / f 0, it will just end specify the output object

1524
01:20:51,500 --> 01:20:52,200
file name.

1525
01:20:52,500 --> 01:20:54,400
It will infer that.

1526
01:20:54,400 --> 01:20:55,500
That's what I want to do.

1527
01:20:55,600 --> 01:20:59,600
I don't actually know but let's try it right.

1528
01:21:00,500 --> 01:21:04,000
- fo and there we go.

1529
01:21:06,200 --> 01:21:12,100
So let's see if that does anything for us - 02.

1530
01:21:13,200 --> 01:21:18,900
And if I just make in here handmade optimized dot CPP, right?

1531
01:21:18,900 --> 01:21:19,900
What happens.

1532
01:21:19,900 --> 01:21:23,600
There looks good.

1533
01:21:23,600 --> 01:21:26,300
So let's go ahead and go into render group.

1534
01:21:26,900 --> 01:21:33,000
And you know if we were to pull the straw rectangle quickly out here,

1535
01:21:34,200 --> 01:21:36,400
See you go.

1536
01:21:38,600 --> 01:21:39,700
Would that work?

1537
01:21:40,400 --> 01:21:41,400
I don't actually know.

1538
01:21:42,500 --> 01:21:46,000
So the first thing we have to do is we'd have to include like handmade

1539
01:21:46,000 --> 01:21:52,400
.h probably and the other thing that we have to do, this would come in

1540
01:21:52,400 --> 01:21:52,900
here.

1541
01:21:54,300 --> 01:21:54,800
Right.

1542
01:21:57,400 --> 01:21:59,000
and,

1543
01:22:01,100 --> 01:22:04,600
Declared but up finds out we would have to deal with a bunch of

1544
01:22:04,900 --> 01:22:07,000
annoying things.

1545
01:22:07,000 --> 01:22:10,100
Like the fact that I declare some Statics that don't get called

1546
01:22:10,300 --> 01:22:14,200
unfortunately but that would be mostly it.

1547
01:22:14,200 --> 01:22:20,200
So all I'd really have to do isn't handmade dot h at that point I

1548
01:22:20,200 --> 01:22:23,200
would just have to say, I guess in handmade render group.

1549
01:22:23,500 --> 01:22:29,000
Maybe I just have to say, Hey, you know, there's this file that you're

1550
01:22:29,000 --> 01:22:29,800
going to link with

1551
01:22:30,900 --> 01:22:34,100
It's external that you're going to link with and there you go.

1552
01:22:36,100 --> 01:22:39,300
There's always gonna soon will draw a rectangle quickly that's true

1553
01:22:39,300 --> 01:22:40,300
because of this.

1554
01:22:40,400 --> 01:22:44,200
So all we would really have to do now is figure out how to get around

1555
01:22:44,200 --> 01:22:45,500
that static function.

1556
01:22:47,700 --> 01:22:52,800
I'm not sure exactly what to do about that.

1557
01:22:53,100 --> 01:22:56,800
Probably I would do something like this where I would go.

1558
01:22:56,800 --> 01:23:00,400
Okay, wherever internal is actually gets to

1559
01:23:00,700 --> 01:23:02,900
find which is probably in handmade platform.

1560
01:23:07,400 --> 01:23:12,600
Wherever internal gets defined, I would do something like this if not

1561
01:23:12,700 --> 01:23:14,100
find internal.

1562
01:23:15,800 --> 01:23:17,600
Define internal, right?

1563
01:23:17,600 --> 01:23:21,700
Like that and then that way you could just say in the optimize thing.

1564
01:23:21,700 --> 01:23:23,100
Oh yeah all that stuff.

1565
01:23:23,100 --> 01:23:26,500
I said was internal I didn't really mean it.

1566
01:23:28,600 --> 01:23:29,200
You know I'm saying?

1567
01:23:31,500 --> 01:23:33,600
So yeah, so we could definitely do it that way.

1568
01:23:35,100 --> 01:23:41,300
We've got debug Global memory is is a unresolved external.

1569
01:23:41,300 --> 01:23:44,700
So that's got to be an extern, you both Global memory.

1570
01:23:45,900 --> 01:23:47,600
So let's take care of that.

1571
01:23:47,700 --> 01:23:48,900
You both Global memory.

1572
01:23:52,700 --> 01:23:54,200
Let's see here.

1573
01:23:57,400 --> 01:23:59,500
Typical memory is memory.

1574
01:24:01,800 --> 01:24:03,100
Why is that?

1575
01:24:06,200 --> 01:24:07,400
That's an extra in though.

1576
01:24:07,400 --> 01:24:09,900
I don't know why that is not

1577
01:24:11,700 --> 01:24:14,400
Why is that an unresolved external symbol?

1578
01:24:14,400 --> 01:24:17,400
Oh, because it's still trying to build the whole thing, isn't it?

1579
01:24:19,100 --> 01:24:19,900
Let's take a look.

1580
01:24:20,500 --> 01:24:21,800
I think this is almost it though.

1581
01:24:22,600 --> 01:24:23,000
So, yeah.

1582
01:24:23,000 --> 01:24:24,000
If I get rid of this.

1583
01:24:25,000 --> 01:24:25,500
Yeah.

1584
01:24:26,000 --> 01:24:29,200
So I just need the switch now, that'll tell it, please don't build a

1585
01:24:29,200 --> 01:24:30,100
whole thing.

1586
01:24:30,600 --> 01:24:33,000
I don't want, you know, don't link.

1587
01:24:34,000 --> 01:24:35,000
Can I do that?

1588
01:24:35,000 --> 01:24:36,000
How do I not link?

1589
01:24:37,700 --> 01:24:38,200
Let's see.

1590
01:24:38,200 --> 01:24:44,200
Here, CL compile C file to obj.

1591
01:24:44,500 --> 01:24:45,400
It's all I want.

1592
01:24:46,400 --> 01:24:47,600
It is / C.

1593
01:24:50,400 --> 01:24:54,200
But it didn't seem to didn't seem to be it.

1594
01:24:54,400 --> 01:24:55,900
Am I, am I nuts?

1595
01:24:59,700 --> 01:25:00,900
So confused right now.

1596
01:25:01,400 --> 01:25:01,600
Yeah.

1597
01:25:01,700 --> 01:25:02,400
But that was it.

1598
01:25:03,100 --> 01:25:09,500
So if we want to, that's one thing we can do and I think that should

1599
01:25:09,500 --> 01:25:10,500
fix it for us.

1600
01:25:12,900 --> 01:25:16,400
So let's let's double-check them in 32 handmade.

1601
01:25:18,500 --> 01:25:22,800
So with optimizations on now that one file that the draw a rectangle

1602
01:25:22,800 --> 01:25:24,900
quickly should be optimized.

1603
01:25:24,900 --> 01:25:29,700
So if I go ahead and look for the 1920, if we switch back to high-res

1604
01:25:29,700 --> 01:25:33,300
mode Let's see if we can run good speed.

1605
01:25:34,800 --> 01:25:35,200
Yeah.

1606
01:25:36,900 --> 01:25:42,200
So that's probably what we should do is leave the bill ballet because

1607
01:25:42,200 --> 01:25:44,800
that way we've got one file that we can just always leave

1608
01:25:44,800 --> 01:25:46,500
optimizations on for

1609
01:25:47,000 --> 01:25:51,700
And so only when we're actually debugging that, will we ever have to

1610
01:25:51,700 --> 01:25:54,900
actually switch out and everything else can always just be in debug

1611
01:25:54,900 --> 01:25:58,300
mode because our render Loop is the only thing that needs that

1612
01:25:58,300 --> 01:25:59,300
optimization.

1613
01:25:59,800 --> 01:26:14,000
So keeper, Caleb, if 1111 is supposed to be less than 0, 0.

1614
01:26:14,000 --> 01:26:16,800
0 0, then how do number comparisons were

1615
01:26:16,900 --> 01:26:18,600
Work on the CPU level.

1616
01:26:19,100 --> 01:26:24,900
I believe that number comparisons are special cased, so those are not

1617
01:26:24,900 --> 01:26:30,500
generic if that makes sense, but you can pretty easily take a look

1618
01:26:30,600 --> 01:26:31,300
actually.

1619
01:26:31,700 --> 01:26:36,600
So, what you can do is, for example, if you want to look here, here's

1620
01:26:36,600 --> 01:26:38,900
a signed 8-bit value, right?

1621
01:26:39,600 --> 01:26:42,900
- 100 here is a, a

1622
01:26:44,500 --> 01:26:51,000
Another one and then here are two unsigned ones.

1623
01:26:54,200 --> 01:26:54,900
Right?

1624
01:26:55,700 --> 01:26:59,800
And so if I do something like that,

1625
01:27:00,000 --> 01:27:02,600
32A because a less than b.

1626
01:27:04,500 --> 01:27:07,200
CD c less than bait.

1627
01:27:07,900 --> 01:27:08,600
Right?

1628
01:27:08,900 --> 01:27:16,500
So if I do that and then step in and look at the code, right, what we

1629
01:27:16,500 --> 01:27:17,600
can see here

1630
01:27:18,800 --> 01:27:20,700
Is what the assembly actually produces.

1631
01:27:20,700 --> 01:27:23,600
So if you right click and this is a good thing for to do any time

1632
01:27:23,600 --> 01:27:26,600
you're curious about this stuff, just take a look at the assembly

1633
01:27:26,600 --> 01:27:27,700
does, right?

1634
01:27:27,700 --> 01:27:30,800
Just take a look and then we can see.

1635
01:27:31,500 --> 01:27:32,900
So let's take a look.

1636
01:27:33,100 --> 01:27:35,400
We go ahead and do move.

1637
01:27:35,400 --> 01:27:39,700
S, SX, move SX, we load in the A and the B.

1638
01:27:39,800 --> 01:27:41,800
We compare the two, right?

1639
01:27:41,800 --> 01:27:47,700
Is X EC X, which is just trying to see what these two values are

1640
01:27:47,700 --> 01:27:48,400
actually looking like these.

1641
01:27:48,500 --> 01:27:53,100
To the sound comparison and then we do jump greater than or equal to,

1642
01:27:54,500 --> 01:27:56,100
which is what we would expect.

1643
01:27:56,100 --> 01:27:58,300
So they now they do exactly the same thing.

1644
01:27:58,800 --> 01:28:00,500
So they must be able to do.

1645
01:28:00,500 --> 01:28:01,300
The comparison.

1646
01:28:01,300 --> 01:28:06,300
Must do like a subtract on them that would, then it would then look to

1647
01:28:06,300 --> 01:28:06,900
see.

1648
01:28:06,900 --> 01:28:08,600
In fact, now that I think about it that would be fine.

1649
01:28:08,600 --> 01:28:09,100
Right?

1650
01:28:09,500 --> 01:28:12,000
Because what's greater than less than going to actually do?

1651
01:28:12,100 --> 01:28:15,500
It's going to do, you know, a

1652
01:28:16,900 --> 01:28:17,900
It's going to do.

1653
01:28:19,700 --> 01:28:23,800
Probably some kind of like a subtraction on the two values and then

1654
01:28:23,800 --> 01:28:29,200
look to see whether it's greater than or equal to the high-value right

1655
01:28:29,600 --> 01:28:29,700
now.

1656
01:28:29,700 --> 01:28:30,700
Let's think about this.

1657
01:28:32,000 --> 01:28:32,500
I don't know.

1658
01:28:32,500 --> 01:28:33,100
It's a good question.

1659
01:28:33,100 --> 01:28:33,900
Let's take a look.

1660
01:28:35,900 --> 01:28:42,600
but the answer is you can kind of see your comp J JG e jump right comp

1661
01:28:42,700 --> 01:28:50,600
jge jump so it does not care in any way which is which so let's take a

1662
01:28:50,600 --> 01:28:54,700
look at that that instruction comp x 36

1663
01:28:56,900 --> 01:28:58,300
compare two operands.

1664
01:29:00,100 --> 01:29:02,500
So, let's see here.

1665
01:29:04,800 --> 01:29:08,100
Set the status Flags, according to the results.

1666
01:29:08,100 --> 01:29:10,500
The comparison is performed by subtracting the second operator, for

1667
01:29:10,500 --> 01:29:13,500
the first operand and then setting the status Flags in the same manner

1668
01:29:13,800 --> 01:29:15,100
as the sub instruction.

1669
01:29:15,400 --> 01:29:17,400
When an immediate value is used as an operand.

1670
01:29:17,400 --> 01:29:20,500
It is sign extended to the length of the first operand.

1671
01:29:21,700 --> 01:29:22,400
So yeah.

1672
01:29:22,400 --> 01:29:23,700
So

1673
01:29:26,000 --> 01:29:27,800
It looks like.

1674
01:29:29,300 --> 01:29:34,100
So it looks like to me and these are encoded the same 3, BC one.

1675
01:29:34,300 --> 01:29:39,600
It looks like to me that that subtraction actually just works, right?

1676
01:29:41,600 --> 01:29:42,500
Let's see here.

1677
01:29:44,300 --> 01:29:47,300
It's a size by subtracting the second with Arista and then say, let's

1678
01:29:47,300 --> 01:29:47,600
see.

1679
01:29:47,800 --> 01:29:52,700
So let's see if we can make sense of that by looking at the table,

1680
01:29:52,900 --> 01:29:53,400
right?

1681
01:29:55,400 --> 01:29:56,600
So what I want to know, right?

1682
01:29:56,600 --> 01:29:59,900
Is If I subtract one value from another value, if

1683
01:30:00,000 --> 01:30:01,500
Want to do a less than comparison.

1684
01:30:01,500 --> 01:30:05,600
I want to know if these two values are less than each other, right.

1685
01:30:06,600 --> 01:30:10,200
Well, if I go ahead and subtract the two values like, you know, let's

1686
01:30:10,200 --> 01:30:13,600
say, I say, I want to know if negative three is less than 2 or

1687
01:30:13,600 --> 01:30:14,400
something like this.

1688
01:30:17,400 --> 01:30:19,500
What I and I subtract I subtract the two of them.

1689
01:30:20,000 --> 01:30:25,200
If I do too - -3 that would actually wrap me, I guess, I guess I need

1690
01:30:25,200 --> 01:30:26,200
smaller numbers here.

1691
01:30:26,700 --> 01:30:28,400
So let's say I do 2.

1692
01:30:28,400 --> 01:30:31,600
Minus minus 1 which would put me up to three in here.

1693
01:30:31,600 --> 01:30:35,000
It would be to compared to 7, right?

1694
01:30:35,600 --> 01:30:41,500
And that would also put me up to three right due to rapping

1695
01:30:43,100 --> 01:30:46,900
Now, if I were to do the opposite way round, right?

1696
01:30:47,400 --> 01:30:51,200
So I was to do two compared to negative one.

1697
01:30:51,200 --> 01:30:54,400
So I'm going to do negative 1 minus 2, right?

1698
01:30:54,400 --> 01:30:58,200
That would put me up to negative 3 and same here.

1699
01:30:58,200 --> 01:30:59,100
Put up 25.

1700
01:30:59,600 --> 01:31:06,100
So I wonder if you can basically just do is the value right after I

1701
01:31:06,100 --> 01:31:06,400
do.

1702
01:31:06,400 --> 01:31:09,100
The subtract is the value negative.

1703
01:31:10,000 --> 01:31:12,700
If the value is negative, then that's my answer.

1704
01:31:12,900 --> 01:31:15,500
Or if the value is positive then that's my answer, right?

1705
01:31:15,500 --> 01:31:18,000
Greater than or less than because

1706
01:31:19,100 --> 01:31:22,000
Yeah, if you think about it, that should just always work, right?

1707
01:31:22,100 --> 01:31:26,300
Because if the values, we don't care, whether the values are signed or

1708
01:31:26,300 --> 01:31:30,800
unsigned to some degree at that point, as long as that behavior is

1709
01:31:30,800 --> 01:31:31,700
consistent,

1710
01:31:34,300 --> 01:31:36,800
So, yeah, I think that's actually fine.

1711
01:31:37,000 --> 01:31:40,300
If I want to know if 2 is less than 5, right?

1712
01:31:41,000 --> 01:31:45,900
Let's say, so let's say, I do 5, minus 2 that equals 3, right?

1713
01:31:45,900 --> 01:31:49,100
If I do 2, minus 5, right?

1714
01:31:50,000 --> 01:31:57,500
So 2, minus 5 would be 1 2, 3 4 5, right?

1715
01:31:59,000 --> 01:31:59,600
Is that correct?

1716
01:31:59,600 --> 01:32:01,800
One, two, three, four, five.

1717
01:32:02,700 --> 01:32:04,500
That's right, right.

1718
01:32:07,400 --> 01:32:10,900
So yeah, it totally, I think that totally works.

1719
01:32:12,000 --> 01:32:16,000
So again, don't we're kind of out of time, but like I think it looks

1720
01:32:16,000 --> 01:32:18,600
like they don't have to be such a case that all it looks like you

1721
01:32:18,600 --> 01:32:22,300
could just literally use the signed math on any value.

1722
01:32:22,300 --> 01:32:25,400
When you do the comparison, even though it's unsigned.

1723
01:32:25,900 --> 01:32:29,800
And then whether or not the value would have been - in signed tells

1724
01:32:29,800 --> 01:32:32,400
you the answer in the comparison, whether it's signed or unsigned,

1725
01:32:33,000 --> 01:32:33,900
it's kind of magical,

1726
01:32:40,700 --> 01:32:43,500
Do you have any tips for speeding up compile time when using multiple

1727
01:32:43,500 --> 01:32:44,600
translation units?

1728
01:32:47,100 --> 01:32:51,400
Yeah, a few but it depends on the circumstances that probably be a

1729
01:32:51,400 --> 01:32:53,000
better question for when we have more time.

1730
01:32:56,400 --> 01:32:58,500
It's move, SX4 signed.

1731
01:33:08,500 --> 01:33:09,600
It well.

1732
01:33:09,700 --> 01:33:12,800
But that's that doesn't really have anything to do with it Sean though

1733
01:33:13,100 --> 01:33:16,200
because that's just making sure that it's sign extends the value,

1734
01:33:16,700 --> 01:33:17,200
right?

1735
01:33:17,700 --> 01:33:21,200
That's just making sure that because we're doing these on full-on, you

1736
01:33:21,200 --> 01:33:23,900
know, not on 8-bit registers.

1737
01:33:24,000 --> 01:33:24,500
Right?

1738
01:33:24,600 --> 01:33:28,100
That's just making sure that it loads in the values sign extended.

1739
01:33:29,000 --> 01:33:30,200
I don't think it changes the way.

1740
01:33:30,200 --> 01:33:31,600
The comparison works at all.

1741
01:33:31,600 --> 01:33:32,200
That makes sense.

1742
01:33:32,200 --> 01:33:32,700
Right.

1743
01:33:32,700 --> 01:33:36,300
So when it loads in these guys, right?

1744
01:33:36,300 --> 01:33:37,000
It's gonna

1745
01:33:38,300 --> 01:33:41,800
If we go to this assembly, when it loads in these guys with a sign

1746
01:33:41,800 --> 01:33:44,100
it's just going to sign extend them, right?

1747
01:33:44,100 --> 01:33:47,500
That's that's all that's doing because the value was only 8 Bits.

1748
01:33:47,500 --> 01:33:49,200
And now it's I'm extending, right?

1749
01:33:49,200 --> 01:33:52,300
Same thing with these guys sign extension.

1750
01:33:52,700 --> 01:33:55,500
So I'm pretty sure that it doesn't affect this at all.

1751
01:33:55,600 --> 01:34:00,100
That's literally just because of the of the fact that needs to sign

1752
01:34:00,100 --> 01:34:00,800
extend them.

1753
01:34:02,600 --> 01:34:03,400
Does that make sense?

1754
01:34:04,500 --> 01:34:07,300
All right, we have come to the end.

1755
01:34:07,900 --> 01:34:09,900
We have come to the end folks.

1756
01:34:11,400 --> 01:34:12,800
Yeah.

1757
01:34:15,200 --> 01:34:18,400
So, you know, not the best handmade hero stream, I was kind of out to

1758
01:34:18,400 --> 01:34:21,500
lunch today, it's true, but that just happens sometimes, you know,

1759
01:34:21,600 --> 01:34:27,500
can't always be on top of it and especially because it is so hot here.

1760
01:34:27,500 --> 01:34:29,100
I am literally melting.

1761
01:34:30,300 --> 01:34:31,600
Well I guess I'm not literally melting.

1762
01:34:31,600 --> 01:34:34,900
I just feel like I'm literally melting because I feels like my skin is

1763
01:34:34,900 --> 01:34:35,700
melting off.

1764
01:34:35,700 --> 01:34:39,100
Me in a very real and literal sense.

1765
01:34:39,800 --> 01:34:43,900
Okay, let's get rid of these guys here and let's leave that guy.

1766
01:34:44,900 --> 01:34:51,000
Is we can also if we want to maybe let's see common compiler Flags.

1767
01:34:51,900 --> 01:34:56,300
What we could do here is some kind of an OD 02 thing.

1768
01:34:57,300 --> 01:35:00,800
I don't, I don't know how we want that to play out.

1769
01:35:02,900 --> 01:35:04,900
I don't know how you unknown how you tell it.

1770
01:35:04,900 --> 01:35:08,000
I don't care about that but we can worry about that in a future

1771
01:35:08,000 --> 01:35:08,300
stream.

1772
01:35:08,300 --> 01:35:10,000
I suppose so.

1773
01:35:10,000 --> 01:35:12,500
Okay, we're all good, I guess.

1774
01:35:12,500 --> 01:35:13,600
I don't want to actually exit.

1775
01:35:13,600 --> 01:35:15,600
We saw how long it takes to load Mischief.

1776
01:35:15,600 --> 01:35:18,100
So we'll just leave that up and running until Monday.

1777
01:35:19,100 --> 01:35:20,900
And we'll go ahead and close these guys off.

1778
01:35:21,700 --> 01:35:24,000
All right, thank you, everyone for joining me for another episode of

1779
01:35:24,000 --> 01:35:24,400
handmade here.

1780
01:35:24,400 --> 01:35:27,600
It's been a pleasure coding with you, as always, if you would like to

1781
01:35:27,600 --> 01:35:30,700
follow along with the source code at home, you always can handmade

1782
01:35:30,700 --> 01:35:31,700
here it out or you can pre-order.

1783
01:35:31,700 --> 01:35:32,500
The game comes with the

1784
01:35:32,600 --> 01:35:36,800
Full source code and you can go right ahead and tweak it.

1785
01:35:36,900 --> 01:35:38,400
Play with it experiment.

1786
01:35:38,400 --> 01:35:39,400
See how it goes.

1787
01:35:40,000 --> 01:35:41,400
Which is a great way to learn from the stream.

1788
01:35:41,700 --> 01:35:42,500
We also have Forum site.

1789
01:35:42,500 --> 01:35:45,100
You can ask questions, get forced to Mac or Linux and stuff like that

1790
01:35:45,100 --> 01:35:45,600
for trying to follow.

1791
01:35:45,600 --> 01:35:49,000
Along with those, you can also see an anti-democratic episode guide

1792
01:35:49,000 --> 01:35:49,700
maintained by the community.

1793
01:35:49,700 --> 01:35:50,400
It's pretty cool.

1794
01:35:50,500 --> 01:35:52,800
We have a patreon page if you want to support the video series, we

1795
01:35:52,800 --> 01:35:54,000
have a tweet bought the Tweet schedule.

1796
01:35:54,000 --> 01:35:56,500
You're trying to catch us live and in fact now would be a good time to

1797
01:35:56,500 --> 01:35:58,800
subscribe to that because this weekend will be posting schedule for

1798
01:35:58,800 --> 01:35:59,800
next week as we do.

1799
01:36:00,000 --> 01:36:02,600
Weekend and the sweet part is what will tell you when the video stream

1800
01:36:02,600 --> 01:36:03,300
is live.

1801
01:36:03,600 --> 01:36:07,900
So we'll be back here Monday and I will go ahead and drop the main

1802
01:36:07,900 --> 01:36:11,000
mixer Loop into s SE and then we will pretty much be done with audio.

1803
01:36:11,000 --> 01:36:14,000
I think there's not really much else you want to do, so we'll be able

1804
01:36:14,000 --> 01:36:20,500
to ping ping pong, back to our asset loader button up, how we want to

1805
01:36:20,500 --> 01:36:23,600
do the memory and then Define the asset file, and that'll be it.

1806
01:36:24,000 --> 01:36:27,000
And then, we could finally be loading out of a real asset file.

1807
01:36:27,200 --> 01:36:29,900
I'll make one for us and then we

1808
01:36:30,000 --> 01:36:31,700
and yeah, we can party on it.

1809
01:36:31,700 --> 01:36:34,100
It's going to be pretty wild actually.

1810
01:36:34,200 --> 01:36:36,300
So many of these things, getting checked off, audios going to get

1811
01:36:36,300 --> 01:36:39,200
checked off asset, loading that checked off, render is actually not

1812
01:36:39,200 --> 01:36:40,200
that far from being checked off.

1813
01:36:40,200 --> 01:36:43,800
Its got to go work on the lighting a little bit, letting particles

1814
01:36:43,900 --> 01:36:44,600
it's going to be good.

1815
01:36:44,800 --> 01:36:49,600
We're getting their people, we're getting there slowly, but surely

1816
01:36:50,200 --> 01:36:51,200
just like the little turtle.

1817
01:36:52,600 --> 01:36:55,500
All right, so that's about it.

1818
01:36:55,600 --> 01:36:58,100
I hope to see everyone back here on Monday until then have a great

1819
01:36:58,100 --> 01:36:59,900
weekend and

1820
01:37:00,000 --> 01:37:03,500
And, yeah, if you're doing any coding this weekend, best of luck

1821
01:37:03,500 --> 01:37:04,100
coding to you.

1822
01:37:04,100 --> 01:37:05,800
I will be doing some coding this weekend as well.

1823
01:37:06,000 --> 01:37:09,100
So hopefully, I'll see you on the Twitter's stop by and say hi.

1824
01:37:09,400 --> 01:37:09,800
Take care.

1825
01:37:09,800 --> 01:37:11,300
Everyone will see you on Monday.

