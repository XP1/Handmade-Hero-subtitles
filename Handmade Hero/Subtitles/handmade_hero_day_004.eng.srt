1
00:00:00,000 --> 00:00:01,200
Start recording.

2
00:00:03,300 --> 00:00:03,900
Okay.

3
00:00:03,900 --> 00:00:04,800
Hello, everybody.

4
00:00:04,800 --> 00:00:08,000
Welcome to day 4 of handmade hero.

5
00:00:08,900 --> 00:00:11,900
This is sort of day, two of my sickness stream.

6
00:00:11,900 --> 00:00:14,400
So I apologize for my scatterbrain Miss.

7
00:00:14,400 --> 00:00:15,300
Although let's be honest.

8
00:00:15,300 --> 00:00:16,600
I'm kind of scatterbrained normally.

9
00:00:19,000 --> 00:00:22,400
Last night was a bit of a defeat for us because we were just about to

10
00:00:22,400 --> 00:00:25,800
draw stuff to the screen and we didn't quite get to it.

11
00:00:25,800 --> 00:00:29,100
I elected to not push into the Q&A and take time away from that.

12
00:00:29,100 --> 00:00:32,900
I said, go to the Q&A as we normally do but tonight we are definitely

13
00:00:32,900 --> 00:00:36,000
the start drawing stuff, but we are going to start with a very

14
00:00:36,000 --> 00:00:38,000
important correction.

15
00:00:39,000 --> 00:00:43,900
And I am very happy that that Chris Hecker tweeted at me because this

16
00:00:43,900 --> 00:00:45,200
is a this is a good thing.

17
00:00:45,500 --> 00:00:48,400
I'm going to go ahead and launch our editor here and

18
00:00:48,500 --> 00:00:51,600
Hang up our source code that we were working on.

19
00:00:52,300 --> 00:00:54,700
Because after Chris treated at me.

20
00:00:54,800 --> 00:00:58,400
I realized what my confusion was yesterday because I was a little

21
00:00:58,400 --> 00:01:00,400
confused and I think you could tell in the Stream.

22
00:01:00,400 --> 00:01:03,000
I was a little hesitant when I came in here to write win32 update

23
00:01:03,000 --> 00:01:03,500
window.

24
00:01:03,700 --> 00:01:07,300
I said something like, should I use stretched Tibbets or shouldn't I

25
00:01:07,300 --> 00:01:08,300
use stretch Tibbets.

26
00:01:08,300 --> 00:01:09,900
I was kind of hemming and hawing what?

27
00:01:09,900 --> 00:01:11,700
I didn't actually fully explain at that time.

28
00:01:11,700 --> 00:01:14,400
Is the thing that I was actually thinking of using, instead of stretch

29
00:01:14,800 --> 00:01:18,100
debits and what that was was bit blit.

30
00:01:18,600 --> 00:01:20,900
And bit blit is the function that I normally use.

31
00:01:20,900 --> 00:01:22,400
I never actually used stretch to B.

32
00:01:22,400 --> 00:01:25,500
I mean I'm aware of it and I know what it does but I never actually

33
00:01:25,500 --> 00:01:25,900
use it.

34
00:01:25,900 --> 00:01:27,100
I normally use bit blit.

35
00:01:27,100 --> 00:01:31,400
And so the thing that was causing the problem yesterday and this is a

36
00:01:31,400 --> 00:01:34,000
bit of a bummer that I just didn't think of it.

37
00:01:34,400 --> 00:01:37,900
Was that actually, that is why there was the confusion about whether

38
00:01:37,900 --> 00:01:40,000
we needed to create a compatible DC.

39
00:01:40,000 --> 00:01:43,600
I remember s Silvan wrote in very helpfully to point out the fact that

40
00:01:43,600 --> 00:01:45,600
since stretched a b takes a pointer to the B.

41
00:01:45,600 --> 00:01:48,300
Why do we even have to have Windows do this allocations?

42
00:01:48,500 --> 00:01:49,100
For us.

43
00:01:49,200 --> 00:01:50,700
And I was like, gosh, I don't know.

44
00:01:50,700 --> 00:01:53,300
And in my mind I was thinking well, I'm pretty sure you need to do it

45
00:01:53,300 --> 00:01:54,200
for performance reasons.

46
00:01:54,200 --> 00:01:55,500
But why was I thinking that?

47
00:01:55,500 --> 00:01:57,700
Because I don't normally call stretch to bits by just thought that

48
00:01:57,700 --> 00:01:59,400
that was true and blah blah blah.

49
00:01:59,600 --> 00:02:02,700
Well, the reason is actually because this is what I normally use bit

50
00:02:02,700 --> 00:02:03,600
blit is what I normally use.

51
00:02:03,600 --> 00:02:06,300
And if you notice bit plate, does not take a pointer to the B.

52
00:02:06,500 --> 00:02:09,000
It has to go device context to device contact.

53
00:02:09,000 --> 00:02:11,300
So, what I was thinking in my head, as I was thinking about the stuff

54
00:02:11,300 --> 00:02:14,700
you had to do to use bit bullet which involves creating a DC that you

55
00:02:14,700 --> 00:02:18,300
leave around that has the bitmap in it.

56
00:02:18,400 --> 00:02:22,500
It and that you always do the bit bit from that DC to the screen to

57
00:02:22,500 --> 00:02:24,900
the window DC that you're actually drawing to, that's what has to

58
00:02:24,900 --> 00:02:25,400
happen.

59
00:02:25,500 --> 00:02:28,300
So you have to do all this stuff because you can't pass a pointer to

60
00:02:28,300 --> 00:02:28,700
the bit.

61
00:02:28,700 --> 00:02:33,900
But if you call stretch TI B, which I never do, you can actually just

62
00:02:33,900 --> 00:02:37,100
point pass a bit pointer, which means you don't even need a DC or a

63
00:02:37,100 --> 00:02:37,800
bitmap.

64
00:02:38,500 --> 00:02:39,400
So the question is,

65
00:02:42,100 --> 00:02:43,200
Why do I always use bit blit?

66
00:02:43,200 --> 00:02:47,500
Well, the reason and this is why Chris is tweet jog my memory because

67
00:02:47,500 --> 00:02:49,600
he actually is, he's a pro at this stuff.

68
00:02:49,600 --> 00:02:53,800
I mean, he knows this stuff better than anyone probably in the world

69
00:02:53,800 --> 00:02:57,000
because he wrote wind G, which was actually the first way that you

70
00:02:57,000 --> 00:02:58,400
could do this sort of stuff on Windows.

71
00:02:58,400 --> 00:02:59,800
It was under win 3-1.

72
00:03:00,100 --> 00:03:04,400
Rin 351 or when windows for workgroups, whatever it was went 3-1.

73
00:03:04,900 --> 00:03:08,100
You could actually do these Blitz to make games actually run on

74
00:03:08,100 --> 00:03:09,900
Windows way back before they could.

75
00:03:10,000 --> 00:03:13,200
And so he knew all about bleeding on Windows and he kind of he just

76
00:03:13,200 --> 00:03:14,100
knows that cold.

77
00:03:14,100 --> 00:03:15,800
And what he pointed out was stretched.

78
00:03:15,800 --> 00:03:17,900
GI B used to be the slow path.

79
00:03:17,900 --> 00:03:21,300
It was slower than bit blit because bit blit since Windows could do

80
00:03:21,300 --> 00:03:24,000
the allocation of the memory and have the bitmap already selected.

81
00:03:24,000 --> 00:03:27,400
It was a faster path than going through stretch GI B, which is why

82
00:03:27,400 --> 00:03:29,800
I've always anachronistically used bit blit.

83
00:03:30,000 --> 00:03:33,300
But since this is supposed to be for us to learn to write a renderer

84
00:03:33,300 --> 00:03:36,100
and that performance difference, may not even exist anymore.

85
00:03:36,100 --> 00:03:38,700
This was back when things weren't going through a 3D card under the

86
00:03:38,700 --> 00:03:40,000
hood, and all these sorts of things.

87
00:03:40,200 --> 00:03:43,900
There's probably no reason for me to ever use, bit put stretch, but it

88
00:03:43,900 --> 00:03:46,500
is probably gonna be fine for us because eventually, what we'll do

89
00:03:46,500 --> 00:03:50,000
when we optimize things will want to create an opengl context.

90
00:03:50,100 --> 00:03:52,700
And actually write directly to a texture with overlap downloads, and

91
00:03:52,700 --> 00:03:53,300
these sorts of things.

92
00:03:53,300 --> 00:03:55,900
So when we get to like the sort of okay, we wrote everything

93
00:03:55,900 --> 00:03:56,300
ourselves.

94
00:03:56,300 --> 00:03:58,400
And now we're going to start doing Hardware things or whatever.

95
00:03:59,400 --> 00:03:59,800
We're going to launch.

96
00:04:00,000 --> 00:04:03,400
Think different anyway, so really we can just use stress GI B and I do

97
00:04:03,400 --> 00:04:04,700
not have to worry about the thing.

98
00:04:04,700 --> 00:04:08,200
I was worried about which s Silvan or also was pointing out.

99
00:04:08,200 --> 00:04:09,800
We shouldn't need to do and he's right.

100
00:04:09,800 --> 00:04:11,100
I don't think we do need to do that.

101
00:04:11,200 --> 00:04:13,300
So with that correction in place.

102
00:04:14,400 --> 00:04:17,500
We can actually simplify things quite a bit.

103
00:04:17,700 --> 00:04:19,899
What that means is we don't actually need to store any of the stuff

104
00:04:19,899 --> 00:04:20,300
anymore.

105
00:04:20,399 --> 00:04:24,100
The H bitmap in the HDC, that Windows was going to create for us.

106
00:04:24,200 --> 00:04:25,600
We don't actually need those anymore.

107
00:04:26,000 --> 00:04:26,300
Right?

108
00:04:26,300 --> 00:04:27,600
We don't need the bitmap handle.

109
00:04:27,600 --> 00:04:28,800
We don't need the device context.

110
00:04:28,800 --> 00:04:33,500
So, all we actually need to do, is have this bitmap info header filled

111
00:04:33,500 --> 00:04:36,300
out that has the width and the height, correct, right?

112
00:04:37,100 --> 00:04:39,700
And then, we can allocate the memory by ourselves.

113
00:04:39,800 --> 00:04:41,800
We can just allocate our own memory.

114
00:04:42,200 --> 00:04:44,100
However, we want to and as long.

115
00:04:44,300 --> 00:04:47,400
It is the right size and works.

116
00:04:47,400 --> 00:04:50,400
Okay, windows will go ahead and do the right thing.

117
00:04:50,400 --> 00:04:51,600
So that makes it a lot easier for us.

118
00:04:51,600 --> 00:04:53,300
And that's what we're going to do is we're going to keep our bitmap

119
00:04:53,300 --> 00:04:53,700
memory here.

120
00:04:53,700 --> 00:04:57,200
But we're going to do instead is we're going to go ahead and say note.

121
00:04:57,800 --> 00:05:07,500
Thank you to Chris pecker of spy party, Fame for clarifying, the deal

122
00:05:07,700 --> 00:05:13,300
with stretch gibbets and bit blit know.

123
00:05:14,400 --> 00:05:16,200
More DC for us.

124
00:05:16,700 --> 00:05:17,500
So this is awesome.

125
00:05:17,500 --> 00:05:19,900
So basically what we'll be able to do here is we're basically just say

126
00:05:20,100 --> 00:05:22,000
we need some memory Windows.

127
00:05:22,000 --> 00:05:24,500
We need some memory for our bitmap.

128
00:05:24,500 --> 00:05:28,100
And the first question is, how much memory do we need?

129
00:05:28,100 --> 00:05:31,800
Well, we have asked for 32 bits per pixel, 8 Bits, red, 8, Bits green.

130
00:05:31,800 --> 00:05:34,900
It's B Lu and I am going to leave a padding bit in there.

131
00:05:35,100 --> 00:05:36,200
Sorry, padding bytes in there.

132
00:05:36,600 --> 00:05:39,400
So eight bits of pad and the reason that I'm going to do that is

133
00:05:39,400 --> 00:05:43,400
because in General on the x86 architecture.

134
00:05:43,400 --> 00:05:44,000
Oftentimes

135
00:05:44,100 --> 00:05:47,500
Is there is a penalty for doing what's called unaligned accessing?

136
00:05:47,900 --> 00:05:48,700
So basically,

137
00:05:50,800 --> 00:05:54,900
If you are trying to operate on a value, that's say 8-bit 16-bit

138
00:05:54,900 --> 00:05:56,600
32-bit 64-bit, this sort of thing.

139
00:05:56,600 --> 00:05:59,900
If you're operating on, like 32-bit values, 32-bit.

140
00:06:00,000 --> 00:06:04,800
Use should be aligned on 32-bit boundaries, meaning they should be on

141
00:06:04,800 --> 00:06:09,600
like the zeroth B, the fourth B, the eighth B and so on, they should

142
00:06:09,600 --> 00:06:10,300
not start.

143
00:06:10,300 --> 00:06:11,700
Unlike the second bite.

144
00:06:11,800 --> 00:06:13,800
They should always if they're four bytes long.

145
00:06:13,800 --> 00:06:16,200
They should be at multiples of 4 in memory.

146
00:06:16,700 --> 00:06:19,600
And that's just the way the CPU is set up to deal with them.

147
00:06:19,600 --> 00:06:21,800
And so, what I want to do is I want to make sure that whenever we

148
00:06:21,800 --> 00:06:25,500
touch a pixel just for now, especially to simplify things and to keep,

149
00:06:25,500 --> 00:06:28,400
make sure we're not incurring any penalties unnecessarily here just to

150
00:06:28,400 --> 00:06:29,100
simplify things.

151
00:06:29,100 --> 00:06:29,900
I want to make sure that

152
00:06:30,000 --> 00:06:35,200
That we're always touching a pixel on an exact 8, 4 byte boundary

153
00:06:35,200 --> 00:06:35,500
there.

154
00:06:35,700 --> 00:06:39,000
So if we were to ask for the bits that we actually need for r g and B,

155
00:06:39,000 --> 00:06:45,600
that would be 8, B 8, B 8, Bits, or 24, bits, and 24 bits is three B,

156
00:06:45,600 --> 00:06:46,700
which is in no way.

157
00:06:46,700 --> 00:06:51,400
Aligned with for you basically have to go out 3 times 4 or 12 to get

158
00:06:51,400 --> 00:06:52,900
back to the right boundary, right?

159
00:06:53,800 --> 00:06:54,600
So that's not going to do it.

160
00:06:54,600 --> 00:06:57,900
So I'm asking for eight extra bits that I need, and those extra bits

161
00:06:57,900 --> 00:06:59,100
are just going to be padding.

162
00:06:59,100 --> 00:06:59,900
They don't actually

163
00:07:00,000 --> 00:07:02,900
Anything and they were actually be used, but we're just going to do

164
00:07:02,900 --> 00:07:03,100
that.

165
00:07:03,100 --> 00:07:06,500
So that we know that our pixels are always aligned on 4 byte boundary.

166
00:07:06,500 --> 00:07:11,600
So if that is the case, then I know I have a pixel size of 4, bytes,

167
00:07:12,100 --> 00:07:12,300
right?

168
00:07:12,300 --> 00:07:13,800
That is how big that's going to be.

169
00:07:13,900 --> 00:07:22,300
So I need a enough of these for B pixels to have the width times the

170
00:07:22,300 --> 00:07:24,500
height worth of pixels, right?

171
00:07:24,500 --> 00:07:28,300
Because this is sort of elementary math if you have a rectangle and

172
00:07:28,300 --> 00:07:29,800
you want the area of that rectangle,

173
00:07:29,900 --> 00:07:32,200
You multiply the width times the height, right?

174
00:07:32,200 --> 00:07:34,600
And so what we want to know, is, how many pixels do we have?

175
00:07:34,600 --> 00:07:37,100
Well, we have width times height pixels, right?

176
00:07:37,400 --> 00:07:39,700
But each pixel is for.

177
00:07:39,700 --> 00:07:43,600
So, if I was to make this a little more explicit, I might say, bytes

178
00:07:43,700 --> 00:07:47,800
per pixel, equals 4, and say that we have width times height times B

179
00:07:47,800 --> 00:07:49,000
per pixel, right?

180
00:07:49,000 --> 00:07:52,600
So, this is the size of our bitmap memory, right?

181
00:07:52,600 --> 00:07:56,700
And if we want to allocate it, we say the bitmap memory equals.

182
00:07:56,700 --> 00:07:59,800
Something that allocates bitmap memory size.

183
00:08:00,000 --> 00:08:02,900
Earth now, in Windows, how can we allocate something?

184
00:08:02,900 --> 00:08:07,700
Well, I like to use Virtual a lock for a couple reasons we could also

185
00:08:07,700 --> 00:08:07,900
use.

186
00:08:07,900 --> 00:08:09,800
He palak either way.

187
00:08:09,900 --> 00:08:12,300
We are probably going to stick with virtual Alec mostly so I might as

188
00:08:12,300 --> 00:08:14,300
well go and introduce it here.

189
00:08:14,600 --> 00:08:18,600
Basically what this does is it goes ahead and allocates a certain

190
00:08:18,600 --> 00:08:20,000
number of memory pages.

191
00:08:20,400 --> 00:08:23,100
And basically what happens is when you allocate memory directly from

192
00:08:23,100 --> 00:08:23,600
the system.

193
00:08:23,800 --> 00:08:27,900
It is generally allocated in pages and pages are a certain size in

194
00:08:27,900 --> 00:08:28,200
Windows.

195
00:08:28,200 --> 00:08:28,900
They are often.

196
00:08:29,900 --> 00:08:32,000
Six bites, sometimes they are 64k.

197
00:08:32,000 --> 00:08:33,000
It depends whether they're large.

198
00:08:33,000 --> 00:08:35,900
Pages, are small pages, that sort of an operating system thing that

199
00:08:35,900 --> 00:08:39,000
we'll talk about a little bit later potentially, but basically there's

200
00:08:39,000 --> 00:08:40,200
two ways we could allocate memory.

201
00:08:40,200 --> 00:08:43,600
We could allocate it with Heap, a lock, like I mentioned and he palak

202
00:08:43,600 --> 00:08:46,400
is basically asking the system to sort of sub allocate out of the

203
00:08:46,400 --> 00:08:47,400
pages for you.

204
00:08:47,700 --> 00:08:50,600
So you can pass any size you want here and you will get back a point

205
00:08:50,600 --> 00:08:51,100
of that.

206
00:08:51,200 --> 00:08:53,300
Whereas virtual Alec is a little more raw.

207
00:08:53,300 --> 00:08:56,900
A virtual Alec must give you back pages.

208
00:08:57,000 --> 00:08:59,800
So you can't for example, ask for something that is

209
00:09:00,000 --> 00:09:03,700
Less than 4096 bytes and expect it to give it back back to you.

210
00:09:03,700 --> 00:09:07,000
What it actually will do is it will give you back the whole 4096 spice

211
00:09:07,000 --> 00:09:08,400
and the rest will just be wasted.

212
00:09:08,400 --> 00:09:10,900
I want to get you used to allocating memory from this because we are

213
00:09:10,900 --> 00:09:12,800
going to be doing almost all of our own.

214
00:09:13,200 --> 00:09:15,000
We're going to be doing our memory allocation almost entirely

215
00:09:15,000 --> 00:09:16,700
ourselves in this project.

216
00:09:16,700 --> 00:09:20,200
So I just want to get started with this virtual elk right away.

217
00:09:20,200 --> 00:09:22,800
So you're used to calling it and it does not frighten you.

218
00:09:23,000 --> 00:09:25,600
So I'm going to call virtual Alec, and I'm going to look at the things

219
00:09:25,600 --> 00:09:25,900
here.

220
00:09:26,200 --> 00:09:29,700
We are going to Virtual luck, our bitmap.

221
00:09:30,000 --> 00:09:31,100
And we are going to take a look at.

222
00:09:31,100 --> 00:09:33,700
It says it wants to starting address of the region.

223
00:09:33,700 --> 00:09:34,100
Now.

224
00:09:34,100 --> 00:09:37,500
This would be good if we actually wanted to place our because,

225
00:09:37,500 --> 00:09:40,000
remember we have a virtual memory space for those of you who watch the

226
00:09:40,000 --> 00:09:42,700
intro stream, know, every process in Windows, has a virtual memory

227
00:09:42,700 --> 00:09:45,900
space its own addressing scheme for memory and that gets, you know,

228
00:09:45,900 --> 00:09:49,400
moved out to physical memory depending on the how the operating system

229
00:09:49,400 --> 00:09:50,500
chooses to map it.

230
00:09:50,500 --> 00:09:54,800
But we are always looking at basically a nice big flat 64-bit address

231
00:09:54,800 --> 00:09:54,800
space.

232
00:09:54,800 --> 00:09:58,300
That appears to all be our own even though Windows behind the scenes,

233
00:09:58,300 --> 00:10:00,000
the sort of swapping that in and out of physical memory.

234
00:10:00,000 --> 00:10:02,100
Are you putting it to disc, doing whatever it needs to do to make it

235
00:10:02,100 --> 00:10:02,900
appear that way to us.

236
00:10:02,900 --> 00:10:05,800
But as far as we're concerned, we have a nice big flat address space

237
00:10:06,000 --> 00:10:08,500
and as long as we don't use too much memory, we can kind of assume

238
00:10:08,500 --> 00:10:10,900
that we'll all be actually put in physical memory.

239
00:10:11,200 --> 00:10:13,500
So we won't have to incur any kind of weird performance penalty.

240
00:10:16,100 --> 00:10:16,600
So

241
00:10:18,600 --> 00:10:22,700
all we have to do here is say we don't actually care where the memory

242
00:10:22,700 --> 00:10:25,800
is because we don't we don't have any real restriction on where it is.

243
00:10:25,900 --> 00:10:29,500
We have to say the size and this is the size, the region in B.

244
00:10:30,200 --> 00:10:33,700
Basically, if the address parameter is null, the value is rounded up

245
00:10:33,700 --> 00:10:34,900
to the, why is this?

246
00:10:34,900 --> 00:10:35,800
Why is this scrolling?

247
00:10:35,800 --> 00:10:36,300
There we go.

248
00:10:36,400 --> 00:10:38,200
Round up to the next page boundary.

249
00:10:38,200 --> 00:10:42,500
So since we did pass in the lp address, as no, it means that even if

250
00:10:42,500 --> 00:10:47,100
we pass something that is less than an, even multiple of the page size

251
00:10:47,100 --> 00:10:48,200
of the system, it will just

252
00:10:48,400 --> 00:10:51,700
It up for us, which is exactly what we want it to do.

253
00:10:52,100 --> 00:10:53,200
So that's totally fine.

254
00:10:53,500 --> 00:10:55,600
Then excuse me.

255
00:10:56,000 --> 00:10:58,900
We have the allocation type and that is going to tell a Windows what?

256
00:10:58,900 --> 00:11:01,300
We actually want it to do to this memory range.

257
00:11:01,300 --> 00:11:03,700
And that the interesting thing about this is there's two actual things

258
00:11:03,700 --> 00:11:04,300
it can do.

259
00:11:04,400 --> 00:11:06,300
There's commit and reserved.

260
00:11:06,300 --> 00:11:08,800
And what's interesting about that is basically, since it is a virtual

261
00:11:08,800 --> 00:11:11,400
memory space, what that means is you start off with 64 bits of address

262
00:11:11,400 --> 00:11:13,800
space, but basically all of it is essentially vacant.

263
00:11:14,000 --> 00:11:15,400
It's not actually memory yet.

264
00:11:15,400 --> 00:11:16,600
And you basically have to say, okay.

265
00:11:16,600 --> 00:11:18,200
I'm announcing that these pages.

266
00:11:18,300 --> 00:11:20,800
Are actually now going to be used by me so windows can do.

267
00:11:20,800 --> 00:11:21,400
Okay.

268
00:11:21,400 --> 00:11:22,900
He's actually going to use some of this memory face.

269
00:11:22,900 --> 00:11:25,100
I have to start tracking it and working with it.

270
00:11:25,100 --> 00:11:27,400
Putting it in physical memory, doing whatever I need to do with it.

271
00:11:27,400 --> 00:11:29,000
And it has a little page table based on that.

272
00:11:29,000 --> 00:11:33,800
It keeps it says, which Pages for each process are actually being

273
00:11:33,800 --> 00:11:34,400
used.

274
00:11:34,400 --> 00:11:36,800
Now, what that means is when we go through virtual, Alec.

275
00:11:36,800 --> 00:11:37,900
There's two ways we can ask.

276
00:11:37,900 --> 00:11:40,900
Remember, you can ask it to actually start tracking the memory and

277
00:11:40,900 --> 00:11:43,500
we're actually gonna start using that memory, which is, that's what

278
00:11:43,500 --> 00:11:47,100
commit actually is but Reserve is a separate thing we can do.

279
00:11:47,100 --> 00:11:48,200
If we just want to make sure

280
00:11:48,300 --> 00:11:51,000
Sure, that memory is available for us and kind of tell you.

281
00:11:51,000 --> 00:11:54,100
Okay, we're going to be using this memory, but you don't actually need

282
00:11:54,100 --> 00:11:57,000
to start tracking it yet because we don't actually need it yet.

283
00:11:57,100 --> 00:11:59,800
So why don't you actually just wait till I actually need it.

284
00:12:00,000 --> 00:12:02,100
To actually start using it if that makes any sense.

285
00:12:02,600 --> 00:12:05,400
So, basically we're going to use mem commit because we actually want

286
00:12:05,400 --> 00:12:06,400
the memory right now.

287
00:12:06,500 --> 00:12:08,900
So I'm going to go ahead and do mem commit.

288
00:12:09,000 --> 00:12:12,700
And, and then we could talk a little bit more about that later.

289
00:12:12,700 --> 00:12:12,900
Now.

290
00:12:12,900 --> 00:12:15,000
I don't think we actually need any of these other ones.

291
00:12:15,000 --> 00:12:16,800
We don't need to ask for a large.

292
00:12:16,800 --> 00:12:18,100
Paid support for any particular reason.

293
00:12:18,100 --> 00:12:18,500
We don't need that.

294
00:12:18,500 --> 00:12:20,100
It's windy extensions or anything like this.

295
00:12:20,100 --> 00:12:22,400
These are all things you do not have to worry about and I don't think

296
00:12:22,400 --> 00:12:23,400
we'll have to worry about either.

297
00:12:23,900 --> 00:12:28,800
And then protection basically says what we want our access privileges

298
00:12:28,900 --> 00:12:29,500
to be.

299
00:12:29,500 --> 00:12:29,800
Now we do

300
00:12:30,000 --> 00:12:31,800
Not need to execute code out of this memory.

301
00:12:31,800 --> 00:12:33,500
So we do not need the execute bit to be set.

302
00:12:33,500 --> 00:12:37,100
That is basically a bit that says, whether or not of the CPU can run

303
00:12:37,100 --> 00:12:38,700
code that is residing in that memory.

304
00:12:38,700 --> 00:12:40,200
This is basically for security purposes.

305
00:12:42,400 --> 00:12:46,900
I believe well could be for forking purposes to don't get hung up on

306
00:12:46,900 --> 00:12:47,100
that.

307
00:12:47,100 --> 00:12:48,300
Don't really matter point.

308
00:12:48,300 --> 00:12:50,800
Being we want full read and write access.

309
00:12:50,800 --> 00:12:51,800
We just don't need execute.

310
00:12:51,800 --> 00:12:54,100
So we are going to ask for read and write access to this memory which

311
00:12:54,100 --> 00:12:56,700
means that our process can both look at the contents of that memory

312
00:12:57,000 --> 00:12:59,900
and store things to that memory, which we

313
00:13:00,000 --> 00:13:01,600
Going to be using both up.

314
00:13:01,600 --> 00:13:04,500
So we are going to ask virtual out to give that back and in theory, it

315
00:13:04,500 --> 00:13:05,800
will return to us.

316
00:13:05,900 --> 00:13:07,400
As you can see, from the documentation here.

317
00:13:07,400 --> 00:13:11,000
It will return to us a void pointer member LP long portrait avoid that

318
00:13:11,000 --> 00:13:12,200
is a void star.

319
00:13:12,500 --> 00:13:14,900
It is going to return us avoid start, which is what we wanted, which

320
00:13:14,900 --> 00:13:16,500
is the memory that we needed.

321
00:13:16,500 --> 00:13:19,700
Now, if we should have to resize, our dip section and bitmap memory

322
00:13:19,800 --> 00:13:21,300
was already allocated.

323
00:13:21,300 --> 00:13:25,200
We want to just make sure that quickly before we do this, we go ahead

324
00:13:25,200 --> 00:13:27,800
and free that memory because that is the only time that we actually

325
00:13:27,800 --> 00:13:28,500
want to do that.

326
00:13:28,500 --> 00:13:29,800
This memory is supposed to always be available.

327
00:13:29,900 --> 00:13:31,600
Available to us so we only want to free it.

328
00:13:31,600 --> 00:13:34,100
If we think we're going to allocate it again right away.

329
00:13:34,100 --> 00:13:36,200
So basically what we're going to do here is going to use the opposite,

330
00:13:36,200 --> 00:13:39,200
which is virtual free, what you can do down here in the see also is

331
00:13:39,200 --> 00:13:40,600
they'll usually put things that are related.

332
00:13:40,600 --> 00:13:42,800
So if you want to know how to free something, usually go down here,

333
00:13:42,800 --> 00:13:44,300
sometimes I'll tell you in here as well.

334
00:13:44,400 --> 00:13:47,500
Sometimes they won't hear it is virtual free can can can free the

335
00:13:47,500 --> 00:13:48,000
memory.

336
00:13:48,300 --> 00:13:53,300
So what we're going to do here is we are going to go ahead and do mem

337
00:13:53,300 --> 00:13:57,000
release to actually get rid of the memory entirely, but I'm going to

338
00:13:57,000 --> 00:13:59,800
talk about mem D, commit, just briefly, just to let you know how

339
00:14:00,000 --> 00:14:01,800
Works because we may use that in the future.

340
00:14:01,800 --> 00:14:05,400
Probably not here, but we will probably use it for other things on

341
00:14:05,400 --> 00:14:06,100
occasion.

342
00:14:06,300 --> 00:14:08,200
Alright, so we are going to free the bitmap memory.

343
00:14:08,200 --> 00:14:09,600
We need to pass it, the address to free.

344
00:14:09,600 --> 00:14:12,800
We need to pass it, the size that it was and that's the bitmap memory

345
00:14:12,800 --> 00:14:13,100
size.

346
00:14:13,100 --> 00:14:13,900
We allocated before.

347
00:14:13,900 --> 00:14:17,900
So, it looks like we're going to have to store that since I assume we

348
00:14:17,900 --> 00:14:20,000
cannot pass a no.

349
00:14:20,900 --> 00:14:22,300
Oh, no, we can't actually pass a note.

350
00:14:22,300 --> 00:14:23,000
That's good.

351
00:14:23,100 --> 00:14:23,900
So we'll just free.

352
00:14:23,900 --> 00:14:25,200
The, it'll actually just free.

353
00:14:25,200 --> 00:14:26,300
The it remembers.

354
00:14:26,300 --> 00:14:28,500
How basically, how we allocated and it will free it.

355
00:14:28,500 --> 00:14:29,200
So that's perfect.

356
00:14:29,200 --> 00:14:29,800
So we don't even have

357
00:14:29,900 --> 00:14:32,300
To store the actual size, it will do that for us.

358
00:14:32,500 --> 00:14:35,800
And then we just have to say that we want to release the memory back

359
00:14:35,800 --> 00:14:38,400
to the operating system and it can reclaim those pages, use them for

360
00:14:38,400 --> 00:14:38,900
something else.

361
00:14:38,900 --> 00:14:40,900
Give them to another process, do whatever.

362
00:14:40,900 --> 00:14:42,900
It's going to do, doesn't have to worry about, keeping them back in

363
00:14:42,900 --> 00:14:45,500
physical memory, on the hard drive, any more now.

364
00:14:45,600 --> 00:14:47,900
When we do this virtual free, I said memory, Lisa would get rid of

365
00:14:47,900 --> 00:14:48,100
Pages.

366
00:14:48,100 --> 00:14:50,000
There's another thing we could have done, we could have done.

367
00:14:50,000 --> 00:14:51,000
Ma'am, D commit.

368
00:14:51,000 --> 00:14:51,900
What is MD commit.

369
00:14:51,900 --> 00:14:52,000
Now?

370
00:14:52,000 --> 00:14:55,000
You notice we did commit over here, which basically said I want you to

371
00:14:55,000 --> 00:14:58,800
actually make these actual Pages, release, mix them, D, commit like

372
00:14:58,800 --> 00:14:59,700
stop being committed.

373
00:15:00,000 --> 00:15:01,200
And it actually frees them as well.

374
00:15:01,300 --> 00:15:06,100
But instead we could D commit them but leave the pages reserved.

375
00:15:06,100 --> 00:15:08,500
So if for some reason, we said, look, you don't have to pay attention

376
00:15:08,500 --> 00:15:09,300
to these anymore.

377
00:15:09,500 --> 00:15:12,500
But we're gonna ask Ali, probably want them back later.

378
00:15:12,500 --> 00:15:15,200
So don't what bother tracking them, but don't get rid of this memory

379
00:15:15,200 --> 00:15:17,700
range, that could be something that we might want to do.

380
00:15:19,400 --> 00:15:20,400
Probably not.

381
00:15:20,400 --> 00:15:22,100
I don't really know the thing that we're more likely to do.

382
00:15:22,100 --> 00:15:23,300
I'll mention really quickly.

383
00:15:23,300 --> 00:15:25,400
Because for some reason, I'm spazzing out tonight.

384
00:15:25,400 --> 00:15:27,600
I'm just kind of in one of those zones where I'm just talking at you

385
00:15:27,600 --> 00:15:28,900
and talking at you and talking at you.

386
00:15:28,900 --> 00:15:32,200
And I see no reason to stop virtual protect is a way of basically

387
00:15:32,200 --> 00:15:34,400
taking something that we did with virtual Alec and changing the

388
00:15:34,400 --> 00:15:35,600
protection of that page.

389
00:15:35,600 --> 00:15:38,700
So, one thing we could do instead of freeing, the memory is, we could

390
00:15:38,700 --> 00:15:40,500
choose to leak this memory and debug mode.

391
00:15:40,500 --> 00:15:41,600
Meaning, we will not forget.

392
00:15:41,600 --> 00:15:44,000
It'll just stay around and instead of freeing it.

393
00:15:44,000 --> 00:15:45,700
We will actually virtual protect it.

394
00:15:45,700 --> 00:15:49,100
We will virtual protect it with no actual access.

395
00:15:49,100 --> 00:15:49,200
So we

396
00:15:49,400 --> 00:15:52,700
We'll go in there and we will change the memory protection context,

397
00:15:52,700 --> 00:15:58,200
contents, memory protection, constants of the page to be page.

398
00:15:58,200 --> 00:15:59,600
No access, no execution.

399
00:15:59,700 --> 00:16:00,400
No writing.

400
00:16:00,500 --> 00:16:01,100
No reading.

401
00:16:01,300 --> 00:16:03,000
So that way we can't use the page anymore.

402
00:16:03,000 --> 00:16:04,100
Even though it is still allocated.

403
00:16:04,100 --> 00:16:05,300
Now, why would we want to do that?

404
00:16:05,400 --> 00:16:08,200
The reason we want to do that is to make sure nobody has a stale

405
00:16:08,200 --> 00:16:10,900
pointer to the page because if someone kept a pointer to the page

406
00:16:10,900 --> 00:16:13,500
somewhere and they were going to try to write to it, that would be a

407
00:16:13,500 --> 00:16:17,300
use after free bug which are very hard to track down sometimes and so

408
00:16:17,300 --> 00:16:19,200
this is one way that you can catch those.

409
00:16:19,300 --> 00:16:21,600
Those bugs, you can go ahead and protect the memory, make it so that

410
00:16:21,600 --> 00:16:22,400
you can't touch it.

411
00:16:22,400 --> 00:16:25,400
And then later when that buggy code, tries to go and touch it instead

412
00:16:25,400 --> 00:16:28,100
of perhaps exceeding touching it because it's still memory, that's

413
00:16:28,100 --> 00:16:30,700
allocated by the operating system that got used for something else

414
00:16:30,700 --> 00:16:31,100
later.

415
00:16:31,300 --> 00:16:34,500
It will now fault, right on the line of code that try to do it, great

416
00:16:34,500 --> 00:16:35,700
way to catch bugs like that.

417
00:16:35,700 --> 00:16:39,500
We will probably do something like that in the future to try to keep

418
00:16:39,500 --> 00:16:42,000
ourselves from from making mistakes like that.

419
00:16:43,800 --> 00:16:45,200
Right now don't see much of a need to do that.

420
00:16:45,200 --> 00:16:46,300
I think we'll probably be okay.

421
00:16:46,400 --> 00:16:48,100
There's other tricks you can do with Mary protect.

422
00:16:48,100 --> 00:16:49,000
We'll get into those later.

423
00:16:49,400 --> 00:16:50,700
But that's all I want to do right now.

424
00:16:50,700 --> 00:16:53,300
I'm going to step through this and make sure that we are doing the

425
00:16:53,300 --> 00:16:54,000
right thing.

426
00:16:54,500 --> 00:16:58,700
So I'm going to go ahead and type Dev em to bring up our project and I

427
00:16:58,700 --> 00:17:01,800
will step into the win32 resize dib section.

428
00:17:02,600 --> 00:17:03,900
So here we go.

429
00:17:04,000 --> 00:17:07,099
Let's make sure the first time we try to resize our dip section.

430
00:17:07,200 --> 00:17:10,700
We expect our bitmap memory to be 0, which is, which means we will not

431
00:17:10,700 --> 00:17:11,400
attempt to free it.

432
00:17:11,400 --> 00:17:12,200
That is exactly what

433
00:17:12,300 --> 00:17:13,700
We wanted, we will fill out that header.

434
00:17:13,700 --> 00:17:14,300
We know, that's right.

435
00:17:14,300 --> 00:17:17,000
We check that yesterday, four bytes per pixel, which is how many we

436
00:17:17,000 --> 00:17:17,500
expected.

437
00:17:17,500 --> 00:17:20,700
We will then ask for a certain amount of memory here, bitmap memory

438
00:17:20,700 --> 00:17:21,200
size.

439
00:17:21,700 --> 00:17:24,300
That is this, which looks about right.

440
00:17:24,300 --> 00:17:27,800
14:24 by 729.

441
00:17:27,900 --> 00:17:29,500
Should be about that.

442
00:17:29,500 --> 00:17:32,600
And then when we multiply, by the size of the picture pits, which for.

443
00:17:32,600 --> 00:17:33,000
Yep.

444
00:17:33,000 --> 00:17:33,900
We all good.

445
00:17:33,900 --> 00:17:34,900
There looks good.

446
00:17:35,100 --> 00:17:36,700
And now we will allocate our memory.

447
00:17:36,700 --> 00:17:37,900
And did we get it back?

448
00:17:37,900 --> 00:17:39,000
We did get it back.

449
00:17:39,000 --> 00:17:39,900
All is good.

450
00:17:40,000 --> 00:17:41,100
We are ready to rock.

451
00:17:41,100 --> 00:17:42,200
So now all we have to do.

452
00:17:42,300 --> 00:17:45,000
Do is pass that memory to stretch the.

453
00:17:45,000 --> 00:17:49,200
I b to put it to the display and that will will solve our problem for

454
00:17:49,200 --> 00:17:49,300
us.

455
00:17:49,300 --> 00:17:49,400
Now.

456
00:17:49,400 --> 00:17:53,600
What we're going to do here is I think we're actually going to start.

457
00:17:53,700 --> 00:17:53,800
Now.

458
00:17:53,800 --> 00:17:56,100
Remember we specially do what's called a dirty rectangle?

459
00:17:56,100 --> 00:17:56,800
Update here.

460
00:17:56,900 --> 00:17:59,800
We passed win 30 up to update window the region.

461
00:18:00,100 --> 00:18:03,500
Of our window that Windows asked us to repaint, but we could introduce

462
00:18:03,500 --> 00:18:06,800
some bugs here and make a stuff harder for us to debug by actually

463
00:18:06,800 --> 00:18:09,000
using this dirty rectangle first time out.

464
00:18:09,000 --> 00:18:11,700
So instead of doing that, I'm going to have stress gibus, just fill

465
00:18:11,700 --> 00:18:12,600
the whole window.

466
00:18:12,600 --> 00:18:13,000
First.

467
00:18:13,100 --> 00:18:14,400
I'm going to have it drawn to the whole window.

468
00:18:14,400 --> 00:18:14,700
First.

469
00:18:14,700 --> 00:18:18,000
We make sure everything is working properly and then we'll worry about

470
00:18:18,000 --> 00:18:20,500
doing a sub-region that Windows wants us to do.

471
00:18:20,500 --> 00:18:21,800
So, instead of doing it this way.

472
00:18:21,800 --> 00:18:25,100
I'm going to go ahead and look up that that call right there.

473
00:18:25,100 --> 00:18:27,500
Just a figure like this will simplify our to Buggy Bill.

474
00:18:27,500 --> 00:18:29,800
Always start, start simple and then get more.

475
00:18:30,000 --> 00:18:30,700
Complicated.

476
00:18:30,800 --> 00:18:33,800
So basically pass, the device comes for painting to, we passed the

477
00:18:33,800 --> 00:18:34,500
destination.

478
00:18:34,500 --> 00:18:35,500
And so the destination.

479
00:18:35,600 --> 00:18:37,900
This is it's no longer going to be this at all.

480
00:18:38,100 --> 00:18:39,200
This is not what it's going to be.

481
00:18:39,600 --> 00:18:44,200
So the destination is going to be 0, 0, always.

482
00:18:44,200 --> 00:18:47,500
And then we are always going to do our full width and height, the full

483
00:18:47,500 --> 00:18:51,600
width and height of the bit map instead of the repaint region.

484
00:18:52,100 --> 00:18:55,200
We are going to pass that and then we will pass.

485
00:18:55,500 --> 00:18:56,300
I guess we should name this.

486
00:18:56,300 --> 00:18:59,800
So, this is, this is actually the bitmap with, and the bitmap height.

487
00:19:00,200 --> 00:19:03,900
And then we will do use the window width and the window height to make

488
00:19:03,900 --> 00:19:06,500
sure that we blit our whole bitmap to the whole window.

489
00:19:06,500 --> 00:19:07,600
Now, in order to do that.

490
00:19:07,600 --> 00:19:10,300
I need to actually know what size that is.

491
00:19:10,400 --> 00:19:11,300
So temporarily.

492
00:19:11,300 --> 00:19:15,100
I'm going to go ahead here and I am going to pass the actual window

493
00:19:15,100 --> 00:19:15,600
size.

494
00:19:15,800 --> 00:19:17,800
Might have not actually be temporarily.

495
00:19:17,800 --> 00:19:19,400
We may just want to always know this.

496
00:19:19,400 --> 00:19:20,500
I think we do.

497
00:19:20,600 --> 00:19:25,100
So I am going to ask here for a window wrecked to be passed in that

498
00:19:25,100 --> 00:19:27,900
will tell us basically how big the the window is.

499
00:19:28,000 --> 00:19:29,300
And then I will save

500
00:19:29,900 --> 00:19:32,900
The the to the width and height of our backing buffer here again,

501
00:19:32,900 --> 00:19:34,100
these are Global variables.

502
00:19:34,200 --> 00:19:36,800
Not because D should actually be Global Bears there because we're just

503
00:19:36,800 --> 00:19:38,200
kind of working on getting the code working.

504
00:19:38,200 --> 00:19:38,700
Right now.

505
00:19:38,800 --> 00:19:40,500
These will not be Global variables eventually.

506
00:19:40,500 --> 00:19:43,700
I do not remember like this is not a good thing to leave these Global

507
00:19:43,700 --> 00:19:44,700
variables and we won't.

508
00:19:44,700 --> 00:19:47,500
So, don't be thinking that you should put these things out there

509
00:19:47,800 --> 00:19:48,500
permanently.

510
00:19:48,500 --> 00:19:50,000
You should only put things as Global variables.

511
00:19:50,000 --> 00:19:52,100
When you're first getting things working and see where everything has

512
00:19:52,100 --> 00:19:54,800
to be and then immediately after you kind of know exactly how things

513
00:19:54,800 --> 00:19:55,300
should go.

514
00:19:55,400 --> 00:19:58,300
You want to clean that up and make sure that only things that actually

515
00:19:58,300 --> 00:19:59,400
should be Global are Global.

516
00:19:59,400 --> 00:19:59,900
And that is what

517
00:20:00,000 --> 00:20:01,400
We'll do a little bit later.

518
00:20:01,600 --> 00:20:02,200
So there we go.

519
00:20:02,200 --> 00:20:04,500
We have our Global variables and when we come through here and we

520
00:20:04,500 --> 00:20:09,000
resize things, we are going to go ahead and set the bitmap with equal

521
00:20:09,000 --> 00:20:12,700
to the width and the bitmap height equal to the height and then we

522
00:20:12,700 --> 00:20:17,800
will go ahead and set using those from then on.

523
00:20:17,800 --> 00:20:20,700
So these will basically just be set there and then we will just use

524
00:20:20,700 --> 00:20:21,200
those from then on.

525
00:20:21,200 --> 00:20:22,000
Okay, there we go.

526
00:20:22,000 --> 00:20:23,800
So that will be how will do that.

527
00:20:23,800 --> 00:20:23,900
We.

528
00:20:23,900 --> 00:20:25,600
Then just need to get the window with.

529
00:20:25,600 --> 00:20:29,300
And the window width, of course, is going to be to thee.

530
00:20:30,300 --> 00:20:32,400
The window wreck see there.

531
00:20:32,400 --> 00:20:34,400
I passed a pointer to it because I didn't want to pass the whole

532
00:20:34,400 --> 00:20:35,200
rectangle on the stack.

533
00:20:35,200 --> 00:20:36,400
Didn't think that was necessary.

534
00:20:36,900 --> 00:20:42,000
The window rex that will be the right - the left to get us the width

535
00:20:42,000 --> 00:20:43,800
of it and we will do the window.

536
00:20:43,800 --> 00:20:46,000
Height will be window wrecked.

537
00:20:46,000 --> 00:20:48,400
Bottom - window wrecked top.

538
00:20:48,700 --> 00:20:49,400
There we go.

539
00:20:49,800 --> 00:20:54,200
And that should basically give us everything that we need to know.

540
00:20:54,200 --> 00:20:56,000
We have our bitmap memory pointer.

541
00:20:56,300 --> 00:20:59,700
But the one thing that I do want to know, is what

542
00:21:00,000 --> 00:21:01,700
Are so stretched a b.

543
00:21:02,300 --> 00:21:03,200
I'm giving it a pointer.

544
00:21:03,600 --> 00:21:06,200
I don't know how it's going to read that pointer.

545
00:21:06,700 --> 00:21:08,100
How is it going to access that memory?

546
00:21:08,100 --> 00:21:09,400
Is it going to go?

547
00:21:09,500 --> 00:21:11,300
Is it going to subtract?

548
00:21:11,300 --> 00:21:12,900
So how should I say this?

549
00:21:13,200 --> 00:21:15,100
So basically it's going to look at that memory.

550
00:21:15,100 --> 00:21:17,700
It's going to interpret that memory as a bunch of pixels basically,

551
00:21:17,700 --> 00:21:18,200
right.

552
00:21:18,200 --> 00:21:20,900
And let's go ahead and do a drawing here so I can so I can kind of get

553
00:21:20,900 --> 00:21:21,600
across to you.

554
00:21:21,600 --> 00:21:23,000
This is a bit of a visual point.

555
00:21:23,000 --> 00:21:24,600
I think it might help to have a diagram.

556
00:21:24,600 --> 00:21:28,000
So I'm going to go ahead and draw one using gimp with my magical

557
00:21:28,000 --> 00:21:28,800
drawing skills.

558
00:21:28,800 --> 00:21:29,900
I think we all agree that.

559
00:21:30,000 --> 00:21:32,100
At my drawing skills are kind of unparalleled.

560
00:21:32,300 --> 00:21:32,900
So let's see.

561
00:21:32,900 --> 00:21:33,800
Oh my god.

562
00:21:34,000 --> 00:21:34,700
Wow!

563
00:21:34,800 --> 00:21:37,700
Drawing with OBS is difficult.

564
00:21:37,900 --> 00:21:39,100
Oh my Lord.

565
00:21:39,100 --> 00:21:40,600
Okay, maybe this won't work.

566
00:21:40,600 --> 00:21:42,200
This is why I got to get a video capture card.

567
00:21:42,200 --> 00:21:44,600
Ladies and gentlemen, that's almost impossible.

568
00:21:44,700 --> 00:21:46,200
That's almost impossible to do.

569
00:21:46,500 --> 00:21:47,000
All right.

570
00:21:47,000 --> 00:21:48,300
So that's a non-starter.

571
00:21:48,300 --> 00:21:50,400
There's no way we're going to draw that diagram.

572
00:21:50,500 --> 00:21:52,800
I will have to get a video capture card before I can actually draw

573
00:21:52,800 --> 00:21:53,400
diagrams.

574
00:21:53,700 --> 00:21:54,600
Oh, that's awful.

575
00:21:54,600 --> 00:21:56,900
Well, I'm glad we tried because when it becomes more important, I'm

576
00:21:56,900 --> 00:21:57,900
going to need to be able to draw stuff.

577
00:21:57,900 --> 00:21:58,900
So we'll skip that for now.

578
00:21:59,200 --> 00:21:59,800
Basically, I'll

579
00:22:00,000 --> 00:22:01,100
A skew diagram for you.

580
00:22:01,400 --> 00:22:01,600
All.

581
00:22:01,600 --> 00:22:06,700
We're trying to do here is say well, we've got a 2d thing, right?

582
00:22:06,700 --> 00:22:10,600
Which is a this bitmap, but we have a 1D representation of it because

583
00:22:10,600 --> 00:22:13,400
memory is just a series of bytes, as a giant series of bytes.

584
00:22:13,600 --> 00:22:16,300
So what we need to do is come up with a convention for storing,

585
00:22:16,300 --> 00:22:18,500
something 2D inside, something 3D.

586
00:22:18,700 --> 00:22:22,200
So basically the X, you know, a row of pixels.

587
00:22:22,200 --> 00:22:23,400
It's pretty easy to understand.

588
00:22:23,400 --> 00:22:25,900
Because if I just give you a pointer to a bite, you can assume that

589
00:22:25,900 --> 00:22:28,600
you just start reading the B, and they are a row of pixels, but when

590
00:22:28,600 --> 00:22:29,800
you get to the end of the row,

591
00:22:29,900 --> 00:22:31,900
row, what's what happens?

592
00:22:32,000 --> 00:22:32,600
Right?

593
00:22:32,700 --> 00:22:36,300
Do you just store the next row down on the image?

594
00:22:36,400 --> 00:22:37,300
And they put that there.

595
00:22:37,300 --> 00:22:39,600
Do you start the next row up on the image?

596
00:22:39,800 --> 00:22:41,100
Do you back up?

597
00:22:41,100 --> 00:22:44,100
You know, do do some Porter math, you know, what's going to happen

598
00:22:44,100 --> 00:22:44,200
there?

599
00:22:44,200 --> 00:22:45,800
You need to know what happens at the end of the row.

600
00:22:45,800 --> 00:22:49,900
Where the next rows bits are because basically, you've got a series of

601
00:22:49,900 --> 00:22:51,900
1D slices in memory.

602
00:22:51,900 --> 00:22:53,800
You've got to reassemble into something to D.

603
00:22:54,500 --> 00:22:56,200
Normally, when I do things, I just tack them on.

604
00:22:56,200 --> 00:22:58,900
So it's just one row, the next row, the next row, the next row going,

605
00:22:58,900 --> 00:22:59,800
usually top down.

606
00:23:00,000 --> 00:23:02,300
But we need to know what Windows is going to do.

607
00:23:02,300 --> 00:23:05,000
That thing is called a pitch or a stride.

608
00:23:05,000 --> 00:23:09,200
Typically the value is basically, when you move a pointer, when you're

609
00:23:09,200 --> 00:23:12,600
going from row to row, typically something called a, I think usually

610
00:23:12,600 --> 00:23:16,100
called a pitch, the value that we would add to a pointer to the first

611
00:23:16,100 --> 00:23:20,500
row to move it to the next row is called the pitch.

612
00:23:20,500 --> 00:23:20,900
Usually.

613
00:23:20,900 --> 00:23:26,500
And a stride is the, the number you would add to a pointer to the end

614
00:23:26,500 --> 00:23:30,000
of a row to move it to the next row, I believe that's true.

615
00:23:30,000 --> 00:23:32,000
Really how those two terms are used but doesn't matter point.

616
00:23:32,000 --> 00:23:35,900
Being there is some notion of what you do and we need to know which

617
00:23:35,900 --> 00:23:38,100
one of those stretch bullet uses.

618
00:23:38,400 --> 00:23:39,600
Sorry, stretch the I bet you use it.

619
00:23:39,600 --> 00:23:44,700
So let's take a look at their remarks and see the origin of a

620
00:23:44,700 --> 00:23:46,600
bottom-up dip is the lower left corner.

621
00:23:46,800 --> 00:23:48,500
So we're talking about something there.

622
00:23:48,500 --> 00:23:50,300
It starts down in the lower left corner.

623
00:23:51,000 --> 00:23:53,300
The origin of a top-down dib is the upper left corner.

624
00:23:53,300 --> 00:23:57,200
Now, I don't actually know which one those are, but I suspect that it

625
00:23:57,200 --> 00:23:59,800
has to do with whether we set the bi height.

626
00:24:00,000 --> 00:24:01,900
Parameter to negative or positive.

627
00:24:01,900 --> 00:24:04,500
So I'm going to go ahead and see if I'm right about that guests.

628
00:24:04,500 --> 00:24:06,500
Let's take a look bi height.

629
00:24:06,600 --> 00:24:09,600
Let's see, the height of the bitmap it pixels.

630
00:24:09,600 --> 00:24:10,500
If B is positive.

631
00:24:10,500 --> 00:24:12,700
The bitmap is a bottom-up dib.

632
00:24:13,300 --> 00:24:16,700
Wow, little but the brain circuitry is still sort of working, just

633
00:24:16,700 --> 00:24:17,400
barely folks.

634
00:24:17,600 --> 00:24:20,800
Just barely the bitmap is a bottom-up tube and it's origin is in the

635
00:24:20,800 --> 00:24:21,500
lower left corner.

636
00:24:21,500 --> 00:24:24,900
If you hide it - the bitmap is top-down dip and its Origins the upper

637
00:24:24,900 --> 00:24:25,500
left corner.

638
00:24:25,500 --> 00:24:27,300
So, you know what I prefer top-down.

639
00:24:27,300 --> 00:24:29,900
I don't know if it's a performance penalty will see but we're

640
00:24:30,000 --> 00:24:32,800
To go ahead and say that we're going to make this negative so that we

641
00:24:32,800 --> 00:24:36,100
can ask the rose to go sequentially from the top down because I think

642
00:24:36,100 --> 00:24:36,900
that's a little clearer.

643
00:24:36,900 --> 00:24:38,600
That's usually the way people expect them to go.

644
00:24:39,100 --> 00:24:40,400
And so let's do that for now.

645
00:24:42,700 --> 00:24:44,200
But also lines better with old school.

646
00:24:44,200 --> 00:24:47,200
Programming old-school, frame buffer start at the top and went down.

647
00:24:47,500 --> 00:24:49,700
And maybe you could argue that this isn't as good for thinking about

648
00:24:49,700 --> 00:24:53,100
new things in 3D where opengl want some going the other way and you

649
00:24:53,100 --> 00:24:54,700
know, we'll take a look at all that stuff later.

650
00:24:54,700 --> 00:24:55,500
Don't worry too much about it.

651
00:24:55,500 --> 00:24:57,000
Now, but Point thing I'm gonna go ahead and do that now.

652
00:24:57,000 --> 00:25:00,500
Just to make things a little bit clearer for people out of the gate,

653
00:25:01,000 --> 00:25:03,600
especially since Windows coordinate system is all top down, right?

654
00:25:03,600 --> 00:25:07,900
X is low, X is lower left to X starts on the left.

655
00:25:07,900 --> 00:25:10,700
At zero goes positive towards the right side of

656
00:25:10,800 --> 00:25:13,400
The screen and Y is zero at the top and gets bigger when it goes to

657
00:25:13,400 --> 00:25:13,700
the bottom.

658
00:25:13,700 --> 00:25:14,900
That's a top-down displace.

659
00:25:14,900 --> 00:25:16,800
It's kind of weird to flip them around.

660
00:25:16,800 --> 00:25:18,700
Alright, so back to stretch GI B.

661
00:25:19,200 --> 00:25:20,800
We now know, we have a top-down window.

662
00:25:20,800 --> 00:25:22,300
So let's see what else is says here.

663
00:25:23,100 --> 00:25:26,500
If the parameters differ, they have different signs, going to mirror

664
00:25:26,500 --> 00:25:26,900
image.

665
00:25:26,900 --> 00:25:27,500
We don't want to do that.

666
00:25:27,500 --> 00:25:31,700
We're gonna use the same sign screw top down image for divots - so

667
00:25:31,700 --> 00:25:32,800
that's what we did.

668
00:25:32,900 --> 00:25:37,200
The function allows Spa blah, but it doesn't really say what the

669
00:25:37,200 --> 00:25:38,000
stride is.

670
00:25:38,000 --> 00:25:40,700
It does not seem to say what

671
00:25:40,900 --> 00:25:42,800
Stride is here.

672
00:25:42,800 --> 00:25:45,200
Does the bitmap info say the stride?

673
00:25:45,600 --> 00:25:47,500
I don't think it does.

674
00:25:47,800 --> 00:25:50,200
So I guess we are just going to have to experiment ladies and

675
00:25:50,200 --> 00:25:52,700
gentlemen and see what the striped actually is.

676
00:25:52,700 --> 00:25:54,500
So we're going to pass that bitmap memory.

677
00:25:54,900 --> 00:25:57,300
We are going to go ahead and see what windows does.

678
00:25:57,300 --> 00:25:59,300
Now, we have not put anything in it yet.

679
00:26:00,600 --> 00:26:01,100
So we are.

680
00:26:01,100 --> 00:26:03,500
Oh, this is something I should note actually.

681
00:26:04,100 --> 00:26:07,400
One of the things that's problematic is basically when you do a

682
00:26:07,400 --> 00:26:10,600
compile inside emacs, or, from the command line.

683
00:26:10,800 --> 00:26:11,900
Sometimes msv.

684
00:26:11,900 --> 00:26:15,500
See doesn't give you the full path to the file name and I would like

685
00:26:15,500 --> 00:26:16,900
it to give a full path to the file name.

686
00:26:16,900 --> 00:26:20,400
So basically when you hit CL, right if I hit question mark slash

687
00:26:20,400 --> 00:26:23,100
question mark CL slash question mark you can see that it gives me all

688
00:26:23,100 --> 00:26:28,600
the compiler options and one of these options is basically to to get

689
00:26:28,600 --> 00:26:29,500
full paths.

690
00:26:29,700 --> 00:26:34,800
And so I am going to go ahead and see if I can't get that to happen.

691
00:26:34,800 --> 00:26:37,200
I think I've got less installed on this machine, do I?

692
00:26:37,200 --> 00:26:38,000
I do.

693
00:26:38,300 --> 00:26:40,500
So I'm going to go ahead and search for full.

694
00:26:40,900 --> 00:26:43,300
Let's see, useful past name / FC.

695
00:26:43,600 --> 00:26:43,900
Okay.

696
00:26:43,900 --> 00:26:44,500
There we go.

697
00:26:44,700 --> 00:26:50,200
So FC is what we want in our build bat, and let's see if I can go

698
00:26:50,200 --> 00:26:52,300
ahead and load that up.

699
00:26:52,300 --> 00:26:54,700
So, let's get a minus FC in there.

700
00:26:55,000 --> 00:26:56,000
See if that works.

701
00:26:56,200 --> 00:26:58,200
And it does look at that full path name.

702
00:26:58,200 --> 00:26:59,800
So what's a nice thing about that is now I can just

703
00:27:00,000 --> 00:27:02,900
Turn on that and emacs and we'll jump right to the line or I can hit

704
00:27:02,900 --> 00:27:03,700
alt M.

705
00:27:03,800 --> 00:27:07,100
Sorry alt n, which is my go-to next error, which makes it a little

706
00:27:07,100 --> 00:27:08,200
easier to find these bugs.

707
00:27:08,200 --> 00:27:11,200
So we change the definition of win32 update window.

708
00:27:11,200 --> 00:27:12,000
We certainly did.

709
00:27:12,000 --> 00:27:14,800
And so we have to go back and take a look here and call it the correct

710
00:27:14,800 --> 00:27:15,000
way.

711
00:27:15,000 --> 00:27:16,400
It needs to take the device context.

712
00:27:16,400 --> 00:27:18,900
It doesn't stick window rack, which we have not passed it.

713
00:27:19,100 --> 00:27:21,500
So I'm going to go ahead and take the same code here.

714
00:27:21,800 --> 00:27:24,300
This that just got the client rectangle and I'm going to pass that for

715
00:27:24,300 --> 00:27:24,500
now.

716
00:27:24,500 --> 00:27:26,500
You may want to clean that up a little bit, but that should be

717
00:27:26,500 --> 00:27:27,200
sufficient.

718
00:27:27,400 --> 00:27:29,800
That is the rectangle that we wanted the same way.

719
00:27:30,000 --> 00:27:32,000
On that we were using to resize our bitmap.

720
00:27:32,000 --> 00:27:33,400
So off we go.

721
00:27:33,700 --> 00:27:34,700
Let's run the code.

722
00:27:34,700 --> 00:27:35,900
We have not put anything in there.

723
00:27:35,900 --> 00:27:38,200
So basically what we're looking here is to make sure we don't crash

724
00:27:38,200 --> 00:27:39,800
because we don't know what stress GI B is going to do.

725
00:27:39,800 --> 00:27:41,000
We want to make sure we're passing it.

726
00:27:41,000 --> 00:27:43,400
Something at least semi valid, we seem to be.

727
00:27:43,500 --> 00:27:45,600
So that is a good start.

728
00:27:45,600 --> 00:27:47,800
Now, let's go ahead and actually draw those pixels.

729
00:27:47,800 --> 00:27:50,200
This is what I wanted to do tonight and we are already there.

730
00:27:50,400 --> 00:27:52,100
I don't know if you can contain your excitement.

731
00:27:52,100 --> 00:27:53,100
You probably can't up.

732
00:27:53,100 --> 00:27:55,300
Didn't your ettore for a syntax again said, I wouldn't do it on the

733
00:27:55,300 --> 00:27:58,500
screen and I did, we are going to go row by row through this bitmap,

734
00:27:58,500 --> 00:27:59,900
ladies and gentlemen, so we are

735
00:28:00,000 --> 00:28:04,000
To start with a for Loop that goes over the bitmap height.

736
00:28:04,200 --> 00:28:06,200
And we are going to look at each individual row.

737
00:28:06,200 --> 00:28:07,900
And for each individual row.

738
00:28:08,100 --> 00:28:13,300
We are going to go ahead and go over each pixel in that row, and for

739
00:28:13,300 --> 00:28:15,200
each one of those did it again.

740
00:28:15,300 --> 00:28:18,000
Her old habits are hard to break using the stream to try and break

741
00:28:18,000 --> 00:28:18,700
that habit.

742
00:28:18,800 --> 00:28:20,100
I know it's not useful anymore.

743
00:28:20,200 --> 00:28:22,300
What can I say old dog?

744
00:28:22,300 --> 00:28:22,900
New tricks.

745
00:28:23,000 --> 00:28:23,500
Sometimes takes.

746
00:28:23,500 --> 00:28:23,900
Well.

747
00:28:26,400 --> 00:28:30,600
Alright, so we have our bitmap memory.

748
00:28:30,600 --> 00:28:33,800
It is a big old chunk of memory reserved by windows for us

749
00:28:33,800 --> 00:28:36,200
specifically for the purpose of writing pixels into it.

750
00:28:36,200 --> 00:28:37,100
But we have a problem.

751
00:28:37,100 --> 00:28:39,000
It is a void pointer and a void pointer.

752
00:28:39,000 --> 00:28:42,300
As you know is a pointer to something that c does not understand.

753
00:28:42,400 --> 00:28:43,500
So in order to start writing to it.

754
00:28:43,500 --> 00:28:45,000
We have to change it into a pointer.

755
00:28:45,000 --> 00:28:46,100
It does understand.

756
00:28:46,400 --> 00:28:50,000
Now, what I want to do is I want actual explicit control over the

757
00:28:50,000 --> 00:28:51,600
pointer and how it's going to move.

758
00:28:51,600 --> 00:28:55,600
So I want to tell see first of all, basically that it is

759
00:28:55,800 --> 00:28:59,300
Going to treat it as a pointer to just bytes in memory.

760
00:28:59,300 --> 00:29:01,700
So I'm going to cast this to a care star.

761
00:29:01,700 --> 00:29:01,900
Now.

762
00:29:01,900 --> 00:29:05,400
I usually use like to use unsigned care Star right and these get sort

763
00:29:05,400 --> 00:29:07,200
of a knowing the type.

764
00:29:07,200 --> 00:29:09,500
So one thing that we're going to do and I'm going to start doing it

765
00:29:09,500 --> 00:29:12,500
now because why not is I like to type def, some convenient.

766
00:29:12,500 --> 00:29:15,600
Typedefs hear something that's a little easier to type and that means

767
00:29:15,600 --> 00:29:19,000
what what I actually want it to me because I really don't care about

768
00:29:19,000 --> 00:29:19,600
unsigned care.

769
00:29:19,600 --> 00:29:22,200
What I care is that this is an unsigned 8-bit integer.

770
00:29:22,200 --> 00:29:25,600
So I like to use you ate for that and basically what

771
00:29:25,700 --> 00:29:28,300
you used to do in the old days is what I'm typing in right now, right.

772
00:29:28,300 --> 00:29:29,500
You used to do bitmap memory.

773
00:29:29,500 --> 00:29:30,100
There you go.

774
00:29:30,100 --> 00:29:31,100
You should do that.

775
00:29:31,500 --> 00:29:36,600
But recently, in C, and I forget exactly where these are defined think

776
00:29:36,600 --> 00:29:38,100
it's in standard type study.

777
00:29:38,100 --> 00:29:39,000
Is that a thing?

778
00:29:39,200 --> 00:29:40,300
Let's find out.

779
00:29:40,500 --> 00:29:41,300
Is that a thing?

780
00:29:41,300 --> 00:29:42,200
No, it is not.

781
00:29:42,300 --> 00:29:43,100
Is it a standard?

782
00:29:43,100 --> 00:29:43,800
Lib?

783
00:29:43,800 --> 00:29:45,000
I don't know where it is.

784
00:29:45,100 --> 00:29:45,800
Who knows where it is?

785
00:29:45,800 --> 00:29:46,200
Basically.

786
00:29:46,200 --> 00:29:49,800
There are new types that actually have the thing that you actually

787
00:29:49,800 --> 00:29:52,700
want, but I don't actually know where they are normally defined

788
00:29:52,700 --> 00:29:53,300
anymore.

789
00:29:54,000 --> 00:29:55,500
That is not correct, but I know you've

790
00:29:55,700 --> 00:29:56,200
got these.

791
00:29:56,200 --> 00:29:57,800
So I'm gonna go ahead and search for where they are.

792
00:29:58,000 --> 00:29:59,800
They only just introduce them recently.

793
00:30:00,000 --> 00:30:03,800
Well, recently in my, you know, I'm old so recently, it's probably

794
00:30:03,800 --> 00:30:05,200
like five years, right?

795
00:30:05,400 --> 00:30:09,500
But but I always had to do these myself back in the day standard ant.

796
00:30:09,500 --> 00:30:12,100
That's what it is, but they've recently added these and that's kind of

797
00:30:12,100 --> 00:30:12,500
cool.

798
00:30:12,500 --> 00:30:15,600
Basically, there are now types which are actually set up to be the

799
00:30:15,600 --> 00:30:19,100
correct size for your platform because platforms used to differ in

800
00:30:19,100 --> 00:30:20,700
terms of what sizes things were.

801
00:30:20,700 --> 00:30:23,600
So if you said in unsigned, that could have been 16 bits, right?

802
00:30:23,600 --> 00:30:24,300
And that's no good.

803
00:30:24,300 --> 00:30:26,500
If you actually needed the thing to be a precise size.

804
00:30:26,600 --> 00:30:28,100
So now that you can actually do that.

805
00:30:28,400 --> 00:30:29,500
I'd like to actually do that.

806
00:30:29,500 --> 00:30:29,800
These are the

807
00:30:30,000 --> 00:30:32,300
Types that I used to use and coincidentally, see who's the type, which

808
00:30:32,300 --> 00:30:35,600
is almost the same but I like to Define it to be my own way just

809
00:30:35,600 --> 00:30:39,600
because I am Persnickety that way you could just as well, use you n8t.

810
00:30:39,600 --> 00:30:41,000
Anyway, that's something to think about.

811
00:30:41,100 --> 00:30:44,400
We are going to basically cast this to an unsigned 8-bit integer, and

812
00:30:44,400 --> 00:30:46,700
only reason I'm doing that is because I'm going to be doing pointer

813
00:30:46,700 --> 00:30:47,500
arithmetic.

814
00:30:47,500 --> 00:30:51,100
And as we know from the interest-free many time, I add or subtract

815
00:30:51,100 --> 00:30:53,100
something for a pointer to move it around in memory.

816
00:30:53,500 --> 00:30:56,400
See will silently multiply that Movement by the size of the thing

817
00:30:56,400 --> 00:30:57,100
being pointed to.

818
00:30:57,100 --> 00:30:59,800
So if I were to change this to a 16-bit, it would move.

819
00:31:00,000 --> 00:31:02,900
I to every time and I don't want to do that.

820
00:31:02,900 --> 00:31:05,600
I want to make sure I can do the arithmetic explicitly.

821
00:31:05,600 --> 00:31:05,800
Now.

822
00:31:05,800 --> 00:31:09,400
That's just something I tend to do in pixel operations.

823
00:31:09,900 --> 00:31:13,300
The reason for that is because sometimes you'll see later on, they

824
00:31:13,300 --> 00:31:16,300
tend to have strides that aren't necessarily aligned, on Pixel

825
00:31:16,300 --> 00:31:18,500
boundaries for various reasons, stuff like that.

826
00:31:18,500 --> 00:31:20,000
It's just a better way to write these Loops.

827
00:31:20,000 --> 00:31:21,500
You'll have to take my word on it for now.

828
00:31:21,900 --> 00:31:23,300
That's just kind of a better way to do it.

829
00:31:23,300 --> 00:31:25,700
But once we get in here we can cast it to what we're actually looking

830
00:31:25,700 --> 00:31:29,800
at and that is a 32-bit integer for going pixel.

831
00:31:29,900 --> 00:31:30,600
By pixel.

832
00:31:30,600 --> 00:31:35,500
So basically, what I will do is it's cast my row pointer here to that.

833
00:31:35,600 --> 00:31:38,400
And then, at the end of each of these iterations, I will increment the

834
00:31:38,400 --> 00:31:42,300
row pointer by that pitch which is the amount we're going to do to

835
00:31:42,300 --> 00:31:42,600
move it.

836
00:31:42,600 --> 00:31:46,200
And of course, the pitch is the difference between the the row, a row

837
00:31:46,200 --> 00:31:50,800
and the next row that is basically just going to be the width times

838
00:31:50,800 --> 00:31:52,700
the size of the, of the pixel, right?

839
00:31:52,700 --> 00:31:56,900
That is how big each individual row is a row, is with pixels wide.

840
00:31:56,900 --> 00:31:58,600
And each one of them is by 4 pixels long.

841
00:31:58,600 --> 00:31:59,500
So that's how big it is.

842
00:31:59,500 --> 00:31:59,800
So,

843
00:32:00,000 --> 00:32:01,700
From row to row, that is the size.

844
00:32:01,700 --> 00:32:03,000
That is the the pitch.

845
00:32:03,000 --> 00:32:04,500
And then each row.

846
00:32:04,500 --> 00:32:05,500
I'm going to access here.

847
00:32:05,500 --> 00:32:07,400
Now again, this is maybe a strange way to write a loop.

848
00:32:07,400 --> 00:32:10,300
It's just a good way that I find a right pixel Loops because

849
00:32:10,300 --> 00:32:13,500
oftentimes, this pitch value, you know, you might say looking at this

850
00:32:13,500 --> 00:32:16,400
it's totally valid and you're totally right to look at this and go.

851
00:32:16,400 --> 00:32:19,100
Hey, wait a second, this pixel.

852
00:32:19,500 --> 00:32:21,200
I bet you're just going to do this in their right.

853
00:32:21,200 --> 00:32:24,400
You're going to go ahead and increment this pixel every time right

854
00:32:24,400 --> 00:32:26,500
through the loop to write to the different pixels on the road.

855
00:32:26,500 --> 00:32:27,500
By the time you get to the end.

856
00:32:27,500 --> 00:32:29,800
It will already be right where this thing is going.

857
00:32:29,900 --> 00:32:30,500
Owing to be.

858
00:32:30,600 --> 00:32:31,100
Why are you doing?

859
00:32:31,100 --> 00:32:32,000
That's inefficient.

860
00:32:32,100 --> 00:32:32,800
You're correct.

861
00:32:32,800 --> 00:32:35,300
The reason I'm doing it is because typically when we do these things,

862
00:32:35,300 --> 00:32:37,500
the pitch is actually not going to line up with this.

863
00:32:37,700 --> 00:32:40,600
And so it's usually easier to write them in this way for various

864
00:32:40,600 --> 00:32:44,100
reasons, most of the time, but the other way we could do it is to just

865
00:32:44,100 --> 00:32:45,700
take pixel and add the stride here.

866
00:32:45,800 --> 00:32:46,800
Six of one half-dozen of the other.

867
00:32:46,800 --> 00:32:48,000
Some, they have performance concerns.

868
00:32:48,000 --> 00:32:48,600
Those are all things.

869
00:32:48,600 --> 00:32:49,900
We look at much later.

870
00:32:49,900 --> 00:32:51,200
So don't worry about it too much right now.

871
00:32:51,200 --> 00:32:53,900
That's just a good way to write those Loops, typically before you're

872
00:32:53,900 --> 00:32:56,100
going to actually go in and start doing any kind of Performance

873
00:32:56,100 --> 00:32:56,300
Tuning.

874
00:32:56,300 --> 00:32:58,800
Now, I went ahead and added you in 32 because we had to find that yet.

875
00:32:58,800 --> 00:32:59,800
You know what we could go bananas.

876
00:33:00,000 --> 00:33:04,800
Here, folks and just finish off our typeset entirely and get all the

877
00:33:04,800 --> 00:33:07,200
different types that we might use.

878
00:33:07,400 --> 00:33:08,100
Well, not all of them.

879
00:33:08,100 --> 00:33:10,100
But you know, most of them just get them in there.

880
00:33:10,100 --> 00:33:12,200
We will be moving these to a platform independent, header, at some

881
00:33:12,200 --> 00:33:13,200
point because that's pretty good.

882
00:33:13,200 --> 00:33:13,700
So, there we go.

883
00:33:13,700 --> 00:33:17,200
We've kind of defined our various sizes, good to have on hand.

884
00:33:18,300 --> 00:33:19,400
All right, inside here.

885
00:33:19,400 --> 00:33:21,700
I'm going to use the dereference operator to write to this pixel.

886
00:33:21,700 --> 00:33:24,600
Basically, that says, I am trying to access a memory pointed to, by

887
00:33:24,600 --> 00:33:27,200
this pointer, which should be pointing to each individual pixel.

888
00:33:27,200 --> 00:33:28,800
And I need something to write in here.

889
00:33:28,800 --> 00:33:28,900
Now.

890
00:33:28,900 --> 00:33:29,800
What am I going to write in here?

891
00:33:30,000 --> 00:33:30,300
Well.

892
00:33:33,200 --> 00:33:36,100
Each of these pixels is essentially packed in memory.

893
00:33:37,200 --> 00:33:42,200
This is the structure of the pixel pixel in memory, right?

894
00:33:42,200 --> 00:33:46,200
We basically have location 0 and that's going to be 8 Bits.

895
00:33:46,200 --> 00:33:49,200
So we basically have in hexadecimal that is two of those things.

896
00:33:49,600 --> 00:33:50,600
This is the first one.

897
00:33:50,800 --> 00:33:51,700
This is the second one.

898
00:33:51,800 --> 00:33:52,700
This is the third one.

899
00:33:52,800 --> 00:33:53,600
This is the fourth one.

900
00:33:53,600 --> 00:33:53,700
Now.

901
00:33:53,700 --> 00:33:57,600
The question is, we know, we have to write r g and B, which one do we

902
00:33:57,600 --> 00:33:58,000
write it 2?

903
00:33:58,000 --> 00:33:59,100
And this is the pixel and memory.

904
00:33:59,100 --> 00:34:02,200
So this is basically the location 0 from the, from the thing.

905
00:34:02,200 --> 00:34:03,200
This is 1 by 10.

906
00:34:03,200 --> 00:34:06,500
This is 2, bytes in, this is three bites in from the pointer.

907
00:34:06,700 --> 00:34:06,900
So,

908
00:34:07,000 --> 00:34:09,199
Basically pixel plus zero, right pixel?

909
00:34:09,199 --> 00:34:11,199
Plus 1 pixel plus 2.

910
00:34:11,199 --> 00:34:11,900
Well, they're not really.

911
00:34:11,900 --> 00:34:15,300
It's the only if that was it's only if this was a un8 right?

912
00:34:15,300 --> 00:34:19,800
Like I said, is that so this is this is pixel + 0 b, + + 1, B and so

913
00:34:19,800 --> 00:34:21,199
on from that pixel pointer.

914
00:34:21,199 --> 00:34:22,600
We are going in memories, right?

915
00:34:22,600 --> 00:34:23,900
So this is this is what that is.

916
00:34:24,000 --> 00:34:26,100
Now the question is which one of those is red?

917
00:34:26,100 --> 00:34:27,900
Which one of those is green, which one of those is blue.

918
00:34:27,900 --> 00:34:31,000
Now, if you were going in memory order, you would probably think.

919
00:34:31,000 --> 00:34:33,199
Well, let's put to the 8 Bits of red there.

920
00:34:33,199 --> 00:34:34,600
Let's put the 8 Bits of green there.

921
00:34:34,600 --> 00:34:36,800
Let's put the 8 Bits of be there, and let's leave this as the

922
00:34:36,900 --> 00:34:40,199
Ting B that you said you're going to have but what happens if we do

923
00:34:40,199 --> 00:34:41,699
that, well, you know what?

924
00:34:41,699 --> 00:34:44,400
I'm just going to do that and I'm going to let you see what happens.

925
00:34:45,500 --> 00:34:48,100
And in fact, you know what I could do just you know, why confuse the

926
00:34:48,100 --> 00:34:48,500
matter.

927
00:34:49,400 --> 00:34:52,199
Let's just start doing it this way, so I can show you full explicitly.

928
00:34:52,500 --> 00:34:54,000
This is will actually be that way.

929
00:34:54,000 --> 00:34:55,500
So we'll just actually do each individual.

930
00:34:55,500 --> 00:35:00,200
One will basically do the first one, so this will be pixel and will

931
00:35:00,200 --> 00:35:02,200
then we'll increment each time will do.

932
00:35:02,300 --> 00:35:04,800
Will do this will actually do it fully explicitly, right?

933
00:35:04,800 --> 00:35:06,200
So we write each byte in memory.

934
00:35:07,100 --> 00:35:11,200
Why not seems like a good idea just to show basically what's

935
00:35:11,200 --> 00:35:11,700
happening.

936
00:35:11,800 --> 00:35:13,800
So let's say we were to write the red first.

937
00:35:13,900 --> 00:35:17,100
So, you know structured art is always a good idea to get things to

938
00:35:17,100 --> 00:35:17,500
bug.

939
00:35:17,500 --> 00:35:19,400
We want to see if we're writing to this thing properly.

940
00:35:19,500 --> 00:35:21,600
So we're going to just write to the red Channel and we'll leave the

941
00:35:21,600 --> 00:35:24,000
green and blue channels black for now so that we can isolate the red

942
00:35:24,000 --> 00:35:25,700
Channel and make sure that we know how to write to it.

943
00:35:25,800 --> 00:35:28,500
Alright, so we're going to write 0 into what we think is green.

944
00:35:28,500 --> 00:35:29,300
What we think is blue.

945
00:35:29,300 --> 00:35:31,700
And then what we think is the pad will also leave zero and then we'll

946
00:35:31,700 --> 00:35:34,700
just write the maximum value for an unsigned character which is 255

947
00:35:34,700 --> 00:35:36,800
into the red Channel or what we think is the red.

948
00:35:36,900 --> 00:35:40,000
No, and then we'll compile that and see how it goes.

949
00:35:40,100 --> 00:35:41,600
We will now go ahead and run this program.

950
00:35:41,600 --> 00:35:43,800
And first of all, we have to see do we get anything on the screen at

951
00:35:43,800 --> 00:35:44,300
all?

952
00:35:44,500 --> 00:35:47,100
And you will see we do get something on the screen, but ladies and

953
00:35:47,100 --> 00:35:48,300
gentlemen, it is blue.

954
00:35:48,500 --> 00:35:50,000
Why is it blue?

955
00:35:50,200 --> 00:35:51,300
Why is it blue?

956
00:35:53,600 --> 00:35:56,600
does anyone know why it's blue welder experts out there who know why

957
00:35:56,600 --> 00:35:59,400
it's blue, but I'm talking about people who took like the intro to

958
00:35:59,400 --> 00:35:59,800
seek or

959
00:36:00,200 --> 00:36:02,000
I'm not talking about the grizzled veterans.

960
00:36:02,000 --> 00:36:02,500
You know why?

961
00:36:02,500 --> 00:36:03,100
It's blue.

962
00:36:06,200 --> 00:36:08,000
You get it yet, It's Tricky.

963
00:36:08,900 --> 00:36:10,800
But we did cover it in the intro to see course.

964
00:36:10,900 --> 00:36:11,400
We did.

965
00:36:11,400 --> 00:36:12,100
Cover it.

966
00:36:12,100 --> 00:36:16,500
The reason is because this is a little endian architecture.

967
00:36:16,500 --> 00:36:22,500
Ladies and gentlemen, which means, as I specified in the intro stream

968
00:36:22,700 --> 00:36:26,300
when B, our load out of memory load it out of memory to form a bigger

969
00:36:26,300 --> 00:36:26,800
value.

970
00:36:26,800 --> 00:36:31,700
So, if I wanted to load for B and produce a Unit, 32 out of them, the

971
00:36:31,700 --> 00:36:35,900
processor will actually put the first byte in the lowest part.

972
00:36:36,500 --> 00:36:37,600
Of those 32 bits.

973
00:36:37,700 --> 00:36:41,600
The second byte will go in the next part and then the next part, and

974
00:36:41,600 --> 00:36:44,100
the highest will be the fourth B.

975
00:36:44,100 --> 00:36:44,500
/.

976
00:36:44,600 --> 00:36:48,100
So basically what happens is, if these are the pixels in memory, if

977
00:36:48,100 --> 00:36:52,700
you were to load them into a un 32, you would load them are first into

978
00:36:52,700 --> 00:36:53,500
the low.

979
00:36:53,500 --> 00:36:54,700
I'm going to use the hexadecimal notation.

980
00:36:54,700 --> 00:36:55,300
We learned.

981
00:36:55,900 --> 00:37:00,400
Here are our heroes are 32-bit value in a register, 32 bits.

982
00:37:00,400 --> 00:37:02,500
Now, it's one big value, right?

983
00:37:03,000 --> 00:37:05,900
The first two are and our go down here.

984
00:37:06,000 --> 00:37:07,800
Here the next to GG.

985
00:37:08,000 --> 00:37:08,900
Go in here.

986
00:37:09,000 --> 00:37:13,800
The next to BB go in here, the next 2, XX, go right there.

987
00:37:13,800 --> 00:37:15,500
And look at that.

988
00:37:15,900 --> 00:37:18,700
It is backwards now BGR.

989
00:37:19,400 --> 00:37:22,100
Well, the person people who wrote Windows didn't like that very much.

990
00:37:22,200 --> 00:37:24,100
They were on a little endian architecture and when they loaded a

991
00:37:24,100 --> 00:37:27,800
32-bit value and thought of it as a pixel, they wanted it to look like

992
00:37:27,800 --> 00:37:30,800
it was in the right order when they were looking at it in the register

993
00:37:30,800 --> 00:37:31,700
of the CPU.

994
00:37:31,700 --> 00:37:35,100
So what they did is they Define the memory order to be backwards.

995
00:37:35,300 --> 00:37:35,900
So it would look like

996
00:37:36,000 --> 00:37:40,000
That which means that it is swapped in the memory of the machine.

997
00:37:40,200 --> 00:37:43,900
So all windows bitmaps actually have the blue b first, the green B.

998
00:37:43,900 --> 00:37:48,700
Next, the red bite after that and then the pad at the end that is

999
00:37:48,700 --> 00:37:49,800
basically how that works.

1000
00:37:50,400 --> 00:37:55,000
And well there's really no other explanation for it than that.

1001
00:37:55,100 --> 00:37:58,700
So what that means is, if we actually want our red shirt to show up as

1002
00:37:58,700 --> 00:38:01,200
red, we need to move it to the third pixel.

1003
00:38:01,400 --> 00:38:03,800
Sorry the third bite and then we run it.

1004
00:38:03,800 --> 00:38:05,800
And now we've got a red bitmap blazing.

1005
00:38:06,000 --> 00:38:07,500
Gentleman, isn't that beautiful?

1006
00:38:07,500 --> 00:38:11,200
And I argue that it is in fact, beautiful, a very beautiful thing.

1007
00:38:11,300 --> 00:38:14,700
Now what we might want to do is start to make this a little bit

1008
00:38:14,700 --> 00:38:16,200
prettier as we go.

1009
00:38:16,300 --> 00:38:19,100
Let's see if we can do something a little bit cooler.

1010
00:38:19,200 --> 00:38:24,200
How about we go ahead and assign just the x-coordinate, cast it down.

1011
00:38:24,300 --> 00:38:27,800
So truncated, basically chopped off if you will just take the lower

1012
00:38:27,800 --> 00:38:33,800
bits of that value and we'll go ahead and assign green into the why

1013
00:38:33,800 --> 00:38:35,700
Channel and then I don't know what will

1014
00:38:36,000 --> 00:38:37,000
Will sign to Blue.

1015
00:38:37,000 --> 00:38:39,500
I guess we'll just leave blue black or sorry.

1016
00:38:40,300 --> 00:38:41,200
Even I'm messed up.

1017
00:38:41,200 --> 00:38:41,500
Now.

1018
00:38:41,700 --> 00:38:45,200
This is actually blue, not red.

1019
00:38:45,200 --> 00:38:47,900
So this is the red channel that will be will be empty.

1020
00:38:47,900 --> 00:38:51,700
So this way, we can, at least get a little amusing gradient going on.

1021
00:38:51,900 --> 00:38:55,700
There you go, as you can see much more attractive than what we were

1022
00:38:55,700 --> 00:38:59,600
drawing before if still not a game, at least something kind of fun.

1023
00:39:00,000 --> 00:39:01,500
Looks like it is all working correctly.

1024
00:39:01,500 --> 00:39:04,000
And now you can see what I did there pretty straightforward.

1025
00:39:04,000 --> 00:39:05,700
I just said, whatever our Exposition is.

1026
00:39:05,700 --> 00:39:08,200
I'm going to take the low bits of that, and I'm going to shove it

1027
00:39:08,200 --> 00:39:09,200
directly in the blue Channel.

1028
00:39:09,200 --> 00:39:12,200
Going to take the low bits of the, why the road that we're on shove

1029
00:39:12,200 --> 00:39:12,600
that in.

1030
00:39:12,600 --> 00:39:14,900
And so you basically get exactly that.

1031
00:39:14,900 --> 00:39:20,000
Look, you get 256 pixels of increasing blue and then it dropped back

1032
00:39:20,000 --> 00:39:23,200
to zero to hundred more 206, more of increasing blue drops, back down

1033
00:39:23,200 --> 00:39:26,900
to 0, because that is just the 8 Bits of the y-value going up, and up,

1034
00:39:26,900 --> 00:39:27,200
and up.

1035
00:39:27,200 --> 00:39:29,000
I hope that is pretty clear to people what's going on.

1036
00:39:29,000 --> 00:39:30,000
There, won't belabor that point.

1037
00:39:30,000 --> 00:39:31,900
A point, but we can go over it in the Q&A.

1038
00:39:32,000 --> 00:39:33,900
If it is somehow mysterious to you.

1039
00:39:33,900 --> 00:39:35,400
Now, ladies and gentlemen, we have done.

1040
00:39:35,400 --> 00:39:39,400
Something that is is rather remarkable.

1041
00:39:39,400 --> 00:39:44,600
If you will, we have gotten ourselves back to 1980.

1042
00:39:45,500 --> 00:39:46,500
That is what we have done.

1043
00:39:46,900 --> 00:39:48,000
I could not be happier.

1044
00:39:50,500 --> 00:39:53,300
But what just happened right before your very eyes, as we have turned

1045
00:39:53,300 --> 00:39:54,900
this modern awesome.

1046
00:39:55,100 --> 00:39:58,700
Beastly computer running a hugely complicated and difficult to wield

1047
00:39:58,700 --> 00:40:02,200
operating system into something where we just basically have a bitmap

1048
00:40:02,200 --> 00:40:05,300
that we can draw two and get back to the joy of coding because there

1049
00:40:05,300 --> 00:40:06,100
is no stopping us.

1050
00:40:06,100 --> 00:40:07,400
Now, we can draw anything.

1051
00:40:07,400 --> 00:40:10,500
We wanted that but there is something we could still do.

1052
00:40:10,500 --> 00:40:13,700
We have 20 minutes left in the Stream and 20 minutes is just enough to

1053
00:40:13,700 --> 00:40:16,500
start to do some damage on something else we might want to do.

1054
00:40:16,500 --> 00:40:18,600
So I say we go ahead.

1055
00:40:18,900 --> 00:40:19,700
And do it.

1056
00:40:19,800 --> 00:40:20,800
I am feeling good tonight.

1057
00:40:20,800 --> 00:40:23,900
Ladies and Gentlemen, even though I am sick, that is usually means

1058
00:40:24,300 --> 00:40:27,100
since Pride cometh before the fall that something terrible will happen

1059
00:40:27,100 --> 00:40:28,200
to me in the next 20 minutes.

1060
00:40:28,200 --> 00:40:29,500
But what can you do?

1061
00:40:29,600 --> 00:40:30,400
I can't stop that.

1062
00:40:30,400 --> 00:40:31,600
It was going to happen was going to happen.

1063
00:40:31,600 --> 00:40:34,400
Anyway, might as well enjoy the last 20 minutes that you get, if

1064
00:40:34,400 --> 00:40:36,300
you're about to get hit by a bus or whatever it is.

1065
00:40:36,300 --> 00:40:37,200
That's going to happen to you.

1066
00:40:37,200 --> 00:40:40,800
I say we move the rendering code for our bitmap.

1067
00:40:41,600 --> 00:40:46,100
Up here into a separate function that basically says, what's this

1068
00:40:46,100 --> 00:40:47,100
function to be called?

1069
00:40:47,100 --> 00:40:48,400
I don't know what it's going to be called.

1070
00:40:48,400 --> 00:40:53,300
Maybe we will call it render weird gradient because honestly, that is

1071
00:40:53,300 --> 00:40:56,200
what it is doing and the render reared gradient call.

1072
00:40:56,400 --> 00:41:00,600
We'll go ahead and take some kind of an integer that will be the X

1073
00:41:00,600 --> 00:41:02,500
offset and the Y offset.

1074
00:41:02,500 --> 00:41:06,600
And all I'm going to do there is when we stuff our values in, we will

1075
00:41:06,600 --> 00:41:11,100
add those offsets so that we can animate our gradient around the

1076
00:41:11,600 --> 00:41:12,600
Name makes sense.

1077
00:41:12,600 --> 00:41:15,000
I think it makes sense seems like a good idea to me.

1078
00:41:16,000 --> 00:41:17,400
And like I said, we got 20 minutes left.

1079
00:41:17,400 --> 00:41:19,200
So how wrong can we really go?

1080
00:41:19,200 --> 00:41:19,400
Now?

1081
00:41:19,400 --> 00:41:22,500
If we want to reproduce the probe, the behavior of our own program, we

1082
00:41:22,500 --> 00:41:26,400
can certainly just do that by calling a render weird gradient right

1083
00:41:26,400 --> 00:41:31,700
there and we can pass 00 to verify that we did not mess anything up.

1084
00:41:31,900 --> 00:41:32,200
Of course.

1085
00:41:32,200 --> 00:41:34,800
It needs to know how big those are, but we save those.

1086
00:41:34,800 --> 00:41:37,400
So that's fine because the width and the height are actually Global

1087
00:41:37,400 --> 00:41:41,000
variables currently, so we can go ahead and use those right there.

1088
00:41:41,400 --> 00:41:44,600
Let's go ahead and call in with the bitmap with then.

1089
00:41:44,600 --> 00:41:49,300
We will call in height, the bitmap height and then we are good to go.

1090
00:41:49,300 --> 00:41:50,300
O b, 4 pixel.

1091
00:41:50,900 --> 00:41:52,200
That is actually a constant.

1092
00:41:52,300 --> 00:41:53,600
We will hoist that out for now.

1093
00:41:53,700 --> 00:41:55,000
All of these things are things.

1094
00:41:55,000 --> 00:41:56,200
We're going to have to wrap up.

1095
00:41:56,200 --> 00:41:58,400
I'd kind of had I have a plan for this, by the way.

1096
00:41:58,700 --> 00:41:59,900
I'm not going willy-nilly.

1097
00:42:00,000 --> 00:42:03,300
I do have a plan for how I want to do this, but we will talk about it

1098
00:42:03,300 --> 00:42:07,000
in the Q&A if I don't forget, but I probably will forget so maybe

1099
00:42:07,000 --> 00:42:07,700
someone remind me.

1100
00:42:07,700 --> 00:42:10,800
Hey Casey, you said you're going to do something and you didn't do it.

1101
00:42:10,800 --> 00:42:13,500
Let's verify that we reproduced our program when we abstracted that

1102
00:42:13,500 --> 00:42:15,500
function out and we did, we pull it out.

1103
00:42:15,500 --> 00:42:16,600
All right, good.

1104
00:42:16,600 --> 00:42:17,800
Give ourselves a pat on the back.

1105
00:42:17,800 --> 00:42:17,900
Now.

1106
00:42:17,900 --> 00:42:20,000
Let's make sure that we can use our offset prep.

1107
00:42:20,100 --> 00:42:25,200
I'm going to go ahead and offset it, halfway on, just the x axis X

1108
00:42:25,200 --> 00:42:25,600
ass.

1109
00:42:26,000 --> 00:42:27,000
Yeah, X.

1110
00:42:27,900 --> 00:42:29,700
Axis talking.

1111
00:42:29,700 --> 00:42:31,000
Ladies and gentlemen, it is difficult.

1112
00:42:31,000 --> 00:42:33,100
You've done it all your life, but it is harder than you think when you

1113
00:42:33,100 --> 00:42:34,900
are programming live on Twitch.

1114
00:42:34,900 --> 00:42:36,100
Okay, there we go.

1115
00:42:36,100 --> 00:42:38,100
It is offset properly just like we want it to be.

1116
00:42:38,100 --> 00:42:40,900
So now we have every reason to believe that this function will work.

1117
00:42:40,900 --> 00:42:43,500
But we need to do something if we want to actually make that animate,

1118
00:42:43,500 --> 00:42:44,700
which is what I want to do.

1119
00:42:44,900 --> 00:42:48,100
We need to go down here and not, wait for Windows.

1120
00:42:48,100 --> 00:42:51,500
We do not want to wait around while Windows stuffs and our message

1121
00:42:51,500 --> 00:42:54,600
queue because you remember, I told you about get message a and one of

1122
00:42:54,600 --> 00:42:57,200
the problems with get message a is that it will block.

1123
00:42:57,200 --> 00:42:57,600
So once

1124
00:42:57,700 --> 00:42:58,700
We run out of messages.

1125
00:42:58,800 --> 00:43:00,200
We will block right there.

1126
00:43:00,200 --> 00:43:03,300
Windows will shut us down and it will wait for another message to come

1127
00:43:03,300 --> 00:43:04,000
to our cue.

1128
00:43:04,000 --> 00:43:05,000
It'll go do other things.

1129
00:43:05,000 --> 00:43:05,200
Whatever.

1130
00:43:05,200 --> 00:43:06,300
The other things need to be switched.

1131
00:43:06,300 --> 00:43:09,200
To another process, use that CPU time, effectively.

1132
00:43:11,000 --> 00:43:12,200
We don't want to do that.

1133
00:43:12,200 --> 00:43:14,600
We want to use that CPU time, all for ourselves.

1134
00:43:14,900 --> 00:43:17,800
So really what we want to do here is we want to change this to a

1135
00:43:17,800 --> 00:43:18,800
message Loop.

1136
00:43:18,800 --> 00:43:20,700
That processes messages when there are messages.

1137
00:43:20,700 --> 00:43:24,400
But if there aren't messages, we keep running, right?

1138
00:43:24,900 --> 00:43:25,800
That's what I want to do.

1139
00:43:25,800 --> 00:43:27,500
So we're going to go ahead and do that.

1140
00:43:27,600 --> 00:43:29,000
At why not?

1141
00:43:29,400 --> 00:43:33,000
We're going to go ahead and switch our message Loop by the seat of our

1142
00:43:33,000 --> 00:43:33,300
pants.

1143
00:43:33,300 --> 00:43:37,100
Ladies and gentlemen, to a peak message Loop, instead of a get message

1144
00:43:37,100 --> 00:43:37,500
Loop.

1145
00:43:37,500 --> 00:43:39,100
Here is our Peak message Loop.

1146
00:43:39,100 --> 00:43:42,200
And basically, what a peak message Loop does is the exact same thing

1147
00:43:42,200 --> 00:43:46,100
as get message, but when there is no message, it will allow us to just

1148
00:43:46,100 --> 00:43:48,400
keep on running instead of blocking.

1149
00:43:48,400 --> 00:43:50,900
So we are going to go ahead and call that you can see that it takes

1150
00:43:50,900 --> 00:43:52,200
substantially the same things.

1151
00:43:52,300 --> 00:43:53,900
It takes the address of a message.

1152
00:43:54,000 --> 00:43:56,700
It takes the window handle and the filters just like we filled out

1153
00:43:56,700 --> 00:43:57,500
before Dawn.

1154
00:43:57,700 --> 00:44:00,800
Any of those and then it has one additional flag that we need to know

1155
00:44:00,800 --> 00:44:01,200
what to do.

1156
00:44:01,200 --> 00:44:03,400
Basically, it's just something that says whether it should pull things

1157
00:44:03,400 --> 00:44:05,700
out of the queue or just look at them in the queue and tell you what

1158
00:44:05,700 --> 00:44:06,100
they were.

1159
00:44:06,100 --> 00:44:07,600
Well, we actually want to process our cue.

1160
00:44:07,800 --> 00:44:11,900
So we're going to pull them right on out of there, and that is p.m.

1161
00:44:11,900 --> 00:44:13,800
Or remove messages are removed from the queue.

1162
00:44:13,800 --> 00:44:15,400
After processing, by Peak message.

1163
00:44:15,400 --> 00:44:16,800
Go ahead and copy that out of there.

1164
00:44:17,200 --> 00:44:17,900
Here we go.

1165
00:44:20,000 --> 00:44:20,600
There we go.

1166
00:44:21,100 --> 00:44:23,100
Not bad Peak message.

1167
00:44:23,200 --> 00:44:25,400
Now, that's going to return a Bool and we need to know what that Bool

1168
00:44:25,400 --> 00:44:25,600
is.

1169
00:44:25,600 --> 00:44:27,400
I assume the Boule is whether or not there was a message, but

1170
00:44:27,600 --> 00:44:29,200
Let's go ahead and verify that it's been a long time.

1171
00:44:29,200 --> 00:44:30,700
Since I've actually written one of these Loops.

1172
00:44:30,700 --> 00:44:31,800
I always have the same Loop.

1173
00:44:31,800 --> 00:44:34,100
I've been using for years to be honest with you, cut and paste or use.

1174
00:44:34,100 --> 00:44:35,100
That's the way to do it.

1175
00:44:35,400 --> 00:44:39,200
Okay, so pick message if no message is available return.

1176
00:44:39,200 --> 00:44:39,800
Not okay.

1177
00:44:39,800 --> 00:44:40,300
Nonzero.

1178
00:44:40,300 --> 00:44:43,200
If a message is available, if no message available return 0, so all we

1179
00:44:43,200 --> 00:44:45,800
need to do is say if we got a peak message.

1180
00:44:48,300 --> 00:44:50,100
Then we are going to have to process it.

1181
00:44:50,400 --> 00:44:50,700
Now.

1182
00:44:50,700 --> 00:44:53,800
One of the things that we need to probably do is we don't want to

1183
00:44:53,800 --> 00:44:56,500
repaint all the time because we had lots of messages in our queue.

1184
00:44:56,500 --> 00:44:57,300
We want to process them.

1185
00:44:57,300 --> 00:44:59,700
Also, really, probably what we want to do is we want to say, while

1186
00:44:59,700 --> 00:44:59,800
people?

1187
00:45:00,000 --> 00:45:02,600
I said returns true translate and dispatch all the message just to

1188
00:45:02,600 --> 00:45:06,000
flush out our Cube because we're kind of obligated to process that Q.

1189
00:45:06,000 --> 00:45:08,100
We can't not process that Q or app.

1190
00:45:08,100 --> 00:45:09,600
Will start being badly behaved.

1191
00:45:09,900 --> 00:45:11,900
Maybe we want a gate limit that sometime just in case.

1192
00:45:11,900 --> 00:45:14,600
There's a flood of messages but I don't know really.

1193
00:45:14,600 --> 00:45:15,200
There's nothing you can do.

1194
00:45:15,200 --> 00:45:16,300
You got to process your Q.

1195
00:45:16,300 --> 00:45:17,600
That's pretty much just something you got to do.

1196
00:45:17,600 --> 00:45:20,000
So, we're probably just going to have to be stuck doing that.

1197
00:45:20,000 --> 00:45:20,600
So let's do it.

1198
00:45:20,600 --> 00:45:23,300
So this will flush out our cue as long as there are messages the Q.

1199
00:45:23,400 --> 00:45:24,300
It will process them.

1200
00:45:24,300 --> 00:45:27,700
But now we will no longer get our PR are quick message.

1201
00:45:27,800 --> 00:45:28,700
Oh, but that's okay.

1202
00:45:28,700 --> 00:45:29,900
We don't have to worry about that because

1203
00:45:30,000 --> 00:45:32,600
We are now using the running thing, but we should probably double

1204
00:45:32,600 --> 00:45:36,900
check our message to make sure that we're not getting a quick message

1205
00:45:36,900 --> 00:45:38,900
from Windows from some other for some other reasons.

1206
00:45:38,900 --> 00:45:41,700
So I'm going to go ahead and double-check that MSG structure.

1207
00:45:42,900 --> 00:45:43,400
Let's see here.

1208
00:45:43,400 --> 00:45:44,300
Dot message.

1209
00:45:44,400 --> 00:45:45,500
So dot message.

1210
00:45:45,600 --> 00:45:48,300
I'm going to say that if Dot message is equal to W M.

1211
00:45:48,300 --> 00:45:48,800
Quit.

1212
00:45:49,300 --> 00:45:52,500
I am going to make sure that running equals false so that we just

1213
00:45:52,500 --> 00:45:57,000
quit, anytime we get that W and quit message just to make sure that

1214
00:45:57,000 --> 00:45:59,700
we're handling this case that we use to handle down here.

1215
00:46:00,000 --> 00:46:00,400
Okay.

1216
00:46:00,500 --> 00:46:03,100
So basically, that will still do the exact same thing as before we

1217
00:46:03,100 --> 00:46:04,800
should have absolutely no difference now.

1218
00:46:04,900 --> 00:46:09,400
Oops, we need deleted the definition of the thing that pulls the

1219
00:46:09,400 --> 00:46:09,700
message.

1220
00:46:09,700 --> 00:46:10,500
That's no good.

1221
00:46:10,900 --> 00:46:14,800
Now, as we go in theory, everything is now exactly the same as it was

1222
00:46:14,800 --> 00:46:15,100
before.

1223
00:46:15,100 --> 00:46:18,600
But we are, we are now able to retain our bitmap as often as we want.

1224
00:46:18,600 --> 00:46:23,300
So, what we could do is we could say, x offset equals 0 and down here,

1225
00:46:23,600 --> 00:46:26,800
we can go ahead and say render weird gradient.

1226
00:46:28,500 --> 00:46:30,500
Right in our Loop.

1227
00:46:30,500 --> 00:46:33,300
So after we're done processing our message queue, we are started

1228
00:46:33,300 --> 00:46:35,900
turning to get behind the at which window there ladies and gentleman.

1229
00:46:35,900 --> 00:46:38,800
So I'm going to go ahead and switch back to this window here.

1230
00:46:38,800 --> 00:46:42,900
So so we are not obscured by the by the little picture of me talking

1231
00:46:42,900 --> 00:46:44,300
because who doesn't want to see me talking.

1232
00:46:44,300 --> 00:46:48,700
I am sure that it's everyone's favorite thing to do is to watch my

1233
00:46:49,000 --> 00:46:49,800
head.

1234
00:46:49,800 --> 00:46:51,200
Alright, here we go.

1235
00:46:51,900 --> 00:46:54,900
We are going to call render rid gradient with the X offset and the Y

1236
00:46:54,900 --> 00:46:55,600
offset.

1237
00:46:55,600 --> 00:46:58,100
And we are just not even going to bother initializing it in here.

1238
00:46:58,700 --> 00:47:02,200
Not at all, not going to do that because we don't actually care will

1239
00:47:02,200 --> 00:47:03,300
probably want to do in here.

1240
00:47:03,300 --> 00:47:07,100
I'll put it to do, probably want to clear this to Black, probably

1241
00:47:07,100 --> 00:47:10,200
clear, this to black, but we don't need to do that right now.

1242
00:47:10,200 --> 00:47:12,100
We're about that right now because we'll be thinking about those sorts

1243
00:47:12,100 --> 00:47:12,600
of things later.

1244
00:47:12,600 --> 00:47:14,600
And what we will do is every time through the loop.

1245
00:47:14,600 --> 00:47:17,300
We will take X offset and we will add 1 to it.

1246
00:47:17,300 --> 00:47:21,000
Just go ahead and commit that using the shorthand for plus 1.

1247
00:47:21,100 --> 00:47:21,400
Let's see.

1248
00:47:21,400 --> 00:47:22,400
What happens now.

1249
00:47:23,600 --> 00:47:24,700
Oops, that doesn't look good.

1250
00:47:24,900 --> 00:47:25,700
What's going on here?

1251
00:47:27,700 --> 00:47:31,400
Well, that was that was not what we wanted at.

1252
00:47:31,400 --> 00:47:31,900
All.

1253
00:47:32,100 --> 00:47:32,900
What happened?

1254
00:47:33,000 --> 00:47:33,800
Why did my render weird?

1255
00:47:34,100 --> 00:47:35,500
Oh, duh.

1256
00:47:35,600 --> 00:47:36,600
Well, there's one thing we.

1257
00:47:38,700 --> 00:47:39,000
Oh man.

1258
00:47:39,000 --> 00:47:39,900
I was little too excited there.

1259
00:47:39,900 --> 00:47:40,900
Forgot something obvious.

1260
00:47:41,000 --> 00:47:42,400
We need to still put it to the screen.

1261
00:47:42,400 --> 00:47:44,400
We'd actually update the window, right?

1262
00:47:44,400 --> 00:47:46,000
Because we were only updating the window inside.

1263
00:47:46,000 --> 00:47:47,000
WM paint.

1264
00:47:47,000 --> 00:47:49,100
Write this thing that actually does the strategy a bit.

1265
00:47:49,100 --> 00:47:50,100
I never called it.

1266
00:47:50,100 --> 00:47:51,900
So, of course, we're not going to see the results.

1267
00:47:51,900 --> 00:47:52,200
Sure.

1268
00:47:52,200 --> 00:47:55,300
We rendered to our bitmap but our bitmaps not on the screen.

1269
00:47:55,300 --> 00:47:56,700
We need to actually blit it to the screen.

1270
00:47:56,700 --> 00:47:57,300
So let's go ahead.

1271
00:47:57,400 --> 00:47:59,000
Head and have that blind to the screen.

1272
00:47:59,000 --> 00:47:59,900
Now, we're going to need the vice consul.

1273
00:48:00,000 --> 00:48:01,700
Next, we're going to need that window, rectangle.

1274
00:48:01,700 --> 00:48:05,600
And we are going to need the dimensions of the blit, which will

1275
00:48:05,600 --> 00:48:10,900
basically just be 00 and our window wrecked, our window width and

1276
00:48:10,900 --> 00:48:11,400
height.

1277
00:48:11,400 --> 00:48:13,600
So I'll go ahead and program those in there.

1278
00:48:14,500 --> 00:48:14,800
Sorry.

1279
00:48:14,800 --> 00:48:16,700
For the for the little hiccup there.

1280
00:48:16,700 --> 00:48:18,500
Ladies and gentlemen, I don't think that was a big one.

1281
00:48:18,500 --> 00:48:20,100
That was just a well.

1282
00:48:20,100 --> 00:48:22,700
I got a little excited and was hoping I could do a little less work

1283
00:48:23,000 --> 00:48:26,800
than what I actually had to do, but you know, no harm, no foul.

1284
00:48:26,800 --> 00:48:29,200
So window wreck at this point.

1285
00:48:29,300 --> 00:48:29,600
This is

1286
00:48:30,000 --> 00:48:30,100
Thing.

1287
00:48:30,100 --> 00:48:31,300
Now just I'm just calling this out.

1288
00:48:31,300 --> 00:48:33,500
I'm not doing it right now because we're just kind of messing with

1289
00:48:33,500 --> 00:48:34,200
things at this moment.

1290
00:48:34,200 --> 00:48:37,200
But you've seen me write this code a couple times with the.

1291
00:48:37,300 --> 00:48:39,200
In fact, I'm just going to actually cut and paste it from here.

1292
00:48:39,500 --> 00:48:41,000
You see me writing this code a couple times.

1293
00:48:41,000 --> 00:48:44,200
So right about now if this were actual code that I wasn't just kind of

1294
00:48:44,200 --> 00:48:47,200
fudging with and was going to rewrite in a second anyway, as we as we

1295
00:48:47,200 --> 00:48:49,200
start to clean things up, which is what we'll do tomorrow.

1296
00:48:49,800 --> 00:48:53,000
I would be pulling this out into a function and keeping the stuff.

1297
00:48:53,000 --> 00:48:55,500
I would actually have a function basically that does this because we

1298
00:48:55,500 --> 00:48:56,400
have done it enough times.

1299
00:48:56,400 --> 00:48:58,800
Now that it's clear, it's something we want to do and I don't want to

1300
00:48:58,800 --> 00:48:59,800
be cutting pasting it all over the

1301
00:49:00,000 --> 00:49:02,500
So I would definitely be doing that right about now, we're not going

1302
00:49:02,500 --> 00:49:04,600
to because I know that we're going to kind of fun, and we're going to

1303
00:49:04,600 --> 00:49:06,000
do something a little bit different.

1304
00:49:06,200 --> 00:49:10,800
But basically, you know, just just so, you're aware right about now is

1305
00:49:10,800 --> 00:49:12,200
when, that's why you sense will be tingling.

1306
00:49:12,400 --> 00:49:14,500
And so, if this were code, that we were going to keep it would it

1307
00:49:14,500 --> 00:49:16,200
would be a it would be pulled out.

1308
00:49:16,300 --> 00:49:18,800
So we're going to go ahead and get the device context of the window,

1309
00:49:18,800 --> 00:49:21,600
which again is something we need to draw and we are going to go ahead

1310
00:49:21,600 --> 00:49:22,600
and release that.

1311
00:49:22,600 --> 00:49:25,700
There's a kind of a getting release thing that has to happen here.

1312
00:49:27,200 --> 00:49:29,800
And by the way, for people who are into resource,

1313
00:49:29,900 --> 00:49:32,200
Acquisition is initialization, which remember I said, I don't like

1314
00:49:32,200 --> 00:49:32,800
very much.

1315
00:49:32,900 --> 00:49:34,600
They're a couple places where I would be okay with it.

1316
00:49:34,600 --> 00:49:35,600
I wouldn't fight you for it.

1317
00:49:35,700 --> 00:49:38,100
If you want to do something like this, and have a little thing that's

1318
00:49:38,100 --> 00:49:39,600
like a DC getter releaser.

1319
00:49:39,600 --> 00:49:41,500
Pair to make sure you don't forget the release.

1320
00:49:41,800 --> 00:49:44,500
If it's something that helps you out and you want to use Rai for that

1321
00:49:44,500 --> 00:49:46,500
you could pull this off into a class with a Constructor and do you

1322
00:49:46,500 --> 00:49:46,900
structure?

1323
00:49:47,100 --> 00:49:50,300
I would not get mad at you for that or disparage you at all.

1324
00:49:50,300 --> 00:49:51,100
It's totally fine.

1325
00:49:51,100 --> 00:49:52,500
Something, you kind of have to do some time.

1326
00:49:52,500 --> 00:49:56,000
So like I said, every programming thing has a place where you may use

1327
00:49:56,000 --> 00:49:56,300
it.

1328
00:49:56,400 --> 00:49:59,200
It's really the Dogma that gets you try not to get into the Dogma

1329
00:49:59,200 --> 00:49:59,800
because every

1330
00:50:00,000 --> 00:50:01,800
You practice probably has a you somewhere.

1331
00:50:01,900 --> 00:50:05,000
It's just usually not something you want to do all the time.

1332
00:50:05,000 --> 00:50:07,900
You need to know when to use things in a lot of times when people get

1333
00:50:07,900 --> 00:50:10,000
into something and they start to assign names to things and do those

1334
00:50:10,000 --> 00:50:10,400
art stuff.

1335
00:50:10,400 --> 00:50:13,300
They get carried away and carried away is almost always bad.

1336
00:50:15,500 --> 00:50:18,600
So for the raii people out there, throw you a bone.

1337
00:50:18,600 --> 00:50:19,300
It is true.

1338
00:50:19,500 --> 00:50:23,000
I would think that would be a perfectly fine thing for you to do.

1339
00:50:23,200 --> 00:50:23,500
Now.

1340
00:50:23,900 --> 00:50:25,300
We need to get the window handle.

1341
00:50:25,500 --> 00:50:26,400
So we have the window handle here.

1342
00:50:26,400 --> 00:50:29,300
I'm going to change this to window honestly, because I don't know why

1343
00:50:29,300 --> 00:50:31,400
I called it window handled again with we're not going to have anything

1344
00:50:31,400 --> 00:50:32,900
else that's called window.

1345
00:50:32,900 --> 00:50:34,200
So we're just going to go ahead and do that.

1346
00:50:34,500 --> 00:50:36,200
We have a client wrecked here.

1347
00:50:36,500 --> 00:50:37,500
So yes, I should call.

1348
00:50:37,500 --> 00:50:37,800
In fact.

1349
00:50:37,800 --> 00:50:38,800
I'm just going to replace that everywhere.

1350
00:50:38,800 --> 00:50:40,300
It really should have been client wrecked everywhere.

1351
00:50:40,300 --> 00:50:43,200
So we're going to change window wreck to client wreck.

1352
00:50:43,600 --> 00:50:45,100
We're going to go ahead and Loops change that.

1353
00:50:45,300 --> 00:50:48,200
So window wrecked, should be client wrecked.

1354
00:50:48,200 --> 00:50:54,800
There we go, just to be a little more concise and then we we actually

1355
00:50:54,800 --> 00:50:55,900
use it correctly there.

1356
00:50:55,900 --> 00:50:56,900
Get rid of that.

1357
00:50:58,000 --> 00:50:59,200
We actually have one.

1358
00:50:59,200 --> 00:50:59,900
It's not a

1359
00:51:00,000 --> 00:51:01,500
Are so we got to change those two dots.

1360
00:51:01,500 --> 00:51:04,900
The most useless thing you ever do in C and C++ and C compiler, should

1361
00:51:04,900 --> 00:51:06,700
just know John already fixed this.

1362
00:51:06,700 --> 00:51:07,900
In this language, I believe.

1363
00:51:08,100 --> 00:51:09,700
And then we need to pass a pointer to that.

1364
00:51:09,700 --> 00:51:14,000
So, cleaned up our compile errors and we should be good to go.

1365
00:51:14,000 --> 00:51:14,300
Now.

1366
00:51:14,300 --> 00:51:16,700
We are actually rendering the gradient and bleeding the gradient.

1367
00:51:16,700 --> 00:51:19,700
I'm hoping to see something on the screen now, but I don't know if we

1368
00:51:19,700 --> 00:51:20,400
actually will.

1369
00:51:20,600 --> 00:51:21,800
So let's take a look and see.

1370
00:51:21,800 --> 00:51:22,800
Is that animating it all?

1371
00:51:22,800 --> 00:51:25,000
Ladies and gentlemen, it does not appear to be.

1372
00:51:25,500 --> 00:51:26,600
Why are we sad?

1373
00:51:26,600 --> 00:51:27,900
Why are you sad Panda?

1374
00:51:27,900 --> 00:51:28,900
What's going on here?

1375
00:51:29,000 --> 00:51:29,800
I must have done something wrong.

1376
00:51:30,000 --> 00:51:33,000
Wrong, let's find out if we not bleeding properly or we not doing.

1377
00:51:33,000 --> 00:51:33,800
What are we not doing?

1378
00:51:34,900 --> 00:51:36,200
Do you do that stretch?

1379
00:51:36,200 --> 00:51:37,200
But I think is supposed to do it.

1380
00:51:37,200 --> 00:51:39,800
I don't know if I have to force it to repaint or not.

1381
00:51:39,800 --> 00:51:42,300
I'll double-check that in a second, but I'm pretty sure we are

1382
00:51:42,300 --> 00:51:43,000
changing up.

1383
00:51:43,500 --> 00:51:43,900
Awesome.

1384
00:51:45,500 --> 00:51:48,200
It is just a, you know, you get excited and you make a bunch of

1385
00:51:48,200 --> 00:51:48,500
mistakes.

1386
00:51:48,500 --> 00:51:51,500
So these are getting reset to zero every time what a surprise, gotta

1387
00:51:51,500 --> 00:51:52,500
put those outside the loop.

1388
00:51:52,500 --> 00:51:55,500
Casey, if you want them to keep increasing think that should be pretty

1389
00:51:55,500 --> 00:51:55,900
obvious.

1390
00:51:56,400 --> 00:51:56,900
There we go.

1391
00:51:56,900 --> 00:51:58,000
There is are animating.

1392
00:51:58,300 --> 00:51:59,800
So we are pretty much in shaped.

1393
00:52:00,000 --> 00:52:01,900
How to animate whatever we want.

1394
00:52:01,900 --> 00:52:05,700
Now what I would normally do at this point and in this is definitely

1395
00:52:05,700 --> 00:52:09,700
something that that is is high on the list of priorities for us to do

1396
00:52:10,000 --> 00:52:13,500
is to figure out how fast that stretch Blitz that stretch call is now

1397
00:52:13,500 --> 00:52:17,100
also, we should test this to make sure we can make it huge and we can,

1398
00:52:17,500 --> 00:52:18,800
we can also make a tiny.

1399
00:52:19,100 --> 00:52:19,800
There you go.

1400
00:52:20,200 --> 00:52:23,000
And now one of the things that I want to note, is basically goes a lot

1401
00:52:23,000 --> 00:52:24,500
faster when it's tiny than when it's large.

1402
00:52:24,500 --> 00:52:27,300
And that's because basically the cost of filling those pixels and

1403
00:52:27,300 --> 00:52:29,800
stuff like that, but the thing that I actually

1404
00:52:29,900 --> 00:52:35,100
want to test is how fast we can actually update the screen using the

1405
00:52:35,100 --> 00:52:37,800
sort of old-school way of updating that we're going to use so that we

1406
00:52:37,800 --> 00:52:39,100
can write the render ourselves.

1407
00:52:39,500 --> 00:52:41,400
But the problem is I can't really do that.

1408
00:52:41,400 --> 00:52:44,800
This speed is not representative of what it would actually be first of

1409
00:52:44,800 --> 00:52:47,100
all, because our gradient code is super crappy right now.

1410
00:52:47,100 --> 00:52:49,200
So that's going to slow things down a little but also just the

1411
00:52:49,200 --> 00:52:51,200
stretch, puts the stretch GI B call.

1412
00:52:51,700 --> 00:52:55,000
It is not a fair measure because open open broadcasting system or

1413
00:52:55,000 --> 00:52:55,400
whatever.

1414
00:52:55,400 --> 00:52:58,400
The OBS thing I'm using a stream right now because I have it set to

1415
00:52:58,400 --> 00:52:59,500
desktop capture.

1416
00:53:00,900 --> 00:53:03,300
Which is what I need to use in order to kind of go through here and

1417
00:53:03,500 --> 00:53:05,200
and show you all the stuff that I'm doing.

1418
00:53:05,900 --> 00:53:06,100
It.

1419
00:53:06,100 --> 00:53:08,600
Makes the machine have like a zero framerate.

1420
00:53:08,800 --> 00:53:10,300
Like basically anything I run.

1421
00:53:10,400 --> 00:53:11,800
It's just it's super slow.

1422
00:53:11,900 --> 00:53:13,800
So I can't actually figure out.

1423
00:53:13,800 --> 00:53:15,300
This might be running really fast right now.

1424
00:53:15,300 --> 00:53:17,700
For all I know and just is getting slowed down by OBS.

1425
00:53:18,100 --> 00:53:22,000
So basically what I have to do sometime very soon and I just haven't

1426
00:53:22,000 --> 00:53:24,400
quite had time to do the research to figure out what one to order is.

1427
00:53:24,400 --> 00:53:27,500
I need to order a video capture card so we can stop OBS from doing

1428
00:53:27,500 --> 00:53:30,500
that so we can actually profile the app on this machine.

1429
00:53:30,600 --> 00:53:33,100
And get somewhat reliable results because we're going to need to do

1430
00:53:33,100 --> 00:53:34,700
that for a lot of other reasons.

1431
00:53:34,700 --> 00:53:36,000
So that's homeless, the things to do.

1432
00:53:36,000 --> 00:53:39,700
But that is why we can't even tell how performant this technique is

1433
00:53:39,700 --> 00:53:40,100
even going to be.

1434
00:53:40,100 --> 00:53:42,500
In fact, you can see when I move the mouse, it slows it down, which

1435
00:53:42,500 --> 00:53:43,600
would never really happen.

1436
00:53:43,800 --> 00:53:46,500
If this was actually happening without OBS, but moving, the mouse

1437
00:53:46,500 --> 00:53:49,200
causes it to do some kind of thing in OBS and, and so on.

1438
00:53:49,200 --> 00:53:50,400
So that's a bit of a problem.

1439
00:53:50,600 --> 00:53:51,800
We are in good shape today.

1440
00:53:51,800 --> 00:53:52,400
People.

1441
00:53:52,400 --> 00:53:55,300
We have an animating window on the screen ladies and gentlemen, that

1442
00:53:55,300 --> 00:53:57,900
was less than three hours of programming including explanations

1443
00:53:57,900 --> 00:53:59,800
because Monday, we don't forget was

1444
00:54:00,100 --> 00:54:01,500
Setting up our Dev environment.

1445
00:54:01,500 --> 00:54:04,200
So three hours of fully explanatory programming, that's like, 20

1446
00:54:04,200 --> 00:54:04,500
minutes.

1447
00:54:04,500 --> 00:54:08,000
Probably of actual programming to get an animated window on the screen

1448
00:54:08,100 --> 00:54:12,700
using only our own code on win32, where we can now, write everything

1449
00:54:12,700 --> 00:54:13,400
we want.

1450
00:54:14,000 --> 00:54:14,400
I don't know.

1451
00:54:14,400 --> 00:54:15,600
People say it takes a lot of work.

1452
00:54:15,600 --> 00:54:16,800
Get something running on Windows.

1453
00:54:16,800 --> 00:54:17,900
I don't think that was a lot of work.

1454
00:54:17,900 --> 00:54:18,600
It's a lot of knowledge.

1455
00:54:18,600 --> 00:54:21,400
Yes, but once you have the knowledge, that's pretty quickly.

1456
00:54:21,400 --> 00:54:23,100
We are inside the five-minute warning.

1457
00:54:23,200 --> 00:54:26,600
So I'm going to do one more thing just to show you how this would work

1458
00:54:26,900 --> 00:54:29,200
writing, 32 bits is faster than running eight bits.

1459
00:54:29,200 --> 00:54:29,800
Ladies and gentlemen.

1460
00:54:30,000 --> 00:54:31,700
Although the compiler could probably do this for us.

1461
00:54:31,700 --> 00:54:35,800
Let's go ahead and change this to a 32-bit right instead of an 8-bit.

1462
00:54:35,800 --> 00:54:36,300
Right?

1463
00:54:36,300 --> 00:54:39,900
So we're going to change our pixel to be a 32-bit pointer, and we are

1464
00:54:39,900 --> 00:54:42,000
just going to go ahead and write to it once like that.

1465
00:54:42,000 --> 00:54:43,000
In a nice little shorthand.

1466
00:54:43,000 --> 00:54:43,600
We're going to write to it.

1467
00:54:43,600 --> 00:54:46,200
And then remember, this is the post increment operator, which means it

1468
00:54:46,200 --> 00:54:49,300
increments pixel after we have already used it dereference which gives

1469
00:54:49,300 --> 00:54:51,400
us the pixel that it actually was a little cleverness.

1470
00:54:51,400 --> 00:54:51,800
There.

1471
00:54:52,100 --> 00:54:52,800
It is true.

1472
00:54:52,900 --> 00:54:56,700
But then I'm going to go ahead and I am going to actually build this

1473
00:54:56,700 --> 00:54:57,300
out of B.

1474
00:54:57,400 --> 00:54:59,900
So we have three values that we

1475
00:55:00,000 --> 00:55:01,000
Actually wanted to use here.

1476
00:55:01,000 --> 00:55:03,100
There is our five minute warning.

1477
00:55:03,500 --> 00:55:05,600
We have the X Plus X offset.

1478
00:55:05,600 --> 00:55:08,800
We had the Y, plus y offset, and I guess we didn't actually have

1479
00:55:09,200 --> 00:55:10,500
another channel, right?

1480
00:55:10,500 --> 00:55:11,400
We didn't actually have another channel.

1481
00:55:11,400 --> 00:55:15,000
So we need to basically shift these values up and, or them together to

1482
00:55:15,000 --> 00:55:18,200
produce a single value that we can write out.

1483
00:55:18,300 --> 00:55:20,700
So what that's going to be is remember the farthest up.

1484
00:55:20,700 --> 00:55:24,100
The highest order is our pad, then we have 24, bits up.

1485
00:55:24,100 --> 00:55:26,500
Basically, those eight bits from 20.

1486
00:55:26,800 --> 00:55:29,800
Sorry, 16 bits up from 16 from bits.

1487
00:55:29,900 --> 00:55:31,000
16-bit 24.

1488
00:55:31,200 --> 00:55:35,000
That is our red Channel and we were leaving the red blank if I

1489
00:55:35,000 --> 00:55:35,600
remember correctly.

1490
00:55:35,600 --> 00:55:37,000
So we don't have to worry about that.

1491
00:55:37,000 --> 00:55:39,100
The green channel is bits 8 through 16.

1492
00:55:39,200 --> 00:55:42,900
So we're going to take that green Channel, which I believe was the Y

1493
00:55:42,900 --> 00:55:44,500
and I believe X was the blue, right?

1494
00:55:44,500 --> 00:55:47,800
We're going to take that green Channel and we are going to shift that

1495
00:55:47,800 --> 00:55:49,200
up by 8.

1496
00:55:49,200 --> 00:55:52,200
Then we are going to or it with the blue Channel which doesn't need to

1497
00:55:52,200 --> 00:55:52,900
be shifted up at all.

1498
00:55:52,900 --> 00:55:56,800
It just sits where it was and then we are going to call that are

1499
00:55:56,800 --> 00:55:58,600
32-bit value that whoops.

1500
00:55:58,600 --> 00:55:59,800
Well, in a way that Cassie still there.

1501
00:56:00,000 --> 00:56:00,500
That out of there.

1502
00:56:00,600 --> 00:56:01,600
Did not want that.

1503
00:56:01,900 --> 00:56:02,600
There we go.

1504
00:56:02,900 --> 00:56:08,500
We are going to call that done and see if we wrote out a 32-bit value.

1505
00:56:08,700 --> 00:56:11,000
Properly y offset is NOT capitalized.

1506
00:56:11,000 --> 00:56:11,700
Their poop.

1507
00:56:11,700 --> 00:56:13,800
Well, that was didn't mean to kill my buffer.

1508
00:56:14,400 --> 00:56:16,900
Well, you know, sometimes you accidentally hit okay, and that kills

1509
00:56:16,900 --> 00:56:17,400
the buffer.

1510
00:56:17,800 --> 00:56:19,600
So let's see if that reproduces it properly.

1511
00:56:19,600 --> 00:56:20,100
There it is.

1512
00:56:20,300 --> 00:56:23,000
So we've just changed to using a 32-bit, right?

1513
00:56:23,000 --> 00:56:25,100
And if you didn't catch what I did there, we still got four minutes

1514
00:56:25,100 --> 00:56:25,300
left.

1515
00:56:25,300 --> 00:56:27,400
So I'm going to go ahead and explain that in a little more detail.

1516
00:56:27,500 --> 00:56:29,800
Basically, what we want to do is we have

1517
00:56:29,900 --> 00:56:34,500
a thing, you know, that we wanted to write, we wanted to write out for

1518
00:56:34,500 --> 00:56:38,100
our pixel, which is 32 bits right in memory.

1519
00:56:38,300 --> 00:56:40,300
Here is the memory here is the register.

1520
00:56:40,500 --> 00:56:42,300
Okay, in memory, right?

1521
00:56:42,400 --> 00:56:44,900
We have blue comes first, then green.

1522
00:56:46,200 --> 00:56:47,800
Then red then pad.

1523
00:56:47,900 --> 00:56:50,400
So when I wrote that out when I did pixel, I wrote the blue pixel

1524
00:56:50,400 --> 00:56:50,800
first.

1525
00:56:50,800 --> 00:56:52,300
The they rotate bits of blue.

1526
00:56:52,400 --> 00:56:53,500
I rotate bits of G.

1527
00:56:53,600 --> 00:56:58,300
I wrote nothing to wrote 0, to 8, Bits of 0 to the RNA pits of 02 that

1528
00:56:58,300 --> 00:56:58,700
right.

1529
00:56:58,800 --> 00:56:59,800
So you saw me right blue.

1530
00:57:00,000 --> 00:57:02,800
In red, in the old one, but now in the register these things come in

1531
00:57:03,000 --> 00:57:06,400
and they get loaded and they get loaded flipped around, right?

1532
00:57:06,400 --> 00:57:08,900
Because of the little endian again, so, they're loaded like that.

1533
00:57:08,900 --> 00:57:12,500
So basically what that means is, if I want to find where I'm going to

1534
00:57:12,500 --> 00:57:14,900
put my blue, it just goes right in the bottom.

1535
00:57:14,900 --> 00:57:17,600
It's the bottom eight bits and then, I'm ordering that together again.

1536
00:57:17,600 --> 00:57:20,500
Ordering just Composites, two things together, if either of them are

1537
00:57:20,500 --> 00:57:21,900
set, then it sets it.

1538
00:57:22,000 --> 00:57:25,200
So I'm going to or those bits of blue with the bits of green but I

1539
00:57:25,200 --> 00:57:28,100
need to move them up to where they would be and they are 8 Bits up

1540
00:57:28,100 --> 00:57:29,500
right there after the blue.

1541
00:57:30,000 --> 00:57:34,000
So I shifted them up by 8 and then I ordered them together and output

1542
00:57:34,000 --> 00:57:34,600
in my pixel.

1543
00:57:34,600 --> 00:57:35,500
So, there we go.

1544
00:57:35,800 --> 00:57:38,000
That is that, and we are good to go.

1545
00:57:38,000 --> 00:57:40,500
That is the end of what I wanted to accomplish tonight.

1546
00:57:40,500 --> 00:57:42,800
I didn't even know if we get to animation, ladies gentlemen, but we

1547
00:57:42,800 --> 00:57:45,900
did and pretty much after we get input in here.

1548
00:57:46,300 --> 00:57:48,000
That means you can move the character around the screen.

1549
00:57:48,000 --> 00:57:51,200
If you really want to, we'll be seeing how to do all of that next

1550
00:57:51,200 --> 00:57:51,300
week.

1551
00:57:51,300 --> 00:57:52,000
Tomorrow.

1552
00:57:52,300 --> 00:57:55,400
What I want to do on the stream actually, is I want to go through and

1553
00:57:55,400 --> 00:57:57,100
really look at all this code.

1554
00:57:57,100 --> 00:57:58,300
I'm going to pull some things out.

1555
00:57:58,300 --> 00:57:59,700
Clean it up a little bit and discuss.

1556
00:58:00,000 --> 00:58:02,300
Each individual thing does show it to you in the debar groans more

1557
00:58:02,300 --> 00:58:03,800
detail just to kind of solidify things.

1558
00:58:03,800 --> 00:58:05,400
So probably, that's what we'll do most.

1559
00:58:05,400 --> 00:58:08,900
The time on Fridays is go through and do that solidifying work talk

1560
00:58:08,900 --> 00:58:11,500
about things that that were confusing people talk about other stuff

1561
00:58:11,500 --> 00:58:12,100
like that.

1562
00:58:12,200 --> 00:58:14,400
But that is a great stopping point for now.

1563
00:58:14,700 --> 00:58:16,700
So we've got two minutes until the Q&A starts.

1564
00:58:16,700 --> 00:58:21,000
I think I will drink the last of my almond milk and then we will go to

1565
00:58:21,000 --> 00:58:21,600
the questions.

1566
00:58:25,100 --> 00:58:26,000
So good, isn't it?

1567
00:58:32,000 --> 00:58:34,000
You know, I like almonds too, but I don't really like him that much.

1568
00:58:34,000 --> 00:58:36,400
So it's interesting that I love almond milk so much.

1569
00:58:36,400 --> 00:58:37,300
It's kind of confusing.

1570
00:58:38,000 --> 00:58:41,000
Alright, let's go ahead and take questions because I think that's all

1571
00:58:41,000 --> 00:58:41,800
I wanted accomplish today.

1572
00:58:41,800 --> 00:58:44,400
Certainly not gonna start something new and I can't think of anything

1573
00:58:44,400 --> 00:58:45,700
that we really wanted to fix.

1574
00:58:45,800 --> 00:58:46,500
Let me go ahead.

1575
00:58:46,500 --> 00:58:50,500
And I guess, one thing I can do is verify that we did not leak any

1576
00:58:50,500 --> 00:58:53,900
handles with Windows, or do anything, untoward in that sense.

1577
00:58:54,300 --> 00:58:55,500
Let me see here.

1578
00:58:56,400 --> 00:58:59,200
I will go ahead and bring up the task manager.

1579
00:59:00,800 --> 00:59:03,400
Or try to anyway, there it is.

1580
00:59:04,100 --> 00:59:04,500
Mr.

1581
00:59:04,500 --> 00:59:05,200
Task manager.

1582
00:59:05,200 --> 00:59:05,600
Please.

1583
00:59:05,600 --> 00:59:09,800
Tell me if my handmade Hero has caused problems.

1584
00:59:10,800 --> 00:59:12,100
Where is when 3D or handmade?

1585
00:59:12,100 --> 00:59:12,800
There it is.

1586
00:59:13,100 --> 00:59:14,700
So there is win32, handmade.

1587
00:59:14,700 --> 00:59:20,200
Ladies and gentlemen, it is using about 10 megabytes of memory, which

1588
00:59:20,200 --> 00:59:22,300
is pretty much all the stuff that Windows allocated.

1589
00:59:22,300 --> 00:59:26,900
I guess, since we didn't do any of that and do, do, do, do do, and

1590
00:59:26,900 --> 00:59:28,400
that is staying nice and stable.

1591
00:59:28,400 --> 00:59:29,100
It's just freeing.

1592
00:59:29,100 --> 00:59:30,400
And reallocating that virtual.

1593
00:59:30,600 --> 00:59:33,100
Look, which is totally fine.

1594
00:59:33,600 --> 00:59:35,200
So that is good.

1595
00:59:35,200 --> 00:59:36,200
No problems there.

1596
00:59:36,400 --> 00:59:39,800
And we will have more sophisticated ways of keeping ourselves from

1597
00:59:39,900 --> 00:59:40,900
doing anything untoward.

1598
00:59:40,900 --> 00:59:41,300
Oh man.

1599
00:59:41,300 --> 00:59:42,200
Look at OBS.

1600
00:59:42,400 --> 00:59:43,300
What is going on?

1601
00:59:43,800 --> 00:59:44,300
Oh man.

1602
00:59:44,900 --> 00:59:45,500
Whoa!

1603
00:59:45,900 --> 00:59:46,900
OBS is not cool.

1604
00:59:46,900 --> 00:59:48,100
I really gotta get that capturecard.

1605
00:59:48,100 --> 00:59:51,300
Ladies and gentlemen, I got to order that because this is not good.

1606
00:59:52,200 --> 00:59:54,000
Oh my gosh, what is happening?

1607
00:59:54,200 --> 00:59:56,800
Everything is going, everything is going haywire on my machine.

1608
00:59:56,800 --> 00:59:58,000
I don't know if you can see this right now.

1609
00:59:58,000 --> 00:59:59,800
I don't know what you're actually seeing on the screen, but

1610
01:00:00,000 --> 01:00:01,300
It is a bit of a disaster.

1611
01:00:01,300 --> 01:00:03,700
Ladies and gentlemen, all of my windows have gone away.

1612
01:00:05,100 --> 01:00:09,500
Oh my Lord, OBS, poor OBS.

1613
01:00:09,900 --> 01:00:11,700
Trying to capture all the windows.

1614
01:00:11,900 --> 01:00:12,700
It is the pop-up.

1615
01:00:12,700 --> 01:00:15,000
I believe that is it is ruining things.

1616
01:00:16,400 --> 01:00:19,600
Maybe we will have to end the stream and restart it.

1617
01:00:19,600 --> 01:00:22,600
I don't know if it's going to be able to to come back from this.

1618
01:00:23,300 --> 01:00:24,400
Yes, the Q&A begins.

1619
01:00:24,400 --> 01:00:27,700
Now, thank you for showing us that unfortunately, you have destroyed

1620
01:00:27,700 --> 01:00:29,800
the entire desktop in the process.

1621
01:00:30,000 --> 01:00:31,700
Us poor OBS.

1622
01:00:31,900 --> 01:00:32,500
I feel for you.

1623
01:00:32,500 --> 01:00:33,100
I really do.

1624
01:00:33,100 --> 01:00:34,600
I know Windows wasn't set up for this.

1625
01:00:35,300 --> 01:00:35,600
Come on.

1626
01:00:35,600 --> 01:00:35,900
Can we?

1627
01:00:35,900 --> 01:00:36,700
Can we just kill?

1628
01:00:36,700 --> 01:00:37,500
Can we kill our app?

1629
01:00:37,500 --> 01:00:41,200
Maybe kill our app, please get things back to normal.

1630
01:00:41,500 --> 01:00:42,300
Do something.

1631
01:00:42,400 --> 01:00:43,400
Somebody save us.

1632
01:00:44,900 --> 01:00:48,300
Yeah, this is not really OBS as fault.

1633
01:00:48,300 --> 01:00:50,100
Ladies and gentlemen, this is just what happens.

1634
01:00:50,200 --> 01:00:53,200
I think, when you are trying to stream a bunch of stuff on Windows 7,

1635
01:00:53,200 --> 01:00:55,700
which I don't think has a good way for OBS to really capture the

1636
01:00:55,700 --> 01:00:56,500
desktop.

1637
01:00:56,800 --> 01:00:57,800
Come on, stop our app.

1638
01:00:57,800 --> 01:00:58,700
Stop our app.

1639
01:00:58,900 --> 01:01:00,900
Stop the app, please.

1640
01:01:01,300 --> 01:01:02,100
Please.

1641
01:01:03,300 --> 01:01:04,200
There we go.

1642
01:01:04,300 --> 01:01:04,700
That work.

1643
01:01:04,700 --> 01:01:05,700
No, it didn't work.

1644
01:01:06,900 --> 01:01:07,200
Oh.

1645
01:01:08,400 --> 01:01:10,400
Well, I'll just go to the questions and hopefully we can answer some

1646
01:01:10,400 --> 01:01:13,600
questions that don't actually require this because apparently we are

1647
01:01:13,600 --> 01:01:16,000
not going to get our desktop back anytime soon.

1648
01:01:17,000 --> 01:01:21,600
Let's take a look at the actual questions and see if we can get

1649
01:01:21,600 --> 01:01:22,200
anywhere.

1650
01:01:23,300 --> 01:01:26,300
Well, this thing is trying to figure out how to get out of its own

1651
01:01:26,300 --> 01:01:26,800
way.

1652
01:01:27,500 --> 01:01:28,200
Oh, there it is.

1653
01:01:28,300 --> 01:01:28,900
We're back.

1654
01:01:29,400 --> 01:01:31,900
Hey, well, alright.

1655
01:01:31,900 --> 01:01:34,400
Well, that's just push the capture card up to a very, very high

1656
01:01:34,400 --> 01:01:35,300
priority for me.

1657
01:01:35,300 --> 01:01:37,800
Ladies and gentlemen, one of the things you should do, if you are an

1658
01:01:37,800 --> 01:01:40,100
expert on streaming and I mean a real expert and you know, some

1659
01:01:40,100 --> 01:01:45,300
things, please send me an email using the handmade hero email address.

1660
01:01:45,300 --> 01:01:46,600
If you could go to handmade hero Dot,

1661
01:01:47,600 --> 01:01:50,600
Whenever you would like to do, so, go to handmade here.com and

1662
01:01:50,600 --> 01:01:51,600
emailing a question.

1663
01:01:51,800 --> 01:01:52,600
And instead of a question.

1664
01:01:52,600 --> 01:01:55,700
Tell me what capture card I should get because that is the only thing

1665
01:01:55,700 --> 01:01:56,800
holding me up right now.

1666
01:01:56,900 --> 01:01:59,100
Thanks to the generosity of people who have pre-ordered.

1667
01:01:59,100 --> 01:01:59,500
The stream.

1668
01:01:59,500 --> 01:02:03,400
There is money in the count for handmade hero that I can use to buy a

1669
01:02:03,400 --> 01:02:04,800
card and I will do so.

1670
01:02:05,600 --> 01:02:06,500
So, all right.

1671
01:02:07,700 --> 01:02:09,000
Let's go.

1672
01:02:09,500 --> 01:02:10,500
Q&A session.

1673
01:02:10,700 --> 01:02:13,400
Is there a reason you prefer using zero instead of null?

1674
01:02:13,400 --> 01:02:14,200
Yes.

1675
01:02:14,900 --> 01:02:15,700
I find that.

1676
01:02:15,700 --> 01:02:17,400
I like less defines.

1677
01:02:18,000 --> 01:02:19,400
The less defines the better.

1678
01:02:21,400 --> 01:02:24,400
So, since 0 always is what null is on.

1679
01:02:24,400 --> 01:02:27,100
Every platform that I ever program on in modern times.

1680
01:02:27,100 --> 01:02:28,200
I just go ahead and use zero.

1681
01:02:28,200 --> 01:02:30,100
There used to be times when that was not true.

1682
01:02:30,100 --> 01:02:33,300
I think potentially or other things like this or I don't know.

1683
01:02:33,300 --> 01:02:34,500
In fact, Sean.

1684
01:02:34,500 --> 01:02:35,600
Barrett is still on.

1685
01:02:35,600 --> 01:02:38,600
I don't know, I think he is right now running a procedural Opera

1686
01:02:38,600 --> 01:02:41,900
generator, but he is the kind of person who likes know and knows those

1687
01:02:41,900 --> 01:02:42,600
sorts of things.

1688
01:02:42,700 --> 01:02:45,400
So he may have a good reason why you might occasionally want to use.

1689
01:02:45,400 --> 01:02:47,200
No, but I do not

1690
01:02:52,400 --> 01:02:55,100
I would love to learn how to script but I just don't get it.

1691
01:02:55,100 --> 01:02:56,200
Can, maybe you help?

1692
01:02:56,400 --> 01:02:56,900
No.

1693
01:02:56,900 --> 01:02:58,100
I don't know anything about scripting.

1694
01:02:58,100 --> 01:02:59,300
I don't really write any Scripts.

1695
01:03:03,600 --> 01:03:04,600
Clips to the rectangle.

1696
01:03:04,600 --> 01:03:09,200
Anyway, so I don't know what that means standard in t.

1697
01:03:10,000 --> 01:03:11,400
Yes, standard in s Silvan.

1698
01:03:11,400 --> 01:03:13,700
That is what we use to just took me a while to find it.

1699
01:03:15,700 --> 01:03:17,600
See, maybe I'm reading too far back here.

1700
01:03:19,700 --> 01:03:22,800
How come you don't like pound to find but typedef all of the student?

1701
01:03:22,800 --> 01:03:24,100
Oh, I like, I like pound to find.

1702
01:03:24,600 --> 01:03:25,300
I'm sorry.

1703
01:03:25,300 --> 01:03:25,800
I didn't mean to.

1704
01:03:26,100 --> 01:03:27,100
I didn't mean to give you the impression.

1705
01:03:27,100 --> 01:03:30,100
I don't like pound to find what I meant is I just like to not Define

1706
01:03:30,100 --> 01:03:35,400
things if they already exist, but the reason that I do, the reason

1707
01:03:35,400 --> 01:03:37,100
that I do the standard type thing.

1708
01:03:39,000 --> 01:03:41,000
Oh, my alt-tab doesn't even work anymore.

1709
01:03:41,500 --> 01:03:42,600
That's pretty awesome.

1710
01:03:43,000 --> 01:03:43,300
All right.

1711
01:03:43,300 --> 01:03:44,200
Let me see if I can.

1712
01:03:45,500 --> 01:03:46,000
There we go.

1713
01:03:46,800 --> 01:03:47,300
Okay.

1714
01:03:48,200 --> 01:03:48,700
Wow.

1715
01:03:48,800 --> 01:03:51,800
All right, ladies and gentlemen, I really need that capture card.

1716
01:03:51,900 --> 01:03:52,700
This can't happen again.

1717
01:03:52,700 --> 01:03:53,200
All right.

1718
01:03:53,300 --> 01:03:57,300
The reason that I did this is basically that in the old days, these

1719
01:03:57,300 --> 01:03:58,400
types didn't exist.

1720
01:03:58,700 --> 01:03:59,800
This is brand-new.

1721
01:03:59,900 --> 01:04:03,300
So I got in the habit of always using my own types because previously,

1722
01:04:03,300 --> 01:04:06,300
you actually needed to Define them all because you might be on

1723
01:04:06,300 --> 01:04:08,200
platforms where you needed to switch this.

1724
01:04:08,200 --> 01:04:12,900
So you might do something like, you know, if on 16-bit architecture,

1725
01:04:13,000 --> 01:04:14,500
you know, and then there was

1726
01:04:15,500 --> 01:04:18,800
In fact, this was this sort of thing would happen a lot, right?

1727
01:04:19,100 --> 01:04:20,300
You see something like this.

1728
01:04:26,800 --> 01:04:27,400
Make sense.

1729
01:04:28,200 --> 01:04:29,300
You have to do stuff like this.

1730
01:04:29,500 --> 01:04:32,400
So you always wanted to use this because you actually had to change

1731
01:04:32,400 --> 01:04:33,100
which type you're using.

1732
01:04:33,100 --> 01:04:34,600
So these are not Superfluous.

1733
01:04:34,800 --> 01:04:37,100
These are actually there because you have to use them and that's why I

1734
01:04:37,100 --> 01:04:37,900
still do it.

1735
01:04:38,400 --> 01:04:41,100
You could I be, you know, like I said, if you're starting your coding

1736
01:04:41,100 --> 01:04:44,100
practices, now, I might just say stick with the underscore T types

1737
01:04:44,100 --> 01:04:46,400
because they are what you want and there's no sense in redefining

1738
01:04:46,400 --> 01:04:46,700
them.

1739
01:04:46,800 --> 01:04:49,500
But the other thing that's true is I would argue that this isn't

1740
01:04:49,500 --> 01:04:51,900
really all that much of a savings anyway, because you still have to

1741
01:04:51,900 --> 01:04:52,700
include standard, ioh.

1742
01:04:52,700 --> 01:04:54,900
I wish they were just built in the language, which maybe they are in

1743
01:04:54,900 --> 01:04:56,400
some part of the spec that I do.

1744
01:05:00,200 --> 01:05:00,800
Senior Tori.

1745
01:05:00,800 --> 01:05:01,600
What would happen if you call.

1746
01:05:01,600 --> 01:05:05,100
Malachi said a virtual Alec, you would basically go through a crap ton

1747
01:05:05,200 --> 01:05:08,000
of C runtime Library code and then you would call keep Alec, which

1748
01:05:08,000 --> 01:05:09,300
eventually would call virtual lock.

1749
01:05:10,100 --> 01:05:12,600
So basically, you are just going through a lot of unnecessary code to

1750
01:05:12,600 --> 01:05:13,200
get the memory.

1751
01:05:13,500 --> 01:05:18,400
Everyone has to basically allocate memory as Pages down at the lower

1752
01:05:18,400 --> 01:05:18,900
level.

1753
01:05:19,600 --> 01:05:22,700
So really we're just going to allocate a bunch of pages with virtual

1754
01:05:22,700 --> 01:05:24,700
Alec and we're going to do all of our memory manager out of that

1755
01:05:24,700 --> 01:05:26,600
instead of calling the C runtime Library.

1756
01:05:27,000 --> 01:05:29,800
To avoid bothering, using whatever it is that they're doing, which is

1757
01:05:29,800 --> 01:05:31,400
just unnecessary stuff, basically.

1758
01:05:34,000 --> 01:05:35,900
What's their speed Malik new and he palak?

1759
01:05:35,900 --> 01:05:36,800
Not much.

1760
01:05:37,100 --> 01:05:39,900
I believe he palak is keep out because basically the system's

1761
01:05:39,900 --> 01:05:43,300
allocator that allocates from the Heap and Malik and new are the C

1762
01:05:43,300 --> 01:05:46,600
runtime, libraries way of allocating from that same Heap.

1763
01:05:46,700 --> 01:05:47,700
And so I believe all that.

1764
01:05:47,700 --> 01:05:50,200
Malkin new do is they basically introduced another level of

1765
01:05:50,200 --> 01:05:55,500
indirection, which I think is usually designed to optimize small

1766
01:05:55,500 --> 01:05:58,700
allocations and like large numbers of allocations.

1767
01:05:58,800 --> 01:05:59,800
Whereas he palak,

1768
01:06:00,000 --> 01:06:03,600
Since it's a system call, can't do a really fast return to you.

1769
01:06:03,600 --> 01:06:04,400
Potentially.

1770
01:06:04,600 --> 01:06:05,600
I don't really know.

1771
01:06:05,700 --> 01:06:07,200
I don't use those calls.

1772
01:06:07,200 --> 01:06:11,000
So I'm not really in a position to speak about what they actually do.

1773
01:06:11,000 --> 01:06:14,600
But if you want to know, you can probably step into mallik and just

1774
01:06:14,600 --> 01:06:15,200
look at the code.

1775
01:06:15,200 --> 01:06:17,200
Like we were doing the other day where you just call malloc and hit

1776
01:06:17,200 --> 01:06:18,400
f11 when you get to that line.

1777
01:06:18,400 --> 01:06:19,400
You can watch what it does.

1778
01:06:29,300 --> 01:06:30,300
I went really fast today.

1779
01:06:30,300 --> 01:06:32,900
Do you think you could go as slow as you did previously days in the

1780
01:06:32,900 --> 01:06:33,500
future?

1781
01:06:33,700 --> 01:06:36,400
Probably not will probably have to go relatively fast.

1782
01:06:36,600 --> 01:06:39,700
But what we'll do on Fridays is what kind of do our slow day on

1783
01:06:39,700 --> 01:06:41,900
Friday, where we go through all the code that we wrote over the week

1784
01:06:41,900 --> 01:06:43,300
and kind of dive into it more detail.

1785
01:06:43,300 --> 01:06:46,000
So what I would say is come back tomorrow and take a look there and

1786
01:06:46,000 --> 01:06:48,600
see if that clears it up for you, but no we can't go too slowly

1787
01:06:49,800 --> 01:06:52,900
because otherwise we would really never get anything done.

1788
01:06:53,100 --> 01:06:55,900
So we kind of have to go and say, well, alright you can go back and

1789
01:06:55,900 --> 01:06:57,000
watch the stream again.

1790
01:06:57,600 --> 01:06:58,500
Look at individual things.

1791
01:06:58,500 --> 01:06:58,900
You can ask

1792
01:06:59,100 --> 01:07:01,600
Questions and then drill down and it, but you're going to kind of have

1793
01:07:01,600 --> 01:07:02,500
to meet me halfway there.

1794
01:07:02,500 --> 01:07:04,000
If we ever want to actually make any progress.

1795
01:07:04,000 --> 01:07:05,000
I have to go fast.

1796
01:07:05,300 --> 01:07:08,300
Say everything that's happening as I go, but you may not understand it

1797
01:07:08,300 --> 01:07:08,700
all.

1798
01:07:08,800 --> 01:07:10,900
And then you'll have to kind of go back to the stream.

1799
01:07:11,300 --> 01:07:13,700
Think about it, go back and correlate with like the intro to see

1800
01:07:13,700 --> 01:07:14,300
course or things.

1801
01:07:14,300 --> 01:07:16,600
We've said earlier, when you don't understand something, you'll have

1802
01:07:16,600 --> 01:07:17,500
to ask me questions.

1803
01:07:17,500 --> 01:07:19,000
Or ask the community questions.

1804
01:07:19,300 --> 01:07:21,400
We're looking right now, try and set up a forum for that.

1805
01:07:21,400 --> 01:07:23,500
But that'll kind of be the way that it has to happen, because

1806
01:07:23,500 --> 01:07:25,000
otherwise, we'll never going to get a game done.

1807
01:07:28,200 --> 01:07:31,100
Are we going to use Val grind later on possibly?

1808
01:07:31,100 --> 01:07:33,100
But we may just use our own homegrown stuff.

1809
01:07:33,500 --> 01:07:36,000
Since we may not need something as heavy weight as valgrind.

1810
01:07:41,100 --> 01:07:42,700
Let's see.

1811
01:07:44,700 --> 01:07:46,100
Is the product going to take two years?

1812
01:07:46,100 --> 01:07:47,500
Are you planning on streaming for two years?

1813
01:07:47,500 --> 01:07:49,800
Yeah, we probably will be streaming for like two years.

1814
01:07:54,400 --> 01:07:55,200
What about null pointer?

1815
01:07:55,200 --> 01:07:56,200
I've never used null pointer.

1816
01:07:56,200 --> 01:07:58,700
So I don't have any thing to say about that.

1817
01:08:01,400 --> 01:08:02,700
Let's see.

1818
01:08:06,200 --> 01:08:07,100
Sorry, I'm still sick.

1819
01:08:07,100 --> 01:08:08,000
I'm sorry about the coughing.

1820
01:08:08,200 --> 01:08:10,000
Really need a cough drop, but there in the other room.

1821
01:08:11,800 --> 01:08:14,600
Can you explain what why we are using the user through you to live in

1822
01:08:14,600 --> 01:08:16,200
the GTI, 32 live in the build-up.

1823
01:08:16,200 --> 01:08:18,000
That I already explained that please go.

1824
01:08:18,000 --> 01:08:18,800
Look at the other stream.

1825
01:08:18,800 --> 01:08:19,800
Basically, what happened was?

1826
01:08:20,100 --> 01:08:23,399
We need those because those are the import libraries that tell Windows

1827
01:08:23,800 --> 01:08:28,100
where we, where to get things, like, stretch TI B, which is in GDI,

1828
01:08:28,100 --> 01:08:28,700
32.

1829
01:08:28,700 --> 01:08:32,500
Lib, so that is, that is basically the way that we get our, we import

1830
01:08:32,500 --> 01:08:33,399
our function calls to Windows.

1831
01:08:33,399 --> 01:08:35,700
I talked about that in the Stream will talk about that later.

1832
01:08:35,700 --> 01:08:38,399
When we when we probably, when we get rid of windows on each,

1833
01:08:44,899 --> 01:08:46,899
With there, be a significant performance increase if you allocate the

1834
01:08:46,899 --> 01:08:51,200
memory for the bitmap on the stack instead of the Heap well

1835
01:08:52,800 --> 01:08:54,000
performance increase.

1836
01:08:54,899 --> 01:08:57,800
So first of all, there's no performance increase just because you

1837
01:08:57,800 --> 01:08:59,899
allocate memory in one place rather than another

1838
01:09:00,000 --> 01:09:02,399
Only reason there would be a performance increases if that memory was

1839
01:09:02,399 --> 01:09:04,600
already hot for some reason, like it was already in the cache.

1840
01:09:04,800 --> 01:09:05,700
But memory is memory.

1841
01:09:05,700 --> 01:09:09,100
So only matters, whether that memory was touched recently whether or

1842
01:09:09,100 --> 01:09:12,500
not it's for some reason going to be more efficient.

1843
01:09:12,500 --> 01:09:15,899
So, so I don't think the question really makes a whole lot of sense in

1844
01:09:15,899 --> 01:09:17,000
that in that way.

1845
01:09:17,000 --> 01:09:20,300
But the more important thing is, we can't allocated on the stack

1846
01:09:20,300 --> 01:09:23,200
because anything that we allocate on the stack will go away after we

1847
01:09:23,200 --> 01:09:25,500
return from that function, right?

1848
01:09:25,500 --> 01:09:28,899
So when we come in to like win, 30 32 resized image section.

1849
01:09:28,899 --> 01:09:29,800
The stack is

1850
01:09:30,000 --> 01:09:31,700
At a certain Watermark, right?

1851
01:09:31,700 --> 01:09:35,300
All of the local variables, like bitmap memory size, right?

1852
01:09:35,300 --> 01:09:37,700
Get pushed onto that stack and our parameters, width and height there

1853
01:09:37,700 --> 01:09:38,399
on the stack.

1854
01:09:38,899 --> 01:09:42,399
But then as soon as we exit that's those get the stack goes back above

1855
01:09:42,399 --> 01:09:44,300
it, and that stuff is used for other things.

1856
01:09:44,399 --> 01:09:46,600
So if we were to allocate this on the stack, as soon as we returned it

1857
01:09:46,600 --> 01:09:49,399
would go away and then we don't have a bitmap anymore.

1858
01:09:49,700 --> 01:09:50,200
Right?

1859
01:09:50,399 --> 01:09:53,600
It's in memory that will get reused as we kind of move move through

1860
01:09:53,600 --> 01:09:53,800
there.

1861
01:09:53,800 --> 01:09:56,700
So you cannot allocate stuff on the stack that needs to be permanent.

1862
01:09:56,700 --> 01:09:59,600
The whole point of allocation is to allocate things that work across

1863
01:10:00,000 --> 01:10:04,100
Multiple functions like that across different Stacks, across different

1864
01:10:04,100 --> 01:10:04,800
levels of the stack.

1865
01:10:07,300 --> 01:10:08,600
Did I restart the stream for Q&A?

1866
01:10:08,600 --> 01:10:10,100
No, we are no longer doing that.

1867
01:10:10,100 --> 01:10:11,500
We're just doing one from now on.

1868
01:10:15,500 --> 01:10:17,000
Let's see.

1869
01:10:26,700 --> 01:10:28,300
I am scanning for questions.

1870
01:10:28,400 --> 01:10:29,900
Do you know what the page?

1871
01:10:29,900 --> 01:10:30,600
Right copy men.

1872
01:10:30,600 --> 01:10:31,800
Protect flag does.

1873
01:10:32,400 --> 01:10:33,400
Yes, I do.

1874
01:10:36,800 --> 01:10:37,200
Well.

1875
01:10:38,800 --> 01:10:41,500
That is one of those fun questions to answer on the Q&A.

1876
01:10:41,800 --> 01:10:46,200
So basically in I'm going to give you what I believe is the

1877
01:10:46,200 --> 01:10:49,500
hypothetical reason for it and you will have to go try to check this

1878
01:10:49,500 --> 01:10:51,600
perhaps on the interwebs or maybe as Silvan can.

1879
01:10:51,600 --> 01:10:53,400
Tell us somebody else for Microsoft.

1880
01:10:53,400 --> 01:10:57,300
Could maybe tell us but basically the reason that you have right copy

1881
01:10:57,300 --> 01:11:01,500
as a thing, which is basically what right copy is is it means we're

1882
01:11:01,500 --> 01:11:02,600
going to take a piece of memory.

1883
01:11:03,500 --> 01:11:09,200
And we're going to make that memory be essentially the same as another

1884
01:11:09,200 --> 01:11:09,900
piece of memory.

1885
01:11:09,900 --> 01:11:12,600
So we're going to put some data in it and we're going to have that

1886
01:11:12,600 --> 01:11:14,600
memory sort of mirror.

1887
01:11:14,600 --> 01:11:15,400
Whatever is in there.

1888
01:11:15,900 --> 01:11:19,300
But we want to do is when you touch the page when you actually go to

1889
01:11:19,300 --> 01:11:20,600
write something to that page.

1890
01:11:20,900 --> 01:11:24,200
We want to instead of actually writing to the memory underneath it.

1891
01:11:24,200 --> 01:11:28,300
We want to silently, move it to a new place in memory, a new, a new

1892
01:11:28,300 --> 01:11:31,000
page, and write to that instead.

1893
01:11:31,100 --> 01:11:33,100
And I believe that is the flag that your ass.

1894
01:11:33,300 --> 01:11:33,800
Going about.

1895
01:11:33,800 --> 01:11:35,300
Let me double-check to make sure.

1896
01:11:35,300 --> 01:11:37,700
I don't give you a completely bogus explanation here.

1897
01:11:38,300 --> 01:11:41,400
But, you know, I'm pretty sure I'm thinking of the right thing when

1898
01:11:41,400 --> 01:11:42,000
you say that.

1899
01:11:42,500 --> 01:11:45,200
So, let's go ahead and take a look here.

1900
01:11:45,500 --> 01:11:46,600
I need this to be a little.

1901
01:11:46,600 --> 01:11:47,100
Oops.

1902
01:11:48,500 --> 01:11:50,000
Didn't mean to grab my emacs window.

1903
01:11:50,000 --> 01:11:50,800
Get back over there.

1904
01:11:51,400 --> 01:11:53,500
I need this to be a little bit wider.

1905
01:11:53,500 --> 01:11:54,400
So it's no scrollbar.

1906
01:11:54,400 --> 01:11:54,600
Okay.

1907
01:11:54,600 --> 01:11:55,100
There we go.

1908
01:11:56,200 --> 01:11:58,700
So, I'm going to go over there and look at the memory protection

1909
01:11:58,700 --> 01:11:59,800
constants, and you said, right?

1910
01:12:00,000 --> 01:12:03,300
Be enables exit read-only and copy on write access to a map value and

1911
01:12:03,300 --> 01:12:06,100
attempt to write to a committed copy-on-write page results in a

1912
01:12:06,100 --> 01:12:08,300
private copy of the page being made for the process yet.

1913
01:12:08,800 --> 01:12:12,300
So so basically, the reason that this is in there and again, this is

1914
01:12:12,300 --> 01:12:14,700
just me hypothesizing, but I'm just going to tell you why I think it's

1915
01:12:14,700 --> 01:12:14,900
in there.

1916
01:12:14,900 --> 01:12:18,300
And someone from Microsoft and confirm this, it's basically in Unix.

1917
01:12:18,500 --> 01:12:19,900
There is a thing called fork.

1918
01:12:20,400 --> 01:12:23,900
And what Fork does is it basically says, I have a running executable.

1919
01:12:23,900 --> 01:12:28,400
I want to make a second copy of that running executable, right, but I

1920
01:12:28,400 --> 01:12:29,900
want the second copy to

1921
01:12:30,000 --> 01:12:33,700
Be able to have it's completely to basically they I want to be able to

1922
01:12:33,700 --> 01:12:34,400
then diverge.

1923
01:12:34,400 --> 01:12:38,100
So any of the things that this guy does to the processes memory after

1924
01:12:38,100 --> 01:12:41,100
the fork and anything that this guy does happen separately.

1925
01:12:41,200 --> 01:12:43,700
So it's sort of like just cloning the process entirely.

1926
01:12:43,900 --> 01:12:46,500
And as far as they are each concerned, they now are completely

1927
01:12:46,500 --> 01:12:47,400
separate copies.

1928
01:12:47,500 --> 01:12:50,500
So, if this guy changes memory, it's not seen by this guy.

1929
01:12:50,500 --> 01:12:52,100
And if this guy changed memory, it's not seen by this guy.

1930
01:12:52,100 --> 01:12:55,000
They're completely separate but cloned, right?

1931
01:12:55,100 --> 01:12:58,700
It's just like a cloning machine in order to do this efficiently and

1932
01:12:58,700 --> 01:12:59,800
that was a very important thing on.

1933
01:13:00,000 --> 01:13:00,500
It's for a while.

1934
01:13:00,500 --> 01:13:01,400
It's not so important anymore.

1935
01:13:01,400 --> 01:13:01,900
I don't think.

1936
01:13:01,900 --> 01:13:05,100
But basically that was the main way that you got multi-processing in

1937
01:13:05,100 --> 01:13:05,500
Unix.

1938
01:13:06,000 --> 01:13:08,800
The way that that's implemented is basically processor started

1939
01:13:08,800 --> 01:13:11,100
speeding this up by having their virtual memory units, go.

1940
01:13:11,100 --> 01:13:14,600
Okay, when I clone a process, all this map, all the exact same

1941
01:13:14,600 --> 01:13:18,100
physical memory into the virtual memory spaces of each process.

1942
01:13:18,100 --> 01:13:20,100
So there really isn't a second copy of the memory.

1943
01:13:20,100 --> 01:13:23,500
It's basically just one copy and then the virtual memory unit has a

1944
01:13:23,500 --> 01:13:27,500
flag that basically says whenever somebody writes to this, right?

1945
01:13:27,700 --> 01:13:29,300
I'm going to raise an exception.

1946
01:13:29,400 --> 01:13:29,800
It's basically

1947
01:13:29,900 --> 01:13:32,500
The the it's basically marking, the pages, read only, but what will

1948
01:13:32,500 --> 01:13:34,700
the operating system will do, is when that exception gets raised, when

1949
01:13:34,700 --> 01:13:36,500
the right triggers, it'll go.

1950
01:13:36,500 --> 01:13:37,200
Ok.

1951
01:13:37,400 --> 01:13:41,000
You actually tried to write to this cloned copy of the memory, which

1952
01:13:41,000 --> 01:13:43,600
we don't want to have happen because you each need your own copy

1953
01:13:43,700 --> 01:13:44,100
right?

1954
01:13:44,100 --> 01:13:47,800
Then I will basically then clone in the page table.

1955
01:13:48,300 --> 01:13:52,400
Make a new entry for you and then actually physically copy the bits

1956
01:13:52,400 --> 01:13:53,200
over to it.

1957
01:13:53,400 --> 01:13:56,500
So that now you actually do have your own copy so that your rights

1958
01:13:56,500 --> 01:13:58,200
won't be seen by the other process.

1959
01:13:58,400 --> 01:13:59,800
So I believe that the reason that this

1960
01:14:00,000 --> 01:14:00,600
In Windows.

1961
01:14:00,700 --> 01:14:04,400
Is because when they went to implement Implement posix compliance, and

1962
01:14:04,400 --> 01:14:07,400
they probably had Implement Fork, which meant they probably had to

1963
01:14:07,400 --> 01:14:08,600
implement this.

1964
01:14:09,100 --> 01:14:09,900
That's my guess.

1965
01:14:10,400 --> 01:14:11,300
You should verify it.

1966
01:14:18,800 --> 01:14:21,100
The download link from Sundial keeps bundling all the zip files

1967
01:14:21,100 --> 01:14:21,700
together.

1968
01:14:21,800 --> 01:14:23,000
That is what it's supposed to do.

1969
01:14:23,100 --> 01:14:25,400
Your base supposed to guess the basically get all the days together,

1970
01:14:25,400 --> 01:14:26,900
so that you can pick which one you want.

1971
01:14:38,600 --> 01:14:42,200
You wanted to say something about size in bytes, reminder.

1972
01:14:44,500 --> 01:14:45,200
You know what?

1973
01:14:46,400 --> 01:14:51,300
I probably did size in bytes reminder.

1974
01:14:52,500 --> 01:14:53,200
But you know what?

1975
01:14:53,200 --> 01:14:55,600
My mind since I had Focus so much on explanations.

1976
01:14:55,600 --> 01:14:58,200
My mind is just a blank as to what I said during the stream.

1977
01:14:58,200 --> 01:14:59,800
It's really hard to actually program.

1978
01:15:00,100 --> 01:15:00,900
At the same time.

1979
01:15:02,100 --> 01:15:02,800
I'm going to ask with you.

1980
01:15:02,800 --> 01:15:03,800
It's pretty difficult.

1981
01:15:05,600 --> 01:15:07,000
Size in bytes.

1982
01:15:07,000 --> 01:15:08,600
What was I even talking about?

1983
01:15:08,600 --> 01:15:09,500
When I said that?

1984
01:15:09,500 --> 01:15:10,500
Does anyone remember?

1985
01:15:10,500 --> 01:15:15,300
Because I would love to answer that question, but I do not remember.

1986
01:15:22,200 --> 01:15:23,100
Deflated.

1987
01:15:23,200 --> 01:15:23,500
I'm sorry.

1988
01:15:23,500 --> 01:15:25,800
I do not remember if someone can jog my memory.

1989
01:15:25,800 --> 01:15:26,600
That would be great.

1990
01:15:27,400 --> 01:15:28,700
Let's see.

1991
01:15:31,100 --> 01:15:33,800
Let's see, doo-doo-doo-doo.

1992
01:15:37,500 --> 01:15:41,100
Mive God, I'm having trouble finding questions here that actually

1993
01:15:41,100 --> 01:15:42,300
pertain to the code that we wrote.

1994
01:15:42,300 --> 01:15:44,700
A lot of these are questions about other stuff, which I don't want to

1995
01:15:44,900 --> 01:15:46,000
do on the end of streams.

1996
01:15:46,000 --> 01:15:48,000
Usually, because we got to concentrate on the actual code.

1997
01:15:48,700 --> 01:15:51,200
So if you could, if you could limit questions on these streams, well,

1998
01:15:51,200 --> 01:15:54,500
maybe we'll do some long stream sometimes when we do other ones pitch

1999
01:15:54,500 --> 01:15:58,600
and stride, so I said size and B and talked about pitch in stride.

2000
01:15:58,600 --> 01:15:58,900
Okay.

2001
01:15:58,900 --> 01:15:59,900
Well, let's see if I can jog.

2002
01:16:00,100 --> 01:16:04,900
I remember it all here pitch and stride.

2003
01:16:04,900 --> 01:16:06,400
So, basically in here.

2004
01:16:09,600 --> 01:16:11,200
Yeah, I don't know.

2005
01:16:11,200 --> 01:16:11,600
I'm sorry.

2006
01:16:11,600 --> 01:16:13,700
I cannot remember was going to say, maybe I'll be Rush this dream

2007
01:16:13,700 --> 01:16:14,100
later.

2008
01:16:14,500 --> 01:16:15,100
Basically.

2009
01:16:15,100 --> 01:16:18,000
What I was talking about here is is pretty basic stuff.

2010
01:16:18,400 --> 01:16:20,100
Basically, you know, we have a block of memory.

2011
01:16:20,100 --> 01:16:21,900
Let's go to her again, and to say the things about it.

2012
01:16:21,900 --> 01:16:22,800
In case, one of them was the thing.

2013
01:16:22,800 --> 01:16:26,000
I was going to say, we want to render to a block of memory, allocated

2014
01:16:26,000 --> 01:16:30,100
a block of memory and basically that memory looks kind of like this,

2015
01:16:30,100 --> 01:16:30,400
right?

2016
01:16:30,400 --> 01:16:31,300
It looks like

2017
01:16:32,800 --> 01:16:37,000
In memory, we have a pointer and that point pointer is bitmap memory

2018
01:16:37,200 --> 01:16:40,700
and it is pointing to right the pixels.

2019
01:16:40,800 --> 01:16:46,000
And they are basically the blue, the G blue, green, red X ax, blue

2020
01:16:46,000 --> 01:16:52,400
green, red x, x, blue, green, red, x, x, that is the memory for a row,

2021
01:16:52,500 --> 01:16:52,800
right?

2022
01:16:52,800 --> 01:16:54,000
One row of the image.

2023
01:16:54,100 --> 01:16:56,800
And so, we basically have width of these, right?

2024
01:16:56,800 --> 01:16:59,800
We have width of these going this way, right?

2025
01:16:59,900 --> 01:17:02,300
Starting from the from from exactly where the pointer

2026
01:17:02,500 --> 01:17:06,300
Is all the way to the pointer plus width times the number of bytes per

2027
01:17:06,300 --> 01:17:08,100
pixel, which is for, right?

2028
01:17:08,300 --> 01:17:16,400
So, you know, we're basically going from bitmap memory zero right to

2029
01:17:16,700 --> 01:17:20,800
to an offset of width x b per pixel.

2030
01:17:21,000 --> 01:17:24,600
All the way at the end which is, which is the end of it off, which is

2031
01:17:24,600 --> 01:17:25,600
like right at the end.

2032
01:17:25,600 --> 01:17:28,100
It's a pointer to like the first thing of the next row.

2033
01:17:28,500 --> 01:17:32,300
So at the end of every row, if we want to move to the next row,

2034
01:17:32,400 --> 01:17:32,700
Row.

2035
01:17:32,700 --> 01:17:35,500
We would actually be right there already because of the way that we've

2036
01:17:35,500 --> 01:17:39,600
packed these in memory, but if the pitch was something else so that

2037
01:17:39,600 --> 01:17:41,700
basically there, if it let's say there was padding, at the end of the

2038
01:17:41,700 --> 01:17:44,900
row like unused stuff at the end of the row for some alignment reason

2039
01:17:44,900 --> 01:17:46,800
which often times there can be in graphics.

2040
01:17:48,300 --> 01:17:53,000
Basically, what we do is we take this pointer and we add the pitch to

2041
01:17:53,000 --> 01:17:54,900
it to get the next row, right?

2042
01:17:54,900 --> 01:17:58,800
So this right here is rho 0, right?

2043
01:17:58,800 --> 01:17:59,600
0, 0.

2044
01:18:03,000 --> 01:18:07,100
And then Row 1 is going to be the next set of these, right?

2045
01:18:08,400 --> 01:18:12,500
And each time advancing this pointer is is like, you know bitmap

2046
01:18:12,500 --> 01:18:15,500
memory plus the pitch right to get to the next one.

2047
01:18:16,100 --> 01:18:16,600
Right?

2048
01:18:16,800 --> 01:18:17,900
Don't know if that makes any sense.

2049
01:18:18,200 --> 01:18:21,100
So we do bitmap memory, plus pitch plus pitch pitch, pitch moves us to

2050
01:18:21,100 --> 01:18:21,700
the next row.

2051
01:18:21,800 --> 01:18:23,000
So that's exactly what we did here.

2052
01:18:23,000 --> 01:18:23,400
Right?

2053
01:18:23,500 --> 01:18:25,000
We just said, here's the bitmap memory.

2054
01:18:25,400 --> 01:18:27,200
We're going to start right at the beginning of it.

2055
01:18:27,400 --> 01:18:30,100
And then each time through, we're going to add pitch to it, to move to

2056
01:18:30,100 --> 01:18:30,800
the next row.

2057
01:18:30,900 --> 01:18:33,200
Then this basically fills in the row of pixels.

2058
01:18:33,400 --> 01:18:36,700
So we take a copy of that pointer a pointer to the beginning of the

2059
01:18:36,700 --> 01:18:37,100
row.

2060
01:18:37,200 --> 01:18:38,100
We go through each pixel.

2061
01:18:38,300 --> 01:18:39,600
The road and me, write it now.

2062
01:18:39,600 --> 01:18:42,100
If we wanted to, you can kind of see what this does, right?

2063
01:18:43,300 --> 01:18:47,400
It does this if we wanted to, we actually could just Boop.

2064
01:18:48,600 --> 01:18:50,900
We actually could just use because pixel is basically getting an

2065
01:18:51,300 --> 01:18:52,700
advanced by 32 bits.

2066
01:18:52,700 --> 01:18:55,500
Every time it's getting Advanced through these things, right 4.

2067
01:18:55,500 --> 01:18:56,700
Bytes, at a time goes through there.

2068
01:18:57,500 --> 01:19:00,800
And so if we wanted to, we could actually not bother keeping a

2069
01:19:00,800 --> 01:19:01,400
separate pointer.

2070
01:19:01,400 --> 01:19:04,200
Because at the end pixel is actually pointing at the beginning of the,

2071
01:19:04,200 --> 01:19:06,300
of the row because the roads are tightly packed together.

2072
01:19:06,400 --> 01:19:08,600
So after it goes through all the pictures of one row, it's pointing at

2073
01:19:08,600 --> 01:19:09,900
the first pixel of the next row.

2074
01:19:10,100 --> 01:19:14,200
So we could just do, you know, basically say, okay, just use the

2075
01:19:14,200 --> 01:19:15,300
pointer that you were on.

2076
01:19:15,400 --> 01:19:17,300
That's that's the next pointer, right?

2077
01:19:17,300 --> 01:19:18,300
And that should just

2078
01:19:18,600 --> 01:19:19,200
Right?

2079
01:19:19,300 --> 01:19:21,100
So we could just do this entirely with one.

2080
01:19:21,500 --> 01:19:22,300
Does that make sense?

2081
01:19:22,400 --> 01:19:24,900
Hopefully that makes some sense, but I chose to write it in a way that

2082
01:19:24,900 --> 01:19:26,300
was a little more explicit.

2083
01:19:26,400 --> 01:19:29,300
Just so you could kind of think about that concept of pitch a little

2084
01:19:29,300 --> 01:19:34,900
bit because it usually comes in relatively often and I want you to be

2085
01:19:34,900 --> 01:19:35,500
aware of it.

2086
01:19:44,200 --> 01:19:45,500
Let's see.

2087
01:19:51,100 --> 01:19:53,500
You mentioned, oh, XXX BB grr.

2088
01:19:53,500 --> 01:19:54,400
Because of little endian.

2089
01:19:54,400 --> 01:19:57,100
Why was the blue Channel set in this case and not the padding?

2090
01:19:57,200 --> 01:20:00,200
So, the answer is just because of what the windows devs decided to do.

2091
01:20:00,300 --> 01:20:03,800
So again, the way this is in memory order, right?

2092
01:20:04,000 --> 01:20:04,500
Or rather.

2093
01:20:04,500 --> 01:20:07,300
I should say the way that it would be in memory order.

2094
01:20:07,300 --> 01:20:10,800
If you just started typing, it probably is you store the red.

2095
01:20:11,000 --> 01:20:11,800
This is memory order.

2096
01:20:12,200 --> 01:20:14,700
You store the read first, then you store the green, then you store the

2097
01:20:14,700 --> 01:20:17,700
blue, then you store the pad that's probably how you would do it.

2098
01:20:17,800 --> 01:20:17,900
Right?

2099
01:20:17,900 --> 01:20:19,100
Because red green blue pad.

2100
01:20:19,200 --> 01:20:20,800
It's logical because we usually think of

2101
01:20:20,900 --> 01:20:22,100
Read first green, second blue.

2102
01:20:22,100 --> 01:20:26,600
Third, when this gets loaded in right, load it in, on the little

2103
01:20:26,600 --> 01:20:29,200
endian machine, you get the exact opposite.

2104
01:20:29,200 --> 01:20:30,700
The red comes in first.

2105
01:20:31,000 --> 01:20:35,300
The green comes in, then the blue comes in, then that comes in right.

2106
01:20:35,300 --> 01:20:36,100
That is what would happen.

2107
01:20:36,100 --> 01:20:38,300
You get the gr like that.

2108
01:20:39,100 --> 01:20:42,400
So, the windows devs decided that they didn't like that.

2109
01:20:42,500 --> 01:20:43,900
They wanted to see.

2110
01:20:43,900 --> 01:20:46,900
They decided they wanted right?

2111
01:20:47,600 --> 01:20:48,300
To have it.

2112
01:20:48,300 --> 01:20:48,700
Look like this.

2113
01:20:48,700 --> 01:20:51,200
Now, you'll notice what they wanted.

2114
01:20:51,200 --> 01:20:52,500
Was just a swap.

2115
01:20:52,500 --> 01:20:56,900
The are in the are in the be they apparently didn't care that the pad

2116
01:20:56,900 --> 01:20:57,800
was still at the top.

2117
01:20:57,800 --> 01:20:58,600
That was okay.

2118
01:20:58,600 --> 01:20:59,700
They just wanted r g and

2119
01:21:00,500 --> 01:21:01,600
To be in the same order.

2120
01:21:01,600 --> 01:21:03,000
That's all they were trying to do there.

2121
01:21:03,200 --> 01:21:03,600
Right?

2122
01:21:03,800 --> 01:21:06,300
So the pad never got swapped in their brain.

2123
01:21:06,500 --> 01:21:10,800
So when they actually made windows and decided what the memory order

2124
01:21:10,800 --> 01:21:14,000
was, they just swapped the are and the G and left the pad where it

2125
01:21:14,000 --> 01:21:15,500
was, that is why.

2126
01:21:15,800 --> 01:21:19,600
So little endian was the impetus for them to change because they

2127
01:21:19,600 --> 01:21:25,100
wanted to read it this way instead of this way, but they didn't

2128
01:21:25,100 --> 01:21:26,300
actually care where the pad was.

2129
01:21:26,300 --> 01:21:27,500
They just left the pad where it was.

2130
01:21:31,700 --> 01:21:34,200
Could the padding B be used as at the alpha channel here?

2131
01:21:34,300 --> 01:21:37,900
Yes, it absolutely could be if we were using what was called what is

2132
01:21:37,900 --> 01:21:41,100
called a layered window, which tells the compositor that we want an

2133
01:21:41,100 --> 01:21:41,900
alpha Channel.

2134
01:21:42,200 --> 01:21:44,000
We could actually use this as an alpha Channel.

2135
01:21:44,000 --> 01:21:47,400
Yes, since we don't want our game to have the backdrop the background

2136
01:21:47,400 --> 01:21:50,000
show through, we did not do that.

2137
01:21:50,200 --> 01:21:51,400
But that is something you could do.

2138
01:21:51,400 --> 01:21:51,800
Yes.

2139
01:21:53,800 --> 01:21:56,300
And in that case, it looks like it looks like this.

2140
01:21:58,800 --> 01:21:59,000
Right.

2141
01:21:59,000 --> 01:22:01,400
So the alpha Channel goes in those patent bit.

2142
01:22:06,400 --> 01:22:09,600
Why are we having a wait symbol on the window?

2143
01:22:09,800 --> 01:22:12,900
The answer is because we have not set our cursor yet.

2144
01:22:13,100 --> 01:22:17,700
So if you are wondering why that is happening, that is because we have

2145
01:22:17,700 --> 01:22:18,800
not set a cursor.

2146
01:22:18,800 --> 01:22:24,500
And so what we actually want to do is we basically want to do a way

2147
01:22:24,500 --> 01:22:25,100
you would do that.

2148
01:22:25,100 --> 01:22:26,800
I believe is this way.

2149
01:22:34,200 --> 01:22:36,500
And now, we don't have a cursor in the window at all, which is what

2150
01:22:36,500 --> 01:22:37,500
we're going to want for the game.

2151
01:22:38,000 --> 01:22:38,500
Right?

2152
01:22:38,700 --> 01:22:41,200
And so, the reason that I haven't gotten that yet.

2153
01:22:41,200 --> 01:22:43,700
It seems there's a little bit of other.

2154
01:22:43,700 --> 01:22:45,000
You don't just want to do that.

2155
01:22:45,000 --> 01:22:46,400
That's not the only thing you want to do.

2156
01:22:46,400 --> 01:22:48,600
So I'm leaving that to a little bit later.

2157
01:22:51,500 --> 01:22:53,200
Could we explain the offset to X and Y?

2158
01:22:53,200 --> 01:22:54,000
Absolutely.

2159
01:22:54,400 --> 01:22:57,100
So basically all I want to do is get something animated.

2160
01:22:57,200 --> 01:23:00,600
So we're still writing the exact same pixels, but we're basically just

2161
01:23:00,600 --> 01:23:01,300
changing.

2162
01:23:01,700 --> 01:23:03,200
In fact, I should maybe rename these.

2163
01:23:03,200 --> 01:23:05,100
In fact, let's go ahead and rename these a little bit.

2164
01:23:05,300 --> 01:23:08,600
What this really is is blue offset and green offset.

2165
01:23:08,600 --> 01:23:11,400
We're just artificially offsetting the colors that we write.

2166
01:23:11,400 --> 01:23:14,200
So it appears to scroll, right?

2167
01:23:14,500 --> 01:23:15,800
We're just, that's all we're doing.

2168
01:23:15,800 --> 01:23:19,600
We're just adding an increment that's constantly incrementing

2169
01:23:19,600 --> 01:23:21,100
overtime, right?

2170
01:23:21,500 --> 01:23:22,300
That's all we're doing.

2171
01:23:22,700 --> 01:23:25,900
So yeah, those aren't really incrementing the X and the Y.

2172
01:23:26,300 --> 01:23:28,200
We're still writing the actual places in X and Y.

2173
01:23:28,200 --> 01:23:29,600
We're just using those to offset the color.

2174
01:23:29,600 --> 01:23:31,700
So it appears to slide now right now.

2175
01:23:31,700 --> 01:23:32,400
We're not passing.

2176
01:23:32,400 --> 01:23:33,800
Y offset at all.

2177
01:23:34,000 --> 01:23:36,000
We're just passing 04 it all the time, right?

2178
01:23:36,000 --> 01:23:40,300
Because y offset never gets incremented, but we could write and we

2179
01:23:40,300 --> 01:23:41,700
could, we could maybe do something.

2180
01:23:41,700 --> 01:23:44,400
We're actually, we could, we could offset it, may be twice as fast.

2181
01:23:44,700 --> 01:23:48,300
And then, as you can see, now we would get to

2182
01:23:49,000 --> 01:23:49,900
two ways of panning.

2183
01:23:55,700 --> 01:23:58,000
You're talking about wrapping your Global's.

2184
01:24:00,600 --> 01:24:02,600
I made a note in theriot.

2185
01:24:02,600 --> 01:24:06,500
I did internal versus global variable explain.

2186
01:24:07,900 --> 01:24:09,000
Oh, well, you know what?

2187
01:24:09,000 --> 01:24:11,000
Maybe I'll call I'll do this now make in case.

2188
01:24:11,000 --> 01:24:11,500
This was the thing.

2189
01:24:11,500 --> 01:24:14,800
I was referring to, I'll go ahead and do this now.

2190
01:24:14,800 --> 01:24:15,600
So, okay.

2191
01:24:17,500 --> 01:24:21,700
So the global variables, some people were a little confused by these.

2192
01:24:21,700 --> 01:24:25,600
So let me just use the last 5 minutes of our Q&A here to talk about

2193
01:24:25,600 --> 01:24:27,100
this potentially.

2194
01:24:29,900 --> 01:24:35,500
So Global variables, the reason that I call this a global variable is

2195
01:24:35,500 --> 01:24:37,800
because for us really is going to be Global and you're going to see

2196
01:24:37,800 --> 01:24:40,900
why in a second here, but assuming that I didn't do these pound

2197
01:24:40,900 --> 01:24:43,500
defines up here, internal local per system.

2198
01:24:43,500 --> 01:24:44,100
Global variable.

2199
01:24:44,100 --> 01:24:44,600
Right?

2200
01:24:44,600 --> 01:24:48,200
What you would have seen here was you would have seen like static in,

2201
01:24:48,400 --> 01:24:51,300
you know, Fuqua something static into blah, equal something.

2202
01:24:51,300 --> 01:24:54,200
And those would have been how we would do ours or or maybe they didn't

2203
01:24:54,200 --> 01:24:56,000
get initialized to the just be 0 or whatever.

2204
01:24:56,100 --> 01:24:57,900
This is what I would have been writing.

2205
01:24:57,900 --> 01:24:59,500
Their wouldn't been Global variables be static.

2206
01:25:00,100 --> 01:25:00,600
Right?

2207
01:25:01,600 --> 01:25:05,500
And basically what static does is static does two things.

2208
01:25:06,400 --> 01:25:12,400
The first is, it says that this name cannot be used outside of this

2209
01:25:12,400 --> 01:25:16,400
translation unit, which usually means file in our case.

2210
01:25:16,400 --> 01:25:18,400
It won't, which is why I say things going to be different from us,

2211
01:25:18,400 --> 01:25:20,100
which we'll see later on in the Stream.

2212
01:25:20,100 --> 01:25:22,400
I don't want to get into it now, but for translation unit, so usually

2213
01:25:22,400 --> 01:25:23,400
it means like the file.

2214
01:25:23,500 --> 01:25:27,600
But technically translation unit means like the file and all files

2215
01:25:27,600 --> 01:25:28,700
included by this file.

2216
01:25:28,700 --> 01:25:29,500
Like the whole thing.

2217
01:25:29,600 --> 01:25:29,800
NG.

2218
01:25:29,900 --> 01:25:32,400
So basically when we have includes the stuff like that, it's all one,

2219
01:25:32,400 --> 01:25:33,700
big translation unit.

2220
01:25:33,800 --> 01:25:34,800
So it's not just the file.

2221
01:25:34,800 --> 01:25:36,800
It's the file and all the things included in that file.

2222
01:25:37,500 --> 01:25:42,400
Static means that the name cannot be used outside of the of the

2223
01:25:42,800 --> 01:25:43,600
translation unit.

2224
01:25:43,700 --> 01:25:48,500
And it means it is going to be initialized to 0 means both of those

2225
01:25:48,500 --> 01:25:48,800
things.

2226
01:25:49,000 --> 01:25:49,400
We could.

2227
01:25:49,400 --> 01:25:52,300
Instead have declared a global variable like that.

2228
01:25:52,300 --> 01:25:55,600
And what that means is that the name can be used outside.

2229
01:25:55,800 --> 01:25:59,500
In fact, anyone can use it by just saying extern infu and

2230
01:25:59,600 --> 01:26:03,000
Hey, there's a food somewhere, you know, in their file somewhere, some

2231
01:26:03,000 --> 01:26:03,700
other files.

2232
01:26:03,700 --> 01:26:04,700
So this is included in file.

2233
01:26:04,700 --> 01:26:08,200
I say extern Foo and then I can just, you know, mess with food and

2234
01:26:08,200 --> 01:26:08,900
it'll work.

2235
01:26:08,900 --> 01:26:11,600
And it'll go find this food that we declared in here.

2236
01:26:11,700 --> 01:26:15,300
This Global variable Foo in here and it will modify it.

2237
01:26:15,300 --> 01:26:15,800
Right.

2238
01:26:16,500 --> 01:26:17,100
You can't do that.

2239
01:26:17,100 --> 01:26:20,400
With static other files can't reach in and touch your static

2240
01:26:20,400 --> 01:26:21,700
variables, right?

2241
01:26:21,700 --> 01:26:22,800
Other translation units.

2242
01:26:23,800 --> 01:26:26,000
So that's that's what static does, right?

2243
01:26:26,900 --> 01:26:29,500
And then the other thing that's

2244
01:26:29,600 --> 01:26:32,300
static does is if you put it in front of a function, which is why I

2245
01:26:32,300 --> 01:26:33,500
declared internal if I do.

2246
01:26:33,500 --> 01:26:36,000
Static void sum function.

2247
01:26:37,900 --> 01:26:40,200
Basically, it doesn't change anything about the function.

2248
01:26:40,300 --> 01:26:43,000
It just applies that naming part again.

2249
01:26:43,000 --> 01:26:44,400
It says nobody outside.

2250
01:26:44,400 --> 01:26:48,500
This file can use the name some function to call this function.

2251
01:26:48,700 --> 01:26:51,400
Now, it doesn't actually mean that other people outside.

2252
01:26:51,400 --> 01:26:52,300
This translation unit.

2253
01:26:52,300 --> 01:26:53,700
Can't call the function.

2254
01:26:54,000 --> 01:26:55,800
They can still call the function.

2255
01:26:56,000 --> 01:26:58,200
They just can't call it by name.

2256
01:26:58,500 --> 01:26:59,800
So if we wanted to

2257
01:27:00,100 --> 01:27:03,500
In some other code, like, let's say in renderware, gradient, which is

2258
01:27:03,500 --> 01:27:05,300
in the same translation unit.

2259
01:27:05,300 --> 01:27:11,200
I could take some function as a pointer and I could pass it to some

2260
01:27:11,500 --> 01:27:13,600
function outside.

2261
01:27:13,600 --> 01:27:15,700
This translation unit.

2262
01:27:15,700 --> 01:27:21,000
I could pass the address to it like that and then that could call into

2263
01:27:21,000 --> 01:27:21,400
it.

2264
01:27:21,400 --> 01:27:24,300
So it can still be called by anyone.

2265
01:27:24,500 --> 01:27:28,300
It just can't be referred to by name in other translation units.

2266
01:27:28,700 --> 01:27:29,800
That's the other thing that static does.

2267
01:27:30,000 --> 01:27:33,800
They're now what we're going to do, as you'll see later in the Stream

2268
01:27:34,000 --> 01:27:40,000
is we are only ever going to have one or maybe two translation units

2269
01:27:40,000 --> 01:27:40,500
total.

2270
01:27:40,600 --> 01:27:44,700
So for us static means completely Global variable.

2271
01:27:44,900 --> 01:27:47,300
So that is why I defined it to be called Global variable.

2272
01:27:47,300 --> 01:27:48,900
Some people got nervous about that.

2273
01:27:48,900 --> 01:27:49,300
Who knows?

2274
01:27:49,300 --> 01:27:50,600
C plus c and C++.

2275
01:27:50,600 --> 01:27:52,100
There were like, you kind of explain that wrong.

2276
01:27:52,100 --> 01:27:53,700
I'm like, well, yeah, I agree.

2277
01:27:53,700 --> 01:27:56,400
I probably should have explained it the standard way.

2278
01:27:56,400 --> 01:27:58,500
So, people know which now I hopefully have done.

2279
01:27:59,700 --> 01:28:02,100
But for us it's actually completely Global variable.

2280
01:28:02,100 --> 01:28:04,300
It's not even restricted to the translation unit because there's only

2281
01:28:04,300 --> 01:28:05,300
one translation unit.

2282
01:28:05,300 --> 01:28:09,200
So all of our code will be able to touch this variable this variable.

2283
01:28:09,200 --> 01:28:10,400
So it really is truly Global.

2284
01:28:10,600 --> 01:28:12,000
Hopefully that cleared some things up.

2285
01:28:17,100 --> 01:28:18,900
Select does not give you zero initialization.

2286
01:28:18,900 --> 01:28:21,100
You get that by virtue of it being a global.

2287
01:28:22,800 --> 01:28:23,900
Is that actually true?

2288
01:28:24,700 --> 01:28:26,600
I don't know if that is actually true.

2289
01:28:26,600 --> 01:28:27,700
Are we sure about that?

2290
01:28:27,800 --> 01:28:29,400
If you're sure about that then that's cool.

2291
01:28:30,000 --> 01:28:33,200
I would like to get confirmation about that because I don't actually

2292
01:28:33,200 --> 01:28:40,200
know our extern variables initialized to 0.

2293
01:28:41,300 --> 01:28:45,100
Let's find out, stack Overflow is a little bit untrustworthy.

2294
01:28:45,100 --> 01:28:49,200
I was kind of hoping that I can maybe get something a little bit.

2295
01:28:51,300 --> 01:28:53,400
A little bit better than that.

2296
01:28:53,400 --> 01:28:55,100
Hoping maybe someone who reference the spec.

2297
01:28:55,100 --> 01:28:58,600
Well, let's see if anyone references the spec.

2298
01:29:00,200 --> 01:29:01,500
Let's see.

2299
01:29:04,200 --> 01:29:05,700
This is useless as always.

2300
01:29:05,700 --> 01:29:06,700
Oh, maybe that guy reference.

2301
01:29:06,700 --> 01:29:07,100
The spec.

2302
01:29:07,100 --> 01:29:07,700
Did he

2303
01:29:10,600 --> 01:29:12,600
Well in C++ here, it says that.

2304
01:29:13,300 --> 01:29:14,200
Well, I don't know.

2305
01:29:15,100 --> 01:29:15,500
I don't know.

2306
01:29:15,500 --> 01:29:16,700
Basically, I would like someone.

2307
01:29:16,700 --> 01:29:19,000
I'm not really, I don't really care about that.

2308
01:29:19,000 --> 01:29:21,700
I never Define anything extern for the most part.

2309
01:29:22,000 --> 01:29:25,000
So I'm not sure I'm not going to trust track overflow on that.

2310
01:29:25,000 --> 01:29:26,500
I would like someone to check the spec.

2311
01:29:27,000 --> 01:29:29,500
But if you absolutely are I would like someone to actually check this

2312
01:29:29,500 --> 01:29:31,500
back and be absolutely sure that is true.

2313
01:29:31,600 --> 01:29:35,300
Before we say that on the stream because for some reason I remember

2314
01:29:35,300 --> 01:29:38,600
that not always being true, so, I don't know.

2315
01:29:41,300 --> 01:29:43,100
Do I consider overflowing numbers?

2316
01:29:43,100 --> 01:29:44,500
A good coding practice?

2317
01:29:45,100 --> 01:29:48,800
If you know if you meant to do it, I guess it's what I would say

2318
01:29:49,600 --> 01:29:50,200
basically.

2319
01:29:50,200 --> 01:29:53,300
Like anything is a good coding practice.

2320
01:29:53,300 --> 01:29:56,100
If you understand what you're doing and you believe that it is a

2321
01:29:56,100 --> 01:29:57,700
proper usage of the CPU.

2322
01:29:57,700 --> 01:29:59,800
And since the CPU can do wrapping.

2323
01:30:00,000 --> 01:30:04,300
With my tech very easily, especially on an 8-bit integer like that.

2324
01:30:04,400 --> 01:30:05,200
It's no problem.

2325
01:30:06,400 --> 01:30:08,300
I mean, it can do it on 32-bit integer just as well.

2326
01:30:08,600 --> 01:30:12,700
So you should absolutely use that if there's a reason to do.

2327
01:30:12,700 --> 01:30:14,500
So we are just about out of time.

2328
01:30:14,500 --> 01:30:15,700
So last question here.

2329
01:30:19,700 --> 01:30:21,300
Let's see.

2330
01:30:21,400 --> 01:30:22,600
Let's see.

2331
01:30:24,000 --> 01:30:24,700
Yeah, misc.

2332
01:30:24,700 --> 01:30:27,300
Annex says it goes in data as DB.

2333
01:30:27,300 --> 01:30:29,900
So it's very likely to be 0 but only because Windows zeros page for.

2334
01:30:29,900 --> 01:30:33,100
Yeah, I believe that the person who said that it gets initialized to

2335
01:30:33,100 --> 01:30:34,000
zero is wrong.

2336
01:30:34,000 --> 01:30:34,500
Actually.

2337
01:30:34,500 --> 01:30:37,500
I believe that only Statics are guaranteed to be initialized to 0 so

2338
01:30:37,500 --> 01:30:39,100
I'm really nervous about that.

2339
01:30:39,300 --> 01:30:42,300
But if someone checks the spec and says that it absolutely is zero

2340
01:30:42,300 --> 01:30:43,600
then maybe you can rely on that.

2341
01:30:43,600 --> 01:30:44,100
I don't know.

2342
01:30:44,600 --> 01:30:44,800
Okay.

2343
01:30:44,800 --> 01:30:50,200
Someone someone says they have is this is this actually I don't know

2344
01:30:50,200 --> 01:30:52,200
if this is actually someone someone sending a link here.

2345
01:30:52,200 --> 01:30:53,400
Maybe this is a link to the spa.

2346
01:30:53,900 --> 01:30:54,800
I don't actually know.

2347
01:30:55,000 --> 01:30:57,000
Let's find out, copy link address.

2348
01:30:58,700 --> 01:31:02,100
Let's see here, because I would like to know the answer.

2349
01:31:02,100 --> 01:31:04,800
I don't ever use it, but let's see.

2350
01:31:06,000 --> 01:31:08,200
Let's see.

2351
01:31:12,500 --> 01:31:13,600
Static.

2352
01:31:17,400 --> 01:31:18,100
If anonymous.

2353
01:31:19,900 --> 01:31:23,200
If an object that has automatic storage durations on its values in

2354
01:31:23,200 --> 01:31:23,800
determinant.

2355
01:31:23,800 --> 01:31:26,600
Yes, if an object has static storage duration, it is not initially

2356
01:31:26,600 --> 01:31:29,500
explicit initially, especially then gets cleared to zero.

2357
01:31:29,800 --> 01:31:30,700
As we thought.

2358
01:31:31,800 --> 01:31:34,100
Let's see what happens with an extern though.

2359
01:31:37,400 --> 01:31:39,600
Yes, it looks like it's not initialized to 0.

2360
01:31:40,400 --> 01:31:40,800
I don't know.

2361
01:31:40,900 --> 01:31:45,300
Someone should go do a careful reading of the spec, but I believe I

2362
01:31:45,300 --> 01:31:47,200
believe Dusty gozongas.

2363
01:31:47,600 --> 01:31:49,300
I believe that is not correct.

2364
01:31:49,400 --> 01:31:52,400
Static is the thing that gets you 0 initialization.

2365
01:31:52,700 --> 01:31:55,500
It being Global does not help you.

2366
01:31:55,800 --> 01:31:58,000
You actually I think do needed to be Global.

2367
01:31:58,000 --> 01:32:03,800
Now granted you could just do you know like this or something and that

2368
01:32:03,800 --> 01:32:07,000
would then cause it to be initialized to 0, but if you just declare it

2369
01:32:07,000 --> 01:32:07,100
with

2370
01:32:07,200 --> 01:32:11,100
Nothing, it will not be initialized to zero, like a static.

2371
01:32:12,400 --> 01:32:16,400
All right, I think that is about it.

2372
01:32:16,500 --> 01:32:19,500
Please save all the questions for tomorrow when we will be going over

2373
01:32:19,500 --> 01:32:21,700
this code with a little more of a fine-tooth comb and I'll explain

2374
01:32:21,700 --> 01:32:26,300
everything in very deep detail and we will clean up a few things and

2375
01:32:26,300 --> 01:32:29,500
talk about how we want to do that cleanup because the code is a little

2376
01:32:29,500 --> 01:32:30,500
bit messy right now.

2377
01:32:30,800 --> 01:32:34,600
So I had an excellent time coding with you this evening.

2378
01:32:34,600 --> 01:32:38,300
I'm pretty psyched that we have an animating bitmap now that we can do

2379
01:32:38,300 --> 01:32:42,000
whatever we want with and we will have about I think one more

2380
01:32:42,300 --> 01:32:43,100
Of Windows coding.

2381
01:32:43,100 --> 01:32:45,100
Next week will be a Windows coding week as well because I got to get

2382
01:32:45,100 --> 01:32:46,000
sound working.

2383
01:32:46,000 --> 01:32:47,800
I don't want to start the game without sound.

2384
01:32:48,000 --> 01:32:50,600
So we're gonna get sound working and just do a little bit of work with

2385
01:32:50,600 --> 01:32:53,100
input so we can have a Gamepad and stuff like that.

2386
01:32:53,200 --> 01:32:55,900
So I think we'll have one more week of window stuff, but then we will

2387
01:32:55,900 --> 01:32:59,700
be in game territory in time for the month of Christmas, which is

2388
01:32:59,700 --> 01:32:59,900
exciting.

2389
01:33:00,000 --> 01:33:03,000
Eating for me because I'm pretty psyched to start working on this

2390
01:33:03,000 --> 01:33:03,400
game.

2391
01:33:03,900 --> 01:33:04,800
I hope you are too.

2392
01:33:05,100 --> 01:33:06,700
So thank you so much everyone for joining me.

2393
01:33:06,700 --> 01:33:08,100
It has been a real pleasure.

2394
01:33:08,700 --> 01:33:09,500
I hope to see you.

2395
01:33:09,500 --> 01:33:10,400
All tomorrow.

2396
01:33:10,400 --> 01:33:11,500
We're going to do 8 p.m.

2397
01:33:11,500 --> 01:33:13,100
I think tomorrow again.

2398
01:33:13,900 --> 01:33:17,100
And then from then on we'll move the Friday streams to an early stream

2399
01:33:17,100 --> 01:33:19,300
so that people in other time zones can follow along.

2400
01:33:19,300 --> 01:33:20,400
But tomorrow we'll do a p.m.

2401
01:33:20,400 --> 01:33:20,600
Again.

2402
01:33:20,600 --> 01:33:23,700
I believe watch the Twitter to find out what the time is and I'll try

2403
01:33:23,700 --> 01:33:26,700
to get a live schedule up at some point.

2404
01:33:26,700 --> 01:33:29,700
So people know when the stream is up, so they know when to come

2405
01:33:30,200 --> 01:33:31,700
Again, thank you so much for joining me.

2406
01:33:31,700 --> 01:33:32,700
I hope to see you back here.

2407
01:33:32,700 --> 01:33:33,700
Tomorrow when we'll go over.

2408
01:33:33,700 --> 01:33:34,700
This code, will clean it up.

2409
01:33:34,700 --> 01:33:35,700
We'll talk about anything.

2410
01:33:35,800 --> 01:33:39,000
Well, you know, we'll sort of tighten down the learning screws on it

2411
01:33:39,000 --> 01:33:41,200
so that everyone kind of comfortable with where we're at because we

2412
01:33:41,200 --> 01:33:42,200
went really fast this week.

2413
01:33:42,200 --> 01:33:45,000
That was the goal will kind of try to do those like basically fast

2414
01:33:45,000 --> 01:33:47,800
through the first four days and then take a day of just like relaxing

2415
01:33:47,800 --> 01:33:50,100
and talking about the code and making sure we're all comfortable that

2416
01:33:50,100 --> 01:33:50,800
before I move on.

2417
01:33:50,900 --> 01:33:52,200
That's probably how will do things.

2418
01:33:52,500 --> 01:33:55,500
And I hope to see you all here tomorrow with your question.

2419
01:33:55,500 --> 01:33:59,800
So, thanks everyone for tuning in and I will catch you tomorrow.

