1
00:00:00,000 --> 00:00:00,300
Here.

2
00:00:01,900 --> 00:00:04,200
Hello everyone and welcome.

3
00:00:04,500 --> 00:00:05,400
I believe it is day.

4
00:00:05,400 --> 00:00:08,700
It is day, 25 of handmade hero.

5
00:00:09,600 --> 00:00:13,800
We have come to the end of a long journey are building our win32

6
00:00:13,800 --> 00:00:14,700
platform layer.

7
00:00:15,100 --> 00:00:17,500
And I know it seems like a long time has been 25 days.

8
00:00:17,500 --> 00:00:22,300
But each day is only an hour of code that we get to do really, so if

9
00:00:22,300 --> 00:00:26,400
you think about it, if we started on Monday and it was, you know, we

10
00:00:26,400 --> 00:00:29,200
were working standard, you know, eight hour day with an hour for lunch

11
00:00:29,200 --> 00:00:29,900
or something like

12
00:00:30,000 --> 00:00:30,100
This.

13
00:00:30,100 --> 00:00:33,300
So we are working seven hours a day, you know, we're talking about

14
00:00:33,300 --> 00:00:34,100
less than four days.

15
00:00:34,100 --> 00:00:36,500
So we started on a Monday at work.

16
00:00:36,800 --> 00:00:38,700
We would have been done with this by Thursday.

17
00:00:38,800 --> 00:00:40,800
That's how little actual coding work.

18
00:00:40,800 --> 00:00:44,600
We've done it's because at only an hour a night, it just doesn't add

19
00:00:44,600 --> 00:00:45,200
up to very much.

20
00:00:45,200 --> 00:00:48,700
So I know it seems like we've spent a long time here, but really, this

21
00:00:48,700 --> 00:00:51,200
is not very much and that's with all the explanations everything.

22
00:00:51,200 --> 00:00:54,200
So building a win32 prototyping, layer is really not that hard

23
00:00:54,400 --> 00:00:58,400
building a shippable win32 layer, which will have to address later on.

24
00:00:58,400 --> 00:00:59,900
Definitely takes more work like they're

25
00:01:00,000 --> 00:01:03,800
Stuff that we have not done because we're just trying to build

26
00:01:03,800 --> 00:01:05,400
something that we can prototype on.

27
00:01:06,100 --> 00:01:09,200
So there will be more when 32 work involved down the road when we get

28
00:01:09,200 --> 00:01:12,200
to that point, but even then it's not going to be a huge amount of

29
00:01:12,200 --> 00:01:12,400
work.

30
00:01:12,400 --> 00:01:13,900
It's not going to take us years, right?

31
00:01:13,900 --> 00:01:15,700
It's going to be something fairly straightforward.

32
00:01:15,700 --> 00:01:18,900
So I think it's important to just kind of take a moment and go gosh,

33
00:01:18,900 --> 00:01:21,200
there really isn't that much work to do here.

34
00:01:21,600 --> 00:01:25,700
We haven't even done a week's worth of programming work yet and we

35
00:01:25,700 --> 00:01:26,800
already have a prototyping layer.

36
00:01:26,800 --> 00:01:29,800
That's got a bunch of features in it and works pretty well for

37
00:01:29,900 --> 00:01:30,600
Our purposes.

38
00:01:30,600 --> 00:01:34,100
And, you know, there's there's some stuff that we didn't do because

39
00:01:34,100 --> 00:01:36,600
we're not using Hardware acceleration yet, but you know, adding

40
00:01:36,600 --> 00:01:38,600
Hardware Solutions, actually, pretty simple, you'll see.

41
00:01:38,900 --> 00:01:41,400
And so at that point, you kind of have something that's pretty close

42
00:01:41,400 --> 00:01:42,300
to a shipping layer.

43
00:01:42,600 --> 00:01:45,100
So, I don't know, I think we're in pretty good shape and it really

44
00:01:45,100 --> 00:01:46,200
didn't take us that long.

45
00:01:46,800 --> 00:01:51,400
So that said today is going to be the last day of win32 specific

46
00:01:51,400 --> 00:01:52,500
coding base.

47
00:01:52,500 --> 00:01:54,600
So we're going to do today is just finish the cleanup that we started

48
00:01:54,600 --> 00:01:59,600
yesterday and maybe do a little bit of recap, but for the most part

49
00:01:59,600 --> 00:01:59,800
after,

50
00:02:00,000 --> 00:02:03,800
Today, we will no longer be thinking of win32 programming.

51
00:02:04,000 --> 00:02:07,900
The only time will go back to when 32, handmade dot CPP is when we

52
00:02:07,900 --> 00:02:11,500
sort of want to hoist things out of it now, because as we start

53
00:02:11,500 --> 00:02:14,800
building the platform independent part of things, some of the stuff

54
00:02:14,800 --> 00:02:17,800
that we did in the win32 layer will no longer be necessary to do in

55
00:02:17,800 --> 00:02:20,400
the winter to layer and we'll kind of pull those things out.

56
00:02:20,400 --> 00:02:24,000
And also there's a bunch of like to dues in the win32 handmade dot CPP

57
00:02:24,600 --> 00:02:27,400
that are things that we can't do now because we don't have services

58
00:02:27,400 --> 00:02:28,200
like logging.

59
00:02:28,500 --> 00:02:29,800
But when we build those services in

60
00:02:29,900 --> 00:02:32,000
The platform independent layer, we can go back into win32.

61
00:02:32,000 --> 00:02:32,600
Handmade in.

62
00:02:32,600 --> 00:02:35,100
All those to do is we can just put log calls in there and they'll call

63
00:02:35,100 --> 00:02:36,900
up to the platform independent layer.

64
00:02:37,200 --> 00:02:39,600
So, for the most part, we will be leaving win32, handmade us if you

65
00:02:39,600 --> 00:02:43,300
behind, but we will still bounce back and forth to it as necessary to

66
00:02:43,300 --> 00:02:47,600
kind of pull Services up from there into the platform independent

67
00:02:47,600 --> 00:02:48,100
portion.

68
00:02:49,200 --> 00:02:53,600
So, so let's go ahead.

69
00:02:53,600 --> 00:02:58,000
And if you are, if you have pre-ordered, the source code using

70
00:02:58,000 --> 00:02:59,800
handmade here, adorbs handy-dandy pre-order.

71
00:03:00,000 --> 00:03:00,400
Martin.

72
00:03:00,700 --> 00:03:02,000
You should have gotten a link in your email.

73
00:03:02,000 --> 00:03:04,800
That link contains a zip file which has tons of Zips in it.

74
00:03:04,900 --> 00:03:06,600
Each one corresponds to a day.

75
00:03:06,800 --> 00:03:07,800
We are on day 25.

76
00:03:07,800 --> 00:03:10,400
So you want to unzip day 24 source code.

77
00:03:10,400 --> 00:03:13,800
That is what I am working with right now, and that is what you will be

78
00:03:13,800 --> 00:03:17,100
working with as well, if you are following along at home.

79
00:03:17,100 --> 00:03:23,000
So let's go ahead and bring up the handmade hero source code here.

80
00:03:23,100 --> 00:03:27,800
I never remember what the source tree looks like, somehow, but I have

81
00:03:27,800 --> 00:03:29,700
some notes which I'm going to

82
00:03:30,000 --> 00:03:34,100
Take a look at here just to see what else it was that I wanted to do.

83
00:03:34,300 --> 00:03:34,800
Okay.

84
00:03:35,600 --> 00:03:36,500
Sorry about that.

85
00:03:36,500 --> 00:03:39,100
This this headset is is causing me problems today.

86
00:03:39,100 --> 00:03:45,800
Never have wet years when you're going to do a headphones oriented

87
00:03:45,800 --> 00:03:46,500
broadcast.

88
00:03:46,800 --> 00:03:51,900
Okay, so it looks to me like there's not very much left to do.

89
00:03:52,800 --> 00:03:54,500
They're just a couple little things.

90
00:03:54,700 --> 00:03:57,800
So I think we'll probably do is try to do those couple little things

91
00:03:58,200 --> 00:03:59,900
and then I might go ahead and do

92
00:04:00,000 --> 00:04:01,600
Work of speeding up.

93
00:04:01,600 --> 00:04:05,600
Our replay stuff because I talked about some ways we could make that

94
00:04:05,600 --> 00:04:08,500
faster, especially on a machine, doesn't have an SD drive.

95
00:04:10,800 --> 00:04:12,000
Which this one doesn't.

96
00:04:12,200 --> 00:04:14,600
And so, maybe we'll play around with some things to see if we can't

97
00:04:14,600 --> 00:04:17,500
make that faster because it's a little slow right now on that on the

98
00:04:17,500 --> 00:04:18,100
record.

99
00:04:18,700 --> 00:04:20,500
So, all right.

100
00:04:20,500 --> 00:04:23,500
So the first thing that we want to do is let's just go ahead for the

101
00:04:23,500 --> 00:04:25,600
sake of completeness.

102
00:04:26,100 --> 00:04:29,900
We do think we talked about this a little bit on the forums and it

103
00:04:29,900 --> 00:04:33,600
does seem like for most platforms from what people could could

104
00:04:33,600 --> 00:04:34,200
determine.

105
00:04:34,500 --> 00:04:38,400
We could actually do a fairly cheap call here and most of the time,

106
00:04:38,400 --> 00:04:39,800
get the monitor refresh rate.

107
00:04:39,900 --> 00:04:40,400
That's what people.

108
00:04:40,600 --> 00:04:42,100
Anyway, we're not sure.

109
00:04:42,100 --> 00:04:45,300
So when it comes time to ship this stuff, we're going to have to do

110
00:04:45,400 --> 00:04:48,900
certainly, a more thorough job of like testing it on a number of

111
00:04:48,900 --> 00:04:52,300
platforms to see if we're getting a reasonable one, but when it comes

112
00:04:52,300 --> 00:04:55,100
to shipping to will probably use a different service for syncing with

113
00:04:55,100 --> 00:04:56,100
the vertical, retrace.

114
00:04:56,100 --> 00:04:59,400
Anyway, like, you know, opengl and direct3d will actually be doing

115
00:04:59,400 --> 00:05:00,200
that sink for us.

116
00:05:00,200 --> 00:05:06,400
So we may not even have to care at that point, but I believe monitor

117
00:05:06,400 --> 00:05:09,600
refresh rate queries, we can actually use the one that we avoided

118
00:05:09,600 --> 00:05:10,200
using.

119
00:05:11,600 --> 00:05:12,000
Excuse me.

120
00:05:12,700 --> 00:05:16,400
I believe it's, these are not, this is not, it's the, it's the get

121
00:05:16,400 --> 00:05:17,200
system.

122
00:05:18,500 --> 00:05:24,100
It's like, get system metrics something like this, call that we can

123
00:05:24,100 --> 00:05:27,500
just call and it assuming that it doesn't encounter one of the

124
00:05:27,500 --> 00:05:30,100
conditions where it doesn't know the monitor refresh rate.

125
00:05:30,300 --> 00:05:32,100
Apparently, it will actually return.

126
00:05:32,300 --> 00:05:33,800
And okay, monitor refresh rate.

127
00:05:33,800 --> 00:05:36,800
I believe, I'm not sure if it's actually, I think you know what?

128
00:05:36,800 --> 00:05:38,200
It's like get device caps.

129
00:05:38,200 --> 00:05:40,300
I think was the one we were looking at we

130
00:05:40,600 --> 00:05:41,400
Got it already.

131
00:05:41,400 --> 00:05:44,200
I was just like, it doesn't look like it's going to always return it.

132
00:05:44,200 --> 00:05:45,400
So I was shying away from it.

133
00:05:45,400 --> 00:05:46,500
But apparently it'll be fine.

134
00:05:47,100 --> 00:05:48,000
Yeah, so this is it.

135
00:05:48,000 --> 00:05:50,100
So it's basically get device caps with this V.

136
00:05:50,100 --> 00:05:51,000
Refresh thing.

137
00:05:51,300 --> 00:05:52,200
And this was the part.

138
00:05:52,200 --> 00:05:54,800
I was scared about, but apparently, most of the time this actually

139
00:05:54,800 --> 00:05:55,600
does work.

140
00:05:55,800 --> 00:05:57,300
So since right now, we're hard coding.

141
00:05:57,300 --> 00:05:57,400
It.

142
00:05:57,400 --> 00:05:59,800
It's probably better than nothing to go.

143
00:06:00,000 --> 00:06:01,800
And actually do something real here.

144
00:06:02,000 --> 00:06:04,600
So we can basically say that there's a monitor refresh hurts.

145
00:06:04,700 --> 00:06:07,400
We'll assume it's 60, which is what we were already doing.

146
00:06:07,700 --> 00:06:11,800
But then what we can do is go ahead and call this get device caps on

147
00:06:11,800 --> 00:06:17,600
are on the actual into me on the actual HDC of our window.

148
00:06:17,800 --> 00:06:22,600
And in theory that will at least sometimes assuming we can you know

149
00:06:22,600 --> 00:06:23,900
actually rely on it at all.

150
00:06:24,200 --> 00:06:26,800
At least give us a better monitor refresh in case the amount of

151
00:06:26,800 --> 00:06:28,800
repression something else in Windows actually did know.

152
00:06:29,300 --> 00:06:29,900
So basically

153
00:06:30,000 --> 00:06:32,900
We'll do here is we'll say, all right, we're going to get an impact

154
00:06:32,900 --> 00:06:33,800
which is the V.

155
00:06:33,800 --> 00:06:36,100
Refresh win32.

156
00:06:36,100 --> 00:06:37,900
Refresh rate will see what that is.

157
00:06:38,200 --> 00:06:41,600
If win32 refresh rate is greater than one, basically.

158
00:06:41,600 --> 00:06:43,300
Because we know we might get a 0 or 1.

159
00:06:43,300 --> 00:06:47,400
It's documented as possibly saying that if it's greater than zero or

160
00:06:47,400 --> 00:06:50,900
one, will assume that it actually is giving us a valid value.

161
00:06:50,900 --> 00:06:53,800
Now, whether this is how reliable this is, we don't know.

162
00:06:53,800 --> 00:06:57,800
This is definitely something we would have to, you know, have to spend

163
00:06:57,800 --> 00:06:59,800
more time investigating if we wanted to ship this.

164
00:07:00,000 --> 00:07:02,800
Directly, before again, for prototyping purposes.

165
00:07:02,800 --> 00:07:03,700
We should be okay.

166
00:07:04,600 --> 00:07:09,400
And so from there, we should be able to define the game update hurts.

167
00:07:09,400 --> 00:07:11,300
Let's go ahead and let's see.

168
00:07:11,300 --> 00:07:13,800
Do we have a where do we actually use game update hurts?

169
00:07:14,000 --> 00:07:15,300
Where is that used?

170
00:07:15,700 --> 00:07:19,700
Looks like that is used.

171
00:07:19,800 --> 00:07:21,000
So the game updates hurt.

172
00:07:21,000 --> 00:07:23,300
We're kind of relying on that to be around number.

173
00:07:23,300 --> 00:07:26,800
I don't know how, I don't know how good of an idea that actually is

174
00:07:27,000 --> 00:07:29,300
because if if it can't be divisible by 2.

175
00:07:30,200 --> 00:07:33,000
Almost all the monitor refresh rates are going to be divisible by 2.

176
00:07:33,000 --> 00:07:35,000
So I don't know how much we really care about that.

177
00:07:35,000 --> 00:07:37,200
But you notice like, if we're storing this an integer here, then if

178
00:07:37,200 --> 00:07:40,000
this was going to be fractional, then we'd be in a problem.

179
00:07:40,000 --> 00:07:42,000
Let's say this was 59 hurts, right?

180
00:07:42,000 --> 00:07:44,600
That would be kind of nasty because we're not getting the right result

181
00:07:44,600 --> 00:07:46,100
here for Target seconds per frame.

182
00:07:46,300 --> 00:07:48,800
So that doesn't that doesn't fill me with joy.

183
00:07:49,100 --> 00:07:50,000
I don't love that.

184
00:07:50,000 --> 00:07:53,000
So I'm wondering if maybe we can just go ahead and do something a

185
00:07:53,000 --> 00:07:54,100
little saner here.

186
00:07:55,000 --> 00:07:56,100
Let's see what we've got.

187
00:07:56,100 --> 00:07:59,600
So latency sample count that isn't used anymore.

188
00:07:59,900 --> 00:08:03,000
We can just, we can just ice that I believe latency sample count

189
00:08:03,000 --> 00:08:04,600
entirely right at least.

190
00:08:04,600 --> 00:08:05,200
I think so.

191
00:08:06,300 --> 00:08:10,300
And yeah, so game update hurts.

192
00:08:10,300 --> 00:08:12,200
We can fix with that guy right there as well.

193
00:08:13,400 --> 00:08:18,800
So gaming update Hertz is really only used here in safety B.

194
00:08:19,200 --> 00:08:26,000
So, in safety B, it looks like, I mean, we could just use an actual

195
00:08:26,300 --> 00:08:29,700
and actual real 32 there and just do the math and then

196
00:08:29,800 --> 00:08:31,500
Then cast down, right?

197
00:08:31,500 --> 00:08:35,200
I mean we can certainly do something like this right where we're

198
00:08:35,200 --> 00:08:36,400
actually just doing the math.

199
00:08:36,400 --> 00:08:40,900
It's loading point and then at the very end, we cast it back to some

200
00:08:40,900 --> 00:08:41,799
kind of an integer.

201
00:08:41,799 --> 00:08:43,799
So I feel like that's probably fine.

202
00:08:44,200 --> 00:08:46,900
And then we know that at least will handle fractional values.

203
00:08:46,900 --> 00:08:50,100
Okay, so I'm basically going to say, alright, let's just let's just do

204
00:08:50,100 --> 00:08:50,700
it that way.

205
00:08:50,900 --> 00:08:51,400
Right?

206
00:08:52,000 --> 00:08:55,400
What's interesting is you'll notice game update Hertz is always used

207
00:08:55,400 --> 00:08:57,300
inverted, right?

208
00:08:57,400 --> 00:08:59,700
It's always / game, update hurts.

209
00:09:00,100 --> 00:09:03,200
So it's almost like we probably shouldn't have bothered.

210
00:09:03,200 --> 00:09:06,100
We probably should do it inverted already right?

211
00:09:06,100 --> 00:09:09,500
And just multiply by it since it's always used that way and you know,

212
00:09:09,500 --> 00:09:09,800
whatever.

213
00:09:09,800 --> 00:09:12,600
But yeah, that's like that's not the kind of thing.

214
00:09:12,600 --> 00:09:15,500
You actually need to worry about but it's just kind of caught my eye.

215
00:09:16,500 --> 00:09:16,800
All right.

216
00:09:16,800 --> 00:09:18,800
So anyway, we need our HD see here.

217
00:09:18,800 --> 00:09:23,800
So we need we need to do our get DC of the window and then we can.

218
00:09:24,300 --> 00:09:27,300
So we're going to, we're going to query this for the refresh and

219
00:09:27,300 --> 00:09:28,300
hopefully this will work.

220
00:09:28,300 --> 00:09:29,900
We don't know what we're going to lie step in.

221
00:09:30,000 --> 00:09:32,400
And make sure at least works on our machine, right?

222
00:09:32,400 --> 00:09:34,900
Because we don't even know that yet.

223
00:09:35,500 --> 00:09:38,400
So I'm going to go ahead and just go ahead and do that here.

224
00:09:38,400 --> 00:09:41,400
In fact, I guess we can just pull up pull on bracket that call

225
00:09:41,400 --> 00:09:42,000
directly.

226
00:09:42,500 --> 00:09:47,000
And then all we need to do is clean up anything where this was not

227
00:09:47,000 --> 00:09:48,100
going to?

228
00:09:48,100 --> 00:09:48,300
Yeah.

229
00:09:48,300 --> 00:09:49,300
Okay, so we can wear.

230
00:09:49,300 --> 00:09:52,500
This was not going to work with our with our change of that to a real.

231
00:09:53,300 --> 00:09:54,400
What did I do?

232
00:09:54,500 --> 00:09:54,800
Okay.

233
00:09:54,800 --> 00:09:58,000
I've got a convert this guy to an integer.

234
00:09:58,200 --> 00:09:59,800
So once we do all this math and

235
00:10:00,100 --> 00:10:00,800
A point.

236
00:10:00,900 --> 00:10:05,700
Then we can convert it to an integer and that'll be fine format, this

237
00:10:05,700 --> 00:10:06,600
a little bit better.

238
00:10:07,800 --> 00:10:08,300
Let's see.

239
00:10:08,300 --> 00:10:10,300
And then so the only thing we have to deal with is this guy.

240
00:10:10,400 --> 00:10:11,900
We don't really care about this.

241
00:10:11,900 --> 00:10:14,500
I don't know why I even made it based on game update hurts.

242
00:10:14,500 --> 00:10:16,800
We just need some number of debug time markers.

243
00:10:17,200 --> 00:10:20,400
So basically, we could just say that there are 30 debug time markers

244
00:10:20,400 --> 00:10:20,800
or something.

245
00:10:20,800 --> 00:10:21,100
Right?

246
00:10:21,100 --> 00:10:24,000
I mean, we don't we don't really even care how many there are the last

247
00:10:24,000 --> 00:10:27,100
the last twenty are kept or something like that is fine.

248
00:10:27,100 --> 00:10:29,800
So that should probably be fine and I'm going to just take a

249
00:10:29,900 --> 00:10:33,600
Look and see, and make sure that all that was kosher.

250
00:10:34,400 --> 00:10:35,600
So at least we're still working.

251
00:10:35,600 --> 00:10:39,200
Okay, I want to go ahead and take a look at what that call looks like,

252
00:10:39,200 --> 00:10:40,200
where we get the vertical.

253
00:10:40,200 --> 00:10:41,000
Refresh.

254
00:10:42,800 --> 00:10:43,800
Let's go in here.

255
00:10:44,300 --> 00:10:44,900
There we go.

256
00:10:45,300 --> 00:10:47,200
So, let's see, we get the refresh, d.c.

257
00:10:47,200 --> 00:10:47,800
Back.

258
00:10:48,200 --> 00:10:49,400
We take a look at the refresh rate.

259
00:10:49,400 --> 00:10:50,500
It does return 60.

260
00:10:50,500 --> 00:10:51,500
We release it.

261
00:10:51,800 --> 00:10:53,600
We go ahead and set that model for refresh rate.

262
00:10:53,600 --> 00:10:53,800
Okay?

263
00:10:53,800 --> 00:10:58,200
Game update Hertz is 30, which is what we wanted and everything looks

264
00:10:58,200 --> 00:10:58,600
kosher.

265
00:10:58,600 --> 00:10:59,800
Okay, so that's that.

266
00:11:00,000 --> 00:11:03,300
Fine, no, big deal there, but that seems fine.

267
00:11:03,400 --> 00:11:04,300
So that's good.

268
00:11:06,000 --> 00:11:09,000
I would say taking a look here.

269
00:11:09,000 --> 00:11:15,200
So I'm going to cross that off of our list do do so we got that looks

270
00:11:15,200 --> 00:11:15,900
good.

271
00:11:15,900 --> 00:11:17,100
All this looks good.

272
00:11:17,400 --> 00:11:21,700
So I'm going to introduce a little concept here that I want to do,

273
00:11:21,700 --> 00:11:25,100
which is I realize it may be a little confusing and it probably won't

274
00:11:25,100 --> 00:11:29,000
make very much sense until we get a little further into things by just

275
00:11:29,000 --> 00:11:29,800
want to introduce a

276
00:11:29,900 --> 00:11:33,000
Concept here that will save us some time and it's kind of the way I

277
00:11:33,000 --> 00:11:33,700
like to do things.

278
00:11:33,700 --> 00:11:34,800
It'll save us some time.

279
00:11:35,100 --> 00:11:37,900
It's basically it's sort of one of those.

280
00:11:37,900 --> 00:11:38,900
In my experience.

281
00:11:38,900 --> 00:11:42,300
It is a good idea to have one of these things and have it early so

282
00:11:42,300 --> 00:11:44,900
that you don't have to sort of add it into your code later.

283
00:11:44,900 --> 00:11:48,900
It's just, it's sort of a, a Having learned by doing, kind of a

284
00:11:48,900 --> 00:11:53,300
situation when you are porting, you find that, you tend to need these

285
00:11:53,300 --> 00:11:54,500
things on win32.

286
00:11:54,500 --> 00:11:55,900
You actually don't really need the thing.

287
00:11:55,900 --> 00:11:59,400
I'm about to do typically that much because there's

288
00:12:00,000 --> 00:12:00,800
You can get around it.

289
00:12:00,800 --> 00:12:02,500
But on other platforms that aren't always.

290
00:12:02,800 --> 00:12:05,200
So what I'm going to do is in the platform nonspecific layer.

291
00:12:05,200 --> 00:12:08,100
I'm going to introduce something and you'll just have to take my word

292
00:12:08,100 --> 00:12:11,400
for it, because you won't actually see why this is necessary for a

293
00:12:11,400 --> 00:12:12,100
little while.

294
00:12:12,300 --> 00:12:15,200
I'll just have to kind of tell you why I'm going to kind of tell you

295
00:12:15,200 --> 00:12:18,100
now why it's a good thing to do, and you're just going to take my word

296
00:12:18,100 --> 00:12:18,500
for it.

297
00:12:18,500 --> 00:12:22,700
But basically, what I want to do is introduce something called a

298
00:12:22,700 --> 00:12:24,500
thread context, right?

299
00:12:25,400 --> 00:12:29,200
And what a thread context is is, it's just a handle.

300
00:12:30,000 --> 00:12:35,900
Or an informational structure that's passed along through every

301
00:12:35,900 --> 00:12:37,300
execution chain in the game.

302
00:12:37,700 --> 00:12:41,000
So basically, Whenever I Call something in the game, like we've got

303
00:12:41,000 --> 00:12:44,400
two functions in the game and that may be all that will ever have, but

304
00:12:44,400 --> 00:12:47,900
whenever I call something in the game, the platform layer will pass

305
00:12:48,300 --> 00:12:49,600
this thread context.

306
00:12:50,200 --> 00:12:56,200
It'll just pass that into into whatever calls and right.

307
00:12:56,200 --> 00:12:59,400
Now the thread context will have absolutely nothing in it, right.

308
00:12:59,400 --> 00:12:59,800
Because we have

309
00:13:00,000 --> 00:13:01,600
No idea what that's eaten going to be used for.

310
00:13:01,600 --> 00:13:03,900
Like I said, it's something that you just have to take my word for it.

311
00:13:04,000 --> 00:13:07,700
But basically what will happen is any time that you actually use some

312
00:13:07,700 --> 00:13:09,800
kind of operating system service.

313
00:13:10,600 --> 00:13:13,400
You're going to need to use one of these thread context.

314
00:13:13,400 --> 00:13:17,000
So basically what I want to do is say alright, if you ever call back

315
00:13:17,000 --> 00:13:21,000
into the platform layer at all, you're going to have to use one of

316
00:13:21,000 --> 00:13:22,100
these thread contexts.

317
00:13:22,400 --> 00:13:25,300
And the thread context is essentially like something.

318
00:13:25,300 --> 00:13:28,800
You know, that's going to get passed into these for example, so

319
00:13:28,800 --> 00:13:29,800
whenever you ask

320
00:13:29,900 --> 00:13:33,700
To free file memory or any of this stuff, you always have to pass your

321
00:13:33,700 --> 00:13:34,700
thread context.

322
00:13:35,000 --> 00:13:40,200
And essentially, all this is, is it makes up for the fact that not

323
00:13:40,200 --> 00:13:41,100
every platform.

324
00:13:41,100 --> 00:13:46,000
Does a good job of giving you information that you can use about what

325
00:13:46,000 --> 00:13:49,100
thread you're in when you're running multi-threaded since we haven't

326
00:13:49,100 --> 00:13:50,100
covered multi-threaded.

327
00:13:50,100 --> 00:13:55,900
Like I said, it's a little bit difficult for me to explain why this

328
00:13:55,900 --> 00:13:57,000
actually matters.

329
00:13:57,500 --> 00:14:01,400
But I'll try to do a little bit of that in a second here.

330
00:14:01,400 --> 00:14:04,300
So, all right, let's go ahead and get that compiling.

331
00:14:04,300 --> 00:14:06,900
And then in here, let's see here.

332
00:14:06,900 --> 00:14:08,700
Go ahead and get that in there.

333
00:14:08,900 --> 00:14:12,200
What did I do debug platform B entire file.

334
00:14:12,200 --> 00:14:13,800
Did I not call it thread?

335
00:14:13,800 --> 00:14:15,900
I called it context.

336
00:14:15,900 --> 00:14:16,500
Fantastic.

337
00:14:16,800 --> 00:14:21,600
Nothing like a starting the day off with inconsistent naming always.

338
00:14:21,600 --> 00:14:22,000
A good thing.

339
00:14:22,000 --> 00:14:25,600
Could tell, how absentminded I am when I'm trying to talk a stream at

340
00:14:25,600 --> 00:14:27,500
the same time and just often hard for

341
00:14:27,500 --> 00:14:29,700
for me to focus on the code that I'm writing, makes it kind of

342
00:14:29,700 --> 00:14:30,900
difficult to be honest with you.

343
00:14:31,400 --> 00:14:31,700
All right.

344
00:14:31,700 --> 00:14:35,800
So what we need to do is pass that thread context here again, nothing

345
00:14:35,800 --> 00:14:38,700
is actually happening with it, but we need to pass it.

346
00:14:39,100 --> 00:14:41,700
And so what I'm going to do is just create a dummy thread handle.

347
00:14:41,700 --> 00:14:45,300
Basically, it's just going to be thread context like this and it's

348
00:14:45,300 --> 00:14:46,900
going to have absolutely nothing in it.

349
00:14:46,900 --> 00:14:48,300
Nothing important whatsoever.

350
00:14:48,300 --> 00:14:51,600
Again, did it again really want to call that context for some reason

351
00:14:52,400 --> 00:14:55,600
and then these guys just get that empty handle.

352
00:14:56,200 --> 00:14:57,400
All right, and so what I

353
00:14:57,500 --> 00:14:58,400
What to do here?

354
00:15:00,000 --> 00:15:05,000
Is, I want to introduce this concept, just because the thread context

355
00:15:05,000 --> 00:15:08,300
is, it's basically.

356
00:15:08,500 --> 00:15:11,600
There's a lot of things that happen when you go to start doing

357
00:15:11,600 --> 00:15:16,300
multi-threaded code, where you want to know which thread is, which so

358
00:15:16,300 --> 00:15:19,600
you'll be inside some code, and you'll be doing something and you're

359
00:15:19,600 --> 00:15:21,800
like, this could be made a lot more efficient.

360
00:15:21,800 --> 00:15:25,600
If I had say one buffer per thread that each of these threads could

361
00:15:25,600 --> 00:15:28,500
write into, but unfortunately, I'm in the middle of this code and I

362
00:15:28,500 --> 00:15:29,800
don't know what what

363
00:15:30,000 --> 00:15:32,500
Buffer goes with the thread that I'm in, right?

364
00:15:33,000 --> 00:15:36,300
So there's just these kinds of situations that you get into when

365
00:15:36,300 --> 00:15:38,100
you're in the middle of coding stuff.

366
00:15:38,100 --> 00:15:40,400
That's multi-threaded where you really want.

367
00:15:40,500 --> 00:15:43,600
One thing per thread or you want to know which thread you're in for

368
00:15:43,600 --> 00:15:47,300
some reason and have one thing inside your own code per thread, that

369
00:15:47,300 --> 00:15:48,000
sort of stuff.

370
00:15:48,200 --> 00:15:51,900
And so typically you want to be able to Define like thread indexes and

371
00:15:51,900 --> 00:15:55,600
have pointers to thread specific things in Windows.

372
00:15:55,700 --> 00:15:59,800
If you're not in a dll or well I should say from,

373
00:16:00,000 --> 00:16:06,900
Deal in Windows, most of the time you can get what's called

374
00:16:06,900 --> 00:16:10,500
thread-local storage which will sort of do this process for you.

375
00:16:10,600 --> 00:16:13,800
So that you don't need that thread context handle, but there are other

376
00:16:13,800 --> 00:16:17,100
platforms where that's not true, and depending on the circumstances,

377
00:16:17,100 --> 00:16:19,600
you may have may not really want to do it in Windows, either, and

378
00:16:19,600 --> 00:16:20,300
blah, blah, blah.

379
00:16:20,600 --> 00:16:25,700
So, really, I'm just setting this up sort of as a predictive thing

380
00:16:25,700 --> 00:16:29,500
where I just want to get in the habit of having the game code, always

381
00:16:29,500 --> 00:16:29,800
know.

382
00:16:29,900 --> 00:16:34,500
No, sort of a thread handle for itself that it can use and it does

383
00:16:34,500 --> 00:16:36,800
take a little bit of overhead to do this because it does have to get

384
00:16:36,800 --> 00:16:37,800
passed around.

385
00:16:38,100 --> 00:16:43,200
But on the whole I find that it's just easier to do that than to deal

386
00:16:43,200 --> 00:16:44,100
with the Alternatives.

387
00:16:44,100 --> 00:16:45,800
So that's the way I'm going to choose to do it.

388
00:16:45,800 --> 00:16:46,500
In this particular case.

389
00:16:46,500 --> 00:16:47,700
I'm just introducing this now.

390
00:16:48,200 --> 00:16:48,900
So that's it.

391
00:16:48,900 --> 00:16:50,400
We don't have to do anything with it.

392
00:16:50,400 --> 00:16:50,600
Now.

393
00:16:50,600 --> 00:16:54,300
I just want to get used to that and get used to kind of having that

394
00:16:54,500 --> 00:16:58,400
get passed through because I would like to be able to use that for a

395
00:16:58,400 --> 00:16:59,500
bunch of different things.

396
00:17:01,100 --> 00:17:04,700
That's all there is for that and the other thing that I wanted to do

397
00:17:04,900 --> 00:17:05,900
again just miscellaneous.

398
00:17:05,900 --> 00:17:10,800
Clean up is one thing that I did notice is we don't pass any Mouse

399
00:17:10,800 --> 00:17:15,700
input to the game and we don't need that for any particular reason

400
00:17:15,700 --> 00:17:18,800
because we won't really be supporting them the Mouse as a controller

401
00:17:18,800 --> 00:17:21,099
like you'll be playing with the keyboard because it's kind of more of

402
00:17:21,099 --> 00:17:22,700
a digitally kind of game.

403
00:17:23,300 --> 00:17:26,099
So the mouse isn't really probably going to be appropriate, but what I

404
00:17:26,099 --> 00:17:29,800
would like to do in case we want to develop some debug over.

405
00:17:29,900 --> 00:17:33,000
Les systems that might be more appropriate for using with the mouse or

406
00:17:33,000 --> 00:17:35,900
if we want to use the mouse to like move elements in some kind of an

407
00:17:35,900 --> 00:17:37,500
editing mode, or anything like that.

408
00:17:37,900 --> 00:17:42,100
What I would like to do is essentially introduced here, just some

409
00:17:42,100 --> 00:17:44,400
mouse debug stuff, right?

410
00:17:44,800 --> 00:17:51,100
So, you know something like, you know, a mouse buttons flag and a

411
00:17:51,100 --> 00:17:56,000
mouse X Mouse, why sort of a situation, just something like that where

412
00:17:56,000 --> 00:17:59,400
we can sort of pass the mouse information.

413
00:18:00,000 --> 00:18:00,500
Game.

414
00:18:04,000 --> 00:18:06,000
And it can be super janky and awful.

415
00:18:07,300 --> 00:18:10,100
It doesn't even matter because it's only going to be used for our

416
00:18:10,100 --> 00:18:11,200
debugging purposes.

417
00:18:11,800 --> 00:18:15,900
But you know, I just kind of would like to have something like that in

418
00:18:15,900 --> 00:18:19,400
there and maybe we'll use the half transition count thing.

419
00:18:19,400 --> 00:18:20,800
I don't know if that's a good idea.

420
00:18:21,200 --> 00:18:23,500
Maybe we'll use the half transition count thing for that since

421
00:18:23,500 --> 00:18:24,400
everything else uses it.

422
00:18:24,400 --> 00:18:29,500
So maybe we'll do something like this where we do mouse buttons and we

423
00:18:29,500 --> 00:18:32,900
say, okay, you know how many Mouse buttons are there on this thing?

424
00:18:32,900 --> 00:18:35,100
I think there's five on this thing.

425
00:18:35,200 --> 00:18:36,700
I don't know if Matt mouse mouse button.

426
00:18:36,900 --> 00:18:39,900
Many Mouse mice have so many buttons these days.

427
00:18:40,200 --> 00:18:42,700
And then, of course, we've got a mousy I suppose as well, which is

428
00:18:42,700 --> 00:18:43,900
that little mouse wheel thing.

429
00:18:44,500 --> 00:18:47,600
And so I just want to create that state there have it so that the game

430
00:18:47,600 --> 00:18:48,900
can get it.

431
00:18:49,300 --> 00:18:54,200
And also, let's go ahead and just go drop in, you know, something

432
00:18:54,200 --> 00:18:57,600
where where we can see if we're actually passing that correctly, and

433
00:18:57,600 --> 00:18:59,400
then I'll pass it correctly in win32.

434
00:19:00,000 --> 00:19:03,000
So we have that little, we have the render Player thing, right?

435
00:19:03,000 --> 00:19:04,500
We have a render player call.

436
00:19:06,100 --> 00:19:06,700
Let's get that up.

437
00:19:06,800 --> 00:19:07,800
Above my head.

438
00:19:08,300 --> 00:19:11,400
And so maybe we'll just go ahead and say let's render where we're

439
00:19:11,400 --> 00:19:13,400
getting told, the mouse is right.

440
00:19:13,500 --> 00:19:19,000
So we have a mouse X in the input layer, and we have a mouse why in

441
00:19:19,000 --> 00:19:19,900
the input layer.

442
00:19:20,300 --> 00:19:22,500
So let's just go ahead and do that.

443
00:19:23,100 --> 00:19:28,400
So that we can see that we have that mouse cursor position and then I

444
00:19:28,400 --> 00:19:32,600
will go in should compile now, I think, yeah, I will go in and just

445
00:19:32,600 --> 00:19:36,400
add the minimum necessary nonsense to get.

446
00:19:36,900 --> 00:19:37,500
The mouse out.

447
00:19:37,500 --> 00:19:41,800
So basically in year, if we only care about where the mouse is right

448
00:19:41,800 --> 00:19:44,100
before we call it really?

449
00:19:44,100 --> 00:19:44,400
Okay.

450
00:19:44,400 --> 00:19:48,100
So when we process our like xinput stuff, we do our controller and put

451
00:19:48,100 --> 00:19:49,600
stuff we can do it right here.

452
00:19:49,900 --> 00:19:51,500
We have that new input pointer.

453
00:19:51,600 --> 00:19:51,900
Right?

454
00:19:51,900 --> 00:19:56,700
We have we have new input and we just want to go ahead and set these

455
00:19:56,700 --> 00:19:59,000
values, all these values here.

456
00:19:59,500 --> 00:20:02,900
So that'd be mousex new input Mouse.

457
00:20:02,900 --> 00:20:05,500
Why new input Mouse Z.

458
00:20:05,500 --> 00:20:06,700
I don't know if we can get

459
00:20:06,800 --> 00:20:10,200
get in the way that I'm about to do the other ones, but if we don't

460
00:20:10,200 --> 00:20:12,700
support Mouse wheel right now, I don't really care.

461
00:20:13,100 --> 00:20:16,500
That doesn't actually matter to me very much and then we'll at least

462
00:20:16,500 --> 00:20:17,900
track those.

463
00:20:17,900 --> 00:20:22,700
Those those three buttons as well, there or buttons, as I

464
00:20:22,700 --> 00:20:23,700
occasionally, say them.

465
00:20:24,000 --> 00:20:25,000
Nice spelling there.

466
00:20:25,000 --> 00:20:25,400
Casey.

467
00:20:26,000 --> 00:20:30,900
So what we can do, if we just want to, if all we need is just a mouse

468
00:20:30,900 --> 00:20:31,400
information.

469
00:20:31,400 --> 00:20:35,900
There's actually a get cursor pause function in Windows that will

470
00:20:35,900 --> 00:20:36,700
basically tell you.

471
00:20:36,800 --> 00:20:40,000
Where the mouse is at any given time, it's pretty trivial to use,

472
00:20:40,000 --> 00:20:40,500
right?

473
00:20:40,500 --> 00:20:40,800
Basically.

474
00:20:40,800 --> 00:20:45,100
What you do is you call This And the main cursor, whatever the main

475
00:20:45,100 --> 00:20:48,700
Mouse is on the system, wherever, you know, this little thing is that

476
00:20:48,700 --> 00:20:50,000
I'm wiggling around right now.

477
00:20:50,600 --> 00:20:54,900
When you call that, you can just get wherever it thinks that thing is,

478
00:20:55,500 --> 00:20:59,800
so basically, we can say, this is the mouse location.

479
00:21:00,300 --> 00:21:04,500
We can we can get that and then we don't even care if this thing fails

480
00:21:04,500 --> 00:21:05,000
or not.

481
00:21:05,000 --> 00:21:07,200
Literally does not matter to us because this is strictly debug

482
00:21:07,200 --> 00:21:07,900
information.

483
00:21:08,300 --> 00:21:12,100
So we can then take a look at this point structure that comes back and

484
00:21:12,100 --> 00:21:13,700
it gives us this long X and Y.

485
00:21:13,700 --> 00:21:18,000
Now, the problem is if we use this directly, well, you know what?

486
00:21:18,000 --> 00:21:21,400
Let me, let me show you what happens if we use it directly so that

487
00:21:21,400 --> 00:21:23,500
you'll understand exactly what I mean.

488
00:21:23,700 --> 00:21:25,900
So I won't have to give this explanation blind.

489
00:21:25,900 --> 00:21:28,500
You can actually see what actually happens.

490
00:21:28,900 --> 00:21:29,800
So, if

491
00:21:30,000 --> 00:21:35,400
If I go ahead and run this, you'll note that we are getting that

492
00:21:35,400 --> 00:21:35,700
Mouse.

493
00:21:35,700 --> 00:21:38,400
You can see that we're getting that Mouse position, but you'll notice

494
00:21:38,400 --> 00:21:39,600
that it's wrong, right?

495
00:21:39,600 --> 00:21:41,200
You see how that's kind of wrong.

496
00:21:42,200 --> 00:21:43,900
So what's going on there, right?

497
00:21:44,200 --> 00:21:48,200
Well, what's going on, is that is when we call that get cursor, that

498
00:21:48,200 --> 00:21:49,700
get cursor position function.

499
00:21:50,000 --> 00:21:55,400
It gives us back the cursor position on the screen, but our window our

500
00:21:55,400 --> 00:21:57,800
coordinate system actually that we're drawing on.

501
00:21:57,800 --> 00:21:59,700
Although we haven't covered coordinate systems much yet.

502
00:21:59,700 --> 00:21:59,900
We're

503
00:22:00,000 --> 00:22:02,200
Talk about that a lot when you get to the renderer, but if you think

504
00:22:02,200 --> 00:22:06,600
about it, if we say the point 0 0, we're talking about this point

505
00:22:06,600 --> 00:22:09,300
right here, but on the screen 00's up there.

506
00:22:09,300 --> 00:22:12,500
So you can see it lines up exactly where if I move the mouse all the

507
00:22:12,500 --> 00:22:14,100
way to the top like that.

508
00:22:14,800 --> 00:22:16,200
Now we're in the upper corner.

509
00:22:16,400 --> 00:22:20,600
So what we need to do is we need to find a way to sort of map that

510
00:22:20,600 --> 00:22:23,900
cursor position into our Windows coordinate system because this is in

511
00:22:23,900 --> 00:22:26,200
the wrong coordinate system and coordinate systems.

512
00:22:26,200 --> 00:22:27,700
Like I said, we'll talk about a lot.

513
00:22:27,700 --> 00:22:29,600
So if you don't know what those are and your little lost right now,

514
00:22:29,600 --> 00:22:29,700
it's

515
00:22:29,900 --> 00:22:30,100
Ali.

516
00:22:30,100 --> 00:22:31,100
Okay, just ignore it.

517
00:22:31,400 --> 00:22:33,700
We are going to talk about this a lot later on when we start

518
00:22:33,700 --> 00:22:35,500
implementing our coordinate system stuff.

519
00:22:35,500 --> 00:22:37,900
So you will have plenty of chance to kind of understand that.

520
00:22:37,900 --> 00:22:40,200
And this is not you an important part of the code that were writing it

521
00:22:40,200 --> 00:22:40,300
now.

522
00:22:40,300 --> 00:22:42,900
So you can literally ignore this entirely.

523
00:22:42,900 --> 00:22:47,000
If you want to, I believe there is something called screen to client.

524
00:22:47,000 --> 00:22:50,600
Remember the name correctly screen to client will basically do that

525
00:22:50,600 --> 00:22:52,300
mapping the exact mapping that we want.

526
00:22:52,400 --> 00:22:55,500
You pass it a window and you give it the point and it just Maps it

527
00:22:55,500 --> 00:22:57,900
from the screen into your client Rec Space.

528
00:22:57,900 --> 00:22:59,800
Now, you remember, we did that, get client.

529
00:23:00,000 --> 00:23:03,300
Thing that basically says, what our window rectangle is.

530
00:23:03,400 --> 00:23:06,400
Well, it's literally that mapping, it Maps it into that rectangle,

531
00:23:06,400 --> 00:23:08,000
which is exactly what we want.

532
00:23:08,200 --> 00:23:08,500
Right?

533
00:23:08,500 --> 00:23:12,400
So we can just say, hey, get the screen to client for this window that

534
00:23:12,400 --> 00:23:15,200
we've got and map it for us, please.

535
00:23:15,300 --> 00:23:15,800
Right?

536
00:23:16,300 --> 00:23:16,700
Oops.

537
00:23:17,200 --> 00:23:17,500
Missing.

538
00:23:17,500 --> 00:23:18,300
Yeah, /.

539
00:23:18,300 --> 00:23:21,000
They're all the sudden so that will correct it.

540
00:23:21,000 --> 00:23:23,500
And now you notice that it is right on target.

541
00:23:23,500 --> 00:23:23,600
Now.

542
00:23:23,600 --> 00:23:27,000
Remember, we're drawing our rectangle as if the upper left corner is

543
00:23:27,000 --> 00:23:27,500
the position.

544
00:23:27,500 --> 00:23:28,500
So that's why it's there.

545
00:23:28,500 --> 00:23:29,800
You know, we if we were actually doing a

546
00:23:29,900 --> 00:23:32,800
Oscar sir, we might want to do an arrow or we might want to like

547
00:23:32,800 --> 00:23:34,700
center of the rectangle over it or something like that.

548
00:23:34,700 --> 00:23:37,700
But for now, we can tell that we're getting the input properly.

549
00:23:37,800 --> 00:23:41,200
So really, all we need to know now, is we need to know whether or not

550
00:23:41,200 --> 00:23:43,400
we had a mouse button up or down.

551
00:23:44,100 --> 00:23:47,500
So the way we could do that if we wanted to is we can sort of do that

552
00:23:47,500 --> 00:23:53,600
in in line with that with when we sort of do all that keyboard

553
00:23:53,600 --> 00:23:55,100
processing, you know, this sort of stuff.

554
00:23:55,600 --> 00:23:59,000
So what we could do there is, we could say, alright, let's go ahead

555
00:23:59,000 --> 00:23:59,800
and process.

556
00:24:00,000 --> 00:24:02,200
Up Mouse down messages here, right?

557
00:24:05,400 --> 00:24:07,700
We could I think we also could get them.

558
00:24:07,800 --> 00:24:08,900
We might be able to just kind of

559
00:24:11,700 --> 00:24:13,100
I'm so I'm so torn.

560
00:24:14,800 --> 00:24:15,400
I'm so torn.

561
00:24:15,400 --> 00:24:16,800
It depends on how we want.

562
00:24:16,800 --> 00:24:19,100
How robust we actually want our Mouse processing to be.

563
00:24:19,100 --> 00:24:20,000
Since it's just debug.

564
00:24:20,000 --> 00:24:24,400
I'm tempted to not even bother and maybe just see if, if we're fine.

565
00:24:24,900 --> 00:24:26,600
Basically, I'm tempted here.

566
00:24:26,600 --> 00:24:30,400
Ladies and gentlemen, what I am tempted to do, I will tell you, I am

567
00:24:30,400 --> 00:24:33,100
tempted to just go ahead and just query it straight away.

568
00:24:34,700 --> 00:24:35,000
Right?

569
00:24:35,000 --> 00:24:35,500
Right in here.

570
00:24:35,500 --> 00:24:39,400
And just, and just see how it's

571
00:24:42,900 --> 00:24:43,300
All right.

572
00:24:43,400 --> 00:24:44,300
I think I'm going to do that.

573
00:24:44,300 --> 00:24:47,000
So I believe this is this is crazy.

574
00:24:47,000 --> 00:24:48,800
You know, don't ask me why I know this stuff.

575
00:24:48,900 --> 00:24:53,400
Hey, it's a, you know, you wish that your brain didn't even have this

576
00:24:53,400 --> 00:24:55,700
information in it because it's just so ridiculous that I even know

577
00:24:55,700 --> 00:24:56,000
this stuff.

578
00:24:56,000 --> 00:25:00,100
So, basically, there's a function that gets the state of the keyboard

579
00:25:00,200 --> 00:25:04,000
for you and it's the state of the keyboard as of your last message

580
00:25:04,000 --> 00:25:05,400
that you pulled off of the message queue.

581
00:25:05,400 --> 00:25:07,000
Because Windows tracks that for you,

582
00:25:08,100 --> 00:25:10,600
And so, you may be asking, why would that matter at all?

583
00:25:11,200 --> 00:25:14,400
Why would we want to do a get key State call?

584
00:25:14,600 --> 00:25:16,000
And you can see that it Returns.

585
00:25:16,000 --> 00:25:19,100
The high-order bit is set at the key is down that the higher order,

586
00:25:21,500 --> 00:25:22,700
bit is not set.

587
00:25:23,400 --> 00:25:25,300
Then it's not down and it's a short.

588
00:25:25,300 --> 00:25:26,300
So it's 16 bits.

589
00:25:26,400 --> 00:25:29,100
So, basically, we could use this to see whether keys are up or down,

590
00:25:29,100 --> 00:25:32,400
and you may be saying, why would you care about that Casey?

591
00:25:32,400 --> 00:25:34,700
Because we are not looking to keep re looking at the mouse.

592
00:25:35,100 --> 00:25:37,400
Well, if I remember,

593
00:25:37,500 --> 00:25:42,500
Directly and I sadly, I think I do, remember, collect correctly.

594
00:25:43,400 --> 00:25:48,900
You can actually ask for the mouse cursor, VK code.

595
00:25:48,900 --> 00:25:52,800
So, basically, if we do something like, look at the VK Code table,

596
00:25:53,500 --> 00:25:57,200
which I assume I can just look at here, virtual key codes and just

597
00:25:57,200 --> 00:25:58,400
typing any VK in there.

598
00:25:58,900 --> 00:26:00,200
There it is, right.

599
00:26:00,200 --> 00:26:01,700
This is exactly what I'm talking about.

600
00:26:01,800 --> 00:26:07,300
You see, those vkl button, vkm button, you can ask for those as if

601
00:26:07,400 --> 00:26:10,900
If you were asking for a key so I can literally go through here and

602
00:26:10,900 --> 00:26:12,000
ask for the R button.

603
00:26:12,000 --> 00:26:16,500
The M button and these X buttons which are those extended buttons.

604
00:26:17,000 --> 00:26:21,200
X button 1, x button to I can ask for those as if I'm asking for keys.

605
00:26:21,200 --> 00:26:24,800
I can ask them at any time and it will tell me whether or not they're

606
00:26:24,800 --> 00:26:25,400
down.

607
00:26:26,000 --> 00:26:28,600
So, you know, let's just do that.

608
00:26:29,400 --> 00:26:31,700
Let's just go ahead and do that.

609
00:26:32,000 --> 00:26:35,500
I don't actually remember, we think we have a utility call here.

610
00:26:36,100 --> 00:26:37,400
That'll do this sort of weird.

611
00:26:39,800 --> 00:26:42,700
Stuff for us that we needed to do for our for our cycle counts.

612
00:26:43,600 --> 00:26:45,500
So where was that guy?

613
00:26:45,800 --> 00:26:50,200
It was to Due Process keyboard message.

614
00:26:50,600 --> 00:26:54,700
This, this is actually I think all we really need right?

615
00:26:54,900 --> 00:26:56,700
Because we're sort of treating this, right?

616
00:26:56,800 --> 00:26:59,500
Just like a keyboard message so I can just call this.

617
00:27:00,400 --> 00:27:02,900
And it'll do exactly what we want.

618
00:27:02,900 --> 00:27:03,400
Right?

619
00:27:03,700 --> 00:27:04,700
We can just Loops.

620
00:27:04,900 --> 00:27:06,200
That's, that's great.

621
00:27:06,800 --> 00:27:08,000
We can just just do this.

622
00:27:08,000 --> 00:27:08,600
I think.

623
00:27:09,100 --> 00:27:13,300
And then and then use that this get key state, for whatever, the

624
00:27:13,300 --> 00:27:14,000
button is.

625
00:27:14,400 --> 00:27:17,100
And, and it with that, with that Top Value.

626
00:27:17,200 --> 00:27:20,800
And I believe they said that it was, it was a short, right?

627
00:27:20,800 --> 00:27:24,700
So the high bit is going to be one shifted up by 15 if I understand

628
00:27:24,700 --> 00:27:25,900
the documentation correctly.

629
00:27:26,400 --> 00:27:29,100
So that's that's like, all we really need to do.

630
00:27:29,300 --> 00:27:29,800
I think

631
00:27:30,300 --> 00:27:31,200
Let's find out.

632
00:27:31,700 --> 00:27:37,300
Let's find out L button, M button, R button, x button, 1 and x button

633
00:27:37,300 --> 00:27:40,300
to will be in there.

634
00:27:40,800 --> 00:27:42,700
That'll be lovely.

635
00:27:42,700 --> 00:27:43,500
I suppose.

636
00:27:44,100 --> 00:27:49,800
And I think in theory, that is it, let me see if that's true.

637
00:27:49,800 --> 00:27:52,700
New input mouse mouse, buttons is not.

638
00:27:52,700 --> 00:27:53,800
A member of new input.

639
00:27:53,800 --> 00:27:54,900
Is that true?

640
00:27:54,900 --> 00:27:56,000
Are you lying to me?

641
00:27:56,300 --> 00:27:57,600
I doubt you are, you're a compiler.

642
00:27:57,600 --> 00:27:59,600
You don't often lie, although, sometimes you do.

643
00:28:00,600 --> 00:28:01,200
You never know.

644
00:28:01,600 --> 00:28:03,400
So game and put Mouse.

645
00:28:03,400 --> 00:28:05,500
Oh, well, if it is if you spell it wrong.

646
00:28:06,000 --> 00:28:06,700
There you go.

647
00:28:07,200 --> 00:28:07,500
All right.

648
00:28:07,500 --> 00:28:10,600
So I think that's literally all we need to do to process that.

649
00:28:12,000 --> 00:28:12,300
Yeah.

650
00:28:12,400 --> 00:28:15,000
I don't think there's really much else we have to do, and we've got to

651
00:28:15,000 --> 00:28:18,600
do here if you ever want support Mouse wheel, which I don't know.

652
00:28:18,600 --> 00:28:21,500
We don't really have zooming in this game because the 2D games so we

653
00:28:21,500 --> 00:28:23,700
probably don't really need the mouse wheel for anything.

654
00:28:23,700 --> 00:28:26,400
But we found out we did, we would be sad because we're not supporting

655
00:28:26,400 --> 00:28:26,600
it.

656
00:28:27,100 --> 00:28:27,600
All right.

657
00:28:27,600 --> 00:28:29,800
So what we need now is just some way to

658
00:28:29,900 --> 00:28:31,200
See if those are working.

659
00:28:31,300 --> 00:28:36,100
Let's go ahead and again, leverage our render player function here.

660
00:28:36,100 --> 00:28:37,800
When you can rent, you'll see this.

661
00:28:37,800 --> 00:28:41,600
This is this is just how programming Works to, it's kind of cool.

662
00:28:42,800 --> 00:28:46,200
Soon, we'll start to be having a lot of functions that we can reuse.

663
00:28:46,200 --> 00:28:49,300
We haven't really gotten to that point yet, but we're gonna be there

664
00:28:49,300 --> 00:28:49,800
very shortly.

665
00:28:49,800 --> 00:28:52,100
Once we start building renderer tools and all these other tools and

666
00:28:52,100 --> 00:28:52,600
it's kind of nice.

667
00:28:52,600 --> 00:28:56,300
Once you have one thing working it builds on itself so quickly like

668
00:28:56,300 --> 00:28:59,200
before we had really, no way to indicate anything and now we can just

669
00:28:59,200 --> 00:29:04,500
call this one function that draws a rectangle from zooming and we can

670
00:29:04,500 --> 00:29:08,600
essentially use that function to do all sorts of other stuff.

671
00:29:08,600 --> 00:29:10,900
So right, for example, I can do something where I just say.

672
00:29:11,100 --> 00:29:12,400
All right Mouse,

673
00:29:12,600 --> 00:29:16,000
Tunes 0 and downright.

674
00:29:16,000 --> 00:29:17,800
I think that's what we have as our thing.

675
00:29:18,000 --> 00:29:19,300
I can just do that.

676
00:29:19,300 --> 00:29:23,000
And see I should see a rectangle happen.

677
00:29:23,100 --> 00:29:23,400
Boo.

678
00:29:23,700 --> 00:29:24,300
What did I do?

679
00:29:25,200 --> 00:29:28,500
New state ended down is not equal to is down.

680
00:29:31,200 --> 00:29:31,700
Okay.

681
00:29:31,700 --> 00:29:33,600
So that's our assertion there.

682
00:29:34,300 --> 00:29:35,300
I guess, I guess.

683
00:29:35,300 --> 00:29:38,800
I don't actually know if this will work then, do we do we, because we

684
00:29:38,800 --> 00:29:39,600
don't.

685
00:29:39,900 --> 00:29:40,400
Okay.

686
00:29:43,600 --> 00:29:45,600
We don't send this guy toggles.

687
00:29:47,600 --> 00:29:51,000
So, this would still yeah this, this, this.

688
00:29:52,800 --> 00:29:55,600
So, I wonder if I just want to make this function, you see what

689
00:29:55,600 --> 00:29:56,300
happened there.

690
00:29:57,000 --> 00:29:58,200
What happened was?

691
00:29:58,400 --> 00:29:59,800
We were previously guarantee.

692
00:30:00,000 --> 00:30:03,700
Essentially, that we always handed.

693
00:30:03,700 --> 00:30:05,900
This guy is down.

694
00:30:05,900 --> 00:30:08,100
Not as down, is down, not as down.

695
00:30:08,100 --> 00:30:11,100
We would never hand it like to is Downs or two is UPS in a row because

696
00:30:11,100 --> 00:30:12,600
we are processing incoming messages.

697
00:30:12,900 --> 00:30:16,600
I think what I'd rather do here because I want to make this more

698
00:30:16,700 --> 00:30:18,300
robust so I can just throw it, whatever.

699
00:30:18,300 --> 00:30:20,000
This current state isn't have it work.

700
00:30:20,500 --> 00:30:24,800
I think what I want to do is kind of just say, you know, if it's not

701
00:30:24,800 --> 00:30:28,200
equal, then do the processing and that just will just work at that

702
00:30:28,200 --> 00:30:29,000
point, right?

703
00:30:29,400 --> 00:30:29,900
Because that

704
00:30:30,000 --> 00:30:31,200
We can use it for more things.

705
00:30:31,200 --> 00:30:32,000
And I don't know.

706
00:30:32,000 --> 00:30:34,200
I feel like that's just going to be more what we're going to want, so

707
00:30:34,200 --> 00:30:35,900
I can throw stuff at it and it just works.

708
00:30:36,500 --> 00:30:37,700
So you see that up in the corner.

709
00:30:37,700 --> 00:30:40,800
You see that guy there, that's showing us that the button is down, and

710
00:30:40,800 --> 00:30:43,500
pushing the button up, down, up, down, up, down.

711
00:30:43,500 --> 00:30:44,800
So, that's totally good.

712
00:30:44,900 --> 00:30:46,500
Let's go ahead and real quickly.

713
00:30:46,800 --> 00:30:49,300
Drop a for, I'm gonna drop a 4 on this.

714
00:30:49,300 --> 00:30:52,000
Yo, let's go ahead and whip out that for Loop.

715
00:30:52,200 --> 00:30:56,100
Everyone knows how much we love a for Loop button Index, right?

716
00:30:56,100 --> 00:30:58,700
Because I wrote this once, no, need to write it again.

717
00:30:58,900 --> 00:30:59,800
Just write it once.

718
00:31:00,000 --> 00:31:01,800
Raptor Loop in there, right?

719
00:31:01,900 --> 00:31:06,900
Let's go ahead and loop over all of the ones, right?

720
00:31:06,900 --> 00:31:08,300
That are that are in this array.

721
00:31:08,500 --> 00:31:11,400
This mouse buttons are a, I can just say for everything in that array.

722
00:31:11,500 --> 00:31:13,700
However, many there are going to do one for each of it.

723
00:31:13,800 --> 00:31:17,600
And then why not go ahead and add something.

724
00:31:17,600 --> 00:31:21,700
Let's say 20 times the button index to just move it over.

725
00:31:21,700 --> 00:31:26,000
So I'm just going to move the move where I render over by 20 pixels

726
00:31:26,000 --> 00:31:29,100
every time we increment that button count, right?

727
00:31:29,600 --> 00:31:29,800
If we

728
00:31:29,900 --> 00:31:30,300
Go.

729
00:31:30,600 --> 00:31:34,100
There's there's our first three buttons left middle, right?

730
00:31:34,200 --> 00:31:36,200
There's our 2 X buttons on the side.

731
00:31:36,200 --> 00:31:36,800
There we go.

732
00:31:37,500 --> 00:31:41,000
Mouse input done completely finished.

733
00:31:42,100 --> 00:31:43,200
So that's always good.

734
00:31:43,200 --> 00:31:44,600
Can I hold them all down at once?

735
00:31:45,200 --> 00:31:45,400
Yeah.

736
00:31:45,400 --> 00:31:45,800
There we go.

737
00:31:45,900 --> 00:31:46,900
It's hard to do on my mouse.

738
00:31:47,500 --> 00:31:48,700
I don't have like, you know why?

739
00:31:49,000 --> 00:31:50,900
I don't have some kind of crazy gaming mouse.

740
00:31:51,000 --> 00:31:53,400
I need one of those mice where you put like weights in them.

741
00:31:53,400 --> 00:31:56,100
So your mouse is like totally perfectly counterbalanced.

742
00:31:56,400 --> 00:31:57,900
That's the way you get the high score as yo,

743
00:32:00,600 --> 00:32:02,500
Like who uses a mouse without weights in it?

744
00:32:02,800 --> 00:32:03,700
It's ridiculous.

745
00:32:04,700 --> 00:32:06,900
Come on, I'm totally behind the times.

746
00:32:07,000 --> 00:32:09,200
Alright, so that's all we really needed for mice.

747
00:32:09,700 --> 00:32:11,700
Mice has nice Mouse.

748
00:32:11,700 --> 00:32:15,800
However, you want to say that, debug mouse cursor, done, and I'll see

749
00:32:15,800 --> 00:32:18,100
anything else on this list to be honest with you.

750
00:32:18,300 --> 00:32:19,900
So I think that's basically it.

751
00:32:20,000 --> 00:32:20,600
So,

752
00:32:22,500 --> 00:32:23,300
There we go.

753
00:32:24,400 --> 00:32:28,700
I'm going to go ahead and slam in the slightly potentially more

754
00:32:28,700 --> 00:32:35,700
optimal version of the Replay code because I don't really know why

755
00:32:35,700 --> 00:32:38,300
because just because some people were nervous about how long it took.

756
00:32:38,600 --> 00:32:41,500
And so we might as well spend a little bit of time since it's not

757
00:32:41,500 --> 00:32:46,000
particularly difficult, basically, using all of the crazy, huge amount

758
00:32:46,000 --> 00:32:51,700
of system resources that we have now, to speed it up because I mean,

759
00:32:51,700 --> 00:32:52,200
hey, if you're going

760
00:32:52,300 --> 00:32:55,200
Have machines, you know, this machine, I don't even know how much

761
00:32:55,200 --> 00:32:56,400
physical memory this thing has.

762
00:32:57,000 --> 00:32:57,700
Let's see.

763
00:32:57,900 --> 00:32:59,900
So this thing has

764
00:33:02,100 --> 00:33:04,700
Why so total so I guess that's telling me we have.

765
00:33:04,700 --> 00:33:06,100
12 gigabytes of memory.

766
00:33:06,800 --> 00:33:08,700
Is that is that what we want to say there?

767
00:33:08,900 --> 00:33:10,100
Let's say that that's true.

768
00:33:10,400 --> 00:33:14,200
So if we have 12 gigabytes of memory, and we're only taking one get so

769
00:33:14,200 --> 00:33:14,500
yeah.

770
00:33:14,500 --> 00:33:18,300
So we can we can just abuse the physical memory in this machine.

771
00:33:18,300 --> 00:33:20,100
We can just, we can, you know, what?

772
00:33:21,900 --> 00:33:22,800
I think it's time.

773
00:33:22,900 --> 00:33:26,000
I was going to save this for the right time, but the right time, maybe

774
00:33:26,000 --> 00:33:26,500
now.

775
00:33:30,800 --> 00:33:33,000
I think it's time to get piggy.

776
00:33:33,300 --> 00:33:34,000
That's what I think.

777
00:33:34,000 --> 00:33:37,800
I think it's time to just like be a total pig and just use all the

778
00:33:37,800 --> 00:33:41,000
memory in this machine because it's their right.

779
00:33:41,500 --> 00:33:44,600
So I don't see any reason why we shouldn't just go to town.

780
00:33:45,400 --> 00:33:49,200
It seems like if you've got the pig hat on, you know, nothing's gonna

781
00:33:49,200 --> 00:33:49,600
stop us.

782
00:33:49,600 --> 00:33:54,800
So let's just say, let's just go ahead and say because we can that

783
00:33:54,800 --> 00:33:59,800
what we're going to do here is we are going to create

784
00:34:00,400 --> 00:34:03,600
Backing stores for all of this stuff, right?

785
00:34:03,600 --> 00:34:07,900
We're just going to go ahead and create backing stores for for this

786
00:34:08,400 --> 00:34:09,400
game memory block.

787
00:34:09,600 --> 00:34:12,199
So we'll do that one way first and then we'll do it.

788
00:34:12,400 --> 00:34:15,699
We'll do it in a slightly different way immediately thereafter.

789
00:34:15,800 --> 00:34:19,900
So what I'm going to do is I'm going to say that we have a particular

790
00:34:20,300 --> 00:34:26,300
count and of of these win32 replay buffers, right?

791
00:34:26,699 --> 00:34:29,699
And and basically the winter if you replay buffer will have a void

792
00:34:29,699 --> 00:34:29,900
star.

793
00:34:30,199 --> 00:34:32,800
Pointer to the memory block like that.

794
00:34:32,800 --> 00:34:36,500
And then I'm going to have this here and maybe what we'll do to is,

795
00:34:36,500 --> 00:34:39,300
maybe we'll say what the back and file name is.

796
00:34:39,800 --> 00:34:42,699
So we've got the replay file name like that.

797
00:34:42,699 --> 00:34:43,199
I don't know.

798
00:34:44,300 --> 00:34:46,500
I don't know how necessary that's going to be but we'll we'll go ahead

799
00:34:46,500 --> 00:34:47,199
and do that.

800
00:34:47,300 --> 00:34:48,600
I think that that should work.

801
00:34:48,800 --> 00:34:52,600
Okay, so we'll say that there's the wheat replay buffer and these are

802
00:34:52,600 --> 00:34:55,300
our replay buffers and we're just going to say that we have four of

803
00:34:55,300 --> 00:34:55,600
them.

804
00:34:55,600 --> 00:34:56,600
Why do we have four of them?

805
00:34:56,600 --> 00:34:58,600
Because I said, so that's something we're going to have.

806
00:34:59,200 --> 00:34:59,900
And so

807
00:35:00,000 --> 00:35:03,400
So, we will go ahead and move that up here.

808
00:35:03,400 --> 00:35:06,300
So, we have the game memory block, which is our actual memory block,

809
00:35:06,300 --> 00:35:09,600
and then we have the replay buffers and they have their game memory

810
00:35:09,600 --> 00:35:11,100
blocks, inside them as well.

811
00:35:11,500 --> 00:35:16,000
And so what we'll do now just to start with is we'll just virtual Alec

812
00:35:16,100 --> 00:35:20,300
buffers and instead of writing the that state to disk will write it

813
00:35:20,300 --> 00:35:23,700
just to the buffer real quickly and see how much performance benefit

814
00:35:23,700 --> 00:35:24,300
we get there.

815
00:35:24,900 --> 00:35:29,900
So basically if we refer to compile this if you remember where we were

816
00:35:30,000 --> 00:35:33,700
Were at, before is grab my little Gamepad here.

817
00:35:34,300 --> 00:35:38,200
We are moving the guy around and you can see when we hit that Loop.

818
00:35:38,500 --> 00:35:40,800
There was this big old Paws, right?

819
00:35:41,600 --> 00:35:42,300
Real long.

820
00:35:42,300 --> 00:35:44,800
Pause while it wrote that stuff to disk.

821
00:35:45,100 --> 00:35:47,900
And so, what we want to do is see if we could speed that up.

822
00:35:47,900 --> 00:35:49,000
You want to make that faster.

823
00:35:49,900 --> 00:35:53,700
So, right here, what I'll do is I'll just Loop over those buffers

824
00:35:53,700 --> 00:35:54,000
again.

825
00:35:54,000 --> 00:35:57,000
It's a looping day today is the kind of day where we Loop.

826
00:35:57,600 --> 00:35:59,800
So we're going to say that our replay index.

827
00:36:00,200 --> 00:36:03,800
Is less than the array count of those replays.

828
00:36:03,800 --> 00:36:05,700
There we go, replay index.

829
00:36:06,200 --> 00:36:06,500
There.

830
00:36:06,500 --> 00:36:06,700
It is.

831
00:36:06,700 --> 00:36:07,800
Replay buffers.

832
00:36:08,200 --> 00:36:10,300
So that is our win32 state.

833
00:36:10,300 --> 00:36:10,900
What did I call?

834
00:36:10,900 --> 00:36:12,200
It went 3-2 State.

835
00:36:12,200 --> 00:36:12,500
There we go.

836
00:36:12,500 --> 00:36:13,400
Replay buffers.

837
00:36:13,700 --> 00:36:18,300
And for each one of those, we are going to just go ahead and allocate

838
00:36:18,800 --> 00:36:19,400
a block.

839
00:36:19,400 --> 00:36:21,200
So this is the replay buffer.

840
00:36:21,800 --> 00:36:23,900
It is going to be equal to whichever one.

841
00:36:23,900 --> 00:36:26,800
We are on replay index like that.

842
00:36:27,000 --> 00:36:29,800
And we are going to go ahead and

843
00:36:30,000 --> 00:36:33,600
and allocate huge amount of memory.

844
00:36:34,000 --> 00:36:35,800
All right, so we've got the memory block here.

845
00:36:36,400 --> 00:36:36,900
Excuse me.

846
00:36:38,400 --> 00:36:41,400
The memory block is just going to be this exact thing, right?

847
00:36:41,500 --> 00:36:43,400
We're just going to do the exact same allocation.

848
00:36:43,400 --> 00:36:44,800
So they're all the same size.

849
00:36:45,100 --> 00:36:48,000
We don't care what the Base address of it is because we're just using

850
00:36:48,000 --> 00:36:49,200
it for temporary storage.

851
00:36:49,400 --> 00:36:49,900
Right?

852
00:36:50,000 --> 00:36:52,200
So we don't care about the base dress is whatsoever.

853
00:36:52,900 --> 00:36:56,500
We have the total size that we were using before same amount.

854
00:36:56,500 --> 00:36:58,100
We want to do the read, write as well.

855
00:36:58,300 --> 00:37:01,300
So we're just going to do those virtual Alex and then we'll go ahead

856
00:37:01,300 --> 00:37:04,400
and insert that we got them because in debug mode, we want to make

857
00:37:04,400 --> 00:37:06,500
sure that we actually can allocate all this stuff.

858
00:37:07,200 --> 00:37:07,800
We want to know.

859
00:37:08,000 --> 00:37:08,500
Ahead of time.

860
00:37:08,500 --> 00:37:09,900
If I replay buffers aren't working.

861
00:37:10,000 --> 00:37:12,100
Looks like we can get them pretty trivially.

862
00:37:13,000 --> 00:37:16,400
If you are on a low memory kind of machine that would not work.

863
00:37:16,400 --> 00:37:17,600
You'll get an assertion there.

864
00:37:18,300 --> 00:37:20,400
Again, this is something that we will to do.

865
00:37:20,400 --> 00:37:26,100
Maybe we will change this change this to a log message so that people

866
00:37:26,100 --> 00:37:31,300
can run on machines with less memory when we actually have some kind

867
00:37:31,300 --> 00:37:32,200
of a logging system.

868
00:37:32,900 --> 00:37:34,600
Okay.

869
00:37:36,200 --> 00:37:37,100
In fact.

870
00:37:39,700 --> 00:37:40,100
Act.

871
00:37:40,700 --> 00:37:41,400
You know what?

872
00:37:41,800 --> 00:37:43,100
I'm just going to go ahead and do it.

873
00:37:43,100 --> 00:37:47,000
I'm going to say this is going to be diagnostic, but we're not going

874
00:37:47,000 --> 00:37:47,500
to report it.

875
00:37:47,500 --> 00:37:48,100
Currently.

876
00:37:48,500 --> 00:37:49,500
We're just going to do that.

877
00:37:49,700 --> 00:37:50,300
All right.

878
00:37:50,500 --> 00:37:52,900
So we've got the replay, buffer memory block thing.

879
00:37:52,900 --> 00:37:54,800
We want to verify that we actually got it.

880
00:37:55,800 --> 00:38:01,700
So actually the diagnostic goes here and then we'll all we're going to

881
00:38:01,700 --> 00:38:03,400
do is on that elk.

882
00:38:03,400 --> 00:38:07,600
All right, you know, we call begin recording input when we call that.

883
00:38:08,000 --> 00:38:09,600
According input begin function.

884
00:38:10,600 --> 00:38:12,800
What we want to do is we're going to move this to do because we're

885
00:38:12,800 --> 00:38:13,800
actually doing now.

886
00:38:14,500 --> 00:38:18,400
We're going to go ahead and say that instead of doing this gigantic,

887
00:38:18,400 --> 00:38:19,000
right?

888
00:38:19,200 --> 00:38:22,300
We're just not, we're going to ignore the right for now.

889
00:38:22,400 --> 00:38:25,600
We're going to pretend that never happened and instead.

890
00:38:25,600 --> 00:38:29,400
We're just going to seek to the place in the file that we would have

891
00:38:29,400 --> 00:38:31,200
been after we do the right?

892
00:38:31,300 --> 00:38:33,400
Because basically file handles the way that they work.

893
00:38:33,400 --> 00:38:34,900
I don't know that we covered this yet.

894
00:38:35,400 --> 00:38:37,700
So I should probably talk about a little bit a file.

895
00:38:37,900 --> 00:38:41,600
Handle in win32 stores where it last wrote to.

896
00:38:41,600 --> 00:38:45,100
And whenever you do a right sort of a pens, the rights just keep

897
00:38:45,100 --> 00:38:46,500
going, sequentially in the file.

898
00:38:46,800 --> 00:38:50,000
So if you open a file you start out assuming that you're going to

899
00:38:50,000 --> 00:38:54,000
write or read from the very first bite in the file and then however

900
00:38:54,000 --> 00:38:55,100
much you write or read.

901
00:38:55,100 --> 00:38:55,300
It.

902
00:38:55,300 --> 00:38:58,800
Moves the sort of the location that the next operation will occur.

903
00:38:58,900 --> 00:38:59,900
It moves it by

904
00:39:00,000 --> 00:39:00,600
Never you did.

905
00:39:00,600 --> 00:39:04,800
So, if you try to write 300 bytes, then the next right will happen.

906
00:39:04,800 --> 00:39:07,100
300 bytes into the file, you then write 500.

907
00:39:07,100 --> 00:39:08,900
The next one will be 800 in, you know, right?

908
00:39:08,900 --> 00:39:12,100
So as you kind of do the rights, they just stack on top of each other,

909
00:39:12,300 --> 00:39:15,700
but you can also do seeking, right?

910
00:39:15,800 --> 00:39:16,800
So you can do.

911
00:39:17,200 --> 00:39:18,800
Think it's called set file, pause.

912
00:39:18,900 --> 00:39:19,600
I don't know what it's called.

913
00:39:19,600 --> 00:39:20,700
Set file pointer.

914
00:39:20,700 --> 00:39:21,400
Is that what it's called?

915
00:39:21,400 --> 00:39:22,300
I'm not sure what it's called.

916
00:39:22,300 --> 00:39:23,400
We're going to find out in a second.

917
00:39:24,500 --> 00:39:27,800
What it's called if msdn MSDS slow, man.

918
00:39:29,300 --> 00:39:30,100
So slow.

919
00:39:30,700 --> 00:39:31,400
Let's take a look.

920
00:39:31,400 --> 00:39:32,900
I don't know if this is the the right thing.

921
00:39:32,900 --> 00:39:33,400
I think it's set.

922
00:39:33,400 --> 00:39:34,600
File pointer is all we really need.

923
00:39:34,600 --> 00:39:35,700
Let's take a look at set valper.

924
00:39:35,700 --> 00:39:36,500
No, ux as well.

925
00:39:36,500 --> 00:39:37,100
See what that is.

926
00:39:38,100 --> 00:39:38,400
Yeah.

927
00:39:38,400 --> 00:39:41,200
So this is I think what we want this is, yeah.

928
00:39:41,200 --> 00:39:42,100
This is what we want.

929
00:39:42,100 --> 00:39:45,200
So step file pointer, X just moves, whatever that look that file

930
00:39:45,200 --> 00:39:45,900
location is talking.

931
00:39:45,900 --> 00:39:47,300
Is it just sets it to somewhere?

932
00:39:47,600 --> 00:39:48,600
And so that's what we want.

933
00:39:48,600 --> 00:39:49,900
What is the minimum?

934
00:39:50,100 --> 00:39:51,500
What's the minimum system XP.

935
00:39:51,500 --> 00:39:52,300
So that's fine.

936
00:39:53,200 --> 00:39:54,200
So basically what we can do.

937
00:39:54,300 --> 00:39:54,700
With this thing.

938
00:39:54,700 --> 00:39:57,100
As we can say, we can give it a constant.

939
00:39:57,100 --> 00:39:59,500
The constant says we're in, the files are reference point.

940
00:39:59,500 --> 00:40:02,200
The current point, the end of the file, the beginning of the file.

941
00:40:02,600 --> 00:40:05,100
And in the our case, we just want to say from the beginning of the

942
00:40:05,100 --> 00:40:05,500
file.

943
00:40:05,500 --> 00:40:08,200
We want to go a certain number of bytes and it's the number of bytes

944
00:40:08,200 --> 00:40:11,400
that would have we would have left if we were going to write to the

945
00:40:11,400 --> 00:40:12,900
file with the B to right thing.

946
00:40:13,100 --> 00:40:13,800
Right?

947
00:40:14,000 --> 00:40:15,500
So however many we would have written.

948
00:40:15,800 --> 00:40:20,000
So all I want to do here is just leave space in the file, you know, I

949
00:40:20,000 --> 00:40:23,000
want to leave the space at the beginning of the file for that block.

950
00:40:23,400 --> 00:40:24,100
So that later.

951
00:40:24,200 --> 00:40:24,600
We can write it.

952
00:40:24,600 --> 00:40:25,900
So we're just going to call this.

953
00:40:26,300 --> 00:40:27,600
We're going to pass that handle.

954
00:40:28,300 --> 00:40:30,500
We're going to pass it the large integer.

955
00:40:30,700 --> 00:40:32,900
So we've got see here.

956
00:40:32,900 --> 00:40:34,500
This is a file position.

957
00:40:35,000 --> 00:40:35,500
Right?

958
00:40:35,500 --> 00:40:38,600
And this is again, those large integers with the quad part, how we

959
00:40:38,600 --> 00:40:40,300
this is, how we set the 64-bit thing.

960
00:40:40,800 --> 00:40:43,000
So we're basically going to do that that b written.

961
00:40:43,100 --> 00:40:46,000
And in fact, you know what, this will this will also solve our to do

962
00:40:46,000 --> 00:40:49,800
about the total size we can now actually do that total size.

963
00:40:49,800 --> 00:40:50,900
I think we can do that properly.

964
00:40:50,900 --> 00:40:52,600
Now if we do it the way we're about to do it.

965
00:40:52,700 --> 00:40:54,100
So that's going to be nice to kind of get

966
00:40:54,300 --> 00:40:59,300
Of a limitation there so we can have greater than 4 gigs of store if

967
00:40:59,300 --> 00:40:59,900
we want there.

968
00:41:00,600 --> 00:41:01,700
So we're going to get rid of this, right?

969
00:41:01,700 --> 00:41:03,000
We're going to stop having this right work.

970
00:41:03,000 --> 00:41:06,600
And we're just going to assume that we're going to set that that total

971
00:41:06,600 --> 00:41:07,800
size as the new position.

972
00:41:07,800 --> 00:41:12,000
So that all of our input gets written after that big block would have

973
00:41:12,000 --> 00:41:12,500
occurred.

974
00:41:12,700 --> 00:41:13,100
So.

975
00:41:13,100 --> 00:41:15,200
Alright, we got the file position past that in there.

976
00:41:15,200 --> 00:41:17,000
We don't actually need to know what the new position is.

977
00:41:17,000 --> 00:41:19,500
We'll just assume it's right and we're going to do file begin as the

978
00:41:19,500 --> 00:41:20,100
location.

979
00:41:21,300 --> 00:41:22,800
So go ahead and compile that

980
00:41:24,700 --> 00:41:27,000
what are you complaining about compiler?

981
00:41:28,100 --> 00:41:31,200
No, Constructor could take the source, type too low.

982
00:41:31,200 --> 00:41:32,400
Does it not take an address of?

983
00:41:32,400 --> 00:41:34,000
It just takes an actual large integer.

984
00:41:34,800 --> 00:41:36,200
You all right, even easier.

985
00:41:36,700 --> 00:41:37,800
So we're going to do that.

986
00:41:37,800 --> 00:41:42,100
And then in in lieu of the right instead of the right we're actually

987
00:41:42,100 --> 00:41:44,100
going to do is we're going to just do a copy.

988
00:41:44,800 --> 00:41:46,400
We're going to we're going to do a mem copy.

989
00:41:46,400 --> 00:41:47,000
Essentially.

990
00:41:47,200 --> 00:41:50,300
I don't know if we can just have Windows.

991
00:41:50,300 --> 00:41:51,500
Do that copy for us.

992
00:41:51,900 --> 00:41:53,200
I don't actually remember.

993
00:41:53,800 --> 00:41:54,700
I think we can.

994
00:41:55,300 --> 00:41:56,900
I believe that's totally valid.

995
00:41:56,900 --> 00:41:57,700
Yeah so we can

996
00:41:57,800 --> 00:41:59,900
Ask Windows to move to copy a block of memory.

997
00:42:00,000 --> 00:42:03,400
Us from a source to destination with some length, right?

998
00:42:03,400 --> 00:42:06,800
And I think that's just fine, but I don't know.

999
00:42:08,300 --> 00:42:09,300
Let's see.

1000
00:42:09,700 --> 00:42:14,300
Well, yeah, I don't know if I want it to.

1001
00:42:14,300 --> 00:42:18,400
Yeah, this is this is looking less like what I want.

1002
00:42:18,400 --> 00:42:18,700
All right.

1003
00:42:18,700 --> 00:42:19,400
Well, you know what?

1004
00:42:19,400 --> 00:42:20,200
We're going to call it.

1005
00:42:20,200 --> 00:42:22,000
We're just going to call it for now, later on.

1006
00:42:22,000 --> 00:42:25,200
I think we'll we should have all our own memory moving stuff and maybe

1007
00:42:25,200 --> 00:42:28,500
I'll rather call ours in the win32 layers.

1008
00:42:28,500 --> 00:42:29,800
I usually try to call.

1009
00:42:30,000 --> 00:42:31,300
Win32 functions.

1010
00:42:31,400 --> 00:42:35,200
I don't know why that is, but I just kind of like to use win32 inside

1011
00:42:35,200 --> 00:42:36,000
win32.

1012
00:42:37,500 --> 00:42:39,700
That's not particularly logical.

1013
00:42:39,700 --> 00:42:42,200
I appreciate that, but that's just the way I do it.

1014
00:42:42,300 --> 00:42:44,900
All right, so we're going to say the state game memory block thing.

1015
00:42:46,200 --> 00:42:48,700
That that is where our game memory is.

1016
00:42:48,700 --> 00:42:49,400
So we're going to use that.

1017
00:42:49,400 --> 00:42:50,200
As a source.

1018
00:42:50,200 --> 00:42:55,000
We know the total size is is how much we want to copy.

1019
00:42:55,200 --> 00:43:00,500
And we know the destination is going to be that that memory block for

1020
00:43:00,500 --> 00:43:05,100
the recording that we allocated in back at that startup.

1021
00:43:05,100 --> 00:43:05,500
Right?

1022
00:43:05,700 --> 00:43:06,300
So we're going to do this.

1023
00:43:06,300 --> 00:43:10,000
Now, what we have to do, of course before we do any of this stuff is

1024
00:43:10,000 --> 00:43:12,800
we have to check whether this block is actually valid.

1025
00:43:13,000 --> 00:43:15,300
So we have to check whether we ever got.

1026
00:43:16,000 --> 00:43:17,100
The recording block.

1027
00:43:17,300 --> 00:43:20,500
So, if you take a look like, I'm going to go ahead and assert, this

1028
00:43:20,500 --> 00:43:24,900
input recording index is is less than that array count as well because

1029
00:43:24,900 --> 00:43:26,700
we might as well check our bounds here.

1030
00:43:27,800 --> 00:43:28,600
Essentially.

1031
00:43:30,200 --> 00:43:34,400
I just want to say all right, let's make sure the recording in.

1032
00:43:34,400 --> 00:43:36,500
This is inside the replay buffers and assuming it is.

1033
00:43:36,500 --> 00:43:38,300
We're going to get the replay buffer out, right?

1034
00:43:38,300 --> 00:43:41,500
So here's our replay buffer, our replay buffer.

1035
00:43:43,300 --> 00:43:45,400
Is is going to be whichever one.

1036
00:43:45,400 --> 00:43:51,200
It was asking for and we are going to try to get this record block out

1037
00:43:51,200 --> 00:43:51,500
of there.

1038
00:43:51,500 --> 00:43:54,800
So I guess I could just use replay, buffer, Arrow, memory block.

1039
00:43:55,100 --> 00:43:57,000
If the memory block couldn't be allocated.

1040
00:43:57,000 --> 00:43:59,400
I don't want to try to write to it or we'll just crash and that

1041
00:43:59,400 --> 00:44:02,400
doesn't seem like a good idea even though it is debug code.

1042
00:44:02,400 --> 00:44:05,200
So I'm going to go ahead and say, all right, let's let's check to see

1043
00:44:05,200 --> 00:44:06,400
if we actually have some memory there.

1044
00:44:06,400 --> 00:44:09,600
And if we do then we'll go ahead and do the copy and that's fine.

1045
00:44:10,300 --> 00:44:11,800
And the same thing will happen.

1046
00:44:11,800 --> 00:44:13,000
In fact, I could go ahead and make

1047
00:44:13,100 --> 00:44:16,200
So utility function since we're going to call it twice right here, I

1048
00:44:16,200 --> 00:44:18,500
could say this is get replay buffer.

1049
00:44:18,600 --> 00:44:19,100
Right?

1050
00:44:19,600 --> 00:44:22,100
And that replay, buffer thing takes the win32 state.

1051
00:44:22,100 --> 00:44:27,800
There's the state, and we go ahead and say that, that is this right

1052
00:44:27,900 --> 00:44:29,100
return results.

1053
00:44:29,500 --> 00:44:31,100
There's the results I can assert.

1054
00:44:31,100 --> 00:44:34,000
Some people were nervous about the potentially that it could be under

1055
00:44:34,000 --> 00:44:34,600
flowing.

1056
00:44:35,900 --> 00:44:40,100
I don't know how realistic that is, but we could also do this in

1057
00:44:40,100 --> 00:44:42,100
unsigned index.

1058
00:44:42,400 --> 00:44:42,900
Now, we

1059
00:44:43,000 --> 00:44:44,600
Oh that it can't be less than zero.

1060
00:44:44,800 --> 00:44:49,600
Okay, so I'm going to go ahead and make that happen.

1061
00:44:50,400 --> 00:44:51,400
Tidy it up there.

1062
00:44:51,700 --> 00:44:59,400
We can we can pretty much just assume now that this replay buffer.

1063
00:45:00,200 --> 00:45:03,300
Can be had by doing the wind to to get replay buffer.

1064
00:45:03,300 --> 00:45:04,300
This pig hat is hot.

1065
00:45:04,300 --> 00:45:07,300
Ladies and gentlemen, I hope I stop being a pig soon because I am

1066
00:45:07,300 --> 00:45:08,100
melting in here.

1067
00:45:08,400 --> 00:45:11,600
All right, cannot convert for win through to repeat buffer tube of.

1068
00:45:11,600 --> 00:45:11,800
Yes.

1069
00:45:11,800 --> 00:45:12,400
That's true.

1070
00:45:12,400 --> 00:45:13,800
We need to take the address of it.

1071
00:45:14,400 --> 00:45:15,500
And so, there we go.

1072
00:45:15,500 --> 00:45:23,200
Because we're asking for a pointer Index right past that there and we

1073
00:45:23,200 --> 00:45:24,200
should be good to go.

1074
00:45:24,200 --> 00:45:25,200
We don't need this anymore.

1075
00:45:25,200 --> 00:45:26,900
So there's our copy memory.

1076
00:45:26,900 --> 00:45:29,300
All right, so hopefully that'll work and we're just going to do the

1077
00:45:29,300 --> 00:45:29,900
exact same.

1078
00:45:30,000 --> 00:45:34,300
Same thing on the, the other side, right?

1079
00:45:34,300 --> 00:45:37,400
So we're going to do the exact same thing when we want to begin input

1080
00:45:37,400 --> 00:45:38,100
playback.

1081
00:45:38,100 --> 00:45:41,500
We're going to use the input playing index, get the replay buffer out,

1082
00:45:41,500 --> 00:45:43,800
assuming that there is a valid memory block for it.

1083
00:45:43,800 --> 00:45:46,700
We are going to go ahead and instead of this read file, that we used

1084
00:45:46,700 --> 00:45:48,900
to be doing this stuff right here.

1085
00:45:49,500 --> 00:45:51,000
We don't actually do that anymore.

1086
00:45:51,000 --> 00:45:53,500
We're just going to do the copy file.

1087
00:45:54,100 --> 00:45:57,300
I'm sorry the copy memory right out of the memory block.

1088
00:45:57,600 --> 00:45:59,300
So we're just reversing what we did.

1089
00:45:59,400 --> 00:45:59,600
So,

1090
00:46:00,000 --> 00:46:02,500
Copy it like that right now.

1091
00:46:02,500 --> 00:46:02,900
I don't know.

1092
00:46:02,900 --> 00:46:04,900
I slammed a bunch of code in there and you know that it's hard for me

1093
00:46:04,900 --> 00:46:06,400
to talk in code at the same time.

1094
00:46:06,700 --> 00:46:09,200
So, I don't know if it's going to work but we'll try it and see if it

1095
00:46:09,200 --> 00:46:09,700
does.

1096
00:46:11,100 --> 00:46:12,500
Oh, you know, what?

1097
00:46:12,500 --> 00:46:14,400
Forgot one thing before I even try it.

1098
00:46:14,900 --> 00:46:17,400
So we have to do the same thing with the set file pointer as well,

1099
00:46:17,400 --> 00:46:22,400
obviously because we up here left space in the file by it by

1100
00:46:22,400 --> 00:46:23,400
pretending, we did the right.

1101
00:46:23,400 --> 00:46:25,600
We basically move the file pointer pass where we would have done the

1102
00:46:25,600 --> 00:46:26,100
right.

1103
00:46:26,200 --> 00:46:27,900
The same is going to be true for the read file.

1104
00:46:28,500 --> 00:46:29,800
It would have move the pointer and we

1105
00:46:29,900 --> 00:46:33,000
To duplicate that behavior because we're about to start reading there.

1106
00:46:33,300 --> 00:46:35,900
And so, we need to make sure that our reads line up with where our

1107
00:46:35,900 --> 00:46:38,500
rights were and I can cover that in the Q&A.

1108
00:46:38,500 --> 00:46:40,000
If that's a little confusing, what happened there.

1109
00:46:40,000 --> 00:46:42,100
We can talk about that in a little more detail.

1110
00:46:42,100 --> 00:46:47,100
So we'll do the set file pointer here and that's going to be on the

1111
00:46:47,100 --> 00:46:48,000
playback handle.

1112
00:46:49,100 --> 00:46:52,300
We've got the file positions going to be that total size again.

1113
00:46:52,400 --> 00:46:54,200
Looks like that's looks right to me.

1114
00:46:54,900 --> 00:46:56,000
Everything's good there.

1115
00:46:56,400 --> 00:46:57,200
So let's take a look.

1116
00:46:57,200 --> 00:46:59,800
Let's see if that's, that's, that's something we could actually try.

1117
00:47:01,200 --> 00:47:02,900
So do the L.

1118
00:47:04,300 --> 00:47:06,200
That takes a phenomenally long time.

1119
00:47:06,200 --> 00:47:07,500
Did we crash or something?

1120
00:47:07,500 --> 00:47:07,800
I assume.

1121
00:47:07,800 --> 00:47:09,500
He crashed know.

1122
00:47:09,900 --> 00:47:11,300
Why did that take so long?

1123
00:47:12,000 --> 00:47:12,500
Shouldn't that?

1124
00:47:12,500 --> 00:47:14,700
That should not be even doing any disk operations.

1125
00:47:14,700 --> 00:47:15,900
So what is going on there?

1126
00:47:15,900 --> 00:47:16,900
That feels odd.

1127
00:47:16,900 --> 00:47:17,300
Doesn't it?

1128
00:47:17,300 --> 00:47:21,300
Feel odd to copy one gig of memory at the memory bandwidth.

1129
00:47:21,300 --> 00:47:23,400
This machine, something something's up.

1130
00:47:23,700 --> 00:47:27,200
Something is fishy II.

1131
00:47:27,200 --> 00:47:27,900
Want to tell you?

1132
00:47:27,900 --> 00:47:28,600
Ladies and gentleman.

1133
00:47:28,600 --> 00:47:30,200
I feel like something is very

1134
00:47:30,500 --> 00:47:31,400
Very fishy.

1135
00:47:31,400 --> 00:47:36,200
I think we've got a bug, a bug that is that is perhaps has been in

1136
00:47:36,200 --> 00:47:37,500
there since the very beginning.

1137
00:47:37,500 --> 00:47:38,900
I need to think it through.

1138
00:47:40,000 --> 00:47:41,400
But let's, let's see here.

1139
00:47:42,400 --> 00:47:43,700
Let's see here.

1140
00:47:44,100 --> 00:47:45,300
What happened?

1141
00:47:47,200 --> 00:47:49,500
I'm going to, I'm going to, I'm going to add a couple output debug

1142
00:47:49,500 --> 00:47:52,100
strings here, but we'll step through that and just make sure we know

1143
00:47:52,100 --> 00:47:52,700
what's going on.

1144
00:47:53,800 --> 00:47:54,600
Let's see here.

1145
00:47:55,700 --> 00:47:58,400
When 3 to begin recording input.

1146
00:48:00,000 --> 00:48:03,500
So, I guess the other thing we could do is not do this file thing at

1147
00:48:03,500 --> 00:48:07,400
all as well just in case that is creating a problem for somebody.

1148
00:48:07,900 --> 00:48:10,400
Well, let me just double check one thing.

1149
00:48:12,900 --> 00:48:14,600
Yeah, so like what is it doing there?

1150
00:48:14,600 --> 00:48:15,300
Right?

1151
00:48:15,600 --> 00:48:19,600
Is that really the cost of the copy because it seems odd that the copy

1152
00:48:19,600 --> 00:48:20,700
would take that long.

1153
00:48:21,200 --> 00:48:25,400
So this is Bears investigation is what I would say, so what I'm going

1154
00:48:25,400 --> 00:48:32,100
to do is I'm going to go ahead and comment out the copy just to see if

1155
00:48:32,100 --> 00:48:34,700
the copy has anything to do with it to see if the copy is really

1156
00:48:34,700 --> 00:48:35,500
taking that long.

1157
00:48:37,000 --> 00:48:37,700
Haha.

1158
00:48:38,000 --> 00:48:39,800
So it has nothing to do with the copy.

1159
00:48:40,200 --> 00:48:42,300
The copy is commented out in our code.

1160
00:48:42,900 --> 00:48:45,500
And we still have that huge cause, right?

1161
00:48:46,500 --> 00:48:50,500
So let's take a look even further and go.

1162
00:48:50,500 --> 00:48:51,200
All right.

1163
00:48:51,500 --> 00:48:53,300
What about the file pointer thing?

1164
00:48:56,100 --> 00:48:59,400
Three to get input file location ago.

1165
00:48:59,400 --> 00:49:00,500
According handle.

1166
00:49:01,500 --> 00:49:04,300
In fact what we could do, you know what I'm going to use a little

1167
00:49:04,400 --> 00:49:06,000
because we don't have a profile or yet.

1168
00:49:06,100 --> 00:49:09,700
I'm going to go ahead and use output debug string to sort of spam

1169
00:49:10,700 --> 00:49:11,400
things here.

1170
00:49:11,500 --> 00:49:14,600
And use a little technique that I often like to use, which is a

1171
00:49:14,600 --> 00:49:17,100
basically just going to go ahead and spam.

1172
00:49:18,100 --> 00:49:21,700
I'm going to spam indexes out to the debug Port, right?

1173
00:49:21,700 --> 00:49:25,700
And I'm going to spam them at each particular location.

1174
00:49:26,500 --> 00:49:31,500
So that we can see who stalls because I don't know, really know who

1175
00:49:31,500 --> 00:49:32,000
stalls.

1176
00:49:32,000 --> 00:49:33,600
This is not a glamorous way to do it.

1177
00:49:33,600 --> 00:49:36,400
But, you know, in short order, it's something we can do.

1178
00:49:37,000 --> 00:49:39,300
So let's go ahead and size that down there.

1179
00:49:41,000 --> 00:49:42,200
Get the output up.

1180
00:49:42,600 --> 00:49:43,900
There is our output.

1181
00:49:44,300 --> 00:49:46,900
So here, we're going and then we go l.

1182
00:49:58,400 --> 00:49:59,800
So, did you see what happened there?

1183
00:50:01,100 --> 00:50:02,200
That was pretty interesting.

1184
00:50:03,400 --> 00:50:04,200
I would say.

1185
00:50:05,300 --> 00:50:07,700
It actually got to hear relatively quickly.

1186
00:50:08,800 --> 00:50:13,400
So something after begin recording input is actually causing the

1187
00:50:13,400 --> 00:50:16,300
problem when 3 to begin recording input.

1188
00:50:16,300 --> 00:50:19,900
So we just have a flat out regular old bug.

1189
00:50:21,800 --> 00:50:23,900
That was presumably causing problems for us.

1190
00:50:24,000 --> 00:50:26,200
Even before this is very good.

1191
00:50:27,100 --> 00:50:30,100
I feel like, I feel like this is, this is a good thing that we looked

1192
00:50:30,100 --> 00:50:33,700
into this because we just had some we just have some other totally

1193
00:50:33,700 --> 00:50:35,300
erroneous Behavior happening.

1194
00:50:35,900 --> 00:50:37,800
Probably down in here somewhere.

1195
00:50:38,000 --> 00:50:38,500
We just have

1196
00:50:38,700 --> 00:50:41,400
Think stupid going on, if that makes sense.

1197
00:50:41,900 --> 00:50:45,000
So I want to see, I'm interested to know.

1198
00:50:45,500 --> 00:50:48,000
Yeah, what what exactly is going on there?

1199
00:50:48,400 --> 00:50:49,900
Because that was an interesting stall.

1200
00:50:49,900 --> 00:50:53,300
It stalled right after spam for.

1201
00:50:53,900 --> 00:50:59,500
So let's I guess I could step through it maybe and see because

1202
00:50:59,500 --> 00:50:59,800
remember,

1203
00:51:00,000 --> 00:51:04,000
It printed spam for right, you saw what happened.

1204
00:51:04,100 --> 00:51:08,100
You were here it printed this and then it didn't print this for a long

1205
00:51:08,100 --> 00:51:08,500
time.

1206
00:51:08,900 --> 00:51:12,700
Now, if you, if you could, think about what that means in terms of

1207
00:51:12,700 --> 00:51:15,300
flow control in terms of what happened in the code.

1208
00:51:15,500 --> 00:51:17,000
It means that we got.

1209
00:51:19,000 --> 00:51:21,000
I can never find my way around an MSP.

1210
00:51:21,000 --> 00:51:23,000
See we got here, right?

1211
00:51:23,300 --> 00:51:26,100
And then when we exited from that,

1212
00:51:27,200 --> 00:51:30,400
You remember when three to begin recording input is called here.

1213
00:51:30,900 --> 00:51:33,400
So we did whatever we were going to do here.

1214
00:51:33,500 --> 00:51:37,700
We exited out of this function of win32 process, pending messages,

1215
00:51:37,900 --> 00:51:38,400
right?

1216
00:51:39,200 --> 00:51:45,100
And then we we actually, you know, I don't know what happened.

1217
00:51:45,100 --> 00:51:46,700
We executing this.

1218
00:51:46,700 --> 00:51:47,800
This part of the code.

1219
00:51:47,800 --> 00:51:51,700
Just executing through all this for some reason, this time around

1220
00:51:51,700 --> 00:51:56,500
before we ever got to the frame output stuff because we still output

1221
00:51:56,500 --> 00:51:56,800
the

1222
00:51:57,700 --> 00:51:59,300
We still output this stuff, right?

1223
00:51:59,400 --> 00:52:00,600
Where did we output?

1224
00:52:00,600 --> 00:52:01,000
BT?

1225
00:52:01,000 --> 00:52:02,200
L 33?

1226
00:52:02,400 --> 00:52:02,700
Okay.

1227
00:52:02,700 --> 00:52:07,000
So basically spam for before this, this line right here.

1228
00:52:07,000 --> 00:52:09,600
The BTL line is all the way up here.

1229
00:52:10,600 --> 00:52:14,600
And so some something in between.

1230
00:52:15,900 --> 00:52:22,500
Yeah, in between when we, when we called the right up here, which is

1231
00:52:22,500 --> 00:52:26,800
happening here in between there and that BTL line took.

1232
00:52:26,900 --> 00:52:28,300
An enormous amount of time.

1233
00:52:28,600 --> 00:52:30,900
So I wonder if we could figure out who that is.

1234
00:52:31,200 --> 00:52:32,600
Let's just see if we can.

1235
00:52:33,000 --> 00:52:34,700
What's the name of this function Again?

1236
00:52:35,100 --> 00:52:38,100
Win32 Begin recording input.

1237
00:52:38,200 --> 00:52:38,600
Yeah.

1238
00:52:38,700 --> 00:52:39,200
This guy.

1239
00:52:39,600 --> 00:52:42,000
Let's see if we can figure out, who is responsible.

1240
00:52:42,600 --> 00:52:43,600
Just really simply.

1241
00:52:43,700 --> 00:52:46,100
Again, a profiler would make this very simple, but we don't have one

1242
00:52:46,100 --> 00:52:46,700
yet.

1243
00:52:47,000 --> 00:52:48,800
So we're going to do this the old-fashioned way.

1244
00:52:49,000 --> 00:52:49,700
So here we go.

1245
00:52:49,700 --> 00:52:51,700
We're going, we end up in here.

1246
00:52:53,500 --> 00:52:58,000
This happens that copy takes a little bit of time but not that much,

1247
00:52:58,100 --> 00:52:58,700
right?

1248
00:52:59,200 --> 00:53:01,200
And so we come out, here we go through.

1249
00:53:01,200 --> 00:53:02,500
Let's see what happens.

1250
00:53:03,000 --> 00:53:05,900
So we come out, you come in here, we get these things.

1251
00:53:05,900 --> 00:53:09,900
We process the keyboard messages, we go ahead and get our X input

1252
00:53:09,900 --> 00:53:10,600
State.

1253
00:53:11,200 --> 00:53:14,100
We do this a couple times you do.

1254
00:53:14,400 --> 00:53:15,700
We finish all the controllers.

1255
00:53:15,700 --> 00:53:16,300
None of them are.

1256
00:53:16,300 --> 00:53:18,800
Other are connected to come through here.

1257
00:53:19,300 --> 00:53:22,200
We try to record the input called the right file.

1258
00:53:22,900 --> 00:53:23,800
What?

1259
00:53:34,300 --> 00:53:35,300
Hmm.

1260
00:53:40,400 --> 00:53:42,000
Very interesting.

1261
00:53:42,300 --> 00:53:45,100
So it's as if the right file.

1262
00:53:46,600 --> 00:53:51,900
So I guess it's because the right file is having to actually reserved

1263
00:53:51,900 --> 00:53:55,300
all when it when you do that set file pointer call.

1264
00:53:56,700 --> 00:53:59,700
Is actually reserving all of that space.

1265
00:54:00,000 --> 00:54:01,700
Something of that nature.

1266
00:54:02,000 --> 00:54:05,400
Let's see if that is true set.

1267
00:54:05,400 --> 00:54:06,700
File pointer X.

1268
00:54:07,000 --> 00:54:08,700
Let's see what happens.

1269
00:54:08,700 --> 00:54:15,800
If we get rid of this, this file pointer situation here, go f-zero.

1270
00:54:18,100 --> 00:54:20,900
Let's see what happens if we if we go ahead and do that.

1271
00:54:24,300 --> 00:54:28,000
Yeah, so that's way faster right way, way.

1272
00:54:28,000 --> 00:54:29,200
Way way way faster.

1273
00:54:31,800 --> 00:54:32,900
Hmm.

1274
00:54:35,400 --> 00:54:38,200
Very interesting people very, very interesting.

1275
00:54:45,600 --> 00:54:49,800
So basically the act of setting the file pointer appears to be forcing

1276
00:54:49,800 --> 00:54:54,000
the operating system to actually like go through and do all of the

1277
00:54:54,000 --> 00:54:58,700
work on that span, which we really did not actually need it to do.

1278
00:54:59,300 --> 00:55:00,000
So.

1279
00:55:02,100 --> 00:55:03,700
I'm not sure how to solve that problem.

1280
00:55:03,700 --> 00:55:04,400
Exactly.

1281
00:55:06,300 --> 00:55:08,600
I'm not sure how to tell it that.

1282
00:55:08,600 --> 00:55:10,400
We don't care very much about that.

1283
00:55:10,500 --> 00:55:13,500
We could make it so that we have two separate files one for the input

1284
00:55:13,500 --> 00:55:15,100
stream in 14, the backing store.

1285
00:55:19,200 --> 00:55:21,900
I don't know.

1286
00:55:22,500 --> 00:55:24,700
I do not know what we want to do about that.

1287
00:55:31,300 --> 00:55:34,300
So what I was going to do, I'll tell you the rest of what I was going

1288
00:55:34,300 --> 00:55:38,100
to do is I was going to go ahead and do a memory map file, which is

1289
00:55:38,100 --> 00:55:41,800
basically where you tell windows that a portion of memory is just

1290
00:55:41,900 --> 00:55:44,400
supposed to be mapping a portion of a file.

1291
00:55:44,700 --> 00:55:47,200
I was going to do that for the memory block.

1292
00:55:47,900 --> 00:55:51,300
And so that way Windows would just commit it to disk when we closed,

1293
00:55:51,300 --> 00:55:54,400
or crashed or whatever and wouldn't think that it needed to write

1294
00:55:54,400 --> 00:56:00,200
stuff all the time now, I don't actually know if

1295
00:56:00,400 --> 00:56:05,300
Windows, I don't actually know if windows will be smart enough.

1296
00:56:05,300 --> 00:56:08,900
If I do that memory map and then we do the set file pointer thing.

1297
00:56:08,900 --> 00:56:14,900
I don't know if it'll be smart enough to know what to do and not to do

1298
00:56:14,900 --> 00:56:18,700
what it's doing right now, which I assume is that it's taking the time

1299
00:56:18,900 --> 00:56:20,700
to go ahead and Pat out that file.

1300
00:56:23,400 --> 00:56:23,900
Yeah.

1301
00:56:24,600 --> 00:56:33,200
Yeah, so very interesting and and you can see in fact, to Loop edit

1302
00:56:33,300 --> 00:56:37,700
HMI is very tiny when we don't do that.

1303
00:56:37,700 --> 00:56:40,500
And so it's very big when we don't set the file pointer because it's

1304
00:56:40,500 --> 00:56:42,500
only recording, just the input into their.

1305
00:56:43,800 --> 00:56:46,100
Yeah, so I don't know what we should do.

1306
00:56:46,400 --> 00:56:47,200
I don't know.

1307
00:56:48,100 --> 00:56:51,500
Maybe we should try the memory mapped file thing and see what happens

1308
00:56:51,900 --> 00:56:52,800
just for education.

1309
00:56:53,200 --> 00:56:53,700
Isis.

1310
00:56:53,900 --> 00:56:55,500
I don't know or maybe we shouldn't.

1311
00:56:55,500 --> 00:56:57,000
Maybe this is a bad idea.

1312
00:56:57,200 --> 00:56:59,900
I'm not sure I really

1313
00:57:00,000 --> 00:57:01,600
No, I'm torn.

1314
00:57:02,200 --> 00:57:03,400
Here's what I will say.

1315
00:57:03,600 --> 00:57:04,900
Let's try the simplest.

1316
00:57:04,900 --> 00:57:09,000
Let's try the stupidest thing that we can think of so far.

1317
00:57:09,200 --> 00:57:12,100
And Let's do let's do the stupidest thing and we'll see if the

1318
00:57:12,100 --> 00:57:13,900
stupidest thing works.

1319
00:57:19,900 --> 00:57:21,000
So so difficult.

1320
00:57:21,000 --> 00:57:25,200
Alright, so basically what we're going to do here is

1321
00:57:31,200 --> 00:57:31,900
Let's just try.

1322
00:57:32,700 --> 00:57:33,400
Let's try it.

1323
00:57:33,500 --> 00:57:36,100
Let's do map view of file and we'll see what happens.

1324
00:57:36,600 --> 00:57:38,500
So I'm going to see if Matt, I'm just gonna see if map view.

1325
00:57:38,500 --> 00:57:40,800
A file will be relatively easy for us to do.

1326
00:57:40,800 --> 00:57:41,600
We'll just try it.

1327
00:57:41,600 --> 00:57:44,200
We'll just put it in there and we'll see what happens.

1328
00:57:44,500 --> 00:57:45,700
So it should be pretty easy.

1329
00:57:45,900 --> 00:57:50,000
So, basically, what this does is this tells Windows to correspond a

1330
00:57:50,000 --> 00:57:51,600
piece of memory with it with a file.

1331
00:57:51,600 --> 00:57:54,200
And every time you touch the memory, it will write it to the file,

1332
00:57:54,300 --> 00:57:54,800
right?

1333
00:57:55,400 --> 00:57:57,900
So it kind of just it sets up a mapping between the two.

1334
00:57:58,500 --> 00:57:59,600
And so if I wanted to do

1335
00:57:59,700 --> 00:58:00,900
Going to go ahead down here.

1336
00:58:01,500 --> 00:58:04,500
And I'm going to go ahead and do that in that inside that Loop where

1337
00:58:04,500 --> 00:58:06,800
we do the memory mapping thing.

1338
00:58:07,000 --> 00:58:10,000
So instead of virtual allocating this we're actually just going to

1339
00:58:10,000 --> 00:58:12,600
going to have that memory is actually just going to be a map view of

1340
00:58:12,600 --> 00:58:13,100
file.

1341
00:58:13,200 --> 00:58:13,800
Right?

1342
00:58:13,800 --> 00:58:16,200
And so what I'm going to do is I'm going to go ahead and change it.

1343
00:58:16,400 --> 00:58:20,800
So that what we do in here essentially is we do file star.

1344
00:58:21,200 --> 00:58:21,600
Hmm.

1345
00:58:26,200 --> 00:58:27,100
Yeah, the handle.

1346
00:58:27,100 --> 00:58:28,400
So this is this is the file handle.

1347
00:58:28,400 --> 00:58:29,700
This is to the replay file.

1348
00:58:30,700 --> 00:58:31,000
Yeah.

1349
00:58:31,100 --> 00:58:33,300
So basically what we're going to do is we're going to say all right,

1350
00:58:33,800 --> 00:58:35,100
we got the replay buffer.

1351
00:58:35,500 --> 00:58:38,400
We're going to have it's not really file handle and it's not file

1352
00:58:38,400 --> 00:58:38,600
star.

1353
00:58:38,600 --> 00:58:41,600
Don't know why I did that as a handle again getting kind of confused

1354
00:58:41,600 --> 00:58:42,100
in my head.

1355
00:58:42,300 --> 00:58:42,700
All right.

1356
00:58:42,700 --> 00:58:43,900
So we want to do is we got this.

1357
00:58:43,900 --> 00:58:45,900
We want to basic setup, this memory mapping.

1358
00:58:46,600 --> 00:58:48,100
So we need to call this, I guess.

1359
00:58:48,100 --> 00:58:49,800
Memory map might be the better word for it.

1360
00:58:50,200 --> 00:58:52,300
So we're going to have to get that memory.

1361
00:58:52,500 --> 00:58:53,000
Somehow.

1362
00:58:53,700 --> 00:58:55,600
So we've got the file mapping object.

1363
00:58:55,900 --> 00:59:00,500
We are desired access is is going to be everything.

1364
00:59:00,500 --> 00:59:03,000
I think we want to do read, write and copyright.

1365
00:59:03,100 --> 00:59:08,000
Well, we don't want be so we just want all access I believe.

1366
00:59:08,100 --> 00:59:08,600
Yeah.

1367
00:59:09,100 --> 00:59:14,400
Yeah, so we want found that all access that again just doing the

1368
00:59:14,400 --> 00:59:15,700
stupidest possible thing here.

1369
00:59:16,100 --> 00:59:18,300
The offset in the file is just 0 0.

1370
00:59:18,400 --> 00:59:22,100
The number of bytes to map is whatever that total size is, right.

1371
00:59:22,500 --> 00:59:23,300
And that's all.

1372
00:59:23,300 --> 00:59:27,200
So we're just going to say, hey, look, I want you to map this file for

1373
00:59:27,200 --> 00:59:27,800
us, please.

1374
00:59:28,600 --> 00:59:29,900
And I want it to be this big.

1375
00:59:30,000 --> 00:59:31,000
So that's all that's going to do.

1376
00:59:31,300 --> 00:59:34,000
And what that's going to do is that's going to return us an LP void,

1377
00:59:34,000 --> 00:59:35,200
which is the memory block.

1378
00:59:35,200 --> 00:59:38,500
So, basically, instead of virtual allocating the memory, we're asking

1379
00:59:38,500 --> 00:59:41,500
Windows to basically set up the memory as a map to the files.

1380
00:59:41,500 --> 00:59:43,800
So we don't need to Virtual allocate anymore because basically the

1381
00:59:43,800 --> 00:59:47,200
memory map will do the allocation and it's not really an allocation.

1382
00:59:47,200 --> 00:59:48,100
It's a mapping.

1383
00:59:48,100 --> 00:59:50,500
So it's allocating the memory, but it's also saying that it

1384
00:59:50,500 --> 00:59:52,300
corresponds directly the disc and windows.

1385
00:59:52,400 --> 00:59:54,700
Bands that Hugh a does not begin.

1386
00:59:54,700 --> 00:59:57,200
Now just in case I was wondering because I want to actually see if

1387
00:59:57,200 --> 00:59:57,700
this works.

1388
01:00:00,400 --> 01:00:03,600
Ignore the timer, ignore the timer.

1389
01:00:05,600 --> 01:00:09,200
So yeah, what we want to do here, is this memory map.

1390
01:00:09,200 --> 01:00:11,700
We just got to figure how to get that and I assume we just need open

1391
01:00:11,700 --> 01:00:12,500
file mapping.

1392
01:00:14,200 --> 01:00:15,000
Let's see here.

1393
01:00:15,900 --> 01:00:20,600
Let's see opens a name file mapping object.

1394
01:00:21,000 --> 01:00:22,200
Let's in fact, you know what?

1395
01:00:22,200 --> 01:00:23,700
Let's see about create file mapping.

1396
01:00:24,800 --> 01:00:27,900
Let's see handle the file from, which create the file mapping.

1397
01:00:27,900 --> 01:00:29,200
The file must be open with access rights.

1398
01:00:29,200 --> 01:00:29,900
Compatible.

1399
01:00:30,200 --> 01:00:31,400
Yes, that's fine.

1400
01:00:31,800 --> 01:00:36,100
Will it create the file if it doesn't exist as my question, let's see.

1401
01:00:36,100 --> 01:00:37,900
Because that's that is a problem for us.

1402
01:00:37,900 --> 01:00:38,900
If that doesn't work.

1403
01:00:39,500 --> 01:00:43,700
Let's see if the others is for the function called which enhance the

1404
01:00:43,700 --> 01:00:45,100
existing object.

1405
01:00:45,800 --> 01:00:46,500
That's fine.

1406
01:00:46,500 --> 01:00:48,500
So yeah, you know, maybe this will just work.

1407
01:00:48,500 --> 01:00:49,500
Let's go ahead and try it again.

1408
01:00:49,500 --> 01:00:51,600
We don't have a lot of time, just gonna go ahead and try it.

1409
01:00:51,600 --> 01:00:54,100
Basically, what we're telling Windows here is what the file is that

1410
01:00:54,100 --> 01:00:58,700
we're trying to map to so we have to pass it a file handle of course,

1411
01:00:59,300 --> 01:01:00,000
so we're basically

1412
01:01:00,100 --> 01:01:01,200
We have to do replay buffer.

1413
01:01:01,200 --> 01:01:04,000
I guess I will still need the file handle as well.

1414
01:01:04,400 --> 01:01:07,300
So we'll do a file handle the security attributes.

1415
01:01:07,300 --> 01:01:10,000
I think we don't care, so we don't care about that.

1416
01:01:10,000 --> 01:01:12,200
At all the F, protect.

1417
01:01:12,200 --> 01:01:13,400
We want readwrite.

1418
01:01:13,400 --> 01:01:14,800
Access to the pages.

1419
01:01:14,900 --> 01:01:17,400
Certainly good.

1420
01:01:17,700 --> 01:01:23,800
We've got the maximum size high and low, so the maximum size high and

1421
01:01:23,800 --> 01:01:28,000
low, we actually need to get out of the total size, so I don't

1422
01:01:28,000 --> 01:01:28,900
actually know.

1423
01:01:30,100 --> 01:01:33,200
Are and then we got our, we got our file name as well, our replay file

1424
01:01:33,200 --> 01:01:35,300
name, which we haven't filled out yet.

1425
01:01:35,300 --> 01:01:36,500
There's the replay buffer.

1426
01:01:36,900 --> 01:01:37,800
There's the file name.

1427
01:01:37,800 --> 01:01:38,800
So I guess we can just call this.

1428
01:01:40,000 --> 01:01:41,300
Alright, so we got that.

1429
01:01:41,900 --> 01:01:46,000
And basically the total size here it wants us to pass the high and the

1430
01:01:46,000 --> 01:01:47,000
low separately.

1431
01:01:47,400 --> 01:01:50,700
So I guess what it's asking us to do is something like this, right?

1432
01:01:50,700 --> 01:01:55,000
It's basically saying alright, it wants the high first, right?

1433
01:01:55,200 --> 01:01:56,500
So I'm going to shift down.

1434
01:01:56,500 --> 01:01:58,000
This is a 64-bit value.

1435
01:01:58,100 --> 01:02:00,000
I'm going to shift that down by 30.

1436
01:02:00,100 --> 01:02:01,300
To and pass it.

1437
01:02:01,900 --> 01:02:04,700
So that will get that and then it will, and then we'll pass the bottom

1438
01:02:05,200 --> 01:02:10,100
just, you know, as is, which I assume we want to do, just and it out.

1439
01:02:10,500 --> 01:02:13,200
So basically just pull out those bottom bit.

1440
01:02:13,200 --> 01:02:15,000
So I'm going to pull out the bottom 32 here.

1441
01:02:15,000 --> 01:02:15,600
And the topic here.

1442
01:02:15,600 --> 01:02:18,900
I thought there was I feel like there is ways to pull those out that

1443
01:02:18,900 --> 01:02:20,000
that Windows just had.

1444
01:02:20,000 --> 01:02:22,300
Like I said, I usually like to call Windows is functions.

1445
01:02:22,300 --> 01:02:27,200
I feel like there was a macro for like, you know, there was no, it's

1446
01:02:27,200 --> 01:02:29,900
like high word lowered, but I don't know if they exist for

1447
01:02:30,100 --> 01:02:33,300
Or, I don't know if they exist for bigger types.

1448
01:02:34,300 --> 01:02:38,700
There's High B and low byte, but I don't know if there's a high long,

1449
01:02:39,800 --> 01:02:42,000
there's a make long now because I don't know.

1450
01:02:42,000 --> 01:02:43,400
You think they would have it, right?

1451
01:02:43,800 --> 01:02:47,200
They have stuff for extracting, the other pieces, but not that one.

1452
01:02:47,300 --> 01:02:49,000
Alright, well, we'll deal with that later.

1453
01:02:49,000 --> 01:02:51,500
I guess the fact that maybe we'll make our own macros for it.

1454
01:02:51,500 --> 01:02:51,800
I don't know.

1455
01:02:51,800 --> 01:02:53,300
Just seems like they should have had that.

1456
01:02:53,300 --> 01:02:55,600
Since if they want you to pull apart 64-bit values.

1457
01:02:55,800 --> 01:02:57,300
They should have had a thing that does that.

1458
01:02:57,500 --> 01:02:59,800
So that everyone does it uniformly incorrectly, right?

1459
01:03:00,300 --> 01:03:03,400
Who knows if we wrote this bug Ali, you know, you want a macro so that

1460
01:03:03,400 --> 01:03:07,100
the user doesn't have to screw up or Can't Screw Up.

1461
01:03:07,100 --> 01:03:11,000
I should say if there's no real reason to not have that habit.

1462
01:03:11,000 --> 01:03:12,700
So, all right.

1463
01:03:12,800 --> 01:03:15,000
So we need to make one of these file names.

1464
01:03:15,000 --> 01:03:19,300
I'm going to go ahead and and and make that happen with the HMI file.

1465
01:03:19,300 --> 01:03:20,100
Let's see here.

1466
01:03:20,700 --> 01:03:25,800
So we've got this guy and we will have to start making this, do

1467
01:03:25,800 --> 01:03:27,200
something a little smarter.

1468
01:03:27,700 --> 01:03:29,800
So what I need to do is insert the name in

1469
01:03:30,000 --> 01:03:33,800
They're so I'll use that Windows sprintf function again that we had

1470
01:03:33,800 --> 01:03:37,900
before to basically make one of these for each of the slots.

1471
01:03:38,200 --> 01:03:42,200
So I'm just going to go ahead and create a string here using that slot

1472
01:03:42,200 --> 01:03:42,600
index.

1473
01:03:42,600 --> 01:03:46,200
Using the windows has formatting function that we used before and

1474
01:03:46,200 --> 01:03:47,200
we'll just make that.

1475
01:03:47,200 --> 01:03:50,500
So we can quickly get one for each of our files.

1476
01:03:50,500 --> 01:03:54,100
So, we'll call this win32 get input file location.

1477
01:03:56,800 --> 01:03:59,900
Excuse me, and we will, we will actually open.

1478
01:04:00,000 --> 01:04:04,600
The file handle directly in that, that that code down.

1479
01:04:04,600 --> 01:04:07,500
So instead of opening it on when we actually start recording or stop

1480
01:04:07,500 --> 01:04:08,000
recording.

1481
01:04:08,500 --> 01:04:10,500
We'll just open it right off the bat.

1482
01:04:11,000 --> 01:04:11,400
Yeah.

1483
01:04:11,500 --> 01:04:17,700
So what we want to do here is take that that file name, where is okay,

1484
01:04:17,700 --> 01:04:18,600
so we have to open the files.

1485
01:04:18,600 --> 01:04:19,300
Well, we want to do.

1486
01:04:19,300 --> 01:04:20,800
We want to do everything that's in here.

1487
01:04:21,000 --> 01:04:22,700
We want to move all of this stuff.

1488
01:04:23,200 --> 01:04:25,500
Every last thing that was in here.

1489
01:04:25,500 --> 01:04:28,700
We want to move all of this stuff into here, essentially.

1490
01:04:29,200 --> 01:04:29,800
And we want these

1491
01:04:29,900 --> 01:04:32,000
Has to be generic, read engineer, right?

1492
01:04:32,000 --> 01:04:37,000
We want both kinds of access to it essentially, and we will go ahead

1493
01:04:37,000 --> 01:04:40,200
and say that the right file is gone as well.

1494
01:04:40,600 --> 01:04:42,400
We want to keep this guy in there.

1495
01:04:43,100 --> 01:04:44,400
We gotta get rid of that.

1496
01:04:44,500 --> 01:04:45,700
You have our copy memory.

1497
01:04:45,700 --> 01:04:47,000
That's all good.

1498
01:04:48,000 --> 01:04:50,000
I have to get rid of this guy.

1499
01:04:50,100 --> 01:04:51,000
So there we go.

1500
01:04:51,000 --> 01:04:51,700
Copy memory.

1501
01:04:51,700 --> 01:04:53,400
We don't want to open the playback handle.

1502
01:04:53,400 --> 01:04:54,500
We don't want to get the file name.

1503
01:04:54,500 --> 01:04:55,400
We don't do any of that stuff.

1504
01:04:55,400 --> 01:04:57,700
That's just going to happen automatically now.

1505
01:04:57,900 --> 01:04:58,500
All right.

1506
01:04:58,700 --> 01:04:59,800
So first we have to generate

1507
01:05:00,000 --> 01:05:03,700
File name, one file name for every one of our replay buffers that we

1508
01:05:03,700 --> 01:05:04,300
have.

1509
01:05:04,800 --> 01:05:09,200
So let's go ahead and do that right off the bat here will generate

1510
01:05:09,200 --> 01:05:11,400
that with the replay index.

1511
01:05:11,400 --> 01:05:13,000
So we'll have one for every file.

1512
01:05:13,200 --> 01:05:14,300
One for every replay.

1513
01:05:14,300 --> 01:05:15,800
A different file name for every replay.

1514
01:05:16,400 --> 01:05:17,600
So will generate that.

1515
01:05:17,800 --> 01:05:21,600
We will then go ahead and open the file handle.

1516
01:05:21,900 --> 01:05:23,600
Oh, so I should, that is true.

1517
01:05:23,600 --> 01:05:25,900
I do need to keep doing this part.

1518
01:05:25,900 --> 01:05:29,300
The recording handle does have to be the replay buffers file handle,

1519
01:05:29,400 --> 01:05:29,800
right?

1520
01:05:29,900 --> 01:05:30,000
Right.

1521
01:05:30,900 --> 01:05:31,400
There we go.

1522
01:05:32,900 --> 01:05:39,300
Like that way back, handle and recording handle creating handle.

1523
01:05:39,600 --> 01:05:40,100
Here we go.

1524
01:05:40,800 --> 01:05:42,000
So I do need to do that.

1525
01:05:42,800 --> 01:05:46,700
So in here, I don't know if we need to open a second handle.

1526
01:05:46,700 --> 01:05:49,700
I don't know if this thing eats the handle and we can't ever use the

1527
01:05:49,700 --> 01:05:50,200
handle again.

1528
01:05:50,200 --> 01:05:54,000
So I don't know if we can't use the same handle that we were using or

1529
01:05:54,000 --> 01:05:54,600
not.

1530
01:05:54,700 --> 01:05:56,100
So, we'll have to take a look at that in a second.

1531
01:05:56,100 --> 01:05:58,200
But for now, we'll just open one handle.

1532
01:05:58,400 --> 01:05:59,800
So we have a replay buffer.

1533
01:06:00,000 --> 01:06:01,300
And it has a file handle, right?

1534
01:06:01,300 --> 01:06:03,600
We're going to open that with both read and write privileges so that

1535
01:06:03,600 --> 01:06:07,100
we can both read and write from it will create that file handle.

1536
01:06:07,100 --> 01:06:09,400
I don't know if we need to pass a thing there that says it's okay for

1537
01:06:09,400 --> 01:06:10,500
mapping will see you in a second.

1538
01:06:10,500 --> 01:06:14,000
I'll read the documentation and find out then we should be able to map

1539
01:06:14,000 --> 01:06:14,200
it.

1540
01:06:14,200 --> 01:06:15,200
We do the map.

1541
01:06:15,500 --> 01:06:19,900
We we've been got our memory block in theory that will then be a

1542
01:06:19,900 --> 01:06:21,700
backing store and that's in theory.

1543
01:06:21,700 --> 01:06:24,000
All we would have to actually do now.

1544
01:06:24,000 --> 01:06:28,700
I don't know if there is anything else that I'm forgetting here.

1545
01:06:28,700 --> 01:06:29,800
Chances are hard.

1546
01:06:30,000 --> 01:06:33,500
A good that we are but let's see.

1547
01:06:33,500 --> 01:06:35,200
Replay buffer, file name.

1548
01:06:36,500 --> 01:06:38,400
So, wait a minute.

1549
01:06:38,400 --> 01:06:39,400
Why am I passing the file?

1550
01:06:39,400 --> 01:06:40,000
Name twice?

1551
01:06:40,000 --> 01:06:42,000
Did I not actually have to do this?

1552
01:06:42,000 --> 01:06:42,800
Create file.

1553
01:06:43,100 --> 01:06:45,300
I feel like that doesn't make sense.

1554
01:06:45,900 --> 01:06:48,900
I feel like I was going too fast there, and I write, because you see

1555
01:06:48,900 --> 01:06:49,400
what I'm saying.

1556
01:06:49,800 --> 01:06:51,600
I passed the file name in two places.

1557
01:06:51,600 --> 01:06:52,400
Doesn't seem right.

1558
01:06:52,400 --> 01:06:52,800
Right.

1559
01:06:52,800 --> 01:06:54,500
So either, I don't have to create this Handler.

1560
01:06:54,500 --> 01:06:55,700
I don't have to pass that file name.

1561
01:06:55,700 --> 01:06:57,500
It seemed it seemed odd if I had to do both.

1562
01:06:57,500 --> 01:06:59,800
So let's just go back here and pay a little more attention staff.

1563
01:07:00,000 --> 01:07:02,100
So quickly and just see what happens.

1564
01:07:02,400 --> 01:07:04,400
So the name of the file mapping object.

1565
01:07:04,600 --> 01:07:05,200
This is Paramount.

1566
01:07:05,200 --> 01:07:05,700
Oh, yeah.

1567
01:07:05,700 --> 01:07:06,200
Oh, okay.

1568
01:07:06,200 --> 01:07:08,000
So this is not this is not the file name.

1569
01:07:08,000 --> 01:07:09,700
This is not what we want.

1570
01:07:10,500 --> 01:07:10,700
Yeah.

1571
01:07:10,700 --> 01:07:13,600
So we, this is just if we wanted to refer to this mapping by name, so

1572
01:07:13,600 --> 01:07:14,800
we do need to make the file handle.

1573
01:07:14,800 --> 01:07:16,500
That's, that was not supposed to beat a fella named.

1574
01:07:16,500 --> 01:07:19,800
That's just, that's just a wrongheaded thing.

1575
01:07:20,300 --> 01:07:23,300
Okay, so we have the replay, buffer, get the file name.

1576
01:07:23,300 --> 01:07:24,700
Go ahead on that go in.

1577
01:07:24,700 --> 01:07:28,900
So let's step in here and see what, what crazy stuff we have wrought

1578
01:07:28,900 --> 01:07:29,300
now.

1579
01:07:29,900 --> 01:07:32,500
Because I just, I just did a ton of crap there.

1580
01:07:33,100 --> 01:07:37,600
And so I think it would be good to go through and see what I did.

1581
01:07:37,600 --> 01:07:40,600
Because even I don't remember everything at this point that we just

1582
01:07:40,600 --> 01:07:40,900
did.

1583
01:07:41,000 --> 01:07:41,400
Okay.

1584
01:07:42,000 --> 01:07:45,000
So, first things first, we're going to get a file name.

1585
01:07:45,000 --> 01:07:46,000
And oh, right?

1586
01:07:46,000 --> 01:07:47,200
We can get rid of that assertion.

1587
01:07:47,200 --> 01:07:50,100
Now we were previously asserting that it was only slut index 1 because

1588
01:07:50,100 --> 01:07:54,000
we weren't handling slot into C's, but we are actually handling slot,

1589
01:07:54,000 --> 01:07:55,900
indices now, so we can get rid of that.

1590
01:07:56,400 --> 01:07:57,200
So that's fine.

1591
01:07:58,400 --> 01:07:59,100
Off we go.

1592
01:07:59,700 --> 01:08:03,700
So let's step back into there and see.

1593
01:08:04,100 --> 01:08:04,700
There we go.

1594
01:08:05,000 --> 01:08:08,000
And let's see what that produced Loop.

1595
01:08:08,000 --> 01:08:08,600
Edit 0.

1596
01:08:08,600 --> 01:08:09,700
That looks good.

1597
01:08:10,000 --> 01:08:11,400
So we get that file name.

1598
01:08:11,400 --> 01:08:14,000
Let's see what the the file name produced.

1599
01:08:14,700 --> 01:08:17,700
Let's go ahead and delete these guys.

1600
01:08:17,700 --> 01:08:18,500
Go, go, go away.

1601
01:08:18,500 --> 01:08:19,000
There we go.

1602
01:08:19,399 --> 01:08:22,000
Let's take a look at what that replay buffer looks like right now.

1603
01:08:22,700 --> 01:08:24,200
Okay, so it should have the file name in there.

1604
01:08:24,200 --> 01:08:25,000
It does.

1605
01:08:25,300 --> 01:08:27,700
We try to open the file handle that succeeded.

1606
01:08:27,899 --> 01:08:31,899
We try to open the memory map and that did not succeed.

1607
01:08:31,899 --> 01:08:33,000
So we have an error there.

1608
01:08:33,000 --> 01:08:33,800
That's bad.

1609
01:08:34,000 --> 01:08:34,300
Right?

1610
01:08:34,300 --> 01:08:35,600
That did not work at all.

1611
01:08:35,600 --> 01:08:36,300
Nobody's.

1612
01:08:37,600 --> 01:08:39,399
Why is that execute read, right?

1613
01:08:40,800 --> 01:08:42,700
I did not actually want it to be executed, right?

1614
01:08:42,700 --> 01:08:43,899
That's wrong regardless.

1615
01:08:43,899 --> 01:08:47,899
But yeah, so we have some, we have some some bad news, you know,

1616
01:08:47,899 --> 01:08:50,000
there's, there's, there's some bad things happening here.

1617
01:08:50,300 --> 01:08:51,500
So this call is wrong.

1618
01:08:51,600 --> 01:08:54,300
And then this call fail as well, obviously, because if you can't, if

1619
01:08:54,300 --> 01:08:55,300
we can't get the fat mapping.

1620
01:08:55,500 --> 01:08:57,300
All right, so let's let's go ahead.

1621
01:08:57,300 --> 01:08:59,800
And first of all, I don't, I don't understand why I've got

1622
01:09:00,000 --> 01:09:01,500
Age execute read, right?

1623
01:09:01,500 --> 01:09:04,399
Because we're not supposed to be executing anything from this.

1624
01:09:04,500 --> 01:09:06,500
So that's just that's just wrong.

1625
01:09:07,399 --> 01:09:09,800
I think we, this, this is what I actually wanted.

1626
01:09:10,600 --> 01:09:12,300
We wanted page read, right?

1627
01:09:12,399 --> 01:09:12,800
Yes.

1628
01:09:13,500 --> 01:09:16,399
So this is this is inside create file mapping.

1629
01:09:16,500 --> 01:09:20,700
We've got the the FL protect what this should have been is that should

1630
01:09:20,700 --> 01:09:22,100
have been paid rewrite.

1631
01:09:22,300 --> 01:09:23,399
So that's what that should have been.

1632
01:09:24,300 --> 01:09:27,300
Okay, and then I want to know what these guys are.

1633
01:09:27,300 --> 01:09:29,899
So this is, this is let's make these these

1634
01:09:30,000 --> 01:09:36,000
He's maximum size, High maximum size, low thing, and what, let's read,

1635
01:09:36,000 --> 01:09:36,899
what those actually are.

1636
01:09:37,399 --> 01:09:39,399
Let's see remarks.

1637
01:09:39,399 --> 01:09:44,000
The hierarchy were to the maximum size lower.

1638
01:09:44,000 --> 01:09:44,800
Do you were to this filament?

1639
01:09:44,800 --> 01:09:48,399
Yeah, the maximum size value is equal to the current size of the file.

1640
01:09:48,399 --> 01:09:49,500
So, no, I don't want that.

1641
01:09:49,500 --> 01:09:51,100
So I want this to actually be.

1642
01:09:51,100 --> 01:09:52,300
Yeah.

1643
01:09:52,300 --> 01:09:55,600
I want I want this to actually be what we think the size is so these

1644
01:09:55,600 --> 01:09:57,400
are going to be Max sighs.

1645
01:09:57,400 --> 01:09:57,800
Hi.

1646
01:09:58,300 --> 01:09:59,900
And I'm saying that, that is

1647
01:10:00,000 --> 01:10:07,300
This right and Max sighs low, and I'm saying that that is this, there

1648
01:10:07,300 --> 01:10:09,300
we go, and so max sighs.

1649
01:10:09,300 --> 01:10:11,700
Hi, Max sighs low.

1650
01:10:11,700 --> 01:10:14,000
And we can, at least inspect those and see what they are.

1651
01:10:14,200 --> 01:10:16,800
And let's also see what are the requirements?

1652
01:10:16,800 --> 01:10:18,400
Are there requirements on.

1653
01:10:20,600 --> 01:10:21,800
On these guys as well.

1654
01:10:22,200 --> 01:10:24,500
It's not like I just baked is backed by the operations and paging

1655
01:10:24,500 --> 01:10:24,900
file.

1656
01:10:25,000 --> 01:10:28,600
The H file parameter specifies that when have you felt that across the

1657
01:10:28,600 --> 01:10:29,700
entire range of pages committed.

1658
01:10:29,700 --> 01:10:30,200
We don't care.

1659
01:10:30,200 --> 01:10:31,300
I don't think they care about that stuff.

1660
01:10:31,500 --> 01:10:32,000
All right.

1661
01:10:32,300 --> 01:10:39,300
So what I want to know is does this have to have any kind of just have

1662
01:10:39,300 --> 01:10:42,300
anything special about the file handle that we should know?

1663
01:10:43,500 --> 01:10:45,900
Let's see if I'm mapping creates a film.

1664
01:10:45,900 --> 01:10:46,500
I've got a specified.

1665
01:10:46,500 --> 01:10:48,300
Size is backed by the system paging file.

1666
01:10:48,300 --> 01:10:49,500
Now, we don't want to do that.

1667
01:10:49,700 --> 01:10:50,200
I wonder if it

1668
01:10:50,400 --> 01:10:54,800
Set the the size of the underlying file to be big enough.

1669
01:10:54,900 --> 01:10:56,800
I don't know if that's a requirement either.

1670
01:10:57,700 --> 01:10:58,300
We'll see.

1671
01:10:58,600 --> 01:11:02,000
So the other thing we can do here is I assume that when this fails, it

1672
01:11:02,000 --> 01:11:06,900
will set the last error in Windows to say, what the error actually is.

1673
01:11:07,000 --> 01:11:10,600
So we could call get last error and see what that error is.

1674
01:11:10,700 --> 01:11:13,400
So I'm going to go ahead and put a call in there so we can take a look

1675
01:11:13,400 --> 01:11:13,900
at it.

1676
01:11:14,700 --> 01:11:17,500
So yeah, so I'm going to go ahead and here and say this is failing.

1677
01:11:17,500 --> 01:11:20,000
So let's take a look at what that is.

1678
01:11:20,000 --> 01:11:20,200
Are.

1679
01:11:20,300 --> 01:11:22,300
Our equals get last there.

1680
01:11:23,300 --> 01:11:28,000
And so let's say we go in here and we run it.

1681
01:11:29,500 --> 01:11:30,900
And our file handle.

1682
01:11:31,800 --> 01:11:32,500
Oh, whoops.

1683
01:11:32,600 --> 01:11:35,200
It's the memory map that fails not the file handle.

1684
01:11:35,200 --> 01:11:35,800
My bad.

1685
01:11:36,100 --> 01:11:37,600
I want to see that actually.

1686
01:11:38,300 --> 01:11:41,900
Okay, so we come in here, we call this and it's wrong.

1687
01:11:41,900 --> 01:11:46,500
What's our high and low, by the way that looks about right to me, Max

1688
01:11:46,500 --> 01:11:47,000
sighs.

1689
01:11:47,000 --> 01:11:52,500
Whoa, let's see that in hexadecimal for

1690
01:11:53,800 --> 01:11:55,300
That wait a minute.

1691
01:11:55,700 --> 01:11:56,800
Wait a second.

1692
01:11:56,800 --> 01:11:58,100
What is the total size?

1693
01:11:58,100 --> 01:11:59,800
Hear that, right?

1694
01:12:00,600 --> 01:12:00,900
Okay.

1695
01:12:00,900 --> 01:12:01,500
Yeah, that's right.

1696
01:12:01,500 --> 01:12:01,800
All right.

1697
01:12:01,900 --> 01:12:02,300
Okay.

1698
01:12:03,500 --> 01:12:04,500
Yeah.

1699
01:12:04,500 --> 01:12:05,100
Okay.

1700
01:12:05,100 --> 01:12:05,500
Yeah.

1701
01:12:05,500 --> 01:12:06,100
All right.

1702
01:12:06,100 --> 01:12:06,600
All right.

1703
01:12:06,800 --> 01:12:08,100
I can be satisfied with that.

1704
01:12:08,500 --> 01:12:08,800
All right.

1705
01:12:08,800 --> 01:12:12,900
Anyway, so we got the, we got the, the Mac side of the max Laszlo.

1706
01:12:12,900 --> 01:12:13,900
They look about, right.

1707
01:12:13,900 --> 01:12:17,200
Let me let me verify that they do go in that order as well.

1708
01:12:17,800 --> 01:12:21,400
Just want to make sure that that's the case high and low.

1709
01:12:21,400 --> 01:12:26,400
Yes, so we've got that done but we didn't succeed it getting our

1710
01:12:26,400 --> 01:12:27,400
memory map.

1711
01:12:27,600 --> 01:12:27,900
Oh.

1712
01:12:28,800 --> 01:12:30,900
This time we did succeed at getting our memory map.

1713
01:12:31,100 --> 01:12:34,800
What, what what do we talk?

1714
01:12:34,800 --> 01:12:36,300
So is it just the execute bit?

1715
01:12:36,300 --> 01:12:37,200
That was the problem?

1716
01:12:38,300 --> 01:12:40,800
Weird, so it's a fact that was page, execute read, right?

1717
01:12:40,800 --> 01:12:42,500
I guess that's about the only thing we changed.

1718
01:12:43,100 --> 01:12:44,600
All right, so there's no error now.

1719
01:12:44,600 --> 01:12:46,400
Let's see if map view of file succeeds.

1720
01:12:46,600 --> 01:12:49,400
It does so off we go.

1721
01:12:49,600 --> 01:12:51,600
Yes, that's very odd.

1722
01:12:51,900 --> 01:12:55,600
So now we have those files mapped, which means in theory, those files

1723
01:12:55,600 --> 01:12:57,900
should exist in the build directory, correct?

1724
01:12:57,900 --> 01:12:58,900
And there they are.

1725
01:12:58,900 --> 01:13:02,000
They're all the right size as well, which is good.

1726
01:13:03,100 --> 01:13:04,200
So, I don't know.

1727
01:13:04,200 --> 01:13:07,400
That looks like, it worked very strange.

1728
01:13:07,500 --> 01:13:08,000
So, that's

1729
01:13:08,300 --> 01:13:11,400
I guess that was just because I had the execute bit acts out

1730
01:13:11,400 --> 01:13:14,000
accidentally pasted the execute one in there, which I should not have

1731
01:13:14,000 --> 01:13:14,300
done.

1732
01:13:14,800 --> 01:13:18,500
But I guess that was just, that was the only problem.

1733
01:13:18,700 --> 01:13:22,500
All right, so when we're actually doing the recording here, let's go

1734
01:13:22,500 --> 01:13:25,300
back and check to make sure we're doing this correct properly.

1735
01:13:25,300 --> 01:13:28,600
So when we say, we're going to be recording, we go ahead and we get

1736
01:13:28,600 --> 01:13:29,600
that replay buffer.

1737
01:13:30,500 --> 01:13:34,000
We take a look at the input recording index and we set that to be, you

1738
01:13:34,000 --> 01:13:35,300
know, what's, what's being recorded.

1739
01:13:35,300 --> 01:13:38,000
Currently, we go ahead and set the recording handle.

1740
01:13:38,100 --> 01:13:40,800
Don't even know if this is actually necessary anymore, but probably

1741
01:13:40,800 --> 01:13:41,100
is.

1742
01:13:41,500 --> 01:13:45,500
Anyway, we go ahead and seek past the part that we mapped.

1743
01:13:45,500 --> 01:13:49,000
And then that way all the rights will happen past there.

1744
01:13:49,400 --> 01:13:55,100
And then we copy the memory into that memory map block that we use

1745
01:13:55,100 --> 01:13:55,600
before.

1746
01:13:56,000 --> 01:13:59,100
And the same happens in Reverse down here.

1747
01:13:59,100 --> 01:14:01,700
So I don't know that this may actually just work.

1748
01:14:01,800 --> 01:14:03,800
I don't know if it will or not because I don't know if you can memory

1749
01:14:03,800 --> 01:14:07,300
map a file and write to file handles like that, but we will certainly

1750
01:14:07,300 --> 01:14:07,700
try.

1751
01:14:07,700 --> 01:14:08,000
So,

1752
01:14:08,200 --> 01:14:09,000
You what happens now?

1753
01:14:09,200 --> 01:14:10,300
So we go down here.

1754
01:14:10,400 --> 01:14:14,200
We hit L, we get that really long.

1755
01:14:14,200 --> 01:14:17,600
Pause on that first, right, still happening, which is annoying.

1756
01:14:26,700 --> 01:14:30,300
So we didn't, we didn't read, we reset the state properly, but we're

1757
01:14:30,300 --> 01:14:32,400
not reading back from the file properly.

1758
01:14:32,600 --> 01:14:36,000
So I do wonder if perhaps this thing does not actually work.

1759
01:14:36,300 --> 01:14:39,800
The way that we would want it to, I'm not actually sure, but it's

1760
01:14:39,800 --> 01:14:40,700
still getting a bit.

1761
01:14:40,900 --> 01:14:43,400
That's that still looking a bit wonky.

1762
01:14:43,600 --> 01:14:48,400
So let's say just for the sake of argument that we split this into two

1763
01:14:48,400 --> 01:14:53,700
streams, temporarily to see what happens as a baseline in that

1764
01:14:53,700 --> 01:14:54,400
circumstance.

1765
01:14:54,500 --> 01:14:56,200
So let's say we pass a slot index.

1766
01:14:56,400 --> 01:14:57,300
And a pool.

1767
01:14:57,500 --> 01:14:59,500
Whether it's the input stream, right?

1768
01:14:59,600 --> 01:14:59,900
So we

1769
01:15:00,000 --> 01:15:00,900
Something like this.

1770
01:15:01,100 --> 01:15:06,400
And so then there's just a loop edit and then it's underscore string.

1771
01:15:06,700 --> 01:15:11,000
We take a look at what whether the input stream is set or not.

1772
01:15:11,000 --> 01:15:12,500
If it is, then it's the input.

1773
01:15:12,500 --> 01:15:15,800
Otherwise, it's the state, write something like that.

1774
01:15:16,500 --> 01:15:22,400
And then we'll just actually do a separate open and a separate closed

1775
01:15:22,400 --> 01:15:23,600
for these guys entirely.

1776
01:15:24,800 --> 01:15:27,300
So what is this?

1777
01:15:27,400 --> 01:15:28,700
Does not take four arguments.

1778
01:15:28,700 --> 01:15:29,200
That's true.

1779
01:15:29,200 --> 01:15:30,600
It does not take four arguments.

1780
01:15:31,200 --> 01:15:34,200
So let's go ahead and do that and put file location.

1781
01:15:35,800 --> 01:15:40,300
So what I want to do here right is I want to sort of go back to the

1782
01:15:40,300 --> 01:15:42,800
old way of doing it, but just for the input stream and we're going to

1783
01:15:42,800 --> 01:15:44,300
store the state in a separate file.

1784
01:15:44,300 --> 01:15:47,500
So the input goes into one file, the state goes into another file just

1785
01:15:47,500 --> 01:15:50,300
so I can see what the Baseline performance is of that and so we could

1786
01:15:50,300 --> 01:15:53,900
figure out why writing to one file is causing us so much headaches.

1787
01:15:54,500 --> 01:15:56,500
We've got the input stream thing coming in here.

1788
01:15:56,500 --> 01:15:58,900
So this is not the input stream, right?

1789
01:15:59,100 --> 01:16:00,000
It is not.

1790
01:16:00,600 --> 01:16:03,400
And so if I compile that I should get the thing, that's not the input

1791
01:16:03,400 --> 01:16:08,200
stream and then I do the begin recording input stuff, so we can hear.

1792
01:16:08,300 --> 01:16:11,000
The recording handle is now not going to be that file handle.

1793
01:16:11,000 --> 01:16:12,700
It's going to be an actual file handle.

1794
01:16:12,800 --> 01:16:15,000
We're not going to do the seek to seek is out.

1795
01:16:15,000 --> 01:16:16,700
We're just going to write to a separate file.

1796
01:16:18,900 --> 01:16:22,900
And so we're going to do it like this, right?

1797
01:16:23,400 --> 01:16:24,100
There we go.

1798
01:16:24,600 --> 01:16:29,400
File name and file name, we go.

1799
01:16:29,900 --> 01:16:32,200
Lovely, lovely, lovely.

1800
01:16:32,700 --> 01:16:34,300
So we're just going to do this, right?

1801
01:16:34,300 --> 01:16:37,000
We're going to go ahead and get the new file name.

1802
01:16:37,600 --> 01:16:38,700
That's what we're going to end.

1803
01:16:38,700 --> 01:16:43,000
We're going to create that file entirely from Whole cloth just like we

1804
01:16:43,000 --> 01:16:44,000
were doing before.

1805
01:16:44,400 --> 01:16:48,100
So I'm going to do the create file a, I'm going to use the exact stuff

1806
01:16:48,100 --> 01:16:49,300
that we were using here.

1807
01:16:49,900 --> 01:16:51,300
So file name,

1808
01:16:52,600 --> 01:16:54,700
That generic right?

1809
01:16:55,000 --> 01:16:55,900
And there we go.

1810
01:16:56,700 --> 01:16:58,800
So we've got the clothes handle thing.

1811
01:16:58,800 --> 01:17:00,000
Oh, you know what?

1812
01:17:00,800 --> 01:17:03,500
This was dumb as well, because we didn't want to keep closing it.

1813
01:17:03,600 --> 01:17:07,600
It doesn't actually matter because that was long after our bug

1814
01:17:07,600 --> 01:17:09,900
occurred, but that was something to that.

1815
01:17:09,900 --> 01:17:13,200
Was we shouldn't have of ever been bothering to close the handle that

1816
01:17:13,200 --> 01:17:13,800
was just dumb.

1817
01:17:14,100 --> 01:17:16,000
That would have caused problems later.

1818
01:17:16,700 --> 01:17:19,900
We just, we haven't gotten far enough to have them cause US problems.

1819
01:17:20,300 --> 01:17:20,600
All right.

1820
01:17:20,600 --> 01:17:21,800
So anyway, we've got our

1821
01:17:22,100 --> 01:17:23,600
File here, generic, right?

1822
01:17:23,600 --> 01:17:27,500
Create always, that looks fine to me.

1823
01:17:27,800 --> 01:17:29,200
We don't need to do the seek.

1824
01:17:29,200 --> 01:17:30,900
So we do that recording handle will close it.

1825
01:17:30,900 --> 01:17:34,700
When we end the recording, We Begin playback will do the opposite.

1826
01:17:34,900 --> 01:17:39,300
The playback handle will now be this thing and we'll go ahead and do

1827
01:17:39,800 --> 01:17:40,400
that.

1828
01:17:40,500 --> 01:17:44,700
So we take that out and put my index.

1829
01:17:44,900 --> 01:17:48,500
So now we're going to we're going to open the the file for read and

1830
01:17:48,500 --> 01:17:51,800
will do open existing to try and get the input back.

1831
01:17:52,500 --> 01:17:56,200
And that is again not going to do the seek and then with the clothes

1832
01:17:56,200 --> 01:17:56,700
comes back.

1833
01:17:56,700 --> 01:17:59,800
So I think that's roughly all I really wanted to have.

1834
01:18:00,000 --> 01:18:01,700
Ben what is what is the complaint?

1835
01:18:01,900 --> 01:18:02,200
Yeah.

1836
01:18:02,200 --> 01:18:05,000
File name is not need to not need an address there.

1837
01:18:05,300 --> 01:18:08,300
What, why was there an address there?

1838
01:18:09,000 --> 01:18:15,700
Oh, because that was just full on the lon Salon bogus.

1839
01:18:16,500 --> 01:18:17,600
That's what to take the state.

1840
01:18:17,600 --> 01:18:18,300
Not, the founding.

1841
01:18:18,300 --> 01:18:19,400
Don't know what I was thinking there.

1842
01:18:19,800 --> 01:18:20,300
Okay.

1843
01:18:20,700 --> 01:18:22,100
So let's take a look at what we've got now.

1844
01:18:22,500 --> 01:18:24,900
So off we go, we hit l.

1845
01:18:38,600 --> 01:18:40,100
So that looks fine to me.

1846
01:18:40,800 --> 01:18:41,400
Right?

1847
01:18:41,600 --> 01:18:45,400
Nothing particularly odd there and it does seem like this is now much

1848
01:18:45,400 --> 01:18:51,000
faster than it was right that pauses pretty brief compared to the old

1849
01:18:51,000 --> 01:18:51,600
paws.

1850
01:18:54,600 --> 01:18:57,600
I think there's no doubt that that's considerably faster, right?

1851
01:18:59,800 --> 01:19:00,200
Yeah.

1852
01:19:06,700 --> 01:19:13,400
So, yeah, I'm a little confused as to why the behavior is such that

1853
01:19:13,400 --> 01:19:16,800
setting that file pointer causes that problem.

1854
01:19:18,000 --> 01:19:23,100
But it's not like we really care because having them into files is not

1855
01:19:23,100 --> 01:19:24,700
really a problem for us.

1856
01:19:24,900 --> 01:19:27,200
It's totally fine for us to do that.

1857
01:19:28,700 --> 01:19:31,300
Let's, let's delete these guys here.

1858
01:19:32,500 --> 01:19:33,500
So, if they're gone.

1859
01:19:34,800 --> 01:19:39,200
So if we go ahead and run, this startup is instantaneous, even though

1860
01:19:39,200 --> 01:19:41,900
we have mapped those files because all it's doing is reserving the

1861
01:19:41,900 --> 01:19:43,000
space on the disk for them.

1862
01:19:43,000 --> 01:19:43,600
Right?

1863
01:19:44,300 --> 01:19:45,100
And that's fine.

1864
01:19:45,500 --> 01:19:53,000
But now if I go back into here when I initially do that, I do get a

1865
01:19:53,100 --> 01:19:55,900
you know, it's a much shorter pause that before but I'm still not sure

1866
01:19:55,900 --> 01:19:57,700
if that's how long the pause should be.

1867
01:19:57,800 --> 01:20:01,000
That still seems like perhaps a little long for the copy seemed to

1868
01:20:01,000 --> 01:20:03,000
take that long, which was kind of odd.

1869
01:20:03,000 --> 01:20:03,900
I feel like the memory

1870
01:20:04,100 --> 01:20:07,100
Within this machine should be higher than that, but maybe that's just

1871
01:20:07,100 --> 01:20:08,700
my intuition being incorrect.

1872
01:20:08,700 --> 01:20:12,100
I'm not sure but point being were way faster than we were before.

1873
01:20:12,100 --> 01:20:13,700
So that's at least good progress.

1874
01:20:14,100 --> 01:20:18,400
And I maybe we don't necessarily need to belabor the point much longer

1875
01:20:18,900 --> 01:20:21,400
we can think about this a little bit more and you know, someday we

1876
01:20:21,400 --> 01:20:22,500
want a bonus thing to do.

1877
01:20:22,500 --> 01:20:23,500
We can look at it again.

1878
01:20:23,900 --> 01:20:28,000
What I think would be interesting to do here, maybe is too.

1879
01:20:28,800 --> 01:20:32,300
I wonder if we want to actually support all four of the streams.

1880
01:20:32,300 --> 01:20:33,700
Now, by actually putting in

1881
01:20:34,000 --> 01:20:36,000
One two, three four kind of a system.

1882
01:20:36,000 --> 01:20:40,700
Maybe you hit alt 12 record that or something like this.

1883
01:20:41,600 --> 01:20:44,700
So you do alt one and then, you know, ended or something like that.

1884
01:20:44,700 --> 01:20:45,500
I'm not sure.

1885
01:20:50,000 --> 01:20:52,700
Hard to say, we'll leave it like this for now and if we ever need

1886
01:20:52,700 --> 01:20:55,300
anything it, when we need more, we'll use more.

1887
01:20:56,000 --> 01:20:56,600
All right.

1888
01:20:57,900 --> 01:20:59,900
Well, I think that's probably.

1889
01:21:00,000 --> 01:21:03,900
We enough for now because we did blow through a bunch of Q&A time,

1890
01:21:03,900 --> 01:21:05,400
which I will just go long on the Q&A.

1891
01:21:05,400 --> 01:21:07,200
I like on Fridays to kind of go along.

1892
01:21:08,100 --> 01:21:10,700
I don't try to think if there's anything else I want to do.

1893
01:21:10,700 --> 01:21:11,400
I don't think there is.

1894
01:21:11,400 --> 01:21:13,800
I just wanted to look and see how long that would take.

1895
01:21:14,000 --> 01:21:14,800
And this is something.

1896
01:21:14,800 --> 01:21:17,700
If people want something to play around with it, home trying to figure

1897
01:21:17,700 --> 01:21:19,300
out exactly what is taking the time.

1898
01:21:19,300 --> 01:21:23,400
There might be interesting seeing, if that copy memory thing happens

1899
01:21:23,400 --> 01:21:25,100
at a reasonable speed as well.

1900
01:21:25,100 --> 01:21:27,400
Like should it be taking as long as it is?

1901
01:21:27,600 --> 01:21:29,800
How long should it take to copy one gigabyte?

1902
01:21:30,000 --> 01:21:34,100
Height of memory because I'm not sure what the memory bandwidth is of

1903
01:21:34,100 --> 01:21:34,800
this machine.

1904
01:21:34,800 --> 01:21:35,000
Right?

1905
01:21:35,000 --> 01:21:38,700
Like I'm not sure how long one megabyte should take to copy.

1906
01:21:39,300 --> 01:21:41,400
And so what we need to do is actually figure that out.

1907
01:21:41,400 --> 01:21:42,100
I don't know.

1908
01:21:42,100 --> 01:21:46,600
I mean, I guess we could potentially if I go in here I suppose we

1909
01:21:46,600 --> 01:21:48,700
could take a look.

1910
01:21:48,700 --> 01:21:52,300
This is a w 5580, right?

1911
01:21:53,500 --> 01:21:55,100
That's the processor type.

1912
01:21:55,600 --> 01:21:59,800
And so if I were to go here and say, w55 a team,

1913
01:22:00,000 --> 01:22:01,400
Memory bandwidth with somebody.

1914
01:22:01,400 --> 01:22:04,600
Tell me what it was right?

1915
01:22:05,500 --> 01:22:07,000
So, let's see.

1916
01:22:13,200 --> 01:22:14,500
I don't know what the memory bandwidth is.

1917
01:22:14,500 --> 01:22:16,500
There's a lot of things that have the word memory bandwidth.

1918
01:22:16,500 --> 01:22:20,000
I don't know if they will actually tell me what the memory bandwidth

1919
01:22:20,200 --> 01:22:20,800
is.

1920
01:22:22,500 --> 01:22:28,000
Let's see, is this mb/s unbuffered memory test?

1921
01:22:28,000 --> 01:22:30,000
Is this unbuffered memory bandwidth?

1922
01:22:31,100 --> 01:22:32,600
Mb/s.

1923
01:22:33,200 --> 01:22:34,400
Higher is better.

1924
01:22:34,800 --> 01:22:35,300
So

1925
01:22:38,300 --> 01:22:41,400
I mean, okay, so I don't actually know right.

1926
01:22:41,400 --> 01:22:45,600
I mean, I'm not I'm II know nothing about this CPU.

1927
01:22:45,600 --> 01:22:47,000
I don't even remember.

1928
01:22:47,000 --> 01:22:48,000
Like, I had to look up.

1929
01:22:48,000 --> 01:22:50,100
Even what would she be was in this machine?

1930
01:22:51,500 --> 01:22:58,500
But if this is actually an unbuffered memory test, right, it's saying

1931
01:22:58,500 --> 01:23:01,900
that this is the number of megabytes per second, right?

1932
01:23:02,500 --> 01:23:07,600
So, ten thousand megabytes per second is in like the 10 gigabytes a

1933
01:23:07,600 --> 01:23:09,500
second range, right?

1934
01:23:10,300 --> 01:23:15,100
So 10 gigabytes a second means that it should take a tenth of a second

1935
01:23:15,400 --> 01:23:18,300
to copy a gigabyte of memory, right?

1936
01:23:18,400 --> 01:23:19,200
I mean

1937
01:23:20,500 --> 01:23:25,200
In theory, it should really not be taking the amount of time that

1938
01:23:25,200 --> 01:23:25,900
we're seeing.

1939
01:23:25,900 --> 01:23:30,100
So it feels like something is still kind of wrong there.

1940
01:23:30,600 --> 01:23:34,900
And so maybe I'm just misreading this but you understand why I'm a

1941
01:23:34,900 --> 01:23:38,400
little apprehensive about what we're seeing.

1942
01:23:38,400 --> 01:23:40,900
So I don't actually know again what these I'm not sure.

1943
01:23:40,900 --> 01:23:43,700
I'm not even reading these Pages because I don't have time to kind of

1944
01:23:43,700 --> 01:23:45,800
sit here and and read through them on stream.

1945
01:23:45,800 --> 01:23:47,600
But like it's a bit odd.

1946
01:23:48,700 --> 01:23:49,900
Let's see what this says.

1947
01:23:50,500 --> 01:23:51,000
Here we go.

1948
01:23:51,000 --> 01:23:52,900
Here's the spec sheet, right?

1949
01:23:52,900 --> 01:23:55,300
Here's the spec sheet for the w55, 80.

1950
01:23:56,300 --> 01:23:59,800
And so, here's the, the stuff here.

1951
01:24:00,000 --> 01:24:04,400
UPI, speed, right transfers, computer components are between

1952
01:24:04,700 --> 01:24:05,400
computers.

1953
01:24:05,400 --> 01:24:06,700
We don't actually care about that.

1954
01:24:07,100 --> 01:24:08,500
Where's the memory bandwidth?

1955
01:24:08,700 --> 01:24:10,000
Max, memory science?

1956
01:24:10,300 --> 01:24:12,400
Wow, that's a lot of memory 144 GB.

1957
01:24:12,600 --> 01:24:13,400
Max very bandwidth.

1958
01:24:13,400 --> 01:24:14,700
32, GB s.

1959
01:24:15,600 --> 01:24:16,200
So

1960
01:24:19,900 --> 01:24:21,100
You see why I'm perplexed.

1961
01:24:21,100 --> 01:24:21,600
Right?

1962
01:24:21,600 --> 01:24:22,600
You see why?

1963
01:24:22,600 --> 01:24:26,300
I don't feel like we're doing things correctly because if the

1964
01:24:26,300 --> 01:24:30,100
processor is supposed to be able to get a max memory bandwidth of 32

1965
01:24:30,100 --> 01:24:34,900
gigabytes, a second then, even if we were only getting like, 10% of

1966
01:24:34,900 --> 01:24:38,800
that memory bandwidth, we should be getting 3 gigabytes a second which

1967
01:24:38,800 --> 01:24:42,400
means it should take 300 milliseconds to copy a gigabyte of memory

1968
01:24:42,400 --> 01:24:46,000
that is taking more like a second, right?

1969
01:24:46,000 --> 01:24:49,600
And we can go time it and see exactly how long it's

1970
01:24:50,400 --> 01:24:54,600
But it ain't as fast as it should be.

1971
01:24:54,800 --> 01:24:56,600
So there's something else, like

1972
01:24:58,400 --> 01:25:01,400
The operating system is interceding in a way there.

1973
01:25:01,400 --> 01:25:05,700
I think that is making it perhaps so that like, you know, maybe those

1974
01:25:05,700 --> 01:25:09,300
pages that were mapped to the file as we're doing the copy into them

1975
01:25:09,300 --> 01:25:10,400
or something like that.

1976
01:25:11,600 --> 01:25:12,000
I don't know.

1977
01:25:12,000 --> 01:25:15,800
Maybe it's maybe it's getting its having to sort of write them for the

1978
01:25:15,800 --> 01:25:16,200
first time.

1979
01:25:16,200 --> 01:25:16,400
I did it.

1980
01:25:16,400 --> 01:25:19,200
Let's see what happens when we do to records in a row.

1981
01:25:19,300 --> 01:25:20,900
Let's ask that question, right?

1982
01:25:22,000 --> 01:25:25,500
So there's the first record not taking too long but still takes longer

1983
01:25:25,500 --> 01:25:26,500
than I think it should.

1984
01:25:26,500 --> 01:25:26,700
Okay.

1985
01:25:26,700 --> 01:25:30,800
Now we Loop and We're looping, right, but I can stop looping if I want

1986
01:25:30,800 --> 01:25:33,400
to and do another record, right?

1987
01:25:34,400 --> 01:25:35,000
So

1988
01:25:49,200 --> 01:25:53,100
So that makes it may actually just be the initial work of the paging

1989
01:25:53,300 --> 01:25:55,500
the initial time that it has to do this stuff.

1990
01:25:55,700 --> 01:25:58,900
Maybe that's the case because now it's like alright, let's do our

1991
01:25:58,900 --> 01:26:00,800
recording and it's like

1992
01:26:05,600 --> 01:26:06,600
Yeah, I don't know.

1993
01:26:06,800 --> 01:26:07,300
I don't know.

1994
01:26:07,600 --> 01:26:08,200
It's a little bit.

1995
01:26:08,200 --> 01:26:09,500
It's a little bit confusing to me.

1996
01:26:13,300 --> 01:26:14,900
It's a little bit confusing to me.

1997
01:26:15,600 --> 01:26:16,900
So, all right.

1998
01:26:17,300 --> 01:26:20,700
Well, let's just go ahead and and and I'm sorry, I'm sorry.

1999
01:26:20,700 --> 01:26:21,800
I'm obsessing on this.

2000
01:26:21,800 --> 01:26:23,400
I know that it's just on the Friday stream.

2001
01:26:23,400 --> 01:26:27,600
I can obsess because I don't have any hard deadline to stop me.

2002
01:26:28,100 --> 01:26:31,600
So anyway, let's see if this is down, if the input recording index is

2003
01:26:31,600 --> 01:26:33,400
0, that's it.

2004
01:26:33,500 --> 01:26:36,500
So we need a way, we don't have a way to stop recording, right?

2005
01:26:36,500 --> 01:26:39,400
We have no way to actually end the recording.

2006
01:26:39,600 --> 01:26:42,400
So we need to do is if the, if the info recording is 0, then it

2007
01:26:42,400 --> 01:26:42,900
starts.

2008
01:26:43,500 --> 01:26:47,400
We need to basically say we need to we need to do if state plate

2009
01:26:47,400 --> 01:26:48,100
playing.

2010
01:26:50,100 --> 01:26:52,200
Playback index or whatever.

2011
01:26:52,200 --> 01:26:52,500
It is.

2012
01:26:52,500 --> 01:26:59,700
What's the what's input playing index if that equals 0, then we do

2013
01:26:59,700 --> 01:26:59,800
this.

2014
01:27:00,900 --> 01:27:08,100
But otherwise if if not, we end playback and Playback.

2015
01:27:09,200 --> 01:27:10,700
Oops getting too close to my head.

2016
01:27:11,300 --> 01:27:15,700
So right like basically I do is say okay if there was nothing playing

2017
01:27:16,200 --> 01:27:19,100
then if there was nothing recording then we begin recording.

2018
01:27:19,200 --> 01:27:21,500
Otherwise we end recording and begin playback.

2019
01:27:22,100 --> 01:27:26,800
If there was something playing we just stop whatever was playing right

2020
01:27:28,000 --> 01:27:29,900
and I feel like that should do.

2021
01:27:30,000 --> 01:27:30,200
Do it.

2022
01:27:30,200 --> 01:27:32,000
And I want to make sure that actually works because there's like some

2023
01:27:32,000 --> 01:27:33,300
ping-pong logic in there.

2024
01:27:33,800 --> 01:27:34,300
Right?

2025
01:27:34,400 --> 01:27:38,500
And I want to make sure that that it actually works somewhat reliably,

2026
01:27:39,100 --> 01:27:39,700
right?

2027
01:27:39,700 --> 01:27:42,300
So I'm here, I hit L.

2028
01:27:42,900 --> 01:27:44,800
I do my little dance.

2029
01:27:44,900 --> 01:27:46,400
I hit elegant and we're playing back.

2030
01:27:46,400 --> 01:27:48,300
We're looping right?

2031
01:27:48,900 --> 01:27:49,600
Looping.

2032
01:27:49,900 --> 01:27:53,700
I hit Elvis top and now we're back in control.

2033
01:27:53,800 --> 01:27:54,900
Let's see if we can do it again.

2034
01:27:55,200 --> 01:27:58,500
L, do up and down.

2035
01:27:58,500 --> 01:27:59,800
It's a little Sawtooth.

2036
01:28:00,100 --> 01:28:00,600
Bloop.

2037
01:28:03,000 --> 01:28:05,200
Yeah, so it looks like we're good.

2038
01:28:07,800 --> 01:28:09,300
Yeah, looks like we're good.

2039
01:28:09,400 --> 01:28:13,600
I would call that certainly not shippable quality, but I would call

2040
01:28:13,600 --> 01:28:15,600
that good enough for debugging purposes for now.

2041
01:28:15,800 --> 01:28:18,300
So, yeah, let's let's say that that's good.

2042
01:28:18,300 --> 01:28:20,600
And the other thing, you know, what I want to do here as well is I

2043
01:28:20,600 --> 01:28:22,500
want to do the win32.

2044
01:28:23,200 --> 01:28:29,000
We do that sort of drawing of the audio buffer, the sort of succinct

2045
01:28:29,000 --> 01:28:29,800
display thing.

2046
01:28:30,500 --> 01:28:37,100
So I want to basically get rid of that for now and say that this is is

2047
01:28:37,100 --> 01:28:37,500
not going to

2048
01:28:37,600 --> 01:28:38,300
Pain anymore.

2049
01:28:40,500 --> 01:28:43,900
See here, when 32 or you know, what am I allowed?

2050
01:28:44,000 --> 01:28:45,700
Let's, let's talk about this for a second.

2051
01:28:45,700 --> 01:28:47,900
Am I allowed to do this to prevent that warning?

2052
01:28:48,100 --> 01:28:52,400
Can I just do still leave it the call in, but have it be on a call

2053
01:28:52,400 --> 01:28:53,600
that can never actually happen.

2054
01:28:55,300 --> 01:28:55,800
Additional stress.

2055
01:28:58,000 --> 01:28:58,600
No, I guess.

2056
01:28:58,600 --> 01:28:59,300
I can't.

2057
01:28:59,600 --> 01:29:00,200
All right.

2058
01:29:00,200 --> 01:29:04,400
Well, in that case, I guess we will just go ahead and comment out that

2059
01:29:04,400 --> 01:29:05,100
call for now.

2060
01:29:05,100 --> 01:29:06,900
And talk will just get rid of the call entirely.

2061
01:29:07,000 --> 01:29:10,900
And then the win32 sync, display went through to sink display.

2062
01:29:11,900 --> 01:29:15,200
We are going to, cause the next time, we revisit that, we're going to

2063
01:29:15,200 --> 01:29:18,400
put it the drawing up in the actual platform code using a real

2064
01:29:18,400 --> 01:29:20,100
renderer, so we can draw stuff for real.

2065
01:29:20,200 --> 01:29:24,900
So I'm just going to go ahead and and comment out this stuff entirely.

2066
01:29:25,700 --> 01:29:29,600
Because we don't actually need it and we will be moving it out into

2067
01:29:29,600 --> 01:29:30,700
the platform layer later.

2068
01:29:31,100 --> 01:29:32,900
So there we go.

2069
01:29:32,900 --> 01:29:35,100
We are now at least only doing

2070
01:29:38,800 --> 01:29:42,000
So we're been the Tigers on we're at now least only doing the

2071
01:29:42,000 --> 01:29:45,300
rendering that we actually need to do in the game and everything is

2072
01:29:45,300 --> 01:29:47,200
rendering inside the game, which is what we wanted.

2073
01:29:47,400 --> 01:29:49,600
We still have our frame rate print out and that is something.

2074
01:29:49,600 --> 01:29:52,100
I guess we can turn off as well at the moment.

2075
01:29:52,300 --> 01:29:57,600
We got rfps kind of print out here, we can turn that off because I

2076
01:29:57,600 --> 01:29:59,800
don't think we actually care about that at all.

2077
01:30:01,000 --> 01:30:02,000
So, we'll turn that off.

2078
01:30:02,000 --> 01:30:06,400
And these will be things that like I said, will hoist up into the

2079
01:30:06,400 --> 01:30:08,300
actual platform code when we have.

2080
01:30:08,300 --> 01:30:11,800
So we can have a kind of real debug displays and not these sort of

2081
01:30:11,800 --> 01:30:12,500
hacky ones.

2082
01:30:13,100 --> 01:30:16,500
So we're not printing out anything every frame anymore.

2083
01:30:16,700 --> 01:30:17,700
So that's good.

2084
01:30:18,300 --> 01:30:19,500
Kind of have that going.

2085
01:30:19,700 --> 01:30:23,300
Do our input Loop, double check that that actually works.

2086
01:30:25,200 --> 01:30:26,000
There we go.

2087
01:30:26,600 --> 01:30:27,500
It's in good shape.

2088
01:30:28,900 --> 01:30:31,200
Alright, I think that's it.

2089
01:30:31,500 --> 01:30:34,700
Everything else seems relatively good.

2090
01:30:35,200 --> 01:30:37,700
Alright, so let's call that for the day.

2091
01:30:38,200 --> 01:30:41,600
We did an extra 30 minutes today of coding because I was kind of

2092
01:30:41,600 --> 01:30:44,100
curious about what was going on there with those memory mapped files.

2093
01:30:44,300 --> 01:30:46,600
I feel like there's still more, we need to learn.

2094
01:30:47,200 --> 01:30:50,600
I feel like we need to learn really like what the most efficient way

2095
01:30:50,600 --> 01:30:53,800
is to get Windows to kind of

2096
01:30:55,800 --> 01:30:59,500
To do the most efficient thing there and I don't know if maybe we need

2097
01:30:59,500 --> 01:31:00,500
to not do.

2098
01:31:00,500 --> 01:31:02,700
I'm not trying to think it's like the copy memory is doing something

2099
01:31:02,700 --> 01:31:06,000
else that we that we, that it shouldn't be doing or what exactly is

2100
01:31:06,000 --> 01:31:09,100
happening and will have to time it.

2101
01:31:09,100 --> 01:31:10,400
Maybe we'll do some profiling.

2102
01:31:10,400 --> 01:31:13,100
So so I would like to know more about that.

2103
01:31:13,100 --> 01:31:16,900
I'm not satisfied with my understanding of what Windows is doing in

2104
01:31:16,900 --> 01:31:19,800
that case, and I feel like there's stuff that were missing.

2105
01:31:20,200 --> 01:31:25,300
So I'm going to go ahead and say to do Casey recording.

2106
01:31:25,600 --> 01:31:29,800
I'm still seems to take too long on record.

2107
01:31:29,800 --> 01:31:37,400
Start find out what Windows is doing and if we can speed up defer,

2108
01:31:38,000 --> 01:31:39,400
some of that processing.

2109
01:31:41,100 --> 01:31:43,800
So yeah.

2110
01:31:47,200 --> 01:31:47,600
Yeah.

2111
01:31:48,200 --> 01:31:48,900
All right.

2112
01:31:49,000 --> 01:31:50,600
Well, that is it for now.

2113
01:31:50,600 --> 01:31:54,600
Let us let us do some Q&A.

2114
01:31:54,700 --> 01:31:57,200
I think it's time for some Q&A.

2115
01:31:57,700 --> 01:32:00,100
So, please put see me oratory.

2116
01:32:01,100 --> 01:32:03,500
I'm going to go ahead and whoo, I'm hot.

2117
01:32:03,700 --> 01:32:06,000
Get my hair is all I got Pig hair.

2118
01:32:06,000 --> 01:32:06,200
You know what?

2119
01:32:06,200 --> 01:32:06,800
I can't see it.

2120
01:32:06,800 --> 01:32:07,900
Let me see what I look like.

2121
01:32:08,200 --> 01:32:08,300
Yeah.

2122
01:32:08,300 --> 01:32:09,700
It kind of matted me down.

2123
01:32:09,700 --> 01:32:11,400
I'm all matted down for the pig.

2124
01:32:11,600 --> 01:32:14,400
You know, it looks like some kind of it.

2125
01:32:14,400 --> 01:32:16,800
Looks like some kind of a skull cap here, right?

2126
01:32:17,400 --> 01:32:18,600
Yeah awful.

2127
01:32:18,700 --> 01:32:21,400
All right, anyway, but you know, when you wear the big hat, you got to

2128
01:32:21,400 --> 01:32:22,600
take the consequences, right?

2129
01:32:22,600 --> 01:32:25,900
You can expect to have fabulous hair after you wear the big hat.

2130
01:32:26,500 --> 01:32:27,900
All right, so I think that's it.

2131
01:32:28,300 --> 01:32:31,600
Let us do questions and that'll be good.

2132
01:32:32,600 --> 01:32:34,000
And that will be good.

2133
01:32:41,500 --> 01:32:44,700
And please put Senior ettore in your question.

2134
01:32:45,300 --> 01:32:45,900
Let's see.

2135
01:32:46,800 --> 01:32:49,500
Maybe first copy is causing Alec and 0 on fault.

2136
01:32:49,500 --> 01:32:51,900
Maybe a second copy could be would be fast.

2137
01:32:52,500 --> 01:32:54,600
So yeah, I mean that's what I was assuming is basically.

2138
01:32:54,600 --> 01:32:57,300
Like there's some kind of like Windows is clearing in the pages or who

2139
01:32:57,300 --> 01:32:59,800
knows what's happening, but it doesn't really explain.

2140
01:33:00,000 --> 01:33:02,000
Why the second copy wasn't more instantaneous?

2141
01:33:02,000 --> 01:33:04,900
I mean 300 milliseconds shouldn't be even that perceptible to us.

2142
01:33:04,900 --> 01:33:07,000
Like, it shouldn't look like a second pause.

2143
01:33:07,000 --> 01:33:07,900
So I don't.

2144
01:33:08,100 --> 01:33:12,900
And that was, you know, it's supposed to get 32 men, 32 megabytes Peak

2145
01:33:12,900 --> 01:33:16,500
and it was getting 10, MB s in the Sandra Benchmark or whatever.

2146
01:33:17,000 --> 01:33:17,400
That means.

2147
01:33:17,400 --> 01:33:20,600
It should only be taking, I'm sorry, 10 gigabytes.

2148
01:33:20,600 --> 01:33:20,900
A second.

2149
01:33:20,900 --> 01:33:22,800
That means should be taking 100 milliseconds.

2150
01:33:23,100 --> 01:33:24,000
That should be.

2151
01:33:24,200 --> 01:33:28,100
We should only see like a 3 frame pause right to do that copy.

2152
01:33:28,100 --> 01:33:29,800
So it's just a little

2153
01:33:30,000 --> 01:33:31,600
Little dicey, so I don't know.

2154
01:33:32,200 --> 01:33:38,300
Yeah, and and what we really need to do, if we want to, if we want to

2155
01:33:38,300 --> 01:33:41,000
investigate this further, it start timing these copy memories.

2156
01:33:41,200 --> 01:33:43,900
See, how long they're taking, and make sure it's reasonable.

2157
01:33:44,100 --> 01:33:44,800
Let me see.

2158
01:33:44,800 --> 01:33:45,200
What is that?

2159
01:33:45,200 --> 01:33:49,300
Total size set to again, make sure I'm not misremembering.

2160
01:33:50,100 --> 01:33:50,800
So it's 1.

2161
01:33:50,800 --> 01:33:53,800
GB + 64 megabytes, right?

2162
01:33:56,700 --> 01:34:00,700
1 GB, + 64 member MB transistors.

2163
01:34:05,000 --> 01:34:05,700
Sorry, I'm just

2164
01:34:08,200 --> 01:34:09,900
trying to think here.

2165
01:34:12,100 --> 01:34:13,600
So I think that's all correct.

2166
01:34:13,700 --> 01:34:15,100
I mean it certainly seems it.

2167
01:34:15,200 --> 01:34:19,700
So if we come in here, let's double-check, if we come in here, we do

2168
01:34:20,300 --> 01:34:21,300
total size.

2169
01:34:22,200 --> 01:34:25,200
Oops, total size is undefined win32 State, total size.

2170
01:34:25,500 --> 01:34:26,100
Right?

2171
01:34:26,100 --> 01:34:28,000
Let's do X decimal display.

2172
01:34:28,500 --> 01:34:33,400
And that does look like 1 GB + 64 MB that that does seem reasonable.

2173
01:34:33,900 --> 01:34:35,600
So, yeah, I mean, I don't know.

2174
01:34:35,800 --> 01:34:37,100
I don't know why it's having such trouble.

2175
01:34:37,800 --> 01:34:41,700
But yeah, we'd have to start doing some more serious profiling.

2176
01:34:41,900 --> 01:34:44,800
Which someday we will do when we have more profiling tools.

2177
01:34:50,300 --> 01:34:52,200
Can you turn off the sound?

2178
01:34:52,200 --> 01:34:53,700
Can you log onto the chat?

2179
01:34:53,700 --> 01:34:57,700
So the app will autocorrect turn off the sound.

2180
01:34:59,900 --> 01:35:03,300
Do you mean just not produce the debug sine wave?

2181
01:35:03,900 --> 01:35:07,600
But as for logging into the chat, I login by RC is the problem.

2182
01:35:07,600 --> 01:35:10,400
So, that's the problem with the auto correct.

2183
01:35:16,600 --> 01:35:17,500
Let's see.

2184
01:35:29,100 --> 01:35:31,700
An interesting part of this project is that you're implementing.

2185
01:35:31,700 --> 01:35:35,100
All the components yourself that you take as given in an existing game

2186
01:35:35,100 --> 01:35:35,500
engine.

2187
01:35:35,500 --> 01:35:39,000
That said, do you intend for these components to be reusable in future

2188
01:35:39,000 --> 01:35:39,700
projects?

2189
01:35:40,100 --> 01:35:43,200
IE there by almost, creating a new game engine in its own, right?

2190
01:35:43,200 --> 01:35:47,200
Or is it all or is all the code tightly coupled to handmade hero?

2191
01:35:49,500 --> 01:35:55,300
I guess what I would say is I'm not sure because it will depend how

2192
01:35:55,300 --> 01:35:55,900
things come out.

2193
01:35:55,900 --> 01:35:59,800
I am not trying to make a game engine that can.

2194
01:36:00,000 --> 01:36:00,700
Used.

2195
01:36:01,000 --> 01:36:04,900
So I will not be doing anything extra to make things reusable.

2196
01:36:05,300 --> 01:36:08,400
So it is likely that a lot of things will be relatively tightly

2197
01:36:08,400 --> 01:36:09,700
coupled to handmade hero.

2198
01:36:10,100 --> 01:36:13,200
That said, it may be that in the course of making handmade hero.

2199
01:36:13,200 --> 01:36:16,100
There's a number of things that just happen to be easily reusable

2200
01:36:16,100 --> 01:36:20,300
because that's just the most sensible way to write them anyway, but

2201
01:36:20,300 --> 01:36:22,700
yeah, I don't care about making a reusable engine.

2202
01:36:22,700 --> 01:36:24,500
That's not part of the goal of the project.

2203
01:36:24,500 --> 01:36:27,800
The goal is to make an engine that runs handmade hero so that you can

2204
01:36:27,800 --> 01:36:28,700
see how it works.

2205
01:36:29,300 --> 01:36:29,800
That makes sense.

2206
01:36:30,000 --> 01:36:30,100
Us.

2207
01:36:32,600 --> 01:36:33,700
Why the pig hat?

2208
01:36:33,700 --> 01:36:34,700
Because we're being piggy.

2209
01:36:34,700 --> 01:36:40,100
I mean, we allocated like five gigabytes of memory on Startup, right?

2210
01:36:40,100 --> 01:36:41,100
That's very piggy.

2211
01:36:41,600 --> 01:36:43,000
You have to admit, it's kind of piggy.

2212
01:36:44,600 --> 01:36:45,800
Why don't you use the visual studio?

2213
01:36:45,800 --> 01:36:47,700
Profiler and analyze performance?

2214
01:36:48,500 --> 01:36:52,300
Well, honestly, because I'd rather write it ourselves.

2215
01:36:52,400 --> 01:36:54,900
So you can see how to have a built-in profiler.

2216
01:36:56,600 --> 01:36:59,100
So we will be like making our own like profiling tools.

2217
01:36:59,100 --> 01:37:00,500
So we can kind of see how they work.

2218
01:37:00,600 --> 01:37:01,200
That makes sense.

2219
01:37:04,700 --> 01:37:05,200
C.

2220
01:37:06,200 --> 01:37:07,200
300 milliseconds.

2221
01:37:07,200 --> 01:37:08,200
Yeah, but 300.

2222
01:37:08,200 --> 01:37:11,800
So I was saying, 30 seconds, cause I just randomly said, 10% of the

2223
01:37:11,800 --> 01:37:12,500
bamboo bandwidth.

2224
01:37:12,500 --> 01:37:14,900
So that was like a maximum, the standard Benchmark.

2225
01:37:14,900 --> 01:37:17,800
Looks like it said, 10 gigabytes a second sustained.

2226
01:37:18,000 --> 01:37:22,800
So, you know, if it's 10 gigabytes a second sustain that should be 100

2227
01:37:22,800 --> 01:37:28,100
milliseconds or, you know, three frames, right?

2228
01:37:28,800 --> 01:37:31,500
Which is just not that many but maybe, you know, it's hard to say

2229
01:37:31,500 --> 01:37:34,300
well, if we actually timed it which is what the next.

2230
01:37:34,400 --> 01:37:36,200
Be, we would know for sure.

2231
01:37:36,200 --> 01:37:37,200
How much longer is taking?

2232
01:37:40,200 --> 01:37:42,100
Does it lack if you save a smaller file size?

2233
01:37:42,100 --> 01:37:44,600
That's a good idea, because that's pretty easy to test.

2234
01:37:44,600 --> 01:37:47,700
So, suppose we take a look at these and we just say we're going to

2235
01:37:47,700 --> 01:37:48,300
delete them.

2236
01:37:48,300 --> 01:37:48,600
Right?

2237
01:37:48,600 --> 01:37:51,500
So we delete all our HMI files, they're gone, right?

2238
01:37:51,900 --> 01:37:55,100
And let's say we go in here and now say that instead of allocating a

2239
01:37:55,100 --> 01:37:55,800
gigabyte.

2240
01:37:55,800 --> 01:37:57,500
There's just no transient storage.

2241
01:37:57,600 --> 01:38:03,100
It's it's, you know, another 64 GB megabytes of transient storage.

2242
01:38:03,100 --> 01:38:06,400
So now, we're just writing 128 megabytes, much, much less than we were

2243
01:38:06,400 --> 01:38:07,000
before.

2244
01:38:12,400 --> 01:38:13,600
It's certainly much faster.

2245
01:38:15,100 --> 01:38:16,200
Right, there's no question.

2246
01:38:16,200 --> 01:38:17,200
That's much faster.

2247
01:38:17,400 --> 01:38:18,400
So it's all becoming.

2248
01:38:18,500 --> 01:38:20,600
So is definitely proportional to size.

2249
01:38:20,700 --> 01:38:24,000
There isn't a some totally stupid bug where we're just doing something

2250
01:38:24,000 --> 01:38:24,800
really, really dumb.

2251
01:38:26,300 --> 01:38:32,700
But but yeah, but it's it what exactly whether it whether it should

2252
01:38:33,900 --> 01:38:36,000
should be that slow though is

2253
01:38:37,200 --> 01:38:38,200
Is another question.

2254
01:38:39,200 --> 01:38:40,300
So yeah.

2255
01:38:47,200 --> 01:38:47,900
Yeah, I'm sorry.

2256
01:38:47,900 --> 01:38:50,400
I'm not I'm not going to turn off the debug sound because we're going

2257
01:38:50,400 --> 01:38:52,400
to be replacing the debug sound with actual sound playback.

2258
01:38:52,400 --> 01:38:55,100
So we just kind of have there's going to be sound sounds going to

2259
01:38:55,100 --> 01:38:55,600
happen.

2260
01:38:59,700 --> 01:38:59,800
Yes.

2261
01:39:00,000 --> 01:39:03,000
The CPU memory bandwidth only valid for on die.

2262
01:39:03,000 --> 01:39:07,500
Memory know I that that number.

2263
01:39:07,500 --> 01:39:10,700
So where was that page?

2264
01:39:10,700 --> 01:39:11,100
Okay.

2265
01:39:12,000 --> 01:39:18,900
So basically this I believe well, actually I'm not sure where is the

2266
01:39:18,900 --> 01:39:21,000
cash bandwidth?

2267
01:39:23,400 --> 01:39:29,300
I don't know what all of these are actually referring to but basically

2268
01:39:29,400 --> 01:39:34,300
the the memory bandwidth that they quote is for actually out to main

2269
01:39:34,300 --> 01:39:34,800
memory.

2270
01:39:34,900 --> 01:39:38,000
At least that's always been my experience in the past.

2271
01:39:38,200 --> 01:39:40,600
So 32 gigabytes a second is the speed.

2272
01:39:40,600 --> 01:39:44,600
It can talk to the memory bus that actually goes to memory, right?

2273
01:39:46,000 --> 01:39:49,400
So at that's not talking about the cache which is the thing that's on

2274
01:39:49,400 --> 01:39:49,900
chip.

2275
01:39:51,100 --> 01:39:53,000
There is no on-die memory.

2276
01:39:53,200 --> 01:39:55,400
We in terms of memory.

2277
01:39:55,400 --> 01:39:56,200
It's just the cash.

2278
01:39:56,200 --> 01:39:56,300
Right?

2279
01:39:56,300 --> 01:40:00,400
I mean it is on die memory, but we don't have stacked RAM on the on

2280
01:40:00,500 --> 01:40:01,100
Intel chip.

2281
01:40:01,100 --> 01:40:04,200
So it's not like there's two gigabytes of memory like sitting on the

2282
01:40:04,200 --> 01:40:05,100
chip or something.

2283
01:40:05,400 --> 01:40:06,800
There's only just that cash.

2284
01:40:07,300 --> 01:40:12,500
So basically like the cache, the cache bandwidth should be much higher

2285
01:40:12,700 --> 01:40:17,500
than 32 GB s 32 gigabytes, a second would be pretty slow for for the

2286
01:40:17,500 --> 01:40:17,800
cash.

2287
01:40:17,800 --> 01:40:18,300
I think.

2288
01:40:24,000 --> 01:40:26,800
Is the intent of saving the complete Game state to support something

2289
01:40:26,800 --> 01:40:28,700
like a rewind function, that braid allows.

2290
01:40:28,700 --> 01:40:33,700
No, you would have to do a much more efficient implementation.

2291
01:40:33,700 --> 01:40:36,700
If you want this to be a runtime feature, this is a debug feature and

2292
01:40:36,700 --> 01:40:38,100
it's so that we can tune things.

2293
01:40:38,300 --> 01:40:43,700
So like if we wanted to work on, you know, the feel of oh, you know,

2294
01:40:43,700 --> 01:40:46,200
you push the button and it shoots and like, oh, we've got the muzzle

2295
01:40:46,200 --> 01:40:47,300
flare and all these sorts of things.

2296
01:40:47,300 --> 01:40:50,500
And we want to start tuning all those effects and whatever we can just

2297
01:40:50,500 --> 01:40:51,100
do it.

2298
01:40:51,500 --> 01:40:53,000
Whatever the action is in game.

2299
01:40:53,200 --> 01:40:57,600
With the looping on and then edit the code live as we go and see the

2300
01:40:57,600 --> 01:40:58,200
results.

2301
01:40:58,300 --> 01:41:00,200
So it's not meant to be a gameplay feature.

2302
01:41:00,200 --> 01:41:01,900
It strictly for our debugging purposes.

2303
01:41:01,900 --> 01:41:02,500
It won't leave.

2304
01:41:02,500 --> 01:41:05,000
It won't even be enabled in the shipping version.

2305
01:41:05,000 --> 01:41:06,400
It's only for our debug build.

2306
01:41:08,100 --> 01:41:09,900
Will you do a string pool?

2307
01:41:11,600 --> 01:41:15,700
Probably not a string pool know we will probably do a string stack,

2308
01:41:15,700 --> 01:41:17,800
but I doubt we'll ever do a string pool and it won't really be a

2309
01:41:17,800 --> 01:41:18,400
string stack.

2310
01:41:18,400 --> 01:41:22,800
It'll be a we will use stacks for our strings, but they will not be

2311
01:41:22,800 --> 01:41:24,700
exclusively for string stacks.

2312
01:41:26,500 --> 01:41:29,400
When you say the platform a circular, does that mean game code and

2313
01:41:29,400 --> 01:41:32,700
renderer and logging sorts of things or is there a sharper distinction

2314
01:41:32,700 --> 01:41:34,200
between some of those?

2315
01:41:34,200 --> 01:41:37,000
If not, could you clarify, your naming and layer structure, just a

2316
01:41:37,000 --> 01:41:37,500
little.

2317
01:41:38,200 --> 01:41:40,800
So, basically, the only structure that we have is, there's the

2318
01:41:40,800 --> 01:41:44,600
platform code, which is like, 32 underscore, or later.

2319
01:41:44,600 --> 01:41:48,100
They'll be like mac underscore or Linux underscore, and then there's

2320
01:41:48,100 --> 01:41:49,100
all the rest of the code.

2321
01:41:49,300 --> 01:41:52,300
So, basically, the only distinction that I'm making is essentially

2322
01:41:52,300 --> 01:41:56,000
between stuff that only runs on one platform and stuff that runs on.

2323
01:41:56,200 --> 01:41:57,100
Every platform.

2324
01:41:57,500 --> 01:41:59,800
So the idea is I want to push.

2325
01:42:00,000 --> 01:42:03,000
Much code is possible up into the stuff that runs on every platform so

2326
01:42:03,000 --> 01:42:06,600
that you don't have to do a ton of work to implement each new

2327
01:42:06,600 --> 01:42:07,200
platform.

2328
01:42:07,300 --> 01:42:10,800
You want to only do the work that's necessary to do the stuff that is

2329
01:42:10,800 --> 01:42:12,200
different on that platform, right?

2330
01:42:16,200 --> 01:42:17,200
A quick test on might be see.

2331
01:42:17,200 --> 01:42:19,500
Gave me around 3 gigabytes a second.

2332
01:42:20,000 --> 01:42:24,300
So that's pretty bad memory bandwidth, but that might be logical for

2333
01:42:24,300 --> 01:42:25,500
older PCS or laptops.

2334
01:42:25,500 --> 01:42:29,700
Maybe, I don't know, but that seems kind of low.

2335
01:42:29,700 --> 01:42:31,000
What kind of processor do you have?

2336
01:42:33,800 --> 01:42:38,500
See ya Uplink coder.

2337
01:42:38,800 --> 01:42:39,900
Do you know what?

2338
01:42:40,600 --> 01:42:41,800
What CPU you have?

2339
01:42:41,800 --> 01:42:46,600
Can you can you look at which CPU have if you go into like the this

2340
01:42:46,600 --> 01:42:48,700
guy and look at this?

2341
01:42:56,000 --> 01:42:57,600
Is that would be interesting information to have?

2342
01:43:00,600 --> 01:43:03,600
But yeah, I'm just that, that's not cash bandwidth.

2343
01:43:03,600 --> 01:43:05,200
I refuse to believe that's cash bandwidth.

2344
01:43:05,200 --> 01:43:06,000
It's so low.

2345
01:43:06,000 --> 01:43:08,700
It just seems like that would be crazy for cash bandwidth, but

2346
01:43:11,200 --> 01:43:12,500
Maybe I'm wrong about that.

2347
01:43:18,100 --> 01:43:20,900
Is it time to split the source into more files?

2348
01:43:21,500 --> 01:43:26,500
Well, when we start programming in handmade dot CPP, we will be

2349
01:43:26,500 --> 01:43:28,600
splitting him a DOT CP into lots of files.

2350
01:43:28,600 --> 01:43:29,000
Yet.

2351
01:43:29,300 --> 01:43:31,600
They'll be, they'll be lots of files there whether we'll ever split

2352
01:43:31,600 --> 01:43:33,500
the win32 file in the model files.

2353
01:43:33,500 --> 01:43:37,100
I don't know if there's a real good reason to maybe but there hasn't

2354
01:43:37,100 --> 01:43:38,900
really been any real reason to yet.

2355
01:43:42,000 --> 01:43:45,600
Woody non caching right be faster for the memory copy, you know the

2356
01:43:45,600 --> 01:43:46,300
SSC, right.

2357
01:43:46,300 --> 01:43:48,400
Instructions that bypass the cache.

2358
01:43:54,100 --> 01:43:58,700
I don't see why it would be because the cash is not really the

2359
01:43:58,700 --> 01:43:59,100
problem.

2360
01:43:59,100 --> 01:43:59,500
Here.

2361
01:44:00,100 --> 01:44:05,600
We are out of cat like we're writing enough memory that the cash can't

2362
01:44:05,600 --> 01:44:07,100
help us at all.

2363
01:44:07,800 --> 01:44:11,800
So I'm like usually the reason that you do a right to bypass the cache

2364
01:44:12,100 --> 01:44:14,100
and again, I'm not really a CPU guy.

2365
01:44:14,100 --> 01:44:18,900
So maybe there's another reason why you would do this, but my my

2366
01:44:18,900 --> 01:44:21,100
understanding of that was the reason that you do a right that

2367
01:44:21,100 --> 01:44:23,700
bypasses, the cash is because you don't want to pollute.

2368
01:44:23,900 --> 01:44:28,000
The cash with the contents of the right, but in our case we're reading

2369
01:44:28,000 --> 01:44:31,400
and writing so much memory there that were entirely out of cash in

2370
01:44:31,400 --> 01:44:32,200
both cases.

2371
01:44:32,500 --> 01:44:36,500
So avoiding polluting, the cash would really have nothing to do with

2372
01:44:36,500 --> 01:44:37,300
what's going on.

2373
01:44:39,100 --> 01:44:39,600
The cash.

2374
01:44:39,600 --> 01:44:43,800
I mean maybe you should do it just because that way the whatever was

2375
01:44:43,800 --> 01:44:47,000
in the cast beforehand still in there so that you don't take a hit on

2376
01:44:47,000 --> 01:44:49,700
the next piece of code, that's going to execute but I don't think it

2377
01:44:49,700 --> 01:44:53,500
would change the right speed because since the cash is very small

2378
01:44:53,500 --> 01:44:54,700
like, you know, I don't know.

2379
01:44:54,800 --> 01:44:56,100
Let's say 8, MB here.

2380
01:44:56,100 --> 01:44:57,100
It says, right?

2381
01:44:57,100 --> 01:44:59,900
And we're writing a gigabyte, the cash just isn't involved.

2382
01:45:00,000 --> 01:45:01,400
We're out of cast the entire time.

2383
01:45:01,400 --> 01:45:03,300
So the only number that matters is here.

2384
01:45:03,300 --> 01:45:04,700
Like we're not going to get any cash.

2385
01:45:04,700 --> 01:45:05,000
Affects.

2386
01:45:05,000 --> 01:45:07,800
I don't think but I could be wrong about that said I'm not really

2387
01:45:07,800 --> 01:45:08,000
asleep.

2388
01:45:08,000 --> 01:45:08,400
You guy.

2389
01:45:14,400 --> 01:45:17,500
When are the four HMI files created?

2390
01:45:17,500 --> 01:45:22,800
The HMI files are created right here in this for I loop at startup.

2391
01:45:22,800 --> 01:45:26,300
So, you know, we come in here, we sort of do our initialization.

2392
01:45:26,300 --> 01:45:27,900
We have our window, we get the refresh rate.

2393
01:45:27,900 --> 01:45:31,400
We set up the sound, we allocate the memory for the game.

2394
01:45:31,400 --> 01:45:35,000
And then we do a loop over each one of the replay buffers that we want

2395
01:45:35,000 --> 01:45:37,400
and we create the file right here.

2396
01:45:37,400 --> 01:45:39,500
So here's the thing, that creates the file.

2397
01:45:39,500 --> 01:45:43,100
Here's the thing that map's it into memory or rather.

2398
01:45:43,100 --> 01:45:44,200
Here's the thing that creates the

2399
01:45:44,500 --> 01:45:45,800
It allows us to map it into memory.

2400
01:45:45,800 --> 01:45:46,500
And here's the call.

2401
01:45:46,500 --> 01:45:47,900
That actually Maps it into memory.

2402
01:45:50,500 --> 01:45:54,000
An AMD A8 6600 K.

2403
01:45:54,900 --> 01:46:01,000
So that is an AMD, A8 6600 K memory bandwidth.

2404
01:46:01,000 --> 01:46:01,700
Let's take a look.

2405
01:46:01,700 --> 01:46:03,100
If we could find that out.

2406
01:46:06,000 --> 01:46:06,900
What is this?

2407
01:46:07,200 --> 01:46:11,600
Here we go, frequency bandwidth.

2408
01:46:13,900 --> 01:46:16,000
Okay, so that's actually not.

2409
01:46:16,700 --> 01:46:19,900
That's not actually.

2410
01:46:21,100 --> 01:46:21,800
Well.

2411
01:46:24,200 --> 01:46:26,500
Not, I guess this is, this is a little confusing.

2412
01:46:26,500 --> 01:46:30,000
There's a lot of different coats here to memory up to 21 gigabytes.

2413
01:46:30,000 --> 01:46:31,400
A second dual Channel memory.

2414
01:46:31,600 --> 01:46:33,300
Are you using it in dual Channel mode?

2415
01:46:33,300 --> 01:46:34,400
Would be the first question.

2416
01:46:34,600 --> 01:46:38,300
If you weren't it would be, you know half that right?

2417
01:46:38,300 --> 01:46:39,000
There's a Mobley.

2418
01:46:39,300 --> 01:46:40,000
I don't actually know.

2419
01:46:40,500 --> 01:46:44,500
So I feel like you are a third, the speed of this chip.

2420
01:46:44,500 --> 01:46:48,200
I don't know what you would be in practice like on The Benchmark here.

2421
01:46:49,400 --> 01:46:50,400
Uplink coder.

2422
01:46:51,100 --> 01:46:53,100
Is there a benchmark?

2423
01:46:54,600 --> 01:46:59,400
Somewhere, Benchmark, discrete, pray for four months ratio of our

2424
01:46:59,400 --> 01:47:05,500
performance thermal design, pros and cons model.

2425
01:47:05,500 --> 01:47:08,700
Number not even know if this is a legitimate site that I'm looking at

2426
01:47:08,700 --> 01:47:09,000
here.

2427
01:47:09,200 --> 01:47:12,300
I'm just wildly searching to see if I can get some memory bandwidth

2428
01:47:12,300 --> 01:47:12,900
numbers.

2429
01:47:13,200 --> 01:47:19,700
Max memory bandwidth, integrated memory controller is between 99 cent,

2430
01:47:19,700 --> 01:47:20,200
right?

2431
01:47:20,900 --> 01:47:21,400
Yeah.

2432
01:47:22,000 --> 01:47:23,900
29 9 is the

2433
01:47:24,000 --> 01:47:24,600
Memory bandwidth.

2434
01:47:24,600 --> 01:47:27,100
So yeah, I don't know if you're getting three.

2435
01:47:28,100 --> 01:47:29,200
It's a tenth of it.

2436
01:47:29,800 --> 01:47:30,600
Yeah, I'm not sure.

2437
01:47:31,200 --> 01:47:32,600
This is kind of a to be continued thing.

2438
01:47:32,600 --> 01:47:34,600
We're going to need we're going to need real profile Fair.

2439
01:47:34,600 --> 01:47:35,200
What's going on here?

2440
01:47:35,200 --> 01:47:37,000
I think this is not going to be a trivial thing.

2441
01:47:37,800 --> 01:47:39,700
Are you going to do a mobile Port Android?

2442
01:47:39,700 --> 01:47:43,400
For example, with the game Loop of a mobile game, be any different?

2443
01:47:46,400 --> 01:47:49,000
So I might do a mobile port to Android.

2444
01:47:49,500 --> 01:47:51,000
I haven't decided yet.

2445
01:47:51,200 --> 01:47:55,300
I don't like having to deal with Android because it's all Java nasty

2446
01:47:55,300 --> 01:47:59,800
Ridiculousness, but you know we could

2447
01:48:00,000 --> 01:48:04,400
The ndk and compiled mostly and see, and maybe go that way.

2448
01:48:05,400 --> 01:48:06,600
So maybe we'll do that.

2449
01:48:06,600 --> 01:48:12,400
I'm not sure it's possible, but not necessarily going to happen.

2450
01:48:12,800 --> 01:48:15,900
We will definitely do the Raspberry Pi port at some point.

2451
01:48:15,900 --> 01:48:17,600
And that basically is a mobile.

2452
01:48:17,600 --> 01:48:19,200
That's a, that's essentially a phone.

2453
01:48:19,400 --> 01:48:22,400
You know, it's an old phone is what the Raspberry Pi basically is.

2454
01:48:23,300 --> 01:48:26,900
So we will be doing that as for whether the game, Loop is any

2455
01:48:26,900 --> 01:48:29,800
different on a mobile game game.

2456
01:48:30,000 --> 01:48:31,400
Oops, our it depends.

2457
01:48:31,400 --> 01:48:32,100
What you mean.

2458
01:48:32,100 --> 01:48:34,200
Obviously the win32 code is all different.

2459
01:48:34,200 --> 01:48:37,200
Like the phone, whatever, the phone operating system is, will have

2460
01:48:37,200 --> 01:48:40,700
completely different platform layer, but the game itself will be

2461
01:48:40,700 --> 01:48:42,300
written the same on all the platforms.

2462
01:48:42,300 --> 01:48:44,900
So there won't be differences there if that makes sense.

2463
01:48:51,300 --> 01:48:53,400
How about disc great speed and access time?

2464
01:48:53,400 --> 01:48:56,400
Well, in theory, we shouldn't have to pay for that because since it's

2465
01:48:56,400 --> 01:49:01,200
all in memory Windows can be as lazy as it wants, writing that stuff

2466
01:49:01,200 --> 01:49:01,400
out.

2467
01:49:01,400 --> 01:49:04,300
So in theory, we don't care about what the disk speed is because we're

2468
01:49:04,300 --> 01:49:07,300
all in memory now and basically we did a memory mapped file.

2469
01:49:07,300 --> 01:49:10,800
So that windows with lazily put it out to disk whenever it wants to.

2470
01:49:11,000 --> 01:49:14,700
But it no longer has to do that before it can complete the operation.

2471
01:49:15,000 --> 01:49:18,600
So in theory, it should just be memory bandwidth of copying, the GB.

2472
01:49:18,600 --> 01:49:20,300
That's all that should have to happen, right?

2473
01:49:20,700 --> 01:49:25,900
Um, so, you know disk write speed shouldn't have been involved.

2474
01:49:31,300 --> 01:49:35,800
Why is the CPU even involved in a memory copy like this?

2475
01:49:37,600 --> 01:49:38,400
Hmm.

2476
01:49:41,700 --> 01:49:42,600
so,

2477
01:49:43,800 --> 01:49:48,300
I guess the first thing I'd say is I'm not sure what you mean by, why

2478
01:49:48,300 --> 01:49:50,800
is this CPU involved in a memory copy?

2479
01:49:51,300 --> 01:49:53,700
What else would you imagine doing?

2480
01:49:53,700 --> 01:49:54,200
The memory?

2481
01:49:54,200 --> 01:49:54,800
Copy?

2482
01:49:54,900 --> 01:49:57,900
I guess are you thinking of something that's like a dma engine or

2483
01:49:57,900 --> 01:49:58,500
something?

2484
01:49:59,100 --> 01:50:03,500
Because really like the memory somebody has to move the memory from

2485
01:50:03,500 --> 01:50:04,600
one place to another.

2486
01:50:05,000 --> 01:50:07,900
And the CPU is the thing that does the memory Ops.

2487
01:50:08,400 --> 01:50:11,500
There's a memory controller on the CPU and, you know,

2488
01:50:13,600 --> 01:50:16,000
I guess I don't know if x64.

2489
01:50:16,000 --> 01:50:19,700
I don't know if any x64 chips have a way to kick off a memory.

2490
01:50:19,700 --> 01:50:23,100
Copy, that doesn't involve the CPU hand holding it.

2491
01:50:25,900 --> 01:50:29,500
You know, a bulldozer core might have something like that because that

2492
01:50:29,500 --> 01:50:33,500
it has the, I mean, I guess what I'm saying is, I don't actually know

2493
01:50:33,500 --> 01:50:36,200
if the compiler can generate x64 instructions.

2494
01:50:36,200 --> 01:50:38,900
That would do a background memory copy kickoff that the memory

2495
01:50:38,900 --> 01:50:39,600
controller does.

2496
01:50:39,600 --> 01:50:41,100
I'm not sure that's all.

2497
01:50:41,100 --> 01:50:44,000
Like really would be really modern stuff and I'm not aware of it one

2498
01:50:44,000 --> 01:50:47,800
way or the other but traditionally speaking at least, you know, in the

2499
01:50:47,800 --> 01:50:51,600
old days the memory is operated on by the CPU.

2500
01:50:51,600 --> 01:50:54,400
So the CPU has to manually say take this and move it here.

2501
01:50:54,400 --> 01:50:55,200
Take this and move it here.

2502
01:50:55,400 --> 01:50:56,100
Take this moving here.

2503
01:50:56,100 --> 01:50:59,000
So the CPU is the thing doing the copy, most of the time.

2504
01:51:02,500 --> 01:51:05,000
What was the reason for choosing get cursor Paws, instead of just

2505
01:51:05,000 --> 01:51:05,900
responding to the WM?

2506
01:51:05,900 --> 01:51:08,400
Ousted message is the message, pump, not fast enough.

2507
01:51:08,600 --> 01:51:12,600
No, it was just convenience since we were only going to pass it once

2508
01:51:12,600 --> 01:51:13,000
for frame.

2509
01:51:13,000 --> 01:51:15,200
Anyway, I figured why bother handling a message.

2510
01:51:15,200 --> 01:51:17,900
Why not just ask where it is when we're about to pass.

2511
01:51:17,900 --> 01:51:18,300
It.

2512
01:51:18,300 --> 01:51:21,300
Just easier than doing the other thing.

2513
01:51:25,500 --> 01:51:29,300
Have I ever programmed in Java for how long?

2514
01:51:29,500 --> 01:51:30,500
No, I have not.

2515
01:51:30,500 --> 01:51:37,100
I mean I have programmed in Java but never for long enough to like

2516
01:51:37,100 --> 01:51:39,100
I've never done like a major Java project.

2517
01:51:39,200 --> 01:51:42,100
I've only done like the barest amount of Java programming where I was

2518
01:51:42,100 --> 01:51:42,500
like, okay.

2519
01:51:42,500 --> 01:51:43,100
What is this?

2520
01:51:43,100 --> 01:51:43,700
How do you do this?

2521
01:51:43,700 --> 01:51:44,600
Etcetera, Etc.

2522
01:51:45,900 --> 01:51:52,500
And so if we wanted the reason I was mentioning that as if we wanted

2523
01:51:52,500 --> 01:51:54,500
to do an Android port.

2524
01:51:55,300 --> 01:51:57,500
I believe unless they've changed it recently.

2525
01:51:57,500 --> 01:52:01,600
You still have to write a bunch of java code at like the interface

2526
01:52:01,600 --> 01:52:05,800
boundary to call your C code because all of their operating system

2527
01:52:05,800 --> 01:52:07,500
stuff all has to go through Java.

2528
01:52:08,400 --> 01:52:11,800
And so you have, you know, you're talking about installing the

2529
01:52:12,300 --> 01:52:16,300
basically a whole Java SDK environment with the Android SDK, and all

2530
01:52:16,300 --> 01:52:18,300
that stuff and dealing with it.

2531
01:52:18,300 --> 01:52:23,000
And, you know, it's all really annoying because I don't care about

2532
01:52:23,000 --> 01:52:24,900
Java, and I don't want to program Java, but

2533
01:52:25,100 --> 01:52:26,200
It's kind of forces you to do.

2534
01:52:26,200 --> 01:52:26,900
So, right.

2535
01:52:27,900 --> 01:52:30,200
Why is the CPU even involved in a memory copy?

2536
01:52:30,200 --> 01:52:32,900
Like this, wouldn't the copy speed, mostly depend on how quickly

2537
01:52:32,900 --> 01:52:35,900
memory from one part of the memory gets to the CPU and back.

2538
01:52:35,900 --> 01:52:37,000
In fact in my mind.

2539
01:52:37,000 --> 01:52:39,600
It seems like large copies should be something that could skip the CPU

2540
01:52:39,600 --> 01:52:41,200
entirely unless it has something to do is paging.

2541
01:52:41,200 --> 01:52:41,400
Okay.

2542
01:52:41,400 --> 01:52:42,700
I see the rest of the question now.

2543
01:52:43,800 --> 01:52:47,000
Yeah, so hope that kind of answered that basically what happens is the

2544
01:52:47,000 --> 01:52:50,600
CPU is still the thing that's in charge of the memory controller.

2545
01:52:50,800 --> 01:52:54,000
So it's still involved in doing those copies and I don't know if they

2546
01:52:54,000 --> 01:52:54,900
have memory controllers.

2547
01:52:55,000 --> 01:52:56,100
Now that'll do those copies.

2548
01:52:56,100 --> 01:52:57,000
Asynchronously.

2549
01:52:58,000 --> 01:52:59,100
We're just kicks them off.

2550
01:52:59,400 --> 01:53:00,700
It certainly could be done.

2551
01:53:00,700 --> 01:53:01,800
I just don't know if it is done.

2552
01:53:05,100 --> 01:53:11,000
So, I don't know, but basically, when you see that memory speed.

2553
01:53:13,300 --> 01:53:14,600
That is sort of what that is.

2554
01:53:14,600 --> 01:53:17,200
When you see the memories fade in the CPU, that's telling you how fast

2555
01:53:17,200 --> 01:53:19,600
the CPU could issue instructions to the memory controller, right?

2556
01:53:19,600 --> 01:53:24,300
Like, how long, how, how fast can the memory controller respond to

2557
01:53:24,300 --> 01:53:27,900
when the CPU says, give me a piece of memory.

2558
01:53:28,100 --> 01:53:31,100
And what's important to recognize is it's only over.

2559
01:53:31,300 --> 01:53:34,800
It's the only reason you would want that asynchronous copy is just to

2560
01:53:34,800 --> 01:53:39,100
the CPU, can go do something else, but you're not making it any faster

2561
01:53:39,100 --> 01:53:42,100
by taking the CPU out of the equation, because the CPUs clock speed is

2562
01:53:42,100 --> 01:53:42,900
way faster than

2563
01:53:43,000 --> 01:53:45,700
in the memory can be handed to it.

2564
01:53:45,800 --> 01:53:46,300
Right?

2565
01:53:46,300 --> 01:53:51,500
The memory bandwidth that the the memory controller can hand back to

2566
01:53:51,500 --> 01:53:54,500
the processor is way less than the processor could handle.

2567
01:53:54,900 --> 01:53:59,000
So we're not getting slowed down by the fact that the CPU is involved

2568
01:53:59,000 --> 01:53:59,600
at all.

2569
01:54:00,000 --> 01:54:02,700
Only thing that you would say about it is the CPU can't go do

2570
01:54:02,700 --> 01:54:04,100
something else while it's happening.

2571
01:54:04,700 --> 01:54:08,000
But definitely the CPU, the CPU could chew through the memory way

2572
01:54:08,000 --> 01:54:09,900
faster than the memory controller is handing it back.

2573
01:54:09,900 --> 01:54:12,500
So the fact of the CPU involve is not making a slower.

2574
01:54:14,000 --> 01:54:17,900
So that is probably why they don't care so much about asynchronous

2575
01:54:17,900 --> 01:54:22,400
copies because the CPU is so much faster that like, you know, just

2576
01:54:22,900 --> 01:54:25,700
launched it on the core and let it go or whatever, and it'll just

2577
01:54:25,700 --> 01:54:27,700
basically be sitting in some hyper threat or something, but I don't

2578
01:54:27,700 --> 01:54:27,900
know.

2579
01:54:28,500 --> 01:54:28,800
So

2580
01:54:32,300 --> 01:54:34,200
Is it worth reading games in Java?

2581
01:54:34,800 --> 01:54:36,400
Well, I don't want to write games in Java.

2582
01:54:36,400 --> 01:54:37,600
But that's my personal preference.

2583
01:54:37,600 --> 01:54:40,900
If you want to write games in Java, then you should write games in

2584
01:54:40,900 --> 01:54:41,300
Java.

2585
01:54:41,400 --> 01:54:44,000
I mean, I don't know whether I'd say it's worth it or not.

2586
01:54:44,000 --> 01:54:48,200
I mean, I do know that there are very few games that shipped that are

2587
01:54:48,200 --> 01:54:52,600
successful that are written in Java, but that is you know, I mean

2588
01:54:52,600 --> 01:54:54,900
Minecraft would be example of a game that was successful that was

2589
01:54:54,900 --> 01:54:57,400
written in Java so it can be done.

2590
01:54:58,200 --> 01:55:01,900
And then the other thing is, you know, a lot of the reason that high

2591
01:55:02,100 --> 01:55:04,700
High-performance high-profile games are written in C and C++ is

2592
01:55:04,700 --> 01:55:08,100
because that's what high-performance programmers program in.

2593
01:55:08,300 --> 01:55:11,000
You know, could they go do a high performance gaming Java?

2594
01:55:11,000 --> 01:55:14,800
I don't know, probably not, but maybe they could, you know, if all the

2595
01:55:14,800 --> 01:55:17,200
high-performance programmers, decided to go spend their time, trying

2596
01:55:17,200 --> 01:55:18,600
to figure out how to make Java run fast.

2597
01:55:18,600 --> 01:55:19,700
Maybe they could, I don't know.

2598
01:55:21,100 --> 01:55:23,900
So I don't really have much of an opinion about Java other than I

2599
01:55:23,900 --> 01:55:24,500
don't like it.

2600
01:55:24,500 --> 01:55:25,800
And I don't see the point of it.

2601
01:55:25,900 --> 01:55:29,300
So I haven't bothered to learn it and program in it, but if someone

2602
01:55:29,300 --> 01:55:31,900
else wants to do that, then that's totally there.

2603
01:55:32,000 --> 01:55:35,200
Prerogative, my main problems with it or basically that like I don't

2604
01:55:35,200 --> 01:55:35,900
see the purpose.

2605
01:55:35,900 --> 01:55:38,300
Like, it doesn't seem to give me anything that see, doesn't that

2606
01:55:38,500 --> 01:55:39,900
doesn't give me.

2607
01:55:40,100 --> 01:55:42,600
I'd like, yeah, I think it has slightly better introspection support,

2608
01:55:42,600 --> 01:55:46,700
but I can get around that pretty easily in my own code.

2609
01:55:47,200 --> 01:55:51,000
So mostly Java just doesn't have what I want, which is like pointers

2610
01:55:51,000 --> 01:55:53,700
and things like this, that are better at expressing memory.

2611
01:55:53,700 --> 01:55:54,600
Direct memory access.

2612
01:55:54,600 --> 01:55:57,400
It forces me to use garbage collection, which I don't want to do

2613
01:55:57,400 --> 01:56:01,700
because garbage collection, just waste CPU time, for no real benefit,

2614
01:56:01,700 --> 01:56:01,900
so,

2615
01:56:02,100 --> 01:56:02,700
Don't like that.

2616
01:56:02,700 --> 01:56:05,700
Aspect of it runs on a VM, which means I don't actually get to see

2617
01:56:05,700 --> 01:56:09,000
what the code is and can't necessarily manhandle the assembly a lot of

2618
01:56:09,000 --> 01:56:09,600
that stuff.

2619
01:56:09,700 --> 01:56:11,100
So I don't like any of that.

2620
01:56:12,300 --> 01:56:15,000
So I just don't see what the point would be of me go.

2621
01:56:15,000 --> 01:56:16,000
It just seems like a bunch of stuff.

2622
01:56:16,000 --> 01:56:17,100
I just have to fight.

2623
01:56:17,700 --> 01:56:22,100
And basically, if you use some kind of a Java, if you use some kind of

2624
01:56:22,100 --> 01:56:26,000
stuff in Java that allows you to kind of get past those things, then

2625
01:56:26,000 --> 01:56:28,700
you're basically back to see anyway, so I feel like I should have just

2626
01:56:28,700 --> 01:56:30,500
been programming in c, right?

2627
01:56:32,000 --> 01:56:34,200
I mean, another way to say that more concisely would be all the stuff

2628
01:56:34,200 --> 01:56:36,500
that Java ads to see it's stuff.

2629
01:56:36,500 --> 01:56:38,500
I don't want and it gets in my way.

2630
01:56:39,000 --> 01:56:41,700
So that's why I've never bothered going the job around.

2631
01:56:41,900 --> 01:56:46,400
But if you're somebody who wants garbage collection, you know, who

2632
01:56:46,400 --> 01:56:48,300
wants a VM, who wants those things.

2633
01:56:48,300 --> 01:56:50,800
For some reason, you have like legitimate reasons for wanting those

2634
01:56:50,800 --> 01:56:53,100
things then maybe it's a good language, read a part of my game and I

2635
01:56:53,100 --> 01:56:53,500
don't know.

2636
01:57:04,300 --> 01:57:07,400
Are you in dual-channel right mode on your system, I believe.

2637
01:57:07,400 --> 01:57:10,800
So, I mean, I'm not actually sure, but I believe this system was set

2638
01:57:10,800 --> 01:57:12,300
up with dual Channel, but I'm not sure.

2639
01:57:13,700 --> 01:57:18,600
Does the MB have any effect on the performance of the memory?

2640
01:57:19,200 --> 01:57:21,300
Oh, you mean like, how much MB there are?

2641
01:57:21,700 --> 01:57:22,800
I'm not sure.

2642
01:57:23,700 --> 01:57:23,900
Again.

2643
01:57:23,900 --> 01:57:27,200
These are things that are like modern memory systems.

2644
01:57:27,200 --> 01:57:28,200
I'm not an expert on.

2645
01:57:28,200 --> 01:57:30,600
So I'm not really prepared to say at all.

2646
01:57:32,900 --> 01:57:33,600
I do not know.

2647
01:57:39,600 --> 01:57:39,900
Yes.

2648
01:57:39,900 --> 01:57:40,400
Oh, Tom.

2649
01:57:40,400 --> 01:57:44,800
Tom Forsythe is saying that CPUs do have dma units but they're not

2650
01:57:44,800 --> 01:57:46,600
easily available for user programs.

2651
01:57:46,600 --> 01:57:47,400
It's all IO stuff.

2652
01:57:47,400 --> 01:57:49,100
Yeah, that's so that's what I would assume.

2653
01:57:49,100 --> 01:57:54,000
Like, for example, I would totally assume that like especially like

2654
01:57:54,000 --> 01:57:56,700
AMD chips that have the well and an Intel chips.

2655
01:57:56,700 --> 01:58:00,200
Now, have the graphics stuff integrated into the CPU.

2656
01:58:00,200 --> 01:58:00,800
Right?

2657
01:58:00,800 --> 01:58:04,600
And so you're going to probably have a sync, copy stuff happening.

2658
01:58:04,600 --> 01:58:08,000
I mean, so you have to have support for a sync, copy stuff in there.

2659
01:58:08,100 --> 01:58:08,900
I just don't think this.

2660
01:58:09,100 --> 01:58:11,400
CPU ever accesses it really in that way.

2661
01:58:11,400 --> 01:58:12,000
I don't know.

2662
01:58:13,400 --> 01:58:16,900
So I, you know, it's probably stuff that only the kernel is doing or

2663
01:58:16,900 --> 01:58:20,600
only the chip is doing based on Graphics things, or, I don't know.

2664
01:58:20,900 --> 01:58:22,800
But yeah, so I don't have much experience with that.

2665
01:58:22,800 --> 01:58:26,300
But Tom is saying that is basically, it's more or less confirming.

2666
01:58:26,300 --> 01:58:29,900
What I was saying, which is that you don't really get to use async

2667
01:58:29,900 --> 01:58:32,700
copies in your code.

2668
01:58:40,600 --> 01:58:43,600
What do I think of tdd test-driven development?

2669
01:58:43,600 --> 01:58:48,500
I assume I think it's not particularly useful for games, because games

2670
01:58:48,500 --> 01:58:52,000
tend to be very hard to write in ways that can be test driven.

2671
01:58:52,600 --> 01:58:55,100
But sometimes it's useful for subsystems.

2672
01:58:55,100 --> 01:58:58,500
Like, if we have, if you have a system whose configuration space is

2673
01:58:58,500 --> 01:59:02,100
very small, then you can use test-driven development.

2674
01:59:02,100 --> 01:59:07,300
Okay, but games, the things that are hard to debug in games, tend to

2675
01:59:07,300 --> 01:59:09,700
be things that cannot be written with Tess.

2676
01:59:10,200 --> 01:59:12,400
Like, there's no way to write them to be tested.

2677
01:59:13,400 --> 01:59:16,100
So so TD just doesn't really work.

2678
01:59:16,600 --> 01:59:17,700
The reason tdd is popular.

2679
01:59:17,700 --> 01:59:20,000
In other Industries is because they are spare programs are much

2680
01:59:20,000 --> 01:59:21,000
simpler than games are.

2681
01:59:21,400 --> 01:59:23,100
They have very well-defined inputs and outputs.

2682
01:59:23,100 --> 01:59:26,400
So tdd works in those circumstances much better, right?

2683
01:59:27,500 --> 01:59:28,800
Can you explain the bit shifting?

2684
01:59:29,000 --> 01:59:30,000
Yes, I can.

2685
01:59:30,600 --> 01:59:32,500
So the pitch shifting we did was really simple.

2686
01:59:33,500 --> 01:59:38,000
It's just in terms of the it's the high-low thing.

2687
01:59:38,600 --> 01:59:44,500
So basically what happened is I had a 64-bit value but I because of

2688
01:59:44,500 --> 01:59:47,600
the way Windows setup their API, they don't accept a 64-bit value,

2689
01:59:47,600 --> 01:59:52,800
they accept to 32-bit values which then they will reassemble into one

2690
01:59:52,800 --> 01:59:53,900
64-bit value.

2691
01:59:54,300 --> 01:59:57,200
So in order to take this 64-bit value, which is the total

2692
01:59:57,300 --> 01:59:59,800
All size and produce two 32-bit values.

2693
02:00:00,400 --> 02:00:02,100
The high part in the low part.

2694
02:00:02,200 --> 02:00:03,900
I first needed to get the high part out.

2695
02:00:03,900 --> 02:00:08,600
So I shifted down by 32, right, which basically moves the high 32 bits

2696
02:00:08,600 --> 02:00:11,600
into the low, 32 bits and clears, the high 32 bits.

2697
02:00:12,300 --> 02:00:16,000
I then just go ahead and assign that to a 32-bit value, which is, you

2698
02:00:16,000 --> 02:00:17,900
know, basically, this is a cast here, right?

2699
02:00:17,900 --> 02:00:22,600
This is doing this, right, so I'm now truncating that I'm lopping off

2700
02:00:22,600 --> 02:00:23,200
the top.

2701
02:00:24,100 --> 02:00:29,800
I then do the opposite to get the low 32 bits out eye mask, right, the

2702
02:00:29,800 --> 02:00:30,000
load.

2703
02:00:30,200 --> 02:00:33,600
D2, B, which will clear the high 32 bits.

2704
02:00:33,700 --> 02:00:35,200
And then again, do the cast.

2705
02:00:35,200 --> 02:00:38,700
So this is basically, I'm just extracting these two things.

2706
02:00:39,500 --> 02:00:43,900
The, the drawing of this, by the way, I tried to get Credo working.

2707
02:00:43,900 --> 02:00:46,000
I don't know if it will, but I tried

2708
02:00:48,300 --> 02:00:49,100
To get it working.

2709
02:00:49,900 --> 02:00:50,800
Let's take a look here.

2710
02:00:51,800 --> 02:00:52,900
Let's take a look.

2711
02:00:54,100 --> 02:01:00,300
So if I, if I oops here hit create here.

2712
02:01:00,300 --> 02:01:01,500
I don't know if it's going to work at all.

2713
02:01:01,900 --> 02:01:03,900
It was a little creepy as a little crashy.

2714
02:01:04,100 --> 02:01:06,700
I will say, at least on Windows, it is.

2715
02:01:06,800 --> 02:01:08,900
So it was a bit problematic, but let's take a look.

2716
02:01:10,000 --> 02:01:10,600
So here we go.

2717
02:01:11,100 --> 02:01:11,600
Okay.

2718
02:01:12,100 --> 02:01:16,900
So what we're looking at here is we've got a 64-bit thing, right?

2719
02:01:17,200 --> 02:01:17,800
So this this

2720
02:01:18,000 --> 02:01:22,100
Entire thing, here is 64 bits, right?

2721
02:01:23,000 --> 02:01:26,500
And so, that means we've got a high 32 bits, right?

2722
02:01:27,200 --> 02:01:30,000
And a low 32 bits, right?

2723
02:01:32,700 --> 02:01:33,800
Hopefully, this makes sense.

2724
02:01:35,800 --> 02:01:37,600
So this is our value here.

2725
02:01:37,600 --> 02:01:39,000
This is total size.

2726
02:01:39,300 --> 02:01:39,900
Right?

2727
02:01:39,900 --> 02:01:44,300
It's 64 bits long and we got some some bits up here, and we got some

2728
02:01:44,300 --> 02:01:45,000
bits down here.

2729
02:01:45,000 --> 02:01:48,200
And what we want to do is we want to extract this into two separate

2730
02:01:48,200 --> 02:01:49,600
pieces, right?

2731
02:01:49,800 --> 02:01:56,500
We want to basically be able to, to do this operation into two pieces,

2732
02:01:56,800 --> 02:02:00,100
the high piece and the low piece, right?

2733
02:02:00,400 --> 02:02:02,400
So what I did is I said, all right.

2734
02:02:02,700 --> 02:02:06,600
The first thing, you know, we can we get them into ways in order to

2735
02:02:06,600 --> 02:02:09,300
get the low 32 bits in order to get this part out.

2736
02:02:09,300 --> 02:02:09,600
Really.

2737
02:02:09,600 --> 02:02:15,500
All we have to do is cast it to a 32-bit value which I did with that,

2738
02:02:15,500 --> 02:02:16,700
parentheses d word.

2739
02:02:16,800 --> 02:02:20,400
Right, which will convert the value to only being 32 bits long.

2740
02:02:20,400 --> 02:02:24,300
But in order to make sure that it didn't do something like take a

2741
02:02:24,300 --> 02:02:24,700
look.

2742
02:02:24,800 --> 02:02:28,800
I want to make sure the compiler knew that I wasn't trying to convert

2743
02:02:28,800 --> 02:02:32,400
the value to the closest 32-bit number in which

2744
02:02:32,500 --> 02:02:34,800
It would, if there was any bit set up here.

2745
02:02:34,800 --> 02:02:35,200
It would be.

2746
02:02:35,200 --> 02:02:37,000
Just like, all the bits set down here.

2747
02:02:37,100 --> 02:02:39,200
I want to just extract just that part.

2748
02:02:39,400 --> 02:02:44,500
So, what I did with that, and remember, ffff ffff, there is just all

2749
02:02:44,500 --> 02:02:46,400
1s in the low bits, right?

2750
02:02:46,400 --> 02:02:48,600
It's 32 ones up here.

2751
02:02:49,200 --> 02:02:53,700
So, what I do with that and is, I basically had all zeros up here,

2752
02:02:53,900 --> 02:02:54,500
right?

2753
02:02:55,400 --> 02:02:56,700
And all ones down here.

2754
02:02:56,700 --> 02:02:59,800
I do the and which, again, nothing up here, too.

2755
02:03:00,000 --> 02:03:02,600
Are what set up here since all of these are 0.

2756
02:03:02,600 --> 02:03:06,100
If the, since all these inputs of the answer is 0, it'll knock out

2757
02:03:06,100 --> 02:03:07,000
everything that's in here.

2758
02:03:07,100 --> 02:03:09,500
So it'll be all zeros up here after we're done.

2759
02:03:10,000 --> 02:03:12,600
And then, since these are all ones, anything left in here, will still

2760
02:03:12,600 --> 02:03:13,100
be there.

2761
02:03:13,700 --> 02:03:18,200
So the and basically just, you know, takes just this part and puts it

2762
02:03:18,200 --> 02:03:20,100
into a separate value for us, right?

2763
02:03:21,000 --> 02:03:23,200
So that's what this line does, right?

2764
02:03:23,200 --> 02:03:25,300
It doesn't end to knock out it.

2765
02:03:25,300 --> 02:03:28,300
Basically, it keeps this part of it, the low 32 bits, and knocks out

2766
02:03:28,300 --> 02:03:30,600
the top part convert to a 32-bit value.

2767
02:03:30,600 --> 02:03:32,700
And that's our low for the high.

2768
02:03:33,100 --> 02:03:36,100
What I did is I said, well, I want all of these, right?

2769
02:03:36,400 --> 02:03:38,300
I want this, this side of things.

2770
02:03:38,700 --> 02:03:42,400
But if I just go ahead and cast it to a 32-bit value, it's going to

2771
02:03:42,400 --> 02:03:44,900
keep this bottom part and throw out the top part.

2772
02:03:45,300 --> 02:03:46,600
So I want the opposite of that.

2773
02:03:46,600 --> 02:03:50,700
So what I did is I shifted this down by 32 to move, these 32 bits.

2774
02:03:50,900 --> 02:03:54,900
These 32 bits shifting down, shift zeros into here.

2775
02:03:54,900 --> 02:03:58,300
So, I've already got all zeros at the top and the 32 bits that were on

2776
02:03:58,300 --> 02:03:59,500
the top, go into the bottom.

2777
02:04:00,100 --> 02:04:02,600
Once that happens, that those 32 bits from the bottom.

2778
02:04:02,800 --> 02:04:05,600
I just do the cast, and now I write them in here, right?

2779
02:04:05,600 --> 02:04:06,500
And that's what this line.

2780
02:04:06,500 --> 02:04:06,800
Does.

2781
02:04:07,000 --> 02:04:10,300
It just shifts down by 32 and conversed with 32-bit value.

2782
02:04:10,300 --> 02:04:13,800
So that extracts, the high extracts, the low and then I've got the

2783
02:04:13,800 --> 02:04:14,600
high and low and I'm done.

2784
02:04:15,300 --> 02:04:16,500
So, hopefully that makes some sense.

2785
02:04:25,200 --> 02:04:27,400
So somebody says you can create a performance heavy application in

2786
02:04:27,400 --> 02:04:28,700
Java without the garbage collection.

2787
02:04:28,700 --> 02:04:33,900
If you configure it to run as real time instead of virtually, I'm not

2788
02:04:33,900 --> 02:04:37,600
sure exactly what you mean in real time instead of virtually.

2789
02:04:38,700 --> 02:04:40,100
But again,

2790
02:04:42,000 --> 02:04:48,800
Like, I'm just trying to underscore the fact that I don't want to have

2791
02:04:48,800 --> 02:04:51,700
to fight a garbage collector.

2792
02:04:52,800 --> 02:04:55,700
And a VM to make my application fast in.

2793
02:04:55,700 --> 02:04:56,700
See if I write it.

2794
02:04:56,700 --> 02:04:58,100
It just already is fast.

2795
02:04:58,300 --> 02:05:02,100
So all I'm doing with Java is adding headaches for myself, where I

2796
02:05:02,100 --> 02:05:07,300
have to fight the language to make the code, do what I already could

2797
02:05:07,300 --> 02:05:08,600
have just written to do and see.

2798
02:05:10,200 --> 02:05:14,800
And so that is the real problem with high-level languages these days

2799
02:05:15,600 --> 02:05:18,100
and it's frustrating because I feel like people don't seem to

2800
02:05:18,100 --> 02:05:22,000
acknowledge this fact, which is that I don't ever want to fight the

2801
02:05:22,000 --> 02:05:22,500
language.

2802
02:05:22,700 --> 02:05:25,100
Performance performance should be a given.

2803
02:05:25,600 --> 02:05:29,100
I should be able to write code that tells the CPU exactly what to do

2804
02:05:29,400 --> 02:05:33,500
and if the high-level language can't do that, then it's it's just not

2805
02:05:33,500 --> 02:05:34,000
interesting.

2806
02:05:34,100 --> 02:05:35,600
I don't think that's a useful thing.

2807
02:05:36,800 --> 02:05:38,600
We should have high-level languages.

2808
02:05:38,700 --> 02:05:42,000
But what they should be is they should be built on that concept and

2809
02:05:42,000 --> 02:05:46,400
then layered on top of that, core ability to write exactly what the

2810
02:05:46,400 --> 02:05:51,300
CPU should do, should be facilities for more easily, expressing.

2811
02:05:51,400 --> 02:05:52,500
Those things that

2812
02:05:52,600 --> 02:05:56,600
You would construct so that they can lever on top of these of one

2813
02:05:56,600 --> 02:05:59,100
another and I've yet to see the high-level language.

2814
02:05:59,100 --> 02:05:59,800
That does that.

2815
02:06:00,400 --> 02:06:01,500
They are all.

2816
02:06:01,600 --> 02:06:03,200
They all don't do that.

2817
02:06:04,500 --> 02:06:07,300
They all are misguided in some way or another, that makes it so that

2818
02:06:07,300 --> 02:06:11,700
they fall short of that goal in my opinion, which is unfortunate.

2819
02:06:11,700 --> 02:06:14,600
But someday I think we'll have one and then that will be a really

2820
02:06:14,600 --> 02:06:17,900
awesome high-level language because then you will have the benefits of

2821
02:06:17,900 --> 02:06:21,600
high level programming without the drawbacks that all of today's

2822
02:06:21,900 --> 02:06:25,200
modern high-level languages have, which is that you have to fight them

2823
02:06:25,200 --> 02:06:26,400
to get your performance back.

2824
02:06:33,500 --> 02:06:34,600
Do I consider visible?

2825
02:06:34,600 --> 02:06:36,500
Basica programming language?

2826
02:06:37,700 --> 02:06:42,200
Yeah, I mean, I I think I've only used Visual Basic once and it was

2827
02:06:42,200 --> 02:06:42,900
many many.

2828
02:06:42,900 --> 02:06:44,300
Many, many years ago.

2829
02:06:44,300 --> 02:06:48,000
I was think I was writing some like word automation stuff in it or

2830
02:06:48,000 --> 02:06:48,600
something.

2831
02:06:50,100 --> 02:06:53,300
But anything that allows you to program a computer is a programming

2832
02:06:53,300 --> 02:06:57,200
language and Visual Basic certainly allows you to program a computer.

2833
02:06:57,600 --> 02:07:00,500
So yes, I would definitely consider it a programming language.

2834
02:07:00,600 --> 02:07:02,600
I don't know what else I would consider it if I didn't.

2835
02:07:02,800 --> 02:07:03,900
That a programming language.

2836
02:07:07,600 --> 02:07:10,700
Connor rents C++ or C sharp.

2837
02:07:10,900 --> 02:07:11,900
Is that a question?

2838
02:07:13,000 --> 02:07:14,000
I'm not sure if that's a question.

2839
02:07:17,000 --> 02:07:18,400
On the memory CPU speed.

2840
02:07:18,400 --> 02:07:21,500
I see the answer is that the hardware doesn't do this?

2841
02:07:21,800 --> 02:07:24,500
I guess I'm just envisioning a system where the GB of memory never

2842
02:07:24,500 --> 02:07:25,700
visits the CPU.

2843
02:07:25,900 --> 02:07:28,100
I am envisioning that the memory could receive an instruction that

2844
02:07:28,100 --> 02:07:29,400
says locally move.

2845
02:07:29,400 --> 02:07:31,000
The gigabyte over to this location.

2846
02:07:31,600 --> 02:07:33,600
So, yes, mr.

2847
02:07:33,600 --> 02:07:34,400
Fourth dimension.

2848
02:07:34,500 --> 02:07:35,300
That is a deep.

2849
02:07:35,300 --> 02:07:40,400
What's called the dma engine usually and they are they exist on many

2850
02:07:40,400 --> 02:07:41,100
things.

2851
02:07:41,100 --> 02:07:42,800
Including modern CPUs.

2852
02:07:42,800 --> 02:07:46,700
Just I think just not in ways that you can really use.

2853
02:07:46,800 --> 02:07:51,000
The way that you're thinking of on things like a PlayStation, right?

2854
02:07:51,000 --> 02:07:55,000
Like on the PlayStation 2 or something, you do a lot of exactly what

2855
02:07:55,000 --> 02:07:55,500
you just said.

2856
02:07:55,500 --> 02:07:58,300
There's like dma engines that you program to move memory around and

2857
02:07:58,300 --> 02:08:01,700
stuff, and they are kind of like their own little processors, that all

2858
02:08:01,700 --> 02:08:03,200
they do is move memory around.

2859
02:08:03,700 --> 02:08:04,800
And so that is a thing.

2860
02:08:05,000 --> 02:08:09,200
It's just not a thing that's common on x64 chips because the

2861
02:08:09,200 --> 02:08:11,700
instruction set just didn't grow up around that.

2862
02:08:11,800 --> 02:08:16,000
So you just yeah, you don't really have.

2863
02:08:18,200 --> 02:08:20,600
That thing available to program in the iso.

2864
02:08:20,600 --> 02:08:24,400
Like it's just not there, but I feel like I could be wrong about this,

2865
02:08:24,400 --> 02:08:27,000
but I feel like I'm like, a bulldozer core or one of these cores.

2866
02:08:27,000 --> 02:08:28,400
That's like an AMD core.

2867
02:08:28,700 --> 02:08:31,600
I feel like there's probably ways to kick off dma and stuff on those

2868
02:08:31,600 --> 02:08:32,900
nowadays, maybe in mantle.

2869
02:08:32,900 --> 02:08:33,400
I don't know.

2870
02:08:33,400 --> 02:08:36,100
I like I said, I don't, I haven't done any of that stuff.

2871
02:08:36,100 --> 02:08:39,800
I don't know if you can or not, but I would be surprised if there

2872
02:08:39,800 --> 02:08:44,400
wasn't some of that going on unlike the modern integrated Graphics

2873
02:08:44,400 --> 02:08:45,400
CPUs at least.

2874
02:08:52,400 --> 02:08:53,200
That's a good point.

2875
02:08:53,200 --> 02:08:56,100
Tom Forsythe was pointing out that one thing we could do if you wanted

2876
02:08:56,100 --> 02:08:57,400
to not do this bit shifting.

2877
02:08:57,400 --> 02:08:59,800
Here is we could use large.

2878
02:09:00,000 --> 02:09:01,100
Jur, right.

2879
02:09:01,100 --> 02:09:03,900
That thing that that Windows uses, we could do something like.

2880
02:09:03,900 --> 02:09:10,800
Okay, large, integer Max size for the file mapping.

2881
02:09:11,000 --> 02:09:12,500
We just say, OK, the max size.

2882
02:09:12,500 --> 02:09:15,800
We have that quad part that we've been using, right?

2883
02:09:16,000 --> 02:09:17,100
We could do that.

2884
02:09:17,100 --> 02:09:22,100
But then, instead of doing, we can just use that to extract the two

2885
02:09:22,100 --> 02:09:23,300
values that we wanted.

2886
02:09:23,300 --> 02:09:23,900
Right?

2887
02:09:24,200 --> 02:09:26,500
So basically, it's a union, right?

2888
02:09:26,500 --> 02:09:29,100
If you remember unions, when we talked about those and see,

2889
02:09:30,000 --> 02:09:35,400
Basically, we can say that, here we go.

2890
02:09:37,300 --> 02:09:38,800
This is the Union, right?

2891
02:09:38,800 --> 02:09:42,600
And you can see the union has a struct that has a low and a high,

2892
02:09:42,800 --> 02:09:43,500
right?

2893
02:09:44,200 --> 02:09:47,800
And it also has a this quad part.

2894
02:09:47,800 --> 02:09:51,600
So if we assign to the quad part, which is 64 bits, we can then read

2895
02:09:51,600 --> 02:09:56,500
out of the low and the high part and those will actually give us back.

2896
02:09:56,600 --> 02:10:00,100
The 32 bits that are the top and the 32 bits that are at the bottom,

2897
02:10:00,400 --> 02:10:00,900
right?

2898
02:10:01,800 --> 02:10:04,600
So we can actually just have the compiler do it for us if we want to

2899
02:10:04,600 --> 02:10:06,100
and it'll jump through the rid, the code.

2900
02:10:06,100 --> 02:10:06,900
If we just do it, this

2901
02:10:07,100 --> 02:10:11,700
Right, right, and then you don't need to worry about doing that

2902
02:10:11,700 --> 02:10:12,700
operation yourself.

2903
02:10:12,700 --> 02:10:13,500
Does that make sense?

2904
02:10:14,700 --> 02:10:22,800
So, you know, now we've done basically exactly the same thing, right?

2905
02:10:24,700 --> 02:10:25,700
And so that's yeah.

2906
02:10:25,700 --> 02:10:28,700
So Tom Tom for us was just pointing out the fact that I was saying

2907
02:10:28,700 --> 02:10:31,500
there was no macro and there isn't a macro, but he was saying, oh, you

2908
02:10:31,500 --> 02:10:32,900
could use large integer, which you can.

2909
02:10:32,900 --> 02:10:36,000
So you can just use that as a way to kind of convert values assignment

2910
02:10:36,000 --> 02:10:36,800
of the quad part pull.

2911
02:10:37,000 --> 02:10:40,100
I'm out of the high low, or you could do the opposite, you could

2912
02:10:40,500 --> 02:10:43,000
assign to the high and the low, and then pull out the quad part, if

2913
02:10:43,000 --> 02:10:47,200
you were trying to assemble a 64-bit value, so kind of useful.

2914
02:10:59,900 --> 02:11:02,700
In your mind, what would be a good way to demonstrate to a potential

2915
02:11:02,700 --> 02:11:05,700
employer Proficiency in the type of engine programming?

2916
02:11:05,700 --> 02:11:06,600
You are teaching.

2917
02:11:07,000 --> 02:11:10,600
I know this is a long way off and I'm still just learning.

2918
02:11:10,600 --> 02:11:11,800
But to prepare for the future.

2919
02:11:11,800 --> 02:11:14,700
What would you recommend to be honest?

2920
02:11:14,700 --> 02:11:15,900
I have no idea.

2921
02:11:18,300 --> 02:11:25,300
I am not involved in the kind of hiring that happens at like lower

2922
02:11:25,300 --> 02:11:29,000
levels of game development, where you're talking about, like an

2923
02:11:29,000 --> 02:11:31,800
entry-level position or something like an entry-level engine program

2924
02:11:31,800 --> 02:11:32,300
position.

2925
02:11:32,500 --> 02:11:36,100
So I don't know how those decisions get made and I don't know how

2926
02:11:36,100 --> 02:11:39,500
people come to the attention of the hiring people.

2927
02:11:39,500 --> 02:11:41,700
So I'm afraid I can't really answer that question.

2928
02:11:42,000 --> 02:11:46,500
All I can really tell you is that at the end of handmade hero, if you

2929
02:11:46,500 --> 02:11:47,900
actually understand everything.

2930
02:11:48,000 --> 02:11:49,500
We did in handmade hero.

2931
02:11:50,900 --> 02:11:55,100
If you really do understand it and could do it yourself afterwards.

2932
02:11:55,600 --> 02:11:59,800
Then you would be immediately able to contribute to.

2933
02:12:00,900 --> 02:12:03,500
an engine team, I think, but

2934
02:12:04,600 --> 02:12:06,300
How that translates into getting hired.

2935
02:12:06,300 --> 02:12:06,900
I don't know.

2936
02:12:07,000 --> 02:12:07,600
Right.

2937
02:12:07,800 --> 02:12:12,100
All I can guarantee you is that I'm teaching you the stuff that you

2938
02:12:12,200 --> 02:12:16,200
do, the mental processes, the code structure, the architecture,

2939
02:12:16,200 --> 02:12:20,200
understanding the way debug things, the way to profile things, that's

2940
02:12:20,200 --> 02:12:24,200
good enough to be on an engine team that we can guarantee now how to

2941
02:12:24,200 --> 02:12:25,100
get hired on engine team.

2942
02:12:25,100 --> 02:12:25,700
I don't know.

2943
02:12:26,200 --> 02:12:29,500
So that's like a, something for an HR person, perhaps to answer.

2944
02:12:30,000 --> 02:12:32,300
But I'm not, I'm not too familiar with that.

2945
02:12:40,100 --> 02:12:42,300
Chasing tiger, thank you for the thank you.

2946
02:12:42,800 --> 02:12:45,300
He was just saying, thank you for the stream.

2947
02:12:45,400 --> 02:12:48,200
I am delighted that you like it.

2948
02:12:49,000 --> 02:12:51,100
It's really awesome to come and see people on the stream.

2949
02:12:51,100 --> 02:12:51,600
To be honest.

2950
02:12:51,600 --> 02:12:54,200
I've been, it's just been awesome.

2951
02:12:54,200 --> 02:12:56,800
How many people have come to watch handmade hero?

2952
02:12:56,800 --> 02:13:00,000
Because I didn't think that many people would, at least, not till the

2953
02:13:00,000 --> 02:13:02,600
game was up and running, and I could say, hey look, there's like a

2954
02:13:02,600 --> 02:13:03,100
cool game.

2955
02:13:03,100 --> 02:13:06,500
You should come watch, How It's being built, and people are like

2956
02:13:06,500 --> 02:13:07,000
interested.

2957
02:13:07,100 --> 02:13:08,500
From the beginning, which is kind of awesome.

2958
02:13:08,500 --> 02:13:09,100
It's made it.

2959
02:13:09,100 --> 02:13:10,000
So it's not lonely.

2960
02:13:10,000 --> 02:13:11,500
You know, I'm not sitting here on the stream going.

2961
02:13:11,700 --> 02:13:13,100
Hello, zero viewers.

2962
02:13:13,200 --> 02:13:14,800
Let's talk about whatever today.

2963
02:13:14,800 --> 02:13:15,200
It's like.

2964
02:13:15,200 --> 02:13:18,000
It's this pretty exciting to know that I'm talking to a large number

2965
02:13:18,000 --> 02:13:20,300
of people who are actually interested in what we're doing, so, it's

2966
02:13:20,300 --> 02:13:21,100
been pretty awesome.

2967
02:13:23,700 --> 02:13:24,800
Let's see here.

2968
02:13:29,100 --> 02:13:31,800
What defines the boundary between a high-level language in a low-level

2969
02:13:31,800 --> 02:13:32,400
language?

2970
02:13:33,200 --> 02:13:34,700
That's kind of a good question.

2971
02:13:34,700 --> 02:13:37,200
And I think it's a little nebulous, right?

2972
02:13:37,200 --> 02:13:38,600
Like it's kind of something.

2973
02:13:41,400 --> 02:13:44,400
That probably doesn't have a very specific definition.

2974
02:13:44,400 --> 02:13:46,700
It's kind of more about your sense of it.

2975
02:13:47,300 --> 02:13:52,700
The way I think about it is I would I would draw the boundary.

2976
02:13:53,100 --> 02:13:55,100
I would probably draw the boundary.

2977
02:13:56,000 --> 02:14:02,600
at whether or not it has features designed to

2978
02:14:06,000 --> 02:14:09,500
whether or not it has a significant number of features that are simply

2979
02:14:09,500 --> 02:14:17,500
designed to create code as opposed to that are designed to create code

2980
02:14:17,500 --> 02:14:21,000
structures as opposed to things that are designed to tell the

2981
02:14:21,000 --> 02:14:22,000
processor what to do.

2982
02:14:22,200 --> 02:14:25,600
So like a low-level language is one that has features for generating

2983
02:14:25,600 --> 02:14:28,500
assembly code like directly General Assembly Language.

2984
02:14:28,500 --> 02:14:29,900
So C is pretty good at that.

2985
02:14:30,000 --> 02:14:33,700
It basically just has a bunch of features that pretty much all they do

2986
02:14:33,700 --> 02:14:34,800
is generate.

2987
02:14:34,900 --> 02:14:36,900
Instructions on the CPU, right?

2988
02:14:36,900 --> 02:14:42,200
And I would say a high-level language is one that has a set of

2989
02:14:42,200 --> 02:14:47,600
features that are designed to create whole structures of code.

2990
02:14:47,600 --> 02:14:52,100
That each themselves have how they would generate Assembly Language.

2991
02:14:52,100 --> 02:14:55,300
So it's like coming up one level from that specificity.

2992
02:14:55,300 --> 02:14:59,800
So and a high-level language I think of is having

2993
02:15:00,100 --> 02:15:04,100
layer where it's like, you know, an example would be

2994
02:15:05,500 --> 02:15:10,100
Let's say that I write a bunch of low-level code, that is all the code

2995
02:15:10,100 --> 02:15:16,500
necessary to make a stack of objects, you know, like a memory stack

2996
02:15:17,500 --> 02:15:20,100
and I think of a high-level language is something that allows me to

2997
02:15:20,100 --> 02:15:22,500
generalize the concept of a stack.

2998
02:15:22,700 --> 02:15:26,800
So that anytime I want to Stack, I can make one using this code that

2999
02:15:26,800 --> 02:15:29,500
I've written and have a bunch of control over, which features, the

3000
02:15:29,500 --> 02:15:32,800
stock has how big the things on the stack are, how often it allocates,

3001
02:15:32,800 --> 02:15:33,900
it all that sort of stuff.

3002
02:15:34,100 --> 02:15:35,100
So I'm kind of like, meh

3003
02:15:35,200 --> 02:15:36,000
Programming at that.

3004
02:15:36,000 --> 02:15:39,900
So I'm pulling back a level and allowing myself to generate code using

3005
02:15:40,000 --> 02:15:43,600
parameters as to how the coach should be generated and different

3006
02:15:43,600 --> 02:15:47,700
languages succeed or fail at this, you know, in various ways.

3007
02:15:48,000 --> 02:15:49,900
So whether something is a good high level language is different.

3008
02:15:49,900 --> 02:15:52,300
From whether it is a high-level language, certainly C++ has a high

3009
02:15:52,300 --> 02:15:53,100
level language.

3010
02:15:53,800 --> 02:15:54,900
It's just a really bad one.

3011
02:15:56,100 --> 02:15:56,800
Right?

3012
02:15:56,800 --> 02:16:01,200
But it is trying to be one is just awful at what it does and some

3013
02:16:01,200 --> 02:16:04,800
other languages, you know, probably something like python.

3014
02:16:05,200 --> 02:16:08,400
Is a very good high level language at certain things, but in terms of

3015
02:16:08,400 --> 02:16:11,500
actually creating what the determining, what the CPU does it's awful.

3016
02:16:11,500 --> 02:16:14,400
So at some level it's a bad high level language at one goal.

3017
02:16:14,500 --> 02:16:18,100
A goal that I find important which is giving the high-level programmer

3018
02:16:18,100 --> 02:16:22,500
control over exactly whether that's happening on the CPU when they

3019
02:16:22,500 --> 02:16:23,000
care.

3020
02:16:23,500 --> 02:16:26,900
So, you know, like I said, I've never seen a good high level language

3021
02:16:26,900 --> 02:16:27,500
so far.

3022
02:16:29,600 --> 02:16:30,300
I'm still waiting.

3023
02:16:41,600 --> 02:16:43,600
When will I start actual game logic?

3024
02:16:45,200 --> 02:16:46,100
Probably Monday?

3025
02:16:46,500 --> 02:16:49,900
Well, maybe Tuesday, Thursday, Wednesday.

3026
02:16:49,900 --> 02:16:51,000
I know sometime next week.

3027
02:16:51,600 --> 02:16:56,000
Will start game logic, have I heard of the rust language?

3028
02:16:56,000 --> 02:17:00,700
Yes, but I have not actually played with it much.

3029
02:17:01,700 --> 02:17:03,900
I only curse or really looked at it.

3030
02:17:04,299 --> 02:17:06,900
It did based on sort of the attitude of it.

3031
02:17:06,900 --> 02:17:07,900
It didn't look like something.

3032
02:17:07,900 --> 02:17:08,600
I would be interested in.

3033
02:17:08,600 --> 02:17:11,100
But, you know, it's hard to say without having actually written.

3034
02:17:11,299 --> 02:17:12,100
Programs in it.

3035
02:17:13,500 --> 02:17:15,700
Obviously the language I'm most excited about is John's.

3036
02:17:15,900 --> 02:17:19,400
So the language, I hold out the most hope for is is the one that John

3037
02:17:19,400 --> 02:17:23,000
blows working on because he seems to be one of the first people

3038
02:17:23,000 --> 02:17:26,400
designing a high-level language you has like a proper approach to it,

3039
02:17:26,400 --> 02:17:27,000
I think.

3040
02:17:31,500 --> 02:17:33,500
Have you ever dealt with programmer, burnout?

3041
02:17:33,500 --> 02:17:36,100
Or how do you deal with the fact that often there are days almost no

3042
02:17:36,100 --> 02:17:38,600
code gets written and on some days, massive amounts of code gets

3043
02:17:38,600 --> 02:17:39,000
written.

3044
02:17:48,799 --> 02:17:50,900
So, I guess what I would say is.

3045
02:17:53,500 --> 02:17:57,799
I rarely have any problem with programmer burnout, if I'm just writing

3046
02:17:57,799 --> 02:17:59,700
code that supposed to do something.

3047
02:18:01,299 --> 02:18:04,000
So I've never had that happen, per se.

3048
02:18:05,200 --> 02:18:09,200
What I do have a problem with is when I'm trying to develop a new

3049
02:18:09,200 --> 02:18:09,900
technique.

3050
02:18:12,200 --> 02:18:14,600
And I just don't know how to do it.

3051
02:18:15,000 --> 02:18:15,600
Right?

3052
02:18:17,400 --> 02:18:19,500
Like when I'm working on something that either, I don't know if it's

3053
02:18:19,500 --> 02:18:21,000
even possible, which can happen.

3054
02:18:21,000 --> 02:18:21,600
Sometimes.

3055
02:18:21,600 --> 02:18:24,799
Like you're like, I don't know if what I'm trying to do is possible or

3056
02:18:24,799 --> 02:18:27,100
if I'm working on something where I'm like, I'm not sure how this

3057
02:18:27,100 --> 02:18:28,200
architecture should work.

3058
02:18:28,200 --> 02:18:30,500
And there's a lot of different ways, it could work and I have to kind

3059
02:18:30,500 --> 02:18:33,100
of think them through those sorts of things.

3060
02:18:33,100 --> 02:18:35,200
You can definitely get into that situation where like, nothing is

3061
02:18:35,200 --> 02:18:35,799
getting done.

3062
02:18:36,600 --> 02:18:37,000
Typically.

3063
02:18:37,000 --> 02:18:41,799
What I try to do in those circumstances is be self-aware enough.

3064
02:18:42,000 --> 02:18:43,900
Recognize the fact that nothing's getting done.

3065
02:18:44,100 --> 02:18:47,799
So recognize the fact that you didn't do any work today, be like,

3066
02:18:47,799 --> 02:18:49,600
okay, we're in a bad situation.

3067
02:18:50,700 --> 02:18:54,400
And then what I would do is I take that opportunity to go.

3068
02:18:54,400 --> 02:18:58,000
All right, I'm going to write at least an hour's worth of code

3069
02:18:58,000 --> 02:19:00,799
tomorrow on whatever first comes to mind.

3070
02:19:01,000 --> 02:19:01,600
Right?

3071
02:19:01,600 --> 02:19:04,299
So let's say, I'm having a lot of trouble with this architecture and I

3072
02:19:04,299 --> 02:19:06,100
just can't figure out the right way to do it.

3073
02:19:06,799 --> 02:19:09,799
Then what I tried in like naoko got done today, like nothing got done.

3074
02:19:09,799 --> 02:19:11,900
It was like eight hours of sitting in front of computer and doing

3075
02:19:11,900 --> 02:19:12,400
nothing.

3076
02:19:13,299 --> 02:19:13,900
Then the next day.

3077
02:19:13,900 --> 02:19:15,700
What I'll try to do is just like, all right.

3078
02:19:16,200 --> 02:19:18,900
I'm going to take the first thing, I think of for this architecture,

3079
02:19:18,900 --> 02:19:19,500
even if it's

3080
02:19:20,500 --> 02:19:22,000
The stupidest idea.

3081
02:19:22,000 --> 02:19:25,799
Like what even no matter whatever my last thought was that was what I

3082
02:19:25,799 --> 02:19:28,299
got to when I was trying to figure this out, no matter how dumb it

3083
02:19:28,299 --> 02:19:28,700
was.

3084
02:19:28,900 --> 02:19:30,100
I'm going to just implement it.

3085
02:19:31,500 --> 02:19:34,400
Because a lot of times you find is just getting the code out there and

3086
02:19:34,400 --> 02:19:37,299
then having something to work with is enough to kind of break through

3087
02:19:37,299 --> 02:19:38,100
that barrier.

3088
02:19:38,400 --> 02:19:41,400
And so, typically what I find is the way that you get into those stuck

3089
02:19:41,400 --> 02:19:45,000
situations, the kind of talking about those stuck situations, often

3090
02:19:45,000 --> 02:19:49,100
are because you're not coding, you're trying to think something

3091
02:19:49,100 --> 02:19:51,900
through, and you're trying to think it through too far, and you've

3092
02:19:51,900 --> 02:19:55,800
reached the limits of what your mind can comprehend without seeing it

3093
02:19:55,900 --> 02:19:57,000
and without playing with it.

3094
02:19:57,200 --> 02:20:00,800
So what you need to do is get it out there and so I usually find that

3095
02:20:00,800 --> 02:20:01,200
that's the way.

3096
02:20:01,400 --> 02:20:01,600
Do it.

3097
02:20:01,600 --> 02:20:04,800
And if you can, just make sure just force yourself to write an hour of

3098
02:20:04,800 --> 02:20:08,700
code a day, in those situations eventually you'll break through and

3099
02:20:08,700 --> 02:20:10,900
you can get back up to writing, a reason amount of code.

3100
02:20:12,700 --> 02:20:16,100
The only thing you must not let happen is, is stopping writing code

3101
02:20:16,100 --> 02:20:16,700
entirely.

3102
02:20:16,700 --> 02:20:19,200
When you do that, you risk run the risk of getting into that

3103
02:20:19,200 --> 02:20:21,200
circumstance where you have several days and you don't get anything

3104
02:20:21,200 --> 02:20:21,500
done.

3105
02:20:22,100 --> 02:20:23,600
So that's what I would say about that.

3106
02:20:29,300 --> 02:20:32,300
Any Source or book recommendation for understanding the concepts you

3107
02:20:32,300 --> 02:20:33,100
use better?

3108
02:20:33,600 --> 02:20:36,700
Not really because I don't think there's any been a lot of books that

3109
02:20:36,700 --> 02:20:37,800
are like.

3110
02:20:37,800 --> 02:20:43,500
I find that most programming educational materials.

3111
02:20:43,500 --> 02:20:44,200
When I look at them.

3112
02:20:44,200 --> 02:20:46,300
I'm kind of horrified at the things they're teaching.

3113
02:20:46,300 --> 02:20:49,400
I'm like that is not the way to Be an Effective programmer, right?

3114
02:20:51,100 --> 02:20:53,600
And so I have a hard time recommending, anything because I'm like, I

3115
02:20:53,600 --> 02:20:54,100
don't know.

3116
02:20:54,100 --> 02:20:57,400
I'm not sure there might be some books out there that are good, but I

3117
02:20:57,400 --> 02:20:58,400
don't know what they are.

3118
02:20:58,400 --> 02:20:58,800
Certainly the

3119
02:20:59,000 --> 02:20:59,100
X.

3120
02:20:59,100 --> 02:20:59,900
I read when I was right.

3121
02:21:00,000 --> 02:21:01,400
Program are not good.

3122
02:21:03,100 --> 02:21:05,800
But yeah, so I don't know.

3123
02:21:05,800 --> 02:21:06,200
I'm sorry.

3124
02:21:06,200 --> 02:21:07,700
I don't have a really good recommendation.

3125
02:21:10,300 --> 02:21:13,100
Have you seen game programming patterns by Robert?

3126
02:21:13,100 --> 02:21:13,800
Nistrim?

3127
02:21:14,200 --> 02:21:15,300
I don't think so.

3128
02:21:15,300 --> 02:21:17,200
Although I think someone has sent me that recently.

3129
02:21:17,200 --> 02:21:20,700
I haven't read it yet, but I think someone was talking about it.

3130
02:21:21,000 --> 02:21:23,300
Are you going to use any design patterns?

3131
02:21:27,600 --> 02:21:31,900
So the phrase design patterns is a little confusing to me because

3132
02:21:31,900 --> 02:21:34,900
people use it differently to mean different things.

3133
02:21:35,500 --> 02:21:35,800
I guess.

3134
02:21:35,800 --> 02:21:40,000
What I would say is, I have my own set of ways that I do architecture,

3135
02:21:41,100 --> 02:21:43,500
and you could call those design patterns.

3136
02:21:43,800 --> 02:21:46,500
They're, like, whatever you want to call Casey's design patterns.

3137
02:21:46,600 --> 02:21:47,500
And they're like, these are the ways.

3138
02:21:47,500 --> 02:21:48,600
I tend to structure things.

3139
02:21:49,000 --> 02:21:51,800
And in that sense, then yes, I would like, you would see these sorts

3140
02:21:51,800 --> 02:21:54,900
of things used in various places of my code and they're similar,

3141
02:21:54,900 --> 02:21:55,500
right?

3142
02:21:56,900 --> 02:21:59,800
In terms of design patterns like the design patterns that are maybe in

3143
02:21:59,800 --> 02:22:01,400
the book design patterns.

3144
02:22:02,000 --> 02:22:02,800
I don't

3145
02:22:04,200 --> 02:22:05,400
I find that those.

3146
02:22:06,500 --> 02:22:10,200
Are very odd things to call Design patterns because they're more like

3147
02:22:10,900 --> 02:22:14,000
utility classes or something out there really straight.

3148
02:22:14,000 --> 02:22:19,400
Like I don't really understand what people mean when they say design

3149
02:22:19,400 --> 02:22:19,700
patterns.

3150
02:22:19,700 --> 02:22:22,800
So, I feel like different people use it to mean different things.

3151
02:22:23,200 --> 02:22:26,200
So it's hard for me to answer that question, if that makes sense.

3152
02:22:31,900 --> 02:22:32,500
Do you find it?

3153
02:22:32,500 --> 02:22:34,800
Useful to learn many different languages to gain perspective?

3154
02:22:35,700 --> 02:22:36,600
No, I don't.

3155
02:22:39,100 --> 02:22:43,100
I think programming works from first principles very well.

3156
02:22:44,100 --> 02:22:47,600
So I think what's valuable to learn is how CPUs and Hardware work.

3157
02:22:47,900 --> 02:22:51,100
That's what I think because anything you will ever do with a language

3158
02:22:51,100 --> 02:22:53,200
is just generating stuff for the CPU to do.

3159
02:22:53,400 --> 02:22:56,600
And so the most important thing is that you understand how the CPU and

3160
02:22:56,600 --> 02:22:56,700
the CPU.

3161
02:22:56,900 --> 02:22:57,400
Them works.

3162
02:22:58,000 --> 02:23:01,000
If you understand that, then everything that is efficient about

3163
02:23:01,000 --> 02:23:03,000
programming can be built on top of that.

3164
02:23:03,300 --> 02:23:07,000
And in fact, when you think it through from first principles in that

3165
02:23:07,000 --> 02:23:11,600
sense, that is the easiest way to recognize and realize what's so bad

3166
02:23:11,600 --> 02:23:15,400
about Minor modern high level languages because you can see as you go

3167
02:23:15,400 --> 02:23:16,900
up each level you go.

3168
02:23:16,900 --> 02:23:19,200
Okay, here's how I, here's how the CPU Works.

3169
02:23:19,200 --> 02:23:20,800
Here's how I'd program in Assembly Language.

3170
02:23:21,200 --> 02:23:23,100
Here's how I program it and see.

3171
02:23:23,100 --> 02:23:23,500
Okay.

3172
02:23:23,500 --> 02:23:26,700
That's okay, but I lost some stuff and you can

3173
02:23:26,800 --> 02:23:28,300
Sort of see what the problems are in.

3174
02:23:28,300 --> 02:23:28,600
See?

3175
02:23:28,600 --> 02:23:31,200
Just by looking at what you can do at assembly versus what you can do

3176
02:23:31,200 --> 02:23:34,000
and see, see loses, a bunch of things and you're like, that's a

3177
02:23:34,000 --> 02:23:34,500
bummer.

3178
02:23:34,700 --> 02:23:37,100
So a better C language would fix that.

3179
02:23:37,600 --> 02:23:43,100
And then going from C to something else like a python or Ruby or C++

3180
02:23:43,100 --> 02:23:45,500
or whatever your higher-level language of choices.

3181
02:23:47,300 --> 02:23:51,000
You can see how they basically just don't get it.

3182
02:23:51,000 --> 02:23:54,700
Like, the people who designed those languages, don't understand what

3183
02:23:54,700 --> 02:23:58,000
you actually needed to make your job of programming in c easier

3184
02:23:58,500 --> 02:23:59,800
because or rather program.

3185
02:24:00,000 --> 02:24:03,100
Simple language, you might even say easier because they don't allow

3186
02:24:03,100 --> 02:24:07,800
you to Loft the commonalities up, which is what you're trying to do.

3187
02:24:07,900 --> 02:24:10,700
You're trying to make something that will allow you to say.

3188
02:24:10,700 --> 02:24:13,000
Here's the Assembly Language that I wanted to generate.

3189
02:24:13,100 --> 02:24:16,200
I want to specify that once and I want to love that up into something

3190
02:24:16,200 --> 02:24:19,600
that I can easily specify in a variety of ways such that it meshes

3191
02:24:19,600 --> 02:24:21,300
properly and does, you know, things properly?

3192
02:24:21,300 --> 02:24:24,100
Whatever, it's so obvious when you look at it.

3193
02:24:25,200 --> 02:24:28,700
what you really should be doing for it to get to that high level level

3194
02:24:28,700 --> 02:24:30,300
language and

3195
02:24:31,700 --> 02:24:36,300
I don't know why universally almost all have a level languages.

3196
02:24:36,600 --> 02:24:38,800
Don't even seem to try to do the right thing.

3197
02:24:38,800 --> 02:24:39,600
I don't know.

3198
02:24:39,800 --> 02:24:42,500
I think it may be because the types of people who do language design,

3199
02:24:42,500 --> 02:24:45,300
maybe aren't the types of people who write efficient programs.

3200
02:24:47,400 --> 02:24:50,800
It might be because languages are hard to write.

3201
02:24:50,800 --> 02:24:53,700
And so you spend a lot of time focusing on other things and don't

3202
02:24:53,700 --> 02:24:56,900
realize that you should be focusing on this.

3203
02:24:56,900 --> 02:25:01,300
I don't know, but I find that hole high level language Mass to be

3204
02:25:01,300 --> 02:25:01,400
rather.

3205
02:25:01,600 --> 02:25:04,500
Or frustrating because I find like they're mostly not very

3206
02:25:04,500 --> 02:25:05,500
intelligently done.

3207
02:25:06,000 --> 02:25:06,500
So, I would say,

3208
02:25:11,200 --> 02:25:14,300
What do you think about using VCS for one man projects?

3209
02:25:14,700 --> 02:25:18,000
I always do use version control system for projects.

3210
02:25:18,200 --> 02:25:19,400
Even my own projects.

3211
02:25:20,000 --> 02:25:22,500
I have one that I wrote myself and that's what I use.

3212
02:25:24,400 --> 02:25:27,200
I wrote it to do the things that I want to do conveniently.

3213
02:25:27,500 --> 02:25:32,100
And so I would recommend using a source code control system.

3214
02:25:33,300 --> 02:25:37,200
I don't super like the ones which that exists currently, which is why

3215
02:25:37,200 --> 02:25:40,600
I wrote my own, but I feel like most

3216
02:25:40,800 --> 02:25:44,200
People can usually find one existing one that that's suitable enough

3217
02:25:44,200 --> 02:25:45,300
for them and use it.

3218
02:25:45,600 --> 02:25:48,700
So if you, if you can find one, that's okay for you and that you're

3219
02:25:48,700 --> 02:25:51,000
comfortable with and you should you should use it, I think.

3220
02:25:53,500 --> 02:25:55,200
What's your mindset when looking at a problem?

3221
02:25:55,200 --> 02:25:55,900
That's new.

3222
02:25:56,100 --> 02:25:58,500
How do you approach a new coding problem that you have?

3223
02:25:58,500 --> 02:25:59,900
No predefined idea on how to solve.

3224
02:26:00,000 --> 02:26:01,800
So we will be seeing that in the Stream.

3225
02:26:02,100 --> 02:26:07,400
So like there's I've intentionally set up a bunch of stuff like in the

3226
02:26:07,400 --> 02:26:12,000
game design that I've never done before in a game logic or anything

3227
02:26:12,300 --> 02:26:16,300
and so will be I will be sort of showing you how I work through it.

3228
02:26:16,300 --> 02:26:17,500
I'll make all the mistakes.

3229
02:26:17,500 --> 02:26:19,700
I'll Rectify them.

3230
02:26:19,700 --> 02:26:20,900
I'll revise the architecture.

3231
02:26:20,900 --> 02:26:22,600
I'll do all those things so you can watch.

3232
02:26:22,900 --> 02:26:23,500
You do them.

3233
02:26:23,900 --> 02:26:30,500
So that will be very well elucidated as we go as we go through the

3234
02:26:30,500 --> 02:26:30,900
Stream.

3235
02:26:34,200 --> 02:26:36,300
Well, I read a book after handmade here is done.

3236
02:26:36,300 --> 02:26:37,600
No, I don't think so.

3237
02:26:38,200 --> 02:26:43,200
I think handmade hero will be probably what what I can contribute in

3238
02:26:43,200 --> 02:26:44,200
terms of education.

3239
02:26:44,700 --> 02:26:45,100
So

3240
02:26:46,600 --> 02:26:48,100
how long have I been in the industry?

3241
02:26:50,600 --> 02:26:53,200
Two decades in the industry.

3242
02:27:00,000 --> 02:27:02,700
Tiny concert has a question for me and Tom Forsythe.

3243
02:27:02,700 --> 02:27:05,400
I've always been a hobbyist, The more I've learned over the last year,

3244
02:27:05,400 --> 02:27:06,200
the more I love programming.

3245
02:27:06,200 --> 02:27:09,600
Your opinion is going back for a 4-year CS degree a waste.

3246
02:27:09,600 --> 02:27:12,000
If I want to learn to make things that don't suck.

3247
02:27:13,500 --> 02:27:14,400
That's a tough question.

3248
02:27:14,500 --> 02:27:17,500
I'ma let Tom answer that one because he actually went to University

3249
02:27:17,500 --> 02:27:18,400
and I did not.

3250
02:27:18,500 --> 02:27:20,100
So I'm not really a position to say.

3251
02:27:22,100 --> 02:27:24,300
Perhaps, the problem with high-level languages that they are less

3252
02:27:24,300 --> 02:27:26,700
General but more domain-specific in the first place.

3253
02:27:26,800 --> 02:27:27,300
It could be.

3254
02:27:27,300 --> 02:27:29,900
I think it's just that they don't care about the right things.

3255
02:27:32,100 --> 02:27:36,700
I think they get caught up in trying to be clever within their own

3256
02:27:36,700 --> 02:27:39,000
framework and they don't understand that.

3257
02:27:39,000 --> 02:27:41,400
The point of programming is to make a CPU, do things.

3258
02:27:41,600 --> 02:27:44,800
And so, what you're trying to do is have the most concise way of

3259
02:27:44,800 --> 02:27:48,000
expressing, exactly what the CPU should be doing.

3260
02:27:48,500 --> 02:27:51,700
It is not to have the most concise way of expressing.

3261
02:27:51,900 --> 02:27:53,600
What the language is doing?

3262
02:27:53,800 --> 02:27:57,300
And those are two very different things and I feel like high-level

3263
02:27:57,300 --> 02:28:00,600
languages designers just don't have never understood this somehow

3264
02:28:00,700 --> 02:28:03,400
which is weird, but that just seems you the case.

3265
02:28:05,700 --> 02:28:08,600
How does your source code control differ from something like get or

3266
02:28:08,600 --> 02:28:09,100
SVN?

3267
02:28:09,100 --> 02:28:11,300
Well, basically, it's designed just to be used by me.

3268
02:28:11,300 --> 02:28:14,900
So it's basically just it's one command you type c mirror.

3269
02:28:15,900 --> 02:28:16,500
That's it.

3270
02:28:16,900 --> 02:28:19,100
So whenever you're done working for the day, you just type c Marin and

3271
02:28:19,100 --> 02:28:19,600
that's it.

3272
02:28:20,700 --> 02:28:25,600
There's no push-pull update get grabbed from diff whatever.

3273
02:28:25,600 --> 02:28:26,100
It's nothing.

3274
02:28:26,100 --> 02:28:27,400
It's just like seamer.

3275
02:28:27,700 --> 02:28:28,200
That's it.

3276
02:28:29,000 --> 02:28:31,300
And then you just have a directory on the server that's got all the

3277
02:28:31,300 --> 02:28:31,700
versions.

3278
02:28:31,700 --> 02:28:33,800
So if you ever want anything, you can just go browse them and grab the

3279
02:28:33,800 --> 02:28:34,400
one you want.

3280
02:28:34,700 --> 02:28:35,300
So it's just designed.

3281
02:28:35,500 --> 02:28:38,400
To be as simple as possible and stop getting in your way.

3282
02:28:38,600 --> 02:28:42,100
I find that like get an SVN, make me do a bunch of stuff that I don't

3283
02:28:42,100 --> 02:28:42,600
want to do.

3284
02:28:42,600 --> 02:28:45,100
Like, I don't ever want to think about the source code control as far

3285
02:28:45,100 --> 02:28:45,600
as I'm concerned.

3286
02:28:45,600 --> 02:28:47,200
The source code, which allows us to safety net.

3287
02:28:47,400 --> 02:28:51,800
It should only be there to catch when I've accidentally, like, deleted

3288
02:28:51,800 --> 02:28:54,600
a file or accidentally modified a file that I wouldn't want to.

3289
02:28:54,800 --> 02:28:58,000
It's only supposed to be able to get that back for me and anything

3290
02:28:58,000 --> 02:28:58,200
else.

3291
02:28:58,200 --> 02:28:59,100
It does slows me down.

3292
02:28:59,100 --> 02:28:59,800
I don't want it.

3293
02:29:00,400 --> 02:29:02,500
So, so, yeah, it's one command.

3294
02:29:02,700 --> 02:29:03,700
That's all seem error.

3295
02:29:04,000 --> 02:29:05,300
And, and I vastly prefer.

3296
02:29:05,400 --> 02:29:06,000
For that.

3297
02:29:07,800 --> 02:29:09,900
Okay, looks like we've come to the end of the questions.

3298
02:29:10,300 --> 02:29:13,600
It is 130 that's been a very long stream today.

3299
02:29:14,700 --> 02:29:17,200
Thank you very much for joining me for handmade hero.

3300
02:29:18,200 --> 02:29:22,700
If you enjoyed the program, we do have a patreon that you can support

3301
02:29:22,700 --> 02:29:23,200
by clicking.

3302
02:29:23,200 --> 02:29:26,200
You can go to him a hero dot organ, click on the patreon.

3303
02:29:26,200 --> 02:29:30,000
If you would like to, to essentially subscribe to the series.

3304
02:29:30,500 --> 02:29:33,300
Also, if you want the source code, you can always pre-order the game

3305
02:29:33,300 --> 02:29:36,800
on the animator at org, and you will get a zip file link to download a

3306
02:29:36,800 --> 02:29:37,400
zip file that has

3307
02:29:37,600 --> 02:29:40,700
Everyday Source in it so you can grab any day that you want and follow

3308
02:29:40,700 --> 02:29:41,500
along at home.

3309
02:29:41,500 --> 02:29:45,200
If you would like to discuss the show news and forums is the button

3310
02:29:45,200 --> 02:29:45,800
for you.

3311
02:29:46,200 --> 02:29:48,500
You can go on there and there's a great site that has all kinds of

3312
02:29:48,500 --> 02:29:52,900
stuff and episode guide with links and stuff time coded and everything

3313
02:29:53,100 --> 02:29:57,300
coding resources, which has ports to Mac OS, X, and Linux on it.

3314
02:29:57,300 --> 02:29:59,800
If you want to use a different platform than Windows.

3315
02:30:00,200 --> 02:30:02,500
And then also Co discussion, we can ask questions and all sorts of

3316
02:30:02,500 --> 02:30:02,800
stuff.

3317
02:30:02,800 --> 02:30:05,400
So that is it for today.

3318
02:30:05,600 --> 02:30:07,700
We will be back on Monday at 8 p.m.

3319
02:30:07,700 --> 02:30:08,900
Pacific Standard time.

3320
02:30:09,100 --> 02:30:11,400
I certainly hope to see everyone there.

3321
02:30:12,300 --> 02:30:13,600
And thank you very much dries.

3322
02:30:13,600 --> 02:30:15,200
I hope to see you on Monday.

3323
02:30:15,200 --> 02:30:16,000
Take it easy, everyone.

