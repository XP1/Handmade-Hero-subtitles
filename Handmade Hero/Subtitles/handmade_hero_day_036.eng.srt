1
00:00:00,900 --> 00:00:01,500
Here we go.

2
00:00:02,700 --> 00:00:05,500
Hello, everyone and welcome to handmade hero.

3
00:00:05,500 --> 00:00:08,500
The show where we code a complete game from scratch using nothing.

4
00:00:08,500 --> 00:00:10,300
But our barest typing fingers.

5
00:00:10,700 --> 00:00:11,400
No libraries.

6
00:00:11,400 --> 00:00:15,500
No engine just so we can see basically everything that goes into a

7
00:00:15,500 --> 00:00:16,600
games execution.

8
00:00:16,600 --> 00:00:19,400
Every last thing and we're basically trying to make sure that we

9
00:00:19,400 --> 00:00:26,500
understand everything that a computer does when running a game and at

10
00:00:26,500 --> 00:00:29,100
this point in the process where actually fairly far along, we've made

11
00:00:29,100 --> 00:00:30,500
a win32 prototyping layer we

12
00:00:30,600 --> 00:00:32,600
Made a tilemap storage system for ourselves.

13
00:00:33,100 --> 00:00:36,400
And we're starting to kind of we're trying to basically figure out

14
00:00:36,400 --> 00:00:39,000
what our engine architecture should be like so that we can start to

15
00:00:39,000 --> 00:00:43,400
write the engine, proper that will run our entire game.

16
00:00:43,500 --> 00:00:47,600
And so one of the things that I push a lot in terms of good

17
00:00:47,600 --> 00:00:51,300
programming practices that I think everyone should do is always

18
00:00:51,300 --> 00:00:54,900
experiment and explore first before you design, it's always a good

19
00:00:54,900 --> 00:00:59,200
idea to kind of let designs come out of an exploration rather than

20
00:00:59,200 --> 00:01:00,400
trying to force them by

21
00:01:00,600 --> 00:01:02,700
By doing design up front without really, knowing what you're getting

22
00:01:02,700 --> 00:01:05,500
into and then trying to follow the design and finding out that it's

23
00:01:05,500 --> 00:01:06,300
not so good.

24
00:01:06,600 --> 00:01:09,100
And so that's really the process that we're going through right now.

25
00:01:09,100 --> 00:01:09,700
We did that.

26
00:01:09,700 --> 00:01:13,000
And we sort of came to a place where we were pretty happy with our

27
00:01:13,000 --> 00:01:16,300
tile map system, which is just one aspect of how we need to design the

28
00:01:16,300 --> 00:01:16,700
engine.

29
00:01:17,000 --> 00:01:19,100
And so now we're kind of looking at just kind of wrapping that up a

30
00:01:19,100 --> 00:01:22,200
little bit and then moving into some other things that we need to do.

31
00:01:22,600 --> 00:01:26,000
There's a bunch of other stuff, obviously, beside the tile map that go

32
00:01:26,000 --> 00:01:26,800
into, making a game.

33
00:01:26,800 --> 00:01:28,700
And so we have to kind of start thinking about what those are.

34
00:01:29,600 --> 00:01:33,700
Now, if you have pre-ordered the game, and there's a little bit more

35
00:01:33,700 --> 00:01:35,100
to talk about today regarding this.

36
00:01:35,100 --> 00:01:38,200
If you have pre-ordered the game on handmade here at dot org, using

37
00:01:38,200 --> 00:01:43,100
the pre-order button, you will have gotten a email with obviously you

38
00:01:43,100 --> 00:01:44,100
get access to all the source code.

39
00:01:44,100 --> 00:01:47,600
But you also get access to all of the art assets that we use during

40
00:01:47,600 --> 00:01:48,500
development.

41
00:01:48,700 --> 00:01:53,200
And so one of the things I want to point out is normally I say at this

42
00:01:53,200 --> 00:01:56,200
part of the stream, go to the link that's in that email and make sure

43
00:01:56,200 --> 00:01:58,900
that you download the right source code to start with from today.

44
00:01:58,900 --> 00:01:59,100
If

45
00:01:59,300 --> 00:02:01,400
Want to follow along and today is the 36.

46
00:02:01,400 --> 00:02:06,100
So you want to unzip day 35 source code, but for the first time today,

47
00:02:06,100 --> 00:02:10,500
also, if you look on that link, when you when you go to that link, you

48
00:02:10,500 --> 00:02:14,100
basically get presented with a bunch of things that you can download

49
00:02:14,100 --> 00:02:16,700
that will kind of increase over time as we add more things to the

50
00:02:16,700 --> 00:02:19,800
distribution instead of just the source code.

51
00:02:19,800 --> 00:02:24,300
Now, you will also see a link to download the test assets and

52
00:02:24,300 --> 00:02:27,200
basically these won't change very frequently like will only update the

53
00:02:27,200 --> 00:02:27,500
test.

54
00:02:27,500 --> 00:02:28,200
That's SS.

55
00:02:28,200 --> 00:02:29,100
Every once in a while.

56
00:02:29,200 --> 00:02:32,500
But since this is the first time everyone has to go and get the test

57
00:02:32,500 --> 00:02:33,500
assets for sure.

58
00:02:34,000 --> 00:02:37,100
Basically what they are is they're just a zip file that has in them

59
00:02:37,100 --> 00:02:38,600
One Directory called test.

60
00:02:39,000 --> 00:02:43,500
And what I want you to do is I want you to go ahead and put that into

61
00:02:43,500 --> 00:02:44,800
our handmade directory.

62
00:02:45,000 --> 00:02:47,800
So basically, you know, here's our source directory, right?

63
00:02:47,800 --> 00:02:50,700
We have our code, we have our data, we have our misc and so on.

64
00:02:51,500 --> 00:02:53,200
I got to remember to turn off Arrow Shake.

65
00:02:53,300 --> 00:02:55,300
Someone sent me how to do it, but I forget how to do it.

66
00:02:55,400 --> 00:02:58,500
But basically inside this data directory, what I want you to do is

67
00:02:58,500 --> 00:02:59,100
basically go into that.

68
00:02:59,200 --> 00:02:59,900
At data directory.

69
00:03:00,200 --> 00:03:03,000
We're just going to drag the test executable.

70
00:03:03,200 --> 00:03:05,700
I'm trying to test directory right in there.

71
00:03:06,300 --> 00:03:09,100
And so then if you look inside there, now, we basically have a bunch

72
00:03:09,100 --> 00:03:12,300
of bitmaps that I've prepared for us, which just have you know,

73
00:03:12,300 --> 00:03:15,000
they're very simple files that just have some stuff that we're going

74
00:03:15,000 --> 00:03:18,200
to use to experiment with and you can kind of see if you click on

75
00:03:18,200 --> 00:03:18,400
them.

76
00:03:18,400 --> 00:03:19,600
We just got some stuff.

77
00:03:19,900 --> 00:03:22,400
None of these are final assets for the game or anything but they're

78
00:03:22,400 --> 00:03:26,500
basically like pieces of a character and a shadow that we can use.

79
00:03:26,800 --> 00:03:29,800
There's some layers for for basically.

80
00:03:30,000 --> 00:03:34,200
Like a for a scene that we're going to test with if for some reason

81
00:03:34,200 --> 00:03:37,800
and I don't really know what the reason is Windows, doesn't display

82
00:03:37,800 --> 00:03:38,900
bitmaps properly.

83
00:03:39,300 --> 00:03:42,700
I'm not sure if you've noticed this but like basically like if you if

84
00:03:42,700 --> 00:03:48,300
you have a bitmap a BMP file that has like I'm trying to think of all

85
00:03:48,300 --> 00:03:51,600
those one of them here if you have a BMP that actually has

86
00:03:51,600 --> 00:03:56,600
transparency in it like it tends to go wonky on me.

87
00:03:56,800 --> 00:03:59,000
Like you can see this has transparency here, right?

88
00:03:59,000 --> 00:03:59,800
Like or something.

89
00:04:00,000 --> 00:04:01,800
What was the one that just looked really weird?

90
00:04:02,700 --> 00:04:04,200
So like this looks really weird.

91
00:04:04,300 --> 00:04:05,900
Testing layer 0 1.

92
00:04:06,400 --> 00:04:07,800
So testing layer 0 1.

93
00:04:07,800 --> 00:04:12,200
If I open that up with gimp, I believe that it looks correct, right.

94
00:04:12,900 --> 00:04:14,300
Yeah, you can kind of see that looks correct.

95
00:04:14,300 --> 00:04:15,700
There's a transparent region.

96
00:04:15,800 --> 00:04:17,800
All the colors look roughly like they do, right?

97
00:04:17,800 --> 00:04:21,100
And this is the background from like the website and stuff.

98
00:04:21,399 --> 00:04:25,000
But for some reason, if you look at them in the windows photo viewer,

99
00:04:25,000 --> 00:04:27,100
like Windows couldn't manage to load a BMP.

100
00:04:27,100 --> 00:04:28,500
Now, this is amusing because

101
00:04:29,900 --> 00:04:34,000
well, I mean windows, they're the people who invented the BMP file

102
00:04:34,000 --> 00:04:34,500
format.

103
00:04:34,600 --> 00:04:37,600
So somehow they don't know how to read their own file format.

104
00:04:38,100 --> 00:04:38,700
What you going to do?

105
00:04:38,700 --> 00:04:41,000
That's just that's life in Windows.

106
00:04:41,000 --> 00:04:45,600
Ladies and gentlemen, sometimes you don't know how to read your own

107
00:04:45,600 --> 00:04:51,700
file format, I guess anyway, basically what we're going to be doing

108
00:04:51,700 --> 00:04:54,900
possibly later today, if not tomorrow, depending on where we get to

109
00:04:55,200 --> 00:04:57,600
is, we're going to be starting to use these assets.

110
00:04:57,600 --> 00:04:59,400
I'm going to show you how to load them in, and I'm going to show you

111
00:04:59,400 --> 00:04:59,800
how to use them.

112
00:05:01,100 --> 00:05:03,800
You know, on the screen and stuff just to get things started because I

113
00:05:03,800 --> 00:05:07,400
wanted to have for us to be able to start looking at the scale of

114
00:05:07,400 --> 00:05:09,000
things and how things looked on the screen.

115
00:05:09,000 --> 00:05:12,800
And so we're going to have to write, probably not really the renderer

116
00:05:12,800 --> 00:05:16,100
yet because that's like a huge involved process that will start a

117
00:05:16,100 --> 00:05:19,300
start on and do many days worth of like explaining how render is work

118
00:05:19,300 --> 00:05:22,800
and how all the math works and how we want to approach them and so on.

119
00:05:23,600 --> 00:05:26,800
But we're going to write basically some very simple little system that

120
00:05:26,800 --> 00:05:28,600
can just load bitmaps and put them up on the screen.

121
00:05:28,600 --> 00:05:29,800
So that we, as we

122
00:05:29,900 --> 00:05:32,900
We sort of move forward with our engine architecture.

123
00:05:33,100 --> 00:05:37,400
We won't be Flying Blind because rectangles can get us a certain can

124
00:05:37,400 --> 00:05:38,500
get us only so far.

125
00:05:38,500 --> 00:05:41,100
Basically, in terms of making good decisions about how things are

126
00:05:41,100 --> 00:05:41,700
supposed to work.

127
00:05:42,600 --> 00:05:45,900
So, please make sure that if you're trying to follow a home that you

128
00:05:45,900 --> 00:05:46,700
go ahead and do that.

129
00:05:46,700 --> 00:05:47,500
Hopefully you've already done.

130
00:05:47,500 --> 00:05:49,600
It should be pretty simple again.

131
00:05:49,600 --> 00:05:53,400
Just go to that link, download handmade Hero Test assets, zero zero,

132
00:05:53,400 --> 00:05:57,200
one dot zip and I will notify you guys any time that you need to

133
00:05:57,200 --> 00:05:57,900
download a new one.

134
00:05:57,900 --> 00:05:59,800
But like I said, they should be pretty infrequent because

135
00:06:00,000 --> 00:06:02,500
They are batch up a bunch of new assets that I when I know we're

136
00:06:02,500 --> 00:06:04,300
working on something in particular and I know we're going to be

137
00:06:04,300 --> 00:06:04,600
assets.

138
00:06:04,600 --> 00:06:05,100
I'll patch them up.

139
00:06:05,100 --> 00:06:06,200
So we shouldn't need.

140
00:06:06,500 --> 00:06:07,500
You shouldn't need to update.

141
00:06:07,500 --> 00:06:08,500
This it hardly at all.

142
00:06:08,500 --> 00:06:09,800
It should be very infrequent.

143
00:06:10,000 --> 00:06:12,600
But once in a while, you will have to do it as we start using

144
00:06:12,600 --> 00:06:14,900
different assets types and stuff like that.

145
00:06:16,300 --> 00:06:19,900
All right, so that's basically the situation that we're in.

146
00:06:20,700 --> 00:06:24,000
So now that we've got that going, let's go back to where we were on

147
00:06:24,000 --> 00:06:26,100
Friday because we had a couple Loose Ends.

148
00:06:26,100 --> 00:06:29,800
If I remember correctly, that we need to tie off namely just walking.

149
00:06:30,000 --> 00:06:32,000
And up and down through doors.

150
00:06:32,000 --> 00:06:34,000
So basically up and down through like stairwells.

151
00:06:34,000 --> 00:06:35,800
Basically, if I remember correctly.

152
00:06:35,800 --> 00:06:37,200
What we sort of said is okay.

153
00:06:37,300 --> 00:06:40,900
We've basically wanted to have two planes of our tile map system, one

154
00:06:40,900 --> 00:06:45,000
like sort of an upper and a lower plane that we tried to make and we

155
00:06:45,000 --> 00:06:48,400
have like this concept of a Dora but we are sorry stairwell.

156
00:06:48,400 --> 00:06:51,600
Like in between them when we have tile that goes, you up a level and a

157
00:06:51,600 --> 00:06:55,600
tile that goes down a level, but we don't actually have any code to

158
00:06:55,600 --> 00:06:58,800
handle what happens when you actually move on to one, right?

159
00:06:59,100 --> 00:06:59,900
So, basically, when you

160
00:07:00,000 --> 00:07:00,900
Move on to one of these.

161
00:07:01,200 --> 00:07:05,600
We need to have some way that allows you to kind of change up and

162
00:07:05,600 --> 00:07:05,800
down.

163
00:07:05,800 --> 00:07:07,800
And again, this was not to do anything specific.

164
00:07:07,800 --> 00:07:11,200
It was just to make sure that we could have our tile map system

165
00:07:11,200 --> 00:07:14,100
working with two different planes.

166
00:07:14,800 --> 00:07:17,200
So that, you know, we could have basically a z component.

167
00:07:17,400 --> 00:07:20,600
And once we handle this e component properly, we did it in a generic

168
00:07:20,600 --> 00:07:20,800
way.

169
00:07:20,800 --> 00:07:22,900
So it should be able to handle as many planes as we want.

170
00:07:22,900 --> 00:07:25,900
We can have as many layers like stacked on top of each other as we

171
00:07:25,900 --> 00:07:26,500
want to have.

172
00:07:27,100 --> 00:07:27,600
Okay.

173
00:07:27,600 --> 00:07:29,800
So basically what we need to do is we need to make some changes.

174
00:07:29,900 --> 00:07:32,700
Has to the to the player code and since we don't really have real

175
00:07:32,700 --> 00:07:35,300
player code yet since we haven't really addressed that, it's going to

176
00:07:35,300 --> 00:07:37,900
be a little harder than it should be because basically all we've got

177
00:07:37,900 --> 00:07:40,500
is a thing that just kind of like checks to see where the player is

178
00:07:40,500 --> 00:07:41,800
going to be and then moves them, right.

179
00:07:41,800 --> 00:07:44,000
This is the player code that we have.

180
00:07:44,000 --> 00:07:45,700
We basically create a new player position.

181
00:07:45,700 --> 00:07:50,300
We check to see whether the player can move wherever it's going to be.

182
00:07:50,300 --> 00:07:55,000
And then we kind of have this sort of acceptance function which

183
00:07:55,000 --> 00:07:56,800
basically says, okay except the new location.

184
00:07:56,800 --> 00:07:59,900
And so what we kind of want to do here is if the player moves

185
00:08:00,000 --> 00:08:01,400
Is onto the style.

186
00:08:01,600 --> 00:08:05,500
We want to do an action at the time, when they move on to it, right?

187
00:08:05,500 --> 00:08:06,900
That's basically what we're trying to do.

188
00:08:07,100 --> 00:08:10,300
We're trying to do something that basically says, you know, if they

189
00:08:10,300 --> 00:08:11,500
moved on to a new tile.

190
00:08:11,500 --> 00:08:15,600
Meaning, basically, if new player P, if the new player Pete, I'll

191
00:08:15,600 --> 00:08:19,100
index is not the same as the old player Pete.

192
00:08:19,100 --> 00:08:22,800
I'll ex-player tile index, then we want to do something.

193
00:08:23,500 --> 00:08:25,400
So basically what I'm going to do is I'm just going to introduce a

194
00:08:25,400 --> 00:08:27,600
function here that I can call.

195
00:08:27,600 --> 00:08:28,100
Basically.

196
00:08:28,100 --> 00:08:29,800
I just something I want to I basically want to

197
00:08:29,900 --> 00:08:38,000
Predicate, I want to be able to say, you know, tile are on same tile

198
00:08:38,000 --> 00:08:38,799
or something like that.

199
00:08:38,799 --> 00:08:40,500
I just want to be able to make that statement.

200
00:08:40,500 --> 00:08:44,000
I want to ask that question and say, if they weren't on the same tile,

201
00:08:44,300 --> 00:08:46,900
then what I want to do is just take an action.

202
00:08:47,000 --> 00:08:48,900
I want to look to see what this is.

203
00:08:48,900 --> 00:08:51,800
And now, when we do more player movement code will actually have a lot

204
00:08:51,800 --> 00:08:53,900
more formalized ways of doing this, and what happens with some of

205
00:08:53,900 --> 00:08:54,600
these onto a tile.

206
00:08:54,600 --> 00:08:57,200
But for now, I'm just going to go ahead and check for the two things

207
00:08:57,500 --> 00:08:58,400
that we set up again.

208
00:08:58,400 --> 00:08:59,800
We just had sort of, this is all.

209
00:09:00,000 --> 00:09:02,700
Scratch code to see how things work, but we basically said that door

210
00:09:02,700 --> 00:09:04,900
ups were three Door downs were for.

211
00:09:05,000 --> 00:09:07,900
So I'm just going to check for those and again, because this code is

212
00:09:07,900 --> 00:09:12,600
all getting nuked for much more for different code later.

213
00:09:12,700 --> 00:09:14,400
I'm not actually being specific about these things.

214
00:09:14,400 --> 00:09:16,700
I don't care about pound to finding them to real things, or making a

215
00:09:16,700 --> 00:09:18,800
numerous or anything like that, because we're not going to be doing

216
00:09:18,800 --> 00:09:19,400
anything like this.

217
00:09:19,400 --> 00:09:20,100
In the final code.

218
00:09:20,100 --> 00:09:22,700
This is just sort of glue code.

219
00:09:22,700 --> 00:09:24,600
That allows us to test other systems.

220
00:09:25,000 --> 00:09:27,100
And then later, when it comes time to actually focus on it.

221
00:09:27,100 --> 00:09:29,800
It will all get blown away and will, you know, kind of move forward.

222
00:09:30,000 --> 00:09:32,600
Same with like that, you know our level generation code is all exactly

223
00:09:32,600 --> 00:09:32,800
that.

224
00:09:32,800 --> 00:09:34,100
It's just total crap code.

225
00:09:34,100 --> 00:09:37,200
That's just there to sort of glue things together and let us move

226
00:09:37,200 --> 00:09:38,600
forward with our experimentation.

227
00:09:39,400 --> 00:09:42,200
And the reason again that I don't try to do a good job on that kind of

228
00:09:42,200 --> 00:09:42,400
code.

229
00:09:42,400 --> 00:09:45,700
I only do the bare minimum is because I just don't want to waste a lot

230
00:09:45,700 --> 00:09:49,100
of time thinking about how that code should work at the wrong time.

231
00:09:50,200 --> 00:09:53,500
I would say one thing that's worth mentioning is there is a context

232
00:09:53,500 --> 00:09:56,200
which cost oftentimes encoding where if you're working on one thing

233
00:09:56,200 --> 00:09:57,700
and you go switch to working on another thing.

234
00:09:57,900 --> 00:09:59,900
There is a cost in terms of your brain and how

235
00:10:00,000 --> 00:10:03,300
Like sort of ready it is and how much stuff it's got paged in almost

236
00:10:03,300 --> 00:10:05,400
like a virtual memory system, right?

237
00:10:05,500 --> 00:10:07,100
For the particular problem that you're working on.

238
00:10:07,100 --> 00:10:09,700
And so one thing that I'd like to do is when I'm concentrating on one

239
00:10:09,700 --> 00:10:10,100
thing.

240
00:10:10,300 --> 00:10:12,000
I like to try and just keep concentrating.

241
00:10:12,000 --> 00:10:14,800
That one thing even if that means putting bad code in some other

242
00:10:14,800 --> 00:10:18,700
place, as long as I know that the bad code is there, and I'm aware.

243
00:10:18,700 --> 00:10:20,600
That that's the code that needs to not be there.

244
00:10:20,900 --> 00:10:21,500
Eventually.

245
00:10:21,600 --> 00:10:24,500
I'm okay with that because basically I want to focus on the thing.

246
00:10:24,500 --> 00:10:29,000
I'm focusing on and get as much sort of utility out of my brain sort

247
00:10:29,000 --> 00:10:29,800
of focus.

248
00:10:29,900 --> 00:10:31,300
On that part as I can.

249
00:10:31,300 --> 00:10:33,700
And so I don't want to spend a lot of time doing things like thinking

250
00:10:33,700 --> 00:10:36,600
about how to specify tile values because I know later, we're going to

251
00:10:36,600 --> 00:10:39,200
spend a whole bunch of time thinking about how we specify table hours.

252
00:10:39,200 --> 00:10:41,500
So, any time we spend Now is really just kind of wasted.

253
00:10:42,300 --> 00:10:46,000
So that's said, what I want to do is I want to get the tile map value

254
00:10:46,100 --> 00:10:49,800
at this point that the player is at when I determined that they move

255
00:10:49,800 --> 00:10:50,800
to a new location, right?

256
00:10:50,800 --> 00:10:52,700
So this new player pee, wherever they are.

257
00:10:52,800 --> 00:10:57,200
I'm going to go ahead and sort of grab with the tile value is there.

258
00:10:57,600 --> 00:10:59,800
So basically, I'm going to go to our town map functions that we

259
00:11:00,000 --> 00:11:03,200
Have, if you remember, we pulled them out into the separate file here

260
00:11:03,300 --> 00:11:06,400
and I'm basically going to just ask what that tile value is.

261
00:11:06,700 --> 00:11:10,100
So I'm going to basically try to, let's see where it is, get tile

262
00:11:10,100 --> 00:11:11,100
value right here.

263
00:11:11,800 --> 00:11:13,800
And I'm going to, I'm going to want to get that towel value.

264
00:11:13,800 --> 00:11:15,700
Now, one of the things we probably want to do.

265
00:11:16,000 --> 00:11:18,400
We're probably going to want a function that gets the tile value

266
00:11:18,400 --> 00:11:21,600
directly from a player position, because why not?

267
00:11:21,700 --> 00:11:25,000
And so, I'm probably going to introduce a tile value call AB, it's

268
00:11:25,000 --> 00:11:27,800
just basically a proxy call to our other call, which will do that sort

269
00:11:27,800 --> 00:11:28,600
of cracking for us.

270
00:11:28,600 --> 00:11:29,800
It takes a player position in brakes.

271
00:11:29,900 --> 00:11:32,200
It out into the smaller values.

272
00:11:32,300 --> 00:11:36,400
So basically we have a tile map and I'm just going to put past that

273
00:11:36,400 --> 00:11:39,700
new player key and I'm going to say, give me what the tile value, is

274
00:11:40,200 --> 00:11:41,200
at that location.

275
00:11:41,400 --> 00:11:44,300
So this is like the new tile value and then I'm going to say, all

276
00:11:44,300 --> 00:11:48,800
right, if the new tile value equals, what did we say that?

277
00:11:48,800 --> 00:11:50,900
It was three and a four, I believe is what we said.

278
00:11:51,200 --> 00:11:52,500
So if the new tile value

279
00:11:54,400 --> 00:11:58,500
Is a three then we are going to go a door up.

280
00:11:58,600 --> 00:11:59,800
So 3 is a door up.

281
00:12:00,000 --> 00:12:06,000
Means that our new player P is technically going to become a, whatever

282
00:12:06,000 --> 00:12:09,700
their abs tiles e was, is going to go up 1, right this.

283
00:12:10,300 --> 00:12:16,600
And if it is a, if the new tile value is a 4 then they are going to go

284
00:12:16,700 --> 00:12:17,700
down 1, right.

285
00:12:17,700 --> 00:12:20,200
That's all I want to do there and then we'll accept the player

286
00:12:20,200 --> 00:12:20,600
position.

287
00:12:20,600 --> 00:12:24,700
Now what we could also do here, we could actually treat this as

288
00:12:24,700 --> 00:12:25,600
another check move.

289
00:12:25,600 --> 00:12:28,800
We could verify that the tile and the other side was empty, but at the

290
00:12:28,800 --> 00:12:29,800
moment, like I said, I don't really

291
00:12:30,000 --> 00:12:31,900
think we want to deal with that kind of stuff because it's really not

292
00:12:31,900 --> 00:12:34,500
important that's going to be something we have to think about more

293
00:12:34,500 --> 00:12:37,000
when we get to later stages of things for now.

294
00:12:37,000 --> 00:12:39,100
We know we always Place doors up and doors down symmetrically.

295
00:12:39,100 --> 00:12:39,700
So it's fine.

296
00:12:40,800 --> 00:12:42,700
So is tilemap point empty.

297
00:12:42,700 --> 00:12:45,800
We also have to modify because at the moment is tilemap empty.

298
00:12:46,200 --> 00:12:52,200
Was only basically allowed to return true if the tile chunk value is

299
00:12:52,200 --> 00:12:52,500
1.

300
00:12:52,500 --> 00:12:55,100
But really what we're allowing it to do now is sort of say there's a

301
00:12:55,100 --> 00:12:59,800
bunch of things that sort of classify as empty if you will, right?

302
00:13:00,700 --> 00:13:04,400
There's there's threes and fours are now also considered empty, right?

303
00:13:04,400 --> 00:13:06,700
So we need to kind of say oh you can move on to something.

304
00:13:06,700 --> 00:13:09,000
That's a 1, 2 3, A 1 3, or a 4.

305
00:13:09,200 --> 00:13:10,300
And so what, it's go ahead and do that.

306
00:13:10,300 --> 00:13:13,100
And that way, these these checks won't fail when the player tries to

307
00:13:13,100 --> 00:13:14,000
move on to a door.

308
00:13:14,700 --> 00:13:16,400
And then similarly, the get Tau value function.

309
00:13:16,400 --> 00:13:21,000
Like I said before I want to be able to pass a tile map position to

310
00:13:21,000 --> 00:13:21,900
that as well.

311
00:13:22,400 --> 00:13:25,700
So we'll go ahead and do that here and that is just going to call get

312
00:13:25,700 --> 00:13:26,300
Tau value.

313
00:13:26,300 --> 00:13:29,200
It's really just a pass-through that's going to call.

314
00:13:29,500 --> 00:13:29,800
Excuse me.

315
00:13:29,900 --> 00:13:35,000
Me that get Tau value function for the the poses components.

316
00:13:35,000 --> 00:13:36,800
So that's just it's really just a utility.

317
00:13:36,800 --> 00:13:39,000
It's so that I don't have to type that if the something that I'm going

318
00:13:39,000 --> 00:13:42,700
to call fairly frequently, which I suspect that it is, I'm just going

319
00:13:42,700 --> 00:13:45,600
to go ahead and do that, right?

320
00:13:45,800 --> 00:13:47,300
Oh, why is there still an empty there?

321
00:13:47,600 --> 00:13:49,100
I got mixed up there.

322
00:13:49,100 --> 00:13:50,500
This is actually a return value.

323
00:13:50,500 --> 00:13:54,700
That's just lazy code that surround it is a bit hard for me.

324
00:13:55,300 --> 00:13:57,700
Like I said, many times programming on the stream is a little bit

325
00:13:57,700 --> 00:13:59,100
tough sometimes because

326
00:14:00,200 --> 00:14:01,500
Basically, like it's hard.

327
00:14:01,500 --> 00:14:05,000
It's harder for me to focus when I have to talk and so code kind of

328
00:14:05,100 --> 00:14:05,900
gets a little strange.

329
00:14:05,900 --> 00:14:06,700
It's weird.

330
00:14:06,700 --> 00:14:07,900
I can't explain the feeling.

331
00:14:08,000 --> 00:14:08,800
It's just a little.

332
00:14:08,800 --> 00:14:10,000
It's like a little hazy.

333
00:14:10,100 --> 00:14:12,400
It's a lot hazier than I am when I'm normally programming.

334
00:14:12,400 --> 00:14:14,000
So it's tough.

335
00:14:14,000 --> 00:14:17,200
It's definitely, it's definitely like running a marathon with the

336
00:14:17,200 --> 00:14:18,000
weight belt on.

337
00:14:18,400 --> 00:14:20,100
Anyway, let's see here.

338
00:14:20,100 --> 00:14:20,900
So are on.

339
00:14:20,900 --> 00:14:21,500
Same tile.

340
00:14:21,500 --> 00:14:22,800
Now, we have to implement.

341
00:14:22,900 --> 00:14:24,400
We did not Implement that before.

342
00:14:25,000 --> 00:14:26,800
So I'm going to go ahead and put that in here.

343
00:14:26,800 --> 00:14:28,400
I don't know, eventually.

344
00:14:28,400 --> 00:14:29,800
I feel like we probably

345
00:14:29,900 --> 00:14:34,400
We want to put stuff like, you know re canonicalize physician and

346
00:14:34,400 --> 00:14:34,800
stuff like that.

347
00:14:34,800 --> 00:14:37,700
Now that I think about it like these things really don't have anything

348
00:14:37,700 --> 00:14:41,400
to do with well, I guess they do have something to do with the time.

349
00:14:41,400 --> 00:14:46,200
I because they involve the time applications and that's how sided M

350
00:14:46,200 --> 00:14:49,600
cross the tile side and M isn't really related as much to the time of

351
00:14:49,600 --> 00:14:50,500
blah blah blah blah.

352
00:14:50,500 --> 00:14:51,900
I can see moving.

353
00:14:51,900 --> 00:14:53,000
Basically.

354
00:14:53,000 --> 00:14:54,000
I guess here's what I'd say.

355
00:14:54,000 --> 00:14:57,800
There's stuff in here that really doesn't have anything to do with the

356
00:14:57,800 --> 00:14:59,900
tile map and I think I might kind of

357
00:15:00,000 --> 00:15:04,100
Not that those things to be capped off at some point like these things

358
00:15:04,100 --> 00:15:07,900
really are about tilemap positioning and they have nothing to do with

359
00:15:07,900 --> 00:15:09,600
the actual tile map.

360
00:15:09,600 --> 00:15:12,400
Like the only insofar as they care about the tile map.

361
00:15:12,400 --> 00:15:14,900
All they really care about is how big a tile is.

362
00:15:15,200 --> 00:15:17,500
And that really has nothing to do with the tile map storage.

363
00:15:17,500 --> 00:15:18,000
Right?

364
00:15:19,100 --> 00:15:22,600
And so I'm going to kind of Mark these here, I'm just going to say, do

365
00:15:22,600 --> 00:15:29,900
these really belong in more of a positioning, or a geometry files.

366
00:15:30,000 --> 00:15:33,600
Alright, like and, and sort of just think about that because I feel

367
00:15:33,600 --> 00:15:38,500
like that's probably going to be the case that there really if they're

368
00:15:38,500 --> 00:15:41,900
inappropriately part of this tile map, and they don't really need to

369
00:15:41,900 --> 00:15:42,400
be there.

370
00:15:42,800 --> 00:15:46,700
So, anyway, we now can go back here and say, well, we've got these two

371
00:15:46,700 --> 00:15:48,400
tilemap positions, right?

372
00:15:48,600 --> 00:15:53,800
I've got a Tom, a position, a, and a Tom at position B, and I want to

373
00:15:53,800 --> 00:15:57,400
know, like I said, when there are on same tile, I want to know whether

374
00:15:57,400 --> 00:15:59,500
or not their tile differs or not.

375
00:15:59,500 --> 00:15:59,900
Now it's going.

376
00:16:00,000 --> 00:16:02,200
Nora basically these do things right?

377
00:16:02,400 --> 00:16:05,900
And so whether or not the tile differs is really trivial.

378
00:16:06,300 --> 00:16:10,300
If they're on the same tile than all of their tile in to see portions

379
00:16:10,300 --> 00:16:11,100
will be the same.

380
00:16:11,200 --> 00:16:11,800
Right.

381
00:16:12,200 --> 00:16:13,100
Each individual.

382
00:16:13,100 --> 00:16:16,500
One of these groups should be an and each individual, one of their

383
00:16:16,500 --> 00:16:19,000
components should be exactly the same.

384
00:16:19,000 --> 00:16:23,100
Otherwise, they are on a different tile like that, and then we'll

385
00:16:23,100 --> 00:16:24,000
return that result.

386
00:16:24,000 --> 00:16:24,600
There we go.

387
00:16:25,100 --> 00:16:28,500
And so then I'll go ahead and compile that let's take a look right.

388
00:16:28,500 --> 00:16:29,800
These need to be addresses of these.

389
00:16:29,900 --> 00:16:31,000
These fellows here.

390
00:16:31,900 --> 00:16:32,600
And there we go.

391
00:16:32,800 --> 00:16:34,000
So I believe.

392
00:16:34,000 --> 00:16:37,300
Now we should be able to walk onto this and hey, look, it worked.

393
00:16:37,300 --> 00:16:38,500
We went up a level.

394
00:16:38,900 --> 00:16:41,500
We can go back down a level again, right?

395
00:16:41,800 --> 00:16:45,100
So when we move on, there we go, back up a level and I can, of course.

396
00:16:45,900 --> 00:16:46,300
Go ahead.

397
00:16:46,300 --> 00:16:47,200
I think I've got a speed key.

398
00:16:47,200 --> 00:16:49,600
I do there is a down.

399
00:16:49,800 --> 00:16:50,200
Whoa.

400
00:16:50,300 --> 00:16:53,000
Okay, so that seems a little bit busted.

401
00:16:53,000 --> 00:16:55,400
So I think I've still got some broken code here, because if I remember

402
00:16:55,400 --> 00:16:59,300
correctly, there should only be one exit other than the one you came

403
00:16:59,300 --> 00:16:59,500
in.

404
00:16:59,500 --> 00:16:59,800
So the only

405
00:17:00,000 --> 00:17:03,100
Two exits from any room, but we're clearly adding a door to every

406
00:17:03,100 --> 00:17:03,600
room.

407
00:17:04,300 --> 00:17:07,700
So, basically, that's that's just not at all right?

408
00:17:07,700 --> 00:17:09,200
In terms of the generation code.

409
00:17:09,400 --> 00:17:12,000
So let's take a look at the generation code because I think the

410
00:17:12,000 --> 00:17:16,300
generation code is just plain busted, and we'll take a look at what's

411
00:17:16,300 --> 00:17:16,900
going on there.

412
00:17:17,500 --> 00:17:22,800
So, let's see here, what we have

413
00:17:25,500 --> 00:17:28,000
Okay, so I based, I see what's going on.

414
00:17:28,000 --> 00:17:29,700
Yeah, this is this is busted.

415
00:17:30,200 --> 00:17:33,300
So basically, the way we were doing things before is we basically

416
00:17:33,300 --> 00:17:35,600
said, okay, we have a door up and we have a door down.

417
00:17:35,600 --> 00:17:36,900
We pick a random choice.

418
00:17:36,900 --> 00:17:41,200
And if the random choice is to, we go ahead and we make a door up or

419
00:17:41,200 --> 00:17:45,300
add or down depending on whether or not we're on the top or the bottom

420
00:17:45,300 --> 00:17:45,700
layer.

421
00:17:49,100 --> 00:17:49,700
Right.

422
00:17:50,900 --> 00:17:55,500
Now, what that means is when we get to the end, when we move to the

423
00:17:55,500 --> 00:17:58,500
next room, if door up or down was true or false.

424
00:17:58,500 --> 00:17:59,700
We should we want to do the

425
00:18:00,000 --> 00:18:02,000
For the other room because we're going to make a room below it or

426
00:18:02,000 --> 00:18:02,500
above it.

427
00:18:02,500 --> 00:18:04,100
And we want it to have the corresponding door.

428
00:18:04,100 --> 00:18:05,100
So we basically flip those.

429
00:18:05,100 --> 00:18:09,200
The problem is when we come back through this, again, the next time

430
00:18:10,000 --> 00:18:12,100
door up or down is now set to true or false.

431
00:18:12,100 --> 00:18:15,600
We make that corresponding door, but then we toggle it again.

432
00:18:15,600 --> 00:18:18,800
So we're just going to keep on making doors ad infinitum.

433
00:18:19,500 --> 00:18:24,000
What we really wanted to do here is if we come into the random Choice

434
00:18:24,200 --> 00:18:26,100
with door up or door down.

435
00:18:26,800 --> 00:18:29,600
Or already equaling true or false, right?

436
00:18:29,900 --> 00:18:33,900
Then what we want to do is make sure that we don't make that we want

437
00:18:33,900 --> 00:18:36,200
to remember whether we added a nude or not.

438
00:18:36,200 --> 00:18:39,500
And only if we added a new door do that thing where we keep it.

439
00:18:39,600 --> 00:18:41,100
Otherwise, we want to clear it.

440
00:18:41,300 --> 00:18:42,000
Right.

441
00:18:42,400 --> 00:18:44,700
So, basically, we have a couple things we need to do here.

442
00:18:44,900 --> 00:18:47,800
First of all, if there's already a door up or down, we don't want to

443
00:18:47,800 --> 00:18:49,000
add another one, right?

444
00:18:49,000 --> 00:18:55,100
So we want to basically say, if not door up and not door down and

445
00:18:55,200 --> 00:18:56,000
random choice.

446
00:18:56,600 --> 00:18:58,600
We'll see you basically or I guess we could say.

447
00:18:59,300 --> 00:19:01,800
Oh, we already did that nevermind, if door up or down.

448
00:19:01,900 --> 00:19:03,000
Okay, we already took nevermind.

449
00:19:03,000 --> 00:19:04,400
We heard he took care of that case.

450
00:19:05,400 --> 00:19:06,900
I'm one step ahead of myself.

451
00:19:06,900 --> 00:19:07,700
We already took care of that case.

452
00:19:07,700 --> 00:19:08,800
So we won't do that.

453
00:19:08,900 --> 00:19:12,100
So the only thing we have to do is remember if we created a door up or

454
00:19:12,100 --> 00:19:13,500
down, then we do the toggle.

455
00:19:13,700 --> 00:19:16,000
Otherwise, we don't want to do the toggle right.

456
00:19:16,500 --> 00:19:16,700
Now.

457
00:19:16,700 --> 00:19:20,100
The other thing we could do here is when we do this toggle, if we do

458
00:19:20,100 --> 00:19:23,800
the door up door down toggle, we could also just check to make sure,

459
00:19:24,900 --> 00:19:26,400
you know, we could do something like this.

460
00:19:26,500 --> 00:19:30,600
Basically, we could do if door left or door, right?

461
00:19:31,700 --> 00:19:34,500
Forward, or down or door up.

462
00:19:34,700 --> 00:19:39,900
Sorry, or door, top or door bottom, right?

463
00:19:40,100 --> 00:19:44,400
We could say something like as long as we know that we didn't have any

464
00:19:44,400 --> 00:19:45,100
other door.

465
00:19:45,400 --> 00:19:50,200
Then we know that these doors are the ones that we came through and we

466
00:19:50,200 --> 00:19:54,000
need to toggle the right, if that makes sense or rather.

467
00:19:54,000 --> 00:19:56,400
I should say the other way around as long.

468
00:19:56,600 --> 00:20:00,700
We know that we had one of these other doors in our thing as well.

469
00:20:00,700 --> 00:20:02,000
Then we know that we need to toggle them.

470
00:20:02,000 --> 00:20:04,900
If we didn't have another type of door, that means that we were a door

471
00:20:04,900 --> 00:20:05,800
up or down.

472
00:20:06,300 --> 00:20:07,300
So we should come through here.

473
00:20:07,400 --> 00:20:09,100
I'll think that's going to work though because

474
00:20:10,400 --> 00:20:13,900
Yeah, I think that's still going to be I that's going to be just dumb

475
00:20:13,900 --> 00:20:15,700
because that's going to also hit another bad guy.

476
00:20:15,700 --> 00:20:17,200
So I don't even know why I was thinking of doing that.

477
00:20:17,200 --> 00:20:17,700
That's dumb.

478
00:20:18,600 --> 00:20:22,800
Let's just leave it at basically doing the if here.

479
00:20:24,200 --> 00:20:29,600
We're we're only going to do this toggle, basically, trying to think

480
00:20:29,600 --> 00:20:30,700
of what the easiest way to do.

481
00:20:30,700 --> 00:20:32,800
This year is I guess we want to do.

482
00:20:33,200 --> 00:20:36,900
We just want to basically say if created vertical, you know, if

483
00:20:36,900 --> 00:20:39,000
created Z door, right?

484
00:20:39,200 --> 00:20:42,200
If we create a disease door, then we want to we want to do that.

485
00:20:42,300 --> 00:20:47,900
Otherwise we want to do the false and I think we want to assert here

486
00:20:48,200 --> 00:20:51,700
that the that we only have the two cases if that makes sense, right?

487
00:20:51,700 --> 00:20:53,800
And in fact, if we know we created a z door.

488
00:20:53,900 --> 00:20:55,300
Or then we really know.

489
00:20:55,400 --> 00:20:58,500
I guess that these are just toggles, we know that whatever it was it

490
00:20:58,500 --> 00:20:59,800
just a toggle, right?

491
00:21:00,400 --> 00:21:05,000
So we're just going to we're just going to go ahead and toggle these.

492
00:21:05,300 --> 00:21:05,700
There we go.

493
00:21:05,700 --> 00:21:07,300
That's I like that better space.

494
00:21:07,300 --> 00:21:10,300
We're going to say if we created if we created one of those to Z doors

495
00:21:10,400 --> 00:21:11,700
on this particular.

496
00:21:13,100 --> 00:21:16,200
Yeah, if we created one of the Z doors on this particular one, then we

497
00:21:16,200 --> 00:21:19,000
know that the next one has to have the inverse doors of that.

498
00:21:19,000 --> 00:21:21,300
But if we didn't create a z door, then there shouldn't be a door.

499
00:21:21,400 --> 00:21:23,300
There shouldn't be any Z doors on the next one at all.

500
00:21:23,300 --> 00:21:25,200
It should write only be corresponding doors.

501
00:21:25,500 --> 00:21:26,700
So I think that's a little bit easier.

502
00:21:26,700 --> 00:21:29,100
So I'm just going to say created Z door.

503
00:21:30,000 --> 00:21:33,100
That is false and then I'll basically say, well actually, you know

504
00:21:33,100 --> 00:21:33,900
what, I can do it.

505
00:21:36,700 --> 00:21:37,800
Yeah, no, I have to do it this way.

506
00:21:38,100 --> 00:21:41,600
So basically, in here will basically say created seed or will equal

507
00:21:41,600 --> 00:21:42,600
true right there.

508
00:21:42,900 --> 00:21:45,900
And then when we do it, that should do the toggle or the clear.

509
00:21:46,000 --> 00:21:49,400
And I hope that will be a relatively clear way of avoiding that

510
00:21:49,400 --> 00:21:49,900
problem.

511
00:21:50,400 --> 00:21:50,700
All right.

512
00:21:50,700 --> 00:21:52,200
So if we look at here, now, I go up.

513
00:21:52,200 --> 00:21:53,000
Let's see.

514
00:21:53,400 --> 00:21:55,600
We should not have a z door, and that's true.

515
00:21:56,400 --> 00:21:57,700
And we should only have another Z door.

516
00:21:57,700 --> 00:21:59,400
Once we get to a dead end to basically, here.

517
00:21:59,400 --> 00:22:00,100
We are at the dead end.

518
00:22:00,100 --> 00:22:01,100
We go down a level.

519
00:22:01,300 --> 00:22:03,200
There we go, we go up.

520
00:22:03,200 --> 00:22:04,500
Here we go up again.

521
00:22:04,500 --> 00:22:05,200
There we go.

522
00:22:05,800 --> 00:22:06,500
So there we go.

523
00:22:07,200 --> 00:22:10,100
We're starting to get pretty respectable tile map here people.

524
00:22:10,100 --> 00:22:12,900
I mean this is basically done, you know, this is dungeon ask.

525
00:22:12,900 --> 00:22:15,900
I'm feeling a little dungeon a here, you know, I could I could see

526
00:22:15,900 --> 00:22:18,300
being in a dungeon at this point in time in my life.

527
00:22:18,400 --> 00:22:21,700
You know, that's something that I feel like a lot of people need to

528
00:22:21,700 --> 00:22:23,600
leave and find themselves in Europe and so on.

529
00:22:23,600 --> 00:22:26,100
And right now we're finding ourselves in a little tilemap dungeon,

530
00:22:26,100 --> 00:22:26,700
right?

531
00:22:26,700 --> 00:22:29,000
And there's nothing in the dungeon and there's no loot to be had.

532
00:22:29,000 --> 00:22:31,200
So I'm not sure why we're in the dungeon, but I guess the reason that

533
00:22:31,200 --> 00:22:34,100
we're here is to program all that loot and make it there be a reason

534
00:22:34,100 --> 00:22:35,300
to walk around these but hey.

535
00:22:35,400 --> 00:22:37,900
Hey, it's pretty Pleasant already.

536
00:22:37,900 --> 00:22:38,600
So there we go.

537
00:22:38,800 --> 00:22:43,000
All right, so we basically now know roughly an API that works.

538
00:22:43,000 --> 00:22:43,700
Okay?

539
00:22:43,800 --> 00:22:48,400
For creating a tile map, and that gives us a good starting point.

540
00:22:48,400 --> 00:22:54,800
So, I would say that we have sort of succeeded in, in sort of our, our

541
00:22:54,800 --> 00:22:57,800
goal of getting a first pass design by experimenting.

542
00:22:57,800 --> 00:23:01,300
Like this is a reasonable tile map API.

543
00:23:01,500 --> 00:23:04,800
And if we wanted to go, start implementing good, Spar storage for it

544
00:23:04,800 --> 00:23:05,300
or other things like that.

545
00:23:05,500 --> 00:23:07,800
We could and know that it would be somewhat usable now.

546
00:23:07,800 --> 00:23:10,300
That doesn't mean it's perfect and we're probably as we get a little

547
00:23:10,300 --> 00:23:12,100
further along, going to find, we need to revise it.

548
00:23:12,100 --> 00:23:12,900
But that's okay.

549
00:23:13,100 --> 00:23:15,800
We've kind of done the exploration that we need to be a little bit

550
00:23:15,800 --> 00:23:18,300
comfortable in the sorts of things that happen here and I'm okay with

551
00:23:18,300 --> 00:23:18,700
that.

552
00:23:19,100 --> 00:23:21,500
Now, I'm looking at this and says, should this be, should these be

553
00:23:21,500 --> 00:23:22,400
from the center of a tile?

554
00:23:22,400 --> 00:23:23,800
I believe we already did that.

555
00:23:24,500 --> 00:23:25,700
I'm so I can get rid of that.

556
00:23:25,900 --> 00:23:29,400
And for now, I guess we'll kind of just leave this this way, the tile

557
00:23:29,400 --> 00:23:30,400
rail X and tile.

558
00:23:30,400 --> 00:23:33,000
I guess we'll call this offset X and offset why?

559
00:23:33,000 --> 00:23:35,300
I don't know and say,

560
00:23:35,400 --> 00:23:36,500
They know Casey.

561
00:23:36,500 --> 00:23:44,000
These are the offsets from The Tile Center and then I will go ahead

562
00:23:44,000 --> 00:23:46,200
and and change all of those.

563
00:23:46,200 --> 00:23:49,100
So tile rail will become offset for now.

564
00:23:49,100 --> 00:23:52,400
That's my that's my official verdict.

565
00:23:52,400 --> 00:23:53,400
So there we go.

566
00:23:53,400 --> 00:23:59,100
Doo-doo-doo-doo ago and now and I think that's that's, you know,

567
00:23:59,100 --> 00:23:59,800
pretty reasonable.

568
00:24:00,100 --> 00:24:02,100
I can I, you know, I'm okay with that.

569
00:24:03,900 --> 00:24:08,900
Yeah, so at this point like I was saying before, what I kind of wanted

570
00:24:08,900 --> 00:24:12,200
to do is I was thinking about what's the next thing that we're going

571
00:24:12,200 --> 00:24:13,100
to want to do?

572
00:24:13,600 --> 00:24:16,000
And I, like I said, we are probably going to want to start dealing

573
00:24:16,000 --> 00:24:19,000
with things like player, motion and collision and that sort of stuff

574
00:24:19,600 --> 00:24:21,800
and sort of animation and all that sort of thing.

575
00:24:21,800 --> 00:24:24,500
Because once we have a tile map to move around, there's really two

576
00:24:24,500 --> 00:24:26,700
things we can do, we can start trying to figure out how to draw the

577
00:24:26,700 --> 00:24:31,900
tile map with better graphics, but we also have to figure out how to

578
00:24:31,900 --> 00:24:33,400
make the the game kind of

579
00:24:33,700 --> 00:24:36,100
Bowl and replace the player movement code with real movement code and

580
00:24:36,100 --> 00:24:37,700
get some monsters in their stuff like that.

581
00:24:37,700 --> 00:24:37,900
Right?

582
00:24:37,900 --> 00:24:39,900
We need to, we need both of those things.

583
00:24:40,000 --> 00:24:40,100
Right?

584
00:24:40,100 --> 00:24:42,200
If you think about the next sort of things that we're going to do.

585
00:24:43,000 --> 00:24:45,900
And so I feel like no matter which of those, we pick, whether we want

586
00:24:45,900 --> 00:24:48,400
to do player movement, code, and stuff like that and collision

587
00:24:48,400 --> 00:24:51,900
detection, or whether we want to do better tile Maps.

588
00:24:51,900 --> 00:24:54,800
We're going to have to start dealing with putting some graphics on the

589
00:24:54,800 --> 00:24:58,400
screen that are at least place of look reasonable Place holders for

590
00:24:58,400 --> 00:25:01,600
what might actually be on the screen when the game actually ships.

591
00:25:01,600 --> 00:25:02,700
And so that's why I was thinking.

592
00:25:02,700 --> 00:25:03,500
The next thing we kind of need.

593
00:25:03,700 --> 00:25:05,800
To do is start loading bitmaps if that makes sense.

594
00:25:06,700 --> 00:25:08,200
So that's what I'd like to do for today.

595
00:25:08,500 --> 00:25:11,000
Maybe our goal for today is just going to sort of be to put a bitmap

596
00:25:11,000 --> 00:25:11,600
up on the screen.

597
00:25:11,600 --> 00:25:14,900
Nothing particularly fancy, but just get a bit map up on the screen

598
00:25:15,300 --> 00:25:20,900
from a file so that we can sort of pull art in as we sort of like that

599
00:25:20,900 --> 00:25:24,300
we can start using for our prototyping purposes from here on out.

600
00:25:24,900 --> 00:25:28,300
Hopefully everyone's okay with that as some sort of a decision point,

601
00:25:28,300 --> 00:25:31,200
but let's go ahead and take a look at that.

602
00:25:32,700 --> 00:25:33,600
Basically what we're going to

603
00:25:33,700 --> 00:25:36,700
Do is we're going to try and load one of these bitmap files.

604
00:25:36,700 --> 00:25:42,000
Like I said at the beginning of the stream, which is where I need a

605
00:25:42,000 --> 00:25:43,700
little handmade shortcut there.

606
00:25:44,200 --> 00:25:47,900
So basically, what we need to do is we need to go to handmade and I

607
00:25:47,900 --> 00:25:51,800
need to, like, do you know, like this, this needs to be pinned?

608
00:25:51,900 --> 00:25:53,000
There we go, handmade.

609
00:25:53,700 --> 00:25:57,200
So in the data directory inside test, right?

610
00:25:57,500 --> 00:26:02,200
We've got some various things here and test background is a probably a

611
00:26:02,200 --> 00:26:03,500
good example of something we should.

612
00:26:03,600 --> 00:26:04,600
Probably try to load.

613
00:26:04,600 --> 00:26:08,000
It's basically just, you know, some trees, some mushrooms.

614
00:26:08,100 --> 00:26:09,200
And some grass, right?

615
00:26:09,500 --> 00:26:12,000
Just it's just like a background image, right?

616
00:26:12,700 --> 00:26:16,000
And if we take a look at the size of this background image, right?

617
00:26:17,100 --> 00:26:19,300
If I go into details here, you can see that.

618
00:26:19,300 --> 00:26:22,400
It's 1024 by 576, right?

619
00:26:22,700 --> 00:26:28,100
So if I go in here and take a look at our code inside win32, when we

620
00:26:28,100 --> 00:26:30,500
open up basically our window, right?

621
00:26:30,600 --> 00:26:32,800
When we said, how big we wanted things to be,

622
00:26:34,900 --> 00:26:38,700
If you remember correctly, I kind of was saying well for our renderer

623
00:26:38,700 --> 00:26:40,000
will make it a little smaller.

624
00:26:40,200 --> 00:26:43,100
And so there was some geometry that went on here and I'll put a note

625
00:26:43,100 --> 00:26:48,100
in so that it people can remember, basically, 1920 by 1080 is

626
00:26:48,100 --> 00:26:51,700
currently like a standard HD resolution for a game nowadays, right?

627
00:26:54,400 --> 00:26:54,900
You know.

628
00:26:56,100 --> 00:26:59,800
if you're trying to run a game in HD, typically, 1080p is

629
00:27:00,000 --> 00:27:00,600
Good standard.

630
00:27:00,600 --> 00:27:05,600
That's, this is this is 1080p display mode, right?

631
00:27:05,600 --> 00:27:08,400
This is how this is the resolution on a 1080p display.

632
00:27:09,200 --> 00:27:11,300
And so, you know, if that was sort of what we were targeting for

633
00:27:11,300 --> 00:27:14,400
handmade here, I was saying well, that's what the GPU will be doing.

634
00:27:14,400 --> 00:27:16,300
That will probably try to do that with a GPU.

635
00:27:17,300 --> 00:27:20,800
But if we don't have a GPU so for our own renderer because we will be

636
00:27:20,800 --> 00:27:21,900
much slower than a GPU.

637
00:27:21,900 --> 00:27:22,600
Obviously.

638
00:27:23,700 --> 00:27:29,200
What I want to do is basically say, Okay, reduce that by half, right?

639
00:27:29,700 --> 00:27:29,900
And

640
00:27:30,000 --> 00:27:32,700
And if we take a look, see if I can use the quick calc thing.

641
00:27:32,700 --> 00:27:33,500
We discovered.

642
00:27:34,000 --> 00:27:36,700
Let's see 19 20 divided by 2.

643
00:27:37,100 --> 00:27:37,900
You can kind of see that.

644
00:27:37,900 --> 00:27:43,800
Basically, if we divide both values by 2, we get this 960 by 540.

645
00:27:45,000 --> 00:27:50,500
So basically half of that is 1960 by six by 540.

646
00:27:51,100 --> 00:27:54,100
So as the saying, let's run it half resolution because then it'll be

647
00:27:54,100 --> 00:27:55,400
easy for us to just imagine.

648
00:27:55,400 --> 00:27:59,000
Well, okay, everything will just be twice as dense.

649
00:27:59,000 --> 00:27:59,700
Pixelize.

650
00:27:59,700 --> 00:28:03,500
It'll just look much nicer when we go up to doing gpus, but basically,

651
00:28:03,500 --> 00:28:06,200
our screen aspect ratio and everything else will be basically the

652
00:28:06,200 --> 00:28:11,200
same, it'll be nice and easy, but what you'll notice is the details

653
00:28:11,200 --> 00:28:14,500
here make are a little bit weird, like 10.

654
00:28:14,700 --> 00:28:16,900
For by fences by 576.

655
00:28:16,900 --> 00:28:18,100
Doesn't really make much sense.

656
00:28:18,300 --> 00:28:20,800
When you think about the fact that our screen is 960 by 540.

657
00:28:20,800 --> 00:28:22,200
So why did I make a bitmap?

658
00:28:22,500 --> 00:28:23,500
That was that sighs.

659
00:28:24,000 --> 00:28:27,300
The reason that I made a bitmap that size is because, at least in GPU

660
00:28:27,300 --> 00:28:31,500
land, a lot of times you want your textures to be a power of 2 in size

661
00:28:31,900 --> 00:28:34,300
for reasons that we can talk about later on.

662
00:28:35,700 --> 00:28:38,000
Basically, when we get down to GPU things.

663
00:28:38,000 --> 00:28:40,900
We'll talk about that a little bit more, but for right now, we'll

664
00:28:40,900 --> 00:28:44,500
simply say that power of two textures tend to be a very handy thing.

665
00:28:44,600 --> 00:28:46,100
To be able to have on GPU side.

666
00:28:46,100 --> 00:28:50,400
So thinking about powers of 2 and looking at 1920 by 1080.

667
00:28:50,400 --> 00:28:55,500
The first thing that you might say is well, 1920 by 1080 is a pretty

668
00:28:55,500 --> 00:28:58,400
inconvenient number in terms of a power of 2.

669
00:28:58,500 --> 00:29:03,200
If you wanted to round it 1920 is pretty easy to fix.

670
00:29:03,500 --> 00:29:06,300
20:48 is a power of 2 that's very close to that.

671
00:29:06,400 --> 00:29:11,500
And so if you think about it 2048 - 1920 right if I oops that's not

672
00:29:11,500 --> 00:29:11,900
good.

673
00:29:12,800 --> 00:29:13,900
Let's do a quick calculation.

674
00:29:14,200 --> 00:29:14,300
So

675
00:29:14,700 --> 00:29:19,600
48 - 1920 is only 128 pixels difference.

676
00:29:19,600 --> 00:29:19,800
Right?

677
00:29:19,800 --> 00:29:22,200
So you're only losing 128 pixel band.

678
00:29:22,200 --> 00:29:27,100
If you went up to 22 to 2048 on the other hand, the closest power of

679
00:29:27,100 --> 00:29:27,600
2.

680
00:29:29,200 --> 00:29:31,600
And again, it's not really the close of our to, it's the next power of

681
00:29:31,600 --> 00:29:32,700
2 up, right?

682
00:29:32,700 --> 00:29:34,300
Because you can't have less than that.

683
00:29:34,300 --> 00:29:36,000
I need to fill the whole screen.

684
00:29:36,200 --> 00:29:41,800
So if I wanted to do a 1080 as a power of 2, I have a problem because

685
00:29:41,900 --> 00:29:43,900
basically 1024 is too small.

686
00:29:43,900 --> 00:29:44,500
That's the closest.

687
00:29:44,600 --> 00:29:46,000
Power of two, right?

688
00:29:46,400 --> 00:29:50,500
But 2048 is massively away, which is the next pair of to up from that.

689
00:29:50,500 --> 00:29:57,900
So too, if I do a quick count there of 2048 - 1080 I'm wasting 968

690
00:29:57,900 --> 00:29:59,900
pixels, which doesn't really make

691
00:30:00,600 --> 00:30:02,000
Very much sense, right?

692
00:30:02,200 --> 00:30:05,100
That is just not very economical at all.

693
00:30:05,100 --> 00:30:07,100
And there's even with screen Shake.

694
00:30:07,100 --> 00:30:08,500
There's no you no chance.

695
00:30:08,500 --> 00:30:10,300
You're ever going to use 968.

696
00:30:10,300 --> 00:30:11,800
So you would never make a bleed.

697
00:30:11,800 --> 00:30:15,100
You would never overdraw by that many pixels.

698
00:30:15,100 --> 00:30:15,700
It's crazy.

699
00:30:18,100 --> 00:30:18,800
You're just throwing away.

700
00:30:18,800 --> 00:30:20,000
Good memory at that point.

701
00:30:21,000 --> 00:30:25,600
So what I was thinking was basically what's the next power of 2?

702
00:30:25,600 --> 00:30:31,500
You could basically use that would be sort of 1024 plus another band

703
00:30:31,500 --> 00:30:34,400
to store the bottom of the image.

704
00:30:35,000 --> 00:30:40,700
Well, basically if you think of what it would take to get past 1080 at

705
00:30:40,700 --> 00:30:45,400
that point, you could, if you wanted to add 64 to it, right?

706
00:30:45,400 --> 00:30:48,700
You could have one power of two texture that was 1024 or one power of

707
00:30:48,700 --> 00:30:51,000
two that 64 and basically what I'm talking about.

708
00:30:51,100 --> 00:30:54,500
Just in case so that you can see it as I've got, you know, oops.

709
00:30:54,500 --> 00:30:57,700
That's that's a that's one heck of a, of a rectangular Casey.

710
00:30:58,500 --> 00:31:03,100
So if I have 1920 by 1080 and I want to figure out how to fit this

711
00:31:03,100 --> 00:31:04,300
into a power of two thing.

712
00:31:04,600 --> 00:31:09,800
Basically what I'm saying is well, okay, 20:48, if you if you add 128

713
00:31:09,800 --> 00:31:16,200
pixels here, then 2048 isn't really isn't too much of a waste.

714
00:31:16,200 --> 00:31:16,600
Is there.

715
00:31:16,600 --> 00:31:18,900
Especially when you consider the fact that you know, if you had a bit

716
00:31:18,900 --> 00:31:20,700
map that was drawn, that was meant to fill the whole screen.

717
00:31:21,000 --> 00:31:22,900
And you want to be able to do a little bit of screen shake or

718
00:31:22,900 --> 00:31:23,800
something like that.

719
00:31:23,800 --> 00:31:25,600
You're just going to be a little bit of bleed.

720
00:31:25,600 --> 00:31:26,200
Right?

721
00:31:26,300 --> 00:31:31,500
So 64 pixels on either side is not too much to think about in terms of

722
00:31:31,500 --> 00:31:32,200
bleed, right?

723
00:31:32,200 --> 00:31:35,900
64 here and 64 here is not too much.

724
00:31:36,000 --> 00:31:39,700
So 1920 + 64, + 64 ends up.

725
00:31:39,700 --> 00:31:44,500
Getting us to 2048 which would be roughly the you know, the size of

726
00:31:44,500 --> 00:31:47,200
what would be a nice power of to size that we could use with gpus.

727
00:31:47,200 --> 00:31:50,500
Right, but the problem is the next power of 2 that we would have to

728
00:31:50,500 --> 00:31:50,900
break too.

729
00:31:51,000 --> 00:31:54,800
Attend 1080, we don't want 2048 for that.

730
00:31:54,800 --> 00:31:56,700
That Dimension because it would be way too large.

731
00:31:56,700 --> 00:31:58,000
We wasting a ton of space.

732
00:31:58,900 --> 00:32:00,800
So we only have 10 24.

733
00:32:00,800 --> 00:32:05,500
Now, 1024 is going to cut off a little bit too soon, right?

734
00:32:05,500 --> 00:32:06,800
It's going to cut off.

735
00:32:08,700 --> 00:32:10,100
Where did I do the calculation?

736
00:32:10,100 --> 00:32:10,600
I don't know.

737
00:32:10,600 --> 00:32:13,000
I thought I did it but I guess I didn't do it.

738
00:32:13,200 --> 00:32:17,800
So if we do a 1024 1080 - 1024 is 56, right?

739
00:32:17,800 --> 00:32:20,900
So we have to store 56, more pixels, which means that we could

740
00:32:20,900 --> 00:32:25,500
Could use a 64 wide texture we could stop at 10:24, and then use a 64

741
00:32:25,500 --> 00:32:26,800
wide right here.

742
00:32:26,900 --> 00:32:27,700
Another Bando.

743
00:32:27,700 --> 00:32:32,200
We could basically store screen size things into chunks one chunk,

744
00:32:32,200 --> 00:32:34,700
that looks like this and one chunk, that looks like that.

745
00:32:36,300 --> 00:32:36,900
Right.

746
00:32:40,600 --> 00:32:43,600
But now we've got another problem if we're saying that we want some

747
00:32:43,600 --> 00:32:47,000
screen shake and we want like 64 is a good, is what we're saying is

748
00:32:47,000 --> 00:32:49,600
might be a reasonable number for screen shake or maybe 32.

749
00:32:49,600 --> 00:32:50,900
I don't know how much we're basically saying.

750
00:32:51,900 --> 00:32:57,700
With our 60 for the actual number that this ends up being if I go

751
00:32:57,700 --> 00:32:59,800
ahead and do the quick Cal combat, right?

752
00:33:00,400 --> 00:33:04,000
If I do 1024 + 64, I'm only at 1088.

753
00:33:04,000 --> 00:33:06,800
Which means I only have four pixels on either side, which isn't very

754
00:33:06,800 --> 00:33:07,800
much for screen shake.

755
00:33:08,000 --> 00:33:11,600
So I probably want something that's going to be higher than that.

756
00:33:12,000 --> 00:33:14,900
And so basically, what I when I was kind of working this map out

757
00:33:14,900 --> 00:33:17,300
myself and trying to think about how I wanted the source art to be

758
00:33:17,300 --> 00:33:23,400
done for the The Source bitmaps I was saying well, okay, if I go with

759
00:33:23,400 --> 00:33:25,600
sort of so 576, right?

760
00:33:26,700 --> 00:33:30,800
If you go ahead and double 576 you will see that it ends up being

761
00:33:31,100 --> 00:33:31,800
11:52.

762
00:33:34,500 --> 00:33:36,000
Is that, is that correct?

763
00:33:36,000 --> 00:33:36,300
Yeah.

764
00:33:36,700 --> 00:33:40,200
So if I - 1024 from that list, I think this is correct.

765
00:33:40,300 --> 00:33:41,100
Maybe I made a mistake her.

766
00:33:41,100 --> 00:33:42,200
Yeah, it's 128.

767
00:33:42,600 --> 00:33:46,700
So basically what I was what I was basically saying was okay if we use

768
00:33:46,700 --> 00:33:49,800
a 128 texture instead of a 64 texture.

769
00:33:49,800 --> 00:33:53,000
So we store it into chunks of 2128 texture then we'd have

770
00:33:55,400 --> 00:34:02,100
Then we would have a number that was that was more closely able to

771
00:34:02,100 --> 00:34:05,000
more able to give us that apron at the top and the bottom is basically

772
00:34:05,000 --> 00:34:05,500
I'm saying.

773
00:34:05,600 --> 00:34:08,699
So if I subtract 80 from that I get 72, right?

774
00:34:08,699 --> 00:34:12,100
So if I divide that by 2, I get 36 pixels on either side.

775
00:34:12,199 --> 00:34:15,500
So now I have 36 pixels on on top and bottom for screen Shake.

776
00:34:15,500 --> 00:34:19,300
I have 64 on either end for screen shake and that seemed to me like a

777
00:34:19,300 --> 00:34:23,600
pretty reasonable sort of breakdown of screen geometry.

778
00:34:23,699 --> 00:34:24,699
Now, I

779
00:34:25,100 --> 00:34:27,500
It all sounds kind of crazy and it is a little bit crazy.

780
00:34:27,600 --> 00:34:29,199
But basically, I was just trying to figure out.

781
00:34:29,199 --> 00:34:32,600
I was like, I kind of want everything to sort of fit into power of two

782
00:34:32,600 --> 00:34:34,000
sizes as much as possible.

783
00:34:34,199 --> 00:34:37,699
What would be the most reasonable way to sort of do the source art?

784
00:34:37,699 --> 00:34:41,900
So that's going to be amenable to that kind of packing and that to me

785
00:34:41,900 --> 00:34:44,300
seemed like the most reasonable thing.

786
00:34:44,300 --> 00:34:45,900
Now that may not be the smartest.

787
00:34:45,900 --> 00:34:46,600
I don't know.

788
00:34:46,800 --> 00:34:48,199
But that was just my opinion.

789
00:34:48,500 --> 00:34:49,900
This sort of, this is the sort of thing.

790
00:34:49,900 --> 00:34:53,400
You don't deal with in 3D Graphics because 3D Graphics work in a very

791
00:34:53,400 --> 00:34:54,900
different way than this, because of the way.

792
00:34:55,000 --> 00:34:57,500
You do sort of wrapping of textures around models.

793
00:34:57,800 --> 00:34:59,800
And that's the way I'm usually used to thinking about things.

794
00:35:00,000 --> 00:35:01,400
So this may be a bad decision.

795
00:35:01,400 --> 00:35:05,500
We'll see, but it seems like a pretty harmless one because at the end

796
00:35:05,500 --> 00:35:09,100
of the day, all the sources are being drawn with an apron around it.

797
00:35:09,400 --> 00:35:11,900
We can always get rid of the apron if we don't want it.

798
00:35:11,900 --> 00:35:14,000
So if you don't want that extra room for screen shake or whatever, we

799
00:35:14,000 --> 00:35:16,300
can always get rid of it, but I figured having it drawn with the apron

800
00:35:16,300 --> 00:35:17,800
was actually probably a good idea.

801
00:35:18,500 --> 00:35:22,600
So long story short or tldr at this point.

802
00:35:22,600 --> 00:35:24,600
Basically, if you want to skip all that isolation,

803
00:35:25,100 --> 00:35:29,100
Reason that these are larger than the actual size that we're going to

804
00:35:29,100 --> 00:35:32,400
be just displaying in terms of one screens with is because of that

805
00:35:32,400 --> 00:35:33,300
apron, that's there.

806
00:35:33,400 --> 00:35:35,700
So they're all a little bit larger and they're designed to be a little

807
00:35:35,700 --> 00:35:37,900
bit larger for that reason.

808
00:35:38,200 --> 00:35:42,100
Okay, so given that fact.

809
00:35:42,100 --> 00:35:44,900
And now we kind of have this sort of I'm going to I'm going to leave

810
00:35:44,900 --> 00:35:47,000
this Ridiculousness in here for now.

811
00:35:48,800 --> 00:35:49,300
Right.

812
00:35:49,600 --> 00:35:50,200
There we go.

813
00:35:50,800 --> 00:35:54,000
So I basically said, 1024 plus 128.

814
00:35:54,700 --> 00:35:56,400
I need to find a key to quit calc.

815
00:35:56,400 --> 00:35:57,300
That's what I need to do.

816
00:35:57,300 --> 00:35:59,800
1024 plus 128 is a

817
00:36:00,000 --> 00:36:00,800
52.

818
00:36:01,600 --> 00:36:06,500
So basically, yeah, I should probably fill that in a little bit more.

819
00:36:06,900 --> 00:36:09,100
Densely it eventually but we'll just leave it like that for now.

820
00:36:09,800 --> 00:36:13,100
So basically what we want to do here is we want to load these images

821
00:36:13,100 --> 00:36:15,000
knowing they're a little bit big, but we're going to basically try to

822
00:36:15,000 --> 00:36:17,900
load them and get them up onto the screen just so we can kind of see

823
00:36:18,000 --> 00:36:19,100
that things are working properly.

824
00:36:19,100 --> 00:36:21,200
So basically we want this draw rectangle call.

825
00:36:21,200 --> 00:36:24,800
We want the equivalent of this draw rectangle call, right, but what we

826
00:36:24,800 --> 00:36:26,200
want to do with the draw a rectangle call is.

827
00:36:26,200 --> 00:36:29,200
We want to be able to instead of just passing a solid color.

828
00:36:29,200 --> 00:36:29,900
We want to instead.

829
00:36:30,000 --> 00:36:32,900
Of just just having one color that the rectangle fills in.

830
00:36:32,900 --> 00:36:33,500
On the screen.

831
00:36:33,500 --> 00:36:38,000
We want to be able to pass essentially, you know, a bitmaps worth of

832
00:36:38,000 --> 00:36:38,500
data here.

833
00:36:38,500 --> 00:36:43,000
So that the draw rectangle call can actually draw, you know, a real

834
00:36:43,000 --> 00:36:47,100
set, a real set of artwork to the screen inside that rectangle, right?

835
00:36:47,300 --> 00:36:50,800
And again, we're not going to focus too intently on this here because

836
00:36:51,100 --> 00:36:53,500
this is stuff that we'll be doing much more industrial strength and we

837
00:36:53,500 --> 00:36:55,800
start the renderer proper, but I just need to get something working

838
00:36:55,800 --> 00:36:56,000
here.

839
00:36:56,000 --> 00:36:59,800
So I'll explain it lightly and I won't belabor it too much, but

840
00:37:00,000 --> 00:37:03,400
You will sort of knowing that will sort of drill down a lot of this

841
00:37:03,400 --> 00:37:03,900
stuff later.

842
00:37:03,900 --> 00:37:06,500
So I'll try to give you enough context to understand what's going on.

843
00:37:07,000 --> 00:37:09,300
But at least for the rendering side of things, putting it up on the

844
00:37:09,300 --> 00:37:09,600
screen.

845
00:37:09,600 --> 00:37:10,800
I'm not going to kind of believe it.

846
00:37:10,800 --> 00:37:14,100
But so, anyway, right now, we basically just need to type in some code

847
00:37:14,100 --> 00:37:15,500
for load for loading a bitmap.

848
00:37:15,500 --> 00:37:16,000
Right?

849
00:37:16,000 --> 00:37:17,100
And I don't know what that's gonna look like.

850
00:37:17,100 --> 00:37:19,900
So I'm just going to go ahead and create a blank function here.

851
00:37:20,500 --> 00:37:25,200
I know that we have in our in our platform code, right?

852
00:37:25,400 --> 00:37:28,400
We have our handmade platform code, we set ourselves up for Success.

853
00:37:28,400 --> 00:37:29,800
Hopefully here.

854
00:37:29,900 --> 00:37:35,400
Because we have this this sort of debug file reading system, right?

855
00:37:35,600 --> 00:37:40,700
Where we can call anything that reads an entire file into memory.

856
00:37:41,100 --> 00:37:44,400
So what I want to do is make sure that this function takes that thing

857
00:37:44,600 --> 00:37:47,800
right, whatever that is and where do we actually put that?

858
00:37:47,800 --> 00:37:52,600
So that was debug platform.

859
00:37:53,200 --> 00:37:54,800
I don't even remember where we stuck it.

860
00:37:54,900 --> 00:37:57,000
So, inside, game memory, we've got these.

861
00:37:57,200 --> 00:37:58,200
When we pass the game memory.

862
00:37:58,200 --> 00:37:59,800
It's got these in it, so

863
00:38:00,000 --> 00:38:03,000
What's going to happen here is this guy is going to need this

864
00:38:03,000 --> 00:38:05,000
function, this read entire file.

865
00:38:05,900 --> 00:38:07,600
So basically, I'm just gonna go ahead and pass that.

866
00:38:08,000 --> 00:38:09,300
This is the function that he's going to need.

867
00:38:09,300 --> 00:38:11,100
This is obviously a debug function as well.

868
00:38:11,100 --> 00:38:12,900
I guess now, I think about it because we're not going to be probably

869
00:38:12,900 --> 00:38:16,500
loading bitmaps for the final shipping version will probably want to

870
00:38:16,500 --> 00:38:17,500
load something that's compressed.

871
00:38:17,500 --> 00:38:20,800
At least bitmaps are really compressed air if they are compressed and

872
00:38:20,800 --> 00:38:21,500
uncompressed very well.

873
00:38:22,200 --> 00:38:24,300
So what we're going to do here is we're going to have this read and

874
00:38:24,300 --> 00:38:25,100
tar file.

875
00:38:25,200 --> 00:38:27,900
We're going to call it and presumably we're going to need a file name,

876
00:38:27,900 --> 00:38:29,800
I guess as well that we're going to have to call.

877
00:38:29,900 --> 00:38:31,700
All that we're gonna have to pass Orient, our file.

878
00:38:31,700 --> 00:38:33,000
So we know which file to read.

879
00:38:33,200 --> 00:38:36,600
So basically we are going to do at least that much to read this file.

880
00:38:36,600 --> 00:38:41,700
So what we need to do there is when we go ahead and read the file into

881
00:38:41,700 --> 00:38:42,400
memory.

882
00:38:42,600 --> 00:38:47,000
Let's see what the debug platform read entire file thing, takes.

883
00:38:47,200 --> 00:38:50,000
I don't actually know it takes a thread context.

884
00:38:50,000 --> 00:38:54,500
So it's going to need that as well and it takes the file name.

885
00:38:54,500 --> 00:38:55,600
So basically that's it.

886
00:38:55,600 --> 00:38:55,800
Really.

887
00:38:55,800 --> 00:38:56,900
That's all there is to it.

888
00:38:56,900 --> 00:38:58,200
Not not particularly interesting.

889
00:38:58,600 --> 00:38:59,800
So basically it just needs to do

890
00:39:00,400 --> 00:39:03,100
So when we read this entire file into memory, we're basically going to

891
00:39:03,100 --> 00:39:04,100
get a buffer, right?

892
00:39:04,100 --> 00:39:06,600
We're going to get the file contents.

893
00:39:07,900 --> 00:39:11,400
So that's going to literally move all of the bits there in this file

894
00:39:11,500 --> 00:39:13,600
into a memory buffer for us to look at.

895
00:39:13,600 --> 00:39:16,400
So then the question is, what do those bits actually mean?

896
00:39:16,700 --> 00:39:19,800
Well, this is basically if for those of you haven't done it before,

897
00:39:19,900 --> 00:39:23,000
here is your crash course in how to read file formats.

898
00:39:23,800 --> 00:39:25,600
Assuming that you don't know what the file format is.

899
00:39:25,600 --> 00:39:27,600
You first have to look it up on the web.

900
00:39:27,600 --> 00:39:30,700
And typically I do this literally by typing in something that looks

901
00:39:30,700 --> 00:39:31,200
like that.

902
00:39:31,300 --> 00:39:34,600
I type in the name of the file that I the like extension that I want

903
00:39:34,600 --> 00:39:35,300
to know about.

904
00:39:35,300 --> 00:39:37,700
I type in file format and I hope that's

905
00:39:37,800 --> 00:39:40,400
Somebody has actually documented what it is.

906
00:39:40,400 --> 00:39:43,300
I then try to look at these links to see if any of them look even

907
00:39:43,300 --> 00:39:44,300
remotely plausible.

908
00:39:44,800 --> 00:39:46,800
And I don't know if any of these do.

909
00:39:46,900 --> 00:39:48,000
Let's take a look here.

910
00:39:48,900 --> 00:39:50,200
Let's see.

911
00:39:50,200 --> 00:39:50,900
Let's see.

912
00:39:50,900 --> 00:39:52,200
This looks pretty plausible.

913
00:39:52,200 --> 00:39:55,800
It looks like it's actually got sort of the stuff that we actually

914
00:39:55,800 --> 00:39:57,400
need to know here.

915
00:39:58,200 --> 00:39:59,400
Let's see.

916
00:39:59,900 --> 00:40:02,100
It's running file, type file size.

917
00:40:03,000 --> 00:40:04,300
These have BM in front of them.

918
00:40:04,300 --> 00:40:06,500
These don't ddb only file, header.

919
00:40:07,400 --> 00:40:07,600
Yes.

920
00:40:07,700 --> 00:40:10,100
So this looks this looks relatively.

921
00:40:10,300 --> 00:40:12,700
This looks relatively straightforward for us.

922
00:40:12,700 --> 00:40:14,700
I think I'll see anything wrong reason.

923
00:40:14,700 --> 00:40:15,500
We can't use this.

924
00:40:15,900 --> 00:40:18,300
So if we look at the file organization here, basically what it shows

925
00:40:18,300 --> 00:40:20,200
us is, it shows us the layer.

926
00:40:20,400 --> 00:40:24,400
The layout of these things right here, since Windows one point, x is

927
00:40:24,400 --> 00:40:27,100
probably not something that that anyone is using these days.

928
00:40:27,100 --> 00:40:29,800
I'm going to assume that the bitmap data here is in the file format

929
00:40:29,800 --> 00:40:33,000
that they're talking about for two, three and four, right?

930
00:40:33,100 --> 00:40:35,000
And so basically what they're showing me here is they're just showing

931
00:40:35,000 --> 00:40:36,400
me what they think is in the file.

932
00:40:36,400 --> 00:40:37,600
They're saying there's a file header a bit.

933
00:40:37,800 --> 00:40:40,700
I've had her a color palette and bitmap data right now.

934
00:40:40,700 --> 00:40:44,900
I know that I saved these files as rgba data basically, so I know that

935
00:40:44,900 --> 00:40:46,300
there isn't going to be a color palette.

936
00:40:46,300 --> 00:40:48,500
I know, you know, I know that I don't have to worry about palletized

937
00:40:48,500 --> 00:40:48,900
colors.

938
00:40:48,900 --> 00:40:52,000
Like palletize, colors are basic things where we store indexes into a

939
00:40:52,000 --> 00:40:54,000
palette instead of the actual colors, but I know we're actually

940
00:40:54,000 --> 00:40:54,700
storing colors.

941
00:40:54,800 --> 00:40:59,800
And in fact, I when I, when I was exporting it through gimp, I

942
00:40:59,800 --> 00:41:01,600
actually selected like that.

943
00:41:01,600 --> 00:41:04,600
I want it to be a RGB like 88 or whatever.

944
00:41:04,600 --> 00:41:07,300
Like basically the same format, a roughly, the same format as we were

945
00:41:07,300 --> 00:41:07,600
using

946
00:41:07,700 --> 00:41:10,200
And for all of our rendering, so I'm assuming that should be pretty

947
00:41:10,200 --> 00:41:11,700
easy to get it out of the file.

948
00:41:11,800 --> 00:41:16,000
Alright, so basically what it says here, for that version 2, which is

949
00:41:16,000 --> 00:41:18,300
I'm assuming, what our, what our version is like, or though.

950
00:41:18,300 --> 00:41:20,700
Maybe I guess version 3 is probably more.

951
00:41:20,700 --> 00:41:22,500
We're like, I don't know, Windows NT.

952
00:41:22,500 --> 00:41:24,400
I mean, these are going back real far.

953
00:41:24,600 --> 00:41:26,700
So I'm guessing that we're probably.

954
00:41:27,500 --> 00:41:28,100
Let's see.

955
00:41:28,500 --> 00:41:29,000
Let's see here.

956
00:41:29,000 --> 00:41:30,500
This version has three additional Fields.

957
00:41:30,500 --> 00:41:33,500
The bitmap header is 40, bytes in length and has the following format.

958
00:41:33,900 --> 00:41:34,600
There it goes.

959
00:41:34,800 --> 00:41:37,600
So yeah, I guess I don't know if this is the best resource for this.

960
00:41:37,800 --> 00:41:40,900
They're not really this map for.

961
00:41:41,700 --> 00:41:46,100
They're not really saying much which one I'm kind of going to which

962
00:41:46,100 --> 00:41:47,800
one I'm likely to encounter here.

963
00:41:48,000 --> 00:41:51,300
And yeah and which one?

964
00:41:51,900 --> 00:41:53,100
Well, so let's just take a look.

965
00:41:53,200 --> 00:41:54,700
So rather than find another resource.

966
00:41:54,700 --> 00:41:56,800
I think I'm actually going to kind of go with this one just so I can

967
00:41:56,800 --> 00:41:57,600
show you some things.

968
00:41:58,100 --> 00:41:59,800
So we're going to load in the contents here, right?

969
00:42:00,500 --> 00:42:04,500
And then what I'm going to do is I'm just going to go ahead and well,

970
00:42:04,500 --> 00:42:04,800
you know what?

971
00:42:04,800 --> 00:42:08,100
I'm just going to go ahead and and have that sort of end here.

972
00:42:08,100 --> 00:42:09,600
I'm just going to do some Dummy Line of code.

973
00:42:09,600 --> 00:42:12,200
I can stop on and then I will.

974
00:42:12,300 --> 00:42:12,900
What is this saying?

975
00:42:12,900 --> 00:42:16,100
Cannot convert from debug read file to void star?

976
00:42:16,400 --> 00:42:18,000
What are you trying to convert to void star?

977
00:42:21,000 --> 00:42:21,500
Oh, right.

978
00:42:21,500 --> 00:42:23,300
We have a debug file read.

979
00:42:23,300 --> 00:42:27,200
Result is what we have platforming file read results.

980
00:42:27,800 --> 00:42:29,300
Where did my platform?

981
00:42:29,300 --> 00:42:31,700
It's debug read files out.

982
00:42:31,700 --> 00:42:32,100
There we go.

983
00:42:33,500 --> 00:42:39,300
So, basically, this is going to be our Central, ER, result.

984
00:42:39,300 --> 00:42:41,100
It's the, the read result.

985
00:42:41,600 --> 00:42:44,000
So I'm going to go ahead and do that.

986
00:42:44,000 --> 00:42:47,700
And then we have our read result has the contents in it and how big it

987
00:42:47,700 --> 00:42:48,000
was.

988
00:42:48,000 --> 00:42:49,000
So that's totally fine.

989
00:42:49,400 --> 00:42:50,400
So now all I'm going to do is

990
00:42:50,600 --> 00:42:53,400
To go ahead and call this basically, in game update and render, I

991
00:42:53,400 --> 00:42:54,500
guess when we initialize.

992
00:42:54,500 --> 00:42:58,400
So when we initialize I'm just going to call the loading function and

993
00:42:58,400 --> 00:43:01,000
I know that we always run in our data directory or that's where we're

994
00:43:01,000 --> 00:43:01,800
always supposed to be running.

995
00:43:01,800 --> 00:43:05,500
Anyway, so I'm just going to ask it to load load this test background

996
00:43:05,500 --> 00:43:08,700
up, BMP background that the MP and I'm just going to look at what the

997
00:43:08,700 --> 00:43:09,400
data looks like.

998
00:43:09,400 --> 00:43:11,900
I'm just going to look at it because I should be able to figure out

999
00:43:11,900 --> 00:43:13,700
pretty quickly, which one of those things.

1000
00:43:13,900 --> 00:43:15,400
These are by just looking at it.

1001
00:43:15,700 --> 00:43:18,700
So I'm going to go ahead and and compile it.

1002
00:43:19,300 --> 00:43:20,200
I need to pass that Fred.

1003
00:43:20,500 --> 00:43:22,700
Context, let's see here.

1004
00:43:22,700 --> 00:43:25,300
And I also need to pass the file function.

1005
00:43:25,700 --> 00:43:30,300
So I need to pass the memory, debug read entire file, right?

1006
00:43:30,300 --> 00:43:32,700
I don't remember what exactly that was called.

1007
00:43:33,100 --> 00:43:33,900
Let's see here.

1008
00:43:35,100 --> 00:43:37,000
Debug platform read entire file.

1009
00:43:37,000 --> 00:43:38,400
So I'm just going to call that.

1010
00:43:38,700 --> 00:43:39,200
There we go.

1011
00:43:39,800 --> 00:43:44,500
So, when I come in here now, where is my debugger?

1012
00:43:44,900 --> 00:43:46,400
Where is my debugger people?

1013
00:43:46,400 --> 00:43:47,300
There's my debugger.

1014
00:43:48,300 --> 00:43:49,800
Okay, is this guy still on?

1015
00:43:49,800 --> 00:43:50,400
Oh, he's still on.

1016
00:43:50,500 --> 00:43:52,300
Thing I used to download its get rid of that.

1017
00:43:52,900 --> 00:43:53,400
Okay.

1018
00:43:53,700 --> 00:43:58,600
So basically now that I've now that I have cleaned up my screen a

1019
00:43:58,600 --> 00:43:59,100
little bit here.

1020
00:43:59,300 --> 00:44:02,800
When we come into the game update and render, right?

1021
00:44:02,900 --> 00:44:07,200
I'm going to go ahead and I'm going to run through here and I'm going

1022
00:44:07,200 --> 00:44:11,900
to step into this function and take a look at what it returns for me

1023
00:44:11,900 --> 00:44:13,100
when I come back through here.

1024
00:44:13,500 --> 00:44:16,200
So, basically, when I come in here and I asked it to read the entire

1025
00:44:16,200 --> 00:44:18,800
file, first of all, verify that it actually did read the entire file.

1026
00:44:18,800 --> 00:44:20,300
Because, you know, I don't know.

1027
00:44:20,400 --> 00:44:22,200
You know, if it did, it looks like it did.

1028
00:44:22,200 --> 00:44:24,600
There's the, the size of the file and then I have the content.

1029
00:44:24,600 --> 00:44:25,800
So I'm just going to go ahead.

1030
00:44:25,900 --> 00:44:30,400
I'm just going to look at the contents basically, as, as just a series

1031
00:44:30,400 --> 00:44:31,000
of bytes.

1032
00:44:31,200 --> 00:44:33,500
I'm just going to take a look at what it looks like.

1033
00:44:33,600 --> 00:44:36,400
I'm going to put a comma 64 after the end of it, so I can see a bunch

1034
00:44:36,400 --> 00:44:37,100
of the bytes.

1035
00:44:38,000 --> 00:44:41,500
And so, I can see here that it starts with a beat, the BM syntax,

1036
00:44:41,800 --> 00:44:45,000
which I believe I saw them document in here.

1037
00:44:45,400 --> 00:44:49,000
So, they were saying that it starts with a header.

1038
00:44:49,000 --> 00:44:50,300
That is, that is BM.

1039
00:44:50,500 --> 00:44:51,100
So, here you go.

1040
00:44:51,200 --> 00:44:52,100
So file type.

1041
00:44:52,100 --> 00:44:56,100
Always 44d 42 H.

1042
00:44:56,100 --> 00:44:58,100
And it says, all versus Beauty profiles, begin with the following

1043
00:44:58,100 --> 00:44:58,700
Fortune by headers.

1044
00:44:58,700 --> 00:44:59,800
Okay, so that's a guess, what we were.

1045
00:45:00,400 --> 00:45:04,600
The file type, there's a file size, two zeros, and then an offset of

1046
00:45:04,600 --> 00:45:07,800
where the image is right in the file.

1047
00:45:08,000 --> 00:45:10,500
So, let's see if that looks like it looks like what we think.

1048
00:45:10,700 --> 00:45:15,400
So there is the be in the m and then there's the size of the file in

1049
00:45:15,400 --> 00:45:16,700
bytes as a dword.

1050
00:45:16,700 --> 00:45:18,500
So that's basically this right here.

1051
00:45:19,200 --> 00:45:23,900
So is that actually accurate would be, I guess, be my next question.

1052
00:45:24,300 --> 00:45:29,900
So let's say that we have something like

1053
00:45:30,000 --> 00:45:30,500
Like this.

1054
00:45:30,500 --> 00:45:32,100
So we have the contents.

1055
00:45:32,700 --> 00:45:34,600
I'm going to add 2 to it, there.

1056
00:45:34,600 --> 00:45:37,400
To get us to where we said we were yet.

1057
00:45:37,400 --> 00:45:38,000
There we go.

1058
00:45:39,700 --> 00:45:45,200
And then I'm going to go ahead and look at that as a unit 32, right?

1059
00:45:45,800 --> 00:45:47,300
As the UN 32 pointer.

1060
00:45:47,700 --> 00:45:48,200
There we go.

1061
00:45:49,500 --> 00:45:51,100
So it is that actually reasonable.

1062
00:45:51,100 --> 00:45:52,800
That doesn't actually oops.

1063
00:45:52,800 --> 00:45:53,400
Am I doing that?

1064
00:45:53,400 --> 00:45:53,900
Right?

1065
00:45:54,100 --> 00:45:54,900
No, I'm not.

1066
00:45:55,100 --> 00:45:56,300
Let's try that again.

1067
00:45:56,400 --> 00:45:57,400
Let's try that again.

1068
00:45:57,400 --> 00:45:57,900
People.

1069
00:45:58,200 --> 00:45:59,700
It's so hard to edit things in this.

1070
00:46:00,100 --> 00:46:00,500
Nothing.

1071
00:46:00,700 --> 00:46:05,100
Basically, what I want you to do is I want you to make read result be

1072
00:46:05,100 --> 00:46:06,300
a un Tate star.

1073
00:46:06,400 --> 00:46:07,700
Okay, there you did that.

1074
00:46:08,200 --> 00:46:08,400
Oops.

1075
00:46:08,400 --> 00:46:12,400
Sorry result, contents, be un8 star, which you did then.

1076
00:46:12,400 --> 00:46:15,900
I want you to add 2 to it, which I hope that you did, right.

1077
00:46:15,900 --> 00:46:18,000
And then I want you to treat that as a you went.

1078
00:46:18,900 --> 00:46:21,700
You went 32, I guess maybe it doesn't actually know what those are

1079
00:46:21,700 --> 00:46:22,000
those.

1080
00:46:22,000 --> 00:46:26,000
So maybe I have to do in done signed and Care star.

1081
00:46:27,000 --> 00:46:28,100
Unrecognized token.

1082
00:46:28,500 --> 00:46:29,800
What is the unrecognized token?

1083
00:46:31,300 --> 00:46:32,500
What are you complaining about?

1084
00:46:33,000 --> 00:46:35,300
I do not actually know that.

1085
00:46:35,300 --> 00:46:36,500
I've got one too many parentheses.

1086
00:46:36,500 --> 00:46:37,800
Is that what you're complaining about?

1087
00:46:38,300 --> 00:46:39,800
That is probably what you're complaining about.

1088
00:46:39,800 --> 00:46:40,300
There we go.

1089
00:46:41,500 --> 00:46:42,000
All right.

1090
00:46:43,100 --> 00:46:47,100
Okay, so there I'm just telling it to look at the second thing as a

1091
00:46:47,100 --> 00:46:49,400
unit 32, and it looks like.

1092
00:46:49,400 --> 00:46:51,400
And so, by the way, just for my own sanity.

1093
00:46:51,400 --> 00:46:53,500
I just want to make sure that it was okay for me to do this.

1094
00:46:53,500 --> 00:46:56,000
Because I'm assuming that it knows my types inside the debugger

1095
00:46:56,600 --> 00:46:59,200
because it should, I'm going to guess it doesn't have to but should

1096
00:46:59,300 --> 00:46:59,800
yeah, there we go.

1097
00:47:00,500 --> 00:47:02,900
So basically I'm just going to look at that as a un 32 which is a d

1098
00:47:02,900 --> 00:47:04,500
word and there it is.

1099
00:47:04,500 --> 00:47:06,000
That does look like the file size.

1100
00:47:06,000 --> 00:47:07,200
So that's all good.

1101
00:47:07,600 --> 00:47:09,900
Then we're supposed to have two zeros after that.

1102
00:47:10,200 --> 00:47:11,100
So we've got 0

1103
00:47:12,400 --> 00:47:12,700
Let's see.

1104
00:47:12,700 --> 00:47:14,400
These are the that was the d word.

1105
00:47:14,400 --> 00:47:17,200
So they've got two zeros, which it does look like they are because

1106
00:47:17,200 --> 00:47:19,300
those are both 16 16 B 0.

1107
00:47:19,300 --> 00:47:21,200
So there's the 16-bit zeros right there.

1108
00:47:21,800 --> 00:47:24,600
And then we've got the bitmap offset, which is where in the file, it

1109
00:47:24,600 --> 00:47:25,100
actually is.

1110
00:47:25,100 --> 00:47:25,900
So there it is.

1111
00:47:26,300 --> 00:47:27,200
And that looks reasonable.

1112
00:47:27,200 --> 00:47:29,100
That just be a deer that be 138.

1113
00:47:29,900 --> 00:47:32,600
So I think that we are basically looking at exactly this.

1114
00:47:32,700 --> 00:47:33,000
Right.

1115
00:47:33,000 --> 00:47:35,700
This is exactly what we are looking at.

1116
00:47:36,200 --> 00:47:40,600
And so we could just go ahead and and assumed that, that was all true.

1117
00:47:41,200 --> 00:47:44,900
Right, so, I'm just going to go ahead and I'm going to copy this into

1118
00:47:45,200 --> 00:47:46,600
see if I can get back to my editor there.

1119
00:47:47,000 --> 00:47:50,100
I'm going to say that that is basically what we are looking at at the

1120
00:47:50,100 --> 00:47:53,200
outset, we're looking at this and so, that's good.

1121
00:47:53,500 --> 00:47:55,900
And so, then the question only is what happens after that.

1122
00:47:56,200 --> 00:47:59,800
The question now is like, basically, what you know, what did the

1123
00:48:00,000 --> 00:48:04,800
Of the things look like finding the file header in V, 2.0, ours to

1124
00:48:04,800 --> 00:48:05,000
point.

1125
00:48:05,000 --> 00:48:06,800
X bitmaps is going to be this stuff.

1126
00:48:06,800 --> 00:48:08,500
What is it in other ones?

1127
00:48:09,800 --> 00:48:12,800
So it looks like the stuff that we actually care about, though.

1128
00:48:14,100 --> 00:48:19,800
So as a bitmap to do pal and element, size, hores resolution, color is

1129
00:48:19,800 --> 00:48:20,200
used.

1130
00:48:20,200 --> 00:48:23,000
So basically these things, these things are the same.

1131
00:48:23,000 --> 00:48:24,500
It looks like, right.

1132
00:48:25,600 --> 00:48:29,100
It looks like we always do that, but we once we get to compression

1133
00:48:29,600 --> 00:48:33,300
they may or not, they may or may not be there basically, right?

1134
00:48:33,400 --> 00:48:34,400
They may or may not.

1135
00:48:34,400 --> 00:48:39,300
Actually, it may or may not have compression or size of bitmap or the

1136
00:48:39,300 --> 00:48:41,900
resolution or colors use color important that sort of stuff.

1137
00:48:42,300 --> 00:48:43,800
But that's really the only difference.

1138
00:48:44,000 --> 00:48:47,300
So if we assume temporarily that were only going to be reading

1139
00:48:47,300 --> 00:48:50,700
uncompressed, we could just look at these fields and assume that we

1140
00:48:50,700 --> 00:48:54,600
always have them and that there and just and just read them in, right?

1141
00:48:54,600 --> 00:48:56,400
So we can just, again, this is just debug code.

1142
00:48:56,400 --> 00:48:58,100
We're not trying to read a file processing Library.

1143
00:48:58,200 --> 00:49:01,400
We're only ever using assets that we ourselves load.

1144
00:49:02,700 --> 00:49:05,600
So, basically, you know, this is, this is pretty good.

1145
00:49:06,000 --> 00:49:10,000
In terms of what we're actually looking at, you know, in the file.

1146
00:49:11,000 --> 00:49:15,900
So, what we could do here is we could just look at it this way, we

1147
00:49:15,900 --> 00:49:19,200
could just say, okay here is a struct, right?

1148
00:49:20,300 --> 00:49:23,700
This is the bitmap header or something like that.

1149
00:49:23,700 --> 00:49:24,000
Right?

1150
00:49:24,000 --> 00:49:28,100
We could say that this is the bitmap header and you know, I don't

1151
00:49:28,100 --> 00:49:32,900
know, just, here's the actual sizes of each of these things.

1152
00:49:33,100 --> 00:49:37,500
This is a in 1616, right?

1153
00:49:37,700 --> 00:49:40,600
You went 32 Unit 32.

1154
00:49:41,400 --> 00:49:46,600
In 32 and 32 un 16 un 16, right?

1155
00:49:47,800 --> 00:49:49,600
And we could basically just say, all right.

1156
00:49:49,600 --> 00:49:53,100
This is the, the layout that we are expecting to look at.

1157
00:49:53,200 --> 00:49:55,400
And we can say, all right, this bitmap header.

1158
00:49:56,200 --> 00:50:01,800
I am going to go ahead and take a look at that read result contents.

1159
00:50:02,500 --> 00:50:03,700
So contents.

1160
00:50:04,500 --> 00:50:07,600
I'm going to take a look at that as the bitmap header, right?

1161
00:50:08,600 --> 00:50:09,200
I'm just going to look.

1162
00:50:09,200 --> 00:50:10,500
I'm just going to cold-cast it.

1163
00:50:10,500 --> 00:50:14,600
So assuming that read result sighs.

1164
00:50:14,800 --> 00:50:19,100
Right is not equal to 0 assuming that we were able to read it.

1165
00:50:19,500 --> 00:50:20,800
Then I'm going to take a look at the header.

1166
00:50:21,600 --> 00:50:21,800
Now.

1167
00:50:21,800 --> 00:50:23,600
We've got a problem here, right?

1168
00:50:24,300 --> 00:50:28,500
And I guess I can, I can probably demonstrate it as well, so that you

1169
00:50:28,500 --> 00:50:29,200
can see it.

1170
00:50:29,700 --> 00:50:30,700
What did I call that?

1171
00:50:30,700 --> 00:50:31,000
Again?

1172
00:50:31,000 --> 00:50:32,600
Where is what is the results?

1173
00:50:32,800 --> 00:50:35,600
Whereas my read results content size?

1174
00:50:36,900 --> 00:50:37,800
Content size.

1175
00:50:38,700 --> 00:50:43,600
So if I go ahead and I actually run this, we have a problem and I've

1176
00:50:43,600 --> 00:50:46,600
talked about it on the stream many times before, but just to solidify

1177
00:50:46,600 --> 00:50:49,600
it for people who again, might not be familiar with this sort of

1178
00:50:49,600 --> 00:50:50,000
thing.

1179
00:50:50,800 --> 00:50:54,800
If you notice, when we actually do what, I just said, we'll have a

1180
00:50:54,800 --> 00:50:55,300
problem.

1181
00:50:55,900 --> 00:50:58,800
And so when we, when we open this up and we look at things, you'll

1182
00:50:58,800 --> 00:50:59,800
notice that it doesn't

1183
00:51:00,000 --> 00:51:01,900
Like what we had hoped, right?

1184
00:51:02,800 --> 00:51:05,300
We looked we expected it and we were expecting the file size.

1185
00:51:05,300 --> 00:51:06,300
We looked at the files and socially.

1186
00:51:06,300 --> 00:51:07,900
Correct, like what's going on here, right?

1187
00:51:07,900 --> 00:51:08,900
Why do these look wrong?

1188
00:51:09,800 --> 00:51:13,000
Well, the answer of course is because like I said on the stream before

1189
00:51:13,000 --> 00:51:18,100
when we lay out a structure, basically, C++ is under no obligation to

1190
00:51:18,100 --> 00:51:20,100
actually pack that structure tightly.

1191
00:51:20,500 --> 00:51:24,600
So we, when we say that there's a un 16 and then there's a Unit 32.

1192
00:51:25,000 --> 00:51:27,300
It doesn't have to put those adjacent to each other and in fact, it

1193
00:51:27,300 --> 00:51:28,100
won't what it does.

1194
00:51:28,100 --> 00:51:29,800
Is it aligns things?

1195
00:51:30,000 --> 00:51:33,600
Things to a boundary that is the same as whatever their size is.

1196
00:51:33,600 --> 00:51:36,700
So if this, this is 4, bytes, this is only to B.

1197
00:51:36,700 --> 00:51:40,200
It will skip to B to put this on a 4, byte boundary basically because

1198
00:51:40,200 --> 00:51:41,100
it is 4 bytes.

1199
00:51:41,500 --> 00:51:45,700
So basically, if we want to read the memory in a nice layout here, we

1200
00:51:45,700 --> 00:51:49,100
have to tell see 2Pac that structure tightly.

1201
00:51:49,900 --> 00:51:54,000
And so what we have is kind of this really janky system.

1202
00:51:54,200 --> 00:51:55,900
I think there is in certain compilers.

1203
00:51:55,900 --> 00:51:58,400
There's better ways of doing this, where you can just label the struct

1204
00:51:58,400 --> 00:51:59,500
as tightly packed.

1205
00:52:00,000 --> 00:52:02,400
But that is a new relatively new thing.

1206
00:52:03,500 --> 00:52:08,300
Basically, there's this thing, Padma, pragma pack, push and pop.

1207
00:52:08,400 --> 00:52:12,100
It's kind of ridiculous, but I'll basically show you what it looks

1208
00:52:12,100 --> 00:52:12,500
like.

1209
00:52:12,700 --> 00:52:18,300
Essentially what you do, if you can, if you can take a look here, you

1210
00:52:18,300 --> 00:52:21,600
can basically do this thing where you do pragma pack, and then you can

1211
00:52:21,600 --> 00:52:23,500
say what the packing level is, right?

1212
00:52:23,500 --> 00:52:26,100
So you can kind of do something where you do something like this,

1213
00:52:26,100 --> 00:52:29,800
pragma Pack 1 and then it will pack everything.

1214
00:52:29,900 --> 00:52:34,600
To be one, you know, one bite, aligned, even if it would have packed

1215
00:52:34,600 --> 00:52:36,100
it, otherwise, which is what we want to do.

1216
00:52:36,100 --> 00:52:37,200
Now.

1217
00:52:37,200 --> 00:52:40,700
Unfortunately, at the end of this, we'd like to set it back to

1218
00:52:40,700 --> 00:52:42,600
whatever it was, but we don't know what it was.

1219
00:52:42,600 --> 00:52:44,700
We don't know what the default packing was going to be.

1220
00:52:44,700 --> 00:52:47,700
Right, and we don't know it, whether we might be inside, someone

1221
00:52:47,700 --> 00:52:48,600
else's packed block.

1222
00:52:48,600 --> 00:52:54,100
So basically what they do in a lot of in a lot of cases just to make

1223
00:52:54,100 --> 00:52:54,500
things easy.

1224
00:52:54,500 --> 00:52:58,700
Is they do a pragma pack push, which basically is a thing that says

1225
00:52:58,700 --> 00:52:59,700
push a

1226
00:53:00,100 --> 00:53:03,500
On the stack, which is basically going to be a know if you can see it

1227
00:53:03,500 --> 00:53:03,800
here.

1228
00:53:03,900 --> 00:53:04,400
Here's okay.

1229
00:53:04,400 --> 00:53:05,700
Here's a good example, right?

1230
00:53:06,100 --> 00:53:09,800
Basically, what you can do is you can use this push pop thing to

1231
00:53:09,800 --> 00:53:12,800
basically tell it to just, okay, for the region that I'm in.

1232
00:53:14,300 --> 00:53:14,800
Start.

1233
00:53:14,800 --> 00:53:18,400
It's like a stack push this new value for packing on the stack.

1234
00:53:18,400 --> 00:53:21,100
But then when you're done pop it off and go back to the previous value

1235
00:53:21,100 --> 00:53:21,600
that you're at.

1236
00:53:21,600 --> 00:53:22,200
Right?

1237
00:53:22,700 --> 00:53:27,000
So if you do this pragmatic pack, push one and then pragma pack, pop

1238
00:53:27,300 --> 00:53:28,500
in theory, you get a thing.

1239
00:53:28,500 --> 00:53:31,700
We're just in between those your tightly packed but everywhere else,

1240
00:53:31,700 --> 00:53:33,600
your regular packing, right?

1241
00:53:33,800 --> 00:53:36,400
So now when we come in here and we look at the header, you can see

1242
00:53:36,400 --> 00:53:38,000
that everything actually looks right now.

1243
00:53:38,000 --> 00:53:39,900
Look, here's the actual size, right?

1244
00:53:39,900 --> 00:53:41,200
Here's the width and height of the bitmap.

1245
00:53:41,200 --> 00:53:43,900
And there, the there, what we expect, here's the bit for Pixel which

1246
00:53:44,000 --> 00:53:45,900
Is what we expect 32 and so on.

1247
00:53:46,400 --> 00:53:49,400
And so really all we need to do is jump to this bitmap offset and load

1248
00:53:49,400 --> 00:53:50,000
the bitmap.

1249
00:53:50,000 --> 00:53:50,600
That's about all.

1250
00:53:50,600 --> 00:53:52,000
We actually need to do.

1251
00:53:52,600 --> 00:53:56,100
And so there's one other surprise waiting for us with bitmaps that

1252
00:53:56,100 --> 00:53:56,600
will see.

1253
00:53:56,800 --> 00:53:58,800
I don't know if we'll have a time to blip this today.

1254
00:53:58,800 --> 00:53:59,400
Probably not.

1255
00:53:59,400 --> 00:53:59,800
If it's the

1256
00:54:00,000 --> 00:54:00,600
That wording.

1257
00:54:01,200 --> 00:54:03,000
But basically, we now know what the header is.

1258
00:54:03,000 --> 00:54:06,400
So we know what the width and height are and we now know exactly where

1259
00:54:06,400 --> 00:54:07,200
the data is.

1260
00:54:07,200 --> 00:54:13,200
So we also know that basically our pixels right are going to be read

1261
00:54:13,200 --> 00:54:14,300
result, contents.

1262
00:54:14,900 --> 00:54:20,600
We know that they are going to be wherever the contents are plus the

1263
00:54:20,600 --> 00:54:22,800
bitmap offset that we got in the header.

1264
00:54:23,200 --> 00:54:26,400
But of course, we don't know what that bitmap offset is relative to is

1265
00:54:26,400 --> 00:54:28,500
it relative to the start of the file or what?

1266
00:54:28,700 --> 00:54:29,900
So I'm going to go take a look at the

1267
00:54:30,000 --> 00:54:34,200
That spec again and just see if it's a little, if it's specific at all

1268
00:54:34,300 --> 00:54:36,600
about what that bitmap offset actually means.

1269
00:54:37,200 --> 00:54:39,300
So starting position of the image in B.

1270
00:54:39,900 --> 00:54:43,100
I don't know if they are any more specific here, bitmap us the

1271
00:54:43,100 --> 00:54:45,400
strength of the bitmap from the beginning of the file.

1272
00:54:45,600 --> 00:54:49,000
So basically we did the right math here, that's going to be the start

1273
00:54:49,000 --> 00:54:49,700
of our pixels.

1274
00:54:49,900 --> 00:54:54,000
And then we're expecting to have basically width times height pixels

1275
00:54:54,100 --> 00:54:56,900
worth of data, I believe because it's 32 bits per pixel.

1276
00:54:56,900 --> 00:54:58,000
Should be well aligned.

1277
00:54:58,000 --> 00:54:59,100
I think, I don't know.

1278
00:54:59,100 --> 00:54:59,900
Basically, if

1279
00:55:00,100 --> 00:55:03,800
I don't know if they talk in here at all about that image data

1280
00:55:03,900 --> 00:55:04,800
uncompressed data.

1281
00:55:04,800 --> 00:55:06,300
Series of values represent the color.

1282
00:55:06,400 --> 00:55:08,600
Each scanline must end on a 4 byte boundary.

1283
00:55:08,800 --> 00:55:11,700
So, one, two or three bites of padding, they follow each scan line.

1284
00:55:12,100 --> 00:55:14,900
So the only other thing we have to worry about is basically our pixels

1285
00:55:14,900 --> 00:55:17,400
are going to be four by the line.

1286
00:55:17,500 --> 00:55:20,800
Since they are already four bytes that should never actually be a

1287
00:55:20,800 --> 00:55:21,400
problem for us.

1288
00:55:21,400 --> 00:55:24,300
But if we were going to load a 24-bit one here for some reason, later,

1289
00:55:24,600 --> 00:55:25,700
then we would actually care.

1290
00:55:25,900 --> 00:55:27,100
But that is our pixel pointer.

1291
00:55:27,100 --> 00:55:29,800
And that is basically all we actually needed to

1292
00:55:29,900 --> 00:55:30,200
Uno.

1293
00:55:30,200 --> 00:55:34,300
Now, if we want to, we could probably do something cheesy here to test

1294
00:55:34,300 --> 00:55:38,100
this just real quickly in the three minutes that I have remaining.

1295
00:55:39,200 --> 00:55:41,100
So, let's see here.

1296
00:55:41,100 --> 00:55:43,700
So this is a unit, 32 star is the is the real.

1297
00:55:43,900 --> 00:55:45,200
What is the contents pointer?

1298
00:55:45,400 --> 00:55:45,900
It's a void.

1299
00:55:45,900 --> 00:55:46,300
Yes.

1300
00:55:47,200 --> 00:55:47,900
So there we go.

1301
00:55:47,900 --> 00:55:50,300
I'm just going to go ahead and cast that.

1302
00:55:50,500 --> 00:55:54,200
So what we could do here, if we wanted to just as a test, we could go

1303
00:55:54,200 --> 00:55:55,300
ahead and say, all right.

1304
00:55:55,300 --> 00:55:58,800
Let's return that for now as a Cheesy thing to do.

1305
00:55:59,400 --> 00:56:01,200
This is this is totally temporary.

1306
00:56:01,200 --> 00:56:04,200
Not at all, what we actually want to do, but let's just do it for now.

1307
00:56:05,000 --> 00:56:08,800
So I'll return result here and

1308
00:56:09,000 --> 00:56:11,400
I will do result equals pixels.

1309
00:56:12,200 --> 00:56:12,500
Okay.

1310
00:56:12,500 --> 00:56:15,600
So when we load this into memory now, we're going to have a pixel

1311
00:56:15,600 --> 00:56:16,000
pointer.

1312
00:56:16,500 --> 00:56:20,400
So I'll stick that temporarily down in here, which is just say, pixel

1313
00:56:20,400 --> 00:56:20,900
pointer.

1314
00:56:21,100 --> 00:56:21,700
Right?

1315
00:56:22,000 --> 00:56:26,500
And I will go ahead and say, all right, the pixel point that came

1316
00:56:26,500 --> 00:56:30,500
State pixel pointer equals that and now we have a pixel pointer.

1317
00:56:30,900 --> 00:56:34,300
And now what I could do is I could basically just copy our draw

1318
00:56:34,300 --> 00:56:37,500
rectangle function or I could even just split it to the screen.

1319
00:56:38,400 --> 00:56:38,700
Yeah.

1320
00:56:38,900 --> 00:56:41,800
Basically, what I could do is I could say, let's just copy the screen,

1321
00:56:41,800 --> 00:56:43,300
it will be a line incorrectly.

1322
00:56:43,300 --> 00:56:44,400
But let's just copy to the screen.

1323
00:56:44,400 --> 00:56:48,300
So at the end of the frame to will overwrite everything we did

1324
00:56:48,600 --> 00:56:52,800
basically that buffer that were writing to, we'll just go ahead and

1325
00:56:52,800 --> 00:56:53,700
overwrite that.

1326
00:56:53,700 --> 00:56:59,800
So I'm basically just going to say, alright for y equals.

1327
00:57:00,200 --> 00:57:03,500
Y is less than buffer height plus plus Y.

1328
00:57:03,800 --> 00:57:09,300
And then I will do an X here, x x x width.

1329
00:57:09,900 --> 00:57:13,000
And then what I'm going to do is I'm just going to straight up copy

1330
00:57:13,400 --> 00:57:16,400
the pixels from the pixel pointer.

1331
00:57:16,400 --> 00:57:20,400
So I'm basically to say, all right, the game State pixel pointer.

1332
00:57:21,000 --> 00:57:24,200
I'm going to go ahead and say I've got that and then I've got the you

1333
00:57:24,200 --> 00:57:28,400
went dest and that's the buffer pixels and I'm just going to go ahead

1334
00:57:28,400 --> 00:57:29,700
and pull on just do.

1335
00:57:30,100 --> 00:57:34,200
The dest pointer equals the source pointer and of course the stride

1336
00:57:34,200 --> 00:57:34,600
won't be, right.

1337
00:57:34,600 --> 00:57:39,200
So our image will be all sheared and weird, but I just want to see if

1338
00:57:39,200 --> 00:57:42,700
reloading anything even close to right in the in the short time that

1339
00:57:42,700 --> 00:57:43,600
we have left.

1340
00:57:43,900 --> 00:57:44,700
So, okay.

1341
00:57:44,700 --> 00:57:46,900
I think I have to cast that if I'm not mistaken.

1342
00:57:46,900 --> 00:57:47,300
Do I?

1343
00:57:47,300 --> 00:57:49,600
Oh no, its just pixels isn't a member of the buffer.

1344
00:57:50,000 --> 00:57:52,600
So let's take a look at what that actually is.

1345
00:57:52,900 --> 00:57:59,100
So the buffer is a memory.

1346
00:57:59,200 --> 00:57:59,700
There we go.

1347
00:57:59,700 --> 00:57:59,800
So

1348
00:58:00,000 --> 00:58:01,300
Never, there we go.

1349
00:58:01,400 --> 00:58:01,700
Oops.

1350
00:58:03,600 --> 00:58:04,900
Signed unsigned mismatch.

1351
00:58:04,900 --> 00:58:07,400
Oh, those are those are integers, I guess.

1352
00:58:07,500 --> 00:58:07,800
Okay.

1353
00:58:07,900 --> 00:58:08,300
There we go.

1354
00:58:09,400 --> 00:58:10,300
And let's take a look.

1355
00:58:10,600 --> 00:58:14,100
So that is not a particularly good sign.

1356
00:58:15,300 --> 00:58:17,000
That doesn't look particularly good to me.

1357
00:58:17,300 --> 00:58:18,500
I don't know about you, guys.

1358
00:58:18,800 --> 00:58:23,800
We have a bunch of things that are expected problems there.

1359
00:58:23,800 --> 00:58:27,200
I can fix the sheer, but that's, that's pretty funny.

1360
00:58:28,800 --> 00:58:29,300
So yeah.

1361
00:58:29,300 --> 00:58:32,700
Okay, we will, we will pick that up next week because

1362
00:58:33,000 --> 00:58:37,400
That is not at all, what we want to look at and and rather than

1363
00:58:37,400 --> 00:58:39,800
debugging that now because there's a couple things we have to do.

1364
00:58:39,800 --> 00:58:46,000
So basically we have to do the stride so that this copying correctly

1365
00:58:46,000 --> 00:58:50,100
without cheering, then we have to fix the color ordering if the color

1366
00:58:50,100 --> 00:58:52,400
ordering is wrong and all sorts of other things like that.

1367
00:58:52,700 --> 00:58:55,300
So I'm just going to not act, you do that because we'll just eat in

1368
00:58:55,300 --> 00:58:55,800
the Q&A.

1369
00:58:55,800 --> 00:58:59,300
I'd rather keep doing on time and tomorrow we can be basically how to

1370
00:58:59,300 --> 00:59:02,700
pull it that stuff onto the screen and then we can also

1371
00:59:02,800 --> 00:59:05,200
so, do our like are

1372
00:59:05,900 --> 00:59:10,400
Our debugging of loading the bitmap in case we had bugs in that code.

1373
00:59:10,400 --> 00:59:13,900
For example, where we were saying that the pixel pointer was might

1374
00:59:13,900 --> 00:59:14,900
have been wrong or something like that.

1375
00:59:14,900 --> 00:59:16,300
It looks like our header is correct.

1376
00:59:16,300 --> 00:59:18,300
So just whether our bitmap offset is correct or not.

1377
00:59:18,700 --> 00:59:24,200
Okay, so that's it for now is time to go to the Q&A.

1378
00:59:24,200 --> 00:59:27,900
Please prefix your questions with Q:, so I will see them.

1379
00:59:27,900 --> 00:59:33,300
And if you could also try to keep questions to programming questions

1380
00:59:33,300 --> 00:59:35,600
that are about today stream or previous dreams.

1381
00:59:36,000 --> 00:59:38,500
That would be very helpful, so we can stay on topic.

1382
00:59:39,000 --> 00:59:42,200
All right, off we go to the Q&A.

1383
00:59:45,500 --> 00:59:46,200
Yes, perfect.

1384
00:59:46,200 --> 00:59:48,400
Blind shift that, I totally agree.

1385
00:59:48,800 --> 00:59:51,500
Well, so basically a lot of times what you can do is just, you gotta

1386
00:59:51,500 --> 00:59:52,700
sell it, right?

1387
00:59:52,700 --> 00:59:54,300
If you have a bug, right?

1388
00:59:54,300 --> 00:59:54,900
Like this.

1389
00:59:55,100 --> 00:59:57,100
And you're just like, okay, that's not so good.

1390
00:59:57,200 --> 00:59:58,500
What you need to do is say, okay.

1391
00:59:58,500 --> 00:59:58,700
No.

1392
00:59:58,700 --> 00:59:59,800
Wait, this is

1393
01:00:00,000 --> 01:00:01,700
This is like an indie game.

1394
01:00:01,800 --> 01:00:07,200
That's about your perception of reality and how you need to be able to

1395
01:00:07,200 --> 01:00:11,100
see things beyond the way that they're normally presented or whatever

1396
01:00:11,300 --> 01:00:13,500
and just sell this as intentional, right?

1397
01:00:13,500 --> 01:00:15,900
Like you just got to have a good Fiction.

1398
01:00:16,000 --> 01:00:18,700
It's the same thing that they do in like art galleries, when they put

1399
01:00:18,700 --> 01:00:22,000
like a little thing, they have a picture and it's totally random and

1400
01:00:22,000 --> 01:00:23,100
then they have a thing on the side.

1401
01:00:23,100 --> 01:00:29,500
That's like a little placard and it says something like, you know, in

1402
01:00:29,500 --> 01:00:29,900
this

1403
01:00:30,000 --> 01:00:34,100
Evocative piece, you can see how like the suggestion of a windmill at

1404
01:00:34,100 --> 01:00:39,000
Sunset evokes, you know, you know, servantes and all the sort of, you

1405
01:00:39,000 --> 01:00:41,100
know, that's, that's that's what you got to do.

1406
01:00:41,100 --> 01:00:44,100
If you cut, if you have this, it's not going to sell itself.

1407
01:00:44,200 --> 01:00:45,800
So you're going to have to sell it.

1408
01:00:46,600 --> 01:00:50,000
That's that's, you know, that's game salesmanship right there.

1409
01:00:50,000 --> 01:00:50,900
That's what you got to do.

1410
01:00:52,800 --> 01:00:55,100
If you don't want to debug it, I'd rather just a bug it.

1411
01:00:55,100 --> 01:00:57,300
But if you don't want to, you have other options.

1412
01:00:59,700 --> 01:01:02,500
I missed the part where you handled endianness of the file or a bit

1413
01:01:02,500 --> 01:01:03,700
Maps, always the same.

1414
01:01:04,600 --> 01:01:07,000
Well, so yeah, bitmaps.

1415
01:01:08,400 --> 01:01:11,400
I want to say that, I don't know if they can be a different

1416
01:01:11,400 --> 01:01:13,700
indianness, if they're saved on a Mac.

1417
01:01:14,200 --> 01:01:15,200
We don't care.

1418
01:01:15,200 --> 01:01:18,300
Because we'll always know that they're in our native Indian and Enos.

1419
01:01:18,300 --> 01:01:19,200
If that makes sense.

1420
01:01:20,200 --> 01:01:23,300
If you were loading a file, like, if you were loading a PSD, for

1421
01:01:23,300 --> 01:01:26,200
example, it's always in the wrong indianness.

1422
01:01:26,200 --> 01:01:28,600
It's always in old Power PC and in this.

1423
01:01:29,900 --> 01:01:30,600
So, yeah.

1424
01:01:31,200 --> 01:01:34,200
Today nowadays, Max also use little endian.

1425
01:01:34,200 --> 01:01:36,700
So if they saved a bitmap, it would be little endian as well.

1426
01:01:36,900 --> 01:01:38,000
I don't know.

1427
01:01:38,200 --> 01:01:42,100
If there's ever been a time when bitmaps for saved, big-endian on like

1428
01:01:42,100 --> 01:01:43,900
powerpc Macs or something, I'm not sure.

1429
01:01:44,400 --> 01:01:49,500
But basically, for bitmaps that are saved on any modern computer.

1430
01:01:49,500 --> 01:01:51,800
They will always be little endian and we're a little endian, so it

1431
01:01:51,800 --> 01:01:52,500
doesn't matter.

1432
01:01:52,500 --> 01:01:53,200
We're always fine.

1433
01:01:57,300 --> 01:01:58,600
Do I prefer pragma pack or what?

1434
01:01:58,600 --> 01:01:59,100
I prefer.

1435
01:01:59,100 --> 01:02:00,500
GCC like annotation.

1436
01:02:01,200 --> 01:02:05,600
Probably GCC like, annotation, but I don't really care.

1437
01:02:05,600 --> 01:02:06,600
I mean, it's a little ugly.

1438
01:02:06,600 --> 01:02:09,500
I'd prefer to just be able to say yeah, like pack this thing or

1439
01:02:09,500 --> 01:02:11,800
whatever and GCC has attributes like that.

1440
01:02:11,800 --> 01:02:12,100
Jesus.

1441
01:02:12,100 --> 01:02:16,200
He and Lov on have attributes like that, but it's not really a big

1442
01:02:16,200 --> 01:02:16,400
deal.

1443
01:02:16,400 --> 01:02:18,700
I don't do this, like you don't do this very often.

1444
01:02:19,100 --> 01:02:19,800
So that's it.

1445
01:02:19,800 --> 01:02:20,600
Usually isn't that?

1446
01:02:20,600 --> 01:02:22,100
That's why it's usually not that big a deal.

1447
01:02:29,200 --> 01:02:32,000
What's your threshold for number of function parameters before putting

1448
01:02:32,000 --> 01:02:34,800
them all into a single structure, as a single function parameter?

1449
01:02:36,300 --> 01:02:37,900
I don't really have a threshold for that.

1450
01:02:38,000 --> 01:02:39,500
I'm rarely thinking about that.

1451
01:02:39,500 --> 01:02:40,300
When I do that.

1452
01:02:40,600 --> 01:02:44,400
What I'm thinking about is whether there will be a lot of times when

1453
01:02:44,400 --> 01:02:48,600
things will get passed through as that structure.

1454
01:02:48,700 --> 01:02:51,300
So, basically, if I think of, a lot of people will be passing around

1455
01:02:51,300 --> 01:02:55,000
the same group of stuff, then I'll condense it into a structure, but

1456
01:02:55,000 --> 01:02:58,100
if a function itself just happens to have a unique set of stuff, even

1457
01:02:58,100 --> 01:02:58,200
if

1458
01:02:58,300 --> 01:02:59,000
It's 30 long.

1459
01:02:59,000 --> 01:02:59,500
I don't care.

1460
01:02:59,500 --> 01:02:59,900
I'll just

1461
01:03:00,000 --> 01:03:05,100
Them as I'll just do them as as individual parameters, so it's not

1462
01:03:05,100 --> 01:03:08,200
really about how many, How many pairs of function has its whether

1463
01:03:08,200 --> 01:03:11,700
those things can be bundled together in ways that lots of people use

1464
01:03:11,700 --> 01:03:13,900
because then that just condenses the code and it's nicer.

1465
01:03:18,500 --> 01:03:21,100
Could you please describe how the sparse tilemap storage is done so

1466
01:03:21,100 --> 01:03:21,500
far.

1467
01:03:21,500 --> 01:03:23,500
Watch last week's videos, but couldn't figure it out.

1468
01:03:23,500 --> 01:03:23,900
Sure.

1469
01:03:25,100 --> 01:03:26,600
I can totally describe that.

1470
01:03:27,400 --> 01:03:32,900
So if we take a look at tilemap the handmade tile .h,

1471
01:03:34,500 --> 01:03:38,500
So basically what we have here at the moment and again remember the

1472
01:03:38,500 --> 01:03:40,800
only reason we were doing this to figure out what kind of API we

1473
01:03:40,800 --> 01:03:41,900
wanted, right?

1474
01:03:45,200 --> 01:03:49,200
So you can see we even have it to do here that says real sparseness

1475
01:03:49,600 --> 01:03:51,600
because we're not really doing real sparseness yet.

1476
01:03:52,500 --> 01:03:53,000
But okay.

1477
01:03:53,500 --> 01:03:57,300
So basically what we have is we have a two level or a scheme that's

1478
01:03:57,300 --> 01:03:58,400
implemented currently.

1479
01:03:59,300 --> 01:04:03,900
What happens is we have an array of tile chunks, right?

1480
01:04:04,000 --> 01:04:05,800
We have tile chunk EXT.

1481
01:04:05,800 --> 01:04:08,200
I'll jump can't watch out Z.

1482
01:04:08,400 --> 01:04:10,400
We have that as an array of tile chunks.

1483
01:04:10,400 --> 01:04:14,200
So it's a three dimensional array of tile chunks, right?

1484
01:04:14,700 --> 01:04:18,000
So if you think about what that looks like, it's a cube, right?

1485
01:04:18,100 --> 01:04:18,600
And imagine.

1486
01:04:18,600 --> 01:04:21,100
This is a cube that contains the world, right?

1487
01:04:21,100 --> 01:04:22,200
This is our whole world.

1488
01:04:22,400 --> 01:04:27,600
It's got some number of slices in Z, right, which is this tile chunk

1489
01:04:27,600 --> 01:04:28,300
count Z.

1490
01:04:28,700 --> 01:04:29,000
So how

1491
01:04:29,200 --> 01:04:32,700
Many this this year is the tile chunk out.

1492
01:04:32,700 --> 01:04:37,200
Z it then has some number of slices in y.

1493
01:04:37,200 --> 01:04:40,900
So those are, those are these slices this way, right?

1494
01:04:42,200 --> 01:04:42,800
Makes sense.

1495
01:04:43,500 --> 01:04:47,600
So we have some number of slices and why, and then we also have some

1496
01:04:47,600 --> 01:04:51,300
number of slices in X, which we finally slice it this way, right?

1497
01:04:51,300 --> 01:04:56,400
Slice, slice slice in here is X, right.

1498
01:04:56,900 --> 01:04:59,700
And so, that is how we dice up the world to begin with.

1499
01:04:59,700 --> 01:05:02,600
And, of course, these lines all continue all the way through, right?

1500
01:05:03,700 --> 01:05:07,100
And you can imagine pulling this apart, one layer at a time, the

1501
01:05:07,100 --> 01:05:10,400
biggest, the most primary index.

1502
01:05:10,900 --> 01:05:11,900
And you can tell this by

1503
01:05:12,000 --> 01:05:14,000
Going into when we do get tile chunk.

1504
01:05:14,300 --> 01:05:14,900
Right?

1505
01:05:15,100 --> 01:05:17,900
And we pass it, the indices, you can see the operation.

1506
01:05:17,900 --> 01:05:18,900
It's Z.

1507
01:05:19,700 --> 01:05:25,200
The each individual Movement by one level of Z moves us all the way in

1508
01:05:25,200 --> 01:05:27,300
all the tile chunk context all tile chunk cut.

1509
01:05:27,300 --> 01:05:28,500
Why, right?

1510
01:05:28,700 --> 01:05:32,900
So what that means is z is the is the price is the largest accessor.

1511
01:05:33,500 --> 01:05:35,000
When we move up one in Z.

1512
01:05:35,000 --> 01:05:38,200
We move up a whole to d block of X Y.

1513
01:05:38,400 --> 01:05:41,800
So you can think of it as the z-index peels off.

1514
01:05:41,900 --> 01:05:43,500
Off one whole thing of this.

1515
01:05:43,500 --> 01:05:48,200
So a single z-index pulls off, basically one.

1516
01:05:50,400 --> 01:05:52,500
Of these guys, right?

1517
01:05:57,300 --> 01:05:59,600
Makes sense so far, hopefully.

1518
01:06:00,100 --> 01:06:04,400
So a single z-index like this might be z-index one, right pulls off an

1519
01:06:04,400 --> 01:06:07,700
entire chunk of these that still has all of the exes and all of the

1520
01:06:07,700 --> 01:06:09,500
Y's right.

1521
01:06:09,500 --> 01:06:10,300
Next.

1522
01:06:10,300 --> 01:06:11,600
They are indexed by y.

1523
01:06:11,800 --> 01:06:15,300
So next you can use a why to pull out one chunk of the exes.

1524
01:06:15,300 --> 01:06:16,900
And again, that's the same operation.

1525
01:06:16,900 --> 01:06:18,800
It's pulling out one chunk.

1526
01:06:18,800 --> 01:06:20,300
Now, we're pulling out a chunk.

1527
01:06:20,400 --> 01:06:23,200
That's just one dimensional, right?

1528
01:06:25,600 --> 01:06:26,100
Make sense.

1529
01:06:26,100 --> 01:06:27,500
So now we're pulling out that chunk.

1530
01:06:27,500 --> 01:06:32,700
And this is z equals 1, y equals, you know, to or something, it's some

1531
01:06:32,800 --> 01:06:33,500
some number.

1532
01:06:33,500 --> 01:06:37,500
It doesn't matter what these are right, Z equals a and Y equals B.

1533
01:06:37,500 --> 01:06:39,000
We're pulling out some row.

1534
01:06:39,100 --> 01:06:42,900
And then finally, we use the X to grab one in particular one.

1535
01:06:43,200 --> 01:06:46,800
And you can see that right in the math X has no multiplier.

1536
01:06:46,800 --> 01:06:49,500
It's just something that once you have one of these, you need to go

1537
01:06:49,500 --> 01:06:51,800
that many tile chunks into it, right?

1538
01:06:52,400 --> 01:06:54,600
And similarly, y, only moves by

1539
01:06:54,800 --> 01:06:56,200
1X is worth, right.

1540
01:06:56,200 --> 01:06:59,100
So moving in, why just moves you one of these rows for words, but

1541
01:06:59,100 --> 01:07:01,600
moving in Z moves, you both, right?

1542
01:07:01,800 --> 01:07:04,500
So it's moving like a whole Plate at a time and we could keep going up

1543
01:07:04,500 --> 01:07:05,600
into higher Dimensions, right?

1544
01:07:05,600 --> 01:07:07,100
And that indexing scheme, still works.

1545
01:07:07,300 --> 01:07:08,300
This is the indexing scheme.

1546
01:07:08,300 --> 01:07:10,100
I talked about that basically flattens.

1547
01:07:10,300 --> 01:07:15,200
Any uniformly, multi-dimensional thing into a one-dimensional thing.

1548
01:07:15,200 --> 01:07:18,100
This is the indexing for that right now.

1549
01:07:18,100 --> 01:07:20,600
Once we grab one of those, we just have a tile chunk.

1550
01:07:20,700 --> 01:07:24,200
So finally, when we have something with an x y, and a z of the tile

1551
01:07:24,200 --> 01:07:24,500
chunk.

1552
01:07:24,700 --> 01:07:29,500
We have a chunk, not a tile and a title chunk.

1553
01:07:29,500 --> 01:07:29,900
Right?

1554
01:07:29,900 --> 01:07:31,500
And I should be more Civic.

1555
01:07:31,600 --> 01:07:33,400
We have a towel chunk pointer, right?

1556
01:07:33,400 --> 01:07:37,700
So, we have a chunk star, if there's nothing to find at the world in

1557
01:07:37,700 --> 01:07:39,400
that location, anywhere in there.

1558
01:07:40,300 --> 01:07:43,500
Venice is 0 and we know there's no tiles in there at all.

1559
01:07:44,200 --> 01:07:47,800
But if it's not 0, if that chunk point that we pull out of there after

1560
01:07:47,800 --> 01:07:52,200
doing this is not zero, then that means it has a tiles pointer, right,

1561
01:07:52,200 --> 01:07:54,800
that that tiles pointer Works were talking about, it's not zero.

1562
01:07:56,000 --> 01:08:00,300
Then that means that we actually also have a two-dimensional array of

1563
01:08:00,300 --> 01:08:02,100
tiles in there.

1564
01:08:02,500 --> 01:08:07,600
And that two-dimensional array of tiles is chunked in by chunk, Tim.

1565
01:08:07,800 --> 01:08:09,100
And I believe we said that chunk.

1566
01:08:09,100 --> 01:08:10,000
Tim was 16.

1567
01:08:10,300 --> 01:08:11,100
Is what we're doing.

1568
01:08:11,500 --> 01:08:16,399
So basically, when we pull out that chunk, it's actually another 16 by

1569
01:08:16,399 --> 01:08:18,200
16 flat piece.

1570
01:08:18,399 --> 01:08:18,899
Right?

1571
01:08:19,000 --> 01:08:21,700
So it's basically, you know, it's pretty dense.

1572
01:08:21,700 --> 01:08:22,000
Right?

1573
01:08:22,000 --> 01:08:24,300
It's like it's even one more denser than that.

1574
01:08:24,300 --> 01:08:29,000
So it's like, it's a lot of tiles right in both directions.

1575
01:08:29,000 --> 01:08:30,700
So it's crazy dense, right?

1576
01:08:30,800 --> 01:08:34,100
But it's a 16 by 16 by one deep.

1577
01:08:34,200 --> 01:08:34,399
Right?

1578
01:08:34,399 --> 01:08:36,500
So it's only one deep.

1579
01:08:36,600 --> 01:08:37,600
It has nosy.

1580
01:08:37,800 --> 01:08:39,300
It's one flat plane.

1581
01:08:39,500 --> 01:08:40,000
That's 60.

1582
01:08:40,100 --> 01:08:43,500
In by 16, we then look up the tile in there and that's where the tiles

1583
01:08:43,500 --> 01:08:44,100
are stored.

1584
01:08:44,500 --> 01:08:47,500
And what this allows us to do is it allows us to basically store a

1585
01:08:47,500 --> 01:08:48,800
reasonably sized chunk.

1586
01:08:48,800 --> 01:08:51,500
So they're reasonably compact 16 by 16.

1587
01:08:51,600 --> 01:08:52,800
Nicely arrayed in memory.

1588
01:08:52,800 --> 01:08:54,800
We don't have to spend time figuring out how to get to them or

1589
01:08:54,800 --> 01:08:55,600
anything like that.

1590
01:08:55,800 --> 01:08:59,200
But we lost that up into a scheme that is sparse, so that we don't

1591
01:08:59,200 --> 01:08:59,800
have to store that.

1592
01:09:00,000 --> 01:09:01,700
Everywhere in the world, right?

1593
01:09:01,700 --> 01:09:03,800
Because we don't want to store this whole Cube.

1594
01:09:03,800 --> 01:09:08,600
Even in our, our current size would be too big to store efficiently.

1595
01:09:08,600 --> 01:09:09,000
Probably.

1596
01:09:09,000 --> 01:09:10,500
So we don't want to have to do that.

1597
01:09:10,600 --> 01:09:10,700
Now.

1598
01:09:10,700 --> 01:09:14,300
This is not a particularly good storage scheme because we still have

1599
01:09:14,300 --> 01:09:16,200
to have this upper this or upper array.

1600
01:09:16,200 --> 01:09:19,000
The tile chunk array is dense, right?

1601
01:09:19,000 --> 01:09:19,700
This is dense.

1602
01:09:20,000 --> 01:09:24,600
So we've subsampled it by 16 times 16 at that lower level.

1603
01:09:25,700 --> 01:09:26,500
But it's still dense.

1604
01:09:26,500 --> 01:09:28,899
And so what we're going to move to when we actually write the engine

1605
01:09:28,899 --> 01:09:29,800
code proper.

1606
01:09:30,500 --> 01:09:32,800
And again, we're it's all hiding behind an API that doesn't care.

1607
01:09:32,800 --> 01:09:35,200
So we will be able to do this without affecting the light code that

1608
01:09:35,200 --> 01:09:37,300
calls into it, which is kind of the goal as well.

1609
01:09:38,300 --> 01:09:40,500
This is dense and we want to turn this into sparse.

1610
01:09:40,500 --> 01:09:41,700
We want us to be fully sparse.

1611
01:09:41,700 --> 01:09:45,300
So there's no cost for storing basically a giant world.

1612
01:09:45,600 --> 01:09:49,000
If you don't, you only pay the cost of how much world you actually

1613
01:09:49,000 --> 01:09:49,700
fill in.

1614
01:09:49,800 --> 01:09:54,100
You never pay a cost based on the wingspan of that world and what that

1615
01:09:54,100 --> 01:09:55,100
means if you

1616
01:09:55,300 --> 01:09:56,300
About it, right?

1617
01:09:56,400 --> 01:10:01,400
Is I don't want to have to be constrained to a bounding rectangle size

1618
01:10:01,400 --> 01:10:02,100
of things.

1619
01:10:02,400 --> 01:10:06,100
If my world is literally only this one long straight path that goes

1620
01:10:06,100 --> 01:10:07,000
from here to here.

1621
01:10:07,200 --> 01:10:07,800
Right?

1622
01:10:07,900 --> 01:10:10,400
If we were storing everything, as a dense array and worse yet.

1623
01:10:10,400 --> 01:10:13,200
Actually, let's make it, let's go 111 worse, right?

1624
01:10:13,200 --> 01:10:16,800
Let's say I've got something that looks like this, so it's actually

1625
01:10:16,800 --> 01:10:17,900
fully three-dimensional.

1626
01:10:18,000 --> 01:10:20,900
It starts at the bottom here and goes all the way to the top corner

1627
01:10:20,900 --> 01:10:21,400
there.

1628
01:10:21,500 --> 01:10:22,100
Right?

1629
01:10:22,400 --> 01:10:24,900
So it's basically this Meandering thing that crosses all three.

1630
01:10:25,200 --> 01:10:26,300
Options in a diagonal.

1631
01:10:26,700 --> 01:10:30,100
I don't want to have to store this whole Cube because that'll be huge.

1632
01:10:30,200 --> 01:10:33,800
I only want to store a little local regions of tiles that cover.

1633
01:10:33,800 --> 01:10:34,200
This.

1634
01:10:34,400 --> 01:10:38,700
I want to pay a cost of storage, commensurate with the area.

1635
01:10:38,700 --> 01:10:44,200
I actually filled and not the bounding rectangle of that area.

1636
01:10:44,200 --> 01:10:47,200
If that makes sense, the axis aligned bounding wrecked on that area

1637
01:10:47,200 --> 01:10:48,100
and a raise.

1638
01:10:48,300 --> 01:10:52,100
If things that are dense, arrays are essentially storing bounded,

1639
01:10:52,300 --> 01:10:54,500
access aligned bounding rectangles.

1640
01:10:55,300 --> 01:10:57,700
Worth of data and that's just not going to fly here.

1641
01:10:58,100 --> 01:11:00,100
So that's why we need is the sparsity scheme.

1642
01:11:00,200 --> 01:11:03,300
Hopefully, that is a reasonable explanation that you can work from

1643
01:11:03,400 --> 01:11:05,900
when you go back and try to understand how that code is working.

1644
01:11:14,400 --> 01:11:18,300
Why not use a function template to redraw B into any struct?

1645
01:11:18,300 --> 01:11:22,000
You cook up one primitive at a time instead of quirky compiler

1646
01:11:22,000 --> 01:11:25,500
commands, then you could ignore whatever weird shape it wants to give

1647
01:11:25,500 --> 01:11:26,600
your struct in memory.

1648
01:11:28,100 --> 01:11:31,400
Well, if you want to do that, that's probably fine.

1649
01:11:31,800 --> 01:11:37,700
I certainly wouldn't say that anyone, you know, I wouldn't fire you

1650
01:11:37,700 --> 01:11:38,400
for doing that.

1651
01:11:38,400 --> 01:11:39,200
Let's put it that way.

1652
01:11:40,100 --> 01:11:42,700
And there are certainly times when that is a useful thing to do.

1653
01:11:43,400 --> 01:11:47,000
The times when that is a useful thing to do the template part, I would

1654
01:11:47,000 --> 01:11:49,300
probably never do because that doesn't sound like a good idea to me,

1655
01:11:49,300 --> 01:11:52,900
but ignoring that part, if you want to do it in templates, go nuts,

1656
01:11:53,600 --> 01:11:56,400
but in terms of having individual Primitives that read in, we could

1657
01:11:56,400 --> 01:11:59,500
imagine writing the code that way that code would basically.

1658
01:11:59,500 --> 01:11:59,700
Look,

1659
01:12:00,000 --> 01:12:01,000
Like this, right.

1660
01:12:01,000 --> 01:12:03,200
It would basically look like something like this.

1661
01:12:06,700 --> 01:12:07,200
Right?

1662
01:12:08,000 --> 01:12:12,100
Where, you know, you had a series of functions that look sort of that

1663
01:12:12,100 --> 01:12:15,900
red in things like this and you basically would call them

1664
01:12:15,900 --> 01:12:16,700
individually.

1665
01:12:16,800 --> 01:12:20,200
So you would kind of go through and say all right to read in the

1666
01:12:20,200 --> 01:12:20,800
header.

1667
01:12:21,100 --> 01:12:23,600
The thing that reads in the header creates one of these parts are

1668
01:12:23,600 --> 01:12:27,100
things which is basically just an index into the file, right?

1669
01:12:27,100 --> 01:12:29,900
So it's got one of these and it initializes it to be, you know, index

1670
01:12:29,900 --> 01:12:33,000
into the file like, you know, beginning of file, right?

1671
01:12:33,500 --> 01:12:36,400
And this this basically like reads a 32

1672
01:12:36,600 --> 01:12:39,700
Value and advances the pointer, right?

1673
01:12:40,100 --> 01:12:41,000
I don't know if you can understand.

1674
01:12:41,000 --> 01:12:42,200
Basically, I'm trying to construct here.

1675
01:12:42,200 --> 01:12:44,000
I don't want to have to write the whole thing out.

1676
01:12:44,900 --> 01:12:48,100
But basically, then what we would do is to read this.

1677
01:12:48,100 --> 01:12:53,000
We'd say, you know you in 16 file type equals U n-- 16, parser like

1678
01:12:53,000 --> 01:12:53,900
this right?

1679
01:12:55,700 --> 01:12:59,200
File size equals Unit, 32 parser and so on, right?

1680
01:12:59,300 --> 01:13:04,100
And then you just you read them in the reason that I don't think that

1681
01:13:04,100 --> 01:13:06,300
is particularly useful.

1682
01:13:06,500 --> 01:13:11,600
Here is because it's just a it's just a lot more work that's going on

1683
01:13:11,600 --> 01:13:16,400
in terms of what the compiler would have to flatten out to make this,

1684
01:13:16,800 --> 01:13:17,100
right.

1685
01:13:17,100 --> 01:13:18,900
I mean, this is way simpler for the compiler.

1686
01:13:18,900 --> 01:13:20,700
It's like a cast, right?

1687
01:13:20,700 --> 01:13:22,000
It's the most trivial thing.

1688
01:13:22,000 --> 01:13:25,600
The compiler could ever have to handle, and there's no question that

1689
01:13:25,600 --> 01:13:26,800
it will be able to generate good code.

1690
01:13:26,800 --> 01:13:27,800
If you write it this way.

1691
01:13:28,100 --> 01:13:31,100
If you write it this way, the compiler has to realize that you're just

1692
01:13:31,100 --> 01:13:33,000
reading out of memory using a structured pointer.

1693
01:13:33,200 --> 01:13:35,900
And so that they know that, you know, it doesn't have to do.

1694
01:13:36,500 --> 01:13:39,100
Actually do these reads one at a time in all this stuff.

1695
01:13:39,100 --> 01:13:41,700
You're just making a lot of extra work for the optimizer.

1696
01:13:41,700 --> 01:13:43,400
That really, there's no point to doing.

1697
01:13:43,400 --> 01:13:43,600
Look.

1698
01:13:43,600 --> 01:13:44,900
What did you gain from this?

1699
01:13:45,300 --> 01:13:47,900
All you had to do is know to put pragma packet, practical pragmatic

1700
01:13:47,900 --> 01:13:51,100
pack push and programmatic pop, that's pretty simple.

1701
01:13:51,100 --> 01:13:52,500
And you didn't have to write any of this.

1702
01:13:53,200 --> 01:13:56,900
So it just seems like a real big waste.

1703
01:13:57,300 --> 01:13:59,700
I really don't see why you would ever write that.

1704
01:14:00,000 --> 01:14:02,600
Now, there are times when you would write that the time that you would

1705
01:14:02,600 --> 01:14:05,600
write that are, for example, let's say you did have an endianness

1706
01:14:05,600 --> 01:14:06,300
issue and any

1707
01:14:06,400 --> 01:14:09,300
and things had to be reversed that might be one good example of when

1708
01:14:09,300 --> 01:14:11,600
you might do this because you can bake the endianness reversal into

1709
01:14:11,600 --> 01:14:12,300
the read.

1710
01:14:12,300 --> 01:14:14,100
Another time is predicated files.

1711
01:14:14,200 --> 01:14:17,800
So for example, let's say that the file saw this reserved if this

1712
01:14:17,800 --> 01:14:21,400
reserved was not zero, then the second Reserve doesn't exist stuff

1713
01:14:21,400 --> 01:14:22,100
like that.

1714
01:14:22,100 --> 01:14:24,400
Then this structured format doesn't work anymore.

1715
01:14:24,600 --> 01:14:27,500
So then you have to do reads and it's sort of like a state machine.

1716
01:14:27,600 --> 01:14:30,600
That's how that's working to figure out what's going on.

1717
01:14:30,600 --> 01:14:31,400
It's not what state machine.

1718
01:14:31,400 --> 01:14:35,000
It's a predicated read and then at that point, you're much better off.

1719
01:14:35,100 --> 01:14:36,300
Not using a structure method.

1720
01:14:36,500 --> 01:14:38,500
So this is what I would expect to see in the case, where you're

1721
01:14:38,500 --> 01:14:44,200
reading, a more complicated file format, like PSD liked, if things

1722
01:14:44,200 --> 01:14:44,700
like that.

1723
01:14:47,600 --> 01:14:49,600
But when you're reading something this simple, it just seems like that

1724
01:14:49,600 --> 01:14:50,900
would be a real big waste of time.

1725
01:14:53,500 --> 01:14:54,500
Both yours and compilers.

1726
01:15:00,300 --> 01:15:02,400
How will we handle memory when reading files, would?

1727
01:15:02,400 --> 01:15:05,800
We would it be wasteful to read into our memory pool than only use

1728
01:15:05,800 --> 01:15:06,500
part of it.

1729
01:15:07,200 --> 01:15:10,800
So basically, that is a question that we want to save for a lot later.

1730
01:15:11,600 --> 01:15:15,000
We will be doing resource streaming which means that what we will be

1731
01:15:15,000 --> 01:15:19,800
doing eventually, when we stopped using debug loading calls is we will

1732
01:15:19,800 --> 01:15:24,900
be reading in essentially stuff that we've pre-processed into a

1733
01:15:24,900 --> 01:15:28,400
format, that's going to be real easy for us to kind of stream in as

1734
01:15:28,400 --> 01:15:29,100
fast as possible.

1735
01:15:29,100 --> 01:15:29,800
Whether that means like,

1736
01:15:30,100 --> 01:15:31,800
You know, that it's compressed or whatever.

1737
01:15:32,900 --> 01:15:35,400
We're going to, we're going to be focusing on how to make that

1738
01:15:35,400 --> 01:15:36,400
pipeline smooth.

1739
01:15:36,700 --> 01:15:40,900
And basically what that means is probably what will happen is the data

1740
01:15:40,900 --> 01:15:44,700
that's read from disk, probably won't be usable directly.

1741
01:15:45,100 --> 01:15:48,700
So what we'll want to be doing is just reading the chunk that we need

1742
01:15:48,800 --> 01:15:49,600
out of the file.

1743
01:15:49,600 --> 01:15:52,000
The exact amount that we need, because we'll have set up our files so

1744
01:15:52,000 --> 01:15:54,300
that we know exactly what we need to read in any circumstance.

1745
01:15:54,300 --> 01:15:57,100
We won't be having a bunch of cruft in the file that we don't care

1746
01:15:57,100 --> 01:15:59,900
about like reserved one and two will read

1747
01:16:00,100 --> 01:16:01,600
Exactly the part that we need.

1748
01:16:01,600 --> 01:16:05,000
We will decompress it directly into the place that supposed to go.

1749
01:16:05,100 --> 01:16:10,400
And then we will basically use that memory that the memory that gets

1750
01:16:10,400 --> 01:16:13,300
used for that temporary read that we before we do, think impress will

1751
01:16:13,300 --> 01:16:16,600
just be part of the transient buffer that we just reuse over and over

1752
01:16:16,600 --> 01:16:17,900
again as we load assets.

1753
01:16:31,300 --> 01:16:33,100
Dragon master, 047.

1754
01:16:33,300 --> 01:16:33,900
I'm not sure.

1755
01:16:33,900 --> 01:16:34,600
I understand this question.

1756
01:16:34,600 --> 01:16:35,200
Exactly.

1757
01:16:35,200 --> 01:16:39,100
I'm going to read it out loud and then see if I can see exactly what

1758
01:16:39,100 --> 01:16:39,500
you're asking.

1759
01:16:39,500 --> 01:16:41,500
If not, you may have to re-ask, it.

1760
01:16:42,500 --> 01:16:46,300
Could you explain how handled platform specific behavior, parentheses

1761
01:16:46,300 --> 01:16:51,200
Windows needs bitmap info for stress GI B, but only pass a platform on

1762
01:16:51,200 --> 01:16:54,000
specific struct back to the game code.

1763
01:16:54,000 --> 01:16:57,700
Would you just use a void Star platform data, if you need to pass

1764
01:16:57,700 --> 01:17:00,000
something platform game code platform.

1765
01:17:00,400 --> 01:17:04,400
So I think what you're asking, if I understand correctly is you have a

1766
01:17:04,400 --> 01:17:05,900
platform service?

1767
01:17:07,100 --> 01:17:10,200
Or a platform specific piece of data that exists.

1768
01:17:10,200 --> 01:17:13,800
In the platform layer, you're going to call the game code and you know

1769
01:17:13,800 --> 01:17:16,600
that the game code is going to call you back.

1770
01:17:17,500 --> 01:17:21,200
And when it calls you back you need it to hand you that data that is

1771
01:17:21,200 --> 01:17:24,800
platform-specific and you're asking how do you architect that?

1772
01:17:24,800 --> 01:17:26,100
Like, what should that look like?

1773
01:17:26,100 --> 01:17:29,600
Ideally the answer is we sort of already have one of those.

1774
01:17:31,800 --> 01:17:33,200
And I will talk a little bit about it.

1775
01:17:33,200 --> 01:17:34,700
So thread context.

1776
01:17:34,700 --> 01:17:37,300
Probably will have some platform specific data in it, eventually

1777
01:17:37,300 --> 01:17:38,000
possibly.

1778
01:17:39,600 --> 01:17:44,200
So there's two things you can do here one is you can actually just

1779
01:17:44,200 --> 01:17:48,600
declare there to be extra space at the end of thread context for you

1780
01:17:48,600 --> 01:17:50,100
to actually work with it.

1781
01:17:50,100 --> 01:17:51,900
So you can basically do something like this.

1782
01:17:54,600 --> 01:17:55,100
Right.

1783
01:17:56,700 --> 01:17:59,400
So the basically you have a place to put platforms that big data and

1784
01:17:59,400 --> 01:17:59,900
you just

1785
01:18:00,000 --> 01:18:00,700
At size B.

1786
01:18:00,700 --> 01:18:04,500
However, big needs to be for the biggest platforms storage.

1787
01:18:05,500 --> 01:18:08,200
I don't love that, but it does have some nice titties too.

1788
01:18:08,200 --> 01:18:10,600
It means that the game can copy those trucks around.

1789
01:18:10,600 --> 01:18:12,000
If it needs to, or things like this.

1790
01:18:12,700 --> 01:18:17,400
What I tend to do instead is I will basically just elongate the

1791
01:18:17,400 --> 01:18:21,700
structure when I pass it to the game and count on it being unnie

1792
01:18:22,100 --> 01:18:27,200
unnie, counted on it being really long dateable on the way back.

1793
01:18:27,300 --> 01:18:29,900
So basically what I'll do is I'll pass thread context.

1794
01:18:30,000 --> 01:18:34,100
In to the game and the game thinks it's just this but secretly, what

1795
01:18:34,100 --> 01:18:36,200
I'll do in the win32 layer.

1796
01:18:36,400 --> 01:18:41,700
Right is, I'll actually have something that's win32 thread context,

1797
01:18:42,000 --> 01:18:44,500
which is a different structure, right?

1798
01:18:45,700 --> 01:18:46,400
Like this.

1799
01:18:49,700 --> 01:18:56,100
And what I'll do is sort of the common or the the common part of it.

1800
01:18:56,100 --> 01:18:58,700
I'll put in there and then the win32 part.

1801
01:18:58,700 --> 01:19:00,300
I'll put out here, right?

1802
01:19:01,200 --> 01:19:02,000
Something like this.

1803
01:19:03,100 --> 01:19:07,100
Basically, so, what I do is I wrap the platform nonspecific structure

1804
01:19:07,100 --> 01:19:09,000
inside a platform specific structure.

1805
01:19:09,300 --> 01:19:12,600
Then when I pass the game, the thing I pass it, the address of this

1806
01:19:12,700 --> 01:19:16,200
knowing that that address is also the same as the address to this.

1807
01:19:16,400 --> 01:19:20,800
So when the thread context comes back to me, I just cast it back out

1808
01:19:20,800 --> 01:19:23,600
to win 3-2 thread context and I know that I've got my extra data

1809
01:19:23,600 --> 01:19:24,600
sitting there at the bottom.

1810
01:19:24,900 --> 01:19:25,600
Does that make sense?

1811
01:19:26,200 --> 01:19:27,800
So that's often how I do that?

1812
01:19:28,300 --> 01:19:30,800
I don't know if that answered your question, but that's how I would

1813
01:19:30,800 --> 01:19:32,200
probably do that in this circumstance.

1814
01:19:32,800 --> 01:19:35,600
Suffice to say, I try to minimize that sort of thing as much as

1815
01:19:35,600 --> 01:19:36,100
possible.

1816
01:19:36,100 --> 01:19:39,700
Anyway, because I don't like to have round trips through the code.

1817
01:19:39,700 --> 01:19:41,400
I think I mentioned that several times.

1818
01:19:41,600 --> 01:19:44,600
So I try to limit the amount of times when you ever would have two

1819
01:19:44,600 --> 01:19:48,300
round-trip anything, let alone platform specific data.

1820
01:19:48,400 --> 01:19:50,700
I try to minimize the number of round trips period.

1821
01:19:51,800 --> 01:19:52,800
So something to think about,

1822
01:19:57,200 --> 01:19:59,700
Would it be easy to implement a generic sparse array to solve our town

1823
01:19:59,700 --> 01:20:02,600
that problem possibly overloading, brackets?

1824
01:20:02,800 --> 01:20:03,800
Probably not.

1825
01:20:04,300 --> 01:20:07,200
I mean I'm thinking probably what I would do.

1826
01:20:07,200 --> 01:20:08,500
I mean not that it wouldn't be easy.

1827
01:20:08,500 --> 01:20:08,700
Yes.

1828
01:20:08,700 --> 01:20:09,200
It would be easy.

1829
01:20:09,200 --> 01:20:10,700
I don't think we necessarily want that.

1830
01:20:10,700 --> 01:20:11,200
Probably.

1831
01:20:11,200 --> 01:20:16,400
What I will do is I will use a hash table that hashes on the the

1832
01:20:16,800 --> 01:20:20,500
abstract but the absolute tile chunk indices or something like that.

1833
01:20:21,700 --> 01:20:26,000
So I don't think a sparse array is probably necessary and probably

1834
01:20:26,000 --> 01:20:26,800
would be slow.

1835
01:20:27,500 --> 01:20:31,600
Slower to index than I want it to be unless the generic sparse array

1836
01:20:31,600 --> 01:20:32,900
happens to be a hash table.

1837
01:20:32,900 --> 01:20:36,000
But even if it was a hash table, how would it know what the hash

1838
01:20:36,000 --> 01:20:36,500
function is?

1839
01:20:36,500 --> 01:20:38,900
So we're gonna have to do something specific to try and make a hash

1840
01:20:38,900 --> 01:20:42,600
function that's good for our purposes or do something smarter and I

1841
01:20:42,600 --> 01:20:42,900
don't know.

1842
01:20:42,900 --> 01:20:47,500
We could do something like a quadtree sliced, Claude tree, or

1843
01:20:47,500 --> 01:20:48,300
something like that.

1844
01:20:49,200 --> 01:20:49,700
I don't know.

1845
01:20:49,700 --> 01:20:52,200
I don't really want to do an octree because I feel like it would be

1846
01:20:52,200 --> 01:20:52,600
wasteful.

1847
01:20:52,600 --> 01:20:56,800
Since our Z is we don't have a lot of Z probably but who knows?

1848
01:20:56,900 --> 01:20:57,100
Rose.

1849
01:21:02,400 --> 01:21:04,100
So we have World chunks and tiles.

1850
01:21:04,100 --> 01:21:05,300
Didn't we also have screens.

1851
01:21:05,300 --> 01:21:07,300
I'm still fuzzy on the map abstractions.

1852
01:21:09,000 --> 01:21:12,400
So we did have screens but we don't really have screens anymore.

1853
01:21:12,400 --> 01:21:16,100
Because essentially, we decided we wanted our tile tile map to just be

1854
01:21:16,100 --> 01:21:17,100
nice and generic.

1855
01:21:17,100 --> 01:21:18,900
So we can scroll through want to or not.

1856
01:21:20,000 --> 01:21:23,100
And so screens are just going to be a gameplay con struct where we fix

1857
01:21:23,100 --> 01:21:27,300
the camera to be looking at just one screen and that will be where

1858
01:21:27,300 --> 01:21:28,000
screens come in.

1859
01:21:28,000 --> 01:21:30,200
We don't actually store screens explicitly ever.

1860
01:21:30,600 --> 01:21:31,500
They're only going to be a game.

1861
01:21:31,700 --> 01:21:34,600
Contract with they'll basically be marked up or just built into how

1862
01:21:34,600 --> 01:21:36,600
the game happens to move around.

1863
01:21:36,700 --> 01:21:37,400
That makes sense.

1864
01:21:46,700 --> 01:21:48,800
Why wouldn't you ever use a function template for the Primitive

1865
01:21:48,800 --> 01:21:49,100
readers?

1866
01:21:49,100 --> 01:21:51,500
I mentioned that seems just like the sort of thing function templates

1867
01:21:51,500 --> 01:21:54,700
are for the reason is because I hate templates.

1868
01:21:56,200 --> 01:22:00,700
I hate templates because I think their syntax is bad, and I think the

1869
01:22:00,700 --> 01:22:04,100
implementation of them in the debugger is bad and the compiler.

1870
01:22:04,400 --> 01:22:08,200
So basically most of the time, if you, if you use templates in your

1871
01:22:08,200 --> 01:22:12,900
code, I find that the error messages, get bad, the debug visibility,

1872
01:22:12,900 --> 01:22:15,700
the ability to inspect things of the burger gets worse and too.

1873
01:22:16,000 --> 01:22:20,200
Cast in the debugger gets worse in almost all the buggers.

1874
01:22:20,200 --> 01:22:24,500
Although mstc is probably the best case for those they usually are.

1875
01:22:26,600 --> 01:22:31,700
And you're basically just introducing that complexity for really no

1876
01:22:31,700 --> 01:22:32,200
gain.

1877
01:22:32,600 --> 01:22:34,900
I mean, think about what has to happen.

1878
01:22:34,900 --> 01:22:39,100
I mean, let's just Let's do let's do the basic thought process here.

1879
01:22:39,400 --> 01:22:43,300
How many values are you really going to read out of a file?

1880
01:22:43,600 --> 01:22:44,200
Right?

1881
01:22:45,000 --> 01:22:51,200
Basically, we've got, you know, you ain't 16s and in 16s and in 32 or

1882
01:22:51,200 --> 01:22:52,000
something, right?

1883
01:22:52,100 --> 01:22:55,000
So you've got, you know, something where you do read you in?

1884
01:22:55,500 --> 01:22:58,000
I mean, you know, something like this.

1885
01:23:11,500 --> 01:23:13,400
Right, we've got something that looks like this.

1886
01:23:13,600 --> 01:23:16,500
Okay, and it's got some file, parser thing that it's that it's that

1887
01:23:16,500 --> 01:23:19,300
it's, you know, taking as the pointer and it's going to return these

1888
01:23:19,300 --> 01:23:22,900
things right now, each one of these has to do a slightly separate a

1889
01:23:22,900 --> 01:23:24,800
slightly different swap, operation, right?

1890
01:23:24,800 --> 01:23:26,800
If we were going to do the endianness thing, like I talked about

1891
01:23:26,800 --> 01:23:28,900
before, right, so assuming you have to do some work on these because

1892
01:23:28,900 --> 01:23:30,600
otherwise, if you didn't have to do work on them, then you shouldn't

1893
01:23:30,600 --> 01:23:31,000
be doing it.

1894
01:23:31,000 --> 01:23:31,300
Really?

1895
01:23:31,800 --> 01:23:33,600
So assuming you have to do some work on this.

1896
01:23:33,600 --> 01:23:35,500
Let's assume you have to do an ND, a swap on this.

1897
01:23:35,600 --> 01:23:39,500
So we basically have, you know, our value here.

1898
01:23:39,600 --> 01:23:41,200
We're going to do whatever.

1899
01:23:41,400 --> 01:23:43,600
It takes to read it from the parser, which is basically it's going to

1900
01:23:43,600 --> 01:23:47,400
be like, you know, something that probably looks like this, right.

1901
01:23:49,100 --> 01:23:53,500
It's going to it's going to do something like this and and the parser

1902
01:23:53,500 --> 01:23:56,800
value is going to be plus equals 2 or something here and then it's

1903
01:23:56,800 --> 01:23:58,600
going to return the result.

1904
01:23:58,700 --> 01:23:59,800
It's got to do the any Nisswa.

1905
01:24:00,700 --> 01:24:03,900
So the Indian is swap is going to have to look, you know, whatever.

1906
01:24:03,900 --> 01:24:04,800
It's going to look like.

1907
01:24:04,800 --> 01:24:06,500
It depends on how you want to write it.

1908
01:24:06,800 --> 01:24:08,100
You could write it like this.

1909
01:24:08,100 --> 01:24:14,400
I suppose result equals results shifted up, you know, eight or results

1910
01:24:14,500 --> 01:24:18,400
and shifted down 8, I don't know, something like this.

1911
01:24:19,900 --> 01:24:20,400
I don't know.

1912
01:24:20,500 --> 01:24:21,600
You're gonna have to write something, right?

1913
01:24:21,600 --> 01:24:23,200
You're gonna have to write your idea, swapping here.

1914
01:24:24,100 --> 01:24:25,700
So what do you really gain?

1915
01:24:25,700 --> 01:24:27,400
And this is going to be different on each one.

1916
01:24:27,400 --> 01:24:27,700
Right?

1917
01:24:27,700 --> 01:24:30,200
Like the endianness swap for read and 32 is going to be different

1918
01:24:30,200 --> 01:24:30,400
here.

1919
01:24:30,400 --> 01:24:33,200
You could write them so that they all kind of roughly look the same.

1920
01:24:33,300 --> 01:24:36,700
I guess the way you would do that is you'd, you know, you'd have to

1921
01:24:36,700 --> 01:24:38,000
start writing a for Loop, right?

1922
01:24:38,000 --> 01:24:40,000
You'd have to write if you wanted them to be templatized.

1923
01:24:40,000 --> 01:24:42,500
So you only had to write it once which would be the only reason.

1924
01:24:42,500 --> 01:24:45,700
I think you would use a template, you have to start writing it, like

1925
01:24:46,200 --> 01:24:47,600
to Loop over the bike count.

1926
01:24:47,600 --> 01:24:50,500
So you'd have to do, like, white count equals zero.

1927
01:24:50,500 --> 01:24:53,700
Byte count is less than 4 or less than size.

1928
01:24:53,900 --> 01:24:58,000
Of the type that you're templatized on + + B count, right?

1929
01:24:59,000 --> 01:25:02,300
And so I should say B Index, right?

1930
01:25:02,500 --> 01:25:08,800
And then you're going to have to read in the thing in here in the

1931
01:25:08,800 --> 01:25:09,500
opposite order.

1932
01:25:09,500 --> 01:25:12,300
So you can start at the end and you read into the beginning, right?

1933
01:25:12,300 --> 01:25:15,000
Of the of the byte order and whatever and that's what you looks like.

1934
01:25:15,100 --> 01:25:18,100
I just don't understand why you would bother doing that when you could

1935
01:25:18,100 --> 01:25:21,800
just write the couple functions that you need and then they're easy to

1936
01:25:21,800 --> 01:25:22,500
read.

1937
01:25:22,500 --> 01:25:23,600
They you

1938
01:25:23,800 --> 01:25:25,900
can see which ones are calling very easily.

1939
01:25:25,900 --> 01:25:27,300
They're easy to refer to.

1940
01:25:28,000 --> 01:25:30,200
They all have actual names, that make sense.

1941
01:25:30,900 --> 01:25:31,400
It's just

1942
01:25:34,000 --> 01:25:39,700
I think people who write templates, tend to write templates a little

1943
01:25:39,700 --> 01:25:42,800
prematurely if you really had something where you're going to save a

1944
01:25:42,800 --> 01:25:44,800
ton of time by template, sizing it.

1945
01:25:45,000 --> 01:25:50,500
Maybe that's okay, but I just find that the tool chains are so bad at

1946
01:25:50,500 --> 01:25:53,000
working with templates that you're just inviting a lot of complexity

1947
01:25:53,000 --> 01:25:55,700
and a lot of unnecessary stuff into your code.

1948
01:25:55,700 --> 01:25:58,600
When it really just not that much to write it properly the first time.

1949
01:25:58,600 --> 01:26:01,500
And, you know, this thing is basically just the same here and here,

1950
01:26:01,500 --> 01:26:02,300
you'd

1951
01:26:02,500 --> 01:26:04,400
Your swap here.

1952
01:26:04,400 --> 01:26:06,800
And in fact, this this and this function could be the same.

1953
01:26:07,000 --> 01:26:08,700
I could just call this function from this.

1954
01:26:09,100 --> 01:26:12,900
This in 32 1 could just read could just use the unit 32 and cast it

1955
01:26:12,900 --> 01:26:13,600
right or whatever.

1956
01:26:13,600 --> 01:26:15,500
So, these actually don't have to be written separately.

1957
01:26:15,500 --> 01:26:16,600
This could just call that one.

1958
01:26:16,900 --> 01:26:19,600
And so, you're talking about a tremendously, small amount of code.

1959
01:26:19,700 --> 01:26:22,500
It just seems crazy to introduce templates into that, given how bad

1960
01:26:22,500 --> 01:26:25,600
templates are throughout the rest of the tool chain.

1961
01:26:26,100 --> 01:26:28,300
So yeah, so I never used templates ever.

1962
01:26:29,700 --> 01:26:33,700
And basically, I use metaprogramming for anything that other people

1963
01:26:33,700 --> 01:26:36,400
would potentially legitimately use templates for.

1964
01:26:36,400 --> 01:26:39,500
So if I looked at the use of templates and said that was a legitimate

1965
01:26:39,500 --> 01:26:42,400
time when I would have used templates, I don't actually ever use

1966
01:26:42,400 --> 01:26:42,800
templates.

1967
01:26:42,800 --> 01:26:47,700
I always met of code that so, because metaprogramming is much more

1968
01:26:47,700 --> 01:26:48,700
powerful than templates.

1969
01:26:49,200 --> 01:26:51,900
So, basically templates is kind of an exercise in trying to figure out

1970
01:26:51,900 --> 01:26:54,000
how to do metaprogramming with a real weak sauce.

1971
01:26:54,200 --> 01:26:54,700
Right?

1972
01:26:55,700 --> 01:26:58,500
You're, you know, you're trying to flavor a good burger with a real

1973
01:26:58,500 --> 01:26:59,300
weak sauce and

1974
01:26:59,400 --> 01:26:59,600
and,

1975
01:27:00,000 --> 01:27:02,100
I feel like you should use good sauce on a good burger.

1976
01:27:12,400 --> 01:27:15,200
Will you write asset importers exporters to get the asset data into an

1977
01:27:15,200 --> 01:27:16,000
efficient format?

1978
01:27:16,000 --> 01:27:17,400
Or will you rely on the tools?

1979
01:27:17,400 --> 01:27:20,400
The asset creators used output, a raw style file?

1980
01:27:20,700 --> 01:27:22,000
We will be writing.

1981
01:27:22,100 --> 01:27:25,700
Well, I don't know if we'll write this or not because this is kind of

1982
01:27:25,700 --> 01:27:29,100
outside of the scope of what we're doing on handmade hero.

1983
01:27:29,800 --> 01:27:30,900
We might.

1984
01:27:30,900 --> 01:27:33,100
I mean, I don't guess there's really no reason not to so we because

1985
01:27:33,100 --> 01:27:34,300
it's not very much code.

1986
01:27:34,300 --> 01:27:37,700
But basically what we'll be doing is we'll be packing our data into a

1987
01:27:37,700 --> 01:27:38,400
single file.

1988
01:27:38,400 --> 01:27:41,500
Basically that's, you know, got all of our resources in the format

1989
01:27:41,500 --> 01:27:41,700
that we

1990
01:27:41,800 --> 01:27:46,000
I'm going to be so yeah, we probably won't ever directly.

1991
01:27:46,200 --> 01:27:49,500
We will never in the shipping version of the game directly, use asset

1992
01:27:49,500 --> 01:27:50,900
data, that came out of an art tool.

1993
01:28:00,200 --> 01:28:01,000
Let's see.

1994
01:28:02,400 --> 01:28:07,600
Easy twitch metaprogramming is, is C code to generate C, code is what

1995
01:28:07,600 --> 01:28:08,400
I'm talking about.

1996
01:28:08,400 --> 01:28:12,700
I almost always use C code to generate C code anytime that I would

1997
01:28:12,700 --> 01:28:14,700
have considered using a template.

1998
01:28:16,300 --> 01:28:19,300
Hey, we're at the end of the questions, right?

1999
01:28:19,300 --> 01:28:20,100
At 9:30.

2000
01:28:21,200 --> 01:28:22,800
That is got to be a good omen people.

2001
01:28:23,500 --> 01:28:25,700
Well, thank you so much for joining me for another episode of Hamming

2002
01:28:25,700 --> 01:28:25,900
here.

2003
01:28:25,900 --> 01:28:27,300
It's been a pleasure programming with you.

2004
01:28:27,300 --> 01:28:32,700
As always, we did our bitmap loading tonight, but unfortunately we

2005
01:28:32,700 --> 01:28:35,200
didn't have any time left in the Stream to actually put it up on the

2006
01:28:35,200 --> 01:28:35,800
screen.

2007
01:28:36,200 --> 01:28:38,800
So please join me tomorrow at 8 p.m.

2008
01:28:38,800 --> 01:28:40,700
PST, it p.m.

2009
01:28:40,700 --> 01:28:44,500
Pacific Standard time when we will go ahead and put our stuff up to

2010
01:28:44,500 --> 01:28:44,800
the screen.

2011
01:28:44,800 --> 01:28:46,000
And then that will finally give us.

2012
01:28:46,700 --> 01:28:50,100
Graphics, we can start using to start playing around with what the

2013
01:28:50,100 --> 01:28:53,500
game is going to look like in terms of, you know, how do we, how do we

2014
01:28:53,500 --> 01:28:56,400
structure our map screens to actually look good?

2015
01:28:56,500 --> 01:29:01,100
How do we have sort of, how do we deal with all of that sort of stuff

2016
01:29:01,100 --> 01:29:03,400
that comes with trying to make a good-looking game?

2017
01:29:03,400 --> 01:29:06,700
Instead of a just a straightforward, tilemap kind of scenario.

2018
01:29:07,300 --> 01:29:10,000
So I am very much looking forward to that and I hope you are too.

2019
01:29:10,000 --> 01:29:11,500
So, please join me tomorrow.

2020
01:29:12,300 --> 01:29:13,000
Right here.

2021
01:29:13,000 --> 01:29:16,100
Same time, same place if you would like to

2022
01:29:16,200 --> 01:29:20,400
You preorder the game you can do so you can do.

2023
01:29:20,400 --> 01:29:23,600
So right here on handmade or hero dot-org.

2024
01:29:23,700 --> 01:29:26,300
You can pre-order the game and you will get all of the source code

2025
01:29:26,300 --> 01:29:27,900
that you see us working on every night.

2026
01:29:27,900 --> 01:29:28,700
I update it.

2027
01:29:29,000 --> 01:29:33,200
And I always starting today was the first time, but going forwards,

2028
01:29:33,400 --> 01:29:33,900
any time.

2029
01:29:33,900 --> 01:29:37,300
I'm using resources to develop stuff on the stream.

2030
01:29:37,300 --> 01:29:40,000
I will also put those up there so you can completely.

2031
01:29:40,000 --> 01:29:41,700
If you are someone who pre-order the game, you could always

2032
01:29:41,700 --> 01:29:45,300
completely, follow along with everything I do at home and then play

2033
01:29:45,300 --> 01:29:46,000
around with it yourself.

2034
01:29:46,200 --> 01:29:47,300
And that's really important, too.

2035
01:29:47,300 --> 01:29:50,000
Because one of the best ways to learn game programming is to play with

2036
01:29:50,000 --> 01:29:50,800
game code.

2037
01:29:50,900 --> 01:29:53,600
And so, I highly recommend that anyone who's interested in learning

2038
01:29:54,700 --> 01:29:57,900
does take the time outside of the stream to kind of play around with

2039
01:29:57,900 --> 01:29:59,600
what we've been doing experiment.

2040
01:29:59,600 --> 01:29:59,800
Learn.

2041
01:30:00,000 --> 01:30:02,700
Self and kind of, you know, maybe try to do some things that I haven't

2042
01:30:02,700 --> 01:30:03,400
done yet.

2043
01:30:03,700 --> 01:30:08,100
Just kind of get familiar with with programming sort of this low-level

2044
01:30:08,100 --> 01:30:10,400
stuff and it's usually a very rewarding experience.

2045
01:30:10,400 --> 01:30:12,600
That's my that's what I found.

2046
01:30:13,100 --> 01:30:16,300
So yeah, I highly recommend that and also if you would like to support

2047
01:30:16,300 --> 01:30:19,700
the video series, just just separately, we have a patreon that you can

2048
01:30:19,700 --> 01:30:23,000
subscribe to and if you're trying to study at home, we have a news and

2049
01:30:23,000 --> 01:30:23,400
Forum site.

2050
01:30:23,400 --> 01:30:25,000
That's really good for that sort of thing.

2051
01:30:25,000 --> 01:30:26,400
If you go here, it's got the schedule.

2052
01:30:26,500 --> 01:30:29,800
It's got an episode guide, that's got sort of annotated videos to help

2053
01:30:29,800 --> 01:30:29,900
you.

2054
01:30:30,000 --> 01:30:32,500
You catch up on previous videos, that you may have missed.

2055
01:30:32,800 --> 01:30:35,900
It's got a coding resources page, which has ports, like people have

2056
01:30:35,900 --> 01:30:37,400
done ports to Linux and mac and so on.

2057
01:30:37,400 --> 01:30:40,300
So if you're trying to work on a different platform than I'm working

2058
01:30:40,300 --> 01:30:42,000
on, if you're trying to work on something, other than Windows, that's

2059
01:30:42,000 --> 01:30:45,400
a great place to go to find out how to do the stuff that we do in

2060
01:30:45,400 --> 01:30:47,100
Windows on those other platforms.

2061
01:30:47,100 --> 01:30:49,400
And finally there's a Code discussion page where you can go to post

2062
01:30:49,400 --> 01:30:52,700
questions or to talk about stuff that you've seen on the stream.

2063
01:30:53,000 --> 01:30:53,800
So definitely check it out.

2064
01:30:53,800 --> 01:30:56,000
If you're trying to learn from the series, that's a great place to go.

2065
01:30:56,000 --> 01:30:57,100
There's a lot of resources there.

2066
01:30:57,600 --> 01:30:58,800
So thank you everyone for joining me.

2067
01:30:58,800 --> 01:30:59,800
I hope to see you here tomorrow.

2068
01:31:00,100 --> 01:31:04,500
A'ight, have a good rest of the evening and a happy Tuesday.

