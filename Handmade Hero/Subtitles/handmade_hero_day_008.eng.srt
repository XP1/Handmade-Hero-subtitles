1
00:00:00,000 --> 00:00:02,700
Recording there and there we go.

2
00:00:04,200 --> 00:00:08,200
Okay, everyone, welcome to day.

3
00:00:08,200 --> 00:00:10,100
8 of handmade hero.

4
00:00:10,300 --> 00:00:13,000
We are on holiday time today, Wednesday, Thursday.

5
00:00:13,000 --> 00:00:14,400
Friday is going to be at 11 a.m.

6
00:00:14,400 --> 00:00:16,200
Due to the Thanksgiving holiday here.

7
00:00:16,800 --> 00:00:21,300
And I would like to to give a warm welcome to all the folks in Europe

8
00:00:21,300 --> 00:00:24,600
who are joining us today for the first time because we are finally at

9
00:00:24,600 --> 00:00:26,400
a time where they can easily tune in.

10
00:00:26,900 --> 00:00:29,300
I think someone said it was about 8 p.m.

11
00:00:29,300 --> 00:00:30,400
In Germany right now.

12
00:00:30,500 --> 00:00:31,300
Not sure if that's right.

13
00:00:31,300 --> 00:00:32,100
That sounds good.

14
00:00:34,300 --> 00:00:34,600
Thank you.

15
00:00:34,600 --> 00:00:35,800
Everyone, for joining us.

16
00:00:35,800 --> 00:00:37,300
This, of course is handmade hero.

17
00:00:38,800 --> 00:00:40,900
We are making a game from scratch.

18
00:00:40,900 --> 00:00:43,600
And right now, we are working our way through the windows platform

19
00:00:43,600 --> 00:00:44,000
layer.

20
00:00:44,600 --> 00:00:46,900
If you would like to follow it home and you have pre-ordered, the

21
00:00:46,900 --> 00:00:47,800
source code here.

22
00:00:48,100 --> 00:00:52,700
You will want to go into the zip file that you can download from the

23
00:00:52,700 --> 00:00:53,800
link that you got in your email.

24
00:00:53,800 --> 00:00:58,900
You can go ahead and unpack 007 from inside that zip and that is a

25
00:00:58,900 --> 00:01:00,300
source code that we are starting with today.

26
00:01:00,300 --> 00:01:03,700
So if you want to follow along home, that is what you're doing.

27
00:01:04,300 --> 00:01:07,900
Okay, I am going to go ahead and jump right back to where we

28
00:01:08,200 --> 00:01:09,300
Left off yesterday.

29
00:01:10,900 --> 00:01:13,700
I have one thing that I'll maybe talk about at the end of the stream

30
00:01:13,700 --> 00:01:17,400
that came in as an email, again, dealing with direct input, but I'm

31
00:01:17,400 --> 00:01:18,600
going to say that to the Q&A for.

32
00:01:18,600 --> 00:01:18,800
Now.

33
00:01:18,800 --> 00:01:20,000
I'm just going to jump right in here.

34
00:01:20,300 --> 00:01:22,300
So I'm going to launch our trusty emacs.

35
00:01:22,300 --> 00:01:25,200
A lot of people have been amusingly getting into e Max.

36
00:01:25,400 --> 00:01:28,500
I think I specifically said it's too old of an Editor to start

37
00:01:28,500 --> 00:01:28,700
learning.

38
00:01:28,700 --> 00:01:31,400
Now, try to find something else, but people have been having Jeff

39
00:01:31,400 --> 00:01:31,600
gone.

40
00:01:31,600 --> 00:01:34,300
Anyway, and that's pretty, pretty hilarious TMax the editor.

41
00:01:34,300 --> 00:01:35,500
That won't die people.

42
00:01:35,800 --> 00:01:38,000
Anyway, I'm going to open up emacs here and we're going to take

43
00:01:38,100 --> 00:01:39,000
A look at where we left off.

44
00:01:39,000 --> 00:01:41,900
Basically, what we did yesterday, is we wrote this in it D, sound

45
00:01:41,900 --> 00:01:42,300
function.

46
00:01:42,900 --> 00:01:44,700
And you can take a look at it here.

47
00:01:44,700 --> 00:01:46,000
It's very simple.

48
00:01:46,000 --> 00:01:49,300
Basically, what we do is we load direct sound directly.

49
00:01:49,300 --> 00:01:54,900
We get a pointer to a single function and that single function is a

50
00:01:54,900 --> 00:01:58,400
function that we call to basically give us back an object.

51
00:01:58,400 --> 00:02:02,200
So this is basically C++ linkage.

52
00:02:02,200 --> 00:02:07,100
It's calm, which is Windows, is sort of implementation of C++ across

53
00:02:07,100 --> 00:02:08,000
the dll boundary.

54
00:02:08,000 --> 00:02:11,200
But basically what happens is we are just calling a function and it is

55
00:02:11,200 --> 00:02:12,800
giving us back an object.

56
00:02:13,000 --> 00:02:16,500
That we can use to call for other functions on that literally does

57
00:02:16,500 --> 00:02:20,300
mean that we are essentially getting back an object with a vtable.

58
00:02:20,600 --> 00:02:20,800
Now.

59
00:02:20,800 --> 00:02:24,700
We are not really going to be covering C++ very explicitly on this

60
00:02:24,700 --> 00:02:27,700
stream, but I will simply mention what this is for.

61
00:02:27,700 --> 00:02:30,100
Those of you who are wondering how this all works with this little

62
00:02:30,100 --> 00:02:30,800
arrow here.

63
00:02:31,100 --> 00:02:33,700
I think it's worth explaining now that we've kind of got the code

64
00:02:33,700 --> 00:02:34,500
working from yesterday.

65
00:02:34,500 --> 00:02:35,900
It's worth explaining how this works.

66
00:02:36,100 --> 00:02:40,300
So normally, if I have something like this, where I type in a struct

67
00:02:40,300 --> 00:02:42,700
like that, basically, we saw

68
00:02:42,900 --> 00:02:45,800
Saw in the intro to see stream and in this stream as well.

69
00:02:45,800 --> 00:02:49,200
We saw that basically what that does is that tells the compiler to lay

70
00:02:49,200 --> 00:02:50,800
out a particular piece of memory.

71
00:02:50,800 --> 00:02:55,000
So that the the things that are in the struct basically come together,

72
00:02:55,100 --> 00:02:57,300
possibly, with some padding in between them and basically, in the

73
00:02:57,300 --> 00:02:59,800
order in which they occur and in the sizes that they occur.

74
00:03:00,400 --> 00:03:05,000
So if I do something like this, I will end up with 32-bit x value in a

75
00:03:05,000 --> 00:03:06,300
16-bit y value.

76
00:03:06,300 --> 00:03:08,000
Anytime I ask for one of these.

77
00:03:08,000 --> 00:03:11,900
So if later, I declare one of them, I basically get the X, and the Y

78
00:03:11,900 --> 00:03:12,300
value.

79
00:03:12,300 --> 00:03:13,800
Now that is, what is in memory.

80
00:03:14,300 --> 00:03:17,300
But C++ allows you to do some extra things.

81
00:03:17,400 --> 00:03:20,300
You can do something called a virtual function declaration, which we

82
00:03:20,300 --> 00:03:23,300
will not be using in the Stream, but you can do it.

83
00:03:23,400 --> 00:03:23,800
Basically.

84
00:03:23,800 --> 00:03:27,800
What it is is you declare some function just like any other function

85
00:03:27,800 --> 00:03:29,700
you might declare but basically what

86
00:03:30,000 --> 00:03:30,400
opens is

87
00:03:31,900 --> 00:03:36,600
Instead of actually just hard-coding calls to that function.

88
00:03:36,600 --> 00:03:39,900
So if later, you know, we were somewhere and we had one of these few

89
00:03:39,900 --> 00:03:41,200
objects, right?

90
00:03:41,500 --> 00:03:43,500
We would call it as if it was a method.

91
00:03:43,500 --> 00:03:47,300
We'd put the dot on there and we'd actually call it like this.

92
00:03:47,500 --> 00:03:49,600
It's just like any other function call at first.

93
00:03:49,700 --> 00:03:50,900
It looks the same right?

94
00:03:50,900 --> 00:03:53,200
You can pass parameters to it this sort of thing.

95
00:03:53,300 --> 00:03:54,500
That's exactly what happens.

96
00:03:54,800 --> 00:03:56,900
But there is a catch.

97
00:03:57,200 --> 00:03:59,900
If you were to just do this, there'd be no difference, really between

98
00:03:59,900 --> 00:04:00,500
it and a normal.

99
00:04:00,800 --> 00:04:02,100
Ocean be exactly the same.

100
00:04:02,100 --> 00:04:04,400
The only difference is actually syntactic.

101
00:04:04,600 --> 00:04:07,200
So basically, if I actually this is this is how I'm again.

102
00:04:07,200 --> 00:04:09,300
I'm I'm going to speed through this because we're not going to be

103
00:04:09,300 --> 00:04:09,700
using them.

104
00:04:09,700 --> 00:04:11,600
I just want you to kind of understand what's going on.

105
00:04:11,900 --> 00:04:13,400
So this is how you would declare it.

106
00:04:13,400 --> 00:04:16,000
Basically, it's the exact same function, declaration that you've seen.

107
00:04:16,000 --> 00:04:16,500
Everywhere else.

108
00:04:16,500 --> 00:04:17,700
I should say function definition.

109
00:04:17,700 --> 00:04:20,899
You've seen everywhere else, but you put this Foo colon colon prefix

110
00:04:20,899 --> 00:04:23,200
on it, which basically is what's called a scoping.

111
00:04:24,300 --> 00:04:27,700
It's called scoping and C++ or the scoping operator.

112
00:04:27,700 --> 00:04:30,700
Basically what it says is this bar is not

113
00:04:30,800 --> 00:04:32,900
Actually just a function at file scope.

114
00:04:32,900 --> 00:04:36,100
It's actually a function that's declared inside this Foo object and

115
00:04:36,100 --> 00:04:37,500
from in, so you can't just call it.

116
00:04:37,500 --> 00:04:39,100
You can't call the function like this.

117
00:04:39,100 --> 00:04:43,300
You gotta call it off of one of those one of those foods and what

118
00:04:43,300 --> 00:04:47,200
actually happens is in this, the compiler implicitly actually

119
00:04:47,200 --> 00:04:47,800
rewrites.

120
00:04:47,800 --> 00:04:51,300
The way, the function is under the hood, you won't see it do this, but

121
00:04:51,300 --> 00:04:51,900
it'll do it.

122
00:04:51,900 --> 00:04:57,100
It'll basically insert a fence that synthetic parameter here called

123
00:04:57,100 --> 00:04:57,800
the this pointer.

124
00:04:57,800 --> 00:05:00,500
And the this pointer will be basically used as an

125
00:05:00,800 --> 00:05:05,000
illicit way to reference anything that happens in the function.

126
00:05:06,500 --> 00:05:10,100
So, inside this function, if I were to reference see I can just

127
00:05:10,100 --> 00:05:10,500
reference.

128
00:05:10,500 --> 00:05:11,800
See, if I were to clear a new variable.

129
00:05:11,800 --> 00:05:12,900
I can declare a new variable.

130
00:05:12,900 --> 00:05:16,400
It works just like any other function, but if I were to reference X

131
00:05:16,400 --> 00:05:20,800
say, for example, C plus equals x, normally X would be undefined here.

132
00:05:20,800 --> 00:05:22,400
There would be no way of the compiler.

133
00:05:22,400 --> 00:05:26,000
Resolving what X-Men you would say that was undefined and it would ask

134
00:05:26,000 --> 00:05:30,400
you to defy it but in our case that was not true because that this

135
00:05:30,400 --> 00:05:32,000
pointer that gets implicitly past year.

136
00:05:32,000 --> 00:05:32,600
This thing.

137
00:05:33,200 --> 00:05:35,700
Basically it will check to see first whether it could

138
00:05:35,800 --> 00:05:38,400
Could have reference something inside that this pointer.

139
00:05:38,400 --> 00:05:40,200
And in this case, there is an X there.

140
00:05:40,200 --> 00:05:44,300
So this gets turned by the compiler into that automatically for you.

141
00:05:44,800 --> 00:05:47,500
That is the only real difference in these functions.

142
00:05:47,500 --> 00:05:51,700
Basically, it allows you to sort of have this free sort of look up

143
00:05:51,800 --> 00:05:53,900
that you wouldn't otherwise have and there are some other things that

144
00:05:53,900 --> 00:05:57,200
I'm not going to go into their totally against syntactic and basically

145
00:05:57,200 --> 00:05:59,800
features that about C++ that we won't be using.

146
00:06:00,000 --> 00:06:04,300
But the thing that I wanted to talk about more explicitly in that

147
00:06:04,500 --> 00:06:08,800
bears understanding or it's worth understanding in order to understand

148
00:06:08,800 --> 00:06:12,000
what's happening with direct sound here and calm interfaces in general

149
00:06:12,000 --> 00:06:12,700
and windows.

150
00:06:13,100 --> 00:06:14,600
Again, cam is Comm.

151
00:06:14,800 --> 00:06:18,400
It stands for component object model.

152
00:06:18,500 --> 00:06:21,500
If you would like to look that up again, we won't really be covering

153
00:06:21,500 --> 00:06:23,900
in detail here because it's not really relevant to us, but it is what

154
00:06:23,900 --> 00:06:25,300
we are calling through at the moment.

155
00:06:25,900 --> 00:06:28,900
Basically, what happens here is I can declare this function virtual

156
00:06:29,600 --> 00:06:32,100
and what that means is that it's actually more complicated than a

157
00:06:32,100 --> 00:06:32,900
regular function.

158
00:06:34,200 --> 00:06:37,800
It is not just a syntactic thing where it's inserting a little fake

159
00:06:37,800 --> 00:06:38,600
parameter for us.

160
00:06:39,400 --> 00:06:40,300
There's more than that.

161
00:06:40,500 --> 00:06:44,200
What this will cause the compiler to do this virtual function is it

162
00:06:44,200 --> 00:06:48,000
will cause it to insert, basically, up here, it will insert what's

163
00:06:48,000 --> 00:06:49,400
called a v table pointer.

164
00:06:50,000 --> 00:06:53,400
And basically, what a vtable pointer is is outside, here.

165
00:06:53,700 --> 00:06:57,100
There will basically be the compiler, will declare this globally.

166
00:06:57,300 --> 00:06:59,500
It will declare a vtable for Foo.

167
00:06:59,600 --> 00:07:03,500
A vtable is basically something that contains a bunch of functions.

168
00:07:03,700 --> 00:07:04,000
Turner's.

169
00:07:04,400 --> 00:07:07,800
It's basically got pointers to the functions that should be called

170
00:07:08,300 --> 00:07:12,000
when you are using a foo and basically what happens from now on is

171
00:07:12,000 --> 00:07:14,900
when you do this food bar, instead of just putting out the code for an

172
00:07:14,900 --> 00:07:15,700
actual function call.

173
00:07:15,700 --> 00:07:17,900
What it does is it looks up in this table.

174
00:07:18,100 --> 00:07:23,200
So first, it'll do look up bar in the vtable for Foo using the

175
00:07:23,200 --> 00:07:23,500
pointer.

176
00:07:23,500 --> 00:07:28,500
So, using Fu's vtable, actually, literally going and looking into the

177
00:07:28,500 --> 00:07:28,900
table.

178
00:07:28,900 --> 00:07:31,200
So it gets the pointer out of the top of Foo, the one that the

179
00:07:31,200 --> 00:07:33,400
compiler silently inserted, without telling you,

180
00:07:33,600 --> 00:07:34,100
About it.

181
00:07:34,100 --> 00:07:35,500
It just silently inserted that pointer.

182
00:07:35,600 --> 00:07:37,200
It'll go look at foofy table.

183
00:07:37,400 --> 00:07:42,300
Eat a look at the index in the vtable to which bar corresponds and it

184
00:07:42,300 --> 00:07:44,100
will then jump to that address.

185
00:07:44,400 --> 00:07:47,600
So if you remember, we basically did this sort of stuff up here

186
00:07:47,600 --> 00:07:48,300
ourselves.

187
00:07:48,500 --> 00:07:51,700
We declared our own function pointers, we made our own function

188
00:07:51,700 --> 00:07:55,800
pointer and called through them for the xinput stuff xinput, get State

189
00:07:55,900 --> 00:07:58,500
and, and so basically that is exactly what it's doing here.

190
00:07:58,500 --> 00:08:03,500
But instead of having a global pointer, it actually has a global

191
00:08:03,600 --> 00:08:08,500
Table and each, it has several Global tables one for each struct that

192
00:08:08,500 --> 00:08:09,800
uses virtual functions.

193
00:08:10,200 --> 00:08:14,700
Basically, what it does is it will actually look at the the structure

194
00:08:14,700 --> 00:08:16,400
to find the pointer to the table.

195
00:08:16,400 --> 00:08:19,200
Look up the pointer to the function, in that table.

196
00:08:19,200 --> 00:08:20,700
It's this W directed thing.

197
00:08:20,900 --> 00:08:24,100
And finally, it will dispatch if it sounds like a lot of extra work.

198
00:08:24,100 --> 00:08:27,700
It is one of the reasons that C++ virtual functions are not fabulous

199
00:08:27,700 --> 00:08:30,400
is they do hit that double in Direction, which is not a very good

200
00:08:30,400 --> 00:08:30,900
thing.

201
00:08:31,000 --> 00:08:33,400
It cost you some performance every time often.

202
00:08:33,600 --> 00:08:35,700
It depends how good the compiler is and CPU.

203
00:08:35,700 --> 00:08:36,400
Is it handling them?

204
00:08:36,400 --> 00:08:36,700
Certainly?

205
00:08:36,700 --> 00:08:40,700
So the cost may vary, but it is definitely a lot different than

206
00:08:40,700 --> 00:08:41,799
calling just a regular function.

207
00:08:41,799 --> 00:08:43,900
It is not a zero cost abstraction as they say.

208
00:08:43,900 --> 00:08:47,800
Anyway, point being, that is actually what we are.

209
00:08:47,800 --> 00:08:51,500
Getting back from this direct sound call.

210
00:08:51,500 --> 00:08:54,300
So back here, when we ask for direct sound, create.

211
00:08:54,300 --> 00:08:54,700
Basically.

212
00:08:54,700 --> 00:08:59,200
We're calling direct sound create and direct sound, create is going to

213
00:08:59,200 --> 00:08:59,800
give us back a

214
00:09:00,000 --> 00:09:01,300
Checked with that V table in it.

215
00:09:01,300 --> 00:09:03,600
So you'll notice we don't have to ask.

216
00:09:03,600 --> 00:09:06,800
We don't have to use get proc address to get the rest of the

217
00:09:06,800 --> 00:09:07,100
functions.

218
00:09:07,100 --> 00:09:08,300
We're going to call instead.

219
00:09:08,300 --> 00:09:11,600
We're just calling them off of the actual object that we got back.

220
00:09:11,700 --> 00:09:16,200
And basically the vtable that is in that object is the thing.

221
00:09:16,600 --> 00:09:19,400
That is actually allowing us to get to these other functions.

222
00:09:19,400 --> 00:09:21,000
And just to be a little more explicit.

223
00:09:21,100 --> 00:09:23,800
You might say, well, where is that vtable in memory?

224
00:09:23,900 --> 00:09:27,900
Well, the vtable got mapped into memory when we loaded the dll, so the

225
00:09:27,900 --> 00:09:29,800
dll itself had the vtable in it.

226
00:09:30,000 --> 00:09:34,100
It when it got loaded, we are actually pointing to when we get back

227
00:09:34,100 --> 00:09:38,400
our handle to the struct, or I should say, the, the direct sound

228
00:09:38,400 --> 00:09:38,900
object.

229
00:09:38,900 --> 00:09:41,400
Since we're, you know, whether it's a struct or class, who knows?

230
00:09:41,400 --> 00:09:42,000
How they declared it.

231
00:09:42,000 --> 00:09:46,000
Internally doesn't matter for our purposes at all struck.

232
00:09:46,000 --> 00:09:47,500
Some classes are the same.

233
00:09:48,100 --> 00:09:51,900
Anyway point being when we get back that handle to the direct sound.

234
00:09:52,000 --> 00:09:54,900
It basically has a pointer to a v table that is inside the direct

235
00:09:54,900 --> 00:09:55,700
sound dll.

236
00:09:55,700 --> 00:09:58,200
And we will basically just be calling through that jump table.

237
00:09:58,500 --> 00:09:59,900
So every time we make a call to

238
00:10:00,000 --> 00:10:00,500
Up in there.

239
00:10:00,500 --> 00:10:01,700
It'll grab out that thing.

240
00:10:01,900 --> 00:10:03,300
And, and there, it'll go.

241
00:10:03,500 --> 00:10:06,400
And, you know, we can even if you if you want to.

242
00:10:06,700 --> 00:10:07,900
I got to save my file.

243
00:10:08,300 --> 00:10:11,700
If you want to we can go ahead and even take a look at that happening.

244
00:10:11,700 --> 00:10:17,800
If I open up the the debugger here, again, everything gets translated

245
00:10:17,800 --> 00:10:21,300
to CPU, doesn't matter what language you program in the CPU, has to do

246
00:10:21,300 --> 00:10:21,900
everything.

247
00:10:22,100 --> 00:10:24,600
So no matter how fancy stuff looks in a language.

248
00:10:25,000 --> 00:10:28,400
Basically, you are always going to end up having to have the CPU, do,

249
00:10:28,400 --> 00:10:29,800
whatever work is necessary to have.

250
00:10:29,900 --> 00:10:33,100
Have that happen languages make things sometimes simpler for the

251
00:10:33,100 --> 00:10:33,600
programmer.

252
00:10:33,600 --> 00:10:37,100
They do not make things a simpler for the CPU, that is just how that

253
00:10:37,100 --> 00:10:37,500
works.

254
00:10:37,800 --> 00:10:40,100
So basically, you can you could take a look at this here.

255
00:10:41,600 --> 00:10:42,400
Let's see here.

256
00:10:42,600 --> 00:10:46,700
So you'll notice this is the Assembly Language for this call, and you

257
00:10:46,700 --> 00:10:48,000
will notice right here.

258
00:10:48,200 --> 00:10:49,800
This is the part that we're looking at.

259
00:10:49,900 --> 00:10:54,900
So normally normally, when we call a function, I'll just show you

260
00:10:54,900 --> 00:10:57,800
another example here actually a just to make it a little clearer.

261
00:10:58,200 --> 00:10:59,800
So normally if we went down here,

262
00:11:00,200 --> 00:11:02,900
Let's look at a function that we were actually you know that we had

263
00:11:02,900 --> 00:11:04,400
implemented ourselves, right?

264
00:11:04,400 --> 00:11:06,400
This is a function that we had implemented ourselves.

265
00:11:06,600 --> 00:11:10,300
So if I go ahead and I go to the disassembly here, you will notice

266
00:11:10,300 --> 00:11:13,900
that basically what gets outputted is essentially a direct call to the

267
00:11:13,900 --> 00:11:15,100
address of that function.

268
00:11:15,400 --> 00:11:18,900
And what basically happened was the Linker when it linked us up.

269
00:11:19,100 --> 00:11:21,900
It basically said, look that is where the function is.

270
00:11:22,300 --> 00:11:25,500
So that is the at the address, I'm going to output and the call is

271
00:11:25,500 --> 00:11:27,400
just a direct call to a constant address.

272
00:11:27,500 --> 00:11:28,300
That's what happens.

273
00:11:28,300 --> 00:11:29,700
There's nothing fancy going on.

274
00:11:29,900 --> 00:11:31,100
And it's one thing.

275
00:11:31,100 --> 00:11:32,300
When we call into it.

276
00:11:32,400 --> 00:11:33,600
Then we're in the function.

277
00:11:33,600 --> 00:11:34,200
That's it.

278
00:11:34,300 --> 00:11:34,700
Right.

279
00:11:34,700 --> 00:11:35,500
That's what happens.

280
00:11:35,900 --> 00:11:37,400
Now, in C++.

281
00:11:37,400 --> 00:11:39,100
Every time you use a virtual function.

282
00:11:39,100 --> 00:11:41,500
You are basically incurring more overhead than that.

283
00:11:41,700 --> 00:11:45,500
What you are actually doing is you are going in here and you can see

284
00:11:45,500 --> 00:11:47,100
that this is the call site.

285
00:11:47,100 --> 00:11:49,200
This is the place where we're actually going to call that set

286
00:11:49,200 --> 00:11:50,100
Cooperative level.

287
00:11:50,300 --> 00:11:53,100
And as you can see, it cannot insert an actual address.

288
00:11:53,200 --> 00:11:56,900
It has to basically insert a call to an address that it loads.

289
00:11:59,400 --> 00:11:59,900
and you can,

290
00:12:00,000 --> 00:12:01,800
That happening right here.

291
00:12:01,800 --> 00:12:04,500
Basically, you can see that it moving into our ax.

292
00:12:04,700 --> 00:12:07,300
It's basically getting the vtable pointer.

293
00:12:07,300 --> 00:12:08,700
It's loading in that function.

294
00:12:08,800 --> 00:12:10,900
This is doing the pushes for the actual.

295
00:12:12,200 --> 00:12:15,400
I think the the actual parameters and stuff and that we want, but this

296
00:12:15,400 --> 00:12:18,500
is actually doing call off of our ax which got loaded up here.

297
00:12:18,500 --> 00:12:19,300
So you can see that.

298
00:12:19,300 --> 00:12:22,000
It's actually doing work to load something in first.

299
00:12:22,000 --> 00:12:26,800
It's loading off the RSP then it's going ahead and actually loading

300
00:12:26,800 --> 00:12:28,500
off of that which is the double indirection.

301
00:12:28,500 --> 00:12:29,800
Like I said, it's loading a pointer.

302
00:12:30,000 --> 00:12:33,800
And then loading a pointer off the pointer, excuse me.

303
00:12:34,200 --> 00:12:38,500
And then finally, it's calling one more in Direction.

304
00:12:38,800 --> 00:12:40,100
It's basically calling.

305
00:12:40,500 --> 00:12:42,500
Yeah, I mean to be more explicit.

306
00:12:42,600 --> 00:12:44,300
It's loading in the direct sound.

307
00:12:44,400 --> 00:12:46,400
It's loading the V table pointer out of the direct sound.

308
00:12:46,400 --> 00:12:49,900
Then it's loading the, the actual address out of that V table because

309
00:12:49,900 --> 00:12:51,000
it knows this is the address.

310
00:12:51,000 --> 00:12:51,600
I believe.

311
00:12:51,800 --> 00:12:54,300
I'm not the best person at at Assembly Language.

312
00:12:54,400 --> 00:12:57,000
I've never written a compiler that output C++ Assembly Language.

313
00:12:57,000 --> 00:12:59,900
So I'm just basically assuming that this is roughly

314
00:13:00,000 --> 00:13:00,800
What it has to do.

315
00:13:00,900 --> 00:13:03,200
Now, maybe if we were in optimized mode, it could get this a little

316
00:13:03,200 --> 00:13:04,500
simpler, something like that.

317
00:13:04,600 --> 00:13:06,200
But basically that is the idea.

318
00:13:06,200 --> 00:13:08,000
So you got to load the pointer to the object.

319
00:13:08,000 --> 00:13:09,200
You got a little, the point of the V table.

320
00:13:09,200 --> 00:13:10,700
Then you got to load the function pointer out of that.

321
00:13:10,700 --> 00:13:13,800
And finally, you can go ahead and call it.

322
00:13:13,800 --> 00:13:15,300
So that's what's going on there.

323
00:13:15,700 --> 00:13:16,500
That makes sense.

324
00:13:16,500 --> 00:13:17,800
Hopefully, that's clear to everyone.

325
00:13:18,000 --> 00:13:20,000
It's not particularly complicated and you don't really have to

326
00:13:20,000 --> 00:13:22,700
understand it because we are not going to be using anything like that

327
00:13:22,700 --> 00:13:23,200
in our code.

328
00:13:23,200 --> 00:13:23,700
But

329
00:13:25,500 --> 00:13:29,200
That is what happens in C++ and that is what happens in calm as well.

330
00:13:29,200 --> 00:13:31,700
So that's what's happening in here.

331
00:13:31,700 --> 00:13:32,200
We're getting back.

332
00:13:32,200 --> 00:13:36,800
One of those, we are basically at asking a direct sound for a handle

333
00:13:36,800 --> 00:13:39,300
to the primary buffer and that primary buffer.

334
00:13:39,400 --> 00:13:43,100
We are using to set the output format for our sound, which we set to

335
00:13:43,100 --> 00:13:50,300
be stereo two channels, 16 bits per sample, which is good and choose

336
00:13:50,300 --> 00:13:52,100
me again.

337
00:13:52,100 --> 00:13:52,300
Sorry.

338
00:13:52,300 --> 00:13:53,000
I'm so sick.

339
00:13:53,600 --> 00:13:55,100
And, and we are also saying,

340
00:13:55,400 --> 00:13:59,600
That we essentially want to be 48, khz audio, which I picked

341
00:13:59,600 --> 00:14:02,300
basically, because I think one time I asked Jeff Roberts who, of

342
00:14:02,300 --> 00:14:04,600
course, was the guy who maintain the mouth sound system for a very

343
00:14:04,600 --> 00:14:05,200
long time.

344
00:14:05,500 --> 00:14:11,100
What was the most common native format for sound output and he said 48

345
00:14:11,100 --> 00:14:12,400
kilohertz, so that's what I'm going with.

346
00:14:12,400 --> 00:14:14,100
But you could pick 44 one as well.

347
00:14:14,100 --> 00:14:16,800
Cd-quality audio, you know, that all sound card support that as well.

348
00:14:17,100 --> 00:14:18,200
Pretty much has to, I think

349
00:14:19,500 --> 00:14:21,500
There's just a question whether they Read sample it or what they do to

350
00:14:21,500 --> 00:14:21,800
it.

351
00:14:22,300 --> 00:14:24,800
So anyway, we then open our own buffer here.

352
00:14:24,900 --> 00:14:26,700
And that is what we're going to talk about right now.

353
00:14:26,800 --> 00:14:29,900
We open a buffer called the secondary buffer, which is the buffer that

354
00:14:29,900 --> 00:14:31,000
we can actually write into.

355
00:14:31,000 --> 00:14:32,300
We can't write in the primary buffer.

356
00:14:32,300 --> 00:14:33,200
Those days are over.

357
00:14:33,600 --> 00:14:35,100
We have to write into the secondary buffer.

358
00:14:35,100 --> 00:14:36,500
That's the way that supposed to work now.

359
00:14:36,600 --> 00:14:39,500
And basically, the colonel will sort of take all the people who are

360
00:14:39,500 --> 00:14:42,300
writing a secondary buffers, mix them together and output them to the

361
00:14:42,300 --> 00:14:42,900
sound card.

362
00:14:43,000 --> 00:14:45,900
We no longer get direct write privileges to the same card, kind of

363
00:14:45,900 --> 00:14:48,500
like, we no longer have direct right privilege to the graphics card.

364
00:14:48,500 --> 00:14:49,200
It all kind of gets.

365
00:14:49,300 --> 00:14:53,200
Admitted, you know, kind of mitigated it all goes through windows.

366
00:14:53,200 --> 00:14:54,400
I guess we use something like mantel.

367
00:14:54,400 --> 00:14:56,500
Maybe you can, but assuming that you're going through the window

368
00:14:56,500 --> 00:14:58,500
standard apis, you don't get direct access anymore.

369
00:14:58,500 --> 00:14:59,400
It's just not how it works.

370
00:15:01,200 --> 00:15:05,000
In here, what we basically want to do is we want to keep this buffer

371
00:15:05,000 --> 00:15:06,000
pointer around.

372
00:15:06,100 --> 00:15:10,200
This is basically the thing that we're going to use all the time to

373
00:15:11,000 --> 00:15:11,900
write to the sound buffer.

374
00:15:11,900 --> 00:15:15,200
So I'm going to basically Elevate that out this secondary buffer.

375
00:15:15,300 --> 00:15:17,800
I'm going to elevate that out to our Global's again.

376
00:15:17,800 --> 00:15:20,300
I'm not sure that that's going to stay there necessarily because like

377
00:15:20,300 --> 00:15:23,700
I said, I don't like to have too many Global variables in a platform

378
00:15:23,700 --> 00:15:23,900
layer.

379
00:15:23,900 --> 00:15:27,300
It's usually not that big a deal actually because you're kind of

380
00:15:27,300 --> 00:15:29,800
really isolated in the code here and you kind of have looked at it all

381
00:15:29,800 --> 00:15:30,600
it's not that big a deal.

382
00:15:30,700 --> 00:15:33,600
But at the same time, you always want to be aware of it because a

383
00:15:33,600 --> 00:15:36,100
global variable is something that anyone can modify and sometimes that

384
00:15:36,100 --> 00:15:37,700
creates a little bit of a stringiness in your code.

385
00:15:37,700 --> 00:15:39,400
So be aware of what you make Global.

386
00:15:39,400 --> 00:15:40,400
Don't do it willy-nilly.

387
00:15:41,800 --> 00:15:44,400
Make sure you understand why it's Global and that it should say Global

388
00:15:44,400 --> 00:15:46,200
and that there's only going to be one of them and if any of those

389
00:15:46,200 --> 00:15:48,100
things aren't true, don't do it.

390
00:15:49,300 --> 00:15:49,600
All right.

391
00:15:49,600 --> 00:15:52,600
So we're going to actually create that that buffer globally here.

392
00:15:52,900 --> 00:15:55,500
And then once we get that buffer, we will be able to output sound from

393
00:15:55,500 --> 00:15:55,800
now on.

394
00:15:55,800 --> 00:15:57,200
So Dillard and output sound.

395
00:15:57,600 --> 00:15:59,600
Basically, I'm going to do something, extremely simple.

396
00:15:59,900 --> 00:16:04,000
I am just going to ask where the right pointer is and I am going to

397
00:16:04,000 --> 00:16:09,200
fill in some memory with with the sound and now sound is a little bit,

398
00:16:09,400 --> 00:16:10,300
is a little bit wonky.

399
00:16:10,300 --> 00:16:12,300
Certainly, it's good question.

400
00:16:12,300 --> 00:16:15,000
What we're going to put in there for not loading anything yet because

401
00:16:15,000 --> 00:16:18,000
I wanted to wait for, you know, I want to I'm going to show you how to

402
00:16:18,000 --> 00:16:18,900
load wav files later.

403
00:16:19,100 --> 00:16:20,800
We will play sound but to get something working.

404
00:16:20,800 --> 00:16:21,500
First off.

405
00:16:21,500 --> 00:16:24,900
I think I'm going to use a good old Square wave, something like that

406
00:16:25,100 --> 00:16:26,300
so that we can just hear.

407
00:16:26,500 --> 00:16:30,200
It's going to be an awful sound certainly, but if we take a look here,

408
00:16:30,200 --> 00:16:32,900
you can see basically we have a square wave.

409
00:16:33,000 --> 00:16:36,400
It's got a pretty reasonable graph here.

410
00:16:36,400 --> 00:16:38,900
These are the basic kinds of waves that you can output that are, you

411
00:16:38,900 --> 00:16:40,300
know, really simple decode.

412
00:16:40,300 --> 00:16:40,600
Obviously.

413
00:16:40,600 --> 00:16:41,600
There's a sine wave.

414
00:16:41,900 --> 00:16:42,700
There's a square wave.

415
00:16:42,700 --> 00:16:44,800
Triangle wave Sawtooth and they just look like this.

416
00:16:44,800 --> 00:16:47,000
You can see square is probably the simplest to code.

417
00:16:47,200 --> 00:16:48,900
All it is is just High.

418
00:16:49,000 --> 00:16:53,800
High signal, High positive signal, followed by a low- signal and

419
00:16:53,800 --> 00:16:54,700
nothing in between.

420
00:16:54,700 --> 00:16:59,400
So it's just full on just full-on oscillation like that, and that's

421
00:16:59,400 --> 00:16:59,900
about it.

422
00:16:59,900 --> 00:17:03,300
So I think, I think, basically that's all I'm going to try and dumped

423
00:17:03,300 --> 00:17:04,000
into this buffer.

424
00:17:04,200 --> 00:17:06,400
So basically we're in our Loop here, right?

425
00:17:06,700 --> 00:17:09,300
One of the things we do in our Loop is we, you know, we get the input.

426
00:17:09,300 --> 00:17:12,200
Then another thing we do is we render that weird gradient.

427
00:17:12,200 --> 00:17:15,700
So right here after the after the gradient, I'm going to go ahead and

428
00:17:15,700 --> 00:17:16,900
try to lock that buffer.

429
00:17:17,300 --> 00:17:18,800
So I'm going to go ahead.

430
00:17:19,099 --> 00:17:24,599
Do direct sound output test right here, just to see if we have

431
00:17:24,599 --> 00:17:25,300
anything working.

432
00:17:25,300 --> 00:17:26,700
Now, in order to do that.

433
00:17:26,700 --> 00:17:29,500
Basically, what we need to do is we need to lock that direct sound

434
00:17:29,500 --> 00:17:29,900
buffer.

435
00:17:30,400 --> 00:17:33,800
And so basically, if you remember from the help, we basically had to

436
00:17:33,800 --> 00:17:36,900
use the help for direct sound 8 because the old directsound help

437
00:17:36,900 --> 00:17:37,600
wasn't even there.

438
00:17:37,700 --> 00:17:40,700
It's probably fine to use direct sound date for any real purposes.

439
00:17:40,700 --> 00:17:44,400
Almost every modern machine I think is going to have direct sound

440
00:17:44,400 --> 00:17:44,600
eight.

441
00:17:44,600 --> 00:17:45,900
So I wouldn't worry about that too much.

442
00:17:45,900 --> 00:17:48,900
But most of the stuff works in the older API as well.

443
00:17:49,000 --> 00:17:51,400
So I was just calling the older version, which is direct sound seven,

444
00:17:51,400 --> 00:17:54,500
and prior Microsoft, doesn't even have a help for those posted

445
00:17:54,500 --> 00:17:54,900
anymore.

446
00:17:54,900 --> 00:17:59,600
But anyway, what we need to actually do is fill up the buffer.

447
00:18:00,100 --> 00:18:01,800
So we got to actually do a lock here.

448
00:18:01,800 --> 00:18:02,800
Where is our lock?

449
00:18:02,800 --> 00:18:05,300
There is our lock right there, where it don't they have?

450
00:18:05,900 --> 00:18:08,100
I need the I need the actual help here at people.

451
00:18:08,500 --> 00:18:10,100
I want to actually see the help.

452
00:18:10,300 --> 00:18:10,900
There it is.

453
00:18:11,000 --> 00:18:12,300
This is what we're talking about.

454
00:18:13,300 --> 00:18:15,200
So this is the function that I actually wanted.

455
00:18:15,600 --> 00:18:16,600
Basically it.

456
00:18:16,600 --> 00:18:17,300
What it does.

457
00:18:17,400 --> 00:18:23,800
If you remember, we are going to be doing circular buffer output and I

458
00:18:23,800 --> 00:18:26,200
drew a diagram about this yesterday.

459
00:18:26,200 --> 00:18:29,400
I'm going to draw a diagram about it today again, just to reinforce it

460
00:18:29,600 --> 00:18:29,800
the page.

461
00:18:30,000 --> 00:18:30,200
Really?

462
00:18:30,200 --> 00:18:30,900
What's Happening Here?

463
00:18:30,900 --> 00:18:34,500
Right is, we have a thing that looks like this.

464
00:18:34,500 --> 00:18:38,800
It's a buffer and we are going to write our sound into the buffer like

465
00:18:38,800 --> 00:18:40,200
this, right off.

466
00:18:40,200 --> 00:18:40,700
It goes.

467
00:18:40,800 --> 00:18:43,700
And basically, what happens here is direct sound will be playing this

468
00:18:43,700 --> 00:18:46,300
buffer and when it gets to the end of the buffer, it's going to loop

469
00:18:46,300 --> 00:18:47,500
back to the beginning.

470
00:18:47,600 --> 00:18:49,200
So just playing it over and over.

471
00:18:49,300 --> 00:18:51,600
So effectively you can think of this as a circular buffer.

472
00:18:51,700 --> 00:18:55,000
It's like the beginning of it was copied to the end, right?

473
00:18:55,000 --> 00:18:58,500
It just keeps going it's, you know, when it plays.

474
00:18:58,500 --> 00:18:59,800
So as it plays, it's going to kiss.

475
00:19:00,300 --> 00:19:01,500
Just keep going as it goes off.

476
00:19:01,500 --> 00:19:02,700
The end that makes sense.

477
00:19:03,400 --> 00:19:07,800
So what's going to happen here is we need to basically right into this

478
00:19:07,800 --> 00:19:08,400
buffer.

479
00:19:08,700 --> 00:19:12,100
And in order to write into this buffer, direct sound actually knows

480
00:19:12,100 --> 00:19:14,400
that you lot of times for using these a circular buffers.

481
00:19:14,500 --> 00:19:18,000
So it allows you to do is it allows you to lock a region by giving a

482
00:19:18,000 --> 00:19:21,100
pointer to the beginning, basically not a pointer, but basically an

483
00:19:21,100 --> 00:19:24,500
offset to say this is the place I want to start locking the buffer to

484
00:19:24,500 --> 00:19:27,700
write into because remember, this is a system buffer Windows wants to

485
00:19:27,700 --> 00:19:28,600
know when we're writing to it.

486
00:19:28,600 --> 00:19:29,700
So we need to basically issue a

487
00:19:29,900 --> 00:19:32,100
Lock call to say, we're about to write into this.

488
00:19:32,200 --> 00:19:35,000
So just so, you know, you're going to have to update it.

489
00:19:35,200 --> 00:19:39,900
So we locked it to right into this and it actually gives us back to

490
00:19:40,000 --> 00:19:41,500
potentially regions.

491
00:19:41,600 --> 00:19:44,900
So for example, when we lock this, we give it a size and maybe that

492
00:19:44,900 --> 00:19:47,100
size was this big, right?

493
00:19:47,100 --> 00:19:49,600
We say that's how many bytes we wanted to write into the buffer.

494
00:19:49,800 --> 00:19:53,200
So it needs to lock that big but it can't lock that big because

495
00:19:53,300 --> 00:19:55,200
obviously there's nothing out here, the buffer ends.

496
00:19:55,300 --> 00:19:59,800
So what it does is it takes this this sort of residual here this part

497
00:20:00,400 --> 00:20:04,200
And it locks the beginning of the buffer for however, much the overrun

498
00:20:04,200 --> 00:20:06,900
was so it basically gives us back to Regions.

499
00:20:07,100 --> 00:20:07,300
Right?

500
00:20:07,300 --> 00:20:11,200
It gives us back a one region here, where that's at the actual office

501
00:20:11,200 --> 00:20:13,300
that we asked for it and that goes to the end of the buffer

502
00:20:13,300 --> 00:20:16,100
potentially and one that starts the beginning of the buffer and then

503
00:20:16,100 --> 00:20:19,400
goes to wherever it would have been to make the buffer the size that

504
00:20:19,400 --> 00:20:20,200
we wanted.

505
00:20:20,200 --> 00:20:22,100
Now, that's doesn't have to happen.

506
00:20:22,100 --> 00:20:25,900
It can also be that if we gave it a pointer or rather an offset to

507
00:20:25,900 --> 00:20:28,700
somewhere in the buffer where it could lock the whole thing just in

508
00:20:28,700 --> 00:20:29,800
one place, right?

509
00:20:29,900 --> 00:20:31,200
And this is my little lock.

510
00:20:31,900 --> 00:20:32,600
How's that?

511
00:20:33,000 --> 00:20:33,800
Oh, it's awful.

512
00:20:34,100 --> 00:20:35,000
Don't look at that.

513
00:20:35,100 --> 00:20:35,400
Okay.

514
00:20:35,400 --> 00:20:38,100
Anyway, it'll lock it all in one chunk.

515
00:20:38,100 --> 00:20:43,000
So we may get back just one we may get back to and we have to handle

516
00:20:43,000 --> 00:20:47,100
both cases basically from direct sound, it's easy to do but that's

517
00:20:47,100 --> 00:20:48,400
that's basically the idea.

518
00:20:48,400 --> 00:20:49,600
Hopefully that makes some sense.

519
00:20:51,300 --> 00:20:51,800
Okay.

520
00:20:54,100 --> 00:20:55,200
Let's put this up here.

521
00:20:56,300 --> 00:20:56,800
All right.

522
00:20:56,800 --> 00:20:59,000
So what we are going to try to do here?

523
00:20:59,400 --> 00:20:59,900
And this is

524
00:21:00,000 --> 00:21:03,100
Things, get a little complicated and I always messed up like this up.

525
00:21:03,200 --> 00:21:04,000
It's confusing.

526
00:21:05,300 --> 00:21:07,800
We need to write a little function, the jumps, the saw, the dumps, the

527
00:21:07,800 --> 00:21:10,000
Sawtooth into into the into the buffer.

528
00:21:10,000 --> 00:21:12,400
So we're going to call this lock all here.

529
00:21:12,400 --> 00:21:19,500
And we are going to go ahead and call our Global secondary buffer, and

530
00:21:19,500 --> 00:21:20,600
attempt to lock it.

531
00:21:20,800 --> 00:21:24,600
We are going to give it the offset and that offset is going to be

532
00:21:24,600 --> 00:21:27,200
something that we get from the right pointer.

533
00:21:27,200 --> 00:21:28,500
So that's going to be the right pointer.

534
00:21:28,500 --> 00:21:30,700
And we are going to try to write out.

535
00:21:30,700 --> 00:21:35,300
I don't know, maybe maybe will basically look at

536
00:21:35,300 --> 00:21:36,700
The plate cursor as well.

537
00:21:36,700 --> 00:21:38,700
We'll talk about those two are in do it.

538
00:21:38,700 --> 00:21:41,400
So let's say b 2 right here.

539
00:21:41,800 --> 00:21:43,100
Let me see if that's actually right.

540
00:21:43,100 --> 00:21:43,800
It isn't B.

541
00:21:43,800 --> 00:21:44,000
Yes.

542
00:21:44,000 --> 00:21:44,600
Yes it is.

543
00:21:44,800 --> 00:21:50,700
Then it is going to give us back basically a series of pointer that

544
00:21:50,700 --> 00:21:55,300
it's going to give us a pair of pointer and size to specify those two

545
00:21:55,300 --> 00:21:55,900
regions.

546
00:21:56,000 --> 00:21:59,200
So this is region 0, let's say or I guess I call it region, one of the

547
00:21:59,200 --> 00:21:59,700
diagram.

548
00:21:59,900 --> 00:22:01,900
So we have a pointer to region 1.

549
00:22:02,300 --> 00:22:05,200
We have a size of region 1, so we have Regional.

550
00:22:05,300 --> 00:22:10,200
And one size and then we're going to have this again for a second one,

551
00:22:10,400 --> 00:22:11,900
and that is what we're going to pass here.

552
00:22:11,900 --> 00:22:15,600
So we got region 1 region, one size, and we're going to pass the

553
00:22:15,600 --> 00:22:18,600
address of both of them because it's basically returning those to us

554
00:22:19,000 --> 00:22:19,300
again.

555
00:22:19,300 --> 00:22:20,000
It's passing the adder.

556
00:22:20,000 --> 00:22:24,500
So it can fill them out in memory and then we're going to pass the

557
00:22:24,500 --> 00:22:25,300
flags.

558
00:22:25,500 --> 00:22:31,700
And the flags are are pretty much self-explanatory here, I guess.

559
00:22:31,900 --> 00:22:32,900
Yeah, there's not much.

560
00:22:33,000 --> 00:22:33,500
Oh, okay.

561
00:22:33,500 --> 00:22:34,600
So, you know what?

562
00:22:34,600 --> 00:22:35,200
We can actually

563
00:22:35,300 --> 00:22:37,000
Block from the right cursor directly.

564
00:22:37,200 --> 00:22:40,500
All right, so we can we can even just do do that.

565
00:22:40,500 --> 00:22:42,800
Although I don't we yeah, we don't really want to do it that way.

566
00:22:42,800 --> 00:22:43,900
We want to actually specify it.

567
00:22:43,900 --> 00:22:44,400
I'm pretty sure.

568
00:22:44,400 --> 00:22:47,000
So we're going to we're going to go ahead and say that that's the

569
00:22:47,000 --> 00:22:47,500
case.

570
00:22:47,600 --> 00:22:48,900
All right, so

571
00:22:50,100 --> 00:22:52,200
We don't really need any flags as far as I can tell.

572
00:22:52,200 --> 00:22:53,700
There's nothing in there that's going to help us.

573
00:22:53,900 --> 00:22:57,900
So this is basically what we're looking at for the entirety of this.

574
00:22:57,900 --> 00:22:58,300
Call.

575
00:22:58,500 --> 00:22:59,600
That'll lock it for us.

576
00:22:59,800 --> 00:23:03,400
So now we just need, we actually need to get that right pointer and we

577
00:23:03,400 --> 00:23:09,300
need to get that bite size, right pointer and we need the B to, right?

578
00:23:09,500 --> 00:23:10,000
Let's see.

579
00:23:11,400 --> 00:23:14,700
Okay, so we have to actually get these from somewhere.

580
00:23:14,700 --> 00:23:15,900
So that's our next goal.

581
00:23:16,000 --> 00:23:19,700
Once we get them, we can then fill the region with a Sawtooth

582
00:23:19,700 --> 00:23:20,400
basically.

583
00:23:23,200 --> 00:23:25,900
I'm going to do that in a little bit of a sort of janky way here.

584
00:23:25,900 --> 00:23:26,100
Again.

585
00:23:26,100 --> 00:23:28,200
This is just test code, this is going to get deleted.

586
00:23:29,100 --> 00:23:32,100
So basically what I'm going to do is I'm just going to make it this

587
00:23:32,200 --> 00:23:33,500
100% explicit.

588
00:23:33,600 --> 00:23:35,900
I'm going to say we're going to start writing at the particular sample

589
00:23:35,900 --> 00:23:37,000
Index, right.

590
00:23:37,000 --> 00:23:39,900
And that sample index is or I should say.

591
00:23:40,700 --> 00:23:41,100
Yeah.

592
00:23:41,100 --> 00:23:42,000
Sample index.

593
00:23:42,000 --> 00:23:46,500
And that sample index is actually going to be wherever this first

594
00:23:46,500 --> 00:23:50,400
region actually ends up being so

595
00:23:51,400 --> 00:23:53,200
So yeah, sorry.

596
00:23:53,200 --> 00:23:54,200
I'm not explaining this very well.

597
00:23:54,200 --> 00:23:55,300
This is the lack of coffee.

598
00:23:55,600 --> 00:23:56,400
Let me say that again.

599
00:23:57,100 --> 00:23:59,800
We have a sound buffer and that sound buffer contains samples.

600
00:24:00,100 --> 00:24:02,300
Contain samples that look like this.

601
00:24:02,600 --> 00:24:07,400
It contains samples that look like this right there interleaved.

602
00:24:07,800 --> 00:24:10,800
And basically each one of these is 16 bits, right?

603
00:24:10,900 --> 00:24:13,000
So it looks like this 16 bit.

604
00:24:13,200 --> 00:24:17,900
It's a it's an in 16, another in 16 another, in 16 kind of AD ad

605
00:24:17,900 --> 00:24:18,800
infinitum, right?

606
00:24:18,800 --> 00:24:19,900
Going on and on, and on.

607
00:24:20,200 --> 00:24:23,800
So, our buffer is 16 bits of the Left Channel, 16 bits for the right

608
00:24:23,800 --> 00:24:26,600
channel, 16 bits To the Left Channel, 16 bits for the right channel.

609
00:24:26,900 --> 00:24:29,900
So basically, I want to Loop over these

610
00:24:30,000 --> 00:24:30,300
Things.

611
00:24:30,300 --> 00:24:33,600
And this is what we're considering a single sample.

612
00:24:33,600 --> 00:24:35,400
Because basically, they go together, right?

613
00:24:35,600 --> 00:24:37,500
We can't output anything less than that.

614
00:24:37,500 --> 00:24:40,800
We need to Output one of those at a time because that is the only

615
00:24:40,800 --> 00:24:41,800
thing that actually makes sense.

616
00:24:41,800 --> 00:24:42,900
For our stereo sound.

617
00:24:43,000 --> 00:24:44,400
We couldn't output just eight bits.

618
00:24:44,400 --> 00:24:46,500
It'd be like half of the left handle value.

619
00:24:46,500 --> 00:24:47,400
That is make any sense.

620
00:24:47,700 --> 00:24:49,700
So, we're going to Output those at a single time.

621
00:24:49,700 --> 00:24:54,800
So basically region one size comes back, and it had better, be an even

622
00:24:54,800 --> 00:24:58,100
multiple of the samples, because if it's not something really weird

623
00:24:58,100 --> 00:24:59,900
has happened because we're only

624
00:25:00,000 --> 00:25:03,100
Going to ask for an even multiple the samples, the buffer is only an

625
00:25:03,100 --> 00:25:04,600
even multiple of sample, size, long.

626
00:25:04,800 --> 00:25:06,600
And we're not going to ever give it a right pointer.

627
00:25:06,600 --> 00:25:08,000
That isn't an even multiple.

628
00:25:08,400 --> 00:25:10,400
So this would be a good place for an assert.

629
00:25:10,400 --> 00:25:12,700
I haven't talked to you about those yet, but we will talk about those

630
00:25:12,700 --> 00:25:15,600
maybe in the later of the stream to just to assert that that's true.

631
00:25:16,800 --> 00:25:19,000
Assert that region one size.

632
00:25:20,400 --> 00:25:24,900
Is valid and read the two sides as well in the case where it gets

633
00:25:24,900 --> 00:25:25,700
returned.

634
00:25:26,000 --> 00:25:28,400
So we'll talk about that a little bit later.

635
00:25:28,400 --> 00:25:30,300
I don't want to start throwing asserts in here, until I actually have

636
00:25:30,300 --> 00:25:32,500
a chance to sit down and talk with you about what they are.

637
00:25:32,500 --> 00:25:34,800
So I have to schedule that some point because it's pretty important.

638
00:25:34,800 --> 00:25:36,900
Anyway, sample index is 0.

639
00:25:37,100 --> 00:25:42,600
It goes up to the region one size and then it, it will be finished.

640
00:25:42,700 --> 00:25:47,700
Now, of course, we then have to do the same thing for for the next

641
00:25:47,700 --> 00:25:48,100
region.

642
00:25:48,400 --> 00:25:50,100
So we want to go up to region.

643
00:25:50,300 --> 00:25:53,100
Sighs, and these sample index, these indices are relative to the

644
00:25:53,100 --> 00:25:53,900
region, right?

645
00:25:54,000 --> 00:25:55,700
So these are all the samples in region 1.

646
00:25:55,800 --> 00:25:57,500
These are all the samples in Region 2.

647
00:25:57,700 --> 00:26:00,200
And what we have to basically do is we have to fill in something now.

648
00:26:00,200 --> 00:26:06,300
So we're going to have to fill in the pointer to the buffer here.

649
00:26:06,800 --> 00:26:09,400
Basically, we're going to write two things, a left and a right each

650
00:26:09,400 --> 00:26:09,900
time.

651
00:26:10,000 --> 00:26:12,600
So the first thing we want to do is get an in 16 pointer to the

652
00:26:12,600 --> 00:26:12,900
buffer.

653
00:26:12,900 --> 00:26:16,200
Now, it returned us the pointer which was region 1, right?

654
00:26:16,400 --> 00:26:19,200
And so this is the basically, the sample out, this is what we're going

655
00:26:19,200 --> 00:26:20,100
to be writing to.

656
00:26:20,200 --> 00:26:23,200
So we're going to cast that to a un to an instant steam, which is the

657
00:26:23,200 --> 00:26:23,300
thing.

658
00:26:23,300 --> 00:26:24,000
We're going to be writing.

659
00:26:24,300 --> 00:26:25,800
And basically we're going to right here.

660
00:26:26,200 --> 00:26:29,700
We're going to we're going to write as we increment along.

661
00:26:29,800 --> 00:26:34,100
We're going to write our left here and are right here, right?

662
00:26:34,200 --> 00:26:36,600
And then we're going to do the same exact thing down here.

663
00:26:36,600 --> 00:26:37,300
So that makes sense.

664
00:26:37,400 --> 00:26:38,100
Hopefully that's clear.

665
00:26:41,000 --> 00:26:44,100
Alright, so basically this will do everything that we want to, we just

666
00:26:44,100 --> 00:26:48,500
have to figure out what we're going to do in terms of the actual

667
00:26:48,500 --> 00:26:49,200
values here.

668
00:26:49,300 --> 00:26:53,200
So what we want to do is we want to go and every sample depending on

669
00:26:53,200 --> 00:26:54,700
which sample we are at.

670
00:26:54,800 --> 00:26:57,500
We basically want to go ahead and make a square wave.

671
00:26:57,500 --> 00:26:59,800
So we want to be able to basically just do if

672
00:27:00,000 --> 00:27:00,300
Sample.

673
00:27:00,300 --> 00:27:04,700
Index happens to be, you know, the first n samples.

674
00:27:04,700 --> 00:27:06,400
It's going to be high positive.

675
00:27:06,400 --> 00:27:09,100
It's the first if it comes after that, the next and samples are going

676
00:27:09,100 --> 00:27:11,900
to be low and high and low and high and low, so we're going to use the

677
00:27:11,900 --> 00:27:12,900
mod operator for that.

678
00:27:12,900 --> 00:27:13,500
Probably.

679
00:27:13,800 --> 00:27:17,100
So basically what we're going to do here is we are going to actually

680
00:27:17,100 --> 00:27:19,100
upload, you know, we could we don't even really need to use the mod.

681
00:27:19,100 --> 00:27:19,400
Operator.

682
00:27:19,400 --> 00:27:22,100
We could we could be a little more gentle than that.

683
00:27:22,200 --> 00:27:25,000
So basically what we're going to do is go to find a variable that's

684
00:27:25,000 --> 00:27:28,100
going to tell us where we are in our Sawtooth pattern.

685
00:27:28,400 --> 00:27:29,800
We are basically going to call that

686
00:27:30,000 --> 00:27:32,100
at I'm sorry, not Sawtooth R square wave pattern.

687
00:27:32,200 --> 00:27:35,100
We're going to call that R square wave counter and basically all

688
00:27:35,100 --> 00:27:38,700
that's going to do is if the square wave counter happens, to be

689
00:27:39,300 --> 00:27:40,500
happens to be 0.

690
00:27:40,500 --> 00:27:44,200
So we're done, you know, basically we finished one part of our Square

691
00:27:44,200 --> 00:27:48,400
wave if the square wave counter happens to be 0, we are going to set

692
00:27:49,300 --> 00:27:52,400
just me man.

693
00:27:52,400 --> 00:27:53,400
I wish I could get healthy again.

694
00:27:53,800 --> 00:27:58,300
I can't tell you how frustrating it is to be trying to talk to you and

695
00:27:58,300 --> 00:27:59,700
have this stupid cold in my way.

696
00:28:00,000 --> 00:28:00,800
Really annoying.

697
00:28:04,700 --> 00:28:05,300
All right.

698
00:28:06,300 --> 00:28:08,300
Anyway, this Square wave counter is going to basically go up to the

699
00:28:08,300 --> 00:28:10,900
number of samples that we want.

700
00:28:10,900 --> 00:28:12,800
Our Square wave to have high.

701
00:28:13,100 --> 00:28:15,700
Before it goes, low and vice versa.

702
00:28:16,000 --> 00:28:20,300
So basically what we're going to do is we're going to say well if R

703
00:28:20,300 --> 00:28:21,100
square wave counter.

704
00:28:21,100 --> 00:28:21,400
I don't know.

705
00:28:21,400 --> 00:28:23,100
I'm going to pick a random value here and then we're going to knit

706
00:28:23,100 --> 00:28:26,000
later Square wave period or something like this.

707
00:28:26,400 --> 00:28:27,200
We're going to reset it.

708
00:28:27,200 --> 00:28:28,300
Each time again.

709
00:28:28,300 --> 00:28:29,300
This is kind of ugly.

710
00:28:29,300 --> 00:28:30,100
The way I'm doing this.

711
00:28:30,100 --> 00:28:33,100
Probably not the best way to do it but its first thing I thought of so

712
00:28:33,100 --> 00:28:34,300
we're going to make it to that way.

713
00:28:34,300 --> 00:28:36,000
And then what we're going to do is we're going to say our

714
00:28:37,200 --> 00:28:41,700
Value is just going to be whether or not the square wave, counter

715
00:28:42,200 --> 00:28:45,800
happened to be above half the square wave period.

716
00:28:45,900 --> 00:28:47,300
Basically, that's about it.

717
00:28:48,700 --> 00:28:49,800
That's that's all we're doing.

718
00:28:50,100 --> 00:28:53,900
If it happens to be above that, then it will output the highest

719
00:28:53,900 --> 00:28:57,300
possible value that it can well, maybe not the highest possible value.

720
00:28:57,300 --> 00:28:58,800
Let's just say 16,000.

721
00:28:59,600 --> 00:28:59,800
Yeah.

722
00:28:59,800 --> 00:29:03,400
I don't know how loud we want this thing to be being, basically.

723
00:29:03,400 --> 00:29:04,400
This is a 16-bit value.

724
00:29:04,400 --> 00:29:06,000
So 32,000 is the maximum.

725
00:29:06,100 --> 00:29:09,800
It could be there, you know, there to whatever it is, 65536 divided by

726
00:29:09,800 --> 00:29:10,200
2.

727
00:29:11,100 --> 00:29:13,500
And if the square wave period, if it's not that if it's in the other

728
00:29:13,500 --> 00:29:16,300
half of the square wave period allowed, put the - that's basically all

729
00:29:16,300 --> 00:29:19,100
I actually want to do here and these are basically the exact same

730
00:29:19,100 --> 00:29:19,600
Loop.

731
00:29:19,700 --> 00:29:22,700
So we'll probably compress these in a second down to one Loop, but

732
00:29:22,700 --> 00:29:23,800
that's basically it.

733
00:29:23,900 --> 00:29:25,200
That is all we wanted to do.

734
00:29:25,200 --> 00:29:27,300
So, all we really need to do now is make sure that we actually fill

735
00:29:27,300 --> 00:29:30,800
out all these values somewhat reasonably, I believe that's correct.

736
00:29:31,100 --> 00:29:34,800
Okay, someone on the stream said, let's code a mini Moog synthesizer

737
00:29:34,800 --> 00:29:36,000
and emulator instead of a game.

738
00:29:36,100 --> 00:29:39,100
Umm, you know what, that is Shawn Barrett's Turf ladies and gentlemen,

739
00:29:39,100 --> 00:29:40,800
I am not the person to do that for you.

740
00:29:40,800 --> 00:29:46,000
But you know, I bet if you asked nothing's at nothing's at Twitter to

741
00:29:46,000 --> 00:29:48,300
do a stream where he codes a Moog synthesizer for you.

742
00:29:48,300 --> 00:29:50,500
I bet he would do that.

743
00:29:50,700 --> 00:29:53,300
That is exactly the kind of thing that he would do and he is exactly

744
00:29:53,300 --> 00:29:57,700
the kind of person who would know how to do that, a lot better than I

745
00:29:57,700 --> 00:29:58,000
would.

746
00:29:58,000 --> 00:29:59,800
I would just end up writing a lot of crappy code.

747
00:30:00,000 --> 00:30:02,700
This that I just wrote for you because honestly, I never synthesized

748
00:30:02,700 --> 00:30:02,900
sound.

749
00:30:02,900 --> 00:30:06,400
Really, I always play from some kind of sample materials that get

750
00:30:06,400 --> 00:30:07,200
mixed together.

751
00:30:07,500 --> 00:30:11,000
So this is way out of my area of expertise to say the least but it's

752
00:30:11,000 --> 00:30:13,500
definitely the easiest thing for us to write to just get things going.

753
00:30:15,200 --> 00:30:15,800
Okay.

754
00:30:17,500 --> 00:30:18,500
So we need some stuff here.

755
00:30:18,500 --> 00:30:21,300
We have not finished because we have to Define some things.

756
00:30:21,700 --> 00:30:22,200
Obviously.

757
00:30:22,200 --> 00:30:25,100
We have a square wave period and that's where wave period is going to

758
00:30:25,100 --> 00:30:27,200
have to be something reasonable.

759
00:30:27,300 --> 00:30:30,700
We also have to make sure that we actually decorate decrement, our

760
00:30:30,700 --> 00:30:35,200
Square wave counter every time we output a sample, write something

761
00:30:35,200 --> 00:30:35,700
like this.

762
00:30:35,900 --> 00:30:39,400
Just so that it starts to count down to zero as it should.

763
00:30:39,500 --> 00:30:40,900
And and so it will repeat.

764
00:30:40,900 --> 00:30:44,200
Now the square wave period, I don't really know what the average

765
00:30:44,400 --> 00:30:47,100
square wave period, should be for a sound that you can hear.

766
00:30:47,500 --> 00:30:49,600
Let's say, middle C.

767
00:30:49,900 --> 00:30:51,600
What is the frequency of middle C?

768
00:30:52,000 --> 00:30:52,200
Okay.

769
00:30:52,200 --> 00:30:54,000
So middle C is in hertz.

770
00:30:54,000 --> 00:30:56,800
Basically, what hurts is, if you don't know what hurts is, its cycles

771
00:30:56,800 --> 00:30:57,700
per second.

772
00:30:58,200 --> 00:30:59,200
Basically what that means?

773
00:30:59,200 --> 00:31:01,500
If I go back over here to our amazing diagram.

774
00:31:02,300 --> 00:31:05,500
Basically, what you can imagine is we have that square wave, right?

775
00:31:05,700 --> 00:31:06,700
It's going like this.

776
00:31:06,900 --> 00:31:09,600
And similarly, you might have a sound wave, you know, that goes like

777
00:31:09,600 --> 00:31:12,800
this and basically, I believe the way they typically measure.

778
00:31:12,800 --> 00:31:17,100
It is a cycle is how long it takes to go back to

779
00:31:17,200 --> 00:31:20,600
Are you were so from like one Peak to the next Peak, right?

780
00:31:20,600 --> 00:31:25,700
Like this or from from, you know, from here to here, basically, for

781
00:31:25,700 --> 00:31:32,400
one complete copy of the pattern of the wave that is basically called

782
00:31:32,400 --> 00:31:33,100
a cycle.

783
00:31:33,300 --> 00:31:35,000
That is what we're considering a cycle.

784
00:31:35,200 --> 00:31:39,200
And so Hertz is just cycles per second.

785
00:31:39,600 --> 00:31:40,200
That's all.

786
00:31:40,400 --> 00:31:43,500
So basically, if we are going to play a sound for one second or fill a

787
00:31:43,500 --> 00:31:45,300
buffer, that's one second long.

788
00:31:46,400 --> 00:31:47,400
Then you can imagine.

789
00:31:47,600 --> 00:31:52,600
It should have 261 copies of that pattern, for middle C.

790
00:31:53,100 --> 00:31:55,400
Basically that that is, that is what that means.

791
00:31:55,900 --> 00:31:59,700
So if we try to back this out here, if we're trying to figure out what

792
00:31:59,700 --> 00:32:03,500
R square wave period, should be, basically what the value is.

793
00:32:03,800 --> 00:32:06,900
Maybe I'll go here and say, you know what the Hertz is.

794
00:32:07,000 --> 00:32:08,800
So we'll try to get a hurt something like that.

795
00:32:08,800 --> 00:32:09,400
So, I don't know.

796
00:32:09,400 --> 00:32:12,400
Let's just say 256, should be close enough.

797
00:32:12,400 --> 00:32:15,200
I want a power of two, just because I'm a programmer like that.

798
00:32:15,200 --> 00:32:15,900
That'll be somewhere.

799
00:32:16,100 --> 00:32:19,400
Most a middle, C in theory, I believe should be fine.

800
00:32:19,600 --> 00:32:24,200
So if we have, if we're wanting to actually do 256 cycles per second,

801
00:32:24,400 --> 00:32:29,300
right then the question is, how many samples do we need to fill?

802
00:32:29,300 --> 00:32:31,400
Because again, this is going to be in samples here.

803
00:32:31,600 --> 00:32:34,200
How many samples do we need to fill before?

804
00:32:34,200 --> 00:32:40,000
We actually have that many, how many samples for a full, you know, for

805
00:32:40,000 --> 00:32:40,800
one of our Loops.

806
00:32:41,000 --> 00:32:43,600
So basically what we want to do is we want to say well Hertz is

807
00:32:43,600 --> 00:32:45,400
samples per second, right?

808
00:32:46,400 --> 00:32:50,400
So all we have to really do is say that whatever our sample rate is,

809
00:32:50,400 --> 00:32:51,500
and we know what it is right here.

810
00:32:51,500 --> 00:32:52,000
We set it.

811
00:32:52,000 --> 00:32:56,200
So I could even say this is our samples per second, right?

812
00:32:56,700 --> 00:32:59,300
That we actually asked the sound buffer for oops.

813
00:33:00,200 --> 00:33:02,400
Actually asked the sound buffer for there.

814
00:33:02,400 --> 00:33:04,300
It is samples per second.

815
00:33:04,500 --> 00:33:06,300
If that is our samples per second.

816
00:33:07,100 --> 00:33:13,300
Then we basically know that if we want to have 256 of our thing, then

817
00:33:13,300 --> 00:33:15,600
each one of them should occupy.

818
00:33:16,200 --> 00:33:20,600
Basically, the, the number of samples were actually going to do in 1 s

819
00:33:20,600 --> 00:33:24,200
divided by the number of the things we want in one second, right?

820
00:33:24,200 --> 00:33:26,200
Because that's how many chunks there would be.

821
00:33:26,700 --> 00:33:28,800
That's how many samples would be per chunk.

822
00:33:28,800 --> 00:33:29,800
If we've chunked up our

823
00:33:30,000 --> 00:33:32,900
Set our full second into 256 slices.

824
00:33:33,100 --> 00:33:35,500
So I'm going to say that's roughly R square wave period.

825
00:33:35,700 --> 00:33:37,100
We're not trying to be precise here.

826
00:33:37,200 --> 00:33:40,000
So I'm basically going to say that that is what we will actually fill

827
00:33:40,000 --> 00:33:40,600
out.

828
00:33:41,300 --> 00:33:42,500
So now this should work.

829
00:33:42,600 --> 00:33:46,100
I think we can go down and see where writing that many samples.

830
00:33:46,100 --> 00:33:46,900
Yes, we are.

831
00:33:47,300 --> 00:33:51,200
So what we have to do here now is we have to actually turn our region

832
00:33:51,200 --> 00:33:53,200
sizes into counts, right?

833
00:33:53,200 --> 00:33:54,200
Because these are sizes.

834
00:33:54,200 --> 00:33:57,600
These are bite sizes that are coming back and we actually need sample

835
00:33:57,600 --> 00:33:58,200
sizes.

836
00:33:58,400 --> 00:33:59,900
So like I said, we got to assert that

837
00:34:00,000 --> 00:34:00,400
Valid.

838
00:34:00,400 --> 00:34:03,400
And then I jumped into an explanation and forgot to finish what I was

839
00:34:03,400 --> 00:34:03,800
trying to do.

840
00:34:03,800 --> 00:34:04,200
Here.

841
00:34:04,500 --> 00:34:08,199
We need region, one, sample count, right?

842
00:34:08,199 --> 00:34:11,300
Because this is how many bytes, but we know that our samples are

843
00:34:11,300 --> 00:34:13,000
actually 32.

844
00:34:13,100 --> 00:34:13,800
So that's 4.

845
00:34:13,800 --> 00:34:18,600
Bytes per, a 32-bit sample to give two 16-bit samples left and a

846
00:34:18,600 --> 00:34:19,100
right.

847
00:34:19,300 --> 00:34:22,600
So, basically, we have to do, is we have to divide this here, by our

848
00:34:22,600 --> 00:34:24,000
B, for sample, right?

849
00:34:24,000 --> 00:34:28,699
So, by our bytes per sample to actually get the region one sample

850
00:34:28,699 --> 00:34:29,800
count, which is what we

851
00:34:29,900 --> 00:34:32,199
To Loop over and same thing here.

852
00:34:32,300 --> 00:34:34,699
We got to do the exact same thing down here.

853
00:34:34,699 --> 00:34:37,199
And the reason I wanted to as do the assertion, like I saying is just

854
00:34:37,199 --> 00:34:42,300
to guarantee that what it gave us back was even lie to me this evenly

855
00:34:42,300 --> 00:34:46,100
divisible here, man.

856
00:34:46,699 --> 00:34:47,500
I hate the winner.

857
00:34:50,300 --> 00:34:52,500
I get sick every year and it is awful.

858
00:34:52,800 --> 00:34:53,600
Absolutely awful.

859
00:34:54,199 --> 00:34:56,000
And I think I've gotten much sleep the past few nights.

860
00:34:56,800 --> 00:34:58,600
It is just absolutely miserable.

861
00:34:58,700 --> 00:34:59,900
Don't ever get sick people.

862
00:34:59,900 --> 00:35:01,900
If you can avoid it, just don't do it.

863
00:35:01,900 --> 00:35:04,900
It's no good God.

864
00:35:04,900 --> 00:35:05,400
All right.

865
00:35:05,500 --> 00:35:08,600
Well anyway, the reason I made B for sample, be a variable is because

866
00:35:08,600 --> 00:35:10,100
I knew it was used up here as well.

867
00:35:10,200 --> 00:35:11,200
This is it right here.

868
00:35:11,500 --> 00:35:12,800
So I figured we're just clean this up.

869
00:35:12,800 --> 00:35:15,000
And now will actually have basically

870
00:35:16,500 --> 00:35:18,900
A complete set of definitions for our sound system that we could

871
00:35:18,900 --> 00:35:19,200
change.

872
00:35:19,200 --> 00:35:22,300
If we wanted to just to make it a little clearer, what's going on?

873
00:35:22,700 --> 00:35:25,500
So we're going to be sad with that exact parameter.

874
00:35:25,600 --> 00:35:26,700
Then we're gonna go down here.

875
00:35:26,900 --> 00:35:28,600
We're going to do all the work with those parameters.

876
00:35:28,800 --> 00:35:31,600
And so pretty much only thing we need to do now is we need to figure

877
00:35:31,600 --> 00:35:32,900
out where these guys are going to come from?

878
00:35:32,900 --> 00:35:34,400
I believe we cut everything else.

879
00:35:34,400 --> 00:35:34,700
I don't know.

880
00:35:34,700 --> 00:35:36,900
There's a lot of code in there, and I was talking to whole time.

881
00:35:36,900 --> 00:35:40,500
So there's probably some bugs, but we will debug them and it will not

882
00:35:40,500 --> 00:35:41,700
be an issue.

883
00:35:43,300 --> 00:35:43,700
Okay.

884
00:35:44,300 --> 00:35:44,700
Hmm.

885
00:35:46,100 --> 00:35:51,500
Finally, we basically need to figure out where we are going to ask

886
00:35:51,600 --> 00:35:52,900
directsound to, right?

887
00:35:52,900 --> 00:35:56,600
And we're going to have to figure out how many bytes we need to write

888
00:35:56,600 --> 00:35:58,200
and we have some information.

889
00:35:58,200 --> 00:35:59,800
We can use to do that.

890
00:36:00,000 --> 00:36:00,400
Lee.

891
00:36:00,900 --> 00:36:06,100
If we go back over here to our direct sound buffer, we can see there

892
00:36:06,100 --> 00:36:07,400
should be a call.

893
00:36:07,500 --> 00:36:11,000
Let's see if I can bring up the actual definition of the buffer

894
00:36:11,000 --> 00:36:12,300
somewhere people.

895
00:36:12,300 --> 00:36:12,800
There it is.

896
00:36:15,600 --> 00:36:16,200
Okay.

897
00:36:16,800 --> 00:36:19,500
Basically what we've got here is, we've got all the calls that we can

898
00:36:19,500 --> 00:36:20,700
call on a buffer.

899
00:36:20,900 --> 00:36:25,300
And what I basically want to do is I want to get back the, the clay

900
00:36:25,300 --> 00:36:27,100
cursor and the right cursor.

901
00:36:27,200 --> 00:36:28,400
I'll talk about what those are.

902
00:36:28,400 --> 00:36:29,900
I believe it is this call right here.

903
00:36:30,000 --> 00:36:34,200
Here and and this is the call that we're going to use to get that

904
00:36:34,200 --> 00:36:34,400
back.

905
00:36:34,400 --> 00:36:37,600
So right before we determine what we're going to do, I'm going to call

906
00:36:37,600 --> 00:36:38,000
this.

907
00:36:38,400 --> 00:36:42,800
We are going to assume that this succeeds, because if we can't get it,

908
00:36:43,000 --> 00:36:47,000
then the sound buffer died or something bad happened and we probably

909
00:36:47,000 --> 00:36:50,000
shouldn't try to output sound if we can actually get it.

910
00:36:50,000 --> 00:36:53,700
So I'm just going to go ahead and wrap this here right up in that so

911
00:36:53,700 --> 00:36:54,900
that we don't actually do anything.

912
00:36:54,900 --> 00:36:59,500
If we can't do this, the same should be true of the lock while we're

913
00:36:59,500 --> 00:36:59,800
at it.

914
00:37:00,500 --> 00:37:04,000
The lock itself again returns at H result.

915
00:37:04,000 --> 00:37:06,600
So, I'm just going to say let's not do anything.

916
00:37:06,800 --> 00:37:10,700
If for some reason we can't lock these buffers because that's no good.

917
00:37:11,200 --> 00:37:12,900
That just means direct sound is encountered.

918
00:37:12,900 --> 00:37:15,600
Some kind of really bad, sort of fatal error, bad condition.

919
00:37:15,600 --> 00:37:18,300
Maybe the sound card got yanked or changed out from under it or

920
00:37:18,300 --> 00:37:20,700
something and we don't want to be doing anything in there.

921
00:37:20,700 --> 00:37:24,500
We might end up with bad rights or some some bad stuff going on.

922
00:37:25,000 --> 00:37:25,600
All right.

923
00:37:26,600 --> 00:37:31,100
Now, what should happen here is basically, we should be able to ask to

924
00:37:31,100 --> 00:37:34,200
direct sound for the play cursor position and the right cursor

925
00:37:34,200 --> 00:37:36,300
position and I will show you what those are.

926
00:37:36,800 --> 00:37:39,900
Basically, those are both going to be returned to us.

927
00:37:40,200 --> 00:37:43,000
If this call succeeds, we will then have that information.

928
00:37:43,500 --> 00:37:44,300
So, there we go.

929
00:37:44,900 --> 00:37:46,900
And that should basically compile.

930
00:37:46,900 --> 00:37:51,100
Now, I would think, oh, right now we need the, we need to call that

931
00:37:51,100 --> 00:37:53,600
off the secondary buffer, like that.

932
00:37:54,100 --> 00:37:55,500
And then we just need to do these.

933
00:37:55,500 --> 00:37:56,300
So, there we go.

934
00:37:56,800 --> 00:37:57,900
Now, what are these things?

935
00:37:57,900 --> 00:38:00,400
Well, basically what's going to happen is in our diagram here.

936
00:38:00,400 --> 00:38:02,800
I don't know if I can back up how far I can undo in this thing.

937
00:38:02,800 --> 00:38:03,700
Look at that.

938
00:38:03,900 --> 00:38:04,300
Look at that.

939
00:38:04,300 --> 00:38:06,600
Undo didn't quite get as far enough.

940
00:38:06,800 --> 00:38:08,000
All right, no big deal.

941
00:38:08,100 --> 00:38:10,900
We'll just go ahead and clear that out and start drawing again.

942
00:38:11,100 --> 00:38:12,500
Where's the pen tool in this thing?

943
00:38:12,500 --> 00:38:13,000
There it is.

944
00:38:13,400 --> 00:38:13,700
Alright.

945
00:38:13,700 --> 00:38:17,100
So basically what happens here is the in that buffer again.

946
00:38:17,200 --> 00:38:18,800
Oh my, why are we so tiny?

947
00:38:18,900 --> 00:38:19,700
You have to use the pen.

948
00:38:20,100 --> 00:38:20,500
Know?

949
00:38:21,400 --> 00:38:22,300
How do I get a brush?

950
00:38:22,300 --> 00:38:22,900
People?

951
00:38:22,900 --> 00:38:23,600
Give me a brush.

952
00:38:23,600 --> 00:38:24,400
Is that a brush?

953
00:38:24,500 --> 00:38:25,100
There we go.

954
00:38:25,500 --> 00:38:26,400
All right here.

955
00:38:26,500 --> 00:38:27,800
Is my buffer, there it is.

956
00:38:27,800 --> 00:38:28,300
Again.

957
00:38:28,500 --> 00:38:31,200
Basically, what's going on here is you have to imagine that the

958
00:38:31,200 --> 00:38:35,900
hardware, the actual sound card, or the kernel mixer or whoever is

959
00:38:36,100 --> 00:38:38,200
basically controlling the situation.

960
00:38:38,200 --> 00:38:39,300
We don't really know who that is.

961
00:38:39,500 --> 00:38:43,800
But whoever it is, they are actually looking at this buffer at a

962
00:38:43,800 --> 00:38:46,900
particular location and that is the play cursor.

963
00:38:47,000 --> 00:38:48,600
That is the play cursor.

964
00:38:48,600 --> 00:38:48,800
Wow.

965
00:38:48,800 --> 00:38:50,200
That is a really bad drawing.

966
00:38:50,400 --> 00:38:54,600
Play cursor right here now because of the way Hardware works and

967
00:38:54,600 --> 00:38:56,400
because of the way the colonel mixing works and all those

968
00:38:56,500 --> 00:38:57,100
sorts of things.

969
00:38:57,300 --> 00:38:58,700
It's all asynchronous, right?

970
00:38:58,700 --> 00:38:59,700
This is happening.

971
00:39:00,200 --> 00:39:02,100
Whether we're running or not, it's happening.

972
00:39:02,100 --> 00:39:05,200
Perhaps concurrently with us on a separate core of the processor.

973
00:39:05,400 --> 00:39:09,200
We may be interrupted at any time in our code because the operating

974
00:39:09,200 --> 00:39:10,900
system wants to do something etcetera, Etc.

975
00:39:11,100 --> 00:39:13,900
So, these are things the hardware that that sound is going to be

976
00:39:13,900 --> 00:39:16,000
playing whether we're running or not.

977
00:39:16,500 --> 00:39:20,100
And so it's not safe for us to start writing directly in there.

978
00:39:20,100 --> 00:39:23,600
Because by the time we finish doing whatever the right is the hardware

979
00:39:23,600 --> 00:39:26,700
may actually have beaten us because we may get interrupted.

980
00:39:26,700 --> 00:39:27,400
Who knows what happens?

981
00:39:27,400 --> 00:39:29,800
The hardware may actually have beaten us and played garbage.

982
00:39:30,000 --> 00:39:32,400
Judge something that's half written or who knows what?

983
00:39:33,100 --> 00:39:36,700
So instead what happens is there's another cursor called the right

984
00:39:36,700 --> 00:39:39,600
cursor and that basically leads the play cursor.

985
00:39:39,800 --> 00:39:43,000
It's a cursor that somewhere else out here and basically the right

986
00:39:43,000 --> 00:39:43,800
cursor tells us.

987
00:39:43,800 --> 00:39:48,300
Well, we can write into a particular location and then we can move,

988
00:39:48,300 --> 00:39:51,200
you know, basically from their forwards, right?

989
00:39:51,900 --> 00:39:55,100
And so what we're going to do is we're basically just going to see how

990
00:39:55,100 --> 00:39:56,000
far the right cursor.

991
00:39:56,000 --> 00:39:58,800
Moved probably and and we'll right into that.

992
00:39:58,800 --> 00:39:59,800
Now there's a little thing a little

993
00:40:00,200 --> 00:40:04,300
Out here since the lock, doesn't as far as I know.

994
00:40:04,400 --> 00:40:06,800
Let's take a look at this because I'm trying to remember exactly how

995
00:40:06,800 --> 00:40:07,600
this system works.

996
00:40:07,900 --> 00:40:10,500
I don't think the lock moves the right cursor, does it?

997
00:40:12,400 --> 00:40:18,100
Let's take a look, blah, blah, blah, Returns the ring buffer stuff.

998
00:40:18,100 --> 00:40:21,600
Like we said, after writing data, to the point of Return by this

999
00:40:21,600 --> 00:40:23,600
method, the application was immediately call unlock.

1000
00:40:24,400 --> 00:40:25,700
Yes, that's true.

1001
00:40:25,700 --> 00:40:26,700
So we should actually do that.

1002
00:40:26,700 --> 00:40:27,700
We got to do that as well.

1003
00:40:28,000 --> 00:40:28,800
The method returns, right?

1004
00:40:28,800 --> 00:40:30,000
Porter's only.

1005
00:40:30,000 --> 00:40:32,100
Yeah, so that's, that's, that's it.

1006
00:40:32,200 --> 00:40:35,400
So, basically, this right cursor is just going to move a little bit

1007
00:40:35,400 --> 00:40:38,000
ahead of the play Chris or it's not going to move when we write.

1008
00:40:38,000 --> 00:40:40,700
So one of the things we're also going to have to add here is the fact

1009
00:40:40,700 --> 00:40:42,000
that we're going to have to track where

1010
00:40:42,200 --> 00:40:45,700
Were in the buffer basically and we're betting that that's really all

1011
00:40:45,700 --> 00:40:46,700
we're going to be able to.

1012
00:40:46,700 --> 00:40:48,100
Yeah, that's what we're going to have to do.

1013
00:40:48,400 --> 00:40:51,100
So really, the right pointer is not actually going to be something

1014
00:40:51,400 --> 00:40:52,500
that we need to know about.

1015
00:40:52,500 --> 00:40:52,800
Basically.

1016
00:40:52,800 --> 00:40:55,400
It's the play curse or really that we're going to have to see because

1017
00:40:55,400 --> 00:40:58,000
we're going to have to look to see where we can fill to basically.

1018
00:40:58,200 --> 00:40:58,800
All right.

1019
00:40:59,000 --> 00:40:59,500
So that's fine.

1020
00:40:59,500 --> 00:41:00,900
It's going to be a little bit more complicated math.

1021
00:41:00,900 --> 00:41:02,700
Like I say this code is going to be pretty janky.

1022
00:41:02,700 --> 00:41:06,500
Hopefully, at the end of this will actually be in relatively good

1023
00:41:06,500 --> 00:41:07,000
shape.

1024
00:41:07,500 --> 00:41:09,700
And when we actually output sound, it'll be a lot easier than this

1025
00:41:09,700 --> 00:41:10,600
because we'll have extracted.

1026
00:41:10,600 --> 00:41:12,000
This kind of weird ring, buffer stuff.

1027
00:41:12,100 --> 00:41:13,800
Out in a way that we don't have to deal with it.

1028
00:41:13,800 --> 00:41:15,700
So so it's that won't be so confusing.

1029
00:41:15,700 --> 00:41:17,900
Basically take almond milk, it here.

1030
00:41:22,800 --> 00:41:24,900
Yeah, this is probably like I said, I told you Sam is going to be

1031
00:41:24,900 --> 00:41:25,700
rough yesterday.

1032
00:41:25,900 --> 00:41:26,700
This is the kind of stuff.

1033
00:41:26,700 --> 00:41:28,400
I was referring to outputting to a ring.

1034
00:41:28,400 --> 00:41:29,300
Buffer is never fun.

1035
00:41:29,300 --> 00:41:31,700
So he's a little confusing as we boil the code down.

1036
00:41:31,700 --> 00:41:33,000
It'll get a little clearer at first.

1037
00:41:33,000 --> 00:41:35,000
It's always a little janky, especially, when you don't remember how

1038
00:41:35,000 --> 00:41:37,000
everything works, which is the case with me at this point.

1039
00:41:37,300 --> 00:41:41,900
But anyway, point being so basically what we want to do is we want to,

1040
00:41:41,900 --> 00:41:46,200
we want to actually remember where we were, how many, how many sounds

1041
00:41:46,200 --> 00:41:47,100
we outputted.

1042
00:41:47,300 --> 00:41:50,400
Which is sort of what we're doing here and we want to be able to lock

1043
00:41:50,400 --> 00:41:52,400
the buffer at wherever we left off.

1044
00:41:52,500 --> 00:41:56,800
Off essentially, so since we basically have a counter, we could we

1045
00:41:56,800 --> 00:41:59,100
could reuse this counter.

1046
00:41:59,100 --> 00:41:59,800
I don't know if we really

1047
00:42:00,000 --> 00:42:00,800
Do that.

1048
00:42:01,800 --> 00:42:02,800
Yeah, maybe we do.

1049
00:42:03,000 --> 00:42:05,800
So basically what we might want to do here for example is we might

1050
00:42:05,800 --> 00:42:06,800
want to just use a mod.

1051
00:42:06,800 --> 00:42:09,800
It's inefficient, but it might be a little cleaner than what we were

1052
00:42:09,800 --> 00:42:12,700
doing basically to actually get this value.

1053
00:42:12,700 --> 00:42:14,500
So let's think about it this way.

1054
00:42:14,600 --> 00:42:17,400
Let's say that we actually have a sample Index.

1055
00:42:17,600 --> 00:42:21,600
This is our, this is our sample index here that we're going to write

1056
00:42:21,600 --> 00:42:21,900
to

1057
00:42:23,800 --> 00:42:25,700
And that's going to actually Loop.

1058
00:42:25,700 --> 00:42:28,800
We want that to be an unsigned integer because we want it to.

1059
00:42:28,800 --> 00:42:31,300
Basically if it ever wraps over 4 billion.

1060
00:42:31,300 --> 00:42:33,500
We want to go back to zero not to a negative number.

1061
00:42:33,600 --> 00:42:36,400
So we're going to have a sample index here basically and that sample

1062
00:42:36,400 --> 00:42:38,000
index is just going to go up forever.

1063
00:42:38,100 --> 00:42:38,600
For now.

1064
00:42:38,600 --> 00:42:39,500
That's what we're going to say.

1065
00:42:39,700 --> 00:42:41,000
We're going to get rid of our square root of counter.

1066
00:42:41,000 --> 00:42:43,000
So we're going to have a sample index and that's going to go Paris

1067
00:42:43,000 --> 00:42:45,400
starts at zero and goes up forever.

1068
00:42:45,600 --> 00:42:48,600
So the first thing that we're going to do two right into the buffer

1069
00:42:48,600 --> 00:42:51,100
basically is when we lock the buffer.

1070
00:42:51,500 --> 00:42:52,900
We're actually just going to lock the

1071
00:42:53,000 --> 00:42:58,300
Buffer at whatever our sample, our sample index is our Global sample

1072
00:42:58,300 --> 00:42:58,700
index.

1073
00:42:58,700 --> 00:43:00,900
So this is going to be a, I don't know what we're going to call this.

1074
00:43:00,900 --> 00:43:04,000
Actually, I guess we, let's see.

1075
00:43:04,100 --> 00:43:05,600
Let's call this are running sample index.

1076
00:43:05,600 --> 00:43:07,900
So it's just where it just keeps going like that.

1077
00:43:08,100 --> 00:43:11,600
So, basically, what we're going to do here is we're going to say,

1078
00:43:11,700 --> 00:43:14,200
okay, we've got this running sample index and it's going to just keep

1079
00:43:14,200 --> 00:43:16,100
going up forever to tell us roughly where we are.

1080
00:43:16,300 --> 00:43:18,200
We're then going to say, okay.

1081
00:43:18,300 --> 00:43:22,200
We need to know where in the buffer that would because this is

1082
00:43:22,200 --> 00:43:22,800
basically just going to go

1083
00:43:23,000 --> 00:43:23,300
Forever.

1084
00:43:23,300 --> 00:43:26,000
And we want to map it into the circular buffer, that makes sense.

1085
00:43:26,200 --> 00:43:28,100
So basically we want to make a d word.

1086
00:43:28,300 --> 00:43:31,300
That is basically the sample index to lock.

1087
00:43:31,300 --> 00:43:35,100
So this is the sample index to lock is going to be the running sample

1088
00:43:35,100 --> 00:43:37,200
index times, the bytes per sample.

1089
00:43:37,200 --> 00:43:39,700
So that turns it from a sample index into a bite sample.

1090
00:43:39,700 --> 00:43:44,900
And so X should actually say this is the B to lock turns it into a,

1091
00:43:45,000 --> 00:43:45,600
we're in the B.

1092
00:43:45,600 --> 00:43:49,700
It was, but we now have 2 mod by the size of the buffer.

1093
00:43:50,300 --> 00:43:52,700
Basically, to say, if it loops

1094
00:43:53,000 --> 00:43:54,100
It gets to the end.

1095
00:43:54,100 --> 00:43:56,000
It's got to go back to the beginning because it's in this life.

1096
00:43:56,000 --> 00:43:57,100
It's in this circular buffer.

1097
00:43:57,100 --> 00:43:57,800
Right now.

1098
00:43:57,800 --> 00:44:00,100
The mod is basically just says remainder.

1099
00:44:00,100 --> 00:44:03,700
It basically says divide this number by this other number and give me

1100
00:44:03,700 --> 00:44:05,900
the remainder, which is exactly what we want.

1101
00:44:05,900 --> 00:44:06,400
Right?

1102
00:44:06,400 --> 00:44:10,400
We basically want it to give us something back, that's going to be

1103
00:44:10,800 --> 00:44:11,100
mmm.

1104
00:44:11,900 --> 00:44:16,500
Excuse me, that's going to be whatever, fractional portion we would

1105
00:44:16,500 --> 00:44:19,100
have of the of the total buffer size because that's where in the

1106
00:44:19,100 --> 00:44:20,800
buffer we will actually be.

1107
00:44:21,200 --> 00:44:22,700
So that's what we actually want here.

1108
00:44:22,900 --> 00:44:24,300
We want that bite to lock.

1109
00:44:24,300 --> 00:44:25,600
So that is where that is.

1110
00:44:25,600 --> 00:44:29,100
What will be asking, B to lock, right there.

1111
00:44:29,100 --> 00:44:29,600
Right?

1112
00:44:29,800 --> 00:44:32,700
And then the number of bytes to write is basically going to be

1113
00:44:32,800 --> 00:44:36,700
however, far, we would go to get to the play cursor because we don't

1114
00:44:36,700 --> 00:44:38,100
want to right past the play curse or so.

1115
00:44:38,100 --> 00:44:41,000
We're just going to write from wherever we are to the play cursor.

1116
00:44:41,000 --> 00:44:42,400
So basically here we go.

1117
00:44:42,800 --> 00:44:45,300
We have got our B to right.

1118
00:44:45,300 --> 00:44:49,200
And basically what we need to know is we need to know whether the play

1119
00:44:49,200 --> 00:44:52,800
cursor is in front of or Behind the B to lock.

1120
00:44:53,000 --> 00:44:57,700
Basically, if the bite to lock is actually in front of, right?

1121
00:44:57,900 --> 00:44:59,800
The play cursor if it's higher than where the plate.

1122
00:45:00,000 --> 00:45:04,800
Sir is because this play cursor again, is also going to be in B, I

1123
00:45:04,800 --> 00:45:07,000
believe let's verify that I don't actually know.

1124
00:45:07,100 --> 00:45:12,800
We didn't, we didn't look, let's take a look address of the variable

1125
00:45:12,800 --> 00:45:14,300
determines the offset in B.

1126
00:45:14,300 --> 00:45:15,300
That's what we want to know.

1127
00:45:15,800 --> 00:45:19,500
So, basically if the bite to lock is above the play cursor, that means

1128
00:45:19,500 --> 00:45:22,000
we have to write all the way to the end of the buffer and that for the

1129
00:45:22,000 --> 00:45:23,400
beginning to the play cursor.

1130
00:45:23,600 --> 00:45:27,000
So basically, that means that our B to right.

1131
00:45:27,000 --> 00:45:28,000
Which is what we're trying to compute.

1132
00:45:28,000 --> 00:45:29,900
Here are B to write is

1133
00:45:30,000 --> 00:45:33,400
Really going to be the buffer size, right?

1134
00:45:33,500 --> 00:45:36,300
So, this is the, I should say, secondary buffer size, is we're clear

1135
00:45:36,300 --> 00:45:36,700
about this.

1136
00:45:37,200 --> 00:45:42,200
The secondary buffer size - wherever, the B to lock is that's how big

1137
00:45:42,200 --> 00:45:45,400
we, that's how far we had to go again, to go back to the diagram.

1138
00:45:45,600 --> 00:45:46,000
Basically.

1139
00:45:46,000 --> 00:45:48,300
I know this sounds complicated and there's tons of finicky math in

1140
00:45:48,300 --> 00:45:51,400
here, but not really it's arithmetic.

1141
00:45:51,400 --> 00:45:54,500
Really basically, what I'm saying is, we've got two cases.

1142
00:45:54,600 --> 00:45:57,000
In fact, let me go ahead and clear that out so I can show the two

1143
00:45:57,000 --> 00:45:57,500
cases.

1144
00:45:57,900 --> 00:45:59,900
So basically we have case 1 and case.

1145
00:46:00,000 --> 00:46:01,700
To and we got to handle both of them.

1146
00:46:01,900 --> 00:46:05,000
So in one case this is this is our right.

1147
00:46:05,000 --> 00:46:07,600
This is our B to right here, right?

1148
00:46:07,600 --> 00:46:09,000
And here was the play cursor.

1149
00:46:09,600 --> 00:46:13,100
This is this is B to write not the right cursor.

1150
00:46:13,100 --> 00:46:15,300
The right cursor, somewhere in here, but we're ignoring the right

1151
00:46:15,300 --> 00:46:15,600
cursor.

1152
00:46:15,600 --> 00:46:16,500
We don't even care where it is.

1153
00:46:16,800 --> 00:46:19,300
So what I'm saying is if this is our B to, right?

1154
00:46:19,300 --> 00:46:22,100
And we see that the play cursor is here, then we know that it's safe

1155
00:46:22,100 --> 00:46:24,900
to fill this part of the buffer and this part of the buffer and this

1156
00:46:24,900 --> 00:46:25,400
is the region.

1157
00:46:25,400 --> 00:46:28,600
We don't want to touch because at basically anywhere in here, we don't

1158
00:46:28,600 --> 00:46:29,800
want to touch because we

1159
00:46:29,900 --> 00:46:31,800
Ready wrote it in the play cursor, still playing.

1160
00:46:31,800 --> 00:46:34,000
Still hasn't played that part yet, if that makes sense.

1161
00:46:34,200 --> 00:46:36,400
So based on what we're going to do is we're going to look at this and

1162
00:46:36,400 --> 00:46:40,400
we're going to say, okay, if the bite to write basically is is greater

1163
00:46:40,400 --> 00:46:42,600
than the play cursor, right?

1164
00:46:42,700 --> 00:46:45,700
If it's greater than it, then we need to do to chunks that chunk.

1165
00:46:45,700 --> 00:46:49,500
And this Chunk on the other hand, if the opposite was true, if here's

1166
00:46:49,500 --> 00:46:52,300
the B to write this is the arbeit to, right?

1167
00:46:52,300 --> 00:46:53,700
And this is our play cursor.

1168
00:46:53,800 --> 00:46:55,300
Then we only have one Chunk.

1169
00:46:55,400 --> 00:46:57,100
We only have this chunk here, right?

1170
00:46:57,200 --> 00:46:58,000
This is case 2.

1171
00:46:58,100 --> 00:46:59,500
So if case one case two,

1172
00:47:00,000 --> 00:47:00,900
That makes some sense.

1173
00:47:01,200 --> 00:47:02,700
That is what I'm trying to, right here.

1174
00:47:04,500 --> 00:47:07,600
So basically, this is the case, this is that case one at the top when

1175
00:47:07,600 --> 00:47:08,400
B to right.

1176
00:47:08,400 --> 00:47:11,500
Sorry, B to lock is above the play cursor.

1177
00:47:11,700 --> 00:47:14,400
Basically, what we need to do is we need to take the secondary buffer

1178
00:47:14,400 --> 00:47:14,700
size.

1179
00:47:14,700 --> 00:47:19,200
So the total buffer size, which is, you know, this whole thing here.

1180
00:47:19,300 --> 00:47:23,500
We're taking that total buffer size and we're subtracting this value

1181
00:47:23,500 --> 00:47:23,900
from it.

1182
00:47:23,900 --> 00:47:26,800
So that we're just producing that number right there, right?

1183
00:47:27,000 --> 00:47:32,100
And then we also need to add the, the plate, the part that part the

1184
00:47:32,100 --> 00:47:32,800
beginning of the buffer.

1185
00:47:32,800 --> 00:47:34,000
So we're basically to add

1186
00:47:34,300 --> 00:47:37,700
That play cursor was because we got to play from zero to that, right?

1187
00:47:37,700 --> 00:47:40,400
Make some sense on the other hand, if they're the other way around,

1188
00:47:40,400 --> 00:47:43,000
then we just have a very simple thing to do, which is say, however,

1189
00:47:43,000 --> 00:47:47,500
far is between those two cursors is how much we're going to write that

1190
00:47:47,500 --> 00:47:48,700
is how much we're going to write.

1191
00:47:48,900 --> 00:47:49,900
So that we go in here.

1192
00:47:49,900 --> 00:47:53,000
We do the lock, we do the lock with that fights to write.

1193
00:47:53,000 --> 00:47:57,300
And then what we do is we basically say, okay our Square wave, counter

1194
00:47:57,300 --> 00:47:59,800
is still in effect, but actually, I guess like I said we

1195
00:48:00,000 --> 00:48:01,200
Get rid of that with a mod.

1196
00:48:02,000 --> 00:48:03,400
I'll show you how to do that in one second.

1197
00:48:04,400 --> 00:48:06,500
I'll get this basically this is all about modding.

1198
00:48:06,500 --> 00:48:08,600
Maybe we should have a little discussion about modding in the Q&A

1199
00:48:08,600 --> 00:48:09,800
since we never really covered modding.

1200
00:48:09,800 --> 00:48:10,600
We'll talk about it.

1201
00:48:10,600 --> 00:48:11,200
A little more detail.

1202
00:48:11,200 --> 00:48:12,000
It's kind of something.

1203
00:48:12,000 --> 00:48:12,500
That's interesting.

1204
00:48:12,500 --> 00:48:12,800
No.

1205
00:48:13,500 --> 00:48:17,000
So basically we are going to go in here and we are going to do two

1206
00:48:17,000 --> 00:48:19,000
regions thing like that.

1207
00:48:19,100 --> 00:48:20,200
Like we wanted to.

1208
00:48:20,200 --> 00:48:24,700
There we go, and we will be writing our stuff as we wanted to.

1209
00:48:25,300 --> 00:48:28,000
And then, so, the only thing we have to do is change our sample value

1210
00:48:28,000 --> 00:48:33,800
to basically be this if statement, instead is just going to be on our

1211
00:48:34,300 --> 00:48:38,200
We're wave period, our sample are running sample.

1212
00:48:38,200 --> 00:48:42,800
Count our sample index rather, mod the square wave period.

1213
00:48:43,100 --> 00:48:46,100
Should basically be what we want to do.

1214
00:48:46,100 --> 00:48:46,900
Is that correct?

1215
00:48:46,900 --> 00:48:51,900
No, sorry / the square wave period divided by 2.

1216
00:48:51,900 --> 00:48:53,000
Yeah man.

1217
00:48:53,000 --> 00:48:56,700
This is, this is a little nuts, but I think that's it, if the running

1218
00:48:56,700 --> 00:49:01,000
sample index, / half the period, that's either going to be 0 or 1.

1219
00:49:03,600 --> 00:49:04,100
So we got

1220
00:49:04,200 --> 00:49:04,700
Ahmad that.

1221
00:49:04,700 --> 00:49:05,800
Yeah, that's that's a little.

1222
00:49:05,800 --> 00:49:06,600
That's a little annoying.

1223
00:49:06,600 --> 00:49:08,800
So I'm going to make a secondary rail for that and then I'll explain

1224
00:49:08,800 --> 00:49:11,500
it assuming that I did it right half.

1225
00:49:11,500 --> 00:49:15,800
We want the half Square wave period, a square wave period equals

1226
00:49:15,900 --> 00:49:17,600
square root 3 divided by 2.

1227
00:49:17,600 --> 00:49:18,200
There we go.

1228
00:49:18,700 --> 00:49:21,100
And so all I'm trying to do here is basically just say.

1229
00:49:21,600 --> 00:49:26,400
So if we have the, the devised that we divide this out by half the

1230
00:49:26,400 --> 00:49:29,100
square root period, Then basically, what we're going to get is which

1231
00:49:29,100 --> 00:49:31,400
half period, we're on, right?

1232
00:49:31,500 --> 00:49:34,100
Basically, if I have a sample index and it's going up, I divide it.

1233
00:49:34,200 --> 00:49:34,900
Half the period.

1234
00:49:34,900 --> 00:49:35,600
We're going to say.

1235
00:49:35,700 --> 00:49:39,800
It's going to be 0 in the first half, period, one in the next one,

1236
00:49:39,800 --> 00:49:41,600
then two in the next one, then three in the next one.

1237
00:49:41,800 --> 00:49:44,800
So basically if you imagine what I'm doing with that divide, if this

1238
00:49:44,800 --> 00:49:46,500
is R square wave, right?

1239
00:49:47,000 --> 00:49:50,900
Basically you can imagine what I'm doing is dividing by half the

1240
00:49:50,900 --> 00:49:51,600
period.

1241
00:49:51,700 --> 00:49:53,500
This is half the period, right?

1242
00:49:53,500 --> 00:49:57,200
This is half period here and dividing by that.

1243
00:49:57,400 --> 00:49:59,700
So the Pacey what that'll give me back is just an integer that counts

1244
00:49:59,700 --> 00:50:01,000
up, which for which half period?

1245
00:50:01,000 --> 00:50:03,500
I mean, they'll go 0 1, 2 3,

1246
00:50:04,200 --> 00:50:06,600
4 5, 6 and so on, right?

1247
00:50:06,700 --> 00:50:10,500
So all I have to then do is look, if the number is even right, if the

1248
00:50:10,500 --> 00:50:12,100
number is even, we should be high.

1249
00:50:12,100 --> 00:50:12,900
If it's negative.

1250
00:50:12,900 --> 00:50:14,000
You should be low or vice versa.

1251
00:50:14,000 --> 00:50:16,800
We don't care which, which phase are thing is.

1252
00:50:17,000 --> 00:50:19,300
So, basically, what I got to do there is I got a mod it by 2.

1253
00:50:19,500 --> 00:50:22,600
I gotta take the mod 2, which says basically 0 or 1.

1254
00:50:22,700 --> 00:50:24,800
Whatever the remainder is when you divide by 2.

1255
00:50:25,000 --> 00:50:28,600
That is the thing that's going to be at its this is actually just goes

1256
00:50:28,600 --> 00:50:29,300
back in there.

1257
00:50:29,600 --> 00:50:31,100
So that's what I'm trying to do here.

1258
00:50:31,200 --> 00:50:31,800
There you go.

1259
00:50:32,300 --> 00:50:34,100
And there that should be just about

1260
00:50:34,300 --> 00:50:35,300
The buffer size.

1261
00:50:35,700 --> 00:50:36,100
Again.

1262
00:50:36,100 --> 00:50:39,400
We got to actually put in here because that's used now.

1263
00:50:39,500 --> 00:50:40,800
Secondary, buffer size.

1264
00:50:41,300 --> 00:50:44,800
And we already again, compute that right there, secondary, buffer

1265
00:50:44,800 --> 00:50:47,100
size, and you'll notice that a lot of these things, kind of work

1266
00:50:47,100 --> 00:50:47,700
themselves out.

1267
00:50:47,700 --> 00:50:47,900
Again.

1268
00:50:47,900 --> 00:50:50,500
This is why I always say compression oriented programming is the best

1269
00:50:50,500 --> 00:50:51,300
way to do things.

1270
00:50:51,500 --> 00:50:53,800
You'll note that basically all I do when I'm trying to write code,

1271
00:50:53,800 --> 00:50:57,000
that's somewhat complicated like this, and that sort of finicky is, I

1272
00:50:57,000 --> 00:50:58,200
just keep writing, whatever.

1273
00:50:58,200 --> 00:50:59,700
The most obvious thing is to write at the

1274
00:51:00,300 --> 00:51:03,800
I don't try to overthink it and then the patterns just kind of emerge.

1275
00:51:03,800 --> 00:51:04,800
You can see everything here.

1276
00:51:04,800 --> 00:51:07,500
If I could even see where we're going to go with this eventually, you

1277
00:51:07,500 --> 00:51:09,200
can see how these two Loops are the same.

1278
00:51:09,300 --> 00:51:11,600
So we'll probably boil that down and so on.

1279
00:51:11,700 --> 00:51:13,300
And basically you just keep pulling stuff out.

1280
00:51:13,300 --> 00:51:14,000
That's common.

1281
00:51:14,200 --> 00:51:16,400
That is the best way to end up with nice working code that does

1282
00:51:16,400 --> 00:51:17,800
exactly what you want to do.

1283
00:51:18,000 --> 00:51:19,300
Is set a try to front load it.

1284
00:51:19,600 --> 00:51:19,900
Okay.

1285
00:51:19,900 --> 00:51:21,100
I got to blow my nose here people.

1286
00:51:21,100 --> 00:51:23,000
I am I have awfully sick today.

1287
00:51:23,000 --> 00:51:27,000
I apologize, man.

1288
00:51:29,200 --> 00:51:31,600
I would like to spare you from that on the stream, but there's really

1289
00:51:31,600 --> 00:51:32,700
not much I can do about it.

1290
00:51:32,700 --> 00:51:33,600
That's just the way it goes.

1291
00:51:34,400 --> 00:51:34,900
Hmm.

1292
00:51:36,200 --> 00:51:36,700
It's awful.

1293
00:51:37,300 --> 00:51:38,100
It is awful.

1294
00:51:38,200 --> 00:51:40,500
All right, let's see here.

1295
00:51:40,500 --> 00:51:43,000
I think we've basically done everything but let's just do a quick spot

1296
00:51:43,000 --> 00:51:45,100
check because there are probably some bugs in this given.

1297
00:51:45,100 --> 00:51:46,300
How many things happened here?

1298
00:51:46,500 --> 00:51:48,000
Let's just do a quick once-over.

1299
00:51:48,000 --> 00:51:50,700
Just, we understand everything that we're trying to do and then we'll

1300
00:51:50,700 --> 00:51:51,900
go debug it.

1301
00:51:52,300 --> 00:51:55,500
So, basically, we basically made our hurts here.

1302
00:51:56,000 --> 00:51:58,300
I'm going to call this our tone hurts because it's basically saying

1303
00:51:58,300 --> 00:51:59,800
art own samples per second.

1304
00:52:01,800 --> 00:52:03,900
However, in the screen that says gross, it is totally true.

1305
00:52:03,900 --> 00:52:04,700
It's awfully gross.

1306
00:52:04,800 --> 00:52:06,200
I have to live with it.

1307
00:52:06,400 --> 00:52:07,600
I have to live with it man.

1308
00:52:08,200 --> 00:52:08,800
That is the thing.

1309
00:52:08,800 --> 00:52:10,100
I've been living with this for like a week.

1310
00:52:10,100 --> 00:52:10,900
It's awful.

1311
00:52:12,700 --> 00:52:14,400
The cautionary tale, do not get sick people.

1312
00:52:14,400 --> 00:52:16,700
That is what I'm telling you do not get sick.

1313
00:52:17,200 --> 00:52:19,700
I'm hoping maybe I'll feel sorry feeling better later today or

1314
00:52:19,700 --> 00:52:20,200
tomorrow.

1315
00:52:20,200 --> 00:52:21,200
It's been a long time.

1316
00:52:21,700 --> 00:52:22,000
All right.

1317
00:52:22,000 --> 00:52:24,300
Anyway, this is our sound stuff here.

1318
00:52:24,400 --> 00:52:27,300
This is just, this was for our Graphics test.

1319
00:52:27,400 --> 00:52:29,000
And this is for our sound test.

1320
00:52:29,100 --> 00:52:31,100
They are not similar at all.

1321
00:52:31,400 --> 00:52:32,500
Okay, now test.

1322
00:52:32,600 --> 00:52:33,900
So we have our samples per second.

1323
00:52:33,900 --> 00:52:34,900
That's 48 kilohertz.

1324
00:52:34,900 --> 00:52:35,800
That's how many were playing.

1325
00:52:35,900 --> 00:52:38,900
We have our tone hurts and that's tones per that.

1326
00:52:38,900 --> 00:52:41,700
You know, this is, this is per second as well.

1327
00:52:42,200 --> 00:52:45,000
We might want to call this sample hurts, but I don't know.

1328
00:52:45,300 --> 00:52:46,200
It's six of one half-dozen.

1329
00:52:46,200 --> 00:52:48,600
The other, Our Town hurts is basically 256.

1330
00:52:48,700 --> 00:52:51,700
So, we are saying it, taking our samples per second and dividing that,

1331
00:52:51,700 --> 00:52:52,300
by the tone hurts.

1332
00:52:52,300 --> 00:52:53,500
That's how many we want.

1333
00:52:53,500 --> 00:52:56,200
We have a half Square wave period which is going to be whatever that

1334
00:52:56,200 --> 00:52:58,500
period is divided by 2, and that's because we want to know ups and

1335
00:52:58,500 --> 00:53:01,200
downs, so we want to build / that we have our B per sample.

1336
00:53:01,600 --> 00:53:05,600
Which basically tells us how many bytes we take two right.

1337
00:53:05,600 --> 00:53:06,500
One left, right?

1338
00:53:06,500 --> 00:53:08,100
Pair each at 16 bits.

1339
00:53:08,200 --> 00:53:09,500
That's times to 16 bits.

1340
00:53:09,600 --> 00:53:11,700
We have a secondary buffer size, which is however make samples per

1341
00:53:11,700 --> 00:53:15,100
second times, the B % sample because we know we have a 1, second

1342
00:53:15,100 --> 00:53:15,600
buffer.

1343
00:53:15,900 --> 00:53:17,400
That's basically what we Define it to be.

1344
00:53:17,700 --> 00:53:24,100
So we in it, direct sound with that and that should be basically

1345
00:53:24,100 --> 00:53:26,000
everything that we needed there.

1346
00:53:26,000 --> 00:53:30,600
I'm going to double check the win32 in its D sound function to make

1347
00:53:30,600 --> 00:53:31,200
sure that that is

1348
00:53:31,400 --> 00:53:33,300
Takes a second and buffer size.

1349
00:53:33,500 --> 00:53:35,700
That's good that that all works.

1350
00:53:36,000 --> 00:53:36,600
All right.

1351
00:53:36,600 --> 00:53:40,400
So we then come in here and now we actually do all the craziness.

1352
00:53:40,400 --> 00:53:43,000
We ask where the play curse in the right cursor is even though we

1353
00:53:43,000 --> 00:53:45,600
don't actually care where the right cursor is.

1354
00:53:45,600 --> 00:53:48,900
So we asked for the play cursor is essentially and let's make sure we

1355
00:53:48,900 --> 00:53:50,000
have those in the right order.

1356
00:53:50,100 --> 00:53:50,400
Yep.

1357
00:53:50,400 --> 00:53:50,800
Play Chris.

1358
00:53:50,800 --> 00:53:51,400
Our first.

1359
00:53:51,600 --> 00:53:52,400
So that's good.

1360
00:53:52,500 --> 00:53:56,300
We then get the bite to lock by taking however, many samples.

1361
00:53:56,300 --> 00:53:58,000
We are in, there's the thing we forgot.

1362
00:53:58,000 --> 00:53:59,000
I knew we forgot something.

1363
00:53:59,000 --> 00:53:59,800
Plus running Sam.

1364
00:54:00,500 --> 00:54:02,900
Index, you gotta add that every time through.

1365
00:54:03,900 --> 00:54:05,700
So we take our running sample index.

1366
00:54:05,700 --> 00:54:09,800
We multiply that, by the B 4 sample, the basically get where we are in

1367
00:54:09,800 --> 00:54:11,300
in the running B.

1368
00:54:11,300 --> 00:54:15,200
So basically an infinitely increasing until we wrap the actual value,

1369
00:54:15,200 --> 00:54:18,900
the actual variable and an infant increasing value of B.

1370
00:54:19,100 --> 00:54:22,900
So then we use the mod to map that into the secondary buffer where we

1371
00:54:22,900 --> 00:54:23,700
are in the actual bummer.

1372
00:54:23,700 --> 00:54:25,600
Cause remember it's kind of the circular buffer thing.

1373
00:54:25,600 --> 00:54:29,100
So we need to take this long linear thing and wrap it into an actual

1374
00:54:29,100 --> 00:54:29,600
buffer.

1375
00:54:30,000 --> 00:54:30,100
We

1376
00:54:30,300 --> 00:54:34,500
And say if the bite to lock was after the play cursor, then we take

1377
00:54:34,700 --> 00:54:35,400
two pieces.

1378
00:54:35,400 --> 00:54:39,000
We're basically going to do two lakhs of risk, and have to fill two

1379
00:54:39,000 --> 00:54:39,500
regions.

1380
00:54:39,900 --> 00:54:43,400
We're going to fill the secondary buffer size - the B to lock, and

1381
00:54:43,400 --> 00:54:45,900
then we're going to fill the play cursors worth from the beginning to

1382
00:54:45,900 --> 00:54:46,400
play coaster with.

1383
00:54:46,400 --> 00:54:48,600
Otherwise, we just feel that the distance in between them.

1384
00:54:49,100 --> 00:54:51,500
That seems totally reasonable.

1385
00:54:52,000 --> 00:54:56,000
We then go through here and we asked to lock exactly that.

1386
00:54:56,000 --> 00:54:59,400
So we should get back in case one will get up five minute warning,

1387
00:54:59,500 --> 00:55:00,100
almost there.

1388
00:55:00,400 --> 00:55:01,300
We should get back either.

1389
00:55:01,300 --> 00:55:04,700
The two chunks in this case or the one Chunk in this other case,

1390
00:55:05,200 --> 00:55:06,800
assuming that we do get them back.

1391
00:55:07,000 --> 00:55:10,400
We then go ahead and we figure out what the region sample counts.

1392
00:55:10,400 --> 00:55:10,700
Are.

1393
00:55:10,900 --> 00:55:12,700
We point to the first region here.

1394
00:55:13,200 --> 00:55:14,300
Let's do it this way.

1395
00:55:14,600 --> 00:55:18,100
Just to make that a little clearer, we point to the, to the

1396
00:55:19,300 --> 00:55:22,400
First region, we find out how many bytes how many samples were got the

1397
00:55:22,400 --> 00:55:23,200
feel for that one.

1398
00:55:23,400 --> 00:55:27,500
We go ahead here and we actually Loop through all of those samples.

1399
00:55:27,800 --> 00:55:30,800
We add to the running sample index each time.

1400
00:55:30,800 --> 00:55:33,100
In fact, we could even stick that right in there.

1401
00:55:33,600 --> 00:55:36,700
Make that a little clearer that that's only getting used just in that

1402
00:55:36,700 --> 00:55:37,500
one place.

1403
00:55:37,700 --> 00:55:38,400
There we go.

1404
00:55:38,500 --> 00:55:40,700
We write out both a left and right value.

1405
00:55:40,700 --> 00:55:42,000
They are exactly the same.

1406
00:55:42,500 --> 00:55:43,400
So that's good.

1407
00:55:43,500 --> 00:55:47,100
We go ahead and do the divided by the half Square wave period.

1408
00:55:47,100 --> 00:55:48,500
Check the mod with two.

1409
00:55:49,000 --> 00:55:51,300
And that looks pretty good.

1410
00:55:51,300 --> 00:55:52,400
So I don't know.

1411
00:55:52,400 --> 00:55:57,300
We could try to run this and I have no idea what will happen, but we

1412
00:55:57,300 --> 00:55:59,900
can certainly try to run it.

1413
00:55:59,900 --> 00:56:02,200
So let's take a look here and see.

1414
00:56:04,700 --> 00:56:05,400
Okay.

1415
00:56:06,200 --> 00:56:09,000
Oh, well, there is one more thing we have to do.

1416
00:56:09,000 --> 00:56:11,300
Before we can test it, that may have worked just fine.

1417
00:56:11,700 --> 00:56:13,500
We have to actually start the sound playing.

1418
00:56:14,000 --> 00:56:16,700
So that's one thing that because we never actually told the buffer, we

1419
00:56:16,700 --> 00:56:19,400
fill were filling the buffer, but we never actually played the sound.

1420
00:56:19,400 --> 00:56:23,400
So we will actually have to also do this one more thing here, which is

1421
00:56:23,400 --> 00:56:26,000
to actually start the buffer playing.

1422
00:56:26,300 --> 00:56:29,200
So we're going to go ahead and start the buffer playing and we can

1423
00:56:29,200 --> 00:56:30,600
basically do that at any time.

1424
00:56:30,900 --> 00:56:33,500
Normally we'd want to fill the buffer first before we start playing

1425
00:56:33,500 --> 00:56:33,600
it.

1426
00:56:33,600 --> 00:56:34,200
But for testing

1427
00:56:34,500 --> 00:56:36,800
Let's just go ahead and do it right here.

1428
00:56:37,300 --> 00:56:39,700
But later we'll kind of have to see maybe how to do that a little bit

1429
00:56:39,700 --> 00:56:40,100
better.

1430
00:56:40,200 --> 00:56:43,400
So Reserve we have to pass zero because all right.

1431
00:56:43,600 --> 00:56:45,800
I don't know why there's some reserved value.

1432
00:56:45,800 --> 00:56:46,100
You pass.

1433
00:56:46,100 --> 00:56:47,700
First the priority.

1434
00:56:48,200 --> 00:56:50,200
I don't think we care about that at all.

1435
00:56:50,200 --> 00:56:54,100
Basically, we don't we don't care about priority because we are only

1436
00:56:54,100 --> 00:56:55,200
playing one sound.

1437
00:56:55,200 --> 00:56:57,800
That is only for playing lots of sound and letting letting it mix them

1438
00:56:57,800 --> 00:56:58,500
or something like this.

1439
00:56:58,500 --> 00:56:59,700
I don't think we care about that at all.

1440
00:57:00,400 --> 00:57:02,000
We are going to Loop this buffer.

1441
00:57:02,000 --> 00:57:03,800
We want it to basically play forever.

1442
00:57:04,100 --> 00:57:05,100
So we're going to Loop it.

1443
00:57:05,600 --> 00:57:07,500
Is there any other flags that we need?

1444
00:57:08,300 --> 00:57:09,300
Let's see.

1445
00:57:09,300 --> 00:57:10,800
We don't care about that.

1446
00:57:11,100 --> 00:57:13,500
We don't care about any of that.

1447
00:57:13,700 --> 00:57:15,500
So I think we're pretty much good to go.

1448
00:57:15,900 --> 00:57:20,000
We will just go ahead and start that sound playing secondary, buffer,

1449
00:57:21,400 --> 00:57:23,700
Global secondary, buffer.

1450
00:57:24,400 --> 00:57:27,000
There we go, and let's see here.

1451
00:57:28,000 --> 00:57:33,200
Do we, wow, well, the square wave Works.

1452
00:57:33,200 --> 00:57:37,000
Ladies and gentlemen, that much was clear.

1453
00:57:37,900 --> 00:57:40,400
That was extremely loud in my ear.

1454
00:57:40,400 --> 00:57:43,200
I think we're going to go ahead and and maybe I don't know if I should

1455
00:57:43,200 --> 00:57:47,500
turn down my sound here, or if I should just go ahead and make this.

1456
00:57:47,500 --> 00:57:49,100
Let's make the volume of parameter.

1457
00:57:49,300 --> 00:57:50,100
Holy cow.

1458
00:57:50,500 --> 00:57:54,100
That was that was a little, a little jarring.

1459
00:57:54,400 --> 00:57:56,800
I don't know how loud it was for the folks at home.

1460
00:57:57,100 --> 00:57:57,600
But if for

1461
00:57:58,500 --> 00:58:02,000
It was a bit bit loud.

1462
00:58:02,200 --> 00:58:04,100
The good news is, it does sound like it worked?

1463
00:58:04,100 --> 00:58:06,800
Although, who knows we could have still have some bugs in there.

1464
00:58:07,200 --> 00:58:10,600
But the basic basic thing seemed to work.

1465
00:58:10,700 --> 00:58:13,800
I'm going to go ahead and set that to be a little bit lower.

1466
00:58:14,000 --> 00:58:15,400
That's where wave was Extremely Loud.

1467
00:58:15,400 --> 00:58:19,800
Let's just say, maybe maybe 6,000 something like that.

1468
00:58:19,900 --> 00:58:22,500
That seems a little bit easier on the ears.

1469
00:58:28,000 --> 00:58:30,100
So that does not sound quite right to me.

1470
00:58:30,100 --> 00:58:31,800
I think we still have a bug in there.

1471
00:58:32,200 --> 00:58:34,200
I can basically hear a clicking over.

1472
00:58:34,300 --> 00:58:37,400
Let me double check that I actually put out the tone volume correctly.

1473
00:58:37,400 --> 00:58:38,500
Yeah, there we go.

1474
00:58:39,300 --> 00:58:40,000
Let's see here.

1475
00:58:40,000 --> 00:58:40,700
Let me make that.

1476
00:58:40,700 --> 00:58:44,000
Just even a little bit quieter, still just to not blow out your drums

1477
00:58:44,000 --> 00:58:44,500
at all.

1478
00:58:48,700 --> 00:58:50,100
That is still awful loud.

1479
00:58:50,100 --> 00:58:50,600
I do not know.

1480
00:58:50,600 --> 00:58:54,700
I wonder if we have a bug that, that that is, that is actually causing

1481
00:58:54,700 --> 00:58:56,200
it to be louder than it should be.

1482
00:58:56,600 --> 00:58:59,100
That's an interesting question as well.

1483
00:58:59,100 --> 00:58:59,400
All right.

1484
00:58:59,400 --> 00:59:01,800
Well, anyway, I think we've got a bug here.

1485
00:59:01,900 --> 00:59:03,900
So I think mmmm.

1486
00:59:04,500 --> 00:59:05,500
What should we do?

1487
00:59:06,100 --> 00:59:08,200
I think we only have a minute left.

1488
00:59:08,200 --> 00:59:11,100
So I think basically what we're going to do is we're basically going

1489
00:59:11,100 --> 00:59:15,100
to mark this as buggy and we're going to debug it tomorrow.

1490
00:59:15,500 --> 00:59:22,000
Because that I think is the sanest thing to actually do would be my

1491
00:59:22,100 --> 00:59:23,500
would be, my guess.

1492
00:59:24,200 --> 00:59:25,400
What is the stream saying?

1493
00:59:26,500 --> 00:59:27,300
What about unlocking?

1494
00:59:27,300 --> 00:59:27,800
The buffer?

1495
00:59:27,800 --> 00:59:28,000
Yes.

1496
00:59:28,000 --> 00:59:28,600
That's right.

1497
00:59:28,700 --> 00:59:29,700
We forgot that as well.

1498
00:59:29,900 --> 00:59:30,300
Duh.

1499
00:59:30,800 --> 00:59:32,800
It's hard to remember everything when you're on the street in waves

1500
00:59:32,800 --> 00:59:34,200
and John and unlocking, the buffer.

1501
00:59:34,400 --> 00:59:35,300
We do need to do that.

1502
00:59:35,300 --> 00:59:36,100
I think all we pass.

1503
00:59:36,100 --> 00:59:38,500
Yeah, we just passed exactly what we pass before.

1504
00:59:39,000 --> 00:59:43,200
So maybe that is the only problem I doubt it, but I think we've got

1505
00:59:43,200 --> 00:59:44,100
another problem as well.

1506
00:59:44,100 --> 00:59:45,000
But if we

1507
00:59:45,200 --> 00:59:45,900
Were lucky.

1508
00:59:45,900 --> 00:59:49,100
It could be that it was just that we weren't unlocking the buffer and

1509
00:59:49,100 --> 00:59:50,600
direct sound was getting confused.

1510
00:59:50,600 --> 00:59:51,700
But I don't think that's it.

1511
00:59:51,700 --> 00:59:54,000
I think that that was definitely a bug as well.

1512
00:59:54,400 --> 00:59:55,900
So we definitely want to do that.

1513
00:59:56,000 --> 00:59:58,900
It's just, I don't think that's our only problem.

1514
00:59:59,400 --> 00:59:59,800
Okay.

1515
01:00:00,300 --> 01:00:00,800
There we go.

1516
01:00:06,200 --> 01:00:08,100
Well, now that actually does sound right.

1517
01:00:10,800 --> 01:00:11,800
All right, that's good.

1518
01:00:11,800 --> 01:00:13,000
We made that may have just been all.

1519
01:00:13,000 --> 01:00:15,400
We just what I said, we have to unlock the buffer and then didn't

1520
01:00:15,400 --> 01:00:17,900
unlock the buffer that may have been one of our only problems.

1521
01:00:18,100 --> 01:00:19,200
I don't actually know.

1522
01:00:19,700 --> 01:00:24,000
I'm going to say more strenuous test.

1523
01:00:24,100 --> 01:00:24,500
Here.

1524
01:00:24,900 --> 01:00:27,100
We should probably look at that buffer verify that it looks like what

1525
01:00:27,100 --> 01:00:29,400
we think it should look like, things like that.

1526
01:00:29,600 --> 01:00:35,600
But for now, it does look like we were basically able to make it to

1527
01:00:35,600 --> 01:00:38,600
make it actually work properly.

1528
01:00:38,600 --> 01:00:40,400
I think on the stream Steel.

1529
01:00:40,600 --> 01:00:43,800
I'm says create a new variable but then didn't set anything equal to

1530
01:00:43,800 --> 01:00:44,300
it.

1531
01:00:44,500 --> 01:00:45,900
I'm not sure what you mean by that.

1532
01:00:45,900 --> 01:00:49,600
I probably just dropped one in here and then didn't actually use it.

1533
01:00:49,600 --> 01:00:50,100
I guess.

1534
01:00:50,100 --> 01:00:53,300
I'm not sure where you're talking about.

1535
01:00:53,400 --> 01:00:55,300
But I guess we're going to go into the Q&A here.

1536
01:00:55,800 --> 01:00:58,000
So in a second, so maybe we can talk about that.

1537
01:00:58,700 --> 01:01:00,700
All right, that was actually pretty productive.

1538
01:01:00,900 --> 01:01:02,200
We actually have sound output.

1539
01:01:02,200 --> 01:01:02,600
Now.

1540
01:01:03,000 --> 01:01:04,200
This is basically all.

1541
01:01:04,200 --> 01:01:06,600
I mean, like I said, I want to test this a little more to make sure

1542
01:01:06,600 --> 01:01:08,500
sound is very finicky and you want to make sure you're doing

1543
01:01:08,500 --> 01:01:10,200
everything just so but

1544
01:01:10,500 --> 01:01:15,300
Actually, we've got the essentials down for actually, outputting sound

1545
01:01:15,300 --> 01:01:16,100
through direct sound.

1546
01:01:16,100 --> 01:01:18,700
This would allow us to Output, basically, anything that we wanted to

1547
01:01:18,700 --> 01:01:20,400
Output effectively.

1548
01:01:20,400 --> 01:01:24,400
We could, we could just go ahead and and output music right now.

1549
01:01:24,400 --> 01:01:27,700
If we wanted to, we could write a wave, you know, from a WAV file into

1550
01:01:27,700 --> 01:01:29,600
here and we would get full sound output.

1551
01:01:29,600 --> 01:01:34,000
So we have basically done everything that we need for our our sound

1552
01:01:34,000 --> 01:01:34,600
output.

1553
01:01:35,400 --> 01:01:35,900
Where is

1554
01:01:37,300 --> 01:01:38,200
Let's see here.

1555
01:01:38,400 --> 01:01:39,500
It's still super loud.

1556
01:01:39,500 --> 01:01:40,300
Compared to voice on the street.

1557
01:01:40,300 --> 01:01:41,800
Yeah, we should actually.

1558
01:01:41,800 --> 01:01:45,000
Now that we actually have sound, I need to go in there and adjust the

1559
01:01:45,000 --> 01:01:48,400
sound volume on stream will do.

1560
01:01:48,400 --> 01:01:52,800
That will definitely do that so that I can talk over it as necessary,

1561
01:01:53,000 --> 01:01:54,300
sound volume on stream.

1562
01:01:54,900 --> 01:01:58,000
So, that'll be good, tone volume.

1563
01:01:59,600 --> 01:02:00,000
Let's see.

1564
01:02:00,000 --> 01:02:01,200
Your steel Golem in 16.

1565
01:02:01,200 --> 01:02:02,100
Total volume equals.

1566
01:02:02,100 --> 01:02:04,900
4,000 this?

1567
01:02:04,900 --> 01:02:06,100
You're talking about this thing.

1568
01:02:07,900 --> 01:02:08,300
I don't know.

1569
01:02:08,300 --> 01:02:09,600
Tone volume gets used, right.

1570
01:02:09,600 --> 01:02:09,700
There.

1571
01:02:09,700 --> 01:02:10,000
It is.

1572
01:02:10,000 --> 01:02:12,400
It's up to 3,000 and then it gets used right here.

1573
01:02:12,600 --> 01:02:13,400
That's, that's what I thought.

1574
01:02:13,400 --> 01:02:14,200
It was supposed to be.

1575
01:02:15,900 --> 01:02:17,100
Yeah, there you go.

1576
01:02:17,700 --> 01:02:20,600
So anyway, that is the end of todays.

1577
01:02:20,600 --> 01:02:21,300
Handmade hero.

1578
01:02:21,300 --> 01:02:24,300
We will now be taking questions for 30 minutes while we.

1579
01:02:24,300 --> 01:02:25,400
I guess I will be taking questions.

1580
01:02:25,400 --> 01:02:26,700
There's no one else here to answer them.

1581
01:02:27,200 --> 01:02:28,800
You will be asking questions and I'll be taking them.

1582
01:02:28,800 --> 01:02:30,300
So we will be doing questions.

1583
01:02:32,000 --> 01:02:34,400
But I do know.

1584
01:02:34,400 --> 01:02:35,400
It's pretty productive.

1585
01:02:35,400 --> 01:02:38,400
That is some very finicky code to write doing the circular buffer

1586
01:02:38,400 --> 01:02:38,900
stuff.

1587
01:02:38,900 --> 01:02:40,700
I would love to go over it here in the Q&A.

1588
01:02:40,700 --> 01:02:43,300
Maybe we'll take a few minutes just to kind of talk about this a

1589
01:02:43,300 --> 01:02:47,200
little bit more detail because I kind of had to back, you know,

1590
01:02:47,200 --> 01:02:49,200
through it as we kind of wrote out the code and go.

1591
01:02:49,200 --> 01:02:49,400
Okay.

1592
01:02:49,400 --> 01:02:50,200
I think I'm gonna do it like this.

1593
01:02:50,200 --> 01:02:51,200
I'm going to do it like that.

1594
01:02:51,400 --> 01:02:54,400
The other thing I'm going to do here is going to say to do collapse.

1595
01:02:54,400 --> 01:02:58,900
These two Loops like because they're the same.

1596
01:03:00,000 --> 01:03:02,200
That should be pretty easy to do too next time.

1597
01:03:02,700 --> 01:03:06,800
So basically, yeah, we'll go ahead and do Q&A here, but for a minute,

1598
01:03:06,900 --> 01:03:09,800
I just want to kind of go through and just really reinforced kind of

1599
01:03:09,800 --> 01:03:10,600
what happened here.

1600
01:03:11,200 --> 01:03:13,900
That especially this this part may be right here, which we didn't

1601
01:03:13,900 --> 01:03:14,900
cover in too much detail.

1602
01:03:14,900 --> 01:03:16,600
Let me just draw, one more diagram for you.

1603
01:03:17,000 --> 01:03:20,300
Now that we actually have the diagrams working for some definition of

1604
01:03:20,300 --> 01:03:20,800
working.

1605
01:03:21,100 --> 01:03:23,700
I don't want to say it to strength strenuously.

1606
01:03:24,000 --> 01:03:28,800
So basically what we want to do right is we want to Output this wave,

1607
01:03:29,100 --> 01:03:29,400
right?

1608
01:03:29,400 --> 01:03:29,900
This is what I

1609
01:03:30,000 --> 01:03:32,900
I was trying to Output just a basic whole Square wave, but you can

1610
01:03:32,900 --> 01:03:35,700
imagine that this is going to get more complicated over time because

1611
01:03:35,700 --> 01:03:38,200
we're basically going to Output real waves to it.

1612
01:03:38,200 --> 01:03:41,200
And so basically, this this exact code is Zach, what we're going to do

1613
01:03:41,300 --> 01:03:43,500
to Output the music for the game, and the sounds for the game.

1614
01:03:43,500 --> 01:03:44,000
It's all the same.

1615
01:03:44,000 --> 01:03:45,200
We're just going to be putting a different way.

1616
01:03:45,200 --> 01:03:48,000
Instead of a square wave, going to be outputting basically the output

1617
01:03:48,000 --> 01:03:51,100
of our mixer, which is basically to take wav files, bring them

1618
01:03:51,100 --> 01:03:54,100
together and mix them together and then eventually compressed some

1619
01:03:54,100 --> 01:03:56,100
kind of compressed sound format, but that's much later.

1620
01:03:56,900 --> 01:03:57,400
Okay.

1621
01:03:57,500 --> 01:03:59,800
So basically if you if you imagine we're trying to

1622
01:04:00,000 --> 01:04:02,200
Put this, but then we've got a buffer.

1623
01:04:02,200 --> 01:04:03,500
Let's say this right here.

1624
01:04:03,500 --> 01:04:07,700
Let's say this is, you know, five seconds long, right?

1625
01:04:08,400 --> 01:04:11,600
It's five seconds long, but we have a buffer and our buffer, right is

1626
01:04:11,600 --> 01:04:13,800
only one second long, right?

1627
01:04:14,500 --> 01:04:18,000
So, basically, we have to fit this into this and that's obviously not

1628
01:04:18,000 --> 01:04:18,600
possible.

1629
01:04:18,700 --> 01:04:21,400
So what we're doing is we're essentially mapping.

1630
01:04:21,800 --> 01:04:24,600
We're going to start direct sound playing this buffer, and what we're

1631
01:04:24,600 --> 01:04:27,500
doing is, were essentially mapping this sound right.

1632
01:04:27,500 --> 01:04:29,800
The first chunk Maps directly to the buffer.

1633
01:04:29,900 --> 01:04:33,200
When we write it, so we write that in there, but then we have to wait

1634
01:04:33,200 --> 01:04:36,400
and as direct sound plays more of it like as the bricks and gets to

1635
01:04:36,400 --> 01:04:36,600
here.

1636
01:04:36,600 --> 01:04:40,600
Let's say we kind of come through, we lock the buffer and what you

1637
01:04:40,600 --> 01:04:43,000
know, it's got still some of the square wave in here.

1638
01:04:43,000 --> 01:04:44,300
It got in it ends right there.

1639
01:04:44,300 --> 01:04:44,900
So it's actually well.

1640
01:04:44,900 --> 01:04:45,900
I guess we should actually end.

1641
01:04:45,900 --> 01:04:48,600
I should try to draw that actually like it actually looks might be a

1642
01:04:48,600 --> 01:04:49,200
little clearer.

1643
01:04:50,500 --> 01:04:51,400
Let's try that.

1644
01:04:51,800 --> 01:04:56,100
So basically, if you imagine, right, it has copied this part in there

1645
01:04:56,100 --> 01:04:57,200
and playing that part.

1646
01:04:57,200 --> 01:05:01,100
Still, we now want to keep playing at this part, but we're at the end

1647
01:05:01,100 --> 01:05:01,600
of the buffer.

1648
01:05:01,600 --> 01:05:04,200
So when we have room at the beginning, when directsound finishes

1649
01:05:04,200 --> 01:05:07,100
playing out of this part and it's done with it, we are going to copy

1650
01:05:07,100 --> 01:05:08,800
this part, right?

1651
01:05:08,900 --> 01:05:13,100
We're going to put that in here so that the sound continues right?

1652
01:05:13,300 --> 01:05:14,100
Does that make sense?

1653
01:05:14,300 --> 01:05:16,900
So basically what we're doing is we're just mapping parts of this.

1654
01:05:16,900 --> 01:05:19,800
We're copying them into the right places in the buffer.

1655
01:05:20,100 --> 01:05:24,300
That were essentially mapping a long linear thing into a rolling

1656
01:05:24,300 --> 01:05:28,900
circular Thing by just putting in however, much right behind as direct

1657
01:05:29,000 --> 01:05:29,600
sound reads it.

1658
01:05:29,600 --> 01:05:31,300
We're just putting in new stuff behind there.

1659
01:05:31,500 --> 01:05:34,900
So, that as it as it comes back around again, it gets the new stuff.

1660
01:05:34,900 --> 01:05:40,100
So the mod operator, which is mod or you know, you can think of it as

1661
01:05:40,100 --> 01:05:42,100
taking the remainder, right?

1662
01:05:42,900 --> 01:05:46,800
The reason that I wanted to do that is because basically if we divide

1663
01:05:46,900 --> 01:05:49,600
some point, if we have some place,

1664
01:05:50,000 --> 01:05:51,000
Right in here.

1665
01:05:51,000 --> 01:05:55,800
Let's say an arbitrary point in here and we divide it by the size of

1666
01:05:55,800 --> 01:05:56,600
this buffer.

1667
01:05:57,300 --> 01:05:57,900
Right?

1668
01:05:58,200 --> 01:05:59,800
What we will get is the

1669
01:06:00,000 --> 01:06:04,400
Remainder of of that division, right?

1670
01:06:04,400 --> 01:06:07,700
And the division, the whole number part of the division, right?

1671
01:06:07,700 --> 01:06:10,900
You know, if we do that division you imagine you do that Division and

1672
01:06:10,900 --> 01:06:11,600
you're going to get back.

1673
01:06:11,600 --> 01:06:17,500
The whole number part is going to be 0 1, 2 3, depending on how many

1674
01:06:17,500 --> 01:06:19,500
full buffer lengths you were in.

1675
01:06:19,500 --> 01:06:23,000
So if you are one full buffer length in the whole part, the whole

1676
01:06:23,000 --> 01:06:25,000
number part of the division would be 1, right?

1677
01:06:25,000 --> 01:06:29,400
But the remainder part of the integer division will be how many

1678
01:06:30,000 --> 01:06:30,600
It's in.

1679
01:06:30,700 --> 01:06:35,200
You were in that region in that in that whole number region, which is

1680
01:06:35,200 --> 01:06:36,600
exactly what we want.

1681
01:06:36,700 --> 01:06:42,300
The mod gives us where we are relative to some whole number region

1682
01:06:42,400 --> 01:06:45,300
that is defined by the terms of the mod.

1683
01:06:45,400 --> 01:06:49,600
So, if we do basically, you know, some Index, this is our index.

1684
01:06:49,900 --> 01:06:57,500
If we do an index mod the size right, then what that gives us back is

1685
01:06:57,500 --> 01:06:59,600
it gives us a relative index.

1686
01:06:59,600 --> 01:06:59,900
It's

1687
01:07:00,000 --> 01:07:02,400
See, a thing that turns an absolute Index.

1688
01:07:02,600 --> 01:07:05,300
This is an absolute index into a relative index and that's what we

1689
01:07:05,300 --> 01:07:05,900
wanted.

1690
01:07:06,000 --> 01:07:11,000
So, hopefully, that makes some sense and, and you can understand

1691
01:07:11,000 --> 01:07:12,200
what's going on with that mod.

1692
01:07:13,000 --> 01:07:17,500
Now the mod showed up again, and it was used in exactly the same way.

1693
01:07:17,900 --> 01:07:19,300
Basically, we had Hoops.

1694
01:07:19,400 --> 01:07:20,100
That's no good.

1695
01:07:20,200 --> 01:07:22,200
Always resets me to being the selection rectangle.

1696
01:07:22,200 --> 01:07:25,900
When I clear everything, which I didn't want, anyway, basically, the

1697
01:07:25,900 --> 01:07:28,900
other thing that I wanted to do that, I use the mod for is, you can

1698
01:07:28,900 --> 01:07:29,800
remember I did this.

1699
01:07:29,900 --> 01:07:30,900
This, right?

1700
01:07:31,000 --> 01:07:34,000
And I said, I want to know whether to Output this value.

1701
01:07:34,100 --> 01:07:36,600
Like I wanted to know whether op out the positive value.

1702
01:07:36,600 --> 01:07:40,000
This again, is the zero Line running through here or if I wanted to do

1703
01:07:40,000 --> 01:07:41,100
the negative value.

1704
01:07:41,200 --> 01:07:43,200
Which one did I want to do, right?

1705
01:07:45,000 --> 01:07:46,100
Positive or negative tone.

1706
01:07:46,800 --> 01:07:49,400
And so basically what I did there is, I said, well, okay, whatever our

1707
01:07:49,400 --> 01:07:52,300
period is, whatever our frequency is that we want to Output.

1708
01:07:52,800 --> 01:07:57,900
I think we call that 256 Hertz, basically, whatever our number of

1709
01:07:57,900 --> 01:07:58,900
samples is here.

1710
01:07:59,000 --> 01:08:01,100
We basically computed using 256 Hertz.

1711
01:08:01,200 --> 01:08:07,600
We computed the samples basically / whole oscillation, right?

1712
01:08:07,800 --> 01:08:10,200
And then I said, well, let's take the half of that.

1713
01:08:10,200 --> 01:08:11,400
We took a half of that.

1714
01:08:11,400 --> 01:08:12,000
Right?

1715
01:08:12,300 --> 01:08:14,700
Well the half of that again, just does that same.

1716
01:08:14,900 --> 01:08:15,700
Relative thing.

1717
01:08:15,900 --> 01:08:19,500
Basically, what we're doing is we're saying where are we in terms of

1718
01:08:19,500 --> 01:08:20,399
half periods.

1719
01:08:20,700 --> 01:08:23,100
So basically an absolute sample index.

1720
01:08:23,399 --> 01:08:31,100
A sample Index, right, modded by the half period, is going to give us

1721
01:08:31,100 --> 01:08:35,100
a whole number, which corresponds, to which one of these buckets,

1722
01:08:35,100 --> 01:08:37,200
we're actually in, right?

1723
01:08:37,899 --> 01:08:40,800
So what I wanted to do of sorry about that,

1724
01:08:41,899 --> 01:08:42,700
/.

1725
01:08:43,399 --> 01:08:44,800
So the sampling is divided by the half.

1726
01:08:44,800 --> 01:08:46,500
Period, gives me the whole number.

1727
01:08:46,500 --> 01:08:47,600
I didn't want the mod yet.

1728
01:08:47,600 --> 01:08:48,800
I just wanted that, right.

1729
01:08:48,800 --> 01:08:50,800
It's the opposite of the other thing.

1730
01:08:50,800 --> 01:08:53,800
We did in the in the previous one, where we just wanted the remainder

1731
01:08:53,899 --> 01:08:54,100
here.

1732
01:08:54,100 --> 01:08:56,600
We actually want the whole numbers, 0 1, 2 3 4.

1733
01:08:56,800 --> 01:08:58,399
So as this goes up.

1734
01:08:58,399 --> 01:08:59,800
We basically just have a number that counts up.

1735
01:09:00,200 --> 01:09:02,800
That tells us which half period were in.

1736
01:09:03,000 --> 01:09:08,000
So what the mod then does mod to basically, just says, well, what's

1737
01:09:08,000 --> 01:09:09,800
the remainder when this is divided by 2.

1738
01:09:09,800 --> 01:09:15,300
Well the remainder when divided by 2, you know, 0 / 2, right is going

1739
01:09:15,300 --> 01:09:16,200
to give us 0.

1740
01:09:16,200 --> 01:09:22,600
1 divided by 2 is going to give us 0 2, divided by 2, right is going

1741
01:09:22,600 --> 01:09:25,500
to give us 1 and so on, right?

1742
01:09:26,399 --> 01:09:29,800
That's how that's going to work and the remainder of that.

1743
01:09:30,000 --> 01:09:32,300
Division is what we will get when we asked the mod.

1744
01:09:32,300 --> 01:09:33,600
So what's the remainder?

1745
01:09:34,000 --> 01:09:37,200
When we do 0, you know, when we do this, it's going to be zero.

1746
01:09:37,200 --> 01:09:39,300
What's the remainder when we do 1 divided by 2.

1747
01:09:39,300 --> 01:09:40,000
Well, it's one.

1748
01:09:40,000 --> 01:09:41,200
What's the remainder here?

1749
01:09:41,200 --> 01:09:42,500
It's 0, right?

1750
01:09:42,500 --> 01:09:48,100
And that keeps going, and it basically just oscillates 01, 01, 01.

1751
01:09:48,200 --> 01:09:51,600
Now someone on the, on the chat said, could you just look at the Loeb

1752
01:09:51,600 --> 01:09:52,000
it?

1753
01:09:52,600 --> 01:09:55,400
And the answer is yes, and not only is it?

1754
01:09:55,400 --> 01:09:56,500
Yes, but that is exactly.

1755
01:09:56,500 --> 01:09:58,500
I believe what the optimizer would do here.

1756
01:09:58,900 --> 01:09:59,900
I don't actually know if

1757
01:10:00,000 --> 01:10:02,700
It's true because there may be some odd rules forces, not do that.

1758
01:10:02,700 --> 01:10:05,400
If this was performance critical code, you would probably write it

1759
01:10:05,400 --> 01:10:06,700
directly as.

1760
01:10:06,700 --> 01:10:09,700
And one, basically, to look at what that lobe.

1761
01:10:09,700 --> 01:10:12,800
It actually is if you actually care, but this is not, this is just

1762
01:10:12,800 --> 01:10:13,300
test code.

1763
01:10:13,300 --> 01:10:16,700
So we use mod because that's, that's the logical operation, you're

1764
01:10:16,700 --> 01:10:17,100
doing.

1765
01:10:17,300 --> 01:10:19,200
And I'd rather show you the logical operation.

1766
01:10:19,200 --> 01:10:23,000
But yes, and 1 and mod 2 are the same for these values.

1767
01:10:24,700 --> 01:10:27,500
Okay, hopefully, that's relatively clear.

1768
01:10:27,500 --> 01:10:28,200
What's going on?

1769
01:10:28,200 --> 01:10:30,300
And everyone sort of roughly follows that.

1770
01:10:30,500 --> 01:10:33,600
Now, we will go ahead and go to the question and answers.

1771
01:10:33,900 --> 01:10:38,600
Please, remember to prefix your question with at senior ettore so I

1772
01:10:38,600 --> 01:10:39,700
can see it.

1773
01:10:41,600 --> 01:10:42,600
Let's take a look.

1774
01:10:47,700 --> 01:10:48,700
Let's see.

1775
01:10:49,900 --> 01:10:55,500
Looks like I answered most of these do

1776
01:11:04,700 --> 01:11:06,900
Sorry, I just taking a second to scan through all the questions that

1777
01:11:06,900 --> 01:11:08,000
have already built up.

1778
01:11:10,700 --> 01:11:12,300
How will the schedule look in the future?

1779
01:11:12,300 --> 01:11:13,400
Will this amazingly Europe?

1780
01:11:13,400 --> 01:11:14,700
Friendly time being at place at other times?

1781
01:11:14,700 --> 01:11:17,600
Yes, every Friday at least will be Europe, friendly.

1782
01:11:17,600 --> 01:11:18,400
That is the goal.

1783
01:11:21,500 --> 01:11:24,800
Why don't we use x audio to because it does not support older

1784
01:11:24,800 --> 01:11:25,400
platforms.

1785
01:11:25,400 --> 01:11:28,200
That is why I want to make sure we actually run on Windows XP.

1786
01:11:28,400 --> 01:11:30,900
Not because I think you need to run on Windows XP.

1787
01:11:31,100 --> 01:11:34,200
I think it's down to like less than 10% of all computers right now.

1788
01:11:34,300 --> 01:11:38,100
So I'm not not trying to push XP compatibility on anybody.

1789
01:11:38,100 --> 01:11:41,400
You probably can start with Windows Vista and just say Vista and up is

1790
01:11:41,400 --> 01:11:44,800
fine, which I don't, I don't know if x audio to even works on

1791
01:11:44,800 --> 01:11:45,100
business.

1792
01:11:45,100 --> 01:11:48,000
That might be actually a legitimate reason why you might not want to

1793
01:11:48,000 --> 01:11:48,600
use it2.

1794
01:11:48,600 --> 01:11:50,800
I'm not sure we're outside to Works necessarily, but

1795
01:11:51,000 --> 01:11:53,700
Basically what I want to make sure we do is on a default install of

1796
01:11:53,700 --> 01:11:54,400
Windows XP.

1797
01:11:54,400 --> 01:11:55,100
We should run.

1798
01:11:55,500 --> 01:11:58,300
And the reason I want to do that is to show you how to get used to

1799
01:11:58,300 --> 01:11:59,500
thinking about.

1800
01:12:00,000 --> 01:12:03,200
Installing and running properly without forcing the user, to go,

1801
01:12:03,200 --> 01:12:05,900
download 10 million drivers, and installing all these, all these

1802
01:12:05,900 --> 01:12:07,700
different things because you actually need to do most of that if you

1803
01:12:07,700 --> 01:12:10,100
just write your code sensibly, so it's just as an exercise room do

1804
01:12:10,100 --> 01:12:10,500
that.

1805
01:12:10,600 --> 01:12:14,100
So we're not using anything that wasn't on XP since direct Sound Works

1806
01:12:14,100 --> 01:12:14,700
totally fine.

1807
01:12:14,700 --> 01:12:16,400
Like, as you can see we got sound output.

1808
01:12:16,400 --> 01:12:17,400
We're pretty much done there.

1809
01:12:17,400 --> 01:12:18,300
Wasn't much to it.

1810
01:12:18,300 --> 01:12:21,800
There's really no reason to go use x audio, maybe you could get lower

1811
01:12:21,800 --> 01:12:22,400
latency with it.

1812
01:12:22,400 --> 01:12:24,400
I don't know what the, what the deal is with that stuff.

1813
01:12:24,900 --> 01:12:27,200
But honestly, there really isn't much reason to go.

1814
01:12:27,200 --> 01:12:27,800
He's like, so you're too.

1815
01:12:27,800 --> 01:12:29,900
It's just kind of a waste of time and makes you less.

1816
01:12:30,000 --> 01:12:33,500
Also, I don't actually really know that there's any reason to use it.

1817
01:12:33,600 --> 01:12:36,100
But if you want to use it, go right ahead.

1818
01:12:36,500 --> 01:12:38,900
I am using direct sun because I want to make sure we can do XP

1819
01:12:38,900 --> 01:12:40,100
compatibility as an exercise.

1820
01:12:44,900 --> 01:12:47,000
Are we going to factor sampling into a separate function?

1821
01:12:47,000 --> 01:12:48,800
It will actually be more than one function.

1822
01:12:48,800 --> 01:12:49,300
But yes.

1823
01:12:52,200 --> 01:12:53,300
Let's see here.

1824
01:12:57,300 --> 01:13:00,000
One mod 2 is 1 not 0.

1825
01:13:00,400 --> 01:13:01,500
That is what I wrote.

1826
01:13:02,100 --> 01:13:03,100
This is, this is the line.

1827
01:13:03,100 --> 01:13:06,800
I wrote I said 1 divided by 2 is 0 and the remainder is 1, that is

1828
01:13:06,800 --> 01:13:07,600
what I wrote here.

1829
01:13:07,900 --> 01:13:09,000
And that is correct.

1830
01:13:09,200 --> 01:13:11,000
This this is the mod Line.

1831
01:13:11,100 --> 01:13:12,700
This is the divided divided Line.

1832
01:13:12,700 --> 01:13:15,100
This is the result of the divides developed to the mod.

1833
01:13:15,200 --> 01:13:17,400
So these go up basically.

1834
01:13:17,700 --> 01:13:21,400
Right 3, divided by 2, is still going to be 14.

1835
01:13:22,000 --> 01:13:24,400
Divided by 2 is going to be 2.

1836
01:13:24,500 --> 01:13:26,100
So basically when you divide by

1837
01:13:26,500 --> 01:13:30,300
You go up every time you increment the thing you're dividing by you go

1838
01:13:30,300 --> 01:13:30,700
up.

1839
01:13:30,700 --> 01:13:31,500
Every other one.

1840
01:13:31,500 --> 01:13:32,600
You go up by 1.

1841
01:13:32,600 --> 01:13:34,300
So 0 0 1 1 2.

1842
01:13:34,300 --> 01:13:37,700
2 3 3 4 4, 5 5 and the mod oscillates.

1843
01:13:37,700 --> 01:13:39,400
0 1 0 1 0 1

1844
01:13:42,400 --> 01:13:43,700
Let's see.

1845
01:13:45,300 --> 01:13:47,900
Why don't I name the secondary buffer sound buffer, something.

1846
01:13:47,900 --> 01:13:49,700
I might in the future again.

1847
01:13:49,700 --> 01:13:52,900
It doesn't really matter that platform code is so going to be.

1848
01:13:52,900 --> 01:13:53,400
So tiny.

1849
01:13:53,400 --> 01:13:54,600
There's just not that much to it.

1850
01:13:54,600 --> 01:13:55,800
And it's just buried in the wind.

1851
01:13:55,800 --> 01:13:57,800
It'll just live in the winter to handmade file.

1852
01:13:57,800 --> 01:13:59,500
You don't really have to worry too much about it.

1853
01:13:59,500 --> 01:14:04,100
The platform, the bulk of the game, the entire D of the code, really

1854
01:14:04,400 --> 01:14:07,200
will never see any of those variables or know about them at all.

1855
01:14:11,000 --> 01:14:13,300
Is there a particular X audio to support our next week?

1856
01:14:13,300 --> 01:14:14,100
No, it is not.

1857
01:14:14,300 --> 01:14:15,400
That is not true.

1858
01:14:15,900 --> 01:14:20,900
You could you can install it possibly on XP but I'm talking about the

1859
01:14:20,900 --> 01:14:21,500
default.

1860
01:14:21,500 --> 01:14:26,400
Install of XP did not come with X audio to, I'm 99% sure of that.

1861
01:14:26,500 --> 01:14:29,200
So if you have a vanilla and salt of XP and you try to run your game

1862
01:14:29,200 --> 01:14:30,700
on it with X audio, it will not work.

1863
01:14:30,700 --> 01:14:33,500
You will have to force the user to install X audio drivers.

1864
01:14:33,700 --> 01:14:34,700
In order to get that to work.

1865
01:14:34,700 --> 01:14:35,100
I am.

1866
01:14:36,000 --> 01:14:37,900
Pretty positive of that if I'm wrong.

1867
01:14:38,000 --> 01:14:41,000
So I can correct me in email later and we'll catch up with you

1868
01:14:41,000 --> 01:14:44,400
tomorrow, but I'm pretty much positive that a vanilla installed of XP

1869
01:14:44,500 --> 01:14:45,500
know X audio too.

1870
01:14:49,700 --> 01:14:52,100
Is there a particular reason why we use the keyboard input events

1871
01:14:52,100 --> 01:14:53,200
instead of pulling?

1872
01:14:54,200 --> 01:14:57,900
No, there isn't a particular reason other than the fact that the

1873
01:14:57,900 --> 01:14:59,800
keyboard events are going to be.

1874
01:15:00,000 --> 01:15:01,000
We're not going to miss anything.

1875
01:15:01,000 --> 01:15:03,900
If we pull the keyboard, we might miss a keyboard event.

1876
01:15:04,200 --> 01:15:06,000
Whereas if we just use the keyboard events.

1877
01:15:06,100 --> 01:15:09,000
We know that the operating system already got as many as it possibly

1878
01:15:09,000 --> 01:15:12,800
could because it's what its are already pulling the keyboard itself

1879
01:15:12,900 --> 01:15:15,700
internally and getting that stuff, as far as I know.

1880
01:15:16,000 --> 01:15:19,600
And so I think we pretty much want to just use the events because

1881
01:15:19,600 --> 01:15:21,600
they're going to be more accurate than pulling.

1882
01:15:24,800 --> 01:15:28,800
Will we be able to remap the keys over the GUI or config file?

1883
01:15:28,800 --> 01:15:30,000
Maybe it depends.

1884
01:15:30,100 --> 01:15:31,500
I don't love remappable keys.

1885
01:15:31,600 --> 01:15:32,400
I don't love them.

1886
01:15:33,300 --> 01:15:36,800
We might we will definitely support multiple key layouts though.

1887
01:15:36,900 --> 01:15:38,500
At least 44, people in France.

1888
01:15:38,500 --> 01:15:40,800
Whose wasd keys are different.

1889
01:15:44,300 --> 01:15:46,700
If I understand correctly, a larger primary, buffer means a longer

1890
01:15:46,700 --> 01:15:49,400
latency between writing sound to the buffer and actually being heard.

1891
01:15:49,400 --> 01:15:50,900
No, that is not true.

1892
01:15:51,300 --> 01:15:55,600
So the size of the primary effort, has nothing to do with the latency.

1893
01:15:55,800 --> 01:15:59,600
And the reason for that is because we're writing into the buffer

1894
01:15:59,600 --> 01:16:00,800
wherever we want.

1895
01:16:01,200 --> 01:16:04,300
So basically let's go over the diagram one more time.

1896
01:16:04,400 --> 01:16:05,600
Just so we're clear on.

1897
01:16:05,600 --> 01:16:09,800
What's Happening Here If this is and primary buffers.

1898
01:16:09,800 --> 01:16:11,900
The wrong thing to say necessarily.

1899
01:16:12,000 --> 01:16:12,600
Oh, okay.

1900
01:16:12,600 --> 01:16:14,000
Well actually maybe that's all right.

1901
01:16:14,200 --> 01:16:17,500
So when you say size of the primary buffer, we aren't setting the size

1902
01:16:17,500 --> 01:16:20,000
of the primary buffer, so did you mean secondary buffered?

1903
01:16:20,000 --> 01:16:25,300
You actually mean, setting the size of the primary buffer do you who

1904
01:16:25,300 --> 01:16:26,100
asked that question?

1905
01:16:29,400 --> 01:16:30,900
It's hard for me to keep track of things on.

1906
01:16:30,900 --> 01:16:32,500
Okay, to n.

1907
01:16:32,500 --> 01:16:34,400
3053.

1908
01:16:34,600 --> 01:16:36,500
Which buffer were you talking about?

1909
01:16:36,900 --> 01:16:40,500
Can you can you tell me which buffer you were talking about?

1910
01:16:45,100 --> 01:16:46,300
I'll ask some other questions.

1911
01:16:46,500 --> 01:16:49,600
If you could go ahead and tell me 2-inch 3053 which buffer you were

1912
01:16:49,600 --> 01:16:51,900
talking about specifically just clarify your question a little bit.

1913
01:16:51,900 --> 01:16:52,700
So I make sure I answer the right.

1914
01:16:52,700 --> 01:16:57,500
One will be writing filters like Reverb or what have you we could.

1915
01:16:57,600 --> 01:17:00,500
I rarely use stuff like that when I'm actually doing stuff.

1916
01:17:00,500 --> 01:17:02,500
I prefer to especially a 2-D game.

1917
01:17:02,500 --> 01:17:05,300
Doesn't make a whole lot of sense, but we could, we could write a

1918
01:17:05,300 --> 01:17:06,900
Reverb filter, just to show how it's done.

1919
01:17:08,500 --> 01:17:12,200
And I could even ask Jeff for some advice on that since he's probably

1920
01:17:12,200 --> 01:17:13,200
set, the person's work with those.

1921
01:17:13,200 --> 01:17:14,000
The most, if he has any

1922
01:17:14,400 --> 01:17:15,200
Words of wisdom.

1923
01:17:16,400 --> 01:17:18,100
Will we refactor the code in a separate files?

1924
01:17:18,100 --> 01:17:18,800
Of course?

1925
01:17:19,000 --> 01:17:19,400
Yes.

1926
01:17:21,600 --> 01:17:22,400
Let's see.

1927
01:17:28,300 --> 01:17:31,000
What causes the slight hiccup in the sound every couple seconds?

1928
01:17:31,200 --> 01:17:34,600
So I think I'm not actually getting that.

1929
01:17:35,800 --> 01:17:36,300
Let's see.

1930
01:17:45,500 --> 01:17:46,500
I'm not getting the hiccup.

1931
01:17:46,500 --> 01:17:47,600
Are you getting a hiccup?

1932
01:17:49,000 --> 01:17:51,300
We were having a hiccup because of the unlock.

1933
01:17:52,500 --> 01:17:53,500
We weren't calling unlocks.

1934
01:17:53,500 --> 01:17:55,600
We were just, we were just erroneously using it.

1935
01:17:55,600 --> 01:17:56,400
We were getting hiccups.

1936
01:17:56,400 --> 01:17:58,600
Oh, I don't actually know if there is a hiccup in there currently.

1937
01:17:58,600 --> 01:17:59,800
Like I said, we're going to test this a little bit.

1938
01:18:00,000 --> 01:18:01,900
Tomorrow, but I'm not sure.

1939
01:18:05,700 --> 01:18:06,400
Let's see.

1940
01:18:07,000 --> 01:18:09,800
It takes about a second for sound to start playing.

1941
01:18:10,400 --> 01:18:11,900
Is that expected acceptable?

1942
01:18:12,100 --> 01:18:12,400
Yeah.

1943
01:18:12,400 --> 01:18:14,900
Well, so basically, what's happening there is again, we're not

1944
01:18:14,900 --> 01:18:15,500
actually.

1945
01:18:16,400 --> 01:18:19,200
I could actually show you this a little bit more specifically.

1946
01:18:19,400 --> 01:18:23,400
So what we could do if we wanted to is, we could actually fill the

1947
01:18:23,400 --> 01:18:27,600
buffer first and then started playing, basically we could do something

1948
01:18:28,100 --> 01:18:29,800
more like this, right?

1949
01:18:30,500 --> 01:18:31,500
I'll just go ahead and show you.

1950
01:18:31,700 --> 01:18:34,800
So let's say we did a thing here that said,

1951
01:18:35,200 --> 01:18:38,600
Sound is playing equals false or something like this, right?

1952
01:18:38,600 --> 01:18:39,100
Are you know what?

1953
01:18:39,100 --> 01:18:40,200
I don't even need to do that.

1954
01:18:40,600 --> 01:18:41,500
I can just do this.

1955
01:18:41,700 --> 01:18:45,100
I'm going to just go ahead and get this part here.

1956
01:18:45,700 --> 01:18:49,600
I'm going to go ahead and extract this out into a separate function.

1957
01:18:49,600 --> 01:18:50,300
Basically.

1958
01:18:51,800 --> 01:18:53,000
Well, that'll all right.

1959
01:18:53,100 --> 01:18:54,700
That'll take too long for Q&A.

1960
01:18:54,800 --> 01:18:56,000
That's what we should do.

1961
01:18:56,300 --> 01:18:57,000
But I'm going to go.

1962
01:18:57,000 --> 01:18:58,400
I'll go, I'll do the original thing first.

1963
01:18:58,600 --> 01:19:02,500
So let's say I do sound is playing here equals false, then I come

1964
01:19:02,500 --> 01:19:04,900
through here and I actually do

1965
01:19:05,100 --> 01:19:09,300
Do this sound play anything after the first time?

1966
01:19:09,300 --> 01:19:12,600
So if not sound is playing, then we play it sounds.

1967
01:19:12,600 --> 01:19:13,700
Playing was true.

1968
01:19:14,200 --> 01:19:17,600
So we start out false like that.

1969
01:19:17,600 --> 01:19:20,400
So we start out without the sour playing and then I'm going to go in

1970
01:19:20,400 --> 01:19:25,100
here and I'm going to take quick look at what we get back and what we

1971
01:19:25,100 --> 01:19:25,800
fill.

1972
01:19:26,100 --> 01:19:28,700
So let's go through here due to do.

1973
01:19:29,100 --> 01:19:30,400
So, let's see here.

1974
01:19:30,700 --> 01:19:32,000
We get back.

1975
01:19:33,100 --> 01:19:35,000
What is our play cursor?

1976
01:19:35,700 --> 01:19:38,100
Wait, cursor is 0.

1977
01:19:38,700 --> 01:19:41,400
We are going to look at how many bytes to write.

1978
01:19:41,600 --> 01:19:47,100
How many bytes to write is zero as well.

1979
01:19:47,100 --> 01:19:49,600
Oh, so this is because they are equal to each other.

1980
01:19:49,800 --> 01:19:51,900
That looks like a bit of a bug.

1981
01:19:52,400 --> 01:19:54,200
It should never actually happen in practice.

1982
01:19:54,200 --> 01:19:58,400
But in the case where they are equal, they're both 0 and 0.

1983
01:19:58,500 --> 01:20:00,700
Or if it happens to have in that particular sense.

1984
01:20:00,700 --> 01:20:02,600
That means We've Ended up in basically yet.

1985
01:20:02,600 --> 01:20:04,500
So, so what I think we should do here.

1986
01:20:05,100 --> 01:20:08,300
Just to handle the case where things have gone pear-shaped as they say

1987
01:20:08,700 --> 01:20:09,400
in the UK.

1988
01:20:09,400 --> 01:20:12,700
I believe we should probably handle the case where they're equal.

1989
01:20:12,700 --> 01:20:15,000
They should never be equal and or because we're always supposed to be

1990
01:20:15,000 --> 01:20:16,000
writing ahead of things.

1991
01:20:16,400 --> 01:20:19,600
But in when we first start up, they will both be zero.

1992
01:20:20,000 --> 01:20:24,000
So we'll say that the B to write is the whole buffer basically, but in

1993
01:20:24,000 --> 01:20:26,500
the case of that act, they should actually collapse down in a bad

1994
01:20:26,500 --> 01:20:27,700
situation in the actual game.

1995
01:20:27,700 --> 01:20:30,400
We probably would want to handle something like that as well.

1996
01:20:30,800 --> 01:20:34,500
So let's take a look at what happens here when we come through first

1997
01:20:34,500 --> 01:20:35,000
time through.

1998
01:20:35,100 --> 01:20:35,700
Are both equal.

1999
01:20:35,700 --> 01:20:37,200
So we fill the whole buffer.

2000
01:20:37,500 --> 01:20:40,300
That is what we wanted and then we start the sound playing.

2001
01:20:40,400 --> 01:20:43,200
Okay, so in theory,

2002
01:20:46,400 --> 01:20:47,300
That should be.

2003
01:20:51,100 --> 01:20:52,200
Not a very good sound.

2004
01:20:52,200 --> 01:20:53,100
I will say that.

2005
01:20:53,400 --> 01:20:55,200
So I suspect we still have some bugs in the thing.

2006
01:20:55,200 --> 01:20:57,300
Like I said, I don't want to bug it now because I want to show how to

2007
01:20:57,300 --> 01:20:59,800
actually go through and debug it because I think we still have some

2008
01:21:00,000 --> 01:21:01,500
In here in terms of how we're filling.

2009
01:21:01,900 --> 01:21:05,300
But as you can see, the sound, now starts basically instantaneously,

2010
01:21:06,600 --> 01:21:07,500
if that makes sense.

2011
01:21:08,400 --> 01:21:11,800
And the reason for that was just that what we were doing first is we

2012
01:21:11,800 --> 01:21:16,300
were starting to sound playing before we actually filled any of it.

2013
01:21:16,400 --> 01:21:18,800
And so basically what happens there is we would be writing into

2014
01:21:18,800 --> 01:21:20,800
essentially the wrong place.

2015
01:21:20,800 --> 01:21:24,000
Like we have to fill, we have to wait till it kind of loops around

2016
01:21:24,000 --> 01:21:24,900
again before.

2017
01:21:24,900 --> 01:21:26,600
We would actually be playing it.

2018
01:21:26,600 --> 01:21:29,900
It's got this kind of gap between the play cursor and the right curse.

2019
01:21:30,000 --> 01:21:35,300
Sir, sir, and we're we're writing that, that that problem essentially

2020
01:21:35,300 --> 01:21:37,900
will cause it so that we're going to have dead time when initially

2021
01:21:37,900 --> 01:21:38,400
starts up.

2022
01:21:38,400 --> 01:21:42,000
So, yeah, if we fill the buffer first, then start playing, and then

2023
01:21:42,000 --> 01:21:43,400
always sure that we're running ahead of it.

2024
01:21:43,400 --> 01:21:46,000
That is how to make the sound, start immediately.

2025
01:21:46,200 --> 01:21:48,600
But like I said, I think we still got a bug in here, so I wouldn't

2026
01:21:48,600 --> 01:21:49,600
worry too much about this yet.

2027
01:21:49,600 --> 01:21:52,800
Don't play with this to extensively, unless you want to start

2028
01:21:52,800 --> 01:21:54,900
debugging yourself because I think we still have a bug in here.

2029
01:21:54,900 --> 01:21:55,800
In terms of where we're filling.

2030
01:21:55,800 --> 01:21:58,000
One of the things that's always been true for me when writing the

2031
01:21:58,000 --> 01:21:58,700
circular bar codes.

2032
01:21:58,700 --> 01:21:59,600
I always write it wrong.

2033
01:21:59,600 --> 01:22:00,000
The first time.

2034
01:22:00,000 --> 01:22:02,900
I'm because there's so many things that play in so many different

2035
01:22:02,900 --> 01:22:05,100
offsets and do you use the sample indexes of the regulate?

2036
01:22:05,100 --> 01:22:06,800
There's, it's just very finicky.

2037
01:22:07,800 --> 01:22:10,800
And so you what you want to do is you actually want to go and be very

2038
01:22:10,800 --> 01:22:12,500
certain check everything.

2039
01:22:12,600 --> 01:22:16,000
And actually, if you can like, draw it out and verify, like, okay,

2040
01:22:16,000 --> 01:22:17,700
we're actually writing to where we think we're writing.

2041
01:22:17,700 --> 01:22:19,800
We're doing the right thing everywhere.

2042
01:22:20,100 --> 01:22:21,900
That's very important and we haven't done that yet.

2043
01:22:21,900 --> 01:22:24,600
So I think we probably have some bugs in here as well.

2044
01:22:24,600 --> 01:22:29,000
And I think if we were to use a sine wave, we probably would see that

2045
01:22:29,000 --> 01:22:29,700
as well?

2046
01:22:29,900 --> 01:22:31,800
We would hear it more distinctly.

2047
01:22:31,800 --> 01:22:33,300
So I think this is probably buggy.

2048
01:22:33,500 --> 01:22:34,600
So let's just say that.

2049
01:22:34,600 --> 01:22:35,100
It's buggy.

2050
01:22:35,200 --> 01:22:36,800
I don't want to go into it till tomorrow.

2051
01:22:40,200 --> 01:22:41,000
Yes, okay.

2052
01:22:41,000 --> 01:22:43,000
We will do a sine wave tomorrow as well.

2053
01:22:43,400 --> 01:22:46,700
That I didn't want to talk about floating Point yet and you do need to

2054
01:22:46,700 --> 01:22:49,700
do that, but wait, maybe tomorrow will be our time that we introduced

2055
01:22:49,700 --> 01:22:50,100
that.

2056
01:22:50,500 --> 01:22:54,100
So we'll just say switch to a sine wave.

2057
01:22:57,400 --> 01:22:58,500
Let's see.

2058
01:23:00,000 --> 01:23:01,300
To do.

2059
01:23:03,300 --> 01:23:04,800
What is acceptable latency for games?

2060
01:23:04,800 --> 01:23:06,900
How far in advance of the read pointer should be right?

2061
01:23:07,300 --> 01:23:08,500
That is a very good question.

2062
01:23:08,800 --> 01:23:10,500
And the answer is, it depends?

2063
01:23:11,000 --> 01:23:13,900
It's very difficult to actually figure out on some platforms.

2064
01:23:14,200 --> 01:23:18,600
Like, on Mac, you can do it exactly because they will tell you when

2065
01:23:18,600 --> 01:23:22,700
your video frames will actually be displayed out the HDMI port, you

2066
01:23:22,700 --> 01:23:23,400
know, or whatever.

2067
01:23:23,700 --> 01:23:29,500
So you can actually make sure that your audio is hard synced, but on

2068
01:23:29,500 --> 01:23:32,000
windows at least on Windows XP.

2069
01:23:32,000 --> 01:23:32,900
I don't know if they've actually

2070
01:23:33,000 --> 01:23:35,600
We finally fixed this in Windows 7 or 8.

2071
01:23:36,600 --> 01:23:38,400
I don't think it was fixed as of 7.

2072
01:23:38,600 --> 01:23:40,500
So maybe an 8 I don't really know.

2073
01:23:44,900 --> 01:23:45,400
Excuse me.

2074
01:23:48,700 --> 01:23:50,200
Wow, I'm dying here people.

2075
01:23:55,400 --> 01:23:56,000
All right.

2076
01:23:58,200 --> 01:23:58,900
Basically.

2077
01:24:00,400 --> 01:24:04,600
On Windows, you have this kind of slop in terms of audio sync.

2078
01:24:05,100 --> 01:24:06,100
That's really confusing.

2079
01:24:06,100 --> 01:24:07,000
And I hate it.

2080
01:24:07,100 --> 01:24:10,400
I really wish that they hadn't had this, that they had done it right

2081
01:24:10,400 --> 01:24:12,300
in direct sound originally, but they didn't.

2082
01:24:14,000 --> 01:24:18,300
So look, maybe maybe like with X audio to like you were saying.

2083
01:24:18,300 --> 01:24:21,700
I haven't looked at that myself, but maybe with, like, newer audio

2084
01:24:21,700 --> 01:24:24,200
apis or something you can do, but in the old days, there wasn't very

2085
01:24:24,200 --> 01:24:24,900
much you could do.

2086
01:24:25,600 --> 01:24:29,000
Basically, what happens is if you can imagine this is

2087
01:24:30,000 --> 01:24:31,700
Let's, let's let's clear this out here.

2088
01:24:31,700 --> 01:24:33,300
So you just know I'm not referring to the old buffer.

2089
01:24:33,300 --> 01:24:35,000
But basically this is time.

2090
01:24:35,500 --> 01:24:36,000
Okay?

2091
01:24:36,300 --> 01:24:38,600
Time is on the axis here.

2092
01:24:38,600 --> 01:24:43,400
The access time is running forwards, its inescapable entropy ladies

2093
01:24:43,400 --> 01:24:43,900
and gentlemen.

2094
01:24:44,700 --> 01:24:48,100
Anyway, time is going forwards and you have to imagine basically like

2095
01:24:48,500 --> 01:24:51,000
here's the startup of the game, right?

2096
01:24:51,100 --> 01:24:54,500
This we get called and then we have a bunch of startup code to do.

2097
01:24:54,500 --> 01:24:57,100
So, there's work here that gets done, right?

2098
01:24:57,200 --> 01:24:58,400
And there's nothing you can do about that.

2099
01:24:58,400 --> 01:24:59,600
We're looking digitalizing some stuff.

2100
01:24:59,600 --> 01:24:59,900
We're

2101
01:25:00,000 --> 01:25:02,700
Direct sound and direct input or do you know, who knows what else

2102
01:25:02,700 --> 01:25:03,300
we're opening?

2103
01:25:03,400 --> 01:25:04,200
We're getting stuff.

2104
01:25:04,200 --> 01:25:04,800
Set up.

2105
01:25:05,900 --> 01:25:09,600
At some point we start to work on the first frame, right?

2106
01:25:09,600 --> 01:25:14,000
So in here, this is the work for frame one, right?

2107
01:25:14,000 --> 01:25:16,100
We're actually doing the work for frame 1.

2108
01:25:16,100 --> 01:25:19,500
So this is our us doing work and that work.

2109
01:25:19,600 --> 01:25:21,100
Involves outputting two things.

2110
01:25:21,300 --> 01:25:23,600
It involves outputting the sound.

2111
01:25:24,800 --> 01:25:26,300
And it outputs and the picture.

2112
01:25:26,600 --> 01:25:27,400
That's what we need to do.

2113
01:25:27,400 --> 01:25:29,300
So we need to sound in the picture, right?

2114
01:25:30,800 --> 01:25:34,700
So we are then going to tell Windows to play the sound that we

2115
01:25:34,700 --> 01:25:36,800
outputted and show the picture that we outputted.

2116
01:25:36,800 --> 01:25:37,400
Right?

2117
01:25:37,400 --> 01:25:41,700
But the problem is, even if we're doing this on some regular

2118
01:25:41,700 --> 01:25:42,400
granularity.

2119
01:25:42,400 --> 01:25:46,900
Like, let's say, this right here is 1/60 of a second, right?

2120
01:25:47,600 --> 01:25:52,700
We can try and sometimes succeed to get Windows to display the picture

2121
01:25:52,900 --> 01:25:55,600
right here at the 60th of a second boundary.

2122
01:25:55,800 --> 01:25:57,800
And then here's another 60th of a second.

2123
01:26:01,000 --> 01:26:04,800
Here's another sixtieth of a second and we want to keep that locked

2124
01:26:04,800 --> 01:26:05,300
frame rate.

2125
01:26:05,300 --> 01:26:09,200
Let's say so, we might be able to buy if the vertical retrace we can

2126
01:26:09,200 --> 01:26:13,100
use what's called a v blank potentially to possibly have Windows show

2127
01:26:13,100 --> 01:26:14,300
the new frame here.

2128
01:26:14,300 --> 01:26:19,000
So that the person is looking at the frame here is for this duration.

2129
01:26:19,100 --> 01:26:22,400
So, this is picture 0, right?

2130
01:26:22,400 --> 01:26:24,100
And we were producing picture 0 here.

2131
01:26:24,600 --> 01:26:30,500
Now sound 0 is a chunk of sound that ideally would go right here.

2132
01:26:30,900 --> 01:26:33,500
Right, that's where we actually want it.

2133
01:26:33,500 --> 01:26:38,000
We want our sound that we outputted to perfectly coincide with the

2134
01:26:38,000 --> 01:26:38,600
picture.

2135
01:26:38,900 --> 01:26:41,900
And then when we generate, you know, sometime after this, we're going

2136
01:26:41,900 --> 01:26:47,200
to start working on sound one and picture 1 instead of 0, right?

2137
01:26:48,200 --> 01:26:51,900
And those we want Windows to show here, right?

2138
01:26:51,900 --> 01:26:52,200
Whoops.

2139
01:26:52,200 --> 01:26:53,800
There's the 60th of a second boundary.

2140
01:26:53,900 --> 01:26:59,700
So we want picture one here and we want sound one to go here, right?

2141
01:27:01,900 --> 01:27:06,900
But the problem is, we don't really have any way of telling Windows to

2142
01:27:07,000 --> 01:27:11,100
place the sound buffer, so that it perfectly coincides with when the

2143
01:27:11,100 --> 01:27:13,100
picture flips, right?

2144
01:27:14,600 --> 01:27:15,600
That is the problem.

2145
01:27:15,800 --> 01:27:17,600
So, we don't really know where this is.

2146
01:27:17,900 --> 01:27:20,900
So your question of how much latency should we have?

2147
01:27:21,000 --> 01:27:24,200
Well, the answer is, we actually ideally would have exactly the right

2148
01:27:24,200 --> 01:27:25,900
latency such that.

2149
01:27:25,900 --> 01:27:29,500
Whenever we wrote to the Sound by for, let's say the right occurred

2150
01:27:29,500 --> 01:27:29,900
right here.

2151
01:27:30,000 --> 01:27:30,400
Here.

2152
01:27:30,800 --> 01:27:35,300
The latency would be, however, long it was in between that right and

2153
01:27:35,300 --> 01:27:40,000
when it when the picture shows up, that's the latency we want, right?

2154
01:27:40,100 --> 01:27:43,200
But there's no way to get that Encore audio.

2155
01:27:43,200 --> 01:27:44,900
Like I said, there is a way to get that.

2156
01:27:44,900 --> 01:27:49,500
There's actually ways you can I think get called back with specific

2157
01:27:49,500 --> 01:27:53,000
things that would allow you to do that sink, but I don't think there

2158
01:27:53,000 --> 01:27:54,600
is on, certainly not an XP.

2159
01:27:54,600 --> 01:27:57,900
I don't think even on Windows 7 maybe on a I don't really know, I

2160
01:27:57,900 --> 01:27:58,800
could be wrong about that.

2161
01:27:58,800 --> 01:27:59,600
But basically the

2162
01:28:00,000 --> 01:28:01,600
Certainly going through direct sound is nothing.

2163
01:28:01,600 --> 01:28:02,200
You can do.

2164
01:28:02,300 --> 01:28:03,600
So you just kind of have to estimate it.

2165
01:28:03,600 --> 01:28:05,100
That's why I games often today.

2166
01:28:05,100 --> 01:28:07,800
I think ship with those weird latency estimators because you've got

2167
01:28:07,800 --> 01:28:08,600
that problem.

2168
01:28:10,500 --> 01:28:13,000
Like, if you use Guitar Hero, they got those latent estimates, you got

2169
01:28:13,000 --> 01:28:16,200
that problem, and then you even got another problem, which is even if

2170
01:28:16,200 --> 01:28:19,700
you got all of this, correct, you have yet another problem, which is

2171
01:28:19,700 --> 01:28:24,100
your HDTV piece of piece of well, pile of poo.

2172
01:28:24,100 --> 01:28:29,700
Let's say right your HDTV, which is not fabulous, is like that could.

2173
01:28:29,700 --> 01:28:29,800
But

2174
01:28:29,900 --> 01:28:31,100
Buffer frames as well.

2175
01:28:31,500 --> 01:28:35,800
There may be a delay in the even when they go out the wire and

2176
01:28:35,800 --> 01:28:36,300
furthermore.

2177
01:28:36,300 --> 01:28:38,200
You may have some audio receiver.

2178
01:28:38,600 --> 01:28:42,300
That's also introducing delay or who, knows what?

2179
01:28:42,400 --> 01:28:46,600
So basically this stuff goes out to here and potentially gets further

2180
01:28:46,600 --> 01:28:47,900
delayed differently.

2181
01:28:48,000 --> 01:28:51,800
Depending on if the audio is going through a separate path, then the

2182
01:28:51,800 --> 01:28:53,200
TV or what's going on.

2183
01:28:53,400 --> 01:28:54,800
It's, it's a nightmare.

2184
01:28:55,100 --> 01:28:59,400
So, actually the saying how much latency you

2185
01:29:02,000 --> 01:29:05,300
Quote unquote is really a it's bad.

2186
01:29:05,400 --> 01:29:09,500
I have been complaining about this for about a decade.

2187
01:29:10,000 --> 01:29:14,400
I have been complaining about this and I have told everyone who ever

2188
01:29:14,400 --> 01:29:18,100
had an ear to listen, that they need to fix this stuff.

2189
01:29:18,200 --> 01:29:22,300
And what should actually happen is basically the opengl driver.

2190
01:29:22,300 --> 01:29:25,400
What I, what I actually want, we'll just a little bit of tangent here.

2191
01:29:25,600 --> 01:29:29,300
The opengl driver should just take a sound sound buffers and the sound

2192
01:29:29,300 --> 01:29:31,300
buffer should just go out with the frames.

2193
01:29:32,000 --> 01:29:33,700
And then it should just be mandatory.

2194
01:29:33,700 --> 01:29:35,000
There should be some seal.

2195
01:29:35,500 --> 01:29:38,600
There should be like a little seal that comes on your TV.

2196
01:29:38,600 --> 01:29:40,100
There should be like this little seal.

2197
01:29:40,300 --> 01:29:46,500
Right like this, that comes on the TV that says, you know, not crappy.

2198
01:29:48,100 --> 01:29:51,300
Right or basically like maybe it's maybe it's basically a thing that

2199
01:29:51,300 --> 01:29:55,800
says poop sauce like this with a little line through it.

2200
01:29:56,000 --> 01:29:59,500
So you get a thing on your television that says no poop sauce, and

2201
01:29:59,500 --> 01:29:59,800
then you

2202
01:30:00,400 --> 01:30:03,800
That whoever made that TV had it certified that they don't delay

2203
01:30:03,800 --> 01:30:04,900
anything they played.

2204
01:30:04,900 --> 01:30:05,600
Exactly.

2205
01:30:05,700 --> 01:30:08,300
And that way, you would know that your buffers in your frames, always

2206
01:30:08,300 --> 01:30:11,200
went out exactly together and then they were actually displayed by

2207
01:30:11,200 --> 01:30:15,800
your HDTV it and put out through the speaker's of the HDTV at the sack

2208
01:30:15,800 --> 01:30:16,200
same time.

2209
01:30:16,200 --> 01:30:20,500
So you at least know for gamers who buy an HDTV or a monitor that has

2210
01:30:20,600 --> 01:30:22,400
audio out if it had the no poop.

2211
01:30:22,400 --> 01:30:27,600
So sauce logo on it, that you would actually get no poop sauce, and I

2212
01:30:27,600 --> 01:30:29,900
don't actually understand why this.

2213
01:30:30,000 --> 01:30:30,600
Isn't done.

2214
01:30:30,600 --> 01:30:32,200
I feel like someone should do it.

2215
01:30:32,200 --> 01:30:34,000
I feel like Gamers would want this.

2216
01:30:34,000 --> 01:30:37,500
I feel like the types of people who go out and spend five thousand

2217
01:30:37,500 --> 01:30:38,900
dollars on a gaming rig.

2218
01:30:39,600 --> 01:30:43,100
The last thing they want is to have this sort of like worse, you know,

2219
01:30:43,100 --> 01:30:47,000
they don't want these sort of bad correlations and and having their

2220
01:30:47,000 --> 01:30:48,700
sound not be perfectly synced to their game.

2221
01:30:48,700 --> 01:30:49,500
That's ridiculous.

2222
01:30:49,600 --> 01:30:53,400
So I would think everyone would want to get the no poop sauce logo for

2223
01:30:53,400 --> 01:30:54,500
a serious gaming rig.

2224
01:30:54,500 --> 01:30:57,600
I mean, it just seems to me like it would be a no-brainer and I feel

2225
01:30:57,600 --> 01:30:59,400
like that's a value-add if your

2226
01:31:00,000 --> 01:31:01,200
Selling products.

2227
01:31:01,300 --> 01:31:04,300
I feel like the no poops lost logo would be really important.

2228
01:31:04,400 --> 01:31:05,200
So I don't know.

2229
01:31:05,900 --> 01:31:09,700
I have advocated this for many years, the industry, nobody cared.

2230
01:31:10,100 --> 01:31:13,800
And so the answer to how much latency you want, is nobody knows, it's

2231
01:31:13,800 --> 01:31:17,500
completely unknown and it's so unknown even that even on an operating

2232
01:31:17,500 --> 01:31:19,800
system that does it correctly, like a Mac OS 10.

2233
01:31:19,900 --> 01:31:24,000
You still don't know because the thing that you output to has latency

2234
01:31:24,000 --> 01:31:26,600
that you don't that you can't predict.

2235
01:31:27,300 --> 01:31:29,600
So even if you get it so that your HDMI

2236
01:31:29,900 --> 01:31:32,600
Put is perfectly synced on the wire.

2237
01:31:32,700 --> 01:31:33,400
It doesn't matter.

2238
01:31:35,700 --> 01:31:36,700
Let's see here.

2239
01:31:36,900 --> 01:31:38,500
So I think we are done for the day.

2240
01:31:38,500 --> 01:31:39,600
That's the end of the Q&A.

2241
01:31:39,600 --> 01:31:41,200
Like I said, if you did have a question, I'm sorry.

2242
01:31:41,200 --> 01:31:45,500
If I didn't get to it, we will be debugging the sound tomorrow.

2243
01:31:46,000 --> 01:31:50,300
And so when we debug the sound tomorrow, you can just hold those

2244
01:31:50,300 --> 01:31:50,700
questions.

2245
01:31:50,700 --> 01:31:51,700
They'll be same time tomorrow.

2246
01:31:51,700 --> 01:31:52,400
11:00 a.m.

2247
01:31:52,900 --> 01:31:56,100
Ask the question in the Q&A tomorrow and we will go over because we're

2248
01:31:56,100 --> 01:31:57,700
going to be debugging sound tomorrow as well.

2249
01:31:58,100 --> 01:31:59,800
So, I apologize for not getting some of the questions.

2250
01:31:59,800 --> 01:32:01,400
We had to get to the no poop sauce logo.

2251
01:32:01,400 --> 01:32:02,900
That was pretty important question to answer.

2252
01:32:03,400 --> 01:32:04,300
So, ladies and gentlemen.

2253
01:32:04,300 --> 01:32:05,000
Thank you so much for

2254
01:32:05,100 --> 01:32:08,000
Joining me here on handmade hero.

2255
01:32:08,500 --> 01:32:11,900
Obviously, if you want to continue discussion, you can go to handmade

2256
01:32:11,900 --> 01:32:13,000
hero dot, o-- r-- g--.

2257
01:32:13,000 --> 01:32:16,300
If you want a copy of the source code, you can always pre-order the

2258
01:32:16,300 --> 01:32:16,500
game.

2259
01:32:16,500 --> 01:32:19,400
It comes with a nightly build updates.

2260
01:32:19,400 --> 01:32:20,900
You can go get the source code.

2261
01:32:20,900 --> 01:32:21,300
In this case.

2262
01:32:21,300 --> 01:32:23,800
It will be an afternoon build up that I will push the new source right

2263
01:32:23,800 --> 01:32:26,700
now after we're done and you can also email me a question.

2264
01:32:26,700 --> 01:32:27,900
This will be turning.

2265
01:32:28,100 --> 01:32:28,900
Hopefully today.

2266
01:32:28,900 --> 01:32:31,500
I'm really hoping if I don't basically fall asleep because of this

2267
01:32:31,500 --> 01:32:32,000
cold.

2268
01:32:32,200 --> 01:32:34,900
I'm hoping to have the forums up and running to this will email

2269
01:32:35,100 --> 01:32:37,900
Question link will turn into a link to the forums where you can ask

2270
01:32:37,900 --> 01:32:39,800
questions and discuss things with the community.

2271
01:32:39,800 --> 01:32:42,400
So watch for that, hopefully by tomorrow.

2272
01:32:42,400 --> 01:32:46,800
If not later today, so hopefully that should be up soon.

2273
01:32:46,800 --> 01:32:49,800
Thank you so much for joining us for another episode of handmade hero,

2274
01:32:50,500 --> 01:32:51,100
11 a.m.

2275
01:32:51,100 --> 01:32:51,700
Tomorrow again.

2276
01:32:51,700 --> 01:32:54,100
So I hope to see you all here again tomorrow, including the folks from

2277
01:32:54,100 --> 01:32:55,000
Europe who were able to join us.

2278
01:32:55,000 --> 01:32:56,100
Thank you so much.

2279
01:32:56,500 --> 01:32:56,800
Sorry.

2280
01:32:56,800 --> 01:32:58,300
We can't always be at a friendly time.

2281
01:32:58,300 --> 01:33:01,700
But Friday's from now on will be your friendly as well.

2282
01:33:01,700 --> 01:33:04,300
So, thank you so much for joining us and I will see you.

2283
01:33:05,100 --> 01:33:05,800
Tomorrow.

