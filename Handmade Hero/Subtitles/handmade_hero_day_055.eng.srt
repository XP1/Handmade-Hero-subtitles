1
00:00:02,200 --> 00:00:03,400
And there we go.

2
00:00:03,600 --> 00:00:04,200
Alright.

3
00:00:04,200 --> 00:00:05,400
Hello everyone.

4
00:00:05,400 --> 00:00:09,000
And welcome to breakfast edition of handmade hero.

5
00:00:09,300 --> 00:00:11,700
The show where we eat a nutritious breakfast.

6
00:00:11,700 --> 00:00:14,000
I was actually just eating chocolate chip cookies, which I agree.

7
00:00:14,000 --> 00:00:15,600
Is not the most nutritious breakfast.

8
00:00:15,800 --> 00:00:17,000
Don't try that at home.

9
00:00:17,500 --> 00:00:18,600
I'm a professional.

10
00:00:19,000 --> 00:00:22,000
And I'm at, I'm trained to eat chocolate chip cookies.

11
00:00:22,300 --> 00:00:25,900
So that's not a good idea in general, but I happen to be instructive

12
00:00:25,900 --> 00:00:26,600
cookies for breakfast.

13
00:00:26,600 --> 00:00:27,600
That's just the way it went.

14
00:00:28,500 --> 00:00:29,500
And we don't need to harp on that.

15
00:00:29,500 --> 00:00:31,600
Okay, we don't need to focus on the unhealthy diet.

16
00:00:32,000 --> 00:00:34,600
What we need to focus on instead is handmade hero.

17
00:00:35,000 --> 00:00:38,400
The only show where we code a complete game from scratch.

18
00:00:38,400 --> 00:00:39,300
No engine.

19
00:00:39,400 --> 00:00:43,100
No libraries, powered, entirely by chocolate chip cookies, apparently

20
00:00:43,100 --> 00:00:45,400
at this point, but you know, whatever works, right?

21
00:00:45,400 --> 00:00:47,300
You gotta, You Gotta Eat what's around?

22
00:00:47,800 --> 00:00:48,900
I'm not letting it go to waste.

23
00:00:48,900 --> 00:00:49,900
Let's put it that way, right?

24
00:00:49,900 --> 00:00:52,600
It's being it's being conscientious about the food supply, eating

25
00:00:52,600 --> 00:00:53,400
chocolate chip cookies.

26
00:00:53,600 --> 00:00:54,700
Someone's got to do it.

27
00:00:54,800 --> 00:00:56,100
You wouldn't want to have that food.

28
00:00:56,100 --> 00:00:57,200
Go to waste anyway.

29
00:00:59,100 --> 00:01:03,300
Today we are going to finally do something that's been on our to-do

30
00:01:03,300 --> 00:01:06,500
list for a long time, which is to make our storage of the world

31
00:01:06,500 --> 00:01:07,600
actually, sparse.

32
00:01:08,400 --> 00:01:11,200
Even if it means it won't be particularly efficient because we're not

33
00:01:11,200 --> 00:01:14,200
really at that point yet, but we need to actually take the step and

34
00:01:14,200 --> 00:01:15,300
make it actually sparse.

35
00:01:16,200 --> 00:01:19,200
So we're going to need a bunch of time to do that, and to talk about

36
00:01:19,200 --> 00:01:20,200
the concepts involved there.

37
00:01:20,200 --> 00:01:21,600
So what I would like to do

38
00:01:22,600 --> 00:01:25,100
Is, I would like to jump straight into that, so quickly.

39
00:01:25,100 --> 00:01:27,600
I will just say that anyone who has pre-ordered the game from handmade

40
00:01:27,600 --> 00:01:28,300
hero dot-org.

41
00:01:28,300 --> 00:01:32,700
You should have gotten a link in your email and that link should have

42
00:01:32,700 --> 00:01:34,700
had the ability to download a zip file.

43
00:01:34,700 --> 00:01:36,700
That zip file has a bunch of smaller Zips in it.

44
00:01:36,900 --> 00:01:38,200
We are on day 55 today.

45
00:01:38,200 --> 00:01:41,900
So, you want to unzip day, 54 is zip file, that would put you at the

46
00:01:41,900 --> 00:01:45,300
same place that I am, so that you can code along with me.

47
00:01:45,300 --> 00:01:47,500
And what's more fun than coding, along with me, really?

48
00:01:47,500 --> 00:01:50,900
You know, it's like those old when Bill Cosby used to do picture

49
00:01:50,900 --> 00:01:51,500
pages.

50
00:01:51,800 --> 00:01:52,100
I don't know if

51
00:01:52,400 --> 00:01:55,900
Also remembers that he used to do picture pages that was before he was

52
00:01:55,900 --> 00:01:56,600
embroiled in Scandal.

53
00:01:56,600 --> 00:01:58,600
Of course, it would be a very different picture pages, what he would

54
00:01:58,600 --> 00:02:00,000
draw today, might be very different.

55
00:02:00,000 --> 00:02:04,300
Anyway, let's go ahead and get back to where we were.

56
00:02:05,800 --> 00:02:09,600
I also wanted to someone was saying we had a typo in our code.

57
00:02:09,600 --> 00:02:12,000
Of course, it's code that doesn't work anyway, because we haven't done

58
00:02:12,000 --> 00:02:15,800
the first thing yet, but we should fix the typo because then once we

59
00:02:15,800 --> 00:02:17,900
do get The Spar stuff in wonder why it's not working.

60
00:02:18,000 --> 00:02:21,700
The typos, will be it inside our set camera call.

61
00:02:22,400 --> 00:02:26,900
We essentially had a greater than or we have our greater than or less

62
00:02:26,900 --> 00:02:27,300
than Z.

63
00:02:27,300 --> 00:02:28,800
And we actually had one of them flips.

64
00:02:28,800 --> 00:02:33,200
You can see, I've got the X greater than tile X less than equal to Max

65
00:02:33,200 --> 00:02:35,400
tile, but the Y is in the wrong.

66
00:02:35,500 --> 00:02:36,900
Wrong order there, right?

67
00:02:37,300 --> 00:02:38,200
So that's no good.

68
00:02:38,400 --> 00:02:42,700
But that is, again this, this actually won't work because of the

69
00:02:42,700 --> 00:02:44,600
sparseness problem, which we talked about earlier.

70
00:02:44,800 --> 00:02:48,600
Basically, what we decided to do is to not support wrapping anymore,

71
00:02:48,600 --> 00:02:49,700
but we don't support sparseness.

72
00:02:49,700 --> 00:02:52,700
So let me quickly go to the white board and explain what that is for

73
00:02:52,700 --> 00:02:55,400
people who aren't quite sure, or who are just joining us.

74
00:02:55,900 --> 00:02:59,200
This will kind of just clarify where we're at, and why we need to do

75
00:02:59,200 --> 00:02:59,800
what we're doing.

76
00:03:00,300 --> 00:03:04,000
So what we decided to do early on this was just a design requirement

77
00:03:04,000 --> 00:03:04,300
of that.

78
00:03:04,300 --> 00:03:05,700
I decided to impose.

79
00:03:06,500 --> 00:03:08,600
Again, you don't necessarily have to do this, but the desired

80
00:03:08,900 --> 00:03:09,400
requirement.

81
00:03:09,400 --> 00:03:13,200
I decided to impose just to show how we would handle it and it does

82
00:03:13,200 --> 00:03:14,100
have some nice benefits.

83
00:03:14,600 --> 00:03:18,200
I decided that we wanted our worlds coordinates to basically allow for

84
00:03:18,200 --> 00:03:20,800
four billion tiles by four billion tiles.

85
00:03:21,000 --> 00:03:21,400
Essentially.

86
00:03:21,400 --> 00:03:25,800
If you thought of the world of the tile map, for example, which is

87
00:03:25,800 --> 00:03:30,000
obviously very very large and what we

88
00:03:30,100 --> 00:03:33,000
We're doing before, is we just kind of started creating the world at 0

89
00:03:33,000 --> 00:03:37,000
0, which kind of makes some sense, but what we would like to do, we

90
00:03:37,000 --> 00:03:40,300
decided that we didn't want to support the concept of wrapping around,

91
00:03:40,300 --> 00:03:43,700
which is to say what happens when you go past the 00 tile this

92
00:03:43,700 --> 00:03:46,400
direction and you come back on over here.

93
00:03:46,900 --> 00:03:49,300
And the reason that this is important is because if you think about

94
00:03:49,300 --> 00:03:52,900
what happens to numbers when they wrap, so if we have zero, right?

95
00:03:55,100 --> 00:03:59,200
If we have zero and we start going below it, if it's a signed number,

96
00:03:59,200 --> 00:04:01,500
it starts going to -1 -2 and so on.

97
00:04:01,600 --> 00:04:04,400
But if it's an unsigned number, right then in and that's what its

98
00:04:04,400 --> 00:04:05,000
meaning is.

99
00:04:05,000 --> 00:04:08,800
If it's an unsigned number, it's slips 24 billion, right?

100
00:04:09,000 --> 00:04:13,100
When you go, when you subtract 1 from 0, you actually go straight up

101
00:04:13,100 --> 00:04:16,399
to 2 to the 32nd minus 1, which is this the you know, the number way

102
00:04:16,399 --> 00:04:16,899
up here.

103
00:04:18,100 --> 00:04:22,100
And so that poses a lot of problems for things that want to use

104
00:04:22,100 --> 00:04:22,900
boundaries.

105
00:04:23,100 --> 00:04:27,600
So if I want to look at a bounds like a rectangle in this space, what

106
00:04:27,600 --> 00:04:31,800
will happen is if I see if I'm past if I'm if I'm somewhere near the

107
00:04:31,800 --> 00:04:35,400
edge here, somewhere near the zero Edge and I do a subtraction to sort

108
00:04:35,400 --> 00:04:37,200
of see what's over here.

109
00:04:37,400 --> 00:04:39,300
I'm actually going to start looking over here.

110
00:04:39,800 --> 00:04:42,600
Now, that's fine for some things where you're just direct indexing, it

111
00:04:42,600 --> 00:04:43,200
will work.

112
00:04:43,700 --> 00:04:46,300
But if you're trying to do greater than or less than it won't work,

113
00:04:46,300 --> 00:04:47,700
because this is a very high number.

114
00:04:48,100 --> 00:04:51,400
So, if you tried to think that this is the men, and this is the max,

115
00:04:51,400 --> 00:04:51,900
right?

116
00:04:51,900 --> 00:04:54,500
This is the man and this is the max of your bounds index.

117
00:04:55,700 --> 00:04:58,200
And I'm going to do a like, is something in between them.

118
00:04:58,200 --> 00:04:59,200
So is it greater than the man?

119
00:04:59,200 --> 00:05:02,900
Is it less than the max kind of a thing that will only work?

120
00:05:02,900 --> 00:05:06,800
When this is inside this region when it straddles, the - lock the zero

121
00:05:06,800 --> 00:05:10,900
line there, or when it straddles, the four billion, the, to 230, s

122
00:05:10,900 --> 00:05:12,300
minus one line, right?

123
00:05:12,300 --> 00:05:16,300
2 to the 32nd, minus 1, which is the highest 32-bit number.

124
00:05:16,900 --> 00:05:18,900
So it's like, for billions and change.

125
00:05:20,600 --> 00:05:23,600
If we're looking at that, it won't work anymore because the men

126
00:05:23,700 --> 00:05:25,000
actually becomes very high.

127
00:05:25,600 --> 00:05:28,500
Iteration would still work, but we'd have to make sure that all of our

128
00:05:28,500 --> 00:05:32,300
iterations were super careful to not use greater than or less than,

129
00:05:32,300 --> 00:05:36,600
and always just used careful math, to make sure that they check for

130
00:05:36,600 --> 00:05:38,900
not equals to, and do other things like this.

131
00:05:39,600 --> 00:05:42,700
And never try to take the length of something like, never try to look

132
00:05:42,700 --> 00:05:45,300
at how long something is that way and all these are the sorts of

133
00:05:45,300 --> 00:05:46,200
things, right?

134
00:05:46,900 --> 00:05:49,600
So, we've got a bunch of stuff that we would have to constantly be

135
00:05:49,600 --> 00:05:50,100
aware of.

136
00:05:50,100 --> 00:05:53,800
Now if we can do it, but it just didn't seem necessary because if we

137
00:05:53,800 --> 00:05:55,300
start the world growing here,

138
00:05:55,500 --> 00:05:57,000
And we imagine growing out the world.

139
00:05:57,000 --> 00:05:59,700
We can make a totally huge world that just fits in the middle.

140
00:06:00,000 --> 00:06:01,800
Not have to worry about these potential wrapping bug.

141
00:06:01,800 --> 00:06:04,900
So we basically don't gain anything from handling, the rapping bugs

142
00:06:05,300 --> 00:06:07,300
because we'd never actually need to make a world.

143
00:06:07,300 --> 00:06:09,200
That's quite that big right?

144
00:06:09,900 --> 00:06:10,800
We could make a world.

145
00:06:10,800 --> 00:06:13,600
Let's just three billion by three billion and fits in that Center and

146
00:06:13,600 --> 00:06:14,300
we'd be fine.

147
00:06:14,400 --> 00:06:14,900
Right?

148
00:06:15,500 --> 00:06:18,000
So what we want to be able to do is start somewhere here.

149
00:06:18,000 --> 00:06:22,100
We want to be able to start somewhere at 2 to the 32nd over to or

150
00:06:22,100 --> 00:06:23,400
something, right?

151
00:06:24,000 --> 00:06:26,100
We want to be able to start it kind of up there.

152
00:06:26,900 --> 00:06:29,900
And so what we need to figure out is we need

153
00:06:30,000 --> 00:06:32,500
To figure out how to actually make that happen.

154
00:06:32,500 --> 00:06:32,900
Now.

155
00:06:32,900 --> 00:06:37,300
The reason that we can't do that directly at the moment is because we

156
00:06:37,300 --> 00:06:40,800
haven't actually written the storage system for the world yet.

157
00:06:40,800 --> 00:06:41,200
Really.

158
00:06:41,400 --> 00:06:44,600
We just kind of put a little hacky thing in there while we were

159
00:06:44,600 --> 00:06:45,400
working on it.

160
00:06:45,700 --> 00:06:50,000
And so what we did was we basically direct access to the world.

161
00:06:50,900 --> 00:06:56,000
By saying we have an array right of tile chunks, which are basically

162
00:06:56,000 --> 00:06:56,800
groupings.

163
00:06:56,900 --> 00:07:02,300
I think we said they were 16 by 16 at the moment of sort of sections

164
00:07:02,300 --> 00:07:06,800
of the world that are 16 tiles by 16 tiles roughly and we just made an

165
00:07:06,800 --> 00:07:09,600
actual dense array of them that centered right here.

166
00:07:10,000 --> 00:07:12,900
So if we wanted to start at a point that was in the center of the

167
00:07:12,900 --> 00:07:15,400
world and we actually still use the same system.

168
00:07:15,400 --> 00:07:18,500
It would cost too much memory even just to store these tile chunks,

169
00:07:18,800 --> 00:07:19,300
right?

170
00:07:19,600 --> 00:07:20,500
Because that would be too.

171
00:07:20,700 --> 00:07:23,400
The 32nd over to right?

172
00:07:23,600 --> 00:07:26,100
Which is just, you know, 2231, right.

173
00:07:26,600 --> 00:07:28,600
So it would be that far in.

174
00:07:29,900 --> 00:07:31,800
If I'm not mistaken, excuse me.

175
00:07:38,900 --> 00:07:41,000
Sometimes you just got to get one chocolate chip cookie in just to

176
00:07:41,000 --> 00:07:41,600
keep you going.

177
00:07:41,800 --> 00:07:43,700
You know what, I'm like, a little hit.

178
00:07:46,600 --> 00:07:48,300
There, there, baby, Taco chip cookies.

179
00:07:48,300 --> 00:07:49,200
I mean, this is what I'm talking about.

180
00:07:52,400 --> 00:07:52,900
Right.

181
00:07:52,900 --> 00:07:54,000
I mean that's not even.

182
00:07:55,100 --> 00:07:56,900
That's a breakfast food at that size.

183
00:07:56,900 --> 00:07:57,800
As far as I'm concerned.

184
00:07:57,800 --> 00:07:58,200
Right?

185
00:07:58,200 --> 00:07:58,400
Right.

186
00:07:58,400 --> 00:08:00,000
I mean, that's look at that.

187
00:08:00,000 --> 00:08:00,600
That's not.

188
00:08:00,600 --> 00:08:01,200
How could that be?

189
00:08:01,200 --> 00:08:01,600
Unhealthy?

190
00:08:01,600 --> 00:08:02,800
It's hardly.

191
00:08:03,600 --> 00:08:06,300
I mean, it's like a 1/16 of a cookie or something, right?

192
00:08:11,800 --> 00:08:12,600
But no matter.

193
00:08:14,400 --> 00:08:15,500
Don't worry about that for now.

194
00:08:18,000 --> 00:08:19,800
We can talk about cookies later point being.

195
00:08:23,700 --> 00:08:29,700
What we need to do is figure out a way to not have to store tile maps.

196
00:08:29,700 --> 00:08:33,100
All the way up to that Center Point, right now, if we wanted to just

197
00:08:33,100 --> 00:08:34,200
cheese it for now.

198
00:08:35,299 --> 00:08:36,900
Which we totally could do if we wanted to.

199
00:08:36,900 --> 00:08:38,799
Because again, we're just trying to figure out how the system works.

200
00:08:38,799 --> 00:08:42,100
We could just re-center our coordinate system so that 00 was like here

201
00:08:42,100 --> 00:08:42,900
or something like that.

202
00:08:42,900 --> 00:08:43,400
Whatever.

203
00:08:46,700 --> 00:08:49,100
But what I'd rather do is get things working with arbitrary

204
00:08:49,100 --> 00:08:53,200
coordinates just so we can see if we have any problems with actually

205
00:08:53,200 --> 00:08:54,400
having Tiles at coordinates.

206
00:08:54,400 --> 00:08:57,900
There it is there any like unforeseen problems that we would be having

207
00:08:57,900 --> 00:08:59,000
blah blah blah, right?

208
00:09:00,000 --> 00:09:04,100
So if I wanted to do that, what I would like to be able to do is I'd

209
00:09:04,100 --> 00:09:07,700
like a system where I can just store tile chunks wherever they

210
00:09:07,700 --> 00:09:12,200
actually happen to occur and not have to have a whole giant array for

211
00:09:12,200 --> 00:09:12,800
indexing them.

212
00:09:12,800 --> 00:09:17,600
That's going to have that that sort of problematic penalty that I was

213
00:09:17,600 --> 00:09:22,400
talking about, in terms of basically, you know, having to store a

214
00:09:22,400 --> 00:09:23,600
continuous dense, set of them.

215
00:09:23,600 --> 00:09:27,300
So that way we could be truly sparse and actually just fill in tile

216
00:09:27,300 --> 00:09:28,100
chunks where we need them.

217
00:09:28,100 --> 00:09:29,600
So we can have kind of sinewy.

218
00:09:30,000 --> 00:09:35,000
Brawling World paths that don't pay a cost for their entire rectangle

219
00:09:35,000 --> 00:09:35,700
footprint.

220
00:09:35,800 --> 00:09:40,200
In terms of memory that only store sort of right along where the paths

221
00:09:40,200 --> 00:09:44,500
actually go and where the player can actually go rather than doing

222
00:09:44,500 --> 00:09:47,700
this kind of weird sort of forced or a thing.

223
00:09:49,300 --> 00:09:55,500
So I'm not sure yet what the best way to do this would be, I don't

224
00:09:55,500 --> 00:09:55,900
know.

225
00:09:57,400 --> 00:10:01,800
So I'm going to pick one method and try it and we'll see how it goes.

226
00:10:02,400 --> 00:10:05,300
And it'll probably be the method that we use here when we're just sort

227
00:10:05,300 --> 00:10:06,500
of working stuff through.

228
00:10:07,400 --> 00:10:11,200
But later on when we do the final world system, you know, we may think

229
00:10:11,200 --> 00:10:14,100
harder about exactly how we should make it work.

230
00:10:14,100 --> 00:10:14,700
I don't know.

231
00:10:15,800 --> 00:10:19,700
But the point is what I've decided to do is I decided to just try

232
00:10:19,700 --> 00:10:22,600
using a hash table because that's an easy thing.

233
00:10:22,600 --> 00:10:25,300
We can implement, it gets us sparseness, and it's relatively

234
00:10:25,300 --> 00:10:28,700
performant in terms of the stuff that we might need it to do.

235
00:10:28,800 --> 00:10:30,000
I think we'll see.

236
00:10:31,300 --> 00:10:33,800
So, what's a hash table for people who don't necessarily know what a

237
00:10:33,800 --> 00:10:34,600
hash table is.

238
00:10:35,200 --> 00:10:40,800
Well, a hash table is usually a linear array, right?

239
00:10:41,200 --> 00:10:44,900
So we basically have a zero slot and we've got some number of slots up

240
00:10:44,900 --> 00:10:45,400
to, you know,

241
00:10:45,600 --> 00:10:50,700
N minus 1, slots 0 and N length hash table, but it has n elements in

242
00:10:50,700 --> 00:10:50,900
it.

243
00:10:50,900 --> 00:10:53,600
It's got, you know, zero through n, minus 1 just like a standard

244
00:10:53,600 --> 00:10:54,200
linear array.

245
00:10:54,200 --> 00:10:57,300
And each one of these things is an entry in the slot, right?

246
00:10:59,000 --> 00:11:00,100
What a hash table is.

247
00:11:00,100 --> 00:11:04,800
It's a way of taking something that you would like to have addressed

248
00:11:04,800 --> 00:11:10,700
as one giant array and collapsing it down to a much smaller array for

249
00:11:10,700 --> 00:11:11,400
storage.

250
00:11:12,300 --> 00:11:14,500
Knowing that it is sparse.

251
00:11:14,900 --> 00:11:15,600
Right?

252
00:11:15,600 --> 00:11:21,000
So, what we actually have is we have x y&z coordinates for our tile

253
00:11:21,000 --> 00:11:22,000
chunks, right?

254
00:11:22,300 --> 00:11:25,700
We can have a three, we basically have a three-dimensional world, and

255
00:11:25,700 --> 00:11:28,600
we can have X Y & Z entries for our child chunks.

256
00:11:28,800 --> 00:11:33,500
If we wanted to store these in memory, we would have to do basically

257
00:11:33,800 --> 00:11:36,300
each one of these can be for a billion wide, right?

258
00:11:36,300 --> 00:11:40,400
So we'd have to do for a billion by four billion, by four billion,

259
00:11:40,600 --> 00:11:44,100
would have to be the size of the array that we stored which is

260
00:11:44,100 --> 00:11:45,600
obviously impossible.

261
00:11:45,700 --> 00:11:48,300
Like, there's not enough memory in the world for that.

262
00:11:51,500 --> 00:11:52,000
Right.

263
00:11:52,400 --> 00:11:57,200
There's probably enough memory in the world for this much, but not

264
00:11:57,200 --> 00:11:59,800
that much right for billion computers times.

265
00:12:00,800 --> 00:12:02,100
GB of memory, you know, whatever.

266
00:12:02,300 --> 00:12:04,000
Anyway, point being, this is too much.

267
00:12:05,700 --> 00:12:09,100
And so what we need to do is say well, okay, but we know that this is

268
00:12:09,100 --> 00:12:10,100
just the addressing scheme.

269
00:12:10,100 --> 00:12:12,800
This is just the giant cube in which the world exists, but we're only

270
00:12:12,800 --> 00:12:15,000
going to make a very small were only going to populate a very small

271
00:12:15,000 --> 00:12:15,700
fraction of it.

272
00:12:15,700 --> 00:12:18,100
We just don't know what fraction we're going to populate.

273
00:12:18,100 --> 00:12:20,400
We want the world generator to be able to be freely.

274
00:12:20,400 --> 00:12:24,400
Make very long skinny, things, it wants to or dense regions.

275
00:12:24,500 --> 00:12:29,600
And we want the storage system to just cope and be able to fit this in

276
00:12:29,600 --> 00:12:29,700
a

277
00:12:30,000 --> 00:12:33,500
Nothing, but such that we can still access it via these coordinates,

278
00:12:33,500 --> 00:12:34,000
right?

279
00:12:35,000 --> 00:12:40,900
So, the way we would do this in with a hash table is, if you imagine

280
00:12:40,900 --> 00:12:43,900
taking these as your actual Index, right?

281
00:12:44,000 --> 00:12:44,700
How would we do this?

282
00:12:44,700 --> 00:12:48,400
We have 32 bits of this, 32 bits of this, 32 bits of this, right?

283
00:12:48,900 --> 00:12:53,100
If we were to pack those together, we would get numb one number which

284
00:12:53,100 --> 00:12:54,800
basically looks like this, right?

285
00:12:54,800 --> 00:12:57,900
It's 32 bits 32 bits, 32 bits, and we could pack it.

286
00:12:57,900 --> 00:13:00,700
However, we wanted zyx or something like that.

287
00:13:00,700 --> 00:13:01,300
Right?

288
00:13:01,600 --> 00:13:02,600
And we'd have one number.

289
00:13:02,600 --> 00:13:04,600
That would be the index into a

290
00:13:04,800 --> 00:13:05,700
Giant array.

291
00:13:05,700 --> 00:13:06,700
That was this big.

292
00:13:06,900 --> 00:13:09,600
And when we looked in there, we would find our tiles.

293
00:13:09,600 --> 00:13:10,300
Now granted.

294
00:13:10,300 --> 00:13:12,900
We said that our tiles are 16 by 16.

295
00:13:13,000 --> 00:13:17,000
So technically these are actually, you know, 16 is 2 to the fourth,

296
00:13:17,100 --> 00:13:17,600
right?

297
00:13:17,800 --> 00:13:21,500
So technically it's really more like the 28, right?

298
00:13:21,700 --> 00:13:25,700
So we actually have 28 bits each here, right?

299
00:13:25,900 --> 00:13:29,000
If we wanted to really talk about how many we have for tile chunks,

300
00:13:29,200 --> 00:13:29,500
right?

301
00:13:29,500 --> 00:13:30,700
Chunks, not tiles.

302
00:13:32,500 --> 00:13:34,600
So, if we're talking about that, and we don't know what this number

303
00:13:34,600 --> 00:13:37,100
because we could expand it to 32 by 32 as well.

304
00:13:37,100 --> 00:13:39,900
And then it was reduced to 27, B, but point being, it's gonna be

305
00:13:39,900 --> 00:13:40,600
something like that.

306
00:13:40,600 --> 00:13:43,300
It's gonna be in the ballpark 24:28, something like that.

307
00:13:43,800 --> 00:13:46,600
If we made a large number out of it, we could just do that by

308
00:13:46,600 --> 00:13:48,200
concatenating the bits together, right?

309
00:13:48,200 --> 00:13:49,400
And just have one really big number.

310
00:13:49,400 --> 00:13:51,300
That's just a very long number, right?

311
00:13:51,300 --> 00:13:55,600
It's something like a 90 bit number or something like this, right?

312
00:13:56,100 --> 00:13:59,300
And then, we would use that 90 bit number to index into a giant array.

313
00:13:59,600 --> 00:14:01,000
And that's the thing that we can't do.

314
00:14:01,000 --> 00:14:01,800
So, the question is,

315
00:14:02,300 --> 00:14:06,600
Can we do that similar to this process that takes advantage of the

316
00:14:06,600 --> 00:14:10,000
sparseness of the array that we know that most of the entries are not

317
00:14:10,000 --> 00:14:11,400
filled, right?

318
00:14:12,300 --> 00:14:15,300
In order to give us something that has similar characteristics to a

319
00:14:15,300 --> 00:14:18,600
nice fast array, look up, but which allows us to collapse the array

320
00:14:18,600 --> 00:14:21,500
down to something quite small that does fit in memory, and that works.

321
00:14:21,500 --> 00:14:21,900
Okay.

322
00:14:23,400 --> 00:14:25,800
And so, a hash table is a pretty obvious choice for something like

323
00:14:25,800 --> 00:14:26,200
this.

324
00:14:27,100 --> 00:14:31,300
What it does is is you make some kind of a mapping some kind of a

325
00:14:31,300 --> 00:14:35,600
function that takes this imaginary number that you've created with the

326
00:14:35,600 --> 00:14:40,400
with the three with the impossibly large number and the mapping just

327
00:14:40,400 --> 00:14:41,200
flat-out.

328
00:14:41,200 --> 00:14:43,500
Reduces the B, A lossy mapping.

329
00:14:43,900 --> 00:14:48,500
So let's say that we wanted to store this in, you know, a 16-bit

330
00:14:48,500 --> 00:14:51,100
array, a 16 bits worth of array space.

331
00:14:51,100 --> 00:14:53,000
So we had

332
00:14:53,100 --> 00:14:54,700
Six entries in it, right?

333
00:14:54,700 --> 00:14:56,200
Maybe that's even a little bit large.

334
00:14:56,300 --> 00:14:59,100
Let's say is 4096 entries, right?

335
00:14:59,300 --> 00:14:59,800
So we have

336
00:15:00,000 --> 00:15:02,700
As a 96, entries in our array, let's say right?

337
00:15:03,600 --> 00:15:04,300
That makes sense.

338
00:15:04,400 --> 00:15:05,400
That's to the 12th.

339
00:15:05,500 --> 00:15:07,600
If I'm not mistaken right to the 850.

340
00:15:07,600 --> 00:15:09,600
68 is 256.

341
00:15:09,800 --> 00:15:13,400
Ninth is 512, 1024 1112.

342
00:15:13,400 --> 00:15:15,000
Yeah, so 2 to the 12.

343
00:15:15,700 --> 00:15:17,200
So let's say we want to to the 12.

344
00:15:17,200 --> 00:15:21,200
So we've got a 2 to the 90 or something thereabouts and we want to map

345
00:15:21,200 --> 00:15:23,400
it to a 2 to the 12, right?

346
00:15:24,000 --> 00:15:28,400
And you could imagine ways that we could do this without thinking it

347
00:15:28,400 --> 00:15:29,700
through to carefully.

348
00:15:30,500 --> 00:15:32,800
The, the most obvious way we could you guys just throw away some of

349
00:15:32,800 --> 00:15:33,900
the bits, right?

350
00:15:33,900 --> 00:15:36,000
We could just flat-out throw away some of the bits.

351
00:15:36,400 --> 00:15:39,900
So we can take just a few bits from each one of these right 2 to the

352
00:15:39,900 --> 00:15:40,200
12th.

353
00:15:40,200 --> 00:15:43,400
Let's say we could take four bits from each of these just randomly,

354
00:15:43,400 --> 00:15:47,100
whichever for a b, we decide take for a bit from each of these instead

355
00:15:47,100 --> 00:15:50,000
of taking all 28 bits or all 30 bits or however many bits there

356
00:15:50,000 --> 00:15:53,200
actually were and we could produce another number, so we could

357
00:15:53,200 --> 00:15:56,700
basically produce this other number that we know is only 2 to the 12th

358
00:15:56,700 --> 00:15:57,900
big, right?

359
00:15:58,000 --> 00:15:59,800
And it's only got four bits of x.

360
00:16:00,100 --> 00:16:02,800
It's got four bits of y, + 4 B of Z.

361
00:16:02,900 --> 00:16:03,300
Right?

362
00:16:03,300 --> 00:16:07,900
And now we know we could use this to address into an array, right?

363
00:16:08,400 --> 00:16:10,900
And that is called the hash function.

364
00:16:10,900 --> 00:16:16,700
The thing that takes basically the this big number and turns it into

365
00:16:16,700 --> 00:16:18,500
the smaller number is the hash function.

366
00:16:18,900 --> 00:16:23,400
Now it when when you're really trying to make a hash work well.

367
00:16:24,700 --> 00:16:26,900
Typically, you do not just throw a b away like that.

368
00:16:26,900 --> 00:16:29,800
You actually think about the patterns of the bits and what they're

369
00:16:29,800 --> 00:16:30,800
likely to take.

370
00:16:30,900 --> 00:16:34,600
And you try to make a function that will minimize what are called

371
00:16:34,600 --> 00:16:38,200
collisions, which we'll talk about in a second, but regardless of how

372
00:16:38,200 --> 00:16:39,100
you think about it.

373
00:16:39,100 --> 00:16:42,700
So I guess what I'm saying is, I'm simplifying here by suggesting you

374
00:16:42,700 --> 00:16:43,500
just concatenate.

375
00:16:43,500 --> 00:16:43,900
The B.

376
00:16:43,900 --> 00:16:47,000
Oftentimes hash functions will do something more fancy than that.

377
00:16:47,000 --> 00:16:49,000
Like they'll mix the bits together.

378
00:16:49,300 --> 00:16:51,900
They'll multiply numbers together, shift them, add them.

379
00:16:51,900 --> 00:16:54,300
They'll do more complex operations, such that.

380
00:16:54,500 --> 00:16:56,400
It's not like, it's just for a bit from each.

381
00:16:56,400 --> 00:16:58,000
It's more like a mixture of them.

382
00:16:58,000 --> 00:16:58,500
Also.

383
00:16:58,500 --> 00:17:00,400
It's really usually to completely new number here.

384
00:17:00,400 --> 00:17:05,000
That isn't identifiable by B that came directly from the previous, but

385
00:17:05,000 --> 00:17:07,900
this would still be a totally valid hash function is just not typical.

386
00:17:08,200 --> 00:17:09,800
So I just wanted to clarify that.

387
00:17:09,800 --> 00:17:11,800
But point being, that's what the hash function is.

388
00:17:12,000 --> 00:17:13,800
So essentially what you've got,

389
00:17:15,400 --> 00:17:17,200
In fact, I guess I don't really need to delete that.

390
00:17:17,200 --> 00:17:19,599
I forget that Creek I can just kind of scroll over.

391
00:17:21,400 --> 00:17:25,700
So what you've got is something which takes you know, a is that

392
00:17:25,700 --> 00:17:26,000
working.

393
00:17:26,000 --> 00:17:31,200
There we go, that takes sort of a to, to the large amount and Maps it

394
00:17:31,200 --> 00:17:34,600
to to a to, to the small amount, right?

395
00:17:34,800 --> 00:17:39,100
So that this becomes feasible to store in the array and then inside

396
00:17:39,100 --> 00:17:39,800
the array.

397
00:17:40,200 --> 00:17:43,100
We now know that we can just look up in there and get the tile trunk

398
00:17:43,100 --> 00:17:43,600
that we wanted.

399
00:17:43,600 --> 00:17:44,400
So we do that map.

400
00:17:44,500 --> 00:17:45,100
Calm down.

401
00:17:45,200 --> 00:17:48,200
So let's say we wanted to get some random number that we wanted to get

402
00:17:48,200 --> 00:17:50,600
the XYZ a thing, right?

403
00:17:51,600 --> 00:17:55,500
We map it down from the large space that that's into a small space.

404
00:17:55,500 --> 00:17:56,800
We can look it up in the array.

405
00:17:57,000 --> 00:17:59,800
We grab the thing that's in there and that gives us our top junk.

406
00:18:00,100 --> 00:18:00,600
Right.

407
00:18:01,300 --> 00:18:03,900
That would literally work almost exactly the same way that we have

408
00:18:03,900 --> 00:18:04,100
things.

409
00:18:04,100 --> 00:18:08,800
Now, only instead of forcing us to store stuff in this, in this sort

410
00:18:08,800 --> 00:18:09,900
of giant dense array.

411
00:18:09,900 --> 00:18:13,100
If we want to do the whole world, now, we can store any any number we

412
00:18:13,100 --> 00:18:13,600
want it.

413
00:18:13,700 --> 00:18:17,000
We don't even have to initialize the bounce to be anything other than

414
00:18:17,000 --> 00:18:20,500
just that initial small amount the, for however, many tile chunks

415
00:18:20,500 --> 00:18:21,200
maximum.

416
00:18:21,300 --> 00:18:23,700
We wanted was all we have to do in there.

417
00:18:24,000 --> 00:18:24,300
Okay.

418
00:18:24,300 --> 00:18:26,600
So what's obviously, it's not magic.

419
00:18:26,700 --> 00:18:28,900
That can't be the only thing because if that was true, you'd just

420
00:18:28,900 --> 00:18:29,500
always do that.

421
00:18:29,500 --> 00:18:29,800
And then,

422
00:18:30,000 --> 00:18:32,000
Magically, you just have smaller memory for everything.

423
00:18:32,000 --> 00:18:32,500
Right?

424
00:18:32,800 --> 00:18:35,500
Well, of course, there obviously is a problem with that, which is

425
00:18:35,500 --> 00:18:38,300
that, since this right here was sparse, right?

426
00:18:39,200 --> 00:18:40,900
You're taking advantage of some of that sparseness.

427
00:18:40,900 --> 00:18:42,600
And so, that's one of the things, right?

428
00:18:42,600 --> 00:18:46,700
But the big thing is, you can have what are called collisions, right?

429
00:18:47,400 --> 00:18:51,800
So, if we're only using some bits of X, some bits of Y, and some bits

430
00:18:51,800 --> 00:18:56,000
of z or r, whatever our hash function, miss, it mixes them up in ways

431
00:18:56,200 --> 00:18:59,600
that Matt from a large coordinate space to a small one.

432
00:19:00,000 --> 00:19:04,700
Right, then obviously you can get to things that were different sets

433
00:19:04,700 --> 00:19:07,600
of numbers that both map to the same slot.

434
00:19:07,800 --> 00:19:13,300
So, you know, I have another set here ABC and ABC and XYZ when they go

435
00:19:13,300 --> 00:19:15,300
through this hash function, right?

436
00:19:16,300 --> 00:19:19,000
Both map to this slot, right?

437
00:19:19,100 --> 00:19:26,000
So both XYZ and ABC both compute through the hash function into some

438
00:19:26,000 --> 00:19:26,700
small number.

439
00:19:26,700 --> 00:19:29,100
And it turns out they both come up with 27.

440
00:19:29,500 --> 00:19:29,800
So we

441
00:19:29,900 --> 00:19:31,400
Look in here and we go.

442
00:19:31,400 --> 00:19:32,600
Oh crud.

443
00:19:32,800 --> 00:19:38,200
We don't have any room to store the second thing because we already

444
00:19:38,200 --> 00:19:40,900
have someone there and it's not this guy, right?

445
00:19:42,200 --> 00:19:46,800
So hash tables need to have in order to function an additional sort of

446
00:19:46,800 --> 00:19:50,700
conceptual thing that regular arrays don't have which is they need to

447
00:19:50,700 --> 00:19:52,900
have Collision handling, right?

448
00:19:53,100 --> 00:19:56,600
So that's called a collision when two things they Collide essentially,

449
00:19:56,600 --> 00:19:59,800
right to things which have different coordinates in the

450
00:20:00,000 --> 00:20:04,100
Space both map to the same coordinates in the small space in that 1D

451
00:20:04,100 --> 00:20:06,300
array space, that we're trying to use for storage.

452
00:20:06,400 --> 00:20:07,400
That's called a collision.

453
00:20:07,700 --> 00:20:11,600
And so we need a way of handling those collisions and there's two

454
00:20:11,600 --> 00:20:15,300
typical ways of handling them and I'll talk about them both.

455
00:20:20,100 --> 00:20:21,400
So, one way.

456
00:20:22,700 --> 00:20:24,300
There's actually lots of different things here.

457
00:20:24,300 --> 00:20:27,500
It's a whole field, but I'm going to talk about two specific ones.

458
00:20:28,700 --> 00:20:29,100
Okay.

459
00:20:32,000 --> 00:20:34,300
Let's expand, its expand our Horizons.

460
00:20:34,900 --> 00:20:36,100
Oh, I keep forgetting any time.

461
00:20:36,100 --> 00:20:39,400
I expand it clears with the wrong color Frita.

462
00:20:41,500 --> 00:20:44,500
Alright, ever mined got a ride to drawing app.

463
00:20:45,400 --> 00:20:47,200
So many things that have to get done.

464
00:20:47,700 --> 00:20:48,400
What you going to do?

465
00:20:48,800 --> 00:20:49,400
All right.

466
00:20:49,600 --> 00:20:51,800
So let's say we've got this situation.

467
00:20:53,200 --> 00:20:57,000
Right, and I'm just going to talk about two elements, A and B.

468
00:20:58,200 --> 00:20:59,800
Now we can forget about the coordinates.

469
00:21:00,000 --> 00:21:02,400
But they both map to the same slot in the hash space.

470
00:21:02,400 --> 00:21:05,200
They both mad to slot 3 or something, right?

471
00:21:06,400 --> 00:21:07,400
And we need to store them.

472
00:21:08,300 --> 00:21:12,400
So the first thing we need to do is recognize that we need to know

473
00:21:12,400 --> 00:21:13,500
when collisions happen.

474
00:21:13,700 --> 00:21:14,300
An array.

475
00:21:14,300 --> 00:21:15,700
Usually just stores something in it.

476
00:21:15,700 --> 00:21:17,900
Right, but we can't do that anymore.

477
00:21:18,100 --> 00:21:24,100
We have to store both the thing and the coordinates, right?

478
00:21:25,700 --> 00:21:31,500
The original coordinates of the thing in the hash lot, because when

479
00:21:31,500 --> 00:21:34,500
something goes into the hash or when someone looks up something in the

480
00:21:34,500 --> 00:21:39,100
hash, we have to be able to look at what's in that hash Le and say is

481
00:21:39,100 --> 00:21:41,000
it actually the thing you wanted?

482
00:21:41,000 --> 00:21:44,900
Because again, if this guy had some coordinates x y z and this other

483
00:21:44,900 --> 00:21:48,200
guy had, you know X2 Y2 Z2, right?

484
00:21:48,200 --> 00:21:49,200
Or whatever in here.

485
00:21:50,300 --> 00:21:53,900
When we go to look up X, Y X2, Y2, Z2.

486
00:21:53,900 --> 00:21:58,400
We have to be able to see that the if like be was currently in hash

487
00:21:58,400 --> 00:22:02,600
lot 3, we have to be able to see that b is not a and if we just

488
00:22:02,600 --> 00:22:05,100
stored, whatever the data is, you know, I don't know what these things

489
00:22:05,100 --> 00:22:05,800
are carrying data.

490
00:22:05,800 --> 00:22:09,900
This carries a 5 and this carries a for if all we see, is the data

491
00:22:09,900 --> 00:22:11,100
five or the data.

492
00:22:11,100 --> 00:22:15,700
For when one of these guys goes in there, when the next guy comes and

493
00:22:15,700 --> 00:22:16,500
looks up there.

494
00:22:16,800 --> 00:22:17,500
It may think.

495
00:22:17,500 --> 00:22:20,000
Oh, the thing that's in there must be the

496
00:22:20,100 --> 00:22:20,500
That's it.

497
00:22:20,500 --> 00:22:22,700
X2 Y2, Z2, but surprised it wasn't.

498
00:22:22,700 --> 00:22:26,400
It was the thing that was at XYZ and you'll get back a for instead of

499
00:22:26,400 --> 00:22:27,900
a five when you asked for.

500
00:22:27,900 --> 00:22:30,400
What was it X2, Y2 Z2, right.

501
00:22:30,700 --> 00:22:33,800
So the first thing you need to do is store the actual coordinates

502
00:22:34,000 --> 00:22:38,000
inside so that you can compare them and know whether you've got the

503
00:22:38,000 --> 00:22:40,100
right one or not, right?

504
00:22:40,100 --> 00:22:41,900
So that's the first thing that has to happen.

505
00:22:42,200 --> 00:22:45,000
And the second thing that has to happen is when you see that, you

506
00:22:45,000 --> 00:22:46,400
don't have the right one.

507
00:22:46,600 --> 00:22:49,200
You have to do something about it, right?

508
00:22:54,900 --> 00:22:55,400
Okay.

509
00:22:56,500 --> 00:22:58,400
And there's two ways you can do something about it.

510
00:23:00,300 --> 00:23:02,300
Usually these are called, I shouldn't say there's two ways.

511
00:23:02,300 --> 00:23:03,600
There's probably a lot more than two ways.

512
00:23:03,900 --> 00:23:07,100
But there's two common ways one is called internal chaining and one is

513
00:23:07,100 --> 00:23:08,100
called external chaining.

514
00:23:09,600 --> 00:23:10,000
Right.

515
00:23:13,000 --> 00:23:15,900
And sometimes this is also called probing.

516
00:23:17,900 --> 00:23:21,300
And so on, there's there's a there's a bunch of terminology here and

517
00:23:21,300 --> 00:23:23,900
it's been a long time since I've ever read any formal literature on

518
00:23:23,900 --> 00:23:24,100
this.

519
00:23:24,100 --> 00:23:27,900
So I apologize if I'm not using the terms 100% precisely, but I'll

520
00:23:27,900 --> 00:23:29,300
explain what they are.

521
00:23:29,700 --> 00:23:32,400
And you can go to like, try to read the Wikipedia page or something.

522
00:23:32,600 --> 00:23:36,300
And and if you want the precise terminology for anything.

523
00:23:36,600 --> 00:23:37,100
All right.

524
00:23:37,400 --> 00:23:41,900
So what ends up happening is there's two sort of basic strategies that

525
00:23:41,900 --> 00:23:47,200
I see people use and that I use one is just to essentially turn the

526
00:23:47,200 --> 00:23:47,600
entries in

527
00:23:47,700 --> 00:23:49,400
To a linked list, right?

528
00:23:49,500 --> 00:23:53,800
So you have an array and that array is some fixed size.

529
00:23:53,800 --> 00:23:54,100
Right?

530
00:23:54,100 --> 00:23:57,100
Like we've got, you know, 256 entries in the array or something.

531
00:23:58,000 --> 00:23:59,600
We mapped to the 286 entries.

532
00:24:00,000 --> 00:24:03,800
We take the thing that's in the entry is just a pointer, right?

533
00:24:03,900 --> 00:24:06,800
Or it may be the first element in a linked list.

534
00:24:06,800 --> 00:24:10,400
Let's say so that would store like the, you know, if be went in there

535
00:24:10,400 --> 00:24:15,400
first, it's sort of XYZ and for and then it's got a little slot for a

536
00:24:15,400 --> 00:24:15,900
pointer.

537
00:24:15,900 --> 00:24:17,100
That's just set to 0.

538
00:24:17,700 --> 00:24:21,000
Then when we want to store a as well, it goes in there.

539
00:24:21,000 --> 00:24:26,800
It looks to see that x y z is not equal to XYZ to write and it creates

540
00:24:26,800 --> 00:24:29,800
in puts in this pointer, instead of it, overwrites the zero.

541
00:24:30,000 --> 00:24:33,300
With a pointer out to another storage field, right?

542
00:24:33,300 --> 00:24:36,900
Which is X2, Y2, Z2, and it stores the five in there.

543
00:24:37,400 --> 00:24:41,300
And so basically, any time you have a collision you just over occupy

544
00:24:41,300 --> 00:24:45,600
the space by having a linked list of the things that all map to that

545
00:24:45,600 --> 00:24:46,900
coordinate, right?

546
00:24:48,000 --> 00:24:49,900
And and that's external chaining, right?

547
00:24:49,900 --> 00:24:53,900
Because basically, if this is the hash table, the chain exists outside

548
00:24:53,900 --> 00:24:54,700
of the hash table.

549
00:24:54,700 --> 00:24:55,900
It's like separate memory.

550
00:24:55,900 --> 00:24:59,900
Basically, that's your pointing out to when you need to handle

551
00:24:59,900 --> 00:25:01,000
Collision, right?

552
00:25:01,100 --> 00:25:02,700
And that's the totally fine way to go.

553
00:25:02,900 --> 00:25:03,500
Obviously.

554
00:25:03,500 --> 00:25:06,700
It's a little wonky in that you end up having to chase these pointers,

555
00:25:06,700 --> 00:25:09,400
but the idea is you hope that you don't have a lot of collisions.

556
00:25:09,600 --> 00:25:13,400
So the depth of these lists is supposed to be quite short one to, you

557
00:25:13,400 --> 00:25:14,300
know, that sort of thing.

558
00:25:15,800 --> 00:25:17,400
The other way you can do it is within

559
00:25:17,500 --> 00:25:20,500
Internal training and what internal training does is the exact same

560
00:25:20,500 --> 00:25:25,600
procedure only instead of looking at a pointer.

561
00:25:25,600 --> 00:25:28,300
So, instead of having a pointer in a slot that kind of goes out to

562
00:25:28,300 --> 00:25:31,600
something else, when there is a collision, what you do is you just

563
00:25:31,600 --> 00:25:36,400
start looking through the hash table to see if you can find it after

564
00:25:36,600 --> 00:25:40,400
doing basically some some, some, some addition, right?

565
00:25:41,000 --> 00:25:43,900
So, if I come in here, and I'm Onslaught one, right?

566
00:25:43,900 --> 00:25:46,000
And here's two, three, four five.

567
00:25:46,200 --> 00:25:47,300
I find a collision on

568
00:25:47,400 --> 00:25:48,000
Not one.

569
00:25:48,000 --> 00:25:53,000
So, I've got, I'm trying to do x to the x 2, Y 2, Z 2, but and it maps

570
00:25:53,000 --> 00:25:54,400
to slot 1, right?

571
00:25:54,400 --> 00:25:58,100
So, it Maps here, but in slot 1 is this x y z, which is not what I

572
00:25:58,100 --> 00:25:58,700
wanted.

573
00:25:59,000 --> 00:26:00,100
Instead of creating a chain.

574
00:26:00,100 --> 00:26:00,700
That's external.

575
00:26:00,700 --> 00:26:01,700
I create essentially A Train.

576
00:26:01,700 --> 00:26:02,700
That's internal, I go.

577
00:26:02,700 --> 00:26:03,200
Okay.

578
00:26:03,300 --> 00:26:06,100
Let's look at like let's say if I was going to Chain by one.

579
00:26:06,100 --> 00:26:09,300
So I'm going to do like plus one was my chaining method.

580
00:26:09,600 --> 00:26:13,100
I would look at the next slot down and say, how about this one?

581
00:26:13,600 --> 00:26:15,800
If this one's empty then I know okay.

582
00:26:15,800 --> 00:26:17,300
Well, if this is empty, Then I then

583
00:26:17,500 --> 00:26:19,000
Just must not have ever been stored.

584
00:26:19,000 --> 00:26:20,600
So I'll just store it there, right?

585
00:26:20,600 --> 00:26:20,900
X2.

586
00:26:20,900 --> 00:26:21,800
Y2 Z2.

587
00:26:22,000 --> 00:26:25,400
I just store it in the next the first available slot that I find,

588
00:26:25,500 --> 00:26:26,100
right?

589
00:26:26,400 --> 00:26:29,100
Then when someone comes to do the lookup, it does the exact same

590
00:26:29,100 --> 00:26:30,500
procedure if it looks up.

591
00:26:30,500 --> 00:26:33,800
X2, Y2, Z2, it goes, it should be in slot 1.

592
00:26:33,800 --> 00:26:34,300
It's not.

593
00:26:34,300 --> 00:26:36,300
All right, look at slot to it.

594
00:26:36,300 --> 00:26:36,900
Sit there.

595
00:26:37,200 --> 00:26:37,900
Yes, it is.

596
00:26:38,000 --> 00:26:38,600
I found it.

597
00:26:38,600 --> 00:26:39,100
Right.

598
00:26:39,300 --> 00:26:41,300
So essentially you just populate slots.

599
00:26:41,300 --> 00:26:43,700
That shouldn't hold the thing that you want.

600
00:26:44,800 --> 00:26:48,500
With the thing that you want and you know that since everyone who does

601
00:26:48,500 --> 00:26:51,800
the lookup follows the same procedure as the person who did the store,

602
00:26:51,800 --> 00:26:54,400
you know, that they'll always find it if it's there and they just stop

603
00:26:54,400 --> 00:26:57,900
when they get to a null, a something that's not filled, right?

604
00:26:59,200 --> 00:26:59,800
Now, that has some.

605
00:27:00,000 --> 00:27:02,100
Add behaviors, which is that?

606
00:27:02,100 --> 00:27:05,700
Like, as the, you know, you can imagine that the linked list version,

607
00:27:05,700 --> 00:27:06,300
right?

608
00:27:06,300 --> 00:27:10,200
The link twist version kind of has a better worst-case performance in

609
00:27:10,200 --> 00:27:10,800
some sense.

610
00:27:10,800 --> 00:27:14,400
In the, when we're by worst case.

611
00:27:14,400 --> 00:27:15,800
I'm talking about specific worst case.

612
00:27:15,800 --> 00:27:19,600
It has a better worst-case performance when the hash table gets close

613
00:27:19,600 --> 00:27:22,200
to full in the entry array, right?

614
00:27:22,200 --> 00:27:27,700
Because for the same size array, like if you say, you know, I've got

615
00:27:27,700 --> 00:27:29,300
I'm going to, I'm going to use

616
00:27:30,000 --> 00:27:31,200
12 pieces of storage.

617
00:27:31,200 --> 00:27:37,000
Let's say and I have 256 of them for my hash table, normally, and each

618
00:27:37,000 --> 00:27:41,200
slot was occupied x 2, that would be full, right?

619
00:27:41,700 --> 00:27:44,900
You can imagine that when you're actually in the case, where you're

620
00:27:44,900 --> 00:27:47,800
doing the probing, you will have a lot of things filled.

621
00:27:47,800 --> 00:27:50,600
So when you go and you try to find something that's not in the hash

622
00:27:50,600 --> 00:27:51,700
table yet or something.

623
00:27:52,000 --> 00:27:52,700
You are see.

624
00:27:52,700 --> 00:27:53,700
You're skipping a lot.

625
00:27:53,700 --> 00:27:56,800
You're going through a lot of thing bins to find an empty space.

626
00:27:57,500 --> 00:27:59,500
Whereas with the linked list case, right?

627
00:27:59,500 --> 00:27:59,900
You would

628
00:28:00,000 --> 00:28:02,000
He's just check two things, you check one slot.

629
00:28:02,000 --> 00:28:04,400
And then the the pointer on that slot, right?

630
00:28:05,700 --> 00:28:09,500
So, as the hash table gets close to filled in the entry in terms of

631
00:28:09,500 --> 00:28:11,800
how many pieces of storage you have for it.

632
00:28:11,800 --> 00:28:15,800
This tends to perform a little bit better than the in terms of like

633
00:28:15,800 --> 00:28:17,000
how much probing gets done.

634
00:28:17,000 --> 00:28:20,100
How many checks get done the linked list case has a flatter

635
00:28:20,100 --> 00:28:21,300
performance curve, right?

636
00:28:21,300 --> 00:28:22,500
It's better in that case.

637
00:28:23,600 --> 00:28:27,500
But you have to look at, there's, there's a flip side to it, which is

638
00:28:27,500 --> 00:28:33,300
that, in the case of, in the, in the case of the, the internal

639
00:28:33,300 --> 00:28:34,700
chaining case, right?

640
00:28:34,800 --> 00:28:35,400
Which is this

641
00:28:35,900 --> 00:28:36,100
Okay.

642
00:28:36,100 --> 00:28:39,600
So the one I just described it has a nicer thing which is that all of

643
00:28:39,600 --> 00:28:42,000
your storage is used for the hashing.

644
00:28:42,200 --> 00:28:47,500
So the likelihood of collisions in the non full case goes down, right.

645
00:28:47,600 --> 00:28:51,400
Because if I'm going to use 512, lots of storage, the linked list

646
00:28:51,400 --> 00:28:52,800
case, right?

647
00:28:53,000 --> 00:28:57,700
Can't use all of them for the hash table because some of them are used

648
00:28:57,700 --> 00:28:59,500
for the linked list, right?

649
00:28:59,600 --> 00:29:02,700
So if I wanted to use a constant the same amount of space for both of

650
00:29:02,700 --> 00:29:05,000
them, I have to say, oh, well, the linked list is partitioned like

651
00:29:05,000 --> 00:29:05,500
it's got

652
00:29:05,600 --> 00:29:10,500
Twenty Eight slots, and then 512 - 128 is reserved for like the

653
00:29:10,500 --> 00:29:11,500
chains, right?

654
00:29:11,500 --> 00:29:12,500
Or something like that.

655
00:29:12,800 --> 00:29:16,800
If I wanted to keep a constant amount of memory, then basically, you

656
00:29:16,800 --> 00:29:21,500
have this problem where you're constantly using a lot less for the

657
00:29:21,500 --> 00:29:22,100
hashing.

658
00:29:22,100 --> 00:29:25,400
So collisions become more likely because you're trying to fit into a

659
00:29:25,400 --> 00:29:27,800
smaller low coordinate system.

660
00:29:27,900 --> 00:29:31,800
Whereas the internal training case, just always uses all of the memory

661
00:29:32,000 --> 00:29:35,100
for the actual hash table, which reduces the number of collisions,

662
00:29:35,200 --> 00:29:35,400
right?

663
00:29:35,600 --> 00:29:35,800
Right.

664
00:29:37,900 --> 00:29:39,400
so something to think about,

665
00:29:44,300 --> 00:29:45,400
Sorry, little stuff you today.

666
00:29:47,200 --> 00:29:48,500
Not sure if I'm getting cold.

667
00:29:54,200 --> 00:29:59,200
Maybe I'm too much Chopper traffic chip cookies, I guess so.

668
00:30:00,300 --> 00:30:03,300
That's the that's the skinny on hash tables.

669
00:30:03,300 --> 00:30:03,800
Right?

670
00:30:03,800 --> 00:30:09,200
So what I want to do for now is I'll probably just Implement a very

671
00:30:09,200 --> 00:30:13,400
simple one and we won't try to do anything fancy like pacifically.

672
00:30:13,400 --> 00:30:14,700
One thing that we won't quite do.

673
00:30:14,700 --> 00:30:20,000
Yet is try to concentrate on the hash function, especially because we

674
00:30:20,000 --> 00:30:23,600
want to be able to introduce something that appears in almost every

675
00:30:23,600 --> 00:30:24,100
code base.

676
00:30:24,200 --> 00:30:29,500
Even after it ships, which is to do: better hash function.

677
00:30:30,300 --> 00:30:33,300
Because everyone always says they should make a better hash function

678
00:30:33,300 --> 00:30:34,800
and then never actually does.

679
00:30:34,900 --> 00:30:38,500
So this to do is in like every code based somewhere, right?

680
00:30:38,900 --> 00:30:41,600
Because Hashem is even with a really lousy hash function.

681
00:30:41,800 --> 00:30:43,400
Still work pretty well.

682
00:30:44,000 --> 00:30:46,600
So a lot of times they're just good enough and no one ever ends up

683
00:30:46,600 --> 00:30:49,500
going to do the math and figuring out what the best way would be.

684
00:30:50,200 --> 00:30:52,700
But you know, maybe at least since this is an educational stream at

685
00:30:52,700 --> 00:30:53,700
some point during development.

686
00:30:53,700 --> 00:30:59,600
We will try to actually not leave that to do in there and do a better

687
00:30:59,600 --> 00:31:00,100
hash function.

688
00:31:00,200 --> 00:31:00,300
No.

689
00:31:01,500 --> 00:31:03,800
Alright, so there you go.

690
00:31:05,200 --> 00:31:06,400
There's a number.

691
00:31:06,400 --> 00:31:08,900
Like I said, if you want to go read about hash tables, there's,

692
00:31:08,900 --> 00:31:11,600
there's tons of topics involved in hash tables.

693
00:31:11,600 --> 00:31:14,700
Lots of things to think about how big they should be size.

694
00:31:14,700 --> 00:31:17,300
Should they be prime number sizes for wrapping?

695
00:31:17,300 --> 00:31:19,800
Because you have to the way you map in the coordinate space.

696
00:31:19,800 --> 00:31:23,300
There's there's all these sort of like number-theoretic issues that in

697
00:31:23,300 --> 00:31:24,300
are involved here.

698
00:31:24,500 --> 00:31:27,500
Some of which I'm not even that good at understanding because I don't

699
00:31:27,500 --> 00:31:29,000
spend a lot of time studying hash tables.

700
00:31:29,200 --> 00:31:31,000
So I'm even the wrong person to explain them.

701
00:31:31,100 --> 00:31:33,000
Point being you should be aware.

702
00:31:33,000 --> 00:31:35,700
Anyways, that there's a whole like big thing.

703
00:31:35,700 --> 00:31:38,100
There's things while perfect hash functions which are guaranteed to

704
00:31:38,100 --> 00:31:42,400
always fill the hash table correctly and just a lot of stuff to learn

705
00:31:42,400 --> 00:31:42,500
there.

706
00:31:42,500 --> 00:31:45,500
If you really wanted to kind of really, no hash tables inside and out

707
00:31:45,500 --> 00:31:49,000
and we probably won't quite get all the way down that rabbit hole, but

708
00:31:49,000 --> 00:31:51,600
I wanted to make sure people understand that it's there.

709
00:31:52,300 --> 00:31:55,900
So all I really want to do is I just want to be able to start saying,

710
00:31:55,900 --> 00:31:56,500
okay.

711
00:31:57,500 --> 00:32:01,200
Let's, let's go to our handmade tile system here.

712
00:32:01,200 --> 00:32:01,700
Right?

713
00:32:02,000 --> 00:32:07,700
And let's stop doing this Kyle chunk count stuff and let's start doing

714
00:32:07,700 --> 00:32:10,900
it so that we're just storing them in a hash table essentially.

715
00:32:11,600 --> 00:32:17,300
So, in our tile chunk, we're going to say what it's it style, chunk X

716
00:32:17,300 --> 00:32:17,900
tile chunk.

717
00:32:17,900 --> 00:32:18,100
Why?

718
00:32:18,100 --> 00:32:20,900
And tile chunk Z actually were right.

719
00:32:20,900 --> 00:32:25,500
So, essentially, these right, we're going to say the coordinates of

720
00:32:25,500 --> 00:32:26,300
the tile chunk.

721
00:32:27,300 --> 00:32:29,700
Down here, and the coordinates.

722
00:32:29,700 --> 00:32:30,100
Why?

723
00:32:30,300 --> 00:32:31,000
Why is that?

724
00:32:31,400 --> 00:32:33,800
My emacs is very slow right now.

725
00:32:34,500 --> 00:32:35,300
What's going on?

726
00:32:35,400 --> 00:32:36,500
Do I have some weird?

727
00:32:36,600 --> 00:32:39,800
What's, who's who is responsible for this?

728
00:32:40,200 --> 00:32:41,300
What's going on here?

729
00:32:42,800 --> 00:32:46,100
Nothing weird going on, really?

730
00:32:47,300 --> 00:32:47,400
No.

731
00:32:47,400 --> 00:32:47,600
No.

732
00:32:47,600 --> 00:32:48,300
No.

733
00:32:53,000 --> 00:32:53,300
Yeah.

734
00:32:54,200 --> 00:32:56,800
I wonder if krita's being a little hog, and I don't think so.

735
00:32:57,000 --> 00:32:57,900
I don't know what's going on.

736
00:32:57,900 --> 00:32:59,600
But I guess that's just the way it goes sometimes.

737
00:33:00,900 --> 00:33:05,800
All right, so we've got these tile chunks, right, and I'm just going

738
00:33:05,800 --> 00:33:09,400
to store with the tile chunk now, which coordinate it was so that it

739
00:33:09,400 --> 00:33:11,100
can be in a hash table, right?

740
00:33:11,400 --> 00:33:14,900
And maybe for now we'll just use external chaining.

741
00:33:15,100 --> 00:33:16,400
So we'll just say that.

742
00:33:16,400 --> 00:33:22,400
Any time that we have a tile chunk that we need to sort of extend to

743
00:33:22,400 --> 00:33:25,900
have more tile chunks after it that map to the same coordinate in our

744
00:33:25,900 --> 00:33:26,600
hash table.

745
00:33:26,800 --> 00:33:27,700
We'll just have a next.

746
00:33:27,700 --> 00:33:30,600
So, we'll say next in hash, just to be clear.

747
00:33:30,700 --> 00:33:34,300
About what next means in this case, right?

748
00:33:35,000 --> 00:33:40,800
And then we can say in this situation when we're going to go store

749
00:33:40,800 --> 00:33:41,200
them.

750
00:33:41,600 --> 00:33:45,700
Then we're actually going to call this our tile chunk hash and we'll

751
00:33:45,700 --> 00:33:46,700
have our tile chunk.

752
00:33:46,700 --> 00:33:49,000
Hash can be of a known size.

753
00:33:49,400 --> 00:33:52,600
I'm going to use a power of two at the moment.

754
00:33:53,100 --> 00:33:57,500
So that that it'll be not too bad to look up in, and I'll show you why

755
00:33:57,500 --> 00:34:00,500
that we do that in a second, but it's worth noting that

756
00:34:00,700 --> 00:34:04,100
That this is not necessarily the smartest thing to do.

757
00:34:05,300 --> 00:34:10,600
because it's a little hard to explain exactly why, but

758
00:34:13,100 --> 00:34:14,800
when we do the mapping,

759
00:34:16,600 --> 00:34:20,300
There's number theoretic reasons why you may not want to have a power

760
00:34:20,300 --> 00:34:23,300
of two because that powers of two directly truncate.

761
00:34:23,300 --> 00:34:26,500
The bits that come out of the hash function and I'll kind of show you

762
00:34:26,500 --> 00:34:26,900
why.

763
00:34:26,900 --> 00:34:29,600
There's, there's some issues there when we get to it.

764
00:34:29,600 --> 00:34:32,600
A bit of a little bit, but I'm going to do that right now just because

765
00:34:32,800 --> 00:34:35,500
I think that'll be a little more efficient at the moment, especially

766
00:34:35,500 --> 00:34:38,100
since we aren't going to be doing a particularly good hash function,

767
00:34:38,600 --> 00:34:40,400
and aren't really thinking that stuff through, I don't think it's

768
00:34:40,400 --> 00:34:40,900
worth it.

769
00:34:41,600 --> 00:34:45,100
So, what I want to do is say we've got this tile chunk hash, and the

770
00:34:45,100 --> 00:34:46,100
tile chunk cash.

771
00:34:46,300 --> 00:34:49,800
We'll just be a bunch of pointers to top chunks, right?

772
00:34:49,800 --> 00:34:52,500
So we'll have 4096 pointers off the top chunks.

773
00:34:53,600 --> 00:34:57,200
That'll basically just store whether or not there's there's a topic

774
00:34:57,200 --> 00:34:57,400
there.

775
00:34:57,400 --> 00:34:57,500
Now.

776
00:34:57,500 --> 00:35:03,900
What I could do is is have some notion of I could just flat-out store

777
00:35:03,900 --> 00:35:04,600
it like this.

778
00:35:04,800 --> 00:35:08,000
So we actually just have tile chunks there or I could throw them as

779
00:35:08,000 --> 00:35:12,300
pointers and I think maybe it's better to just store the top chunks

780
00:35:12,800 --> 00:35:13,700
exactly.

781
00:35:14,000 --> 00:35:16,300
Because I don't want to have to chase a pointer right at the first

782
00:35:16,300 --> 00:35:16,600
look up.

783
00:35:16,600 --> 00:35:17,400
So we'll just say that.

784
00:35:17,400 --> 00:35:21,800
The first tile chunk is stored directly in the hash table entry and

785
00:35:21,800 --> 00:35:23,200
then the slots over.

786
00:35:23,400 --> 00:35:24,900
Just like I drew it on the diagram.

787
00:35:25,400 --> 00:35:27,900
The slot is just is stored there.

788
00:35:28,200 --> 00:35:30,800
And the other thing that I could do is, instead of this being a

789
00:35:30,800 --> 00:35:36,000
pointer to tiles again, we could actually make that as well be the 16

790
00:35:36,000 --> 00:35:36,400
by 16.

791
00:35:36,400 --> 00:35:39,400
I don't know if we really want to do that yet though, that's hard to

792
00:35:39,400 --> 00:35:43,300
say because the reason we were making that pointer be a pointer to

793
00:35:43,300 --> 00:35:46,100
tiles is because some of them weren't filled.

794
00:35:46,200 --> 00:35:48,200
And so what we could do is say that those are actually there.

795
00:35:48,200 --> 00:35:48,900
I don't know.

796
00:35:50,500 --> 00:35:50,800
Yeah.

797
00:35:52,200 --> 00:35:52,500
Right?

798
00:35:52,500 --> 00:35:55,000
Because this was something like this, right?

799
00:35:55,800 --> 00:35:57,500
But I don't think we want to do that yet.

800
00:35:57,500 --> 00:35:58,800
So let's just do it this way.

801
00:35:59,200 --> 00:35:59,900
Let's say that we have

802
00:36:00,000 --> 00:36:04,000
Our touch on cash like so and we've got our tile Chung.

803
00:36:06,100 --> 00:36:08,500
And so now we're basically just going to implement a very simple hash

804
00:36:08,500 --> 00:36:10,800
table that looks up inside the touch on cash.

805
00:36:10,800 --> 00:36:11,400
Right?

806
00:36:11,400 --> 00:36:14,400
And in order to do that.

807
00:36:14,400 --> 00:36:20,000
I need to actually change the functions that look up that towel, but

808
00:36:20,000 --> 00:36:23,400
look up in that top junk array, which is compiler will helpfully, tell

809
00:36:23,400 --> 00:36:23,600
me about.

810
00:36:23,600 --> 00:36:28,200
So when we go to get a tile chunk, and we're passing it in x y and a z

811
00:36:28,200 --> 00:36:30,100
instead of this stuff.

812
00:36:30,100 --> 00:36:32,700
Now, we're never actually going to do these checks, right?

813
00:36:32,700 --> 00:36:35,700
Because we no longer have any bounds on where our chunks could be.

814
00:36:35,700 --> 00:36:36,000
That can be

815
00:36:36,200 --> 00:36:41,700
Beware, what I'm going to do instead is create a hash index and I'm

816
00:36:41,700 --> 00:36:45,600
going to do the stupidest possible thing at the moment that you could

817
00:36:45,600 --> 00:36:46,500
ever possibly do.

818
00:36:46,500 --> 00:36:50,500
I'm literally just pulling this completely out of nowhere.

819
00:36:50,600 --> 00:36:53,700
There's really nothing intelligent about it whatsoever.

820
00:36:54,000 --> 00:36:56,300
Literally, you know, don't do this at home.

821
00:36:56,300 --> 00:36:57,500
It's just stupid.

822
00:36:58,300 --> 00:37:01,700
I'm literally just going to create a function that just does some

823
00:37:01,800 --> 00:37:06,000
arbitrary completely arbitrary, mapping of these things.

824
00:37:06,100 --> 00:37:07,100
Together, right?

825
00:37:07,100 --> 00:37:12,200
So it's just, it's just flat out doing some kind of weird manipulation

826
00:37:12,200 --> 00:37:15,100
of the numbers and it's basically just doing a standard array kind of

827
00:37:15,100 --> 00:37:18,100
thing where we're manipulating them and then smashing them together,

828
00:37:18,200 --> 00:37:18,800
right?

829
00:37:19,600 --> 00:37:25,000
And then I'm just going to take whatever that number is and we'll call

830
00:37:25,000 --> 00:37:27,000
this look like to call this a hash value.

831
00:37:27,200 --> 00:37:31,700
And then I'm going to make a hash slot which is to say whatever random

832
00:37:31,700 --> 00:37:35,400
number, this thing pulled out by Smashing these guys together into one

833
00:37:35,400 --> 00:37:35,900
number.

834
00:37:36,100 --> 00:37:38,300
I now need to just put it into the table.

835
00:37:38,400 --> 00:37:40,900
And so the way I'm going to do that is I'm going to take the array

836
00:37:40,900 --> 00:37:41,600
count.

837
00:37:42,200 --> 00:37:43,700
However, big my tile chunk.

838
00:37:43,700 --> 00:37:44,700
Hashed was right.

839
00:37:44,700 --> 00:37:45,500
However, many slots.

840
00:37:45,500 --> 00:37:46,100
I had.

841
00:37:46,200 --> 00:37:47,500
I'm just going to take that.

842
00:37:49,600 --> 00:37:52,300
And I'm going to subtract 1 from it because we know it's a power of 2,

843
00:37:52,500 --> 00:37:53,100
right.

844
00:37:54,300 --> 00:37:56,500
I'm just put this in here at the moment.

845
00:37:58,700 --> 00:38:00,200
This must be a power of 2.

846
00:38:02,100 --> 00:38:02,600
Right.

847
00:38:04,300 --> 00:38:06,100
So what I want to do here is say okay.

848
00:38:09,100 --> 00:38:12,500
Take me Rake out with it for the top, for the touch on cash, subtract

849
00:38:12,500 --> 00:38:16,400
1 from it, which will basically give me a mask that will that I can.

850
00:38:16,400 --> 00:38:18,600
And my hash value against, right?

851
00:38:18,600 --> 00:38:20,100
Because, remember, it was the power of 2.

852
00:38:20,100 --> 00:38:24,000
It means, it's if it's a power of two, it means that it's something

853
00:38:24,000 --> 00:38:26,200
that looks like this in binary, right?

854
00:38:27,100 --> 00:38:28,800
It's a one, followed by a bunch of zeros.

855
00:38:28,800 --> 00:38:32,800
If it's a power of 2, If I subtract 1 from it, it will borrow all the

856
00:38:32,800 --> 00:38:36,100
way across until they're in the make a 0, which is exactly the mask.

857
00:38:36,100 --> 00:38:37,800
I want to mask out.

858
00:38:38,000 --> 00:38:41,800
Out the part of this value, that would not fit in the array.

859
00:38:42,000 --> 00:38:46,000
So this basically just makes it into sort of a rapping number, if you

860
00:38:46,000 --> 00:38:49,200
will that fits inside the array size that we've defined.

861
00:38:49,800 --> 00:38:52,400
So, that we know is that the, the hash lat

862
00:38:53,600 --> 00:38:56,400
That this thing would fit into and I think I said I wanted to do it

863
00:38:56,400 --> 00:38:57,000
that way, right?

864
00:38:57,000 --> 00:38:58,600
I think I said I didn't want to store pointers.

865
00:38:58,600 --> 00:38:59,400
So we're going to do that.

866
00:39:00,400 --> 00:39:03,900
So, the chunk that we actually want is just a child chunk.

867
00:39:03,900 --> 00:39:06,300
Hash now plus, that hash lat.

868
00:39:06,400 --> 00:39:09,600
So now, we've just indexed that that value, right?

869
00:39:09,600 --> 00:39:14,000
And we can assert here as well that the hash lot is less than that

870
00:39:14,000 --> 00:39:14,800
array count.

871
00:39:14,800 --> 00:39:18,700
Because we never, we always want this trunk, this truncation.

872
00:39:18,700 --> 00:39:21,200
Basically here should have made it, so that it always will be.

873
00:39:21,700 --> 00:39:24,200
So after we compute the hash lot, we can get out the chunk.

874
00:39:24,400 --> 00:39:26,900
Oh, and I forgot to do this is the to do.

875
00:39:26,900 --> 00:39:28,600
I said that every code base has in it.

876
00:39:31,600 --> 00:39:34,500
Right, so that'll be in there will probably shift the game with it.

877
00:39:34,500 --> 00:39:35,400
That's just how it works.

878
00:39:36,600 --> 00:39:37,400
What can you say?

879
00:39:37,500 --> 00:39:40,500
But if we remember someday, we'll have to go back study UPS on our

880
00:39:40,500 --> 00:39:43,100
hash tables and do a better job, okay.

881
00:39:45,000 --> 00:39:48,700
So we've got our Tau chunk now and then what we need to do is say is

882
00:39:48,700 --> 00:39:51,000
this chunk by Chunk we wanted, right.

883
00:39:51,100 --> 00:39:56,000
So essentially what we have to do is make a for Loop now which goes

884
00:39:56,000 --> 00:39:58,700
over the chunks in order.

885
00:40:01,100 --> 00:40:08,100
Like so on and tries to find whichever chunk is the one that that has

886
00:40:08,100 --> 00:40:10,400
that is the values that we were looking for, right?

887
00:40:10,400 --> 00:40:12,600
Because we have to again, we can have Collision.

888
00:40:12,600 --> 00:40:16,400
So we need to start comparing the value stored in the tile chunk to

889
00:40:16,400 --> 00:40:18,200
see whether it's the chunk that we wanted.

890
00:40:18,300 --> 00:40:18,800
Right.

891
00:40:20,200 --> 00:40:23,200
This might actually have to be a while loop Jimmy.

892
00:40:26,600 --> 00:40:28,000
In fact, I think I will make it a while loop.

893
00:40:32,200 --> 00:40:32,600
Okay.

894
00:40:33,100 --> 00:40:38,200
So what we need to do is we kind of know in fact that that's going to

895
00:40:38,200 --> 00:40:38,600
be that.

896
00:40:38,600 --> 00:40:41,000
So really, it's a do while loop at the end of the day.

897
00:40:42,200 --> 00:40:45,100
So what we need to do now is we need to say, okay.

898
00:40:45,300 --> 00:40:49,100
We have a certain tile chunk xed out require that we were looking for.

899
00:40:49,200 --> 00:40:51,600
We're starting to look through our our chain.

900
00:40:51,700 --> 00:40:56,000
Remember, we're trying to look through basically, you know, this guy

901
00:40:56,000 --> 00:40:56,600
right here.

902
00:40:56,900 --> 00:41:00,900
We're going to look through and see which one of these guys has.

903
00:41:00,900 --> 00:41:01,900
Our thing has the

904
00:41:02,100 --> 00:41:03,300
The chunk that we were looking for.

905
00:41:03,900 --> 00:41:08,700
So you want to look to see whether we get a match on all three of the

906
00:41:08,700 --> 00:41:10,900
coordinates, exactly, right?

907
00:41:11,800 --> 00:41:16,400
So, we look to see whether we've got an X Y or Z match and it's Ari

908
00:41:16,400 --> 00:41:17,300
and Uzi match.

909
00:41:17,500 --> 00:41:20,700
And if we have all three of them, then we know we've found the Tau

910
00:41:20,700 --> 00:41:21,100
chunk.

911
00:41:21,200 --> 00:41:24,600
So if we found all three, then we say, yes, good.

912
00:41:24,600 --> 00:41:26,100
That's exactly what we wanted.

913
00:41:26,800 --> 00:41:30,100
Although we need one more thing, which is, we need to see whether the

914
00:41:30,100 --> 00:41:33,700
slot is filled at all, because it could be that the child Chuck XYZ

915
00:41:33,700 --> 00:41:37,500
are all zero, which I don't know if we want to, you know, we, I guess

916
00:41:37,500 --> 00:41:41,600
we could also just say that all zero is considered an invalid.

917
00:41:41,700 --> 00:41:45,200
We're so you can never get down 2000 so we could do something like

918
00:41:45,200 --> 00:41:45,600
this.

919
00:41:45,800 --> 00:41:50,800
A certain child chunk X not equal to 0 kind of thing or not.

920
00:41:51,100 --> 00:41:54,400
I should say Tau chunk x equals 0.

921
00:41:56,200 --> 00:41:59,800
And Kyle, junk y equals zero and tell chunk Z equals zero.

922
00:42:01,800 --> 00:42:04,600
So we could just say that 0 0 since we're not allowing rapping,

923
00:42:04,800 --> 00:42:07,400
basically the whole border of our world.

924
00:42:07,400 --> 00:42:11,500
The very outer, most tile all the way around is not really allowed to

925
00:42:11,500 --> 00:42:13,000
be occupied.

926
00:42:13,300 --> 00:42:16,300
So 000 would be totally fine.

927
00:42:16,300 --> 00:42:21,200
We could also assert that we're never asking for one of those ones on

928
00:42:21,200 --> 00:42:21,700
the border.

929
00:42:21,800 --> 00:42:25,800
So in some sense, we could also say assert that you never actually

930
00:42:25,800 --> 00:42:27,000
asked for a border tile.

931
00:42:27,200 --> 00:42:29,900
In fact, that might be a good idea because if we're not allowing

932
00:42:29,900 --> 00:42:31,400
wrapping you should never ever ever.

933
00:42:31,600 --> 00:42:32,200
Doing that.

934
00:42:33,200 --> 00:42:36,000
So we kind of want to do something like this anyway.

935
00:42:41,400 --> 00:42:43,200
And we could even say, you know.

936
00:42:44,900 --> 00:42:47,300
Assert, maybe I'll do it this way.

937
00:42:47,400 --> 00:42:50,000
We could say that there's a safe margin, right?

938
00:42:50,400 --> 00:42:55,700
And we could say, you know, pound to find safe margin tile chunk,

939
00:42:56,100 --> 00:42:56,400
safe.

940
00:42:56,400 --> 00:42:59,900
Margin, we could just say never let the person get within the world

941
00:42:59,900 --> 00:43:03,200
should never get within 16 of the border, right?

942
00:43:03,200 --> 00:43:04,000
We start at the middle.

943
00:43:04,000 --> 00:43:05,600
There's no way you should ever get out there.

944
00:43:05,600 --> 00:43:08,000
So if something happens, that's like that.

945
00:43:08,100 --> 00:43:11,900
That's just full on banana cakes and some there was some heinous bug

946
00:43:11,900 --> 00:43:12,600
in the code.

947
00:43:12,800 --> 00:43:13,800
So let's just say that we have to

948
00:43:14,000 --> 00:43:15,500
Rather than the safe margin here.

949
00:43:16,300 --> 00:43:20,800
And then we have to be, you know, less than the safe margin on the

950
00:43:20,800 --> 00:43:23,500
outside as well, right?

951
00:43:24,900 --> 00:43:28,800
On all the coordinates and that seems pretty reasonable to me, right.

952
00:43:28,800 --> 00:43:29,800
That seems pretty good.

953
00:43:30,400 --> 00:43:33,800
So we start by going through.

954
00:43:33,800 --> 00:43:36,700
We grab the first Chunk in the hash lat, right?

955
00:43:37,700 --> 00:43:39,200
And we then say, all right.

956
00:43:39,200 --> 00:43:41,500
Let's go ahead and start looking through these guys.

957
00:43:41,500 --> 00:43:41,900
Oops.

958
00:43:43,300 --> 00:43:45,200
Compiled to good compelled to well.

959
00:43:46,900 --> 00:43:50,800
Start looking through these guys assuming that we don't find it.

960
00:43:50,900 --> 00:43:53,500
We need to go to the next one, the hash, right?

961
00:43:55,200 --> 00:43:58,900
And so what we need to do is say well first, let's check does.

962
00:43:58,900 --> 00:44:02,400
Is there a next one in the hash if there isn't a next one?

963
00:44:02,400 --> 00:44:07,600
In the hash, then we're sort of, we're done right with the with the

964
00:44:07,600 --> 00:44:08,300
situation.

965
00:44:08,400 --> 00:44:14,000
Certainly, although I guess what I should do here is say, when we do

966
00:44:14,000 --> 00:44:14,800
get to a chunk.

967
00:44:15,000 --> 00:44:20,600
We can also pass a Bool to it, which says, create if doesn't exist or

968
00:44:20,600 --> 00:44:24,500
something, create, if missing, and that will just assume to be

969
00:44:24,700 --> 00:44:28,600
Else but if someone wants to actually make the tile chunk put it in

970
00:44:28,600 --> 00:44:29,100
place.

971
00:44:29,200 --> 00:44:31,600
We're at the right position in the code to do that.

972
00:44:32,000 --> 00:44:36,900
So I might just go ahead and say all right, if you know

973
00:44:40,800 --> 00:44:45,100
Like so I might just say if there isn't a next one in the hash and we

974
00:44:45,100 --> 00:44:46,600
didn't match, right?

975
00:44:47,000 --> 00:44:51,900
Then if create if missing is true, then I want to actually make one.

976
00:44:52,000 --> 00:44:56,200
So I want to make next in half be equal to a new tile chunk.

977
00:44:56,800 --> 00:44:57,400
Right?

978
00:44:57,700 --> 00:44:59,800
And so what that's going to have to do is that

979
00:45:00,000 --> 00:45:00,600
Going to have to.

980
00:45:00,600 --> 00:45:03,500
And in fact, you know what, I can even do it in a slightly more

981
00:45:03,500 --> 00:45:06,600
interesting way to what I could do is, if you pass the memory

982
00:45:06,600 --> 00:45:10,000
allocator to it, then it will it will do the creation and if you

983
00:45:10,000 --> 00:45:10,900
don't, you don't.

984
00:45:11,000 --> 00:45:14,500
So, I don't know if you remember this, if you basically pass the

985
00:45:14,500 --> 00:45:15,300
memory Arena.

986
00:45:17,700 --> 00:45:23,700
Here, we'll just say, if you pass a memory Arena to it, then it will

987
00:45:23,700 --> 00:45:25,000
go ahead and create one for you.

988
00:45:25,200 --> 00:45:26,800
And if you don't then it won't.

989
00:45:26,800 --> 00:45:32,100
So if there's an arena then it will create a new, a new one.

990
00:45:33,700 --> 00:45:37,900
So I may have to return a little bit more than that.

991
00:45:38,200 --> 00:45:39,400
But let's let's find out.

992
00:45:40,200 --> 00:45:44,100
So yeah, so what we would do here is we'd also have to clear it

993
00:45:44,100 --> 00:45:46,900
potentially if we always wanted to clear it, but we may want to not

994
00:45:46,900 --> 00:45:47,500
clear at some time.

995
00:45:47,500 --> 00:45:49,600
So we'll have to think about how we want to handle that.

996
00:45:49,600 --> 00:45:50,200
Exactly.

997
00:45:50,800 --> 00:45:54,100
But essentially what will happen here is this will do that fill,

998
00:45:54,400 --> 00:45:55,000
right?

999
00:45:55,800 --> 00:45:56,400
So

1000
00:45:58,600 --> 00:46:00,100
In the case where we don't find one.

1001
00:46:00,400 --> 00:46:03,500
We we do our push here.

1002
00:46:04,000 --> 00:46:10,300
So we would do to push, has essentially right one to push the array,

1003
00:46:10,900 --> 00:46:11,400
right?

1004
00:46:11,900 --> 00:46:12,700
New chunk.

1005
00:46:13,500 --> 00:46:15,100
New chunk, like so.

1006
00:46:17,500 --> 00:46:20,400
I'll chunk new chunk equals push.

1007
00:46:21,800 --> 00:46:22,400
I'll jump.

1008
00:46:23,200 --> 00:46:25,600
So we push a new one on to our Arena.

1009
00:46:26,100 --> 00:46:28,500
We push a new array for the tiles.

1010
00:46:28,500 --> 00:46:33,000
We initialize the tiles and we set the chain are in our hash chain.

1011
00:46:33,200 --> 00:46:38,000
We set that chain to point to the new chunk.

1012
00:46:38,200 --> 00:46:39,300
And now we are done.

1013
00:46:39,500 --> 00:46:44,600
You can just flat-out break out of the thing and we're done, right?

1014
00:46:46,500 --> 00:46:47,700
Same thing is true here.

1015
00:46:48,100 --> 00:46:49,400
If we happen to find it.

1016
00:46:49,400 --> 00:46:50,500
We have found the chunk.

1017
00:46:50,900 --> 00:46:53,000
So that's fine and everything's good.

1018
00:46:53,400 --> 00:46:58,200
And we can also do this so that when we break we can just return chunk

1019
00:46:58,400 --> 00:47:02,100
and that's the chunk that we found and that's, yeah, that's pretty

1020
00:47:02,100 --> 00:47:02,700
much it.

1021
00:47:02,800 --> 00:47:03,900
Don't need that either.

1022
00:47:04,600 --> 00:47:06,000
So you hope that you can see what happens here.

1023
00:47:06,000 --> 00:47:10,200
Let's walk through it once and this is mostly what we need.

1024
00:47:12,200 --> 00:47:12,700
so,

1025
00:47:13,900 --> 00:47:16,800
We assert that we're not asking for a chunk that's in an illegal

1026
00:47:16,800 --> 00:47:19,300
boundary, that we don't ever want to have something in because our

1027
00:47:19,300 --> 00:47:20,900
code is now not.

1028
00:47:21,000 --> 00:47:24,100
We're saying by Design can never wrap, and so we want to make sure no

1029
00:47:24,100 --> 00:47:26,700
one's near that apron, because then calculations that are based on

1030
00:47:26,700 --> 00:47:30,900
regions will go outside it, right?

1031
00:47:31,400 --> 00:47:32,200
We don't want that.

1032
00:47:33,400 --> 00:47:35,500
So we make sure that we're not in that region by checking to see

1033
00:47:35,500 --> 00:47:38,200
whether we're greater than and less than basically the two boundaries

1034
00:47:38,200 --> 00:47:41,400
on the low side and the high side which is set to 16 right now, but we

1035
00:47:41,400 --> 00:47:42,100
could set it higher.

1036
00:47:42,200 --> 00:47:44,800
Well, we could set it to 56 and just make a real big margin for

1037
00:47:44,800 --> 00:47:45,100
safety.

1038
00:47:45,100 --> 00:47:45,400
No one.

1039
00:47:45,400 --> 00:47:48,100
Should the world would be massive if you ever got out that far.

1040
00:47:48,100 --> 00:47:51,300
Anyway, there's never the player couldn't even walk that far in like

1041
00:47:51,300 --> 00:47:52,100
weeks, right?

1042
00:47:53,400 --> 00:47:54,800
So that's fine.

1043
00:47:55,300 --> 00:47:57,900
If we go to our hashtag computation.

1044
00:47:57,900 --> 00:47:59,800
We just are doing something random and crappy right now.

1045
00:48:00,000 --> 00:48:01,900
That's just going to compute some number.

1046
00:48:02,000 --> 00:48:02,900
That mixes together.

1047
00:48:02,900 --> 00:48:05,800
All three to give us a place to look in our hash table.

1048
00:48:06,000 --> 00:48:07,700
We then get rid of the bottom.

1049
00:48:07,700 --> 00:48:10,800
Sorry of the top bits of that and just use, however, many bits will

1050
00:48:10,800 --> 00:48:12,200
actually fit into the array.

1051
00:48:12,200 --> 00:48:14,500
That's the size that we made for our hash.

1052
00:48:15,500 --> 00:48:17,300
We assert that that's a valid thing to look up.

1053
00:48:17,300 --> 00:48:19,700
We then actually go and grab it out of the hash table.

1054
00:48:19,900 --> 00:48:21,000
And we start walking.

1055
00:48:21,200 --> 00:48:24,500
If we find a match by comparing the child chunks that we're looking

1056
00:48:24,500 --> 00:48:26,100
for, with the junk that's in, there we go.

1057
00:48:27,000 --> 00:48:29,600
Then we go and check to see if the person passes an

1058
00:48:30,000 --> 00:48:34,700
before allocation, and there isn't another new chunk to check.

1059
00:48:35,900 --> 00:48:38,700
Oh, I guess there's two things.

1060
00:48:38,700 --> 00:48:39,100
We should do.

1061
00:48:39,100 --> 00:48:44,800
They're actually now that I think about it because there's a second

1062
00:48:44,800 --> 00:48:51,300
case, the second case is, if there's a Rena and not chunk not Chum

1063
00:48:51,500 --> 00:48:52,500
hash, right?

1064
00:48:53,300 --> 00:48:57,100
Or, you know, tile chunk x equals 0, right?

1065
00:48:57,400 --> 00:48:59,800
Which is to say that, it was an uninitialized.

1066
00:48:59,800 --> 00:49:02,300
If it's an uninitialized slot, right?

1067
00:49:02,700 --> 00:49:05,500
Because we that first slot would,

1068
00:49:05,600 --> 00:49:06,200
Uninitialized?

1069
00:49:06,200 --> 00:49:08,300
Right, because we actually stored it directly in there.

1070
00:49:09,600 --> 00:49:14,000
So in either case, if it doesn't have the next one, or this one is not

1071
00:49:14,000 --> 00:49:14,300
it.

1072
00:49:14,300 --> 00:49:15,400
And I guess that we really owe.

1073
00:49:15,400 --> 00:49:16,600
This is a little ugly.

1074
00:49:16,700 --> 00:49:18,800
This makes the code a little more complicated storing it directly in

1075
00:49:18,800 --> 00:49:19,200
their that.

1076
00:49:19,200 --> 00:49:20,900
Whereas, if we just had a pointer, it wouldn't be.

1077
00:49:21,200 --> 00:49:23,000
Because then you have to kind of go like, okay.

1078
00:49:23,000 --> 00:49:24,800
Well, which one actually is it?

1079
00:49:24,800 --> 00:49:26,700
Do we need a new child chunk or not?

1080
00:49:26,700 --> 00:49:27,300
Right.

1081
00:49:28,700 --> 00:49:32,400
So I guess the way we would actually do it again to make the code work

1082
00:49:32,400 --> 00:49:35,200
properly, is if Arena and

1083
00:49:37,000 --> 00:49:39,100
Tile chunk count, right?

1084
00:49:39,800 --> 00:49:40,600
Equals zero.

1085
00:49:40,600 --> 00:49:44,400
So if the slot was uninitialized that first slop, it's there.

1086
00:49:45,000 --> 00:49:49,400
Then what we do is we'd say, okay, if that's the case, then chunk

1087
00:49:49,400 --> 00:49:51,900
equals push on the on the arena.

1088
00:49:52,000 --> 00:49:55,400
And I'm just going to go ahead and say that tile chunk x equals 0,

1089
00:49:55,700 --> 00:49:56,200
right.

1090
00:49:56,200 --> 00:49:57,800
So we're going to push a new one on there.

1091
00:49:59,300 --> 00:50:02,500
And then we're going to go ahead and set its x equal to 0.

1092
00:50:03,800 --> 00:50:04,200
Yeah.

1093
00:50:08,000 --> 00:50:09,600
Sorry, that's not what I meant to do.

1094
00:50:09,600 --> 00:50:10,700
That's not what I meant to do.

1095
00:50:10,700 --> 00:50:11,800
I did it backwards.

1096
00:50:14,300 --> 00:50:14,600
Sorry.

1097
00:50:14,600 --> 00:50:16,200
This is a little complicated to talk through.

1098
00:50:16,700 --> 00:50:19,000
I'm trying to make it so that these cases are relatively simple.

1099
00:50:20,600 --> 00:50:21,800
This is what I meant to do.

1100
00:50:22,300 --> 00:50:24,800
So if we have an arena, so we're supposed to make Nutella chunks when

1101
00:50:24,800 --> 00:50:25,600
we don't find them.

1102
00:50:26,100 --> 00:50:27,400
If we don't.

1103
00:50:27,400 --> 00:50:30,200
If there isn't another one next in the hash, then we need to make one

1104
00:50:30,200 --> 00:50:32,400
that's next in the hash right now.

1105
00:50:32,400 --> 00:50:35,700
So this is the case where we actually do new chunk, right?

1106
00:50:35,800 --> 00:50:39,400
So I'll make a new chunk because we know that this chunk was occupied,

1107
00:50:39,700 --> 00:50:40,200
right?

1108
00:50:43,700 --> 00:50:44,200
So,

1109
00:50:49,800 --> 00:50:50,300
there we go.

1110
00:50:51,500 --> 00:50:56,800
If this chunk was occupied and it doesn't have another one in the

1111
00:50:56,800 --> 00:50:59,600
chain, but we needed to make a new one, right?

1112
00:51:00,200 --> 00:51:02,700
Then I will go ahead and make the new one.

1113
00:51:03,500 --> 00:51:06,500
And in fact, I can just do it directly this way.

1114
00:51:06,600 --> 00:51:10,600
I'll just say that the the next in hash for this guy equals a new

1115
00:51:10,600 --> 00:51:13,400
chunk and is tile chunk x equals 0.

1116
00:51:13,400 --> 00:51:19,600
So we've marked then now we have moved on to the next guy, right?

1117
00:51:19,600 --> 00:51:25,900
So we can say chunk equals chunk next in hash, like so, and then I can

1118
00:51:25,900 --> 00:51:26,900
do, okay?

1119
00:51:27,000 --> 00:51:28,800
If we're supposed to allocate.

1120
00:51:30,000 --> 00:51:33,600
And end, we know that.

1121
00:51:35,800 --> 00:51:39,700
That the chunk tile chunk x, equals zero.

1122
00:51:40,200 --> 00:51:45,400
And again, we now know that this this has to be valid now because

1123
00:51:45,600 --> 00:51:51,000
there is no way we could have gotten past this case and have an arena.

1124
00:51:52,200 --> 00:51:54,000
If we didn't actually make a new one.

1125
00:51:54,800 --> 00:51:58,500
So we look to see if it's equal to zero, which means either it was an

1126
00:51:58,500 --> 00:52:02,400
empty slot to begin with which meant that this case didn't execute.

1127
00:52:05,300 --> 00:52:06,000
Can't really do that.

1128
00:52:06,000 --> 00:52:06,200
There.

1129
00:52:06,200 --> 00:52:07,900
Can I I have to actually do it here.

1130
00:52:08,900 --> 00:52:09,400
Gosh.

1131
00:52:09,500 --> 00:52:09,600
All right.

1132
00:52:09,600 --> 00:52:12,600
This is, this is, this is way more complicated than doing it with just

1133
00:52:12,600 --> 00:52:13,900
the pointers gah.

1134
00:52:17,100 --> 00:52:18,300
Maybe just climb talking through it.

1135
00:52:18,300 --> 00:52:19,400
Maybe it's not complicated.

1136
00:52:21,700 --> 00:52:23,500
Okay, one more time.

1137
00:52:24,300 --> 00:52:26,400
We check for the match, if we find the match, we're done.

1138
00:52:26,900 --> 00:52:27,900
That's the easy case.

1139
00:52:28,100 --> 00:52:29,500
We just return chunk, and we're good.

1140
00:52:30,300 --> 00:52:35,000
If the chunks lot was filled, so it is actually valid, which were

1141
00:52:35,000 --> 00:52:38,200
using chunk X e0 to tell us, right?

1142
00:52:38,700 --> 00:52:43,500
If the chunks lot was filled and the next in hash.

1143
00:52:45,700 --> 00:52:46,700
Is not filled.

1144
00:52:47,100 --> 00:52:50,200
Then that's a, that's a problem because that basically means they've

1145
00:52:50,200 --> 00:52:53,500
given us an arena, so they want new chunks and we're about to run off

1146
00:52:53,500 --> 00:52:54,600
the end of the list.

1147
00:52:54,600 --> 00:52:58,500
So what we do is we stick a new one on to the end of the list, we set

1148
00:52:58,500 --> 00:53:03,900
it style chunk X to be 0 so that we know that it's empty and then we

1149
00:53:03,900 --> 00:53:04,700
move to it.

1150
00:53:05,200 --> 00:53:07,800
The next thing we do is we say okay if we were supposed to make some

1151
00:53:07,800 --> 00:53:11,600
and we're on an empty slot, which we either were already or we just

1152
00:53:11,600 --> 00:53:13,100
made an empty slot for ourselves.

1153
00:53:13,400 --> 00:53:14,400
Then it is time.

1154
00:53:14,600 --> 00:53:17,500
To allocate that chunk, right?

1155
00:53:17,600 --> 00:53:20,600
Like so push our tiles on there.

1156
00:53:21,000 --> 00:53:24,800
The tile count, we actually need where is the total count?

1157
00:53:24,900 --> 00:53:26,000
What is the toe cap?

1158
00:53:26,500 --> 00:53:27,300
It's just this.

1159
00:53:27,900 --> 00:53:28,300
We go.

1160
00:53:29,200 --> 00:53:32,100
So we don't actually need this case anymore at all.

1161
00:53:34,500 --> 00:53:36,800
This just passes the arena done.

1162
00:53:38,100 --> 00:53:38,500
So,

1163
00:53:40,400 --> 00:53:41,400
We get the tile count.

1164
00:53:41,400 --> 00:53:44,700
We allocate space for the tiles.

1165
00:53:44,700 --> 00:53:48,000
We initialize a tiles all to one for now and we'll put it to do there

1166
00:53:48,000 --> 00:53:53,800
that says, you know, something like do we want to always initialize?

1167
00:53:53,800 --> 00:53:54,600
I don't know.

1168
00:53:54,900 --> 00:53:57,400
See, and there we go.

1169
00:53:57,400 --> 00:53:58,700
So we actually initialize all them.

1170
00:53:58,700 --> 00:53:59,800
And now we've got our

1171
00:54:00,000 --> 00:54:00,600
And we're done.

1172
00:54:00,600 --> 00:54:01,700
So we break out.

1173
00:54:02,500 --> 00:54:06,500
If none of those things happened, then we just go ahead and go to the

1174
00:54:06,500 --> 00:54:11,600
next in hash as we normally would and we continue probing.

1175
00:54:12,300 --> 00:54:15,200
I think that's roughly correct, but that's pretty darn complicated.

1176
00:54:16,300 --> 00:54:21,000
So yeah, what what did I do?

1177
00:54:21,000 --> 00:54:22,200
Incorrectly here?

1178
00:54:22,200 --> 00:54:25,800
I forget, I haven't used we hardly ever have done much in the way of

1179
00:54:25,800 --> 00:54:27,400
actually having to use our Arena.

1180
00:54:27,500 --> 00:54:29,700
I don't remember where we actually

1181
00:54:30,600 --> 00:54:31,600
made that.

1182
00:54:31,900 --> 00:54:34,900
Where is our push push strut?

1183
00:54:37,300 --> 00:54:39,600
Okay, there's chunk.

1184
00:54:39,800 --> 00:54:45,300
So and now we don't need to do this anymore at all.

1185
00:54:48,600 --> 00:54:51,300
Essentially, all we have to do is initialize that tile map to 0.

1186
00:54:51,800 --> 00:54:55,900
So we do need to do is we need to do a clear where we basically say

1187
00:54:55,900 --> 00:54:57,000
all of the things.

1188
00:54:57,000 --> 00:55:01,800
All of the things in that tilemap struct in handmade tile, dot h at

1189
00:55:01,800 --> 00:55:04,800
the beginning have to have their exes cleared, if that makes sense.

1190
00:55:06,100 --> 00:55:12,200
So we could do something, you know, like have an initialization

1191
00:55:12,200 --> 00:55:16,000
procedure or something like that, which maybe would be a good idea

1192
00:55:16,000 --> 00:55:16,400
here.

1193
00:55:16,900 --> 00:55:21,700
So what I'll do is I will make a, you know, initialize tile, map

1194
00:55:21,700 --> 00:55:22,900
function, the base.

1195
00:55:22,900 --> 00:55:26,200
We just takes that town map and does that in it in here.

1196
00:55:27,100 --> 00:55:34,600
So, that is something like this void initialise tile map, that takes

1197
00:55:34,600 --> 00:55:40,300
the tile map to initialize, and the tile side in meters that you

1198
00:55:40,300 --> 00:55:42,600
wanted for your tile map.

1199
00:55:43,300 --> 00:55:45,600
And then it goes ahead and does this stuff.

1200
00:55:46,000 --> 00:55:46,500
It'll

1201
00:55:46,800 --> 00:55:50,400
Initialize the chunk shift to whatever it wants to be utilized to tell

1202
00:55:50,400 --> 00:55:57,200
side M, like so, and then it'll Loop through all the top trunks.

1203
00:55:57,800 --> 00:56:02,000
So now chunk index less than a red count, touch on cash.

1204
00:56:04,100 --> 00:56:10,000
So tell Chuck index and then it will do child chunk, hash table chunk

1205
00:56:10,000 --> 00:56:10,600
index.

1206
00:56:10,800 --> 00:56:12,800
And again, the reason I'm doing this the first time through it would

1207
00:56:12,800 --> 00:56:16,900
always work because we're guaranteed all zero memory, but that's not

1208
00:56:16,900 --> 00:56:17,700
true.

1209
00:56:18,000 --> 00:56:21,600
If we wanted to do these in place, which we're going to make world's

1210
00:56:21,600 --> 00:56:25,100
multiple times throughout a game because the player May restart, that

1211
00:56:25,100 --> 00:56:25,700
sort of stuff.

1212
00:56:25,900 --> 00:56:27,300
So I just want to make sure we clear it.

1213
00:56:28,300 --> 00:56:30,600
So top chunk x equals zero.

1214
00:56:30,600 --> 00:56:33,300
That's how we have been marking, empty slots.

1215
00:56:34,200 --> 00:56:37,900
And we also want to go ahead and I guess we don't really need to clear

1216
00:56:37,900 --> 00:56:38,800
the next pointer.

1217
00:56:39,200 --> 00:56:43,100
The zero is sufficient because the zero will tell it to fill right

1218
00:56:43,100 --> 00:56:43,300
away.

1219
00:56:43,300 --> 00:56:45,900
So what we really all, we really need to do is go make sure that the

1220
00:56:45,900 --> 00:56:48,900
next pointer is always equal to 0, so I'll go do that a second.

1221
00:56:49,400 --> 00:56:53,400
All right, so I want to make sure I always clear that out, which is

1222
00:56:53,400 --> 00:56:53,900
good.

1223
00:56:56,300 --> 00:56:59,800
That and then this is just going to do initial as town map with that.

1224
00:57:00,000 --> 00:57:01,100
Point for value.

1225
00:57:01,200 --> 00:57:05,200
And if we go ahead and clean that out and we'll go ahead and move this

1226
00:57:05,600 --> 00:57:06,500
into the C file.

1227
00:57:07,400 --> 00:57:10,500
So that'll be that that's good.

1228
00:57:10,900 --> 00:57:11,600
And then up here.

1229
00:57:11,600 --> 00:57:14,600
We just have to make sure that our initialization does something sane.

1230
00:57:15,400 --> 00:57:20,000
So we want to do here is say that whenever we go to initialize one of

1231
00:57:20,000 --> 00:57:24,800
these guys, so we want to actually make sure that we initialize all

1232
00:57:24,800 --> 00:57:26,300
the values in that struct.

1233
00:57:26,500 --> 00:57:29,800
So we want to do the tile chunk x equals cosine X.

1234
00:57:31,000 --> 00:57:31,700
Y z.

1235
00:57:31,700 --> 00:57:34,500
So we store what the coordinates were of this guy.

1236
00:57:35,300 --> 00:57:41,000
We want to make sure that the next in hash is set to nothing so that

1237
00:57:41,000 --> 00:57:44,500
we know there's nothing after it and then I think we're good.

1238
00:57:45,000 --> 00:57:47,100
So that seems reasonable.

1239
00:57:48,100 --> 00:57:49,100
Oops combat.

1240
00:57:49,500 --> 00:57:54,700
So and that actually, I think does do what we wanted.

1241
00:57:54,800 --> 00:57:57,400
I think borrowing bugs.

1242
00:57:57,600 --> 00:57:59,900
So I think we've managed to get

1243
00:58:00,000 --> 00:58:02,400
Cells into a position where we're storing things parsley.

1244
00:58:03,600 --> 00:58:06,800
So now what we have to do and this assert fired, which it should fire.

1245
00:58:06,800 --> 00:58:09,700
Because remember, we haven't actually tried to move the world, pass

1246
00:58:09,700 --> 00:58:11,300
the origin yet.

1247
00:58:11,300 --> 00:58:12,000
So it's zero.

1248
00:58:12,200 --> 00:58:15,400
So now, what we have to do to start using it is actually start

1249
00:58:15,400 --> 00:58:17,800
building the world from the center, right?

1250
00:58:18,400 --> 00:58:20,200
And so to build the world from the center.

1251
00:58:20,200 --> 00:58:24,400
What we need to do is start us ourselves off at the actual center of

1252
00:58:24,400 --> 00:58:25,000
the world.

1253
00:58:26,500 --> 00:58:27,700
So let's go ahead and do that.

1254
00:58:28,700 --> 00:58:34,400
We have our this waiting for full sparseness that starts us off at the

1255
00:58:34,400 --> 00:58:35,800
middle, right?

1256
00:58:36,900 --> 00:58:40,000
You went 32 Max divided by 2.

1257
00:58:40,100 --> 00:58:44,300
That'd be the middle of where we would be starting and we then need to

1258
00:58:44,300 --> 00:58:49,100
also use that for our camera because we want to start the camera off

1259
00:58:49,100 --> 00:58:50,400
at that location as well.

1260
00:58:50,800 --> 00:58:54,400
So instead of starting it off at zero zero, we should do that screen

1261
00:58:55,400 --> 00:58:55,800
Center.

1262
00:58:56,000 --> 00:58:58,700
So, whatever, I don't remember, what we call, those just then let's go

1263
00:58:58,700 --> 00:59:01,300
find out what were those called.

1264
00:59:02,200 --> 00:59:03,400
Let's see.

1265
00:59:04,400 --> 00:59:06,200
Screen, x 4 and Y course we're okay.

1266
00:59:06,200 --> 00:59:15,300
So we actually need to save those screen base X and Screen base y so,

1267
00:59:15,300 --> 00:59:19,000
we'll just go ahead and store those there.

1268
00:59:20,300 --> 00:59:22,500
And Screen base X.

1269
00:59:23,100 --> 00:59:23,700
There.

1270
00:59:24,800 --> 00:59:25,800
Screen-based.

1271
00:59:27,100 --> 00:59:27,600
Okay.

1272
00:59:28,400 --> 00:59:30,600
And so then these guys can just use that.

1273
00:59:32,000 --> 00:59:33,100
Green Bay sex.

1274
00:59:34,500 --> 00:59:35,500
Screen baseball.

1275
00:59:36,500 --> 00:59:39,600
And now we've got the beginnings of our hash system working.

1276
00:59:41,100 --> 00:59:43,000
Aha and Z also have to be the same.

1277
00:59:43,800 --> 00:59:49,000
So, let's see here, what do we have for Z on our ABS tile?

1278
00:59:49,000 --> 00:59:51,400
Z should also be the same.

1279
00:59:52,100 --> 00:59:54,200
So that will be screen-based Z

1280
00:59:55,900 --> 00:59:59,800
so, and in here,

1281
01:00:00,300 --> 01:00:08,100
We need to now do screen Z or sorry, AB style Z.

1282
01:00:09,200 --> 01:00:10,100
Know why we're going.

1283
01:00:10,100 --> 01:00:12,100
Well AB style Z.

1284
01:00:12,900 --> 01:00:15,400
So if AB style Z equal screen-based Z.

1285
01:00:16,700 --> 01:00:22,200
Let's see here, AB style, Z AB style, Z apps Halsey

1286
01:00:23,400 --> 01:00:25,100
Equals screen basis Z.

1287
01:00:25,600 --> 01:00:27,500
Then it equals screen-based, z, plus 1.

1288
01:00:27,500 --> 01:00:29,000
Otherwise, it equals screen-based see.

1289
01:00:30,100 --> 01:00:30,500
Right.

1290
01:00:31,500 --> 01:00:33,600
Just gotta make that work out.

1291
01:00:34,900 --> 01:00:35,400
Here we go.

1292
01:00:36,500 --> 01:00:41,200
And so now, unfortunately, we have to actually figure out if we have

1293
01:00:41,200 --> 01:00:44,600
any bugs here, which we very melt very well may.

1294
01:00:44,600 --> 01:00:49,800
So, first of all, this should be showing our entities, and it's not.

1295
01:00:49,900 --> 01:00:51,600
So, the first bug we have to start to work with.

1296
01:00:51,600 --> 01:00:53,600
Now is figuring out

1297
01:00:56,200 --> 01:00:56,500
Why?

1298
01:00:56,500 --> 01:00:58,500
We're not why we're set camera.

1299
01:00:58,500 --> 01:01:00,000
Call is not working.

1300
01:01:00,000 --> 01:01:01,800
And I think we're just about out of time.

1301
01:01:02,400 --> 01:01:05,800
So I'll briefly step through it just going interested, but we'll have

1302
01:01:05,800 --> 01:01:08,900
to pick this up on on Monday.

1303
01:01:09,300 --> 01:01:13,400
All right, so when we come through our set camera call, let's see what

1304
01:01:13,400 --> 01:01:16,000
happens here, when we're actually doing this stuff.

1305
01:01:17,900 --> 01:01:21,000
We are stepping through our entities.

1306
01:01:22,800 --> 01:01:25,700
These mins and Max's now, correct.

1307
01:01:25,900 --> 01:01:28,500
Right, so that's all good.

1308
01:01:30,300 --> 01:01:33,600
And I guess.

1309
01:01:36,500 --> 01:01:38,200
New camera P AB style C.

1310
01:01:38,200 --> 01:01:39,700
So there's our first problem.

1311
01:01:40,500 --> 01:01:44,600
Our camera needs to be at screen-based Z because our camera was

1312
01:01:44,600 --> 01:01:46,900
previously all the way down to the bottom of the world, which is no

1313
01:01:46,900 --> 01:01:47,400
good.

1314
01:01:47,900 --> 01:01:48,800
So that's that.

1315
01:01:49,200 --> 01:01:50,000
Let's try that again.

1316
01:01:53,300 --> 01:01:53,600
Okay.

1317
01:01:53,600 --> 01:01:55,100
So now we have one.

1318
01:01:58,800 --> 01:02:01,500
I don't even have an idea of how we had that bug.

1319
01:02:01,500 --> 01:02:03,700
That's going to be interesting to see what's happening there.

1320
01:02:03,700 --> 01:02:03,900
I have.

1321
01:02:03,900 --> 01:02:04,600
Absolutely no idea.

1322
01:02:04,600 --> 01:02:05,400
What's happening there.

1323
01:02:07,000 --> 01:02:07,900
That's pretty funny.

1324
01:02:09,200 --> 01:02:10,600
You know, I guess I don't know.

1325
01:02:11,900 --> 01:02:13,600
What, how are we doing our screen?

1326
01:02:15,600 --> 01:02:16,600
Our screen Basie.

1327
01:02:17,600 --> 01:02:19,900
Screen face Z.

1328
01:02:21,700 --> 01:02:24,300
What are we actually doing here to compute these?

1329
01:02:25,200 --> 01:02:25,900
I don't know.

1330
01:02:27,500 --> 01:02:27,800
Three.

1331
01:02:27,800 --> 01:02:29,600
Next times tiles per width.

1332
01:02:30,400 --> 01:02:32,200
Oh, duh.

1333
01:02:32,800 --> 01:02:34,500
So this is not quite correct.

1334
01:02:34,600 --> 01:02:39,400
So, these are actually divided by a lot more than two because they're

1335
01:02:39,400 --> 01:02:41,600
actually divided by our chunk size.

1336
01:02:41,900 --> 01:02:42,400
Right?

1337
01:02:42,500 --> 01:02:46,900
So these are actually there's actually the notion of the max number of

1338
01:02:46,900 --> 01:02:48,700
chunks, right?

1339
01:02:49,100 --> 01:02:51,400
So this is actually divided by 16 here.

1340
01:02:51,500 --> 01:02:54,400
So we're going to want a better way of encapsulating that, right?

1341
01:02:54,500 --> 01:02:56,500
Because the screen base yet week that would

1342
01:02:56,600 --> 01:02:59,800
Ali overflow, the tile amount because we want however many tiles,

1343
01:03:00,000 --> 01:03:01,700
Harper tiles to say, where the center is.

1344
01:03:01,900 --> 01:03:03,700
I think we should have a better way of doing that.

1345
01:03:04,000 --> 01:03:04,800
Let's take a look.

1346
01:03:08,900 --> 01:03:10,900
Yeah, so that's a good point.

1347
01:03:10,900 --> 01:03:12,600
We should have a better way of doing that.

1348
01:03:13,100 --> 01:03:17,700
But okay, so when we actually create dudes here and we have our app

1349
01:03:17,700 --> 01:03:21,500
style, except I'll why we're making that by figuring out how many

1350
01:03:21,500 --> 01:03:23,900
tiles over we go?

1351
01:03:24,000 --> 01:03:27,900
And so the same should be true of our tiles e, but that will be now

1352
01:03:28,000 --> 01:03:29,000
and so that's fine.

1353
01:03:29,700 --> 01:03:36,300
That seems, although I guess for, for Z, we don't actually have chunks

1354
01:03:36,300 --> 01:03:36,900
in that form.

1355
01:03:36,900 --> 01:03:38,600
So Z actually does work this way.

1356
01:03:39,000 --> 01:03:41,400
Z is actually still just divide by 2.

1357
01:03:42,500 --> 01:03:43,900
But okay.

1358
01:03:43,900 --> 01:03:46,100
So now let's see where we're at.

1359
01:03:46,500 --> 01:03:49,700
Let's go ahead and step into the thing that creates them again.

1360
01:03:49,700 --> 01:03:53,800
I'll try to stop in a second and go back to questions by just, it's

1361
01:03:53,800 --> 01:03:57,600
frustrating to do something and I want to go see what our bugs are in

1362
01:03:57,600 --> 01:03:57,900
it.

1363
01:03:57,900 --> 01:04:01,300
I, you know, it's that obsessive, programming kind of thing where it's

1364
01:04:01,300 --> 01:04:04,500
hard to just stop when you're just about to finish something.

1365
01:04:05,100 --> 01:04:07,000
It's kind of difficult sometimes.

1366
01:04:09,800 --> 01:04:11,200
So, let's see.

1367
01:04:11,200 --> 01:04:12,000
What happens here.

1368
01:04:12,700 --> 01:04:13,400
AB style.

1369
01:04:13,400 --> 01:04:17,400
X, AB style, y, AB, style Z.

1370
01:04:18,600 --> 01:04:19,900
So why is ABS tile?

1371
01:04:19,900 --> 01:04:22,400
Why so much different than ABS tiles e?

1372
01:04:22,900 --> 01:04:24,500
That doesn't make a whole lot of sense to me.

1373
01:04:24,900 --> 01:04:25,700
What happened there?

1374
01:04:30,800 --> 01:04:32,000
That's a bit odd, right?

1375
01:04:33,000 --> 01:04:33,800
You would agree.

1376
01:04:38,100 --> 01:04:38,700
Oh.

1377
01:04:42,500 --> 01:04:45,900
It's because they're x 0, right?

1378
01:04:46,200 --> 01:04:49,300
So we're actually not doing it by chunks, even though

1379
01:04:50,500 --> 01:04:52,400
We're not doing it by chunks at all.

1380
01:04:53,000 --> 01:04:55,400
These screens are not in chunks.

1381
01:04:55,900 --> 01:04:59,000
These screens are in in our canonical.

1382
01:04:59,800 --> 01:05:00,900
Are in this.

1383
01:05:02,000 --> 01:05:03,900
That's so we actually want.

1384
01:05:05,200 --> 01:05:05,900
That.

1385
01:05:06,700 --> 01:05:07,300
Yeah.

1386
01:05:08,200 --> 01:05:08,900
All right.

1387
01:05:09,900 --> 01:05:10,900
That was weird.

1388
01:05:13,200 --> 01:05:14,000
Now, let's see.

1389
01:05:15,500 --> 01:05:17,700
Yeah, so those should now be close to Center and they are.

1390
01:05:18,000 --> 01:05:20,500
That's what I would have expected to see last time.

1391
01:05:20,800 --> 01:05:21,400
So we come in.

1392
01:05:21,400 --> 01:05:23,700
Here we go.

1393
01:05:23,700 --> 01:05:24,600
To get our tile Chunk.

1394
01:05:24,600 --> 01:05:27,200
We should see some random hash value here.

1395
01:05:27,300 --> 01:05:31,400
And the hash lot is some something that maps in there, which it does.

1396
01:05:31,800 --> 01:05:33,100
We go ahead and grab it.

1397
01:05:34,100 --> 01:05:37,200
It should not be filled and it isn't filled.

1398
01:05:37,200 --> 01:05:39,300
So we go ahead and grab the tile count.

1399
01:05:39,500 --> 01:05:40,400
That's supposed to be there.

1400
01:05:40,400 --> 01:05:41,400
We fill out.

1401
01:05:41,400 --> 01:05:44,900
Where is we push into our array?

1402
01:05:45,300 --> 01:05:49,400
We initialize everything, we set the chunk index, we break out.

1403
01:05:49,400 --> 01:05:50,800
So now we've got the valid chunk.

1404
01:05:50,800 --> 01:05:56,000
That chunk is the Chunk we asked for which is good, and then we set

1405
01:05:56,000 --> 01:05:58,200
the tile value in that chunk.

1406
01:05:58,200 --> 01:05:59,700
So that works exactly like

1407
01:06:00,000 --> 01:06:04,100
I would have thought when we go ahead and add our Walt, that works

1408
01:06:04,100 --> 01:06:04,800
just fine.

1409
01:06:06,100 --> 01:06:08,000
So that seems correct as well.

1410
01:06:08,800 --> 01:06:12,300
But for some reason we don't actually ever see any there and then when

1411
01:06:12,300 --> 01:06:16,600
we come in here we are finding that our tile map.

1412
01:06:18,600 --> 01:06:20,200
Relative positions are wrong.

1413
01:06:20,800 --> 01:06:22,600
So, let's take a look at what's going on there.

1414
01:06:22,900 --> 01:06:28,100
Is that just, because we're wrapping around, in terms of, in 32s.

1415
01:06:28,600 --> 01:06:29,900
I guess would be the problem there.

1416
01:06:30,500 --> 01:06:32,900
That's a little annoying, right?

1417
01:06:32,900 --> 01:06:37,600
Because you can see that that's, we actually, we are offset, has to be

1418
01:06:37,600 --> 01:06:38,800
signed there.

1419
01:06:39,200 --> 01:06:41,700
But the thing that we're doing is a little too much, so we could fix

1420
01:06:41,700 --> 01:06:44,200
that by again, reducing our range, a little, but I'm not sure if I

1421
01:06:44,200 --> 01:06:48,300
love that idea, but that would be fixed if we did this.

1422
01:06:48,900 --> 01:06:49,200
Right?

1423
01:06:49,200 --> 01:06:52,600
Because that just means that our range is a little too wide.

1424
01:06:52,800 --> 01:06:55,500
I think why is that?

1425
01:06:57,500 --> 01:07:00,400
Let me, let me see what happens if I just reduce this relatively

1426
01:07:00,400 --> 01:07:02,100
drastically, right?

1427
01:07:02,800 --> 01:07:05,100
So I do like something like this, right?

1428
01:07:05,200 --> 01:07:08,200
I just want to see what happens if we're just having bugs at the

1429
01:07:08,200 --> 01:07:10,400
Overflow, or not.

1430
01:07:11,200 --> 01:07:13,600
Yeah, so it looks like it looks like there's bugs in terms of the

1431
01:07:13,600 --> 01:07:14,400
Overflow there.

1432
01:07:14,600 --> 01:07:15,800
So let's take a look at it.

1433
01:07:15,800 --> 01:07:18,600
When we have it at a slightly more reasonable thing.

1434
01:07:22,000 --> 01:07:24,200
Yeah, let's let's see if we do it this way.

1435
01:07:24,400 --> 01:07:27,400
We'll see what it looks like when we debug it this way.

1436
01:07:27,900 --> 01:07:33,700
So inside here, I step in and I'm adding these guys, right and I add

1437
01:07:33,700 --> 01:07:36,100
their entities and so on, and off we go.

1438
01:07:36,600 --> 01:07:39,800
So now I looked like that was working properly.

1439
01:07:39,800 --> 01:07:44,600
In fact, when I go do this a second time or third time, we should see

1440
01:07:44,600 --> 01:07:47,900
that it finds the tachanka again, right?

1441
01:07:47,900 --> 01:07:49,400
Which yeah, which it does.

1442
01:07:49,700 --> 01:07:50,800
So storing it in the towel.

1443
01:07:51,300 --> 01:07:53,100
Seems fine at the moment.

1444
01:07:53,600 --> 01:07:57,700
So I think it just it's in our entity sort of situation that things

1445
01:07:57,700 --> 01:07:59,200
are going wonky.

1446
01:07:59,800 --> 01:08:03,700
So, let's see what happens when we map something from low to high,

1447
01:08:03,900 --> 01:08:05,400
since that seems to be our problem.

1448
01:08:05,400 --> 01:08:07,200
Now, let's see what happens there.

1449
01:08:09,200 --> 01:08:10,800
So, we want to do a make high entity.

1450
01:08:10,800 --> 01:08:14,700
So, the first problem was that none of the things past our inclusion.

1451
01:08:14,700 --> 01:08:15,800
Check, right?

1452
01:08:15,800 --> 01:08:19,100
Because we should have made High entities just right off the bat for

1453
01:08:19,100 --> 01:08:20,800
all of the walls, and that didn't happen.

1454
01:08:20,899 --> 01:08:21,200
Open.

1455
01:08:21,200 --> 01:08:22,800
So, let's see why that wasn't happening.

1456
01:08:24,100 --> 01:08:26,600
I don't know if that's because our cameras in the wrong place or what.

1457
01:08:26,600 --> 01:08:29,100
Let's take a look actually what's going on with our camera.

1458
01:08:29,600 --> 01:08:33,200
So this is our screen base X, so we're probably still setting the

1459
01:08:33,200 --> 01:08:34,399
camera wrong, right?

1460
01:08:35,200 --> 01:08:35,399
Yes.

1461
01:08:35,399 --> 01:08:36,700
That's our screen base X.

1462
01:08:36,800 --> 01:08:41,800
So that needs to be equal to tiles tiles per width and that needs to

1463
01:08:41,800 --> 01:08:42,300
be tiles.

1464
01:08:42,300 --> 01:08:42,500
Right?

1465
01:08:42,500 --> 01:08:45,399
So we were just basically had the camera in the wrong place, right?

1466
01:08:47,399 --> 01:08:47,899
There we go.

1467
01:08:50,600 --> 01:08:51,399
So, there we go.

1468
01:08:52,000 --> 01:08:57,700
And and so then when I create my dude, I need to actually create the

1469
01:08:57,700 --> 01:08:59,800
dude, wherever the camera is as

1470
01:09:00,800 --> 01:09:03,399
So let's go ahead and see if what add player does.

1471
01:09:03,600 --> 01:09:04,399
So add player.

1472
01:09:04,399 --> 01:09:05,899
We need to fix that as well.

1473
01:09:06,100 --> 01:09:08,500
So we want to add a player for now.

1474
01:09:08,500 --> 01:09:10,700
Since we don't have any other real idea about how we're going to add a

1475
01:09:10,700 --> 01:09:11,200
player.

1476
01:09:11,500 --> 01:09:13,500
We want to add a player wherever the camera is.

1477
01:09:13,700 --> 01:09:14,800
So we'll say that entity.

1478
01:09:14,800 --> 01:09:20,200
Lo P equals, whatever the camera p is, we'll just flat-out.

1479
01:09:20,200 --> 01:09:22,399
Put it where the camera is like, so,

1480
01:09:26,100 --> 01:09:33,200
Alright, so now we are properly sparse and our query seems to be

1481
01:09:33,200 --> 01:09:35,399
working at least to some degree.

1482
01:09:35,600 --> 01:09:36,899
So we're in better shape here.

1483
01:09:37,300 --> 01:09:40,200
We're not out of the woods yet, but we're definitely in better shape,

1484
01:09:40,399 --> 01:09:40,899
right?

1485
01:09:41,200 --> 01:09:41,600
Okay.

1486
01:09:42,200 --> 01:09:42,899
All right.

1487
01:09:42,899 --> 01:09:45,100
So that's an okay stopping point to leave it at again.

1488
01:09:45,100 --> 01:09:48,300
We still have plenty of work to do but now we're a little we're about

1489
01:09:48,300 --> 01:09:50,899
10 minutes over but we still have time for about 20 minutes of Q&A.

1490
01:09:51,800 --> 01:09:54,100
So let's go ahead and go to the Q&A.

1491
01:09:54,100 --> 01:09:55,400
Please prefix, your questions.

1492
01:09:55,600 --> 01:10:00,100
With Q: so I can see them and try to keep them to stuff that we did on

1493
01:10:00,100 --> 01:10:02,800
today's stream or on previous dreams while he ate my cookies.

1494
01:10:15,300 --> 01:10:18,500
How do I do it q a like that?

1495
01:10:20,300 --> 01:10:21,300
I don't know how to do it.

1496
01:10:26,600 --> 01:10:29,000
I think it's exclamation point q a

1497
01:10:35,000 --> 01:10:37,900
Why not center of the world at 0, 0, 0, and you signed into the

1498
01:10:37,900 --> 01:10:38,400
tablet?

1499
01:10:38,400 --> 01:10:39,900
Yeah, I would like to do that.

1500
01:10:45,700 --> 01:10:46,500
Unfortunately.

1501
01:10:50,900 --> 01:10:52,100
I think we met.

1502
01:10:56,500 --> 01:10:59,100
I can't remember if we baked in some stuff here.

1503
01:10:59,100 --> 01:11:00,100
That doesn't do that.

1504
01:11:00,500 --> 01:11:03,300
I didn't want to do that right off the bat.

1505
01:11:03,500 --> 01:11:07,000
I want to do that as a separate as a separate change, but I would like

1506
01:11:07,000 --> 01:11:09,400
to do that as well, because the reason that that would be nicer.

1507
01:11:10,200 --> 01:11:12,200
They just are the values are smaller so we can see them.

1508
01:11:14,800 --> 01:11:15,400
But yeah.

1509
01:11:20,400 --> 01:11:24,200
So what we're doing here is we take the tile side in meters and then

1510
01:11:24,200 --> 01:11:26,700
we divide by the relative tile.

1511
01:11:26,700 --> 01:11:28,500
So that just gives we should be.

1512
01:11:28,500 --> 01:11:30,200
That should work, right?

1513
01:11:33,600 --> 01:11:35,300
Because this just gives us an offset.

1514
01:11:35,300 --> 01:11:39,000
And so we're moving, whatever we move the offset by could be signed or

1515
01:11:39,000 --> 01:11:41,200
unsigned and it shouldn't matter, right?

1516
01:11:42,000 --> 01:11:43,600
So it seems like

1517
01:11:45,000 --> 01:11:46,900
It seems like that would work.

1518
01:11:53,000 --> 01:11:54,300
It seems like that would work.

1519
01:11:57,800 --> 01:11:58,800
You want to try it?

1520
01:11:58,900 --> 01:11:59,800
Because I would like to.

1521
01:12:00,000 --> 01:12:03,100
As well, just to the numbers are smaller and easier to spot identify.

1522
01:12:04,500 --> 01:12:05,500
So, let's try it.

1523
01:12:05,600 --> 01:12:07,900
I mean, you know, if it doesn't work, it doesn't work.

1524
01:12:08,100 --> 01:12:08,700
Right.

1525
01:12:09,600 --> 01:12:13,500
So if we, if we did that we would just change all of these guys to in

1526
01:12:13,500 --> 01:12:14,900
32s, right?

1527
01:12:19,000 --> 01:12:19,800
Something like this.

1528
01:12:24,400 --> 01:12:29,400
And then we have to kind of clean up everywhere that it was doing

1529
01:12:29,400 --> 01:12:30,000
something.

1530
01:12:30,300 --> 01:12:31,800
That was at a chunk extell chunk.

1531
01:12:31,800 --> 01:12:33,300
Why sort of a situation.

1532
01:12:34,800 --> 01:12:35,900
So the chunk dim.

1533
01:12:37,500 --> 01:12:40,800
Tilak, so let's just, let's just do all these within 32s and that's

1534
01:12:40,800 --> 01:12:41,200
fine.

1535
01:12:46,900 --> 01:12:51,900
Andre canonicalize cord would work like that.

1536
01:12:55,700 --> 01:12:59,200
And ab style X greater than equal to.

1537
01:12:59,200 --> 01:13:01,400
So these are all done this way.

1538
01:13:01,900 --> 01:13:09,100
So so in theory, let's see if that causes any immediate problems.

1539
01:13:09,500 --> 01:13:10,400
No, it doesn't.

1540
01:13:11,100 --> 01:13:15,600
So in theory that would allow us to go ahead and do that.

1541
01:13:15,600 --> 01:13:18,600
And now so what we want to do to, I guess in our handmade tile here,

1542
01:13:19,400 --> 01:13:21,000
our tile chunk safe.

1543
01:13:21,000 --> 01:13:21,700
Margin.

1544
01:13:22,700 --> 01:13:24,500
We basically want to stay.

1545
01:13:25,400 --> 01:13:29,300
Away from the edge in any way that might cause us to rap.

1546
01:13:37,200 --> 01:13:37,600
So,

1547
01:13:43,000 --> 01:13:43,400
Oops.

1548
01:13:44,800 --> 01:13:46,100
What would really be doing here?

1549
01:13:49,200 --> 01:13:52,700
Is something like this, where this is like?

1550
01:13:54,400 --> 01:13:56,700
You know, it 32 Max.

1551
01:13:58,300 --> 01:13:59,300
/.

1552
01:14:01,100 --> 01:14:04,000
Some kind of safe number, right?

1553
01:14:04,300 --> 01:14:06,300
That's the chunk size that we're using currently.

1554
01:14:08,700 --> 01:14:10,400
So, that would be one chunk away.

1555
01:14:11,100 --> 01:14:14,400
And so what we maybe want to do is go a few more chunks than that

1556
01:14:14,400 --> 01:14:14,700
away.

1557
01:14:14,700 --> 01:14:15,600
Something like this.

1558
01:14:16,500 --> 01:14:17,100
I don't know.

1559
01:14:19,300 --> 01:14:23,400
And just say that, okay, we'll keep it to within their, I don't know

1560
01:14:23,400 --> 01:14:25,900
what the safe margin is, will have to think about that.

1561
01:14:27,500 --> 01:14:29,900
Think about what the real safe margin is.

1562
01:14:33,400 --> 01:14:39,100
Okay, so in theory that's fine still and that way we can now go back

1563
01:14:39,100 --> 01:14:43,100
to here and set our screen X screen y, right?

1564
01:14:43,200 --> 01:14:50,500
Screen-based ice cream base y to be 0 0 and 0 again and then

1565
01:14:50,500 --> 01:14:53,700
everything should still work out just fine, hopefully.

1566
01:14:55,300 --> 01:14:59,800
Yeah, so yeah, so no, I did want to do that.

1567
01:15:00,000 --> 01:15:00,900
That's a good idea.

1568
01:15:00,900 --> 01:15:03,100
Just really for legibility.

1569
01:15:03,300 --> 01:15:03,900
Right?

1570
01:15:05,200 --> 01:15:07,300
So I just wasn't sure if we could do it.

1571
01:15:07,300 --> 01:15:08,400
I didn't want to do it first.

1572
01:15:08,400 --> 01:15:10,900
I want to get it working first with the UN just in case there's any

1573
01:15:10,900 --> 01:15:12,500
baked in there, but looks like we're okay.

1574
01:15:13,900 --> 01:15:18,300
And so now I again, the reason I want to do that with just because now

1575
01:15:18,300 --> 01:15:22,400
if we look at those numbers, they're just easier to quickly identify

1576
01:15:22,400 --> 01:15:23,100
what they are.

1577
01:15:24,400 --> 01:15:27,400
You know, like if I look at this guy, when I first start up and we're

1578
01:15:27,400 --> 01:15:29,900
creating the world before they were these huge numbers.

1579
01:15:30,000 --> 01:15:32,500
As and now they're like 000 which is a much easier thing.

1580
01:15:32,500 --> 01:15:36,300
To internalize second time through there like, you know, 10 is right,

1581
01:15:36,300 --> 01:15:38,100
and that's just easier to read really.

1582
01:15:39,000 --> 01:15:40,600
And so that'll be a little handier, I think.

1583
01:15:43,200 --> 01:15:47,200
Is the Hat hashmap essentially, just a creatively shaped tile chunk.

1584
01:15:47,500 --> 01:15:48,300
If that's the case.

1585
01:15:48,300 --> 01:15:53,200
Could you preempt the hash function by contributing more bits from the

1586
01:15:53,200 --> 01:15:56,400
Z coordinate as opposed to the X + Y 4?

1587
01:15:56,400 --> 01:15:59,700
At our emap, for example, am I thinking about this, right?

1588
01:16:04,000 --> 01:16:07,800
I don't think you are necessarily.

1589
01:16:10,100 --> 01:16:14,400
But it's hard to say, let me give you an example and we'll see if this

1590
01:16:14,400 --> 01:16:16,600
clarifies, right?

1591
01:16:17,500 --> 01:16:21,300
So let's say, I wanted to store all the words.

1592
01:16:23,900 --> 01:16:24,800
In the dictionary.

1593
01:16:28,900 --> 01:16:29,400
Right.

1594
01:16:30,500 --> 01:16:35,600
Such that I could quickly given a word, tell whether that word was in

1595
01:16:35,600 --> 01:16:36,900
the dictionary or not.

1596
01:16:37,700 --> 01:16:41,000
Okay, so they could be arbitrary length.

1597
01:16:41,200 --> 01:16:45,800
Like you've got short words like it and you've got long words like

1598
01:16:45,800 --> 01:16:47,800
antidisestablishmentarianism.

1599
01:16:54,200 --> 01:16:54,700
Right.

1600
01:16:57,200 --> 01:17:00,400
And what I want to do is I want to quickly be able to say, are these

1601
01:17:00,400 --> 01:17:01,700
in the dictionary or are they not?

1602
01:17:02,900 --> 01:17:05,800
And what you can see from this is that like a hash table is

1603
01:17:05,800 --> 01:17:08,600
essentially just a function, right?

1604
01:17:09,600 --> 01:17:14,400
That takes B in some number of bits in, and that could be an arbitrary

1605
01:17:14,400 --> 01:17:18,300
number of bits and spits out a fixed number of bits.

1606
01:17:18,600 --> 01:17:19,200
Right?

1607
01:17:19,400 --> 01:17:25,000
So, it takes arbitrary, arbitrary, bits in and speak Stout Fitbit

1608
01:17:25,000 --> 01:17:25,800
fixed B.

1609
01:17:27,200 --> 01:17:31,100
Those fixed B can then be used to look up into a table of a specific

1610
01:17:31,100 --> 01:17:33,100
of a known length proportional to the bits.

1611
01:17:33,100 --> 01:17:33,600
Right?

1612
01:17:33,700 --> 01:17:38,700
So if I say that it's going to spit out, you know, a number between 0

1613
01:17:38,700 --> 01:17:44,700
and 27, then I've got a table whose n equals 27 and there's 27 slots

1614
01:17:44,700 --> 01:17:45,200
in it.

1615
01:17:45,300 --> 01:17:48,500
I look up in there and I do my chaining or whatever else I need to do

1616
01:17:48,500 --> 01:17:49,700
to store multiple things.

1617
01:17:49,800 --> 01:17:50,300
Right?

1618
01:17:50,900 --> 01:17:52,900
And that allows me to look up any word.

1619
01:17:53,600 --> 01:17:56,600
So it's not really shaped per se.

1620
01:17:56,700 --> 01:17:59,800
say, it's not confined to a shape or

1621
01:18:00,000 --> 01:18:06,900
Like that, it's a way of mapping anything that comes in into a fixed

1622
01:18:06,900 --> 01:18:11,900
number of slots, a raid linearly to do to accelerate the testing.

1623
01:18:12,300 --> 01:18:14,900
Because you could imagine just having an array and testing each

1624
01:18:14,900 --> 01:18:16,400
individual one, right?

1625
01:18:16,400 --> 01:18:17,900
We could have written the tile chunk thing.

1626
01:18:17,900 --> 01:18:20,600
So we just had an array of the tile jumps up there were and we just

1627
01:18:20,600 --> 01:18:21,400
Loop through them all.

1628
01:18:21,400 --> 01:18:23,600
Testing them one after the other, right?

1629
01:18:24,500 --> 01:18:25,700
But that be really slow.

1630
01:18:26,100 --> 01:18:27,100
Wom Pro.

1631
01:18:27,100 --> 01:18:27,500
Look up.

1632
01:18:27,500 --> 01:18:29,300
We have to look through all end tile Maps.

1633
01:18:29,300 --> 01:18:31,800
Every time we want to find one of them and that's real bad.

1634
01:18:32,200 --> 01:18:36,300
So the hashmap turns it much closer to 0 1, which is to say, we just

1635
01:18:36,300 --> 01:18:38,000
look up one slot.

1636
01:18:38,000 --> 01:18:41,000
We just go directly there and say is it there?

1637
01:18:41,000 --> 01:18:42,100
And most of the time we're right.

1638
01:18:42,100 --> 01:18:44,800
Sometimes we have to chase a chain one or two steps or something, but

1639
01:18:44,800 --> 01:18:48,400
mostly it's just a very fixed number of operations and it works for

1640
01:18:48,400 --> 01:18:49,000
anything.

1641
01:18:49,400 --> 01:18:53,100
We could just sum up all the characters in a string X, some numbers

1642
01:18:53,100 --> 01:18:54,000
going to kind of produce.

1643
01:18:54,400 --> 01:18:57,200
Some fixed set of bits that we can use look up on the table and this

1644
01:18:57,200 --> 01:18:58,000
will work for that.

1645
01:18:58,000 --> 01:19:00,000
Just like I work for our child chunk, just for it work for anything

1646
01:19:00,000 --> 01:19:01,800
else because that make more sense.

1647
01:19:11,600 --> 01:19:16,900
What do you think about and do you ever do free optimizations in early

1648
01:19:16,900 --> 01:19:18,300
or late stage of development?

1649
01:19:18,300 --> 01:19:22,700
Such as is in rectangle, equals true if greater than or equal to left

1650
01:19:22,700 --> 01:19:26,000
and less than right, and greater than equal to the top and less than

1651
01:19:26,000 --> 01:19:27,400
bottom in.

1652
01:19:27,700 --> 01:19:30,500
And instead trying to fail as early as possible.

1653
01:19:32,000 --> 01:19:35,200
Best case scenario, you only did one comparison rather than four.

1654
01:19:35,600 --> 01:19:39,100
So two things about that that I would comment on.

1655
01:19:42,700 --> 01:19:44,000
And we'll talk about both of them.

1656
01:19:44,700 --> 01:19:48,300
The first one is that is exactly how this is already written.

1657
01:19:49,400 --> 01:19:58,700
So, in see, the rule for treating, binary logical, operators and an

1658
01:19:58,700 --> 01:20:02,200
orange, so on is that you only evaluate as many of them as you need to

1659
01:20:02,200 --> 01:20:03,300
to produce the result.

1660
01:20:04,000 --> 01:20:09,300
So when you have an and operator, it'll compute this first.

1661
01:20:09,600 --> 01:20:14,200
And if it's value, is already 0, it knows that none of the rest of the

1662
01:20:14,200 --> 01:20:15,400
things need to be computed.

1663
01:20:17,400 --> 01:20:19,100
So the compiler is already free.

1664
01:20:19,100 --> 01:20:20,800
To generate exactly what you just said.

1665
01:20:23,900 --> 01:20:26,700
There'd be no difference to the compiler between running it this way

1666
01:20:27,700 --> 01:20:30,400
and writing it as a cascading series of ifs that return.

1667
01:20:31,300 --> 01:20:36,300
So the first answer to your question is those optimization look like

1668
01:20:36,300 --> 01:20:40,100
the kind you're talking about are already in the code in the places

1669
01:20:40,100 --> 01:20:43,100
where you see that, that's just how see works.

1670
01:20:45,300 --> 01:20:47,800
But the second part of your question, if we extend it out to something

1671
01:20:47,800 --> 01:20:49,200
that wasn't that way.

1672
01:20:49,600 --> 01:20:51,700
So, maybe like, you look at something like this, that's actually doing

1673
01:20:51,700 --> 01:20:54,500
a bunch of logic in multiple steps.

1674
01:20:54,500 --> 01:20:57,000
And do we think about, you know, how we're going to arrange those?

1675
01:20:57,300 --> 01:20:59,400
The answer is, no, I never think about that.

1676
01:21:00,800 --> 01:21:04,500
Before I get to a point where I'm actually profiling something,

1677
01:21:04,800 --> 01:21:09,500
because one of the things that you have to understand is performance

1678
01:21:09,600 --> 01:21:10,300
surrounding.

1679
01:21:10,300 --> 01:21:14,600
If statements is incredibly, incredibly complicated.

1680
01:21:14,600 --> 01:21:17,000
It is not sufficient to think about it.

1681
01:21:17,000 --> 01:21:19,900
The way that you are suggesting where you're just like, oh well early

1682
01:21:19,900 --> 01:21:20,500
out.

1683
01:21:21,800 --> 01:21:26,400
Some pieces of code are made Faster by always doing all the operations

1684
01:21:26,600 --> 01:21:27,800
instead of having any F's.

1685
01:21:28,600 --> 01:21:31,100
Some code is made Faster by doing the ifs.

1686
01:21:31,400 --> 01:21:35,300
Some code is made Faster by picking exactly which ifs you do when

1687
01:21:35,300 --> 01:21:41,300
because of Branch prediction and so trying to before you have time

1688
01:21:41,300 --> 01:21:47,000
things optimize, if statements, I would almost say never do it because

1689
01:21:47,000 --> 01:21:50,500
the chances that you will actually guess properly as to, which is the

1690
01:21:50,500 --> 01:21:51,400
optimal way to do them.

1691
01:21:51,800 --> 01:21:52,700
Are like zero?

1692
01:21:54,000 --> 01:21:57,300
So yeah, I would say when you're writing code in this stage.

1693
01:21:57,400 --> 01:21:58,700
Never think about that.

1694
01:21:58,700 --> 01:22:01,800
And only start to think about it when you get to a stage where you're

1695
01:22:01,800 --> 01:22:04,400
actually timing your performance.

1696
01:22:04,600 --> 01:22:07,400
And once you're actually timing your performance, then you can start

1697
01:22:07,400 --> 01:22:10,400
to think about how you should arrange your, if statements, for

1698
01:22:10,400 --> 01:22:11,500
performance purposes.

1699
01:22:12,500 --> 01:22:15,500
So I definitely wouldn't say don't think about it.

1700
01:22:15,800 --> 01:22:19,300
There is a very specific time in a place where you absolutely want to.

1701
01:22:19,300 --> 01:22:20,000
Think about it.

1702
01:22:20,200 --> 01:22:21,300
That time is just

1703
01:22:21,600 --> 01:22:26,400
Once you are actually timing, the cycle counts of your routine if you

1704
01:22:26,400 --> 01:22:29,000
haven't gotten to that stage, no.

1705
01:22:31,900 --> 01:22:33,900
What sort of cookie is best for programming?

1706
01:22:34,100 --> 01:22:35,700
Probably chocolate chip.

1707
01:22:36,300 --> 01:22:37,800
Sometimes new Munoz?

1708
01:22:40,500 --> 01:22:42,900
What do you think about splitting the hashmap code from the tile codes

1709
01:22:42,900 --> 01:22:45,300
that you can use hash map for other stuff later on.

1710
01:22:46,200 --> 01:22:48,500
So I realize that's a tempting thing for people.

1711
01:22:48,500 --> 01:22:50,000
People like to do that sort of stuff.

1712
01:22:52,100 --> 01:22:54,300
And I don't really want to be too critical of it because like I said,

1713
01:22:54,300 --> 01:22:55,500
programming Styles vary.

1714
01:23:03,400 --> 01:23:08,400
So I don't want to say don't ever do X or whatever because it's over.

1715
01:23:08,500 --> 01:23:11,400
It's more dramatic than I probably should sound.

1716
01:23:13,200 --> 01:23:16,700
But I think I can illustrate at least in this case, a very good

1717
01:23:16,700 --> 01:23:19,400
example, why I don't think it's useful to pull out hash code.

1718
01:23:21,500 --> 01:23:26,300
So here is the hashcode that's common among hash tables right here.

1719
01:23:28,800 --> 01:23:29,400
That much.

1720
01:23:31,400 --> 01:23:35,100
So if you tried to make this a common function, you would be saving

1721
01:23:35,100 --> 01:23:39,900
two lines of code at the expense of trying to shoehorn all the rest of

1722
01:23:39,900 --> 01:23:44,300
this into some common thing because the comparison function is

1723
01:23:44,300 --> 01:23:44,800
different.

1724
01:23:44,800 --> 01:23:47,700
So you're going to have to write that every time, one way or the other

1725
01:23:47,700 --> 01:23:49,900
because you don't know the comparison could be something pretty crazy.

1726
01:23:49,900 --> 01:23:50,400
Right?

1727
01:23:51,000 --> 01:23:52,300
It's going to check multiple values.

1728
01:23:52,300 --> 01:23:55,300
It can be checking vitals and different styles are coming.

1729
01:23:55,300 --> 01:23:56,400
So you're going to no matter what you did.

1730
01:23:56,400 --> 01:23:57,800
Like, let's say you made a template or something.

1731
01:23:57,900 --> 01:23:59,600
You're going to have to supply this.

1732
01:24:00,500 --> 01:24:01,100
Right.

1733
01:24:01,500 --> 01:24:04,100
This is completely custom and often doesn't exist at all.

1734
01:24:04,700 --> 01:24:06,500
So that's going to have to go outside the hash.

1735
01:24:07,900 --> 01:24:12,800
This way of doing things right where we're sort of doing like we want

1736
01:24:12,800 --> 01:24:15,800
the internal versus external chaining or things like that is a

1737
01:24:15,800 --> 01:24:19,100
decision / hash table, but you could have one for each like an

1738
01:24:19,100 --> 01:24:20,900
internal and external Cheney version or something.

1739
01:24:20,900 --> 01:24:22,600
So you could maybe save a little bit of that.

1740
01:24:22,600 --> 01:24:26,500
But this code that actually initializes the hash and the way that we

1741
01:24:26,500 --> 01:24:29,500
said, which value was whether things were filled or not.

1742
01:24:30,100 --> 01:24:33,200
Those are also totally specific to the structure.

1743
01:24:33,700 --> 01:24:37,500
So really almost none of this code can be reused because it's

1744
01:24:37,700 --> 01:24:42,300
All based entirely on how the chunks themselves work and how we want

1745
01:24:42,300 --> 01:24:42,900
them to function.

1746
01:24:44,700 --> 01:24:47,100
So really, it's just much more efficient to just write it this way.

1747
01:24:47,100 --> 01:24:50,100
Because I mean that's all the code that it takes to write a hash

1748
01:24:50,100 --> 01:24:50,400
table.

1749
01:24:50,400 --> 01:24:51,000
There it is.

1750
01:24:52,200 --> 01:24:56,100
So I would not pull that out from traction because it's much better.

1751
01:24:56,100 --> 01:24:59,200
All being in line and we can do very custom stuff here that can be

1752
01:24:59,200 --> 01:25:02,100
much better than what we would do, if we had to force it through some

1753
01:25:02,100 --> 01:25:03,600
kind of procrustean system.

1754
01:25:04,500 --> 01:25:05,800
So that's what I would say about that.

1755
01:25:12,800 --> 01:25:15,800
You're not passing the arena to the hash lookup function.

1756
01:25:16,700 --> 01:25:17,200
What do you mean?

1757
01:25:17,200 --> 01:25:19,200
I'm not passing it to the hash lookup function.

1758
01:25:19,200 --> 01:25:21,300
Get Tau chunk, right?

1759
01:25:23,800 --> 01:25:26,600
And so in get tile value, we don't call it which is what we want

1760
01:25:26,600 --> 01:25:29,300
because we shouldn't an inset tile value.

1761
01:25:29,300 --> 01:25:29,900
We do.

1762
01:25:31,000 --> 01:25:31,500
Right.

1763
01:25:34,100 --> 01:25:34,900
So what?

1764
01:25:35,100 --> 01:25:35,400
I'm not sure.

1765
01:25:35,400 --> 01:25:36,000
I follow you.

1766
01:25:36,800 --> 01:25:37,400
What do you mean that?

1767
01:25:37,400 --> 01:25:41,300
We're not passing the arena to the hash book up function, MTS mocks.

1768
01:25:41,600 --> 01:25:42,700
Could you clarify that question?

1769
01:25:42,700 --> 01:25:44,700
So that I know what you were referring to?

1770
01:25:47,100 --> 01:25:49,900
Is the world going to be generated on the fly or at game startup?

1771
01:25:50,400 --> 01:25:51,300
Probably?

1772
01:25:51,400 --> 01:25:51,600
Well.

1773
01:25:51,600 --> 01:25:55,400
I don't know about game startup, but game start anyway, at startup

1774
01:25:55,400 --> 01:25:57,800
that I mean, the player might generate multiple worlds when they like,

1775
01:25:57,800 --> 01:25:58,700
restart their game, whatever.

1776
01:25:58,700 --> 01:25:59,000
But yeah.

1777
01:25:59,000 --> 01:26:03,000
At the restart time, I think it'll be generated at the restart time

1778
01:26:03,000 --> 01:26:05,200
because I want to do a lot more complicated things.

1779
01:26:05,200 --> 01:26:09,900
And if you generate the world on the Fly Like, You know, I want to

1780
01:26:09,900 --> 01:26:12,600
have stuff where, oh, there's like a messenger.

1781
01:26:12,600 --> 01:26:14,100
Who's going between two places.

1782
01:26:14,100 --> 01:26:16,800
That's like really far from where you are like your way down here.

1783
01:26:16,900 --> 01:26:20,500
And he's going here and he tell somebody something, who tells another

1784
01:26:20,500 --> 01:26:21,700
guy to go do something.

1785
01:26:21,700 --> 01:26:24,600
Like, I want to be able to have very complicated stuff going on in the

1786
01:26:24,600 --> 01:26:26,800
world and that can't be simulated.

1787
01:26:26,800 --> 01:26:29,000
If the world only exists right around where you are.

1788
01:26:29,200 --> 01:26:32,700
So I want the world to exist everywhere at high frequency around where

1789
01:26:32,700 --> 01:26:35,500
you are, but at low frequency everywhere is the goal.

1790
01:26:35,700 --> 01:26:38,000
So it kind of all has to be generated before you start playing.

1791
01:26:46,500 --> 01:26:47,200
Instead of chunks.

1792
01:26:47,200 --> 01:26:48,900
Have you thought about spatial hashing?

1793
01:26:48,900 --> 01:26:51,500
I'm considering it for my game to allow an open General but not

1794
01:26:51,500 --> 01:26:53,800
confined to gridline tiles for fixed sized objects.

1795
01:26:53,900 --> 01:26:55,300
So, yes, we are not a lot.

1796
01:26:55,300 --> 01:26:57,000
We are not going to be confined to those either.

1797
01:26:57,100 --> 01:26:58,400
This is a spatial hash.

1798
01:26:59,400 --> 01:26:59,800
So the what?

1799
01:27:00,000 --> 01:27:03,100
What I'm planning to do next because we already did the step of it,

1800
01:27:03,400 --> 01:27:04,900
which is this step right here.

1801
01:27:05,000 --> 01:27:05,700
What I'm planning to do.

1802
01:27:05,700 --> 01:27:08,400
Next is entities will just be sorted out chunks and there will no

1803
01:27:08,400 --> 01:27:10,100
longer be tile store to tell chunks.

1804
01:27:10,600 --> 01:27:11,600
So that's our next step.

1805
01:27:11,800 --> 01:27:13,800
So we are actually already doing exactly what you're saying.

1806
01:27:13,800 --> 01:27:15,300
We just haven't quite gotten there yet.

1807
01:27:22,000 --> 01:27:23,600
What about using an octree for sparse?

1808
01:27:23,600 --> 01:27:25,300
Tell storage rather than a hashmap?

1809
01:27:25,500 --> 01:27:30,400
So I don't know what the benefit, like, what would the benefit of an

1810
01:27:30,400 --> 01:27:31,800
octree be right?

1811
01:27:37,700 --> 01:27:39,100
There's only one thing I can think of.

1812
01:27:41,900 --> 01:27:42,800
And I don't love it.

1813
01:27:45,800 --> 01:27:46,800
So, let's think about that.

1814
01:27:48,600 --> 01:27:49,300
Shall we?

1815
01:27:53,300 --> 01:27:56,400
So first, let's talk about the point of an octree, right?

1816
01:27:57,800 --> 01:27:59,200
The point of an octree.

1817
01:28:00,600 --> 01:28:03,900
Is usually that you want to store things at multiple levels of detail.

1818
01:28:05,300 --> 01:28:07,200
Audrey is really a large scheme.

1819
01:28:07,500 --> 01:28:09,900
Like I don't really think of octree is a spatial partition because

1820
01:28:09,900 --> 01:28:12,700
it's not a very good spatial partition if you're not talking about

1821
01:28:12,700 --> 01:28:16,000
this in my opinion, right?

1822
01:28:17,300 --> 01:28:21,500
Because if we have the ability to access like with the hashmap, we can

1823
01:28:21,500 --> 01:28:25,500
basically jump right into a table and do some small number of

1824
01:28:25,500 --> 01:28:31,300
comparisons to find out exactly the tile chunk that we're on, right?

1825
01:28:31,900 --> 01:28:34,200
And that number of comparisons will probably be quite small.

1826
01:28:34,200 --> 01:28:36,700
We can make the hashmap Fairly large and I think that number curves

1827
01:28:36,700 --> 01:28:37,900
will be like one or two.

1828
01:28:38,100 --> 01:28:43,300
Typically, an octree is guaranteed to every time you do a lookup have

1829
01:28:43,300 --> 01:28:46,700
to do as many steps as there are levels.

1830
01:28:46,800 --> 01:28:47,600
In the octree.

1831
01:28:48,100 --> 01:28:49,800
So how many levels would there be in Iraq?

1832
01:28:49,800 --> 01:28:50,200
Tree?

1833
01:28:50,400 --> 01:28:52,300
Well, we have four billion.

1834
01:28:53,400 --> 01:28:54,300
Possible coordinates.

1835
01:28:54,300 --> 01:28:54,800
Right?

1836
01:28:54,900 --> 01:28:56,000
We're saying there's an apron there.

1837
01:28:56,000 --> 01:28:59,100
So let's say conservatively maybe there's two billion or 1 billion,

1838
01:28:59,500 --> 01:29:00,100
right?

1839
01:29:00,700 --> 01:29:04,400
So that'd be like to let's say we have two to the 28th or something of

1840
01:29:04,400 --> 01:29:07,500
that nature tiles, and we're doing them by 16.

1841
01:29:07,500 --> 01:29:10,800
So we have something like 2 to the 24th, right?

1842
01:29:11,200 --> 01:29:14,900
If we have 2 to the 24th, that means the number of splits in the

1843
01:29:14,900 --> 01:29:15,600
octree, right?

1844
01:29:15,600 --> 01:29:17,200
The octree splits things in half.

1845
01:29:18,000 --> 01:29:18,500
Right.

1846
01:29:20,600 --> 01:29:22,300
Because any Dimension is split in half.

1847
01:29:22,300 --> 01:29:22,400
It.

1848
01:29:22,400 --> 01:29:25,400
Splits it into eight, cubes half on each Dimension.

1849
01:29:25,900 --> 01:29:31,100
So the first split would take us from 2224 to to the 23rd right on

1850
01:29:31,100 --> 01:29:31,700
either side.

1851
01:29:33,300 --> 01:29:35,800
So each one of these would be a two to the 23rd side Cube.

1852
01:29:35,900 --> 01:29:37,300
The next one would do is 22nd.

1853
01:29:37,300 --> 01:29:38,300
Then 21st.

1854
01:29:38,300 --> 01:29:40,300
We would need to test 24.

1855
01:29:40,300 --> 01:29:44,600
We need to do twenty four iterations down the octree to get to a

1856
01:29:44,600 --> 01:29:47,900
single one of our tile Maps, right?

1857
01:29:48,000 --> 01:29:49,700
There's just no way hash tables.

1858
01:29:49,700 --> 01:29:51,500
Not going to beat that in my opinion.

1859
01:29:51,500 --> 01:29:52,700
I just don't see it.

1860
01:29:54,100 --> 01:29:57,300
So I feel like an octree would be a real waste of computing resources

1861
01:29:57,300 --> 01:29:59,900
because usually the reason you do an octree is because

1862
01:30:00,000 --> 01:30:02,600
You start storing things at lower levels of detail.

1863
01:30:03,700 --> 01:30:06,400
So the only things that take 2 to the 24th things that aren't very

1864
01:30:06,400 --> 01:30:10,100
high level detail and other things are stored earlier up.

1865
01:30:10,100 --> 01:30:13,800
So you're talking about a non fully populated tree, but we actually

1866
01:30:13,800 --> 01:30:17,500
have a fully populated tree in the sense that all of our information

1867
01:30:17,500 --> 01:30:18,700
is at the very leaves.

1868
01:30:18,700 --> 01:30:21,900
We don't have any way of doing anything at at higher up levels, really

1869
01:30:21,900 --> 01:30:23,200
nor do I think we want any.

1870
01:30:24,200 --> 01:30:26,700
So this is just really, I think not very useful, unless I'm missing

1871
01:30:26,700 --> 01:30:27,200
something.

1872
01:30:33,600 --> 01:30:36,800
Since you are using a memory arena for all allocations, how will you

1873
01:30:36,800 --> 01:30:38,000
handle Dynamic amount of objects?

1874
01:30:38,000 --> 01:30:39,600
Like enemies, particles, Etc.

1875
01:30:40,200 --> 01:30:41,900
Well, you will have to see when we get there.

1876
01:30:43,100 --> 01:30:46,100
I mean, the short answer is, I just usually use circular buffers for

1877
01:30:46,100 --> 01:30:46,400
this.

1878
01:30:54,800 --> 01:30:57,800
Shouldn't the safe margin be in 32 Max minus margin.

1879
01:30:58,600 --> 01:31:00,100
So is that enough?

1880
01:31:00,100 --> 01:31:01,300
That's what I'm wondering.

1881
01:31:03,800 --> 01:31:04,600
I don't really know.

1882
01:31:05,400 --> 01:31:09,700
So the first thing is it's the the these are in tile chunks, right?

1883
01:31:09,800 --> 01:31:14,500
So it's at the very least, the it 32 Max over 16, which is the size

1884
01:31:14,700 --> 01:31:17,400
that we're using right now for tile chunks, right?

1885
01:31:19,000 --> 01:31:23,600
And so it's definitely going to be more than just in 32.

1886
01:31:23,600 --> 01:31:27,400
Max minus margin because that would be in tiles, not in touch honks

1887
01:31:27,800 --> 01:31:30,800
and I decided to just make it smaller than that, just to be extra safe

1888
01:31:30,800 --> 01:31:32,100
because I don't think we should ever get out there.

1889
01:31:32,100 --> 01:31:33,200
So that's why I used.

1890
01:31:33,800 --> 01:31:35,000
That as the margin?

1891
01:31:39,900 --> 01:31:41,200
When will this little guy have feet?

1892
01:31:41,200 --> 01:31:42,400
He's, he doesn't get feet.

1893
01:31:42,400 --> 01:31:43,100
He's limbless.

1894
01:31:43,100 --> 01:31:44,700
He does not have hands or feet.

1895
01:31:50,400 --> 01:31:55,200
Isn't the explanation where one letter points to the next letter until

1896
01:31:55,200 --> 01:31:59,500
the end of the word, but that's sorry.

1897
01:31:59,500 --> 01:32:01,900
I didn't I didn't mean to imply.

1898
01:32:01,900 --> 01:32:03,800
That was what was happening.

1899
01:32:05,100 --> 01:32:06,500
Are you talking about?

1900
01:32:09,000 --> 01:32:13,000
When I said we had the words in the dictionary and we had, like, ABC

1901
01:32:13,000 --> 01:32:17,400
or ABCDEFG QRS.

1902
01:32:17,600 --> 01:32:19,900
A,b,c Etc.

1903
01:32:22,500 --> 01:32:24,400
The letters, don't point to the next letters.

1904
01:32:24,400 --> 01:32:25,800
There's no pointing in here.

1905
01:32:25,900 --> 01:32:29,400
I'm talking about just a string and the hash function for this string

1906
01:32:29,400 --> 01:32:31,100
would just add all the letters together.

1907
01:32:31,200 --> 01:32:35,500
It would take all of the the ASCII values and produce one, say 32-bit

1908
01:32:35,500 --> 01:32:38,300
number, right, that it then truncates down.

1909
01:32:38,400 --> 01:32:43,500
To, you know, 8 Bits, right, like we did and then those eight bits

1910
01:32:43,500 --> 01:32:48,900
look up into a 256 entry table and the table has the each string that

1911
01:32:48,900 --> 01:32:49,700
was stored there.

1912
01:32:49,700 --> 01:32:53,000
And if so, this this string might be the word Foo, right?

1913
01:32:53,100 --> 01:32:56,300
And then if there was another thing that collided with Foo, it would

1914
01:32:56,300 --> 01:32:59,400
have a pointer off to the next word, which is bar or whatever.

1915
01:33:00,000 --> 01:33:03,300
Right, so there's no pointers to letters or anything like that.

1916
01:33:03,300 --> 01:33:07,300
So it's not a, it's not a tree in that sense.

1917
01:33:13,600 --> 01:33:16,200
I think you said that a hash table was just one of many ways to start

1918
01:33:16,200 --> 01:33:16,800
this First Data.

1919
01:33:16,800 --> 01:33:19,600
Could you briefly mention one or a couple of the other methods?

1920
01:33:19,600 --> 01:33:20,100
Sure.

1921
01:33:21,300 --> 01:33:25,300
So there's lots of other ways we could imagine storing them ranging

1922
01:33:25,300 --> 01:33:27,600
from common, to, to bizarre.

1923
01:33:28,800 --> 01:33:32,700
And so essentially, they're all exactly the same in principle.

1924
01:33:33,000 --> 01:33:35,100
They all take an XYZ.

1925
01:33:35,100 --> 01:33:40,100
Like I said, which is very large when you concatenated together,

1926
01:33:40,300 --> 01:33:40,700
right?

1927
01:33:40,800 --> 01:33:42,500
So in this case, if they were all

1928
01:33:42,700 --> 01:33:44,600
For a b, let's say like we were saying before.

1929
01:33:45,700 --> 01:33:48,800
Then when you add those together, you're going to get something like

1930
01:33:48,800 --> 01:33:50,400
72 bits worth of data.

1931
01:33:50,700 --> 01:33:51,300
Right?

1932
01:33:51,800 --> 01:33:55,700
So they're all something that tries to take 72 bits and smush it into

1933
01:33:55,700 --> 01:33:57,600
some smaller number, right?

1934
01:33:57,800 --> 01:34:00,300
Because we know that in memory, you're only going to have chance to

1935
01:34:00,300 --> 01:34:04,700
allocate say 24 bits worth of data, right, 24, bits, worth of space

1936
01:34:05,000 --> 01:34:06,000
for indexing or something.

1937
01:34:06,000 --> 01:34:09,400
That'd be 16 million entries, for example, or something like that.

1938
01:34:09,500 --> 01:34:10,200
That's a reasonable.

1939
01:34:10,200 --> 01:34:13,900
Number of entries, probably to have a something this is not

1940
01:34:15,600 --> 01:34:18,800
So they're all trying to do this same process.

1941
01:34:19,900 --> 01:34:22,200
So somebody already mentioned one of them which was like an octree.

1942
01:34:22,600 --> 01:34:23,200
Right?

1943
01:34:23,200 --> 01:34:27,100
And octree is a way of storing things such that you essentially have

1944
01:34:28,100 --> 01:34:32,200
A data structure that splits the world recursively into smaller and

1945
01:34:32,200 --> 01:34:34,100
smaller cubes, right?

1946
01:34:34,100 --> 01:34:38,300
So you have a head node, which is the world and it has eight.

1947
01:34:38,300 --> 01:34:39,300
It's like an octopus.

1948
01:34:39,300 --> 01:34:41,500
It has eight child nodes, right?

1949
01:34:41,700 --> 01:34:44,100
One, two, three, four, five, six, seven, eight.

1950
01:34:44,200 --> 01:34:48,900
It has eight child nodes and each of those nodes is a world that is

1951
01:34:48,900 --> 01:34:49,500
18.

1952
01:34:49,500 --> 01:34:50,100
Besides.

1953
01:34:50,100 --> 01:34:51,600
So it's one of these right?

1954
01:34:51,900 --> 01:34:54,700
And each one of those could be split into eight, right?

1955
01:34:55,700 --> 01:34:58,100
And basically, that's for storing things, at different levels of

1956
01:34:58,100 --> 01:34:58,500
sparseness.

1957
01:34:58,500 --> 01:35:01,200
So that you only kind of go down to a certain level.

1958
01:35:01,200 --> 01:35:04,200
Usually they're like, five deep or 60, right?

1959
01:35:05,100 --> 01:35:05,900
For the world.

1960
01:35:06,900 --> 01:35:09,800
And so, you know, that's one way of storing things parsley because you

1961
01:35:09,800 --> 01:35:11,800
don't have to subdivide every node.

1962
01:35:11,800 --> 01:35:14,000
You only subdivide down to where there's actually data.

1963
01:35:15,400 --> 01:35:19,000
There are similar ones in that family, the octave family.

1964
01:35:19,100 --> 01:35:22,700
There's quadtrees which are the 2 to D equivalent of an octree.

1965
01:35:23,000 --> 01:35:25,400
There's KD trees which are the same.

1966
01:35:25,600 --> 01:35:28,100
Idea, but instead of splitting along multiple access.

1967
01:35:28,100 --> 01:35:29,900
They only put on one axis at once.

1968
01:35:30,200 --> 01:35:33,500
So they'll start like, you know, like a quadtree, for example, splits

1969
01:35:33,500 --> 01:35:36,400
the world into quarters every time, right?

1970
01:35:36,400 --> 01:35:38,600
So as you go down, the tree, you keep splitting, quarters, quarters

1971
01:35:38,600 --> 01:35:44,000
quarters a KD tree splits, the World by one dimension each time.

1972
01:35:44,000 --> 01:35:47,800
So it splits the world in half exactly each time and that it can be a

1973
01:35:47,800 --> 01:35:55,100
variable place where it split and so that's how it works trying to

1974
01:35:55,100 --> 01:35:55,300
think of

1975
01:35:55,500 --> 01:35:59,800
Like some other sparseness ones, there's rle, right or run.

1976
01:36:00,000 --> 01:36:00,700
Encoding.

1977
01:36:05,100 --> 01:36:07,900
And basically that's just a straightforward sparse encoding.

1978
01:36:08,000 --> 01:36:09,200
What that basically says is.

1979
01:36:09,200 --> 01:36:09,800
All right.

1980
01:36:09,800 --> 01:36:15,700
I've got the world and I've got like contiguous regions where there is

1981
01:36:15,700 --> 01:36:17,000
stuff stored in the world.

1982
01:36:17,300 --> 01:36:17,800
Right?

1983
01:36:18,400 --> 01:36:21,700
So the way I'm going to store, it is just by storing counts.

1984
01:36:21,900 --> 01:36:23,500
Of what is filled in, what is not.

1985
01:36:23,500 --> 01:36:26,800
So, maybe there's like 200 million entries that are empty.

1986
01:36:27,000 --> 01:36:30,500
So, the first entry in my table is 200 million, right?

1987
01:36:32,600 --> 01:36:36,300
Empty, so, just the number 200 million in the note that it's empty.

1988
01:36:36,800 --> 01:36:38,600
Then the next entry in my table is like, okay.

1989
01:36:38,600 --> 01:36:42,100
There's 12 screens in a row that are filled twelve tile chunks in a

1990
01:36:42,100 --> 01:36:43,000
rather filled.

1991
01:36:43,100 --> 01:36:49,700
So then I put in twelve filled and I put like, you know, that I store

1992
01:36:49,700 --> 01:36:50,800
the data for the 12.

1993
01:36:51,000 --> 01:36:52,800
Then the next thing is how many empty there are.

1994
01:36:52,900 --> 01:36:55,800
And you go empty, filled empty field, empty field and you basically

1995
01:36:55,800 --> 01:36:57,800
put break it up into bands, right?

1996
01:36:57,800 --> 01:37:00,500
And you can imagine more complicated ways of doing that for 2D stuff

1997
01:37:00,500 --> 01:37:01,100
and whatever.

1998
01:37:03,100 --> 01:37:05,500
Trying to think of what other things are good for doing that.

1999
01:37:08,100 --> 01:37:08,600
I don't know.

2000
01:37:09,200 --> 01:37:09,900
I have to think about it.

2001
01:37:09,900 --> 01:37:11,800
There's surely more ways of storing Spar stuff.

2002
01:37:11,800 --> 01:37:13,400
But those are the ones that come to mind.

2003
01:37:16,500 --> 01:37:16,900
Yeah.

2004
01:37:24,700 --> 01:37:26,300
Yes, thank you for catching that.

2005
01:37:26,300 --> 01:37:31,100
Someone just caught a stupid thing that we just did in setting.

2006
01:37:31,100 --> 01:37:34,300
They were saying, does starting at zero cause a problem with the tile

2007
01:37:34,300 --> 01:37:37,700
chunks because now we're using that as our uninitialized variable and

2008
01:37:37,700 --> 01:37:39,000
you're totally right, it does.

2009
01:37:39,500 --> 01:37:46,700
So what we should actually do is Define tile, chunk uninitialized.

2010
01:37:50,500 --> 01:37:54,300
And and we should Define that to be, you know, something outside the

2011
01:37:54,300 --> 01:37:57,000
safe margin basically, right?

2012
01:37:58,500 --> 01:38:02,400
So we want to do is say that we've got an initialized value and that

2013
01:38:02,400 --> 01:38:06,400
initialized value goes everywhere that we were checking 40, right?

2014
01:38:06,600 --> 01:38:07,200
Like so

2015
01:38:09,200 --> 01:38:11,200
And and that should should do that.

2016
01:38:11,200 --> 01:38:13,800
So we have our initializer here as well.

2017
01:38:14,000 --> 01:38:16,000
So I think that is what we should do.

2018
01:38:16,000 --> 01:38:16,900
Thank you for catching that.

2019
01:38:16,900 --> 01:38:18,200
We would have had to debug that later.

2020
01:38:18,200 --> 01:38:19,400
It would have been a huge pain.

2021
01:38:21,000 --> 01:38:25,400
Yeah, so yeah, that's definitely true because that was something that

2022
01:38:25,400 --> 01:38:30,500
we did assuming that we weren't going to have assuming that we were

2023
01:38:30,500 --> 01:38:33,900
never going to have any at 000.

2024
01:38:34,000 --> 01:38:37,300
But now we since someone suggested to switch to the in three twos.

2025
01:38:37,300 --> 01:38:39,400
We kind of did it hurriedly and I forgot about that.

2026
01:38:39,400 --> 01:38:40,200
So that's pretty good.

2027
01:38:40,500 --> 01:38:41,400
Thanks for catching that.

2028
01:38:41,600 --> 01:38:42,500
That would have been really annoying.

2029
01:38:55,300 --> 01:38:59,800
Shouldn't chunk touching x equals 0 B, touch.

2030
01:39:00,200 --> 01:39:03,400
Tom next and chunk, hash touch on T equals 0.

2031
01:39:04,700 --> 01:39:05,900
Yes, you are.

2032
01:39:05,900 --> 01:39:07,000
Correct about that as well.

2033
01:39:07,200 --> 01:39:08,100
Well, I'm glad this is great.

2034
01:39:08,100 --> 01:39:10,800
This is like having this is very good.

2035
01:39:11,600 --> 01:39:12,700
So chunk next in hash.

2036
01:39:12,700 --> 01:39:13,000
Yes.

2037
01:39:13,000 --> 01:39:13,500
It should be.

2038
01:39:13,500 --> 01:39:15,000
I mean, or we can just do it this way.

2039
01:39:15,500 --> 01:39:17,200
I suppose move it one down.

2040
01:39:17,400 --> 01:39:18,800
So we move to the next one.

2041
01:39:20,000 --> 01:39:21,500
Set at uninitialized and go.

2042
01:39:22,400 --> 01:39:23,100
Thank you for catching.

2043
01:39:23,500 --> 01:39:24,700
Thank you for catching the bugs.

2044
01:39:25,800 --> 01:39:26,800
This is pretty handy.

2045
01:39:26,900 --> 01:39:29,800
I need people to watch me program regularly during, you know, during

2046
01:39:29,800 --> 01:39:30,100
the day.

2047
01:39:30,100 --> 01:39:32,000
Maybe they would find on my bugs before I made them.

2048
01:39:34,300 --> 01:39:36,600
Will you write an analog function to Malik?

2049
01:39:36,800 --> 01:39:40,400
Probably not normally in the in the normal execution of a game.

2050
01:39:40,600 --> 01:39:42,000
You never really need to call malloc.

2051
01:39:42,400 --> 01:39:45,700
I know lots of people think for some reason that they need a

2052
01:39:45,700 --> 01:39:46,800
general-purpose allocator.

2053
01:39:46,800 --> 01:39:51,500
But I mean I find in general, you don't really ever need to call a

2054
01:39:51,500 --> 01:39:52,700
general-purpose allocator.

2055
01:39:54,800 --> 01:39:56,800
So I doubt we will maybe but I doubt we will.

2056
01:40:04,600 --> 01:40:05,500
Start your pancakes.

2057
01:40:05,900 --> 01:40:09,800
I see, I guess what I was thinking about is what the full four billion

2058
01:40:09,800 --> 01:40:13,600
by four billion map would look like if you passed each index in the

2059
01:40:13,600 --> 01:40:16,800
hashmap, the opposite way through the hash function.

2060
01:40:17,100 --> 01:40:19,900
It seems like it doesn't matter in the case, because no matter what,

2061
01:40:19,900 --> 01:40:22,500
it's always going to be better than 0 n and in most of the time it's

2062
01:40:22,500 --> 01:40:25,200
01 with a tiny bit of performance cost to throw the coordinates

2063
01:40:25,400 --> 01:40:26,200
through the function.

2064
01:40:27,200 --> 01:40:28,200
Yes, I think.

2065
01:40:28,400 --> 01:40:28,900
But yeah.

2066
01:40:31,800 --> 01:40:33,100
Most of your comments are notes.

2067
01:40:33,100 --> 01:40:36,100
And to do is, do you ever add section title comments to separate long

2068
01:40:36,100 --> 01:40:40,500
blocks of code sometime, but I still use note, I use note to denote

2069
01:40:40,500 --> 01:40:41,300
those things.

2070
01:40:41,600 --> 01:40:43,800
Even, I always still put a note in there.

2071
01:40:53,600 --> 01:40:55,900
Do you see any value in adding unit tests for certain bits of this

2072
01:40:55,900 --> 01:40:56,600
functionality?

2073
01:40:56,800 --> 01:40:59,000
Yes, that has been asked many times before and I've answered it the

2074
01:40:59,000 --> 01:41:03,400
same many times before which is that some things are good for unit

2075
01:41:03,400 --> 01:41:05,400
testing and some things aren't definitely.

2076
01:41:05,400 --> 01:41:06,700
I don't want to do any unit testing tool.

2077
01:41:06,700 --> 01:41:09,600
We actually have final code that we're actually talking about.

2078
01:41:09,600 --> 01:41:11,800
This is what we want to ship because otherwise you're just wasting

2079
01:41:11,800 --> 01:41:12,200
your time.

2080
01:41:13,800 --> 01:41:17,500
So yeah, unit testing will happen for certain Small Things.

2081
01:41:17,800 --> 01:41:21,900
Most of the things in a game are not unit testable in any real way.

2082
01:41:21,900 --> 01:41:22,300
Least not.

2083
01:41:22,500 --> 01:41:23,500
Things that are hard to debug.

2084
01:41:23,800 --> 01:41:28,400
So unit testing is kind of limited utility in game development, but

2085
01:41:28,400 --> 01:41:30,900
there are some things that we probably will unit tests, especially

2086
01:41:30,900 --> 01:41:31,800
probably in the renderer.

2087
01:41:44,100 --> 01:41:46,500
Can you visualize the shape of the map?

2088
01:41:46,600 --> 01:41:50,300
So I can understand why a hash table is better than an array sure.

2089
01:41:51,000 --> 01:41:52,400
So let's say,

2090
01:41:55,400 --> 01:41:57,200
We'll take two simple examples.

2091
01:41:58,100 --> 01:41:59,300
Let's start.

2092
01:42:02,600 --> 01:42:08,300
With, you know, the Tower of Doom.

2093
01:42:13,200 --> 01:42:13,800
Or something.

2094
01:42:14,400 --> 01:42:18,200
So let's say, we make a map and we actually make the map fully dense,

2095
01:42:18,700 --> 01:42:19,200
right?

2096
01:42:19,300 --> 01:42:22,400
So, here's our map, and these are the tile chunks, right?

2097
01:42:22,800 --> 01:42:26,000
So clearly, you know, we've got something that's like, you know, it's

2098
01:42:26,000 --> 01:42:29,900
like five tile chunks by five tile chunks and you're asking me, why

2099
01:42:29,900 --> 01:42:31,200
wouldn't we store this as an array?

2100
01:42:31,200 --> 01:42:33,700
And you're totally right, but why wouldn't we it's way easier to

2101
01:42:33,700 --> 01:42:34,900
destroy this as a dense array.

2102
01:42:34,900 --> 01:42:37,700
5 by 5, the lookups would be slightly faster than in the hash table.

2103
01:42:37,700 --> 01:42:41,800
Certainly and there what was the point of having that whole hash table

2104
01:42:41,800 --> 01:42:42,900
just figure out?

2105
01:42:43,000 --> 01:42:46,400
Bounds of the world and make it so that you offset your coordinates by

2106
01:42:46,400 --> 01:42:46,600
that.

2107
01:42:46,600 --> 01:42:47,100
Right?

2108
01:42:47,800 --> 01:42:55,000
But now we make the Tower of Doom which has several tiles high on this

2109
01:42:55,000 --> 01:42:58,800
one square because there's a tower that the player can climb up and

2110
01:42:58,800 --> 01:43:02,100
then there's like, you know, similarly there's the Dungeon of Doom

2111
01:43:03,200 --> 01:43:09,500
dunes and it's got several tiles underneath, right?

2112
01:43:10,100 --> 01:43:12,800
So now our array has to be

2113
01:43:12,900 --> 01:43:17,000
Be five by five by however, many of these are here.

2114
01:43:17,000 --> 01:43:18,000
Let's say by ten.

2115
01:43:18,300 --> 01:43:20,500
So now it's five by five by ten.

2116
01:43:21,200 --> 01:43:21,600
Right?

2117
01:43:21,600 --> 01:43:23,900
But how many and what is that number?

2118
01:43:23,900 --> 01:43:24,100
Right?

2119
01:43:24,100 --> 01:43:25,800
That's 250 entries.

2120
01:43:26,700 --> 01:43:28,200
Well, how many of those do we actually need?

2121
01:43:28,300 --> 01:43:30,400
Will we only needed 25 for this?

2122
01:43:30,700 --> 01:43:35,000
And we only needed like 10 for these two like 5 here, and five down or

2123
01:43:35,000 --> 01:43:35,900
whatever, right?

2124
01:43:37,300 --> 01:43:38,700
So, we only needed 30.

2125
01:43:39,000 --> 01:43:39,300
I'm sorry.

2126
01:43:39,300 --> 01:43:40,900
We only needed 35.

2127
01:43:41,600 --> 01:43:45,300
So, we over-allocated by a tremendous amount, right?

2128
01:43:45,300 --> 01:43:48,400
This is, this is like nine times over allocated or eight times over

2129
01:43:48,400 --> 01:43:49,200
delicate or something.

2130
01:43:49,200 --> 01:43:49,700
Right?

2131
01:43:50,300 --> 01:43:53,100
So the reason we want to store things, sparse Tree in a hash map is to

2132
01:43:53,100 --> 01:43:54,500
avoid that over-allocation.

2133
01:43:54,600 --> 01:43:56,800
So, now, apply this to a whole world.

2134
01:43:57,000 --> 01:44:00,900
Now, imagine that our world is fairly sprawling, right?

2135
01:44:00,900 --> 01:44:05,000
So, we have towers of Doom and dungeons of Doom, and we've got little

2136
01:44:05,000 --> 01:44:06,800
areas of our map, but then we also have

2137
01:44:06,900 --> 01:44:08,400
Long winding passages.

2138
01:44:08,400 --> 01:44:10,800
Let's say that kind of come out right?

2139
01:44:10,900 --> 01:44:12,100
Like this sort of thing.

2140
01:44:12,500 --> 01:44:16,700
And then there's like long tall towers here and like Dungeons e here

2141
01:44:16,700 --> 01:44:19,700
and maybe these things connect underground like that, but there's

2142
01:44:19,700 --> 01:44:23,900
whole areas that are empty and all this stuff storing this in a giant

2143
01:44:23,900 --> 01:44:26,600
Cube would just be massively over allocating.

2144
01:44:27,000 --> 01:44:30,000
And so what we do with the sparseness is just make sure that we don't

2145
01:44:30,000 --> 01:44:33,100
over allocate and we only store where stuff actually is.

2146
01:44:40,500 --> 01:44:43,400
The randomize map only goes up into the end to the right at the

2147
01:44:43,400 --> 01:44:43,800
moment.

2148
01:44:43,800 --> 01:44:45,200
Is it good enough to catch bugs?

2149
01:44:45,400 --> 01:44:46,200
No, not really.

2150
01:44:46,200 --> 01:44:48,600
But like I said, at this point, we're not really trying to catch bugs.

2151
01:44:48,700 --> 01:44:51,200
We're just trying to make things work so that we can see what the API

2152
01:44:51,200 --> 01:44:51,900
needs to be.

2153
01:44:52,100 --> 01:44:52,700
That's it.

2154
01:44:53,200 --> 01:44:55,500
So, there's gonna be tons of bugs in here, and we don't really care.

2155
01:44:55,600 --> 01:44:59,200
We only care about the bugs so far as they slow down our development.

2156
01:44:59,200 --> 01:44:59,800
And so far, we haven't

2157
01:45:00,000 --> 01:45:01,000
Too much problem with that.

2158
01:45:08,100 --> 01:45:11,600
Will the renderer be a separate piece of code as like the platform

2159
01:45:11,600 --> 01:45:13,800
player, so that can be substitute with something like opengl.

2160
01:45:13,800 --> 01:45:14,700
Yes, it will be.

2161
01:45:18,900 --> 01:45:19,900
And I think that's it.

2162
01:45:20,000 --> 01:45:21,400
We have come to the end of the questions.

2163
01:45:22,900 --> 01:45:24,000
Very good.

2164
01:45:24,200 --> 01:45:27,800
I'm glad we have come to the end of the questions because that means

2165
01:45:28,100 --> 01:45:29,200
it is now time.

2166
01:45:29,700 --> 01:45:31,500
Well, to transition from breakfast to lunch.

2167
01:45:31,600 --> 01:45:34,000
I guess maybe we'll have to have chocolate cookies for choc chip

2168
01:45:34,000 --> 01:45:35,000
cookies, for lunch as well.

2169
01:45:35,200 --> 01:45:39,100
Who knows document on named?

2170
01:45:42,500 --> 01:45:43,400
Why is carita?

2171
01:45:43,700 --> 01:45:45,300
That was weird, right?

2172
01:45:46,600 --> 01:45:47,800
Don't know why that just happened.

2173
01:45:48,400 --> 01:45:51,200
Well, ladies and gentlemen, thank you very much for joining me for

2174
01:45:51,200 --> 01:45:52,800
another episode of handmade here.

2175
01:45:52,800 --> 01:45:54,000
It's been a pleasure coding with you.

2176
01:45:54,000 --> 01:45:56,700
As always, we have finally gotten the point.

2177
01:45:56,700 --> 01:45:57,700
We're doing sparse storage.

2178
01:45:57,700 --> 01:45:59,400
So we don't have that much left to go.

2179
01:45:59,400 --> 01:46:01,900
This is pretty good on Monday.

2180
01:46:01,900 --> 01:46:05,600
We will get to go and and start doing our like entity stuff.

2181
01:46:05,600 --> 01:46:07,700
Maybe we'll try to start to do a little bit of World building at that

2182
01:46:07,700 --> 01:46:10,700
time, so we can actually make some some maps with entities and

2183
01:46:10,900 --> 01:46:13,400
In-store the enemies and pull them in and out of our storage.

2184
01:46:13,800 --> 01:46:16,100
That's would be where I'd like to get to, so hopefully, we'll do that

2185
01:46:16,100 --> 01:46:16,500
on Monday.

2186
01:46:16,500 --> 01:46:16,900
8:00 p.m.

2187
01:46:16,900 --> 01:46:18,500
Pacific Standard time, on Monday again.

2188
01:46:18,600 --> 01:46:19,700
Hope to see you all there.

2189
01:46:20,600 --> 01:46:21,700
And I think that'll be kind of cool.

2190
01:46:21,700 --> 01:46:24,300
It'd be nice to actually have some real maps to walk around and so

2191
01:46:24,300 --> 01:46:27,100
we'll make something with maybe with with trees or something like that

2192
01:46:27,500 --> 01:46:31,900
where we can kind of walk around them in preparation for moving on to

2193
01:46:31,900 --> 01:46:32,800
animation and stuff.

2194
01:46:33,200 --> 01:46:35,100
So I'd like to get to that point and I think we're almost there.

2195
01:46:35,100 --> 01:46:36,800
So that's going to be pretty good and that's going to be a lot of fun

2196
01:46:36,800 --> 01:46:37,600
to do as well.

2197
01:46:38,100 --> 01:46:38,900
We do have some more things.

2198
01:46:38,900 --> 01:46:40,700
We'd like to deal with like we have to

2199
01:46:40,800 --> 01:46:43,100
Go ahead and figure out how we want to do walking up and down, and

2200
01:46:43,100 --> 01:46:43,700
that sort of stuff.

2201
01:46:43,700 --> 01:46:46,100
So we got a lot of stuff to think about but we're in a good place, I

2202
01:46:46,100 --> 01:46:46,400
think.

2203
01:46:46,600 --> 01:46:48,000
And I think we're still making pretty good progress.

2204
01:46:48,000 --> 01:46:49,000
So I'm happy about that.

2205
01:46:49,500 --> 01:46:53,100
Anyway, if you would like to follow along at home with a source code,

2206
01:46:53,200 --> 01:46:56,500
you can always pre-order the game on handmade hero dot-org using the

2207
01:46:56,500 --> 01:46:57,700
handy pre-order button.

2208
01:46:58,200 --> 01:47:01,300
If you do that, you will get a link in your email that allows you to

2209
01:47:01,300 --> 01:47:04,400
download the source code and the test assets update them.

2210
01:47:04,400 --> 01:47:06,700
So they're always totally current with whatever I'm working with

2211
01:47:06,700 --> 01:47:07,500
anything on the Stream.

2212
01:47:08,600 --> 01:47:10,000
So, I had around checking that out.

2213
01:47:10,000 --> 01:47:11,600
If you want to follow along at home.

2214
01:47:11,600 --> 01:47:12,600
We also have a patreon.

2215
01:47:12,600 --> 01:47:14,300
If you want to just support the video series.

2216
01:47:15,400 --> 01:47:16,400
You can always go there.

2217
01:47:16,400 --> 01:47:17,400
Check that out.

2218
01:47:17,400 --> 01:47:19,300
And then finally, we've got a news and Forum site.

2219
01:47:19,300 --> 01:47:20,300
That's really cool.

2220
01:47:20,600 --> 01:47:23,000
You should go ahead and check that out.

2221
01:47:23,000 --> 01:47:24,300
It's got the schedule on it.

2222
01:47:25,000 --> 01:47:27,600
It's got the coding resources, where we basically have people have

2223
01:47:27,600 --> 01:47:29,700
ported the game already to Mac and Linux and stuff.

2224
01:47:29,700 --> 01:47:31,300
So I've been trying to follow along another platform.

2225
01:47:31,300 --> 01:47:33,300
I highly recommend looking in there that could save you.

2226
01:47:33,300 --> 01:47:35,300
A lot of time, see what people have already done.

2227
01:47:35,700 --> 01:47:37,900
There's a Code discussion where you can post, you know, if

2228
01:47:38,100 --> 01:47:41,300
And bugs, or if you have questions or anything like that, we got a

2229
01:47:41,300 --> 01:47:43,900
nice discussion board going there, people are pretty helpful on it.

2230
01:47:44,300 --> 01:47:46,600
And finally there's an episode guide which I highly recommend checking

2231
01:47:46,600 --> 01:47:50,100
out, it lets you catch up on old episodes and stuff like that and also

2232
01:47:50,100 --> 01:47:53,600
people have been annotating them so that you can go in here you can

2233
01:47:53,600 --> 01:47:57,700
jump directly to certain things in the time code, but there's they

2234
01:47:57,700 --> 01:47:59,900
could use your help to it's entirely a

2235
01:48:00,000 --> 01:48:00,300
Effort.

2236
01:48:00,300 --> 01:48:03,000
So, if you're someone who watches the videos very carefully, and

2237
01:48:03,000 --> 01:48:07,100
wouldn't mind writing down the times at which we talked about various

2238
01:48:07,100 --> 01:48:07,600
things.

2239
01:48:08,400 --> 01:48:10,400
Definitely try to get in concrete cells.

2240
01:48:10,400 --> 01:48:12,500
Either post on the code discussion board, or you can tweet it.

2241
01:48:12,500 --> 01:48:13,100
One of them.

2242
01:48:15,000 --> 01:48:16,300
They would love to have some more help.

2243
01:48:16,300 --> 01:48:17,600
I know that it's a lot of work for them.

2244
01:48:17,600 --> 01:48:19,400
And obviously, they're just totally volunteering it.

2245
01:48:19,400 --> 01:48:22,000
So anyway, something to think about.

2246
01:48:22,100 --> 01:48:25,700
So, thank you everyone for joining me and I hope to see you again

2247
01:48:25,900 --> 01:48:26,200
here.

2248
01:48:26,200 --> 01:48:27,100
Monday night, 8:00 p.m.

2249
01:48:27,100 --> 01:48:29,900
Pacific Standard Time, have a fabulous.

2250
01:48:30,000 --> 01:48:32,200
This weekend and I will see you all then.

2251
01:48:32,400 --> 01:48:33,300
Take it easy, everyone.

