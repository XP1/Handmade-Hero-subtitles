1
00:00:00,000 --> 00:00:00,900
Stop recording.

2
00:00:01,400 --> 00:00:02,100
Start recording.

3
00:00:02,100 --> 00:00:04,300
Hello everyone and welcome to handmade hero.

4
00:00:04,300 --> 00:00:07,500
The show where we Cody complete game live on stream.

5
00:00:07,600 --> 00:00:09,200
We don't use any engines or libraries.

6
00:00:09,200 --> 00:00:13,600
This is actually a full picture of game development, all the way from

7
00:00:13,600 --> 00:00:15,200
the pixels up to the AI.

8
00:00:15,800 --> 00:00:18,000
Every last little thing is covered on the stream.

9
00:00:18,800 --> 00:00:23,500
We have gotten to the point where we would like to do what I would

10
00:00:23,500 --> 00:00:28,100
consider, you know, perhaps even really the only

11
00:00:30,000 --> 00:00:33,100
hard memory management problem that we will have in handmade hero

12
00:00:33,100 --> 00:00:37,400
because we talk about memory once in a while I'm handmade hero.

13
00:00:37,400 --> 00:00:40,800
But usually it's to point out the fact that you really just don't have

14
00:00:40,800 --> 00:00:42,000
to think about it that much.

15
00:00:42,400 --> 00:00:45,900
There's a lot of people who think that they can't program without a

16
00:00:45,900 --> 00:00:49,200
garbage collected language or think that it'll slow them down too much

17
00:00:49,200 --> 00:00:52,600
or have all of these sort of preconceived notions about how hard it

18
00:00:52,600 --> 00:00:56,900
would be for them if they didn't rely on these sort of abstract

19
00:00:56,900 --> 00:00:59,800
Notions of memory where it's just kind of amorphous and weird.

20
00:01:00,000 --> 00:01:00,500
Right.

21
00:01:01,700 --> 00:01:02,800
But so far on handmade here.

22
00:01:02,800 --> 00:01:04,800
As I hope I've demonstrated this you really just don't have to think

23
00:01:04,800 --> 00:01:05,500
about it that much.

24
00:01:05,500 --> 00:01:09,800
There's a couple times that you might think about it a little bit, but

25
00:01:09,800 --> 00:01:12,400
on the whole, you can model most things.

26
00:01:12,400 --> 00:01:13,800
As very simple Stacks.

27
00:01:14,000 --> 00:01:16,600
You write it once and you really never have to think about it again.

28
00:01:17,700 --> 00:01:19,600
And so that's the case for most of the time.

29
00:01:19,600 --> 00:01:22,800
But this, there's two places in handmade hero, I think that we might

30
00:01:22,800 --> 00:01:23,700
have to think about it.

31
00:01:24,700 --> 00:01:28,000
One of them is what we're at right now, and so I want to talk about it

32
00:01:28,700 --> 00:01:29,800
and one of the things that's

33
00:01:29,900 --> 00:01:33,700
Kind of important to remember about this is actually, this one in

34
00:01:33,700 --> 00:01:37,900
particular, is one that also can't really be solved by a garbage

35
00:01:37,900 --> 00:01:38,800
collecting language.

36
00:01:39,000 --> 00:01:42,200
So, this is a problem that you really have to think about, no matter

37
00:01:42,200 --> 00:01:43,900
how you choose to model your memory.

38
00:01:44,500 --> 00:01:49,000
If you care, if you actually care about being able to do some of the

39
00:01:49,000 --> 00:01:51,600
stuff correctly, you actually have to think about it, whether you're

40
00:01:51,600 --> 00:01:56,000
managing memory yourself or not, because it's less about remembering

41
00:01:56,000 --> 00:01:59,200
to free stuff for collecting garbage and that sort of stuff and more

42
00:01:59,200 --> 00:01:59,800
about.

43
00:02:00,000 --> 00:02:04,500
How to make the optimal use of a fixed amount of storage space.

44
00:02:04,500 --> 00:02:06,200
It's a caching problem, really?

45
00:02:07,300 --> 00:02:09,900
So what I'd like to do today is just talk about this problem.

46
00:02:10,100 --> 00:02:13,900
I don't know how much programming will do, but at what I'd like to do

47
00:02:13,900 --> 00:02:17,100
is go to the Blackboard and basically try to give you some of an

48
00:02:17,100 --> 00:02:18,300
overview of the problem.

49
00:02:18,300 --> 00:02:20,000
We're trying to solve why.

50
00:02:20,000 --> 00:02:24,300
It's very difficult ways in which you might just decide not to solve

51
00:02:24,300 --> 00:02:30,100
it, which is certainly an option and then we'll make some decisions or

52
00:02:30,100 --> 00:02:34,100
decide kind of what our first stab is going to be like in trying to

53
00:02:34,100 --> 00:02:35,600
solve it for him a hero.

54
00:02:36,600 --> 00:02:44,600
Alright, so here on day one 57 let's go ahead and talk about the

55
00:02:44,600 --> 00:02:45,000
problem.

56
00:02:45,000 --> 00:02:51,100
We have, which is asset memory.

57
00:02:52,700 --> 00:02:53,600
Management.

58
00:02:56,600 --> 00:02:59,700
Okay, so here's the thing.

59
00:03:03,500 --> 00:03:08,500
All the crazy Java versus C Sharp versus C memory management.

60
00:03:08,500 --> 00:03:10,500
Oh my God pointers no it's so hard.

61
00:03:10,500 --> 00:03:14,500
I can't program blah blah blah like and everyone fights its cognitive

62
00:03:14,500 --> 00:03:14,900
load.

63
00:03:14,900 --> 00:03:16,900
They say all these are the things right.

64
00:03:18,400 --> 00:03:20,800
It's this gigantic Nightmare and you never want to get to.

65
00:03:20,800 --> 00:03:21,800
Those are just take it from me.

66
00:03:21,800 --> 00:03:25,300
If someone starts saying stuff, like garbage collection is a cognitive

67
00:03:25,300 --> 00:03:29,500
load, just let them take their cognitive load and go load it up,

68
00:03:29,500 --> 00:03:29,800
right?

69
00:03:29,800 --> 00:03:32,800
Like it's not even worth arguing with those people, but if you're

70
00:03:32,800 --> 00:03:36,300
someone who's really actually legitimately intellectually interested

71
00:03:36,300 --> 00:03:39,700
in this topic, here is a good way to think about it, right?

72
00:03:40,900 --> 00:03:46,100
So there's a couple things that you care about, when you care about

73
00:03:46,100 --> 00:03:47,600
memory, right?

74
00:03:47,800 --> 00:03:48,100
Number

75
00:03:48,300 --> 00:03:51,700
One is how much right?

76
00:03:52,600 --> 00:03:53,100
Right.

77
00:03:54,000 --> 00:03:55,300
So there's quantity.

78
00:03:57,700 --> 00:04:01,700
And this is just how much memory do you actually need to run?

79
00:04:01,700 --> 00:04:04,700
Like, like what is the actual footprint, right?

80
00:04:05,600 --> 00:04:06,800
And we care about this?

81
00:04:06,800 --> 00:04:09,900
Because there are times when that's actually constrained and no matter

82
00:04:09,900 --> 00:04:13,000
how much anyone would like to pertain to pretend that that's not true,

83
00:04:13,300 --> 00:04:16,800
it rears its ugly head again and again and again.

84
00:04:16,800 --> 00:04:21,200
And again we don't have to care about memory because PCS have a lot of

85
00:04:21,200 --> 00:04:22,000
memory up here.

86
00:04:22,000 --> 00:04:24,100
Come consoles and they don't have a lot of memory.

87
00:04:24,300 --> 00:04:26,400
Okay, finally consoles, get enough memory.

88
00:04:26,600 --> 00:04:27,100
Don't worry.

89
00:04:27,500 --> 00:04:30,900
Memory it's fine, we've got plenty and then all of a sudden phones

90
00:04:30,900 --> 00:04:33,500
happen and now phones have no memory, right?

91
00:04:33,500 --> 00:04:35,900
And then when phones get memory, all of a sudden it's going to be

92
00:04:35,900 --> 00:04:36,600
something else.

93
00:04:36,600 --> 00:04:38,200
It's like, oh, wearables.

94
00:04:38,200 --> 00:04:40,900
I got my little wrist watch and the wristwatch has no memory, right?

95
00:04:40,900 --> 00:04:45,700
It's like, it seems like throughout time no matter what happened.

96
00:04:45,800 --> 00:04:48,600
We always run out of memory and you always have to care how much

97
00:04:48,600 --> 00:04:49,400
memory you're using.

98
00:04:49,500 --> 00:04:52,900
Because no matter what, no matter when we think we have enough either,

99
00:04:52,900 --> 00:04:56,600
what we want to start using in terms of assets, gets too big or the

100
00:04:56,600 --> 00:04:57,300
machine suddenly

101
00:04:57,400 --> 00:04:58,800
Lee come out that we want to Target.

102
00:04:58,800 --> 00:05:00,500
That are too small, right?

103
00:05:01,300 --> 00:05:04,800
So quantity actually is important and we need to think about that.

104
00:05:04,800 --> 00:05:09,100
Right to is when, right?

105
00:05:10,100 --> 00:05:15,200
And you know when is like, you know, sort of the concept of Alec and

106
00:05:15,200 --> 00:05:16,400
free right?

107
00:05:16,500 --> 00:05:18,700
Where did these things happen in the code?

108
00:05:18,900 --> 00:05:23,300
Because there's how much memory we need at any given time as one

109
00:05:23,300 --> 00:05:23,900
question.

110
00:05:24,000 --> 00:05:27,300
But how we track when we need which parts of it is?

111
00:05:27,400 --> 00:05:29,400
Kind of a different thing, right?

112
00:05:30,100 --> 00:05:34,100
And so, if we think about garbage collection, as a thing, right,

113
00:05:35,200 --> 00:05:39,300
garbage collection is end and languages that management before you are

114
00:05:39,300 --> 00:05:41,600
really entirely about this, right?

115
00:05:41,700 --> 00:05:45,000
They're entirely about figuring out when you need the memory, they

116
00:05:45,000 --> 00:05:47,300
have nothing to do with this, right?

117
00:05:47,300 --> 00:05:51,500
So that no matter what, you've got for a language, it doesn't help you

118
00:05:51,500 --> 00:05:54,300
use less memory if your code is written so that it needs that much

119
00:05:54,300 --> 00:05:55,200
memory, right?

120
00:05:55,200 --> 00:05:56,300
It doesn't help you at all.

121
00:05:56,600 --> 00:05:57,300
So really the only

122
00:05:57,400 --> 00:05:59,900
only thing that garbage collection helps you do is if you

123
00:06:00,000 --> 00:06:01,600
You can't figure out how to write your code.

124
00:06:01,600 --> 00:06:04,700
So that, you know, when you need memory garbage collection can help

125
00:06:04,700 --> 00:06:04,800
you.

126
00:06:04,800 --> 00:06:09,300
Because what garbage collection effectively is, is it's a search over

127
00:06:09,300 --> 00:06:12,700
the graph of your programs ownership structure.

128
00:06:13,700 --> 00:06:16,300
To see what memory is actually in use.

129
00:06:16,600 --> 00:06:20,100
And when that ownership structure changes, the graph search will then

130
00:06:20,100 --> 00:06:20,700
figure out.

131
00:06:20,700 --> 00:06:25,200
Oh-oh there's been a piece that's now been calved off it is no longer

132
00:06:25,200 --> 00:06:26,000
necessary.

133
00:06:26,100 --> 00:06:28,500
So I know that it can be freed right?

134
00:06:28,500 --> 00:06:29,900
And so garbage collection is

135
00:06:30,000 --> 00:06:34,600
Is basically replacing you right garbage.

136
00:06:34,600 --> 00:06:36,400
In fact, I could even just summarize it.

137
00:06:36,600 --> 00:06:39,800
Basically all garbage collection is is garbage collection.

138
00:06:42,800 --> 00:06:48,500
Means it replaces you with search, right?

139
00:06:48,500 --> 00:06:49,400
That is what that is.

140
00:06:50,100 --> 00:06:54,000
So instead of you having to know, when things are elected freed, it

141
00:06:54,000 --> 00:06:55,900
will search to figure out what those are.

142
00:06:56,100 --> 00:07:00,000
And basically all of the research around garbage collection and all of

143
00:07:00,000 --> 00:07:01,900
the, you know, technology around garbage.

144
00:07:01,900 --> 00:07:05,800
Collection is designed to figure out how to make this less expensive,

145
00:07:06,000 --> 00:07:06,600
right?

146
00:07:06,600 --> 00:07:09,200
Because if you actually think of it as a real search,

147
00:07:09,900 --> 00:07:11,200
It would be impossible.

148
00:07:11,200 --> 00:07:14,300
Like, it would be totally impractical because running that search.

149
00:07:14,300 --> 00:07:17,700
Every time you did something would just be prohibitively expensive.

150
00:07:17,800 --> 00:07:20,500
So what they do instead is well, okay, can we limit the search space

151
00:07:20,500 --> 00:07:22,900
to just things that we know of changed recently?

152
00:07:23,000 --> 00:07:23,700
Can we do it?

153
00:07:23,700 --> 00:07:27,100
Only at certain times coming overlap, it on other threads, blaubart,

154
00:07:27,100 --> 00:07:27,600
right?

155
00:07:27,600 --> 00:07:29,900
And so there's all these sorts of things that try to make this less

156
00:07:29,900 --> 00:07:31,100
expensive, right?

157
00:07:35,500 --> 00:07:38,100
So, the reason I dismiss garbage collection is uninteresting.

158
00:07:39,400 --> 00:07:43,500
Is because as you've seen so far on handmade hero when is not really a

159
00:07:43,500 --> 00:07:46,100
problem for us, like we just don't have that problem.

160
00:07:46,100 --> 00:07:48,500
I'm, you know, we haven't, we've literally not even come to a single

161
00:07:48,500 --> 00:07:53,800
point and handmade hero so far, where when was we, when we even

162
00:07:53,800 --> 00:07:56,900
thought about it, we just know, we've got some Stacks, we put stuff on

163
00:07:56,900 --> 00:07:58,900
the stack, that's appropriate and that's it, right?

164
00:07:58,900 --> 00:08:02,400
It doesn't matter because we know that the world exists is one thing

165
00:08:04,100 --> 00:08:07,000
and we just run it and we don't really have to think about it, much

166
00:08:07,000 --> 00:08:07,600
more than that.

167
00:08:07,600 --> 00:08:09,100
We know when something gets destroyed.

168
00:08:09,200 --> 00:08:10,300
Whatever that it's been freed.

169
00:08:10,300 --> 00:08:13,200
So we don't you know it's just really there really isn't anything, a

170
00:08:13,200 --> 00:08:14,400
garbage collector could do for us.

171
00:08:14,400 --> 00:08:19,200
So all you would be doing would be paying for a bunch of search that

172
00:08:19,200 --> 00:08:20,500
we don't need to do.

173
00:08:20,700 --> 00:08:22,700
It's strictly baggage, right?

174
00:08:23,500 --> 00:08:27,700
Whereas if you know either you are confused about it or maybe you have

175
00:08:27,700 --> 00:08:31,500
some very wacky program where it's just this is going to be the only

176
00:08:31,500 --> 00:08:34,700
way to really know for some reason and I don't really know what that

177
00:08:34,700 --> 00:08:35,400
program would look like.

178
00:08:35,400 --> 00:08:36,299
But you know,

179
00:08:37,299 --> 00:08:37,799
Who knows?

180
00:08:38,500 --> 00:08:41,100
Then you can imagine this being a thing, right?

181
00:08:41,600 --> 00:08:44,000
And one place that that might happen, let's say was like some kind of

182
00:08:44,000 --> 00:08:47,400
editor with really dense weird structures in it and you like delete

183
00:08:47,400 --> 00:08:50,300
one of them and it's hard to tell whether some of the other related

184
00:08:50,300 --> 00:08:53,400
things should go away or what you know you know maybe something like

185
00:08:53,400 --> 00:08:54,000
this.

186
00:08:55,700 --> 00:08:59,500
I don't know or you know in a more game context like maybe we'll see

187
00:08:59,500 --> 00:08:59,800
it later.

188
00:09:00,000 --> 00:09:04,200
On where we maybe we get into a situation where there's like, entities

189
00:09:04,200 --> 00:09:05,700
that have sub entities.

190
00:09:05,700 --> 00:09:09,200
And you know, when one of those goes away, like should other sub

191
00:09:09,200 --> 00:09:11,000
entities of it, go away or, you know what I'm saying.

192
00:09:11,400 --> 00:09:15,200
So that's really the only time where you can start to see like, oh,

193
00:09:15,200 --> 00:09:18,800
okay, I get it like like, that's, you know, garbage collection.

194
00:09:19,500 --> 00:09:22,700
Well, I'm personally not interested in it because I just Implement

195
00:09:22,700 --> 00:09:23,300
something myself.

196
00:09:23,300 --> 00:09:23,700
There.

197
00:09:23,900 --> 00:09:27,500
You could at least see where it might be useful.

198
00:09:27,500 --> 00:09:29,800
Whereas, in, handmade hero so far, we haven't had any

199
00:09:30,000 --> 00:09:31,700
Thing where it would, it would be useful, right?

200
00:09:31,700 --> 00:09:33,200
So, it's just kind of a, no, op.

201
00:09:33,700 --> 00:09:35,600
But eventually, maybe we'll get something where it is.

202
00:09:35,600 --> 00:09:36,200
And I'll point it out.

203
00:09:36,200 --> 00:09:39,400
If we, if we do, if we don't try to imagine that in your head.

204
00:09:39,400 --> 00:09:41,500
And that's, that's what that's doing for you.

205
00:09:41,600 --> 00:09:46,300
It's preventing you from having to write code that detects what that

206
00:09:46,300 --> 00:09:49,700
is because it's like a generic version of that.

207
00:09:49,700 --> 00:09:51,300
Thing of the oh I deleted.

208
00:09:51,300 --> 00:09:54,400
Entity are there any entities which are now irrelevant to the game and

209
00:09:54,400 --> 00:09:55,700
should also be deleted.

210
00:09:55,800 --> 00:09:59,100
That's like what garbage collection is supposed to solve the generic

211
00:09:59,100 --> 00:09:59,800
version of that.

212
00:10:00,000 --> 00:10:02,300
So you don't have to write it yourself, right?

213
00:10:02,500 --> 00:10:03,100
So, there you go.

214
00:10:04,800 --> 00:10:10,000
Okay, so what we have unfortunately, in the asset memory management

215
00:10:10,000 --> 00:10:13,400
thing is this is not really relevant.

216
00:10:14,000 --> 00:10:18,100
We don't care about this at all because when is not at all the issue

217
00:10:19,000 --> 00:10:22,700
in terms of when the memory is used because what asset memory.

218
00:10:22,700 --> 00:10:24,600
If you think about how this works is, right?

219
00:10:24,600 --> 00:10:26,400
We have something.

220
00:10:26,500 --> 00:10:32,500
That's like, you know, let's just say it's like a bazillion, right?

221
00:10:33,300 --> 00:10:34,100
Assets.

222
00:10:35,200 --> 00:10:38,600
However, many there are we have a huge number of them, right?

223
00:10:38,900 --> 00:10:42,700
And then we have some amount of space that we have to run our game in,

224
00:10:42,700 --> 00:10:43,300
right?

225
00:10:43,300 --> 00:10:46,700
So let's say this is like three terabytes because who knows?

226
00:10:46,700 --> 00:10:49,300
It's the world's largest game, right?

227
00:10:49,300 --> 00:10:51,900
So you know, the community gets together in the make three terabytes

228
00:10:51,900 --> 00:10:54,800
worth of assets for handmade hero and we're trying to run the game

229
00:10:54,800 --> 00:10:55,900
with three terabytes of asset.

230
00:10:58,500 --> 00:10:59,400
But guess what?

231
00:10:59,700 --> 00:11:01,700
You know, we only have 4 gigabytes of RAM.

232
00:11:03,000 --> 00:11:03,600
Right.

233
00:11:04,500 --> 00:11:11,400
And so what we need to do is the when for memory is always, there's no

234
00:11:11,400 --> 00:11:15,900
there's no time when we didn't want all these assets we wanted all of

235
00:11:15,900 --> 00:11:16,700
them right?

236
00:11:16,700 --> 00:11:17,800
They're all in use.

237
00:11:17,800 --> 00:11:20,200
None of them will ever be garbage collected.

238
00:11:20,200 --> 00:11:21,700
Now, they'll never be garbage.

239
00:11:21,700 --> 00:11:23,900
We need all the asset data, it's all there.

240
00:11:24,800 --> 00:11:27,600
The problem is we can't fit it all in memory.

241
00:11:28,300 --> 00:11:32,000
So what we essentially have is a caching problem, right?

242
00:11:32,200 --> 00:11:32,600
We have a

243
00:11:32,800 --> 00:11:37,000
Problem, right here, where the amount of memory that we need is larger

244
00:11:37,000 --> 00:11:41,200
than the amount of memory we have and just to underscore why this is

245
00:11:41,200 --> 00:11:42,100
irrelevant.

246
00:11:43,000 --> 00:11:45,400
If that wasn't the case, right?

247
00:11:45,400 --> 00:11:49,500
If we had four gigabytes of assets and 4, gigabytes of RAM for the

248
00:11:49,500 --> 00:11:53,500
assets, we're already done our asset system already.

249
00:11:53,500 --> 00:11:57,700
Does the exactly maximally efficient thing, which is that at any given

250
00:11:57,700 --> 00:11:59,800
time the assets that it predicts that

251
00:12:00,000 --> 00:12:03,900
Needs are getting loaded into the 4 GB end over end over end.

252
00:12:03,900 --> 00:12:04,900
You can actually see this.

253
00:12:04,900 --> 00:12:09,800
I'll load up the code and show you exactly what I mean, so that it's

254
00:12:09,800 --> 00:12:12,600
concrete for you and you know, exactly, which part of the code I'm

255
00:12:12,600 --> 00:12:16,000
talking about when I say this, if I go into handmade code handmade

256
00:12:16,000 --> 00:12:17,400
asset, right.

257
00:12:18,400 --> 00:12:23,100
Then when we do that sort of load asset work stuff, right?

258
00:12:23,400 --> 00:12:25,400
You can see in load bitmap what we do.

259
00:12:25,400 --> 00:12:29,800
Right here is we do a push struct to push the bitmap sort of

260
00:12:30,000 --> 00:12:30,900
Handle on.

261
00:12:31,100 --> 00:12:34,400
And then we do a push size to push on the bitmap B, right?

262
00:12:34,400 --> 00:12:36,300
And that goes into our asset Arena.

263
00:12:37,300 --> 00:12:40,500
Now, the fat-ass Audrina will never fill.

264
00:12:40,900 --> 00:12:43,600
So, we're got four gigabytes asset for GB Arena.

265
00:12:43,700 --> 00:12:48,800
And they'll fit, if it'll never fill, we're done our asset code AS

266
00:12:48,800 --> 00:12:50,500
written will do exactly the right thing.

267
00:12:50,600 --> 00:12:54,400
It will it will load all the assets into memory eventually.

268
00:12:54,600 --> 00:12:57,600
It will load them in the order in which we need them to be loaded and

269
00:12:57,600 --> 00:12:59,600
it will do so in the background so that you don't have to wait for a

270
00:12:59,600 --> 00:13:00,200
loading screen.

271
00:13:00,300 --> 00:13:01,900
So it's exactly what we want.

272
00:13:02,000 --> 00:13:04,400
If our asset load is lower,

273
00:13:05,300 --> 00:13:09,200
then our memory footprint allows us to keep at one time.

274
00:13:10,400 --> 00:13:14,700
So, the reason this turns into a caching problem is because if we have

275
00:13:14,700 --> 00:13:18,000
more memory than would fit in here, right?

276
00:13:18,000 --> 00:13:19,300
So it's too much.

277
00:13:20,500 --> 00:13:24,300
Then what we have is essentially a VM problem, we've got a virtual

278
00:13:24,300 --> 00:13:25,100
memory problem.

279
00:13:25,500 --> 00:13:31,400
We have a problem where what this actually is is a cache of the assets

280
00:13:32,100 --> 00:13:36,900
that only stores some small subset of them at any given time.

281
00:13:37,300 --> 00:13:41,900
And what we need to do is pick out the slices of our asset pool and

282
00:13:41,900 --> 00:13:45,500
map them into here as necessary, right?

283
00:13:45,800 --> 00:13:49,800
And when we need to load an asset and the 4 GB has been filled up,

284
00:13:50,200 --> 00:13:53,800
Need to find room by evicting, right?

285
00:13:53,800 --> 00:13:58,300
We need to evict assets that are currently in their get rid of them,

286
00:13:58,400 --> 00:14:02,400
temporarily to put something else in, and then when those assets are

287
00:14:02,400 --> 00:14:05,500
needed again, they will be reloaded, right?

288
00:14:07,000 --> 00:14:11,200
And so you can see why garbage collection doesn't help us here,

289
00:14:12,000 --> 00:14:14,900
because garbage collection, doesn't solve this problem, right?

290
00:14:14,900 --> 00:14:17,200
This is a inherently, a virtual memory problem.

291
00:14:17,300 --> 00:14:19,800
And what we want to do is essentially say, well, we always have a

292
00:14:19,800 --> 00:14:21,600
handle to all the Assets in some sense.

293
00:14:21,700 --> 00:14:22,900
None of them are ever garbage.

294
00:14:23,100 --> 00:14:26,800
But we only want you to have one's resident that are ones that we

295
00:14:26,800 --> 00:14:31,200
believe ourselves to need in the in the in the immediate frame or in

296
00:14:31,200 --> 00:14:33,800
you know, frames that are coming up within the next second or two.

297
00:14:33,900 --> 00:14:34,400
Right?

298
00:14:34,900 --> 00:14:36,600
But things that are going to be used in

299
00:14:36,900 --> 00:14:37,800
Thirty minutes.

300
00:14:38,000 --> 00:14:41,900
We don't need to have those in memory right now so you don't need to

301
00:14:41,900 --> 00:14:42,900
store them, right?

302
00:14:46,600 --> 00:14:47,000
Okay.

303
00:14:49,100 --> 00:14:54,700
So ways we can ways we can choose out on this right?

304
00:14:56,100 --> 00:14:59,800
so, what this means and again to underscore, why the garbage

305
00:15:00,000 --> 00:15:00,900
Doesn't help you.

306
00:15:01,200 --> 00:15:03,900
And also in fact, I'll show you why both doesn't help you.

307
00:15:03,900 --> 00:15:06,300
So we have, you know, we talked about two things here.

308
00:15:06,300 --> 00:15:08,000
I was like, we were we've been using Stacks.

309
00:15:08,200 --> 00:15:10,900
Other people say garbage collection, woohoo, right?

310
00:15:10,900 --> 00:15:11,500
Or whatever.

311
00:15:12,000 --> 00:15:13,800
So why did neither of those two Loops?

312
00:15:13,800 --> 00:15:15,200
Two solutions work for us.

313
00:15:15,200 --> 00:15:18,800
Why don't stacks and or Garbage Collection work for us.

314
00:15:19,000 --> 00:15:19,600
Right.

315
00:15:19,900 --> 00:15:23,000
Well, the reason is because if we have four gigabytes of memory,

316
00:15:23,400 --> 00:15:29,900
right, then what we've got in that 40 bytes of memory is some

317
00:15:30,000 --> 00:15:31,700
Ooping of stuff in there, right?

318
00:15:31,700 --> 00:15:36,300
We've got acid a acid be at sea ssds iesf or whatever, right?

319
00:15:36,700 --> 00:15:38,000
In a garbage collected system.

320
00:15:38,000 --> 00:15:40,300
We have handles into these, right?

321
00:15:40,900 --> 00:15:45,000
And what we would need to do in order to make room for the new assets

322
00:15:45,000 --> 00:15:47,800
to come in, is we would have to tell the garbage collector that we no

323
00:15:47,800 --> 00:15:48,400
longer need.

324
00:15:48,400 --> 00:15:49,100
Be right?

325
00:15:49,100 --> 00:15:52,000
So we need to basically free be right?

326
00:15:52,300 --> 00:15:55,000
So garbage collection doesn't help us because we have to explicitly,

327
00:15:55,000 --> 00:15:55,900
tell it to get rid of that.

328
00:15:55,900 --> 00:15:57,700
Otherwise, it would still just pile up.

329
00:15:58,800 --> 00:16:01,900
And the same thing is through true of the stack, as the stack gets

330
00:16:01,900 --> 00:16:03,100
pushed on there, right?

331
00:16:03,400 --> 00:16:08,500
ABCDEF, right, or whatever, we need to tell it to free one of these

332
00:16:08,500 --> 00:16:09,600
guys, right?

333
00:16:09,800 --> 00:16:10,500
Would freebie.

334
00:16:10,500 --> 00:16:15,200
And it would know to get rid of be right in either of these cases.

335
00:16:16,700 --> 00:16:17,200
Sure.

336
00:16:17,400 --> 00:16:20,300
We could then say well, okay, you know, that's good enough, right?

337
00:16:20,300 --> 00:16:22,800
I mean, yes we have to do free so maybe it's not garbage collection

338
00:16:22,800 --> 00:16:24,900
but now it's a heat or something right now.

339
00:16:24,900 --> 00:16:26,600
It's like well, we're still could do it.

340
00:16:26,600 --> 00:16:29,300
We could say freebie, or we could say, freaky free this thing or

341
00:16:29,300 --> 00:16:30,100
whatever, right?

342
00:16:30,600 --> 00:16:31,500
Not exactly.

343
00:16:32,000 --> 00:16:35,000
The reason for that is because when we free something out of the

344
00:16:35,000 --> 00:16:40,100
inside of an asset pool like this or inside of the stack, right?

345
00:16:40,200 --> 00:16:44,400
We end up in a situation where it leaves a hole, it leaves a hole in

346
00:16:44,400 --> 00:16:45,000
the memory.

347
00:16:45,600 --> 00:16:49,300
And in order to put something else in that hole, the thing that going

348
00:16:49,300 --> 00:16:52,000
going into the hole has to be smaller than it, right?

349
00:16:52,600 --> 00:16:56,100
But what happens when I put something or the same size, what happens

350
00:16:56,100 --> 00:16:58,200
when I put something smaller than it in?

351
00:16:59,000 --> 00:17:02,500
Is that now I've left an even smaller hole that probably nothing could

352
00:17:02,500 --> 00:17:03,500
go in or very few.

353
00:17:03,500 --> 00:17:04,900
Things could go in, right?

354
00:17:05,200 --> 00:17:06,900
And this is called fragmentation.

355
00:17:09,099 --> 00:17:12,700
And fragmentation is exactly the problem that you get, when the size

356
00:17:12,700 --> 00:17:16,500
of the memory that you have is, is very constrained.

357
00:17:16,500 --> 00:17:20,400
So, I've got four gigabytes of memory, and I'm using 4, gigabytes of

358
00:17:20,400 --> 00:17:21,700
memory, right?

359
00:17:22,200 --> 00:17:26,599
Fragmentation is a big problem because what happens is over time,

360
00:17:26,599 --> 00:17:28,900
you'll do stuff like, oh, I allocated this memory.

361
00:17:29,000 --> 00:17:31,900
And then I freed the memory and I loaded something else in.

362
00:17:31,900 --> 00:17:35,700
So I had, you know, just this part used, but I had already put

363
00:17:35,700 --> 00:17:36,800
something in after it.

364
00:17:36,800 --> 00:17:38,700
So now this part right,

365
00:17:38,900 --> 00:17:41,000
Is the is free, right?

366
00:17:41,300 --> 00:17:44,700
But this thing sticks around and now like I do some other stuff.

367
00:17:44,700 --> 00:17:48,100
I like free and real like this thing and then I end up with like some

368
00:17:48,100 --> 00:17:51,900
other swiss cheese in here and suddenly my total memory size starts

369
00:17:51,900 --> 00:17:55,100
going down from 4 GB with these sort of holes in there, too.

370
00:17:55,100 --> 00:17:57,900
Like, oh, and I've only got 3 GB because I've got all these holes in

371
00:17:57,900 --> 00:17:59,900
there that are you know, sort of taking it up and

372
00:18:00,000 --> 00:18:02,600
Can't free this asset because it's in use or whatever blah blah blah

373
00:18:02,600 --> 00:18:03,700
blah blah, right?

374
00:18:05,000 --> 00:18:08,500
So fragmentation is a huge problem where you're trying to maximally

375
00:18:08,500 --> 00:18:12,600
fill this space that you've got you constantly run into these problems

376
00:18:12,600 --> 00:18:15,800
where you're like, ah crap, you know, I can't

377
00:18:18,500 --> 00:18:21,900
I can't just free one resource and put another resources in this

378
00:18:21,900 --> 00:18:22,300
place.

379
00:18:22,300 --> 00:18:26,200
If they're not the same size, I leave these little fragments and who

380
00:18:26,200 --> 00:18:30,200
knows, how long it'll be before, I can actually start to do something

381
00:18:30,200 --> 00:18:31,300
with those, right?

382
00:18:32,900 --> 00:18:35,400
And so again, yeah, garbage collectors, don't address this at all,

383
00:18:37,100 --> 00:18:38,100
neither do stacks.

384
00:18:38,400 --> 00:18:41,100
But what's underneath could write?

385
00:18:41,100 --> 00:18:45,900
So a garbage collector, could be built on top of a memory allocator

386
00:18:45,900 --> 00:18:47,800
that does try to address this, right?

387
00:18:48,300 --> 00:18:50,000
Similarly, for our usage.

388
00:18:50,100 --> 00:18:52,900
We could imagine doing something similar like, building something

389
00:18:53,200 --> 00:18:54,200
underneath it.

390
00:18:54,200 --> 00:18:55,700
Which does handle this, right?

391
00:18:57,100 --> 00:19:00,000
So let's talk about that and that's that's really what I want to talk

392
00:19:00,000 --> 00:19:00,700
about today.

393
00:19:01,200 --> 00:19:02,100
How much time we got here.

394
00:19:02,100 --> 00:19:06,600
So 35, we're going to 15 after something like this, so 6:15.

395
00:19:06,600 --> 00:19:09,100
So yeah, we got, we got plenty of time.

396
00:19:09,100 --> 00:19:09,900
We got 40 minutes,

397
00:19:11,600 --> 00:19:13,600
Okay 40 minutes.

398
00:19:13,700 --> 00:19:18,800
Alright yeah we got 40 minutes so yeah so let's talk about this

399
00:19:18,800 --> 00:19:19,300
problem.

400
00:19:21,200 --> 00:19:26,200
In a world, in a world, in a world where all the assets were the same

401
00:19:26,200 --> 00:19:26,800
size.

402
00:19:27,000 --> 00:19:29,600
We would be very, very happy campers, right?

403
00:19:29,800 --> 00:19:32,700
Because let's say, all of our assets were the same size in our memory

404
00:19:32,700 --> 00:19:33,400
pool, right?

405
00:19:33,400 --> 00:19:36,300
So this is our, these are active assets.

406
00:19:37,500 --> 00:19:43,500
So if all the assets are the same size a,b,c,d,e, then when I need to

407
00:19:43,500 --> 00:19:44,800
load a new asset, right?

408
00:19:44,800 --> 00:19:46,500
I need to load asset f.

409
00:19:46,600 --> 00:19:48,600
It is exactly the same size as everything else.

410
00:19:48,600 --> 00:19:50,800
So what I can do is I can look and see.

411
00:19:51,000 --> 00:19:53,100
Which of these assets is the oldest.

412
00:19:53,400 --> 00:19:56,400
But the one that hasn't been used in the most number of frames, let's

413
00:19:56,400 --> 00:19:56,700
say

414
00:19:58,700 --> 00:20:04,100
and I can take that evict it, right, and stick the new one in its

415
00:20:04,100 --> 00:20:04,600
place.

416
00:20:05,000 --> 00:20:06,100
So we get rid of asset.

417
00:20:06,100 --> 00:20:09,500
See if that's the oldest, let's say, and we put asset evidence place,

418
00:20:09,700 --> 00:20:11,200
there is no fragmentation.

419
00:20:11,200 --> 00:20:15,000
Everything is always used perfectly because however, much space.

420
00:20:15,000 --> 00:20:16,900
There is let's say there's four gigabytes of space.

421
00:20:17,000 --> 00:20:20,900
If every asset is, you know, I don't know, 256, Meg's or something?

422
00:20:21,100 --> 00:20:23,400
Then I know I have space for 16 assets.

423
00:20:23,500 --> 00:20:25,400
I'm always storing exactly, 16 assets.

424
00:20:25,600 --> 00:20:28,300
Whenever I get a new asset, I evict the oldest of

425
00:20:28,500 --> 00:20:32,400
16 and put it in its place and the memory is always guaranteed to be

426
00:20:32,400 --> 00:20:34,100
used maximally and perfectly.

427
00:20:35,500 --> 00:20:36,900
No problem, right?

428
00:20:37,400 --> 00:20:42,000
And this is why fixed-size allocators, right?

429
00:20:42,800 --> 00:20:43,600
Are really great.

430
00:20:44,200 --> 00:20:46,600
Any problem that you can turn into a fixed size.

431
00:20:46,600 --> 00:20:51,600
Allocation problem is really fantastic because it will allow you to,

432
00:20:51,600 --> 00:20:56,100
basically do perfect management of the memory, never have any

433
00:20:56,100 --> 00:20:57,000
fragmentation.

434
00:20:57,600 --> 00:20:59,900
It's very, very simple and straightforward and we've seen

435
00:21:00,000 --> 00:21:02,900
Before we've done it with a free list and I remember, we did free

436
00:21:02,900 --> 00:21:07,900
lists where we just reuse blocks of that size to kind of just like,

437
00:21:07,900 --> 00:21:10,900
you know, when we free, we just keep the old ones around and then

438
00:21:10,900 --> 00:21:11,300
reuse them.

439
00:21:11,300 --> 00:21:14,100
Again, that's a classic example of a nice fixed size allocator.

440
00:21:14,100 --> 00:21:15,900
They're so simple, and they work.

441
00:21:15,900 --> 00:21:16,900
Great, right.

442
00:21:21,700 --> 00:21:22,900
So, our problem.

443
00:21:24,500 --> 00:21:27,700
We kind of have two ways you can go with it, right?

444
00:21:28,200 --> 00:21:31,200
What we want to do is we want to handle the solution.

445
00:21:31,400 --> 00:21:35,000
We want to handle the situation where these assets are not the same

446
00:21:35,000 --> 00:21:35,500
size.

447
00:21:37,800 --> 00:21:38,800
So, how do we do that?

448
00:21:39,400 --> 00:21:45,000
Well, the first thing that we can look at right is the fact that we

449
00:21:45,000 --> 00:21:49,600
could choose to make this into a fixed size, allocation problem,

450
00:21:50,000 --> 00:21:50,500
right?

451
00:21:50,600 --> 00:21:55,000
That is actually an option that we do have, and the way that we would

452
00:21:55,000 --> 00:21:59,400
do that, for example, is, let's say you just flat-out decided that all

453
00:21:59,400 --> 00:22:01,500
Sprites are 256 by 256.

454
00:22:02,500 --> 00:22:08,100
Right, let's just say you just said that if that was the case, then

455
00:22:08,100 --> 00:22:10,600
all of our bitmaps would be the same size.

456
00:22:11,300 --> 00:22:15,600
And at that point, it would be pretty darn easy for us to go ahead and

457
00:22:15,700 --> 00:22:18,900
load the bitmaps on top of each other.

458
00:22:18,900 --> 00:22:22,600
Because when we freed one, we would free exactly the same the amount

459
00:22:22,600 --> 00:22:25,900
of space we would need to load the new in it, right?

460
00:22:27,300 --> 00:22:28,800
So that's pretty compelling.

461
00:22:29,400 --> 00:22:34,200
The problem with that is that doesn't really necessarily do a good job

462
00:22:34,200 --> 00:22:36,700
of representing what we actually want, right?

463
00:22:36,800 --> 00:22:38,400
It doesn't make sense for us to force.

464
00:22:38,400 --> 00:22:42,400
All of our bitmaps to conform to this size because you know, some of

465
00:22:42,400 --> 00:22:43,100
them are larger.

466
00:22:43,100 --> 00:22:45,900
Some of them are smaller, it would be wasting space or whatever, you

467
00:22:45,900 --> 00:22:46,900
know, if we did that.

468
00:22:48,100 --> 00:22:50,400
And so the other thing we could do is we could say, well, okay, we

469
00:22:50,400 --> 00:22:52,100
could tile things, right?

470
00:22:52,100 --> 00:22:54,300
We could make it so that everything was in tiles.

471
00:22:54,400 --> 00:22:56,800
So, you know, if we have the hero or something like that,

472
00:22:57,100 --> 00:22:58,800
Said of the hero just being one bitmap.

473
00:22:58,800 --> 00:23:00,000
That was a certain size.

474
00:23:00,000 --> 00:23:03,200
We broke it up into ones that were 256 by 256, right?

475
00:23:05,600 --> 00:23:10,900
So if you want a 512 by 512 hero or something like this, you break

476
00:23:10,900 --> 00:23:12,700
them up in interviews expect of you styles.

477
00:23:13,700 --> 00:23:15,200
It's an option, right?

478
00:23:15,400 --> 00:23:17,500
You still have some wastage, right?

479
00:23:17,500 --> 00:23:20,700
You still have, you know, times when it's going to be too big?

480
00:23:20,700 --> 00:23:26,600
Like if the hero was only supposed to be 270 by 283, or whatever,

481
00:23:26,700 --> 00:23:27,200
right?

482
00:23:27,300 --> 00:23:29,600
Well, you got ton of wastage now, because you've got, you know, the

483
00:23:29,600 --> 00:23:33,200
hero only taking up, you know, maybe that much of your four tiles and

484
00:23:33,200 --> 00:23:34,900
there's all this empty space there, right?

485
00:23:35,400 --> 00:23:38,200
But there's even stuff that we could do to try to mitigate that,

486
00:23:38,200 --> 00:23:38,600
right?

487
00:23:38,800 --> 00:23:41,300
And to sort of, give you an idea of one way to mitigate that.

488
00:23:45,100 --> 00:23:46,900
One option that we easily could do.

489
00:23:48,300 --> 00:23:53,500
It's a let's pretend the game is one gigantic Sprite sheet, right?

490
00:23:53,600 --> 00:23:56,800
And all of the Sprites are like packed into the Sprite sheet.

491
00:24:00,900 --> 00:24:06,100
Not by hand, but by an automated process.

492
00:24:06,400 --> 00:24:12,000
And then the Sprite sheet is just broken up, you know, into 256 by 256

493
00:24:12,000 --> 00:24:12,500
tiles.

494
00:24:12,900 --> 00:24:15,900
Then when we say we want to load a Sprite, we just have to figure out

495
00:24:15,900 --> 00:24:17,100
which set of tiles.

496
00:24:17,700 --> 00:24:20,100
It needs and we load those in.

497
00:24:20,100 --> 00:24:24,900
And then all of the tiles are always 256 by 256 in the, you know, in

498
00:24:24,900 --> 00:24:28,600
this tiling scheme and that's like, very similar to like, you know, a

499
00:24:28,600 --> 00:24:30,500
mega texture scheme, basically, right?

500
00:24:30,700 --> 00:24:33,600
That's very similar to a sparse virtual texture.

501
00:24:35,500 --> 00:24:37,400
And it has some Merit, right?

502
00:24:37,500 --> 00:24:40,200
It's definitely has some Merit to it.

503
00:24:40,300 --> 00:24:42,400
So I wouldn't necessarily dismiss out of hand.

504
00:24:44,600 --> 00:24:46,400
We could do something like that, right.

505
00:24:46,400 --> 00:24:50,800
But there are, there are concerns around this, right?

506
00:24:51,400 --> 00:24:52,900
The biggest concern around doing things.

507
00:24:52,900 --> 00:24:55,700
This way, is what you do about mipmapping.

508
00:24:55,900 --> 00:24:59,200
For example, because mipmapping gets very difficult than schemes like

509
00:24:59,200 --> 00:25:02,100
this for reasons that I don't really think we necessarily want to go

510
00:25:02,100 --> 00:25:05,200
into detail here, but there are reasons why?

511
00:25:05,300 --> 00:25:07,300
Might not do it now with a 2-D game.

512
00:25:09,400 --> 00:25:11,500
It's possible that we could get away with it right.

513
00:25:11,600 --> 00:25:14,200
You know 2D game is totally possible that we could get away with it

514
00:25:14,600 --> 00:25:18,000
because in a 2-D game you know what the mips are ahead of time you

515
00:25:18,000 --> 00:25:21,300
don't have to do like trilinear and you don't have to have a lot of

516
00:25:21,300 --> 00:25:25,100
angular stuff going on, where the mid-levels going to change across a

517
00:25:25,100 --> 00:25:26,100
single polygon.

518
00:25:26,500 --> 00:25:32,800
So it's actually plausible in a lot of cases to do a scheme like this

519
00:25:32,800 --> 00:25:33,500
for a 2-D game.

520
00:25:33,600 --> 00:25:34,200
I think.

521
00:25:37,100 --> 00:25:39,000
So, yeah, so I'm just going to put that out there.

522
00:25:39,000 --> 00:25:44,900
So that's one thing that we could choose to do and what that does just

523
00:25:44,900 --> 00:25:49,600
to be clear, is it doesn't quite get you entirely out of the business

524
00:25:50,300 --> 00:25:52,300
of having your assets, be different sizes.

525
00:25:52,500 --> 00:25:56,300
Because even though it now means that the actual page able asset that

526
00:25:56,300 --> 00:25:58,500
you're working with is to is all the same size.

527
00:25:58,500 --> 00:25:59,700
So we have a uniform size.

528
00:25:59,700 --> 00:26:05,000
For the page will ask that which is a tile, what it doesn't do.

529
00:26:05,400 --> 00:26:09,800
Is fix the problem with the asset tile list, right?

530
00:26:09,800 --> 00:26:11,600
So we still have the case that asset.

531
00:26:11,600 --> 00:26:15,000
A, if it was a 512 by 512 asset, right?

532
00:26:15,100 --> 00:26:17,100
It's got four tiles in it.

533
00:26:17,500 --> 00:26:23,100
But asset be that was 256 by 256 that only has one tile in it, right?

534
00:26:23,300 --> 00:26:27,300
So you still have a variable size to your assets.

535
00:26:27,900 --> 00:26:31,400
This one requires four indices into the tile table and this one

536
00:26:31,400 --> 00:26:35,200
requires one but because 256 by

537
00:26:35,300 --> 00:26:36,900
I 256 by 4, right?

538
00:26:36,900 --> 00:26:45,300
The actual size of the Sprite data is well to put a fine to put not to

539
00:26:45,300 --> 00:26:46,800
put too fine a point on it, right?

540
00:26:46,800 --> 00:26:58,400
But 256 x, 256 is 64th, you know, K right 64 K times 4 is 64 K more

541
00:26:58,500 --> 00:26:59,800
than what it takes to store an

542
00:27:00,400 --> 00:27:01,200
Right.

543
00:27:01,400 --> 00:27:06,700
And so what you can choose to do is just not page the tile set, right?

544
00:27:06,700 --> 00:27:10,700
So the thing that stores, the asset tile list could just be loaded in

545
00:27:10,700 --> 00:27:11,700
memory at startup.

546
00:27:11,800 --> 00:27:13,800
It's probably pretty small you know like the okay.

547
00:27:13,800 --> 00:27:16,100
So it's a 10 megabyte thing or something like this.

548
00:27:16,600 --> 00:27:19,900
You just load that in once and you're done and then you're just paging

549
00:27:19,900 --> 00:27:22,900
in the tiles as necessary, right?

550
00:27:28,200 --> 00:27:29,400
So that's one thing we could do.

551
00:27:32,700 --> 00:27:36,700
And as I'm saying it to myself, I am kind of wondering if that's not

552
00:27:36,700 --> 00:27:38,700
the best solution, right?

553
00:27:39,100 --> 00:27:43,700
Like, I don't know if that's a smarter solution to the problem than

554
00:27:44,100 --> 00:27:48,100
then what I was going to propose here but

555
00:27:51,900 --> 00:27:52,700
I'll keep God.

556
00:27:54,600 --> 00:27:59,300
So, our other option, right is to do a regular alligator, right?

557
00:28:00,400 --> 00:28:03,900
So if we do sort of, for lack of a better term of variable,

558
00:28:05,700 --> 00:28:08,400
Allocator one, that can allocate things of variable sizes.

559
00:28:09,100 --> 00:28:11,900
What we can do is say, okay, we've got our memory here, right?

560
00:28:11,900 --> 00:28:13,300
So we've got our four gigabytes.

561
00:28:13,800 --> 00:28:15,600
And what we would do is we would go in here.

562
00:28:15,600 --> 00:28:20,700
We would allocate a chunk of memory for a resource, you know, an asset

563
00:28:20,700 --> 00:28:26,500
a right and then we will go here and you know allocate 1 B and then

564
00:28:26,500 --> 00:28:29,200
going here and allocate 1 C, right?

565
00:28:29,600 --> 00:28:35,400
If later on we then deallocate be, lets say,

566
00:28:35,600 --> 00:28:35,900
Right.

567
00:28:35,900 --> 00:28:37,000
So be goes away.

568
00:28:38,900 --> 00:28:44,200
And we put something else in it, so in comes a new asset D.

569
00:28:45,400 --> 00:28:48,700
We've lost the ability to kind of use this space, because it's like

570
00:28:48,700 --> 00:28:51,600
maybe two tiny now to really load much of an asset in there.

571
00:28:52,300 --> 00:28:56,700
So this space has become fragmented, then what we can do, we have

572
00:28:56,700 --> 00:28:57,500
really two choices.

573
00:28:57,500 --> 00:29:01,000
Actually, one thing we can do is because our assets immune system is

574
00:29:01,000 --> 00:29:04,900
already in directed because the asset table itself points into these

575
00:29:04,900 --> 00:29:07,900
things and people always reference assets through the asset table.

576
00:29:08,500 --> 00:29:11,600
We can then start to do some kind of compaction, like we could move,

577
00:29:11,600 --> 00:29:13,800
see up to close in that space, right?

578
00:29:13,900 --> 00:29:16,200
We have the ability to basically do defragmentation.

579
00:29:17,100 --> 00:29:20,000
So that's one thing we can actually move stuff around in here.

580
00:29:21,000 --> 00:29:24,300
But the other thing that we could do to is as stuff, gets freed, we

581
00:29:24,300 --> 00:29:27,200
can do the standard stuff that you do in a very well allocator, which

582
00:29:27,200 --> 00:29:29,200
is we would actually condense on free.

583
00:29:29,200 --> 00:29:32,300
So when you start to free stuff when you get you know you get this

584
00:29:32,300 --> 00:29:36,300
little space in here, if C then we're to get freed, we would record

585
00:29:36,300 --> 00:29:38,200
the fact that these phases would be merged.

586
00:29:38,300 --> 00:29:41,800
Aged so instead of thinking that there was a sea space, you know, a

587
00:29:41,800 --> 00:29:47,100
see size space and a b - D size space to be used.

588
00:29:47,200 --> 00:29:51,500
We would now know that we have space, that's the, you know, actually a

589
00:29:51,500 --> 00:29:57,300
B minus D plus C size space to use which is a bunch more open Memory,

590
00:29:57,500 --> 00:29:58,000
right?

591
00:30:00,800 --> 00:30:01,400
So, yeah.

592
00:30:01,600 --> 00:30:02,400
So

593
00:30:04,100 --> 00:30:06,800
Probably the thing that I say that we might as well just go ahead and

594
00:30:06,800 --> 00:30:11,700
do because it's possibly a good exercise to sort of go through the

595
00:30:11,700 --> 00:30:13,300
steps of making a variable allocator.

596
00:30:13,300 --> 00:30:18,400
So you can see how one works because at the end of the day, that is

597
00:30:18,400 --> 00:30:22,500
what malloc and free, what new and delete, you know what these things

598
00:30:22,500 --> 00:30:26,400
do and it's also if you're in a garbage collector language, it's what

599
00:30:26,400 --> 00:30:29,600
the thing underneath, the Hood in a garbage collector has to do too,

600
00:30:29,600 --> 00:30:32,300
because, remember underneath the garbage collection layer, you still

601
00:30:32,300 --> 00:30:33,700
have to have something that can do.

602
00:30:34,100 --> 00:30:38,300
Random size, free Alec and free, right?

603
00:30:38,300 --> 00:30:40,900
Because that the lower level, the garbage collector, still needs to be

604
00:30:40,900 --> 00:30:45,300
able to you know we use memory efficiently otherwise it's going to be

605
00:30:45,300 --> 00:30:47,200
a really bad garbage collector, right?

606
00:30:51,200 --> 00:30:57,500
So yeah, so I kind of felt like that was the right thing to do for our

607
00:30:57,500 --> 00:31:01,900
asset system even though it, you know, maybe it's not the smartest way

608
00:31:01,900 --> 00:31:03,800
to do, if the

609
00:31:04,000 --> 00:31:06,800
You were strictly doing was like how do we make the world's best asset

610
00:31:06,800 --> 00:31:07,400
system?

611
00:31:07,800 --> 00:31:11,400
I feel like this may be the right thing to do in terms of the

612
00:31:11,400 --> 00:31:14,800
educational aspect of it because I feel like it would be good for us

613
00:31:14,800 --> 00:31:17,100
to just do one of these as part of handmade hero.

614
00:31:17,100 --> 00:31:20,500
So everyone kind of has a chance to play around with it.

615
00:31:20,500 --> 00:31:23,600
And you get to watch me kind of go through building one and seeing how

616
00:31:23,600 --> 00:31:28,000
it goes and what happens because it really is kind of the lowest level

617
00:31:28,000 --> 00:31:33,700
allocator that everything has to run on top of at some level and

618
00:31:33,900 --> 00:31:36,100
So it's probably kind of useful for that.

619
00:31:36,900 --> 00:31:41,200
And so what we would do for this again is we would make our system

620
00:31:41,200 --> 00:31:43,700
work pretty similar to how it's working.

621
00:31:43,700 --> 00:31:48,000
Now where as you go through, you know, when you call load bitmap, it

622
00:31:48,000 --> 00:31:49,700
goes ahead and allocate stuff.

623
00:31:50,100 --> 00:31:54,400
But what we would then do is we would put sort of a cap on its

624
00:31:54,400 --> 00:31:56,800
allocation limit on its allocation size.

625
00:31:57,000 --> 00:32:01,400
So when it gets up to some number of gigabytes, right?

626
00:32:01,400 --> 00:32:03,700
However, much we set aside for asset storage

627
00:32:04,400 --> 00:32:09,000
When it gets up to 1 GB or whatever, we said it will then have to free

628
00:32:09,000 --> 00:32:15,600
enough, other stuff to basically give it space if you will, you know,

629
00:32:16,300 --> 00:32:20,600
sort of give it space to ensure that it's never going to use over that

630
00:32:20,600 --> 00:32:22,600
one gigabyte amount, right?

631
00:32:24,400 --> 00:32:25,100
So that's it.

632
00:32:25,500 --> 00:32:27,100
That's all we're talking about.

633
00:32:27,400 --> 00:32:28,900
Nothing more complicated than that.

634
00:32:29,300 --> 00:32:31,300
It's pretty straightforward really.

635
00:32:32,000 --> 00:32:33,700
And yeah.

636
00:32:34,100 --> 00:32:38,100
And so, all of the Finesse is really just in constructing.

637
00:32:38,100 --> 00:32:41,900
The thing that actually does this, there's nothing particularly

638
00:32:41,900 --> 00:32:44,000
conceptually Difficult about what's going on.

639
00:32:44,100 --> 00:32:47,200
It's just a very finicky kind of a thing because it's about placing

640
00:32:47,200 --> 00:32:50,600
things and looking through structures to see where, you know, if

641
00:32:50,600 --> 00:32:53,700
there's free space and whether you can fit something in or would it be

642
00:32:53,700 --> 00:32:54,100
smarter to

643
00:32:54,200 --> 00:32:55,000
Put it somewhere else.

644
00:32:55,000 --> 00:32:58,500
And, you know, it's just kind of this nasty if that kind of a sort of

645
00:32:58,500 --> 00:32:59,800
nasty finicky code.

646
00:33:00,300 --> 00:33:06,600
And so, you know, while there's nothing particularly tricky about the

647
00:33:06,600 --> 00:33:10,600
high-concept, when you actually start getting down to, how do I do a

648
00:33:10,600 --> 00:33:11,500
good job at this?

649
00:33:11,700 --> 00:33:14,100
It can be kind of tortured and weird, right?

650
00:33:14,100 --> 00:33:17,500
And to some degree, it's sort of a black art, I believe to, you know,

651
00:33:17,500 --> 00:33:20,700
I don't tend to write much code that goes through variable allocators.

652
00:33:20,700 --> 00:33:24,400
So, I'm actually not the best person to say, what the state of the art

653
00:33:24,400 --> 00:33:26,200
is, in terms of variable occurs.

654
00:33:26,200 --> 00:33:29,300
But my experience with them in the past has been roughly, that, it's

655
00:33:29,300 --> 00:33:29,900
sort of a black

656
00:33:30,100 --> 00:33:34,100
Cart sort of a thing where it's like, yeah, there's certain allocation

657
00:33:34,100 --> 00:33:38,400
scheme seemed to be pretty good at the kinds of stuff that people do

658
00:33:38,400 --> 00:33:39,300
with allocation.

659
00:33:40,600 --> 00:33:41,300
Right.

660
00:33:42,100 --> 00:33:46,100
And so, you know, you'll see people saying, you know, oh I used DL

661
00:33:46,100 --> 00:33:48,800
Malik or whatever and it was good for this workload is the it's just

662
00:33:48,800 --> 00:33:52,400
like these are just like arbitrary schemes that people kind of tuned

663
00:33:52,400 --> 00:33:55,200
to be good at arbitrary workloads.

664
00:33:56,700 --> 00:34:00,700
That they were testing and had good performance in terms of not taking

665
00:34:00,700 --> 00:34:04,500
too long to find out where things should go and being able to use a

666
00:34:04,500 --> 00:34:07,500
reason a lot of memory without too much wastage right without leaving

667
00:34:07,500 --> 00:34:11,100
lots of empty space and all these sorts of other things, right?

668
00:34:11,699 --> 00:34:16,800
All right, so we've got about 24 minutes something like that, 24

669
00:34:16,800 --> 00:34:17,600
minutes left.

670
00:34:18,000 --> 00:34:24,000
So what I wanted to do was go into the system and try to figure out a

671
00:34:24,000 --> 00:34:24,300
way.

672
00:34:24,300 --> 00:34:26,199
I'm not 100% certain

673
00:34:26,400 --> 00:34:30,800
How we will do this, but try to figure out a good way to make it so

674
00:34:30,800 --> 00:34:36,199
that we will run out of memory in our asset system, right?

675
00:34:37,699 --> 00:34:42,699
So if we take a look down here a base, I want to us to assert.

676
00:34:43,400 --> 00:34:46,699
So, when we say memory index size here, when we allocate the sub

677
00:34:46,699 --> 00:34:51,600
Arena, that's what we're going to use for our our system here.

678
00:34:52,199 --> 00:34:55,199
I'm going to, I'm just going to go ahead and tell it to allocate

679
00:34:55,199 --> 00:34:56,400
something really small.

680
00:34:56,800 --> 00:34:57,300
Right?

681
00:34:57,400 --> 00:35:01,100
So it's like oh yeah you know, one megabyte or 2 MB or something like

682
00:35:01,100 --> 00:35:01,400
this.

683
00:35:01,700 --> 00:35:04,500
And I just want to get it to the point where it goes ahead and asserts

684
00:35:04,900 --> 00:35:07,400
so that it doesn't, you know, it can't actually live.

685
00:35:07,600 --> 00:35:11,900
Would all of the memory that it would would want, right?

686
00:35:16,100 --> 00:35:16,600
There we go.

687
00:35:18,100 --> 00:35:24,200
So you know, at some point here I turned the character, you know, and

688
00:35:24,200 --> 00:35:26,100
it came in here and it decided, right?

689
00:35:26,100 --> 00:35:30,600
And you can even see here it is with the heroes head or Cape or

690
00:35:30,600 --> 00:35:31,100
whatever.

691
00:35:31,700 --> 00:35:34,600
At some point, I turned the character and that was enough to like,

692
00:35:34,600 --> 00:35:36,800
blow out that size, right?

693
00:35:36,900 --> 00:35:38,400
So that's exactly what I want.

694
00:35:38,400 --> 00:35:43,000
This is what I want some situation where we artificially constrained.

695
00:35:43,000 --> 00:35:45,800
So that even with a small number of assets that were currently

696
00:35:45,900 --> 00:35:49,600
Working with, we will hit that hard cap and we can start to play

697
00:35:49,600 --> 00:35:50,800
around with what to do.

698
00:35:51,000 --> 00:35:54,700
When we hit it, I forgot that we left the particle system on there,

699
00:35:55,200 --> 00:35:58,000
that is kind of ridiculous, obviously.

700
00:36:05,800 --> 00:36:07,900
Particle systems are so damn funny.

701
00:36:11,400 --> 00:36:14,800
I'm for those of you who missed it on Thursday and Friday, we added a

702
00:36:14,800 --> 00:36:15,800
particle system.

703
00:36:15,800 --> 00:36:18,700
I just we were kind of I said, what should we do for a fun diversion

704
00:36:18,700 --> 00:36:20,800
and particle system was on the list.

705
00:36:20,800 --> 00:36:25,100
So we added this and you can't tell me.

706
00:36:25,100 --> 00:36:26,100
That's not hilarious.

707
00:36:26,500 --> 00:36:28,300
That is just, that is just hilarious.

708
00:36:28,300 --> 00:36:31,500
All right, so yeah, okay.

709
00:36:32,500 --> 00:36:36,300
So here's what we need to start thinking about, let's let's, let's

710
00:36:36,300 --> 00:36:37,300
start this process here.

711
00:36:37,300 --> 00:36:39,900
Let's recover from the humor of seeing a bunch of weird little

712
00:36:40,100 --> 00:36:42,600
He had spew out of our heroes abdomen.

713
00:36:44,100 --> 00:36:50,000
So we've got the asset system and the the asset system itself has this

714
00:36:50,000 --> 00:36:50,800
memory Arena.

715
00:36:51,000 --> 00:36:54,100
And so it's allocating things on this memory Rina.

716
00:36:54,100 --> 00:36:58,200
And what we want to be able to do is we want to be able to have some

717
00:36:58,200 --> 00:36:59,200
kind of an opinion.

718
00:37:00,600 --> 00:37:04,100
About when we need to free memory and like, how much Headroom?

719
00:37:04,100 --> 00:37:05,100
We need their, right?

720
00:37:05,100 --> 00:37:12,200
So, let's take care of a few really basic things, first that we kind

721
00:37:12,200 --> 00:37:14,500
of need to, to address, right?

722
00:37:14,500 --> 00:37:20,200
So one thing that I was thinking about is for our assets, Lots, I

723
00:37:20,200 --> 00:37:24,100
wanted to think about whether we wanted to expand the assets.

724
00:37:24,100 --> 00:37:29,200
Lot set to, you know, how much memory would it take to, to expand the

725
00:37:29,200 --> 00:37:30,600
assets lot set to just have

726
00:37:30,700 --> 00:37:32,200
The data in itself.

727
00:37:32,700 --> 00:37:35,300
And so what I'm going to do here is I'm going to go in and I'm going

728
00:37:35,300 --> 00:37:39,100
to take a look at what the loaded bitmap stuff does and I'll show you

729
00:37:39,100 --> 00:37:39,900
what I'm talking about here.

730
00:37:39,900 --> 00:37:44,000
So if you take a look at the the loaded bitmap stuff and you can

731
00:37:44,000 --> 00:37:46,400
ignore the five-minute warning because like I said, we got 15 extra

732
00:37:46,400 --> 00:37:47,300
minutes on the clock today.

733
00:37:47,300 --> 00:37:49,800
So we've got 20 minutes.

734
00:37:50,300 --> 00:37:52,400
It was a long question day-to-day, it start.

735
00:37:58,700 --> 00:38:01,700
yeah, so if you take a look here, if we just take a quick look at

736
00:38:03,000 --> 00:38:05,500
What we're looking at, in terms of loaded bitmap, you can see there,

737
00:38:05,500 --> 00:38:08,200
that's what the loaded bitmap looks like, with the little bit map

738
00:38:08,200 --> 00:38:08,400
code.

739
00:38:08,400 --> 00:38:11,500
Looks like we need to store with over height.

740
00:38:12,000 --> 00:38:16,000
We need to sort of the alignment percentages for where the bitmap

741
00:38:16,000 --> 00:38:16,900
should be centered.

742
00:38:17,700 --> 00:38:21,500
We need to store the width and the height of the actual bitmap itself

743
00:38:21,700 --> 00:38:23,100
and we needed to store the pitch.

744
00:38:23,300 --> 00:38:24,900
Those are the things that we need to store.

745
00:38:25,700 --> 00:38:30,500
Now my assumption and I could be very wrong about this, is that pitch

746
00:38:30,600 --> 00:38:32,100
actually doesn't need to be Stewart.

747
00:38:32,500 --> 00:38:32,600
My

748
00:38:32,800 --> 00:38:35,500
Option is that we could just make a rule about how you compute the

749
00:38:35,500 --> 00:38:39,100
pitch from the height and that from now, I'm sorry from the with, and

750
00:38:39,100 --> 00:38:41,600
then from, so we could get rid of that, right?

751
00:38:41,800 --> 00:38:42,800
So that could go away.

752
00:38:45,800 --> 00:38:47,100
So let's try that first.

753
00:38:47,300 --> 00:38:50,900
And again, what I'm trying to do here just to say it again, are what

754
00:38:50,900 --> 00:38:54,700
we have in our game as we have this assets lat and we have as many of

755
00:38:54,700 --> 00:38:55,800
them as we have assets.

756
00:38:56,400 --> 00:38:59,800
And right now, they store their essentially, a 12 B thing.

757
00:39:00,200 --> 00:39:00,600
Right?

758
00:39:00,800 --> 00:39:06,100
If they were packed which is they have a 32-bit State variable which

759
00:39:06,100 --> 00:39:08,600
does not in any way need to actually be 32 bits.

760
00:39:08,600 --> 00:39:11,400
If you actually look at how big it is, that's totally not necessary,

761
00:39:11,500 --> 00:39:12,200
right?

762
00:39:13,200 --> 00:39:19,000
And then they've got pointers out to whatever the actual data.

763
00:39:19,000 --> 00:39:21,100
Is that would be there, right?

764
00:39:21,200 --> 00:39:24,200
And so there are 12, bytes, or something like that.

765
00:39:24,800 --> 00:39:28,500
What I'm wondering is, could we just get rid of loaded bitmap?

766
00:39:29,200 --> 00:39:29,800
I'm sorry, I could get

767
00:39:30,000 --> 00:39:32,600
Rid of the pointers and actually put loaded bitmap and loaded sound

768
00:39:32,600 --> 00:39:33,900
directly into the asset slot.

769
00:39:33,900 --> 00:39:35,000
So that it's just always there.

770
00:39:35,500 --> 00:39:36,700
Why do I want to do that?

771
00:39:36,900 --> 00:39:40,100
I want to do that because it means that assets are only the size that

772
00:39:40,100 --> 00:39:42,000
they actually are from then on.

773
00:39:42,200 --> 00:39:44,900
So we don't have to constantly think about allocating.

774
00:39:46,200 --> 00:39:49,500
How loaded bitmap structure 2.2 and then have that point to the

775
00:39:49,500 --> 00:39:50,500
memory, right?

776
00:39:50,500 --> 00:39:53,300
I'm just removing a little bit of indirection there because what you

777
00:39:53,300 --> 00:39:54,200
see happen?

778
00:39:55,800 --> 00:39:59,600
If we actually go to load bitmap or something like that, right?

779
00:39:59,700 --> 00:40:02,900
Is you see that first we push, we do a push truck for loaded bitmap

780
00:40:02,900 --> 00:40:07,800
into the arena and then we do a push size for the memory that we

781
00:40:07,800 --> 00:40:08,500
actually need.

782
00:40:08,500 --> 00:40:10,100
So I wanted to get it down to just the memory.

783
00:40:10,100 --> 00:40:13,200
So we know that assets, take the size that they are, whatever their

784
00:40:13,200 --> 00:40:15,800
size is is what they take, right?

785
00:40:17,700 --> 00:40:18,000
So yeah.

786
00:40:18,000 --> 00:40:20,500
So I just want to condense these structures down and see if I can put

787
00:40:20,500 --> 00:40:21,000
them in there.

788
00:40:21,500 --> 00:40:23,100
So let's think about that pitch.

789
00:40:23,200 --> 00:40:25,400
You know do we actually need to store that?

790
00:40:25,600 --> 00:40:29,200
So let's go ahead and see if we can get rid of it, right?

791
00:40:31,600 --> 00:40:34,600
So what I'd like to do is just replace that with a thing that's like

792
00:40:34,600 --> 00:40:36,900
get pitch, right?

793
00:40:36,900 --> 00:40:38,500
Some function that we just call.

794
00:40:38,600 --> 00:40:43,200
So every time the pitch is talked about, we actually just do, like,

795
00:40:43,200 --> 00:40:46,100
you'd get pitch called, write something like this.

796
00:40:47,600 --> 00:40:49,700
And so, I guess, you know, now that I look at it too.

797
00:40:50,100 --> 00:40:51,700
I could already see what the problem is going to be.

798
00:40:51,700 --> 00:40:54,900
So I wonder if we want to do one more step before we do this, which is

799
00:40:54,900 --> 00:40:55,400
that are

800
00:40:55,500 --> 00:40:58,800
Our when we're actually writing to stuff, those are technically loaded

801
00:40:58,800 --> 00:41:01,700
bitmaps as well because we don't have a we don't distinguish between

802
00:41:01,700 --> 00:41:02,800
the two of those things.

803
00:41:03,400 --> 00:41:08,700
So the actual problem is going to be how we handle buffers.

804
00:41:08,700 --> 00:41:10,900
We write to if that makes sense.

805
00:41:12,000 --> 00:41:14,900
And so I feel like what we would almost want to do is do something

806
00:41:14,900 --> 00:41:18,200
like struct like a writable bitmap, right?

807
00:41:19,000 --> 00:41:23,100
And that thing has an extra pitch on it that the other ones don't have

808
00:41:23,400 --> 00:41:24,100
that make sense.

809
00:41:24,600 --> 00:41:25,400
I may try to do

810
00:41:25,600 --> 00:41:27,700
At, let's do something simpler first though.

811
00:41:27,900 --> 00:41:29,600
Since I can see that, that's going to be a little bit of problem.

812
00:41:29,600 --> 00:41:30,800
So we'll try that first.

813
00:41:30,900 --> 00:41:32,100
We'll try something else first.

814
00:41:32,200 --> 00:41:36,800
So, first of all, width and height right now, can be 4 billion by four

815
00:41:36,800 --> 00:41:37,300
billion.

816
00:41:37,600 --> 00:41:40,900
So there's really no, well, two billion, they're signed, there's

817
00:41:40,900 --> 00:41:42,500
really no need for that, right?

818
00:41:42,500 --> 00:41:44,100
That is not at all necessary.

819
00:41:44,300 --> 00:41:45,100
I don't feel like.

820
00:41:45,700 --> 00:41:48,800
So one thing we could also do here is, we could choose to store this

821
00:41:49,200 --> 00:41:50,700
in a much smaller way.

822
00:41:50,800 --> 00:41:53,700
Now, eight bits isn't going to cut it because to Pieces by 26 is too

823
00:41:53,700 --> 00:41:55,400
small but 16 bits would

824
00:41:55,500 --> 00:41:56,800
Certainly be fine, right?

825
00:41:56,800 --> 00:41:59,500
64000 by 64,000 is bigger than any bitmap.

826
00:41:59,500 --> 00:41:59,900
We're

827
00:42:00,000 --> 00:42:03,800
Haven't handmade hero, because our screen is not even that big.

828
00:42:05,000 --> 00:42:09,200
So that would be kind of Overkill, in fact, our screen would most be

829
00:42:09,200 --> 00:42:09,900
like 4K.

830
00:42:09,900 --> 00:42:12,400
So we'd be talking about sixty four by four.

831
00:42:12,500 --> 00:42:16,700
We talking about a Sprite that was 16 screens wide not going to

832
00:42:16,700 --> 00:42:18,000
happen, right?

833
00:42:18,300 --> 00:42:21,700
So, we could change these guys to 16 bit and we wouldn't miss it

834
00:42:22,000 --> 00:42:22,500
right.

835
00:42:23,200 --> 00:42:25,400
That would be totally fine, right?

836
00:42:25,900 --> 00:42:31,200
And so that gets us down to two, three, four, five, and then the

837
00:42:31,200 --> 00:42:33,200
pointer 67, right?

838
00:42:33,900 --> 00:42:34,600
And so, we

839
00:42:34,800 --> 00:42:40,400
Also of course, change the pitch, also be one of those and then I'm

840
00:42:40,400 --> 00:42:45,500
not sure that we could really do much else we need these guys to be

841
00:42:45,500 --> 00:42:47,000
float, right?

842
00:42:47,800 --> 00:42:50,300
So yeah, we really want to get rid of the pitch because that would

843
00:42:50,300 --> 00:42:53,400
leave us dangling at 16, which we don't really want to do.

844
00:42:54,400 --> 00:42:57,400
So that would be for what we really want to do is get it to this.

845
00:42:57,400 --> 00:43:03,300
Because then what we have is essentially two floats, one, float 2016.

846
00:43:03,300 --> 00:43:04,600
So it would be like for

847
00:43:04,700 --> 00:43:08,300
44 B, things or 16 bytes, and then the pointer

848
00:43:10,100 --> 00:43:10,500
Right.

849
00:43:16,500 --> 00:43:17,500
That would I think be

850
00:43:19,700 --> 00:43:21,900
Probably what we would want, right?

851
00:43:24,100 --> 00:43:27,600
So that'd be good and if we were down to that, right?

852
00:43:27,600 --> 00:43:31,300
If we were down to that, that's basically just talking about for you.

853
00:43:31,300 --> 00:43:34,800
That's talking about 16, bytes extra per asset.

854
00:43:36,200 --> 00:43:38,200
And we could also do a little snuggling there.

855
00:43:38,400 --> 00:43:42,300
We could snuggle that up a bit because if you think about what happens

856
00:43:42,300 --> 00:43:45,500
with this assets lot, we have this asset stayed in there, that asset

857
00:43:45,500 --> 00:43:51,000
State could probably be stuffed into here somehow in a relatively, you

858
00:43:51,000 --> 00:43:56,500
know, in a relatively sort of cozy, fashion, if you will, right, in

859
00:43:56,500 --> 00:43:57,800
fact, if I did it like this,

860
00:44:00,100 --> 00:44:06,000
Now, the asset State could easily just be a u16 and and off you go,

861
00:44:06,100 --> 00:44:06,700
right?

862
00:44:06,900 --> 00:44:09,600
Of course, the only problem is, we do atomic rights to that guy.

863
00:44:14,000 --> 00:44:15,100
Yeah, not sure.

864
00:44:15,100 --> 00:44:15,700
You'll find out.

865
00:44:15,700 --> 00:44:18,100
S, let's find out.

866
00:44:18,600 --> 00:44:19,000
Okay.

867
00:44:20,000 --> 00:44:20,800
So here we go.

868
00:44:23,000 --> 00:44:24,400
Let's see.

869
00:44:24,400 --> 00:44:24,800
I think we do.

870
00:44:24,800 --> 00:44:25,300
Am I?

871
00:44:25,300 --> 00:44:26,800
So that guy could be wrong.

872
00:44:27,100 --> 00:44:29,300
Yeah, we do at our gross that guy, right?

873
00:44:30,000 --> 00:44:30,900
So that's no good.

874
00:44:31,400 --> 00:44:32,500
So that's no good.

875
00:44:32,500 --> 00:44:36,600
So, that guy has to stay as a youth order to basically will have to

876
00:44:36,900 --> 00:44:39,800
have to play around with that a little bit because we we could do

877
00:44:39,800 --> 00:44:41,400
stuff to make that, not be an issue.

878
00:44:42,000 --> 00:44:43,800
All right, so let's go in here.

879
00:44:44,900 --> 00:44:45,400
All of these.

880
00:44:45,400 --> 00:44:46,700
I think we just want to do.

881
00:44:46,700 --> 00:44:47,100
Oops.

882
00:44:50,400 --> 00:44:52,200
We want to just do a safe truncation.

883
00:44:52,200 --> 00:44:54,200
I don't know if we've got a safe truncation there.

884
00:44:54,900 --> 00:44:56,900
Let's let's actually take a look and see if we do.

885
00:44:57,200 --> 00:44:59,800
There's made transics trunk.

886
00:45:00,000 --> 00:45:00,500
it's

887
00:45:02,000 --> 00:45:04,300
I'm a platform truncate.

888
00:45:04,500 --> 00:45:05,000
Here we go.

889
00:45:05,700 --> 00:45:08,700
So what we want to do is something here where we can safely truncate

890
00:45:08,700 --> 00:45:14,800
something from a 32 you know some kind of a 32-bit value.

891
00:45:15,000 --> 00:45:17,700
I'm sorry 32-bit value down to a 16 byte value.

892
00:45:18,000 --> 00:45:22,800
Just so we can ensure that you know it's not going to be that we

893
00:45:22,800 --> 00:45:25,500
didn't accidentally truncate something that we actually wanted.

894
00:45:25,700 --> 00:45:26,200
Right?

895
00:45:26,800 --> 00:45:29,500
So we want to do something like you know we want.

896
00:45:30,000 --> 00:45:31,200
What is it 65536.

897
00:45:31,400 --> 00:45:34,000
My to, we want 32 768.

898
00:45:36,600 --> 00:45:42,000
We want to make sure that it's greater than then 32 cents 58 and less

899
00:45:42,000 --> 00:45:47,800
than 32767 because we know that we'll be able to be stored in a 16-bit

900
00:45:47,800 --> 00:45:51,600
integer, so we can go ahead then and cast it down, right?

901
00:45:52,300 --> 00:45:55,800
Although, I guess I think about it, if we do a safe truncate,

902
00:45:57,900 --> 00:46:01,800
if we did something like safe truncate to you and 16, then really,

903
00:46:01,800 --> 00:46:03,700
what we want to do is something more like this.

904
00:46:03,700 --> 00:46:10,100
We want to be less than 6 5, 5 3, 6 or 5 and greater than 0 because we

905
00:46:10,100 --> 00:46:12,000
want to truncated in that way, right?

906
00:46:12,600 --> 00:46:16,000
So that that's a little more that's that's more what we were trying to

907
00:46:16,000 --> 00:46:16,400
do there.

908
00:46:17,300 --> 00:46:22,900
Okay so in this case that should be fine, we'll keep that result there

909
00:46:23,700 --> 00:46:26,200
and then we can just go ahead and do these safe truncations.

910
00:46:26,200 --> 00:46:26,900
So there we go.

911
00:46:28,200 --> 00:46:28,800
Right.

912
00:46:33,200 --> 00:46:36,800
And yeah, and you can see that that pitch is very easy to compute in

913
00:46:36,800 --> 00:46:37,200
here.

914
00:46:37,200 --> 00:46:39,900
So we know that we can do it for everything except for bitmaps

915
00:46:39,900 --> 00:46:40,500
basically.

916
00:46:41,300 --> 00:46:41,600
All right.

917
00:46:41,600 --> 00:46:42,200
So why don't you ask?

918
00:46:42,200 --> 00:46:44,400
No Object file generated?

919
00:46:45,000 --> 00:46:48,300
Initializing conversion from you and 32 to you and 16?

920
00:46:51,200 --> 00:46:52,400
That is just a typo.

921
00:46:54,300 --> 00:46:54,700
Okay?

922
00:46:55,700 --> 00:46:59,300
So these guys again are also safe truncations.

923
00:47:00,900 --> 00:47:01,400
so,

924
00:47:05,900 --> 00:47:07,800
and one more time.

925
00:47:12,200 --> 00:47:18,900
Okay, so that should just be fine and of course, we should still crash

926
00:47:18,900 --> 00:47:23,500
whenever it will not crash but we should assert that as soon as I use

927
00:47:23,500 --> 00:47:24,300
enough bitmaps.

928
00:47:25,100 --> 00:47:25,600
Okay.

929
00:47:26,200 --> 00:47:30,800
And so, inside asset here, let's go ahead and just finish this off.

930
00:47:31,100 --> 00:47:36,900
So for loaded sound, the same thing would be true, right?

931
00:47:38,000 --> 00:47:41,200
I'm going to go ahead and say that the sample count and the channel

932
00:47:41,200 --> 00:47:41,800
count.

933
00:47:42,300 --> 00:47:46,400
Could be shrunk quite a bit and what I would assume is the sample

934
00:47:46,400 --> 00:47:49,000
count, you know, does it really need to be a 32-bit value?

935
00:47:49,000 --> 00:47:50,400
Could it be a 24-bit value?

936
00:47:50,800 --> 00:47:54,200
So what I might say to do here is could we go ahead and pack these?

937
00:47:54,700 --> 00:47:59,400
So that basically we have you know, sample count is 24 and channel

938
00:47:59,400 --> 00:47:59,800
count

939
00:48:00,300 --> 00:48:03,500
You know, is, is it even less, right?

940
00:48:03,500 --> 00:48:06,900
The channel, count could be four bits, and the sample count could be

941
00:48:06,900 --> 00:48:08,900
28 bits or something like that, right?

942
00:48:09,000 --> 00:48:13,400
So, if we packed those guys together, again, that would keep it even

943
00:48:13,400 --> 00:48:14,000
smaller.

944
00:48:14,100 --> 00:48:18,300
And so, then it would be basically the same size as, as the load a bit

945
00:48:18,300 --> 00:48:19,400
Maps as well, right?

946
00:48:21,500 --> 00:48:23,100
Although now that I think about it, it might be at the load.

947
00:48:23,100 --> 00:48:24,500
A bitmap is still a little bit bigger.

948
00:48:25,000 --> 00:48:29,300
Let me take a look at that certain render group so loaded bitmap.

949
00:48:29,600 --> 00:48:31,500
It's got one pointer one pointer.

950
00:48:32,200 --> 00:48:36,500
Then these two guys would encounter another pointer so then you've got

951
00:48:36,500 --> 00:48:39,600
the R32 which account for it.

952
00:48:39,600 --> 00:48:40,000
So yeah.

953
00:48:40,000 --> 00:48:42,700
So basically the loaded bitmaps, always a little bit bigger so I

954
00:48:42,700 --> 00:48:46,900
suppose we don't really have to do that one because in since they're

955
00:48:46,900 --> 00:48:49,100
both stored in a union, right?

956
00:48:49,900 --> 00:48:51,100
Unless I could get them.

957
00:48:51,300 --> 00:48:52,600
Look down to a smaller size.

958
00:48:52,600 --> 00:48:54,500
It wouldn't really matter, right?

959
00:48:55,800 --> 00:49:01,700
So I'll just play to do in here to do if the loaded and also, we don't

960
00:49:01,700 --> 00:49:02,700
even need two pointers.

961
00:49:02,700 --> 00:49:13,100
So the loaded sound, this could be shrunk to 12 B if the loaded

962
00:49:14,600 --> 00:49:18,000
Bitmap ever got down that small.

963
00:49:19,400 --> 00:49:19,800
Right.

964
00:49:21,700 --> 00:49:26,000
So yeah, that's all I want to just mention there, we don't need to go

965
00:49:26,000 --> 00:49:28,700
totally crazy with it but it's something we could probably do a little

966
00:49:28,700 --> 00:49:32,200
bit more of and you know what, I'll put one into this to where I'm

967
00:49:32,200 --> 00:49:33,800
like just to do

968
00:49:36,500 --> 00:49:40,600
Get rid of pitch and we'll try that in a second potentially.

969
00:49:41,600 --> 00:49:44,900
All right, so what I want to do now is I want to just make these guys

970
00:49:44,900 --> 00:49:47,000
actually stored, right?

971
00:49:48,400 --> 00:49:51,300
So instead of being pointers, they're just actually going to be stored

972
00:49:51,300 --> 00:49:53,500
in there and we'll make the asset State be.

973
00:49:53,500 --> 00:49:56,100
The only thing that actually determines whether you can use them or

974
00:49:56,100 --> 00:49:57,800
not, which I think we already did.

975
00:49:57,800 --> 00:50:01,700
Like we already did this check right to make sure that the thing was

976
00:50:01,700 --> 00:50:02,000
loaded.

977
00:50:02,000 --> 00:50:03,600
So I think we're totally fine on that.

978
00:50:03,700 --> 00:50:06,700
So basically all we're doing here is making it so that it's going to

979
00:50:06,700 --> 00:50:08,600
use it out of there directly.

980
00:50:09,700 --> 00:50:14,400
And we no longer have to do a push struct on these guys, what we can

981
00:50:14,400 --> 00:50:18,100
do instead is just take, whatever was in that.

982
00:50:18,300 --> 00:50:22,100
Slot and use what was in the slot, right?

983
00:50:23,400 --> 00:50:23,900
So yeah.

984
00:50:24,300 --> 00:50:26,100
So we can go ahead and take this.

985
00:50:26,100 --> 00:50:30,300
In fact, we can probably do this at the top here where we just kind of

986
00:50:30,300 --> 00:50:36,700
go like asset slot, slot equals whatever the slot is like.

987
00:50:36,700 --> 00:50:40,300
So I guess we don't have to do that until we actually use this thing

988
00:50:41,000 --> 00:50:44,000
and then in here we can just you know we you know what, we could

989
00:50:44,000 --> 00:50:48,000
probably even just do it like this because it's not invalid.

990
00:50:48,200 --> 00:50:49,300
You just do the computation.

991
00:50:49,300 --> 00:50:51,600
We're never going to access it, unless it actually is valid.

992
00:50:51,700 --> 00:50:53,500
We can just come in here and say, okay.

993
00:50:55,100 --> 00:50:57,600
You know, instead of actually doing this, we can just do it off the

994
00:50:57,600 --> 00:50:59,800
slot pointer like so right.

995
00:51:01,100 --> 00:51:05,900
So, now when we want to use this, and I guess I could do this here

996
00:51:05,900 --> 00:51:07,300
slot unloaded.

997
00:51:08,700 --> 00:51:09,400
So now

998
00:51:10,700 --> 00:51:14,400
When we come in here, I can just say that the bitmap is just the slot

999
00:51:14,400 --> 00:51:19,000
bitmap and there's you don't have to do anything, right?

1000
00:51:19,200 --> 00:51:22,400
And that means that we don't use up any additional memory and all this

1001
00:51:22,400 --> 00:51:24,300
stuff should just work fine, right?

1002
00:51:24,900 --> 00:51:27,400
So I can go and compel that I think that's really all we need to do

1003
00:51:29,700 --> 00:51:33,000
and this doesn't actually need to happen at all, right?

1004
00:51:34,200 --> 00:51:35,500
Then in here, the same is true.

1005
00:51:35,600 --> 00:51:39,300
We don't actually need to do that anymore but we do need to actually

1006
00:51:39,300 --> 00:51:40,100
pull out that slot

1007
00:51:40,700 --> 00:51:46,100
so here it is, then we can, you know in here take that

1008
00:51:47,600 --> 00:51:48,700
Use that slots now.

1009
00:51:48,700 --> 00:51:51,400
It's it's already been kind of pre-addressed for us.

1010
00:51:52,000 --> 00:51:56,600
And in here we can avoid ever doing that that allocation for the

1011
00:51:56,600 --> 00:51:57,100
sound.

1012
00:51:57,400 --> 00:52:00,200
So I'm just going to take the address of the sound that's already

1013
00:52:00,200 --> 00:52:03,400
there for us to fill in and use it, right?

1014
00:52:06,300 --> 00:52:10,400
So there we go, and while we're doing this, I think I might go ahead

1015
00:52:10,400 --> 00:52:14,000
and turn the music back on just, so I can hear that still loading

1016
00:52:14,000 --> 00:52:14,300
properly.

1017
00:52:14,300 --> 00:52:17,500
In case we make a false move, that makes it.

1018
00:52:17,500 --> 00:52:19,400
So that our music stops playing.

1019
00:52:19,600 --> 00:52:21,600
That would just be a good thing to keep in mind.

1020
00:52:21,700 --> 00:52:22,300
So, there we go.

1021
00:52:27,300 --> 00:52:27,900
Aha.

1022
00:52:29,500 --> 00:52:31,400
And of course, just loading.

1023
00:52:31,400 --> 00:52:36,400
The music was enough to blow out our amount of space that we said we

1024
00:52:36,400 --> 00:52:36,800
can use.

1025
00:52:36,800 --> 00:52:38,800
Let's try and change it to 3 megabytes.

1026
00:52:41,600 --> 00:52:46,000
So now, just by virtue of playing the music well or creating the guy,

1027
00:52:46,000 --> 00:52:47,400
we blow out the arena, right?

1028
00:52:47,400 --> 00:52:48,100
So that's good.

1029
00:52:48,400 --> 00:52:48,900
Okay.

1030
00:52:52,200 --> 00:52:53,200
So, all that's nice.

1031
00:52:54,300 --> 00:52:55,800
And now what we need to know

1032
00:52:57,000 --> 00:53:01,400
I is, we need to have some way of now determining ahead of time.

1033
00:53:05,300 --> 00:53:06,500
when we are going to,

1034
00:53:07,600 --> 00:53:09,800
Hit our load limit, right?

1035
00:53:13,900 --> 00:53:17,800
And this is actually trickier than you might think the reason this is

1036
00:53:17,800 --> 00:53:18,900
trickier than you might think.

1037
00:53:18,900 --> 00:53:21,900
And the reason that we're going to have to probably introduce

1038
00:53:21,900 --> 00:53:23,100
something somewhat fancy.

1039
00:53:24,500 --> 00:53:28,600
And you know, when I say fancy, it's not that fancy but and I should

1040
00:53:28,600 --> 00:53:32,500
probably know if I should end now, or if I should explain it, I'll

1041
00:53:32,500 --> 00:53:34,600
give you a little preview and then we'll do it tomorrow.

1042
00:53:35,500 --> 00:53:37,300
So, what needs to happen now, right?

1043
00:53:38,200 --> 00:53:45,200
Is we need to have some kind of a situation where when we are full and

1044
00:53:45,200 --> 00:53:47,400
we have something that we want to put in here, right?

1045
00:53:47,400 --> 00:53:49,800
We're saying we got to load an asset and it's going to take a

1046
00:53:49,800 --> 00:53:51,100
megabyte, right?

1047
00:53:51,500 --> 00:53:53,200
But we don't have a megabyte of space.

1048
00:53:54,600 --> 00:53:58,100
We then need to be able to start freeing stuff to fit, 1, megabytes,

1049
00:53:58,100 --> 00:53:58,900
worth of space.

1050
00:54:00,400 --> 00:54:02,900
We can't actually free anything.

1051
00:54:04,200 --> 00:54:06,000
at the time, when you call this,

1052
00:54:07,100 --> 00:54:07,600
Why?

1053
00:54:08,400 --> 00:54:11,200
Well, let's see when it gets cold.

1054
00:54:12,700 --> 00:54:16,400
and those of you who are sharp who are watching right now,

1055
00:54:17,700 --> 00:54:19,400
you should know what I'm going to say.

1056
00:54:20,100 --> 00:54:21,400
You should be able to figure it out.

1057
00:54:22,200 --> 00:54:23,600
So I'll give you a little couple seconds.

1058
00:54:24,800 --> 00:54:25,900
Where is this called?

1059
00:54:27,200 --> 00:54:30,000
Where we calling load sound for example, right?

1060
00:54:31,700 --> 00:54:32,500
Well actually you know what?

1061
00:54:32,500 --> 00:54:35,600
Load sounds probably the not the best example because it's we don't

1062
00:54:35,600 --> 00:54:36,800
load probably any sound.

1063
00:54:36,800 --> 00:54:38,400
So let's do little bit map instead.

1064
00:54:38,800 --> 00:54:39,200
Okay.

1065
00:54:39,900 --> 00:54:42,200
So where are we calling load bitmap, right?

1066
00:54:42,700 --> 00:54:46,200
Well, we're crawling little bit map inside push bitmap, right?

1067
00:54:47,300 --> 00:54:51,300
And game update and render is where that gets called.

1068
00:54:52,200 --> 00:54:56,500
Now, the problem is on this Frame, we've already called push bitmap a

1069
00:54:56,500 --> 00:55:01,100
bunch of times, and what happens when we actually call Push bitmap is,

1070
00:55:01,100 --> 00:55:03,500
if the bitmap exists, we use it.

1071
00:55:04,000 --> 00:55:04,800
How do we use it?

1072
00:55:05,000 --> 00:55:09,000
We put it on a list of things that the renderer will go and use.

1073
00:55:10,500 --> 00:55:16,100
So if during this load bitmap call we were to evict an existing

1074
00:55:16,100 --> 00:55:16,800
bitmap.

1075
00:55:17,500 --> 00:55:21,700
We would run the risk of Addicting, a bitmap that is currently being

1076
00:55:21,700 --> 00:55:23,600
used, right?

1077
00:55:25,400 --> 00:55:29,900
So what we would much rather do you know because we can we can try to

1078
00:55:29,900 --> 00:55:33,800
go the route of introducing locking code to bring that from happening.

1079
00:55:34,400 --> 00:55:35,000
Right.

1080
00:55:35,500 --> 00:55:38,900
But rather than doing that, what I'd rather do is say let's introduce

1081
00:55:38,900 --> 00:55:43,900
a controlled time when bitmaps are actually marked us freed

1082
00:55:45,600 --> 00:55:49,300
So that we don't ever free them in the middle of things, right?

1083
00:55:50,000 --> 00:55:53,600
And so there's two ways we can do that one is that when we call load

1084
00:55:53,600 --> 00:55:58,600
bitmap we can put them onto a list of things to be loaded later.

1085
00:55:59,600 --> 00:56:02,900
The other is that we can kick off the tasks immediately at that time,

1086
00:56:03,000 --> 00:56:04,700
using space, we've pre freed

1087
00:56:06,200 --> 00:56:09,400
Okay, we'll say those two again on the Blackboard.

1088
00:56:10,900 --> 00:56:16,800
We can either keep some amount of free space around in here, right?

1089
00:56:17,000 --> 00:56:21,500
So we keep, you know, out of our four gigabytes, we keep, you know, 16

1090
00:56:21,500 --> 00:56:22,200
Meg's free.

1091
00:56:23,100 --> 00:56:24,300
So every frame

1092
00:56:25,400 --> 00:56:29,100
We can kick off tasks that will write to the 16 megabytes.

1093
00:56:29,500 --> 00:56:34,000
And at the end of the frame, we will free back up to 16 megabytes.

1094
00:56:34,000 --> 00:56:37,600
So if we, if we used up some portion of the 60 megabytes of free

1095
00:56:37,600 --> 00:56:40,900
space, we've done will three a bunch of stuff that gets us back to 16

1096
00:56:40,900 --> 00:56:41,800
total mix free.

1097
00:56:41,800 --> 00:56:42,700
Something like that.

1098
00:56:43,000 --> 00:56:48,000
So we always have places to kick off our new slots tasks to write into

1099
00:56:48,700 --> 00:56:50,900
without having to evict things can do that.

1100
00:56:51,100 --> 00:56:54,400
Or we can do is when we do load bitmap calls, we actually defer them

1101
00:56:54,400 --> 00:56:55,000
to the end of the

1102
00:56:55,200 --> 00:56:55,600
frame.

1103
00:56:55,700 --> 00:56:58,300
So when somebody calls the bitmap, we don't kick off the task.

1104
00:56:58,300 --> 00:56:59,800
We just right in all of the bit.

1105
00:57:00,000 --> 00:57:03,500
We wanted to load ABCDEFG, whatever.

1106
00:57:04,000 --> 00:57:06,900
And then at the end of the frame, we say kick off, and it goes through

1107
00:57:06,900 --> 00:57:09,100
and it kicks off all of these to new tasks.

1108
00:57:10,700 --> 00:57:11,200
Right.

1109
00:57:11,800 --> 00:57:13,100
You do either of those two things.

1110
00:57:14,400 --> 00:57:19,700
I would lean towards probably doing the free space one because I'd

1111
00:57:19,700 --> 00:57:24,800
rather kick off the load immediately so that we have the rest of that

1112
00:57:24,800 --> 00:57:29,400
frames render time to get the stuff for that.

1113
00:57:29,400 --> 00:57:31,800
We're missing for the next frame on this, you know.

1114
00:57:32,100 --> 00:57:33,300
So I don't know.

1115
00:57:33,700 --> 00:57:36,600
Like because missing, yeah, I don't know.

1116
00:57:36,700 --> 00:57:39,700
There's a lot of ways we could make that trade-off on the other hand.

1117
00:57:39,700 --> 00:57:40,400
We always pray.

1118
00:57:40,600 --> 00:57:41,400
Want to be precasting.

1119
00:57:41,400 --> 00:57:43,100
Anyway, so this may actually be fine.

1120
00:57:43,600 --> 00:57:51,200
I'm not sure, but either way, I'd like to go to the Q&A because well,

1121
00:57:51,900 --> 00:57:54,400
we talked about a bunch of stuff today and I want to make sure people

1122
00:57:54,400 --> 00:57:56,000
who have questions have a chance to ask them.

1123
00:57:56,300 --> 00:57:59,800
So and I noticed pseudonym 73.

1124
00:57:59,800 --> 00:58:01,400
Sing well, it's official assets are now.

1125
00:58:01,400 --> 00:58:04,900
Handles, I wouldn't say they're now handles.

1126
00:58:04,900 --> 00:58:06,800
I would say they've been there were handles right from the very

1127
00:58:06,800 --> 00:58:08,300
beginning, right?

1128
00:58:08,300 --> 00:58:10,100
Because as soon as we introduce that

1129
00:58:10,500 --> 00:58:16,000
It's lap thing that was when they became handles so they've been

1130
00:58:16,000 --> 00:58:19,800
handled for a while now and that is exactly the way I want them

1131
00:58:20,500 --> 00:58:25,800
because I want the game to be able to always refer to an asset and not

1132
00:58:25,800 --> 00:58:28,200
have to worry if it exists or not, right?

1133
00:58:28,200 --> 00:58:32,000
I don't want the game code to have to think about ownership.

1134
00:58:37,600 --> 00:58:40,600
Will there be a benefit to using a two level cache for storing

1135
00:58:40,600 --> 00:58:42,800
compressed and uncompressed assets?

1136
00:58:44,600 --> 00:58:45,300
Mmm,

1137
00:58:50,600 --> 00:58:54,800
I mean, the answer is certainly that it's possible.

1138
00:58:56,400 --> 00:58:59,200
And I guess I don't know whether the answer would be yes.

1139
00:58:59,200 --> 00:58:59,500
Or no.

1140
00:58:59,500 --> 00:59:02,000
You'd probably it would probably depend on the

1141
00:59:03,200 --> 00:59:03,900
Platform.

1142
00:59:06,500 --> 00:59:10,900
On the PC, I strongly doubt it because you've got so much memory.

1143
00:59:12,500 --> 00:59:17,100
I don't know that and the hard drives are so darn fast, you know?

1144
00:59:20,800 --> 00:59:21,500
on the

1145
00:59:23,800 --> 00:59:25,900
You know, a system for that II.

1146
00:59:25,900 --> 00:59:26,900
Don't know, I'm sorry.

1147
00:59:26,900 --> 00:59:30,300
I really couldn't tell you, I feel like you'd really have to test it

1148
00:59:30,300 --> 00:59:32,600
but I suspect it uncompressed is probably fine.

1149
00:59:36,100 --> 00:59:39,900
Is there any performance reason to not use malloc and free?

1150
00:59:44,000 --> 00:59:48,800
You mean like if we just if we didn't want to?

1151
00:59:51,700 --> 00:59:54,700
Okay, I think I know chasing so you're saying if I didn't want to show

1152
00:59:54,700 --> 00:59:57,700
you how to write one of these, could we just call malloc and free

1153
00:59:57,700 --> 00:59:58,100
here?

1154
00:59:58,300 --> 00:59:59,300
And the answer is yes.

1155
01:00:00,000 --> 01:00:04,600
In fact you could even do that probably even if you didn't want to use

1156
01:00:04,600 --> 01:00:08,100
the C runtime Library, you could just call the platform's malloc and

1157
01:00:08,100 --> 01:00:12,700
free which is like in Windows like keep Alec and Heat free because

1158
01:00:12,900 --> 01:00:16,000
we're making so few allocations you know we're going to make like 16

1159
01:00:16,000 --> 01:00:20,700
allegations of frame or something like that for these asset movements

1160
01:00:20,700 --> 01:00:23,700
or something at that point.

1161
01:00:24,400 --> 01:00:26,200
It doesn't have to be super efficient.

1162
01:00:26,800 --> 01:00:28,200
So so yeah.

1163
01:00:28,200 --> 01:00:32,000
If we didn't want to look at this problem in a little more detail, you

1164
01:00:32,000 --> 01:00:35,500
probably could just call, whatever it doesn't even matter, what new

1165
01:00:35,500 --> 01:00:38,200
and delete malloc and free he palak.

1166
01:00:38,200 --> 01:00:39,000
Keep free.

1167
01:00:39,800 --> 01:00:40,100
I don't know.

1168
01:00:40,100 --> 01:00:44,500
You want to call virtual a lock because that's a little heavy weight,

1169
01:00:45,700 --> 01:00:48,000
but but certainly anything else would probably be fine.

1170
01:00:52,800 --> 01:00:56,600
Are there technical terms for the memory emptiness Assurance

1171
01:00:56,600 --> 01:00:57,300
algorithm?

1172
01:00:58,600 --> 01:01:01,700
Are you talking about like these two things I said here, where like

1173
01:01:01,700 --> 01:01:05,800
you defer to the end of the frame or you leave space to kick off the

1174
01:01:05,800 --> 01:01:06,400
tasks.

1175
01:01:06,900 --> 01:01:11,400
And the answer is I don't know the technical term for those know, I

1176
01:01:11,400 --> 01:01:14,000
don't think I've ever heard some of them refer to those as a specific

1177
01:01:14,000 --> 01:01:14,900
technical term.

1178
01:01:18,300 --> 01:01:19,200
Dual 1,000.

1179
01:01:19,200 --> 01:01:22,700
Can you talk a bit more about what new and delete actually does and

1180
01:01:22,700 --> 01:01:23,700
when to use them.

1181
01:01:24,700 --> 01:01:25,300
Sure.

1182
01:01:25,600 --> 01:01:29,400
So we don't need new and delete on handmade hero because we don't use

1183
01:01:29,500 --> 01:01:34,600
any kinds of C++ features that need them that need to use them.

1184
01:01:35,500 --> 01:01:39,300
But basically, what happens is, you can think about there being sort

1185
01:01:39,300 --> 01:01:46,100
of two steps to constructing a, you can think about two steps to using

1186
01:01:46,100 --> 01:01:47,100
memory, right?

1187
01:01:47,400 --> 01:01:49,500
There's one, there's like getting the memory.

1188
01:01:53,700 --> 01:01:55,800
two, there's initializing the memory

1189
01:02:01,000 --> 01:02:03,900
and then we might as well like those are the two steps but we could

1190
01:02:03,900 --> 01:02:06,700
also throw in step 3 if we want them to which is freeing the memory

1191
01:02:08,100 --> 01:02:08,500
Right?

1192
01:02:08,500 --> 01:02:10,800
Or I should say this, you know, if we're going to do that in, we might

1193
01:02:10,800 --> 01:02:11,800
as well do four steps.

1194
01:02:12,000 --> 01:02:14,900
3D initializing, the memory

1195
01:02:20,400 --> 01:02:21,900
And for freeing the memory.

1196
01:02:24,600 --> 01:02:25,100
Right.

1197
01:02:26,900 --> 01:02:30,600
And so the way to think about the things that you're talking, the

1198
01:02:30,600 --> 01:02:32,800
things you're asking about new and delete, right?

1199
01:02:33,600 --> 01:02:35,800
Is essentially

1200
01:02:37,000 --> 01:02:40,300
If you look at this process, this is Malik.

1201
01:02:41,300 --> 01:02:45,000
Write these two together.

1202
01:02:47,900 --> 01:02:48,600
Our new.

1203
01:02:50,300 --> 01:02:57,100
This here is free and these two together.

1204
01:02:58,900 --> 01:02:59,800
Or delete.

1205
01:03:01,500 --> 01:03:05,900
So basically what C++ tried to do is it tried to formalize steps, two

1206
01:03:05,900 --> 01:03:10,600
and three whereas see only really formalized steps 1 & 4.

1207
01:03:11,300 --> 01:03:13,700
Okay, so this is C.

1208
01:03:13,800 --> 01:03:17,800
This is C + + to make these a little more concrete.

1209
01:03:17,800 --> 01:03:25,200
Let's suppose that I have something here, struct Foo, it has an

1210
01:03:25,200 --> 01:03:27,400
interior bar in it.

1211
01:03:29,000 --> 01:03:33,900
okay, and so if I want to make one of these, that's not on the stack

1212
01:03:34,700 --> 01:03:37,700
that is going to be dynamically allocated from a heap

1213
01:03:38,600 --> 01:03:43,100
The C runtime Library provides you with steps 1 & 4, which is malloc

1214
01:03:43,100 --> 01:03:43,600
and free.

1215
01:03:44,400 --> 01:03:48,400
And what those do is they go to the Heap and they reserved something

1216
01:03:48,400 --> 01:03:51,000
of this size and they return it to you.

1217
01:03:51,300 --> 01:03:59,100
So, when you say Foo star, a equals malloc right size of

1218
01:04:00,200 --> 01:04:00,600
Oops.

1219
01:04:01,900 --> 01:04:08,300
Sighs of Foo, you are asking to do step one, which is to reserve as a

1220
01:04:08,300 --> 01:04:12,100
place in the computer's memory for a food, right?

1221
01:04:12,200 --> 01:04:15,700
And you'd have to cast it here in C++, but in see, you wouldn't cast

1222
01:04:15,700 --> 01:04:17,600
it because the cast is implicit from void.

1223
01:04:18,400 --> 01:04:20,200
So if it was see, it would be this, right?

1224
01:04:21,000 --> 01:04:24,100
But the memory you got back is just garbage.

1225
01:04:24,200 --> 01:04:26,900
It just has whatever is in there, right?

1226
01:04:26,900 --> 01:04:28,300
It's not this.

1227
01:04:28,300 --> 01:04:31,000
Step two was not done for you.

1228
01:04:31,900 --> 01:04:33,400
And then later, right?

1229
01:04:33,400 --> 01:04:39,400
You can imagine calling free on a, which is saying, I no longer need

1230
01:04:39,400 --> 01:04:42,500
the memory that you got here, so put it back into the heat, put it

1231
01:04:42,500 --> 01:04:45,500
back like let it be known that this part of memory doesn't have to be

1232
01:04:45,500 --> 01:04:46,900
reserved anymore that step 4.

1233
01:04:47,500 --> 01:04:48,000
Okay?

1234
01:04:48,100 --> 01:04:48,800
And that's free.

1235
01:04:49,400 --> 01:04:52,800
So that's what see looks like and so when you wrote C code you did

1236
01:04:52,800 --> 01:04:57,400
this, then you did whatever you want to do to initialize the object

1237
01:04:57,400 --> 01:04:59,500
like a bar equals 5.

1238
01:05:01,000 --> 01:05:01,200
Right?

1239
01:05:01,200 --> 01:05:02,400
There's the initialization.

1240
01:05:02,700 --> 01:05:05,500
I'm going to sizing bar 25, I use it.

1241
01:05:05,600 --> 01:05:09,900
And then later, if I have some D initialization to do, I do it in this

1242
01:05:09,900 --> 01:05:10,100
case.

1243
01:05:10,100 --> 01:05:13,400
I don't have any but you can imagine something more complicated there.

1244
01:05:13,400 --> 01:05:14,600
In fact, I guess you know what?

1245
01:05:14,700 --> 01:05:18,500
Let me help illustrate this a little bit better by saying, instead of

1246
01:05:18,500 --> 01:05:19,200
in bar.

1247
01:05:19,200 --> 01:05:20,200
Let's say it's file.

1248
01:05:20,200 --> 01:05:20,900
Star Bar.

1249
01:05:22,800 --> 01:05:23,500
Right.

1250
01:05:23,500 --> 01:05:25,800
So there's actually another thing inside it.

1251
01:05:25,900 --> 01:05:31,700
So an initialization time, I want to do bar equals F open some file

1252
01:05:33,100 --> 01:05:34,700
when I'm done with it, right?

1253
01:05:34,700 --> 01:05:35,700
I then need to close it.

1254
01:05:35,700 --> 01:05:40,900
So I need an F close here, and I need to fclose a bar before freeing

1255
01:05:40,900 --> 01:05:42,300
the memory, right?

1256
01:05:42,800 --> 01:05:46,200
So again, those are the steps, two, and three right here, step one

1257
01:05:46,200 --> 01:05:48,600
here, step to hear step 3 here, step 4.

1258
01:05:49,600 --> 01:05:52,400
And so, what new and delete tried to do in C++?

1259
01:05:52,800 --> 01:05:56,300
Is standardized on this step as a couple.

1260
01:05:56,500 --> 01:05:59,800
So instead of one, two, three, and four being

1261
01:06:00,000 --> 01:06:03,700
Is where one in four were facilitated by the C runtime Library & 2 & 3

1262
01:06:03,700 --> 01:06:04,900
were entirely up to you.

1263
01:06:05,600 --> 01:06:09,200
C++ makes it so that, actually, those things can be bound together.

1264
01:06:10,900 --> 01:06:15,400
So, if we expand this class to have a Constructor Foo, right?

1265
01:06:15,500 --> 01:06:18,500
And a Destructor Foo, right?

1266
01:06:18,500 --> 01:06:21,100
And I'm calling this truck, but remember, struct and class have our.

1267
01:06:21,100 --> 01:06:22,400
There's no difference between these two things.

1268
01:06:22,400 --> 01:06:24,900
The see, they don't, they're exactly the same.

1269
01:06:25,100 --> 01:06:27,700
The only difference is whether things are declared private or public

1270
01:06:27,700 --> 01:06:28,900
by default, that's it.

1271
01:06:29,400 --> 01:06:29,900
So if you

1272
01:06:30,000 --> 01:06:33,000
A public at the top of this thing, there'd be no difference between

1273
01:06:33,000 --> 01:06:36,500
calling the class instruct, so, you know, don't let that confuse you.

1274
01:06:36,700 --> 01:06:38,000
They're literally, they're there.

1275
01:06:38,000 --> 01:06:40,200
It was a meaningless keyword, it was should never have been

1276
01:06:40,200 --> 01:06:40,800
introduced.

1277
01:06:40,900 --> 01:06:42,100
It doesn't actually mean anything.

1278
01:06:42,600 --> 01:06:43,700
It's just a struct.

1279
01:06:43,800 --> 01:06:47,700
The only thing that we have in C and CE os are structs and so class

1280
01:06:47,700 --> 01:06:50,500
was just you know, someone's little mental.

1281
01:06:50,800 --> 01:06:52,100
You know, be honest roster of how to

1282
01:06:53,100 --> 01:06:56,400
You know, unhealthy attraction to similar or something.

1283
01:06:59,800 --> 01:07:00,200
Okay.

1284
01:07:02,100 --> 01:07:04,200
So, we introduced these Constructors and destructors.

1285
01:07:04,200 --> 01:07:08,700
And what they are designed to do is move the understanding of what

1286
01:07:08,700 --> 01:07:13,200
steps two and three are into C++ proper rather than just as something,

1287
01:07:13,200 --> 01:07:14,100
the programmer does.

1288
01:07:14,600 --> 01:07:18,200
So what we do is inside these Constructors, right here is Foose

1289
01:07:18,200 --> 01:07:20,100
Constructor inside the Constructor.

1290
01:07:20,100 --> 01:07:24,500
We actually do, you know, bar equals F open, right?

1291
01:07:24,600 --> 01:07:29,900
And inside the destructor for Foo, we actually do the F close.

1292
01:07:31,000 --> 01:07:33,000
Okay, right.

1293
01:07:34,500 --> 01:07:40,200
So that's what's actually happening in the case of in the case of

1294
01:07:40,200 --> 01:07:41,200
doing the C++ way.

1295
01:07:41,800 --> 01:07:44,400
So steps two and three move into the class, right?

1296
01:07:44,400 --> 01:07:47,600
They move they move in the responsibility for that is no longer in the

1297
01:07:47,600 --> 01:07:47,900
outside.

1298
01:07:47,900 --> 01:07:50,500
It's on the inside of the struct, right?

1299
01:07:51,200 --> 01:07:58,300
And so the reason that C++ had to introduce new and delete was because

1300
01:07:58,400 --> 01:08:04,100
now you needed a way of saying, I want to do a Malik follow.

1301
01:08:04,300 --> 01:08:10,600
By the initialization I wanted to do step one and step two and that is

1302
01:08:10,600 --> 01:08:11,500
what new means.

1303
01:08:11,900 --> 01:08:14,900
And similarly to be symmetric, they needed to introduce a way to say I

1304
01:08:14,900 --> 01:08:17,500
want to do step 3 and step 4.

1305
01:08:17,899 --> 01:08:20,200
And that is what delete means, right?

1306
01:08:20,899 --> 01:08:24,700
So the time when you have to use new and delete is really, very

1307
01:08:24,700 --> 01:08:25,200
simple.

1308
01:08:25,700 --> 01:08:29,700
Did you want the compiler to call the Constructor?

1309
01:08:30,100 --> 01:08:32,399
Did you want the compiler to call the destructor?

1310
01:08:33,000 --> 01:08:33,800
Or didn't you?

1311
01:08:34,600 --> 01:08:35,399
That's it.

1312
01:08:37,000 --> 01:08:41,700
Now, it's worth noting that sometimes you really don't have a choice

1313
01:08:42,200 --> 01:08:43,700
in this struct that I have here.

1314
01:08:43,700 --> 01:08:47,100
It would be trivial for you to balak it and just not, you don't have

1315
01:08:47,100 --> 01:08:50,399
to call new, even if it's got a Constructor in it, if you didn't want

1316
01:08:50,399 --> 01:08:54,200
the Constructor to run, you could just call malloc, right?

1317
01:08:54,800 --> 01:08:55,399
Doesn't matter.

1318
01:08:57,100 --> 01:08:59,800
But suppose you were to introduce a virtual.

1319
01:09:00,000 --> 01:09:05,899
Chen Heaven, help you first, you would get fired from my team but then

1320
01:09:05,899 --> 01:09:12,500
second what would happen is inside this this struct Foo, the compiler

1321
01:09:12,500 --> 01:09:15,300
would silently introduced a pointer to what's called a vtable, which

1322
01:09:15,300 --> 01:09:17,300
is a dispatch table.

1323
01:09:17,399 --> 01:09:21,600
That is how it actually implements virtual functions right now.

1324
01:09:21,600 --> 01:09:26,000
You have no way of initializing that virtual table yourself because

1325
01:09:26,000 --> 01:09:28,300
you don't even know where that you don't know anything about that.

1326
01:09:28,300 --> 01:09:29,600
That's a compiler detail.

1327
01:09:30,000 --> 01:09:30,500
Right?

1328
01:09:31,000 --> 01:09:36,200
And so, one of the things new also does is it initializes any hidden

1329
01:09:36,200 --> 01:09:39,300
information that you did not put there but the compiler did.

1330
01:09:40,000 --> 01:09:45,000
And so if you start using compiler features, C++ features that the

1331
01:09:45,000 --> 01:09:49,300
compiler needs to augment the structure of the class width and which

1332
01:09:49,300 --> 01:09:52,700
have important initialization that has to happen.

1333
01:09:53,500 --> 01:09:55,000
You must call new.

1334
01:09:55,100 --> 01:09:58,700
Even if you don't care about the compiler, calling your Constructor

1335
01:09:58,800 --> 01:09:59,900
because the compiler,

1336
01:10:00,000 --> 01:10:02,500
Are essentially has a Constructor that has to get called.

1337
01:10:03,600 --> 01:10:06,000
And it is the initialization of that V table.

1338
01:10:07,100 --> 01:10:07,500
Okay.

1339
01:10:09,300 --> 01:10:12,400
so yeah, hopefully that gives you some perspective on what new and

1340
01:10:12,400 --> 01:10:14,900
delete are and when you have to call them, the reason we don't need to

1341
01:10:14,900 --> 01:10:17,300
call them in handmade Heroes because I find them be completely

1342
01:10:17,300 --> 01:10:22,100
Superfluous in a relevant because if I wanted a function that both

1343
01:10:22,100 --> 01:10:24,700
Malik to memory and initialize my thing,

1344
01:10:26,200 --> 01:10:28,000
I just write the function.

1345
01:10:28,300 --> 01:10:33,900
I just write a function called a lock and in it and I passed the print

1346
01:10:33,900 --> 01:10:38,100
like new and delete are literally two of the worst ideas I've ever

1347
01:10:38,100 --> 01:10:38,400
seen.

1348
01:10:38,400 --> 01:10:40,300
I have no idea why they were written that way.

1349
01:10:40,300 --> 01:10:41,800
They don't make any sense to me at all.

1350
01:10:42,600 --> 01:10:46,500
They're really, really, really stupid right?

1351
01:10:47,100 --> 01:10:49,100
The correct way to have added them to the language.

1352
01:10:49,100 --> 01:10:53,200
If you wanted to get the features that you were going to to get there.

1353
01:10:55,400 --> 01:10:58,700
I think would have been to just have a way of doing a stack call.

1354
01:10:58,800 --> 01:11:02,000
So saying like the thing that this thing returns is a stack call is is

1355
01:11:02,000 --> 01:11:03,800
on the stack, you know, move semantics.

1356
01:11:03,800 --> 01:11:07,500
Basically as they call them nowadays probably would have been the

1357
01:11:07,500 --> 01:11:09,700
thing to implement because then you wouldn't ever care about these at

1358
01:11:09,700 --> 01:11:09,900
all.

1359
01:11:09,900 --> 01:11:13,300
But yeah, so I never use these because they're literally worthless in

1360
01:11:13,300 --> 01:11:18,300
my opinion, I don't think they ever have a point but like I said, if

1361
01:11:18,300 --> 01:11:21,000
you ever start doing things like virtual function calls, you don't

1362
01:11:21,000 --> 01:11:21,700
have a choice.

1363
01:11:22,300 --> 01:11:24,300
You're going to have to do them now.

1364
01:11:24,300 --> 01:11:24,900
Mind you

1365
01:11:25,100 --> 01:11:28,600
You know, this kind of gets into C++ programming which I don't care

1366
01:11:28,600 --> 01:11:35,100
about but like I said, you know, as much as I bagged on other

1367
01:11:35,100 --> 01:11:38,700
languages like Java and C++ or whatever on the stream that's just

1368
01:11:38,700 --> 01:11:40,400
because I don't like them, right?

1369
01:11:40,400 --> 01:11:43,100
But if you like them, you should use them right?

1370
01:11:43,100 --> 01:11:45,100
You know, there's people should program in the language that they want

1371
01:11:45,100 --> 01:11:45,600
to use.

1372
01:11:46,200 --> 01:11:49,300
So if you are someone who does like C++ in your programming in C++,

1373
01:11:49,300 --> 01:11:50,500
again, keep in mind.

1374
01:11:52,300 --> 01:11:53,500
You do have other options here.

1375
01:11:53,500 --> 01:11:54,900
There's a thing called a placement.

1376
01:11:55,100 --> 01:11:59,900
New right, which is a way of telling the compiler.

1377
01:12:00,000 --> 01:12:03,900
Order to generate the code that it needs to generate to initialize an

1378
01:12:03,900 --> 01:12:06,800
object without allocating the memory, right?

1379
01:12:06,800 --> 01:12:12,300
So, if you want to just do Step 2 or just do step 3, you can actually

1380
01:12:12,300 --> 01:12:12,900
do those.

1381
01:12:13,500 --> 01:12:16,000
And so, if you weren't aware of that, you know, go read about that.

1382
01:12:16,000 --> 01:12:18,400
That's something that is pretty important, to be able to do, if you

1383
01:12:18,400 --> 01:12:22,800
want to do sort of advanced memory management stuff and see, I mean

1384
01:12:22,800 --> 01:12:24,700
C++, it's relevant

1385
01:12:34,300 --> 01:12:37,400
Could you briefly comment on how viable it would be to recast?

1386
01:12:37,400 --> 01:12:40,600
The problem, as one as asset packing, split sounds into fixed size

1387
01:12:40,600 --> 01:12:42,900
chunks and dice bitmaps into fixed size tiles.

1388
01:12:43,200 --> 01:12:45,900
So that all the tiles are a reasonable science group related assets

1389
01:12:45,900 --> 01:12:46,200
together.

1390
01:12:46,200 --> 01:12:48,100
So that they are loaded together that sort of thing.

1391
01:12:49,200 --> 01:12:52,000
So, you're talking about elaborate more than what I said.

1392
01:12:52,000 --> 01:12:58,000
Already back when I talked about the option here, are you talking

1393
01:12:58,000 --> 01:13:01,300
about more students sitting in my you're talking about more than this

1394
01:13:01,300 --> 01:13:02,100
elaboration?

1395
01:13:02,600 --> 01:13:03,600
Because this is what that is.

1396
01:13:04,300 --> 01:13:05,000
Right.

1397
01:13:06,200 --> 01:13:08,300
Mega texture is basically what that is, right?

1398
01:13:08,300 --> 01:13:13,700
It's just you pack all of the assets into a giant bitmap effectively

1399
01:13:14,200 --> 01:13:16,700
and then you break it up into two phases by two basic Styles.

1400
01:13:18,100 --> 01:13:20,600
Then you have to figure out some way that you're going to deal with

1401
01:13:20,600 --> 01:13:24,600
the fact that your assets now have to list variable length tiles in

1402
01:13:24,600 --> 01:13:25,000
them.

1403
01:13:25,100 --> 01:13:27,900
But like I said, that's probably okay because you can probably fit

1404
01:13:27,900 --> 01:13:30,400
that all in memory and flat loaded, the beginning, kind of like we do

1405
01:13:30,400 --> 01:13:31,500
with our asset tags.

1406
01:13:32,300 --> 01:13:33,900
So that's you know, that's rough.

1407
01:13:34,100 --> 01:13:37,700
What that would look like and you do the same thing for sounds.

1408
01:13:37,700 --> 01:13:43,000
You just have a giant sound one giant sound, which is arbitrarily

1409
01:13:43,000 --> 01:13:48,900
long, and you'd break that into chunks of say, you know, I don't know.

1410
01:13:49,300 --> 01:13:51,500
Sixty-four thousand samples or something, right?

1411
01:13:51,800 --> 01:13:53,600
And you just what, you know, what I'd probably do.

1412
01:13:53,600 --> 01:13:55,800
Is I'd make it to I'd make the sound chunks.

1413
01:13:55,800 --> 01:14:00,100
Be 256 by 256 by 4, right?

1414
01:14:00,900 --> 01:14:03,800
I make it be that many bites, right?

1415
01:14:04,300 --> 01:14:07,800
So that everything could be swapped uniformly, right?

1416
01:14:07,800 --> 01:14:12,000
So I make everything, be 256k, everything would be a 256k chunk.

1417
01:14:17,500 --> 01:14:21,900
Is there a real philosophy difference between using smart pointers and

1418
01:14:21,900 --> 01:14:24,400
using garbage collection, or are smart pointers just a way to

1419
01:14:24,400 --> 01:14:25,800
implement garbage collection?

1420
01:14:29,300 --> 01:14:33,400
So, you know, first of all, let's clarify what you mean by smart

1421
01:14:33,400 --> 01:14:35,600
pointers because smart pointers in.

1422
01:14:35,800 --> 01:14:39,300
You know, sometimes you say smart pointers, people think Otto pointer

1423
01:14:40,100 --> 01:14:41,300
right in C++.

1424
01:14:41,600 --> 01:14:47,400
And so, and that's a pointer that like freeze automatically, right,

1425
01:14:48,400 --> 01:14:51,300
and it's worth noting that like that's not the same thing as garbage

1426
01:14:51,300 --> 01:14:51,700
collection.

1427
01:14:51,700 --> 01:14:54,900
Even at a feature level, right?

1428
01:14:55,300 --> 01:14:58,900
Because if you have two things that both Auto,

1429
01:14:59,000 --> 01:14:59,800
Enter to the same.

1430
01:15:00,800 --> 01:15:05,000
Then it's an error because when one gets freed, it'll delete it, and

1431
01:15:05,000 --> 01:15:07,000
the other one was still trying to point to it, right?

1432
01:15:07,300 --> 01:15:12,000
So you can't just use something like an auto pointer and get what

1433
01:15:12,000 --> 01:15:15,100
garbage collection gives you because garbage collection actually gives

1434
01:15:15,100 --> 01:15:17,000
you reference counted pointers right.

1435
01:15:17,900 --> 01:15:22,100
And so smart pointer, if I smart pointer, you mean a pointer which

1436
01:15:22,100 --> 01:15:24,400
does reference counting on the target.

1437
01:15:24,900 --> 01:15:28,000
Then yes, that is a way of implementing.

1438
01:15:28,000 --> 01:15:29,800
What is essentially garbage collection?

1439
01:15:30,000 --> 01:15:30,000
No.

1440
01:15:31,400 --> 01:15:35,400
But it's not the same as a general-purpose garbage collector because

1441
01:15:35,400 --> 01:15:38,300
the jumpers garbage collector, could be a lot more efficient than that

1442
01:15:38,300 --> 01:15:42,800
potentially, because it can know things about the usage patterns that

1443
01:15:42,800 --> 01:15:46,700
that pigeonhole thing that a reference kind of player does can't tell.

1444
01:15:47,200 --> 01:15:47,800
Right.

1445
01:15:50,300 --> 01:15:54,300
So I would say, philosophically speaking garbage, collection isn't

1446
01:15:54,300 --> 01:15:57,100
super different from reference counted pointers.

1447
01:15:57,400 --> 01:15:58,100
That's true.

1448
01:16:00,100 --> 01:16:05,400
But you know, there's also the concept of of liveness and how it

1449
01:16:05,400 --> 01:16:08,900
actually gets how that actually gets handled.

1450
01:16:10,100 --> 01:16:10,700
so,

1451
01:16:17,200 --> 01:16:19,100
there's kind of an island concept, right?

1452
01:16:19,100 --> 01:16:23,100
So, I'll just sketch it out, briefly, it's stupid.

1453
01:16:23,100 --> 01:16:28,100
But, so let's say, I have object, a, and object B.

1454
01:16:29,600 --> 01:16:34,100
Right object, a stores, a pointed object, B, be stored as a pointed

1455
01:16:34,100 --> 01:16:34,500
object.

1456
01:16:34,500 --> 01:16:39,900
A right, I've got a pointer to both A and B, okay?

1457
01:16:39,900 --> 01:16:43,900
So let's pretend that this situation occurs, how does it occur in

1458
01:16:43,900 --> 01:16:44,600
practice?

1459
01:16:44,800 --> 01:16:45,300
Right.

1460
01:16:45,400 --> 01:16:49,300
I'll actually do it sort of step by step.

1461
01:16:51,400 --> 01:16:57,100
Okay, step one allocate a right, I create one, right?

1462
01:16:57,100 --> 01:16:58,200
I want to use the word allocate.

1463
01:16:58,200 --> 01:17:02,900
I'll just say you know we get a new a so however that happens in your

1464
01:17:02,900 --> 01:17:03,500
language.

1465
01:17:04,300 --> 01:17:05,300
So what happens there?

1466
01:17:05,300 --> 01:17:09,800
Well, now there's a pointer from the outside world right into a.

1467
01:17:09,900 --> 01:17:11,900
So it's reference count goes up, right?

1468
01:17:11,900 --> 01:17:14,100
It's actually reference count is 1.

1469
01:17:14,100 --> 01:17:16,900
Now then I get a newbie.

1470
01:17:18,100 --> 01:17:22,200
Okay, so that means the world now has a pointer to a b and that

1471
01:17:22,300 --> 01:17:23,200
reference count goes up.

1472
01:17:23,600 --> 01:17:24,000
Yeah.

1473
01:17:25,500 --> 01:17:26,200
Step 3.

1474
01:17:27,700 --> 01:17:30,500
I have a point to be right.

1475
01:17:31,600 --> 01:17:36,900
Like so, so it's reference count goes up by one step for I have be

1476
01:17:36,900 --> 01:17:38,800
point to a right.

1477
01:17:39,900 --> 01:17:41,600
So it's reference count goes up by 1.

1478
01:17:42,600 --> 01:17:47,500
Now, step 5, I stopped.

1479
01:17:47,500 --> 01:17:50,200
You know, I stopped using a right?

1480
01:17:50,400 --> 01:17:53,800
So this world pointer to a goes away.

1481
01:17:54,800 --> 01:17:57,900
It's reference count goes down by one, so it's reference.

1482
01:17:57,900 --> 01:17:59,800
Count is now just one step.

1483
01:18:00,000 --> 01:18:01,600
Six I stopped using be.

1484
01:18:02,700 --> 01:18:04,600
So now this world pointer to be goes away.

1485
01:18:04,700 --> 01:18:06,400
Its reference count goes down by one.

1486
01:18:06,600 --> 01:18:07,100
Right?

1487
01:18:07,100 --> 01:18:09,100
So now it's just, it's just a reference, kind of one.

1488
01:18:10,900 --> 01:18:14,400
If these were just reference counted pointers you now have an island,

1489
01:18:15,700 --> 01:18:17,600
which is course the term for saying, you know.

1490
01:18:17,700 --> 01:18:20,500
All right, this A, and B point to each other and are mutually

1491
01:18:20,500 --> 01:18:22,100
supporting each other with a reference count.

1492
01:18:22,200 --> 01:18:23,300
Nobody gets freed.

1493
01:18:24,600 --> 01:18:26,000
There is no way to ever access these.

1494
01:18:26,000 --> 01:18:28,700
Again, they are no longer used the world, the pointers from the

1495
01:18:28,700 --> 01:18:32,200
outside into them are gone, but because they mutually support each

1496
01:18:32,200 --> 01:18:36,400
other, they will stay alive for the rest of the program and that is

1497
01:18:36,400 --> 01:18:38,500
effectively a memory leak, right?

1498
01:18:40,000 --> 01:18:44,200
So some garbage collection algorithms can detect this right?

1499
01:18:44,300 --> 01:18:44,900
Good garbage.

1500
01:18:44,900 --> 01:18:52,300
Collections collection, algorithms do Walks from the live set of

1501
01:18:52,300 --> 01:18:56,900
pointers things that it knows our lives out to see if things are being

1502
01:18:56,900 --> 01:18:59,400
mutually supported like this and realize that there's an island and

1503
01:18:59,400 --> 01:19:00,300
get rid of the Island.

1504
01:19:00,800 --> 01:19:01,000
Right?

1505
01:19:01,000 --> 01:19:04,400
So a good garbage collector, can do that a reference counted pointer

1506
01:19:04,400 --> 01:19:05,500
can't really do that.

1507
01:19:05,900 --> 01:19:09,200
So for certain use cases philosophically like

1508
01:19:09,400 --> 01:19:13,300
Feature wise, I should say again there's a difference there.

1509
01:19:14,200 --> 01:19:20,500
So a garbage collector is typically a more powerful thing than the

1510
01:19:20,500 --> 01:19:22,500
kind of pointer you're probably envisioning.

1511
01:19:32,000 --> 01:19:33,900
Let's see, the sizzix.

1512
01:19:33,900 --> 01:19:35,100
What about resource?

1513
01:19:35,100 --> 01:19:36,800
Acquisition is initialization.

1514
01:19:38,200 --> 01:19:46,200
So resource acquisition, so he said are a AI that stands for resource

1515
01:19:47,700 --> 01:19:48,700
acquisition

1516
01:19:51,100 --> 01:19:53,500
Is initialization.

1517
01:19:55,800 --> 01:19:58,400
For those of you who don't know what that is, what that basically.

1518
01:20:00,600 --> 01:20:02,200
Out early even know if I want to explain it.

1519
01:20:05,300 --> 01:20:08,700
it's a modern programming Trend that basically says,

1520
01:20:11,300 --> 01:20:14,200
If you are conceptualizing things in terms of object, because it

1521
01:20:14,200 --> 01:20:17,500
doesn't really make any sense, it doesn't actually have a meaning

1522
01:20:17,500 --> 01:20:21,500
outside of opportunity program to some degree because without the

1523
01:20:21,500 --> 01:20:29,100
notion of some like unit of data, it's hard to describe what it would

1524
01:20:29,100 --> 01:20:31,000
even mean, right?

1525
01:20:31,500 --> 01:20:34,700
But thinking about it in those terms, right?

1526
01:20:35,000 --> 01:20:36,400
If you have an object,

1527
01:20:38,200 --> 01:20:43,400
Then the idea is that the object should be considered initialized once

1528
01:20:43,400 --> 01:20:47,000
it has acquired its resources, right?

1529
01:20:48,100 --> 01:20:54,200
Meaning I should not have the ability for objects to exist in

1530
01:20:54,200 --> 01:20:59,800
partially initialized states where they have acquired some butt.

1531
01:21:00,000 --> 01:21:04,200
All of their resources or something along those lines, right?

1532
01:21:04,900 --> 01:21:09,600
So the classic example of resource acquisition is initialization is

1533
01:21:09,600 --> 01:21:14,100
just saying like, I mean to give up this is a pretty stupid example,

1534
01:21:14,100 --> 01:21:16,500
but if I had an object

1535
01:21:17,900 --> 01:21:23,400
You know, don't make an object, that's has to file pointers in it.

1536
01:21:24,800 --> 01:21:25,400
Right?

1537
01:21:25,800 --> 01:21:31,000
Because when I when I go to initialize, this object there's no way for

1538
01:21:31,000 --> 01:21:36,300
me to actually do a single initialization step that will make these

1539
01:21:36,300 --> 01:21:37,200
both valid.

1540
01:21:37,400 --> 01:21:41,900
So it's entirely possible that I got one of them and not the other

1541
01:21:41,900 --> 01:21:43,500
one, right?

1542
01:21:47,000 --> 01:21:49,200
It's not really good example because you could still at that point,

1543
01:21:49,200 --> 01:21:53,400
just going to just throw the exception there and trying to think of

1544
01:21:53,400 --> 01:21:56,400
what the best example would be for someone who's never looked at this

1545
01:21:56,400 --> 01:21:57,200
game before.

1546
01:21:59,900 --> 01:22:02,600
I mean I guess I can still describe it in terms of that.

1547
01:22:02,600 --> 01:22:08,000
It's what I just said, which is that if I did want to have an object

1548
01:22:08,000 --> 01:22:12,400
that had to file pointers, it has to only be used.

1549
01:22:12,400 --> 01:22:17,700
It has to only come into existence when those are both valid, right?

1550
01:22:18,300 --> 01:22:20,000
And so this is where you get into exception handling and all those

1551
01:22:20,000 --> 01:22:20,700
other sorts of things.

1552
01:22:21,000 --> 01:22:25,500
So, what is trying to say is like, okay, when I Define this object,

1553
01:22:25,500 --> 01:22:26,100
right?

1554
01:22:26,100 --> 01:22:28,100
And I say I've got struct Foo.

1555
01:22:28,800 --> 01:22:29,300
Okay.

1556
01:22:29,900 --> 01:22:34,100
And I've got my Foo Constructor here and then I've got these two file

1557
01:22:34,100 --> 01:22:35,100
Stars, right?

1558
01:22:35,100 --> 01:22:37,900
I've got file star, a and file star, b or whatever.

1559
01:22:37,900 --> 01:22:40,600
Right in this Constructor.

1560
01:22:41,200 --> 01:22:46,000
The idea behind resources position is initialization, is inside the

1561
01:22:46,000 --> 01:22:46,800
Constructor.

1562
01:22:46,900 --> 01:22:51,000
I need to get both A and B and if for some reason I don't get them

1563
01:22:51,200 --> 01:22:51,800
right.

1564
01:22:53,000 --> 01:22:57,400
I need to abort and the reason why I was kind of saying that if you

1565
01:22:57,400 --> 01:23:00,200
have two of them, you shouldn't do that.

1566
01:23:00,500 --> 01:23:04,400
Is because generally the reason that people care about this and the

1567
01:23:04,400 --> 01:23:11,300
reason why they sort of fallaciously think it's a good idea, is

1568
01:23:11,300 --> 01:23:12,000
because

1569
01:23:13,500 --> 01:23:15,600
The destructor for my thing.

1570
01:23:17,700 --> 01:23:21,000
Should be able to do the clean up properly, right?

1571
01:23:21,400 --> 01:23:26,800
And so if I make it through the Constructor for the object, then I

1572
01:23:26,800 --> 01:23:28,900
know that my Destructor will clean it up.

1573
01:23:29,100 --> 01:23:33,600
If I don't make it through, then there shouldn't have to be clean up

1574
01:23:33,900 --> 01:23:37,000
because if they're did have to be clean up, no one's going to be able

1575
01:23:37,000 --> 01:23:39,700
to do it because the destructor won't run, right?

1576
01:23:39,700 --> 01:23:44,400
Because if I did a and I try to F open the A and it doesn't work if I

1577
01:23:44,400 --> 01:23:46,500
threw an exception here, right?

1578
01:23:46,500 --> 01:23:47,100
I'm fine.

1579
01:23:47,300 --> 01:23:51,600
If I do a and it works and I do B and it doesn't work and I throw an

1580
01:23:51,600 --> 01:23:52,100
exception here.

1581
01:23:52,100 --> 01:23:56,500
Now, I'm messed up because this file handle leaked, right?

1582
01:23:56,500 --> 01:23:59,700
So the idea is, if you only acquire one,

1583
01:24:00,000 --> 01:24:06,200
Horse and you only free one resource in your objects, right?

1584
01:24:07,700 --> 01:24:11,400
Then you kind of know that you can always rely on the destructor to

1585
01:24:11,400 --> 01:24:11,700
free.

1586
01:24:11,700 --> 01:24:13,900
The thing that you allocated in the first place, right?

1587
01:24:15,200 --> 01:24:18,600
And so the way that they, you know, sort of advocate programming with

1588
01:24:18,600 --> 01:24:23,000
resource acquisition is initialization, is making it so that all of

1589
01:24:23,000 --> 01:24:26,900
your code is basically constructed in this fashion where if there was

1590
01:24:26,900 --> 01:24:31,000
a need for multiple things to happen, those are actually separate

1591
01:24:31,000 --> 01:24:31,600
objects.

1592
01:24:31,800 --> 01:24:32,300
Right.

1593
01:24:32,300 --> 01:24:34,600
So, the way they would probably Advocate that you did.

1594
01:24:34,600 --> 01:24:38,000
This was to say that, okay, instead of having an object that's got to

1595
01:24:38,000 --> 01:24:43,100
file pointers, what I do instead is I make a file object, right?

1596
01:24:43,200 --> 01:24:44,400
And a file object is just

1597
01:24:44,700 --> 01:24:45,200
File.

1598
01:24:45,700 --> 01:24:49,200
And then the object that I was making over here is going to be to file

1599
01:24:49,200 --> 01:24:50,900
objects, right?

1600
01:24:52,800 --> 01:24:55,800
It's going to be file object, a and file object B.

1601
01:24:55,800 --> 01:25:01,100
And that way, when I go into my Constructor and I've got a b, c d,

1602
01:25:01,100 --> 01:25:01,600
right?

1603
01:25:01,600 --> 01:25:04,400
They get initialized up here in the Minish Eliezer list and I'm sorry

1604
01:25:04,400 --> 01:25:07,400
for people who don't know C++, I don't want to explain it because it's

1605
01:25:07,400 --> 01:25:10,700
all stupid and a waste of time, but for the people who asked the

1606
01:25:10,700 --> 01:25:11,000
question.

1607
01:25:11,000 --> 01:25:15,300
So in here, you would start actually initializing these guys, and what

1608
01:25:15,300 --> 01:25:15,600
will happen?

1609
01:25:15,600 --> 01:25:19,700
There is, if one of them fails, it will throw an exception, which will

1610
01:25:19,700 --> 01:25:22,600
unwind that initialization and call the destructor codes.

1611
01:25:23,000 --> 01:25:24,700
Which will clean them up one at a time.

1612
01:25:24,800 --> 01:25:27,900
However, many of them actually got initialized, right?

1613
01:25:29,000 --> 01:25:30,900
So that's that's resources.

1614
01:25:31,000 --> 01:25:34,900
Acquisition is initialization, there's more to it.

1615
01:25:35,100 --> 01:25:37,600
I mean, that's not a complete explanation of kind of how it works.

1616
01:25:37,600 --> 01:25:40,200
But just for knowing for people who've, literally don't know anything

1617
01:25:40,200 --> 01:25:40,800
about it.

1618
01:25:40,900 --> 01:25:45,700
It's trying to say that the acquisition of something that needs to be,

1619
01:25:46,800 --> 01:25:48,400
why should you can begin even broader?

1620
01:25:48,500 --> 01:25:51,200
The notion of a resource is just something that has to have shut down,

1621
01:25:51,200 --> 01:25:51,700
right?

1622
01:25:52,000 --> 01:25:55,700
As soon as you have gotten something that needs to be shut down, that

1623
01:25:55,700 --> 01:25:58,500
is the end of your work.

1624
01:25:59,000 --> 01:26:03,000
That that that is you have now initialize up into freeing, the part

1625
01:26:03,000 --> 01:26:06,400
where you will free is going to take care of the symmetric operation

1626
01:26:06,400 --> 01:26:07,300
of freeing that.

1627
01:26:07,300 --> 01:26:10,100
So that you know that you're not ending up with a lot of things that

1628
01:26:10,100 --> 01:26:11,800
some of them might be initialized on the might not.

1629
01:26:11,800 --> 01:26:13,600
And how do I clean that up, right?

1630
01:26:16,100 --> 01:26:18,200
So, I don't like this programming model at all.

1631
01:26:20,000 --> 01:26:22,700
It's it's really just kind of dumb.

1632
01:26:24,400 --> 01:26:26,100
I don't really know why people like it.

1633
01:26:29,000 --> 01:26:33,200
I think it's probably for people who aren't super maybe super aren't

1634
01:26:33,200 --> 01:26:36,700
super versed in actually like production code or something people

1635
01:26:36,700 --> 01:26:39,500
who've kind of think about code more theoretically maybe, but the

1636
01:26:39,500 --> 01:26:44,200
reason that it's not very good is because you, you, you basically

1637
01:26:44,200 --> 01:26:46,500
obvious Kate the part of the system that was actually the problem in

1638
01:26:46,500 --> 01:26:48,000
the first place, right?

1639
01:26:48,400 --> 01:26:51,200
So the problem with the code that they were trying to solve because

1640
01:26:51,200 --> 01:26:53,800
the because with restart, the only reason you care about resource

1641
01:26:53,800 --> 01:26:55,000
acquisition is initialization.

1642
01:26:55,300 --> 01:26:57,000
Is if something goes wrong right?

1643
01:26:57,000 --> 01:26:58,600
Because if nothing goes wrong then

1644
01:26:58,700 --> 01:26:59,900
it doesn't matter how many things you

1645
01:27:00,000 --> 01:27:01,400
Initialized, right?

1646
01:27:01,400 --> 01:27:04,300
Because you could you could digitize 50 things and then shut down 50

1647
01:27:04,300 --> 01:27:06,200
things and it wouldn't matter, right?

1648
01:27:06,200 --> 01:27:08,600
So the reason to break things up into things that do a single

1649
01:27:08,600 --> 01:27:14,100
acquisition and then a single shutdown is so you can handle an error,

1650
01:27:14,400 --> 01:27:14,600
right?

1651
01:27:14,600 --> 01:27:19,100
If you have an error, then you know that that you were going to, you

1652
01:27:19,100 --> 01:27:20,500
know, unwind or whatever, right?

1653
01:27:20,500 --> 01:27:25,000
The problem is error, handling is usually more complicated than this,

1654
01:27:25,100 --> 01:27:25,600
right?

1655
01:27:26,000 --> 01:27:26,200
What?

1656
01:27:26,200 --> 01:27:27,400
Usually you want to do an error.

1657
01:27:27,400 --> 01:27:29,700
Handling situation is actually look at what the are actually.

1658
01:27:30,000 --> 01:27:33,500
Was and take corrective action and these kinds of systems are

1659
01:27:33,500 --> 01:27:39,700
fantastically brittle because the only thing they can do is unwind but

1660
01:27:39,700 --> 01:27:42,700
unwinding may not be what you wanted, right?

1661
01:27:45,000 --> 01:27:50,600
And so yeah the sort of inexorable binding of this to like a wrote

1662
01:27:50,600 --> 01:27:55,300
series of steps that have to be done symmetrically, just ruins all of

1663
01:27:55,300 --> 01:27:58,300
the flexibility that you had in a handling errors and be handling

1664
01:27:58,300 --> 01:27:59,700
shutdown, right?

1665
01:27:59,900 --> 01:28:05,100
Um, because now, you don't know the difference between shutting down

1666
01:28:05,100 --> 01:28:07,900
in a normal scenario and shutting down an error scenario, they both

1667
01:28:07,900 --> 01:28:11,700
have to do the same thing essentially, right because all of your stuff

1668
01:28:11,700 --> 01:28:12,700
was written in this way.

1669
01:28:12,700 --> 01:28:15,200
Whether you have these little guys who just do Alec free or whatever,

1670
01:28:15,200 --> 01:28:15,500
right?

1671
01:28:15,500 --> 01:28:18,400
And there's no way to get like more information into them because

1672
01:28:18,400 --> 01:28:20,000
you've constructed them in this way.

1673
01:28:20,000 --> 01:28:22,600
That you know you've got these guys with hundreds of little tiny

1674
01:28:22,600 --> 01:28:25,800
objects in them that all do these sort of symmetric operations and now

1675
01:28:25,800 --> 01:28:29,500
you don't have the option of doing them as a batch because the whole

1676
01:28:29,500 --> 01:28:29,900
point of

1677
01:28:29,900 --> 01:28:31,400
Of resource acquisition is initialization.

1678
01:28:31,400 --> 01:28:33,600
Is that they were done individually, right?

1679
01:28:35,100 --> 01:28:40,000
The trivial example is I want to have the choice of using this thing

1680
01:28:40,300 --> 01:28:43,400
where I've allocated a block of memory, but they all use versus one

1681
01:28:43,400 --> 01:28:46,300
were, you know, it's just a narrow piece of memory, right?

1682
01:28:46,600 --> 01:28:50,400
Well if these people don't know, if they're all written to like do

1683
01:28:50,400 --> 01:28:51,500
their malloc and free.

1684
01:28:51,600 --> 01:28:54,900
Well, now, it's like impossible for me to do an asymmetric version

1685
01:28:55,000 --> 01:28:58,600
where I, you know, allocated them in sort of this block or whatever,

1686
01:28:58,600 --> 01:28:59,100
right?

1687
01:28:59,100 --> 01:29:02,300
It just, it encourages you to write this really stupid code, which

1688
01:29:02,300 --> 01:29:04,000
always does exactly the same thing.

1689
01:29:04,400 --> 01:29:07,700
This is what the situation actually wanted you to do and that's true

1690
01:29:07,700 --> 01:29:10,600
for the error handling part and for the resource acquisition part

1691
01:29:10,600 --> 01:29:12,700
which is what this kind of is all about.

1692
01:29:13,500 --> 01:29:15,900
So I really don't recommend that resource acquisition is

1693
01:29:15,900 --> 01:29:16,800
initialization.

1694
01:29:17,400 --> 01:29:22,700
I don't use it myself and I strongly recommend against it but that's

1695
01:29:22,700 --> 01:29:23,300
what it is.

1696
01:29:23,400 --> 01:29:25,600
It's sort of this notion of keeping those things.

1697
01:29:25,800 --> 01:29:27,200
Tightly coupled symmetrically.

1698
01:29:43,200 --> 01:29:47,700
Let's see how about vibration affect assets, I don't think we're going

1699
01:29:47,700 --> 01:29:52,600
to have any vibration, effect assets, soy sauce, the kid, what is it

1700
01:29:52,600 --> 01:29:55,300
in between Mega texture and texture Atlas?

1701
01:29:56,100 --> 01:29:58,600
So, it depends a texture.

1702
01:29:58,600 --> 01:29:59,800
Atlas is basically the same

1703
01:30:00,000 --> 01:30:05,100
Bang Mega texture when I say that, it's megatexture involves other

1704
01:30:05,100 --> 01:30:05,500
things.

1705
01:30:05,500 --> 01:30:09,800
It's part of like how the query works and it it's how you do the the

1706
01:30:09,800 --> 01:30:11,200
texture coordinates into it.

1707
01:30:11,300 --> 01:30:13,500
So there are two different.

1708
01:30:13,500 --> 01:30:15,100
There are two different flavors of a similar thing.

1709
01:30:15,100 --> 01:30:19,000
Mega texture is more includes the 3D pieces of it, but but if you know

1710
01:30:19,000 --> 01:30:21,100
it at a texture Atlas is, that's basically what I was talking about.

1711
01:30:33,900 --> 01:30:36,600
Do you object-- to you to the use of explicit V tables like you would

1712
01:30:36,600 --> 01:30:37,600
have to use Encino?

1713
01:30:38,400 --> 01:30:39,800
I'm actually fine with supposed to be tables.

1714
01:30:39,800 --> 01:30:45,600
In fact what I what I wish C++ had done is instead of making V tables

1715
01:30:45,600 --> 01:30:48,700
and implicit thing is I wish that what C++ I've been about when they

1716
01:30:48,700 --> 01:30:53,000
decided to introduce, those concept was actually giving you the tools

1717
01:30:53,100 --> 01:30:58,700
to write code about V tables conveniently that would have been useful.

1718
01:30:59,200 --> 01:31:01,500
What they did was not useful implicit V.

1719
01:31:01,500 --> 01:31:03,100
Tables are almost never useful

1720
01:31:03,700 --> 01:31:06,200
But if they had given you good tools for making your own V tables.

1721
01:31:06,200 --> 01:31:09,800
Like, for example, what John blows doing in j.i., that would have been

1722
01:31:09,800 --> 01:31:10,500
very useful.

1723
01:31:11,800 --> 01:31:12,200
So,

1724
01:31:16,300 --> 01:31:19,100
With thinking about asset allocation in terms of maximum amount of

1725
01:31:19,100 --> 01:31:21,000
pixels that can be displayed on screen at one time.

1726
01:31:21,000 --> 01:31:23,900
Be worth it for instance, with your 16, MB safety buffer.

1727
01:31:24,200 --> 01:31:26,600
So you tailor the asset loading to load assets at a resolution

1728
01:31:26,600 --> 01:31:29,100
proportional to the distance of the camera and operate under the

1729
01:31:29,100 --> 01:31:30,500
assumption that only a fixed number of things.

1730
01:31:30,500 --> 01:31:33,600
Could physically occupy, the high risk space and so on for medium

1731
01:31:33,600 --> 01:31:34,300
load, Etc.

1732
01:31:35,000 --> 01:31:41,300
Yes, that is actually how we do it in the engine that I did for what

1733
01:31:41,300 --> 01:31:42,700
we're doing at Molly rocket right now.

1734
01:31:43,500 --> 01:31:46,000
That is not really necessary necessary for handmade hero because in

1735
01:31:46,200 --> 01:31:47,900
Here we don't do a lot of zooming.

1736
01:31:48,600 --> 01:31:51,800
Right hand made here as a 2-D game that basically takes place at the

1737
01:31:51,800 --> 01:31:57,100
same zoom level or close to it pretty much all the time, right?

1738
01:31:57,100 --> 01:32:02,800
Like a Zelda game doesn't zoom out or zoom in a lot that's just not

1739
01:32:02,800 --> 01:32:03,400
what it does.

1740
01:32:03,900 --> 01:32:07,300
So for this game we don't really need to do that but that's a totally

1741
01:32:07,300 --> 01:32:10,700
valid thing to do and if you have a if you're expecting a 2-D game

1742
01:32:10,900 --> 01:32:15,500
where the assets get zoomed in and zoomed out on a lot, that's a very

1743
01:32:15,500 --> 01:32:16,000
good thing to do.

1744
01:32:16,100 --> 01:32:18,700
Do because you want to be able to load the assets at different

1745
01:32:18,700 --> 01:32:19,200
resolutions.

1746
01:32:19,200 --> 01:32:23,100
So you would actually have, you know, sort of MIT mapped versions of

1747
01:32:23,100 --> 01:32:26,100
all of your assets that you would load, dynamically and stuff like

1748
01:32:26,100 --> 01:32:27,100
that too, right?

1749
01:32:28,400 --> 01:32:30,500
There's a lot of other things that you would be doing there.

1750
01:32:30,500 --> 01:32:34,700
If zooming was something, you were targeting heavily students, every

1751
01:32:34,700 --> 01:32:34,900
three.

1752
01:32:34,900 --> 01:32:37,100
Yeah, the thing I didn't see was grouping small related assets

1753
01:32:37,100 --> 01:32:39,600
together, so they fit in one allocation unit.

1754
01:32:39,800 --> 01:32:40,100
Yes.

1755
01:32:40,100 --> 01:32:41,600
So basically, what you would do,

1756
01:32:43,700 --> 01:32:48,300
In this scheme is you just pack all of your Sprites into one giant

1757
01:32:48,300 --> 01:32:50,300
bitmap, right?

1758
01:32:50,500 --> 01:32:52,500
So and you just pack them as closely as you can.

1759
01:32:53,200 --> 01:32:56,800
And so that way you can just load out of it and you just grab out the

1760
01:32:56,800 --> 01:32:58,500
piece that you need, right?

1761
01:33:00,000 --> 01:33:00,900
So that's how that works.

1762
01:33:05,200 --> 01:33:07,600
Is this still the same Blackboard file from day one?

1763
01:33:07,700 --> 01:33:14,900
Not quite, we didn't find Mischief as a black boarding tool until day

1764
01:33:15,000 --> 01:33:16,400
you know, 20 or 30 or something.

1765
01:33:16,400 --> 01:33:16,900
I don't remember.

1766
01:33:16,900 --> 01:33:17,700
But otherwise.

1767
01:33:17,700 --> 01:33:18,100
Yes.

1768
01:33:18,700 --> 01:33:21,600
And if you would like to view it yourself it comes with the pre-order.

1769
01:33:21,600 --> 01:33:25,000
Actually, if you take a look at

1770
01:33:27,900 --> 01:33:33,200
See here, if you take a look, if you pre-ordered the game unpack, the

1771
01:33:33,200 --> 01:33:38,400
source code and look in hand in the misc directory, I think oh wait,

1772
01:33:38,400 --> 01:33:39,600
no it's not in this directory.

1773
01:33:40,100 --> 01:33:43,800
It's actually just in the zip file.

1774
01:33:44,200 --> 01:33:45,800
It's just in that the source zip file.

1775
01:33:45,800 --> 01:33:49,200
It's right in the sort of that file and it's there.

1776
01:33:49,400 --> 01:33:53,800
It's Blackboard to Art and you can actually load it with the free

1777
01:33:53,800 --> 01:33:54,900
version of Mischief.

1778
01:33:55,200 --> 01:33:57,600
So if you want, you can load, you can go down.

1779
01:33:57,700 --> 01:34:01,000
The free version of mischief and zoom around the Blackboard all you

1780
01:34:01,000 --> 01:34:01,500
want.

1781
01:34:01,800 --> 01:34:03,800
So that that's actually comes with the pre-order.

1782
01:34:06,100 --> 01:34:06,900
All right.

1783
01:34:08,600 --> 01:34:09,700
let's,

1784
01:34:12,300 --> 01:34:13,300
Let's close this down.

1785
01:34:18,900 --> 01:34:20,300
No, there we go.

1786
01:34:21,800 --> 01:34:24,000
Okay, everyone, thank you for joining me for another episode of

1787
01:34:24,000 --> 01:34:24,500
handmade hero.

1788
01:34:24,500 --> 01:34:25,600
It's been a pleasure coding with you.

1789
01:34:25,600 --> 01:34:29,500
As always, if you would like to follow along with the code at home,

1790
01:34:30,000 --> 01:34:33,100
like I just referred to with the Blackboard or other things like that.

1791
01:34:33,800 --> 01:34:38,000
You can always pre-order the game on handmade here a.org and it comes

1792
01:34:38,000 --> 01:34:38,600
with the source code.

1793
01:34:38,600 --> 01:34:40,800
So every night, I update the source code, and you can follow along

1794
01:34:40,800 --> 01:34:42,500
with the game as it is developed.

1795
01:34:43,700 --> 01:34:47,100
You can also go to our Forum site if you have questions and want to

1796
01:34:47,100 --> 01:34:49,500
ask questions or get ports to Mac and Linux that community members

1797
01:34:49,500 --> 01:34:51,400
have done or look at our anti depa sewed guide.

1798
01:34:51,700 --> 01:34:53,000
Which community members have done.

1799
01:34:53,600 --> 01:34:56,100
You can also, if you want support this video series pledge to our

1800
01:34:56,100 --> 01:34:57,100
patreon page.

1801
01:34:57,100 --> 01:34:57,800
We always very much.

1802
01:34:57,800 --> 01:34:58,700
Appreciate that.

1803
01:34:59,000 --> 01:35:01,600
And then we also have a tweetbot which tweets the schedule at you.

1804
01:35:02,100 --> 01:35:04,600
So if you want to catch the stream live, it's a great place to go.

1805
01:35:04,600 --> 01:35:07,200
So you kind of know when it's coming up, that's all the stuff we've

1806
01:35:07,200 --> 01:35:07,900
got up there.

1807
01:35:08,400 --> 01:35:09,100
So check that out.

1808
01:35:09,100 --> 01:35:12,600
If you're trying to file the video series, we will be back here

1809
01:35:12,600 --> 01:35:13,600
tomorrow at 5 p.m.

1810
01:35:13,600 --> 01:35:18,200
Pacific Daylight time to do a little bit more work on this asset

1811
01:35:18,200 --> 01:35:19,200
memory management.

1812
01:35:19,300 --> 01:35:21,400
So we'll do kind of the very rudimentary thing tomorrow.

1813
01:35:21,500 --> 01:35:23,800
So we're we're just kind of allocating and freeing and not thinking

1814
01:35:23,800 --> 01:35:26,500
too much about it and then we'll slowly try to make that a little bit

1815
01:35:26,500 --> 01:35:26,900
better.

1816
01:35:27,300 --> 01:35:29,000
And that's really what we'll do for this week.

1817
01:35:29,200 --> 01:35:31,400
I don't know exactly how long it will take, but, you know, it

1818
01:35:31,400 --> 01:35:33,800
shouldn't be too much of an adventure, but it will take a little bit

1819
01:35:33,800 --> 01:35:34,700
of work on our part.

1820
01:35:34,700 --> 01:35:37,500
So, you know, plan for a couple of days of us getting the assets

1821
01:35:37,500 --> 01:35:40,000
system memory management, correct?

1822
01:35:40,700 --> 01:35:43,600
Alright, so I hope to see you back here tomorrow for that until then

1823
01:35:43,600 --> 01:35:45,800
have fun programming and I will see you guys on the internet.

