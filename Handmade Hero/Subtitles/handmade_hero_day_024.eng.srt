1
00:00:00,300 --> 00:00:00,900
There we go.

2
00:00:01,500 --> 00:00:02,000
Alright.

3
00:00:02,000 --> 00:00:02,800
Hello everyone.

4
00:00:02,800 --> 00:00:07,800
And welcome to day 24 of handmade hero, the show where we create a

5
00:00:07,800 --> 00:00:13,700
complete game from scratch using no libraries and no engine, just our

6
00:00:13,700 --> 00:00:19,400
own, our own cunning and wit it is basically, it is a team effort here

7
00:00:19,400 --> 00:00:20,700
at handmade hero dot-org.

8
00:00:20,800 --> 00:00:24,000
It is, it is me, plus the twitch chat and so far.

9
00:00:24,000 --> 00:00:26,100
We've I think done a really good job.

10
00:00:26,100 --> 00:00:27,500
We've made some pretty cool stuff.

11
00:00:27,500 --> 00:00:29,900
We have a win32 prototyping layer that we built it.

12
00:00:30,100 --> 00:00:34,500
Pretty awesome things already such as Live code editing and the

13
00:00:34,500 --> 00:00:37,900
ability to set like Loops in the game that you can live code it and

14
00:00:37,900 --> 00:00:39,300
watch the changes as you go.

15
00:00:39,300 --> 00:00:41,000
We did that earlier this week.

16
00:00:41,000 --> 00:00:41,900
It was pretty awesome.

17
00:00:42,400 --> 00:00:44,200
So I am excited for where we're at.

18
00:00:44,300 --> 00:00:48,700
We are at the point now in the process where we are going to wrap up

19
00:00:48,700 --> 00:00:50,700
the win32 platform layer.

20
00:00:51,200 --> 00:00:54,800
So that basically will just be doing light modifications to it for the

21
00:00:54,800 --> 00:00:55,400
next few months.

22
00:00:55,400 --> 00:00:58,200
Where, you know, if we need something, will go in and deal with it,

23
00:00:58,200 --> 00:00:59,900
but for the most part, we want to move on to working on.

24
00:01:00,000 --> 00:01:00,300
The game.

25
00:01:00,300 --> 00:01:03,800
So we want to kind of wrap up the winter to platform layer for now,

26
00:01:03,800 --> 00:01:06,400
and not have to really think about it anymore.

27
00:01:06,400 --> 00:01:08,200
So what I'm going to be doing today.

28
00:01:09,400 --> 00:01:15,500
Is I am going to try to sort of go through the win32 platform layer

29
00:01:15,600 --> 00:01:18,800
and clean up some stuff that we kind of have left that we haven't

30
00:01:18,800 --> 00:01:23,900
finished or that we haven't really like kind of massaged into the into

31
00:01:23,900 --> 00:01:26,500
the right format or whatever, that sort of thing.

32
00:01:26,500 --> 00:01:29,700
Just kind of go through like spend some time dealing with your dues,

33
00:01:29,700 --> 00:01:32,700
that sort of stuff in preparation for tomorrow, when we'll kind of

34
00:01:32,900 --> 00:01:36,600
button everything up and do a little recap, just so everyone can kind

35
00:01:36,600 --> 00:01:37,200
of get a second.

36
00:01:37,200 --> 00:01:39,000
Look at all the stuff that we've

37
00:01:39,200 --> 00:01:41,100
Done and how it's architected and how it works.

38
00:01:41,100 --> 00:01:45,800
Just for kind of to cement in the sort of the the overall design of

39
00:01:45,800 --> 00:01:47,600
everything and how it kind of came together.

40
00:01:47,600 --> 00:01:48,600
Now that it's done.

41
00:01:49,900 --> 00:01:55,400
So if you have pre-ordered, the game on handmade hero dot-org, using

42
00:01:55,400 --> 00:01:58,600
the handy dandy pre-order button, then you should have gotten an email

43
00:01:58,600 --> 00:02:01,500
and the email has a link that allows you to download a zip file

44
00:02:01,700 --> 00:02:04,300
inside, which is another set of zip files.

45
00:02:04,300 --> 00:02:06,100
For every day of handmade hero.

46
00:02:06,500 --> 00:02:09,000
We are on day, 24, which means if you want to follow,

47
00:02:09,100 --> 00:02:12,700
Follow along with your source code, you unzip day 23, which is

48
00:02:12,700 --> 00:02:13,400
yesterday.

49
00:02:13,500 --> 00:02:16,800
And that is the state of the source code that I am starting with right

50
00:02:16,800 --> 00:02:17,200
now.

51
00:02:18,100 --> 00:02:23,000
So I will go ahead and open that up and then we will start to get to

52
00:02:23,500 --> 00:02:26,700
all the stuff that we kind of need to clean up.

53
00:02:26,800 --> 00:02:30,500
So I have in my notebook here, some things that I've written down,

54
00:02:31,300 --> 00:02:35,300
which are basically, like little bugs or things that probably could

55
00:02:35,300 --> 00:02:38,600
have been better, that we just didn't want to stop and do at the time,

56
00:02:38,600 --> 00:02:38,900
but that

57
00:02:39,100 --> 00:02:42,000
Keep out of the afterwards, or somebody wrote in or post on the Forum

58
00:02:42,000 --> 00:02:45,300
said, hey, you should take a look at this or you forgot to do this.

59
00:02:45,400 --> 00:02:47,700
I just tried to buffer those up, and we can kind of go through them

60
00:02:47,700 --> 00:02:49,200
all at once.

61
00:02:49,500 --> 00:02:56,700
So, first things first, basically, we still have an audio bug.

62
00:02:57,100 --> 00:02:59,900
It's not really I guess it's a bug, is the wrong word.

63
00:03:00,000 --> 00:03:00,600
For it.

64
00:03:00,700 --> 00:03:04,400
We did some work to make our audio better and then we didn't actually

65
00:03:04,400 --> 00:03:05,000
use it.

66
00:03:05,500 --> 00:03:07,800
So I'll show you what I mean by that in a second here.

67
00:03:07,800 --> 00:03:09,300
I'll just going to turn the audio back on.

68
00:03:09,300 --> 00:03:10,300
We turned it off yesterday.

69
00:03:10,300 --> 00:03:11,800
So it wouldn't be so annoying.

70
00:03:12,400 --> 00:03:18,400
But basically, if I run this here, you can kind of see that we have a

71
00:03:19,100 --> 00:03:22,800
when we're when we're looking at the the audio here.

72
00:03:22,800 --> 00:03:27,700
We had kind of a display that was showing us some stuff and I don't

73
00:03:27,700 --> 00:03:29,600
know if I can pause this in an easier way.

74
00:03:29,600 --> 00:03:29,800
Can I

75
00:03:30,000 --> 00:03:30,100
I do.

76
00:03:30,100 --> 00:03:30,500
There we go.

77
00:03:30,500 --> 00:03:32,000
That's the easiest way to pause right now.

78
00:03:32,000 --> 00:03:33,000
Oh, I made a piki.

79
00:03:33,000 --> 00:03:33,400
That's right.

80
00:03:33,400 --> 00:03:34,400
We made a pause key.

81
00:03:35,000 --> 00:03:39,200
So basically what we did is we drew some bars here and the Bars were

82
00:03:39,200 --> 00:03:42,200
sort of telling us some various things about where we were outputting

83
00:03:42,200 --> 00:03:44,300
audio and all sorts of other stuff like that.

84
00:03:45,000 --> 00:03:48,900
But basically the weird thing about it was that we were expecting our

85
00:03:48,900 --> 00:03:54,400
prediction algorithm to give us something where this yellow bar would

86
00:03:54,400 --> 00:03:57,800
always fall in between this white and this pink bar, right?

87
00:03:58,000 --> 00:03:59,700
The White and the pink bar.

88
00:04:00,000 --> 00:04:05,600
We're basically like the, we're basically showing us where the right

89
00:04:05,600 --> 00:04:10,300
cursor and the play cursor and stuff was going to be during our page

90
00:04:10,300 --> 00:04:10,900
flip.

91
00:04:11,100 --> 00:04:15,200
And the yellow was where we were predicting it would be and we felt

92
00:04:15,200 --> 00:04:17,899
like we should always have a prediction that was kind of in between

93
00:04:17,899 --> 00:04:19,300
where it actually turned out to be.

94
00:04:19,300 --> 00:04:22,700
And the next basically the pink bar.

95
00:04:22,700 --> 00:04:23,100
Sorry.

96
00:04:23,200 --> 00:04:24,800
This, this is the the play cursor.

97
00:04:24,800 --> 00:04:25,800
This is the right cursor.

98
00:04:25,800 --> 00:04:26,600
During the flip.

99
00:04:26,800 --> 00:04:29,400
This pink bar was basically the error.

100
00:04:29,900 --> 00:04:33,400
That we could expect to have in where the play cursor was.

101
00:04:33,400 --> 00:04:35,800
So the play cursor would be somewhere in here and we wanted to make

102
00:04:35,800 --> 00:04:39,500
sure that basically we were predicting that it would be somewhere in

103
00:04:39,500 --> 00:04:40,100
between there.

104
00:04:40,100 --> 00:04:41,700
But I believe.

105
00:04:41,700 --> 00:04:44,800
Yeah, like right there, for example, various times.

106
00:04:44,800 --> 00:04:47,000
It would not actually line up properly.

107
00:04:47,500 --> 00:04:48,300
I guess it didn't.

108
00:04:48,300 --> 00:04:49,400
It's kind of hard.

109
00:04:49,600 --> 00:04:50,200
There we go.

110
00:04:50,300 --> 00:04:51,400
It was kind of hard to make it happen.

111
00:04:51,400 --> 00:04:51,800
But there you go.

112
00:04:51,800 --> 00:04:55,700
There's an example where you can see it was outside of their and so we

113
00:04:55,700 --> 00:04:59,200
were doing some work to try and get that Tighter and basically what

114
00:04:59,200 --> 00:04:59,800
had happened.

115
00:05:00,000 --> 00:05:05,400
As we had uh, we had talked with kind of gone through on that day, a

116
00:05:05,400 --> 00:05:09,000
whole bunch of stuff that we thought we should do in order to try to

117
00:05:09,000 --> 00:05:11,800
sort of get our sound as synchronous as possible and to make it so

118
00:05:11,800 --> 00:05:13,500
that would work with low latency sound cards.

119
00:05:13,500 --> 00:05:15,100
This is not a low latency sound card.

120
00:05:15,100 --> 00:05:19,900
But if we had one, or if we later Implement, some lower latency

121
00:05:19,900 --> 00:05:21,300
output, something that's not dirt.

122
00:05:21,500 --> 00:05:24,200
Direct sound for example, and we could get better sound latency.

123
00:05:24,200 --> 00:05:27,500
We wanted our system to kind of be structured properly to make that

124
00:05:27,500 --> 00:05:28,000
work.

125
00:05:28,300 --> 00:05:29,800
And so what we did is

126
00:05:29,900 --> 00:05:33,600
We computed a thing that was called expected B until flip, which was

127
00:05:33,600 --> 00:05:39,800
basically the amount of bytes in the sound buffer that we expected to

128
00:05:39,800 --> 00:05:45,600
be consumed by the audio card in between when we were doing the

129
00:05:45,600 --> 00:05:46,500
computation.

130
00:05:46,500 --> 00:05:50,400
And when we like right here in the code, basically, and when we

131
00:05:50,400 --> 00:05:55,100
actually expect the video to flip to the next frame, because that's

132
00:05:55,100 --> 00:05:57,500
when we want our next frame of sound to start as well.

133
00:05:57,500 --> 00:05:59,100
We want those two things to coincide.

134
00:05:59,400 --> 00:05:59,800
So we

135
00:06:00,000 --> 00:06:01,500
She did the work previously.

136
00:06:01,500 --> 00:06:05,000
We were using expected sound bytes per frame and we were using it to

137
00:06:05,000 --> 00:06:07,200
basically compute where in the sound buffer.

138
00:06:07,200 --> 00:06:11,300
We thought the video flip would happen and we were using that and then

139
00:06:11,300 --> 00:06:13,400
we can computed this better value.

140
00:06:13,700 --> 00:06:15,600
That was not using these type of sound bites for frame.

141
00:06:15,600 --> 00:06:19,300
It was basically subtracting out the part of the frame that had

142
00:06:19,300 --> 00:06:22,500
already been computed, the amount of time that it already elapsed up

143
00:06:22,500 --> 00:06:25,500
to the point of the computation, but then, we never actually use this

144
00:06:25,500 --> 00:06:25,800
value.

145
00:06:25,800 --> 00:06:28,200
We never replaced this with that.

146
00:06:28,400 --> 00:06:29,900
So that's actually what we

147
00:06:30,000 --> 00:06:30,700
Affected it.

148
00:06:31,100 --> 00:06:34,000
What we were trying to do and we never actually did that.

149
00:06:34,100 --> 00:06:36,500
And so I just want to go in and make fix that bug.

150
00:06:36,500 --> 00:06:39,300
We did we did the work of doing the computation, but then we never

151
00:06:39,300 --> 00:06:43,500
actually tried using it and so I just want to go through and actually

152
00:06:43,500 --> 00:06:47,800
see if we could try using it and to see if that makes it any more

153
00:06:47,800 --> 00:06:53,500
likely to be accurate, but it looks like it's a little behind now.

154
00:06:53,500 --> 00:06:56,300
Actually is mostly the only difference.

155
00:06:57,100 --> 00:06:59,700
So I don't know that that actually improved.

156
00:07:00,200 --> 00:07:01,300
Our accuracy at all.

157
00:07:01,300 --> 00:07:04,700
Now it's hard to tell because again, the information we're getting

158
00:07:04,700 --> 00:07:07,200
back from direct sound is very inaccurate.

159
00:07:08,200 --> 00:07:11,900
So we don't really know if maybe this is a more accurate thing.

160
00:07:12,100 --> 00:07:17,600
I will say that it tends to be much closer to where the play cursor is

161
00:07:18,200 --> 00:07:19,800
at least most of the time but I don't know.

162
00:07:19,900 --> 00:07:24,000
I would necessarily say that's much of an improvement to me seems like

163
00:07:24,400 --> 00:07:26,400
either we still have some bugs in there.

164
00:07:26,400 --> 00:07:29,800
Are some things that we could do more efficiently or this is the

165
00:07:29,900 --> 00:07:30,100
Best.

166
00:07:30,100 --> 00:07:33,700
We're going to get on Direct sound because it's not particularly

167
00:07:33,700 --> 00:07:36,800
accurate, one way or the other, so, I don't know.

168
00:07:37,000 --> 00:07:39,500
So I don't know if I think that's actually better or not.

169
00:07:40,600 --> 00:07:41,700
So, so, we'll see.

170
00:07:42,000 --> 00:07:45,800
And I think in general, I would say we've probably spent enough time

171
00:07:45,800 --> 00:07:46,900
trying to get the sound sync.

172
00:07:46,900 --> 00:07:50,900
Well, we will probably come back and revisit this stuff when we want

173
00:07:50,900 --> 00:07:51,500
to ship things.

174
00:07:51,500 --> 00:07:54,600
But since our sound is playing fine for the purposes of developing the

175
00:07:54,600 --> 00:07:55,500
game so far.

176
00:07:55,600 --> 00:07:59,700
I think we can mostly call that fine for now, but I didn't want to get

177
00:07:59,700 --> 00:07:59,800
rid of

178
00:08:00,000 --> 00:08:02,400
So, we'd actually be using the values that we computed.

179
00:08:02,700 --> 00:08:04,700
So, fortunately, that didn't seem to really help all that much.

180
00:08:04,700 --> 00:08:06,600
That doesn't seem to be a very good Improvement.

181
00:08:06,600 --> 00:08:09,300
But at least now, we're actually doing what we said.

182
00:08:09,300 --> 00:08:12,500
We were going to do which is better than that not.

183
00:08:12,500 --> 00:08:14,800
So people who look at the code in the future will not be like wait a

184
00:08:14,800 --> 00:08:15,500
minute.

185
00:08:15,500 --> 00:08:16,900
That is not what they said.

186
00:08:16,900 --> 00:08:17,800
They were doing it all.

187
00:08:18,800 --> 00:08:19,200
Alright.

188
00:08:19,200 --> 00:08:22,800
So the next thing I want to take a look at is basically

189
00:08:26,000 --> 00:08:31,200
So, there was supposedly, some, some stuff where we weren't checking

190
00:08:31,500 --> 00:08:34,900
for succeeded properly like this sort of stuff here.

191
00:08:35,500 --> 00:08:36,200
Supposedly.

192
00:08:36,200 --> 00:08:39,799
There was some stuff that were, this wasn't quite right.

193
00:08:39,900 --> 00:08:42,100
I'm not sure if that's actually true or not.

194
00:08:42,600 --> 00:08:43,500
But let's see.

195
00:08:46,700 --> 00:08:47,500
Well, I don't know.

196
00:08:47,500 --> 00:08:50,300
Someone was saying, basically, that we were checking these

197
00:08:50,300 --> 00:08:50,800
differently.

198
00:08:50,800 --> 00:08:53,100
I think maybe they were just trying to say that we didn't need to do

199
00:08:53,100 --> 00:08:53,600
this anymore.

200
00:08:53,700 --> 00:08:56,600
Cuz we were doing these output debug strings, but I don't know this

201
00:08:56,600 --> 00:08:59,800
looks this, this actually looks roughly correct to me.

202
00:09:00,000 --> 00:09:00,700
I don't know.

203
00:09:00,800 --> 00:09:04,400
I feel like this looks roughly like what it should look like.

204
00:09:04,900 --> 00:09:06,300
So I'm going to call that one.

205
00:09:06,300 --> 00:09:08,600
Not actually something that we need to clean up again.

206
00:09:08,600 --> 00:09:10,900
I'm just going to go through the things that people were mentioning

207
00:09:11,600 --> 00:09:15,900
and that looks that looks pretty good to me.

208
00:09:17,400 --> 00:09:21,300
Yeah, in fact, if anything we probably want to pull out these guys

209
00:09:21,300 --> 00:09:24,200
eventually so when we print out our Diagnostics will probably want to

210
00:09:24,200 --> 00:09:28,300
save what the error code is in these so that we can print them out

211
00:09:28,300 --> 00:09:29,800
since we don't have a logging system yet.

212
00:09:30,000 --> 00:09:31,400
There's not much we can do about that.

213
00:09:31,400 --> 00:09:33,800
But that does seem like something we probably would want to do

214
00:09:34,100 --> 00:09:34,900
eventually.

215
00:09:35,700 --> 00:09:38,200
So, yeah, I'm going to, I'm going to call that something we're not

216
00:09:38,200 --> 00:09:38,600
going to.

217
00:09:38,900 --> 00:09:42,600
We are not going to address at the moment, so good.

218
00:09:42,600 --> 00:09:44,300
That's another one down.

219
00:09:45,000 --> 00:09:47,800
Let's take a look here, get rid of that.

220
00:09:48,400 --> 00:09:50,400
And then similarly on that front.

221
00:09:50,400 --> 00:09:53,400
Someone was saying that we really didn't need to do these.

222
00:09:53,400 --> 00:09:55,900
Not equal to s or equal to S anymore.

223
00:09:57,400 --> 00:09:57,700
She's me.

224
00:09:59,200 --> 00:09:59,900
So, let's see.

225
00:10:00,400 --> 00:10:04,000
What are we actually doing with was down Elke.

226
00:10:04,000 --> 00:10:05,000
Was down.

227
00:10:05,300 --> 00:10:05,800
It does.

228
00:10:06,000 --> 00:10:07,000
Yeah, I would agree.

229
00:10:07,000 --> 00:10:09,900
So I would agree that we don't need to turn these into actual Bulls

230
00:10:09,900 --> 00:10:10,500
anymore.

231
00:10:11,500 --> 00:10:13,100
So that's, that's true.

232
00:10:13,500 --> 00:10:15,900
We could probably simplify this by just saying.

233
00:10:16,100 --> 00:10:21,400
Okay, this this evaluates to a to a non-zero value, if it is, correct,

234
00:10:21,400 --> 00:10:22,600
and so we could just do that.

235
00:10:22,600 --> 00:10:23,800
There isn't there?

236
00:10:23,800 --> 00:10:25,400
Isn't anything happening there.

237
00:10:27,000 --> 00:10:28,100
Well, no, you know what?

238
00:10:28,100 --> 00:10:28,200
That's

239
00:10:28,300 --> 00:10:28,900
Not true.

240
00:10:29,600 --> 00:10:32,700
So, you know why that has to be there is because we're doing a

241
00:10:32,700 --> 00:10:34,800
comparison between was down, in, is down.

242
00:10:35,100 --> 00:10:39,300
And so, basically, because these two values are going to be separate

243
00:10:39,300 --> 00:10:44,700
types of bit Fields, you know, if you think about it, if was down is

244
00:10:44,700 --> 00:10:45,900
going to be true.

245
00:10:46,700 --> 00:10:50,600
If we didn't do this comparison with zero, which forces see to produce

246
00:10:50,600 --> 00:10:52,500
a unique zero or one value.

247
00:10:52,700 --> 00:10:56,800
We would either have the 30th beset or you have no bit set.

248
00:10:57,200 --> 00:10:58,100
So the true.

249
00:10:58,200 --> 00:10:59,100
You would be the 30th.

250
00:10:59,100 --> 00:11:03,900
B would be set is down on the other hand if it were set to true or

251
00:11:03,900 --> 00:11:08,000
false, that's going to be whether or not the 31st bit with set.

252
00:11:08,300 --> 00:11:10,900
And so, we can't really compare the two of those.

253
00:11:13,300 --> 00:11:14,800
That's that's not going to work.

254
00:11:14,900 --> 00:11:18,600
So we needed to do this, to turn them, to turn those two into real

255
00:11:18,600 --> 00:11:19,300
values.

256
00:11:19,800 --> 00:11:24,100
So that's not that's not an unnecessary check, that's actually

257
00:11:24,100 --> 00:11:27,200
necessary and I can I can mark that up here.

258
00:11:27,200 --> 00:11:33,300
I can basically, say note since we are comparing was down to is down.

259
00:11:35,900 --> 00:11:43,600
We must convert, we must use equals equals and not equals to convert

260
00:11:43,600 --> 00:11:48,900
these bit tests to actual 0 or 1 values.

261
00:11:49,200 --> 00:11:50,800
Now, there's other things we could do.

262
00:11:50,800 --> 00:11:53,400
We could, we could rewrite these Expressions to be simpler.

263
00:11:53,500 --> 00:11:57,000
We could, for example, shift this down by 30 and then and it with one.

264
00:11:57,200 --> 00:11:59,100
And then they would line up in the same place.

265
00:12:00,300 --> 00:12:02,000
But I don't know.

266
00:12:02,000 --> 00:12:05,700
I mean, that's totally optimization types of stuff that doesn't need

267
00:12:05,700 --> 00:12:06,200
to happen.

268
00:12:06,200 --> 00:12:08,300
So I think I would rather just leave it the way that it was written

269
00:12:08,300 --> 00:12:09,700
and not spend time.

270
00:12:09,700 --> 00:12:11,900
Do you know, kind of rattling on things like that?

271
00:12:12,000 --> 00:12:14,600
We will care about those sorts of things when they're in Loops that

272
00:12:14,600 --> 00:12:18,300
cost us a lot of time and we just don't care about them in other, in

273
00:12:18,300 --> 00:12:18,900
other cases.

274
00:12:19,500 --> 00:12:21,300
So, okay.

275
00:12:21,600 --> 00:12:23,500
Let's take a look at what else?

276
00:12:23,500 --> 00:12:24,200
We've got here.

277
00:12:25,000 --> 00:12:26,600
We have a definite bug.

278
00:12:26,600 --> 00:12:27,000
I think.

279
00:12:27,000 --> 00:12:29,600
Well, I mean, I don't even know if we want to call it a bug, but it's

280
00:12:29,600 --> 00:12:29,900
definitely.

281
00:12:31,000 --> 00:12:32,300
Worse than it should be.

282
00:12:32,400 --> 00:12:35,800
But that way, if you remember when we were doing our controller stuff

283
00:12:35,800 --> 00:12:42,300
here, we had a thing where the game, the game input was wanted a flag

284
00:12:42,300 --> 00:12:45,000
that kind of said, whether a controller was analog or not.

285
00:12:45,200 --> 00:12:47,700
And that's pretty easy for controllers that are always one of the

286
00:12:47,700 --> 00:12:50,700
other because you just set that set it and it's fine.

287
00:12:51,300 --> 00:12:55,700
But for gamepads, there's a sort of a complex issue, which is that the

288
00:12:55,700 --> 00:12:59,200
GamePad maybe being used as an analog controller or it may be being

289
00:12:59,200 --> 00:12:59,900
used as a digital.

290
00:13:00,000 --> 00:13:00,700
Controller.

291
00:13:00,700 --> 00:13:05,400
Because if you start using the d-pad, right, if you start using the

292
00:13:05,400 --> 00:13:09,400
d-pad, then you have this problem, where you want to switch it from

293
00:13:09,400 --> 00:13:12,600
being considered an analog input to, it being considered a digital and

294
00:13:12,600 --> 00:13:15,100
then if you go back to using the stick, you want to convert it back to

295
00:13:15,100 --> 00:13:16,700
say, use it as an analog.

296
00:13:19,600 --> 00:13:20,200
so,

297
00:13:21,800 --> 00:13:26,100
what we want to do is we want to try and make a determination at any

298
00:13:26,100 --> 00:13:27,000
given time.

299
00:13:27,900 --> 00:13:32,400
That's the most accurate we can to say whether or not the GamePad is

300
00:13:32,400 --> 00:13:35,700
currently being treated by the player as an analog or a digital thing.

301
00:13:35,800 --> 00:13:37,800
So that the game knows which one they're using.

302
00:13:38,600 --> 00:13:44,700
And so what we did in to do in here is we set the is analog to equal

303
00:13:44,700 --> 00:13:49,000
to true or false based on whether the user was using the d-pad or the

304
00:13:49,000 --> 00:13:51,400
stick at any given time, but if they were

305
00:13:51,600 --> 00:13:56,500
Using neither, then it would always just default to whatever happens

306
00:13:56,500 --> 00:13:59,900
to be set in the controller structure before now, since we have two

307
00:13:59,900 --> 00:14:02,700
controllers structures and we ping-pong back and forth between them.

308
00:14:04,000 --> 00:14:08,100
That means that it would actually be the value that was set the frame

309
00:14:08,100 --> 00:14:10,100
before the previous frame.

310
00:14:11,200 --> 00:14:15,500
What we would rather do is say that the new controller every time.

311
00:14:15,500 --> 00:14:18,000
We're about to make a new determination new controller.

312
00:14:18,100 --> 00:14:21,200
Let's set it to whatever old controller was.

313
00:14:21,300 --> 00:14:22,100
Right, whatever.

314
00:14:22,100 --> 00:14:25,800
The very previous frame was instead of skipping a frame.

315
00:14:26,000 --> 00:14:29,400
Let's use whatever it was on the last frame so that the user doesn't

316
00:14:29,400 --> 00:14:30,300
do anything.

317
00:14:30,600 --> 00:14:34,200
Instead of defaulting to whatever the previous previous frame is, Will

318
00:14:34,200 --> 00:14:35,900
default to what the previous frame is.

319
00:14:37,200 --> 00:14:38,900
I don't know if that makes very good sense.

320
00:14:39,500 --> 00:14:43,000
But you know, I could this could be our excuse to try out.

321
00:14:43,200 --> 00:14:43,900
I don't know how you pronounce.

322
00:14:43,900 --> 00:14:44,500
This could eat.

323
00:14:44,500 --> 00:14:47,300
The maybe I don't know, krita.

324
00:14:47,400 --> 00:14:48,500
I'm not sure how you pronounce it.

325
00:14:48,500 --> 00:14:50,700
I'm not sure what nationality is Creator.

326
00:14:51,100 --> 00:14:52,200
So I'm not sure how to pronounce it.

327
00:14:52,200 --> 00:14:59,800
But if we were to try opening up creating here to see if it if it's

328
00:15:00,000 --> 00:15:02,600
Our drawing problem, which I don't know.

329
00:15:02,600 --> 00:15:03,400
If it does.

330
00:15:04,000 --> 00:15:05,700
We will, we will see what happens.

331
00:15:06,200 --> 00:15:08,000
Make it large, make it larger.

332
00:15:08,800 --> 00:15:09,500
Is it working?

333
00:15:10,100 --> 00:15:13,800
Well, I can't see the cursor so I can't say that.

334
00:15:13,800 --> 00:15:14,800
That's particularly useful.

335
00:15:14,800 --> 00:15:16,400
The cursor is hidden.

336
00:15:16,400 --> 00:15:17,100
It would appear.

337
00:15:18,400 --> 00:15:20,900
I'm not sure why I will have to maybe work on those settings a little

338
00:15:20,900 --> 00:15:21,000
bit.

339
00:15:21,000 --> 00:15:23,200
But otherwise, the drawing is quite nice.

340
00:15:23,800 --> 00:15:27,900
So that's this is much closer to something, we can work with.

341
00:15:28,700 --> 00:15:29,800
So, let's see here.

342
00:15:30,000 --> 00:15:30,900
How do I make?

343
00:15:30,900 --> 00:15:31,900
How do I pick a brush?

344
00:15:31,900 --> 00:15:32,800
Is that a brush?

345
00:15:33,100 --> 00:15:33,800
What is this?

346
00:15:34,300 --> 00:15:35,100
What is that?

347
00:15:35,500 --> 00:15:36,900
That's the text tool?

348
00:15:37,100 --> 00:15:38,400
I don't want to text tool.

349
00:15:38,800 --> 00:15:39,600
Is that a brush?

350
00:15:40,700 --> 00:15:41,300
Oh dear.

351
00:15:41,700 --> 00:15:42,700
I don't know what that is.

352
00:15:43,200 --> 00:15:45,100
Something around here should be a brush.

353
00:15:45,200 --> 00:15:47,700
I would think but I'm not sure what.

354
00:15:49,200 --> 00:15:54,500
Okay, someone tell me how to use this program.

355
00:15:55,000 --> 00:15:56,500
I guess I can just click on one of these.

356
00:15:57,000 --> 00:16:02,400
No, maybe not, no, no tools edit.

357
00:16:03,700 --> 00:16:04,200
Well.

358
00:16:05,600 --> 00:16:07,200
I can maybe practice using this.

359
00:16:07,200 --> 00:16:09,400
It certainly seems like it's pretty useful.

360
00:16:09,400 --> 00:16:14,800
So and it if I can just make the gradient paint paint with brushes.

361
00:16:15,100 --> 00:16:16,700
Well, I would like to paint with brushes.

362
00:16:16,700 --> 00:16:18,700
I thought I clicked on that though and it didn't seem to work.

363
00:16:19,900 --> 00:16:21,700
Can't paint on a vector layer.

364
00:16:22,700 --> 00:16:23,300
Oh man.

365
00:16:23,400 --> 00:16:24,500
Now I've really done it.

366
00:16:25,600 --> 00:16:27,100
Let's get rid of all these guys.

367
00:16:27,500 --> 00:16:27,800
Yeah.

368
00:16:28,600 --> 00:16:28,800
Yeah.

369
00:16:28,800 --> 00:16:31,500
So for some reason I can't seem to see my cursor.

370
00:16:31,500 --> 00:16:36,200
So we almost we kind of snatching defeat from the jaws of Victory

371
00:16:36,200 --> 00:16:37,100
here, like right?

372
00:16:37,100 --> 00:16:40,600
We almost had something that would have worked on stream.

373
00:16:40,600 --> 00:16:43,500
So we'll have to play with that a little bit more and see if we can

374
00:16:43,500 --> 00:16:46,300
get that to do what we want because it's pretty close.

375
00:16:46,400 --> 00:16:47,300
So I'll play around with that.

376
00:16:47,300 --> 00:16:49,500
Maybe I don't want to waste too much time on the stream on it.

377
00:16:49,500 --> 00:16:51,600
So I'm going to skip it for now, but that's pretty cool.

378
00:16:51,600 --> 00:16:53,100
We might be able to use that in the drawings.

379
00:16:53,100 --> 00:16:54,800
A lot better than mspaint.

380
00:16:54,800 --> 00:16:55,300
That's for sure.

381
00:16:56,500 --> 00:16:57,000
Anyway.

382
00:16:58,500 --> 00:17:02,200
So basically what we have here is we have a thing where we've got

383
00:17:02,200 --> 00:17:07,700
basically a 0 and a 1 version, in an array.

384
00:17:07,700 --> 00:17:10,400
We've got two states for the controller.

385
00:17:10,500 --> 00:17:10,800
Right?

386
00:17:10,800 --> 00:17:15,700
So we have the controller in two different buffers basically for

387
00:17:15,700 --> 00:17:17,700
holding the controller state, right?

388
00:17:17,900 --> 00:17:21,400
And what we're doing is at any given time.

389
00:17:21,400 --> 00:17:27,300
We have a pointer to the new one and a pointer to the old one, right?

390
00:17:28,099 --> 00:17:28,500
During the frame.

391
00:17:28,500 --> 00:17:29,600
We treat them this way.

392
00:17:30,000 --> 00:17:33,000
Then, at the end of the frame, we swap which ones.

393
00:17:33,000 --> 00:17:37,900
Which so, we basically say, okay, now it's no longer new and old.

394
00:17:38,000 --> 00:17:38,500
Now.

395
00:17:38,500 --> 00:17:41,100
It is old and new, right?

396
00:17:41,100 --> 00:17:43,700
So we basically are just swapping the pointers.

397
00:17:44,100 --> 00:17:47,800
We basically just do a little, a little swap right at the end of the

398
00:17:47,800 --> 00:17:48,100
frame.

399
00:17:48,100 --> 00:17:50,600
So the old one becomes the new one, and the new one, because the old

400
00:17:50,600 --> 00:17:51,900
one, right?

401
00:17:52,000 --> 00:17:55,800
So what that means is, if you look over time, right?

402
00:17:55,800 --> 00:17:57,100
Well, what happens?

403
00:17:57,500 --> 00:17:58,000
So if

404
00:17:58,100 --> 00:17:59,900
We draw our famous Arrow of time.

405
00:18:00,000 --> 00:18:00,700
I'm here.

406
00:18:00,700 --> 00:18:01,200
Right?

407
00:18:01,300 --> 00:18:05,500
This is time going forwards, and we look at our famous frame ticks

408
00:18:05,500 --> 00:18:07,300
that we always draw in here, right?

409
00:18:07,900 --> 00:18:12,000
Then if you actually look at where things are pointing in terms of old

410
00:18:12,000 --> 00:18:16,600
and new, right, you sort of have something that goes like this, you

411
00:18:16,600 --> 00:18:21,900
have old, if this is slot 0, if this is R 0 with 0 controller, and

412
00:18:21,900 --> 00:18:23,800
this is not shouldn't say slot 0 code.

413
00:18:23,800 --> 00:18:27,200
Or if this is our zero input State, and this is our one input State,

414
00:18:27,200 --> 00:18:29,800
we have old and new here and then the next frame.

415
00:18:30,000 --> 00:18:32,900
We swap it so that they're opposite and this flame, we swap it so that

416
00:18:32,900 --> 00:18:34,200
they're opposite than this flame.

417
00:18:34,200 --> 00:18:34,600
We swap it.

418
00:18:34,600 --> 00:18:35,600
So they're opposite, right?

419
00:18:35,700 --> 00:18:38,900
So we're constantly ping-pong you back and forth and that corresponds

420
00:18:39,000 --> 00:18:43,200
right in here to this structure, right?

421
00:18:43,200 --> 00:18:47,500
We've got, we've got to game inputs that were talking about two blocks

422
00:18:47,500 --> 00:18:51,500
that represent the input State and inside each of those like inside.

423
00:18:51,500 --> 00:18:53,900
Each of these inputs, right is a bunch of controllers.

424
00:18:53,900 --> 00:18:56,200
We said there's five controllers or something like that.

425
00:18:56,200 --> 00:18:59,100
Controller States inside an input, but we have to whole game and put

426
00:18:59,100 --> 00:18:59,900
States and we have

427
00:19:00,200 --> 00:19:05,500
We start by pointing to 0 is new and old is one and every frame at the

428
00:19:05,500 --> 00:19:06,200
end of the frame.

429
00:19:06,200 --> 00:19:08,500
When we get down to the very end after we've done everything.

430
00:19:09,300 --> 00:19:10,800
We just swap them, right?

431
00:19:10,800 --> 00:19:11,900
We do this little swap.

432
00:19:11,900 --> 00:19:14,100
So the old becomes the new in the new becomes the old.

433
00:19:14,400 --> 00:19:19,300
So all I was trying to say was well basically is analog Get Set.

434
00:19:19,300 --> 00:19:22,300
Let's say in here, so we're here we set is analog.

435
00:19:23,000 --> 00:19:26,300
So we start off let's say this is our is analog State.

436
00:19:26,300 --> 00:19:28,500
It's zero and zero, right?

437
00:19:28,700 --> 00:19:29,900
Then in this Frame, we find.

438
00:19:30,100 --> 00:19:31,700
That they're using the analog stick.

439
00:19:31,700 --> 00:19:33,900
So now we set a new, we set it to one.

440
00:19:33,900 --> 00:19:37,200
But of course, old is still whatever it was before, so it's zero in

441
00:19:37,200 --> 00:19:39,000
the next frame, right?

442
00:19:40,100 --> 00:19:43,200
And the very next frame these carryover, right?

443
00:19:43,200 --> 00:19:46,500
So one is here and 0 is here because they carry over.

444
00:19:46,500 --> 00:19:49,100
We've swapped the pointers but we haven't swap the buffers.

445
00:19:49,100 --> 00:19:50,700
We just swapped who's pointing to who.

446
00:19:51,300 --> 00:19:55,700
So the old one is now set to is analog, which is which is correct the

447
00:19:55,900 --> 00:20:00,400
in the previous frame which is what old means it was analog, but the

448
00:20:00,400 --> 00:20:04,200
new one is not yet set to analog because it has whatever the value was

449
00:20:04,200 --> 00:20:06,100
in the in the previous buffer on the previous frame.

450
00:20:06,500 --> 00:20:09,800
So what we'd like to do at the start is just copy this in here so that

451
00:20:10,000 --> 00:20:12,000
If if on the previous frame it was analog.

452
00:20:12,000 --> 00:20:13,500
We're going to assume on the new frame.

453
00:20:13,500 --> 00:20:16,600
It's also analog until we hear otherwise, right?

454
00:20:16,700 --> 00:20:22,500
And so that's all I did with this with this line up here that I was

455
00:20:22,500 --> 00:20:23,300
trying to base.

456
00:20:23,300 --> 00:20:23,600
Correct.

457
00:20:23,600 --> 00:20:27,100
That error is basically say, alright, whatever it was in the last

458
00:20:27,100 --> 00:20:27,300
frame.

459
00:20:27,300 --> 00:20:30,300
Let's assume that's what it is on this Frame and then if we hear

460
00:20:30,300 --> 00:20:33,300
otherwise, we'll just go ahead and overwrite that but if we don't hear

461
00:20:33,300 --> 00:20:37,000
otherwise, we'll use what as far as we're concerned is the most recent

462
00:20:37,000 --> 00:20:39,800
information we have and so that seems like a clear Improvement.

463
00:20:39,900 --> 00:20:43,500
Meant to me, someone wrote in on the forums that we admit that and

464
00:20:43,500 --> 00:20:44,500
that's a good point.

465
00:20:46,600 --> 00:20:47,400
All right.

466
00:20:48,300 --> 00:20:49,600
So, let's see here.

467
00:20:49,600 --> 00:20:51,300
Time for some more, almond milk.

468
00:20:56,400 --> 00:20:57,000
All right.

469
00:20:57,200 --> 00:20:59,800
So one thing I want to do.

470
00:21:02,400 --> 00:21:06,700
Is that I think that for our prototyping purposes I had used stretch.

471
00:21:07,200 --> 00:21:09,200
I'd use stretch deai bits here.

472
00:21:10,600 --> 00:21:13,500
And what I think I want to do is because we're trying to learn how to

473
00:21:13,500 --> 00:21:15,000
do rendering and stuff like that.

474
00:21:15,100 --> 00:21:17,400
I don't think we want to scale our image at all.

475
00:21:17,600 --> 00:21:20,800
I think for our purposes while we're doing prototyping.

476
00:21:20,900 --> 00:21:24,100
I think we want to always see 121 pixels to pixels.

477
00:21:25,200 --> 00:21:28,400
So what I think I want to do is say that we're always going to blit

478
00:21:28,400 --> 00:21:30,800
the buffer width and the buffer height.

479
00:21:31,200 --> 00:21:34,100
Ways no matter what the size of the window is.

480
00:21:34,200 --> 00:21:38,600
So basically, like we're always doesn't matter how we draw this,

481
00:21:39,000 --> 00:21:39,300
right?

482
00:21:39,300 --> 00:21:40,700
We doesn't matter what you do.

483
00:21:40,800 --> 00:21:45,300
We're always gonna just do however, big.

484
00:21:45,300 --> 00:21:47,100
It should be for one-to-one, pixels.

485
00:21:47,200 --> 00:21:48,400
We're just going to do that.

486
00:21:48,500 --> 00:21:49,100
Right?

487
00:21:50,000 --> 00:21:55,000
And we'll let the scale, the scale can go down if it wants to.

488
00:21:55,000 --> 00:21:55,400
Oops.

489
00:21:55,400 --> 00:21:56,300
I forgot.

490
00:21:56,300 --> 00:21:57,800
We added that crazy feature.

491
00:21:57,900 --> 00:22:01,000
It's just the weirdest feature will have to look at that today.

492
00:22:01,100 --> 00:22:02,400
See if we can clean that up a bit.

493
00:22:02,900 --> 00:22:04,100
Will let the it's scale.

494
00:22:04,100 --> 00:22:06,900
If we need to like make it smaller, whatever we can leave the sizing

495
00:22:06,900 --> 00:22:09,900
in there for now, but I'm just going to make it so that it's locked

496
00:22:09,900 --> 00:22:11,300
and it won't ever do the scaling.

497
00:22:11,300 --> 00:22:14,200
So that way we can see exactly 121 pixels.

498
00:22:14,800 --> 00:22:16,800
What we're actually doing, right?

499
00:22:18,500 --> 00:22:20,000
So that's what we're going to do there.

500
00:22:20,900 --> 00:22:23,800
I'm hearing some audio clicking which I wonder if we introduced a bug

501
00:22:23,800 --> 00:22:24,300
somewhere.

502
00:22:24,600 --> 00:22:28,900
Its audio is always so annoying to try and get it all exactly correct.

503
00:22:29,900 --> 00:22:34,900
Yeah, either you either you get little weird problems or you you or

504
00:22:34,900 --> 00:22:37,300
you have high latency or it's just annoying.

505
00:22:37,500 --> 00:22:40,400
Anyway, let's keep going here with the with the various things.

506
00:22:40,400 --> 00:22:43,800
So I wanted to turn that off and so we did turn that off and I

507
00:22:43,800 --> 00:22:47,000
probably will say let's just get rid of this for now.

508
00:22:47,000 --> 00:22:48,200
Let's not play with stretch mode.

509
00:22:48,300 --> 00:22:49,000
Not doing that stuff.

510
00:22:49,000 --> 00:22:52,600
We'll save that for when we actually do our shipping stuff.

511
00:22:53,000 --> 00:22:57,600
And so I'm just going to put a note in here and say for prototyping

512
00:22:58,400 --> 00:22:59,300
purposes.

513
00:23:00,500 --> 00:23:09,500
We're going to always blit 121 pixels, to make sure we don't introduce

514
00:23:10,000 --> 00:23:12,600
artifacts with stretching.

515
00:23:13,000 --> 00:23:15,700
While we are learning to code.

516
00:23:15,700 --> 00:23:16,500
The renderer.

517
00:23:17,300 --> 00:23:17,800
There we go.

518
00:23:18,500 --> 00:23:21,100
Okay, so I think that's just a better idea.

519
00:23:22,200 --> 00:23:24,600
Pretty much pretty much all around.

520
00:23:25,100 --> 00:23:28,400
All right, so choose me.

521
00:23:30,400 --> 00:23:31,900
Let's see what else we got here.

522
00:23:31,900 --> 00:23:34,400
Oh, so some things in our build up at file.

523
00:23:34,700 --> 00:23:37,600
So someone pointed out that we can do things a lot easier.

524
00:23:38,500 --> 00:23:41,700
I like I said, I don't know batch file programming very well at all.

525
00:23:42,200 --> 00:23:45,600
I know almost none of the things the commands you can use in Windows

526
00:23:45,600 --> 00:23:46,300
batch files.

527
00:23:46,600 --> 00:23:49,300
What they were saying is we could just put a random number in here.

528
00:23:49,700 --> 00:23:53,100
They basically said that instead of doing all the date craziness,

529
00:23:53,100 --> 00:23:54,700
since we don't actually care about that.

530
00:23:54,700 --> 00:23:58,800
They were saying, we could just do percent random and percent random

531
00:23:58,900 --> 00:23:59,400
just insert.

532
00:23:59,500 --> 00:23:59,600
Is a?

533
00:24:00,000 --> 00:24:01,900
Number which for our purposes is fine.

534
00:24:02,000 --> 00:24:06,000
Because all we really wanted to know is all we really wanted to do is

535
00:24:06,000 --> 00:24:09,000
make sure that we could generate ones that didn't conflict name wise.

536
00:24:09,200 --> 00:24:12,800
And so that's totally fine and way easier and easier for people to

537
00:24:12,800 --> 00:24:15,200
read and cleaner, and it's not confusing what's going on.

538
00:24:15,500 --> 00:24:16,700
So I like that suggestion.

539
00:24:16,700 --> 00:24:17,900
I think that's a better idea.

540
00:24:18,700 --> 00:24:23,000
Another thing that I wanted to say was that when we, when we set the

541
00:24:23,100 --> 00:24:25,600
compiler switch to make sure that we were using, that we were

542
00:24:25,600 --> 00:24:27,800
statically linking with the c runtime Library.

543
00:24:28,200 --> 00:24:29,800
Since we're currently only doing debug.

544
00:24:30,000 --> 00:24:30,900
Builds at the moment.

545
00:24:30,900 --> 00:24:32,700
That should probably be a d.

546
00:24:33,200 --> 00:24:36,100
And what the D does is it says, use the debug version of the runtime

547
00:24:36,100 --> 00:24:36,700
library.

548
00:24:36,900 --> 00:24:40,000
And that way, we know that we have like extra checking and stuff,

549
00:24:40,000 --> 00:24:41,500
which we may want.

550
00:24:41,600 --> 00:24:41,900
Right?

551
00:24:41,900 --> 00:24:44,200
And so I think that's just better.

552
00:24:44,400 --> 00:24:47,400
It's a very simple thing, nothing particular interesting there.

553
00:24:47,400 --> 00:24:50,700
But but something to something to do, just to make sure we're getting

554
00:24:50,700 --> 00:24:54,600
all the checking that we can that make sense.

555
00:24:55,500 --> 00:24:56,200
All right.

556
00:24:56,600 --> 00:24:59,600
So, let's see what else we've got here.

557
00:25:00,100 --> 00:25:03,200
So for our looping, we had a couple of things that we need to take

558
00:25:03,200 --> 00:25:03,700
care of.

559
00:25:04,200 --> 00:25:07,000
One of the things that we haven't done with our looping system.

560
00:25:07,600 --> 00:25:12,000
Is we have not actually made it so that it writes those HMI files to a

561
00:25:12,000 --> 00:25:13,800
reasonable location, right?

562
00:25:14,200 --> 00:25:20,100
If you remember we had these HMI file things and we never really we

563
00:25:20,100 --> 00:25:23,000
didn't really make them right to the build directory.

564
00:25:23,000 --> 00:25:25,600
Like we want to we want we don't want to run into our data directory

565
00:25:26,000 --> 00:25:28,600
because that's not a that's just not a good place for them because

566
00:25:28,600 --> 00:25:29,800
those will get zipped up and we do

567
00:25:29,900 --> 00:25:31,500
Our source distribution and stuff like that.

568
00:25:31,500 --> 00:25:32,300
And that's just bad.

569
00:25:32,300 --> 00:25:34,400
So we need them to be in some kind of temporary directory.

570
00:25:34,400 --> 00:25:38,100
Basically, that's not gonna have that problem.

571
00:25:38,800 --> 00:25:42,700
And so I think what I'll do here is maybe I'll just try to take a look

572
00:25:42,700 --> 00:25:44,400
at how we were doing that before.

573
00:25:44,600 --> 00:25:50,600
If you remember inside our wind main, we actually were to think we

574
00:25:50,600 --> 00:25:54,000
were actually doing some stuff with that for the dll stuff.

575
00:25:54,000 --> 00:25:54,200
Right?

576
00:25:54,200 --> 00:25:57,800
We already did this sort of scan thing and we came up with a way of

577
00:25:57,800 --> 00:25:59,800
saying, alright, let's build file names.

578
00:26:00,000 --> 00:26:02,000
That are in the same directory as our executable.

579
00:26:04,900 --> 00:26:06,100
So what I'd like to do.

580
00:26:07,400 --> 00:26:11,400
Is make kind of pull that out and make that into something a little

581
00:26:11,400 --> 00:26:15,900
more, a little easier to use in general.

582
00:26:16,100 --> 00:26:16,700
Right?

583
00:26:16,900 --> 00:26:21,000
So what I'd like to do is do something like all right, maybe we take

584
00:26:21,000 --> 00:26:24,400
that win32 state structure that we have here that we started to use

585
00:26:24,400 --> 00:26:27,900
right where we just put things and maybe we can put something in

586
00:26:27,900 --> 00:26:28,300
there.

587
00:26:28,700 --> 00:26:31,400
That's just going to be that stem.

588
00:26:31,700 --> 00:26:36,400
So we could put something like like this information here that we had.

589
00:26:37,300 --> 00:26:39,100
We could put that in here.

590
00:26:39,100 --> 00:26:41,000
So the XE file name when we get that.

591
00:26:41,000 --> 00:26:45,000
When we started up we can put that in there and we can also put in the

592
00:26:45,000 --> 00:26:47,700
one past / B so we can put that in.

593
00:26:47,700 --> 00:26:53,800
So this is basically like the one path / / in the exe file name last

594
00:26:54,100 --> 00:26:54,900
XZ, file name.

595
00:26:54,900 --> 00:26:55,400
/.

596
00:26:55,600 --> 00:26:57,100
We could just store those.

597
00:26:57,100 --> 00:26:59,400
And then anytime we want to,

598
00:27:00,200 --> 00:27:03,800
We can generate a new one of these path.

599
00:27:03,800 --> 00:27:05,900
Things, one of these, you know.

600
00:27:08,000 --> 00:27:10,400
One of these past that's in the same directors are dll.

601
00:27:10,800 --> 00:27:16,200
And so I'm just going to do that win32 state file name.

602
00:27:16,500 --> 00:27:20,900
I'm gonna guess I'll call that count.

603
00:27:21,300 --> 00:27:24,100
So, I'm going to go ahead and just say that we're going to Define

604
00:27:24,500 --> 00:27:25,000
this.

605
00:27:25,300 --> 00:27:27,800
This Max path thing out here because I'm not super comfortable with

606
00:27:27,800 --> 00:27:28,200
that.

607
00:27:28,200 --> 00:27:29,400
And we may want to revisit it later.

608
00:27:29,400 --> 00:27:32,800
So I'm just going to basically say that everything has to be this

609
00:27:32,800 --> 00:27:35,900
instead of Max path so that I kind of have a better handle on what's

610
00:27:35,900 --> 00:27:36,700
going on with it.

611
00:27:37,100 --> 00:27:37,600
And then,

612
00:27:37,800 --> 00:27:40,400
I'm going to do is I'm just going to say let's pull out this code into

613
00:27:40,400 --> 00:27:44,100
something that operates in the with the win32 state.

614
00:27:44,800 --> 00:27:50,800
So I will say here, internal void process.

615
00:27:51,000 --> 00:27:53,600
Let's say win32.

616
00:27:55,900 --> 00:27:58,700
Get XZ, file name or something like this?

617
00:27:59,200 --> 00:28:02,400
And that will take our win32 state structure.

618
00:28:03,000 --> 00:28:10,100
And that doesn't actually need any parameters because it is it is able

619
00:28:10,100 --> 00:28:13,400
to get the module file name, just straight from itself.

620
00:28:13,900 --> 00:28:19,900
So basically what we'll do is we'll say that this is going to be off

621
00:28:19,900 --> 00:28:20,600
of this now.

622
00:28:20,600 --> 00:28:23,600
So we're going to say that the XE file name when we get it.

623
00:28:23,600 --> 00:28:24,400
It's going to go straight into

624
00:28:24,600 --> 00:28:30,400
When 32 State structure, we will then make our last one pass / /, that

625
00:28:30,400 --> 00:28:32,900
will actually be off the state structure as well.

626
00:28:33,100 --> 00:28:36,300
So now, these things are preserved, right?

627
00:28:36,500 --> 00:28:42,400
And then when we do that, we can make a utility here that will just

628
00:28:42,400 --> 00:28:45,100
generate these names for us and we'll be good.

629
00:28:45,100 --> 00:28:49,700
So, for example, we can do something where we can say, let's grab this

630
00:28:49,700 --> 00:28:50,300
in here.

631
00:28:50,900 --> 00:28:51,800
So, there we go.

632
00:28:52,300 --> 00:28:53,900
We can now do something where we'll say.

633
00:28:54,500 --> 00:29:00,900
Went through to build XZ path, file name or something like this.

634
00:29:00,900 --> 00:29:01,900
I don't know what we'll call it.

635
00:29:01,900 --> 00:29:03,000
That seems reasonable enough.

636
00:29:03,000 --> 00:29:07,400
I guess you pass in that state structure, and then you pass the file

637
00:29:07,400 --> 00:29:12,100
name in and that will that will replace this thing here.

638
00:29:12,100 --> 00:29:16,800
I think we also probably want to pass the site.

639
00:29:16,800 --> 00:29:21,400
Well, we could, we could assume that that's always passing in an

640
00:29:21,400 --> 00:29:23,200
actual null-terminated string.

641
00:29:23,200 --> 00:29:24,500
So maybe we'll do that as

642
00:29:24,600 --> 00:29:27,600
Well, so we'll take care of that.

643
00:29:27,600 --> 00:29:33,100
And will basically say that all we really need is a dest count and a

644
00:29:33,100 --> 00:29:37,200
dest and so that way we can just go ahead and get rid of all this.

645
00:29:37,200 --> 00:29:43,100
So then we basically pass in that desk count and we pass in the desk

646
00:29:43,100 --> 00:29:43,800
as well.

647
00:29:44,000 --> 00:29:45,000
That's going to go in there.

648
00:29:46,000 --> 00:29:51,700
We can now convert this to using our state structure, right?

649
00:29:52,100 --> 00:29:54,300
So that's sexy, file name and that

650
00:29:54,500 --> 00:29:57,000
at and this is actually file name as well.

651
00:29:57,400 --> 00:29:59,800
And then this will simply be

652
00:30:00,500 --> 00:30:07,500
The file name and the will say the string length of the file name and

653
00:30:07,500 --> 00:30:10,100
we don't have a function for computing a string length yet, but it's

654
00:30:10,100 --> 00:30:11,500
pretty easy for us to write one.

655
00:30:11,700 --> 00:30:18,200
We know that basically if you remember all the way back from way way

656
00:30:18,200 --> 00:30:21,700
back when, if you remember all the way back to the time when we were

657
00:30:21,700 --> 00:30:25,500
in the intro to see course, we know that the way that these strings

658
00:30:25,500 --> 00:30:26,100
are stored.

659
00:30:26,100 --> 00:30:29,400
Is there just bytes in memory and then the last bite is a 0.

660
00:30:29,600 --> 00:30:29,800
So

661
00:30:30,000 --> 00:30:32,900
We know if we start from wherever the first the pointer to the string

662
00:30:32,900 --> 00:30:35,000
is and we just look until we find a zero.

663
00:30:35,600 --> 00:30:37,300
If we count, how many times we had to go.

664
00:30:37,300 --> 00:30:38,800
How many bytes for we had to go.

665
00:30:39,000 --> 00:30:40,800
That would be how long the string is.

666
00:30:40,800 --> 00:30:42,600
It's just counting how many characters there are, we know each

667
00:30:42,600 --> 00:30:48,400
character's 8, b, 1 B, since we know this isn't Unicode.

668
00:30:48,400 --> 00:30:49,900
It's just an see if it's Unicode.

669
00:30:49,900 --> 00:30:52,100
You got a little bit more to deal with because you can have multi by

670
00:30:52,100 --> 00:30:55,800
characters, but ignoring that for now we can do a pretty simple thing,

671
00:30:55,800 --> 00:30:57,000
but it's just the string length.

672
00:30:58,200 --> 00:31:01,400
And in our case, we don't even we really just care about how many

673
00:31:01,400 --> 00:31:02,100
characters are in it.

674
00:31:02,100 --> 00:31:05,000
We don't even care what the number of logical characters is.

675
00:31:05,000 --> 00:31:08,000
So even if this was Unicode, this is still probably what we'd want.

676
00:31:08,100 --> 00:31:13,100
Anyway, so we basically have a string that comes in here and we have a

677
00:31:13,400 --> 00:31:14,700
length that we're going to do.

678
00:31:14,900 --> 00:31:17,600
So we're just going to get, get, get that length.

679
00:31:18,000 --> 00:31:22,200
All we have to basically do is say, while, you know, while the string

680
00:31:22,300 --> 00:31:24,400
star string is going to dereference the pointer to the string.

681
00:31:24,400 --> 00:31:26,000
It's going to get whatever the character is.

682
00:31:26,300 --> 00:31:27,500
We're looking for a null.

683
00:31:28,100 --> 00:31:29,300
So basically we can do something.

684
00:31:29,300 --> 00:31:31,000
That's really just that.

685
00:31:31,000 --> 00:31:31,500
Right.

686
00:31:31,500 --> 00:31:35,600
We can basically say that if the, if the character that's pointing to

687
00:31:35,600 --> 00:31:37,300
Star string, right?

688
00:31:37,400 --> 00:31:42,800
If star string is not zero, we increment count and keep going.

689
00:31:43,700 --> 00:31:46,200
And if it is 0, we stop and don't increment.

690
00:31:46,200 --> 00:31:49,800
And then we also have the plus plus here to basically say after you

691
00:31:49,800 --> 00:31:53,500
check it increment the pointer to the string as you go, right?

692
00:31:54,300 --> 00:31:57,800
So that's that's you know, what, let me, let me go.

693
00:31:57,900 --> 00:31:59,300
Ahead and step through that too.

694
00:31:59,300 --> 00:32:01,600
So you can actually see how it works.

695
00:32:01,700 --> 00:32:05,100
We'll take a look at that in a second here and I can kind of explain

696
00:32:05,100 --> 00:32:07,500
it a little bit in a little bit more detail.

697
00:32:08,000 --> 00:32:08,600
All right.

698
00:32:09,000 --> 00:32:10,900
So what do we have to do?

699
00:32:10,900 --> 00:32:11,300
Here?

700
00:32:11,300 --> 00:32:13,300
We need to fix that pointer.

701
00:32:13,300 --> 00:32:14,100
There we go.

702
00:32:14,900 --> 00:32:18,500
And again which places where that was true.

703
00:32:19,100 --> 00:32:21,400
Then we have to come down here and right.

704
00:32:21,400 --> 00:32:24,600
So now we basically have a utility function for doing this, that makes

705
00:32:24,600 --> 00:32:25,000
sense.

706
00:32:25,500 --> 00:32:27,800
So we should be able to basically make

707
00:32:28,000 --> 00:32:31,400
This all of these guys should be able to work with that.

708
00:32:31,400 --> 00:32:37,000
So now if we just have this place that we want it, we should be able

709
00:32:37,000 --> 00:32:38,500
to pass that state structure.

710
00:32:39,500 --> 00:32:43,000
We should be able to pass the destination, where we want the thing to

711
00:32:43,000 --> 00:32:48,300
go, and then we just pass, whatever the file name, stem is like that,

712
00:32:48,300 --> 00:32:50,700
and we can get rid of all of this extra code.

713
00:32:50,700 --> 00:32:52,300
So that's kind of nice, right?

714
00:32:52,500 --> 00:32:53,300
Get rid of some code.

715
00:32:53,300 --> 00:32:56,900
They're always good to get rid of code, if you can, and this one will

716
00:32:56,900 --> 00:32:57,800
be the handmade.

717
00:32:57,900 --> 00:32:59,800
made temp Dot dll, and it

718
00:33:00,000 --> 00:33:03,800
Going into this guy like that.

719
00:33:04,000 --> 00:33:09,600
So, get rid of those and then we just need to actually call this guy

720
00:33:10,500 --> 00:33:18,100
go and that should just about hoop and the why did that everything

721
00:33:18,100 --> 00:33:19,400
turned green for a moment.

722
00:33:19,500 --> 00:33:20,900
And that is just about it.

723
00:33:21,000 --> 00:33:25,700
We now need to grab that win32 state structure and get it, so that

724
00:33:25,700 --> 00:33:27,900
it's actually in a useful position.

725
00:33:28,100 --> 00:33:29,800
I don't know when we want to actually

726
00:33:30,000 --> 00:33:31,400
The the order of operations here.

727
00:33:31,400 --> 00:33:33,900
I'm not sure when we want these various things to occur.

728
00:33:34,600 --> 00:33:37,300
You know, we could think about how we want these to be lined up.

729
00:33:37,300 --> 00:33:42,100
I don't know, you know, it feels like maybe, maybe we just want this

730
00:33:42,100 --> 00:33:43,100
to happen right away.

731
00:33:43,100 --> 00:33:44,400
I don't know, hard to say.

732
00:33:45,300 --> 00:33:50,800
But anyway, 32 State and 32 state in 32 states.

733
00:33:50,900 --> 00:33:52,800
And in theory, we now should be running.

734
00:33:53,000 --> 00:33:55,400
Let's go ahead and step through that because I wanted to talk about

735
00:33:55,400 --> 00:33:56,300
that a little bit more.

736
00:33:57,300 --> 00:33:59,900
So this is again just doing the code exactly like it was before.

737
00:34:00,000 --> 00:34:02,600
Or and doing that same scan that we already looked at.

738
00:34:02,600 --> 00:34:05,000
So, that's basically, all it's doing is it's putting it in here.

739
00:34:05,000 --> 00:34:07,900
Now, instead of before, you can see it, pulls out the stem just like

740
00:34:07,900 --> 00:34:08,900
we wanted to.

741
00:34:09,300 --> 00:34:10,900
So that all works exactly the same as you used to.

742
00:34:10,900 --> 00:34:14,500
But now in here, we've got a new thing which is that string, length

743
00:34:14,500 --> 00:34:14,900
thing.

744
00:34:15,000 --> 00:34:15,900
Oh, and you know what?

745
00:34:15,900 --> 00:34:19,100
There's I left that - one in there, but we don't need it anymore.

746
00:34:19,400 --> 00:34:21,000
So I left that - one in there.

747
00:34:21,199 --> 00:34:23,800
If you remember this used to be a size of, right?

748
00:34:23,900 --> 00:34:27,400
And so it used to be taking an array and ask what the sides of it was.

749
00:34:27,400 --> 00:34:29,800
Now the array will include that know.

750
00:34:29,900 --> 00:34:32,000
Because you have to remember, there's always a little null in here.

751
00:34:32,000 --> 00:34:33,000
This is zero.

752
00:34:33,800 --> 00:34:38,500
Not the not the letter zero but the actual, and actual 0 B at the end

753
00:34:38,500 --> 00:34:38,800
of it.

754
00:34:38,800 --> 00:34:44,500
So when you ask for the size of a string, you will, if you do size of

755
00:34:44,500 --> 00:34:48,800
a constant string in the code, you're going to end up getting one more

756
00:34:48,800 --> 00:34:50,699
character than the actual number of characters in it.

757
00:34:50,699 --> 00:34:52,400
Because that last character is that null?

758
00:34:52,699 --> 00:34:55,900
And so we were subtracting one from those two to get rid of that.

759
00:34:55,900 --> 00:34:58,500
But our thing here doesn't count that null Terminator.

760
00:34:58,500 --> 00:34:59,800
Our string length doesn't count it.

761
00:35:00,500 --> 00:35:03,500
So basically, we don't ever need that anymore.

762
00:35:03,500 --> 00:35:05,900
We don't need to do that.

763
00:35:06,200 --> 00:35:08,100
Make that subtraction, right?

764
00:35:10,200 --> 00:35:14,100
So, let me jump right to this again, and go into that string length.

765
00:35:14,200 --> 00:35:15,800
So let's take a look at the string length.

766
00:35:15,900 --> 00:35:18,300
We initialize our count, 20, right?

767
00:35:18,400 --> 00:35:22,000
So there, there it is, getting initialized to 0 and then we have the

768
00:35:22,000 --> 00:35:22,500
oops.

769
00:35:22,700 --> 00:35:23,700
Don't mean type in there.

770
00:35:23,700 --> 00:35:24,400
While typing here.

771
00:35:24,600 --> 00:35:29,900
Then we have our string and you can see that it's

772
00:35:30,000 --> 00:35:32,300
I'm 10 11 12, characters long.

773
00:35:33,300 --> 00:35:36,800
So we start and we look at that first character, which is an H.

774
00:35:36,800 --> 00:35:40,600
It's not zero, so we increment count by one and we so you see we've

775
00:35:40,600 --> 00:35:41,600
eaten the H.

776
00:35:41,700 --> 00:35:43,900
And then we're just going to keep eating the characters eating the

777
00:35:43,900 --> 00:35:47,500
characters, eating the characters, using the characters with Microsoft

778
00:35:47,500 --> 00:35:50,900
Visual Studio is incredibly slow, watch window update, not able to

779
00:35:50,900 --> 00:35:51,500
keep up with us.

780
00:35:52,500 --> 00:35:55,200
You can see, we get to 12 like that.

781
00:35:55,200 --> 00:35:58,200
And then we have now there's there's just a 0 B there.

782
00:35:58,300 --> 00:35:59,800
You can see that like the bite is playing.

783
00:36:00,000 --> 00:36:01,000
Actually just 0.

784
00:36:01,200 --> 00:36:06,200
And so this will Now fail and we pop down and return that 12 count,

785
00:36:06,200 --> 00:36:07,200
which is what we wanted.

786
00:36:07,400 --> 00:36:08,700
So, let's see if the cat strings.

787
00:36:08,700 --> 00:36:11,400
Worked probably should.

788
00:36:11,600 --> 00:36:12,000
Yep.

789
00:36:12,000 --> 00:36:13,300
Casting work just fine.

790
00:36:13,600 --> 00:36:16,400
And so now we should be back to square one only.

791
00:36:16,400 --> 00:36:19,800
Now, we have a convenient function for doing that so we can do it

792
00:36:19,900 --> 00:36:20,900
anytime we want to.

793
00:36:20,900 --> 00:36:23,300
So now that that's true.

794
00:36:24,400 --> 00:36:28,600
We should be able to go ahead and move this guy up into just a sort of

795
00:36:28,600 --> 00:36:30,900
General utility place here.

796
00:36:31,400 --> 00:36:32,100
Let's take a look.

797
00:36:32,100 --> 00:36:33,400
I don't know exactly where we want to put.

798
00:36:33,400 --> 00:36:36,800
That probably just put it right right at the top here.

799
00:36:37,300 --> 00:36:38,100
So there we go.

800
00:36:38,400 --> 00:36:44,900
And then when we do our hiim nonsense down here, where was that?

801
00:36:44,900 --> 00:36:50,900
That was like, .h I am or knows dot handmade input HMI, that's what it

802
00:36:50,900 --> 00:36:51,200
was.

803
00:36:52,000 --> 00:36:54,100
So what we want to do here is we want these

804
00:36:54,300 --> 00:36:58,500
I has to be written out to something reasonable something in that

805
00:36:58,500 --> 00:36:59,200
directory.

806
00:36:59,500 --> 00:37:02,600
And so, what we want to do, I believe, is just do a, something, like,

807
00:37:02,600 --> 00:37:07,600
win32, get input file location or something like that.

808
00:37:10,000 --> 00:37:13,200
Seems reasonable and that'll just take a slot index.

809
00:37:13,200 --> 00:37:15,000
Whatever that index thing is, right?

810
00:37:15,000 --> 00:37:16,300
And the win32 state.

811
00:37:16,300 --> 00:37:19,600
So, there's the winter to State structure, which again has the stuff

812
00:37:19,600 --> 00:37:19,800
in it.

813
00:37:19,800 --> 00:37:22,900
That we need, just information that we need to do our job.

814
00:37:23,500 --> 00:37:24,100
So we're going to call.

815
00:37:24,200 --> 00:37:28,600
All that, that to that not necessary.

816
00:37:29,700 --> 00:37:31,000
So this is going to do that.

817
00:37:31,000 --> 00:37:35,100
That build again will sort of go ahead and say that the the food odd

818
00:37:35,100 --> 00:37:37,000
HDMI, I don't know.

819
00:37:37,000 --> 00:37:38,500
That Foo is the best name.

820
00:37:38,500 --> 00:37:43,200
So maybe we'll say like Loop edit or something like that.

821
00:37:43,300 --> 00:37:45,500
I don't know, something like that seem reasonable.

822
00:37:45,600 --> 00:37:48,500
I know what you guys think of loop edit dot h, of H of my.

823
00:37:49,400 --> 00:37:51,600
So will basically say that that's, that's what that is.

824
00:37:51,600 --> 00:37:54,100
I don't know if we want to actually do the slot index.

825
00:37:54,200 --> 00:37:56,300
Yet because we don't actually support slot index.

826
00:37:56,500 --> 00:37:59,200
So I'm just going to assert that slot index equals one.

827
00:37:59,200 --> 00:38:00,300
For now later.

828
00:38:00,300 --> 00:38:03,300
We'll actually dynamically build the file name and maybe stick the

829
00:38:03,300 --> 00:38:04,200
slot and mix in there.

830
00:38:04,200 --> 00:38:04,400
I don't know.

831
00:38:04,400 --> 00:38:06,300
But we don't actually have even a way to test that yet.

832
00:38:06,300 --> 00:38:07,800
So I'm going to avoid doing that for now.

833
00:38:08,200 --> 00:38:10,600
And then we'll just pass that Destin this.

834
00:38:11,400 --> 00:38:13,400
So there's our desk out, there's our desks.

835
00:38:13,600 --> 00:38:14,400
That's all done.

836
00:38:15,200 --> 00:38:17,700
And and that is pretty much all we need to do.

837
00:38:17,700 --> 00:38:23,700
So now when we have the file name, this guy can be done this way.

838
00:38:23,900 --> 00:38:24,000
It is

839
00:38:24,200 --> 00:38:25,700
Is again not a great way to do this.

840
00:38:25,700 --> 00:38:28,000
I'm just doing cuz we don't care about this code very much.

841
00:38:28,000 --> 00:38:30,500
I don't want to think about strings or anything at this point.

842
00:38:30,500 --> 00:38:31,900
So we're not doing anything clever.

843
00:38:32,100 --> 00:38:34,700
We're doing just things very basic and very uninteresting.

844
00:38:35,200 --> 00:38:37,800
There's better ways we could do some of the stuff we wanted to take a

845
00:38:37,800 --> 00:38:41,100
day or two and talk about strings and do a nice string implementation.

846
00:38:41,400 --> 00:38:44,600
Eventually we may get there but I don't anticipate us doing a whole

847
00:38:44,600 --> 00:38:48,200
lot with strings in this app anyway, so I'm not even sure that that's

848
00:38:48,500 --> 00:38:52,600
really all that productive anyway, so we're just going to go ahead and

849
00:38:52,600 --> 00:38:53,100
do this.

850
00:38:54,200 --> 00:38:56,700
Skal here win32 get input file location.

851
00:38:56,700 --> 00:38:58,100
We will pass the recording index.

852
00:38:58,100 --> 00:38:59,800
So, that in the future, when we do actually,

853
00:39:00,000 --> 00:39:01,500
And make that maybe work.

854
00:39:01,500 --> 00:39:06,700
If we decide to make it work for for more slots, we can.

855
00:39:06,900 --> 00:39:08,800
And it's passing through properly.

856
00:39:09,300 --> 00:39:11,500
We'll go ahead and take that out of there.

857
00:39:11,900 --> 00:39:13,700
So that's going to be the file name now.

858
00:39:14,700 --> 00:39:15,500
Compile that.

859
00:39:15,800 --> 00:39:16,100
Oops.

860
00:39:16,400 --> 00:39:17,300
What did I do wrong?

861
00:39:18,300 --> 00:39:18,900
Oh, right.

862
00:39:18,900 --> 00:39:20,700
It's true waiting for you to State.

863
00:39:20,900 --> 00:39:24,600
I decided not to call it win32 state but there's some places where it

864
00:39:24,600 --> 00:39:25,500
is still called that.

865
00:39:25,500 --> 00:39:28,600
So let's just get rid of that because there's really no reason keep

866
00:39:28,600 --> 00:39:29,900
saying that there aren't multiple.

867
00:39:30,000 --> 00:39:31,600
All states in these things.

868
00:39:31,600 --> 00:39:34,900
So it seems like it should just be called State.

869
00:39:36,400 --> 00:39:39,500
I could call it win32 State everywhere suppose that the other option,

870
00:39:40,100 --> 00:39:42,200
but it just seems like a necessary typing, so I don't know.

871
00:39:42,600 --> 00:39:46,800
All right, so we did the file name and one of them looks like it

872
00:39:46,800 --> 00:39:47,500
worked properly.

873
00:39:47,500 --> 00:39:50,100
So let's go ahead and do the file name and the other one as well and

874
00:39:50,100 --> 00:39:51,300
now they're both calling.

875
00:39:51,900 --> 00:39:54,700
The other thing that I like about this is they're both calling

876
00:39:55,100 --> 00:39:55,700
through.

877
00:39:56,000 --> 00:39:59,800
There's that mean not ever having a consistent capitalization for.

878
00:40:00,000 --> 00:40:05,200
Oh man, basically now, they're both going through the same function to

879
00:40:05,200 --> 00:40:11,000
get the the name as well, which I like, because that way I know that

880
00:40:11,000 --> 00:40:14,500
the names match up before there was a separate string in each of them

881
00:40:14,500 --> 00:40:15,900
and that's not so good.

882
00:40:16,000 --> 00:40:16,500
Right?

883
00:40:17,000 --> 00:40:19,800
So this way, they're both calling the same function to get the names

884
00:40:19,800 --> 00:40:20,700
of recording files.

885
00:40:20,700 --> 00:40:22,400
So hopefully they'll line up.

886
00:40:23,300 --> 00:40:26,600
So basically that's that's really all that is to it.

887
00:40:26,600 --> 00:40:27,200
Let me test.

888
00:40:27,200 --> 00:40:28,300
I did a bunch of changes there.

889
00:40:28,300 --> 00:40:29,700
Let me test to make sure

890
00:40:30,600 --> 00:40:31,800
that we actually,

891
00:40:33,200 --> 00:40:35,400
See here that we actually have.

892
00:40:35,600 --> 00:40:36,800
There's definitely some audio clicking.

893
00:40:36,800 --> 00:40:38,700
So I think I definitely broke something.

894
00:40:39,200 --> 00:40:40,400
We'll have to see about that.

895
00:40:40,900 --> 00:40:41,300
See.

896
00:40:54,700 --> 00:40:55,100
Yeah.

897
00:41:00,000 --> 00:41:02,900
All right, so that looks like it's all good.

898
00:41:03,800 --> 00:41:05,000
Although I don't know if we have

899
00:41:06,100 --> 00:41:07,300
What's going on here?

900
00:41:09,500 --> 00:41:10,300
GE.

901
00:41:12,100 --> 00:41:16,700
I can't get, I need to get to my code, but I can't.

902
00:41:17,900 --> 00:41:18,600
Damn you.

903
00:41:18,600 --> 00:41:21,200
This is the problem with the top-level window stuff.

904
00:41:21,700 --> 00:41:23,300
What was the actual as though?

905
00:41:23,300 --> 00:41:27,700
The assertion was here, a certain new state ended down not equal to is

906
00:41:27,700 --> 00:41:29,200
down, huh?

907
00:41:30,300 --> 00:41:33,400
That I would not have been expecting basically that says that there

908
00:41:33,400 --> 00:41:41,500
was a time when the keyboard input state was not, well, I could

909
00:41:41,500 --> 00:41:44,500
actually see that being true once in a while, when because we don't

910
00:41:44,500 --> 00:41:47,800
actually handle things, like switching apps, switching the app and

911
00:41:47,800 --> 00:41:48,000
then.

912
00:41:48,000 --> 00:41:48,200
Yeah.

913
00:41:48,200 --> 00:41:50,900
All right, I could actually see that being true once in a while.

914
00:41:51,200 --> 00:41:53,700
That's something we have to talk about when we get to the more

915
00:41:53,700 --> 00:41:55,200
industrial strength input handling.

916
00:41:55,200 --> 00:41:56,000
So I'm not going to.

917
00:41:56,200 --> 00:41:59,200
I don't think we needed to worry about that quite just yet.

918
00:41:59,500 --> 00:41:59,800
But yeah.

919
00:42:00,900 --> 00:42:01,600
All right.

920
00:42:02,100 --> 00:42:05,600
So what what was I about to do there?

921
00:42:05,600 --> 00:42:08,500
I was checking the oh, the filename thing worked properly.

922
00:42:08,600 --> 00:42:13,500
I'm going to get rid of that on top layered nonsense because I think

923
00:42:13,500 --> 00:42:14,900
that's going to cause us some problems.

924
00:42:14,900 --> 00:42:19,800
So I'm going to get rid of that until we actually until we actually

925
00:42:19,800 --> 00:42:21,200
decide to spend some time on that.

926
00:42:21,200 --> 00:42:22,500
So we don't keep having this problem.

927
00:42:22,500 --> 00:42:24,600
Where our window is is being mean.

928
00:42:25,100 --> 00:42:25,600
All right.

929
00:42:26,400 --> 00:42:26,900
There we go.

930
00:42:30,500 --> 00:42:31,000
Much better.

931
00:42:31,400 --> 00:42:31,800
Okay.

932
00:42:32,700 --> 00:42:35,200
So took care of that.

933
00:42:36,100 --> 00:42:39,400
So in theory, let's take a look here.

934
00:42:40,600 --> 00:42:44,200
That should be the end of the path for those guys.

935
00:42:44,400 --> 00:42:46,400
So someone pointed it out.

936
00:42:46,400 --> 00:42:51,400
I was looking for this on the stream, but I never found it while we

937
00:42:51,400 --> 00:42:54,500
were on the stream when we were trying to get the date of files.

938
00:42:55,200 --> 00:42:58,100
I was looking for a way to do it without a handle and I couldn't quite

939
00:42:58,100 --> 00:42:59,900
find one, but

940
00:43:00,600 --> 00:43:03,500
Someone pointed out you can get it with this one.

941
00:43:04,600 --> 00:43:16,700
Get file attributes X, I guess so it looks like yeah looks like okay.

942
00:43:16,700 --> 00:43:17,900
So it looks like there it is.

943
00:43:18,100 --> 00:43:22,400
So it looks like we can use get file attributes X to get it without a

944
00:43:22,400 --> 00:43:23,000
handle.

945
00:43:23,100 --> 00:43:23,900
I'm not sure.

946
00:43:24,100 --> 00:43:26,500
Get file attributes doesn't do it.

947
00:43:26,500 --> 00:43:30,100
So only excess so what basically person wrote in and said is this

948
00:43:30,200 --> 00:43:32,300
The function, you are looking for because I don't know if you remember

949
00:43:32,300 --> 00:43:34,100
me trying to find it and I couldn't find it.

950
00:43:34,200 --> 00:43:37,000
I was like, I thought there was one you could use without a handle,

951
00:43:38,900 --> 00:43:40,100
but I never found it.

952
00:43:40,700 --> 00:43:41,700
Well, this is it.

953
00:43:41,800 --> 00:43:46,500
So, if we go to where we were getting that get last right time instead

954
00:43:46,500 --> 00:43:47,400
of having to do this fine.

955
00:43:47,400 --> 00:43:51,700
First find clothes thing we can basically say, okay, let's not do that

956
00:43:51,700 --> 00:43:52,300
anymore.

957
00:43:52,600 --> 00:43:54,100
That's, that's not necessary.

958
00:43:54,400 --> 00:43:57,400
Let's just use, let's just use this guy.

959
00:43:57,500 --> 00:44:00,100
Get file, attribute CX will pass the file.

960
00:44:00,300 --> 00:44:03,100
Just like we were before and of course, it's inconsistently

961
00:44:03,100 --> 00:44:06,700
capitalized because I always for some reason cannot seem to figure out

962
00:44:06,700 --> 00:44:10,500
how to do that and then we'll pass whatever this thing wants.

963
00:44:10,900 --> 00:44:14,300
So it wants a class of attribute to receive the parameter can be one

964
00:44:14,300 --> 00:44:17,600
of the following values and it looks like get file X.

965
00:44:17,600 --> 00:44:20,000
Info standard is the value.

966
00:44:20,900 --> 00:44:23,700
It's a very odd value to pass, but that's it.

967
00:44:23,800 --> 00:44:29,800
So I'll pass get file X info standard and then it wants me to pass one

968
00:44:29,800 --> 00:44:30,100
of these.

969
00:44:30,200 --> 00:44:34,400
These guys, as the as the file information out / am.

970
00:44:34,900 --> 00:44:38,300
So basically, I have to declare one of those to hold it.

971
00:44:39,300 --> 00:44:42,600
This is the data, then I will pass the address of it, and it should

972
00:44:42,600 --> 00:44:43,500
fill it out for me.

973
00:44:43,700 --> 00:44:44,800
It should return a Bool.

974
00:44:44,800 --> 00:44:47,000
It looks like for whether it found it or not.

975
00:44:47,500 --> 00:44:52,300
And then if it did, I will basically say that whatever that said.

976
00:44:52,300 --> 00:44:54,200
The last right, time is what I will do.

977
00:44:56,500 --> 00:44:58,600
Oops, that's a mistake.

978
00:45:00,100 --> 00:45:06,100
And if there and so that should give us the same results but in a much

979
00:45:06,100 --> 00:45:08,700
smoother way, we don't have to actually deal with an operating system

980
00:45:08,700 --> 00:45:09,100
handle.

981
00:45:09,500 --> 00:45:14,700
So hopefully that will that will let us do it much smoother.

982
00:45:14,700 --> 00:45:16,200
So, let's see if that actually works.

983
00:45:16,900 --> 00:45:21,400
If I go over here and make my emacs tinier.

984
00:45:21,600 --> 00:45:25,100
If I go do the standard code edit that we've been doing to test our

985
00:45:25,100 --> 00:45:26,000
hot reloading.

986
00:45:26,400 --> 00:45:29,900
Let's just check to see if it still is nice and snappy.

987
00:45:30,000 --> 00:45:32,000
Happy, sure is beautiful.

988
00:45:32,400 --> 00:45:36,200
Alright, so yeah, that's just a better way of doing what we were

989
00:45:36,200 --> 00:45:36,500
doing.

990
00:45:36,500 --> 00:45:39,300
It's just a finding the right Windows call, can sometimes take a

991
00:45:39,300 --> 00:45:43,800
while, but oftentimes there is like a better call for doing various

992
00:45:43,800 --> 00:45:45,100
things and that's definitely better.

993
00:45:45,300 --> 00:45:46,600
So we can get rid of this one.

994
00:45:46,900 --> 00:45:48,200
We won't need that one anymore.

995
00:45:48,400 --> 00:45:49,000
There we go.

996
00:45:49,500 --> 00:45:52,900
All right, so that should be all there is to that.

997
00:45:53,800 --> 00:45:55,500
We're getting through a lot of stuff here.

998
00:45:55,800 --> 00:45:56,800
Let's see.

999
00:45:58,700 --> 00:45:59,400
What else we got?

1000
00:45:59,400 --> 00:46:01,300
What else is on the, on the hopper?

1001
00:46:02,300 --> 00:46:03,000
All right.

1002
00:46:03,000 --> 00:46:08,800
So this is one that is kind of interesting to try a pair of Onsen

1003
00:46:08,800 --> 00:46:09,400
wrote this in.

1004
00:46:09,400 --> 00:46:09,800
Actually.

1005
00:46:09,800 --> 00:46:11,400
He's a person.

1006
00:46:11,400 --> 00:46:12,500
I actually know personally.

1007
00:46:14,200 --> 00:46:15,400
He used to work at rad game tools.

1008
00:46:15,400 --> 00:46:17,000
I believe he is that Oculus now.

1009
00:46:21,200 --> 00:46:28,400
But basically, he was suggesting to try something, which I think is

1010
00:46:28,900 --> 00:46:30,700
pretty interesting and it may work.

1011
00:46:30,700 --> 00:46:31,400
I don't know.

1012
00:46:31,400 --> 00:46:35,100
I don't think I've ever tried this before but basically what he was

1013
00:46:35,100 --> 00:46:38,800
saying was that and I may be putting words in his mouth there because

1014
00:46:38,800 --> 00:46:40,800
he tweeted it to me.

1015
00:46:40,800 --> 00:46:42,700
So it course with 140 characters.

1016
00:46:43,200 --> 00:46:44,400
Sometimes it's hard to know.

1017
00:46:44,600 --> 00:46:50,000
But basically when we when we go to write out our, our recording when

1018
00:46:50,000 --> 00:46:50,700
we do our work,

1019
00:46:50,900 --> 00:46:55,800
Hurting and we want to blast out that huge memory buffer like a lot of

1020
00:46:55,800 --> 00:46:59,100
its zeros if it hasn't been used yet.

1021
00:46:59,400 --> 00:47:02,800
And so one of the things that he was pointing out is you might be able

1022
00:47:02,800 --> 00:47:09,000
to use when NTFS is sparse file information to make that right faster

1023
00:47:09,000 --> 00:47:13,100
in the cases for free basically in the cases where there isn't that

1024
00:47:13,100 --> 00:47:14,100
much stuff in it.

1025
00:47:14,100 --> 00:47:17,900
Now, I don't think this will help us at all in the case when we

1026
00:47:17,900 --> 00:47:19,400
actually have the full running game.

1027
00:47:19,400 --> 00:47:20,700
So it's maybe kind of

1028
00:47:20,900 --> 00:47:24,400
A hollow victory in some sense, but for the time being, it may help us

1029
00:47:25,100 --> 00:47:29,900
because yeah, it may help us make the right faster in cases where we

1030
00:47:29,900 --> 00:47:33,600
don't have where we don't have stuff.

1031
00:47:34,700 --> 00:47:36,300
It actually filling the memory buffer.

1032
00:47:36,700 --> 00:47:42,700
So basically device IO controls, the thing that sort of tells Windows

1033
00:47:42,700 --> 00:47:46,200
additional information about handles and how you want them to work.

1034
00:47:46,300 --> 00:47:49,500
So we have a handle to a file here that we created and we can give it

1035
00:47:49,500 --> 00:47:50,700
some information about how we

1036
00:47:50,900 --> 00:47:53,400
expect rights to happen to that file.

1037
00:47:53,400 --> 00:47:59,200
And so the thing that we want to do is this device IO control call.

1038
00:47:59,200 --> 00:47:59,900
We want to

1039
00:48:00,000 --> 00:48:04,500
That after this and the thing that we want to look at is this thing.

1040
00:48:04,700 --> 00:48:05,400
It's a bit weird.

1041
00:48:05,400 --> 00:48:07,500
It's called fctl set.

1042
00:48:08,300 --> 00:48:08,700
Oops.

1043
00:48:09,300 --> 00:48:10,900
What was it set sparse?

1044
00:48:10,900 --> 00:48:14,500
I think sets parse this guy.

1045
00:48:16,900 --> 00:48:21,000
So, oh they've already filled out the whole thing for me that's even

1046
00:48:21,000 --> 00:48:21,500
easier.

1047
00:48:21,800 --> 00:48:22,500
So okay.

1048
00:48:22,500 --> 00:48:25,100
That's basically what we that is the call that we want to do.

1049
00:48:25,700 --> 00:48:27,900
And so what this does,

1050
00:48:29,700 --> 00:48:35,600
Is it says that a particular file is allowed to be stored or that

1051
00:48:35,600 --> 00:48:39,800
windows can look to see if large ranges of the file are 0.

1052
00:48:40,000 --> 00:48:43,000
And if they don't need to be stored, then they just won't be stored.

1053
00:48:43,100 --> 00:48:47,400
So since we know that almost all of our memory is 0 right now, it

1054
00:48:47,400 --> 00:48:51,700
might be that that helps Windows do this operation a lot more quickly,

1055
00:48:51,700 --> 00:48:52,400
right?

1056
00:48:52,800 --> 00:48:55,800
So basically, all we'd be doing here is just calling this device IO

1057
00:48:55,800 --> 00:48:58,400
control purely as a hint to Windows, basically.

1058
00:48:59,500 --> 00:49:02,200
Hey, we've got this handle, right?

1059
00:49:03,100 --> 00:49:04,700
We want to set it to sparse.

1060
00:49:06,100 --> 00:49:08,200
I don't know what the input buffer part is.

1061
00:49:08,700 --> 00:49:09,500
Let's see.

1062
00:49:12,300 --> 00:49:13,800
A pointer to the sparsely.

1063
00:49:13,800 --> 00:49:15,400
So the parameter is optional, if it's null.

1064
00:49:15,400 --> 00:49:16,900
So we don't we don't care about that.

1065
00:49:17,000 --> 00:49:18,900
We're not going to set that at all.

1066
00:49:19,600 --> 00:49:21,800
And the in buffer size will also be 0.

1067
00:49:22,300 --> 00:49:29,400
The output buffer will be 0, that will be 0 B returned that can be

1068
00:49:29,400 --> 00:49:30,000
known as well.

1069
00:49:30,000 --> 00:49:30,600
Right?

1070
00:49:30,800 --> 00:49:32,800
Let's see if we're just null.

1071
00:49:33,600 --> 00:49:35,300
Help B, return cannot be null.

1072
00:49:35,400 --> 00:49:36,400
Even when operates returns.

1073
00:49:36,400 --> 00:49:36,800
No output.

1074
00:49:36,800 --> 00:49:37,000
Okay.

1075
00:49:37,000 --> 00:49:38,000
So we do have two best.

1076
00:49:38,200 --> 00:49:40,300
We do have to pass it a d word here.

1077
00:49:40,300 --> 00:49:41,200
That's ignored.

1078
00:49:41,300 --> 00:49:41,900
Of course.

1079
00:49:42,100 --> 00:49:43,400
Because why wouldn't you do that?

1080
00:49:44,100 --> 00:49:47,500
So there's our ignored value, basically.

1081
00:49:47,500 --> 00:49:49,100
So the all we're doing is just telling it.

1082
00:49:49,100 --> 00:49:51,900
Hey, you can store this file sparsely.

1083
00:49:51,900 --> 00:49:55,800
If you want to you don't have to record all of those long zero runs,

1084
00:49:56,300 --> 00:49:58,300
so just, you know, be advised.

1085
00:49:58,400 --> 00:50:02,200
So I don't know if that'll actually help or not, but it did seem like

1086
00:50:02,200 --> 00:50:03,200
a pretty smart thing to try.

1087
00:50:03,200 --> 00:50:04,500
So I did want to try it.

1088
00:50:04,500 --> 00:50:05,200
So, let's see.

1089
00:50:07,900 --> 00:50:09,800
That does not seem to be any faster to me.

1090
00:50:14,400 --> 00:50:16,300
Yeah, so it doesn't actually seem.

1091
00:50:17,700 --> 00:50:19,300
To improve the performance at all.

1092
00:50:20,000 --> 00:50:21,800
Now, I may not have done it quite right.

1093
00:50:21,900 --> 00:50:23,500
I think I did but I'm not entirely.

1094
00:50:23,500 --> 00:50:23,800
Sure.

1095
00:50:23,800 --> 00:50:24,700
Let's double-check.

1096
00:50:25,200 --> 00:50:25,800
So let's see.

1097
00:50:25,800 --> 00:50:26,200
Here.

1098
00:50:27,200 --> 00:50:27,900
We get the recording.

1099
00:50:27,900 --> 00:50:29,700
Can do we create a generic right?

1100
00:50:29,900 --> 00:50:30,800
For the file?

1101
00:50:31,100 --> 00:50:35,100
We set the thing too, sparse.

1102
00:50:35,700 --> 00:50:38,200
Yeah, so that doesn't actually appear to help.

1103
00:50:39,600 --> 00:50:40,400
Hmm.

1104
00:50:44,200 --> 00:50:45,700
Does not appear to help to me.

1105
00:50:45,700 --> 00:50:47,400
So I'm going to say we don't actually do that.

1106
00:50:47,400 --> 00:50:50,600
It would have been nice if it did but I don't think it actually does.

1107
00:50:50,600 --> 00:50:52,700
So I'm going to go ahead and pull that.

1108
00:50:53,000 --> 00:50:54,700
All right too bad.

1109
00:50:54,700 --> 00:50:55,600
That might have been fun.

1110
00:50:56,200 --> 00:50:57,500
But what can you do?

1111
00:50:58,700 --> 00:50:59,800
Let's see.

1112
00:51:00,200 --> 00:51:01,100
What else I got here?

1113
00:51:01,100 --> 00:51:03,400
I got some of the things, some of these things.

1114
00:51:03,400 --> 00:51:06,300
Maybe we'll say for tomorrow, multiple translations units.

1115
00:51:06,300 --> 00:51:09,500
Okay, so somebody was asking some people have importing handmade here

1116
00:51:09,500 --> 00:51:12,800
obviously to other platforms and they were just asking basically for

1117
00:51:12,800 --> 00:51:13,200
something.

1118
00:51:13,200 --> 00:51:15,200
If we could do to make their lives a little easier.

1119
00:51:15,500 --> 00:51:18,300
Basically, what it is is there's these sub functions, right?

1120
00:51:19,400 --> 00:51:22,400
And the stub functions are in the header file.

1121
00:51:22,500 --> 00:51:27,000
And so what ends up happening, is they the stub functions being in the

1122
00:51:27,000 --> 00:51:28,400
header means that.

1123
00:51:28,400 --> 00:51:29,900
If they have multiple translations,

1124
00:51:30,000 --> 00:51:32,700
In units that all include the header file, then the thing gets defined

1125
00:51:32,700 --> 00:51:33,400
multiple times.

1126
00:51:37,000 --> 00:51:37,600
Right.

1127
00:51:38,700 --> 00:51:41,400
So there's a couple things we could do here.

1128
00:51:41,400 --> 00:51:43,800
We could make sure that these things are only defined once if we

1129
00:51:43,800 --> 00:51:44,500
wanted to.

1130
00:51:45,400 --> 00:51:48,800
And you know, that's one way to go.

1131
00:51:49,100 --> 00:51:51,700
The other thing we could do is just guard, the calls to them.

1132
00:51:51,800 --> 00:51:54,300
And so, what I think what I might do is just guard, the calls to them

1133
00:51:54,800 --> 00:51:55,500
entirely.

1134
00:51:55,600 --> 00:51:57,000
So, just get rid of the stubs.

1135
00:51:57,200 --> 00:51:58,600
The only reason the stubs were there.

1136
00:52:00,700 --> 00:52:05,400
Was to make it so that you could use this function calls, even if

1137
00:52:05,400 --> 00:52:07,300
there was an even if it was invalid.

1138
00:52:07,800 --> 00:52:11,100
But really all we have to do is just say that it's always going to be

1139
00:52:11,100 --> 00:52:11,900
0.

1140
00:52:13,100 --> 00:52:15,400
So we could, we could always just say that it's zero.

1141
00:52:15,400 --> 00:52:18,100
And then anywhere that we're going to call update and render.

1142
00:52:19,700 --> 00:52:23,000
Again, just clearing this 20, anywhere that we're going to call update

1143
00:52:23,000 --> 00:52:24,600
and render will just check.

1144
00:52:24,900 --> 00:52:29,100
We'll just check the sea and we just won't call it if it's, if it's

1145
00:52:29,100 --> 00:52:29,800
null, right?

1146
00:52:29,800 --> 00:52:30,300
That's, that's

1147
00:52:30,400 --> 00:52:33,300
We're going to do and that just seems to me to be a little more saying

1148
00:52:33,300 --> 00:52:36,200
we know there's, there's not going to be hardly any functions in here.

1149
00:52:36,700 --> 00:52:39,800
And there's only two time they're going to be called and so few places

1150
00:52:39,800 --> 00:52:41,400
will just say that you have to check for null.

1151
00:52:41,900 --> 00:52:43,700
So basically what we'll just Define.

1152
00:52:44,600 --> 00:52:49,800
Well, we will basically Define that excuse me, we will basically

1153
00:52:49,800 --> 00:52:54,300
Define this game code thing to say, you know, what note.

1154
00:52:55,300 --> 00:52:59,700
Either of the callbacks can be null, right?

1155
00:53:01,100 --> 00:53:03,300
You must check before calling.

1156
00:53:05,000 --> 00:53:08,100
And so, that's just, that's just a rule that we've made.

1157
00:53:08,500 --> 00:53:12,300
And that way people don't have to worry about that, that symbol being

1158
00:53:12,300 --> 00:53:13,000
multiplied, defined.

1159
00:53:13,000 --> 00:53:15,400
So that way, there's nothing in this header file.

1160
00:53:15,400 --> 00:53:18,800
That's a function that's being defined other than an inline, right,

1161
00:53:18,800 --> 00:53:22,200
other than these in lines, which inline functions, you can declare

1162
00:53:22,200 --> 00:53:24,300
multiple times because they just, they can be anywhere since they're

1163
00:53:24,300 --> 00:53:26,600
not declaring it and they're not actually making new function.

1164
00:53:26,600 --> 00:53:28,700
They're just basically a macro, you know, kind of thing that gets

1165
00:53:28,900 --> 00:53:30,100
inserted in code.

1166
00:53:31,200 --> 00:53:32,600
So that seems totally fine.

1167
00:53:33,600 --> 00:53:34,200
And that

1168
00:53:34,400 --> 00:53:37,700
It'll help some people out here, doing some porting work, and who

1169
00:53:37,700 --> 00:53:42,500
don't want to deal with with having to only have one one file in the

1170
00:53:42,500 --> 00:53:43,300
platform layer.

1171
00:53:43,700 --> 00:53:44,300
Like we are.

1172
00:53:44,700 --> 00:53:45,200
Okay.

1173
00:53:46,000 --> 00:53:48,800
So I think that maybe most of the stuff we're going to do today and

1174
00:53:48,800 --> 00:53:50,600
then we'll save the rest of the stuff for tomorrow.

1175
00:53:50,600 --> 00:53:55,600
Oh, well, I will say that there's a virtual Alec thing that I thought

1176
00:53:55,600 --> 00:53:59,800
might be good to do just for fun, which is that to release.

1177
00:54:00,000 --> 00:54:03,800
Some pressure on the the on the translation lookaside buffer

1178
00:54:03,800 --> 00:54:06,400
potentially something we haven't gotten to yet.

1179
00:54:06,800 --> 00:54:10,300
But one of the things that we could do is in our giant virtual lock

1180
00:54:11,300 --> 00:54:13,800
that we do down here.

1181
00:54:13,900 --> 00:54:14,500
This guy.

1182
00:54:15,200 --> 00:54:15,800
Where is he?

1183
00:54:16,200 --> 00:54:18,000
Oops virtual?

1184
00:54:19,200 --> 00:54:20,100
It's almost there.

1185
00:54:21,800 --> 00:54:22,200
There we go.

1186
00:54:23,100 --> 00:54:26,500
So in this is this guy where we do our giant virtual Alec, it might be

1187
00:54:26,500 --> 00:54:30,600
nice to allow the operating system to use large pages.

1188
00:54:31,400 --> 00:54:35,300
And so the way that this works is just me.

1189
00:54:36,600 --> 00:54:37,900
I believe.

1190
00:54:38,500 --> 00:54:41,000
Yeah, so there's this guy here, large Pages.

1191
00:54:42,800 --> 00:54:48,300
What large pages are, is when you do this mapping, when we're talking

1192
00:54:48,300 --> 00:54:50,300
about virtual membrane, right?

1193
00:54:51,400 --> 00:54:52,800
We've got our application.

1194
00:54:52,800 --> 00:54:56,400
Space is laid out in these pages, right?

1195
00:54:56,400 --> 00:54:59,500
We've got, we've got page size and that page size.

1196
00:54:59,500 --> 00:55:01,800
I think I was talking about before is usually for K.

1197
00:55:02,200 --> 00:55:03,500
So it's 4096.

1198
00:55:03,500 --> 00:55:04,000
Bytes.

1199
00:55:04,200 --> 00:55:05,900
And basically what has to happen is

1200
00:55:06,400 --> 00:55:08,700
Inside the processor, right?

1201
00:55:08,700 --> 00:55:12,900
Because remember, in fact, let's just do you know what, since this is

1202
00:55:12,900 --> 00:55:13,300
the Q&A?

1203
00:55:13,300 --> 00:55:15,500
Let's just we're since we're starting with you, and I let me, let me

1204
00:55:15,500 --> 00:55:19,200
just do a diagram here that explains this what's going to happen

1205
00:55:19,200 --> 00:55:20,600
because it's something that's useful to know.

1206
00:55:20,900 --> 00:55:23,200
So let's just use the first part of the Q&A for that.

1207
00:55:23,900 --> 00:55:24,700
So, okay.

1208
00:55:25,600 --> 00:55:27,300
Let's go over this one more time.

1209
00:55:28,100 --> 00:55:31,100
Here is physical memory, right?

1210
00:55:31,100 --> 00:55:32,400
So this is physical.

1211
00:55:33,500 --> 00:55:38,000
Ram if the actual RAM on your computer, so I don't know how much

1212
00:55:38,000 --> 00:55:38,600
you've got.

1213
00:55:38,600 --> 00:55:40,100
Let's say, it's a pretty good machine.

1214
00:55:40,300 --> 00:55:42,400
It's 16 GB, right?

1215
00:55:42,400 --> 00:55:45,700
So basically they're 16 gigs of physical memory in the machine.

1216
00:55:46,000 --> 00:55:48,000
It is actually laid out in order.

1217
00:55:48,100 --> 00:55:51,800
It goes from B 0 to B 16 gigs, right?

1218
00:55:52,300 --> 00:55:53,200
And it's all there.

1219
00:55:53,700 --> 00:55:55,500
Now in our process.

1220
00:55:55,700 --> 00:56:02,900
We have process virtual memory and that virtual memory is

1221
00:56:03,300 --> 00:56:07,600
Some other thing, it has no relationship really to this physical RAM,

1222
00:56:07,800 --> 00:56:08,400
right?

1223
00:56:08,400 --> 00:56:13,400
So we see, you know, B, 0 is, that's wow.

1224
00:56:13,400 --> 00:56:14,300
That's a great Arrow.

1225
00:56:14,900 --> 00:56:19,300
We see B 0 is here and I don't know we allocate we you know, who knows

1226
00:56:19,300 --> 00:56:20,400
how much we have.

1227
00:56:21,000 --> 00:56:24,700
But, but we're looking at memory, just kind of going up and this can

1228
00:56:24,700 --> 00:56:25,500
go all the way up.

1229
00:56:25,500 --> 00:56:30,000
I believe to 8 terabytes in 64-bit windows, for the app.

1230
00:56:30,100 --> 00:56:32,400
And then I think there's another 8 terabytes for the system.

1231
00:56:32,500 --> 00:56:33,100
I don't actually remember.

1232
00:56:33,200 --> 00:56:33,600
Member.

1233
00:56:34,000 --> 00:56:35,000
So I don't know if that's true.

1234
00:56:35,100 --> 00:56:36,800
But basically there's 8 terabytes.

1235
00:56:37,300 --> 00:56:39,900
This is again, the worst diagrams today is try that again.

1236
00:56:41,000 --> 00:56:44,500
8 terabytes for us and 8 terabytes for the system.

1237
00:56:44,500 --> 00:56:46,000
So that's like a 16 terabyte thing.

1238
00:56:46,000 --> 00:56:48,900
I think it looks something like that, but I don't actually know the.

1239
00:56:48,900 --> 00:56:51,600
I think this might be there might be a bunch of space in between here.

1240
00:56:51,600 --> 00:56:54,900
I'm not sure exactly what this looks like, but point being this is

1241
00:56:54,900 --> 00:56:56,500
some totally other space.

1242
00:56:57,000 --> 00:56:58,400
This is no bearing on.

1243
00:56:58,400 --> 00:56:59,200
Physical RAM.

1244
00:56:59,300 --> 00:56:59,800
We met

1245
00:57:00,000 --> 00:57:04,700
It's something and say oh, you know in a fact we did when we did our

1246
00:57:04,700 --> 00:57:05,900
virtual Alec right?

1247
00:57:06,000 --> 00:57:11,600
We asked for it to be at at this Base address right in the Base

1248
00:57:11,600 --> 00:57:11,900
address.

1249
00:57:11,900 --> 00:57:13,200
Was that two terabytes.

1250
00:57:13,400 --> 00:57:15,800
So we actually said oh, okay.

1251
00:57:16,100 --> 00:57:20,200
The Base address is somewhere like right here at two terabytes.

1252
00:57:20,400 --> 00:57:21,600
Well 2 terabytes.

1253
00:57:22,100 --> 00:57:24,200
There's only 16 gigabytes in the Machine 2.

1254
00:57:24,200 --> 00:57:26,900
Terabytes is way off the end of physical memory if you think about

1255
00:57:26,900 --> 00:57:28,200
where it actually is located.

1256
00:57:28,400 --> 00:57:29,600
So this is a purely

1257
00:57:30,000 --> 00:57:33,900
Fictional address that we've created and so our game exists in one

1258
00:57:33,900 --> 00:57:36,100
gigabyte of memory right here or whatever.

1259
00:57:36,600 --> 00:57:38,900
It's a little more than that because we have 64, Meg's of perm store

1260
00:57:38,900 --> 00:57:39,300
or whatever.

1261
00:57:39,300 --> 00:57:44,100
But like we said at the to 2 terabyte range, we're going to use the

1262
00:57:44,100 --> 00:57:47,900
number 2 terabytes and every all the bytes in between there and and

1263
00:57:47,900 --> 00:57:50,800
one gig from, there are going to be part of our game.

1264
00:57:51,600 --> 00:57:55,700
Those numbers have to correspond to Something in here when the

1265
00:57:55,700 --> 00:57:58,100
processor is actually doing work, right?

1266
00:57:58,200 --> 00:57:59,900
So the CPU is

1267
00:58:00,000 --> 00:58:01,300
In here, running our game.

1268
00:58:01,500 --> 00:58:04,000
It's going to see a number that looks like two terabytes.

1269
00:58:04,200 --> 00:58:05,500
So 2 terabyte number.

1270
00:58:05,500 --> 00:58:08,400
The number 2, terabytes, whatever.

1271
00:58:08,400 --> 00:58:08,800
It is.

1272
00:58:09,400 --> 00:58:09,900
Some number.

1273
00:58:09,900 --> 00:58:11,400
It's actually some big number.

1274
00:58:11,400 --> 00:58:13,300
That's like, complicated and long, right?

1275
00:58:13,300 --> 00:58:15,400
Two terabytes with some fractional part or whatever.

1276
00:58:15,400 --> 00:58:15,800
Right?

1277
00:58:16,400 --> 00:58:19,000
So some crazy long byte address.

1278
00:58:19,000 --> 00:58:21,400
And in fact, I can even make this more concrete, right?

1279
00:58:21,800 --> 00:58:25,200
Let's go in and just see one of the numbers I can give you an example

1280
00:58:25,500 --> 00:58:26,700
of exactly what it is.

1281
00:58:27,600 --> 00:58:29,500
Inside our game.

1282
00:58:31,300 --> 00:58:32,000
Let's see here.

1283
00:58:32,700 --> 00:58:33,600
Let's take a look.

1284
00:58:34,200 --> 00:58:35,200
Let's take a look.

1285
00:58:36,200 --> 00:58:44,100
So we go into our, our game call which I need to put some comments in

1286
00:58:44,100 --> 00:58:44,600
here soon.

1287
00:58:44,600 --> 00:58:46,100
So I can find my way around.

1288
00:58:46,800 --> 00:58:51,200
I keep getting lost in my own code because I haven't made any markers

1289
00:58:51,200 --> 00:58:51,600
in it.

1290
00:58:54,800 --> 00:58:55,900
What's going on?

1291
00:58:55,900 --> 00:58:58,500
Why can I set a breakpoint recompile?

1292
00:58:59,000 --> 00:58:59,500
Run?

1293
00:58:59,800 --> 00:59:00,300
There we go.

1294
00:59:01,100 --> 00:59:01,600
Ok.

1295
00:59:01,900 --> 00:59:05,100
So inside here, here's game update and render, right?

1296
00:59:05,200 --> 00:59:08,900
So let's just take a look at what the pointer to like.

1297
00:59:08,900 --> 00:59:14,000
Say the player, X, where is player X being stored in memory?

1298
00:59:14,100 --> 00:59:14,500
Right?

1299
00:59:14,600 --> 00:59:17,200
Well, there's the number and you can see, there's that two terabyte or

1300
00:59:17,200 --> 00:59:21,300
whatever and there's the like, fractional part of it, that the offset

1301
00:59:21,300 --> 00:59:22,300
from there, right?

1302
00:59:22,700 --> 00:59:23,200
So, that's the

1303
00:59:23,500 --> 00:59:29,800
Or if you actually look at what this equals in in a decimal, right?

1304
00:59:29,800 --> 00:59:31,600
Let me try and cast that to a decimal.

1305
00:59:32,000 --> 00:59:34,600
I don't know if it'll actually do it or not does not appear to

1306
00:59:34,600 --> 00:59:35,300
actually do it.

1307
00:59:36,100 --> 00:59:37,800
Why won't you convert it?

1308
00:59:39,200 --> 00:59:39,800
There it is.

1309
00:59:40,400 --> 00:59:43,600
So I guess I don't know my way around the visual studio Watchman, do

1310
00:59:43,600 --> 00:59:45,400
comment, comma syntax, very well.

1311
00:59:45,400 --> 00:59:48,400
But if you put a comma after something, and then you do these codes,

1312
00:59:48,400 --> 00:59:50,700
you can use in Visual Studio, that will turn it into different number

1313
00:59:50,700 --> 00:59:51,200
types.

1314
00:59:51,400 --> 00:59:53,000
Select up, be is binary.

1315
00:59:53,200 --> 00:59:55,800
That's a new one that we that didn't used to work the works.

1316
00:59:55,800 --> 00:59:57,400
Now D is decimal.

1317
00:59:57,700 --> 00:59:59,900
So you can see this is actually the number this.

1318
01:00:00,000 --> 01:00:03,700
A number of the processor actually sees when we go to reference player

1319
01:00:03,700 --> 01:00:06,800
X, the processor sees this number, right?

1320
01:00:06,900 --> 01:00:11,000
So that number is coming into the CPU here, right?

1321
01:00:11,000 --> 01:00:14,400
It's the, the CPU is seeing this, that crazy number.

1322
01:00:14,400 --> 01:00:19,400
We just said now that number doesn't exist that that location in

1323
01:00:19,400 --> 01:00:19,800
physical.

1324
01:00:19,800 --> 01:00:20,900
RAM does not exist.

1325
01:00:21,200 --> 01:00:23,800
There aren't two terabytes of memory, even in the machine.

1326
01:00:23,900 --> 01:00:28,300
Let alone, two terabytes plus whatever that was, you know, plus some

1327
01:00:28,500 --> 01:00:29,800
where we were looking at it would

1328
01:00:30,000 --> 01:00:32,400
Be way way off the end of physical memory.

1329
01:00:32,700 --> 01:00:38,400
So what has to happen is the CPU, has to translate that address into

1330
01:00:38,400 --> 01:00:42,700
wherever the memory is actually being stored in physical RAM, which

1331
01:00:42,700 --> 01:00:44,100
the operating system manages.

1332
01:00:44,300 --> 01:00:48,200
It basically pulls in parts of the memory that we asked for and keeps

1333
01:00:48,200 --> 01:00:48,400
them in.

1334
01:00:48,400 --> 01:00:51,500
Physical RAM as necessary, and it can do stuff like swap them out to

1335
01:00:51,500 --> 01:00:53,200
disk if it needs to write.

1336
01:00:53,200 --> 01:00:55,200
There's a paging file, right?

1337
01:00:56,700 --> 01:01:00,600
It can swap pieces out to disk if it runs out of physical RAM storing

1338
01:01:00,600 --> 01:01:00,900
stuff.

1339
01:01:00,900 --> 01:01:01,900
It can move it out to disk.

1340
01:01:01,900 --> 01:01:06,300
And in fact, you can see it move it out to disk if you actually look.

1341
01:01:06,900 --> 01:01:08,500
I think it can see it here.

1342
01:01:09,400 --> 01:01:11,700
Let's see if I can see it here.

1343
01:01:12,000 --> 01:01:14,000
So yeah, you can see on the C drive.

1344
01:01:14,100 --> 01:01:14,300
There.

1345
01:01:14,300 --> 01:01:16,300
It is right there page file dot sis.

1346
01:01:17,200 --> 01:01:22,300
So if I do pagefile this and do a doron that well, alright, so it

1347
01:01:22,300 --> 01:01:24,800
won't let me do it because it's some operating system protected file

1348
01:01:24,800 --> 01:01:26,300
nonsense, I guess but

1349
01:01:26,500 --> 01:01:28,000
I can see it there that page failed out.

1350
01:01:28,000 --> 01:01:33,200
Sis is actually where it's writing the stuff that gets swapped out.

1351
01:01:34,500 --> 01:01:42,400
So in this process, what has to happen is there has to be a way for

1352
01:01:42,400 --> 01:01:45,300
the CPU to translate those addresses.

1353
01:01:45,300 --> 01:01:49,400
It has to do work to support virtual memory, virtual memory isn't

1354
01:01:49,400 --> 01:01:49,700
free.

1355
01:01:49,700 --> 01:01:53,600
The CPU has to actually dedicate circuitry for doing this process.

1356
01:01:53,600 --> 01:01:55,900
So how does it translate that number?

1357
01:01:56,000 --> 01:01:58,500
Well, the way that it does that is in chunks.

1358
01:02:02,300 --> 01:02:03,100
Basically.

1359
01:02:04,200 --> 01:02:09,300
Each 4K page right for so 4096.

1360
01:02:09,300 --> 01:02:11,700
Bytes worth of memory.

1361
01:02:12,200 --> 01:02:12,500
Each.

1362
01:02:12,500 --> 01:02:18,700
4K page basically is mapped individually between virtual memory and

1363
01:02:18,700 --> 01:02:19,600
physical memory.

1364
01:02:19,800 --> 01:02:22,000
Such that there is a page table.

1365
01:02:23,100 --> 01:02:26,700
Which literally says stuff like, you know, okay, you know, you can

1366
01:02:26,700 --> 01:02:31,200
imagine something like, there's the physical address and the virtual

1367
01:02:31,200 --> 01:02:34,900
address, right, and they're mapped in like a table.

1368
01:02:35,000 --> 01:02:35,600
So we basically.

1369
01:02:35,600 --> 01:02:41,800
Oh, physical address, you know, 16 or something maps to Virtual

1370
01:02:41,800 --> 01:02:44,900
address, you know, 2048 or whatever, right?

1371
01:02:44,900 --> 01:02:49,000
It's basically just a thing that says, the 4K based at this address.

1372
01:02:49,100 --> 01:02:51,300
Well, they don't these would all be on 4K boundaries obviously.

1373
01:02:51,300 --> 01:02:52,600
So those are stupid examples.

1374
01:02:52,900 --> 01:02:59,800
But like the physical at two times 4096 and the virtual at 10.

1375
01:03:00,000 --> 01:03:02,400
X 4096 are the same page.

1376
01:03:02,400 --> 01:03:06,000
We have mapped this location to this location.

1377
01:03:06,000 --> 01:03:06,700
Right?

1378
01:03:07,200 --> 01:03:13,900
And what you have to appreciate is that this mapping isn't free.

1379
01:03:13,900 --> 01:03:17,200
It has to actually be stored and it has to actually be managed.

1380
01:03:17,200 --> 01:03:21,400
So the CPU has a bunch of stuff in it to try and make this faster and

1381
01:03:21,400 --> 01:03:24,600
one of the things that it has something called a tlb or translation

1382
01:03:24,600 --> 01:03:28,000
lookaside buffer and basically what that is is something

1383
01:03:28,800 --> 01:03:33,400
designed to translate addresses quickly by having a small number of

1384
01:03:33,400 --> 01:03:37,200
these mappings directly on the CPU, that can be looked up extremely

1385
01:03:37,200 --> 01:03:37,600
quickly.

1386
01:03:37,600 --> 01:03:41,200
It's basically like a cash for address translation, right?

1387
01:03:41,200 --> 01:03:44,500
And you can look this up if you want more information.

1388
01:03:44,800 --> 01:03:46,000
I'm not a CPU guy.

1389
01:03:46,000 --> 01:03:50,400
So I'm not the guy to give you the explanation on that, but you can

1390
01:03:50,400 --> 01:03:54,700
look for this translation lookaside buffer.

1391
01:03:55,400 --> 01:03:58,400
You can look for this on like Wikipedia and it can sort of

1392
01:03:58,600 --> 01:03:59,400
Tell you, right?

1393
01:03:59,400 --> 01:04:03,000
So it's cash for virtual addresses, like a saying and it can kind of

1394
01:04:03,000 --> 01:04:05,200
explain to you a little bit more about exactly how it works.

1395
01:04:05,200 --> 01:04:08,700
But the part that I'm trying to get to that, I thought was interesting

1396
01:04:08,700 --> 01:04:09,800
to kind of dive into here.

1397
01:04:09,800 --> 01:04:14,500
And the reason I want to talk about it was because if you think about

1398
01:04:14,500 --> 01:04:18,300
what happens, the number of entries in this table, the number of

1399
01:04:18,300 --> 01:04:21,800
entries in the number of total entries of translation that have to

1400
01:04:21,800 --> 01:04:23,200
happen in the operating system.

1401
01:04:23,600 --> 01:04:24,200
Right?

1402
01:04:24,400 --> 01:04:28,300
Is based on how big this number is, if each thing is 4K,

1403
01:04:29,000 --> 01:04:30,700
Then there's going to be a certain number of entries.

1404
01:04:30,900 --> 01:04:33,900
If everything was instead, 16k right?

1405
01:04:34,000 --> 01:04:37,300
Then there would be four times less entries because for the same

1406
01:04:37,300 --> 01:04:42,200
amount of memory to be mapped, each mapping stores four times the

1407
01:04:42,200 --> 01:04:43,900
amount of addresses, essentially, right?

1408
01:04:43,900 --> 01:04:47,200
Because you're mapping it in 16k blocks, which means that for a

1409
01:04:47,200 --> 01:04:49,600
translation lookaside buffer on the CPU.

1410
01:04:49,900 --> 01:04:53,900
If the pages are 4K, there's going to be a lot more entries in here

1411
01:04:53,900 --> 01:04:55,500
than if they were larger.

1412
01:04:55,800 --> 01:04:58,400
And so what I believe is that I believe you can switch to you.

1413
01:04:58,600 --> 01:05:01,100
Two megabyte, which is massively larger than for.

1414
01:05:01,100 --> 01:05:05,300
Okay, I believe you can switch to using 2, MB sizes for the

1415
01:05:05,300 --> 01:05:06,900
translation lookaside buffer.

1416
01:05:07,000 --> 01:05:08,000
I don't actually know if that's true.

1417
01:05:08,000 --> 01:05:10,400
But I think that's something like that is basically true.

1418
01:05:11,500 --> 01:05:15,400
And if you tell virtual a life, that you're okay, using large pages on

1419
01:05:15,400 --> 01:05:18,200
some operating systems on some versions of Windows.

1420
01:05:18,200 --> 01:05:21,900
I think it can actually switch your process to using 2.

1421
01:05:21,900 --> 01:05:23,100
MB Pages.

1422
01:05:23,300 --> 01:05:26,200
Which takes a lot of pressure off of that tlb.

1423
01:05:26,800 --> 01:05:28,300
And so, since we're allocating one,

1424
01:05:28,500 --> 01:05:32,100
Chunk, it may be that we can get a lot of benefit there and take

1425
01:05:32,100 --> 01:05:35,300
pressure off of the CPU by doing that.

1426
01:05:35,300 --> 01:05:37,200
So it's just something that I wanted to mention.

1427
01:05:37,400 --> 01:05:41,000
And so I think it's probably worth as passing that flag in the case

1428
01:05:41,000 --> 01:05:48,200
that we're not on Windows XP to just say, hey, you know, let's let's

1429
01:05:48,200 --> 01:05:50,600
go ahead and and use those large pages.

1430
01:05:50,800 --> 01:05:53,700
So what I want to do is I just want to go ahead and pass that.

1431
01:05:53,800 --> 01:05:54,700
That's about it.

1432
01:05:54,700 --> 01:05:58,400
I believe that's on, that's on the the mem commitment.

1433
01:05:58,500 --> 01:05:59,800
Curve, whatever side of.

1434
01:06:00,600 --> 01:06:03,900
So it's right in here we do that and I'm just going to put to do in

1435
01:06:03,900 --> 01:06:05,100
there to do.

1436
01:06:06,600 --> 01:06:08,600
Like do we need to not pass that in empty?

1437
01:06:08,600 --> 01:06:09,600
Will that mess up in t?

1438
01:06:09,600 --> 01:06:15,500
So do we need to not pass member large pages on Windows XP?

1439
01:06:16,000 --> 01:06:17,300
Or will it be fine?

1440
01:06:17,400 --> 01:06:18,900
Right, that's about it.

1441
01:06:19,400 --> 01:06:23,000
So I just wanted to try that because I think that may help us in the

1442
01:06:23,000 --> 01:06:27,900
future basically, avoid the situation where we have a lot of tlb

1443
01:06:27,900 --> 01:06:28,500
pressure.

1444
01:06:28,800 --> 01:06:30,100
That's just another thing that

1445
01:06:30,200 --> 01:06:33,500
Make life harder for the processor when it's trying to run our code.

1446
01:06:33,900 --> 01:06:35,200
So I just going to see if that works.

1447
01:06:36,100 --> 01:06:37,500
All right, so that doesn't work.

1448
01:06:37,500 --> 01:06:41,700
I assume there is a problem with allocating the mem large pages that

1449
01:06:41,700 --> 01:06:41,900
way.

1450
01:06:41,900 --> 01:06:43,100
I don't actually know what it is.

1451
01:06:43,100 --> 01:06:44,500
But I'm going to take a sari to eat up.

1452
01:06:44,500 --> 01:06:45,100
Q&A time.

1453
01:06:45,100 --> 01:06:48,100
We can go a little long but I just wanted to try that because I'd like

1454
01:06:48,100 --> 01:06:52,700
I've never used it before but I feel like it's something that we could

1455
01:06:52,700 --> 01:06:53,000
do.

1456
01:06:53,000 --> 01:06:57,700
So I'm going to see if there's anything particular that we have to do.

1457
01:06:58,700 --> 01:07:02,200
To use are two sorts lock memory, privileged privileged by calling

1458
01:07:02,200 --> 01:07:03,100
just tokens.

1459
01:07:03,200 --> 01:07:04,000
So we didn't do that.

1460
01:07:04,000 --> 01:07:07,100
We'd have to do that retrieve, the minimal large paid size.

1461
01:07:07,200 --> 01:07:08,400
Include member large pages.

1462
01:07:08,600 --> 01:07:11,100
So we'd also have to do a little bit extra.

1463
01:07:11,100 --> 01:07:15,500
It looks like here we have to actually call adjust token privileges to

1464
01:07:15,500 --> 01:07:17,900
basically say, hey, we're going to be a large page app.

1465
01:07:19,200 --> 01:07:22,500
Alright, so maybe I'll have to leave this as a to do for later, on in

1466
01:07:22,500 --> 01:07:23,800
things because that does actually sound.

1467
01:07:23,800 --> 01:07:26,200
Like I was hoping we could just say, hey, please let us use large

1468
01:07:26,200 --> 01:07:27,800
pages, but doesn't look that way.

1469
01:07:28,700 --> 01:07:35,200
So, let's see, use mem large pages and call adjust token.

1470
01:07:35,200 --> 01:07:36,100
Privileges.

1471
01:07:39,000 --> 01:07:42,200
When not on Windows XP, so that's something that I'd like to do in the

1472
01:07:42,200 --> 01:07:47,100
future because the translation lookaside buffer actually can cause you

1473
01:07:47,100 --> 01:07:50,000
to slow down because basically anytime you miss that translation,

1474
01:07:50,000 --> 01:07:53,600
lookaside buffer and you're accessing and a dress that needs to get

1475
01:07:53,600 --> 01:07:55,900
translated and you have to pull new entries into the tlb.

1476
01:07:55,900 --> 01:07:58,800
That's another source of processor slow down, right?

1477
01:07:58,900 --> 01:08:02,900
And so since we don't really care too much about how that memory is

1478
01:08:02,900 --> 01:08:06,100
page because we're trying to run in all of our game and memory.

1479
01:08:06,100 --> 01:08:08,500
At once I feel like there.

1480
01:08:08,600 --> 01:08:12,400
Isn't probably much of a downside to using the large Pages.

1481
01:08:12,400 --> 01:08:14,500
Maybe that's not true.

1482
01:08:14,500 --> 01:08:16,600
But I would least like to have it in our app.

1483
01:08:16,600 --> 01:08:19,500
So we could do some testing and like, turn it on and off and see if it

1484
01:08:19,500 --> 01:08:20,800
made a difference in any way.

1485
01:08:20,800 --> 01:08:23,399
And it might be that we find that it doesn't matter about it since we

1486
01:08:23,399 --> 01:08:25,000
can do it at thought, it might be nice to try.

1487
01:08:25,000 --> 01:08:31,000
All right, so I think that's about it and we are now into the Q&A.

1488
01:08:31,000 --> 01:08:38,600
So hopefully everyone knows the drill by now, if you could include

1489
01:08:38,600 --> 01:08:41,399
Include senior ettore in your question.

1490
01:08:41,399 --> 01:08:42,500
So I will see it.

1491
01:08:42,500 --> 01:08:43,500
That would be very helpful.

1492
01:08:43,500 --> 01:08:47,800
And please keep your questions to things we did on this stream or in a

1493
01:08:47,800 --> 01:08:50,700
previous stream, but not stuff that we're going to do a future streams

1494
01:08:50,700 --> 01:08:53,800
just because we will get there when we get there.

1495
01:08:54,100 --> 01:08:54,700
All right.

1496
01:08:54,899 --> 01:08:56,600
Let's see if we got any questions.

1497
01:09:02,899 --> 01:09:05,700
Course, I got to wait for the, gotta wait for the twitch lag'.

1498
01:09:05,700 --> 01:09:09,200
I got to wait for things to catch up here.

1499
01:09:10,100 --> 01:09:11,399
We got through quite a lot of stuff today.

1500
01:09:11,399 --> 01:09:12,200
I was pretty good.

1501
01:09:14,100 --> 01:09:15,100
That was pretty good.

1502
01:09:15,100 --> 01:09:17,399
A couple more things will have to do tomorrow, but we're in pretty

1503
01:09:17,399 --> 01:09:18,000
good shape.

1504
01:09:22,100 --> 01:09:25,200
Any questions any questions?

1505
01:09:29,300 --> 01:09:30,700
Any question.

1506
01:09:33,600 --> 01:09:35,700
Come on Twitch like ketchup.

1507
01:09:38,000 --> 01:09:41,800
Do do, do, do, do do.

1508
01:09:51,000 --> 01:09:55,500
Can we go over really fast overview of the game recording and Playback

1509
01:09:55,500 --> 01:09:56,100
code?

1510
01:09:57,500 --> 01:10:03,000
Sure, there's almost no code, though, but we can certainly go over it.

1511
01:10:04,400 --> 01:10:05,400
Very briefly.

1512
01:10:06,900 --> 01:10:08,300
There's basically nothing to it.

1513
01:10:08,600 --> 01:10:11,900
So, here are the parts that make it work.

1514
01:10:12,900 --> 01:10:14,100
Very simply again.

1515
01:10:14,100 --> 01:10:17,300
This is all, just because if you pick your architecture, right certain

1516
01:10:17,300 --> 01:10:20,500
things become very easy, I happen to pick the architecture.

1517
01:10:20,500 --> 01:10:21,900
So that this is very easy.

1518
01:10:21,900 --> 01:10:25,200
If you don't do the these architectural choices, then it becomes very

1519
01:10:25,200 --> 01:10:25,500
hard.

1520
01:10:25,500 --> 01:10:27,200
And that's just, that's the nature of architecture.

1521
01:10:27,200 --> 01:10:30,200
Architecture is about making choices that make the things you want to

1522
01:10:30,200 --> 01:10:33,800
do easy at the expense of other things, becoming

1523
01:10:34,100 --> 01:10:36,900
But those other things you try to pick such that there are things, you

1524
01:10:36,900 --> 01:10:38,700
don't care about, if that makes sense.

1525
01:10:39,400 --> 01:10:42,000
So, the first thing that we did, that makes it easy.

1526
01:10:42,000 --> 01:10:43,800
Is we made game controller input.

1527
01:10:43,800 --> 01:10:44,700
Be a structure.

1528
01:10:44,700 --> 01:10:45,900
That's easy to record.

1529
01:10:46,000 --> 01:10:46,200
Right?

1530
01:10:46,200 --> 01:10:49,400
So basically, the entire input to our game is in here.

1531
01:10:50,400 --> 01:10:56,200
And we made that that decision makes it trivial to record game input.

1532
01:10:56,400 --> 01:10:58,500
So basically what we and to play it back.

1533
01:10:58,500 --> 01:11:01,100
So basically the first thing that we did that made things easy for us

1534
01:11:01,400 --> 01:11:05,400
is we now know that in order to record or play back in, put the only

1535
01:11:05,400 --> 01:11:08,000
thing we have to do is before we call game update and render.

1536
01:11:08,000 --> 01:11:10,800
Which is the only place that can actually do any work to change the

1537
01:11:10,800 --> 01:11:11,600
state of the game.

1538
01:11:12,200 --> 01:11:14,200
All it does is take that input structure.

1539
01:11:14,200 --> 01:11:14,900
That's it.

1540
01:11:15,300 --> 01:11:17,100
That's the only thing it knows about.

1541
01:11:17,100 --> 01:11:19,200
That's the only thing that can affect how the game runs.

1542
01:11:19,800 --> 01:11:20,100
So,

1543
01:11:20,900 --> 01:11:21,900
As a result.

1544
01:11:22,000 --> 01:11:25,300
All we have to do is before we call that update.

1545
01:11:25,500 --> 01:11:27,200
If we wanted to record.

1546
01:11:27,200 --> 01:11:30,100
We just record the input that we're going to pass it by writing that

1547
01:11:30,100 --> 01:11:30,600
out to a file.

1548
01:11:30,600 --> 01:11:33,700
Just the whole block, this just destruct flat to a file.

1549
01:11:33,800 --> 01:11:37,500
Bam into the file, just like it is in memory, and if we wanted to play

1550
01:11:37,500 --> 01:11:38,800
back, we just do the opposite.

1551
01:11:38,800 --> 01:11:41,200
We blast, we pull it right out of the file.

1552
01:11:41,300 --> 01:11:43,000
We just romp it right over the input.

1553
01:11:43,000 --> 01:11:43,700
We were going to pass.

1554
01:11:43,700 --> 01:11:46,800
So instead of passing at the actual input that the user, did we pass

1555
01:11:46,800 --> 01:11:47,000
it?

1556
01:11:47,000 --> 01:11:48,200
Whatever we read from the file.

1557
01:11:48,300 --> 01:11:49,000
That was the other.

1558
01:11:49,000 --> 01:11:50,100
The input that we were recording.

1559
01:11:50,200 --> 01:11:51,500
It on some previous run through.

1560
01:11:52,300 --> 01:11:54,400
So that's Thing One and that's totally trivial.

1561
01:11:54,400 --> 01:11:57,000
It's just reading and writing a struct from a file.

1562
01:11:57,000 --> 01:11:58,400
That's it, right.

1563
01:12:00,000 --> 01:12:03,300
So, the only other thing that we needed to be able to do after we had

1564
01:12:03,300 --> 01:12:04,900
that working, right?

1565
01:12:05,600 --> 01:12:08,100
Is we just needed a way to reset the game state.

1566
01:12:08,100 --> 01:12:10,500
So that basically, we could record the input.

1567
01:12:10,600 --> 01:12:12,100
We just play it back by reading from a file.

1568
01:12:12,100 --> 01:12:12,600
That was fine.

1569
01:12:12,600 --> 01:12:15,000
But we don't have a way to do is reset the state of the game.

1570
01:12:15,400 --> 01:12:19,500
Well, again, architecture wise we made smart decisions.

1571
01:12:19,800 --> 01:12:23,400
So the way that our game works is it just gets past a block of memory

1572
01:12:23,400 --> 01:12:26,500
and it's assumed that the game is supposed to just run entirely inside

1573
01:12:26,500 --> 01:12:27,400
that block a memory.

1574
01:12:28,300 --> 01:12:28,900
So

1575
01:12:30,000 --> 01:12:33,700
All we have to do to save and load the state of the game is just save

1576
01:12:33,700 --> 01:12:34,600
that block of memory.

1577
01:12:34,700 --> 01:12:37,200
Now, we know what the block of memory is because we allocated it right

1578
01:12:37,200 --> 01:12:37,600
here.

1579
01:12:37,700 --> 01:12:41,600
This is the block of memory and because we told virtual a lock to

1580
01:12:41,600 --> 01:12:44,900
always put that block of memory at the same Base address in memory.

1581
01:12:45,200 --> 01:12:48,700
It means that any pointers inside that block of memory that point into

1582
01:12:48,700 --> 01:12:51,700
other parts of the locker memory will still just work because it's

1583
01:12:51,700 --> 01:12:52,200
always there.

1584
01:12:52,200 --> 01:12:55,700
Always going to be the exact same locations, no matter when you run

1585
01:12:55,700 --> 01:12:58,200
the game because it's always allocating memory at the same Base

1586
01:12:58,200 --> 01:12:58,700
address.

1587
01:12:58,800 --> 01:12:59,900
So what it turned into

1588
01:13:00,000 --> 01:13:03,800
You was in order to restore save and restore the game State.

1589
01:13:04,000 --> 01:13:08,100
The only thing that you have to do is just blast that memory block out

1590
01:13:08,100 --> 01:13:08,700
to a file.

1591
01:13:08,900 --> 01:13:13,100
So literally all we do when we first open the file to write it.

1592
01:13:14,000 --> 01:13:14,800
So, let's see.

1593
01:13:14,800 --> 01:13:16,800
Begin recording input to write it.

1594
01:13:16,800 --> 01:13:20,700
All we do is just write out that memory block the whole thing, blam.

1595
01:13:21,100 --> 01:13:22,600
And then we want to play it back.

1596
01:13:22,600 --> 01:13:25,500
We just read it back in right over the memory block, just romp It,

1597
01:13:25,500 --> 01:13:26,800
Whatever the memory block is right now.

1598
01:13:26,800 --> 01:13:28,500
We just read in the old one blam.

1599
01:13:28,500 --> 01:13:29,800
It's on top of it, and there, you

1600
01:13:29,900 --> 01:13:30,200
Go.

1601
01:13:31,300 --> 01:13:34,600
This is exactly like someone mentioned this in the forums and they're

1602
01:13:34,600 --> 01:13:35,500
totally right.

1603
01:13:35,500 --> 01:13:40,300
It's exactly like what an emulator does in like when you can save the

1604
01:13:40,300 --> 01:13:43,400
state in like a skin, like a NES emulator or something.

1605
01:13:43,500 --> 01:13:47,300
It just takes the memory of the machine and it dumps it out to disk.

1606
01:13:47,400 --> 01:13:50,000
Well, what we've done is we sort of created almost like a virtual

1607
01:13:50,000 --> 01:13:53,700
machine that are game runs in and so we can do just like what an

1608
01:13:53,700 --> 01:13:54,500
emulator does.

1609
01:13:54,800 --> 01:13:57,900
Our engine sort of works almost like an emulator where you can just

1610
01:13:57,900 --> 01:13:59,800
write out the block of memory and it's fine.

1611
01:14:00,500 --> 01:14:01,500
So that's it.

1612
01:14:01,500 --> 01:14:02,800
It's really simple.

1613
01:14:02,800 --> 01:14:04,200
And again, it's all about architecture.

1614
01:14:04,200 --> 01:14:07,900
If you build your architecture, smart stuff, that seems like it's very

1615
01:14:07,900 --> 01:14:12,000
complicated actually, is really totally trivial and, and you get a lot

1616
01:14:12,000 --> 01:14:12,700
of stuff for free.

1617
01:14:16,600 --> 01:14:19,400
When you're saving game State snapshot, how big is the file?

1618
01:14:19,800 --> 01:14:23,200
The file will be however, much memory you gave the game to work in.

1619
01:14:24,100 --> 01:14:29,000
So we allocated a GB, + 64 Meg's, so the file will be a GB.

1620
01:14:29,000 --> 01:14:30,100
+ 64 Meg's

1621
01:14:31,300 --> 01:14:31,900
That makes sense.

1622
01:14:32,100 --> 01:14:33,300
And I should double-check the work.

1623
01:14:33,300 --> 01:14:33,600
We did.

1624
01:14:33,600 --> 01:14:34,700
Today worked actually.

1625
01:14:35,600 --> 01:14:37,200
So in handmade.

1626
01:14:37,600 --> 01:14:38,800
These should be in the bill directory.

1627
01:14:38,800 --> 01:14:42,500
Now those, those yet Loop edit HMI, so you can see there.

1628
01:14:42,500 --> 01:14:45,800
It's a gig plus 16 Meg's, which is what we expected.

1629
01:14:46,100 --> 01:14:47,000
What is that?

1630
01:14:47,000 --> 01:14:48,200
That doesn't look good?

1631
01:14:48,700 --> 01:14:55,000
Fuu dot txt food up bar and to I think those were that was for when we

1632
01:14:55,000 --> 01:14:57,600
did that mistaken pipe, right?

1633
01:15:00,000 --> 01:15:02,200
Was that was from when we were messing around on the street before I

1634
01:15:02,200 --> 01:15:04,900
let me make sure those those guys don't get recreated.

1635
01:15:05,600 --> 01:15:12,600
But, yeah, that was funny that after their close that down.

1636
01:15:16,200 --> 01:15:17,400
yeah, so

1637
01:15:20,500 --> 01:15:21,400
yeah, so we're all good.

1638
01:15:21,600 --> 01:15:22,000
Okay.

1639
01:15:25,800 --> 01:15:28,000
Can you check if the string length needs a win 3-2 prefix?

1640
01:15:28,000 --> 01:15:29,000
Or is this game code?

1641
01:15:29,000 --> 01:15:32,600
Yeah, I don't want to put a prefix on that because we'll probably move

1642
01:15:32,600 --> 01:15:34,300
that into game code eventually.

1643
01:15:34,300 --> 01:15:36,000
That's not a win32 specific function.

1644
01:15:37,000 --> 01:15:40,000
How many lines of code is the finished game estimated to be?

1645
01:15:44,300 --> 01:15:44,800
I don't know.

1646
01:15:47,400 --> 01:15:48,100
I've no idea.

1647
01:15:52,300 --> 01:15:54,400
Yeah, I don't usually look at lines of code very much.

1648
01:15:54,400 --> 01:15:55,300
So, I don't know.

1649
01:15:55,500 --> 01:15:57,900
I've no idea how many it'll be, we'll see you when we get there.

1650
01:15:58,100 --> 01:15:59,300
Someone can run clock on it.

1651
01:16:02,700 --> 01:16:05,800
Maybe use to random in your batch file to get a more unique file name.

1652
01:16:06,300 --> 01:16:07,100
It doesn't matter.

1653
01:16:07,200 --> 01:16:09,400
Like if they Collide, we don't care.

1654
01:16:09,700 --> 01:16:11,900
It just means that the build will fail that one time.

1655
01:16:11,900 --> 01:16:12,700
You had all Dem.

1656
01:16:12,900 --> 01:16:17,500
But I mean, yeah, it's not that's that's just not going to be a

1657
01:16:17,500 --> 01:16:17,800
problem.

1658
01:16:17,800 --> 01:16:18,400
I don't think.

1659
01:16:20,900 --> 01:16:23,300
Having just finished my first University course in C++.

1660
01:16:23,300 --> 01:16:26,300
I found myself really enjoying coding, but not really sure where to

1661
01:16:26,300 --> 01:16:29,600
continue learning on my own any advice on where I could go or what to

1662
01:16:29,600 --> 01:16:33,000
do to pick up a bit more coding or knowledge experience.

1663
01:16:33,400 --> 01:16:34,100
Not really.

1664
01:16:34,100 --> 01:16:39,800
I mean basically this stream is is my answer to what I think maybe

1665
01:16:39,800 --> 01:16:40,600
people should doing.

1666
01:16:40,600 --> 01:16:42,300
I'm trying to go over the sorts of things.

1667
01:16:42,300 --> 01:16:43,700
I think people should learn how to do.

1668
01:16:44,500 --> 01:16:47,600
So, that's really this stream is the best answer I have because I

1669
01:16:47,600 --> 01:16:49,900
didn't think there was necessarily a lot of information out there.

1670
01:16:49,900 --> 01:16:50,300
So I

1671
01:16:50,700 --> 01:16:52,100
You know, that's what I'm trying to do with the stream.

1672
01:16:52,700 --> 01:16:56,000
So, I don't know, I'm sure there are other good things out there to

1673
01:16:56,000 --> 01:16:57,900
do, but I'm not super familiar with them.

1674
01:16:57,900 --> 01:17:01,700
So I'm not sure I can necessarily recommend anything in particular.

1675
01:17:05,600 --> 01:17:07,600
What is a good example of well-written game code?

1676
01:17:07,600 --> 01:17:09,800
For example, everyone talks about Doom code?

1677
01:17:10,500 --> 01:17:11,100
I don't know.

1678
01:17:11,500 --> 01:17:12,900
I haven't looked at the Doom code.

1679
01:17:13,000 --> 01:17:17,200
I'm not, I'm not sure, there's not that many Game Source Code things

1680
01:17:17,200 --> 01:17:17,800
out there.

1681
01:17:18,600 --> 01:17:20,200
I mean, Carmack was a very good programmer.

1682
01:17:20,200 --> 01:17:23,000
So I suspect that doom and Quake are probably very well programmed

1683
01:17:23,000 --> 01:17:24,000
things, but I don't know.

1684
01:17:24,000 --> 01:17:27,200
I haven't looked at them myself, so I couldn't say,

1685
01:17:29,300 --> 01:17:32,200
Assuming you want to record exactly what happens in the game.

1686
01:17:32,400 --> 01:17:36,400
How would the looping handle, random values, say enemy bullets that

1687
01:17:36,400 --> 01:17:38,000
are fired at random angles.

1688
01:17:38,900 --> 01:17:41,400
Well, the answer is there's no such thing as random values.

1689
01:17:41,700 --> 01:17:47,800
So actually what we already did will record quote unquote, random.

1690
01:17:48,100 --> 01:17:49,400
Enemy bullets just fine.

1691
01:17:49,900 --> 01:17:52,400
The reason for that is because the way Randomness actually is

1692
01:17:52,400 --> 01:17:56,500
generated in code is it's actually pseudo-random.

1693
01:17:56,800 --> 01:17:58,100
So they're basically mathematical

1694
01:17:58,200 --> 01:17:59,900
Chuckle functions that generate numbers that appear.

1695
01:18:00,000 --> 01:18:02,300
To be random but they're not actually random.

1696
01:18:03,100 --> 01:18:07,700
And so as long as you save the memory state of the thing of all the

1697
01:18:07,700 --> 01:18:10,600
stuff you're using to generate your random numbers, which we would by

1698
01:18:10,600 --> 01:18:13,600
default be doing because we're saving all the state from the game,

1699
01:18:14,300 --> 01:18:16,700
then all of the random stuff will happen exactly the same.

1700
01:18:17,700 --> 01:18:20,200
And in fact, you'll see that happen because we will have plenty of

1701
01:18:20,200 --> 01:18:21,000
random stuff in the game.

1702
01:18:23,300 --> 01:18:26,000
If we dump memory to disk in a large-scale application, wouldn't that?

1703
01:18:26,000 --> 01:18:28,500
Cause more than one gig footprint for every state?

1704
01:18:31,900 --> 01:18:35,000
I'm not sure what that means.

1705
01:18:35,700 --> 01:18:41,400
Obviously, whatever the size is of the memory that you're dumping is

1706
01:18:41,400 --> 01:18:46,600
the size of the footprint, so,

1707
01:18:48,100 --> 01:18:49,900
Yeah, I'm not, I do not sure.

1708
01:18:49,900 --> 01:18:51,000
I understand the question.

1709
01:18:51,400 --> 01:18:53,600
However, much memory it takes to store.

1710
01:18:53,600 --> 01:18:56,900
The state is how big the state is on disk.

1711
01:18:57,200 --> 01:19:00,700
All right, I mean you could compress it if you wanted to save space

1712
01:19:00,700 --> 01:19:01,400
for some reason.

1713
01:19:01,900 --> 01:19:04,700
But again, this is for the looped edit feature.

1714
01:19:04,800 --> 01:19:05,700
So we don't care.

1715
01:19:05,800 --> 01:19:08,300
We're only going to have a couple of those files at any given time at

1716
01:19:08,300 --> 01:19:09,000
most.

1717
01:19:09,500 --> 01:19:10,900
So we don't care how big they are.

1718
01:19:11,100 --> 01:19:12,100
They could be 10 gigabytes.

1719
01:19:12,100 --> 01:19:12,800
We wouldn't care.

1720
01:19:13,100 --> 01:19:13,300
Really.

1721
01:19:13,300 --> 01:19:14,400
It just doesn't matter.

1722
01:19:14,700 --> 01:19:16,700
The only thing we really care about is

1723
01:19:18,000 --> 01:19:21,700
We want them to load relatively fast so which I think they will do on

1724
01:19:21,700 --> 01:19:24,900
an SSD, but we could try to do things to speed that up a little bit

1725
01:19:24,900 --> 01:19:27,200
potentially, but that's really the only reason we care about the size.

1726
01:19:27,200 --> 01:19:28,900
We don't care about the space at all.

1727
01:19:34,800 --> 01:19:37,700
I don't get the stuff for you, declare a variable without initializing

1728
01:19:37,700 --> 01:19:40,900
it and then you use the address to it in a function call.

1729
01:19:40,900 --> 01:19:41,900
Is that a dummy thing?

1730
01:19:41,900 --> 01:19:43,300
Or what is it used for?

1731
01:19:45,200 --> 01:19:47,500
So I'm not sure exactly what you're referring to.

1732
01:19:47,500 --> 01:19:54,800
But maybe are you talking about stuff like like this?

1733
01:19:55,400 --> 01:19:56,200
Is this what you mean?

1734
01:19:57,600 --> 01:19:58,000
Assuming?

1735
01:19:58,000 --> 01:19:58,900
This is what you mean.

1736
01:19:59,200 --> 01:20:04,000
Then basically, what this is is this is reserving, space on the stack.

1737
01:20:05,000 --> 01:20:08,500
For essentially, use by some other function.

1738
01:20:09,300 --> 01:20:12,600
We are going to reserve something this big, however, big this struct

1739
01:20:12,600 --> 01:20:16,300
is we are going to call get file, attribute CX, and pass it.

1740
01:20:16,300 --> 01:20:19,700
The address of it so it can then right into that memory.

1741
01:20:19,700 --> 01:20:23,400
That's on the stack in our stack frame, right?

1742
01:20:23,400 --> 01:20:24,400
What it needs to write in there.

1743
01:20:24,400 --> 01:20:25,800
And so that we can access it.

1744
01:20:26,800 --> 01:20:30,500
So basically the reason that it's not initialized is because we don't

1745
01:20:30,500 --> 01:20:31,700
care what its values are.

1746
01:20:31,700 --> 01:20:34,500
We just care that space was reserved for it because this

1747
01:20:34,700 --> 01:20:36,500
Function is actually going to do the right.

1748
01:20:36,600 --> 01:20:40,100
It's going to actually create the values and you can see that happen.

1749
01:20:41,800 --> 01:20:44,000
Like what, you can just step in and watch that happen.

1750
01:20:44,600 --> 01:20:45,200
Right?

1751
01:20:45,300 --> 01:20:46,500
What's the name of this function?

1752
01:20:46,700 --> 01:20:47,900
Get last right time?

1753
01:20:48,300 --> 01:20:53,500
So if we wanted to actually watch that happen, you can see it.

1754
01:20:53,600 --> 01:20:58,800
So we come in here and basically at this point in the code we have

1755
01:20:58,800 --> 01:20:59,800
reserved.

1756
01:21:00,900 --> 01:21:03,900
So size of data, right?

1757
01:21:03,900 --> 01:21:10,200
We reserved 36 bytes at this address, which is on the stack, which is

1758
01:21:10,200 --> 01:21:11,400
on our stack frame.

1759
01:21:11,600 --> 01:21:16,100
We've reserved 36 bytes of our stack that we are now passing the

1760
01:21:16,100 --> 01:21:17,900
address to get file attributes to X.

1761
01:21:18,100 --> 01:21:21,900
You can see that it's just garbage right now, but then when we

1762
01:21:22,000 --> 01:21:25,400
actually call that function, it fills all of it in on our stack, with

1763
01:21:25,400 --> 01:21:26,100
the values.

1764
01:21:27,300 --> 01:21:28,800
So, so that's how that works.

1765
01:21:30,800 --> 01:21:31,900
Hopefully, that answered the question.

1766
01:21:31,900 --> 01:21:32,300
I'm not sure.

1767
01:21:32,300 --> 01:21:35,800
I knew exactly what, which question you were asking, but hopefully

1768
01:21:35,800 --> 01:21:37,700
that is roughly.

1769
01:21:38,000 --> 01:21:38,400
Roughly.

1770
01:21:38,400 --> 01:21:41,800
The question also is the breakpoints window.

1771
01:21:41,800 --> 01:21:44,400
Why do I need my breakpoints window, get that break points with

1772
01:21:44,400 --> 01:21:45,100
malaria?

1773
01:21:45,700 --> 01:21:46,500
Let's get those.

1774
01:21:46,800 --> 01:21:47,200
Okay.

1775
01:21:48,900 --> 01:21:52,800
You can make the recording instantaneous using copy on write Pages.

1776
01:21:53,400 --> 01:21:53,700
Yes.

1777
01:21:53,700 --> 01:21:57,200
Oh, I was trying to think about how to do that.

1778
01:22:01,100 --> 01:22:02,300
I was wondering about that.

1779
01:22:03,600 --> 01:22:09,100
And I wasn't 100% sure how to still always have the same Base address

1780
01:22:09,400 --> 01:22:10,400
when doing that.

1781
01:22:10,900 --> 01:22:11,700
Does that make sense?

1782
01:22:14,400 --> 01:22:15,100
so,

1783
01:22:19,000 --> 01:22:23,200
Yeah, I mean, I think basically the way to do it is you do a memory

1784
01:22:23,200 --> 01:22:23,800
map?

1785
01:22:24,000 --> 01:22:28,800
You do the memory mapped file of the memory from the current location

1786
01:22:28,800 --> 01:22:31,300
to attempt location, right?

1787
01:22:31,400 --> 01:22:34,600
And then you let the game Run, then we need to restore it.

1788
01:22:34,600 --> 01:22:36,900
You just mem map back, right?

1789
01:22:38,200 --> 01:22:39,300
And I think that works.

1790
01:22:39,300 --> 01:22:39,800
I don't know.

1791
01:22:39,800 --> 01:22:40,900
I haven't tried it yet.

1792
01:22:40,900 --> 01:22:43,200
I didn't want to do it that way at first, because I wasn't actually

1793
01:22:43,200 --> 01:22:46,600
sure if it was gonna work, but I agree that that may work.

1794
01:22:48,300 --> 01:22:49,300
I just have never tried it.

1795
01:22:49,300 --> 01:22:52,900
So I can't promise you that it would but I think that it might it

1796
01:22:52,900 --> 01:22:56,400
doesn't help you with storing it to disk really as much.

1797
01:22:56,500 --> 01:22:57,400
But, you know.

1798
01:23:00,000 --> 01:23:02,100
With the sparse file for flags have dropped.

1799
01:23:02,100 --> 01:23:04,400
.H of my file size by how much?

1800
01:23:04,900 --> 01:23:05,300
Bye.

1801
01:23:05,400 --> 01:23:08,000
Well, it probably would drop the H of my file size and probably drop

1802
01:23:08,000 --> 01:23:12,900
it by however many 0 Pages there were in it.

1803
01:23:13,100 --> 01:23:16,500
But again, it wouldn't drop it at all later when we're totally feeling

1804
01:23:16,500 --> 01:23:17,100
the memory.

1805
01:23:17,500 --> 01:23:20,200
So it's not really a meaningful optimization later on.

1806
01:23:20,500 --> 01:23:23,600
It was just a fun thing to see if it would work in our current state

1807
01:23:23,600 --> 01:23:24,800
where most of the memory is 0.

1808
01:23:30,400 --> 01:23:33,400
Still got him says, I'm still not sure we're using the windows API to

1809
01:23:33,400 --> 01:23:35,200
get memory instead of the standard Library.

1810
01:23:35,300 --> 01:23:36,800
Why are we making windows calls?

1811
01:23:36,800 --> 01:23:39,600
If we were supposed to be doing everything from scratch, are the

1812
01:23:39,600 --> 01:23:44,300
windows functions were using optimized for use for use Windows?

1813
01:23:44,800 --> 01:23:47,200
Outperforming the standard Library?

1814
01:23:51,400 --> 01:23:54,000
I do not understand the question.

1815
01:23:54,200 --> 01:23:58,600
I guess, what, I would try to say is, we need to get memory from the

1816
01:23:58,600 --> 01:23:59,300
operating system.

1817
01:23:59,400 --> 01:23:59,800
There is no.

1818
01:24:00,000 --> 01:24:01,700
Such thing as writing something from scratch.

1819
01:24:01,700 --> 01:24:06,300
If you still want to write on Windows, we would have to like

1820
01:24:06,300 --> 01:24:08,700
re-implement the operating system to get any lower level.

1821
01:24:08,700 --> 01:24:12,400
So when I say from scratch, I just mean that runs on Windows, right?

1822
01:24:12,400 --> 01:24:18,000
On Raspberry Pi, we will be able to do our own memory mapping.

1823
01:24:18,000 --> 01:24:21,200
And so that will be more from scratch than this.

1824
01:24:21,200 --> 01:24:25,700
But as long as we're running on Windows, we have to ask windows for

1825
01:24:25,700 --> 01:24:26,100
the memory.

1826
01:24:26,100 --> 01:24:28,400
It's the only thing that controls the memory table.

1827
01:24:28,400 --> 01:24:30,000
We have no ability to

1828
01:24:30,000 --> 01:24:31,000
Me to do anything else.

1829
01:24:31,300 --> 01:24:34,500
We could write a device driver or something and try to do it that way.

1830
01:24:34,500 --> 01:24:37,300
But like assuming that you want to be a gain that person can run

1831
01:24:37,500 --> 01:24:40,500
without being administrator, without escalating to administrator every

1832
01:24:40,500 --> 01:24:43,800
time they run it or whatever, or installing a device driver on their

1833
01:24:43,800 --> 01:24:44,800
machine to run it.

1834
01:24:45,900 --> 01:24:47,900
Yeah, I so, I don't really understand the question.

1835
01:24:47,900 --> 01:24:48,300
Sorry.

1836
01:24:49,600 --> 01:24:52,100
As the game grows, how are you going to partition the game member

1837
01:24:52,100 --> 01:24:55,900
between systems to keep the record and playback feature working.

1838
01:24:57,100 --> 01:25:01,300
We shouldn't have to do the record and playback feature just works

1839
01:25:03,600 --> 01:25:06,900
because everything happens inside the game memory.

1840
01:25:06,900 --> 01:25:08,400
So it doesn't matter how we partition it.

1841
01:25:08,400 --> 01:25:09,600
It'll still work.

1842
01:25:09,900 --> 01:25:14,100
You did the partitioning of the memory for the game is not related to

1843
01:25:14,100 --> 01:25:17,100
whether the record and playback feature works or not.

1844
01:25:20,300 --> 01:25:23,300
Would it make sense to Temporary less than the size of game em, we

1845
01:25:23,300 --> 01:25:24,100
don't use it the moment.

1846
01:25:24,100 --> 01:25:30,400
Anyway, well, not really because like we're going to be using it so

1847
01:25:30,400 --> 01:25:34,000
lessening it temporarily doesn't really help us much.

1848
01:25:34,000 --> 01:25:37,000
I mean if we were tuning something early on and wanted to speed up

1849
01:25:37,000 --> 01:25:39,700
that, right, but I think we could speed up the right that right in

1850
01:25:39,700 --> 01:25:43,300
other ways as well like using the copy on write Pages or other stuff

1851
01:25:43,300 --> 01:25:44,200
like that that was mentioned.

1852
01:25:44,200 --> 01:25:47,900
So if we really found that was annoying us a ton we could speed that

1853
01:25:47,900 --> 01:25:48,200
up.

1854
01:25:54,700 --> 01:25:57,500
Are you happy with the timing FPS results?

1855
01:25:58,200 --> 01:26:01,300
I found an old article on RD SE for more accurate timing.

1856
01:26:02,400 --> 01:26:03,400
So rdst.

1857
01:26:03,400 --> 01:26:06,900
Our dtsc is for profiling not timing.

1858
01:26:06,900 --> 01:26:11,100
You cannot use our dtsc for timing using our DC SC for timing is very

1859
01:26:11,100 --> 01:26:11,600
bad.

1860
01:26:11,800 --> 01:26:14,900
So you need to use Query performance counter for timing.

1861
01:26:15,000 --> 01:26:17,800
Meaning, the thing that actually measures, how long the game Loop

1862
01:26:17,800 --> 01:26:21,500
takes for synchronization with like the audio and stuff.

1863
01:26:21,900 --> 01:26:22,300
And

1864
01:26:22,600 --> 01:26:26,400
For like trying to hit 60, hertz for 30 Hertz, or whatever.

1865
01:26:26,600 --> 01:26:29,900
That has to be query performance counter because our dtsc doesn't tell

1866
01:26:29,900 --> 01:26:35,300
you, well clock time, our dtsc we do call and we so we have that in

1867
01:26:35,300 --> 01:26:36,500
here, right?

1868
01:26:36,900 --> 01:26:41,200
But that's only for profiling and so until we start actually profiling

1869
01:26:41,200 --> 01:26:41,500
code.

1870
01:26:41,500 --> 01:26:44,900
We will not be using the results of our dtsc because that is not, you

1871
01:26:44,900 --> 01:26:47,900
never want to use the results of our dtsc for timing.

1872
01:26:48,800 --> 01:26:50,900
Unless it's you want to use it for profiling.

1873
01:26:50,900 --> 01:26:52,300
So they're ambiguous words.

1874
01:26:52,500 --> 01:26:54,600
You never want to use it for synchronization.

1875
01:26:54,700 --> 01:26:57,600
You only want to use it for profiling and we haven't done any

1876
01:26:57,600 --> 01:26:58,500
profiling yet.

1877
01:27:01,700 --> 01:27:03,200
When would the Mac code start?

1878
01:27:03,200 --> 01:27:05,500
I am following with Windows in a VM and is really slow.

1879
01:27:05,800 --> 01:27:07,900
We won't do Mac until we ship.

1880
01:27:08,200 --> 01:27:09,900
So it'll be a very long time.

1881
01:27:10,100 --> 01:27:14,700
But if you want Mac earlier, keep in mind that if you click on, if you

1882
01:27:14,700 --> 01:27:19,300
go to handmade hero dot org and you click on news and forums, keep in

1883
01:27:19,300 --> 01:27:21,200
mind that in the coding resources section.

1884
01:27:21,300 --> 01:27:23,600
There's already two options for Mac.

1885
01:27:23,700 --> 01:27:25,600
There's the Mac OS, X, native port.

1886
01:27:26,200 --> 01:27:29,800
And there's also the sdl port that's originally for Linux, but you can

1887
01:27:29,800 --> 01:27:30,700
use it on Mac.

1888
01:27:31,200 --> 01:27:31,300
So you

1889
01:27:31,500 --> 01:27:34,500
I have two options for Mac right now.

1890
01:27:35,100 --> 01:27:39,900
If you don't want to run into VM, so I would highly recommend checking

1891
01:27:39,900 --> 01:27:43,300
those out because there's people who are keeping those up-to-date and

1892
01:27:43,300 --> 01:27:43,900
all that.

1893
01:27:47,000 --> 01:27:49,900
Is there any negative effects of making the page size bigger?

1894
01:27:50,800 --> 01:27:52,300
So I don't really know.

1895
01:27:52,800 --> 01:27:54,400
I would say that possibly.

1896
01:27:54,400 --> 01:27:58,200
Yes, because having, you know, increasing the granularity like that.

1897
01:27:59,900 --> 01:28:02,900
To from like 4K to 2 Meg or something.

1898
01:28:04,200 --> 01:28:08,600
You do run the risk of sort of fragmentation of the tlb.

1899
01:28:08,600 --> 01:28:11,400
So if you think about like what happens here, right?

1900
01:28:12,800 --> 01:28:20,100
If I've got something where, you know, I've got memory and who knows

1901
01:28:20,100 --> 01:28:22,500
how like here's the translation lookaside buffer.

1902
01:28:22,600 --> 01:28:23,100
Right?

1903
01:28:23,100 --> 01:28:26,700
And the translation lookaside buffer has some number of entries in it.

1904
01:28:26,700 --> 01:28:28,000
Let's say it's got four.

1905
01:28:28,500 --> 01:28:29,800
Hopefully, it's got more than that.

1906
01:28:29,800 --> 01:28:32,800
But right, let's say it's got four entries in the tlb.

1907
01:28:33,500 --> 01:28:33,700
And

1908
01:28:34,000 --> 01:28:37,800
Four entries can each point, 22 megabytes, right?

1909
01:28:37,900 --> 01:28:43,000
So they can either, they can either point to 4K or they can point to

1910
01:28:43,000 --> 01:28:44,300
two megabytes or something like that.

1911
01:28:44,300 --> 01:28:44,900
Right?

1912
01:28:45,700 --> 01:28:50,200
Well, I would guess I'm trying to think about if this is true or not.

1913
01:28:52,100 --> 01:28:53,300
Well, now, you know what?

1914
01:29:00,100 --> 01:29:01,000
You know, the more I think about it.

1915
01:29:01,000 --> 01:29:01,900
No, I guess, you know what?

1916
01:29:01,900 --> 01:29:02,500
To tell you the truth.

1917
01:29:02,500 --> 01:29:04,900
I was going to draw something out that I was going to say, like, well,

1918
01:29:04,900 --> 01:29:06,300
maybe this is a problem, but you know what?

1919
01:29:06,300 --> 01:29:06,700
I don't know.

1920
01:29:06,700 --> 01:29:10,200
I can't I can't think of anything for our particular circumstance.

1921
01:29:10,500 --> 01:29:11,400
Where would be a problem?

1922
01:29:11,400 --> 01:29:13,000
But again, I'm not a CPU guy.

1923
01:29:13,200 --> 01:29:16,400
So I think probably I'm not qualified to answer that question is what

1924
01:29:16,400 --> 01:29:20,800
I would say, so all I wanted to do with the larger Pages was be able

1925
01:29:20,800 --> 01:29:22,500
to be able to turn them on and off.

1926
01:29:22,500 --> 01:29:26,900
So we could run our game with large Pages run our game without the

1927
01:29:26,900 --> 01:29:28,200
large pages and see if it

1928
01:29:28,400 --> 01:29:31,800
Impact on performance down the line, you know, later on when we're

1929
01:29:31,800 --> 01:29:32,800
doing Performance Tuning.

1930
01:29:32,800 --> 01:29:34,200
I kind of want to be able to do that.

1931
01:29:35,500 --> 01:29:37,800
But I do not know practically.

1932
01:29:37,800 --> 01:29:39,400
If there'd be downsides, are upsides.

1933
01:29:44,800 --> 01:29:46,100
Let's see.

1934
01:29:47,200 --> 01:29:49,600
How do you calculate the size of a struct?

1935
01:29:49,600 --> 01:29:52,700
Do you mean besides just doing size of?

1936
01:29:52,700 --> 01:29:56,400
I mean, the easiest way to calculate the size of struct is just to ask

1937
01:29:56,400 --> 01:29:57,700
what it is, right?

1938
01:29:57,700 --> 01:29:59,800
You just ask the compiler, we do.

1939
01:30:00,000 --> 01:30:02,300
The time we just call size of right, I did it right here.

1940
01:30:02,400 --> 01:30:05,800
So size of is the thing that says, how big a struct is and technically

1941
01:30:05,800 --> 01:30:09,200
that's the only way to know how big a struct is because I think

1942
01:30:09,200 --> 01:30:12,300
technically the compiler is allowed to pad things in ways that maybe

1943
01:30:12,300 --> 01:30:13,500
aren't completely defined.

1944
01:30:13,500 --> 01:30:14,500
I don't know if that's actually true.

1945
01:30:14,500 --> 01:30:16,900
It may be that they're always completely defined and you could always

1946
01:30:16,900 --> 01:30:20,800
compute it entirely yourself but basically size of is the thing that

1947
01:30:20,800 --> 01:30:24,800
tells you how big is the struct is but all it's doing what size of

1948
01:30:24,800 --> 01:30:28,500
does if you're just cook, if you're just curious of like, how big is a

1949
01:30:28,500 --> 01:30:29,100
struct

1950
01:30:30,000 --> 01:30:32,800
All it's doing is it's going through the members of the struct and

1951
01:30:32,800 --> 01:30:33,600
looking how big they are.

1952
01:30:33,900 --> 01:30:34,400
Right?

1953
01:30:34,700 --> 01:30:35,200
It's just going.

1954
01:30:35,200 --> 01:30:35,600
Okay.

1955
01:30:35,600 --> 01:30:40,300
This is a pointer on 64-bit a pointer is 8, bytes long.

1956
01:30:40,600 --> 01:30:41,200
So that's eight.

1957
01:30:41,300 --> 01:30:42,800
This is an integer.

1958
01:30:42,800 --> 01:30:43,800
That's 32 bits.

1959
01:30:44,000 --> 01:30:45,800
So it's four bytes long.

1960
01:30:45,800 --> 01:30:47,400
So 4444.

1961
01:30:47,400 --> 01:30:50,000
So it's this is 888.

1962
01:30:50,000 --> 01:30:52,500
So that's going to be 24, right?

1963
01:30:52,500 --> 01:30:57,300
But that's how big it would need.

1964
01:30:57,300 --> 01:31:00,000
If it was packed optimally, you then have to account for.

1965
01:31:00,000 --> 01:31:05,000
The fact that the compiler aligns things on boundaries that are equal

1966
01:31:05,000 --> 01:31:07,100
to the size of the thing being aligned.

1967
01:31:07,200 --> 01:31:12,700
So for example, if I was to move this memory pointer, which is 8,

1968
01:31:12,700 --> 01:31:13,500
bytes long

1969
01:31:14,600 --> 01:31:18,400
If I move this 8 B thing below the integer, which is only four bytes.

1970
01:31:18,600 --> 01:31:22,100
It would insert 4 bytes of padding before it to make sure that the

1971
01:31:22,100 --> 01:31:24,700
memory this part is, is a is a line.

1972
01:31:24,700 --> 01:31:27,200
This 8 B thing is aligned on an 8 byte boundary.

1973
01:31:27,900 --> 01:31:30,700
So there is a little bit of Finnick Enos that you have to be aware of

1974
01:31:31,000 --> 01:31:32,100
but basically that's it.

1975
01:31:37,200 --> 01:31:39,500
Can you add line numbers to those of us following along at home?

1976
01:31:39,500 --> 01:31:40,600
Have an easier time?

1977
01:31:40,700 --> 01:31:42,000
So we tried to do that.

1978
01:31:42,000 --> 01:31:43,700
We put line numbers in the de bugger.

1979
01:31:43,700 --> 01:31:46,800
We couldn't really put line numbers in emacs because they were really

1980
01:31:46,800 --> 01:31:49,500
pretty ugly and they were a little bit buggy.

1981
01:31:49,500 --> 01:31:52,400
So I don't know about that.

1982
01:31:53,000 --> 01:31:57,900
Basically the problem was we can we can maybe try it again and see if

1983
01:31:57,900 --> 01:32:00,700
people object-- but basically

1984
01:32:03,900 --> 01:32:07,100
Basically, if we if you think is it line number?

1985
01:32:07,100 --> 01:32:09,300
No, it's not that it's like lyneham or whatever.

1986
01:32:09,900 --> 01:32:12,300
I don't know how to get this guy to let's let's see here.

1987
01:32:12,600 --> 01:32:19,500
So here was the problem with line numbers is that inside inside the

1988
01:32:19,500 --> 01:32:22,500
dot e, Max file, there's a linum thing.

1989
01:32:23,100 --> 01:32:24,500
So this guy, right?

1990
01:32:24,700 --> 01:32:30,300
So basically what we did is we tried turning it on and it looks it

1991
01:32:30,300 --> 01:32:31,800
looks like

1992
01:32:36,200 --> 01:32:38,800
Codes and 32, it looks like that.

1993
01:32:38,800 --> 01:32:43,200
And they were kind of really ugly, and bright and weird, and whatever.

1994
01:32:43,200 --> 01:32:47,100
So, anyway, and they also had this weird, this, this like a bug with

1995
01:32:47,300 --> 01:32:49,500
there was this weird bug with that line down the middle.

1996
01:32:49,500 --> 01:32:50,900
You can see it like it erases.

1997
01:32:50,900 --> 01:32:51,600
It's like go up.

1998
01:32:51,600 --> 01:32:53,700
It's really it's just all messed up.

1999
01:32:54,300 --> 01:32:56,800
And so I don't know if I really like.

2000
01:32:56,800 --> 01:32:59,400
That's all glitchy and weird and it just seemed kind of bad.

2001
01:32:59,700 --> 01:32:59,800
So

2002
01:33:00,200 --> 01:33:03,700
I was not super happy about that.

2003
01:33:03,700 --> 01:33:06,100
And I don't know if that's something that can be fixed or not.

2004
01:33:06,600 --> 01:33:10,300
I'm not even sure why that line is there at all in the first place.

2005
01:33:10,700 --> 01:33:14,000
But if someone wants to do the work on the dot, exe file, to get these

2006
01:33:14,000 --> 01:33:17,000
line numbers, first of all, to be like a darker color, like this, the

2007
01:33:17,000 --> 01:33:18,500
same as the comments, let's say.

2008
01:33:18,900 --> 01:33:21,300
And then to fix that line that goes down the middle.

2009
01:33:21,300 --> 01:33:26,600
If someone wants to do that, then I would turn them on because I'd be

2010
01:33:26,600 --> 01:33:27,300
fine with that.

2011
01:33:28,000 --> 01:33:29,800
But I as they are, they're really

2012
01:33:30,000 --> 01:33:32,400
kind of bad and ugly and they're very distracting.

2013
01:33:32,400 --> 01:33:35,700
So I don't think I would be inclined to use them if we can't fix that

2014
01:33:35,700 --> 01:33:40,000
problem, but if we can then that's that's that would work.

2015
01:33:40,200 --> 01:33:42,100
So yeah.

2016
01:33:50,200 --> 01:33:53,200
Okay, I believe some people think that the game state is saved every

2017
01:33:53,200 --> 01:33:55,400
time with the input, whereas it is only saved the beginning of the

2018
01:33:55,400 --> 01:33:57,700
recording and then modified through input playback.

2019
01:33:57,700 --> 01:33:58,300
That is correct.

2020
01:33:58,300 --> 01:34:00,500
So, we only save this.

2021
01:34:00,500 --> 01:34:05,000
The one gigabyte only gets saved when we start from, then on, we just

2022
01:34:05,000 --> 01:34:05,600
play back.

2023
01:34:05,600 --> 01:34:06,400
What the input was.

2024
01:34:06,400 --> 01:34:09,100
I mean, let the game recreate it, state from that.

2025
01:34:09,200 --> 01:34:11,800
So, it doesn't create a gigabyte, every frame.

2026
01:34:12,000 --> 01:34:15,100
It just creates a gigabyte, once that's it.

2027
01:34:21,900 --> 01:34:24,800
Do you think the recording technique will run into problems if we have

2028
01:34:24,800 --> 01:34:26,700
multiple threads using the game State?

2029
01:34:27,400 --> 01:34:29,800
Well, it depends how you do those multiple threads.

2030
01:34:30,600 --> 01:34:34,800
So basically I don't think we will run into problems with it.

2031
01:34:35,800 --> 01:34:39,100
The way I am going to do the threading in the game.

2032
01:34:39,300 --> 01:34:44,300
But if you didn't do it the way, I'm going to do it then yes, you very

2033
01:34:44,300 --> 01:34:48,800
well could but you also have the option of sort of having your

2034
01:34:48,800 --> 01:34:51,100
threading system have two modes.

2035
01:34:51,600 --> 01:34:54,700
You can certainly do a mode that safe for recording and one that's

2036
01:34:54,700 --> 01:34:55,300
not.

2037
01:34:55,400 --> 01:34:58,200
And so when you're doing tuning, you could use the one that's safe

2038
01:34:58,200 --> 01:34:58,600
recording.

2039
01:34:58,600 --> 01:35:00,300
And when it's not not right.

2040
01:35:00,300 --> 01:35:02,500
So you could work around it that way, as well.

2041
01:35:07,300 --> 01:35:10,000
If virtual Alec does not guarantee contiguous memory.

2042
01:35:10,000 --> 01:35:15,200
Could this pose a hindrance to cash optimizations virtual Alec does

2043
01:35:15,200 --> 01:35:19,200
guarantee contiguous memory, so I'm not sure what that means.

2044
01:35:23,900 --> 01:35:26,300
So I'll say, two things about that question.

2045
01:35:27,300 --> 01:35:33,300
So first of all, the first thing to remember, is no virtual a lock.

2046
01:35:35,300 --> 01:35:39,600
Only operates on pages anyway, and cache lines are smaller than a

2047
01:35:39,600 --> 01:35:40,100
page.

2048
01:35:40,300 --> 01:35:45,500
So, for example, 4096 bytes is the smallest page size that virtual

2049
01:35:45,500 --> 01:35:48,100
Alec will even allocate in a chunk at once.

2050
01:35:49,900 --> 01:35:54,200
And I'm pretty sure that virtual Alec always aligns to 64k boundaries.

2051
01:35:54,200 --> 01:35:57,400
Anyway, so basically you're talking about things that are massively

2052
01:35:57,400 --> 01:35:59,300
larger than a cache line anyway.

2053
01:36:00,300 --> 01:36:03,400
So, so I'm not sure the question.

2054
01:36:03,600 --> 01:36:04,200
I'm not sure.

2055
01:36:04,200 --> 01:36:07,700
I understand really where that question is coming from, but also

2056
01:36:07,700 --> 01:36:10,100
virtual Alec does guarantee contiguous memory.

2057
01:36:11,500 --> 01:36:17,000
So so I even so it is all going to be contiguous.

2058
01:36:17,100 --> 01:36:19,600
And remember it's contiguous in our virtual address space.

2059
01:36:19,600 --> 01:36:22,400
It's not continuous in contiguous in physical memory.

2060
01:36:22,500 --> 01:36:25,800
But again, that doesn't affect the cash at all because the cash is

2061
01:36:25,800 --> 01:36:32,800
actually always going to be some some subdivision of the virtual

2062
01:36:32,800 --> 01:36:36,900
memory paging sighs anyway, so it doesn't really matter.

2063
01:36:36,900 --> 01:36:40,900
It's never going to be discontinuous across a cache line boundary that

2064
01:36:40,900 --> 01:36:41,100
makes

2065
01:36:45,100 --> 01:36:46,500
Where can I get earlier versions of the code?

2066
01:36:46,500 --> 01:36:48,200
The link only gives me the latest version?

2067
01:36:48,400 --> 01:36:52,500
No, the link gives you all the versions, so that when you download in

2068
01:36:52,500 --> 01:36:55,600
the link where you download the source code, it's a zip file that has

2069
01:36:55,600 --> 01:36:57,400
every day's Source in it.

2070
01:36:57,800 --> 01:37:00,100
So you should be able to just open up the zip file and see all the

2071
01:37:00,200 --> 01:37:01,700
days every single day is in there.

2072
01:37:02,500 --> 01:37:04,600
Really should be if it's not, please let me know.

2073
01:37:07,500 --> 01:37:08,000
All right.

2074
01:37:08,000 --> 01:37:09,700
Looks like that is the end of questions.

2075
01:37:10,200 --> 01:37:11,300
So that is good.

2076
01:37:13,900 --> 01:37:17,400
Perfect, all right, everyone will thank you very much for joining me

2077
01:37:17,700 --> 01:37:19,800
for another episode of handmade hero.

2078
01:37:19,800 --> 01:37:23,100
We have one more day of cleanup that we're going to do tomorrow and

2079
01:37:23,100 --> 01:37:24,400
then next week.

2080
01:37:24,400 --> 01:37:26,800
We will be starting on our game engine, which should be pretty

2081
01:37:26,800 --> 01:37:27,200
exciting.

2082
01:37:27,200 --> 01:37:28,000
I'm looking forward to it.

2083
01:37:28,000 --> 01:37:28,500
Definitely.

2084
01:37:28,500 --> 01:37:33,300
I'd like to have some prettier stuff up on the screen than our

2085
01:37:33,300 --> 01:37:33,700
gradient.

2086
01:37:33,700 --> 01:37:36,700
Not that our gradient is an awesome, but it would be nice to have some

2087
01:37:36,700 --> 01:37:39,600
real art made by a real artist on the screen.

2088
01:37:39,600 --> 01:37:40,900
So that's going to be pretty exciting.

2089
01:37:40,900 --> 01:37:43,000
I think as always

2090
01:37:43,700 --> 01:37:46,800
If you would like to follow along at home with the source code, you

2091
01:37:46,800 --> 01:37:48,700
can pre-order the game and it comes with the source code.

2092
01:37:48,700 --> 01:37:53,200
You can download it every night after I upload after we finish here.

2093
01:37:53,200 --> 01:37:56,200
I upload it so you can get immediate access to it.

2094
01:37:57,100 --> 01:38:03,200
And if you would like to basically discuss the the series or get more

2095
01:38:03,200 --> 01:38:06,300
resources, you can go to this news and forums site.

2096
01:38:06,300 --> 01:38:08,000
And basically it's got all kinds of things.

2097
01:38:08,000 --> 01:38:12,000
Got an episode guide for watching past episodes, along with some nice

2098
01:38:12,200 --> 01:38:13,600
time, annotations that allow you to

2099
01:38:13,700 --> 01:38:14,700
Jump Around the videos.

2100
01:38:15,000 --> 01:38:17,900
There's a coating Resource page, which has ports you can use, and also

2101
01:38:17,900 --> 01:38:19,400
some some helpful guides.

2102
01:38:19,800 --> 01:38:21,500
There's the discussion, which is the forums.

2103
01:38:21,500 --> 01:38:24,200
You can kind of go on here and post questions and talk with other

2104
01:38:24,200 --> 01:38:24,800
people.

2105
01:38:25,100 --> 01:38:27,300
So I highly recommend checking out this site.

2106
01:38:27,400 --> 01:38:31,000
If you're into the series and just want more resources and a place to

2107
01:38:31,000 --> 01:38:31,500
talk about it.

2108
01:38:31,500 --> 01:38:32,300
It's pretty handy.

2109
01:38:33,000 --> 01:38:35,400
So thank you very much, everyone for joining me.

2110
01:38:35,600 --> 01:38:37,400
We will be back tomorrow at the same time.

2111
01:38:37,400 --> 01:38:38,300
11:00 a.m.

2112
01:38:39,300 --> 01:38:43,000
We'll be back tomorrow for a little more clean up before coming back

2113
01:38:43,000 --> 01:38:43,500
on Monday.

2114
01:38:43,700 --> 01:38:45,600
At our regular time 8:00 p.m.

2115
01:38:45,600 --> 01:38:48,200
So thank you very much for and I will hope.

2116
01:38:48,200 --> 01:38:49,300
Hopefully see you tomorrow.

