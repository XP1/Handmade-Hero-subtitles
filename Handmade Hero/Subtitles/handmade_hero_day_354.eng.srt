1
00:00:01,300 --> 00:00:02,100
Start recording.

2
00:00:03,500 --> 00:00:04,400
Alrighty.

3
00:00:04,400 --> 00:00:06,200
Hello everyone and welcome to handmade hero.

4
00:00:06,200 --> 00:00:09,700
The show we code a complete game live on stream yesterday during the

5
00:00:09,700 --> 00:00:10,000
priest room.

6
00:00:10,000 --> 00:00:11,200
We had a question about.

7
00:00:11,400 --> 00:00:12,100
Well, not really question.

8
00:00:12,100 --> 00:00:17,100
We had a little quick talk about our Ellie and I decided there's some

9
00:00:17,100 --> 00:00:20,900
stuff I wanted to show about how R ly and LZ are very similar.

10
00:00:22,000 --> 00:00:25,700
So, I wrote One Yesterday, wrote a gnarly compressor, and a little

11
00:00:25,700 --> 00:00:29,300
framework for us to use and we compressed our art asset files with it.

12
00:00:30,000 --> 00:00:34,100
And, you know, as we showed yesterday, surprisingly even a really

13
00:00:34,100 --> 00:00:37,900
really dumb Marley compressor actually compresses our art pretty well,

14
00:00:38,600 --> 00:00:40,400
not compared to a really good compressor.

15
00:00:40,400 --> 00:00:41,100
It doesn't.

16
00:00:41,200 --> 00:00:42,800
But compared to no compression.

17
00:00:42,800 --> 00:00:43,600
It was quite nice.

18
00:00:43,600 --> 00:00:47,600
I think it saved 25% of the file size just from our little really,

19
00:00:47,600 --> 00:00:48,200
really bad.

20
00:00:48,200 --> 00:00:49,000
Our Ally compressor.

21
00:00:51,100 --> 00:00:54,900
And again, I think that's largely because hey, you got a lot of alpha

22
00:00:54,900 --> 00:00:57,000
space in Sprites, right?

23
00:00:57,100 --> 00:00:57,600
And a gnarly.

24
00:00:57,600 --> 00:01:01,500
Compressor can just suck all that up really easily, so it ends up

25
00:01:01,500 --> 00:01:02,300
being pretty handy.

26
00:01:03,800 --> 00:01:07,600
Anyway, what I wanted to do today, was just quickly for this session

27
00:01:07,600 --> 00:01:12,400
show how, you know, a basic LZ compressor or style compressor

28
00:01:12,400 --> 00:01:13,500
dictionary compressors really.

29
00:01:13,500 --> 00:01:17,100
What I should say is not that different from an early compressor

30
00:01:17,100 --> 00:01:19,800
actually, and for that matter, you

31
00:01:19,900 --> 00:01:22,300
Can sort of just treat our Ellie.

32
00:01:22,400 --> 00:01:24,900
You can basically get are really out of a dictionary compressor as I

33
00:01:24,900 --> 00:01:26,000
explained yesterday.

34
00:01:26,300 --> 00:01:28,900
How are really just kind of automatically happens in a dictionary

35
00:01:28,900 --> 00:01:33,600
compressor, because it's just a look back of one or some number, and

36
00:01:33,600 --> 00:01:35,000
it just will repeat that thing.

37
00:01:35,300 --> 00:01:37,500
So, we kind of went over that as well.

38
00:01:37,800 --> 00:01:39,800
Let me go ahead and do that.

39
00:01:40,300 --> 00:01:41,500
Just show how that stuff works.

40
00:01:41,500 --> 00:01:42,500
So now we have it in practice.

41
00:01:42,500 --> 00:01:45,400
If you haven't watched yesterday stream, you definitely want to

42
00:01:45,400 --> 00:01:47,900
because I explained all the stuff about LZ yesterday.

43
00:01:48,400 --> 00:01:49,700
So, you're going to be a little lost.

44
00:01:49,800 --> 00:01:53,600
If you didn't hear that, exploit explanation when we start here today.

45
00:01:54,000 --> 00:01:59,300
Alright, so what we did is we built this little compressor right here,

46
00:01:59,300 --> 00:01:59,800
it is.

47
00:02:00,000 --> 00:02:02,300
And I'm going to go ahead and light on here.

48
00:02:03,000 --> 00:02:04,800
I'm going to go ahead and build it.

49
00:02:05,300 --> 00:02:07,900
I guess I also have to load my project file.

50
00:02:07,900 --> 00:02:08,900
There we go.

51
00:02:10,400 --> 00:02:14,400
And our compressor is very, very simple.

52
00:02:14,400 --> 00:02:17,200
So you can see here is the entirety of the code for it, right?

53
00:02:17,600 --> 00:02:19,800
And all it does is it starts out in Maine and

54
00:02:19,900 --> 00:02:20,500
Loads.

55
00:02:20,600 --> 00:02:23,000
It basically looks to see whether it needs to compress or decompress

56
00:02:23,000 --> 00:02:23,400
the file.

57
00:02:23,400 --> 00:02:29,000
It loads its first argument after that instruction, and then it either

58
00:02:29,000 --> 00:02:31,200
calls the compressor or the decompressor.

59
00:02:31,200 --> 00:02:32,800
And then it writes out, whatever.

60
00:02:32,800 --> 00:02:36,700
The that thing spit out, if it was a compressor, it writes out the

61
00:02:36,700 --> 00:02:38,800
compressed file, if it's a decompressor, it writes out the

62
00:02:38,800 --> 00:02:41,000
decompressed file, that's all the main Loop does.

63
00:02:41,300 --> 00:02:44,700
And then we just have up here are compress and decompress functions.

64
00:02:44,900 --> 00:02:48,100
And right now, all they do is thunk through to the rle compressor

65
00:02:48,100 --> 00:02:49,500
because that's what we wrote up here.

66
00:02:49,800 --> 00:02:52,000
Right, so that's what we got.

67
00:02:53,100 --> 00:02:54,500
So here's our early compressed.

68
00:02:54,500 --> 00:02:55,800
Here's our, our LED compressed.

69
00:02:55,800 --> 00:02:57,100
And one thing you will notice

70
00:02:59,000 --> 00:02:59,900
And this is pretty much.

71
00:03:00,000 --> 00:03:04,000
Universally true of every compression thing I've ever seen.

72
00:03:04,600 --> 00:03:07,800
And again, as I said, many times yesterday, take it all with a grain

73
00:03:07,800 --> 00:03:09,500
of salt because I'm not a compression person.

74
00:03:09,500 --> 00:03:15,100
So, anything I really say about compression is is basic, is is

75
00:03:15,100 --> 00:03:16,000
beginner stuff.

76
00:03:16,500 --> 00:03:20,700
But you know, typically speaking whenever you look at these, what you

77
00:03:20,700 --> 00:03:23,300
generally will see, is exactly what this looks like.

78
00:03:23,500 --> 00:03:28,100
The decompressor for something is usually very simple, right?

79
00:03:28,100 --> 00:03:29,800
It's probably not this simple.

80
00:03:30,000 --> 00:03:32,000
I'll for more complicated compressors.

81
00:03:32,000 --> 00:03:38,900
It's going to be you know, not quite so trivial but it's typically not

82
00:03:38,900 --> 00:03:43,000
that big compared to the compressor which is usually to three times

83
00:03:43,000 --> 00:03:43,600
its size.

84
00:03:44,100 --> 00:03:47,200
And the reason for that is because usually D compressors.

85
00:03:47,600 --> 00:03:54,100
The the formats for things are over specified and and just to give you

86
00:03:54,100 --> 00:03:57,100
a little bit of sort of a feel for that

87
00:03:57,500 --> 00:04:01,800
There are some compressors, such as like, entropy encoder is like

88
00:04:01,800 --> 00:04:03,200
Huffman or arithmetic.

89
00:04:03,200 --> 00:04:06,000
Encoders rants, encoders, or ANS encoders?

90
00:04:06,000 --> 00:04:10,100
I should say those sorts of things that are extremely tightly

91
00:04:10,100 --> 00:04:11,000
specified.

92
00:04:11,000 --> 00:04:15,100
And what that means is that generally, there's only one way to encode

93
00:04:15,100 --> 00:04:18,600
and decode a particular stream right now.

94
00:04:18,600 --> 00:04:21,300
That doesn't mean there's not, lots of ways you could choose to

95
00:04:21,300 --> 00:04:23,100
structure the encoding, right?

96
00:04:23,100 --> 00:04:27,200
Whether or not it's adaptive, whether or not you encode it with

97
00:04:27,600 --> 00:04:30,700
Bit patterns, whether how you're putting certain pieces of data, in

98
00:04:31,000 --> 00:04:32,600
all that stuff is definitely flexible.

99
00:04:33,000 --> 00:04:35,200
So, I don't mean to say that the compressors aren't flexible.

100
00:04:35,200 --> 00:04:39,100
What I mean to say is, once you pick how all that's done, there's no

101
00:04:39,100 --> 00:04:41,200
decisions to be made, right?

102
00:04:41,700 --> 00:04:45,100
So, when a stream goes into the compressor, it's just churning through

103
00:04:45,100 --> 00:04:48,600
it, and it spits out the, the, the stream on the other end.

104
00:04:48,600 --> 00:04:49,600
And then, the decompressor does.

105
00:04:49,600 --> 00:04:50,100
The same thing.

106
00:04:50,100 --> 00:04:54,300
It takes in a stream turns through it and spits out the result, right?

107
00:04:55,000 --> 00:04:57,400
And what that means is that the compressor and

108
00:04:57,500 --> 00:05:01,000
decompressor very often for those.

109
00:05:01,000 --> 00:05:05,500
Sorts of things are not that different in terms of size and complexity

110
00:05:05,700 --> 00:05:10,200
because the compressor doesn't have to think, right?

111
00:05:10,300 --> 00:05:13,200
There's only one way to encode the thing coming in.

112
00:05:13,200 --> 00:05:18,300
So there's not a lot of thinking that the compressor has to do now

113
00:05:18,600 --> 00:05:19,900
with everything else.

114
00:05:20,800 --> 00:05:25,500
You know elzy and mpeg-4 or any of these other sorts of things.

115
00:05:26,300 --> 00:05:31,200
Typically what happens is the compressor actually has lots of options

116
00:05:31,500 --> 00:05:35,600
of how it's going to choose to encode an incoming stream.

117
00:05:35,600 --> 00:05:39,800
There are many ways to encode an incoming stream that will all produce

118
00:05:39,800 --> 00:05:42,100
the same output stream, right?

119
00:05:42,700 --> 00:05:47,700
And that is why the compressor side often ends up being larger and

120
00:05:47,700 --> 00:05:50,800
more complicated and involving more sophisticated algorithms than the

121
00:05:50,800 --> 00:05:52,000
decompression side.

122
00:05:52,300 --> 00:05:56,000
Because essentially the compression side is like an AI problem.

123
00:05:56,100 --> 00:05:59,800
Almost right, it involves like search and you know, graph.

124
00:06:00,000 --> 00:06:03,800
Reversal and things like this, often times to try and figure out what

125
00:06:03,800 --> 00:06:04,600
it should be doing.

126
00:06:04,600 --> 00:06:10,500
And what the most likely thing is that will produce the small-sized

127
00:06:10,500 --> 00:06:12,300
signals the small-sized outputs.

128
00:06:12,800 --> 00:06:14,900
Whereas the decompressor is just wrote.

129
00:06:14,900 --> 00:06:18,200
The decompressor is still just one stream in one stream out.

130
00:06:18,200 --> 00:06:20,700
No decisions to make no thought, right?

131
00:06:22,600 --> 00:06:28,800
So typically, it always does look like this and you can actually even

132
00:06:28,800 --> 00:06:29,800
see just in our

133
00:06:30,000 --> 00:06:33,800
A little rle compressor which is the stupidest possible thing, right?

134
00:06:34,700 --> 00:06:36,100
You can see even there.

135
00:06:36,100 --> 00:06:40,200
We have all these complex decisions to make at any given time to the

136
00:06:40,200 --> 00:06:40,600
loop.

137
00:06:40,600 --> 00:06:45,100
We can choose to Output a new literal run pair or not.

138
00:06:46,800 --> 00:06:50,200
Right, every time to this Loop or making a decision should be do that.

139
00:06:50,200 --> 00:06:53,200
Now, our decision logic is very, very basic right here and not

140
00:06:53,200 --> 00:06:53,900
particularly good.

141
00:06:53,900 --> 00:06:57,600
Like I said before, this should probably be a different number, right?

142
00:07:00,100 --> 00:07:00,700
But

143
00:07:02,600 --> 00:07:08,300
Even in this extremely simple case you can already start to see the

144
00:07:08,400 --> 00:07:13,100
asymmetry in complexity of compressors and D compressors even though

145
00:07:13,100 --> 00:07:15,000
we have done the very stupidest thing.

146
00:07:15,000 --> 00:07:18,300
Possible in both cases we did the very stupidest thing we could

147
00:07:18,300 --> 00:07:20,400
possibly do we still

148
00:07:21,600 --> 00:07:23,500
Are already seeing that difference?

149
00:07:23,700 --> 00:07:25,500
Start to appear, right?

150
00:07:27,400 --> 00:07:30,400
And it only gets worse, so that that's just typically.

151
00:07:31,000 --> 00:07:34,500
My experience is that it only gets worse as you go further and further

152
00:07:34,500 --> 00:07:39,400
down the rabbit hole of compression towards better and better results

153
00:07:39,800 --> 00:07:41,900
and more and more sophisticated algorithms.

154
00:07:42,000 --> 00:07:45,800
It's generally the case that, you know, if I wanted to explain to

155
00:07:45,800 --> 00:07:49,200
somebody how to write the decompressor for a particular compression

156
00:07:49,200 --> 00:07:53,500
algorithm, usually, that's the kind of thing you can do in an hour if

157
00:07:53,500 --> 00:07:55,700
you want to explain to someone how to write a good.

158
00:07:56,600 --> 00:08:00,500
For it, it might take months right up, study, right?

159
00:08:00,500 --> 00:08:04,600
Who knows that may be an exaggeration, but you get the idea, the

160
00:08:04,600 --> 00:08:08,000
compressors end up being sort of very sophisticated and having a lot

161
00:08:08,000 --> 00:08:10,300
of complexity to them.

162
00:08:11,900 --> 00:08:14,900
So that is basically where we're at with that.

163
00:08:14,900 --> 00:08:19,600
So, all I want to do now is sort of expand this out to instead of

164
00:08:19,600 --> 00:08:22,500
doing just are really doing LZ compression.

165
00:08:24,400 --> 00:08:25,100
Now again,

166
00:08:26,700 --> 00:08:29,000
We are not trying to make a good compressor here.

167
00:08:29,000 --> 00:08:31,700
I'm just trying to illustrate the concept.

168
00:08:31,700 --> 00:08:35,200
So this is going to be a very bad LZ compressor.

169
00:08:35,600 --> 00:08:38,799
Not one that that would ever be particularly good.

170
00:08:38,799 --> 00:08:39,299
What was the?

171
00:08:39,299 --> 00:08:40,799
Oh I wish I could have seen with that.

172
00:08:40,799 --> 00:08:41,200
Just what?

173
00:08:41,200 --> 00:08:42,000
Inserted in there.

174
00:08:42,100 --> 00:08:46,500
Oh it was that it was the day title from yesterday stream.

175
00:08:46,500 --> 00:08:48,000
I guess it was still in the paste buffer.

176
00:08:49,100 --> 00:08:49,700
All right.

177
00:08:49,800 --> 00:08:50,200
Anyway.

178
00:08:50,200 --> 00:08:53,500
So here we go with with our early situation.

179
00:08:54,300 --> 00:08:56,200
You know I'm going to just copy this and

180
00:08:56,300 --> 00:08:57,900
It in 2lz decompress.

181
00:08:58,100 --> 00:08:59,700
And like I was saying before,

182
00:09:00,400 --> 00:09:03,800
Really the only difference between our ly and LZ from the base

183
00:09:03,800 --> 00:09:07,500
conceptual standpoint is that instead of encoding.

184
00:09:07,700 --> 00:09:11,300
The thing that we are going to copy as just a single piece of

185
00:09:11,300 --> 00:09:15,200
information that we just replicate some number of times instead.

186
00:09:15,200 --> 00:09:19,000
What we're going to do is encode an offset that tells us we're in the

187
00:09:19,000 --> 00:09:23,100
Stream to look back to grab the thing that we want to replicate.

188
00:09:23,400 --> 00:09:23,900
Right?

189
00:09:25,100 --> 00:09:28,200
So what we're going to do here instead is you see this, this is how

190
00:09:28,200 --> 00:09:29,400
our decompression.

191
00:09:30,000 --> 00:09:31,700
For our Ali was working before we were saying.

192
00:09:31,700 --> 00:09:35,700
Okay while we still have stuff to ingest, let's take a look at how

193
00:09:35,700 --> 00:09:39,000
many literals we expect to see go through the literals and copy them

194
00:09:39,000 --> 00:09:40,000
to the output stream.

195
00:09:40,200 --> 00:09:43,700
Then, you know, because we're always doing it in pairs, then we go

196
00:09:43,700 --> 00:09:44,200
through and say.

197
00:09:44,200 --> 00:09:46,200
All right, what's the the rep count?

198
00:09:46,300 --> 00:09:47,400
And what's the rep value?

199
00:09:47,400 --> 00:09:50,200
And then we rep that we repeat that value going forwards now.

200
00:09:50,200 --> 00:09:54,200
So all we're going to do here is change this to like a copy count and

201
00:09:54,200 --> 00:09:55,900
a copy value, right?

202
00:09:56,100 --> 00:09:59,000
Instead, our copy value will now become a.

203
00:09:59,000 --> 00:09:59,800
Well, I guess I can leave it as

204
00:10:00,000 --> 00:10:04,300
Wait, instead of a single value is just going to be a distance, right?

205
00:10:05,100 --> 00:10:08,800
And so the instead of reading in a bite to replicate, we're going to

206
00:10:08,800 --> 00:10:09,300
read into B.

207
00:10:09,300 --> 00:10:11,400
The tells us how far back from our current location.

208
00:10:11,400 --> 00:10:14,500
We want to go, right?

209
00:10:16,100 --> 00:10:16,600
Okay.

210
00:10:17,800 --> 00:10:21,100
Now what you'll notice here is that the copy distance, we have some

211
00:10:21,100 --> 00:10:21,700
choices here.

212
00:10:21,700 --> 00:10:25,600
If we want to we can simplify this algorithm a little bit.

213
00:10:26,400 --> 00:10:29,800
If we want to one thing we can do if you take

214
00:10:29,900 --> 00:10:30,300
Look at this.

215
00:10:30,300 --> 00:10:31,900
Copy distance, right?

216
00:10:31,900 --> 00:10:32,700
And copy count.

217
00:10:32,800 --> 00:10:35,100
Let's think about what that's going to do and I guess I can, I can

218
00:10:35,100 --> 00:10:37,700
just go ahead and implement it so you can see right.

219
00:10:37,700 --> 00:10:40,600
But here we're going to need a pointer that's like a source pointer,

220
00:10:40,600 --> 00:10:41,200
right?

221
00:10:41,400 --> 00:10:43,000
And the source pointer is just going to be.

222
00:10:43,000 --> 00:10:46,000
Like I said, it's our out buffer - the copy distance.

223
00:10:46,200 --> 00:10:46,700
Right?

224
00:10:46,900 --> 00:10:49,500
Because if you remember how LZ is supposed to work from discussion

225
00:10:49,500 --> 00:10:51,200
yesterday, we are.

226
00:10:51,200 --> 00:10:52,100
Well, you know what?

227
00:10:53,900 --> 00:10:57,500
If we go here to this, This Disaster, where is it?

228
00:10:58,000 --> 00:11:00,000
It's down here somewhere, right?

229
00:11:00,700 --> 00:11:03,100
We're in the output buffer, writing to the output buffer, and when we

230
00:11:03,100 --> 00:11:06,000
get to a particular location, sometimes we just say, hey, go back to

231
00:11:06,000 --> 00:11:08,700
somewhere else in the Stream and copy from there, right?

232
00:11:08,700 --> 00:11:10,900
So it's all happening in our output buffer.

233
00:11:10,900 --> 00:11:15,000
The only thing that we're trying to do here is say like okay when we

234
00:11:15,000 --> 00:11:18,400
have that output buffer pointer which is where we're currently

235
00:11:18,400 --> 00:11:22,000
outputting, we just want to start some distance back from there and

236
00:11:22,000 --> 00:11:23,200
copy, right?

237
00:11:23,300 --> 00:11:23,500
So,

238
00:11:23,600 --> 00:11:23,900
Say.

239
00:11:23,900 --> 00:11:25,600
All right, we're gonna start some distance back from there.

240
00:11:25,600 --> 00:11:28,300
We're going to go copy count and we're going to Output into the

241
00:11:28,300 --> 00:11:33,900
buffer, whatever was in the buffer previously at that location, right?

242
00:11:35,800 --> 00:11:41,700
Now again, this is where that subtlety of how orally can actually be

243
00:11:41,700 --> 00:11:43,200
implemented directly in LZ.

244
00:11:43,200 --> 00:11:46,700
This is it right here, because imagine what happens when copy distance

245
00:11:46,700 --> 00:11:51,700
is just one for example, but copy count is 20, right?

246
00:11:51,900 --> 00:11:56,000
Well, what will happen is, we'll go back one from where we are right

247
00:11:56,000 --> 00:11:59,800
now, which means that the last bite we output is now where

248
00:12:00,000 --> 00:12:03,400
We're looking at for copy and then we're going to do it 20 times.

249
00:12:03,400 --> 00:12:07,600
So we're going to take a copy of that bite and put it in the current

250
00:12:07,600 --> 00:12:08,400
output position.

251
00:12:08,600 --> 00:12:11,200
We're going to move the source point or forwards which is now pointing

252
00:12:11,200 --> 00:12:12,200
at exactly the bite.

253
00:12:12,200 --> 00:12:15,800
It just wrote which is a replication of the previous B and the process

254
00:12:15,800 --> 00:12:16,500
will repeat itself.

255
00:12:16,500 --> 00:12:22,100
19 more times copying that bite every time so effectively we get a

256
00:12:22,100 --> 00:12:26,600
gnarly compressor inside rlz compressor for free essentially, right?

257
00:12:27,000 --> 00:12:29,800
I mean in free is probably not the right term because you are

258
00:12:30,000 --> 00:12:33,600
perhaps giving up a little bit of encoding for a but you can kind of

259
00:12:33,600 --> 00:12:37,700
see how it doesn't really take any special work to get run length,

260
00:12:37,700 --> 00:12:44,100
encoding out of an LZ compressor because effectively if you just give

261
00:12:44,100 --> 00:12:48,400
a larger copy count than the distance that you jumped back, you will

262
00:12:48,400 --> 00:12:49,100
replicate.

263
00:12:50,100 --> 00:12:50,600
Right.

264
00:12:50,600 --> 00:12:53,500
And it also allows you to do something that they are really can't do

265
00:12:53,700 --> 00:12:55,400
without additional parameters.

266
00:12:55,400 --> 00:12:59,100
That would take space to encode, which is you can replicate values

267
00:12:59,100 --> 00:13:02,400
that are longer than one symbol, right?

268
00:13:02,500 --> 00:13:07,300
You can say go back for copy eight and that will do two copies of the

269
00:13:07,300 --> 00:13:08,600
last four in the buffer, right?

270
00:13:08,600 --> 00:13:11,600
So it can do that sort of thing, hopefully, that makes sense.

271
00:13:13,500 --> 00:13:14,000
All right.

272
00:13:16,200 --> 00:13:20,400
So there's our ldl-c decompressor and literally that's all there is to

273
00:13:20,400 --> 00:13:20,900
it.

274
00:13:21,100 --> 00:13:24,800
There's really nothing else that you have to do to implement the

275
00:13:24,800 --> 00:13:25,600
decompressor.

276
00:13:25,800 --> 00:13:29,900
Again, like I said, it's always the compressor.

277
00:13:29,900 --> 00:13:31,000
That's the more complicated.

278
00:13:31,000 --> 00:13:34,100
So even though that's the only change we made our compressor is about

279
00:13:34,100 --> 00:13:36,300
to get a lot more complicated in order to do anything.

280
00:13:36,300 --> 00:13:41,200
Even even a really crappy LZ, compressor is much more complicated than

281
00:13:41,400 --> 00:13:42,900
a crappy lzd compressor.

282
00:13:43,400 --> 00:13:45,600
And so, we're about to see that.

283
00:13:45,600 --> 00:13:48,100
But anyway, so now you can see how this LCD compressor works.

284
00:13:48,700 --> 00:13:51,800
We do the exact same thing, we read in a literal count and off we go.

285
00:13:52,200 --> 00:13:55,200
And then we do the same thing in the early, just copy.

286
00:13:55,300 --> 00:13:57,200
And then we do, you know our other stuff here.

287
00:13:57,200 --> 00:13:57,900
We take, okay?

288
00:13:57,900 --> 00:14:01,300
A copy count or copy distance and we perform that copy from somewhere

289
00:14:01,300 --> 00:14:02,000
Back In The Stream.

290
00:14:02,000 --> 00:14:05,600
Now, what I was going to say is there's another thing we can do here

291
00:14:05,900 --> 00:14:08,300
to simplify this further, actually.

292
00:14:09,200 --> 00:14:12,400
And give us a little more flexibility in the end coder.

293
00:14:13,100 --> 00:14:15,000
We could have done this with our Ali as well.

294
00:14:17,200 --> 00:14:22,700
Potentially, but it costs more in the early to do.

295
00:14:23,500 --> 00:14:28,300
And basically what happens in a an LZ encoder is, if you think about

296
00:14:28,300 --> 00:14:31,800
what's going on here is, we're reading a copy count, and then we're

297
00:14:31,800 --> 00:14:34,200
reading a copy distance, okay?

298
00:14:35,200 --> 00:14:36,300
That's what we're doing, right?

299
00:14:37,000 --> 00:14:40,600
And if you think about what that copy distance is going to be, if the

300
00:14:40,600 --> 00:14:43,900
copy distance were to come in as 0, right?

301
00:14:43,900 --> 00:14:45,500
So the amount to look,

302
00:14:45,600 --> 00:14:46,900
Back was Zero.

303
00:14:49,000 --> 00:14:53,700
In that case, we would know that we couldn't possibly be talking about

304
00:14:53,700 --> 00:14:57,100
an actual copy, right?

305
00:14:57,100 --> 00:14:59,800
Because 0 would not move the pointer at all from

306
00:15:00,000 --> 00:15:03,400
Output location which means that we would be reading garbage because

307
00:15:03,400 --> 00:15:06,700
we haven't seen what happens in the Stream at that point, right?

308
00:15:07,100 --> 00:15:12,000
So in order to not waste one value, which is zero.

309
00:15:13,300 --> 00:15:17,100
In the copy distance lat, there's two choices of what we can do.

310
00:15:17,500 --> 00:15:20,400
One is we can get an extra bite.

311
00:15:20,500 --> 00:15:24,200
You know, of Look Back by saying, when we read in the copy distance

312
00:15:24,200 --> 00:15:27,100
since we know 0 is invalid just add one.

313
00:15:27,300 --> 00:15:30,800
And that way, instead of being able to look 255, bytes back, we can

314
00:15:30,800 --> 00:15:33,300
now look 256 bytes back, right?

315
00:15:33,400 --> 00:15:36,200
So we can steal that value to get a little bit further.

316
00:15:36,200 --> 00:15:37,300
Look back, right?

317
00:15:38,900 --> 00:15:42,600
But perhaps more powerfully in terms of what we will probably

318
00:15:43,100 --> 00:15:48,400
To get in terms of compression, there is what if instead we just said

319
00:15:48,400 --> 00:15:51,600
well, we're reading a literal count or a copy count, right?

320
00:15:51,600 --> 00:15:55,600
What if we just called it account and we read it every time and then

321
00:15:55,600 --> 00:16:00,300
we said when we read the distance if the copy distance is 0 then we

322
00:16:00,300 --> 00:16:04,600
assume right that we're going to be copying literals from the input

323
00:16:04,600 --> 00:16:10,200
stream and if the if the copy distance isn't 0 then we will do our

324
00:16:11,500 --> 00:16:12,200
account.

325
00:16:13,900 --> 00:16:14,700
Our replication.

326
00:16:16,300 --> 00:16:16,800
Right?

327
00:16:17,900 --> 00:16:19,100
And that's perhaps a little bit more.

328
00:16:19,100 --> 00:16:20,700
Interesting way to use that value.

329
00:16:20,700 --> 00:16:24,400
Now, again, this is not supposed to be some deep insight into LZ at

330
00:16:24,400 --> 00:16:27,400
all, because by the time you start doing anything sophisticated with

331
00:16:27,400 --> 00:16:30,600
LZ your way, past the point of thinking about it in those terms

332
00:16:30,600 --> 00:16:31,200
anyway.

333
00:16:32,800 --> 00:16:35,900
But just in terms of the very simplistic, way that, we've set it up,

334
00:16:35,900 --> 00:16:37,300
you can see that there's an interesting choice.

335
00:16:37,300 --> 00:16:39,400
There, it seems like this is probably a better choice.

336
00:16:40,000 --> 00:16:44,600
Given what we're going with two to say like hey well you know, do we

337
00:16:44,600 --> 00:16:45,900
really care about just

338
00:16:46,100 --> 00:16:47,200
One extra bite of.

339
00:16:47,200 --> 00:16:51,200
Look back is instead we could use that one bite to be the thing that

340
00:16:51,200 --> 00:16:54,600
switches between our two modes that way when the encoder wants to

341
00:16:54,600 --> 00:16:57,100
encode things, it doesn't have to encode them as pairs.

342
00:16:57,300 --> 00:17:01,500
It can every time in code which one it wanted to do and we put in one

343
00:17:01,500 --> 00:17:05,500
branch in the decompressor to make that happen, right?

344
00:17:09,700 --> 00:17:14,400
Now, as you can see, that means that essentially we've got two Loops

345
00:17:14,400 --> 00:17:16,800
here, and these Loops are almost identical.

346
00:17:17,099 --> 00:17:17,599
Right?

347
00:17:17,800 --> 00:17:19,400
They're almost exactly the same.

348
00:17:20,599 --> 00:17:21,700
You can see them here.

349
00:17:23,200 --> 00:17:23,500
Right.

350
00:17:23,500 --> 00:17:27,500
We've got wild count - - while count - - and the only difference is,

351
00:17:27,500 --> 00:17:29,400
which thing we're taking from.

352
00:17:30,000 --> 00:17:34,200
So, what I might further say, just to keep this decompressor just to

353
00:17:34,400 --> 00:17:38,700
hammer home, the point that the compressors are so simple, you know, a

354
00:17:38,700 --> 00:17:39,400
lot of the times.

355
00:17:39,900 --> 00:17:44,800
If we were to just say, all right, what if we just made our source, be

356
00:17:44,800 --> 00:17:49,500
dependent, just the pointer dependent on which one we were going to do

357
00:17:49,500 --> 00:17:50,600
here, right?

358
00:17:52,400 --> 00:17:53,600
and, and then,

359
00:17:55,800 --> 00:17:58,500
we could maybe avoid having to do,

360
00:18:00,100 --> 00:18:02,000
We could just have a single Loop, right?

361
00:18:02,000 --> 00:18:05,000
That just one Loop that executes, we don't have to have two different

362
00:18:05,000 --> 00:18:05,800
Loops, right?

363
00:18:06,500 --> 00:18:10,800
And it's not quite as pretty as we might want it to be, right?

364
00:18:10,900 --> 00:18:13,400
And these are actually backwards here like me.

365
00:18:13,600 --> 00:18:13,900
Yeah.

366
00:18:16,200 --> 00:18:19,000
So you know, if the copy distance is 0, then we copy from in.

367
00:18:19,000 --> 00:18:24,900
If the copy distance is is not, then we do sort of our replication.

368
00:18:26,500 --> 00:18:30,600
But the only problem that we get here is that we don't know.

369
00:18:30,600 --> 00:18:35,600
Actually, which of the once we do this, we've pulled the in pointer

370
00:18:35,600 --> 00:18:38,500
out into the source pointer, which means that it won't actually

371
00:18:38,500 --> 00:18:40,300
Advance, right?

372
00:18:40,500 --> 00:18:44,500
And we need it to advance by the count, in the case where,

373
00:18:45,400 --> 00:18:46,900
you know, we were going to actually

374
00:18:50,900 --> 00:18:54,300
In the case, where we were actually going to copy from in, we need

375
00:18:54,300 --> 00:18:55,000
into advanced.

376
00:18:55,000 --> 00:18:57,900
So really, we need there to be something like, you know, that where we

377
00:18:58,000 --> 00:19:03,100
remove it forwards, and I'm not sure there's any really cleaner way to

378
00:19:03,100 --> 00:19:03,600
write that.

379
00:19:03,600 --> 00:19:03,900
Right?

380
00:19:03,900 --> 00:19:08,400
So, I can't quite see how to do,

381
00:19:11,800 --> 00:19:13,500
I mean, I guess we could just do this.

382
00:19:23,700 --> 00:19:24,200
Right.

383
00:19:26,100 --> 00:19:26,400
Yeah.

384
00:19:26,400 --> 00:19:28,300
But I don't know that there's any way to do it.

385
00:19:28,300 --> 00:19:29,400
Any more cleanly than that.

386
00:19:29,400 --> 00:19:33,300
Unfortunately, you I mean, you don't really want to execute the, if in

387
00:19:33,300 --> 00:19:36,700
line, but you can kind of see that it's relatively straightforward,

388
00:19:36,700 --> 00:19:37,100
right?

389
00:19:38,500 --> 00:19:40,400
So yeah, there's something.

390
00:19:40,400 --> 00:19:42,300
Am I missing anything cleaner?

391
00:19:42,300 --> 00:19:43,700
We could do there?

392
00:19:43,700 --> 00:19:45,200
I don't know.

393
00:19:45,700 --> 00:19:50,100
Really what you want to do is just have it be like you know,

394
00:19:53,800 --> 00:19:57,400
There and have this happen after the fact that would be the nicest way

395
00:19:57,400 --> 00:19:58,100
to do it.

396
00:19:58,100 --> 00:20:02,100
But unfortunately, there is no sort of post decrement with a ver with

397
00:20:02,100 --> 00:20:04,500
a variable size in C.

398
00:20:04,500 --> 00:20:07,800
So I think that's pretty much the only way you could do it, if that

399
00:20:07,800 --> 00:20:08,300
makes sense.

400
00:20:08,900 --> 00:20:13,300
So yeah, so maybe you know, it's better to just say like okay, you

401
00:20:13,300 --> 00:20:19,300
know, we've got our source pointer and we just say if the copy

402
00:20:19,300 --> 00:20:21,700
distance is zero then the source

403
00:20:23,100 --> 00:20:26,400
Peoples in and in plus equals count.

404
00:20:29,700 --> 00:20:31,000
And I guess I could just sort of

405
00:20:33,300 --> 00:20:33,900
do that.

406
00:20:37,000 --> 00:20:40,200
So again, not quite as concise as I would like but still very very

407
00:20:40,200 --> 00:20:40,900
small, right?

408
00:20:40,900 --> 00:20:41,900
Very, very simple.

409
00:20:42,400 --> 00:20:44,700
And so we come in here and we say, all right well we have stuff to

410
00:20:44,700 --> 00:20:45,200
ingest.

411
00:20:45,200 --> 00:20:50,000
We grab the count that we're going to use out of the current location

412
00:20:50,000 --> 00:20:51,000
in our input stream.

413
00:20:51,100 --> 00:20:57,100
We grabbed a distance as well and then we look and say, okay, when we

414
00:20:57,100 --> 00:20:58,100
see the distance

415
00:21:02,900 --> 00:21:06,200
We will say if it is equal to 0, then we're going to copy from the

416
00:21:06,200 --> 00:21:09,800
input and we're going to advance the input by however many things

417
00:21:09,800 --> 00:21:11,000
we're going to copy out of it.

418
00:21:11,300 --> 00:21:13,300
Otherwise we're going to look backwards.

419
00:21:13,300 --> 00:21:15,900
The copy distance from our current output location.

420
00:21:16,200 --> 00:21:18,800
Then we're going to use a while loop to go for as long as we were

421
00:21:18,800 --> 00:21:19,100
told.

422
00:21:19,100 --> 00:21:22,300
To go copying from whichever one of those we decided to copy from

423
00:21:23,400 --> 00:21:23,900
Right.

424
00:21:25,100 --> 00:21:28,300
And so there you go that's that's about it.

425
00:21:28,700 --> 00:21:33,100
Now you'll note that in doing so when I said we're going to use that

426
00:21:33,100 --> 00:21:37,000
extra value, we give something up in terms of compression for doing

427
00:21:37,000 --> 00:21:37,500
that.

428
00:21:38,400 --> 00:21:42,900
Because previously, when the encoder didn't have a decision and it was

429
00:21:42,900 --> 00:21:49,000
always done in pairs, doing it, in Paris, has the advantage of not

430
00:21:49,000 --> 00:21:50,200
needing to.

431
00:21:50,200 --> 00:21:53,000
Encode the fact that you were going to do

432
00:21:53,200 --> 00:21:53,800
The other.

433
00:21:53,900 --> 00:21:56,900
So what we did is we gave up a bite here.

434
00:21:57,200 --> 00:22:00,700
Every time we want to encode a series of literals, we will have to

435
00:22:00,700 --> 00:22:02,900
encode a bite and that bite that.

436
00:22:02,900 --> 00:22:03,800
There's a 0 B.

437
00:22:03,800 --> 00:22:07,500
Basically, that would have to be encoded there and that might be a bad

438
00:22:07,500 --> 00:22:08,400
decision, right?

439
00:22:08,500 --> 00:22:12,900
So it may be that it would be better for us to do depending on what

440
00:22:12,900 --> 00:22:13,900
our circumstances are it?

441
00:22:13,900 --> 00:22:17,200
Maybe that would be better for us to always do a where we go literal,

442
00:22:17,400 --> 00:22:20,700
repeat literal, repeat literal repeat right.

443
00:22:20,700 --> 00:22:23,000
Look we're doing a gnarly, it might be better for us to go.

444
00:22:23,200 --> 00:22:26,800
Go like literal copy literal, copy literal copy.

445
00:22:27,300 --> 00:22:31,400
If the data tends to be of the format that allows us to do that

446
00:22:31,400 --> 00:22:37,300
interleave then that would always be better because we're saving 10 B.

447
00:22:37,400 --> 00:22:41,700
Every time we do that internally, however, if most of the time we

448
00:22:41,700 --> 00:22:45,200
aren't doing the interleave, if most of the time were either, we're

449
00:22:45,200 --> 00:22:49,900
doing like unusual like unpredictable patterns like copy copy literal,

450
00:22:49,900 --> 00:22:52,900
copy literal, literal copy copy, copy literal, copy literal.

451
00:22:53,200 --> 00:22:58,000
Our then we've saved quite a bit so it's really hard to say and like

452
00:22:58,000 --> 00:23:00,600
this this is sort of the way compression works, right?

453
00:23:02,300 --> 00:23:05,400
You're constantly thinking about all these sorts of things and if you

454
00:23:05,400 --> 00:23:08,700
were a compression expert, which says I've said many times I am not,

455
00:23:09,600 --> 00:23:12,500
you probably have strong opinions about a lot of these things.

456
00:23:13,100 --> 00:23:14,700
And, and to the nth degree, right?

457
00:23:14,700 --> 00:23:17,300
Like much more complicated sorts of stuff than what we're talking

458
00:23:17,300 --> 00:23:17,800
about here.

459
00:23:17,800 --> 00:23:21,800
But they all follow that same pattern of well, if I encode something

460
00:23:21,800 --> 00:23:23,000
this way, then I get some

461
00:23:23,100 --> 00:23:27,600
Benefit this way but I lose something here is that the trade-off

462
00:23:27,600 --> 00:23:30,800
that's appropriate for the type of data that I'm doing blah blah,

463
00:23:30,800 --> 00:23:31,300
right?

464
00:23:33,000 --> 00:23:34,700
So that's, you know, that's that.

465
00:23:35,500 --> 00:23:39,700
So let's go ahead and take a look at how to do the compressor now as

466
00:23:39,700 --> 00:23:40,900
opposed to the decompressor.

467
00:23:41,400 --> 00:23:45,700
So, here is our rle compressor, and we'll just going to grab that and

468
00:23:45,700 --> 00:23:49,400
start with it like we did with the decompressor because like I said,

469
00:23:49,400 --> 00:23:58,900
they're basically the same but more is compressor that way or that

470
00:23:58,900 --> 00:23:59,200
way.

471
00:23:59,400 --> 00:23:59,800
I don't even

472
00:24:00,200 --> 00:24:00,800
Doesn't matter.

473
00:24:00,800 --> 00:24:01,500
Anyway point being.

474
00:24:01,500 --> 00:24:03,700
So if we have Elsie compressed, we're going to do basically.

475
00:24:03,700 --> 00:24:08,200
The same thing we were doing before, let's start by just making

476
00:24:08,200 --> 00:24:13,100
something which doesn't actually ever encode any real dictionary.

477
00:24:13,100 --> 00:24:16,000
Look backs, we'll just do something that encodes.

478
00:24:19,200 --> 00:24:23,600
Are really essentially but inside LZ, just like I said, we could do

479
00:24:23,600 --> 00:24:27,700
where we're just using L, Z's ability to do rle inside it in order to

480
00:24:27,700 --> 00:24:28,200
compress.

481
00:24:30,600 --> 00:24:31,200
Right.

482
00:24:32,900 --> 00:24:35,700
Alright, so here's our LZ, compressor.

483
00:24:39,200 --> 00:24:40,700
If you look, I have something stuck in my teeth.

484
00:24:42,800 --> 00:24:44,000
I know that has nothing to do with.

485
00:24:44,100 --> 00:24:45,700
I don't, nobody cares about that, besides me.

486
00:24:46,400 --> 00:24:48,300
I just feel like I do anyway.

487
00:24:50,600 --> 00:24:54,500
So if we take a look at the LZ compressor, starting from a gnarly

488
00:24:54,500 --> 00:24:57,200
compressor, you can kind of see that we would have to make a little

489
00:24:57,200 --> 00:24:59,300
bit of changes here because we're giving our LZ compressor of the

490
00:24:59,300 --> 00:25:02,700
ability to decide which one of the two things it was doing.

491
00:25:02,700 --> 00:25:07,600
And if you recall inside our, our LED compressor, the reason that we

492
00:25:07,600 --> 00:25:11,300
didn't really do it that way is because we didn't super have

493
00:25:12,600 --> 00:25:16,300
Any way to encode that, right?

494
00:25:16,600 --> 00:25:20,400
We could have there wasn't anything sort of for free in one of our

495
00:25:20,400 --> 00:25:22,000
things that we might have wanted to use.

496
00:25:22,600 --> 00:25:24,400
All of these values are sort of maximal use.

497
00:25:24,400 --> 00:25:27,900
Now we could have just used a value that was reserved in here.

498
00:25:28,700 --> 00:25:32,800
Where we basically said like, okay, if we do a rep count of zero,

499
00:25:33,000 --> 00:25:33,600
right?

500
00:25:34,000 --> 00:25:36,800
Then that means it's literals coming after it.

501
00:25:36,800 --> 00:25:41,000
And so the rep value would actually be how many there are, whereas if

502
00:25:41,000 --> 00:25:42,400
there's a rep count of

503
00:25:42,500 --> 00:25:46,900
You know, a different number, let's say then we know that it's a copy

504
00:25:46,900 --> 00:25:51,900
so we could have done that as well in the early sort of but it's not

505
00:25:51,900 --> 00:25:54,700
as obvious as in this one where it's like oh hey there's going to be a

506
00:25:54,700 --> 00:25:56,000
thing that's got to be 0.

507
00:25:56,300 --> 00:25:57,900
That that has a big old zero hole in it.

508
00:25:57,900 --> 00:26:01,000
You're going to have to adjust for it, one way or the other there.

509
00:26:03,700 --> 00:26:05,900
But anyway, so yeah, so it's unclear.

510
00:26:05,900 --> 00:26:08,600
I'm not really sure maybe that was a stupid thing to do, but I don't

511
00:26:08,600 --> 00:26:09,300
know, we'll see.

512
00:26:10,700 --> 00:26:11,500
So here's our LZ.

513
00:26:11,500 --> 00:26:14,200
Compressor, we come through here and we're starting to ingest the

514
00:26:14,200 --> 00:26:15,100
data, right?

515
00:26:15,200 --> 00:26:17,500
And we're going to use a literal buffer just like we did before which

516
00:26:17,500 --> 00:26:20,000
is just whenever we see something that we don't think we want to

517
00:26:20,000 --> 00:26:22,800
encode, we're going to shove it in there and then we know that

518
00:26:22,800 --> 00:26:26,400
eventually have to kind of flush that buffer as the case may be.

519
00:26:27,300 --> 00:26:31,200
So what we have here is our is our run length, encoding a right.

520
00:26:31,200 --> 00:26:31,500
It's

521
00:26:31,700 --> 00:26:33,900
Art, which is basically looking to see whether we've got a run of

522
00:26:33,900 --> 00:26:34,500
something.

523
00:26:35,700 --> 00:26:38,300
And so let's use exactly the same logic, right?

524
00:26:38,300 --> 00:26:42,300
Like I said before, let's just encode runs with rlz encoder, so what

525
00:26:42,300 --> 00:26:46,400
we'll do is say okay, if there is a run to encode, then will basically

526
00:26:46,400 --> 00:26:51,300
say like, you know, flush at this point.

527
00:26:52,500 --> 00:26:53,600
Otherwise, we buffer.

528
00:26:53,600 --> 00:26:57,500
So, the first thing we have to do is, see, are there any literals to

529
00:26:57,500 --> 00:26:57,900
flush?

530
00:26:57,900 --> 00:26:58,800
Right?

531
00:26:58,800 --> 00:26:59,900
So we take our little

532
00:27:00,000 --> 00:27:00,900
We'll count eight.

533
00:27:01,200 --> 00:27:03,400
And we say, are there any literals in the buffer?

534
00:27:03,400 --> 00:27:06,200
Because remember, unlike the are released game, we've given ourselves

535
00:27:06,200 --> 00:27:09,700
a way where if we don't have any literals to encode yet, we don't have

536
00:27:09,700 --> 00:27:10,900
to write.

537
00:27:10,900 --> 00:27:11,900
So that's kind of nice.

538
00:27:12,800 --> 00:27:15,200
So we say, Okay, are there any literals to encode?

539
00:27:15,300 --> 00:27:18,600
If there are flushed a little buffer right out it goes,

540
00:27:21,000 --> 00:27:23,200
And so the question is now well, how do we encode that?

541
00:27:23,300 --> 00:27:25,700
We'll remember, we can look at our decoder for that information.

542
00:27:26,000 --> 00:27:27,800
We do account and a copy distance.

543
00:27:27,800 --> 00:27:31,300
The rule is if the copy distance is 0, then it will copy from the

544
00:27:31,300 --> 00:27:31,800
input.

545
00:27:31,900 --> 00:27:34,600
So all we have to do here is say, alright, we're going to Output 2

546
00:27:34,600 --> 00:27:37,700
things, the literal count, which is the count that we actually wanted,

547
00:27:38,000 --> 00:27:39,400
and then a 0 and that tells it.

548
00:27:39,400 --> 00:27:42,500
Okay, we're going to literals are coming next and here they come.

549
00:27:42,700 --> 00:27:47,300
Right, there's our little count reset so there we're good to go and

550
00:27:47,300 --> 00:27:48,100
then we come through here.

551
00:27:48,100 --> 00:27:49,200
Now we've got our run.

552
00:27:49,200 --> 00:27:50,300
We want to Output.

553
00:27:50,400 --> 00:27:51,200
Our run.

554
00:27:52,100 --> 00:27:56,500
And the way that we want to Output the run is we want to say like, hey

555
00:27:56,500 --> 00:27:59,400
output, a copy of the thing that came before us in the buffer.

556
00:27:59,400 --> 00:28:04,500
Now, it's a little bit complicated here because effectively we are we

557
00:28:04,500 --> 00:28:06,000
have to sort of put

558
00:28:08,400 --> 00:28:08,900
How should I phrase?

559
00:28:08,900 --> 00:28:10,100
This we have to

560
00:28:11,600 --> 00:28:12,900
have outputted.

561
00:28:12,900 --> 00:28:17,300
The thing that we are going to be run running with if that makes any

562
00:28:17,300 --> 00:28:20,000
sense before we can replicate it.

563
00:28:20,500 --> 00:28:24,000
So technically we're going to have to modify this routine to be

564
00:28:24,000 --> 00:28:26,800
looking for matches that start with the previous symbol but we can do

565
00:28:26,800 --> 00:28:27,500
that in a second.

566
00:28:27,500 --> 00:28:29,000
It's not too difficult, right?

567
00:28:30,600 --> 00:28:33,600
But anyway, so let's assume that we're talking about a run that starts

568
00:28:33,600 --> 00:28:34,600
with the previous symbol.

569
00:28:35,100 --> 00:28:39,000
In that case, we just have to Output exactly the same thing here.

570
00:28:39,000 --> 00:28:39,500
Right?

571
00:28:40,100 --> 00:28:41,300
That we were doing before.

572
00:28:41,600 --> 00:28:45,800
But now instead of outputting a zero, we're going to Output that run

573
00:28:46,800 --> 00:28:48,500
the Run length, right?

574
00:28:48,600 --> 00:28:52,000
Or I should say the the look-back length and the look-back length is

575
00:28:52,000 --> 00:28:53,400
going to be one, right?

576
00:28:53,700 --> 00:28:56,100
So instead of outputting a starting value, we're just going to Output

577
00:28:56,100 --> 00:28:59,000
a 1 here which is, say, look back at the previous symbol and replicate

578
00:28:59,000 --> 00:28:59,600
that.

579
00:28:59,800 --> 00:29:03,200
For whatever the Run size is, okay.

580
00:29:04,100 --> 00:29:06,600
So in this case, what we're going to do is say, all right, there's a

581
00:29:06,600 --> 00:29:14,000
starting value here and that starting value is going to be something

582
00:29:14,000 --> 00:29:16,200
from the, you know, from the previous, right?

583
00:29:16,200 --> 00:29:20,700
So, the starting value is going to be something from the previous

584
00:29:20,700 --> 00:29:25,000
character and we want the run to start at zero now, right?

585
00:29:25,200 --> 00:29:28,300
Because we're going to look at the initial character and say, okay, is

586
00:29:28,300 --> 00:29:28,900
that

587
00:29:29,800 --> 00:29:31,600
Run from the previous character.

588
00:29:32,200 --> 00:29:34,700
So when we look at the starting value, this is actually going to be

589
00:29:34,700 --> 00:29:35,600
the previous.

590
00:29:35,900 --> 00:29:36,500
Now, we can't.

591
00:29:36,500 --> 00:29:40,300
Look at the previous if we're on the very first one, right?

592
00:29:41,000 --> 00:29:45,800
So we have to do a thing where we're going to be a little bit more.

593
00:29:45,800 --> 00:29:49,100
Careful about when we actually start doing this thing, right?

594
00:29:49,800 --> 00:29:52,500
So if we start off with the run at zero,

595
00:29:54,000 --> 00:29:59,100
we need to now check is in greater than the starting in, right?

596
00:29:59,700 --> 00:29:59,800
And

597
00:30:00,000 --> 00:30:02,000
We just need to make sure.

598
00:30:07,600 --> 00:30:10,500
That we've gotten somewhere first, right?

599
00:30:11,900 --> 00:30:12,900
And that's about it.

600
00:30:12,900 --> 00:30:17,500
So when we actually have to go so this for buffering literals here, I

601
00:30:17,500 --> 00:30:19,400
think this this is probably just

602
00:30:21,300 --> 00:30:22,100
Better written like that.

603
00:30:22,100 --> 00:30:26,600
Anyway, so I think that's really all we need to do.

604
00:30:26,900 --> 00:30:30,700
And so now we should be able to run this and we'll have to cast up

605
00:30:30,700 --> 00:30:32,800
through it because these things are kind of delicate obviously.

606
00:30:32,800 --> 00:30:36,500
So, you know, I can't promise that I doubted, my eyes and cross my T's

607
00:30:36,500 --> 00:30:41,200
there, but now we've sort of got the ability to run this guy as just a

608
00:30:41,200 --> 00:30:43,700
gnarly compressor, which is again, not going to be very good.

609
00:30:43,700 --> 00:30:45,700
In fact, it's probably going to be worse than our other one because

610
00:30:45,700 --> 00:30:47,800
it's basically got a bunch of stuff.

611
00:30:47,800 --> 00:30:50,200
It's baked in there for it to do that.

612
00:30:50,200 --> 00:30:50,900
It doesn't need to do.

613
00:30:51,900 --> 00:30:52,900
It's not using rather.

614
00:30:54,400 --> 00:30:55,500
But we'll get to that eventually.

615
00:30:56,000 --> 00:30:57,500
All right, so let me load up.

616
00:30:57,800 --> 00:30:58,600
I'm gonna step up here.

617
00:31:01,300 --> 00:31:02,000
and,

618
00:31:04,500 --> 00:31:07,800
Let's step into the okay.

619
00:31:09,800 --> 00:31:10,400
Forgot.

620
00:31:10,400 --> 00:31:12,800
We need to call it.

621
00:31:15,100 --> 00:31:15,600
There we go.

622
00:31:17,300 --> 00:31:19,600
And so let's go ahead and jump in now.

623
00:31:20,400 --> 00:31:22,000
And why are we?

624
00:31:22,000 --> 00:31:23,100
Oh, we're on the decompressor.

625
00:31:23,100 --> 00:31:23,900
That's not good.

626
00:31:24,200 --> 00:31:26,200
I don't want to be on the decompressor at all.

627
00:31:27,000 --> 00:31:27,500
You know, what else?

628
00:31:27,500 --> 00:31:29,500
We should probably do actually know, I think about it.

629
00:31:32,300 --> 00:31:34,100
It might be nice.

630
00:31:36,700 --> 00:31:37,800
To just have a test.

631
00:31:43,200 --> 00:31:47,200
If we're going to do test, I was thinking like, oh okay, what if we

632
00:31:47,200 --> 00:31:49,100
just do something where we go?

633
00:31:49,100 --> 00:31:54,700
Like okay, you call test and it goes, give me the data.

634
00:31:55,100 --> 00:31:58,200
Let's make an output buffer and a test buffer.

635
00:31:58,300 --> 00:32:01,100
The test buffer will just be a buffer.

636
00:32:01,200 --> 00:32:03,300
The same size as whatever the input is.

637
00:32:09,100 --> 00:32:11,500
We'll go ahead and say, OK, compress the thing.

638
00:32:12,200 --> 00:32:15,000
So here's the compression, right?

639
00:32:15,600 --> 00:32:17,100
And then decompress the thing.

640
00:32:29,500 --> 00:32:33,800
And that'll run the compressor, then the decompressor, and then we

641
00:32:33,800 --> 00:32:36,700
could even do a mem comp, which I don't think we've ever done, because

642
00:32:36,700 --> 00:32:39,600
we don't normally program using the standard library on handmade here,

643
00:32:39,600 --> 00:32:39,900
right?

644
00:32:39,900 --> 00:32:44,600
We almost always just write everything ourselves, but you can kind of

645
00:32:44,600 --> 00:32:45,000
see here.

646
00:32:45,000 --> 00:32:50,500
We've got the ability to use the C standard Library, a mem Compass.

647
00:32:50,500 --> 00:32:55,100
Just a thing that says, hey, compare two pieces of memory and return

648
00:32:55,100 --> 00:32:56,700
to me a difference between them.

649
00:32:56,700 --> 00:32:59,000
So if there's no difference between them, it'll just return.

650
00:32:59,400 --> 00:32:59,900
So, if there is

651
00:33:00,000 --> 00:33:01,800
Return nonzero, right?

652
00:33:03,000 --> 00:33:05,000
So, what we want to do is say like

653
00:33:08,100 --> 00:33:09,200
If mem comp.

654
00:33:10,600 --> 00:33:15,200
And we want to pass that file size there.

655
00:33:15,200 --> 00:33:20,900
We just want to say hey if our input buffer and our output buffer

656
00:33:21,100 --> 00:33:24,900
match, then we would just say like okay

657
00:33:32,100 --> 00:33:33,300
maybe just a success.

658
00:33:38,000 --> 00:33:39,600
Otherwise, we just say failure.

659
00:33:42,000 --> 00:33:48,100
Right, and so now we can just have a single way to run it when we're

660
00:33:48,100 --> 00:33:52,200
doing development that would just you know, allow us to figure out

661
00:33:52,900 --> 00:33:53,800
what's going on there.

662
00:33:54,200 --> 00:33:59,200
And so in this case, we've got test-1 dot h a and we can just do test

663
00:33:59,200 --> 00:34:02,300
one to speak but the the second parameter would actually just be

664
00:34:02,300 --> 00:34:04,400
ignored, I guess in this case, because we're not going to actually

665
00:34:04,400 --> 00:34:05,300
write it out now.

666
00:34:05,300 --> 00:34:09,100
I suppose we could actually write it out so that we can run the test

667
00:34:09,100 --> 00:34:11,699
and have the output saved which does

668
00:34:11,900 --> 00:34:12,800
In potentially useful.

669
00:34:12,800 --> 00:34:16,900
But man, I'm not gonna bother so really, I suppose, that that's

670
00:34:16,900 --> 00:34:20,400
something better done in an ARG count equals three scenario.

671
00:34:20,400 --> 00:34:22,500
But whatever, don't really care at this point.

672
00:34:22,600 --> 00:34:27,900
All right, so let's go ahead and run this so I can actually get to my

673
00:34:27,900 --> 00:34:29,600
compressor now, which is what I wanted.

674
00:34:30,699 --> 00:34:31,400
So, here we go.

675
00:34:31,400 --> 00:34:34,300
So the first time through the loop, we can't actually have a run

676
00:34:34,500 --> 00:34:37,800
because again, we can't look backwards to see if we've encoded

677
00:34:37,800 --> 00:34:39,400
something that we want to replicate.

678
00:34:39,900 --> 00:34:41,699
So we're going to skip these the first

679
00:34:41,800 --> 00:34:42,199
Time through.

680
00:34:42,199 --> 00:34:43,500
And we're just going to buffer a literal.

681
00:34:43,500 --> 00:34:44,199
And there it is.

682
00:34:44,199 --> 00:34:44,699
Right?

683
00:34:45,300 --> 00:34:47,600
The next time 3, we're going to look to see whether or not.

684
00:34:47,600 --> 00:34:49,199
We have a run from the previous.

685
00:34:49,900 --> 00:34:53,300
And in this case we do because the H is duplicated, right?

686
00:34:53,400 --> 00:34:57,800
So, now, the Run of course, would have kicked in, but it's not long

687
00:34:57,800 --> 00:34:59,000
enough, right?

688
00:35:00,000 --> 00:35:03,800
Because it was only one replication from from what we had output in

689
00:35:03,800 --> 00:35:06,300
the literal, which isn't good enough, right?

690
00:35:07,200 --> 00:35:10,300
Notice again, that's a difference from the rle because like I said the

691
00:35:10,300 --> 00:35:14,600
LZ can only are at least something it's already output, right?

692
00:35:14,600 --> 00:35:17,300
Which is, you know, not not as good, right?

693
00:35:19,200 --> 00:35:20,900
So anyway, so off we go.

694
00:35:20,900 --> 00:35:23,900
And then we're just looking here, we found a much longer run, a much

695
00:35:23,900 --> 00:35:27,500
longer run of 3 and so now we're going to actually encode, one of

696
00:35:27,500 --> 00:35:31,800
these runs here is our output are literal count, right as getting out,

697
00:35:31,800 --> 00:35:34,700
put it down to zero and then we're out putting literals because we do

698
00:35:34,700 --> 00:35:36,900
need to flush the literal buffer right now.

699
00:35:37,000 --> 00:35:40,200
Little buffer is now flushed and now we're going to say, okay.

700
00:35:40,200 --> 00:35:45,700
Now we're going to run that last Saucy fellow for three times.

701
00:35:46,100 --> 00:35:46,900
So here we go.

702
00:35:47,100 --> 00:35:50,800
And then we're going to go forward by that amount, right?

703
00:35:52,500 --> 00:35:54,000
So, I think we're good now.

704
00:35:54,000 --> 00:35:56,600
I think that will do our encoding for us.

705
00:35:57,800 --> 00:35:59,800
Don't quote me on that, but here we are.

706
00:36:00,000 --> 00:36:03,500
Decompressor having have after having done that and let's see what we

707
00:36:03,500 --> 00:36:03,700
get.

708
00:36:03,700 --> 00:36:04,800
So we read in count.

709
00:36:04,800 --> 00:36:08,200
First, in the count is five and the copy distance should be 0, because

710
00:36:08,200 --> 00:36:09,100
this is a literal.

711
00:36:09,600 --> 00:36:11,500
So, let's take a look at what we're going to copy.

712
00:36:11,500 --> 00:36:13,400
Here's the thing that we're going to copy.

713
00:36:16,100 --> 00:36:16,400
Rich.

714
00:36:16,400 --> 00:36:17,000
Is there?

715
00:36:17,000 --> 00:36:19,100
It is HAF.

716
00:36:19,100 --> 00:36:21,500
And then some noise, which is exactly what we want.

717
00:36:21,600 --> 00:36:24,800
So we output that literal right there.

718
00:36:24,800 --> 00:36:25,300
It is.

719
00:36:26,700 --> 00:36:28,200
Now we come back through and we learn.

720
00:36:28,400 --> 00:36:31,200
Okay, we're into account three and we're going to do a replication

721
00:36:31,200 --> 00:36:33,600
from just the previous thing, whatever, that was.

722
00:36:34,100 --> 00:36:35,900
So there's our source, right?

723
00:36:35,900 --> 00:36:38,000
And it's going to copy a zero a couple times.

724
00:36:38,400 --> 00:36:42,800
So there it is copying a zero a couple times and off we go, right?

725
00:36:42,800 --> 00:36:43,800
And it just keeps going.

726
00:36:44,700 --> 00:36:45,700
Now it turns out that

727
00:36:45,900 --> 00:36:48,100
unless I wrote the comparison wrong here,

728
00:36:50,000 --> 00:36:51,900
We should be able to determine whether we succeeded.

729
00:36:51,900 --> 00:36:52,800
It looks like we did.

730
00:36:53,000 --> 00:36:54,400
So hey we wrote Our compressor, right?

731
00:36:54,400 --> 00:36:58,900
The first time right the first time, so that's great.

732
00:37:01,200 --> 00:37:05,800
And let's see, just for our own Amusement here.

733
00:37:06,300 --> 00:37:09,800
Let's go ahead and see what, how well we did.

734
00:37:09,800 --> 00:37:10,300
Right.

735
00:37:10,400 --> 00:37:11,400
There's our test one.

736
00:37:11,500 --> 00:37:12,400
Aha.

737
00:37:12,700 --> 00:37:13,700
We'll start with that one.

738
00:37:14,000 --> 00:37:20,200
So if I want to do simple, compressor, compress test, 1hh, a test

739
00:37:20,200 --> 00:37:24,000
one.you know, simple LZ or something like this.

740
00:37:24,000 --> 00:37:26,200
Or I guess we'll say run length rlz.

741
00:37:27,500 --> 00:37:28,500
Run on the LZ.

742
00:37:29,900 --> 00:37:30,600
Let's see how that.

743
00:37:33,100 --> 00:37:37,300
So you can see that actually amusingly enough, we're still smaller

744
00:37:37,300 --> 00:37:40,600
even though we haven't actually implemented the LZ yet because the

745
00:37:40,600 --> 00:37:44,400
test one, SCP the rle one that we were doing before.

746
00:37:46,000 --> 00:37:46,800
In fact I could

747
00:37:51,600 --> 00:37:54,900
Probably the fact that it had to do alternating pairs of literals and

748
00:37:54,900 --> 00:37:59,000
runs was probably causing it to be not as good as it could have been,

749
00:37:59,000 --> 00:37:59,400
right?

750
00:38:01,300 --> 00:38:05,000
Because now that we've gone to the LZ, we haven't actually implemented

751
00:38:05,000 --> 00:38:05,500
LZ yet.

752
00:38:05,500 --> 00:38:06,300
We're already smaller.

753
00:38:06,300 --> 00:38:09,100
It's probably because it doesn't, it can take advantage of that,

754
00:38:09,100 --> 00:38:09,600
right?

755
00:38:11,000 --> 00:38:13,800
Furthermore, I can go ahead and say, like, okay, intro arced at SCP

756
00:38:13,800 --> 00:38:20,300
here is intro, art rle, and then I can do simple compressor, compress,

757
00:38:20,600 --> 00:38:27,800
intro art, that ha intro art rlz and that'll do the compression on.

758
00:38:29,800 --> 00:38:33,800
That big huge file and then we can see how well that one does.

759
00:38:33,800 --> 00:38:38,600
And again this one is is not really doing LZ at all.

760
00:38:38,600 --> 00:38:41,100
You can see this one doesn't do better, right?

761
00:38:41,100 --> 00:38:45,000
In this case, the rle by itself is actually an improvement, I guess

762
00:38:45,000 --> 00:38:48,500
because again, presumably that alternation happens to fit the pattern.

763
00:38:48,500 --> 00:38:48,800
Okay.

764
00:38:48,800 --> 00:38:51,000
So it doesn't lose anything and it doesn't have to encode that zero

765
00:38:51,000 --> 00:38:51,500
every time.

766
00:38:51,500 --> 00:38:52,400
So you know, who knows?

767
00:38:52,700 --> 00:38:53,800
But that's just conjecture.

768
00:38:53,800 --> 00:38:55,300
We haven't actually looked at it yet, right?

769
00:38:55,300 --> 00:38:58,700
So we don't really know but that's just interesting to take a baseline

770
00:38:58,700 --> 00:38:59,200
of right?

771
00:39:01,300 --> 00:39:04,700
alright, so now let's actually try to implement actual Elsie

772
00:39:04,700 --> 00:39:07,600
compression because like I said, this is not LZ compression what this

773
00:39:07,600 --> 00:39:08,500
is, is

774
00:39:10,800 --> 00:39:16,600
Is strictly us using an LZ backend to implement rle, which is not what

775
00:39:16,600 --> 00:39:17,300
we wanted to do.

776
00:39:17,300 --> 00:39:20,100
I just wanted to sort of demonstrate that that worked.

777
00:39:21,600 --> 00:39:22,900
What I want to do now is extend it.

778
00:39:22,900 --> 00:39:27,400
So that not only can it do runs like that, but it can also actually do

779
00:39:27,500 --> 00:39:29,800
look backs at which is what it's supposed to do.

780
00:39:29,800 --> 00:39:30,000
Right?

781
00:39:30,000 --> 00:39:34,200
The whole point of dictionary compressor is to use a whole bunch of

782
00:39:34,200 --> 00:39:35,600
stuff in the output stream.

783
00:39:36,500 --> 00:39:40,600
From anywhere, not just the most recently output thing, which is what

784
00:39:41,000 --> 00:39:42,000
the only thing we're doing now.

785
00:39:42,700 --> 00:39:47,600
So in order to do this, I need some way of looking back over the

786
00:39:47,600 --> 00:39:51,200
stream to see where in the Stream, we would get the longest match

787
00:39:51,200 --> 00:39:51,600
from.

788
00:39:52,000 --> 00:39:54,700
Now, the first thing I'm going to do is Implement something which is

789
00:39:54,700 --> 00:39:59,200
incredibly, unbearably slow probably and we would not be able to run.

790
00:40:00,100 --> 00:40:01,300
Well actually you know what?

791
00:40:02,300 --> 00:40:03,100
I take that back.

792
00:40:03,900 --> 00:40:06,400
The first thing I'm going to implement is a very slow, way of doing

793
00:40:06,400 --> 00:40:10,800
it, but because we're only talking about B here and the look back.

794
00:40:10,800 --> 00:40:15,500
Buffer is only 255 bytes back.

795
00:40:16,200 --> 00:40:19,100
This probably won't be prohibited slow, because computers are so fast

796
00:40:19,100 --> 00:40:19,600
nowadays.

797
00:40:19,600 --> 00:40:22,200
They can scan up to 55 window, really easily.

798
00:40:23,300 --> 00:40:28,200
So, you know, take this with a grain of salt because 285 285 is only

799
00:40:28,200 --> 00:40:30,100
65536, that's extreme r6i.

800
00:40:30,100 --> 00:40:30,900
534.

801
00:40:31,300 --> 00:40:32,000
That's a

802
00:40:32,100 --> 00:40:35,400
Small number of iterations for something to do on a modern computer.

803
00:40:35,900 --> 00:40:41,400
So surprisingly this will probably actually run just fine, but if we

804
00:40:41,400 --> 00:40:45,500
were to upgrade that look back window to more like 16 bits, which is a

805
00:40:45,500 --> 00:40:48,800
more common size to use and there's a number of reasons we can talk

806
00:40:48,800 --> 00:40:49,800
about at the end of the stream.

807
00:40:49,800 --> 00:40:53,700
If someone wants to remind me about why it's why 255 is not a

808
00:40:53,700 --> 00:40:54,300
particularly good?

809
00:40:54,300 --> 00:40:57,200
Look, back number for graphics compression.

810
00:40:57,800 --> 00:41:01,700
I can talk about that because it really isn't, but we'll just we'll

811
00:41:01,700 --> 00:41:01,900
go.

812
00:41:02,000 --> 00:41:03,700
Ahead with this for now and you can see.

813
00:41:03,700 --> 00:41:06,400
So, first, I'm going to implement the stupidest possible thing.

814
00:41:06,600 --> 00:41:09,300
So how would we look for a run where we could say?

815
00:41:09,300 --> 00:41:12,700
Let's look back over everything in the buffer that we could possibly

816
00:41:12,700 --> 00:41:15,800
access and just see what the longest match is, right?

817
00:41:16,500 --> 00:41:19,200
Well, if you think about what that would look like, we could just say

818
00:41:19,200 --> 00:41:19,400
well.

819
00:41:19,400 --> 00:41:25,200
Okay, let's say we just start as far back as we can and so we could

820
00:41:25,200 --> 00:41:27,200
say like all right, you know?

821
00:41:29,300 --> 00:41:30,900
You know, start of window or something.

822
00:41:31,600 --> 00:41:33,200
Well, that's wherever we are at.

823
00:41:33,200 --> 00:41:39,300
The moment - whatever our Max run count is going to be right.

824
00:41:39,500 --> 00:41:41,100
And I guess we shouldn't say Max, Renn.

825
00:41:41,100 --> 00:41:46,700
Can't we kind of need a new thing here which is like, you know, Max

826
00:41:47,200 --> 00:41:51,200
look back out and we'll just keep that in there.

827
00:41:57,200 --> 00:41:59,800
so we've got our Max look back and we're just going to say like okay

828
00:42:00,000 --> 00:42:03,400
Whatever the maximum value is that we could look backwards.

829
00:42:04,000 --> 00:42:05,100
Let's start with that.

830
00:42:05,200 --> 00:42:10,000
Now the start of the window here maybe behind the beginning of the

831
00:42:10,000 --> 00:42:10,500
buffer.

832
00:42:10,900 --> 00:42:13,500
So we also need to double-check, right?

833
00:42:13,500 --> 00:42:14,600
And we need to say that.

834
00:42:14,600 --> 00:42:20,000
Well if we haven't gone that far yet we can only go as far back as we

835
00:42:20,000 --> 00:42:21,300
have actual data.

836
00:42:21,600 --> 00:42:24,700
So really what we're talking about here is more like, okay

837
00:42:27,800 --> 00:42:28,200
Max.

838
00:42:28,200 --> 00:42:31,300
Look back equals, you know?

839
00:42:32,800 --> 00:42:36,000
Whatever the in pointer is - the in base, right?

840
00:42:36,000 --> 00:42:37,500
So that's how far we've gone.

841
00:42:37,800 --> 00:42:41,300
If the max look back is greater than this value.

842
00:42:42,500 --> 00:42:44,100
Then we use it, right?

843
00:42:44,100 --> 00:42:47,100
So, we're sort of like only using to the beginning of the buffer, but

844
00:42:47,100 --> 00:42:50,600
as we move forward, we may then start pulling that window with us as

845
00:42:50,600 --> 00:42:55,200
we get past the 255, 255, 255, B of the buffer.

846
00:42:56,800 --> 00:42:57,200
All right.

847
00:42:58,300 --> 00:43:03,600
So now we want to go ahead and I guess we'll do it like this.

848
00:43:03,800 --> 00:43:04,700
Here's our window.

849
00:43:05,100 --> 00:43:07,900
We know that wherever we are, we are going to go back.

850
00:43:07,900 --> 00:43:10,100
However, much that look back is right.

851
00:43:10,800 --> 00:43:16,100
And then we're going to step all the way up to, where we currently are

852
00:43:16,100 --> 00:43:16,800
in the Stream.

853
00:43:17,100 --> 00:43:19,500
Looking at each individual B, right?

854
00:43:21,400 --> 00:43:23,100
Maybe we'll call this the window base.

855
00:43:24,000 --> 00:43:24,300
Right.

856
00:43:24,300 --> 00:43:25,600
Or maybe Windows start.

857
00:43:31,300 --> 00:43:31,800
Right.

858
00:43:33,100 --> 00:43:36,100
And then what we need to do is we need to do something almost exactly

859
00:43:36,100 --> 00:43:37,900
equivalent to what we just did.

860
00:43:38,500 --> 00:43:43,500
Which is to say, when we encode the, the, when we are looking for a

861
00:43:43,500 --> 00:43:48,300
match, we can only go as far as the maximum run count that we could

862
00:43:48,300 --> 00:43:50,000
have encoded, right?

863
00:43:50,300 --> 00:43:53,800
Because as we're looking for matches, we can't look for any matches

864
00:43:53,800 --> 00:43:55,600
that are longer than we can encode.

865
00:43:55,700 --> 00:43:58,200
We can only encode matches 255 long.

866
00:43:58,200 --> 00:44:00,400
So even if there was like a thousand zeros,

867
00:44:01,200 --> 00:44:05,000
In a run of zeros or something like this, we couldn't, you know,

868
00:44:05,000 --> 00:44:07,600
encode more than that or, you know, any pattern or not doesn't have to

869
00:44:07,600 --> 00:44:09,700
be constant anymore because this is LZ, not rle.

870
00:44:09,700 --> 00:44:13,000
We could, you know, it could be any pattern, any replicated pattern

871
00:44:13,000 --> 00:44:14,600
can only be that long.

872
00:44:15,700 --> 00:44:17,300
So we need to do exactly the same thing.

873
00:44:17,500 --> 00:44:20,600
We need to say, well, the end of this thing, right?

874
00:44:21,300 --> 00:44:22,300
Is in end.

875
00:44:26,700 --> 00:44:27,200
Right?

876
00:44:27,500 --> 00:44:30,500
But we don't know that we can actually go there, right?

877
00:44:30,600 --> 00:44:36,400
So essentially, we have a window size and the window size is going to

878
00:44:36,400 --> 00:44:39,100
be, however, long we have till the end of the buffer.

879
00:44:39,300 --> 00:44:43,900
But if that is longer, which most of the time, it will be, if that is

880
00:44:43,900 --> 00:44:48,300
longer than the max run count, then we can only use the max run count,

881
00:44:48,300 --> 00:44:48,800
right?

882
00:44:48,900 --> 00:44:52,600
So the window end is going to be Loops.

883
00:44:52,600 --> 00:44:53,700
I mess that up its

884
00:44:55,700 --> 00:44:56,400
It's the window start.

885
00:44:56,400 --> 00:44:56,900
There we go.

886
00:44:57,300 --> 00:44:59,900
So from where we're looking to the end that's how big

887
00:45:00,000 --> 00:45:00,700
Window can be.

888
00:45:00,700 --> 00:45:05,400
And the window end is going to be wherever we started, plus whatever

889
00:45:05,400 --> 00:45:06,600
that that size is.

890
00:45:06,800 --> 00:45:10,000
So now we know where we're looking in this particular window.

891
00:45:11,100 --> 00:45:16,000
So now we just need to see how big of a run we can make with that

892
00:45:16,800 --> 00:45:18,500
matching from there, right?

893
00:45:18,700 --> 00:45:24,800
So what we want to look at is we want to look at the test in versus

894
00:45:25,200 --> 00:45:27,300
the window in, right?

895
00:45:29,500 --> 00:45:33,800
So the test in is where we're at right now, the window in is whatever

896
00:45:33,800 --> 00:45:36,800
the Windows start is, and then we're just going to go ahead and say,

897
00:45:37,700 --> 00:45:38,300
you know,

898
00:45:44,900 --> 00:45:46,000
While they're equal.

899
00:45:49,900 --> 00:45:50,500
Right.

900
00:45:51,000 --> 00:45:52,100
We're going to increment them.

901
00:45:55,300 --> 00:45:56,800
And in fact we could just do it this way.

902
00:46:03,100 --> 00:46:06,000
So we will count the run just like we were doing before.

903
00:46:08,300 --> 00:46:10,900
So we're going to look in the window and say, okay, how far can we go

904
00:46:10,900 --> 00:46:13,000
while there while we're moving off?

905
00:46:13,000 --> 00:46:13,500
We go.

906
00:46:13,700 --> 00:46:18,400
But we want to make sure that we never exceed the end of the window,

907
00:46:18,500 --> 00:46:19,000
right?

908
00:46:19,000 --> 00:46:20,700
So we want to say, okay.

909
00:46:22,100 --> 00:46:25,900
Cap the window in to the window end.

910
00:46:27,600 --> 00:46:28,100
Right?

911
00:46:28,200 --> 00:46:31,600
But as long as we're doing that test to see, if the two things are

912
00:46:31,600 --> 00:46:36,200
equal, the the input stream and the the window, you know, are they the

913
00:46:36,200 --> 00:46:36,600
same?

914
00:46:36,600 --> 00:46:40,300
And if they are in, keep the, you know, keep track of how many of

915
00:46:40,300 --> 00:46:41,200
those we could do.

916
00:46:41,900 --> 00:46:46,400
So after we pop out of this Loop we will now know the maximum match we

917
00:46:46,400 --> 00:46:48,000
could do at this location.

918
00:46:48,700 --> 00:46:50,500
So then we just have to do our standard thing.

919
00:46:50,500 --> 00:46:51,400
You've seen on him a hero.

920
00:46:51,400 --> 00:46:54,800
Many times is keep the best one of these whatever it is, right?

921
00:46:55,400 --> 00:46:57,200
So if our best run size,

922
00:46:57,600 --> 00:46:59,400
Is less than our test run size.

923
00:46:59,500 --> 00:47:03,000
Then what we want to do is our best run becomes our test run,

924
00:47:05,100 --> 00:47:10,000
And our best location, equals whatever our test location was, right.

925
00:47:11,500 --> 00:47:13,900
And I guess I'll be really need to know, is what the look-back was

926
00:47:13,900 --> 00:47:14,300
here.

927
00:47:14,600 --> 00:47:17,800
So actually it's just however, far back the window start is.

928
00:47:18,200 --> 00:47:20,300
So we just want to kind of know like, oh, okay.

929
00:47:21,900 --> 00:47:25,500
How far back do we go to get to the Windows start, right?

930
00:47:27,100 --> 00:47:28,900
So, I don't know what best distance, I guess.

931
00:47:28,900 --> 00:47:29,400
We'll call this.

932
00:47:31,200 --> 00:47:33,400
so then all we need to do is actually keep those

933
00:47:37,000 --> 00:47:37,600
Right.

934
00:47:37,600 --> 00:47:38,400
Best run.

935
00:47:40,800 --> 00:47:41,500
Just distance.

936
00:47:43,800 --> 00:47:46,500
And so then we come through here, we don't care about this anymore,

937
00:47:46,700 --> 00:47:46,900
right?

938
00:47:46,900 --> 00:47:50,200
This is not, we're not doing that anymore because or finding the run a

939
00:47:50,200 --> 00:47:50,800
different way.

940
00:47:51,300 --> 00:47:56,500
And then we coming here, we've got our best run and now we're going to

941
00:47:56,500 --> 00:47:58,900
do exactly the same thing we did before, right?

942
00:47:59,400 --> 00:47:59,800
Okay.

943
00:48:00,500 --> 00:48:03,300
So cleaning this up.

944
00:48:04,700 --> 00:48:06,900
We now know that out of this and we'll have to step through this and

945
00:48:06,900 --> 00:48:08,400
be careful and make sure we did everything right.

946
00:48:08,400 --> 00:48:12,000
But coming out of this is assuming that we have our best run and our

947
00:48:12,000 --> 00:48:12,700
best distance.

948
00:48:12,900 --> 00:48:16,100
We now that we can say okay when do we want to encode a run?

949
00:48:16,100 --> 00:48:19,700
Well we know that a run is going to cost us something, right?

950
00:48:20,800 --> 00:48:23,500
And it's going to be a little bit interesting to look at the cost are

951
00:48:23,500 --> 00:48:26,500
but so I'm just going to put a little to do here because we'll do it

952
00:48:26,500 --> 00:48:27,200
in a second.

953
00:48:28,100 --> 00:48:32,300
Think about when to Output but for right now we're just going to use

954
00:48:32,300 --> 00:48:34,300
the if the best run if there was any run at all.

955
00:48:34,700 --> 00:48:35,300
Right.

956
00:48:36,200 --> 00:48:38,700
So if the run is greater than 1 will use it, right?

957
00:48:40,900 --> 00:48:43,100
So let me come in and we need to do our flesh, we need to do our

958
00:48:43,100 --> 00:48:44,600
literal count flushing.

959
00:48:44,800 --> 00:48:47,600
Now, one thing that you'll notice that I forgot to do, when we kind of

960
00:48:48,000 --> 00:48:53,300
added this in just moments ago, is really if the literal count was the

961
00:48:53,300 --> 00:48:53,900
thing.

962
00:48:53,900 --> 00:48:57,700
If the max little count was hit, then we don't actually need to encode

963
00:48:57,700 --> 00:48:58,900
the run, right?

964
00:48:58,900 --> 00:49:03,200
Because if there was no run to encode, you know, if if the best run

965
00:49:04,000 --> 00:49:09,600
was not sort of something we need to encode then we don't actually

966
00:49:09,600 --> 00:49:10,300
need to

967
00:49:10,800 --> 00:49:12,300
Do any of this, right?

968
00:49:13,500 --> 00:49:14,200
If that makes sense.

969
00:49:15,200 --> 00:49:17,700
So if the only reason that we went through here is because we needed

970
00:49:17,700 --> 00:49:20,800
to flush the literal buffer, right?

971
00:49:21,400 --> 00:49:23,700
Then that was all we need to do, right?

972
00:49:23,700 --> 00:49:24,400
That's all we need to do.

973
00:49:24,400 --> 00:49:27,800
And then we just want to restart queuing literals up at the beginning

974
00:49:27,800 --> 00:49:28,900
again, right?

975
00:49:29,900 --> 00:49:33,000
So, I believe really what we want to do is sort of have something more

976
00:49:33,000 --> 00:49:34,900
like this output run.

977
00:49:40,000 --> 00:49:42,600
And I guess we don't probably have a pool here.

978
00:49:42,600 --> 00:49:43,100
There we go.

979
00:49:48,700 --> 00:49:49,500
and then, in this case,

980
00:49:51,700 --> 00:49:52,900
we're now using best run.

981
00:49:54,700 --> 00:49:55,300
And off we go.

982
00:49:57,500 --> 00:50:00,600
Okay, so I guess this is probably a size T here.

983
00:50:08,000 --> 00:50:09,400
That's supposed to be window size.

984
00:50:09,900 --> 00:50:10,300
Okay?

985
00:50:11,200 --> 00:50:13,600
And now what we need to do is just say, all right, now, remember,

986
00:50:13,800 --> 00:50:18,400
we're no longer trying to encode just copies and so we've got this

987
00:50:18,400 --> 00:50:21,400
distance value that we actually need to use as well.

988
00:50:21,800 --> 00:50:25,200
And so, now right here, we need to actually do our distance.

989
00:50:25,200 --> 00:50:27,500
Ay equals U, 8, best distance.

990
00:50:27,700 --> 00:50:32,000
And we want to assert that that distance 8 equals our best distance,

991
00:50:32,300 --> 00:50:34,400
so that we know that we didn't accidentally overflow.

992
00:50:34,700 --> 00:50:36,800
And then we just output that distance.

993
00:50:37,000 --> 00:50:37,400
Right.

994
00:50:38,500 --> 00:50:39,200
And that's it.

995
00:50:39,400 --> 00:50:43,400
So now we've effectively got something that will actually look back

996
00:50:43,400 --> 00:50:44,400
over the entire window.

997
00:50:44,400 --> 00:50:45,500
Find the longest run.

998
00:50:45,500 --> 00:50:47,600
It could possibly output and output that run.

999
00:50:48,900 --> 00:50:49,400
Right.

1000
00:50:50,200 --> 00:50:55,700
And now that's of course, assuming that we didn't mess it up, which we

1001
00:50:55,700 --> 00:50:56,600
may well have,

1002
00:50:58,200 --> 00:50:59,600
now, according to our

1003
00:51:00,000 --> 00:51:00,600
We passed.

1004
00:51:00,600 --> 00:51:03,600
So I guess we wrote the compressor at least in a way that doesn't

1005
00:51:03,600 --> 00:51:07,500
crash but we have no idea if we actually are compressing particularly

1006
00:51:07,500 --> 00:51:09,500
well or anything like that, but we can certainly try it now.

1007
00:51:09,500 --> 00:51:13,900
So, let's take a look at again doing our simple decompressor.

1008
00:51:14,300 --> 00:51:14,600
I'm sorry.

1009
00:51:14,600 --> 00:51:15,500
Simple compressor.

1010
00:51:17,500 --> 00:51:18,900
To do an actual rlz.

1011
00:51:18,900 --> 00:51:21,600
Here's our simple LZ and now it's going to do.

1012
00:51:21,600 --> 00:51:23,000
It's compression here it is.

1013
00:51:23,800 --> 00:51:26,200
And so taking a look at the simple as Z we have not done a

1014
00:51:26,200 --> 00:51:27,000
particularly good job.

1015
00:51:27,000 --> 00:51:31,500
It looks like actually so that look that's that's actually bigger than

1016
00:51:32,000 --> 00:51:33,500
than our are strictly.

1017
00:51:33,500 --> 00:51:37,400
Our run length one which perhaps is not surprising.

1018
00:51:37,400 --> 00:51:40,500
Now why is it not surprising again, we could have a bug in here.

1019
00:51:40,500 --> 00:51:41,600
So we're going to have to step through.

1020
00:51:42,200 --> 00:51:45,000
But at least, I'm going to finish this part before we actually step

1021
00:51:45,000 --> 00:51:46,300
through and see if we're working properly.

1022
00:51:47,000 --> 00:51:50,800
specifically, if you think about what this is doing, now that we're

1023
00:51:50,800 --> 00:51:52,200
looking back over the window,

1024
00:51:54,200 --> 00:51:57,000
it's highly likely that we will often find pairs of bytes.

1025
00:51:57,000 --> 00:52:00,300
We can replicate and the only thing that we're checking for here is

1026
00:52:00,300 --> 00:52:01,800
whether or not there's a pair, right?

1027
00:52:01,800 --> 00:52:04,500
It only has to be to before it will do this.

1028
00:52:04,700 --> 00:52:07,400
But what that would mean is, if it was going to have to do an output

1029
00:52:07,400 --> 00:52:12,800
of 2, it will have to write to B to flush the literal buffer, then any

1030
00:52:12,800 --> 00:52:15,800
literals that it has, which of course, we don't kind of gets to B

1031
00:52:15,800 --> 00:52:18,400
there then, another two bytes here to do the run.

1032
00:52:18,500 --> 00:52:22,700
So it's actually expanding every 2, B, run into four bytes for no

1033
00:52:22,700 --> 00:52:23,600
reason, right?

1034
00:52:24,300 --> 00:52:27,700
So given that you me.

1035
00:52:29,000 --> 00:52:32,900
What we want to do is something more like this, right?

1036
00:52:32,900 --> 00:52:36,300
What we want to do is say, all right, first of all, are there any

1037
00:52:36,300 --> 00:52:38,800
literals in the literal buffer, right?

1038
00:52:38,800 --> 00:52:41,700
Because if there are literals in the literal buffer, it means that the

1039
00:52:41,800 --> 00:52:45,400
in order to Output a run, we're already going to have to flush the

1040
00:52:45,400 --> 00:52:48,800
literal buffer which costs us to B, right?

1041
00:52:48,800 --> 00:52:52,200
We're going to have to Output this and this and then the literals, so

1042
00:52:52,200 --> 00:52:56,200
if we're already doing that, we had better, make sure that just adding

1043
00:52:56,200 --> 00:52:58,600
the literals that we have on to the end of the litter.

1044
00:52:58,800 --> 00:53:01,400
Buffer isn't a more efficient approach, right?

1045
00:53:03,200 --> 00:53:07,000
So in this case, what we want to do is say all right, the wrong that

1046
00:53:07,000 --> 00:53:08,300
you're going to have here.

1047
00:53:08,300 --> 00:53:11,900
Had better be greater than like four bytes, because if the Run isn't

1048
00:53:11,900 --> 00:53:15,000
greater than 4 B, it's going to cost us more to Output it than it

1049
00:53:15,000 --> 00:53:16,800
would otherwise, right?

1050
00:53:18,600 --> 00:53:22,000
On the other hand, if we don't have to flush the literal buffer,

1051
00:53:22,700 --> 00:53:23,200
right?

1052
00:53:25,500 --> 00:53:28,600
Then technically we're only going to have to do two bites to encode,

1053
00:53:28,600 --> 00:53:29,900
whatever this duplication is.

1054
00:53:30,000 --> 00:53:33,500
So technically, it only has to be that good before, it's better right

1055
00:53:33,700 --> 00:53:36,900
now, when I say better, I mean, in a very, like, loose sense here.

1056
00:53:37,500 --> 00:53:39,200
And we'll talk about that in a second.

1057
00:53:39,300 --> 00:53:39,700
Right?

1058
00:53:40,400 --> 00:53:40,800
Or at least.

1059
00:53:40,800 --> 00:53:41,700
Hopefully I remember too,

1060
00:53:48,300 --> 00:53:52,100
Okay, so we'll just go ahead and put that in there and let's let's do

1061
00:53:52,100 --> 00:53:52,700
these two.

1062
00:53:53,400 --> 00:53:55,000
And so, let's see if that improves it at all.

1063
00:53:55,000 --> 00:53:56,700
Now, again, we haven't slept through it yet.

1064
00:53:58,800 --> 00:53:59,200
Disney

1065
00:54:00,000 --> 00:54:03,600
Not sure if we're actually properly working.

1066
00:54:03,600 --> 00:54:10,100
Yet that makes it a little bit different, but you can already see

1067
00:54:10,100 --> 00:54:18,800
that, you know, if assuming we are working, you can see that with that

1068
00:54:18,800 --> 00:54:19,700
change.

1069
00:54:20,600 --> 00:54:23,400
We are now down to a much smaller file size, right?

1070
00:54:23,400 --> 00:54:24,200
Compared to where we were.

1071
00:54:24,200 --> 00:54:26,100
We were worse than the other two before.

1072
00:54:26,100 --> 00:54:27,800
Now we're better, right?

1073
00:54:28,200 --> 00:54:29,500
And so, that's pretty handy, right?

1074
00:54:29,500 --> 00:54:29,900
So, it's like,

1075
00:54:30,000 --> 00:54:30,800
Now we can see.

1076
00:54:30,800 --> 00:54:35,400
Oh, okay, before we were, you know, 175 now we're down to 158, so

1077
00:54:35,400 --> 00:54:36,800
we're the best compressor of the three.

1078
00:54:36,800 --> 00:54:39,000
Now, before we were the worst

1079
00:54:40,500 --> 00:54:40,900
Okay.

1080
00:54:41,600 --> 00:54:44,200
Now again like I said, this is very, very slow because we're doing

1081
00:54:44,200 --> 00:54:48,500
that search which is very expensive and we're not accelerating it at

1082
00:54:48,500 --> 00:54:48,800
all.

1083
00:54:51,200 --> 00:54:55,100
So the downside to this is, if we want to run one of these guys, well

1084
00:54:55,100 --> 00:54:56,000
it's going to take a while.

1085
00:54:57,700 --> 00:54:59,000
Here's our intro art.

1086
00:54:59,200 --> 00:55:01,500
Let's go ahead and run that and we're going to be running it for a

1087
00:55:01,500 --> 00:55:02,300
while, right?

1088
00:55:02,300 --> 00:55:05,500
It's got a kind of sit there and it's going to like, turn and turn and

1089
00:55:05,500 --> 00:55:09,700
turn, and turn and turn and turn and turn right now.

1090
00:55:09,700 --> 00:55:11,600
We can fix this a little bit.

1091
00:55:13,800 --> 00:55:18,200
If we open our build, we can at least get some O2 on that, right?

1092
00:55:18,200 --> 00:55:22,400
We can at least have the compiler optimize it for us which I believe

1093
00:55:22,400 --> 00:55:23,200
it's going to do right?

1094
00:55:23,200 --> 00:55:24,900
Because we've passed the flags to it.

1095
00:55:24,900 --> 00:55:25,600
Do we not?

1096
00:55:28,800 --> 00:55:33,100
Yeah we passed common compiler flags and the common compiler Flags

1097
00:55:33,900 --> 00:55:36,200
should have that in there.

1098
00:55:36,200 --> 00:55:40,500
Yeah so if we do this we should get a little bit of extra speed but of

1099
00:55:40,500 --> 00:55:42,900
course it's still going to be very slow because just fundamentally

1100
00:55:43,000 --> 00:55:43,200
doing

1101
00:55:43,400 --> 00:55:43,900
Search.

1102
00:55:45,000 --> 00:55:46,700
And so, you know, we'll just let that run.

1103
00:55:46,900 --> 00:55:51,300
I'm going to get a drink while we do that because I am parched, hold

1104
00:55:51,300 --> 00:55:51,900
on one second.

1105
00:56:56,000 --> 00:56:56,500
All right.

1106
00:56:58,700 --> 00:56:59,200
so,

1107
00:57:00,900 --> 00:57:01,300
All right.

1108
00:57:01,300 --> 00:57:06,500
Well our little you know, completely N squared compressor is is truing

1109
00:57:06,500 --> 00:57:08,200
through this ridiculously large file.

1110
00:57:10,000 --> 00:57:12,800
we can go over here and play with our

1111
00:57:15,000 --> 00:57:16,400
Notepad.

1112
00:57:26,200 --> 00:57:28,700
All right, so let's talk a little bit about optimal parse.

1113
00:57:31,200 --> 00:57:35,200
Basically, the problem that we have here and you just saw me do a

1114
00:57:35,200 --> 00:57:40,000
little bit of it, is that LZ schemes have a lot of decisions.

1115
00:57:42,300 --> 00:57:42,600
Right.

1116
00:57:42,600 --> 00:57:45,600
And this is what I was talking about before when I said like, oh the

1117
00:57:45,600 --> 00:57:48,100
compressors, get more complicated because that's essentially an AI

1118
00:57:48,100 --> 00:57:48,400
problem.

1119
00:57:48,400 --> 00:57:51,600
It's got to do a bunch of intelligence here and graphs arches and

1120
00:57:51,600 --> 00:57:56,800
optimization of sort of thinking based optimization in order to figure

1121
00:57:56,800 --> 00:57:58,900
out what the best way to do something is it's definitely a

1122
00:57:58,900 --> 00:58:00,500
maximization kind of process.

1123
00:58:03,200 --> 00:58:04,500
And so what do I mean here?

1124
00:58:04,500 --> 00:58:07,600
Well, as you saw when where's that?

1125
00:58:08,400 --> 00:58:10,800
Let's go to some compressor, here you go.

1126
00:58:11,300 --> 00:58:14,600
As you see here where we've got, you know, literal count and I don't

1127
00:58:14,600 --> 00:58:15,800
know why I'm on that side.

1128
00:58:18,500 --> 00:58:22,100
Again, as you see here, we've got, you know this if a little account,

1129
00:58:22,100 --> 00:58:23,000
then output the run.

1130
00:58:23,000 --> 00:58:25,200
If it's better than this or a better than that or whatever.

1131
00:58:25,500 --> 00:58:29,200
We already even though we're not together and intelligent, we already

1132
00:58:29,200 --> 00:58:33,200
have this concept of trying to wait two different options based on

1133
00:58:33,200 --> 00:58:34,900
which one we think is going to be better for compression.

1134
00:58:34,900 --> 00:58:35,300
But

1135
00:58:36,800 --> 00:58:38,000
Is this the whole picture?

1136
00:58:38,100 --> 00:58:40,000
No, it's definitely not the whole picture.

1137
00:58:40,200 --> 00:58:40,800
Why?

1138
00:58:41,200 --> 00:58:46,100
Because every time we encode something, we affect the decision, making

1139
00:58:46,100 --> 00:58:48,600
process all the way down the line, right?

1140
00:58:48,700 --> 00:58:53,900
And so, if you think about what happens, let's suppose that we have

1141
00:58:53,900 --> 00:59:01,700
something like, you know, a b c, d, e, f, g, h in the buffer or

1142
00:59:01,700 --> 00:59:02,900
something like this, right?

1143
00:59:02,900 --> 00:59:06,400
This is what we've output at this point, and we're talking about

1144
00:59:06,600 --> 00:59:13,700
It to Output next let's say right and well I guess I maybe need one

1145
00:59:13,700 --> 00:59:14,600
other thing here.

1146
00:59:14,900 --> 00:59:17,600
Maybe I want something that looks like

1147
00:59:26,100 --> 00:59:27,700
This is not going to be very good example.

1148
00:59:28,900 --> 00:59:31,500
I'm trying to think of exactly how I want to Output this.

1149
00:59:31,500 --> 00:59:37,100
So let's say that I've got this in the buffer and then I have another

1150
00:59:37,100 --> 00:59:40,600
thing in the buffer which is

1151
00:59:42,200 --> 00:59:45,400
Comes from part of this.

1152
00:59:45,500 --> 00:59:47,800
So let's say it's

1153
00:59:51,200 --> 00:59:52,400
Hmm.

1154
00:59:56,800 --> 00:59:59,800
I'm not sure my compression, nah.

1155
01:00:00,200 --> 01:00:03,900
Expertness means it's hard for me to come up with a case on the spot,

1156
01:00:03,900 --> 01:00:07,900
that demonstrates what I mean about picking the wrong match because we

1157
01:00:07,900 --> 01:00:12,000
can pick matches from anywhere in the input stream, but we don't

1158
01:00:12,000 --> 01:00:16,400
necessarily always know which one is going to be best.

1159
01:00:16,700 --> 01:00:17,500
So

1160
01:00:24,900 --> 01:00:25,500
All right.

1161
01:00:25,600 --> 01:00:27,100
Here's one that.

1162
01:00:27,200 --> 01:00:28,300
Okay, here you go.

1163
01:00:29,700 --> 01:00:34,500
so, let's suppose that we had something that was like,

1164
01:00:38,300 --> 01:00:40,300
You know in very interleave e.

1165
01:00:40,300 --> 01:00:45,200
So it was abcdefgh, right?

1166
01:00:45,800 --> 01:00:51,900
And then we had something that was like, you know, trying to encode

1167
01:00:51,900 --> 01:00:55,100
something and then we had another one here that was like

1168
01:00:58,400 --> 01:01:02,100
Maybe 12, let's say.

1169
01:01:06,400 --> 01:01:07,800
A b.

1170
01:01:07,800 --> 01:01:12,500
And then we had another like,

1171
01:01:28,400 --> 01:01:31,300
Okay, so, it's probably gonna be a really bad example.

1172
01:01:31,400 --> 01:01:33,600
Again, this is because I don't do compression hardly ever.

1173
01:01:33,600 --> 01:01:35,900
So, you know, I feel like if you were kind of person to do a

1174
01:01:35,900 --> 01:01:37,500
compression all the time, you would be able to think of these

1175
01:01:37,500 --> 01:01:45,100
examples, much more cleanly but so imagine that we're trying to Output

1176
01:01:45,600 --> 01:01:46,600
things right here.

1177
01:01:47,000 --> 01:01:52,000
Okay, well if I look back in the Stream and I look at them for the

1178
01:01:52,000 --> 01:01:53,400
longest match right here.

1179
01:01:53,400 --> 01:01:56,200
You can see that the longest match is this one, right?

1180
01:01:57,800 --> 01:02:01,600
Went to a b which is just long enough that we would probably choose to

1181
01:02:01,600 --> 01:02:03,400
encode it, which would put us right here.

1182
01:02:03,700 --> 01:02:06,600
And then we would look back and we would find that the longest match

1183
01:02:06,600 --> 01:02:08,500
was like right here, right.

1184
01:02:10,800 --> 01:02:13,800
It's C, D E, F H and it goes that far right.

1185
01:02:14,400 --> 01:02:18,000
Well probably if this was a literal.

1186
01:02:19,400 --> 01:02:24,500
It probably would have made a lot more sense to just include these two

1187
01:02:24,500 --> 01:02:28,800
in the literal right and make this literal slightly longer.

1188
01:02:28,800 --> 01:02:34,900
Then include this very long match because that would allow us to only

1189
01:02:34,900 --> 01:02:40,700
send an additional two bytes of data to encode this match rather than

1190
01:02:40,700 --> 01:02:45,200
having to encode two matches this one and this one, which would be two

1191
01:02:45,200 --> 01:02:46,900
extra bytes each, right?

1192
01:02:46,900 --> 01:02:49,400
So every time you

1193
01:02:49,500 --> 01:02:50,400
Make a decision.

1194
01:02:50,800 --> 01:02:53,700
You're making a decision that affects all the future decisions that

1195
01:02:53,700 --> 01:02:54,800
you're going to make.

1196
01:02:54,800 --> 01:02:59,500
Because you've changed where the like outputs where you're going to

1197
01:02:59,500 --> 01:02:59,800
be.

1198
01:03:00,000 --> 01:03:01,800
Making your decision points, right?

1199
01:03:02,600 --> 01:03:08,700
And so, the concept of an optimal parse is basically the concept that

1200
01:03:08,700 --> 01:03:14,500
when you're doing one of these compression passes, there is some set.

1201
01:03:14,600 --> 01:03:18,800
There may be more than one but there is some set of ways of choosing

1202
01:03:18,800 --> 01:03:23,500
where you broke up the stream like that that will produce the smallest

1203
01:03:23,500 --> 01:03:24,900
possible output size.

1204
01:03:26,000 --> 01:03:31,600
And lots of other decisions sets you could make will not produce the

1205
01:03:31,600 --> 01:03:35,400
smallest possible output size even for the same encoder, right?

1206
01:03:36,700 --> 01:03:39,800
And so, that is what this sort of thing is about.

1207
01:03:39,900 --> 01:03:45,600
Typically you are making a bunch of pieces of code that operate inside

1208
01:03:45,600 --> 01:03:48,100
your compressor, that are much more complicated than this.

1209
01:03:49,200 --> 01:03:55,000
Whose goal is to figure out whether or not you should in code matches

1210
01:03:55,000 --> 01:03:55,400
and code.

1211
01:03:55,600 --> 01:03:56,600
Rules Etc.

1212
01:03:56,700 --> 01:04:01,300
Based on heuristics right now you could try to do the actual optimal.

1213
01:04:01,300 --> 01:04:01,700
Parse

1214
01:04:05,100 --> 01:04:09,300
Because for example, you could just try everything try every possible

1215
01:04:09,300 --> 01:04:11,900
way of breaking up the stream, but again it becomes prohibitively

1216
01:04:11,900 --> 01:04:13,800
expensive to actually run those things.

1217
01:04:14,100 --> 01:04:16,800
So you have to use, you know, dynamic programming or something like

1218
01:04:16,800 --> 01:04:19,600
this, to make it a little more tractable and then maybe you don't test

1219
01:04:19,600 --> 01:04:20,000
everything.

1220
01:04:20,000 --> 01:04:22,600
You just have some things and you can imagine it just getting much

1221
01:04:22,600 --> 01:04:25,600
more complicated as you try to make something, which actually does

1222
01:04:25,600 --> 01:04:27,000
look across all of those options.

1223
01:04:28,000 --> 01:04:32,100
Now that I'm done with the explanation, you can see that we've got our

1224
01:04:32,100 --> 01:04:34,200
output here and let's take a look at how it did.

1225
01:04:34,200 --> 01:04:34,800
So here's our

1226
01:04:34,900 --> 01:04:38,700
Simple LZ compressor and you can actually see it's real good compared

1227
01:04:38,700 --> 01:04:40,700
to our other two compressors, right?

1228
01:04:41,000 --> 01:04:45,700
It's not quite down in the range of a really good compressor like

1229
01:04:45,700 --> 01:04:49,100
7-Zip, but that's pretty great.

1230
01:04:49,100 --> 01:04:54,100
I mean, we've, this is less than half the size of our art pack, right?

1231
01:04:54,400 --> 01:04:56,900
That means, you know, if it was going to take 10 minutes to download

1232
01:04:56,900 --> 01:04:59,500
Before, It's Gonna Take 5 minutes to download or less.

1233
01:04:59,500 --> 01:05:03,000
Now, that's pretty great for really stupid compressor, right?

1234
01:05:04,400 --> 01:05:07,600
But hey, it took a long time to do the compression.

1235
01:05:07,900 --> 01:05:12,200
So, the next thing you might want to do is start looking at how you

1236
01:05:12,200 --> 01:05:13,600
would speed it up, right?

1237
01:05:15,300 --> 01:05:20,400
So we don't really need to belabor these points right now, but I'm

1238
01:05:20,400 --> 01:05:22,200
going to go ahead and put a thing in here.

1239
01:05:42,600 --> 01:05:47,000
So let's talk a little bit about what you might do with this

1240
01:05:47,000 --> 01:05:50,100
compression code to start to make it better one.

1241
01:05:52,800 --> 01:05:56,800
Figure out an efficient way to expand.

1242
01:05:58,600 --> 01:05:59,500
Plz.

1243
01:05:59,500 --> 01:05:59,900
And

1244
01:06:00,900 --> 01:06:01,900
To support.

1245
01:06:03,600 --> 01:06:07,400
You know greater than 2 and 55 sighs.

1246
01:06:07,900 --> 01:06:08,600
Look back.

1247
01:06:11,200 --> 01:06:15,700
And or runs to add an interview back end.

1248
01:06:17,200 --> 01:06:20,100
Like Huffman arithmetic.

1249
01:06:21,600 --> 01:06:22,400
ANS.

1250
01:06:27,200 --> 01:06:30,800
All right, so adding an inch me back end would be another great thing

1251
01:06:30,800 --> 01:06:31,800
to do to this code.

1252
01:06:35,600 --> 01:06:43,100
Add hash look up for other acceleration structure to the LZ encoder.

1253
01:06:45,200 --> 01:06:51,000
So that it isn't unusually slow.

1254
01:06:52,300 --> 01:06:55,000
For add better heuristics.

1255
01:06:56,200 --> 01:07:05,600
To the LZ compressor to get closer to an optimal parse 5 ad

1256
01:07:05,600 --> 01:07:06,900
preconditioners.

1257
01:07:09,000 --> 01:07:09,700
Two.

1258
01:07:12,900 --> 01:07:21,100
test, you know, whether something better can be done for bitmaps, like

1259
01:07:21,200 --> 01:07:22,200
different saying,

1260
01:07:23,400 --> 01:07:26,500
The interleaving by for etcetera.

1261
01:08:08,600 --> 01:08:13,800
So there's lots of things that you could do and compression, you know,

1262
01:08:14,100 --> 01:08:18,899
certainly you want to learn more about compression, if you were

1263
01:08:18,899 --> 01:08:21,899
actually going to try and do something good with compression.

1264
01:08:23,100 --> 01:08:26,500
That's better than what we're doing here, but the other aspect of

1265
01:08:26,500 --> 01:08:29,500
compression that generally tends to be true is even after you really

1266
01:08:29,500 --> 01:08:30,600
know what you're doing.

1267
01:08:31,800 --> 01:08:39,000
There's just a lot of, you know, for lack of a better term fiddling

1268
01:08:40,000 --> 01:08:44,800
and refinement, you know, getting to a reasonable State, theoretically

1269
01:08:44,800 --> 01:08:47,300
is one part of the battle and that's Obviously good.

1270
01:08:47,300 --> 01:08:51,600
But then just the, the actual like mechanics of how you get things to

1271
01:08:51,600 --> 01:08:52,600
be encoded, cleanly.

1272
01:08:54,600 --> 01:08:59,100
How you work out all of the details and make them fit the problems

1273
01:08:59,100 --> 01:08:59,800
that you have as well?

1274
01:09:00,100 --> 01:09:04,700
Possible, those things are definitely, you know, those are a whole

1275
01:09:04,700 --> 01:09:08,399
different set of techniques, which is a lot more like optimizing

1276
01:09:08,399 --> 01:09:08,899
render code.

1277
01:09:08,899 --> 01:09:12,200
There's just a lot of iterations and testing and measurement.

1278
01:09:12,300 --> 01:09:15,700
That's necessary to do that, right?

1279
01:09:17,300 --> 01:09:22,700
So yeah, I think that's I think that's basically it for that.

1280
01:09:23,100 --> 01:09:25,700
I'm going to go ahead and add just a little bit more.

1281
01:09:25,700 --> 01:09:32,000
I think to this framework here just so we can maybe like yeah, maybe

1282
01:09:32,399 --> 01:09:35,399
if anyone wants to play with it and do some stuff, they'll be in a

1283
01:09:35,399 --> 01:09:36,600
slightly better position.

1284
01:09:37,000 --> 01:09:42,500
So what I'm going to do here is just say, like, okay, maybe there's

1285
01:09:42,500 --> 01:09:45,800
some kind of a way that we expose statistics

1286
01:09:47,000 --> 01:09:49,000
out of this, you know, and

1287
01:09:52,300 --> 01:09:54,700
I'm trying to think about how I would want to do that.

1288
01:09:55,000 --> 01:10:00,700
Let's suppose we did something like maybe an enum here, which is like

1289
01:10:00,800 --> 01:10:06,300
stat type and then we would have something like, you know,

1290
01:10:34,000 --> 01:10:36,600
Or don't you want to call it?

1291
01:10:37,700 --> 01:10:41,100
I feel like you need a different name for like a repeat versus a copy

1292
01:10:41,100 --> 01:10:41,700
back.

1293
01:10:41,800 --> 01:10:43,100
I don't know that.

1294
01:10:43,100 --> 01:10:44,000
We'll call it that way.

1295
01:10:44,000 --> 01:10:45,200
We'll call it, something like that.

1296
01:10:48,400 --> 01:10:50,900
Stat literal bites.

1297
01:11:00,300 --> 01:11:02,800
I don't know, let's say we've got a bunch of Staff types here.

1298
01:11:03,800 --> 01:11:04,300
Right.

1299
01:11:05,400 --> 01:11:09,300
And I want to print these things out and then I'm going to have a

1300
01:11:09,300 --> 01:11:12,900
struct like stat in a struct.

1301
01:11:14,000 --> 01:11:15,000
Stat group.

1302
01:11:16,600 --> 01:11:22,300
And then I've got my stats here, which is

1303
01:11:24,200 --> 01:11:26,000
however, many there is, there are

1304
01:11:29,200 --> 01:11:33,100
and then my stat is just going to be a count and a total something

1305
01:11:33,100 --> 01:11:33,800
like that.

1306
01:11:35,000 --> 01:11:37,200
So basically what I'm going to do here is just create a little thing

1307
01:11:37,200 --> 01:11:41,800
that allows me to record information about, you know, what's going on?

1308
01:11:42,400 --> 01:11:44,100
And maybe I've got an addition here.

1309
01:11:44,100 --> 01:11:45,200
I've just got like

1310
01:11:47,400 --> 01:11:48,400
Uncompressed.

1311
01:11:51,000 --> 01:11:51,600
B.

1312
01:11:56,100 --> 01:11:58,300
And compressed tights.

1313
01:12:02,200 --> 01:12:07,400
And yeah, so well actually I suppose the total I suppose, those are

1314
01:12:07,400 --> 01:12:11,300
things that we actually just kind of know, so maybe that's not in the

1315
01:12:11,300 --> 01:12:14,200
stat group, maybe that's down here.

1316
01:12:23,600 --> 01:12:25,500
Trying to figure out a good way to keep track of all this stuff.

1317
01:12:25,500 --> 01:12:31,500
So, we've got ya, we've got all of our staff that we might want to

1318
01:12:31,500 --> 01:12:32,200
Output it.

1319
01:12:32,200 --> 01:12:34,700
We've got the stat group here,

1320
01:12:37,500 --> 01:12:38,300
And off we go.

1321
01:12:39,100 --> 01:12:42,200
So what I'm going to do is I'm basically just making a little thing

1322
01:12:42,200 --> 01:12:44,600
that will make this a little bit easier to use for various purposes.

1323
01:12:44,600 --> 01:12:49,800
I'm going to take here and make a compress and an uncompressed kind of

1324
01:12:49,800 --> 01:12:52,500
thing into a typedef.

1325
01:12:53,300 --> 01:12:58,500
So I'm just going to pound Define like compress Handler.

1326
01:13:02,400 --> 01:13:03,700
And decompress Handler.

1327
01:13:13,900 --> 01:13:14,800
So here they are.

1328
01:13:15,800 --> 01:13:17,200
So I've got the

1329
01:13:22,500 --> 01:13:23,300
compressors.

1330
01:13:24,000 --> 01:13:25,200
They'll all look like this.

1331
01:13:29,000 --> 01:13:30,100
I've got the D compressors.

1332
01:13:30,100 --> 01:13:31,300
They'll look like this.

1333
01:13:39,500 --> 01:13:41,500
And then we'll just do typedef.

1334
01:13:42,500 --> 01:13:43,400
Press Handler.

1335
01:13:49,600 --> 01:13:52,000
Typedef decompressed Handler.

1336
01:13:58,600 --> 01:13:59,200
All right.

1337
01:14:13,100 --> 01:14:13,600
But we go.

1338
01:14:14,500 --> 01:14:17,100
And so now what I can do is I can just sort of make these

1339
01:14:19,900 --> 01:14:24,400
And we need to actually figure out something here for a reasonable

1340
01:14:24,400 --> 01:14:25,100
size.

1341
01:14:25,600 --> 01:14:29,800
You know kind of some kind of thing that handles the size more

1342
01:14:29,800 --> 01:14:30,300
reasonably here.

1343
01:14:30,300 --> 01:14:35,900
But let's go ahead and just say we got compressed Handler our Ally

1344
01:14:35,900 --> 01:14:36,700
compress.

1345
01:14:43,800 --> 01:14:46,300
you can press Handler, we decompress

1346
01:14:50,400 --> 01:14:52,700
Press Handler, as you can press.

1347
01:14:58,800 --> 01:14:59,800
And decompress Handler.

1348
01:15:03,900 --> 01:15:04,700
I was impressed.

1349
01:15:07,500 --> 01:15:11,900
So at that point once we've got those sort of handlers there then I

1350
01:15:11,900 --> 01:15:16,400
can sort of also Define this idea of like a compressor and the

1351
01:15:16,400 --> 01:15:18,200
compressor can have a compress Handler.

1352
01:15:22,200 --> 01:15:23,400
And decompress Handler.

1353
01:15:25,600 --> 01:15:29,400
And you'll notice, I want to have both kinds are want to have a

1354
01:15:29,400 --> 01:15:33,200
compressor other and decompress Handler pointers because we may want

1355
01:15:33,200 --> 01:15:35,700
to use the same decompress Handler for a whole bunch of different

1356
01:15:35,700 --> 01:15:38,000
compressors because we might want to have different compressors that

1357
01:15:38,000 --> 01:15:38,900
we try or whatever.

1358
01:15:38,900 --> 01:15:39,800
So you know, who knows?

1359
01:15:41,300 --> 01:15:44,200
And so what I can do is I can say we've got compressors.

1360
01:15:52,800 --> 01:15:57,200
And these are just going to be like compress and decompress pairs for

1361
01:15:57,200 --> 01:15:59,700
like all the stuff that we've got, right?

1362
01:16:00,500 --> 01:16:04,400
So you can imagine like we just say like, okay, we've got a bunch of

1363
01:16:04,400 --> 01:16:05,100
compressors.

1364
01:16:05,500 --> 01:16:07,800
We've got the rle one, right?

1365
01:16:14,600 --> 01:16:15,900
We've got the lz1.

1366
01:16:17,300 --> 01:16:20,900
You know, and maybe we want to do a thing in here where we're going to

1367
01:16:20,900 --> 01:16:21,400
name them.

1368
01:16:27,400 --> 01:16:27,900
Who knows?

1369
01:16:29,100 --> 01:16:36,400
okay, so let's assume that that's how we're going to do it and you

1370
01:16:36,400 --> 01:16:39,900
know, maybe get rid of these guys and then we go up to our compressor

1371
01:16:39,900 --> 01:16:44,900
here, we'll just say like, oh yeah, okay, so the compressor has a name

1372
01:16:47,000 --> 01:16:51,300
And this way we can say, like when you are specifying something here,

1373
01:16:51,400 --> 01:16:57,000
when we, when you do the arguments or whatever, we can say that when

1374
01:16:57,000 --> 01:17:02,900
you do compress or decompress week before that, maybe this becomes a 5

1375
01:17:03,300 --> 01:17:08,500
and we do a little check to see which compressor we're talking about,

1376
01:17:08,700 --> 01:17:09,200
right?

1377
01:17:12,200 --> 01:17:16,300
And yeah, I mean I guess the, I guess the other way we could do it

1378
01:17:16,300 --> 01:17:20,300
might be to say as long as it's you know greater than 4 or you just,

1379
01:17:20,300 --> 01:17:25,100
we take all of the ones and we use the compressor for each one or

1380
01:17:25,100 --> 01:17:25,600
something.

1381
01:17:25,900 --> 01:17:26,600
I'm not sure.

1382
01:17:27,100 --> 01:17:28,400
We got to think this through a little bit.

1383
01:17:28,400 --> 01:17:28,800
I don't know.

1384
01:17:28,800 --> 01:17:31,400
We'll do the simpler one first and just see how that goes.

1385
01:17:32,600 --> 01:17:35,500
But point being we should be able to say something like okay, you know

1386
01:17:35,700 --> 01:17:40,300
let's say you got to take five arguments and so instead of

1387
01:17:40,700 --> 01:17:43,000
One two three will do two, three four.

1388
01:17:43,000 --> 01:17:49,600
And we'll say here caressed are compress or codec.

1389
01:17:51,000 --> 01:17:51,500
Name.

1390
01:17:54,000 --> 01:17:55,100
And that'll be the first one.

1391
01:17:55,500 --> 01:17:57,500
So the first thing we'll do is try to find the compressor.

1392
01:17:57,500 --> 01:17:58,700
So we'll say, compressor,

1393
01:18:00,000 --> 01:18:04,900
Press R equals 0 and we'll just go through all of our compressors

1394
01:18:04,900 --> 01:18:05,400
compressor.

1395
01:18:05,400 --> 01:18:09,100
Index equals zero, press your index is less than you know.

1396
01:18:09,100 --> 01:18:10,900
However, many there are in that array.

1397
01:18:19,600 --> 01:18:20,100
Right.

1398
01:18:20,600 --> 01:18:23,900
And then we'll say, Okay compressors, compressor index.

1399
01:18:34,700 --> 01:18:36,400
And we'll just check this the string compare.

1400
01:18:36,900 --> 01:18:44,100
So if the codec name and the compressor name or the same Breakout

1401
01:18:46,900 --> 01:18:47,600
And that's that.

1402
01:18:47,700 --> 01:18:49,100
So this is really probably should be.

1403
01:18:53,400 --> 01:18:53,900
Right.

1404
01:18:54,700 --> 01:18:59,400
So in this case we only want to proceed if the compressor is known,

1405
01:19:01,000 --> 01:19:02,500
like, if we have that compressor,

1406
01:19:18,300 --> 01:19:21,300
But assuming that we have it, then from then on out, we will just use

1407
01:19:21,300 --> 01:19:22,800
whatever the compressor is that we found.

1408
01:19:22,800 --> 01:19:25,600
So now instead of calling compress, we're going to call compressor

1409
01:19:25,600 --> 01:19:27,000
compress, right?

1410
01:19:27,800 --> 01:19:30,100
Instead of calling decompress will compress or decompress.

1411
01:19:32,000 --> 01:19:32,500
And so on.

1412
01:19:34,400 --> 01:19:35,400
So hopefully that makes sense.

1413
01:19:37,100 --> 01:19:42,200
And let's go ahead and and rename these guys to be base so that they

1414
01:19:42,200 --> 01:19:43,000
don't conflict.

1415
01:19:43,100 --> 01:19:46,300
And then anyone who doesn't want that can obviously,

1416
01:19:50,200 --> 01:19:51,800
Sort of play with that later.

1417
01:19:52,000 --> 01:19:53,600
So this is going to be in base.

1418
01:20:05,900 --> 01:20:06,600
And same here.

1419
01:20:17,700 --> 01:20:18,100
and,

1420
01:20:22,400 --> 01:20:22,900
Oops.

1421
01:20:31,600 --> 01:20:32,500
And then I think we're good.

1422
01:20:33,200 --> 01:20:37,100
So now if we take a look at what's going on here, so let's do simple

1423
01:20:37,100 --> 01:20:38,000
compressor.

1424
01:20:40,200 --> 01:20:41,000
Compress.

1425
01:20:41,800 --> 01:20:44,300
And I think we wanted to say like let's say rle, right?

1426
01:20:44,300 --> 01:20:52,100
Compress test one that ha test one are Ali out or something like that.

1427
01:20:52,600 --> 01:20:54,000
Let's see if that actually oh

1428
01:20:55,200 --> 01:20:55,900
My goodness.

1429
01:20:57,400 --> 01:20:59,700
Well, that didn't work particularly well.

1430
01:21:00,900 --> 01:21:02,400
Let's take a look at what's going on there.

1431
01:21:13,400 --> 01:21:15,700
All right, so in here, we got now.

1432
01:21:16,700 --> 01:21:18,700
Let's put something on the front of this here.

1433
01:21:19,600 --> 01:21:20,400
So

1434
01:21:27,100 --> 01:21:28,200
I'm going to go ahead and step in.

1435
01:21:33,000 --> 01:21:35,300
Compress, wait a minute.

1436
01:21:39,200 --> 01:21:40,600
also, we got to change the

1437
01:21:51,600 --> 01:21:55,400
And we do not need this to be 02 anymore, we can go back to debug

1438
01:21:55,400 --> 01:21:55,800
mode.

1439
01:21:57,200 --> 01:21:57,700
There we go.

1440
01:21:59,500 --> 01:22:00,800
So, let's see here.

1441
01:22:00,800 --> 01:22:04,200
What did I need to set the thing to our count?

1442
01:22:04,200 --> 01:22:04,500
Five?

1443
01:22:04,500 --> 01:22:06,000
One, two, three.

1444
01:22:06,500 --> 01:22:08,100
Forgot to put the compress in there.

1445
01:22:08,400 --> 01:22:11,800
Yeah, let's step through here.

1446
01:22:11,800 --> 01:22:18,700
There's the compressor, and we, oh, that's a nice type of there.

1447
01:22:23,900 --> 01:22:24,300
Area.

1448
01:22:28,100 --> 01:22:29,700
All right, so let's see how that Rose.

1449
01:22:29,700 --> 01:22:31,800
So we go through here, we find our compressor.

1450
01:22:32,500 --> 01:22:35,500
We go through, we can press with it and and we're done.

1451
01:22:35,700 --> 01:22:36,700
Okay, so that's all good.

1452
01:22:37,800 --> 01:22:40,800
Alright, so now we should be able to use any of the compressors that

1453
01:22:40,800 --> 01:22:47,100
we want which is nice but we would like to maybe do a little bit more

1454
01:22:47,100 --> 01:22:50,600
here in terms of outputting some statistics and stuff like are saying

1455
01:22:50,600 --> 01:22:55,900
before, and we also might want to Output the algorithms that you can

1456
01:22:55,900 --> 01:22:56,700
use as well.

1457
01:22:56,700 --> 01:22:57,100
So we know

1458
01:22:57,300 --> 01:22:59,000
we could go ahead and

1459
01:23:01,000 --> 01:23:05,800
put that in here where we say like okay, you know, algorithm

1460
01:23:34,700 --> 01:23:36,500
Not a particularly good help system.

1461
01:23:36,800 --> 01:23:37,700
Let's be honest.

1462
01:23:41,100 --> 01:23:45,000
But there's like what the algorithms could be right at the moment.

1463
01:23:47,700 --> 01:23:48,800
And off you go.

1464
01:23:49,300 --> 01:23:52,100
So now, the only other thing like I said that I wanted to do was have

1465
01:23:52,100 --> 01:23:55,500
a concept that Stats come in to play at some point.

1466
01:23:56,400 --> 01:23:59,000
So what I'm going to do here is we're going to say that, hey, we're

1467
01:23:59,000 --> 01:23:59,800
going to pass

1468
01:24:02,600 --> 01:24:04,900
Stats to both of these.

1469
01:24:04,900 --> 01:24:08,800
So that basically like if they want to record stats they can.

1470
01:24:09,600 --> 01:24:12,900
And then what we're going to do here is say like okay there's you

1471
01:24:12,900 --> 01:24:15,600
know, sort of a stat

1472
01:24:21,600 --> 01:24:25,700
It comes in uninitialized that we pass the compressor.

1473
01:24:25,700 --> 01:24:29,800
I guess decompressor, maybe doesn't need stats now, I think about it

1474
01:24:29,800 --> 01:24:33,200
because we don't really care about recording statue, the decompressor.

1475
01:24:33,700 --> 01:24:39,200
So probably it's we're only really talking about stats in this case,

1476
01:24:40,500 --> 01:24:41,700
where we're calling the compressor.

1477
01:24:43,600 --> 01:24:44,100
All right.

1478
01:24:45,600 --> 01:24:46,500
So yeah.

1479
01:24:46,500 --> 01:24:49,800
So now we're passing those stats through and now we really all I want

1480
01:24:49,800 --> 01:24:53,400
to do is have a way to dump the stats out, right?

1481
01:24:53,400 --> 01:24:57,900
So I want to be able to take these stats here and and output them,

1482
01:24:57,900 --> 01:24:58,300
right?

1483
01:24:58,600 --> 01:25:00,500
So it's kind of annoying.

1484
01:25:00,500 --> 01:25:01,200
This is one of those.

1485
01:25:01,200 --> 01:25:03,700
See things that just really is awful.

1486
01:25:06,000 --> 01:25:07,200
About C and C, plus plus.

1487
01:25:11,700 --> 01:25:14,000
I just want to be able to get the names of these things so I can have

1488
01:25:14,000 --> 01:25:15,500
put them, of course, I can't.

1489
01:25:16,100 --> 01:25:17,100
So, that's kind of annoying.

1490
01:25:17,100 --> 01:25:23,400
But, you know, I can make a function that does it, you know, that

1491
01:25:23,400 --> 01:25:26,100
name, the takes that type.

1492
01:25:30,900 --> 01:25:33,600
And then just does this nonsense here, right?

1493
01:25:33,700 --> 01:25:35,200
Well, I guess I could even just do

1494
01:25:36,600 --> 01:25:37,600
Well, we'll do it this way.

1495
01:25:50,400 --> 01:25:54,300
It's a little more robust than using an array because if you or going

1496
01:25:54,300 --> 01:25:57,900
to reorganize things, you don't end up with wrong printouts which is

1497
01:25:57,900 --> 01:25:59,500
kind of nice, right?

1498
01:26:12,800 --> 01:26:13,700
So you can kind of see what I'm doing here.

1499
01:26:13,700 --> 01:26:15,900
I'm just saying, hey let's make a macro where we say if we're going to

1500
01:26:15,900 --> 01:26:18,400
do this thing, we don't put whatever.

1501
01:26:18,500 --> 01:26:22,000
You know, the thing is that we want and we probably don't really need

1502
01:26:22,100 --> 01:26:23,500
the stat underscore in front of it.

1503
01:26:23,500 --> 01:26:27,500
So we could just say like, you know, go forwards, five characters and

1504
01:26:27,500 --> 01:26:28,700
and do that or something like this.

1505
01:26:29,500 --> 01:26:33,300
You can imagine that being sort of, a

1506
01:26:34,400 --> 01:26:40,500
An amusement that we could do and of course you know how much I hate

1507
01:26:41,100 --> 01:26:43,500
const, it's the worst thing ever.

1508
01:26:44,000 --> 01:26:47,000
So typically, what I'll do is I'll just get rid of it, right?

1509
01:26:47,200 --> 01:26:49,800
You always, I always get rid of const anywhere, I possibly can.

1510
01:26:50,800 --> 01:26:54,000
So now we've got a way to print out these stats.

1511
01:26:54,500 --> 01:26:58,400
So you can imagine us going through, you know, something like this.

1512
01:27:07,700 --> 01:27:09,100
Don't know why I made that in line.

1513
01:27:10,700 --> 01:27:15,200
So if I want to do, you know a stat print out, and we've got a stat

1514
01:27:15,200 --> 01:27:16,000
group here.

1515
01:27:18,700 --> 01:27:21,000
Then I can guess I can go through these in a pretty straightforward

1516
01:27:21,000 --> 01:27:21,900
way, right?

1517
01:27:21,900 --> 01:27:24,400
And again, I don't know why I'm on that side where my head gets in the

1518
01:27:24,400 --> 01:27:24,800
way.

1519
01:27:28,100 --> 01:27:28,600
Go over here.

1520
01:27:29,800 --> 01:27:31,900
So if I have one of these stacked groups, I can just kind of come

1521
01:27:31,900 --> 01:27:34,600
through here and say all right what's my fat index?

1522
01:27:35,700 --> 01:27:36,500
Go through them all.

1523
01:27:39,400 --> 01:27:42,000
Like so I want to grab out one of these stats.

1524
01:27:42,000 --> 01:27:43,400
So I just say, all right,

1525
01:27:48,500 --> 01:27:49,900
let's take each one in turn.

1526
01:27:52,000 --> 01:27:55,500
If anyone recorded anything to the statistic, we will print it out.

1527
01:27:57,500 --> 01:27:58,500
Otherwise, we won't.

1528
01:28:05,000 --> 01:28:07,000
I don't know if we want to print these, the standard error standard

1529
01:28:07,000 --> 01:28:08,100
out, maybe standard out.

1530
01:28:08,100 --> 01:28:09,800
I'm not sure it's a good question.

1531
01:28:10,700 --> 01:28:14,100
I'm not sure which is the more appropriate but we're like okay, this

1532
01:28:14,100 --> 01:28:16,200
particular stat, right?

1533
01:28:16,200 --> 01:28:26,100
And it's going to be I don't actually know how to print out with the c

1534
01:28:26,100 --> 01:28:30,500
runtime Library, how to print out 64-bit things, reliably, it changes

1535
01:28:30,500 --> 01:28:31,100
all the time.

1536
01:28:31,400 --> 01:28:34,100
So what I'm probably going to do is just print them out as doubles.

1537
01:28:34,700 --> 01:28:36,500
And say that I don't want any.

1538
01:28:38,500 --> 01:28:40,500
Additional number to it, right?

1539
01:28:41,000 --> 01:28:45,600
Because that allow me to make sure that it's you know that it's

1540
01:28:45,700 --> 01:28:46,600
properly printed out.

1541
01:28:46,600 --> 01:28:49,600
On any particular platform you might be on without having to guess

1542
01:28:49,600 --> 01:28:52,700
what that platform is going to do in terms of asking to print out a

1543
01:28:52,700 --> 01:28:53,800
64-bit variable.

1544
01:28:57,100 --> 01:29:01,900
So yeah, so, you know, oops, I should probably put that up here.

1545
01:29:03,000 --> 01:29:10,600
First so uncompressed or like maybe we'll do like compression first.

1546
01:29:11,300 --> 01:29:16,200
It went from here to here and then, you know, we've got a particular

1547
01:29:16,200 --> 01:29:17,100
percentage.

1548
01:29:23,600 --> 01:29:26,100
so, what I want to do here is say like, all right, we've got a certain

1549
01:29:26,100 --> 01:29:33,700
uncompressed size and a certain compressed size and I, yeah, I could

1550
01:29:33,700 --> 01:29:38,300
say if stats uncompressed B greater than 0,

1551
01:29:42,500 --> 01:29:43,900
Then we go through and print them out.

1552
01:29:44,500 --> 01:29:47,800
So we get our compression goes from, you know, whatever uncompressed B

1553
01:29:47,800 --> 01:29:50,300
were to whatever are compressed by its were and there's certain

1554
01:29:50,300 --> 01:29:51,100
percentage there.

1555
01:29:51,200 --> 01:29:55,200
I'm going to introduce a function just called percent where I can pass

1556
01:29:55,200 --> 01:29:57,400
two things that I want the percentage of

1557
01:30:01,800 --> 01:30:04,800
And so what, we usually, the way compression percentages are phrased

1558
01:30:04,800 --> 01:30:07,600
as what percentage of the original file size.

1559
01:30:07,600 --> 01:30:09,500
The output file size, was, I believe.

1560
01:30:09,500 --> 01:30:12,600
So, it's like the compressed over the uncompressed is, I believe how

1561
01:30:12,600 --> 01:30:16,600
they typically are stated again, not a compression person.

1562
01:30:16,600 --> 01:30:18,000
So, I don't really

1563
01:30:20,000 --> 01:30:23,300
I don't really want to suggest that that's for sure.

1564
01:30:23,300 --> 01:30:24,100
But, you know,

1565
01:30:25,600 --> 01:30:26,700
I believe that's how it is.

1566
01:30:28,100 --> 01:30:30,400
So we'll do a numerator and a denominator here on this.

1567
01:30:30,800 --> 01:30:34,100
And so we want to do is we want to say like if the denominator is not

1568
01:30:34,100 --> 01:30:38,600
0 because we can't do a divide if it is 0, then what we're going to do

1569
01:30:38,700 --> 01:30:42,500
is return an actual valid results.

1570
01:30:44,200 --> 01:30:45,400
Otherwise, we'll return 0.

1571
01:30:49,000 --> 01:30:52,900
So in this case, we'll say numerator over denominator off the go, we

1572
01:30:52,900 --> 01:30:55,500
are actually, where are we on the timeline?

1573
01:30:55,500 --> 01:30:56,000
I don't even know.

1574
01:30:56,000 --> 01:30:58,900
We're probably just about done but either way.

1575
01:31:08,000 --> 01:31:10,800
Okay, let's see.

1576
01:31:11,100 --> 01:31:12,700
Actually wanted that to be that way.

1577
01:31:18,300 --> 01:31:25,000
Okay, so that gives us a way to start printing out our stats.

1578
01:31:25,000 --> 01:31:30,500
Now, for each of these stats, whatever the stats are here, we don't

1579
01:31:30,500 --> 01:31:36,000
really have a whole lot in the way of sort of ways of looking at this,

1580
01:31:36,000 --> 01:31:38,200
this data necessarily.

1581
01:31:38,200 --> 01:31:42,800
But so, for the first thing I'm going to do, I'm just going to print

1582
01:31:42,800 --> 01:31:45,500
out what they are and then we'll start to think about what we want to

1583
01:31:45,500 --> 01:31:46,400
actually output.

1584
01:31:46,400 --> 01:31:48,200
In fact, what I should probably do is

1585
01:31:49,700 --> 01:31:50,200
Okay.

1586
01:31:51,400 --> 01:31:56,200
Out of the total, certain ones of these out of the totals of what they

1587
01:31:56,200 --> 01:31:56,800
were.

1588
01:31:57,800 --> 01:32:01,400
You know, we would want to sort of have internal summing, right?

1589
01:32:01,400 --> 01:32:04,100
And, you know, I guess we don't really have a good way of

1590
01:32:06,700 --> 01:32:07,700
About putting that stuff.

1591
01:32:07,700 --> 01:32:10,400
So we'll sort of start with something basic and then we'll see.

1592
01:32:10,400 --> 01:32:13,600
Maybe if people wanted to improve the Stat system, they could do that

1593
01:32:13,600 --> 01:32:14,000
as well.

1594
01:32:14,800 --> 01:32:16,400
Alright, so inside print stats.

1595
01:32:16,400 --> 01:32:20,500
Let's just do the basic thing which is to say for every stat will just

1596
01:32:20,500 --> 01:32:21,800
output what it actually is.

1597
01:32:33,900 --> 01:32:37,200
So, here's our stat count and here's our stat.

1598
01:32:43,200 --> 01:32:43,600
Total.

1599
01:32:45,600 --> 01:32:50,200
And then all I really want to do here is introduced and these can kind

1600
01:32:50,200 --> 01:32:51,100
of come down now.

1601
01:33:01,200 --> 01:33:06,700
All I really want to do here is introduce an idea of, you know, an

1602
01:33:06,700 --> 01:33:08,100
increment for the stat.

1603
01:33:09,000 --> 01:33:15,100
So, you know, if we have a stack group and we have a stat type and

1604
01:33:15,100 --> 01:33:16,400
then we have a value

1605
01:33:18,700 --> 01:33:22,800
Then all that's going to do is say hey whatever our stat is that we're

1606
01:33:22,800 --> 01:33:24,400
trying to increment here.

1607
01:33:26,200 --> 01:33:32,700
We want to increment the count for that and then add to the value.

1608
01:33:35,700 --> 01:33:39,200
So this lets us know how many times you recorded something, and then

1609
01:33:39,200 --> 01:33:40,600
what we recorded, right?

1610
01:33:40,900 --> 01:33:43,500
And so now that I think about it, that actually allows us to say,

1611
01:33:44,000 --> 01:33:50,500
literal, repeat and copy are all, actually, we really need at the

1612
01:33:50,500 --> 01:33:53,500
moment, because I think that's the only things that we actually care

1613
01:33:53,500 --> 01:33:54,100
about their.

1614
01:33:55,100 --> 01:33:57,600
So let's go ahead and do it that way.

1615
01:33:57,600 --> 01:33:59,500
We'll just pretend that that's good.

1616
01:34:00,100 --> 01:34:02,600
So, let's go ahead and put our increment in here.

1617
01:34:03,800 --> 01:34:07,500
So, let's take a look at our compressor for our compressor.

1618
01:34:07,500 --> 01:34:13,100
Now, we can sort of say like OK, we can now actually record these

1619
01:34:13,500 --> 01:34:14,900
things that we're talking about.

1620
01:34:15,200 --> 01:34:19,700
So we could say increment stats and then whatever our status that we

1621
01:34:19,700 --> 01:34:21,000
want, and then whatever it is.

1622
01:34:21,000 --> 01:34:23,900
So, in this case, we've got a literal count, right?

1623
01:34:24,900 --> 01:34:28,800
And we can say literal, we've got a run, right stat.

1624
01:34:36,600 --> 01:34:38,800
So, and you know what?

1625
01:34:39,000 --> 01:34:40,000
It occurs to me.

1626
01:34:40,000 --> 01:34:45,900
Also that there is one thing in here that I think we're not doing

1627
01:34:45,900 --> 01:34:46,600
quite right.

1628
01:34:46,600 --> 01:34:55,500
I should point out that basically like we have to do we have to Output

1629
01:34:55,500 --> 01:34:57,900
a final like this little clip off the end.

1630
01:34:58,300 --> 01:35:00,700
So we have to kind of input a thing here as well.

1631
01:35:00,700 --> 01:35:06,100
That's like, hey, if this is the last thing that we're going to do

1632
01:35:06,300 --> 01:35:09,900
Like if n plus 1 equals in, and we have to flush, right?

1633
01:35:10,300 --> 01:35:13,700
Meaning, if n plus 1 equals in end,

1634
01:35:18,600 --> 01:35:21,700
Like if we're at the end of the buffer, so there's nothing left to do,

1635
01:35:22,500 --> 01:35:26,100
we need to flush the literals out that we have, right?

1636
01:35:26,400 --> 01:35:27,800
So we should put in a search here.

1637
01:35:27,800 --> 01:35:33,400
That like literal count is 0 because otherwise, we forgot a few bites

1638
01:35:33,400 --> 01:35:34,900
at the end of the file, right?

1639
01:35:35,700 --> 01:35:37,200
And the same would be true of this one.

1640
01:35:37,200 --> 01:35:38,500
So output run.

1641
01:35:38,500 --> 01:35:43,900
In this case, you know, in terms of the flushing and so on.

1642
01:35:50,000 --> 01:35:52,000
It's fine, but we need to do the same check.

1643
01:35:52,300 --> 01:35:56,200
So here we need to say like, okay, if

1644
01:35:57,900 --> 01:35:59,800
The next one is the end there.

1645
01:36:00,000 --> 01:36:03,000
Nothing if there's nothing else Beyond it.

1646
01:36:03,800 --> 01:36:06,000
Then we would need to to do it.

1647
01:36:06,000 --> 01:36:08,800
And I guess, you know, nothing about that's not quite right either.

1648
01:36:10,700 --> 01:36:14,200
In that case, we haven't necessarily pushed the literal into the

1649
01:36:14,200 --> 01:36:14,800
buffer.

1650
01:36:16,900 --> 01:36:20,600
So I guess really, the way to look at it is more like if it's the last

1651
01:36:20,600 --> 01:36:22,000
one, right?

1652
01:36:22,000 --> 01:36:27,500
Like if we're on the very last one, then we need to flush and we only

1653
01:36:27,500 --> 01:36:30,100
check for runs in that case.

1654
01:36:30,100 --> 01:36:32,400
So this is more like that, right?

1655
01:36:37,500 --> 01:36:40,800
And I think that should all work because these should all be zeros so

1656
01:36:40,800 --> 01:36:41,800
it should be fine.

1657
01:36:41,800 --> 01:36:44,200
I think famous last words, right?

1658
01:36:45,700 --> 01:36:51,800
but I think that's fine, so we should be able to say I'll go back and

1659
01:36:51,800 --> 01:36:56,900
double-check that as we should be able to say while it's just

1660
01:36:58,400 --> 01:36:59,400
Less than or equal to.

1661
01:37:00,800 --> 01:37:04,500
When we come through here we can say like okay if

1662
01:37:06,100 --> 01:37:08,800
We're on the last one, then go ahead and do it.

1663
01:37:09,500 --> 01:37:12,300
And in this case, let's see the windows started from looked back and

1664
01:37:12,300 --> 01:37:15,500
then that's going to start, so it should be.

1665
01:37:15,500 --> 01:37:18,000
Yeah, I mean, I think all that should work just fine.

1666
01:37:18,500 --> 01:37:21,200
I believe that we should double-check that obviously.

1667
01:37:22,000 --> 01:37:23,700
All right, so

1668
01:37:29,000 --> 01:37:30,600
Let's go ahead and clean this up here.

1669
01:37:32,000 --> 01:37:33,900
Syntax error.

1670
01:37:35,200 --> 01:37:36,300
What is the syntax error?

1671
01:37:36,300 --> 01:37:39,100
Missing semicolon before.

1672
01:37:39,100 --> 01:37:40,600
Okay set?

1673
01:37:44,700 --> 01:37:45,100
There we go.

1674
01:37:47,700 --> 01:37:49,200
All right, so I'm not quite sure.

1675
01:37:49,200 --> 01:37:52,900
We got all that in there yet, but let's, let's just do one more here.

1676
01:37:52,900 --> 01:37:58,400
Let's do a test of the rle compressor first and see if that works,

1677
01:38:00,200 --> 01:38:02,200
retry break.

1678
01:38:09,100 --> 01:38:12,100
so in this case, I feel like

1679
01:38:15,200 --> 01:38:20,000
Yeah, so run in this case because it equals one will still increment.

1680
01:38:20,000 --> 01:38:24,200
The in pointer, which we don't want for our assertion doesn't actually

1681
01:38:24,500 --> 01:38:26,300
cause a real problem.

1682
01:38:29,200 --> 01:38:30,200
But yeah.

1683
01:38:30,200 --> 01:38:32,600
So if you look through here, right, our run,

1684
01:38:34,800 --> 01:38:39,200
Are running code needs to be slightly a little a little bit smarter,

1685
01:38:39,600 --> 01:38:40,000
right?

1686
01:38:40,100 --> 01:38:42,500
So we want to actually start it like this.

1687
01:38:46,100 --> 01:38:49,900
And actually make it do that copy from the initial one if that makes

1688
01:38:49,900 --> 01:38:49,900
sense.

1689
01:38:49,900 --> 01:38:56,400
Because that way that way we won't actually get a run in that case.

1690
01:38:56,400 --> 01:38:59,700
So when we output this run here, this would be

1691
01:39:00,200 --> 01:39:04,300
And an output of 0, I guess, for flushing the buffer.

1692
01:39:20,200 --> 01:39:23,500
Yeah, I'm not sure this this is this is just a touchy thing to get

1693
01:39:23,500 --> 01:39:28,900
right because there should be a more cleaner way of an easier way of

1694
01:39:28,900 --> 01:39:30,000
sort of getting it.

1695
01:39:32,800 --> 01:39:33,500
Flushable here.

1696
01:39:33,500 --> 01:39:37,000
Because again, starting value is going to be an invalid value here, if

1697
01:39:37,000 --> 01:39:37,900
that's the case.

1698
01:39:38,500 --> 01:39:41,600
So when it actually goes to Output the run, which it always has to do.

1699
01:39:41,600 --> 01:39:42,900
If there was a literal,

1700
01:39:45,900 --> 01:39:46,500
Right?

1701
01:39:47,500 --> 01:39:50,600
I'm not sure how we get that workout, right?

1702
01:39:50,600 --> 01:39:53,400
It you don't well I guess it doesn't really matter because it's zero

1703
01:39:53,600 --> 01:39:54,600
so I suppose that's fine.

1704
01:39:55,400 --> 01:39:58,100
The fact that it reads, one off the end of the buffer isn't

1705
01:39:58,100 --> 01:39:59,700
necessarily A Bad Thing.

1706
01:40:03,700 --> 01:40:05,100
You know, but we could do this.

1707
01:40:11,700 --> 01:40:13,300
Or something like that, right?

1708
01:40:14,800 --> 01:40:16,900
Well, that would work either.

1709
01:40:28,900 --> 01:40:30,000
Just kind of ugly is all.

1710
01:40:31,500 --> 01:40:33,700
But handling that end I'll have to see if there's maybe there's a

1711
01:40:33,700 --> 01:40:35,400
better way to handle that end than that.

1712
01:40:47,900 --> 01:40:48,300
Yeah.

1713
01:40:53,800 --> 01:40:56,200
Okay, so let's take a look at this.

1714
01:40:56,200 --> 01:41:01,100
So when we come through here, I kind of want to see, I guess it's a

1715
01:41:01,100 --> 01:41:04,400
little bit hard for me to look at the case that I want.

1716
01:41:04,400 --> 01:41:06,100
So what I might do is just put a little

1717
01:41:21,100 --> 01:41:22,000
So let's break here.

1718
01:41:22,500 --> 01:41:26,800
So if we go in equals an end, then we know that we've actually got the

1719
01:41:26,800 --> 01:41:27,300
end of the buffer.

1720
01:41:27,300 --> 01:41:29,900
So in this case, I want my starting value to be 0, which it is.

1721
01:41:29,900 --> 01:41:31,200
So I don't read off the end.

1722
01:41:31,800 --> 01:41:34,600
My run is also zero because it's not going to go anywhere in here.

1723
01:41:34,600 --> 01:41:37,300
And then I'm going to come through here and do my output, right?

1724
01:41:38,400 --> 01:41:40,900
So, I'm at putting a literal count of however, much is left in the

1725
01:41:40,900 --> 01:41:41,100
buffer.

1726
01:41:41,100 --> 01:41:43,300
There are no literals in the buffer at the moment.

1727
01:41:43,300 --> 01:41:48,500
So, I guess it had been flushed previously, which is a little odd.

1728
01:41:48,500 --> 01:41:49,600
I'm not sure why.

1729
01:41:49,700 --> 01:41:52,200
Likely, it would have been flushed necessarily I guess because we

1730
01:41:52,200 --> 01:41:54,400
ended with a run, which is handy.

1731
01:41:54,900 --> 01:41:56,300
So we get the literal count.

1732
01:41:56,800 --> 01:41:59,500
We take a look at the the run count, we output it.

1733
01:42:00,000 --> 01:42:05,600
And we output the that final value, we then don't go forwards at all.

1734
01:42:05,900 --> 01:42:07,700
Oh, right.

1735
01:42:07,900 --> 01:42:11,700
We actually would have to break as well at the end of this, right?

1736
01:42:12,600 --> 01:42:17,200
We have to actually stop on in equals end.

1737
01:42:27,900 --> 01:42:29,200
So yeah not great.

1738
01:42:29,200 --> 01:42:31,900
I feel like we could probably code that more concisely.

1739
01:42:32,100 --> 01:42:34,500
That's one of those things that tends to be harder at least for me to

1740
01:42:34,500 --> 01:42:37,800
do on stream because I need to think it through and it's hard to talk

1741
01:42:37,800 --> 01:42:40,900
while you're necessarily doing that in terms of like fiddly, things

1742
01:42:40,900 --> 01:42:41,300
like that.

1743
01:42:41,300 --> 01:42:43,300
But usually that doesn't it being the case.

1744
01:42:43,300 --> 01:42:46,700
In this case, where we have a situation here, the same is true with

1745
01:42:46,700 --> 01:42:48,900
the LZ encoder where we're looking at these guys.

1746
01:42:49,500 --> 01:42:51,700
We would we would also need to do

1747
01:42:54,000 --> 01:42:57,500
I break to get out of the loop, so yeah.

1748
01:43:00,000 --> 01:43:03,700
Alright, so here is the here.

1749
01:43:03,700 --> 01:43:05,500
Is it doing the rlz test?

1750
01:43:05,900 --> 01:43:07,700
Let's take a look at what happens here.

1751
01:43:08,300 --> 01:43:09,200
Looks like it succeeds.

1752
01:43:09,200 --> 01:43:09,700
Okay.

1753
01:43:10,400 --> 01:43:12,500
Which means we get the same data out in both cases.

1754
01:43:13,900 --> 01:43:14,900
So that's all good.

1755
01:43:15,900 --> 01:43:18,200
And now let's actually call our print stats routine.

1756
01:43:21,800 --> 01:43:25,600
So at the end of here, we just do our print stats.

1757
01:43:30,400 --> 01:43:31,900
So now those will get outputted.

1758
01:43:33,000 --> 01:43:36,900
And when we, what I want to do here is when we actually record the

1759
01:43:36,900 --> 01:43:39,800
stats, I'd like to record the input size in the output size.

1760
01:43:40,200 --> 01:43:45,400
So when we do like a compress here, I want to do like stats

1761
01:43:45,500 --> 01:43:49,400
uncompressed, B, stats compressed B.

1762
01:43:51,200 --> 01:43:51,600
Oops.

1763
01:44:06,000 --> 01:44:10,500
And so, you know, the uncompressed B is the in file file size, right?

1764
01:44:10,500 --> 01:44:13,100
And the compressed B is the compressed size.

1765
01:44:13,600 --> 01:44:17,600
And these two cases, and we won't look at the plus four for the, the

1766
01:44:17,600 --> 01:44:19,000
size recording at the moment.

1767
01:44:19,000 --> 01:44:23,300
We'll just leave that out of there and the same.

1768
01:44:23,300 --> 01:44:25,000
We would do the same thing in here.

1769
01:44:29,600 --> 01:44:31,300
And I think that's really all we need.

1770
01:44:32,000 --> 01:44:33,200
That's Dot.

1771
01:44:39,200 --> 01:44:43,100
So now when we call one of these at least in theory, if we do a

1772
01:44:43,100 --> 01:44:46,100
compress, we should oops.

1773
01:44:46,300 --> 01:44:48,300
We should be able to take a look at that.

1774
01:44:48,300 --> 01:44:49,100
What's going on here?

1775
01:44:49,100 --> 01:44:51,900
Okay, so clean up a couple things.

1776
01:44:52,100 --> 01:44:56,100
In our words, our staff princess.

1777
01:45:02,200 --> 01:45:05,600
So yeah, one thing I forgot to in our percentage is multiplied by 100.

1778
01:45:07,600 --> 01:45:07,800
Right?

1779
01:45:07,800 --> 01:45:12,200
Because typically percentages are printed out times 100 so we got to

1780
01:45:12,200 --> 01:45:17,900
multiply it by 100 and here right we forgot to print out the name name

1781
01:45:18,400 --> 01:45:20,200
but then I think we're probably done.

1782
01:45:25,000 --> 01:45:27,100
Sorry, gets that name, right?

1783
01:45:28,900 --> 01:45:33,400
Gets to next.

1784
01:45:35,400 --> 01:45:35,900
All right.

1785
01:45:40,000 --> 01:45:42,900
So in theory, now we can actually get a little bit of visibility into

1786
01:45:42,900 --> 01:45:48,600
what was going on, so you can kind of see for the rle compressor for

1787
01:45:48,600 --> 01:45:50,000
the literals and repeats.

1788
01:45:50,000 --> 01:45:54,400
You can see how many repeats it did versus, how many little is it did?

1789
01:45:54,400 --> 01:45:59,000
And hey, you know, the two are exactly the same in terms of how many,

1790
01:45:59,000 --> 01:46:02,300
that's because the rle compressor is an alternating one, right?

1791
01:46:02,300 --> 01:46:06,100
So, it has to be the same of each one, but the bite counts are very

1792
01:46:06,100 --> 01:46:09,400
different so it encoded 153 K worth.

1793
01:46:09,600 --> 01:46:16,100
Of literals but it encoded one point three Meg's worth of repeating

1794
01:46:16,100 --> 01:46:17,100
characters, right?

1795
01:46:17,200 --> 01:46:21,100
And that's why we got such a good compression ratio here, right,

1796
01:46:21,200 --> 01:46:28,200
because most of the file consists of repeats, let's try the LZ version

1797
01:46:28,400 --> 01:46:29,800
and see what it says.

1798
01:46:29,800 --> 01:46:34,900
Oh well of course I have to actually put in the stat counts there.

1799
01:46:38,500 --> 01:46:40,100
So here's our LZ.

1800
01:46:41,500 --> 01:46:48,100
version and when it comes through, when it does, it's flush here, will

1801
01:46:48,100 --> 01:46:49,000
say okay,

1802
01:46:56,000 --> 01:46:57,400
Here's the literal count.

1803
01:46:57,700 --> 01:47:00,900
Here's the best run.

1804
01:47:04,700 --> 01:47:05,200
Right?

1805
01:47:06,200 --> 01:47:11,500
And what we could do is in addition we could say here like hey you

1806
01:47:11,500 --> 01:47:12,900
know, if the

1807
01:47:17,100 --> 01:47:18,600
If the distance.

1808
01:47:28,700 --> 01:47:29,600
That we're doing.

1809
01:47:30,800 --> 01:47:31,500
Is.

1810
01:47:32,900 --> 01:47:34,500
Less than the run count.

1811
01:47:34,600 --> 01:47:36,500
This is a copy, right?

1812
01:47:37,100 --> 01:47:42,500
So I'm sorry, then it's a repeat, otherwise it's a copy, right?

1813
01:47:42,500 --> 01:47:45,800
Because that's that was like how we were doing our Ali inside the LZ.

1814
01:47:46,100 --> 01:47:51,600
So if the best distance in this case is greater than the best run.

1815
01:47:54,400 --> 01:47:55,400
Or equal to it.

1816
01:47:56,300 --> 01:47:59,500
Then it's a copy but otherwise it's a repeat.

1817
01:48:02,400 --> 01:48:05,900
And it's a repeat of that of whatever that length is right?

1818
01:48:07,600 --> 01:48:11,300
So yeah, let's let's see how what that will tell us.

1819
01:48:12,600 --> 01:48:13,300
So, here you go.

1820
01:48:13,300 --> 01:48:17,900
So it looks like here's how many bytes we encoded as basically reps.

1821
01:48:17,900 --> 01:48:21,400
Here is how many we encode it as like look backs, but that didn't rep

1822
01:48:22,100 --> 01:48:22,400
assume.

1823
01:48:22,400 --> 01:48:23,300
I got this right?

1824
01:48:23,300 --> 01:48:25,600
If the best is no, I'd this is backwards.

1825
01:48:29,900 --> 01:48:30,400
There we go.

1826
01:48:32,100 --> 01:48:32,200
Right?

1827
01:48:32,200 --> 01:48:34,800
Because if it's greater, if the distance.

1828
01:48:35,200 --> 01:48:36,600
Wait, no no, I did it right.

1829
01:48:39,200 --> 01:48:42,200
If the distance is greater than the Run size than it is a copy.

1830
01:48:42,200 --> 01:48:42,500
Yeah.

1831
01:48:47,200 --> 01:48:48,000
So there we go.

1832
01:48:48,000 --> 01:48:53,200
That's a little surprising to me actually because I'm surprised that

1833
01:48:53,200 --> 01:48:57,000
it encoded so many things as copies that were not reps.

1834
01:48:57,900 --> 01:49:04,700
But that looks like the case am I sure I didn't get that wrong the

1835
01:49:04,700 --> 01:49:05,800
best distance.

1836
01:49:06,300 --> 01:49:09,800
That's how far back we're going if it's greater than equal to the run.

1837
01:49:10,600 --> 01:49:12,500
Then yeah then you wouldn't be repeating.

1838
01:49:14,000 --> 01:49:15,300
So that would be a copy.

1839
01:49:18,200 --> 01:49:19,400
That's that was surprising to me.

1840
01:49:19,400 --> 01:49:21,500
I would not have expected that but I guess that's the case.

1841
01:49:23,000 --> 01:49:23,700
So

1842
01:49:29,700 --> 01:49:34,900
For the sake of argument or slight edification.

1843
01:49:34,900 --> 01:49:40,300
I suppose let's also verify that we can do test here.

1844
01:49:48,700 --> 01:49:54,200
There's our our success and let's see the LZ passes as well also.

1845
01:49:55,900 --> 01:50:01,900
And we'll do our intro art HHA with our Ellie.

1846
01:50:04,200 --> 01:50:06,300
Just to see again, what those numbers are.

1847
01:50:08,200 --> 01:50:10,900
And while we're running the old l z.

1848
01:50:13,900 --> 01:50:14,200
Kind of.

1849
01:50:14,200 --> 01:50:16,100
See, that's where again all the questions.

1850
01:50:16,100 --> 01:50:18,600
Well, we're running our LZ on that.

1851
01:50:18,600 --> 01:50:19,800
Which I was, he takes a while.

1852
01:50:21,900 --> 01:50:23,000
Let's go ahead and go to the Q&A.

1853
01:51:05,200 --> 01:51:06,400
Let's see.

1854
01:51:32,300 --> 01:51:34,300
Looks like there are no questions.

1855
01:51:38,800 --> 01:51:40,200
That will make answering them easy.

1856
01:51:51,700 --> 01:51:55,100
Blow says, I think I followed it, but definitely want to re-watch

1857
01:51:55,600 --> 01:51:56,500
during and after granting.

1858
01:51:56,500 --> 01:51:57,200
All right.

1859
01:52:04,000 --> 01:52:07,300
Forgive me if this information was somehow implicit in today's lecture

1860
01:52:07,300 --> 01:52:10,400
and I missed it, but is compression.

1861
01:52:11,900 --> 01:52:15,200
Ever used for locality wins.

1862
01:52:23,500 --> 01:52:30,800
I guess I don't know what a locality win is but yeah, I'm not sure.

1863
01:52:35,200 --> 01:52:38,400
I'm sorry, I don't think, I know what a locality when is in this case?

1864
01:52:38,700 --> 01:52:41,400
I mean, I could guess, but I'm not sure, I know what you're referring

1865
01:52:41,400 --> 01:52:41,800
to.

1866
01:52:43,500 --> 01:52:46,200
Do you know offhand, what kind of compression ratio and decompression

1867
01:52:46,200 --> 01:52:49,200
speed or needed before it's faster to load compressed data and

1868
01:52:49,200 --> 01:52:52,700
decompress overloading decompressed data the answer, is it entirely

1869
01:52:52,700 --> 01:52:56,200
depends on your backing Store Speed.

1870
01:52:56,700 --> 01:53:05,100
So, if the thing you're loading from is very slow, then you may get a

1871
01:53:05,100 --> 01:53:07,400
win from any compression at all, right?

1872
01:53:07,400 --> 01:53:10,200
Like if you're loading from a really bad hard drive like, you know,

1873
01:53:10,200 --> 01:53:12,300
maybe something like a PS4 hard drive.

1874
01:53:12,300 --> 01:53:13,100
That's really slow.

1875
01:53:15,100 --> 01:53:20,600
Old-school 5200 RPM kind of style hard drive, then you may get a lot

1876
01:53:20,600 --> 01:53:22,600
of wind out of it, right?

1877
01:53:23,500 --> 01:53:29,500
However, if you're talking about a really fast SSD, or the upcoming

1878
01:53:29,500 --> 01:53:38,600
xpoint stuff, those sorts of things, then, you know, it's the

1879
01:53:38,600 --> 01:53:40,500
compression is going to be a lot less effective.

1880
01:53:41,100 --> 01:53:41,700
Right.

1881
01:53:42,100 --> 01:53:46,900
So it really depends on how slow like how much compression you need

1882
01:53:46,900 --> 01:53:47,700
for it to be a win.

1883
01:53:47,700 --> 01:53:54,700
In terms of IO is really all about how fast the io is right.

1884
01:54:02,300 --> 01:54:05,700
Neal says in types and pure I, you 64 is probably what you're supposed

1885
01:54:05,700 --> 01:54:07,400
to do for % LL.

1886
01:54:07,400 --> 01:54:10,000
You search for print test.

1887
01:54:10,000 --> 01:54:14,200
Yeah, but that is so variable, like it was, which compiler are you on?

1888
01:54:14,200 --> 01:54:14,500
Did this?

1889
01:54:14,900 --> 01:54:17,300
Does it have a newer version of the CRT, and all that stuff?

1890
01:54:17,300 --> 01:54:19,300
So, I just find, like, printing it out with float.

1891
01:54:19,500 --> 01:54:20,300
Always works.

1892
01:54:20,300 --> 01:54:22,500
So, just do that, you know.

1893
01:54:24,900 --> 01:54:29,300
The only time that you really can't is if you really are using all 64

1894
01:54:29,300 --> 01:54:33,100
bits of the 64-bit value because then the float will lose a little bit

1895
01:54:33,100 --> 01:54:33,900
of it, right?

1896
01:54:34,000 --> 01:54:36,800
Because the double-doubles only 64-bit itself.

1897
01:54:38,400 --> 01:54:41,100
Do you still have to uncompress your images for display?

1898
01:54:41,300 --> 01:54:43,800
So do you have plans for using block compression?

1899
01:54:44,400 --> 01:54:48,600
No, we don't have to worry about that because we're only using whole

1900
01:54:48,600 --> 01:54:49,700
images at a time.

1901
01:54:53,200 --> 01:54:56,400
So we only need to I mean I guess if you're saying when we compress

1902
01:54:56,400 --> 01:54:59,900
images individually, the answer is yes because we want to load only

1903
01:55:00,000 --> 01:55:01,400
the images we actually need.

1904
01:55:02,100 --> 01:55:06,300
So that's definitely the case, but we don't need block impression like

1905
01:55:06,300 --> 01:55:09,700
8, by 8 block compression or anything like that, if that makes sense.

1906
01:55:16,600 --> 01:55:18,800
Okay, I see what you're asking now.

1907
01:55:18,800 --> 01:55:21,700
Okay, so the question before us from forgive me, this information with

1908
01:55:21,700 --> 01:55:23,500
some implicit in today's lecture and I missed it.

1909
01:55:23,600 --> 01:55:25,800
But it's compression ever used for locality wins.

1910
01:55:26,300 --> 01:55:29,200
And what he was talking about is he means like better usage of the

1911
01:55:29,200 --> 01:55:30,000
cash.

1912
01:55:31,200 --> 01:55:37,800
The answer is, I don't think I have ever done that, but I suppose

1913
01:55:37,800 --> 01:55:39,300
somebody probably has

1914
01:55:43,100 --> 01:55:44,100
Really hard to say.

1915
01:55:44,200 --> 01:55:49,200
I mean, again, I'm sure there are cases when it could happen, right?

1916
01:55:51,800 --> 01:55:55,900
I just, I can't think of a time where I specifically had any

1917
01:55:55,900 --> 01:56:00,500
experience with that myself, but yeah.

1918
01:56:02,400 --> 01:56:06,200
Sorry, I do not know the case off hand but it certainly could happen.

1919
01:56:07,500 --> 01:56:11,600
The problem is just that you know compression is kind of slow like

1920
01:56:11,600 --> 01:56:17,300
even very very fast D compressors are still not that fast so you know

1921
01:56:17,700 --> 01:56:22,500
cat the cash isn't that slow filling?

1922
01:56:22,500 --> 01:56:23,600
The cash isn't that slow?

1923
01:56:23,600 --> 01:56:24,200
So

1924
01:56:25,500 --> 01:56:26,700
It's tough, right?

1925
01:56:26,700 --> 01:56:30,800
It's tough to beat memory speed with it with a decompressor in that

1926
01:56:30,800 --> 01:56:31,300
way.

1927
01:56:35,900 --> 01:56:39,800
And streaming is like, the best case for filling the cash, right?

1928
01:56:40,300 --> 01:56:43,900
Intel chips are really good at knowing that you're like, reading a big

1929
01:56:43,900 --> 01:56:47,100
chunk of memory in and out putting a chunk of memory, so you're

1930
01:56:47,100 --> 01:56:49,700
actually going up against probably the best place.

1931
01:56:51,900 --> 01:56:56,600
You know, in terms of Origins, the best place, the the case that it's

1932
01:56:56,600 --> 01:56:59,800
best made to work with because you can issue

1933
01:57:00,000 --> 01:57:00,800
Stuff like that.

1934
01:57:01,100 --> 01:57:02,700
So it's kind of hard to.

1935
01:57:03,700 --> 01:57:04,500
Yeah, it's tough.

1936
01:57:05,200 --> 01:57:06,300
I would say it's probably tough.

1937
01:57:09,500 --> 01:57:10,200
MTS mocks.

1938
01:57:10,200 --> 01:57:13,300
Why is 225 not a good look back limit for images, you want to

1939
01:57:13,300 --> 01:57:13,900
elaborate on that.

1940
01:57:13,900 --> 01:57:15,200
Yes, thank you for reminding me.

1941
01:57:15,700 --> 01:57:18,300
The reason that I was saying that you probably want for image

1942
01:57:18,300 --> 01:57:20,800
compression, you want to expand Beyond 55?

1943
01:57:21,400 --> 01:57:27,300
It is because most images are longer than 255, bytes per row.

1944
01:57:27,700 --> 01:57:32,000
And often times you're going to copy stuff from a previous row to the

1945
01:57:32,000 --> 01:57:36,400
next row, if there's a duplicated, like, little bit of the image that

1946
01:57:36,400 --> 01:57:37,200
might be similar.

1947
01:57:37,900 --> 01:57:38,400
So if you can

1948
01:57:38,600 --> 01:57:39,900
Only look back to 55.

1949
01:57:39,900 --> 01:57:43,800
You probably can't get back to the same location on the row.

1950
01:57:44,300 --> 01:57:45,800
Like to give you an example.

1951
01:57:47,700 --> 01:57:48,200
Suppose.

1952
01:57:48,200 --> 01:57:49,700
This is my image right?

1953
01:57:50,100 --> 01:57:54,500
And my image is 256 by 256, right?

1954
01:57:54,700 --> 01:57:58,700
And I've got a thing that's like, oh cures, you know, a line in the

1955
01:57:58,700 --> 01:58:01,900
image, and then there's another line here and then it's here, right?

1956
01:58:02,000 --> 01:58:05,400
And then on the next row down, it looks almost the same as that,

1957
01:58:05,400 --> 01:58:06,000
right?

1958
01:58:06,400 --> 01:58:07,400
But shift it a little

1959
01:58:10,900 --> 01:58:15,300
You can see how maybe like this could get a whole copy and put it

1960
01:58:15,300 --> 01:58:17,000
right here, right?

1961
01:58:17,300 --> 01:58:21,900
Because it's exactly the same, let's say, but if it's 256, and 256,

1962
01:58:22,200 --> 01:58:22,800
right?

1963
01:58:23,700 --> 01:58:26,800
Well, District, this one doesn't matter, but if it's 256 long, well,

1964
01:58:26,800 --> 01:58:32,600
256 pixels x 4, bytes, per pixel, right?

1965
01:58:32,900 --> 01:58:35,800
Means that we've got 1024 bytes per row,

1966
01:58:37,300 --> 01:58:37,800
Right?

1967
01:58:38,000 --> 01:58:40,700
So there's no way a 255 look back.

1968
01:58:40,700 --> 01:58:43,900
Window is going to get all the way back to here, because that's a

1969
01:58:43,900 --> 01:58:46,400
little more than a 1024 look back already.

1970
01:58:47,300 --> 01:58:51,500
So, typically you want a 16-bit look back window for images or

1971
01:58:51,500 --> 01:58:54,800
something in those ranges, because in order to get back to the

1972
01:58:54,800 --> 01:58:58,800
previous rows, you're going to have to go back that far for a text

1973
01:58:58,800 --> 01:59:00,500
compressor that may not be true.

1974
01:59:00,700 --> 01:59:05,200
25 might be a good idea for text compressor for all I know, but for

1975
01:59:05,200 --> 01:59:07,000
image data it's not a great idea.

1976
01:59:15,200 --> 01:59:17,000
See, if there's any other things on compression.

1977
01:59:22,700 --> 01:59:25,400
Have you ever heard of random seed data compression?

1978
01:59:26,400 --> 01:59:29,300
No but that's not surprising because I don't do compression.

1979
01:59:29,700 --> 01:59:34,300
So there's most most things that involve compression.

1980
01:59:34,300 --> 01:59:36,800
I will not have heard of if that makes sense.

1981
01:59:38,600 --> 01:59:40,500
I see if there's any more compression questions.

1982
01:59:46,400 --> 01:59:49,200
Probably more of Jeff and fabian's territory.

1983
01:59:49,200 --> 01:59:52,000
But is there generally such a thing as a compressor that compresses a

1984
01:59:52,000 --> 01:59:57,100
lot and fast with some rad compressor, leave 10% of initial size and

1985
01:59:57,100 --> 01:59:57,400
considerably.

1986
01:59:57,400 --> 01:59:59,900
Faster than LG, I guess bank is hyper fast, isn't it?

1987
02:00:00,000 --> 02:00:01,800
Like live decompression or something.

1988
02:00:04,500 --> 02:00:10,000
Well I guess what I would say is yes, oh there is compressors.

1989
02:00:10,000 --> 02:00:15,700
That can press a lot in fast, the rad sells a product called doodle

1990
02:00:15,700 --> 02:00:19,300
which is all those compressors basically and they actually are the

1991
02:00:19,300 --> 02:00:25,600
first people that I know of at all who shipped a compressor that is

1992
02:00:25,600 --> 02:00:30,700
smaller, that typically produces smaller output sizes and typically

1993
02:00:30,700 --> 02:00:34,100
runs faster than lzn.

1994
02:00:34,100 --> 02:00:34,100
A

1995
02:00:34,600 --> 02:00:35,500
Lzma right.

1996
02:00:35,500 --> 02:00:40,600
They did a thing called lzn a which is significantly faster but

1997
02:00:40,700 --> 02:00:43,500
oftentimes as small or smaller than 7-Zip.

1998
02:00:45,300 --> 02:00:50,100
So yes the rad compressors are best in class I guess at this point and

1999
02:00:50,100 --> 02:00:54,300
they've got all kinds of compressors that are super crazy in that way.

2000
02:00:59,800 --> 02:01:05,100
IEEE 754 I meant block compression that's GPU supported like be C1 C1

2001
02:01:05,100 --> 02:01:06,000
through C7.

2002
02:01:06,200 --> 02:01:08,300
You upload the compressed images, you pu and Hardware decodes, it was

2003
02:01:08,300 --> 02:01:08,800
sampled.

2004
02:01:08,900 --> 02:01:09,200
Yes.

2005
02:01:09,200 --> 02:01:12,700
So I talked about this before, I don't like those compressors at all

2006
02:01:12,900 --> 02:01:17,100
because they're lossy and when you're doing it, 2D art in my opinion,

2007
02:01:17,100 --> 02:01:22,000
I really care about the quality of the 2D art so I don't like using

2008
02:01:22,000 --> 02:01:27,200
GPU compression because it degrades the quality of the image right in

2009
02:01:27,200 --> 02:01:29,100
a 3D game, it's not as big of a deal.

2010
02:01:29,300 --> 02:01:32,300
Has your typically layering a bunch of shaders on top of it and

2011
02:01:32,500 --> 02:01:35,100
there's a lot of like layering of textures and stuff.

2012
02:01:35,100 --> 02:01:40,200
So at that point it's a little less important to maintain the quality.

2013
02:01:40,200 --> 02:01:43,400
But I don't love lossy compression.

2014
02:01:44,200 --> 02:01:48,000
I theese days when you've got so much memory to play with, I feel like

2015
02:01:48,000 --> 02:01:50,900
you've got a really, make a strong argument for why you think it's

2016
02:01:50,900 --> 02:01:56,400
okay to be lossy on stuff because if you're just doing compression

2017
02:01:56,400 --> 02:01:58,300
because you saw that there was compression in the hardware and you

2018
02:01:58,300 --> 02:01:59,000
turn it on.

2019
02:01:59,400 --> 02:02:01,700
That may be a very bad decision because you'll degrade your image

2020
02:02:01,700 --> 02:02:04,300
quality but you don't know that you actually needed what it gave you

2021
02:02:04,400 --> 02:02:06,900
you don't know that you need a smaller size, you don't know that you

2022
02:02:06,900 --> 02:02:08,100
needed better bandwidth.

2023
02:02:08,300 --> 02:02:09,900
So you should actually determine that.

2024
02:02:09,900 --> 02:02:12,200
You need those things first before turning it on because otherwise

2025
02:02:12,200 --> 02:02:14,100
you're just making it worse looking image.

2026
02:02:14,300 --> 02:02:15,500
Like that's all it's giving you right?

2027
02:02:15,500 --> 02:02:16,300
Is there a syringe.

2028
02:02:16,600 --> 02:02:19,400
So you need to First determine that you actually needed more bandwidth

2029
02:02:19,400 --> 02:02:22,700
or more space before, turning something that on I think.

2030
02:02:22,700 --> 02:02:25,900
Because otherwise you're basically taking quality hit and you're not

2031
02:02:25,900 --> 02:02:27,000
getting anything for it.

2032
02:02:28,300 --> 02:02:32,600
And even if you do need it, you should first determine that the speed

2033
02:02:32,600 --> 02:02:37,000
when the truck getting is, is worth the quality degradation.

2034
02:02:37,000 --> 02:02:40,300
So at that point, even when you've decided that you might need it,

2035
02:02:40,300 --> 02:02:46,300
turn it on first verify that the degradation is not worse than making

2036
02:02:46,300 --> 02:02:49,800
some other decision, like, using less textures or something that you

2037
02:02:49,800 --> 02:02:54,300
could have done, or less passes or a slightly lower resolution or

2038
02:02:54,300 --> 02:02:55,100
something, right?

2039
02:02:55,100 --> 02:02:57,700
So you always want to like you always want to understand.

2040
02:02:57,800 --> 02:02:59,800
That the texture compression that is.

2041
02:03:00,000 --> 02:03:03,800
In Hardware right now is lossy compression.

2042
02:03:03,800 --> 02:03:05,800
You are taking quality, hit for using it.

2043
02:03:05,900 --> 02:03:11,600
So first, make sure that you actually want that before before doing

2044
02:03:11,600 --> 02:03:13,500
it, don't just do it right.

2045
02:03:14,300 --> 02:03:17,300
Make sure that, you know, make sure you understand the trade-offs

2046
02:03:17,300 --> 02:03:20,200
first and that you're making an educated decision, it's not a hard

2047
02:03:20,200 --> 02:03:24,300
decision to make because you can just test it both ways and see, you

2048
02:03:24,300 --> 02:03:25,900
know, at the minimum

2049
02:03:44,400 --> 02:03:48,700
So I think, all right, I think we're done here with the questions that

2050
02:03:48,700 --> 02:03:49,900
I was going to address.

2051
02:03:49,900 --> 02:03:54,200
So let me go ahead and close this off.

2052
02:04:02,600 --> 02:04:06,200
All right, so yeah so that was just a little foreign compression.

2053
02:04:06,200 --> 02:04:09,000
Like I said we won't do anything else with that for quite some time.

2054
02:04:11,500 --> 02:04:14,700
We might return to it when we're done with the game and just want to

2055
02:04:14,700 --> 02:04:18,300
reduce the size of the asset packs that we ship.

2056
02:04:18,300 --> 02:04:21,100
For example, we might go ahead and put that in there, if that makes

2057
02:04:21,100 --> 02:04:21,500
sense.

2058
02:04:22,900 --> 02:04:27,500
So, let's go ahead and and wrap up this stream.

2059
02:04:27,500 --> 02:04:31,900
And we'll be back after the after the holiday break with just regular

2060
02:04:31,900 --> 02:04:32,600
game coding.

2061
02:04:33,100 --> 02:04:34,500
All right, thank you so much.

2062
02:04:34,500 --> 02:04:36,400
Everyone for joining me for this episode of handmade.

2063
02:04:36,400 --> 02:04:38,600
He rots in a pleasure coding with you.

2064
02:04:38,600 --> 02:04:42,900
As always, if you want to follow along with the stream, you can always

2065
02:04:42,900 --> 02:04:45,400
pre-order the game on handmade here a.org and it comes with a source

2066
02:04:45,400 --> 02:04:45,700
code.

2067
02:04:45,700 --> 02:04:48,800
So if you want to play around with it, like, for example, if you want

2068
02:04:48,800 --> 02:04:52,000
to go play around with the the compressor, and try your hand at doing

2069
02:04:52,000 --> 02:04:52,200
some good,

2070
02:04:52,300 --> 02:04:54,600
At weeks or maybe learning about compressor and adding some things,

2071
02:04:54,600 --> 02:04:59,200
those compressors that will all be obviously included in tonight's

2072
02:04:59,200 --> 02:04:59,600
upload.

2073
02:04:59,600 --> 02:05:02,200
So if you sink with the source code, you will get that and play around

2074
02:05:02,200 --> 02:05:02,400
with it.

2075
02:05:02,400 --> 02:05:05,000
We also have a patreon.

2076
02:05:05,000 --> 02:05:07,500
If you want to support the video series, you can pledge to that.

2077
02:05:07,500 --> 02:05:10,700
We also have a schedule bot, which I will be rewriting soon to

2078
02:05:10,700 --> 02:05:12,000
actually work with.

2079
02:05:12,000 --> 02:05:12,900
We can streams.

2080
02:05:12,900 --> 02:05:17,600
It doesn't properly, mention them at the moment, but we'll fix that.

2081
02:05:17,600 --> 02:05:22,200
And then we've got an episode guide, you can go to to catch up on old.

2082
02:05:22,300 --> 02:05:24,200
Older streams that's about it for now.

2083
02:05:24,200 --> 02:05:27,800
I don't know that we will have a stream next week because it is

2084
02:05:28,400 --> 02:05:31,800
Christmas holiday as a deserved here in the states.

2085
02:05:32,300 --> 02:05:34,900
So most people are off and doing holiday things.

2086
02:05:34,900 --> 02:05:38,000
So we may skip that one but we'll be back the week after regardless.

2087
02:05:38,000 --> 02:05:45,700
So either way we we will see you soon and until then have fun

2088
02:05:45,700 --> 02:05:47,800
programming and I'll see y'all on the internet.

2089
02:05:47,800 --> 02:05:48,800
Take it easy everyone.

