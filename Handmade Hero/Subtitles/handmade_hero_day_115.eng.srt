1
00:00:02,700 --> 00:00:03,800
And let's get started.

2
00:00:03,800 --> 00:00:05,600
Hello everyone and welcome to handmade hero.

3
00:00:05,600 --> 00:00:09,400
The show we coded complete game live on Twitch, no engines and no

4
00:00:09,400 --> 00:00:10,000
libraries.

5
00:00:10,000 --> 00:00:11,700
This is an educational stream, we go through.

6
00:00:11,700 --> 00:00:15,500
Absolutely everything that is required to make a game Run and run.

7
00:00:15,500 --> 00:00:19,200
Well and right now we are right in the middle of a pretty interesting

8
00:00:19,200 --> 00:00:23,600
topic, which is Cindy optimization basically, how to optimize code to

9
00:00:23,600 --> 00:00:26,800
run wide, Vector units inside your processor.

10
00:00:27,400 --> 00:00:30,600
And, you know, basically what we're going to do today is we're gonna

11
00:00:30,600 --> 00:00:30,800
spend a little

12
00:00:31,000 --> 00:00:33,700
Time, the Blackboard just explaining the basics.

13
00:00:34,000 --> 00:00:36,200
What Cindy is how you use it.

14
00:00:36,500 --> 00:00:40,400
And then we're going to go start to actually do some code in some D so

15
00:00:40,400 --> 00:00:42,300
that people can kind of understand how that works.

16
00:00:42,900 --> 00:00:43,700
Before I do that.

17
00:00:43,700 --> 00:00:46,800
If you want to follow along with the code today, we are on day, 1 15.

18
00:00:46,800 --> 00:00:50,400
So if you download that source, code file, if you pre-ordered the game

19
00:00:50,400 --> 00:00:53,400
on hand right here at org, if you download the source code file, you

20
00:00:53,400 --> 00:00:56,500
should be able to unpack day 114 source code.

21
00:00:56,500 --> 00:00:59,100
And see exactly where I am right now.

22
00:00:59,900 --> 00:01:02,300
So I'm going to go ahead and open us up here.

23
00:01:06,300 --> 00:01:06,900
Here we go.

24
00:01:07,700 --> 00:01:09,800
And you can see here is where we're at right now.

25
00:01:10,800 --> 00:01:15,500
And basically, all of these routines are running through our new flat

26
00:01:15,500 --> 00:01:17,000
and function that we did yesterday.

27
00:01:17,700 --> 00:01:19,400
We basically took the entire function

28
00:01:21,100 --> 00:01:25,800
That we were working with for rendering there and we flattened it out

29
00:01:25,800 --> 00:01:29,500
so that we could see exactly all the stuff that it was doing, right?

30
00:01:29,500 --> 00:01:32,600
So here is the inner loop and you can see that we've got sort of this

31
00:01:32,600 --> 00:01:35,100
flattened version here, that shows us all of the operations.

32
00:01:35,100 --> 00:01:38,300
We actually need to do flattened out, no function calls here,

33
00:01:39,400 --> 00:01:43,500
flattened out so that we could figure out what we do for optimization.

34
00:01:44,100 --> 00:01:48,000
All right, so first I'm going to talk about the assembly stuff and

35
00:01:48,000 --> 00:01:50,600
then we're going to go ahead and take a look at it in the

36
00:01:50,700 --> 00:01:51,100
Road.

37
00:01:52,600 --> 00:01:53,500
So again, here we go.

38
00:01:53,500 --> 00:01:54,500
Day 115.

39
00:01:57,300 --> 00:02:01,700
Let's talk about 70 and this is going to be 70 on x64 for now.

40
00:02:02,000 --> 00:02:04,200
Right there is some D also,

41
00:02:06,700 --> 00:02:08,600
On arm processors is called Neon.

42
00:02:10,600 --> 00:02:11,100
But anyway,

43
00:02:13,700 --> 00:02:17,700
all right, so what is simply as we said before it stands for single

44
00:02:18,400 --> 00:02:19,300
instruction

45
00:02:21,000 --> 00:02:22,000
Multiple data.

46
00:02:23,600 --> 00:02:28,900
And it means that for every instruction that the processor decodes, it

47
00:02:28,900 --> 00:02:35,000
is actually going to do what that instruction tells it to do on more

48
00:02:35,000 --> 00:02:37,500
than one piece of data at once, right?

49
00:02:37,500 --> 00:02:41,600
And so, if you think about the typical way, that you might understand

50
00:02:41,600 --> 00:02:48,300
a piece of code, you might see a thing that says b equals a plus a.

51
00:02:48,300 --> 00:02:53,200
And the way that we typically understand that in C is to

52
00:02:53,600 --> 00:02:58,500
late itself into some kind of instruction, the processor that might

53
00:02:58,500 --> 00:02:59,800
look something like,

54
00:03:00,600 --> 00:03:06,100
An add instruction where you have a destination register of be and you

55
00:03:06,100 --> 00:03:09,400
know, to Source registers of a and a depending on how your posture

56
00:03:09,400 --> 00:03:12,800
looks at may look nothing like this but point being, we understand

57
00:03:12,800 --> 00:03:18,800
there to be some concept that we have two registers write an A and A B

58
00:03:18,800 --> 00:03:22,100
register and we are telling the processor to take the contents of the

59
00:03:22,100 --> 00:03:22,800
a register.

60
00:03:22,800 --> 00:03:26,700
Add it to another to the contents of the tip of itself, right?

61
00:03:26,800 --> 00:03:29,200
And put the result in the B register, right?

62
00:03:29,500 --> 00:03:29,900
So this

63
00:03:30,000 --> 00:03:31,300
C Code maps.

64
00:03:31,300 --> 00:03:35,600
Very directly to this code in the processor usually one or two

65
00:03:35,600 --> 00:03:37,100
instructions or something like that.

66
00:03:38,100 --> 00:03:39,800
I'm very straightforward, right?

67
00:03:41,200 --> 00:03:46,100
Sometimes there's, there's this concept of a ternary, operator

68
00:03:46,200 --> 00:03:49,700
operation versus a binary operation, which is how many of these

69
00:03:49,900 --> 00:03:51,300
registers it takes as inputs.

70
00:03:51,500 --> 00:03:55,400
And so the reason I was kind of hesitating to say that it always looks

71
00:03:55,400 --> 00:03:59,700
this way is because sometimes if you have to Source if you have Source

72
00:03:59,700 --> 00:04:04,600
0 Source, 1 and dest, sometimes processors, don't operate that way.

73
00:04:04,600 --> 00:04:07,700
In fact, x 64 processors have

74
00:04:07,900 --> 00:04:08,800
Don't operate this way.

75
00:04:10,100 --> 00:04:12,300
Sometimes the source and the desk.

76
00:04:12,300 --> 00:04:14,500
The, the destination has to be one of the sources.

77
00:04:14,800 --> 00:04:19,300
So sometimes you have to do like add ba and it puts the result in B.

78
00:04:19,500 --> 00:04:24,300
And so what you have to do first is load the contents of a into the B

79
00:04:24,300 --> 00:04:24,800
register.

80
00:04:24,800 --> 00:04:29,500
So something like this actually looks like, you know, a move that

81
00:04:29,500 --> 00:04:34,400
loads the contents of a register in to be and then an ad that adds A

82
00:04:34,400 --> 00:04:37,600
and B which effectively puts in to be a plus.

83
00:04:37,800 --> 00:04:39,000
Say right.

84
00:04:39,900 --> 00:04:43,100
Just a little aside, their turn and reverses binary operations.

85
00:04:44,300 --> 00:04:46,300
And again, turn to read this means, three inputs.

86
00:04:46,300 --> 00:04:49,700
Binary means to write and I shouldn't say inputs registers.

87
00:04:51,500 --> 00:04:53,500
All right, but Insanity.

88
00:04:53,500 --> 00:04:55,700
We don't talk about this kind of operation much.

89
00:04:55,800 --> 00:04:59,200
What we usually talk about is an operation that looks like this.

90
00:05:00,200 --> 00:05:07,600
It's the same math, but it basically is operating spread across

91
00:05:07,700 --> 00:05:09,900
multiple values at the same time.

92
00:05:11,900 --> 00:05:12,400
Okay.

93
00:05:15,500 --> 00:05:19,400
And so we no longer talk about saying b equals a plus, a, what we

94
00:05:19,400 --> 00:05:23,400
talked about is a family of values called be equal, a family of

95
00:05:23,400 --> 00:05:26,600
values, called A Plus, another family of values, right?

96
00:05:26,800 --> 00:05:31,400
And so this example, that I've given here is 4 wide right?

97
00:05:31,600 --> 00:05:35,100
Because it happens on four things at once and they all have the same

98
00:05:35,100 --> 00:05:36,100
operation done to them.

99
00:05:36,700 --> 00:05:38,800
These things are often called Lanes.

100
00:05:41,000 --> 00:05:43,600
Which I think is more of kind of becomes from the hardware side of

101
00:05:43,600 --> 00:05:48,100
things, but these are often called lanes, and this operation is

102
00:05:48,100 --> 00:05:50,300
assembly operation, single instruction.

103
00:05:50,400 --> 00:05:54,100
Meaning it's just telling it to do an ad but multiple data, there are

104
00:05:54,100 --> 00:05:55,200
four pieces of data.

105
00:05:55,800 --> 00:05:58,600
Now, there are a couple different kinds of this, right?

106
00:05:58,700 --> 00:05:59,700
There's SSC and

107
00:06:00,000 --> 00:06:02,700
On but you've heard right?

108
00:06:03,100 --> 00:06:05,300
SSE is an x 64 thing.

109
00:06:05,300 --> 00:06:12,100
Arm is a sorry, neon is an arm thing and these are four wide recently

110
00:06:12,100 --> 00:06:15,100
Intel introduced a VX which is eight wide.

111
00:06:15,100 --> 00:06:17,000
But exactly the same kind of thing, right?

112
00:06:17,000 --> 00:06:17,900
It's still doing this only.

113
00:06:17,900 --> 00:06:23,000
Now it's eight values of said and they also announced avx-512, which I

114
00:06:23,000 --> 00:06:26,000
think isn't actually technically here and consumer processors until

115
00:06:26,000 --> 00:06:29,400
the end of the year, but that's 16 wide, right?

116
00:06:29,500 --> 00:06:29,800
So just

117
00:06:30,000 --> 00:06:30,700
Keeps getting bigger.

118
00:06:32,000 --> 00:06:33,500
Okay so

119
00:06:34,800 --> 00:06:38,600
What are these things in terms of, you know, like how do we, how do we

120
00:06:38,600 --> 00:06:40,900
use this, what's going to have to happen here, right?

121
00:06:41,700 --> 00:06:48,300
So what typically happens here, is we want to, you know, because it

122
00:06:48,300 --> 00:06:51,400
looks like this because every time we issue an instruction it's going

123
00:06:51,400 --> 00:06:51,900
to do that.

124
00:06:51,900 --> 00:06:53,200
Same thing four times.

125
00:06:53,700 --> 00:06:58,600
What we want to do is find entire groups of code, right?

126
00:06:58,900 --> 00:07:03,800
That we want to operate on that, you know, that one entire code path

127
00:07:03,800 --> 00:07:04,400
that we can.

128
00:07:04,600 --> 00:07:07,100
Do on four things at once.

129
00:07:07,500 --> 00:07:07,900
Okay?

130
00:07:08,400 --> 00:07:12,800
And so the reason that we were talking about doing for pixels at once

131
00:07:12,800 --> 00:07:16,300
in our render Loop is because each pixel has the exact same things

132
00:07:16,300 --> 00:07:17,100
happen to it right?

133
00:07:17,100 --> 00:07:21,400
Like this cool set of things has to happen for all the pixels.

134
00:07:21,600 --> 00:07:22,200
Right?

135
00:07:22,900 --> 00:07:26,700
And so since this whole thing has to happen for every pixel, write

136
00:07:26,700 --> 00:07:30,600
this for, I Loop here for x equals x Min X, less than x, Max Plus with

137
00:07:30,600 --> 00:07:31,000
X.

138
00:07:31,500 --> 00:07:34,400
We could instead choose to do this, right?

139
00:07:34,500 --> 00:07:34,800
Right.

140
00:07:36,200 --> 00:07:37,000
Based on.

141
00:07:38,300 --> 00:07:39,800
Doing four of them at once.

142
00:07:40,000 --> 00:07:43,900
So, typically what you'll do the most simplest Cindy thing you can do

143
00:07:44,100 --> 00:07:46,400
is take a loop such as this one.

144
00:07:47,100 --> 00:07:52,100
And instead of going by one thing at a time, you can go at by four

145
00:07:52,100 --> 00:07:53,500
things at a time, right?

146
00:07:53,500 --> 00:07:55,500
So we'll just start at x equals X.

147
00:07:55,500 --> 00:07:59,600
Men, will do X less than equal to X Max and will do X plus 2 equals 4,

148
00:08:00,000 --> 00:08:00,300
right?

149
00:08:00,300 --> 00:08:02,800
So we'll go, you know, will move by forward time.

150
00:08:03,500 --> 00:08:04,500
Hopefully, that makes some sense.

151
00:08:09,000 --> 00:08:11,300
And then it's a simple matter of translating all of these into some D

152
00:08:11,300 --> 00:08:14,500
instructions which will show how to do in a second, but that's the

153
00:08:14,500 --> 00:08:15,300
basic idea.

154
00:08:16,200 --> 00:08:21,100
So, what we would be doing here to make this Cindy site style,

155
00:08:22,500 --> 00:08:24,800
There's a couple things I want to talk about just real briefly.

156
00:08:25,300 --> 00:08:28,400
Again, I want to get this done maybe in the next ten minutes, so we

157
00:08:28,400 --> 00:08:29,500
can go look at the code.

158
00:08:30,800 --> 00:08:36,299
So what ends up happening when you look at this is because we are

159
00:08:36,299 --> 00:08:37,500
going to be four wide.

160
00:08:38,600 --> 00:08:42,500
Basically what happens is you can think about the for wideness of it

161
00:08:42,600 --> 00:08:46,300
if we were doing four pixels right here are the four pixels that we

162
00:08:46,300 --> 00:08:50,100
would be doing if we were to load out of the frame buffer and operate

163
00:08:50,100 --> 00:08:51,600
on the frame buffer.

164
00:08:52,100 --> 00:08:53,300
Probably right.

165
00:08:53,500 --> 00:08:55,700
We wouldn't necessarily have to do it this way, but it's one way to

166
00:08:55,700 --> 00:08:56,300
think about it.

167
00:08:56,500 --> 00:08:58,500
We load in four pixels, right?

168
00:08:58,500 --> 00:08:59,900
We do those then we load

169
00:09:00,000 --> 00:09:02,600
The next four pixels, and we do those and so on.

170
00:09:03,900 --> 00:09:09,600
But I wanted to mention briefly a couple things that differ CPU vs.

171
00:09:09,600 --> 00:09:10,500
GPU here

172
00:09:12,200 --> 00:09:16,800
is that right now in our code, our frame buffer is stored.

173
00:09:17,000 --> 00:09:21,100
Such that pixels are contiguous in X, right?

174
00:09:21,100 --> 00:09:22,000
I don't know if you remember.

175
00:09:22,000 --> 00:09:25,600
But like, basically we have a pointer to some row of pixels and the

176
00:09:25,600 --> 00:09:30,400
pixels just go in order rgba rgba rgba rgba right.

177
00:09:31,800 --> 00:09:37,600
And what's important to remember about that is probably right.

178
00:09:37,900 --> 00:09:40,800
That is not the most efficient way to organize.

179
00:09:41,300 --> 00:09:45,100
The pixels that were actually operating on and it's fact it's not the

180
00:09:45,100 --> 00:09:50,700
way that gpus often up organize this pixels so often times, they use

181
00:09:50,700 --> 00:09:51,300
something.

182
00:09:51,600 --> 00:09:52,800
I'm going to call it.

183
00:09:53,300 --> 00:09:59,600
I'm gonna say Swizzle but often you know that term is thrown around in

184
00:09:59,600 --> 00:10:00,800
a lot of different contexts.

185
00:10:01,100 --> 00:10:05,700
So maybe I'll try not to harp on the term too much but basically what

186
00:10:05,700 --> 00:10:10,700
happens is if you think about how this ends up working if you operate

187
00:10:10,700 --> 00:10:11,000
on for

188
00:10:11,200 --> 00:10:12,000
Pixels at a time.

189
00:10:12,200 --> 00:10:15,300
The thing that you start to have to worry about is operating on

190
00:10:15,300 --> 00:10:15,700
pixels.

191
00:10:15,700 --> 00:10:18,700
A lot of pixels you didn't actually need to operate on, right?

192
00:10:19,600 --> 00:10:22,100
So let's say that we have a rectangle, right?

193
00:10:22,500 --> 00:10:25,400
And it's somewhere on the pixel grid, right?

194
00:10:27,100 --> 00:10:28,000
And we're filling it in.

195
00:10:29,300 --> 00:10:32,400
Now, if you look at what happens here, we're going to have to load

196
00:10:32,400 --> 00:10:32,600
things.

197
00:10:32,600 --> 00:10:35,200
We're going to load these pixels in and operate on them.

198
00:10:35,200 --> 00:10:35,400
Right?

199
00:10:35,900 --> 00:10:39,800
And depending on what the granularity is, how we choose to break up

200
00:10:39,800 --> 00:10:40,300
the memory.

201
00:10:40,300 --> 00:10:45,500
Even if we got lucky and we can do it so that we start right on the

202
00:10:45,500 --> 00:10:48,800
the, you know, the right on the first pixel of the thing.

203
00:10:48,800 --> 00:10:49,900
And we do four at a time.

204
00:10:50,400 --> 00:10:52,500
Then next one we do right?

205
00:10:52,800 --> 00:10:55,900
You can see that we're going to waste two pixels at the end of it,

206
00:10:55,900 --> 00:10:56,200
right?

207
00:10:56,700 --> 00:10:59,200
We're going to calculate those but we're not actually ever going to

208
00:10:59,300 --> 00:11:01,800
Use them because they're outside of the rectangle.

209
00:11:01,800 --> 00:11:04,800
So they'll fail the inclusion test and we won't actually write

210
00:11:04,800 --> 00:11:06,100
anything to them, right?

211
00:11:07,100 --> 00:11:08,200
Hope that makes some sense.

212
00:11:09,700 --> 00:11:15,300
So, what often happens is, if you look at how shapes fill shapes

213
00:11:15,300 --> 00:11:18,900
filler on a display, and the typical ways that 3D and 2D Graphics

214
00:11:18,900 --> 00:11:22,300
work, you typically don't have long slivery things.

215
00:11:22,500 --> 00:11:24,500
So, like long, slivers,

216
00:11:26,500 --> 00:11:27,800
Tend to not be common.

217
00:11:28,000 --> 00:11:30,900
You don't tend to have really long, thin things.

218
00:11:30,900 --> 00:11:33,000
Look like that for Sprites, right?

219
00:11:33,000 --> 00:11:36,300
You tend to have blocks that are roughly, you know, rectangle shapes.

220
00:11:36,300 --> 00:11:38,000
That's what games tend to do.

221
00:11:38,200 --> 00:11:41,100
And similarly, in 3D you tend to have lots of triangles that are

222
00:11:41,100 --> 00:11:44,400
fairly well, formed there aren't like, usually a lot of triangles that

223
00:11:44,400 --> 00:11:47,200
are like super thin, like this, right?

224
00:11:47,200 --> 00:11:49,600
Sometimes there are, but it's just, it's not the common case.

225
00:11:51,200 --> 00:11:53,600
So because long some servers aren't common.

226
00:11:53,800 --> 00:11:56,600
You end up with stuff that looks like this a lot and you end up

227
00:11:56,600 --> 00:11:58,900
burning a lot of pixels when you do it this way.

228
00:11:59,700 --> 00:11:59,800
So

229
00:12:00,000 --> 00:12:04,900
What they try to do to minimize that is they will often rearrange the

230
00:12:04,900 --> 00:12:09,000
memory so that instead of storing things continuously like this, they

231
00:12:09,000 --> 00:12:13,600
actually store it so that for contiguous pixels actually mapped to a

232
00:12:13,600 --> 00:12:15,600
block that looks like this.

233
00:12:16,100 --> 00:12:16,700
Right?

234
00:12:17,000 --> 00:12:24,400
So, one sim D, once 170 element actually is ABCD where it's like, this

235
00:12:24,400 --> 00:12:26,400
ABCD in a block.

236
00:12:27,100 --> 00:12:29,500
And that way, if you look at what happens there you can see, you get

237
00:12:29,500 --> 00:12:29,800
much better.

238
00:12:30,000 --> 00:12:33,400
Tiling in fact, in this case you basically get perfect tiling you

239
00:12:33,400 --> 00:12:33,700
waste.

240
00:12:33,700 --> 00:12:34,500
No pixels.

241
00:12:34,900 --> 00:12:37,400
But the maximum pixels, you could waste around the edges, just one

242
00:12:37,400 --> 00:12:41,400
row, you know, you can't waste a double row and if you think about

243
00:12:41,400 --> 00:12:44,700
this, it gets much more important when it's for why it's not perhaps,

244
00:12:44,700 --> 00:12:48,600
as important, but it gets much more important when you start thinking

245
00:12:48,600 --> 00:12:50,700
about these being huge, right?

246
00:12:51,900 --> 00:12:56,300
Let's say you were to implement this using this avx-512 instruction

247
00:12:56,300 --> 00:12:58,600
set, that Intel will be putting in consumer processor.

248
00:12:58,600 --> 00:12:59,900
It's coming at the end of the year, I think.

249
00:13:02,200 --> 00:13:03,000
Sometime soon.

250
00:13:04,400 --> 00:13:08,700
Well, that would be this gigantic long 16 wide thing.

251
00:13:09,000 --> 00:13:11,400
That burns a ton of pixels over here, right?

252
00:13:11,600 --> 00:13:14,100
And just gets worse and worse as you get wider.

253
00:13:14,200 --> 00:13:15,700
And so, what you'd rather do, right?

254
00:13:15,700 --> 00:13:19,300
Is you'd rather have it packed that into a block which will burn a lot

255
00:13:19,300 --> 00:13:21,900
less pixels on the outside, right?

256
00:13:23,500 --> 00:13:28,900
So I don't know that we're going to actually do that because at for

257
00:13:28,900 --> 00:13:31,400
wide, it's not clear, you know, we'll have to take a look and see

258
00:13:31,400 --> 00:13:35,000
whether we want to bother rearranging our frame buffer for it but

259
00:13:35,000 --> 00:13:37,100
that's basically a data organization thing.

260
00:13:37,200 --> 00:13:40,400
It won't actually affect how we write this loop at all.

261
00:13:40,900 --> 00:13:44,700
Like literally at all, it would only affect just sort of maybe the way

262
00:13:44,700 --> 00:13:48,600
that we Loop over things, and how we pick the starting point.

263
00:13:49,700 --> 00:13:52,100
But the actual instructions on the inside, we'll all be the same

264
00:13:52,100 --> 00:13:53,200
because they're all doing the same.

265
00:13:53,300 --> 00:13:57,700
Aim for Pixel operations but it's worth understanding basically how

266
00:13:57,700 --> 00:14:00,700
you kind of are loading in those things that are lined.

267
00:14:01,000 --> 00:14:03,700
So let's talk about one more thing that we probably don't have to deal

268
00:14:03,700 --> 00:14:05,000
with too much at the moment.

269
00:14:05,200 --> 00:14:08,800
But you probably see basically this

270
00:14:10,600 --> 00:14:11,500
You've probably seen this.

271
00:14:11,500 --> 00:14:12,700
I just want to mention what it is.

272
00:14:13,600 --> 00:14:15,900
Basically, this is structure.

273
00:14:17,500 --> 00:14:18,600
Of arrays.

274
00:14:20,700 --> 00:14:24,700
S0 a versus array.

275
00:14:26,200 --> 00:14:27,100
Of structures.

276
00:14:32,800 --> 00:14:33,400
OS.

277
00:14:34,200 --> 00:14:36,300
This is what C makes easy.

278
00:14:37,200 --> 00:14:42,200
This is what you actually wanted for 70 and we can talk about why that

279
00:14:42,200 --> 00:14:42,500
is.

280
00:14:42,700 --> 00:14:47,200
So remember C is in my opinion, a pretty great language actually for

281
00:14:47,200 --> 00:14:50,800
its day, but the important part here, being for its day and

282
00:14:50,800 --> 00:14:57,400
unfortunately, in its day, there was no big emphasis on Cindy, right

283
00:14:58,900 --> 00:14:59,300
processors?

284
00:14:59,300 --> 00:14:59,800
Pretty much

285
00:15:00,000 --> 00:15:04,000
Putting on single pieces of data and see did not need to worry about

286
00:15:04,000 --> 00:15:05,800
generating Cindy instructions.

287
00:15:06,300 --> 00:15:08,300
At least I don't think they were at all worried about that at the

288
00:15:08,300 --> 00:15:08,800
time.

289
00:15:09,500 --> 00:15:15,900
So what happens is C, makes it very easy to do something like struct.

290
00:15:18,400 --> 00:15:28,300
You know, float X float, why float Z float W, right?

291
00:15:28,300 --> 00:15:36,000
Or I guess maybe more to the point here, RG, b, and a right.

292
00:15:36,000 --> 00:15:41,100
So, there's a color C, makes it pretty easy to type that in and work

293
00:15:41,100 --> 00:15:41,500
with that.

294
00:15:41,500 --> 00:15:43,700
That's what you expect to see in a sea program.

295
00:15:43,700 --> 00:15:46,200
And in most kinds of programs actually, because a lot of people just

296
00:15:46,200 --> 00:15:46,900
inherited

297
00:15:47,400 --> 00:15:51,800
That method because, you know, C, sharp or something, comes from C,

298
00:15:51,800 --> 00:15:55,500
Java comes from C, in terms of its structural nature.

299
00:15:57,700 --> 00:15:58,700
They all look that way.

300
00:16:00,100 --> 00:16:05,800
But if you remember how this works typically we want to do the same

301
00:16:05,800 --> 00:16:08,100
operations on the same sorts of things.

302
00:16:08,200 --> 00:16:13,500
And so what we actually want when we talk about things we want to talk

303
00:16:13,500 --> 00:16:18,200
about for ours together and Four G's together and Four B's together

304
00:16:18,200 --> 00:16:19,800
and forays together.

305
00:16:20,100 --> 00:16:23,500
So that's actually what we wanted to see but this is what the language

306
00:16:23,500 --> 00:16:25,100
tends to do, right?

307
00:16:25,300 --> 00:16:29,700
So when you have a array of structures such

308
00:16:29,800 --> 00:16:35,000
As in C, we will often see color star colors, you know, which is just

309
00:16:35,000 --> 00:16:37,500
some array of colors values that we want to operate on.

310
00:16:38,500 --> 00:16:42,900
The problem that we see is that they're typically packed rgba.

311
00:16:43,200 --> 00:16:46,500
But when we do operations on the, we want to do something like a times

312
00:16:46,500 --> 00:16:47,200
are right?

313
00:16:47,200 --> 00:16:51,600
We want to do something like, you know, our Prime equals a times are

314
00:16:51,900 --> 00:16:52,200
right.

315
00:16:52,200 --> 00:16:56,400
That's what we want to do, but the actual values as they appear in

316
00:16:56,400 --> 00:16:59,700
memory, aren't for RS, 4 G's for bees.

317
00:16:59,800 --> 00:17:00,400
Or A's.

318
00:17:00,400 --> 00:17:05,800
So in order to get them into this format, when we load these things

319
00:17:05,800 --> 00:17:10,300
out of memory they're not in the format that a Sim deregister expects

320
00:17:10,300 --> 00:17:11,000
right?

321
00:17:11,000 --> 00:17:15,500
A Sim deregister is going to expect these this way and instead they're

322
00:17:15,500 --> 00:17:20,900
this way and so on the load before you start doing your operations you

323
00:17:20,900 --> 00:17:23,200
end up with a bunch of fiddly instructions.

324
00:17:23,200 --> 00:17:28,000
Designed to grab all of the Ours from adjacent elements and put them

325
00:17:28,000 --> 00:17:29,700
into one packed register.

326
00:17:30,100 --> 00:17:32,600
And then do the same with the geez and the bees and the A's and so on,

327
00:17:32,900 --> 00:17:33,400
right?

328
00:17:35,000 --> 00:17:36,300
And so, let's talk about that.

329
00:17:36,500 --> 00:17:37,600
Well, I should finish this.

330
00:17:37,700 --> 00:17:41,200
So structure of a raise is when you do things the opposite way, you

331
00:17:41,200 --> 00:17:48,100
say struct colors, instead of color, and you have float star, our

332
00:17:48,800 --> 00:17:57,800
float star G, float star be float, star a right, which you can see is

333
00:17:57,800 --> 00:17:59,600
exact same data, but it, flips it around.

334
00:17:59,600 --> 00:17:59,900
So, instead,

335
00:18:00,000 --> 00:18:00,800
Of one array.

336
00:18:00,800 --> 00:18:02,100
Instead of a ray of colors.

337
00:18:02,400 --> 00:18:06,000
Again, array of structures, you have a structure that has different

338
00:18:06,000 --> 00:18:09,800
arrays in it and these are just a bunch of ours in sequence, right?

339
00:18:10,100 --> 00:18:13,700
And bunch of G's in sequence and that way when you actually go to

340
00:18:13,700 --> 00:18:15,900
gather the data it's already in the format that you want.

341
00:18:15,900 --> 00:18:20,600
It's already packed together by type by look, which channel you're

342
00:18:20,600 --> 00:18:21,400
talking about.

343
00:18:22,700 --> 00:18:25,400
And so that brings us to the final thing that we want to talk about

344
00:18:25,400 --> 00:18:27,600
which is how this stuff actually works.

345
00:18:28,000 --> 00:18:31,700
So how this stuff actually works much like we were talking about

346
00:18:31,700 --> 00:18:35,800
before where I sort of said this this situation here right where we

347
00:18:35,800 --> 00:18:40,200
have, you know, operations that that work on these values Sim D is

348
00:18:40,200 --> 00:18:42,800
basically the exact same sort of thing.

349
00:18:42,900 --> 00:18:46,200
So inside the processor, you know, before we were talking about, you

350
00:18:46,200 --> 00:18:51,100
may have a thing that's like, okay I want to take, you know, some

351
00:18:51,100 --> 00:18:52,300
memory location somewhere.

352
00:18:53,100 --> 00:18:57,900
And I want to move it into this register inside the processor and

353
00:18:57,900 --> 00:19:00,800
again that the register inside the processor, right?

354
00:19:02,100 --> 00:19:05,700
Is some 64-bit wide thing, right?

355
00:19:06,200 --> 00:19:09,500
What is going on some 64-bit wide thing?

356
00:19:11,700 --> 00:19:12,300
Right.

357
00:19:12,500 --> 00:19:16,000
And so I'm going to grab memory 64, bits of memory and I fill it in

358
00:19:16,000 --> 00:19:16,700
here, right?

359
00:19:16,700 --> 00:19:18,400
And oftentimes, we're doing less than that.

360
00:19:18,400 --> 00:19:22,900
So like if we're going to load in, you know, some 32-bit, integer it,

361
00:19:22,900 --> 00:19:25,400
maybe it only goes in the bottom 32 bits or something like that,

362
00:19:25,400 --> 00:19:25,900
right?

363
00:19:26,200 --> 00:19:27,200
And then we do those things.

364
00:19:27,200 --> 00:19:31,600
Like I said, where we do ads, you know, maybe we do an ad of a and a

365
00:19:31,600 --> 00:19:32,900
two, a, which just takes this.

366
00:19:32,900 --> 00:19:34,100
Register adds it to itself.

367
00:19:34,100 --> 00:19:37,400
And you know, like I said baby it's just a it's a binary Apso, it just

368
00:19:37,400 --> 00:19:40,500
takes a register, adds it to itself and you know sort of double

369
00:19:40,700 --> 00:19:41,000
Value.

370
00:19:41,000 --> 00:19:42,100
That's in there, right?

371
00:19:43,700 --> 00:19:47,900
So, the way Cindy works is exactly the same as this, it's just that

372
00:19:47,900 --> 00:19:50,400
the registers are wider now, right?

373
00:19:50,500 --> 00:19:55,600
So, there are 128 bits wide instead of 64 bits wide and when you load

374
00:19:55,600 --> 00:20:00,700
something in it, just loads that 128 bits, right?

375
00:20:00,800 --> 00:20:04,600
So if I say, I want to move something to my SIM deregister, whatever

376
00:20:04,600 --> 00:20:06,200
that Cindy register is for memory.

377
00:20:07,400 --> 00:20:10,400
It's going to go and grab 128 bits and stick it in here.

378
00:20:11,000 --> 00:20:11,400
Okay?

379
00:20:12,000 --> 00:20:13,400
Then there are going to be

380
00:20:13,500 --> 00:20:15,400
Operations, which operate on that.

381
00:20:15,400 --> 00:20:19,300
So for example, I may have a thing that does that ad.

382
00:20:20,900 --> 00:20:25,800
And instead of just saying, what the ad is, instead of just an add

383
00:20:25,800 --> 00:20:29,500
instruction, in addition to the part of the instruction that says what

384
00:20:29,500 --> 00:20:30,800
you're doing, which is ADD.

385
00:20:30,800 --> 00:20:33,600
There's also a thing, which says, how you're doing it.

386
00:20:33,700 --> 00:20:39,200
So it may say like this, you know, might be just you know, an integer

387
00:20:39,200 --> 00:20:43,600
add but this one is like, okay, I'm going to say that this is 4 wide

388
00:20:43,600 --> 00:20:45,100
floating point, right?

389
00:20:45,600 --> 00:20:49,900
You know so I want to treat the register as if there's for floating

390
00:20:49,900 --> 00:20:50,600
Point values in it.

391
00:20:50,700 --> 00:20:53,400
It and add them separately, right?

392
00:20:54,400 --> 00:20:58,600
It might do something different, which is ADD 8, signed integers,

393
00:20:58,800 --> 00:20:59,800
let's say which

394
00:21:00,000 --> 00:21:04,000
Treat this register as eight pact signed integers in their right.

395
00:21:04,000 --> 00:21:07,000
And each one of those would be 16 bits, right?

396
00:21:07,600 --> 00:21:12,500
So the instructions now have in addition to what the operation is such

397
00:21:12,500 --> 00:21:17,700
as add subtract, multiply whatever they have, what you are thinking

398
00:21:17,700 --> 00:21:20,600
the register had in it basically, right.

399
00:21:20,900 --> 00:21:24,100
And that allows the processor to know which units you know which

400
00:21:24,100 --> 00:21:26,600
operation in the unit to tell it to do.

401
00:21:26,700 --> 00:21:29,900
Should it should it treat these as separate entities?

402
00:21:30,000 --> 00:21:32,100
Dude, you know, as going by 16s.

403
00:21:32,100 --> 00:21:33,700
So, treat them as going by fours.

404
00:21:33,700 --> 00:21:35,000
Are they floats, whatever?

405
00:21:35,500 --> 00:21:36,400
All those sorts of things?

406
00:21:40,200 --> 00:21:43,600
And so, as you can see, from this, once you get things into the

407
00:21:43,600 --> 00:21:47,700
register, it's basically exactly the same thinking about programming.

408
00:21:47,700 --> 00:21:50,000
It's exactly the same as thinking about programming, regular

409
00:21:50,000 --> 00:21:53,400
instructions, you're just issuing math operations that you want to

410
00:21:53,400 --> 00:21:56,300
have happen between things that are in registers and you go.

411
00:21:57,100 --> 00:22:02,700
So it's really mostly about this, this this startup part here and also

412
00:22:02,700 --> 00:22:07,400
when you store things that it really comes down to thinking about the

413
00:22:07,400 --> 00:22:07,600
same.

414
00:22:08,100 --> 00:22:12,500
And that is, how do I fill up the 128 bits and how do I write them out

415
00:22:12,500 --> 00:22:13,000
later?

416
00:22:13,200 --> 00:22:13,700
Right?

417
00:22:13,800 --> 00:22:18,500
And that's where this array of structures versus structure rates comes

418
00:22:18,500 --> 00:22:21,600
into play, and the reason that it comes into play, pretty heavily on

419
00:22:21,600 --> 00:22:25,600
Intel is because they do not know why.

420
00:22:25,600 --> 00:22:29,000
But they just did not support any kind of strided loading.

421
00:22:29,300 --> 00:22:29,700
Okay.

422
00:22:30,100 --> 00:22:32,000
So for example,

423
00:22:33,000 --> 00:22:39,800
On the neon architecture, on AMD, what they can do is you can actually

424
00:22:39,800 --> 00:22:45,700
issue a load instruction which says load every fourth bite, you know,

425
00:22:45,800 --> 00:22:51,100
into my into my sim deregister as the pieces of the same deregister,

426
00:22:51,200 --> 00:22:51,700
right?

427
00:22:51,800 --> 00:22:57,100
So if you have a pact rgba rgba kind of a thing, right?

428
00:22:57,200 --> 00:22:57,900
Like this.

429
00:22:58,100 --> 00:23:01,100
And I say, I shouldn't say every fourth bite, every fourth float and

430
00:23:01,100 --> 00:23:02,200
you want to load that in.

431
00:23:02,800 --> 00:23:03,800
It's not a big deal.

432
00:23:04,400 --> 00:23:10,000
Basically, you just say the stride of this thing, right is is going to

433
00:23:10,000 --> 00:23:10,300
be

434
00:23:12,000 --> 00:23:12,400
What is that?

435
00:23:12,400 --> 00:23:13,800
That's 4 times.

436
00:23:14,800 --> 00:23:15,400
4 times, 4.

437
00:23:15,400 --> 00:23:17,700
So 16, it's just going to be 16, bytes?

438
00:23:18,100 --> 00:23:18,800
Right?

439
00:23:19,000 --> 00:23:24,200
You say the slightest thing is 16, bytes and I want to load from this

440
00:23:24,200 --> 00:23:27,100
address, it grabs the first our and puts it in the grabs.

441
00:23:27,100 --> 00:23:28,000
A second are puts it in.

442
00:23:28,000 --> 00:23:31,400
Third are and forth are right, so it's no big deal, you can just load

443
00:23:31,400 --> 00:23:32,400
them out, that's fine.

444
00:23:33,200 --> 00:23:35,400
But SSE, there is no such thing.

445
00:23:35,500 --> 00:23:39,200
There's only loads that load contiguous stuff.

446
00:23:39,700 --> 00:23:41,700
So when you issue one of these moves to

447
00:23:41,800 --> 00:23:44,900
Well, one of your registers you are going to get whatever was in

448
00:23:44,900 --> 00:23:48,400
memory coming out into the processor like that.

449
00:23:48,400 --> 00:23:49,600
That's just what you're going to get.

450
00:23:50,200 --> 00:23:55,500
So what you have to do, if you don't use sort of this this structure

451
00:23:55,500 --> 00:23:58,300
where things are already packed in the order that you want them in the

452
00:23:58,300 --> 00:23:59,800
registers if you have

453
00:24:00,100 --> 00:24:03,900
In this format, you have to do a bunch of reorganization.

454
00:24:03,900 --> 00:24:06,900
So when you load them in, you then have to shuffle things around.

455
00:24:06,900 --> 00:24:12,200
So they end up in the right place and SSE actually has operations for

456
00:24:12,200 --> 00:24:15,000
this, that can help you but they're not that great.

457
00:24:15,000 --> 00:24:19,700
So there's these unpack instructions and pack instructions and stuff

458
00:24:19,700 --> 00:24:24,800
like this that are used to help you sort of smush things down, or a

459
00:24:24,800 --> 00:24:27,600
blow them back out again and interleaved and different ways.

460
00:24:27,600 --> 00:24:29,900
And you can do it will see

461
00:24:30,000 --> 00:24:36,000
It's really annoying, but point being that is why this this format is

462
00:24:36,000 --> 00:24:39,800
preferred, by Intel over this formats because their chip doesn't have

463
00:24:39,900 --> 00:24:41,700
good handling for that.

464
00:24:41,700 --> 00:24:47,200
Sort of transposition is often what's called, that makes sense.

465
00:24:47,800 --> 00:24:48,300
So,

466
00:24:49,500 --> 00:24:52,800
All right, I think that's about enough to understand what we're doing

467
00:24:52,800 --> 00:24:53,100
here.

468
00:24:53,100 --> 00:24:54,300
Hopefully you're clear on that.

469
00:24:54,300 --> 00:24:57,000
I mean really what we're talking about is pretty basic we're just

470
00:24:57,000 --> 00:25:01,600
talking about registers in the processor that when you issue something

471
00:25:01,600 --> 00:25:07,000
like an ad, it does not have to add the entire B to the entire B, it

472
00:25:07,000 --> 00:25:08,900
can basically break them up into lanes.

473
00:25:08,900 --> 00:25:12,800
That get treated independently, which is I mean, like I said, really

474
00:25:12,800 --> 00:25:17,700
all we're talking about here, it's just it's that straightforward and

475
00:25:17,700 --> 00:25:18,600
so, you know,

476
00:25:19,400 --> 00:25:20,700
Hopefully, that's pretty clear.

477
00:25:20,700 --> 00:25:21,300
How that works?

478
00:25:22,500 --> 00:25:25,400
So, we have a compiling program here, I'm going to take just one

479
00:25:25,400 --> 00:25:26,000
second.

480
00:25:26,100 --> 00:25:30,300
I'm going to turn off optimization so we can take a look at the

481
00:25:30,300 --> 00:25:32,000
unoptimized code, right?

482
00:25:32,000 --> 00:25:34,900
So the processor, I mean, so the compiler is not doing anything fancy

483
00:25:34,900 --> 00:25:36,700
for us here, right?

484
00:25:37,400 --> 00:25:42,100
I want to show you what this actually looks like before we do anything

485
00:25:42,100 --> 00:25:44,400
else, significant to it, right?

486
00:25:44,900 --> 00:25:45,400
So,

487
00:25:46,800 --> 00:25:49,900
If I go in here, I'm just going to at the top of this.

488
00:25:49,900 --> 00:25:50,900
This thing.

489
00:25:50,900 --> 00:25:53,800
I'm going to show you just a little bit of how this works.

490
00:25:54,600 --> 00:25:56,500
So, first of all, I don't know.

491
00:25:56,500 --> 00:25:58,500
If you remember, we were taking a look at this on the screen the other

492
00:25:58,500 --> 00:26:00,800
day, a very handy thing.

493
00:26:01,100 --> 00:26:04,900
The Intel intrinsics guide, I want to show you how to use that because

494
00:26:04,900 --> 00:26:07,900
I never remember the mnemonics for some of the some of them, I

495
00:26:07,900 --> 00:26:10,900
remember that are simple like add or whatever but I never remember

496
00:26:10,900 --> 00:26:11,200
them.

497
00:26:11,500 --> 00:26:14,100
We're going to be using this extensively so you probably want to know

498
00:26:14,500 --> 00:26:15,100
this site.

499
00:26:15,100 --> 00:26:16,000
It's really handy.

500
00:26:16,000 --> 00:26:16,500
I don't know who

501
00:26:16,600 --> 00:26:19,900
Didn't L wrote it, but it's way easier than using the, the

502
00:26:19,900 --> 00:26:21,400
architecture manual, which is what I used to do.

503
00:26:21,400 --> 00:26:24,700
In fact, someone on the stream told me about this back, I guess when

504
00:26:24,700 --> 00:26:29,200
we first talked briefly about Cindy, someone told me about this and

505
00:26:29,200 --> 00:26:30,300
it's pretty great.

506
00:26:30,400 --> 00:26:34,100
And furthermore, it allows you to isolate down the instructions to

507
00:26:34,100 --> 00:26:36,000
only the ones that we are targeting.

508
00:26:36,000 --> 00:26:39,100
So, for example, we're trying to Target an sse2 processors, which if

509
00:26:39,100 --> 00:26:42,200
you target sse2, that covers basically all the processors anyone runs

510
00:26:42,200 --> 00:26:44,200
games on right now for Intel

511
00:26:45,300 --> 00:26:48,700
So, if we check those two, we can see all of the instructions that we

512
00:26:48,700 --> 00:26:50,400
can actually use, right?

513
00:26:50,400 --> 00:26:54,500
And when I say instructions, this is the actual instruction over here.

514
00:26:54,700 --> 00:26:55,900
The mnemonic for the instruction.

515
00:26:56,000 --> 00:26:58,100
This is actually what's called an intrinsic.

516
00:26:58,100 --> 00:26:59,500
We've talked about these before.

517
00:27:00,100 --> 00:27:04,100
We have them in a handmade intrinsic .h out here, right?

518
00:27:04,500 --> 00:27:06,200
Where we're trying to get the processor to do stuff.

519
00:27:08,500 --> 00:27:16,500
Basically, these are intrinsics that the that, that the compiler uses

520
00:27:16,500 --> 00:27:20,700
to, if they're basically things specified by Intel, which are supposed

521
00:27:20,700 --> 00:27:24,100
to tell the compiler to produce a specific Assembly, Language

522
00:27:24,100 --> 00:27:24,600
instructions.

523
00:27:24,600 --> 00:27:28,500
So that the programmer in see can say what Cindy stuff.

524
00:27:28,500 --> 00:27:29,700
They want to have happen.

525
00:27:30,000 --> 00:27:33,000
So it's basically like programming in a pseudo Assembly Language.

526
00:27:33,000 --> 00:27:35,600
It's not quite Assembly Language because you're not doing register

527
00:27:35,600 --> 00:27:39,400
allocation or specifying, registers your just specifying values, but

528
00:27:39,400 --> 00:27:41,400
you are specifying the instructions.

529
00:27:41,400 --> 00:27:43,900
So it's like, instruction, specification without register

530
00:27:43,900 --> 00:27:45,600
specification, that makes sense.

531
00:27:46,700 --> 00:27:48,400
So, these are the instructions that we have.

532
00:27:48,400 --> 00:27:51,500
And these are the data types, these little underscore underscore em,

533
00:27:51,700 --> 00:27:55,800
64 and 128, whatever that refers to one of the reddest, like,

534
00:27:55,800 --> 00:27:56,700
basically, a type.

535
00:27:56,700 --> 00:27:59,400
That is the same as what the register would hold, right?

536
00:28:00,400 --> 00:28:03,700
And the difference between these, this is just a stupid thing.

537
00:28:03,900 --> 00:28:06,900
These are all exactly the same type, mmm, 128.

538
00:28:07,800 --> 00:28:09,900
I am 21:28.

539
00:28:10,200 --> 00:28:11,600
All of those are the same.

540
00:28:12,100 --> 00:28:15,800
They're just, they introduced this week sort of typing model, and I

541
00:28:15,800 --> 00:28:16,200
really wish.

542
00:28:16,500 --> 00:28:17,300
I've done that.

543
00:28:18,000 --> 00:28:18,900
It's really annoying.

544
00:28:18,900 --> 00:28:21,800
But basically, they introduced sort of pseudo typing.

545
00:28:21,900 --> 00:28:25,700
So if you're executing, what would be an integer instruction, like

546
00:28:25,700 --> 00:28:26,700
that's treating the register.

547
00:28:26,700 --> 00:28:30,200
As if it contains integers, it expects the Type M 128.

548
00:28:30,200 --> 00:28:35,800
I but if you're issuing a instruction that expects something that is

549
00:28:35,900 --> 00:28:39,600
floating point, it's an M1 28, it's purely arbitrary.

550
00:28:39,600 --> 00:28:42,300
The processor does not distinguish between these two things in any

551
00:28:42,300 --> 00:28:43,900
way, and I really wish they hadn't done that.

552
00:28:43,900 --> 00:28:45,800
It's super super annoying.

553
00:28:45,900 --> 00:28:46,200
One of the

554
00:28:46,400 --> 00:28:49,700
Most annoying things in programming Cindy.

555
00:28:50,100 --> 00:28:51,700
But what do you do?

556
00:28:52,200 --> 00:28:52,700
So anyway,

557
00:28:54,300 --> 00:28:57,400
So, the way that you get one of these right is your use that

558
00:28:57,400 --> 00:28:59,700
underscore underscore and 128 that I showed you over there.

559
00:28:59,900 --> 00:29:00,400
Right?

560
00:29:00,900 --> 00:29:05,300
And you can basically say, you know, here is a here's a value and you

561
00:29:05,300 --> 00:29:08,800
can even do something like just initialize it to a constant, right?

562
00:29:09,200 --> 00:29:13,400
So cure is me initializing this thing to the value 1.0, right?

563
00:29:13,800 --> 00:29:15,700
And there's a couple different ways you can do this.

564
00:29:15,900 --> 00:29:16,700
Mmm set 1.

565
00:29:16,700 --> 00:29:23,100
PS basically says take this scalar value 1.0 and replicate it to all

566
00:29:23,100 --> 00:29:23,900
four lanes.

567
00:29:24,200 --> 00:29:25,000
Of the same day.

568
00:29:26,300 --> 00:29:26,800
Right?

569
00:29:27,200 --> 00:29:31,100
I can then say something like some equals.

570
00:29:31,300 --> 00:29:32,000
Mmm.

571
00:29:32,100 --> 00:29:32,500
Well you know what?

572
00:29:32,500 --> 00:29:33,500
I'll do this value.

573
00:29:33,500 --> 00:29:35,400
A and B, right?

574
00:29:35,600 --> 00:29:42,100
I'll make two and then I'll do add PS value, a value p and as you can

575
00:29:42,100 --> 00:29:45,000
see here, I'm just setting 11 all the full four lanes.

576
00:29:45,000 --> 00:29:46,300
Evaluate should be equal to 1.

577
00:29:46,300 --> 00:29:48,800
All four lanes of value B should be equal to 2 and then I want the

578
00:29:48,800 --> 00:29:50,800
process to add them together, right?

579
00:29:50,800 --> 00:29:52,200
That's all I'm going to do now.

580
00:29:52,200 --> 00:29:56,000
When we compile this it happens to compile properly, I think.

581
00:29:56,100 --> 00:29:59,900
That's because maybe we have the intrinsics or a specified in.

582
00:30:00,200 --> 00:30:02,200
I don't know if that's true.

583
00:30:02,200 --> 00:30:03,100
I'm not sure.

584
00:30:03,100 --> 00:30:05,700
I guess, to be honest with you I'm not sure why though.

585
00:30:06,800 --> 00:30:09,900
I'm not sure why those are defined typically you have to do a pound

586
00:30:09,900 --> 00:30:14,600
include like, you know, xmm intron dot h or there's there's like emm

587
00:30:14,600 --> 00:30:15,400
intron .h.

588
00:30:15,400 --> 00:30:18,100
There's a file that you have to include to do that, but it looks like

589
00:30:18,100 --> 00:30:19,500
it's already getting included in our train.

590
00:30:19,500 --> 00:30:22,900
I don't remember when we did that or why, but we're already including

591
00:30:22,900 --> 00:30:24,300
it so so we're good to go.

592
00:30:25,600 --> 00:30:29,400
All right, and these intrinsics will basically work on all x64

593
00:30:29,400 --> 00:30:30,900
compilers for the most part.

594
00:30:31,200 --> 00:30:35,800
Like, if you these are not actually stick to Microsoft Visual Studio,

595
00:30:35,800 --> 00:30:38,200
these are specific to the Target.

596
00:30:38,200 --> 00:30:42,600
So actually on llvm, you could also use, mmm, set, 1p, S and M 128.

597
00:30:42,600 --> 00:30:45,700
These will actually work on both their the same because until specify

598
00:30:45,700 --> 00:30:47,100
the format for the intrinsic.

599
00:30:47,100 --> 00:30:47,900
So that's kind of nice.

600
00:30:49,000 --> 00:30:51,700
All right, so if I go ahead and compile this, you can see it compiled

601
00:30:51,700 --> 00:30:52,100
fine.

602
00:30:52,400 --> 00:30:55,600
I want to go ahead and go into that render function.

603
00:30:57,100 --> 00:30:58,300
Why is it never loaded?

604
00:30:58,700 --> 00:30:59,300
Draw a rectangle.

605
00:30:59,300 --> 00:31:03,700
Hopefully quickly draw Tango hopefully quickly.

606
00:31:04,100 --> 00:31:09,300
So, and I'm going to go ahead and run to their and now I'm going to go

607
00:31:09,300 --> 00:31:12,900
into the disassembly so you can see what it looks like, right?

608
00:31:13,600 --> 00:31:14,200
So,

609
00:31:16,700 --> 00:31:17,700
Here's a disassembly.

610
00:31:18,500 --> 00:31:21,200
And if you can see in the register window, right?

611
00:31:21,200 --> 00:31:26,400
The registers window, these are those CMD registers, right?

612
00:31:26,700 --> 00:31:31,400
And this first, these first 8 here are the ones that were introduced

613
00:31:31,400 --> 00:31:32,700
originally with SSE.

614
00:31:33,000 --> 00:31:36,900
And then these additional registers are ones that were introduced

615
00:31:36,900 --> 00:31:40,200
later as they started to expand that destruction set so you can

616
00:31:40,200 --> 00:31:41,600
actually turn them on separately.

617
00:31:42,000 --> 00:31:45,200
Like if I if I turn off well,

618
00:31:46,300 --> 00:31:47,000
Maybe not.

619
00:31:47,300 --> 00:31:53,200
So in theory, it was supposed to change the display but it didn't do

620
00:31:53,200 --> 00:31:53,800
that.

621
00:31:54,500 --> 00:31:56,200
Let me see why it didn't do that.

622
00:31:57,400 --> 00:31:58,300
I don't know why.

623
00:31:58,300 --> 00:31:59,100
There we go.

624
00:31:59,900 --> 00:32:00,600
There we go.

625
00:32:01,500 --> 00:32:01,800
Mmm.

626
00:32:03,000 --> 00:32:06,000
much better so you can see well,

627
00:32:08,400 --> 00:32:09,400
I'll be completely honest with you.

628
00:32:09,400 --> 00:32:13,400
This is probably the worst possible way to view these registers I

629
00:32:13,400 --> 00:32:14,500
could possibly imagine.

630
00:32:15,700 --> 00:32:16,900
So ignore these.

631
00:32:16,900 --> 00:32:18,200
These are basically yet.

632
00:32:18,300 --> 00:32:19,800
We don't actually want to look at these for now.

633
00:32:19,800 --> 00:32:21,100
I do not know why they put them there.

634
00:32:21,300 --> 00:32:23,500
These were the actual registers that were in SSE.

635
00:32:23,700 --> 00:32:25,900
These are the rest registers that were expanded.

636
00:32:26,000 --> 00:32:31,400
So, as you can see, they basically added eight more registers to the

637
00:32:31,600 --> 00:32:37,300
to the processor and I guess this is just, this is their attempt,

638
00:32:37,500 --> 00:32:38,000
really?

639
00:32:38,100 --> 00:32:41,300
Lousy attempt at showing us, the floating Point values that are in

640
00:32:41,300 --> 00:32:45,400
there, so, I believe that this Maps like this guy Maps out to this,

641
00:32:45,500 --> 00:32:45,900
right?

642
00:32:45,900 --> 00:32:52,500
So xmm 00 is like this floating point value shown here, right?

643
00:32:52,500 --> 00:32:53,900
Because remember, these are for wide.

644
00:32:53,900 --> 00:32:56,800
So there's one value, there's one value, there's one value.

645
00:32:56,800 --> 00:32:58,100
There's one value, right?

646
00:32:58,100 --> 00:32:59,900
And so this is the these

647
00:33:00,000 --> 00:33:04,200
The, for floating Point values that are in XM 0, these are the four

648
00:33:04,200 --> 00:33:06,600
values that are in xmm one, right?

649
00:33:06,700 --> 00:33:10,400
So it's excellent 10 X-Men, 1 1, right?

650
00:33:10,400 --> 00:33:12,200
So it's just showing us what the components are.

651
00:33:12,800 --> 00:33:16,600
So you can see here, this move APS instruction, it basically grabbed

652
00:33:16,600 --> 00:33:20,200
out of a constant location which is where it's stored this 1.0 F.

653
00:33:20,200 --> 00:33:22,800
When we compile the program into XM M 0.

654
00:33:22,900 --> 00:33:26,700
So now we have one one, one one loaded across all four lanes right

655
00:33:26,700 --> 00:33:27,500
1111.

656
00:33:31,200 --> 00:33:31,600
Excuse me.

657
00:33:36,300 --> 00:33:40,400
Because we're in debug mode, it then goes ahead and stores that to the

658
00:33:40,400 --> 00:33:42,000
stock for absolutely no reason.

659
00:33:43,300 --> 00:33:48,000
In fact, I've really no reason why it's doing that, but that's what it

660
00:33:48,000 --> 00:33:48,400
did.

661
00:33:50,000 --> 00:33:55,000
It then goes ahead and loads the exact same value right back in again

662
00:33:55,200 --> 00:33:59,100
again, the horrors of debug output like, literally this was just

663
00:33:59,100 --> 00:34:01,300
stored in the stack and then read back from the stack.

664
00:34:01,300 --> 00:34:03,400
Why you would have to read back something from the stack that you

665
00:34:03,400 --> 00:34:06,300
already started the sock, I have no idea but then again I'm not an

666
00:34:06,300 --> 00:34:08,699
assembly jockey, maybe there's some reason why you would ever want to

667
00:34:08,699 --> 00:34:09,199
do that.

668
00:34:09,400 --> 00:34:10,400
Anyway, point being,

669
00:34:14,199 --> 00:34:14,800
It's just big.

670
00:34:14,900 --> 00:34:17,300
This is basically just a bunch of really annoying stuff that didn't

671
00:34:17,300 --> 00:34:17,900
need to happen.

672
00:34:17,900 --> 00:34:18,900
You can ignore it completely.

673
00:34:18,900 --> 00:34:20,600
This is the only instruction we actually cared about.

674
00:34:20,600 --> 00:34:22,500
And in release mode, that's probably, the only instruction we would

675
00:34:22,500 --> 00:34:29,600
have had their, we then go ahead and load in the other value which is

676
00:34:29,600 --> 00:34:35,300
to write and it does the same ridiculous nonsense and

677
00:34:38,100 --> 00:34:39,900
Oh, the debug compiler.

678
00:34:39,900 --> 00:34:44,000
I mean jeez how card could it have been to write that but I suppose

679
00:34:44,000 --> 00:34:46,500
it's trying to write it out to the stack so it's easy to inspect in

680
00:34:46,500 --> 00:34:47,000
the debugger.

681
00:34:47,000 --> 00:34:48,500
I don't even know why it's doing that.

682
00:34:48,500 --> 00:34:52,699
It's crazy town anyway so then you can kind of see what it's doing.

683
00:34:52,699 --> 00:34:57,600
Here it loads in value a finally into an actual register and then it

684
00:34:57,600 --> 00:35:01,200
does what's called an OP from memory which is it doesn't add

685
00:35:01,200 --> 00:35:03,800
instruction with the the register.

686
00:35:04,900 --> 00:35:08,900
That loaded with a and the quantity B, which it just does directly out

687
00:35:08,900 --> 00:35:09,800
of memory, right?

688
00:35:09,800 --> 00:35:13,800
And so, there it is and it produced as you can see for results, 1 2, 3

689
00:35:13,800 --> 00:35:15,100
4, right 3333.

690
00:35:17,700 --> 00:35:18,700
That's, that's it.

691
00:35:18,800 --> 00:35:23,700
That's MD in a nutshell, if the compiler wasn't absolutely nuts, you

692
00:35:23,700 --> 00:35:27,200
would only have basically this one, instruct.

693
00:35:27,200 --> 00:35:31,200
Well, honestly, you'd have this, this is what you have, right?

694
00:35:31,200 --> 00:35:34,500
You'd have one to move it into the register another, to add with that.

695
00:35:34,700 --> 00:35:40,000
Memory location because Intel processor, support memory Ops a lot of

696
00:35:40,000 --> 00:35:43,000
processors don't but Intel supports memory Ops.

697
00:35:43,000 --> 00:35:46,100
We're basically instead of having to move something into a register,

698
00:35:46,100 --> 00:35:50,200
you can actually say just operate directly like grab the red, grab the

699
00:35:50,500 --> 00:35:53,900
memory and do the op which, you know, doesn't actually require it

700
00:35:53,900 --> 00:35:55,000
going through the register.

701
00:35:56,200 --> 00:35:59,200
Doesn't require like naming it to an actual register.

702
00:36:00,000 --> 00:36:02,100
So that's all we're talking about.

703
00:36:02,100 --> 00:36:07,900
And so, as an example of how to do multiple of these, we can also use

704
00:36:07,900 --> 00:36:09,700
a separate intrinsic, right?

705
00:36:09,700 --> 00:36:15,400
Which we could set something, that's actually got four values.

706
00:36:16,800 --> 00:36:18,400
so, let's say we want to

707
00:36:19,600 --> 00:36:26,500
Set these guys, I'll do 100 here thousand and are, right?

708
00:36:27,000 --> 00:36:31,700
So that will actually now show how to do for ads with just those

709
00:36:31,700 --> 00:36:32,500
instructions.

710
00:36:34,300 --> 00:36:34,800
Here we go.

711
00:36:38,200 --> 00:36:41,700
So now you can see I'm going to skip right to the good part.

712
00:36:41,800 --> 00:36:44,400
So here's the actual operations that the processor would actually need

713
00:36:44,400 --> 00:36:44,900
to do.

714
00:36:45,500 --> 00:36:49,700
We take that value a and we loaded into this xmm register so you can

715
00:36:49,700 --> 00:36:50,100
see it here.

716
00:36:50,100 --> 00:36:54,600
4 3, 2, 1, like so now you'll notice

717
00:36:56,500 --> 00:36:59,200
Actually, the ordering there is a little suspicious, right?

718
00:37:02,500 --> 00:37:05,000
I always forget this it bites me every time.

719
00:37:05,800 --> 00:37:10,800
In fact, it bit me last night actually when I was doing witness code

720
00:37:10,800 --> 00:37:14,800
optimization stuff, it only takes a second to figure out, so it's not

721
00:37:14,800 --> 00:37:19,600
a bad bug, but I always think of it as least significant first to last

722
00:37:19,600 --> 00:37:21,700
significant took two most significant.

723
00:37:21,800 --> 00:37:26,000
So I think of it as loading one into the low register to hire to the

724
00:37:26,000 --> 00:37:28,800
low part to hire three higher for higher.

725
00:37:29,400 --> 00:37:32,200
But the wait until specified, this intrinsic was backwards.

726
00:37:32,600 --> 00:37:35,700
So they actually put the most significant byte, as the first

727
00:37:35,700 --> 00:37:36,300
parameter.

728
00:37:36,800 --> 00:37:41,900
So, it actually loads in, in reverse order from what you see here,

729
00:37:41,900 --> 00:37:42,200
right?

730
00:37:42,200 --> 00:37:45,100
It's like normally, if it was loading on a memory, it would load here,

731
00:37:45,100 --> 00:37:46,400
here here here.

732
00:37:47,100 --> 00:37:51,400
So if the memory order was this way, it would load one, two, three,

733
00:37:51,400 --> 00:37:51,900
four.

734
00:37:52,000 --> 00:37:53,100
But it actually does.

735
00:37:53,100 --> 00:37:55,200
This intrinsic specify to do it the opposite way.

736
00:37:55,400 --> 00:37:59,300
So it actually loads for in to hear it.

737
00:37:59,300 --> 00:38:00,000
Does it the way it?

738
00:38:00,000 --> 00:38:01,300
Would it prints out, right?

739
00:38:01,300 --> 00:38:02,200
It does it the way you would read?

740
00:38:02,400 --> 00:38:03,800
Out the register in a debugger.

741
00:38:04,800 --> 00:38:07,600
And so just something to point out there.

742
00:38:09,000 --> 00:38:13,300
Anyway, so we do this set, you can see we loaded for three, two and

743
00:38:13,300 --> 00:38:16,000
one in there, and then we're going to do the op from memory.

744
00:38:16,000 --> 00:38:19,700
So it's going to do be directly and there's the op and now you can see

745
00:38:19,700 --> 00:38:20,800
what it did, right?

746
00:38:20,800 --> 00:38:22,000
It's got 1,000.

747
00:38:23,900 --> 00:38:30,900
Excuse me, it's got 1, plus 100 plus 23, plus 1000, and 10,000 plus 4,

748
00:38:31,100 --> 00:38:31,300
right?

749
00:38:31,300 --> 00:38:32,900
So computed all four of those results.

750
00:38:33,600 --> 00:38:34,200
All right.

751
00:38:34,600 --> 00:38:38,500
So that's literally all we're talking about with Cindy, okay?

752
00:38:38,500 --> 00:38:40,300
That's, that's it right?

753
00:38:40,300 --> 00:38:43,900
There's, there's nothing more complicated going on there.

754
00:38:47,500 --> 00:38:48,500
Hopefully, it's pretty clear.

755
00:38:48,500 --> 00:38:51,600
What's happening, very very straightforward.

756
00:38:52,300 --> 00:38:55,400
The trick, in fact, and when you are, when you're translating math

757
00:38:55,400 --> 00:38:57,900
code, it's usually super easy.

758
00:38:57,900 --> 00:38:59,800
I mean, it's usually as simple as

759
00:39:00,000 --> 00:39:04,900
Want to do an ad you type, mmm, ad PS, like it's that dumb and then

760
00:39:04,900 --> 00:39:05,400
things are for.

761
00:39:05,400 --> 00:39:10,000
Why the all of the Finesse all the hard part comes in the like

762
00:39:10,000 --> 00:39:10,700
preambles.

763
00:39:10,700 --> 00:39:16,400
Usually it comes in saying, okay, you know, I got data in this format

764
00:39:16,400 --> 00:39:19,400
and I got a munch it over to this format or I need to operate on it in

765
00:39:19,400 --> 00:39:20,000
this other way.

766
00:39:20,000 --> 00:39:22,300
So I gotta rotate it or rearrange it.

767
00:39:22,500 --> 00:39:25,300
So typically what you're talking about when you do Cindy programming,

768
00:39:25,800 --> 00:39:28,200
when you say like oh I gotta send the optimize this routine.

769
00:39:28,200 --> 00:39:29,900
You're not talking about

770
00:39:30,000 --> 00:39:31,800
Translating plus into mmm.

771
00:39:31,800 --> 00:39:34,800
Add PS because that's brain-dead and super easy.

772
00:39:35,000 --> 00:39:37,700
Usually what you're talking about is how to structure the data so that

773
00:39:37,700 --> 00:39:43,600
you don't waste all your time, fussing with it and and you'll kind of

774
00:39:43,600 --> 00:39:46,800
see as we go through what I'm, what, I mean by that, right?

775
00:39:47,600 --> 00:39:50,600
So let's take a simple example here, right?

776
00:39:50,800 --> 00:39:55,800
Let's just take one set of things that we're doing and turn them into

777
00:39:55,800 --> 00:39:57,900
Cindy Cindy, right?

778
00:39:59,100 --> 00:40:04,200
So right now we've got this srgb to linear brightness face thing.

779
00:40:04,200 --> 00:40:07,200
And you can see that this is just a bunch of multiplies, right?

780
00:40:07,700 --> 00:40:11,900
In fact if we were to simplify this down a little bit more, this

781
00:40:11,900 --> 00:40:14,500
Square function, if we were to get that square function out of there,

782
00:40:14,800 --> 00:40:19,000
right, take it take the square function out it would look like this,

783
00:40:19,000 --> 00:40:19,500
right?

784
00:40:29,800 --> 00:40:30,400
Make sense.

785
00:40:31,100 --> 00:40:34,200
That's that's what that's what we're really talking about, right?

786
00:40:36,600 --> 00:40:38,800
So, if I take a look at this, right, we're all running fine.

787
00:40:39,700 --> 00:40:42,200
This is the actual code that's being executed, and hopefully, you can

788
00:40:42,200 --> 00:40:45,900
see that this should be pretty simple to Cindy eyes, right?

789
00:40:46,300 --> 00:40:47,300
That would be pretty.

790
00:40:47,300 --> 00:40:48,700
That would be pretty straightforward.

791
00:40:51,000 --> 00:40:53,400
Although now that I think about it, we probably want to do one step

792
00:40:53,400 --> 00:40:53,900
before hand.

793
00:40:53,900 --> 00:40:56,500
We got what we got, 20 minutes left, let's do one step before hanging

794
00:40:56,500 --> 00:40:58,300
so make it easier to think about I'll leave.

795
00:40:58,500 --> 00:40:59,900
For one second but that's right.

796
00:40:59,900 --> 00:41:02,100
I mean you can kind of see this as just a bunch of multiplies that's

797
00:41:02,100 --> 00:41:03,200
all that is right.

798
00:41:04,600 --> 00:41:09,200
All right, so the first thing that I was going to say is well before

799
00:41:09,200 --> 00:41:12,600
we actually do any of that I guess I have to fix my Loop right to run

800
00:41:12,600 --> 00:41:15,600
over pixels and batches of for, right.

801
00:41:20,000 --> 00:41:23,200
That's kind of just obvious.

802
00:41:23,900 --> 00:41:28,000
So if I'm going to do pixels in batches of, for, I'm going to need to

803
00:41:28,000 --> 00:41:29,700
modify the way I Loop over X for now.

804
00:41:29,700 --> 00:41:32,900
So let's, let's actually start by doing that and there's some things

805
00:41:32,900 --> 00:41:36,200
that kind of go along with that that we kind of have to talk about as

806
00:41:36,200 --> 00:41:36,500
well.

807
00:41:38,000 --> 00:41:42,700
All right, so there's some things with like alignment and stuff like

808
00:41:42,700 --> 00:41:42,900
that.

809
00:41:42,900 --> 00:41:46,200
So I'm not really going to talk too much right now because it's not

810
00:41:46,200 --> 00:41:48,900
the focus of today's episode about how to get this data out

811
00:41:48,900 --> 00:41:50,200
efficiently or any that stuff.

812
00:41:50,200 --> 00:41:52,800
We're just going to do the simplest possible thing for the loading

813
00:41:53,100 --> 00:41:55,600
right now, and then later on, we're going to have to look probably a

814
00:41:55,600 --> 00:41:59,400
little more closely at this, for some other, for other reasons.

815
00:41:59,500 --> 00:41:59,800
But for right,

816
00:42:00,000 --> 00:42:03,800
Now, let's just stick with talking about this very straightforward.

817
00:42:04,400 --> 00:42:06,900
So what I want to do first is I want to say, all right, I'm starting

818
00:42:06,900 --> 00:42:09,800
an X-Man and I'm going to go by by fours, right?

819
00:42:09,800 --> 00:42:11,600
So I'm going to, I'm going to do it this way, right?

820
00:42:11,600 --> 00:42:13,000
So I'm going to do 4 pics that time.

821
00:42:13,200 --> 00:42:17,200
Now, if I just literally just do that, right?

822
00:42:18,200 --> 00:42:20,000
You can see what happens here, right?

823
00:42:21,000 --> 00:42:22,600
Which is that everything basically works fine.

824
00:42:23,200 --> 00:42:26,100
But I'm I'm a little too, I'm smooshed, right?

825
00:42:26,600 --> 00:42:29,800
And that's just because down at the bottom when we

826
00:42:30,000 --> 00:42:31,000
Advanced a pixel.

827
00:42:31,200 --> 00:42:33,900
We're only advancing one pixel at a time, right?

828
00:42:34,000 --> 00:42:38,300
So if I actually change to advancing four pixels at a time, now, when

829
00:42:38,300 --> 00:42:40,300
I run it, we should in theory.

830
00:42:42,700 --> 00:42:50,100
And we do basically get you know kind of a screen door version of this

831
00:42:50,100 --> 00:42:51,800
here, right?

832
00:42:51,800 --> 00:42:56,100
Which is as we go we're advancing 4 pixels at a time trying to think.

833
00:42:56,100 --> 00:42:57,200
Did I miss anything else?

834
00:42:57,200 --> 00:42:58,200
Sir, I don't think I did.

835
00:42:58,300 --> 00:43:00,600
That's what we should have been able to do, right?

836
00:43:00,600 --> 00:43:01,800
We read out the pixels.

837
00:43:02,000 --> 00:43:03,400
We advance for Pixel at a time.

838
00:43:03,600 --> 00:43:05,000
I think that's still correct.

839
00:43:05,100 --> 00:43:06,000
It's not correct.

840
00:43:06,600 --> 00:43:07,400
I think that's right.

841
00:43:08,100 --> 00:43:09,200
This is less than X Men.

842
00:43:09,600 --> 00:43:11,400
It's not exactly what I expected to see.

843
00:43:11,600 --> 00:43:12,000
I would have

844
00:43:12,300 --> 00:43:13,300
Back to the Sea.

845
00:43:16,100 --> 00:43:18,700
Always there be a little bit of tree there.

846
00:43:20,600 --> 00:43:22,500
It's a little bit weird.

847
00:43:25,800 --> 00:43:26,700
Why is that?

848
00:43:36,400 --> 00:43:37,400
That is just weird.

849
00:43:37,500 --> 00:43:38,800
That's not what I expected to see.

850
00:43:39,600 --> 00:43:43,700
I'm a little bit weirded out by that is there are some other thing

851
00:43:43,700 --> 00:43:49,900
we're doing that means that that is not proper because that should

852
00:43:49,900 --> 00:43:52,500
have just been more of a screen door effect than it was.

853
00:43:54,600 --> 00:43:56,300
So I'm a little weirded out by that.

854
00:43:56,500 --> 00:44:03,700
So pixel plus equals 4 it's advancing 4, pixels is pixel pixel is a

855
00:44:03,700 --> 00:44:05,000
you and 32.0 right?

856
00:44:05,000 --> 00:44:06,900
So that will advance for pixels at a time.

857
00:44:07,300 --> 00:44:11,400
We're going by for in X so it's knows what the correct x-coordinate is

858
00:44:11,700 --> 00:44:13,600
and loads that out.

859
00:44:14,000 --> 00:44:17,500
So yeah, I'm not sure, that's not what I would have expected to see.

860
00:44:17,600 --> 00:44:20,800
I'm going to keep going here, but I'm a little weirded out by that but

861
00:44:20,800 --> 00:44:21,200
okay.

862
00:44:23,400 --> 00:44:23,900
All right.

863
00:44:24,800 --> 00:44:29,900
And then in here, I'm just going to go ahead and say, you know, the

864
00:44:29,900 --> 00:44:31,000
very stupidest thing.

865
00:44:31,700 --> 00:44:35,000
I'm going to say p and X or something like this.

866
00:44:35,400 --> 00:44:39,000
And I'm going to actually Loop over the four pixels, which again, this

867
00:44:39,000 --> 00:44:41,300
is actually just adding insult to injury in going to make our routine

868
00:44:41,300 --> 00:44:41,900
slower.

869
00:44:42,100 --> 00:44:46,300
But, like I said, at the moment, I'm actually not.

870
00:44:46,300 --> 00:44:48,700
That's not the thing that I'm actually concerned about.

871
00:44:50,500 --> 00:44:51,700
At all.

872
00:44:51,700 --> 00:44:54,400
I'm just trying to structure this so that we can start to work on it.

873
00:44:54,400 --> 00:44:59,100
So I'm going to go through these four here and I guess inside here I

874
00:44:59,100 --> 00:44:59,900
will go ahead and

875
00:45:00,000 --> 00:45:01,600
And do the plus + pixel.

876
00:45:02,100 --> 00:45:06,200
And so hopefully now we will get back to drawing everything.

877
00:45:06,500 --> 00:45:12,700
There we go, all right now, excuse me.

878
00:45:13,300 --> 00:45:16,500
So as you can see in that in that screenshot fact Let me show that one

879
00:45:16,500 --> 00:45:17,400
more explicitly there.

880
00:45:18,600 --> 00:45:21,600
You can see kind of in here that we are blocky.

881
00:45:22,100 --> 00:45:22,700
Right?

882
00:45:23,100 --> 00:45:28,700
You can see that that we are that we're basically just spread out for

883
00:45:28,700 --> 00:45:29,800
Pixel wide and the

884
00:45:30,000 --> 00:45:33,600
Reason for that is we're incrementing X at all here, right?

885
00:45:34,200 --> 00:45:39,600
So the actual value, the actual x value is not getting incremented as

886
00:45:39,600 --> 00:45:41,400
we step through those four different pixels.

887
00:45:42,000 --> 00:45:45,200
And so, if we wanted to fix that, we could just go ahead and say, all

888
00:45:45,200 --> 00:45:51,500
right, we've got our like X iterator on the outside, but the actual x

889
00:45:51,500 --> 00:45:55,900
value that we're actually using is, is computed separately.

890
00:45:55,900 --> 00:45:59,100
So that's going to be equal to X Plus DX I, right?

891
00:45:59,200 --> 00:45:59,900
So now we're actually

892
00:46:00,000 --> 00:46:00,400
Away.

893
00:46:02,000 --> 00:46:02,400
Oops.

894
00:46:08,500 --> 00:46:08,900
Area.

895
00:46:15,400 --> 00:46:16,500
Sorry, little out of it today.

896
00:46:16,600 --> 00:46:17,400
It's early morning.

897
00:46:20,400 --> 00:46:23,900
Alright, so now we're back to drawing the right things, but we're

898
00:46:23,900 --> 00:46:26,000
doing Loops in terms of for.

899
00:46:26,500 --> 00:46:30,600
And the thing that I want to call your attention to, in addition is

900
00:46:30,600 --> 00:46:32,900
there's a little artifact to pay attention to here.

901
00:46:33,400 --> 00:46:36,900
And this will come into play a little bit later, which is that, if you

902
00:46:37,200 --> 00:46:39,600
look on the side of the screen, right?

903
00:46:39,700 --> 00:46:43,400
You can see that we're over writing our boundary by a little bit,

904
00:46:43,500 --> 00:46:44,100
right?

905
00:46:44,200 --> 00:46:46,300
You can see the stuff that's over here.

906
00:46:46,400 --> 00:46:48,400
Come on, to the screen over here.

907
00:46:48,800 --> 00:46:49,300
Okay.

908
00:46:50,500 --> 00:46:55,200
Now why that's happening is because we're still going by 4 pixels even

909
00:46:55,200 --> 00:46:58,400
if we pick the the rightmost pics of the screen, we're overriding by

910
00:46:58,400 --> 00:47:01,500
50 pixels which wraps around on to the next row.

911
00:47:02,100 --> 00:47:03,000
It does that make sense.

912
00:47:03,500 --> 00:47:08,900
So what that means is that technically, we're over writing, we're

913
00:47:08,900 --> 00:47:10,300
overriding our row by a little bit.

914
00:47:10,300 --> 00:47:12,200
Now, like I said, I don't want to worry about that stuff at the

915
00:47:12,200 --> 00:47:14,300
moment, we're just going to talk about the, the Straight Ahead Cindy

916
00:47:14,300 --> 00:47:14,800
stuff.

917
00:47:15,100 --> 00:47:17,300
So, all I'm going to do is prevent us from since we're only going to

918
00:47:17,300 --> 00:47:19,800
ever write down to the other side of the screen, I'm just gonna

919
00:47:20,100 --> 00:47:23,900
Prevent that by clipping a slightly here, right?

920
00:47:24,000 --> 00:47:28,700
So what I want to do is take that with Max and that height Max where

921
00:47:28,700 --> 00:47:29,400
did those go?

922
00:47:30,800 --> 00:47:36,700
These guys here, let's see yeah I'm going to temporarily assume that

923
00:47:36,700 --> 00:47:39,100
the the buffers are smaller than they actually are.

924
00:47:39,300 --> 00:47:39,700
Right?

925
00:47:39,800 --> 00:47:42,300
So I'm going to put it to do in here Casey

926
00:47:49,300 --> 00:47:51,700
So once we actually talk about more of how we're going to do loading

927
00:47:51,700 --> 00:47:56,100
stuff and we fix that, I'm just going to go ahead and make sure that I

928
00:47:56,100 --> 00:47:57,400
guess we could do it by -3.

929
00:47:57,700 --> 00:47:59,800
I'm going to make sure that we don't have that happen.

930
00:48:00,300 --> 00:48:06,000
By just pre clipping things to be a little bit to have a little bit of

931
00:48:06,000 --> 00:48:06,500
a border.

932
00:48:06,800 --> 00:48:11,000
So now we just don't fill that part of the screen, right?

933
00:48:11,500 --> 00:48:12,200
And now we're fine.

934
00:48:13,000 --> 00:48:15,400
And again, that's just a to prevent us from over writing the memory in

935
00:48:15,400 --> 00:48:17,400
wondering, what the hell is going on there, right?

936
00:48:18,800 --> 00:48:19,300
All right.

937
00:48:20,100 --> 00:48:22,900
So now let's talk about the Cindy, part of things, right?

938
00:48:23,400 --> 00:48:25,300
So when we do these four operations,

939
00:48:29,100 --> 00:48:29,600
Excuse me.

940
00:48:33,100 --> 00:48:36,900
Like I said, what we want to do here is we want to be able to do all

941
00:48:36,900 --> 00:48:37,700
of these things.

942
00:48:38,100 --> 00:48:39,200
Essentially four wide.

943
00:48:43,600 --> 00:48:45,700
We're going to ignore some of the tricky stuff with the loading and

944
00:48:45,700 --> 00:48:49,600
stuff for now, like I said, but once we get down to here, maybe we

945
00:48:49,600 --> 00:48:55,200
would like to start doing things in actual widths of for, right?

946
00:48:56,200 --> 00:48:59,500
So what we could do is we could take this first part here.

947
00:48:59,500 --> 00:49:01,500
This p and X part, right?

948
00:49:02,400 --> 00:49:06,900
And we could start by critic having that off, so that we do these

949
00:49:06,900 --> 00:49:08,300
operations for times.

950
00:49:08,300 --> 00:49:12,100
But then not these ones down here, right?

951
00:49:12,600 --> 00:49:13,000
And then

952
00:49:13,100 --> 00:49:18,000
I'm going to essentially sort of bracket if you will the routine like

953
00:49:18,000 --> 00:49:18,400
so.

954
00:49:20,200 --> 00:49:20,900
Let's see here.

955
00:49:23,500 --> 00:49:27,400
Yeah, like this, we go.

956
00:49:30,400 --> 00:49:35,000
Again, this is kind of since I'm normally, I would not do this the way

957
00:49:35,000 --> 00:49:36,000
that I'm doing it.

958
00:49:36,200 --> 00:49:37,600
I would not do it in these stages.

959
00:49:37,600 --> 00:49:41,300
I just go ahead and write it, Cindy kind of directly because this is

960
00:49:41,300 --> 00:49:45,700
sort of a wasted work that I'm doing if that makes sense, but I kind

961
00:49:45,700 --> 00:49:48,900
of want to show it to you step-by-step and so it's I think we're

962
00:49:48,900 --> 00:49:52,400
spending a little extra time to just kind of go through and do it in a

963
00:49:52,400 --> 00:49:59,000
series of Transformations, so that you can kind of see it a little

964
00:49:59,000 --> 00:49:59,900
more explicitly.

965
00:50:00,200 --> 00:50:00,600
Right.

966
00:50:02,100 --> 00:50:02,700
All right.

967
00:50:03,100 --> 00:50:05,900
So what I'm doing is I'm breaking this up into multiple Loops here.

968
00:50:07,100 --> 00:50:10,500
Okay, there we go.

969
00:50:10,800 --> 00:50:14,600
And I'm going to get rid of the fill pixel timer because we're going

970
00:50:14,600 --> 00:50:18,200
to stop actually having that particular piece of data in a second

971
00:50:18,200 --> 00:50:18,500
here.

972
00:50:19,300 --> 00:50:23,400
So what I want to do is I want to go ahead and Loft these things out

973
00:50:23,600 --> 00:50:27,800
so that I can basically execute a loop and make a bunch of values.

974
00:50:28,000 --> 00:50:31,300
And then execute another loop that's going to be in Cindy that uses

975
00:50:31,300 --> 00:50:32,000
those values.

976
00:50:32,500 --> 00:50:36,400
And then finally X Cube, one more Loop that does

977
00:50:36,800 --> 00:50:37,400
The retirement.

978
00:50:37,400 --> 00:50:40,100
And basically, what I've done here is, I've separated the memory

979
00:50:40,100 --> 00:50:43,600
loading stuff, which I don't want to talk about yet, from the actual

980
00:50:43,600 --> 00:50:45,200
just computation, like all of this.

981
00:50:45,200 --> 00:50:49,000
You can see in here is just straight computations, not much is going

982
00:50:49,000 --> 00:50:49,100
on.

983
00:50:49,100 --> 00:50:53,100
Now, the destination load I would like to be in the memory part,

984
00:50:54,400 --> 00:50:54,900
right.

985
00:50:55,300 --> 00:50:59,500
So, we'll put that in there as well, so and so, here we go.

986
00:51:00,000 --> 00:51:03,000
This isn't going to compile because obviously tons of these things,

987
00:51:03,400 --> 00:51:05,300
you know, now only exists inside here.

988
00:51:05,300 --> 00:51:07,700
So what I need to now do is just transform stuff.

989
00:51:07,700 --> 00:51:13,600
So that these are put all of this stuff here is put into external sort

990
00:51:13,600 --> 00:51:14,700
of registers, right?

991
00:51:14,700 --> 00:51:16,500
External variables.

992
00:51:16,900 --> 00:51:22,900
So we have the outputs of this routine here that we actually need, are

993
00:51:22,900 --> 00:51:26,600
the dest and the Texel values, right?

994
00:51:28,000 --> 00:51:29,000
So, I'm going to put those in here.

995
00:51:29,800 --> 00:51:35,300
So we've got Texel AR and that's four floats, right?

996
00:51:36,400 --> 00:51:41,300
So a g, a b, a and then we've got the

997
00:51:43,700 --> 00:51:47,200
B, c d.

998
00:51:48,600 --> 00:51:51,600
And again, don't worry that like I know this looks kind of ugly and oh

999
00:51:51,600 --> 00:51:53,500
my God, he's having to do all this stuff again.

1000
00:51:53,500 --> 00:51:55,400
You don't have to do any of this stuff.

1001
00:51:55,400 --> 00:51:58,800
I'm just want to get this code into something where I can show you

1002
00:51:58,800 --> 00:52:01,700
just one isolated part of it and work our way out when you actually

1003
00:52:01,700 --> 00:52:03,900
put them on Sunday, none of the stuff that I'm doing right here.

1004
00:52:04,100 --> 00:52:07,300
And you'll see that once we finish this routine, you'll see that none

1005
00:52:07,300 --> 00:52:08,000
of this stuff is in there.

1006
00:52:08,000 --> 00:52:11,300
So this is literally just setting up the code so that it runs in

1007
00:52:11,300 --> 00:52:14,100
multiple chunks so that I can show you how to optimize one chunk

1008
00:52:14,100 --> 00:52:16,400
without having talked about the others so, so please do not be

1009
00:52:16,400 --> 00:52:16,900
nervous.

1010
00:52:17,200 --> 00:52:18,200
None of this has to do with

1011
00:52:18,400 --> 00:52:18,900
Deprogramming.

1012
00:52:18,900 --> 00:52:22,700
This is literally just a rigid transformation that I'm doing here.

1013
00:52:23,900 --> 00:52:28,300
All right, so I'm going to go ahead and you know what?

1014
00:52:28,300 --> 00:52:29,800
Let's just rectangle, this stuff.

1015
00:52:32,900 --> 00:52:33,400
There we go.

1016
00:52:37,200 --> 00:52:41,500
And so all I'm going to do is I guess I'm going to use, I to say which

1017
00:52:41,500 --> 00:52:43,200
one of these were using i-i-i-i-i-i-i-i-i-i-i-i.

1018
00:52:49,700 --> 00:52:50,200
This.

1019
00:52:53,200 --> 00:52:54,700
And then we're just going to Loop over eye.

1020
00:52:59,800 --> 00:53:00,200
There we go.

1021
00:53:01,700 --> 00:53:04,800
Okay, so let's go ahead and compile that whereas our first error,

1022
00:53:05,200 --> 00:53:06,200
let's get rid of that guy.

1023
00:53:08,000 --> 00:53:08,500
Okay.

1024
00:53:09,400 --> 00:53:14,200
So well as you can see all I did was I just made place to store all

1025
00:53:14,200 --> 00:53:16,400
the stuff that we load and then we load it.

1026
00:53:16,400 --> 00:53:19,900
All right, so we load all our textiles in we load all our destination

1027
00:53:19,900 --> 00:53:20,300
in.

1028
00:53:20,400 --> 00:53:23,100
So with this is just a loop that does all the loads.

1029
00:53:23,300 --> 00:53:26,400
Now there's one more thing that we need to know, right?

1030
00:53:26,400 --> 00:53:28,000
And that's basically just a like

1031
00:53:29,800 --> 00:53:31,800
Should fill or something, right?

1032
00:53:31,800 --> 00:53:36,800
Which is we just need to know which one of, you know, whether we're

1033
00:53:36,800 --> 00:53:38,000
filling it or not.

1034
00:53:38,300 --> 00:53:39,100
So we just need to know.

1035
00:53:39,100 --> 00:53:42,000
Should fill I equals false, right?

1036
00:53:42,000 --> 00:53:45,200
Or if we're inside here, should feel like was true, right?

1037
00:53:45,300 --> 00:53:47,700
So, basically, what we need to do is just this, right?

1038
00:53:47,700 --> 00:53:51,000
We've got a should fill value and then only if we should fill it, do

1039
00:53:51,000 --> 00:53:54,300
we actually bother to load all the rest of the stuff out of it, right?

1040
00:53:54,300 --> 00:53:55,200
It looks like that.

1041
00:53:57,100 --> 00:53:59,500
That makes sense pretty straightforward.

1042
00:54:01,800 --> 00:54:05,400
So basically what we want to do here is we then want to Loop through

1043
00:54:05,400 --> 00:54:06,300
these things again.

1044
00:54:06,800 --> 00:54:07,300
Right?

1045
00:54:07,700 --> 00:54:08,800
Let's go ahead and do that.

1046
00:54:09,300 --> 00:54:13,000
And now I just want to do these operations on each of the things that

1047
00:54:13,000 --> 00:54:15,600
were actually talking about, right?

1048
00:54:15,600 --> 00:54:16,800
So I've got my eye here.

1049
00:54:20,200 --> 00:54:20,800
Like so.

1050
00:54:25,000 --> 00:54:27,900
And again just totally straightforward.

1051
00:54:28,200 --> 00:54:29,500
I'm not doing anything at all.

1052
00:54:29,500 --> 00:54:35,200
Other than converting this routines to run in a series of batched of

1053
00:54:35,200 --> 00:54:35,900
batches of four.

1054
00:54:37,400 --> 00:54:40,000
And none of the stuff like I said would be necessary if you just

1055
00:54:40,000 --> 00:54:42,300
already knew somebody programming, you wouldn't bother doing any of

1056
00:54:42,300 --> 00:54:43,400
these things that I'm doing here.

1057
00:54:44,400 --> 00:54:49,500
It's literally just a set us up to make sure we can properly do what

1058
00:54:49,500 --> 00:54:50,000
we need to do.

1059
00:54:54,300 --> 00:54:57,000
What's funny, is, like the code to show how to do, it is actually more

1060
00:54:57,000 --> 00:54:59,800
complicated than the code that actually just does it, but that's,

1061
00:55:00,500 --> 00:55:02,200
that's just how things go sometimes.

1062
00:55:04,900 --> 00:55:05,900
Oops, I didn't mean to do that.

1063
00:55:05,900 --> 00:55:06,500
I don't think.

1064
00:55:13,400 --> 00:55:16,500
Okay and f x.

1065
00:55:18,000 --> 00:55:19,900
So FX comes out of here as well.

1066
00:55:19,900 --> 00:55:27,500
Although FX is just he X for that value.

1067
00:55:28,800 --> 00:55:29,600
Right?

1068
00:55:29,600 --> 00:55:30,800
So we need f x.

1069
00:55:30,800 --> 00:55:37,900
So we need we need, let's see.

1070
00:55:39,100 --> 00:55:41,600
We need an, we need just FX.

1071
00:55:42,400 --> 00:55:43,800
Which ones do we need down here?

1072
00:55:46,200 --> 00:55:47,900
Looks like we only need FX.

1073
00:55:47,900 --> 00:55:53,900
So, we also need to compute FX and FY, right?

1074
00:55:56,200 --> 00:55:57,200
so, these guys

1075
00:55:59,800 --> 00:56:00,700
are also that way.

1076
00:56:04,300 --> 00:56:05,000
Is that correct?

1077
00:56:07,600 --> 00:56:07,900
Yeah.

1078
00:56:19,800 --> 00:56:24,300
so, now we've got down to desk and desk, obviously, also,

1079
00:56:25,600 --> 00:56:26,600
Structured this way.

1080
00:56:29,900 --> 00:56:30,900
And put that together.

1081
00:56:31,500 --> 00:56:34,900
We go and the output.

1082
00:56:34,900 --> 00:56:38,800
So what it needs to write out here is Blended, so blend, it is also

1083
00:56:39,400 --> 00:56:40,100
done this way.

1084
00:56:40,600 --> 00:56:45,000
Like so let's go ahead and get that out.

1085
00:56:48,600 --> 00:56:49,300
All right.

1086
00:56:54,900 --> 00:56:58,200
And last but not least you actual pack.

1087
00:56:59,500 --> 00:56:59,800
All right.

1088
00:57:04,300 --> 00:57:07,700
Set think we're basically done with that.

1089
00:57:08,800 --> 00:57:10,100
You're too Blended.

1090
00:57:19,200 --> 00:57:19,500
Yeah.

1091
00:57:21,400 --> 00:57:22,000
Now.

1092
00:57:25,000 --> 00:57:26,700
Oops, that's not good.

1093
00:57:27,900 --> 00:57:28,700
What did I make?

1094
00:57:28,700 --> 00:57:33,100
I made I have made a grievous error of some kind.

1095
00:57:34,300 --> 00:57:36,800
In my in my transformation here.

1096
00:57:39,600 --> 00:57:44,100
Exercise should fill equals.

1097
00:57:44,300 --> 00:57:46,400
What is that problem there.

1098
00:57:47,300 --> 00:57:50,200
X x is less than texture with.

1099
00:57:50,600 --> 00:57:51,900
What is the texture with?

1100
00:57:53,700 --> 00:57:54,400
Is 81.

1101
00:57:54,400 --> 00:57:56,100
So it's right on the boundary.

1102
00:57:59,600 --> 00:58:00,800
Why has that?

1103
00:58:00,800 --> 00:58:03,100
Why have half that happened?

1104
00:58:04,300 --> 00:58:11,100
Equals X 60 X, qu with -2, so, that should not actually be possible.

1105
00:58:12,200 --> 00:58:16,000
So, I think I actually made a mistake here when I was doing my

1106
00:58:16,000 --> 00:58:17,100
Transformations.

1107
00:58:18,800 --> 00:58:25,600
Oh, it would help if I actually tested the show should fill value.

1108
00:58:27,400 --> 00:58:27,900
There we go.

1109
00:58:32,200 --> 00:58:34,000
So it looks like I messed up.

1110
00:58:34,400 --> 00:58:36,000
Oh yes.

1111
00:58:37,000 --> 00:58:39,700
So we're testing, the should fill value, but then I'm not actually

1112
00:58:39,700 --> 00:58:42,700
doing the test for the should fill value out here.

1113
00:58:42,700 --> 00:58:44,200
So got to fix that as well.

1114
00:58:44,400 --> 00:58:45,400
Should fill, I

1115
00:58:48,400 --> 00:58:48,700
There we go.

1116
00:58:50,400 --> 00:58:51,900
All right, so now we should be back.

1117
00:58:51,900 --> 00:58:56,700
I think to where we started and it looks like we are for the most part

1118
00:58:57,600 --> 00:59:02,800
although for some reason we're still that's kind of interesting.

1119
00:59:03,000 --> 00:59:07,400
We're still pixelated.

1120
00:59:10,900 --> 00:59:12,300
In certain circumstances.

1121
00:59:14,500 --> 00:59:15,800
She makes very little sense.

1122
00:59:16,400 --> 00:59:17,800
What did I do wrong here?

1123
00:59:20,400 --> 00:59:21,300
I'm not sure.

1124
00:59:23,100 --> 00:59:29,100
I must have not one of the things that I'm doing, I did not apparently

1125
00:59:29,100 --> 00:59:33,000
actually do wide properly, so let me just go ahead and check make sure

1126
00:59:33,000 --> 00:59:36,100
that they're all happening the way I think they should be happening.

1127
00:59:43,200 --> 00:59:43,800
All right.

1128
00:59:45,800 --> 00:59:50,200
So we compute our should fill value based on the current X and that is

1129
00:59:50,200 --> 00:59:51,300
actually doing x.

1130
00:59:51,800 --> 00:59:54,800
I plus I write which is this value here.

1131
00:59:56,400 --> 00:59:57,700
So that should be correct.

1132
00:59:59,000 --> 00:59:59,800
Loading things in

1133
01:00:00,000 --> 01:00:08,000
And come through here, compute the blend Factor TX, that's all good.

1134
01:00:09,000 --> 01:00:09,600
Oh,

1135
01:00:11,000 --> 01:00:11,700
Wait.

1136
01:00:13,200 --> 01:00:17,100
But why, that's weird, how we always been doing that, where we have

1137
01:00:17,100 --> 01:00:17,900
our index.

1138
01:00:17,900 --> 01:00:21,300
And then we do our in, through, to cast here, that's kind of stupid.

1139
01:00:23,000 --> 01:00:24,400
Where are these used somewhere?

1140
01:00:24,400 --> 01:00:27,400
Yeah, so that's that's what we did.

1141
01:00:27,700 --> 01:00:28,800
That's what we did wrong.

1142
01:00:29,300 --> 01:00:31,900
So this is this was a poorly named thing.

1143
01:00:32,200 --> 01:00:35,700
I'm going to call this actual X and fix that, right?

1144
01:00:38,100 --> 01:00:39,600
Let's go ahead and Cascade that down.

1145
01:00:52,000 --> 01:00:52,600
Okay.

1146
01:00:53,000 --> 01:00:53,300
Well no.

1147
01:00:53,300 --> 01:00:54,000
That wasn't it.

1148
01:00:57,900 --> 01:00:59,800
So, I guess this is literally only used here.

1149
01:01:00,800 --> 01:01:01,500
Is that correct?

1150
01:01:02,900 --> 01:01:03,300
Yeah.

1151
01:01:04,600 --> 01:01:07,400
All right, well we're still busted.

1152
01:01:07,400 --> 01:01:09,900
I did not fix the problem, but that was kind of just an interesting

1153
01:01:09,900 --> 01:01:10,300
thing.

1154
01:01:10,600 --> 01:01:15,400
Alright, so keep going, like I said, I had a bug in when I do my

1155
01:01:15,400 --> 01:01:16,000
transformation.

1156
01:01:16,000 --> 01:01:17,900
So let's go ahead and keep looking for it.

1157
01:01:19,100 --> 01:01:22,300
So grab out the pixel position, take a look at the exhibition

1158
01:01:22,300 --> 01:01:23,100
relative, the origin.

1159
01:01:23,100 --> 01:01:27,900
I'm going to do that four times, we compute the use and Vees, but we

1160
01:01:27,900 --> 01:01:29,900
don't store those, we just store whether or not.

1161
01:01:29,900 --> 01:01:32,200
It was a valid for that particular pixel.

1162
01:01:33,000 --> 01:01:35,000
We compute the texture X texture.

1163
01:01:35,000 --> 01:01:41,400
Why, and we use those to look up and we record basically, where we are

1164
01:01:41,400 --> 01:01:44,600
for the blend factors, right in th in the t, x- x.

1165
01:01:46,200 --> 01:01:46,400
Auntie.

1166
01:01:46,400 --> 01:01:51,300
Why - why we then go ahead and look up each of the samples and we load

1167
01:01:51,300 --> 01:01:52,500
in the destination.

1168
01:01:53,500 --> 01:01:54,800
Ah, that's our problem.

1169
01:01:55,800 --> 01:02:00,500
Yeah, we need to actually load in the pixels.

1170
01:02:04,600 --> 01:02:05,800
From the right place.

1171
01:02:12,700 --> 01:02:15,100
So we weren't actually implementing the pixel by the iso.

1172
01:02:15,100 --> 01:02:17,300
We have to load in the for different destinations.

1173
01:02:17,500 --> 01:02:21,300
We go through, do the Ops on the destination and then at the end, we

1174
01:02:21,300 --> 01:02:24,900
write each one out, and I could actually change this now to look a

1175
01:02:24,900 --> 01:02:26,500
little bit more proper.

1176
01:02:27,200 --> 01:02:31,200
So now we're actually incrementing by forests on the pixel as well.

1177
01:02:31,900 --> 01:02:32,600
So there we go.

1178
01:02:34,100 --> 01:02:37,700
And now, we're back to good or at least some semblance of good.

1179
01:02:37,700 --> 01:02:38,400
As you can see.

1180
01:02:38,400 --> 01:02:39,000
There we go.

1181
01:02:39,400 --> 01:02:42,500
All's well, so, you know what?

1182
01:02:42,900 --> 01:02:45,200
I think we're basically out of time.

1183
01:02:46,100 --> 01:02:49,000
So I feel like we should probably stop and tomorrow.

1184
01:02:49,000 --> 01:02:51,900
We're now in a position to actually do the Cindy optimization.

1185
01:02:52,300 --> 01:02:55,300
So, tomorrow we can do is I shouldn't say something opposition.

1186
01:02:55,300 --> 01:02:56,900
I say just to write this Insanity.

1187
01:02:57,800 --> 01:02:59,200
So basically tomorrow, what we'll do.

1188
01:02:59,200 --> 01:02:59,800
We'll pick up again.

1189
01:03:00,000 --> 01:03:00,800
At 9 a.m.

1190
01:03:02,600 --> 01:03:03,800
we'll, just go ahead and take these.

1191
01:03:03,800 --> 01:03:04,800
So for example.

1192
01:03:11,200 --> 01:03:17,000
Now, that we have our loading isolated and we have these guys as, as

1193
01:03:17,000 --> 01:03:20,000
for floats, it's pretty trivial for us to go ahead and change.

1194
01:03:20,000 --> 01:03:24,100
One of these four floats to actually be Cindy, right?

1195
01:03:24,700 --> 01:03:31,100
And in fact, it's extra easy to do that on MSNBC because of the way

1196
01:03:31,100 --> 01:03:33,600
they Define, the M 128 structure.

1197
01:03:34,000 --> 01:03:37,800
In fact I can sort of show you one sort of interesting aspect of it.

1198
01:03:38,100 --> 01:03:40,300
So let's go back.

1199
01:03:41,100 --> 01:03:43,600
It's real quickly about, you know what Rod time?

1200
01:03:44,200 --> 01:03:47,500
I'll end there, and I'll show you the stuff that's going to show you

1201
01:03:47,500 --> 01:03:51,100
tomorrow because we did all the work we need to do to get there and we

1202
01:03:51,100 --> 01:03:52,500
showed how the Cindy stuff works.

1203
01:03:52,500 --> 01:03:56,200
So, tomorrow will actually go ahead and write that core part of the

1204
01:03:56,200 --> 01:03:59,200
routine and Cindy, which, at this point now will be really really

1205
01:03:59,200 --> 01:04:00,000
straightforward for us to do.

1206
01:04:00,000 --> 01:04:04,100
In fact, you could almost do it as homework if you wanted to.

1207
01:04:04,100 --> 01:04:04,700
But

1208
01:04:06,800 --> 01:04:08,400
We'll do it tomorrow morning at 9 a.m.

1209
01:04:08,800 --> 01:04:09,100
all right.

1210
01:04:09,100 --> 01:04:14,500
So for now, let's go ahead and go to the Q&A so that I can basically

1211
01:04:14,500 --> 01:04:16,200
answer any questions that anyone has.

1212
01:04:31,100 --> 01:04:35,000
Would it be faster to unpack pistols using a union of an inch 32, with

1213
01:04:35,000 --> 01:04:39,100
a struct of four in Tate's instead of doing four shifts and mass per

1214
01:04:39,100 --> 01:04:39,700
pixel?

1215
01:04:41,100 --> 01:04:42,000
I do not know.

1216
01:04:43,100 --> 01:04:48,200
I never actually unpack things that way in real life.

1217
01:04:49,500 --> 01:04:50,100
Or at least never.

1218
01:04:50,100 --> 01:04:54,600
When I actually care how fast they go, so you have to time it.

1219
01:04:55,300 --> 01:04:57,000
My suspicion would be probably not.

1220
01:04:57,000 --> 01:04:58,000
My suspicions would be that.

1221
01:04:58,000 --> 01:05:01,300
The compiler is smart enough to do, which, when you're compiling with

1222
01:05:01,300 --> 01:05:03,100
O2, I suspect the compiler.

1223
01:05:03,100 --> 01:05:05,400
Turns it into whatever it thinks is faster either way.

1224
01:05:06,600 --> 01:05:08,100
But I don't know, you have to time it.

1225
01:05:16,100 --> 01:05:20,800
Why don't we go y less than 2 and X less than 2 and go through in

1226
01:05:20,800 --> 01:05:22,600
blocks instead of a line.

1227
01:05:24,500 --> 01:05:29,400
Well, so the reason is because of the way the loads work in Cindy.

1228
01:05:29,400 --> 01:05:35,700
We when we issue a single command will be able to load 4 pixels at

1229
01:05:35,700 --> 01:05:36,200
once.

1230
01:05:36,500 --> 01:05:41,500
In a line, we wouldn't be able to load blocks at a time, right?

1231
01:05:42,600 --> 01:05:46,100
Because if we load blocks at a time, we actually have to do both

1232
01:05:46,100 --> 01:05:46,500
loads.

1233
01:05:46,500 --> 01:05:48,500
So see if I can explain this here.

1234
01:05:51,900 --> 01:05:53,000
It doesn't really matter.

1235
01:05:53,000 --> 01:05:57,800
I mean, we could do the blocks at a time, but basically, right, if I

1236
01:05:58,000 --> 01:05:59,600
imagine what I've got in memory,

1237
01:06:00,300 --> 01:06:00,800
Right.

1238
01:06:01,600 --> 01:06:02,500
This is memory.

1239
01:06:06,100 --> 01:06:09,400
Okay, and here's the register.

1240
01:06:11,500 --> 01:06:16,000
When I issue a load, a single load instruction will load this stuff in

1241
01:06:16,300 --> 01:06:16,700
right.

1242
01:06:16,800 --> 01:06:18,900
It will load this.

1243
01:06:27,100 --> 01:06:27,600
Right.

1244
01:06:27,700 --> 01:06:32,800
One move APS will grab this whole set of four pixels and put it into a

1245
01:06:32,800 --> 01:06:33,400
register.

1246
01:06:34,600 --> 01:06:39,800
If we wanted to do blocks, so the next row as well, right?

1247
01:06:39,900 --> 01:06:41,900
We have to do to move aps's.

1248
01:06:45,200 --> 01:06:50,500
For every time we were going to process, so we actually we have twice

1249
01:06:50,500 --> 01:06:51,300
the memory.

1250
01:06:52,500 --> 01:06:57,300
Fetches going on right now because they're going to be cache coherent.

1251
01:06:57,300 --> 01:07:01,700
That may not be the end of the world, but I just don't feel like we

1252
01:07:01,700 --> 01:07:02,900
necessarily want to do that.

1253
01:07:02,900 --> 01:07:06,100
Like I mean we'd have to actually know that we were going to start

1254
01:07:06,100 --> 01:07:10,400
saving a lot of time with those with those overhangs which maybe we'll

1255
01:07:10,400 --> 01:07:12,300
test and find out if we do or not.

1256
01:07:12,400 --> 01:07:15,200
But even if we were going to do that, I suspect what we do is

1257
01:07:15,200 --> 01:07:19,100
rearrange the frame buffer to be in that sort of Blocky format.

1258
01:07:19,100 --> 01:07:22,000
And then just do at the very end when we live

1259
01:07:22,700 --> 01:07:26,300
It will be output to the screen or whatever we Swizzle it then.

1260
01:07:29,400 --> 01:07:30,000
About.

1261
01:07:30,300 --> 01:07:31,600
So I'm not sure about that.

1262
01:07:31,600 --> 01:07:36,300
We could do that but again you have to be aware that once you do that,

1263
01:07:36,300 --> 01:07:39,500
you're issuing two instructions to do the loads instead of one.

1264
01:07:45,400 --> 01:07:48,500
Is it better if we calculate, if the pixel should be filled and cue it

1265
01:07:48,500 --> 01:07:51,900
up and only do the calculations once we hit four of them.

1266
01:07:52,500 --> 01:07:53,900
So, that's an excellent question.

1267
01:07:58,700 --> 01:08:00,000
And the answer is, it depends.

1268
01:08:01,800 --> 01:08:05,100
Doing that requires a lot of instructions.

1269
01:08:06,200 --> 01:08:10,900
Okay, and the reason it requires a lot of instructions is because

1270
01:08:10,900 --> 01:08:12,900
knowing how to do that packing.

1271
01:08:13,000 --> 01:08:15,200
Imagine all the stuff you have to do, right?

1272
01:08:15,200 --> 01:08:18,200
You need to have a counter that counts where you're putting things

1273
01:08:18,200 --> 01:08:21,600
when you load them you have to load them into a particular Channel and

1274
01:08:21,600 --> 01:08:23,700
then when you're done, you have to write them out.

1275
01:08:23,700 --> 01:08:27,300
If to remember what memory addresses you've got them from and and

1276
01:08:27,399 --> 01:08:28,399
outrun them out.

1277
01:08:29,300 --> 01:08:30,700
44 wide.

1278
01:08:31,399 --> 01:08:33,000
It almost certainly would be a lose.

1279
01:08:34,399 --> 01:08:35,100
Right.

1280
01:08:35,100 --> 01:08:37,500
But if you were say 64 wide,

1281
01:08:38,700 --> 01:08:39,600
it might be a win.

1282
01:08:40,899 --> 01:08:47,700
And there's actually, this is actually a topic that has a lot to do

1283
01:08:47,700 --> 01:08:50,200
with how much stuff you're doing internally, right?

1284
01:08:50,500 --> 01:08:54,500
So right now, you know, this is the the math Ops basically in here at

1285
01:08:54,500 --> 01:08:57,500
this is them, there's not very many of them, right?

1286
01:08:57,800 --> 01:08:59,200
I mean there's there's you know I don't know.

1287
01:08:59,200 --> 01:08:59,800
Something like 60.

1288
01:09:00,000 --> 01:09:02,399
My pops in here, maybe 32 math Ops.

1289
01:09:02,399 --> 01:09:02,899
I like that.

1290
01:09:02,899 --> 01:09:03,300
I don't know.

1291
01:09:03,500 --> 01:09:04,200
Not very many.

1292
01:09:07,399 --> 01:09:07,700
Yeah.

1293
01:09:07,800 --> 01:09:09,800
3032 Ops, maybe something like that.

1294
01:09:10,700 --> 01:09:15,300
And so the amount that you're saving, when you avoid Computing pixels,

1295
01:09:15,300 --> 01:09:18,200
you don't need to compute is not that great.

1296
01:09:18,399 --> 01:09:23,300
If This Were a super conflict Shader then it starts to become more.

1297
01:09:23,300 --> 01:09:25,899
Like you can start to spend more Cycles doing that packing and

1298
01:09:25,899 --> 01:09:26,600
unpacking.

1299
01:09:26,800 --> 01:09:28,700
And you still, you do a huge.

1300
01:09:28,700 --> 01:09:30,700
You do a big savings there, right?

1301
01:09:31,000 --> 01:09:34,700
And so, what it really boils down to is the cost trade-off between

1302
01:09:34,700 --> 01:09:36,399
doing the all the logic.

1303
01:09:36,399 --> 01:09:36,700
That's it.

1304
01:09:36,700 --> 01:09:36,899
Go,

1305
01:09:37,100 --> 01:09:40,000
The pack and then unpack, two different memory locations.

1306
01:09:41,300 --> 01:09:44,899
All that logic, it's a trade-off between that and the savings that you

1307
01:09:44,899 --> 01:09:46,300
get by not Computing pixels.

1308
01:09:46,300 --> 01:09:48,399
You didn't need to compute, right?

1309
01:09:48,899 --> 01:09:51,899
And so right now, we're kind of at the worst case for that because

1310
01:09:51,899 --> 01:09:55,100
actually our pixel computation is very inexpensive by comparison.

1311
01:09:55,200 --> 01:09:58,200
But if you got out to some crazy fader that was doing all sorts of

1312
01:09:58,200 --> 01:10:02,200
ridiculous stuff, it might become more important that make sense.

1313
01:10:27,000 --> 01:10:27,800
No questions.

1314
01:10:46,400 --> 01:10:49,700
Oh, and by the way, for the hmh, but I am not using an unknown

1315
01:10:49,700 --> 01:10:52,400
keyboard that I had lying around anymore.

1316
01:10:52,400 --> 01:10:55,100
I switched it out like I'm using a DOT the Das Keyboard three that I

1317
01:10:55,100 --> 01:10:56,300
used to have in the living room.

1318
01:10:58,400 --> 01:11:02,900
This was my, this was a gift from Jeff, actually, he had a Das

1319
01:11:02,900 --> 01:11:03,600
Keyboard.

1320
01:11:04,200 --> 01:11:08,500
3 is his Das Keyboard 3 and then he switched to some other keyboard

1321
01:11:08,500 --> 01:11:10,100
and I was like, I really like the dust covers for you.

1322
01:11:10,100 --> 01:11:12,600
So I asked him if I could have it and he said, yes.

1323
01:11:12,600 --> 01:11:14,900
So I'm actually using that's what I'm actually using right now.

1324
01:11:15,000 --> 01:11:16,500
I really love the Das Keyboard 3s.

1325
01:11:16,500 --> 01:11:17,900
I wish they'd kept making these.

1326
01:11:17,900 --> 01:11:20,800
I've never had a problem with one and I love the feel.

1327
01:11:22,700 --> 01:11:23,100
So

1328
01:11:31,000 --> 01:11:32,200
Sorry, maybe this is off topic.

1329
01:11:32,200 --> 01:11:33,200
Would it be correct to say?

1330
01:11:33,200 --> 01:11:36,500
Anyone coding in Java by default is not making use of any of the Cindy

1331
01:11:36,500 --> 01:11:36,800
stuff?

1332
01:11:36,800 --> 01:11:40,000
Or do you think the jit compiler is smart enough to make use of it in

1333
01:11:40,000 --> 01:11:40,900
certain circumstances?

1334
01:11:40,900 --> 01:11:42,800
Maybe with some analysis of the bytecode?

1335
01:11:44,700 --> 01:11:48,100
You know, I don't program in Java so I don't I'm not really qualified

1336
01:11:48,100 --> 01:11:48,600
to say.

1337
01:11:49,700 --> 01:11:55,100
I feel like you know if you're programming in Java, most of the time

1338
01:11:55,100 --> 01:11:57,500
that's probably the least of your worries is whether things Cindy

1339
01:11:57,500 --> 01:11:58,000
wide.

1340
01:12:00,200 --> 01:12:04,500
But, you know, it wouldn't be out of the question for the jit compiler

1341
01:12:04,500 --> 01:12:05,200
to do it.

1342
01:12:05,800 --> 01:12:09,300
And I also feel like I mean by now I feel like job has got to have

1343
01:12:09,300 --> 01:12:11,800
some way of specifying Cindy instructions.

1344
01:12:11,800 --> 01:12:15,000
I mean there's got to be there's got to be some Library you can use or

1345
01:12:15,000 --> 01:12:19,600
something that's like are not library but like you know, extension

1346
01:12:19,600 --> 01:12:24,200
that you can use that basically extends the bytecode for Cindy, if

1347
01:12:24,200 --> 01:12:27,500
not, that's crazy that they don't have that.

1348
01:12:29,400 --> 01:12:32,600
How often do you optimize for cash basis versus optimizing with Cindy?

1349
01:12:32,900 --> 01:12:35,400
I got the impression that cache misses are by far the most important

1350
01:12:35,400 --> 01:12:36,500
things to look out for.

1351
01:12:37,800 --> 01:12:39,100
So they are in the art.

1352
01:12:44,400 --> 01:12:46,200
Basically what it boils down to is.

1353
01:12:47,500 --> 01:12:51,100
What does the structure of the data look like, right?

1354
01:12:52,700 --> 01:12:57,700
And so in our case we do have some some question about cache, misses

1355
01:12:57,700 --> 01:12:58,300
right?

1356
01:12:58,300 --> 01:13:02,600
We're doing Texel fetches and those can result in the cast mixes but

1357
01:13:02,600 --> 01:13:07,400
on the whole when we're doing rectangle, a rectangle we should in

1358
01:13:07,400 --> 01:13:10,900
theory and we'll have to find out but we should be able to get it down

1359
01:13:10,900 --> 01:13:12,800
so that they're really just aren't a lot of cache misses this code

1360
01:13:12,800 --> 01:13:16,600
because its operating on a large number of pixels, all of which are

1361
01:13:16,600 --> 01:13:17,000
typically

1362
01:13:17,200 --> 01:13:21,100
Very contiguous in memory write cache.

1363
01:13:21,100 --> 01:13:24,300
Misses tend to be more about chasing pointers and other sorts of

1364
01:13:24,300 --> 01:13:28,100
things where you can't predict what the next piece of memory is that

1365
01:13:28,100 --> 01:13:31,700
you're actually going to go get but in our case we often will know

1366
01:13:31,700 --> 01:13:34,200
exactly what the next piece of memory is that we're going to go get

1367
01:13:34,200 --> 01:13:34,900
and so cache.

1368
01:13:34,900 --> 01:13:37,200
Misses are going to be less of an issue for this type of code

1369
01:13:37,200 --> 01:13:37,900
probably.

1370
01:13:38,200 --> 01:13:38,900
So I guess

1371
01:13:41,000 --> 01:13:45,200
So operating wide is very, very, very important to us, because

1372
01:13:45,200 --> 01:13:49,000
typically we're going to do something like loading, two pieces of

1373
01:13:49,000 --> 01:13:53,900
memory from very known, very contiguous locations, and then doing 60

1374
01:13:53,900 --> 01:13:58,800
math operations on them or something like this 60 might be a little

1375
01:13:58,800 --> 01:14:00,000
money, but something like that.

1376
01:14:00,300 --> 01:14:04,300
And so, we really want to make sure that those 60 operations are done

1377
01:14:04,400 --> 01:14:09,500
wide, so that we don't pay for x 60 in cost, right?

1378
01:14:09,800 --> 01:14:13,300
So, for this particular type of code where we're filling a large

1379
01:14:13,300 --> 01:14:17,800
blocks of known pixels in a contiguous order, especially when we're

1380
01:14:17,800 --> 01:14:22,000
talking about rectangular Blitz as opposed to like little tiny

1381
01:14:22,000 --> 01:14:23,100
triangles and stuff.

1382
01:14:25,100 --> 01:14:29,000
Cache misses are probably going to be less of a concern in this code

1383
01:14:29,000 --> 01:14:33,800
than they typically would be in optimizing other sorts of code that

1384
01:14:33,800 --> 01:14:36,000
you met randomly need to optimize in a game.

1385
01:14:41,400 --> 01:14:42,100
Culver fly.

1386
01:14:42,100 --> 01:14:44,100
I will send your best regards to Jeff.

1387
01:14:45,700 --> 01:14:46,400
Absolutely.

1388
01:14:52,600 --> 01:14:55,900
Schedule-wise how many more weeks until we are done with optimization

1389
01:14:55,900 --> 01:14:59,500
of the renderer who knows hard to say.

1390
01:15:01,700 --> 01:15:04,400
Will you be covering more than order Texas whistling?

1391
01:15:04,700 --> 01:15:09,700
Probably not just because I don't know that we actually need any

1392
01:15:09,700 --> 01:15:10,700
sizzling for the render.

1393
01:15:10,700 --> 01:15:14,300
I could all mean I'll mention it briefly we order we already mentioned

1394
01:15:14,700 --> 01:15:17,800
the concept of putting things into blocks, right?

1395
01:15:18,500 --> 01:15:22,200
But textures whistling is less important for us because we don't

1396
01:15:22,200 --> 01:15:27,700
actually access Textures in the way the GPU typically would.

1397
01:15:28,700 --> 01:15:31,100
So we wouldn't actually I don't think get any benefit from it.

1398
01:15:32,400 --> 01:15:36,600
Basically, what, what he's talking about is the fact that Textures in

1399
01:15:36,600 --> 01:15:41,100
on gpus are typically not stored as contiguous pixels and not even as

1400
01:15:41,100 --> 01:15:42,200
contiguous blocks.

1401
01:15:42,800 --> 01:15:45,100
And the reason for that is because textures are much more random

1402
01:15:45,100 --> 01:15:50,500
access on on a GPU than they are here.

1403
01:15:50,800 --> 01:15:56,000
So, typically on a GPU, you know, if you've got a texture, you know

1404
01:15:56,600 --> 01:15:58,400
you're talking about triangles that are mapped.

1405
01:15:58,600 --> 01:16:00,300
You know, like this sort of a thing, right?

1406
01:16:00,300 --> 01:16:04,100
So they're grabbing from just a portion of the texture and they're

1407
01:16:04,100 --> 01:16:05,200
putting that on the screen.

1408
01:16:05,800 --> 01:16:09,800
And so typically what you want to do is you want to make sure that the

1409
01:16:09,900 --> 01:16:12,500
your access pattern into the memory of the texture.

1410
01:16:13,600 --> 01:16:15,300
Is optimized for this Behavior.

1411
01:16:15,800 --> 01:16:17,400
We don't actually have that problem.

1412
01:16:17,700 --> 01:16:21,600
We are pretty much always bleeding our entire bitmap right?

1413
01:16:22,900 --> 01:16:27,800
And so we don't really have to think too hard about how we're storing

1414
01:16:27,800 --> 01:16:28,200
our bitmaps.

1415
01:16:28,200 --> 01:16:30,300
I don't think so.

1416
01:16:30,300 --> 01:16:33,400
Probably the way we have them right now would be fine and if it wasn't

1417
01:16:33,400 --> 01:16:39,200
fine probably just going in blocks of 2 by 2 would be totally

1418
01:16:39,200 --> 01:16:40,000
sufficient.

1419
01:16:40,000 --> 01:16:42,000
And we don't have to do anything more complicated than that.

1420
01:16:42,400 --> 01:16:43,200
But gpus

1421
01:16:43,400 --> 01:16:46,200
Harder time of it because they are dealing with something that's not

1422
01:16:46,200 --> 01:16:49,200
just typically Brit bleeding rectilinear strip rights to the screen.

1423
01:16:55,600 --> 01:16:57,900
Possibly a noob question, have you ever run into problems with

1424
01:16:57,900 --> 01:16:59,100
floating Point arithmetic?

1425
01:16:59,200 --> 01:17:01,400
And what are some good approaches to avoiding those problems?

1426
01:17:01,800 --> 01:17:05,300
That is not a noob question, that is actually a very real problem and

1427
01:17:05,300 --> 01:17:06,300
happens all the time.

1428
01:17:07,800 --> 01:17:11,800
Some good approaches to avoiding those problems, are one to try and

1429
01:17:11,800 --> 01:17:15,200
avoid having the problem in the first place and you saw me do that,

1430
01:17:15,200 --> 01:17:15,700
right?

1431
01:17:16,200 --> 01:17:20,900
One of the things that we did is we use that same region concept to

1432
01:17:20,900 --> 01:17:23,800
make sure that we always simulate things around the origin.

1433
01:17:25,000 --> 01:17:29,800
And we don't try to have a giant world, that's like 100,000 units in

1434
01:17:29,800 --> 01:17:33,700
all directions and doing floating Point math out there where the

1435
01:17:33,700 --> 01:17:35,100
Precision starts to break down.

1436
01:17:35,700 --> 01:17:39,100
So one way to get around, having to worry, about floating-point

1437
01:17:39,200 --> 01:17:42,700
arithmetic, problems is to make sure that you're always doing things

1438
01:17:42,800 --> 01:17:46,100
in in very small scales, right?

1439
01:17:46,100 --> 01:17:50,700
That don't involve very large things that will have catastrophic

1440
01:17:50,700 --> 01:17:52,400
cancellation problems, stuff like that.

1441
01:17:54,300 --> 01:17:58,100
so that's one way to deal with it, but obviously there's also the

1442
01:17:58,100 --> 01:17:59,700
other problem where no matter

1443
01:18:00,000 --> 01:18:02,800
Your scale is, if you're doing certain floating-point things, you may

1444
01:18:02,800 --> 01:18:03,500
run into problems.

1445
01:18:03,800 --> 01:18:07,600
And the answer there is it's just really pretty tough if you actually

1446
01:18:07,600 --> 01:18:11,100
are having real, floating-point arithmetic problems, even when you

1447
01:18:11,100 --> 01:18:13,800
make sure that your stuff is well conditioned and you're not doing

1448
01:18:13,800 --> 01:18:17,000
sort of this, you know, expecting the floating Point Unit to handle

1449
01:18:17,000 --> 01:18:18,500
more than what its Precision has.

1450
01:18:20,000 --> 01:18:23,100
Then you're into the world of having to actually become more of a

1451
01:18:23,100 --> 01:18:24,000
floating-point expert.

1452
01:18:24,000 --> 01:18:27,200
And there's a couple of references that you should know about there.

1453
01:18:34,300 --> 01:18:38,700
So this, whatever computer scientist should know about floating Point

1454
01:18:39,200 --> 01:18:40,000
values.

1455
01:18:40,700 --> 01:18:43,000
This, this is a PDF, it's kind of famous.

1456
01:18:43,700 --> 01:18:47,300
It might be a little bit old at this point but it's still probably a

1457
01:18:47,300 --> 01:18:48,900
good thing to go to.

1458
01:18:49,200 --> 01:18:53,800
So if you, if you grab this PDF and you read it and you actually spend

1459
01:18:53,800 --> 01:18:57,000
some time trying to understand it, it'll probably put you in some

1460
01:18:57,200 --> 01:19:00,300
pretty good shape to understand what's going on when you have floating

1461
01:19:00,300 --> 01:19:01,500
Point operation problems.

1462
01:19:01,500 --> 01:19:02,700
So I do highly.

1463
01:19:03,000 --> 01:19:05,000
I recommend taking a look at it.

1464
01:19:05,500 --> 01:19:11,000
Similarly, you can then go a step up from that in terms of

1465
01:19:12,500 --> 01:19:13,700
Time investment.

1466
01:19:14,900 --> 01:19:17,800
You can read the two books by Foreman Acton

1467
01:19:19,200 --> 01:19:20,900
Which is real Computing Made Real.

1468
01:19:23,000 --> 01:19:24,300
Let's see here, is this.

1469
01:19:26,900 --> 01:19:30,000
Yes, real Computing Made Real and basically the form and active books.

1470
01:19:30,000 --> 01:19:31,500
He has other one called numerical methods.

1471
01:19:31,500 --> 01:19:32,600
That usually work.

1472
01:19:33,100 --> 01:19:37,000
This one right here and you can see it's called numerical methods that

1473
01:19:37,000 --> 01:19:39,900
work technically, but you can see, it says, usually in there, right?

1474
01:19:41,000 --> 01:19:43,900
And it's warm and acting always kind of had a sense of humor.

1475
01:19:43,900 --> 01:19:48,300
And so, he's actually his methods, pretty much always work.

1476
01:19:48,700 --> 01:19:52,200
But he was kind of joking about about that because he talks about

1477
01:19:52,200 --> 01:19:55,200
people doing bad, things numerically, and so on these

1478
01:19:55,400 --> 01:19:56,900
Two books are great.

1479
01:19:57,000 --> 01:19:59,900
So basically the two books by Foreman actin I would highly recommend

1480
01:19:59,900 --> 01:20:02,000
taking a look at it looks like the this is kind of cool.

1481
01:20:02,000 --> 01:20:06,300
Looks like there's a only a ten dollar you could buy real computer

1482
01:20:06,300 --> 01:20:08,400
memory of for only $10 on Kindle which is good.

1483
01:20:08,400 --> 01:20:11,500
I don't know if the Kindle edition is any good, A lot of times the

1484
01:20:11,500 --> 01:20:14,400
conversions to Kindle a pretty awful, but yeah.

1485
01:20:15,500 --> 01:20:17,900
So, those are some books that I would definitely check out.

1486
01:20:17,900 --> 01:20:21,700
I definitely check out this PDF as well because it's got a lot of

1487
01:20:21,700 --> 01:20:22,400
information there.

1488
01:20:22,400 --> 01:20:26,200
And so basically, if you, if you can't set yourself up for success and

1489
01:20:26,200 --> 01:20:31,000
just not care about floating-point arithmetic, if you actually are in

1490
01:20:31,000 --> 01:20:33,900
a situation where you have to care about it, and there isn't a good

1491
01:20:33,900 --> 01:20:36,700
way to structure the way you're doing your operations to avoid it,

1492
01:20:37,200 --> 01:20:41,900
then you are definitely in the realm of halfing to understand what's

1493
01:20:41,900 --> 01:20:45,200
mechanically literally happening on the CPU at those funny.

1494
01:20:45,300 --> 01:20:49,400
Point values, which that PDF and those books will be the way to

1495
01:20:49,400 --> 01:20:53,200
probably gain enough information to start a tackle those problems, but

1496
01:20:53,200 --> 01:20:54,400
that's not a new question.

1497
01:20:54,400 --> 01:20:55,800
That's more of an advanced question.

1498
01:20:55,800 --> 01:20:59,700
Honestly, once you're into that, that sort of stuff,

1499
01:21:08,000 --> 01:21:09,000
Any other questions?

1500
01:21:17,700 --> 01:21:18,300
Anyone.

1501
01:21:22,000 --> 01:21:22,600
Anyone.

1502
01:21:26,000 --> 01:21:26,400
No.

1503
01:21:37,600 --> 01:21:38,900
And starchy Pancakes.

1504
01:21:38,900 --> 01:21:41,300
Yes, sse2 is very standard.

1505
01:21:42,600 --> 01:21:46,700
One of the things that we didn't talk about was too much is how I

1506
01:21:46,700 --> 01:21:47,400
picked sse2.

1507
01:21:47,400 --> 01:21:51,200
I think I mentioned it on an earlier stream, but the steam Hardware

1508
01:21:51,200 --> 01:21:51,800
survey

1509
01:21:53,100 --> 01:21:57,800
I think covers this stuff, so it's something to potentially take a

1510
01:21:57,800 --> 01:21:58,500
look at

1511
01:22:01,000 --> 01:22:05,500
So if you want just kind of a baseline of like I'm going to ship a

1512
01:22:05,500 --> 01:22:06,600
game on a PC.

1513
01:22:07,400 --> 01:22:09,900
Basically, you know that your audience typically looks like steam

1514
01:22:09,900 --> 01:22:10,500
users.

1515
01:22:10,500 --> 01:22:13,200
If you're shipping the kind of games where you care about a bunch of

1516
01:22:13,200 --> 01:22:14,200
optimization stuff, right?

1517
01:22:14,200 --> 01:22:17,100
You're talking about a higher end game, you're not talking about Match

1518
01:22:17,100 --> 01:22:18,900
3 game or something where nobody cares.

1519
01:22:19,800 --> 01:22:24,100
So if you take a look here at the the CPU,

1520
01:22:26,500 --> 01:22:27,500
Side of things.

1521
01:22:27,800 --> 01:22:28,100
Is it?

1522
01:22:28,100 --> 01:22:28,600
This one?

1523
01:22:28,600 --> 01:22:30,200
That's the type of processor.

1524
01:22:31,100 --> 01:22:36,200
How do I get more physical CPUs until CPU speeds?

1525
01:22:36,400 --> 01:22:37,200
I don't know.

1526
01:22:37,300 --> 01:22:38,400
I thought this one.

1527
01:22:38,400 --> 01:22:38,900
Here we go.

1528
01:22:39,000 --> 01:22:39,800
Other settings.

1529
01:22:41,300 --> 01:22:45,600
So this is an example of what you could use.

1530
01:22:45,600 --> 01:22:47,000
And it's not perfect, right?

1531
01:22:47,000 --> 01:22:49,100
It's just the steam Hardware survey but it's, you know, it's one of

1532
01:22:49,100 --> 01:22:50,100
the only source of information.

1533
01:22:50,100 --> 01:22:52,000
We really have about what Gamers have.

1534
01:22:53,000 --> 01:22:55,900
And if you take a look at this, you can kind of see like, okay.

1535
01:22:56,100 --> 01:22:59,000
You know, sse4 4.2.

1536
01:22:59,000 --> 01:23:02,000
And for a are look, a little sketch, right?

1537
01:23:02,000 --> 01:23:06,200
Like, you couldn't guarantee that all of your users, if you sold your

1538
01:23:06,200 --> 01:23:09,000
game on Steam, for example, which is where you'd probably be selling

1539
01:23:09,000 --> 01:23:15,800
it at the very least would would be able to run the game, right?

1540
01:23:16,400 --> 01:23:21,700
But if you take a look at sse2, and then also to a large extent sse3,

1541
01:23:21,800 --> 01:23:24,100
although I don't remember if there's really all that much in sse3,

1542
01:23:24,100 --> 01:23:25,900
that anyone cares about, but

1543
01:23:26,000 --> 01:23:29,400
But at the very least, you can see you're not really losing any one,

1544
01:23:29,400 --> 01:23:29,700
right?

1545
01:23:29,700 --> 01:23:33,200
So, if you say that this game requires us to see to, it's totally

1546
01:23:33,200 --> 01:23:33,600
fine.

1547
01:23:33,700 --> 01:23:36,500
If you say it requires us to see three, probably still, totally fine.

1548
01:23:36,600 --> 01:23:43,000
If you say it requires sse4 of some flavor, especially for a accrue

1549
01:23:43,000 --> 01:23:43,200
least.

1550
01:23:43,200 --> 01:23:47,000
According to steam Hardware survey, not a good sign, right?

1551
01:23:48,000 --> 01:23:51,400
Just not not what you would want.

1552
01:23:52,300 --> 01:23:55,100
That's just going to be a lot of Gamers who can't run your game.

1553
01:23:56,400 --> 01:23:57,700
So hopefully that's

1554
01:24:01,500 --> 01:24:03,700
Yeah, hopefully, that makes some sense.

1555
01:24:08,200 --> 01:24:11,600
Is there a way to track how memory gets stored to the cash?

1556
01:24:12,700 --> 01:24:15,300
So not not exactly.

1557
01:24:16,100 --> 01:24:20,500
Meaning, there isn't until doesn't give you access to their

1558
01:24:20,500 --> 01:24:24,100
super-secret simulation tools that they have, which would actually

1559
01:24:24,100 --> 01:24:25,300
tell you that information.

1560
01:24:27,600 --> 01:24:32,200
Basically, you know, Intel has internally, uh, simulation of their

1561
01:24:32,200 --> 01:24:32,700
processor.

1562
01:24:32,700 --> 01:24:33,600
Everyone has this

1563
01:24:35,700 --> 01:24:41,400
We're basically, they could run the processor in a simulation and view

1564
01:24:41,400 --> 01:24:43,500
exactly what it will do, right?

1565
01:24:43,500 --> 01:24:47,100
And that would tell you exactly how the cache is getting used and so

1566
01:24:47,100 --> 01:24:49,100
they can do it but you can't do it.

1567
01:24:49,900 --> 01:24:52,400
So if you really need to know how the cash is being used, you have to

1568
01:24:52,400 --> 01:24:55,500
be friends with somebody until probably unless they've since then

1569
01:24:55,500 --> 01:24:56,800
changed her mind and released it publicly.

1570
01:24:56,800 --> 01:24:57,700
I don't think they do.

1571
01:24:57,900 --> 01:25:00,100
I think it's a competitive problem for them because if they release

1572
01:25:00,100 --> 01:25:02,900
it, then people may look at what they're doing and or might sue them

1573
01:25:02,900 --> 01:25:04,400
for patent infringement or something.

1574
01:25:04,400 --> 01:25:05,000
Who knows, right?

1575
01:25:05,000 --> 01:25:05,200
Like

1576
01:25:06,200 --> 01:25:07,800
Giving out a simulation how the processor works.

1577
01:25:07,800 --> 01:25:10,000
Could open up all kinds of problems for Intel I suppose, so they

1578
01:25:10,000 --> 01:25:13,800
probably have plenty of reasons not to do that, so I'm assuming they

1579
01:25:13,800 --> 01:25:14,300
don't.

1580
01:25:14,300 --> 01:25:16,000
But that's one way you could do it, right?

1581
01:25:16,000 --> 01:25:18,100
Is, if you have a friend at Intel be like, can you run this code on

1582
01:25:18,100 --> 01:25:22,500
your super-secret processor stuff and you know if they said yes, then

1583
01:25:22,500 --> 01:25:24,700
they could give you back some traces.

1584
01:25:24,700 --> 01:25:27,500
That would tell you what was happening in lieu of that.

1585
01:25:27,500 --> 01:25:32,600
There are some things that the average person who does not have secret

1586
01:25:32,600 --> 01:25:35,700
access to Intel stuff can do basically.

1587
01:25:35,900 --> 01:25:42,400
Processor itself has performance counters on it and I don't know.

1588
01:25:43,800 --> 01:25:52,300
There's a good listing for these things, maybe maybe in here.

1589
01:26:02,800 --> 01:26:06,800
You know, I don't really know what the best way to get access to these

1590
01:26:06,800 --> 01:26:09,500
are but you know, it'd be something like one of these.

1591
01:26:12,900 --> 01:26:14,500
Can you can you load this for me?

1592
01:26:16,800 --> 01:26:17,500
There we go.

1593
01:26:18,100 --> 01:26:20,700
So let's see.

1594
01:26:22,900 --> 01:26:24,000
Where is the?

1595
01:26:24,000 --> 01:26:24,600
Here we go.

1596
01:26:28,200 --> 01:26:32,400
So you can kind of see in here and I don't really know what I'm

1597
01:26:32,400 --> 01:26:33,700
looking at here to be honest with you.

1598
01:26:33,700 --> 01:26:36,500
This is not exactly what I wanted but point B.

1599
01:26:36,900 --> 01:26:41,700
So here you go, you can kind of see what this is doing here.

1600
01:26:42,200 --> 01:26:45,700
There's basically like this is a little library that gives you access

1601
01:26:46,100 --> 01:26:48,300
to a bunch of information about what the processor is doing.

1602
01:26:48,600 --> 01:26:51,700
Some of them being L3 cache.

1603
01:26:51,700 --> 01:26:55,600
Misses L2 cache misses L3 cache hits L2 cache hits.

1604
01:26:56,600 --> 01:26:57,900
So basically there's

1605
01:26:58,000 --> 01:26:59,800
there's, you know, there's

1606
01:27:00,000 --> 01:27:05,300
Ways you can see how many times you are missing the cash and how many

1607
01:27:05,300 --> 01:27:08,700
times you are hitting the cash within a section of code.

1608
01:27:09,300 --> 01:27:14,200
And so while you can't see exactly what happened to the cash.

1609
01:27:14,200 --> 01:27:15,900
Phil you know what lines?

1610
01:27:15,900 --> 01:27:17,900
Got Phil, what lines got evicted, whatever.

1611
01:27:19,300 --> 01:27:25,700
You can get aggregate statistics, which often times is enough, right?

1612
01:27:25,700 --> 01:27:30,300
Oftentimes all you really want to know, is did I really miss the cash?

1613
01:27:30,300 --> 01:27:31,500
A bunch, right.

1614
01:27:31,500 --> 01:27:34,000
And was I missing the L3 or the L2 or whatever?

1615
01:27:34,000 --> 01:27:34,600
Right?

1616
01:27:35,400 --> 01:27:39,700
And so that is information that you can get, if that makes sense.

1617
01:27:40,700 --> 01:27:45,200
But explicitly, what happened with the cash is not super possible

1618
01:27:46,000 --> 01:27:47,700
without it without insides that?

1619
01:28:02,000 --> 01:28:02,500
Off topic.

1620
01:28:02,500 --> 01:28:06,100
Do you know, if J, I will have extensions or method for using Cindy,

1621
01:28:06,100 --> 01:28:07,200
that's not really off topic.

1622
01:28:07,200 --> 01:28:08,600
That is on the topic of 70.

1623
01:28:10,700 --> 01:28:15,200
Yes, he already has kohi already implemented in j.i.

1624
01:28:15,200 --> 01:28:18,500
stuff that changes array of structures to structure of arrays.

1625
01:28:18,900 --> 01:28:22,900
So he already set it up for Cindy to do automatic simply

1626
01:28:22,900 --> 01:28:25,200
Transformations for you, which is pretty awesome.

1627
01:28:26,300 --> 01:28:30,200
He, I don't think necessarily has actually gone in and done Cindy,

1628
01:28:30,400 --> 01:28:33,400
like, intrinsic stuff, because that's a little more low level.

1629
01:28:33,400 --> 01:28:35,400
But, you know, obviously he's thinking about that.

1630
01:28:35,400 --> 01:28:38,100
So I suspect he would add that eventually, just it's not quite there

1631
01:28:38,100 --> 01:28:38,500
yet.

1632
01:28:50,700 --> 01:28:53,600
How much do you need to think about the intrinsic instructions while

1633
01:28:53,600 --> 01:28:56,000
programming or does the compiler usually take care of that?

1634
01:28:56,000 --> 01:28:59,000
Is this the big difference between using canoe and Intel compiler for

1635
01:28:59,000 --> 01:28:59,600
example?

1636
01:29:04,200 --> 01:29:07,000
I'm sorry, I'm not sure I super understand what you're asking there.

1637
01:29:09,500 --> 01:29:10,700
Could you be more specific?

1638
01:29:37,900 --> 01:29:38,800
I will wait a second.

1639
01:29:38,800 --> 01:29:40,500
See about the more specific part.

1640
01:29:43,700 --> 01:29:48,000
Yeah, I don't know what the, I don't know these days.

1641
01:29:48,000 --> 01:29:52,400
What the easiest way is to do this stuff.

1642
01:29:55,000 --> 01:29:57,600
You know, it may be that you just go ahead and Link in one of these

1643
01:29:57,600 --> 01:29:58,000
things.

1644
01:29:58,000 --> 01:29:58,600
I don't know.

1645
01:29:58,600 --> 01:29:59,700
I haven't looked at that recently.

1646
01:30:00,000 --> 01:30:00,400
Nice.

1647
01:30:00,400 --> 01:30:01,600
I'd like to get something like this.

1648
01:30:01,600 --> 01:30:03,200
I'd even I'd use this at work, too.

1649
01:30:03,200 --> 01:30:05,500
If I was, if it worked reasonably.

1650
01:30:05,500 --> 01:30:08,500
Well, I'm always skeptical of some of these until libraries though

1651
01:30:08,500 --> 01:30:11,700
because they tend to be really weird but you know,

1652
01:30:16,500 --> 01:30:19,000
This is, this is the kind of data that you want when you're optimizing

1653
01:30:19,000 --> 01:30:19,700
stuff, right?

1654
01:30:20,300 --> 01:30:25,500
You want to be able to to get the those cache misses and be able to

1655
01:30:25,500 --> 01:30:29,300
bracket two pieces of code to see how those cache misses have happened

1656
01:30:29,300 --> 01:30:30,300
over the course of the Run.

1657
01:30:38,600 --> 01:30:41,200
I think he's essentially asking how proficient compilers are

1658
01:30:41,200 --> 01:30:43,200
automatically emitting Cindy instructions.

1659
01:30:43,600 --> 01:30:47,900
They are not very proficient at emitting them unfortunately.

1660
01:30:50,500 --> 01:30:53,000
So at the very least you usually have to give them some help

1661
01:30:58,400 --> 01:31:05,000
So, here is a documentation on auto, vectorizing and llvm, vectorizing

1662
01:31:05,000 --> 01:31:06,100
is what they mean.

1663
01:31:06,200 --> 01:31:11,300
Vectorizing is the phrase, they use to talk about producing wide

1664
01:31:11,300 --> 01:31:12,200
operations, right?

1665
01:31:12,200 --> 01:31:14,300
Because you can think about it, that is a vector, right?

1666
01:31:14,300 --> 01:31:16,500
It's a vector of four things, or eight things or whatever.

1667
01:31:16,800 --> 01:31:20,100
So Auto vectorization means taking code, that was scalar and turning

1668
01:31:20,100 --> 01:31:22,100
it into wide turning into Vector.

1669
01:31:23,300 --> 01:31:26,200
So you can see, like, you know, you can say stuff here about what you

1670
01:31:26,200 --> 01:31:27,000
want to do.

1671
01:31:27,400 --> 01:31:31,700
Then you kind of give it these like hints and stuff and you hope that

1672
01:31:31,700 --> 01:31:33,200
it does a good job.

1673
01:31:33,200 --> 01:31:36,600
But basically you know what it tries to do is it tries to take things

1674
01:31:36,600 --> 01:31:40,400
that look like this and turn them into vectored stuff, right?

1675
01:31:42,000 --> 01:31:44,500
And you know, you can read about stuff that has to do here.

1676
01:31:47,900 --> 01:31:51,500
How it's a does, its loads and that sort of things and basically how

1677
01:31:51,500 --> 01:31:54,800
everything works and you can kind of see you know here's their

1678
01:31:54,800 --> 01:31:55,700
performance graph.

1679
01:31:55,700 --> 01:31:59,300
So on about who did a better job, you know, vectorizing some stuff,

1680
01:32:00,100 --> 01:32:03,200
and that sort of thing and this I believe is pretty old documentation

1681
01:32:03,200 --> 01:32:04,100
potentially.

1682
01:32:04,500 --> 01:32:07,700
I think this actually hasn't the documentation hasn't changed in a

1683
01:32:07,700 --> 01:32:08,600
year or more.

1684
01:32:08,600 --> 01:32:11,400
So, you know, it might be a little bit better even than it, that

1685
01:32:11,400 --> 01:32:11,800
suggests.

1686
01:32:11,800 --> 01:32:16,200
But so, it's in there and you can try turning it on.

1687
01:32:16,200 --> 01:32:17,500
I don't know very much about

1688
01:32:17,600 --> 01:32:20,400
Microsoft's, but I pretty sure they've had an auto vectorizer in there

1689
01:32:20,400 --> 01:32:21,000
as well.

1690
01:32:22,200 --> 01:32:25,500
I just don't remember the specifics of that, but I think they do.

1691
01:32:25,600 --> 01:32:30,400
So they're in there and, you know, I don't know, your mileage may

1692
01:32:30,400 --> 01:32:31,000
vary.

1693
01:32:31,100 --> 01:32:32,800
You could play with them and see how they go.

1694
01:32:33,500 --> 01:32:38,300
Typically, what I find and this may just be me, but that auto

1695
01:32:38,300 --> 01:32:40,200
vectorization, is not really that useful.

1696
01:32:40,600 --> 01:32:43,600
And the reason for that is because typically, if you haven't

1697
01:32:43,600 --> 01:32:47,400
structured your code to work with Cindy, then there's not that much

1698
01:32:47,400 --> 01:32:50,500
the compiler can actually do to help you because typically, your stuff

1699
01:32:50,500 --> 01:32:51,700
just isn't getting.

1700
01:32:51,900 --> 01:32:54,900
Loaded and stored out in efficient enough.

1701
01:32:54,900 --> 01:32:59,300
Way to make the auto vectorization, actually work on x64 anyway.

1702
01:33:00,100 --> 01:33:04,800
And so I find that typically the work that goes into 70 programming is

1703
01:33:04,800 --> 01:33:08,100
not this this part is easy so you might as well just do it and make

1704
01:33:08,100 --> 01:33:09,700
sure the compiler doesn't screw it up.

1705
01:33:10,800 --> 01:33:15,100
The hard part is reorganizing the data and the like unpacking and

1706
01:33:15,100 --> 01:33:18,700
packing steps, which the compiler tends to be the worst at.

1707
01:33:19,100 --> 01:33:21,800
And so typically I find that the compiler has some help you that much

1708
01:33:21,900 --> 01:33:23,700
and really it's not because

1709
01:33:24,700 --> 01:33:28,100
It couldn't necessarily figure out how to do an M&M add PS, it's

1710
01:33:28,100 --> 01:33:29,500
because figuring out the do an M, Ed.

1711
01:33:29,500 --> 01:33:30,700
PS is the easy part.

1712
01:33:30,700 --> 01:33:35,000
Anyone can just type it in and it's really not an issue, you know,

1713
01:33:35,000 --> 01:33:38,700
it's as easy as just changing it from, you know, a plus b, 2 m, Ed PS

1714
01:33:38,700 --> 01:33:40,000
parentheses 8, comma B.

1715
01:33:40,200 --> 01:33:43,100
You know, anyone can do that in the compiler is not really saving you

1716
01:33:43,100 --> 01:33:44,100
very much time there.

1717
01:33:44,300 --> 01:33:49,300
The problem is those that set up in the, the shutdown of the routine,

1718
01:33:49,300 --> 01:33:49,900
basically.

1719
01:33:50,500 --> 01:33:52,400
And so that's that's the issue, usually?

1720
01:33:54,500 --> 01:33:57,000
Do you have to take the instruction cache into account or is it large

1721
01:33:57,000 --> 01:34:02,900
enough typically not for sort of the lighter-weight optimizations like

1722
01:34:02,900 --> 01:34:03,900
what I tend to do?

1723
01:34:04,700 --> 01:34:07,000
If you're a super hard carve score Optimizer.

1724
01:34:07,000 --> 01:34:07,200
Yeah.

1725
01:34:07,200 --> 01:34:10,700
You tell you you do you have to think about it?

1726
01:34:10,700 --> 01:34:13,800
At least, depends on the routine, whether it'll be a problem or not.

1727
01:34:13,800 --> 01:34:17,700
But it does basically mean that sometimes routines that are larger but

1728
01:34:17,700 --> 01:34:20,800
potentially more efficient or actually slower than routines that are

1729
01:34:20,800 --> 01:34:23,700
smaller and a little less efficient, that's what

1730
01:34:23,800 --> 01:34:27,300
And some practice, but again, like at the level that I tend to

1731
01:34:27,300 --> 01:34:29,500
optimize things, that's not the sort of thing I start thinking about,

1732
01:34:29,500 --> 01:34:31,300
because I don't take it to that level.

1733
01:34:31,600 --> 01:34:34,300
But if you're a super hardcore Optimizer, you probably do think about

1734
01:34:34,300 --> 01:34:34,700
that.

1735
01:34:39,400 --> 01:34:41,900
How does intrinsic some parallel processing work together?

1736
01:34:42,000 --> 01:34:44,400
Does each CPU have registers to do intrinsics?

1737
01:34:44,600 --> 01:34:47,000
If so, could we increase X fill the number pixel rendering and our

1738
01:34:47,000 --> 01:34:48,700
computer if we compute in parallel?

1739
01:34:48,900 --> 01:34:49,300
Yes.

1740
01:34:49,300 --> 01:34:51,900
So typically, they're completely separate you.

1741
01:34:51,900 --> 01:34:53,400
They don't interact in any way.

1742
01:34:53,600 --> 01:34:56,600
So, basically, anything that you can do with a bunch of intrinsics on

1743
01:34:56,600 --> 01:35:01,600
One processor, you could then just do on another processor as well.

1744
01:35:01,600 --> 01:35:02,500
Totally separately.

1745
01:35:03,100 --> 01:35:07,800
So we will actually probably take advantage of this when we

1746
01:35:08,900 --> 01:35:11,100
We optimize for multi-threading a little later on.

1747
01:35:11,300 --> 01:35:15,600
We will probably basically bin things into rows or something like this

1748
01:35:16,400 --> 01:35:20,000
and have our different processors operate on different regions of the

1749
01:35:20,000 --> 01:35:22,400
screen or something like this, right?

1750
01:35:33,700 --> 01:35:35,800
All right, think that's about it.

1751
01:35:37,500 --> 01:35:39,000
Look like there's any more questions.

1752
01:35:39,400 --> 01:35:41,400
So I'm going to go ahead and wrap things up.

1753
01:35:44,100 --> 01:35:45,500
Close these down here.

1754
01:35:55,800 --> 01:35:58,800
Alrighty, thank you everyone for joining me for another episode of

1755
01:35:58,800 --> 01:35:59,700
handmade hero.

1756
01:36:00,500 --> 01:36:02,100
I wasn't a pleasure coding with you.

1757
01:36:02,100 --> 01:36:08,700
As always tomorrow, we will start actually writing our actual routine

1758
01:36:08,700 --> 01:36:12,000
in Cindy because we've looked at how it works.

1759
01:36:12,000 --> 01:36:14,500
We've talked about it, we've restructured the routine for it.

1760
01:36:14,600 --> 01:36:16,800
And so now all we really have to do is put in some intrinsics to

1761
01:36:16,800 --> 01:36:20,500
actually start using some Sim decode and we'll do that tomorrow.

1762
01:36:20,500 --> 01:36:22,500
And I suspect we'll probably actually finish it tomorrow as well.

1763
01:36:22,500 --> 01:36:26,200
It's really pretty straightforward but we won't get to is those pre

1764
01:36:26,200 --> 01:36:28,400
and post ambles the load in the store because that's a lot more

1765
01:36:28,400 --> 01:36:28,900
complicated.

1766
01:36:28,900 --> 01:36:29,900
And that will what will

1767
01:36:30,000 --> 01:36:32,000
To pick up on next week.

1768
01:36:32,600 --> 01:36:34,100
So I hope you'll come back and join me.

1769
01:36:34,100 --> 01:36:34,500
Nine a.m.

1770
01:36:34,500 --> 01:36:37,200
tomorrow when we actually go through and and Cindy eyes the math

1771
01:36:37,200 --> 01:36:37,700
block,

1772
01:36:38,700 --> 01:36:39,800
Again it's pretty straightforward.

1773
01:36:39,800 --> 01:36:42,100
You could almost do it for homework but there's a couple things I

1774
01:36:42,100 --> 01:36:45,400
didn't quite show you yet so you know, maybe not don't, don't worry

1775
01:36:45,400 --> 01:36:48,100
too much if you're not ready to do that yet, we will do it tomorrow.

1776
01:36:48,400 --> 01:36:49,400
So thank you, everyone.

1777
01:36:49,400 --> 01:36:51,900
And I hope to see you back here tomorrow in the meantime, if you do

1778
01:36:51,900 --> 01:36:54,300
want to follow along with the source code at home, you can always

1779
01:36:54,300 --> 01:36:56,500
pre-order the game on handmade hero dot org and it comes with the

1780
01:36:56,500 --> 01:36:57,300
source code.

1781
01:36:57,300 --> 01:36:59,700
Just use the little pre-order button here, and that will take care of

1782
01:36:59,700 --> 01:37:00,100
it.

1783
01:37:00,500 --> 01:37:03,700
We also have a forum site where you can ask questions if you miss the

1784
01:37:03,700 --> 01:37:05,900
Q&A and want to ask some questions stuff like that, it's good place to

1785
01:37:05,900 --> 01:37:06,200
do it.

1786
01:37:06,200 --> 01:37:08,300
Also Sports a Mac and Linux ante the episode

1787
01:37:08,500 --> 01:37:09,400
Stuff like that.

1788
01:37:09,600 --> 01:37:12,400
There's also a patreon page where you can support the video series,

1789
01:37:12,700 --> 01:37:14,900
always very much, appreciate if you want, subscribe to that.

1790
01:37:14,900 --> 01:37:17,300
And finally, there's a tweetbot that helps you keep up to date with a

1791
01:37:17,300 --> 01:37:17,600
schedule.

1792
01:37:17,600 --> 01:37:19,500
If you want to catch the live stream, which again would be very

1793
01:37:19,500 --> 01:37:23,600
important say for today, where we had to move the livestreams time due

1794
01:37:23,600 --> 01:37:25,900
to unforeseen consequences.

1795
01:37:26,900 --> 01:37:30,300
So basically if you do like catching the stream live and you want to

1796
01:37:30,300 --> 01:37:33,800
be kept up to date on when it's going to be on any given day, the

1797
01:37:33,800 --> 01:37:35,400
tweetbot is the place to go.

1798
01:37:35,900 --> 01:37:36,800
So thanks again for joining me.

1799
01:37:36,800 --> 01:37:38,000
I hope to see you back here again.

1800
01:37:38,400 --> 01:37:38,900
9 a.m.

1801
01:37:38,900 --> 01:37:42,300
tomorrow until then have a wonderful day and I will see you guys

1802
01:37:42,300 --> 01:37:42,700
later.

1803
01:37:42,700 --> 01:37:43,600
Take it easy everyone.

