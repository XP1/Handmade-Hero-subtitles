1
00:00:00,030 --> 00:00:03,270
hello everyone in Wilkin handmade here

2
00:00:01,649 --> 00:00:04,798
oh sure we could a complete game live on

3
00:00:03,270 --> 00:00:07,349
stream we sketched out a routine

4
00:00:04,799 --> 00:00:08,339
yesterday that we want to code today and

5
00:00:07,349 --> 00:00:13,379
I don't know why I'm still wearing my

6
00:00:08,339 --> 00:00:14,849
headset that was for playing slipways in

7
00:00:13,380 --> 00:00:16,859
the pre stream if you haven't played

8
00:00:14,849 --> 00:00:20,969
slipways yet I highly recommend it you

9
00:00:16,859 --> 00:00:24,510
can go to slipways net and you know you

10
00:00:20,969 --> 00:00:26,729
can you can get your slipways on this is

11
00:00:24,510 --> 00:00:29,160
actually for the PC version that's

12
00:00:26,730 --> 00:00:30,629
coming the Piko 8 Edition is the one I'm

13
00:00:29,160 --> 00:00:33,420
playing because the PC version isn't

14
00:00:30,629 --> 00:00:34,679
here yet but this thing is awesome it's

15
00:00:33,420 --> 00:00:36,359
like my favorite game I've played in

16
00:00:34,679 --> 00:00:39,929
quite some time

17
00:00:36,359 --> 00:00:41,878
and quite a respite from playing some

18
00:00:39,929 --> 00:00:44,820
Animal Crossing which is like absolutely

19
00:00:41,878 --> 00:00:48,509
the most tedious game that you can

20
00:00:44,820 --> 00:00:52,859
imagine now so check out slipways I am

21
00:00:48,509 --> 00:00:55,948
going today to be doing the routine the

22
00:00:52,859 --> 00:00:58,710
grid-based raycast and routine that we

23
00:00:55,948 --> 00:01:01,289
sketched out yesterday because I wanted

24
00:00:58,710 --> 00:01:03,350
to test that because we want to sort of

25
00:01:01,289 --> 00:01:07,400
circle the wagons and finish up the

26
00:01:03,350 --> 00:01:09,930
raycasting part of the lighting system

27
00:01:07,400 --> 00:01:12,868
which you know works fine as it is

28
00:01:09,930 --> 00:01:16,200
currently but is not up to the speed

29
00:01:12,868 --> 00:01:17,909
that I would prefer so basically what we

30
00:01:16,200 --> 00:01:20,579
need to do is make that run fast enough

31
00:01:17,909 --> 00:01:24,450
and if you take a look right now at you

32
00:01:20,579 --> 00:01:26,609
know how it's running in game you can

33
00:01:24,450 --> 00:01:33,379
see oh wait you know what that's running

34
00:01:26,609 --> 00:01:33,379
the wrong the wrong um or out there grid

35
00:01:34,819 --> 00:01:40,048
grid based raycast do we have like

36
00:01:37,618 --> 00:01:45,868
raycast or grid raycast grid raycast

37
00:01:40,049 --> 00:01:51,229
that's it so if we want to we can switch

38
00:01:45,868 --> 00:01:54,209
this back on by saying use for arrays

39
00:01:51,228 --> 00:01:56,009
and if we take a look at the lighting

40
00:01:54,209 --> 00:01:59,578
there's two things that we're basically

41
00:01:56,009 --> 00:02:02,280
working on right now so we roughly have

42
00:01:59,578 --> 00:02:04,349
the effects we want from our lighting

43
00:02:02,280 --> 00:02:05,939
system CPU side right now but there's

44
00:02:04,349 --> 00:02:09,719
two things I want to do one is reduce

45
00:02:05,938 --> 00:02:12,180
the noise in the sampling and the other

46
00:02:09,719 --> 00:02:13,900
is to just speed it up now it does run

47
00:02:12,180 --> 00:02:16,180
30 frames a second pretty saw

48
00:02:13,900 --> 00:02:18,430
right now but the problem is I'd rather

49
00:02:16,180 --> 00:02:20,319
a trance IXY frames/second because we're

50
00:02:18,430 --> 00:02:22,840
gonna have more complex geometry in here

51
00:02:20,318 --> 00:02:25,000
and so I don't want something that

52
00:02:22,840 --> 00:02:27,610
already can't hit 60 when we're not

53
00:02:25,000 --> 00:02:32,229
really using the full geometry and yeah

54
00:02:27,610 --> 00:02:33,340
we could just do this GPU side and that

55
00:02:32,229 --> 00:02:42,518
would probably get us our frame rate

56
00:02:33,340 --> 00:02:44,859
back but you know I want to do a cpu

57
00:02:42,519 --> 00:02:48,099
side one at least first and prove that

58
00:02:44,859 --> 00:02:49,989
that's feasible because I don't really

59
00:02:48,098 --> 00:02:51,340
know how much ray-tracing support on

60
00:02:49,989 --> 00:02:53,259
cards we're gonna be able to count on

61
00:02:51,340 --> 00:02:54,969
like it'd be nice to have a fallback

62
00:02:53,259 --> 00:02:57,688
plan for if you're running on an iPad or

63
00:02:54,969 --> 00:03:00,310
something who knows what you want to do

64
00:02:57,688 --> 00:03:02,590
obviously I refuse to use Apple hardware

65
00:03:00,310 --> 00:03:05,170
now because of their like ridiculous

66
00:03:02,590 --> 00:03:07,959
policies on not letting programmers

67
00:03:05,169 --> 00:03:10,358
distribute programs they're basically

68
00:03:07,959 --> 00:03:14,739
like Richard Stallman's arch-enemy or

69
00:03:10,359 --> 00:03:16,450
something for no real reason even if he

70
00:03:14,739 --> 00:03:19,539
does occasionally eat something from his

71
00:03:16,449 --> 00:03:21,518
foot that is not a reason to not allow

72
00:03:19,539 --> 00:03:23,459
people to distribute software on your

73
00:03:21,519 --> 00:03:27,730
platform that's just basically

74
00:03:23,459 --> 00:03:31,299
antisocial and weird anyway let's go

75
00:03:27,729 --> 00:03:33,098
ahead and take a look at the routine

76
00:03:31,299 --> 00:03:35,859
that I sketched out and how it would

77
00:03:33,098 --> 00:03:38,798
need to work so in order to start using

78
00:03:35,859 --> 00:03:41,500
this grid raycast routine we need to do

79
00:03:38,799 --> 00:03:44,109
three things first we need to actually

80
00:03:41,500 --> 00:03:45,699
like implement the routine correctly

81
00:03:44,109 --> 00:03:47,109
like there's a couple things in here

82
00:03:45,699 --> 00:03:49,530
that are just sketched out and we need

83
00:03:47,109 --> 00:03:52,120
to like fill those in we can do that now

84
00:03:49,530 --> 00:03:54,759
then we need to do to set up phase

85
00:03:52,120 --> 00:03:57,699
things one is we need to produce the

86
00:03:54,759 --> 00:04:01,959
look-up tables for the directions the

87
00:03:57,699 --> 00:04:03,669
rays go and that's not that hard but it

88
00:04:01,959 --> 00:04:05,109
is a little finicky so we'll have to

89
00:04:03,669 --> 00:04:07,349
write that routine and then the other

90
00:04:05,109 --> 00:04:10,930
one is we need to actually grid up our

91
00:04:07,348 --> 00:04:12,698
geometry so we've got three steps to

92
00:04:10,930 --> 00:04:14,709
produce here so I'm gonna go ahead and

93
00:04:12,699 --> 00:04:17,049
comment in the routine we sketched out

94
00:04:14,709 --> 00:04:20,319
and we'll start by trying to make this

95
00:04:17,048 --> 00:04:21,759
work sensibly so if you look at what's

96
00:04:20,319 --> 00:04:24,189
going on the first thing you'll notice

97
00:04:21,759 --> 00:04:26,649
is we don't have a walk table here and

98
00:04:24,189 --> 00:04:29,500
so what we need to do here is in the

99
00:04:26,649 --> 00:04:32,649
the same way where we're actually doing

100
00:04:29,500 --> 00:04:35,740
the the Ray casts here where we pass the

101
00:04:32,649 --> 00:04:37,839
Ray in we need to know what our walk

102
00:04:35,740 --> 00:04:39,160
table is and I think that's probably

103
00:04:37,839 --> 00:04:42,810
going to be something that comes from

104
00:04:39,160 --> 00:04:45,070
the outer code because my guess is that

105
00:04:42,810 --> 00:04:47,410
yeah like if you look at what this is

106
00:04:45,069 --> 00:04:48,849
gonna do the people who look up the Ray

107
00:04:47,410 --> 00:04:50,740
or the people who know what the walk

108
00:04:48,850 --> 00:04:54,490
table is so it's probably gonna look

109
00:04:50,740 --> 00:04:57,310
something like walk out and we know that

110
00:04:54,490 --> 00:04:59,288
this is also a small value I don't know

111
00:04:57,310 --> 00:05:01,329
if we actually need to specify that here

112
00:04:59,288 --> 00:05:04,180
but it's something that would need to

113
00:05:01,329 --> 00:05:07,509
that might affect like it could be

114
00:05:04,180 --> 00:05:09,910
relevant to the optimizer so I'm just

115
00:05:07,509 --> 00:05:12,189
gonna tell it that it's a tiny value and

116
00:05:09,910 --> 00:05:15,639
I don't know sometimes that's actually

117
00:05:12,189 --> 00:05:19,478
worse this is one of those ways that C

118
00:05:15,639 --> 00:05:21,460
is just terrible like there's no way to

119
00:05:19,478 --> 00:05:23,740
tell it things like this is an 8-bit

120
00:05:21,459 --> 00:05:25,719
value that never overflows like that's

121
00:05:23,740 --> 00:05:27,220
the actual information I need to give it

122
00:05:25,720 --> 00:05:28,990
and of course you can't give it because

123
00:05:27,220 --> 00:05:31,510
the C++ standard community is like too

124
00:05:28,990 --> 00:05:33,728
busy you know going on vacations to

125
00:05:31,509 --> 00:05:36,969
theory land without actually ever making

126
00:05:33,728 --> 00:05:39,490
the language work so anyway I'm gonna

127
00:05:36,970 --> 00:05:41,949
give the walk table a little set up here

128
00:05:39,490 --> 00:05:44,288
and we're gonna assume that this

129
00:05:41,949 --> 00:05:46,840
actually this part doesn't actually need

130
00:05:44,288 --> 00:05:50,829
to happen right so what's actually gonna

131
00:05:46,839 --> 00:05:52,839
happen here is when we look up the walk

132
00:05:50,829 --> 00:05:56,848
table we're just gonna look it up like

133
00:05:52,839 --> 00:05:59,788
this we're gonna say like the grid index

134
00:05:56,848 --> 00:06:03,908
equals the walk table walk index and

135
00:05:59,788 --> 00:06:06,610
this is the grid index here and so those

136
00:06:03,908 --> 00:06:08,288
are both driven off of this well not

137
00:06:06,610 --> 00:06:12,250
both that is driven off of the walk

138
00:06:08,288 --> 00:06:14,469
index so we run through that array in

139
00:06:12,250 --> 00:06:17,139
the way that you would expect and we

140
00:06:14,470 --> 00:06:19,270
pull out the individual grid squares

141
00:06:17,139 --> 00:06:21,579
that we think that we're gonna need we

142
00:06:19,269 --> 00:06:25,389
pull those spatial grid nodes out of

143
00:06:21,579 --> 00:06:27,579
this out of whatever the storage is

144
00:06:25,389 --> 00:06:29,769
going to be for those and we expect each

145
00:06:27,579 --> 00:06:34,629
time we get one of those to see a start

146
00:06:29,769 --> 00:06:35,680
in a one pass last right now these are

147
00:06:34,629 --> 00:06:37,810
probably just going to be copied

148
00:06:35,680 --> 00:06:40,240
directly out because all they are is two

149
00:06:37,810 --> 00:06:43,269
16-bit integers which

150
00:06:40,240 --> 00:06:45,129
is just totally like it's a 32-bit value

151
00:06:43,269 --> 00:06:46,569
right so we don't really want to do

152
00:06:45,129 --> 00:06:47,949
anything where we we actually used

153
00:06:46,569 --> 00:06:50,349
pointers or anything on this so I'm just

154
00:06:47,949 --> 00:06:52,569
gonna copy this out and access it this

155
00:06:50,350 --> 00:06:54,070
way that just lets the compiler know

156
00:06:52,569 --> 00:06:59,860
that it's not alias like it just

157
00:06:54,069 --> 00:07:01,810
simplifies things for the optimizer so

158
00:06:59,860 --> 00:07:04,389
now when we go in here we're gonna be

159
00:07:01,810 --> 00:07:05,740
loading these leaves out and each leaf

160
00:07:04,389 --> 00:07:08,710
is gonna have to have the information

161
00:07:05,740 --> 00:07:10,389
that we require we have the hit ref

162
00:07:08,709 --> 00:07:12,879
color and the hit emission and those

163
00:07:10,389 --> 00:07:17,848
need to come from somewhere

164
00:07:12,879 --> 00:07:23,019
mostly I think we're just doing this and

165
00:07:17,848 --> 00:07:29,259
if we look at what's happening here this

166
00:07:23,019 --> 00:07:30,698
is kind of busted actually so so my

167
00:07:29,259 --> 00:07:33,280
streaming machine right now just popped

168
00:07:30,699 --> 00:07:36,610
up a thing that says we've turned on

169
00:07:33,279 --> 00:07:39,008
storage sense to optimize storage usage

170
00:07:36,610 --> 00:07:41,319
we've turned on storage sense for you

171
00:07:39,009 --> 00:07:43,449
that is a terrifying statement so I'm

172
00:07:41,319 --> 00:07:48,399
just gonna go over to this machine and

173
00:07:43,449 --> 00:07:50,379
see what that means I think that means

174
00:07:48,399 --> 00:07:53,649
we're low on disk space so I'm gonna go

175
00:07:50,379 --> 00:07:56,348
ahead and make that not happen because

176
00:07:53,649 --> 00:07:59,168
that is very bad whatever it's doing I

177
00:07:56,348 --> 00:08:02,379
don't trust it like if Windows 10 thinks

178
00:07:59,168 --> 00:08:04,870
it's doing something it should stop it

179
00:08:02,379 --> 00:08:07,300
will never be good it's just a bad

180
00:08:04,870 --> 00:08:09,370
situation so I'm gonna go ahead and

181
00:08:07,300 --> 00:08:12,038
delete some of these recordings here

182
00:08:09,370 --> 00:08:15,280
that were on this machine and like free

183
00:08:12,038 --> 00:08:18,490
up some disk space that way so that we

184
00:08:15,279 --> 00:08:21,728
do not have this problem and I'm gonna

185
00:08:18,490 --> 00:08:26,168
turn off storage sense cuz storage sense

186
00:08:21,728 --> 00:08:27,728
is giving me the creeps Windows 10 is

187
00:08:26,168 --> 00:08:31,810
like the worst thing ever

188
00:08:27,728 --> 00:08:33,908
I really wish I think John often says

189
00:08:31,810 --> 00:08:36,099
the phrase they need an adult to

190
00:08:33,908 --> 00:08:38,139
supervise it and I totally agree

191
00:08:36,099 --> 00:08:41,110
I don't think Windows has had an adult

192
00:08:38,139 --> 00:08:44,189
on the team in like I mean at least in

193
00:08:41,110 --> 00:08:46,480
management for an incredibly long time

194
00:08:44,190 --> 00:08:48,100
they may have forgotten what an adult

195
00:08:46,480 --> 00:08:49,720
looks like they're like Oh an adult

196
00:08:48,100 --> 00:08:51,490
that's the thing in diapers that like

197
00:08:49,720 --> 00:08:54,129
waves a rattle around right and you're

198
00:08:51,490 --> 00:08:58,620
like no that's not an adult

199
00:08:54,129 --> 00:08:58,620
that's the opposite of an adult actually

200
00:08:58,649 --> 00:09:01,990
so okay

201
00:09:00,250 --> 00:09:04,659
I have cleaned up this particular

202
00:09:01,990 --> 00:09:06,339
problem here and now we can go back to

203
00:09:04,659 --> 00:09:08,559
actual programming which is what I

204
00:09:06,339 --> 00:09:15,339
wanted to do before Windows interrupted

205
00:09:08,559 --> 00:09:23,409
me so okay so going back to actual

206
00:09:15,339 --> 00:09:25,060
programming what I want to do here is I

207
00:09:23,409 --> 00:09:27,278
want to make sure that we're actually

208
00:09:25,059 --> 00:09:31,778
picking these things properly and if

209
00:09:27,278 --> 00:09:34,539
we're loading these things up four at a

210
00:09:31,778 --> 00:09:38,439
time so this is testing four leaves at

211
00:09:34,539 --> 00:09:40,149
once and you know one of the other

212
00:09:38,440 --> 00:09:42,579
things about this is is these are all

213
00:09:40,149 --> 00:09:46,480
for wide so these leaves are for boxes

214
00:09:42,578 --> 00:09:49,539
packed together but it's fine

215
00:09:46,480 --> 00:09:53,649
we want to be able to load in for ref

216
00:09:49,539 --> 00:09:56,198
colors at the same time and we also want

217
00:09:53,649 --> 00:09:58,480
to load in for his emissions at the same

218
00:09:56,198 --> 00:10:00,458
time so these need to be loaded this way

219
00:09:58,480 --> 00:10:02,170
now these are a little bit piggy they're

220
00:10:00,458 --> 00:10:03,938
bigger than they need to be but it's

221
00:10:02,169 --> 00:10:06,250
okay for now because we haven't done

222
00:10:03,938 --> 00:10:08,198
storage optimization on this yet we're

223
00:10:06,250 --> 00:10:10,360
gonna have to to make sure that we

224
00:10:08,198 --> 00:10:12,309
actually get the most performance out of

225
00:10:10,360 --> 00:10:14,589
it because we don't really want to be

226
00:10:12,309 --> 00:10:17,799
moving a bunch of crap around that

227
00:10:14,589 --> 00:10:19,480
doesn't need to get moved right it's

228
00:10:17,799 --> 00:10:21,578
just worse for the cache and takes more

229
00:10:19,480 --> 00:10:23,740
instructions and etc etc so the more

230
00:10:21,578 --> 00:10:25,750
things we can load up into one the

231
00:10:23,740 --> 00:10:27,490
better and so if you looked at like this

232
00:10:25,750 --> 00:10:29,078
for example so you know you've got like

233
00:10:27,490 --> 00:10:31,180
the min the max color of the emission

234
00:10:29,078 --> 00:10:33,429
you know there's so many things that we

235
00:10:31,179 --> 00:10:34,539
could start doing here to optimize the

236
00:10:33,429 --> 00:10:36,698
way that these things flew through the

237
00:10:34,539 --> 00:10:37,958
pipe and so eventually we may like do

238
00:10:36,698 --> 00:10:41,229
some of that right that's all as I'm

239
00:10:37,958 --> 00:10:43,599
saying so I think that's all we really

240
00:10:41,230 --> 00:10:47,350
need here this loads everything out that

241
00:10:43,600 --> 00:10:50,040
we needed to we know that these are 16s

242
00:10:47,350 --> 00:10:55,120
as well like I said all of these are

243
00:10:50,039 --> 00:10:58,198
small right and so we can just leave

244
00:10:55,120 --> 00:11:00,759
that be and we can look to see what the

245
00:10:58,198 --> 00:11:02,979
compiler is actually generating and we

246
00:11:00,759 --> 00:11:06,339
may need to do other things there it

247
00:11:02,980 --> 00:11:08,649
depends right so in

248
00:11:06,339 --> 00:11:11,230
we now have a question if I compile that

249
00:11:08,649 --> 00:11:13,089
what I can do too is sketch out what

250
00:11:11,230 --> 00:11:14,589
these look like as well because I might

251
00:11:13,089 --> 00:11:16,740
as well do that too

252
00:11:14,589 --> 00:11:20,019
so we would know that if we were gonna

253
00:11:16,740 --> 00:11:21,220
implement this routine the grid nodes we

254
00:11:20,019 --> 00:11:24,818
now know what they would look like

255
00:11:21,220 --> 00:11:27,730
they're a start index and a one past

256
00:11:24,818 --> 00:11:29,409
last index and we also know what the

257
00:11:27,730 --> 00:11:36,970
leaves look like so we know what this

258
00:11:29,409 --> 00:11:45,870
looks like yeah we know that this is a

259
00:11:36,970 --> 00:11:50,490
box men a box Max and a ref color and

260
00:11:45,870 --> 00:11:54,698
emission so this is for emissions pact

261
00:11:50,490 --> 00:11:57,549
this is for ref colors pax this is for

262
00:11:54,698 --> 00:12:02,729
box mins and this is for box maxes and

263
00:11:57,549 --> 00:12:05,740
those can all get load up load load opt

264
00:12:02,730 --> 00:12:08,949
here and these get loaded in and

265
00:12:05,740 --> 00:12:12,870
processed here so that seems totally

266
00:12:08,948 --> 00:12:16,419
fine to me and doesn't super-scary mean

267
00:12:12,870 --> 00:12:18,639
so if we go into the lighting solution

268
00:12:16,419 --> 00:12:21,039
and we look at what we're doing here so

269
00:12:18,639 --> 00:12:23,678
we can also say like okay in the same

270
00:12:21,039 --> 00:12:25,088
way that we were just gonna like have

271
00:12:23,678 --> 00:12:29,068
all these different things flat on top

272
00:12:25,089 --> 00:12:31,809
of each other I can go ahead and grab a

273
00:12:29,068 --> 00:12:33,849
an array for each of these and say these

274
00:12:31,808 --> 00:12:35,139
are gonna go in here and I don't

275
00:12:33,850 --> 00:12:37,928
actually know like what they're gonna

276
00:12:35,139 --> 00:12:39,278
look like yet and I don't care but we

277
00:12:37,928 --> 00:12:41,708
know that we're gonna be loading these

278
00:12:39,278 --> 00:12:49,028
off like this and actually that's

279
00:12:41,708 --> 00:12:52,149
spatial grid node spatial grid leaves so

280
00:12:49,028 --> 00:12:54,370
that's the whole collision detector like

281
00:12:52,149 --> 00:12:56,169
basically this is the Ray caster now and

282
00:12:54,370 --> 00:12:57,490
you can see why I wanted to try it out

283
00:12:56,169 --> 00:12:59,498
this way because when I was thinking

284
00:12:57,490 --> 00:13:01,480
about it in my head I'm like this can be

285
00:12:59,499 --> 00:13:06,129
so much more straightforward all it's

286
00:13:01,480 --> 00:13:08,740
doing is doing an index based load off

287
00:13:06,129 --> 00:13:12,428
of these leaves right so it loads

288
00:13:08,740 --> 00:13:15,759
indices in order and loads leaves off of

289
00:13:12,428 --> 00:13:17,759
those indices so it's dependent load but

290
00:13:15,759 --> 00:13:19,930
it's there's nothing to predict right

291
00:13:17,759 --> 00:13:22,269
there's no ifs

292
00:13:19,929 --> 00:13:24,609
at all in this entire thing so you're

293
00:13:22,269 --> 00:13:27,460
only paying the only thing you're paying

294
00:13:24,610 --> 00:13:29,379
for during the raycast is one branch

295
00:13:27,460 --> 00:13:30,639
that is only happening at the end so

296
00:13:29,379 --> 00:13:34,059
this is predictable the whole time

297
00:13:30,639 --> 00:13:36,340
through until you end right and then

298
00:13:34,059 --> 00:13:39,279
you've got this one so this is the only

299
00:13:36,340 --> 00:13:41,830
like issue is the branch for this loop

300
00:13:39,279 --> 00:13:45,909
otherwise it's just a straight streaming

301
00:13:41,830 --> 00:13:47,800
process or right now there's issues with

302
00:13:45,909 --> 00:13:49,990
it I don't necessarily know that's going

303
00:13:47,799 --> 00:13:52,299
to be placing lis fast but you can see

304
00:13:49,990 --> 00:13:54,310
why I wanted this because if you compare

305
00:13:52,299 --> 00:13:57,879
this to how complicated like the K treat

306
00:13:54,309 --> 00:14:00,489
gate KD tree or a bee tree walks were is

307
00:13:57,879 --> 00:14:03,549
there's just a lot more decision-making

308
00:14:00,490 --> 00:14:06,669
going on and the more decision-making

309
00:14:03,549 --> 00:14:08,649
there is the harder it is to make the

310
00:14:06,669 --> 00:14:11,019
routine operate in a streamlined fashion

311
00:14:08,649 --> 00:14:13,689
right because it's not just a straight

312
00:14:11,019 --> 00:14:21,730
stream process that that CPU can chug

313
00:14:13,690 --> 00:14:25,870
through right and so I don't know what

314
00:14:21,730 --> 00:14:27,519
else to do to predict its performance

315
00:14:25,870 --> 00:14:29,860
unfortunately so we're just implementing

316
00:14:27,519 --> 00:14:32,919
it but that's the idea that's why I want

317
00:14:29,860 --> 00:14:34,870
to test this one so I think that's

318
00:14:32,919 --> 00:14:36,969
everything for the loop so mostly now

319
00:14:34,870 --> 00:14:41,320
it's the support of the loop that is the

320
00:14:36,970 --> 00:14:43,450
issue now exiting the loop we have more

321
00:14:41,320 --> 00:14:45,010
work to do because before we

322
00:14:43,450 --> 00:14:45,580
fundamentally have two ways we can

323
00:14:45,009 --> 00:14:47,200
raycast

324
00:14:45,580 --> 00:14:48,730
in this version of the raycasting and

325
00:14:47,200 --> 00:14:50,410
this is another reason that I like it

326
00:14:48,730 --> 00:14:52,269
but again it could end up being a bad

327
00:14:50,409 --> 00:14:55,839
idea but the other reason I like it is

328
00:14:52,269 --> 00:14:58,600
instead of casting for raise at a time

329
00:14:55,840 --> 00:14:59,889
it cast one rate at a time and normally

330
00:14:58,600 --> 00:15:01,389
you think of that as a bad idea but the

331
00:14:59,889 --> 00:15:02,710
problem is with a rain caster when you

332
00:15:01,389 --> 00:15:06,159
cast for a raise at a time they're

333
00:15:02,710 --> 00:15:07,690
incoherent so you don't necessarily know

334
00:15:06,159 --> 00:15:10,149
that they have to both that that all

335
00:15:07,690 --> 00:15:13,690
four rays go down the same parts of your

336
00:15:10,149 --> 00:15:15,309
spatial partition so if you if you're

337
00:15:13,690 --> 00:15:16,540
doing it that way it means every time

338
00:15:15,309 --> 00:15:18,699
through your loop you're testing one

339
00:15:16,539 --> 00:15:20,469
leaf at a time against four rays you

340
00:15:18,700 --> 00:15:22,210
would rather be testing one Regan's four

341
00:15:20,470 --> 00:15:24,040
leaves if you can figure out a way to

342
00:15:22,210 --> 00:15:25,780
make that fast enough and in this case I

343
00:15:24,039 --> 00:15:28,269
think maybe we have I don't actually

344
00:15:25,779 --> 00:15:30,100
know the problem we're gonna run into is

345
00:15:28,269 --> 00:15:32,069
if you don't have very many leaves that

346
00:15:30,100 --> 00:15:33,850
are actually filled with you know

347
00:15:32,070 --> 00:15:35,680
actually four

348
00:15:33,850 --> 00:15:37,990
if a lot of the leaves are filled with

349
00:15:35,679 --> 00:15:39,399
only two or one that becomes a problem

350
00:15:37,990 --> 00:15:41,230
because then you're spending a lot of

351
00:15:39,399 --> 00:15:43,179
time doing operations that you don't use

352
00:15:41,230 --> 00:15:45,730
much like in the other version you're

353
00:15:43,179 --> 00:15:47,500
spending a lot of time walking down tree

354
00:15:45,730 --> 00:15:50,460
branches that aren't necessarily useful

355
00:15:47,500 --> 00:15:53,769
for a particular array so you can either

356
00:15:50,460 --> 00:15:56,320
push into the spatial partition side of

357
00:15:53,769 --> 00:15:58,419
things or you can push into the leaf

358
00:15:56,320 --> 00:16:00,010
side of things that inefficiency and the

359
00:15:58,419 --> 00:16:01,659
question is which one's smarter now

360
00:16:00,009 --> 00:16:03,759
there are ways you can actually fill

361
00:16:01,659 --> 00:16:05,259
holes so if you look at what's going on

362
00:16:03,759 --> 00:16:08,620
here there's another way we could write

363
00:16:05,259 --> 00:16:10,000
this routine and again it may be the

364
00:16:08,620 --> 00:16:11,080
better way to write this routine so

365
00:16:10,000 --> 00:16:13,419
we're gonna have to write it both ways

366
00:16:11,080 --> 00:16:14,800
to see which one's faster probably and

367
00:16:13,419 --> 00:16:18,009
the other way to write this routine is

368
00:16:14,799 --> 00:16:20,049
to pack on demand so if instead of doing

369
00:16:18,009 --> 00:16:21,819
the inner leaf here what we actually did

370
00:16:20,049 --> 00:16:23,169
was the inner leaf in a pre walk which

371
00:16:21,820 --> 00:16:24,250
is the way I first like what sort of

372
00:16:23,169 --> 00:16:26,319
sketching it out and I said well let's

373
00:16:24,250 --> 00:16:28,090
try this way first if you actually do

374
00:16:26,320 --> 00:16:30,640
the inner leave in a pre walk then you

375
00:16:28,090 --> 00:16:32,470
know you are only paying the absolute

376
00:16:30,639 --> 00:16:34,990
minimum wastage because you only waste

377
00:16:32,470 --> 00:16:36,430
the very end it could be that that's

378
00:16:34,990 --> 00:16:38,620
just a fundamentally smarter way to do

379
00:16:36,429 --> 00:16:40,329
it so basically you load you have a pre

380
00:16:38,620 --> 00:16:43,029
walk that goes through loading in

381
00:16:40,330 --> 00:16:46,450
interleaving as many things as the Rae

382
00:16:43,029 --> 00:16:48,009
actually touches and again I really

383
00:16:46,450 --> 00:16:53,110
don't know which of those two would be

384
00:16:48,009 --> 00:16:56,110
more efficient so you're gonna have to

385
00:16:53,110 --> 00:16:58,060
figure that out yourself and I'm gonna

386
00:16:56,110 --> 00:17:01,720
have to figure that out myself as we go

387
00:16:58,059 --> 00:17:03,669
so that part is is tough and you know

388
00:17:01,720 --> 00:17:06,328
I'll slap you in here in case just so

389
00:17:03,669 --> 00:17:06,328
everyone remembers

390
00:17:29,099 --> 00:17:34,719
and so it's hard to say now it's worth

391
00:17:32,048 --> 00:17:37,529
noting that this one is still fine when

392
00:17:34,720 --> 00:17:41,740
there's nothing so if there are no

393
00:17:37,529 --> 00:17:44,829
actual members it will just skip right

394
00:17:41,740 --> 00:17:51,279
so it's we're not wasting computation in

395
00:17:44,829 --> 00:17:53,439
cases where you don't so we're not gonna

396
00:17:51,279 --> 00:17:55,178
we're not wasting computation in cases

397
00:17:53,440 --> 00:17:56,980
where there's nothing to do we're just

398
00:17:55,179 --> 00:17:59,019
wasting computation where there's not a

399
00:17:56,980 --> 00:18:01,120
multiple of four things to do because

400
00:17:59,019 --> 00:18:03,700
whatever the modulus is whatever the

401
00:18:01,119 --> 00:18:05,798
wastage is on that if there was only two

402
00:18:03,700 --> 00:18:08,710
things in it but we compute four then

403
00:18:05,798 --> 00:18:10,418
we're wasting two lanes of our Sindhi in

404
00:18:08,710 --> 00:18:11,558
much the same way that if you went down

405
00:18:10,419 --> 00:18:13,690
a branch of a tree

406
00:18:11,558 --> 00:18:15,519
that you didn't need for one of the

407
00:18:13,690 --> 00:18:18,009
raise in or two of the raise in your

408
00:18:15,519 --> 00:18:20,319
lanes but the other two did need that

409
00:18:18,009 --> 00:18:22,900
branch then you're wasting half of your

410
00:18:20,319 --> 00:18:25,119
lanes in that case right so the wastage

411
00:18:22,900 --> 00:18:27,370
is very similar in both cases because

412
00:18:25,119 --> 00:18:28,808
when you mask out you're gonna end up

413
00:18:27,369 --> 00:18:30,668
like masking out something and you don't

414
00:18:28,808 --> 00:18:33,970
actually need to do it or whatever right

415
00:18:30,669 --> 00:18:35,890
so it's just it's it's this thing that

416
00:18:33,970 --> 00:18:39,100
happens with Cindy it's why Cindy is

417
00:18:35,890 --> 00:18:41,530
inefficient you do it because you can

418
00:18:39,099 --> 00:18:43,058
tell the cpu to do a lot of things at

419
00:18:41,529 --> 00:18:46,058
once and that turns out to be a big

420
00:18:43,058 --> 00:18:47,710
benefit but it's just it's inefficient

421
00:18:46,058 --> 00:18:50,859
because you can't always come up with

422
00:18:47,710 --> 00:18:56,650
enough work to do without going through

423
00:18:50,859 --> 00:18:58,750
a lot of gyrations especially in things

424
00:18:56,650 --> 00:19:03,669
like this where you've got where you

425
00:18:58,750 --> 00:19:06,308
trying to call all right so now if we

426
00:19:03,669 --> 00:19:08,740
take a look and we look at the outside

427
00:19:06,308 --> 00:19:10,210
of the gene when we fall out and we just

428
00:19:08,740 --> 00:19:13,390
have to figure out which way were

429
00:19:10,210 --> 00:19:16,919
actually take taking the fastest way to

430
00:19:13,390 --> 00:19:21,730
do this would be using SC 4 sorry 3

431
00:19:16,919 --> 00:19:22,750
ssse3 and use them in Posie PU which is

432
00:19:21,730 --> 00:19:25,599
this right here

433
00:19:22,750 --> 00:19:27,279
and the way that we would do this this

434
00:19:25,599 --> 00:19:30,939
is basically gonna tell us it would come

435
00:19:27,279 --> 00:19:33,309
it would put into the min test it would

436
00:19:30,940 --> 00:19:36,029
actually put in there who was the

437
00:19:33,309 --> 00:19:39,720
minimum act the actual minimum value and

438
00:19:36,029 --> 00:19:42,250
that's a much faster way to do this than

439
00:19:39,720 --> 00:19:44,049
actually doing any kind of sets of

440
00:19:42,250 --> 00:19:47,079
swizzles the question is do we want to

441
00:19:44,049 --> 00:19:49,629
use ssse3 we looked it up and there is

442
00:19:47,079 --> 00:19:51,669
no nothing like nobody on Steam doesn't

443
00:19:49,630 --> 00:19:56,940
have it so it's probably pretty safe to

444
00:19:51,670 --> 00:20:00,640
use three more or less across the board

445
00:19:56,940 --> 00:20:03,400
so we could probably use min pause EPU

446
00:20:00,640 --> 00:20:04,990
and if we did that then if you take a

447
00:20:03,400 --> 00:20:06,700
look at what that actually does here so

448
00:20:04,990 --> 00:20:13,420
you can see in the insulin in transit

449
00:20:06,700 --> 00:20:15,430
sky min pause EPU so if you look at the

450
00:20:13,420 --> 00:20:18,550
way this behaves it's basically a

451
00:20:15,430 --> 00:20:21,910
horizontal compare it takes four cycles

452
00:20:18,549 --> 00:20:25,599
to do you can see why it's ssse3 it's

453
00:20:21,910 --> 00:20:28,150
only in skylake and forward cores so if

454
00:20:25,599 --> 00:20:30,490
you have the old ones it's not there I

455
00:20:28,150 --> 00:20:32,320
guess now sometimes the intelligence

456
00:20:30,490 --> 00:20:33,670
guide is wrong I mean how could it be

457
00:20:32,319 --> 00:20:35,439
right it's only made by the people who

458
00:20:33,670 --> 00:20:37,330
make the chips so sometimes you want to

459
00:20:35,440 --> 00:20:39,580
go look at a third party for that so I

460
00:20:37,329 --> 00:20:42,849
don't actually know the same hardware

461
00:20:39,579 --> 00:20:44,439
survey is really the thing but let's

462
00:20:42,849 --> 00:20:49,750
take a look at whatever that is and

463
00:20:44,440 --> 00:20:54,070
what's that instruction it's that so if

464
00:20:49,750 --> 00:20:57,190
we turn on as this e we can look here

465
00:20:54,069 --> 00:20:59,889
and see what it actually thinks it's on

466
00:20:57,190 --> 00:21:01,420
so in this case it's just registered to

467
00:20:59,890 --> 00:21:04,120
register we don't care about registered

468
00:21:01,420 --> 00:21:06,880
in memory here it is and you can see

469
00:21:04,119 --> 00:21:09,519
that it's in sky lake ice lake cable a

470
00:21:06,880 --> 00:21:12,190
coffee like and okay so basically the

471
00:21:09,519 --> 00:21:15,629
Intel intrinsics guide is full of it

472
00:21:12,190 --> 00:21:20,200
this is totally wrong I mean here it is

473
00:21:15,630 --> 00:21:22,030
like it's on everything like so I don't

474
00:21:20,200 --> 00:21:24,009
know where they were getting that from

475
00:21:22,029 --> 00:21:26,829
like Sandy Bridge ivory bridge has well

476
00:21:24,009 --> 00:21:30,329
Broadwell everybody has it way before

477
00:21:26,829 --> 00:21:35,189
sky lake so I don't know what I I don't

478
00:21:30,329 --> 00:21:38,849
why that's the case so we can do that

479
00:21:35,190 --> 00:21:41,850
it's a latency for instruction so to be

480
00:21:38,849 --> 00:21:44,278
honest I'm not 100% certain we actually

481
00:21:41,849 --> 00:21:46,500
need it because if you take a look at

482
00:21:44,278 --> 00:21:51,558
how long it takes us to do it the other

483
00:21:46,500 --> 00:21:59,548
way around it's also going to be for

484
00:21:51,558 --> 00:22:02,730
probably latency for I mean it's more

485
00:21:59,548 --> 00:22:04,470
like latency five to do it the other so

486
00:22:02,730 --> 00:22:06,298
I'm gonna go ahead and say this is just

487
00:22:04,470 --> 00:22:08,339
stupid like if it's a latency for

488
00:22:06,298 --> 00:22:11,278
instruction but it only took us five

489
00:22:08,339 --> 00:22:14,220
instructions probably to do this I'm not

490
00:22:11,278 --> 00:22:18,869
sure we actually need to do that

491
00:22:14,220 --> 00:22:21,960
I mean I guess the benefit is this brick

492
00:22:18,869 --> 00:22:36,778
this gives us something better to work

493
00:22:21,960 --> 00:22:38,460
with I mean I guess the benefit of it is

494
00:22:36,778 --> 00:22:40,200
this latency for but it puts the right

495
00:22:38,460 --> 00:22:41,460
thing in there and I didn't really have

496
00:22:40,200 --> 00:22:42,778
a good strategy for putting the right

497
00:22:41,460 --> 00:22:44,730
thing in there like we needed to use a

498
00:22:42,778 --> 00:22:47,638
shuffle table to pick up what the answer

499
00:22:44,730 --> 00:22:50,159
was and so I suppose that the argument

500
00:22:47,638 --> 00:22:52,019
there is like look it's latency for but

501
00:22:50,159 --> 00:22:53,760
it puts exactly the right thing in for

502
00:22:52,019 --> 00:22:56,700
us I believe because if we take a look

503
00:22:53,759 --> 00:23:00,210
at what the actual result is of that you

504
00:22:56,700 --> 00:23:03,269
can see that you get in 0-2 like right

505
00:23:00,210 --> 00:23:09,329
here in the zero two bits you get the

506
00:23:03,269 --> 00:23:11,460
index of of who was the minimum right so

507
00:23:09,329 --> 00:23:19,349
it looks at all the 16-bit integers of

508
00:23:11,460 --> 00:23:23,278
which there should be eight right it

509
00:23:19,349 --> 00:23:29,579
fills the the bottom three bits with

510
00:23:23,278 --> 00:23:31,909
that information although I think is the

511
00:23:29,579 --> 00:23:31,908
min

512
00:23:34,670 --> 00:23:39,570
where do those go oh I'm like I'm like

513
00:23:37,859 --> 00:23:41,609
what the heck it's just using those as

514
00:23:39,569 --> 00:23:44,549
temporary variables for some reason so

515
00:23:41,609 --> 00:23:46,289
it's storing the minimum the value that

516
00:23:44,549 --> 00:23:49,349
was actually the minimum it's storing it

517
00:23:46,289 --> 00:23:52,500
in 0 through 15 and then in 16 through

518
00:23:49,349 --> 00:23:57,089
18 so in the next 16-bit up it's storing

519
00:23:52,500 --> 00:24:00,059
the index right so if we actually wanted

520
00:23:57,089 --> 00:24:04,740
to use a byte shuffle we'd have to do

521
00:24:00,059 --> 00:24:09,200
like a replicate that like you know that

522
00:24:04,740 --> 00:24:14,789
broadcasts this thing across the entire

523
00:24:09,200 --> 00:24:17,400
across the entire selection and that's

524
00:24:14,789 --> 00:24:19,920
fine so if you look at where this is

525
00:24:17,400 --> 00:24:21,420
being placed it's kind of a little bit

526
00:24:19,920 --> 00:24:25,710
inconvenience so we would need to do a

527
00:24:21,420 --> 00:24:27,150
shift first to move it down so it would

528
00:24:25,710 --> 00:24:30,480
be something like this

529
00:24:27,150 --> 00:24:33,030
like you'd do a shift or well if you

530
00:24:30,480 --> 00:24:36,240
could do a shuffle as well so you would

531
00:24:33,029 --> 00:24:38,039
do a 32-bit shift or I don't know to

532
00:24:36,240 --> 00:24:46,410
actually do they have a 32-bit shift

533
00:24:38,039 --> 00:24:48,119
they may not know they do I was like I

534
00:24:46,410 --> 00:24:49,560
couldn't remember if 32-bit shift got

535
00:24:48,119 --> 00:24:52,969
added the first time or where the 32-bit

536
00:24:49,559 --> 00:25:03,329
shifts were added later so we can do a

537
00:24:52,970 --> 00:25:05,970
shift right and I want that one so we

538
00:25:03,329 --> 00:25:12,029
can do a shift right by 16 so it'd be

539
00:25:05,970 --> 00:25:14,009
like a like a ester a epi32 right and

540
00:25:12,029 --> 00:25:16,740
what we would want to do here is just

541
00:25:14,009 --> 00:25:19,619
say like okay we want to shift this

542
00:25:16,740 --> 00:25:21,720
thing after we get it we want to shift

543
00:25:19,619 --> 00:25:25,019
this thing right by 16 to put it in the

544
00:25:21,720 --> 00:25:28,410
bottom and then we want to do so that

545
00:25:25,019 --> 00:25:31,889
produces a new whole ball of wax there

546
00:25:28,410 --> 00:25:34,470
then we want to do now that we have that

547
00:25:31,890 --> 00:25:37,140
we want to do an mm shuffle to broadcast

548
00:25:34,470 --> 00:25:40,380
it right and you can see so this avoids

549
00:25:37,140 --> 00:25:43,650
actually loading in a table and which

550
00:25:40,380 --> 00:25:46,080
again this this might be faster I mean

551
00:25:43,650 --> 00:25:46,740
just looking at it I'm wondering cuz I

552
00:25:46,079 --> 00:25:53,339
don't know how long

553
00:25:46,740 --> 00:26:00,140
move masks takes I don't know how long

554
00:25:53,339 --> 00:26:03,209
move mistakes it's not long right

555
00:26:00,140 --> 00:26:05,250
so yeah I mean it may just be that it

556
00:26:03,210 --> 00:26:07,140
just isn't worth it you just move just

557
00:26:05,250 --> 00:26:13,650
move masks and load out of shuffle table

558
00:26:07,140 --> 00:26:15,900
I mean seems like it so even though we

559
00:26:13,650 --> 00:26:21,840
could use that and what's the what's

560
00:26:15,900 --> 00:26:24,960
shuffle epi8 as sse3 so if we want to

561
00:26:21,839 --> 00:26:28,919
use that we do have to use sse3 as well

562
00:26:24,960 --> 00:26:32,220
so we don't actually get that for free

563
00:26:28,920 --> 00:26:34,140
if I look at you ops info what speech f

564
00:26:32,220 --> 00:26:40,380
be listed as in terms of architectures

565
00:26:34,140 --> 00:26:43,250
here if I go to just a standard register

566
00:26:40,380 --> 00:26:43,250
register shuffle

567
00:26:47,890 --> 00:26:54,160
so again are they sure I don't know I

568
00:26:54,970 --> 00:27:00,170
don't always know if this thing is right

569
00:26:58,059 --> 00:27:01,819
anyway it doesn't really matter point

570
00:27:00,170 --> 00:27:03,740
being that's probably fine because

571
00:27:01,819 --> 00:27:05,899
there's not going to be again like the I

572
00:27:03,740 --> 00:27:09,349
think min pause and shuffle are both

573
00:27:05,900 --> 00:27:13,310
fine so it's really hard

574
00:27:09,349 --> 00:27:15,230
I mean P chef P Chef be not regular chef

575
00:27:13,309 --> 00:27:18,319
PS regular stuff PS goes back even

576
00:27:15,230 --> 00:27:21,440
further that's like to the first that

577
00:27:18,319 --> 00:27:25,429
was in the first SSU release like SSE

578
00:27:21,440 --> 00:27:27,920
one so I don't actually know what to do

579
00:27:25,430 --> 00:27:29,840
here I do not know which of these would

580
00:27:27,920 --> 00:27:32,300
be smarter but it does seem like you'd

581
00:27:29,839 --> 00:27:34,159
be doing a lot too once you actually got

582
00:27:32,299 --> 00:27:37,190
the min out there and you wanted then

583
00:27:34,160 --> 00:27:40,730
produce a shuffle that corresponds in

584
00:27:37,190 --> 00:27:47,180
order to shuffle any shuffle you can do

585
00:27:40,730 --> 00:27:50,809
that's gonna have an input is gonna be

586
00:27:47,180 --> 00:27:54,920
ssse3 anyway so you're already kind of

587
00:27:50,809 --> 00:27:59,829
out of luck because the inputs I don't

588
00:27:54,920 --> 00:27:59,830
think you can there's nothing you can do

589
00:28:00,970 --> 00:28:05,960
there's nothing you can do that takes a

590
00:28:03,259 --> 00:28:08,150
that doesn't use an immediate right so

591
00:28:05,960 --> 00:28:09,860
basically the first time like pea chef B

592
00:28:08,150 --> 00:28:12,230
is the first time you can actually get

593
00:28:09,859 --> 00:28:13,729
something out like as far as I know I

594
00:28:12,230 --> 00:28:16,009
don't think there's any other way

595
00:28:13,730 --> 00:28:17,779
besides pea chef B to have something

596
00:28:16,009 --> 00:28:21,379
that's in the register and actually do

597
00:28:17,779 --> 00:28:25,089
something with it right everything else

598
00:28:21,380 --> 00:28:25,090
that shuffles is immediate shuffle

599
00:28:25,539 --> 00:28:31,970
that's that's what I recall anyway so

600
00:28:29,210 --> 00:28:33,289
yeah so having to do all that work it

601
00:28:31,970 --> 00:28:34,970
seems like maybe you just load the

602
00:28:33,289 --> 00:28:37,579
shuffle table and call it a day and that

603
00:28:34,970 --> 00:28:39,259
way you don't really care about min pose

604
00:28:37,579 --> 00:28:40,789
because it just seems like it's more

605
00:28:39,259 --> 00:28:45,230
trouble than it's worth

606
00:28:40,789 --> 00:28:47,119
to get that out now we could use instead

607
00:28:45,230 --> 00:28:49,849
of doing it this way we could still use

608
00:28:47,119 --> 00:28:51,649
min pose epu and say look we do the mole

609
00:28:49,849 --> 00:28:55,669
we do the min pause and then we're just

610
00:28:51,650 --> 00:28:58,040
gonna actually like move that 32-bit

611
00:28:55,670 --> 00:28:59,750
value out so we'll just extract the

612
00:28:58,039 --> 00:29:00,589
32-bit value and then still use a

613
00:28:59,750 --> 00:29:03,380
shuffle table

614
00:29:00,589 --> 00:29:06,769
and that may still be faster than doing

615
00:29:03,380 --> 00:29:13,789
all of these it's latency for but it

616
00:29:06,769 --> 00:29:16,069
might work maybe again it builds up a

617
00:29:13,788 --> 00:29:18,319
huge dependency chain off of here so I'm

618
00:29:16,069 --> 00:29:20,480
not sure but yeah so if we did a min

619
00:29:18,319 --> 00:29:23,418
pause here and then we said look just

620
00:29:20,480 --> 00:29:25,730
move that value out so you know maybe

621
00:29:23,419 --> 00:29:27,549
you do maybe you do the shift so that

622
00:29:25,730 --> 00:29:29,419
now you've cleared it and then you do an

623
00:29:27,548 --> 00:29:33,648
mm oops

624
00:29:29,419 --> 00:29:38,600
mm convert and we just extract the value

625
00:29:33,648 --> 00:29:40,009
so in fact actually we may be able to do

626
00:29:38,599 --> 00:29:43,189
that in one go

627
00:29:40,009 --> 00:29:45,648
actually we can so what we could do is

628
00:29:43,190 --> 00:29:50,210
not do that we could just say alright do

629
00:29:45,648 --> 00:29:53,239
an mm extract epi16 and then just say

630
00:29:50,210 --> 00:29:55,880
look we need the second one bro right so

631
00:29:53,240 --> 00:30:00,200
like get us that particular one out so

632
00:29:55,880 --> 00:30:01,640
this here is what whatever the actual

633
00:30:00,200 --> 00:30:04,700
lookup in the shuffle table is so this

634
00:30:01,640 --> 00:30:06,649
is the like shuffle index here we would

635
00:30:04,700 --> 00:30:10,009
just say all right that's the extraction

636
00:30:06,648 --> 00:30:15,099
that we actually wanted and now we just

637
00:30:10,009 --> 00:30:15,099
say look that up in the shuffle table

638
00:30:15,548 --> 00:30:28,009
and off we go so once we have that that

639
00:30:24,288 --> 00:30:30,140
just loads a shuffle table for 0 1 2 or

640
00:30:28,009 --> 00:30:34,009
3 right whichever one it's going to be

641
00:30:30,140 --> 00:30:35,570
and then we shuffle epp chef B I don't

642
00:30:34,009 --> 00:30:37,158
know why they insist on always having

643
00:30:35,569 --> 00:30:39,678
different names for the intrinsics

644
00:30:37,159 --> 00:30:42,980
versus the instructions it's maddening

645
00:30:39,679 --> 00:30:44,480
just call it something if it's shuffle

646
00:30:42,980 --> 00:30:46,880
call it shuffle if it's pea chef be

647
00:30:44,480 --> 00:30:49,669
caught Keisha feed just like this nobody

648
00:30:46,880 --> 00:30:50,929
wants this I do not know why anyone

649
00:30:49,669 --> 00:30:53,809
wants this I should just make a giant

650
00:30:50,929 --> 00:30:54,950
pound to find thing that like but you

651
00:30:53,808 --> 00:30:57,019
can't even do that because they force

652
00:30:54,950 --> 00:30:59,028
you to pass these different I hate this

653
00:30:57,019 --> 00:31:02,960
just make it look like sembly language

654
00:30:59,028 --> 00:31:05,359
it is assembly language huh so

655
00:31:02,960 --> 00:31:09,079
frustrating and the typing like the MM

656
00:31:05,359 --> 00:31:14,359
128 versus once we I hate that stuff so

657
00:31:09,079 --> 00:31:17,659
annoying anyway so what we want to

658
00:31:14,359 --> 00:31:20,659
here is we want to go in and make this

659
00:31:17,660 --> 00:31:23,210
code path now be correct so we want to

660
00:31:20,660 --> 00:31:26,480
shuffle everything so that we load up a

661
00:31:23,210 --> 00:31:31,430
shuffle table we shuffle each time to

662
00:31:26,480 --> 00:31:35,870
produce a output that has only the one

663
00:31:31,430 --> 00:31:38,120
Rea we care about right now because we

664
00:31:35,869 --> 00:31:40,309
like there's no reason for us to drop

665
00:31:38,119 --> 00:31:41,599
the scaler here even though we only care

666
00:31:40,309 --> 00:31:50,119
about the thing that's in the zero

667
00:31:41,599 --> 00:31:53,419
column because we so actually we don't

668
00:31:50,119 --> 00:31:58,750
need to do this either this can be an mm

669
00:31:53,420 --> 00:31:58,750
like load one now that I think about it

670
00:32:03,910 --> 00:32:09,710
so we can't actually just load a single

671
00:32:07,279 --> 00:32:17,420
value I don't know what they call that

672
00:32:09,710 --> 00:32:23,299
in oops or as my so if I want to load

673
00:32:17,420 --> 00:32:32,840
just one thing you're gonna let me do

674
00:32:23,299 --> 00:32:35,930
that you're not I feel like there's a

675
00:32:32,839 --> 00:32:38,059
way to do a load one PS of a float so

676
00:32:35,930 --> 00:32:42,500
shouldn't there be a way to do a load 1

677
00:32:38,059 --> 00:32:44,629
of an int right but if I remember

678
00:32:42,500 --> 00:32:47,359
correctly this there's some really weird

679
00:32:44,630 --> 00:32:51,260
thing we're loading one integer actually

680
00:32:47,359 --> 00:32:54,559
just doesn't work and you the intrinsic

681
00:32:51,259 --> 00:32:57,170
slike don't work on they only work on

682
00:32:54,559 --> 00:32:59,329
Windows or something it's I don't

683
00:32:57,170 --> 00:33:03,140
remember the specifics it's absolutely

684
00:32:59,329 --> 00:33:05,329
nuts it's again just more stupidity but

685
00:33:03,140 --> 00:33:09,140
like I want to say there was a thing

686
00:33:05,329 --> 00:33:17,710
that like you can do was it in

687
00:33:09,140 --> 00:33:20,980
conversion it's also frustrating so yeah

688
00:33:17,710 --> 00:33:20,980
it's like

689
00:33:22,558 --> 00:33:31,788
I don't know where it is

690
00:33:35,230 --> 00:33:42,160
I do not know where it is there's there

691
00:33:39,009 --> 00:33:45,819
was a way to like cast from an inch to

692
00:33:42,160 --> 00:33:47,919
one of these things yes set one so I

693
00:33:45,819 --> 00:33:51,939
want to say that there was some really

694
00:33:47,919 --> 00:33:56,259
weird stuff where when you do a set one

695
00:33:51,940 --> 00:34:02,380
like epi16 or whatever it like doesn't

696
00:33:56,259 --> 00:34:03,099
work like on intel or some weird thing

697
00:34:02,380 --> 00:34:07,330
like this

698
00:34:03,099 --> 00:34:09,368
I really cannot remember the specifics

699
00:34:07,329 --> 00:34:12,969
but it's like I'm it doesn't work on

700
00:34:09,369 --> 00:34:16,358
Linux rather there was some ridiculous

701
00:34:12,969 --> 00:34:18,969
like getting the VP broadcast W like

702
00:34:16,358 --> 00:34:22,029
didn't happen or something

703
00:34:18,969 --> 00:34:23,678
I just cannot remember so what we want

704
00:34:22,030 --> 00:34:32,350
to do is this basically we want to do a

705
00:34:23,679 --> 00:34:36,460
VP broadcast D and we want to do a VP

706
00:34:32,349 --> 00:34:39,039
broadcast D of 0 1 2 3 right so we would

707
00:34:36,460 --> 00:34:42,220
load that up and we would we would put

708
00:34:39,039 --> 00:34:44,980
that in there so it just goes 0 1 2 3 0

709
00:34:42,219 --> 00:34:46,868
1 2 3 0 1 2 3 but it's not actually 0 1

710
00:34:44,980 --> 00:34:49,090
2 3 it's whatever the it's whatever the

711
00:34:46,869 --> 00:34:50,679
action the C's are so it might be four

712
00:34:49,090 --> 00:34:53,108
five six seven four five six seven four

713
00:34:50,679 --> 00:34:55,269
six seven four seven it's just pulling

714
00:34:53,108 --> 00:34:57,369
the correct bytes so that everyone

715
00:34:55,269 --> 00:35:00,519
shuffles into the lower Lane that's all

716
00:34:57,369 --> 00:35:03,670
we're trying to do here right so I don't

717
00:35:00,519 --> 00:35:06,400
know if I can actually use this on Linux

718
00:35:03,670 --> 00:35:07,960
I just don't remember I remembered there

719
00:35:06,400 --> 00:35:09,608
being some weird thing like I shipped a

720
00:35:07,960 --> 00:35:10,869
version of meow hash with this in it and

721
00:35:09,608 --> 00:35:13,509
people were like it doesn't compile on

722
00:35:10,869 --> 00:35:15,430
Linux and they were right it didn't and

723
00:35:13,510 --> 00:35:16,990
it was like what the heck you know what

724
00:35:15,429 --> 00:35:20,649
I can test it here cuz I don't really

725
00:35:16,989 --> 00:35:22,179
want to go the like the slash the Stack

726
00:35:20,650 --> 00:35:24,940
Exchange route and have someone tell me

727
00:35:22,179 --> 00:35:28,539
something wrong so let's just test it

728
00:35:24,940 --> 00:35:32,829
here here's GCC I'm gonna shove this in

729
00:35:28,539 --> 00:35:37,329
here and just see what it says if I

730
00:35:32,829 --> 00:35:39,099
include the the intrinsics file so in

731
00:35:37,329 --> 00:35:40,299
here if I set the options I'm gonna use

732
00:35:39,099 --> 00:35:41,618
clang because I don't really actually

733
00:35:40,300 --> 00:35:43,810
know how to use you see I'm used in a

734
00:35:41,619 --> 00:35:45,460
really long time

735
00:35:43,809 --> 00:35:46,750
I assume the switches are the same they

736
00:35:45,460 --> 00:35:49,240
usually are but I don't actually

737
00:35:46,750 --> 00:35:51,849
so if I go to clang here and I say

738
00:35:49,239 --> 00:35:53,559
alright like go ahead and include like

739
00:35:51,849 --> 00:36:01,500
what is it in trend on H or something

740
00:35:53,559 --> 00:36:08,469
like this in trend on H is not correct

741
00:36:01,500 --> 00:36:14,409
see this it might be that I'm gonna go

742
00:36:08,469 --> 00:36:16,269
ahead and look at me on hash cuz I don't

743
00:36:14,409 --> 00:36:17,440
ever remember what the heck the fact

744
00:36:16,269 --> 00:36:19,780
that these are different include files

745
00:36:17,440 --> 00:36:21,940
on different platforms is also amazing

746
00:36:19,780 --> 00:36:23,440
to me everything about the way these

747
00:36:21,940 --> 00:36:27,099
intrinsics were handled is amazing to me

748
00:36:23,440 --> 00:36:30,329
it's like the biggest cluster of stuff

749
00:36:27,099 --> 00:36:32,680
for no reason like at all

750
00:36:30,329 --> 00:36:36,269
like everything should have been done

751
00:36:32,679 --> 00:36:42,190
cleanly here and none of it was alright

752
00:36:36,269 --> 00:36:46,090
so if I do that it does not like that

753
00:36:42,190 --> 00:36:56,409
now maybe that's because what's the

754
00:36:46,090 --> 00:36:58,720
architecture switch on this thing so I'm

755
00:36:56,409 --> 00:37:01,179
gonna give it like a boost and say look

756
00:36:58,719 --> 00:37:04,088
use all the extensions and all that

757
00:37:01,179 --> 00:37:07,179
stuff do you know this instruction so

758
00:37:04,088 --> 00:37:10,389
yeah so unless I'm missing something

759
00:37:07,179 --> 00:37:13,598
oh no it's fine so it just didn't I just

760
00:37:10,389 --> 00:37:16,358
because I didn't give it a memory all

761
00:37:13,599 --> 00:37:19,869
right so it looks like I can use Sethi

762
00:37:16,358 --> 00:37:21,219
pi32 on clang so I'm gonna go ahead and

763
00:37:19,869 --> 00:37:23,410
say just something else I was thinking

764
00:37:21,219 --> 00:37:25,059
of and we're okay I just want to make

765
00:37:23,409 --> 00:37:26,649
sure that I wasn't gonna set a little

766
00:37:25,059 --> 00:37:32,219
booby trap for folks compounding on

767
00:37:26,650 --> 00:37:34,838
another platform there so set one epi32

768
00:37:32,219 --> 00:37:37,059
should work and that does a broadcast

769
00:37:34,838 --> 00:37:39,190
correct like I'll verify that it

770
00:37:37,059 --> 00:37:40,509
actually does a broadcast but then I'm

771
00:37:39,190 --> 00:37:45,550
gonna say that that's the way we'll just

772
00:37:40,510 --> 00:37:49,480
load out of our table so let me look at

773
00:37:45,550 --> 00:37:50,589
the V broadcast oops the key broadcast

774
00:37:49,480 --> 00:37:58,978
right

775
00:37:50,588 --> 00:37:58,978
where's the broadcast instruction what

776
00:38:06,429 --> 00:38:15,009
so what is this actually doing you

777
00:38:11,170 --> 00:38:18,369
notice it doesn't actually mention what

778
00:38:15,010 --> 00:38:22,390
does it actually do why does it it

779
00:38:18,369 --> 00:38:25,180
normally it has the instruction that

780
00:38:22,389 --> 00:38:30,219
it's going to use and in here it does

781
00:38:25,179 --> 00:38:32,710
not which no here it is so VP broadcast

782
00:38:30,219 --> 00:38:35,078
EVP Brooke SW and so on so why was I not

783
00:38:32,710 --> 00:38:35,740
able to search for these is there a

784
00:38:35,079 --> 00:38:39,039
reason for that

785
00:38:35,739 --> 00:38:44,649
is that because of like I don't have

786
00:38:39,039 --> 00:38:50,049
something contract that I need to okay

787
00:38:44,650 --> 00:38:52,720
so those were in a V X so if that

788
00:38:50,048 --> 00:38:54,788
intrinsic might it says it's an SS

789
00:38:52,719 --> 00:38:58,298
either so I wonder what it what will it

790
00:38:54,789 --> 00:39:04,750
generate only in SSE what would actually

791
00:38:58,298 --> 00:39:10,000
use would be my question right like if I

792
00:39:04,750 --> 00:39:13,449
use that if it's if it's not gonna do a

793
00:39:10,000 --> 00:39:16,900
VP broadcast what is it gonna do you

794
00:39:13,449 --> 00:39:21,848
know what I mean like cuz I don't really

795
00:39:16,900 --> 00:39:24,039
know what that will actually generate so

796
00:39:21,849 --> 00:39:26,890
I guess one way to do it is just to look

797
00:39:24,039 --> 00:39:29,589
and see what it generates so if I do a

798
00:39:26,889 --> 00:39:32,798
set one EP a-- epi32 let's just see

799
00:39:29,588 --> 00:39:36,480
because I don't again I I'm just nervous

800
00:39:32,798 --> 00:39:39,940
that's all I'm just nervous about this

801
00:39:36,480 --> 00:39:46,659
but if I do a set one epi32 offer the

802
00:39:39,940 --> 00:39:49,000
shuffle table like so that's what I

803
00:39:46,659 --> 00:39:52,420
actually want to have happen here and if

804
00:39:49,000 --> 00:40:01,920
we do a nerfing of the rest of the

805
00:39:52,420 --> 00:40:06,039
routine like this and I don't know

806
00:40:01,920 --> 00:40:08,170
transfer PPS it's nothing

807
00:40:06,039 --> 00:40:11,220
let me just go ahead and make sure this

808
00:40:08,170 --> 00:40:11,220
does something

809
00:40:16,099 --> 00:40:31,909
first and this needs a convert so if I'm

810
00:40:25,530 --> 00:40:36,570
gonna do a convert here I need to do a

811
00:40:31,909 --> 00:40:38,759
so yeah again if I do this EP u16 this

812
00:40:36,570 --> 00:40:43,609
is a little bit gnarly because if I do a

813
00:40:38,760 --> 00:40:50,400
convert here to go from float to 16 I

814
00:40:43,608 --> 00:40:54,108
have to then pack and after I pack the

815
00:40:50,400 --> 00:40:57,829
index of which six teens to grab is

816
00:40:54,108 --> 00:40:57,829
slightly off

817
00:40:58,760 --> 00:41:03,030
well no it's still correct because it's

818
00:41:01,170 --> 00:41:03,840
still zero one two three four yeah so

819
00:41:03,030 --> 00:41:05,790
okay it's fine

820
00:41:03,840 --> 00:41:07,470
so after I do my mol this puts it into

821
00:41:05,789 --> 00:41:11,279
the range so then I just need to do an

822
00:41:07,469 --> 00:41:13,169
mm convert and I'm going to do this in

823
00:41:11,280 --> 00:41:16,470
action of multiple steps then I'm gonna

824
00:41:13,170 --> 00:41:22,320
do this here where I'm gonna do like you

825
00:41:16,469 --> 00:41:24,149
know in tier a integer basically so I'm

826
00:41:22,320 --> 00:41:28,950
gonna do like a Mull and then I'm gonna

827
00:41:24,150 --> 00:41:30,780
do a mm convert EP IPs right so this

828
00:41:28,949 --> 00:41:33,839
will basically turn these floating-point

829
00:41:30,780 --> 00:41:38,070
numbers into integers which is what I

830
00:41:33,840 --> 00:41:42,840
want so once we have them as integers

831
00:41:38,070 --> 00:41:53,940
then I'll do the comparison on them now

832
00:41:42,840 --> 00:41:57,260
one thing so actually I don't need to do

833
00:41:53,940 --> 00:41:57,260
the multiplication do I

834
00:42:00,079 --> 00:42:08,869
I mean you sort of do because we're

835
00:42:07,190 --> 00:42:11,088
gonna truncate them so I guess we do I

836
00:42:08,869 --> 00:42:16,489
was gonna be like you can just compare

837
00:42:11,088 --> 00:42:20,268
them directly because the minimum like a

838
00:42:16,489 --> 00:42:26,269
floating-point value if you compared the

839
00:42:20,268 --> 00:42:30,439
floating-point value if you can poured

840
00:42:26,268 --> 00:42:36,618
the floating-point value as if it were

841
00:42:30,440 --> 00:42:39,739
an integer that would work right meaning

842
00:42:36,619 --> 00:42:41,749
a floating point values layout is such

843
00:42:39,739 --> 00:42:48,139
that it will compare as if it was a

844
00:42:41,748 --> 00:42:50,298
signed integer is that not true because

845
00:42:48,139 --> 00:42:52,489
the sign bit is still the first bit

846
00:42:50,298 --> 00:42:54,920
meaning much like two's complement if

847
00:42:52,489 --> 00:42:58,059
the high bit of the value point number

848
00:42:54,920 --> 00:43:01,849
is set its negative if it's 0 it's not

849
00:42:58,059 --> 00:43:06,619
then you have the exponent and the

850
00:43:01,849 --> 00:43:11,180
exponent works exactly the same way it

851
00:43:06,619 --> 00:43:12,858
gets larger as it get as the number gets

852
00:43:11,179 --> 00:43:15,409
larger and then you have the mantissa

853
00:43:12,858 --> 00:43:18,139
which is just an integer basically in

854
00:43:15,409 --> 00:43:23,838
the exact same way it just gets larger

855
00:43:18,139 --> 00:43:26,420
as it gets larger so I think that I mean

856
00:43:23,838 --> 00:43:28,278
I'm assuming if they were smart when

857
00:43:26,420 --> 00:43:30,608
they did I Triple E which they were if I

858
00:43:28,278 --> 00:43:33,108
remember correctly they were very good

859
00:43:30,608 --> 00:43:35,389
they wouldn't have wanted to make 2

860
00:43:33,108 --> 00:43:38,058
comparison circuits they would have

861
00:43:35,389 --> 00:43:40,068
wanted to be able to feed the I Triple E

862
00:43:38,059 --> 00:43:42,890
floating point value directly into their

863
00:43:40,068 --> 00:43:44,808
normal comparison circuit and have that

864
00:43:42,889 --> 00:43:46,879
do the comparison right

865
00:43:44,809 --> 00:43:48,769
they wouldn't have wanted to have made a

866
00:43:46,880 --> 00:43:50,749
completely separate comparison circuit

867
00:43:48,768 --> 00:43:53,328
just for a trick just for a

868
00:43:50,748 --> 00:44:00,139
floating-point number when when you

869
00:43:53,329 --> 00:44:02,479
wouldn't normally need to anyone out

870
00:44:00,139 --> 00:44:05,469
there in I Triple E expert who wants to

871
00:44:02,478 --> 00:44:07,759
confirm that that sounds right to me

872
00:44:05,469 --> 00:44:11,380
we probably don't have any I Triple E

873
00:44:07,759 --> 00:44:11,380
jockeys on the stream right now but

874
00:44:11,800 --> 00:44:19,120
that sounds right to me because it seems

875
00:44:14,679 --> 00:44:20,289
like they laid it out exactly such that

876
00:44:19,119 --> 00:44:22,329
you could have done that but I'm just

877
00:44:20,289 --> 00:44:24,309
not sure about the exponent part because

878
00:44:22,329 --> 00:44:25,599
when the number is negative of course

879
00:44:24,309 --> 00:44:28,150
our numbers are never going to be

880
00:44:25,599 --> 00:44:30,730
negative so in our case even if they

881
00:44:28,150 --> 00:44:33,460
didn't do that part I know I'm right for

882
00:44:30,730 --> 00:44:35,380
us because in our case we're never

883
00:44:33,460 --> 00:44:37,389
negative so we don't actually care what

884
00:44:35,380 --> 00:44:42,490
they do with the exponent or if there's

885
00:44:37,389 --> 00:44:44,049
something special I can confirm that I

886
00:44:42,489 --> 00:44:46,479
am NOT a nitro player

887
00:44:44,050 --> 00:44:50,950
fair enough in this case we could I'm

888
00:44:46,480 --> 00:44:54,300
pretty positive we could because so we

889
00:44:50,949 --> 00:45:00,599
don't actually need this convert EP IPS

890
00:44:54,300 --> 00:45:03,010
at all I don't think so

891
00:45:00,599 --> 00:45:05,079
you know we don't really need to do this

892
00:45:03,010 --> 00:45:07,060
but the reason that I'm going to is

893
00:45:05,079 --> 00:45:10,750
because since I have to pack down 216

894
00:45:07,059 --> 00:45:15,880
that part might break if you truncate

895
00:45:10,750 --> 00:45:17,860
the end of the mantissa I'm assuming

896
00:45:15,880 --> 00:45:19,720
that after the multiply truncating the

897
00:45:17,860 --> 00:45:21,190
end of the mantissa would do what you

898
00:45:19,719 --> 00:45:24,819
would do anyway if you were doing the

899
00:45:21,190 --> 00:45:28,179
conversion so I want to say I want to

900
00:45:24,820 --> 00:45:31,830
say that that that basically like

901
00:45:28,179 --> 00:45:31,829
there's two things you could do here so

902
00:45:33,630 --> 00:45:41,280
there's like a when we do them in pause

903
00:45:36,789 --> 00:45:46,659
EPU 16 there's like the horizontal

904
00:45:41,280 --> 00:45:48,850
compare right so this is our H comp

905
00:45:46,659 --> 00:45:51,699
vector and so there's two ways we could

906
00:45:48,849 --> 00:45:54,099
do this one is we can actually convert

907
00:45:51,699 --> 00:45:58,230
this to an integer right and then we can

908
00:45:54,099 --> 00:45:58,230
say build this by doing a pack

909
00:46:03,139 --> 00:46:09,568
and these are unsigned we know that

910
00:46:06,269 --> 00:46:12,780
they're not negative because you can't

911
00:46:09,568 --> 00:46:18,960
have t raise and be negative so if we

912
00:46:12,780 --> 00:46:23,900
pack tear a int like so where we just

913
00:46:18,960 --> 00:46:26,369
pack on sign 16s as a down convert I

914
00:46:23,900 --> 00:46:28,170
think that's the correct that's what

915
00:46:26,369 --> 00:46:35,309
they normally call this instruction

916
00:46:28,170 --> 00:46:39,809
right fact convert taxes and reduce a

917
00:46:35,309 --> 00:46:43,950
bit know so it's pack it's the it's

918
00:46:39,809 --> 00:46:47,298
actually the pack 30 to 1 but where is

919
00:46:43,949 --> 00:46:47,298
that one

920
00:46:55,929 --> 00:47:02,690
okay I want ones that just have PAC in

921
00:46:59,900 --> 00:47:04,250
the title please I don't actually want

922
00:47:02,690 --> 00:47:05,409
you to search the description but thank

923
00:47:04,250 --> 00:47:09,860
you

924
00:47:05,409 --> 00:47:11,960
so here's PAC s I guess you can't pack

925
00:47:09,860 --> 00:47:13,250
unsigned again I don't care because this

926
00:47:11,960 --> 00:47:20,289
number is the same no matter how you

927
00:47:13,250 --> 00:47:24,710
interpret it so it's PAC s epi32 and

928
00:47:20,289 --> 00:47:27,139
that'll pack these two down to 16s and

929
00:47:24,710 --> 00:47:31,670
then we can run the age comp on this

930
00:47:27,139 --> 00:47:34,609
right so this is one way to do it and if

931
00:47:31,670 --> 00:47:36,409
we were to look at it step by step we

932
00:47:34,610 --> 00:47:38,420
would and we need to do the multiply

933
00:47:36,409 --> 00:47:40,969
either way so I could do this and say

934
00:47:38,420 --> 00:47:47,990
alright there's an m1 28 which is like

935
00:47:40,969 --> 00:47:50,599
tier a scaled and this happens right so

936
00:47:47,989 --> 00:47:54,469
if we do tier a scaled and scale to the

937
00:47:50,599 --> 00:47:56,449
16-bit range and then I do a tea the

938
00:47:54,469 --> 00:48:01,009
tier a scaled convert if I do the

939
00:47:56,449 --> 00:48:02,239
conversion here you know and I guess I

940
00:48:01,010 --> 00:48:07,810
shouldn't say I don't know maybe this

941
00:48:02,239 --> 00:48:11,029
doesn't happen in both cases in fact

942
00:48:07,809 --> 00:48:13,340
maybe it doesn't so this would be the

943
00:48:11,030 --> 00:48:16,430
steps you scale it you convert the scale

944
00:48:13,340 --> 00:48:18,769
up to 32 bits you pack the 32 bit value

945
00:48:16,429 --> 00:48:21,980
down to 16 and then you compare the 16s

946
00:48:18,769 --> 00:48:24,949
right the other way to do it is to just

947
00:48:21,980 --> 00:48:31,340
say screw it I do not fundamentally care

948
00:48:24,949 --> 00:48:36,679
about that at all and you then literally

949
00:48:31,340 --> 00:48:41,780
just do a cast think so you need to do a

950
00:48:36,679 --> 00:48:45,529
cast and you need to do a cast in an and

951
00:48:41,780 --> 00:48:49,760
to knock out the 16-bit values you don't

952
00:48:45,530 --> 00:48:51,410
care about right so you do trying to

953
00:48:49,760 --> 00:48:54,160
think if there's any other way like I

954
00:48:51,409 --> 00:48:54,159
want it to

955
00:48:56,960 --> 00:49:02,740
I wanted to do just an extract

956
00:49:13,849 --> 00:49:17,610
so let me just take a look and see what

957
00:49:16,170 --> 00:49:21,690
a nun pack would do here because a nun

958
00:49:17,610 --> 00:49:24,390
pack might be what we want right so in

959
00:49:21,690 --> 00:49:28,470
here if we have like unpacks unpack hi

960
00:49:24,389 --> 00:49:35,699
unpack low so if I just take the upper

961
00:49:28,469 --> 00:49:38,549
part of these unpack and interleave so

962
00:49:35,699 --> 00:49:46,439
she finished in the high half so yeah

963
00:49:38,550 --> 00:49:48,330
it's not quite what I want because I

964
00:49:46,440 --> 00:49:55,260
would want something that that actually

965
00:49:48,329 --> 00:49:57,480
just zeroed out so there may be no way

966
00:49:55,260 --> 00:49:58,950
to finesse this like that like that may

967
00:49:57,480 --> 00:50:01,590
just be fine it's only three

968
00:49:58,949 --> 00:50:03,989
instructions because I can't think of it

969
00:50:01,590 --> 00:50:05,550
because although you could do like you

970
00:50:03,989 --> 00:50:07,889
could literally just compare the bits

971
00:50:05,550 --> 00:50:09,960
without you can let min pause compare

972
00:50:07,889 --> 00:50:13,440
the bits I don't know how to put it into

973
00:50:09,960 --> 00:50:16,139
a structure that gets rid of the cruft

974
00:50:13,440 --> 00:50:19,800
at the bottom so I need to compare just

975
00:50:16,139 --> 00:50:23,369
the high sixteen bits of each 32 so like

976
00:50:19,800 --> 00:50:25,950
packing the high 30 bits the high bits

977
00:50:23,369 --> 00:50:34,619
there I guess is a shuffle what a

978
00:50:25,949 --> 00:50:41,189
shuffle do that for me oh those are

979
00:50:34,619 --> 00:50:44,779
interested in the low 64 bits of a yeah

980
00:50:41,190 --> 00:50:50,579
and that's not what I want

981
00:50:44,780 --> 00:50:56,190
so I don't actually see so we could do a

982
00:50:50,579 --> 00:51:00,869
pea chef be right a pea chef B would do

983
00:50:56,190 --> 00:51:03,710
it and so you know you could do this you

984
00:51:00,869 --> 00:51:03,710
could do like a

985
00:51:09,099 --> 00:51:19,369
you could do this where you say take

986
00:51:17,300 --> 00:51:23,180
tier a shuffle it according to my

987
00:51:19,369 --> 00:51:24,500
specifications and then we have the bits

988
00:51:23,179 --> 00:51:29,139
arranged that we actually want to

989
00:51:24,500 --> 00:51:29,139
compare right so it would be like that

990
00:51:35,289 --> 00:51:49,150
you know I'm saying so I think that

991
00:51:46,519 --> 00:51:49,150
would be it

992
00:51:50,199 --> 00:52:01,339
what's the problem Oh P yeah 28 I wait

993
00:51:59,539 --> 00:52:03,860
what are you saying here cannot give our

994
00:52:01,340 --> 00:52:05,720
argument one for mentoring - no you

995
00:52:03,860 --> 00:52:06,890
define okay so is this actually the

996
00:52:05,719 --> 00:52:12,409
other way around I never remember which

997
00:52:06,889 --> 00:52:15,079
way they write these yeah okay so yeah

998
00:52:12,409 --> 00:52:16,699
so this probably is wrong to them this

999
00:52:15,079 --> 00:52:22,719
is probably the wrong way around right

1000
00:52:16,699 --> 00:52:22,719
this is probably convert PS epi32 yeah

1001
00:52:26,050 --> 00:52:31,580
so here's the two ways we could do it

1002
00:52:28,550 --> 00:52:35,360
one is one instruction it's this

1003
00:52:31,579 --> 00:52:38,569
instruction one is three instructions so

1004
00:52:35,360 --> 00:52:41,630
this is just better all the way around I

1005
00:52:38,570 --> 00:52:45,260
think it's just one instruction to do

1006
00:52:41,630 --> 00:52:46,760
everything I think and this is a load up

1007
00:52:45,260 --> 00:52:48,380
so this would not actually be an

1008
00:52:46,760 --> 00:52:50,390
instruction it would just use the

1009
00:52:48,380 --> 00:52:54,430
address it via it be a pea chef be from

1010
00:52:50,389 --> 00:52:54,429
memory I think

1011
00:52:56,869 --> 00:53:03,829
I don't know if my analysis is 100%

1012
00:53:01,068 --> 00:53:06,798
correct there but I'm pretty sure that

1013
00:53:03,829 --> 00:53:09,109
if you just compare the top 16 bits of

1014
00:53:06,798 --> 00:53:11,150
to floating-point numbers that's the

1015
00:53:09,108 --> 00:53:13,190
same as first scaling them to the best

1016
00:53:11,150 --> 00:53:14,690
possible range for the comparison which

1017
00:53:13,190 --> 00:53:18,849
is what we were going to do and then

1018
00:53:14,690 --> 00:53:22,489
comparing them as doing a conversion

1019
00:53:18,849 --> 00:53:25,430
because the bottom bits of the

1020
00:53:22,489 --> 00:53:28,639
floating-point number are bits that you

1021
00:53:25,429 --> 00:53:30,889
only get to if all the previous bits

1022
00:53:28,639 --> 00:53:32,509
were the same if any of the previous

1023
00:53:30,889 --> 00:53:34,068
bits differ you would have already known

1024
00:53:32,509 --> 00:53:35,358
because either the exponent was

1025
00:53:34,068 --> 00:53:37,429
different in which case the number is

1026
00:53:35,358 --> 00:53:40,969
higher or like we already know which

1027
00:53:37,429 --> 00:53:42,588
one's higher or the earlier bits in the

1028
00:53:40,969 --> 00:53:43,639
mantissa were higher so scaling the

1029
00:53:42,588 --> 00:53:45,788
number there's no way they could produce

1030
00:53:43,639 --> 00:53:52,838
something else you know what I'm saying

1031
00:53:45,789 --> 00:53:52,839
you know I'm saying to you you know

1032
00:53:54,130 --> 00:54:01,759
anyone anyway this is where you need

1033
00:54:00,048 --> 00:54:03,739
some I Triple E jockeys on stream but

1034
00:54:01,759 --> 00:54:05,989
I'm just saying I think you can just do

1035
00:54:03,739 --> 00:54:08,088
this I think you can just do that and

1036
00:54:05,989 --> 00:54:12,769
and you're pretty much done and you're

1037
00:54:08,088 --> 00:54:15,228
this here the H comp shuffler is just a

1038
00:54:12,768 --> 00:54:18,258
predefined value that we need to do

1039
00:54:15,228 --> 00:54:21,348
right and so in this case it's just it's

1040
00:54:18,259 --> 00:54:24,259
a u8 pattern that we define for loading

1041
00:54:21,349 --> 00:54:26,749
stuff and in here we just pretend that

1042
00:54:24,259 --> 00:54:30,710
it's an m1 28 I even though it's not

1043
00:54:26,748 --> 00:54:33,169
right so we just say look this is an H

1044
00:54:30,710 --> 00:54:36,108
comp shuffler we need this to be deco

1045
00:54:33,170 --> 00:54:40,670
spec aligned because the compiler is

1046
00:54:36,108 --> 00:54:42,199
stupid and sucks and well it's not

1047
00:54:40,670 --> 00:54:43,880
actually that it's actually not the

1048
00:54:42,199 --> 00:54:45,710
class it's that Intel was stupid and

1049
00:54:43,880 --> 00:54:48,318
sucks because they made it fault on an

1050
00:54:45,710 --> 00:54:49,548
unaligned memory operand if you don't

1051
00:54:48,318 --> 00:54:51,558
put a V prefix in front of the

1052
00:54:49,548 --> 00:54:53,809
instruction for no reason I don't know

1053
00:54:51,559 --> 00:54:55,940
why they did that this very bad idea

1054
00:54:53,809 --> 00:55:00,829
maybe there was a good ship reason but I

1055
00:54:55,940 --> 00:55:02,659
seriously doubt it anyway so in in here

1056
00:55:00,829 --> 00:55:04,579
we're gonna base to say look we've got a

1057
00:55:02,659 --> 00:55:06,858
H comp shuffler and what we need to do

1058
00:55:04,579 --> 00:55:08,809
is we need to put the things into 16-bit

1059
00:55:06,858 --> 00:55:10,199
values as necessary so what we want to

1060
00:55:08,809 --> 00:55:13,050
do is we want these to go

1061
00:55:10,199 --> 00:55:22,379
in the correct order so like zero this

1062
00:55:13,050 --> 00:55:25,160
is that's a null shuffle right so this

1063
00:55:22,380 --> 00:55:27,690
is a thing that would take a register

1064
00:55:25,159 --> 00:55:31,109
one SSE register

1065
00:55:27,690 --> 00:55:33,780
16 wide bytes right and it would shuffle

1066
00:55:31,110 --> 00:55:35,970
it to be itself because it puts the zero

1067
00:55:33,780 --> 00:55:38,330
byte at zero the one byte at one the 2

1068
00:55:35,969 --> 00:55:40,859
by 2 to the 3 by 2 3 the 4 by 2 4 right

1069
00:55:38,329 --> 00:55:44,099
so what I want to do is I want to take

1070
00:55:40,860 --> 00:55:47,610
the high 16 bits of each 32-bit value

1071
00:55:44,099 --> 00:55:49,710
and I want to put them into 0 1 2 3 and

1072
00:55:47,610 --> 00:55:54,120
then everything else I want to be 0

1073
00:55:49,710 --> 00:55:56,369
right so if we just look at you know

1074
00:55:54,119 --> 00:55:58,469
what that would look like if we actually

1075
00:55:56,369 --> 00:56:00,839
try to do it you're manually moving

1076
00:55:58,469 --> 00:56:02,459
these things around what that's going to

1077
00:56:00,840 --> 00:56:07,050
look like is first of all all right so

1078
00:56:02,460 --> 00:56:12,000
the high of a 32-bit is 2 3 right so I

1079
00:56:07,050 --> 00:56:15,690
want to put the 2 3 first right so I

1080
00:56:12,000 --> 00:56:18,719
want to put the 2 in the 3 here then the

1081
00:56:15,690 --> 00:56:24,539
4 and the 5 again are not what I want I

1082
00:56:18,719 --> 00:56:25,349
want the 6 and the 7 the 8 and the 9 or

1083
00:56:24,539 --> 00:56:28,320
not what I want

1084
00:56:25,349 --> 00:56:30,360
I wanted the 10 and the 11 and then the

1085
00:56:28,320 --> 00:56:33,510
12 and 13 or not what I want I want the

1086
00:56:30,360 --> 00:56:35,970
14 - 15 right so that would take the

1087
00:56:33,510 --> 00:56:37,920
high bits of the first d-word the high

1088
00:56:35,969 --> 00:56:39,599
bits of the second d-word the high bits

1089
00:56:37,920 --> 00:56:44,039
of the third d-word in the high bits of

1090
00:56:39,599 --> 00:56:48,029
the fourth D word impact them 0 1 2 3 in

1091
00:56:44,039 --> 00:56:50,130
terms of 16-bit values up here we end up

1092
00:56:48,030 --> 00:56:52,590
with stuff that we do not want to

1093
00:56:50,130 --> 00:56:54,840
compare against this we don't want any

1094
00:56:52,590 --> 00:56:58,829
of this to ever be the highest value

1095
00:56:54,840 --> 00:57:01,740
right so what I want to do there is I

1096
00:56:58,829 --> 00:57:04,769
want to say ok we do have a special out

1097
00:57:01,739 --> 00:57:09,419
condition which is that you can see here

1098
00:57:04,769 --> 00:57:16,230
if any of the bits like if I you can see

1099
00:57:09,420 --> 00:57:23,650
here when we do the the shuffle assuming

1100
00:57:16,230 --> 00:57:29,679
that the index itself is from is from

1101
00:57:23,650 --> 00:57:33,700
zero to sixteen then it will actually do

1102
00:57:29,679 --> 00:57:38,679
a move of that element but if instead

1103
00:57:33,699 --> 00:57:42,509
you set the high bit right so the

1104
00:57:38,679 --> 00:57:46,659
seventh bit of the value if that's set

1105
00:57:42,510 --> 00:57:49,390
then you pack a zero so what we can do

1106
00:57:46,659 --> 00:57:57,639
is just like say alright there's gonna

1107
00:57:49,389 --> 00:57:59,489
be just like clearing that happens so

1108
00:57:57,639 --> 00:58:01,900
that we will in one instruction

1109
00:57:59,489 --> 00:58:03,669
literally one instruction we will both

1110
00:58:01,900 --> 00:58:05,800
move all the comparison data to the

1111
00:58:03,670 --> 00:58:08,710
right location we will zero out

1112
00:58:05,800 --> 00:58:12,700
everything that's above us and then we

1113
00:58:08,710 --> 00:58:17,650
will be prepared to do our min pause so

1114
00:58:12,699 --> 00:58:18,759
one instruction does everything right

1115
00:58:17,650 --> 00:58:23,980
and that's better than three

1116
00:58:18,760 --> 00:58:24,910
instructions it's not always better than

1117
00:58:23,980 --> 00:58:25,840
three instructions you'd have to see

1118
00:58:24,909 --> 00:58:27,339
what those instructions take but I

1119
00:58:25,840 --> 00:58:28,900
happen to know that those instructions

1120
00:58:27,340 --> 00:58:35,670
don't execute in less than one cycle

1121
00:58:28,900 --> 00:58:39,369
altogether so right um so anyway if we

1122
00:58:35,670 --> 00:58:42,599
look at what happens here I think that's

1123
00:58:39,369 --> 00:58:49,269
the complete version of the compare and

1124
00:58:42,599 --> 00:58:57,460
the only question I have here is this

1125
00:58:49,269 --> 00:58:59,980
the right number of things it is this is

1126
00:58:57,460 --> 00:59:04,179
actually a looks like a full-on

1127
00:58:59,980 --> 00:59:06,880
reinterpret cast for some reason and the

1128
00:59:04,179 --> 00:59:10,059
rest I think we're good so now we do it

1129
00:59:06,880 --> 00:59:12,970
min pause then we extract and that gives

1130
00:59:10,059 --> 00:59:17,110
us the index we actually need why is

1131
00:59:12,969 --> 00:59:19,480
this complaining in 216 okay fine you're

1132
00:59:17,110 --> 00:59:22,570
saying this is an INT that you're giving

1133
00:59:19,480 --> 00:59:24,909
me back that's fine and then we have the

1134
00:59:22,570 --> 00:59:26,740
shuffle table here so now we just need

1135
00:59:24,909 --> 00:59:29,170
our actual shuffle table and then we can

1136
00:59:26,739 --> 00:59:30,519
have the correct shuffler so the shuffle

1137
00:59:29,170 --> 00:59:33,010
table is just going to be this thing

1138
00:59:30,519 --> 00:59:34,929
again and when this comes out the thing

1139
00:59:33,010 --> 00:59:36,790
that I don't want to have happen is what

1140
00:59:34,929 --> 00:59:37,239
if all of the raise all hit something at

1141
00:59:36,789 --> 00:59:40,509
zero

1142
00:59:37,239 --> 00:59:42,189
I shouldn't say all of the Rays what if

1143
00:59:40,510 --> 00:59:44,020
all of the leaves all somehow hit

1144
00:59:42,190 --> 00:59:49,420
something at zero so everything is zero

1145
00:59:44,019 --> 00:59:54,880
I don't know what this will pick right

1146
00:59:49,420 --> 00:59:57,639
oh and you know what that's not quite

1147
00:59:54,880 --> 01:00:02,440
right making those all zero means

1148
00:59:57,639 --> 01:00:06,659
they'll always get picked so I actually

1149
01:00:02,440 --> 01:00:10,420
need some way of making these be greater

1150
01:00:06,659 --> 01:00:12,699
which is tough so it can't do it all in

1151
01:00:10,420 --> 01:00:24,700
one instruction because we need to fill

1152
01:00:12,699 --> 01:00:29,679
those values with well we can still do

1153
01:00:24,699 --> 01:00:31,469
it in one instruction yeah we can we can

1154
01:00:29,679 --> 01:00:33,219
well we can sort of do in less pressure

1155
01:00:31,469 --> 01:00:35,379
depends on how we want to build or two

1156
01:00:33,219 --> 01:00:37,779
so we can still do into one instruction

1157
01:00:35,380 --> 01:00:42,338
by saying look we're just going to

1158
01:00:37,780 --> 01:00:45,839
repeat so zero one two three we will

1159
01:00:42,338 --> 01:00:49,989
simply PAB the end of this thing with

1160
01:00:45,838 --> 01:00:54,009
zeros I mean with a element zero so that

1161
01:00:49,989 --> 01:01:00,789
way we know if we just Pat it out right

1162
01:00:54,010 --> 01:01:03,130
so we have let's say 1 2 3 4 5 6 7 8 so

1163
01:01:00,789 --> 01:01:06,460
if we just Pat it out with 2 3 2 3 2 3 2

1164
01:01:03,130 --> 01:01:09,760
3 then if 0 is the minimum value we'll

1165
01:01:06,460 --> 01:01:12,010
get back 0 because it's never gonna

1166
01:01:09,760 --> 01:01:14,619
compare against itself assuming this

1167
01:01:12,010 --> 01:01:16,809
returns the lowest value we know if they

1168
01:01:14,619 --> 01:01:18,849
do anything else if it doesn't we have

1169
01:01:16,809 --> 01:01:20,829
to add our some things to our table in

1170
01:01:18,849 --> 01:01:22,900
case it picks the later values now I

1171
01:01:20,829 --> 01:01:31,619
don't know what it's defined to do so

1172
01:01:22,900 --> 01:01:31,619
let's take a look what's going on

1173
01:01:32,260 --> 01:01:39,619
how are you not finding that I thought

1174
01:01:34,760 --> 01:01:43,069
that was sse3 all right it's just to see

1175
01:01:39,619 --> 01:01:46,160
4.1 now thought it was ssse3 I guess

1176
01:01:43,068 --> 01:01:47,539
it's not so yeah this is so again it's a

1177
01:01:46,159 --> 01:01:48,710
little bit more expensive because we

1178
01:01:47,539 --> 01:01:52,009
don't actually know what our steam

1179
01:01:48,710 --> 01:01:53,240
hardware survey would be or outside the

1180
01:01:52,010 --> 01:01:56,349
same hardware server we don't really

1181
01:01:53,239 --> 01:02:11,118
know whether this is good or not right

1182
01:01:56,349 --> 01:02:12,890
why am I not know Wow alright um so

1183
01:02:11,119 --> 01:02:15,108
again we don't really know and that's

1184
01:02:12,889 --> 01:02:18,529
why I say like we may want to do an

1185
01:02:15,108 --> 01:02:19,759
alternate path for this we'll see but we

1186
01:02:18,530 --> 01:02:22,700
may just want to say look by the time

1187
01:02:19,760 --> 01:02:27,140
handmade hero ships because you know at

1188
01:02:22,699 --> 01:02:30,798
one weekend it's worth of like at four

1189
01:02:27,139 --> 01:02:32,088
hours a week yeah I mean come on SSC 4

1190
01:02:30,798 --> 01:02:36,710
will be I don't know we could say that

1191
01:02:32,088 --> 01:02:38,239
I'm not sure um anyway point being if we

1192
01:02:36,710 --> 01:02:41,900
take a look at what this does I don't

1193
01:02:38,239 --> 01:02:45,828
actually know which one it picks so if

1194
01:02:41,900 --> 01:02:48,769
multiple of these are the same I'm not

1195
01:02:45,829 --> 01:02:51,470
sure which one it picks if you look at

1196
01:02:48,769 --> 01:02:54,048
the way that they literally wrote this

1197
01:02:51,469 --> 01:02:56,659
then that would mean that it would pick

1198
01:02:54,048 --> 01:02:59,119
an earlier value meaning it's saying

1199
01:02:56,659 --> 01:03:04,818
less than not less than or equal to so

1200
01:02:59,119 --> 01:03:08,420
if if you pick a min value at 0 and then

1201
01:03:04,818 --> 01:03:10,308
a later one is less is equal to that one

1202
01:03:08,420 --> 01:03:12,019
it won't overwrite it because it's not

1203
01:03:10,309 --> 01:03:15,200
going to be less than it's just going to

1204
01:03:12,019 --> 01:03:17,389
be equal to so we would assume that that

1205
01:03:15,199 --> 01:03:24,618
would be fine and the shuffle index can

1206
01:03:17,389 --> 01:03:26,960
look like this cannot ever be greater

1207
01:03:24,619 --> 01:03:29,630
than 4 it has to be one of those first

1208
01:03:26,960 --> 01:03:32,960
four because it just repeats itself from

1209
01:03:29,630 --> 01:03:34,849
then on right so that's what the docs

1210
01:03:32,960 --> 01:03:37,250
say but we may have to test to make sure

1211
01:03:34,849 --> 01:03:40,548
that that's like actually true because

1212
01:03:37,250 --> 01:03:43,039
who knows right so assuming we actually

1213
01:03:40,548 --> 01:03:44,480
have this right though our shuffle table

1214
01:03:43,039 --> 01:03:46,369
then produces what

1215
01:03:44,480 --> 01:03:49,730
ever it is that we actually want here

1216
01:03:46,369 --> 01:03:51,650
and if we do a set one epi32 on it it

1217
01:03:49,730 --> 01:03:53,630
means that we then have another one of

1218
01:03:51,650 --> 01:03:57,590
these here right which is our shuffle

1219
01:03:53,630 --> 01:04:00,650
table and the shuffle table just needs

1220
01:03:57,590 --> 01:04:03,740
to have the correct values to pick out

1221
01:04:00,650 --> 01:04:05,809
those bytes so if we imagine that what

1222
01:04:03,739 --> 01:04:09,368
we're doing here is is picking out the

1223
01:04:05,809 --> 01:04:11,358
right bytes that go hmm

1224
01:04:09,369 --> 01:04:13,550
depending on which one of these we want

1225
01:04:11,358 --> 01:04:16,579
we kind of know that hey it's just

1226
01:04:13,550 --> 01:04:19,700
replicated each bite is just replicated

1227
01:04:16,579 --> 01:04:26,630
you know what I mean so I need a few

1228
01:04:19,699 --> 01:04:30,199
more of these here right so if zero was

1229
01:04:26,630 --> 01:04:34,369
the lowest value then we would know that

1230
01:04:30,199 --> 01:04:37,250
we would pick the if zero was the lowest

1231
01:04:34,369 --> 01:04:38,720
value then we would just pick all zeros

1232
01:04:37,250 --> 01:04:41,300
so we don't really have to do anything

1233
01:04:38,719 --> 01:04:43,879
for our shuffle table there because it's

1234
01:04:41,300 --> 01:04:47,019
just going to just replicate all zeros

1235
01:04:43,880 --> 01:04:50,480
right oh wait no I take that back

1236
01:04:47,019 --> 01:04:55,460
that's not true it needs to replicate 0

1237
01:04:50,480 --> 01:04:59,630
1 2 3 so as to be 0 1 2 3 0 1 2 3 0 1 2

1238
01:04:55,460 --> 01:05:04,780
3 right so it would have to be across

1239
01:04:59,630 --> 01:05:04,780
the byte here it would have to be like 0

1240
01:05:11,289 --> 01:05:20,659
so it would be 0 1 2 3 like that right

1241
01:05:17,630 --> 01:05:23,690
because it's gonna load this up it's

1242
01:05:20,659 --> 01:05:26,389
gonna replicate it for wide and then

1243
01:05:23,690 --> 01:05:28,450
it's going to use it so if that's gonna

1244
01:05:26,389 --> 01:05:31,819
pull the load D word out of everything

1245
01:05:28,449 --> 01:05:36,559
now if I wanted to pull the next D word

1246
01:05:31,820 --> 01:05:41,300
out then it's 4 5 6 7 if I want to pull

1247
01:05:36,559 --> 01:05:43,820
the next D word out it's 8 9 10 11 and

1248
01:05:41,300 --> 01:05:53,650
if I want to pull the final D word out

1249
01:05:43,820 --> 01:05:53,650
it's 12 13 14 15 right

1250
01:05:58,369 --> 01:06:04,469
so I think literally all we're doing

1251
01:06:01,199 --> 01:06:06,929
here is just loading you yeah we're mean

1252
01:06:04,469 --> 01:06:10,199
it's it is what it it's just whatever

1253
01:06:06,929 --> 01:06:12,299
right and we don't have to use a

1254
01:06:10,199 --> 01:06:15,000
broadcast we could use a direct load

1255
01:06:12,300 --> 01:06:21,170
here but I'm not sure that we need to do

1256
01:06:15,000 --> 01:06:25,550
that like we'll see what it generates

1257
01:06:21,170 --> 01:06:28,349
all right so compiling this code yeah

1258
01:06:25,550 --> 01:06:30,870
this needs to pass some stuff to it and

1259
01:06:28,349 --> 01:06:33,869
at the moment we don't really know what

1260
01:06:30,869 --> 01:06:36,420
that stuff is going to be so we're gonna

1261
01:06:33,869 --> 01:06:42,900
stub that out temporarily in fact we'll

1262
01:06:36,420 --> 01:06:45,690
just do this and then we'll worry about

1263
01:06:42,900 --> 01:06:47,880
it later so what I wanted to do here is

1264
01:06:45,690 --> 01:06:50,130
it probably compiled this out so I

1265
01:06:47,880 --> 01:06:52,260
probably can't actually look at it this

1266
01:06:50,130 --> 01:06:55,380
way but I wanted to see what instruction

1267
01:06:52,260 --> 01:06:59,100
it generates or tries to generate from

1268
01:06:55,380 --> 01:07:02,849
that API set oh and you know what I

1269
01:06:59,099 --> 01:07:06,029
could have done there actually I had

1270
01:07:02,849 --> 01:07:10,230
that god bolts going I could totally use

1271
01:07:06,030 --> 01:07:17,640
the god bolt for that so what did you

1272
01:07:10,230 --> 01:07:23,990
generate mr. man so let's suppose I

1273
01:07:17,639 --> 01:07:29,059
wanted to know what this value was and

1274
01:07:23,989 --> 01:07:29,059
like guy returned it or something oops

1275
01:07:32,739 --> 01:07:38,529
what's what's the deal

1276
01:07:34,929 --> 01:07:42,909
look what do you do so for the set one

1277
01:07:38,530 --> 01:07:50,019
epi32 it looks like there is no

1278
01:07:42,909 --> 01:07:52,269
instruction for that right you turn this

1279
01:07:50,019 --> 01:07:58,630
off because this is more what I'm

1280
01:07:52,269 --> 01:08:02,530
interested in just basic SSE so assuming

1281
01:07:58,630 --> 01:08:05,079
that I do a set one epi32 it looks like

1282
01:08:02,530 --> 01:08:09,220
what it's gonna do here is to mob D's in

1283
01:08:05,079 --> 01:08:13,650
a PN pack and that's not what we want at

1284
01:08:09,219 --> 01:08:15,819
all maybe it does something smarter in a

1285
01:08:13,650 --> 01:08:27,850
303 forget oh three

1286
01:08:15,820 --> 01:08:30,909
let's do o2 so what it actually did

1287
01:08:27,850 --> 01:08:35,230
there is it actually went ahead and

1288
01:08:30,909 --> 01:08:38,649
generated the correct table that we

1289
01:08:35,229 --> 01:08:41,169
would have used and it did a DQ a mauve

1290
01:08:38,649 --> 01:08:43,179
so that pretty much tells me what I need

1291
01:08:41,170 --> 01:08:46,840
to know which is that don't do what I

1292
01:08:43,180 --> 01:08:49,720
did right so what I actually want to do

1293
01:08:46,840 --> 01:08:52,750
here is I actually just want to do the

1294
01:08:49,720 --> 01:08:59,400
table like the full table so instead of

1295
01:08:52,750 --> 01:08:59,399
doing that set one where did that go

1296
01:09:01,189 --> 01:09:07,998
so instead of this we actually do want

1297
01:09:03,929 --> 01:09:15,349
the shuffle table to be like you know

1298
01:09:07,998 --> 01:09:15,349
four of sixteen it's like a Borg index

1299
01:09:15,469 --> 01:09:30,960
and we just want to do like we just want

1300
01:09:27,420 --> 01:09:32,730
to build this table so that we've

1301
01:09:30,960 --> 01:09:45,538
manually replicated it and I know wives

1302
01:09:32,729 --> 01:09:47,818
did that and that way we can just do

1303
01:09:45,538 --> 01:09:52,288
this in one load it looks like that's

1304
01:09:47,819 --> 01:09:54,829
the preferable way to do it and so I

1305
01:09:52,288 --> 01:09:56,939
guess that's how we're going to do it

1306
01:09:54,828 --> 01:09:59,009
because if that's what the compiler

1307
01:09:56,939 --> 01:10:00,629
wanted to do anyway and looking at that

1308
01:09:59,010 --> 01:10:11,699
there's no instruction for it so it

1309
01:10:00,630 --> 01:10:13,559
seems fine actually want a little more

1310
01:10:11,698 --> 01:10:17,038
spacing between those just so I could

1311
01:10:13,559 --> 01:10:20,038
see them a little loops for that very

1312
01:10:17,038 --> 01:10:25,018
reason okay

1313
01:10:20,038 --> 01:10:27,448
I could also line these up a little

1314
01:10:25,019 --> 01:10:29,690
better just you can see what the table

1315
01:10:27,448 --> 01:10:29,689
looks like

1316
01:10:42,810 --> 01:10:49,180
so what I want to do here is just again

1317
01:10:46,569 --> 01:10:51,789
have this be pre-loaded so that that way

1318
01:10:49,180 --> 01:10:53,980
there's no set API and that way getting

1319
01:10:51,789 --> 01:10:56,829
the shuffler is just a case of like

1320
01:10:53,979 --> 01:11:01,269
loading up whatever one of these you're

1321
01:10:56,829 --> 01:11:04,300
actually looking for and I don't know

1322
01:11:01,270 --> 01:11:07,600
how to tell this thing to align the base

1323
01:11:04,300 --> 01:11:16,000
of the table but I'm hoping that we'll

1324
01:11:07,600 --> 01:11:20,560
do it again see kind of just always just

1325
01:11:16,000 --> 01:11:23,380
well C++ it just kind of sucks so I want

1326
01:11:20,560 --> 01:11:24,730
the shuffle table here to just produce

1327
01:11:23,380 --> 01:11:26,739
one of those values for me and I

1328
01:11:24,729 --> 01:11:29,619
basically just want it to turn it into

1329
01:11:26,738 --> 01:11:31,988
something that I can use there and that

1330
01:11:29,619 --> 01:11:35,619
should do it so I think that's

1331
01:11:31,988 --> 01:11:37,299
everything for getting the min test done

1332
01:11:35,619 --> 01:11:40,090
and so like I said it's really nice and

1333
01:11:37,300 --> 01:11:45,640
simple it's one operation to get the H

1334
01:11:40,090 --> 01:11:48,039
comp value one operation to comp it one

1335
01:11:45,640 --> 01:11:52,090
operation to extract it and then one

1336
01:11:48,039 --> 01:11:54,909
operation to load it and so that's a

1337
01:11:52,090 --> 01:11:59,319
pretty efficient conversion from four

1338
01:11:54,909 --> 01:12:01,319
values to one there's probably an even

1339
01:11:59,319 --> 01:12:04,689
better way if I thought about it longer

1340
01:12:01,319 --> 01:12:06,279
but that's not terrible like I'm not

1341
01:12:04,689 --> 01:12:08,319
gonna lose sleep over that especially

1342
01:12:06,279 --> 01:12:09,819
since this only happens after you've

1343
01:12:08,319 --> 01:12:13,840
done all these leaf tests which should

1344
01:12:09,819 --> 01:12:20,259
in theory be way more expensive so

1345
01:12:13,840 --> 01:12:22,150
hopefully this will be so efficient as

1346
01:12:20,260 --> 01:12:26,130
to not be something we actually care

1347
01:12:22,149 --> 01:12:28,149
about because that already should be

1348
01:12:26,130 --> 01:12:31,060
more than enough to keep it under the

1349
01:12:28,149 --> 01:12:34,089
radar if this turns out to be a good

1350
01:12:31,060 --> 01:12:38,880
routine so off we go

1351
01:12:34,090 --> 01:12:41,230
and now in here where we've got the

1352
01:12:38,880 --> 01:12:44,560
actual processing that has to knock on

1353
01:12:41,229 --> 01:12:46,868
from that so I think that basically we

1354
01:12:44,560 --> 01:12:49,869
just do the same stuff we were doing

1355
01:12:46,868 --> 01:12:52,420
so the only difference is first we just

1356
01:12:49,868 --> 01:12:56,139
like make sure that the zero layer so

1357
01:12:52,420 --> 01:12:57,849
when we come through here right what

1358
01:12:56,139 --> 01:13:00,730
we're doing is we're saying alright put

1359
01:12:57,849 --> 01:13:03,639
into the zero level like so in lane zero

1360
01:13:00,729 --> 01:13:05,888
of our floats we want to put the value

1361
01:13:03,639 --> 01:13:07,659
that actually was the hit so the whole

1362
01:13:05,889 --> 01:13:09,310
point of this shuffler was just to get

1363
01:13:07,658 --> 01:13:11,529
us something that moves everything to

1364
01:13:09,310 --> 01:13:13,570
the zero lane so that we actually can

1365
01:13:11,529 --> 01:13:15,729
use that right and it doesn't actually

1366
01:13:13,569 --> 01:13:17,229
matter when we do that we can either do

1367
01:13:15,729 --> 01:13:20,169
it to the input or we can do it to the

1368
01:13:17,229 --> 01:13:21,759
output and the question of course is

1369
01:13:20,170 --> 01:13:24,489
when is the most efficient way to

1370
01:13:21,760 --> 01:13:41,110
actually do that right and I have no

1371
01:13:24,488 --> 01:13:47,859
idea actually yes I do also that's

1372
01:13:41,109 --> 01:13:51,848
that's a uhm I think we can do this even

1373
01:13:47,859 --> 01:13:55,509
better so actually if we just let it

1374
01:13:51,849 --> 01:14:01,840
compute all four so so riddle me this

1375
01:13:55,510 --> 01:14:07,210
Batman once we get here we know who

1376
01:14:01,840 --> 01:14:09,550
we're gonna extract right if we know who

1377
01:14:07,210 --> 01:14:13,029
we're going to extract we only have to

1378
01:14:09,550 --> 01:14:16,779
shuffle the actual people who we care

1379
01:14:13,029 --> 01:14:18,729
about extracting and the people that we

1380
01:14:16,779 --> 01:14:25,868
care about extracting are the emission

1381
01:14:18,729 --> 01:14:31,529
the ref color and the tier a right and

1382
01:14:25,868 --> 01:14:31,529
the hit normal so we could

1383
01:14:47,479 --> 01:15:04,439
we could in theory defer this down to

1384
01:14:53,699 --> 01:15:08,489
something else let's take a look

1385
01:15:04,439 --> 01:15:11,819
so in here if we have hitbox men and

1386
01:15:08,489 --> 01:15:13,619
hitbox max if we look for where those

1387
01:15:11,819 --> 01:15:15,869
are used you can see that they're only

1388
01:15:13,619 --> 01:15:18,599
used here to compute the radius in the

1389
01:15:15,869 --> 01:15:22,079
center so actually like we just don't

1390
01:15:18,600 --> 01:15:24,930
need to do any of this probably right

1391
01:15:22,079 --> 01:15:27,390
like you could probably just do that so

1392
01:15:24,930 --> 01:15:29,430
you do this computation exactly the way

1393
01:15:27,390 --> 01:15:32,880
that you were doing it before or

1394
01:15:29,430 --> 01:15:35,940
whatever right this doesn't need to be

1395
01:15:32,880 --> 01:15:37,140
cleared so we come through here I don't

1396
01:15:35,939 --> 01:15:39,239
even know if we're gonna need to do this

1397
01:15:37,140 --> 01:15:40,890
this may not actually happen I mean we

1398
01:15:39,239 --> 01:15:41,369
need this shuffle table eventually but I

1399
01:15:40,890 --> 01:15:42,690
don't know

1400
01:15:41,369 --> 01:15:43,859
so we have the shuffler if we need it

1401
01:15:42,689 --> 01:15:46,799
but let's just see if we actually need

1402
01:15:43,859 --> 01:15:48,569
it so all of this can just happen and

1403
01:15:46,800 --> 01:15:51,119
then the question is well we've got

1404
01:15:48,569 --> 01:15:53,609
scaled D and we want to pick which one

1405
01:15:51,119 --> 01:15:58,019
of those like we want a particular one

1406
01:15:53,609 --> 01:15:59,819
of those which is based on whatever the

1407
01:15:58,020 --> 01:16:05,370
shuffle index is and we could shuffle

1408
01:15:59,819 --> 01:16:07,109
scale D at that point mm-hmm but let's

1409
01:16:05,369 --> 01:16:10,649
just identify identify the places that

1410
01:16:07,109 --> 01:16:13,019
we need it so Rea origin plus R ad in v3

1411
01:16:10,649 --> 01:16:15,589
we only need the T ray to have been

1412
01:16:13,020 --> 01:16:18,210
shuffled at that point right and

1413
01:16:15,590 --> 01:16:20,640
furthermore we actually only really need

1414
01:16:18,210 --> 01:16:22,289
it to be extracted so we could do a

1415
01:16:20,640 --> 01:16:24,210
shuffle extract cuz I don't think you

1416
01:16:22,289 --> 01:16:29,180
can do there's no way for me to do an

1417
01:16:24,210 --> 01:16:31,560
extract on a on a on an actual like non

1418
01:16:29,180 --> 01:16:33,360
immediate right I thought we verified

1419
01:16:31,560 --> 01:16:37,320
that and I'm pretty sure that's true

1420
01:16:33,359 --> 01:16:39,509
right so there's no way to get when we

1421
01:16:37,319 --> 01:16:41,939
get an actual value out of here there's

1422
01:16:39,510 --> 01:16:43,829
no way to say here's the value I wanted

1423
01:16:41,939 --> 01:16:46,049
and it's in a register right that

1424
01:16:43,829 --> 01:16:48,760
doesn't happen so you would have to

1425
01:16:46,050 --> 01:16:52,809
distort it and pull it out

1426
01:16:48,760 --> 01:16:54,969
yourself somehow right and I don't know

1427
01:16:52,809 --> 01:16:56,800
which is faster whether it's to store it

1428
01:16:54,969 --> 01:17:01,210
and read it or whether it's to pull it

1429
01:16:56,800 --> 01:17:03,038
out using the using the shuffler you

1430
01:17:01,210 --> 01:17:05,559
know I'm saying but we'll use the

1431
01:17:03,038 --> 01:17:08,800
shuffler for now just to see so if we

1432
01:17:05,559 --> 01:17:12,250
want to pull out the tear a so this is

1433
01:17:08,800 --> 01:17:14,019
the tear a scaler if I want to pull out

1434
01:17:12,250 --> 01:17:20,319
the tear a scaler that's just gonna be

1435
01:17:14,019 --> 01:17:22,449
an mm extract epi you know PS we're just

1436
01:17:20,319 --> 01:17:24,988
going to use an MMS truck PS and we're

1437
01:17:22,448 --> 01:17:29,589
gonna extract the zero value and the mm

1438
01:17:24,988 --> 01:17:32,799
shuffle epi8 of tear a and the shuffler

1439
01:17:29,590 --> 01:17:35,920
right so this would get us whatever the

1440
01:17:32,800 --> 01:17:38,349
scaler is that's the tear a you know and

1441
01:17:35,920 --> 01:17:41,859
I'm saying so basically like this would

1442
01:17:38,349 --> 01:17:47,409
get us the scalar value of tear a so

1443
01:17:41,859 --> 01:17:50,018
tear a scaler oops not equal to F 32 max

1444
01:17:47,408 --> 01:17:52,210
in this case what you can see here is

1445
01:17:50,019 --> 01:17:54,550
the transfer PPS when you didn't hit all

1446
01:17:52,210 --> 01:17:57,849
of this stuff doesn't have to happen if

1447
01:17:54,550 --> 01:18:00,670
you can't use it right so really this

1448
01:17:57,849 --> 01:18:02,980
whole nonsense here can also move inside

1449
01:18:00,670 --> 01:18:04,840
because if you didn't hit something you

1450
01:18:02,979 --> 01:18:06,939
don't need to do that so since we

1451
01:18:04,840 --> 01:18:09,578
already know we have to do and if or we

1452
01:18:06,939 --> 01:18:11,379
think we do anyway to fill in a base

1453
01:18:09,578 --> 01:18:13,000
color here that means we could save a

1454
01:18:11,380 --> 01:18:14,980
ton of work in the cases where the Rays

1455
01:18:13,000 --> 01:18:16,300
don't hit and that's not something we

1456
01:18:14,979 --> 01:18:18,189
could have done before because we were

1457
01:18:16,300 --> 01:18:21,788
dealing with more than one ray that's

1458
01:18:18,189 --> 01:18:24,158
kind of compelling as well right it's a

1459
01:18:21,788 --> 01:18:25,300
bonus of this routine so you can see

1460
01:18:24,158 --> 01:18:26,828
that that's what we would do here

1461
01:18:25,300 --> 01:18:28,389
unfortunately just stacks up behind the

1462
01:18:26,828 --> 01:18:31,299
branch which is not the best possible

1463
01:18:28,389 --> 01:18:33,279
thing but you know oh well and then in

1464
01:18:31,300 --> 01:18:34,929
here we're gonna do a bunch of stuff

1465
01:18:33,279 --> 01:18:35,979
these can all just happen the way that

1466
01:18:34,929 --> 01:18:37,090
they were happening and so then the only

1467
01:18:35,979 --> 01:18:39,669
question is how does this stuff happen

1468
01:18:37,090 --> 01:18:41,739
if we look here we've already extracted

1469
01:18:39,670 --> 01:18:45,489
tier a scalar so this can happen just

1470
01:18:41,738 --> 01:18:47,259
fine right the probe sample N and

1471
01:18:45,488 --> 01:18:49,899
honestly this stuff we don't even really

1472
01:18:47,260 --> 01:18:51,969
need the extract because this stuff yeah

1473
01:18:49,899 --> 01:18:52,899
it's a long story we can talk about all

1474
01:18:51,969 --> 01:18:54,578
this when we actually look at the

1475
01:18:52,899 --> 01:18:56,259
routine we're getting ahead of ourselves

1476
01:18:54,578 --> 01:18:59,170
there's a micro optimization that could

1477
01:18:56,260 --> 01:19:01,750
be happening in here for sure right

1478
01:18:59,170 --> 01:19:03,250
okay so for sample ref color we now have

1479
01:19:01,750 --> 01:19:05,949
a problem which is that the sample ref

1480
01:19:03,250 --> 01:19:11,409
colors came from a pack a packed set

1481
01:19:05,949 --> 01:19:15,460
right but but if we actually look at how

1482
01:19:11,409 --> 01:19:19,869
these are loaded there's no reason they

1483
01:19:15,460 --> 01:19:23,140
had to be loaded that way right so what

1484
01:19:19,869 --> 01:19:26,739
we could have done is done RGB emission

1485
01:19:23,140 --> 01:19:32,730
RGB emission and actually loaded them

1486
01:19:26,739 --> 01:19:35,199
out without the Select I think right I

1487
01:19:32,729 --> 01:19:37,329
mean with the Select but selecting for a

1488
01:19:35,199 --> 01:19:39,539
different thing I'm not explaining this

1489
01:19:37,329 --> 01:19:39,539
well

1490
01:19:46,630 --> 01:19:51,039
yeah I don't know I'm gonna leave that

1491
01:19:49,090 --> 01:19:54,940
for now and we'll talk about that again

1492
01:19:51,039 --> 01:19:56,409
also later so this is fine this part is

1493
01:19:54,939 --> 01:19:57,909
the part that now we would have to deal

1494
01:19:56,409 --> 01:19:59,920
with which is how the hit normal gets

1495
01:19:57,909 --> 01:20:03,279
done here and so we can just say that

1496
01:19:59,920 --> 01:20:04,510
this is like probe sample n right and

1497
01:20:03,279 --> 01:20:06,699
get rid of this so we can see that a

1498
01:20:04,510 --> 01:20:08,800
little more curly this is something we

1499
01:20:06,699 --> 01:20:10,269
can just compute it's like that's just

1500
01:20:08,800 --> 01:20:12,550
something we know how to do right

1501
01:20:10,270 --> 01:20:14,560
because it's the origin is in scalar

1502
01:20:12,550 --> 01:20:16,329
radius scalar this is scalar everything

1503
01:20:14,560 --> 01:20:18,060
is in the scalar nothing is packed right

1504
01:20:16,329 --> 01:20:20,640
I should say single not scalar

1505
01:20:18,060 --> 01:20:24,720
everything's in single not packed there

1506
01:20:20,640 --> 01:20:28,450
so really what we're talking about is

1507
01:20:24,720 --> 01:20:31,140
these amiss emission if we want to get

1508
01:20:28,449 --> 01:20:35,139
the emission that's gonna be the same

1509
01:20:31,140 --> 01:20:39,070
routine here right so in getting the

1510
01:20:35,140 --> 01:20:43,390
emission is just gonna be doing that one

1511
01:20:39,069 --> 01:20:44,710
shuffle so that's pretty easy to get as

1512
01:20:43,390 --> 01:20:47,289
well because it's just a single value

1513
01:20:44,710 --> 01:20:50,020
and then all the rest of this stuff can

1514
01:20:47,289 --> 01:20:52,420
just do what it does right so I think

1515
01:20:50,020 --> 01:20:54,340
mostly what we're looking at is this

1516
01:20:52,420 --> 01:20:56,440
piece of code here is the piece of code

1517
01:20:54,340 --> 01:20:59,110
that we actually need to do like that we

1518
01:20:56,439 --> 01:21:09,819
actually need to make good what did I

1519
01:20:59,109 --> 01:21:11,679
screw up here oh great so I'm gonna go

1520
01:21:09,819 --> 01:21:16,420
ahead and assume there's no way to do a

1521
01:21:11,680 --> 01:21:19,600
shuffle epi8 that has the right stupid

1522
01:21:16,420 --> 01:21:26,770
casting I absolutely hate these

1523
01:21:19,600 --> 01:21:29,230
intrinsic s-- they're so terrible yeah

1524
01:21:26,770 --> 01:21:31,570
so basically like this is that we want

1525
01:21:29,229 --> 01:21:34,149
to call a pea chef B and we don't want

1526
01:21:31,569 --> 01:21:36,849
it to be yeah it's whatever I'm gonna

1527
01:21:34,149 --> 01:21:38,379
make a in our cindy code I'm gonna make

1528
01:21:36,850 --> 01:21:39,310
a routine for this because that's gonna

1529
01:21:38,380 --> 01:21:44,260
drive me nuts

1530
01:21:39,310 --> 01:21:45,940
so in here I'm gonna do one and it's

1531
01:21:44,260 --> 01:21:47,680
gonna be one that that can shuffle

1532
01:21:45,939 --> 01:21:51,460
either way right so it's like we're

1533
01:21:47,680 --> 01:21:53,740
gonna do one that's that's a I guess we

1534
01:21:51,460 --> 01:21:57,609
could use our I guess we don't have the

1535
01:21:53,739 --> 01:21:59,859
inversion but I'm just gonna call it

1536
01:21:57,609 --> 01:22:00,759
like this for now and we'll we'll figure

1537
01:21:59,859 --> 01:22:03,000
how we want to deal with this a little

1538
01:22:00,760 --> 01:22:09,070
bit later but I'm gonna call this like

1539
01:22:03,000 --> 01:22:14,640
pshh FB and it's gonna take an M 128 is

1540
01:22:09,069 --> 01:22:18,549
the shuffle and the M mm 128 that's the

1541
01:22:14,640 --> 01:22:20,820
value and it's gonna do the ridiculous

1542
01:22:18,550 --> 01:22:23,920
dance that you have to do to shuffle

1543
01:22:20,819 --> 01:22:26,170
it's so nuts where do you see this so

1544
01:22:23,920 --> 01:22:28,810
it's one assembly instruction it's just

1545
01:22:26,170 --> 01:22:31,090
pshh FB register register that's all you

1546
01:22:28,810 --> 01:22:32,320
would type in assembly and link C is

1547
01:22:31,090 --> 01:22:34,060
supposed to be like a higher-level

1548
01:22:32,319 --> 01:22:35,349
language and C++ must be like a

1549
01:22:34,060 --> 01:22:38,260
higher-level language right

1550
01:22:35,350 --> 01:22:40,780
what is higher-level about this

1551
01:22:38,260 --> 01:22:59,710
ridiculous crap that I'm about to have

1552
01:22:40,779 --> 01:23:07,809
to type right so in this case this is

1553
01:22:59,710 --> 01:23:11,829
the wrong way around like I just want

1554
01:23:07,810 --> 01:23:15,060
this but I had to type all of that right

1555
01:23:11,829 --> 01:23:23,850
that's not tear a that's value and

1556
01:23:15,060 --> 01:23:26,830
pattern okay mm-hmm so the higher-level

1557
01:23:23,850 --> 01:23:28,960
language of C++ that's doing such

1558
01:23:26,829 --> 01:23:31,149
helpful type checking here for me and

1559
01:23:28,960 --> 01:23:32,500
saving me all of these wonderful errors

1560
01:23:31,149 --> 01:23:34,329
I have no idea what they could possibly

1561
01:23:32,500 --> 01:23:35,680
be because all the errors you get when

1562
01:23:34,329 --> 01:23:37,090
you do this sort of thing are about Lane

1563
01:23:35,680 --> 01:23:38,770
swizzle patterns and things that you

1564
01:23:37,090 --> 01:23:40,300
don't understand it's never because you

1565
01:23:38,770 --> 01:23:41,950
accidentally treated a floating-point

1566
01:23:40,300 --> 01:23:44,770
value as a 32-bit value when you're

1567
01:23:41,949 --> 01:23:47,889
programming in sse that's absurd right

1568
01:23:44,770 --> 01:23:53,470
but here is the like time savings that I

1569
01:23:47,890 --> 01:23:54,820
got from C++ instead of typing this this

1570
01:23:53,470 --> 01:23:57,369
is what I would have typed in assembly

1571
01:23:54,819 --> 01:24:02,099
language this is what you had to

1572
01:23:57,369 --> 01:24:05,229
remember to type in C and C++ right it's

1573
01:24:02,100 --> 01:24:06,610
absolutely insane like they constantly

1574
01:24:05,229 --> 01:24:08,229
say that these things are high-level in

1575
01:24:06,609 --> 01:24:10,029
languages but they're not they actually

1576
01:24:08,229 --> 01:24:11,379
make work for you if you're actually

1577
01:24:10,029 --> 01:24:12,550
trying cuz like what they're supposed to

1578
01:24:11,380 --> 01:24:13,569
do what a high-level language is

1579
01:24:12,550 --> 01:24:16,150
supposed to do

1580
01:24:13,569 --> 01:24:17,679
is provide a more convenient way for you

1581
01:24:16,149 --> 01:24:19,509
to generate the assembly language you

1582
01:24:17,680 --> 01:24:21,820
were trying to generate right like it

1583
01:24:19,510 --> 01:24:23,170
shouldn't be easier to type the assembly

1584
01:24:21,819 --> 01:24:25,389
language than it is to type the

1585
01:24:23,170 --> 01:24:26,470
higher-level language because at the

1586
01:24:25,390 --> 01:24:27,460
very least the higher-level language

1587
01:24:26,470 --> 01:24:28,600
should have just let me type the

1588
01:24:27,460 --> 01:24:31,750
assembly language if that was the case

1589
01:24:28,600 --> 01:24:33,190
and of course I can't because MS PC

1590
01:24:31,750 --> 01:24:34,779
doesn't even support inline assembler so

1591
01:24:33,189 --> 01:24:37,059
I can't even do that if I'd wanted to

1592
01:24:34,779 --> 01:24:38,889
but the point is it should have been as

1593
01:24:37,060 --> 01:24:41,530
simple as just typing pfb parentheses

1594
01:24:38,890 --> 01:24:43,300
the two inputs right like that should

1595
01:24:41,529 --> 01:24:45,579
have been the hilar this was a save me

1596
01:24:43,300 --> 01:24:46,930
time it doesn't save your time these

1597
01:24:45,579 --> 01:24:48,880
higher-level languages they just they're

1598
01:24:46,930 --> 01:24:51,100
so bad that they just waste your time

1599
01:24:48,880 --> 01:24:55,270
instead of saving you time it's so nuts

1600
01:24:51,100 --> 01:24:56,350
it's it's just so stupid anyway so let

1601
01:24:55,270 --> 01:24:57,970
me actually get this working here so I

1602
01:24:56,350 --> 01:25:01,240
can actually type P chef be the way that

1603
01:24:57,970 --> 01:25:04,240
I want to this is coming about something

1604
01:25:01,239 --> 01:25:08,309
cannot give everyone from F 32x so yeah

1605
01:25:04,239 --> 01:25:14,109
in this case maybe I'll just do this

1606
01:25:08,310 --> 01:25:20,070
here and I'll return this here same way

1607
01:25:14,109 --> 01:25:25,920
right so we'll do f3 2 for X results and

1608
01:25:20,069 --> 01:25:25,920
this will be I think I do this right

1609
01:25:28,350 --> 01:25:37,420
that's a value dot P okay and so we can

1610
01:25:35,260 --> 01:25:40,360
down to our pfb and this will come back

1611
01:25:37,420 --> 01:25:43,079
I don't know if we have an extract like

1612
01:25:40,359 --> 01:25:45,279
extract zero extract one kind of thing

1613
01:25:43,079 --> 01:25:48,239
we should probably add one of those to

1614
01:25:45,279 --> 01:25:53,769
our little tool here so we can do em

1615
01:25:48,239 --> 01:25:55,119
right but I guess I don't really like

1616
01:25:53,770 --> 01:26:00,520
that so I'm gonna do this

1617
01:25:55,119 --> 01:26:02,529
I'm gonna have a thing for F 32 for X to

1618
01:26:00,520 --> 01:26:06,850
get the F credit F 32 out that's just

1619
01:26:02,529 --> 01:26:09,489
like extract zero right and you do the

1620
01:26:06,850 --> 01:26:15,660
value here and that will just do the MM

1621
01:26:09,489 --> 01:26:15,659
extract PS of value dot P

1622
01:26:17,469 --> 01:26:32,618
so that is how will extract stuff so

1623
01:26:23,988 --> 01:26:32,618
we'll do like a extract zero like so I

1624
01:26:32,679 --> 01:26:38,958
think that's all we really need what is

1625
01:26:35,868 --> 01:26:47,238
the complaint here extract PS version

1626
01:26:38,958 --> 01:26:48,679
from int to what warning the

1627
01:26:47,238 --> 01:27:02,589
initialisation conversions from int to

1628
01:26:48,679 --> 01:27:04,190
f/32 my doing something odd oh well

1629
01:27:02,590 --> 01:27:07,099
that's not good

1630
01:27:04,189 --> 01:27:12,339
but that's separate mmm extract PS

1631
01:27:07,099 --> 01:27:12,340
should extract am I thinking something

1632
01:27:17,639 --> 01:27:32,449
Oh weird it returns an integer even

1633
01:27:21,179 --> 01:27:32,449
though we are extracting a float okay

1634
01:27:34,579 --> 01:27:43,010
I'm gonna do it this way I feel like

1635
01:27:39,719 --> 01:27:46,079
that's probably fine to do it this way I

1636
01:27:43,010 --> 01:27:47,520
don't actually know it may be that you

1637
01:27:46,079 --> 01:27:49,590
want to do it this way just to tell the

1638
01:27:47,520 --> 01:27:55,440
compiler what's actually going on but I

1639
01:27:49,590 --> 01:27:59,670
think I'm gonna do the store I think I'm

1640
01:27:55,439 --> 01:28:09,000
gonna do this so so we're gonna do it

1641
01:27:59,670 --> 01:28:12,179
this way like so and that way we'll just

1642
01:28:09,000 --> 01:28:13,529
say look store this thing here and

1643
01:28:12,179 --> 01:28:15,810
hopefully the compiler is smart enough

1644
01:28:13,529 --> 01:28:20,908
to know what that is you know I'm saying

1645
01:28:15,810 --> 01:28:22,469
okay so at that point let's see so we

1646
01:28:20,908 --> 01:28:24,589
have this is this there's actually a

1647
01:28:22,469 --> 01:28:27,329
scalar array Direction here so there's a

1648
01:28:24,590 --> 01:28:33,230
radius Kahler I'm gonna call this radius

1649
01:28:27,329 --> 01:28:37,920
scalar or a radius single I guess and

1650
01:28:33,229 --> 01:28:40,618
then we'll call this tier a single

1651
01:28:37,920 --> 01:28:42,060
because I realize it's kind of just just

1652
01:28:40,618 --> 01:28:44,519
calling its thing scalar is wrong

1653
01:28:42,060 --> 01:28:47,639
because they're scalar everywhere it's

1654
01:28:44,520 --> 01:28:56,190
not what I really mean all right so

1655
01:28:47,639 --> 01:28:58,789
we've got our singles there and I think

1656
01:28:56,189 --> 01:28:58,789
that's everything

1657
01:28:59,479 --> 01:29:07,769
what's the Rey origin so the Rey origin

1658
01:29:05,819 --> 01:29:09,299
we also need the single version of so

1659
01:29:07,770 --> 01:29:11,460
I'm gonna go ahead and and have that

1660
01:29:09,300 --> 01:29:13,860
come in that way too as Rey origin

1661
01:29:11,460 --> 01:29:15,689
single and I'm gonna do the same

1662
01:29:13,859 --> 01:29:18,630
replication process we did on it before

1663
01:29:15,689 --> 01:29:26,928
so I'm gonna say you know ray origin

1664
01:29:18,630 --> 01:29:26,929
goes b3 for x-ray origin single

1665
01:29:27,600 --> 01:29:40,410
so yeah so I'm not sure what we want to

1666
01:29:38,279 --> 01:29:47,369
do now but basically this part here

1667
01:29:40,409 --> 01:29:49,319
where we generate the where we generate

1668
01:29:47,369 --> 01:29:53,840
like the normals and stuff like that is

1669
01:29:49,319 --> 01:29:58,969
mostly what we need now as far as

1670
01:29:53,840 --> 01:30:03,230
extraction is concerned again I'm not

1671
01:29:58,970 --> 01:30:10,140
exactly sure how we want to do this but

1672
01:30:03,229 --> 01:30:13,139
do this pea chef be here so there's

1673
01:30:10,140 --> 01:30:15,660
definitely some open questions there let

1674
01:30:13,140 --> 01:30:17,700
me see so we need to diffuse Atlas here

1675
01:30:15,659 --> 01:30:18,779
which we forgot to pass I deleted it

1676
01:30:17,699 --> 01:30:20,340
because thinking that we weren't gonna

1677
01:30:18,779 --> 01:30:24,689
use it but we are gonna use it because

1678
01:30:20,340 --> 01:30:29,699
we need that for sampling so let's drop

1679
01:30:24,689 --> 01:30:31,889
that bad boy in here all right so we're

1680
01:30:29,699 --> 01:30:35,130
real close to being done with how this

1681
01:30:31,890 --> 01:30:38,970
routine actually walks and if we look

1682
01:30:35,130 --> 01:30:44,400
through this part all we really have to

1683
01:30:38,970 --> 01:30:45,900
think about now is how we're actually

1684
01:30:44,399 --> 01:30:47,460
gonna I don't know we're done scaled

1685
01:30:45,899 --> 01:30:51,509
diga we got rid of unskilled D

1686
01:30:47,460 --> 01:30:55,350
accidentally it's it's just the it's the

1687
01:30:51,510 --> 01:31:00,470
probe sample P subtracting from the

1688
01:30:55,350 --> 01:31:02,610
center but yeah so if we look at this

1689
01:31:00,470 --> 01:31:05,460
the other thing I'm thinking is now

1690
01:31:02,609 --> 01:31:08,519
maybe I'm wrong maybe origin single and

1691
01:31:05,460 --> 01:31:10,949
tier a single maybe I'm sorry and and

1692
01:31:08,520 --> 01:31:17,250
this stuff maybe we don't actually care

1693
01:31:10,949 --> 01:31:18,569
about that at all and actually we can

1694
01:31:17,250 --> 01:31:21,149
just do this whole thing without

1695
01:31:18,569 --> 01:31:24,059
converting down because if we look where

1696
01:31:21,149 --> 01:31:26,429
this will actually use its in unscaled D

1697
01:31:24,060 --> 01:31:28,050
that's the only place we would use it

1698
01:31:26,430 --> 01:31:33,090
and so we don't actually need to shuffle

1699
01:31:28,050 --> 01:31:34,980
any of those I don't think so if we

1700
01:31:33,090 --> 01:31:38,400
wanted to we could do something here

1701
01:31:34,979 --> 01:31:48,119
where tier a just equals

1702
01:31:38,399 --> 01:31:50,489
pshhh FB tear a Schaeffler right so now

1703
01:31:48,119 --> 01:31:54,859
we know that T ray is correct the whole

1704
01:31:50,489 --> 01:31:54,859
way around and then if you did this

1705
01:32:01,970 --> 01:32:10,619
this probe sample P is now fine for all

1706
01:32:08,250 --> 01:32:18,270
of this well okay but you still have to

1707
01:32:10,619 --> 01:32:26,399
extract it here right so you do still

1708
01:32:18,270 --> 01:32:34,710
have to extract it either way so I'm not

1709
01:32:26,399 --> 01:32:38,059
sure how I feel about it to be extract

1710
01:32:34,710 --> 01:32:38,060
first retracts second

1711
01:32:52,039 --> 01:32:59,060
it's tough call folks it is a tough call

1712
01:33:07,109 --> 01:33:11,759
so there's a riff-off times the hannam

1713
01:33:10,238 --> 01:33:15,519
our product down here

1714
01:33:11,760 --> 01:33:17,650
let's here's what I want to do let's

1715
01:33:15,520 --> 01:33:21,430
work backwards from what's being

1716
01:33:17,649 --> 01:33:25,299
computed lighting wise here to get a

1717
01:33:21,430 --> 01:33:29,110
little bit of a better feeling for how

1718
01:33:25,300 --> 01:33:30,880
this is actually getting used because I

1719
01:33:29,109 --> 01:33:33,939
want this to be as efficient as possible

1720
01:33:30,880 --> 01:33:35,199
now that it's actually able to choose

1721
01:33:33,939 --> 01:33:37,750
because it's not as enough to do for

1722
01:33:35,199 --> 01:33:41,909
wide it's actually able to choose when

1723
01:33:37,750 --> 01:33:45,909
it steps down so let's suppose we missed

1724
01:33:41,909 --> 01:33:49,059
right if we missed then really all we

1725
01:33:45,909 --> 01:33:51,609
need is the emission direction to figure

1726
01:33:49,060 --> 01:33:54,310
out how much moonlight would shine onto

1727
01:33:51,609 --> 01:34:02,309
this like we need the cosine attenuation

1728
01:33:54,310 --> 01:34:02,310
on the moonlight but that's it right so

1729
01:34:14,619 --> 01:34:20,420
and furthermore if we don't actually

1730
01:34:18,859 --> 01:34:22,069
need to do that work because we know

1731
01:34:20,420 --> 01:34:27,819
what that value would be its

1732
01:34:22,069 --> 01:34:27,819
the attenuation on the moonlight from

1733
01:34:29,050 --> 01:34:36,500
well actually wait but this is also

1734
01:34:31,550 --> 01:34:38,420
wrong I mean I guess it's not wrong

1735
01:34:36,500 --> 01:34:40,010
because we are pretending there's a moon

1736
01:34:38,420 --> 01:34:42,500
that's shining down and we're just like

1737
01:34:40,010 --> 01:34:44,930
losing some of the light as we Bend away

1738
01:34:42,500 --> 01:34:46,850
from it so I guess that's fine no so it

1739
01:34:44,930 --> 01:34:49,610
is the emission direction times the moon

1740
01:34:46,850 --> 01:34:51,289
light I guess as it comes this way you'd

1741
01:34:49,609 --> 01:34:55,210
be hitting it less so this is just a

1742
01:34:51,289 --> 01:34:58,909
crappy way of saying do you hit the moon

1743
01:34:55,210 --> 01:35:02,539
or the atmosphere right so I suppose

1744
01:34:58,909 --> 01:35:05,869
that's all fine and yeah this could just

1745
01:35:02,539 --> 01:35:08,539
be pre computed as well so like this is

1746
01:35:05,869 --> 01:35:15,739
just true for like this whole equation

1747
01:35:08,539 --> 01:35:19,909
is just a known thing that you just

1748
01:35:15,739 --> 01:35:25,760
always know for a given R a direction so

1749
01:35:19,909 --> 01:35:27,349
you could even pull this up out of like

1750
01:35:25,760 --> 01:35:28,909
that scaler could just you could just be

1751
01:35:27,350 --> 01:35:31,010
pulled directly out so it doesn't even

1752
01:35:28,909 --> 01:35:32,930
need to be there I'm gonna actually

1753
01:35:31,010 --> 01:35:42,650
change the way this works a little bit

1754
01:35:32,930 --> 01:35:44,600
and say look let's just do let's just do

1755
01:35:42,649 --> 01:35:48,369
this as like an input value kind of a

1756
01:35:44,600 --> 01:35:52,310
thing and maybe what we say here is

1757
01:35:48,369 --> 01:35:54,949
maybe we say something like that this

1758
01:35:52,310 --> 01:36:01,490
updates the transfer PPS value or

1759
01:35:54,949 --> 01:36:04,579
something so like you know maybe it

1760
01:36:01,489 --> 01:36:07,670
looks a little bit more like this so the

1761
01:36:04,579 --> 01:36:11,500
moon color and Moon derp are not in here

1762
01:36:07,670 --> 01:36:14,480
and this value that the transfer PPS

1763
01:36:11,500 --> 01:36:15,649
value that we initialized to I think

1764
01:36:14,479 --> 01:36:18,199
what we want to do is say that that

1765
01:36:15,649 --> 01:36:20,750
comes from externally right because that

1766
01:36:18,199 --> 01:36:22,729
makes a lot more sense and so in here

1767
01:36:20,750 --> 01:36:23,430
maybe what we do is we do something like

1768
01:36:22,729 --> 01:36:26,969
this

1769
01:36:23,430 --> 01:36:30,930
and we say all right so we've got a

1770
01:36:26,970 --> 01:36:32,640
transfer PPS of four and actually these

1771
01:36:30,930 --> 01:36:36,200
are just going to be things that are

1772
01:36:32,640 --> 01:36:40,470
like return values of the thing right

1773
01:36:36,199 --> 01:36:43,019
I'm sorry our output parameters of the

1774
01:36:40,470 --> 01:36:47,850
thing and we will initialize them to

1775
01:36:43,020 --> 01:36:50,580
what we want in the case of of you

1776
01:36:47,850 --> 01:36:53,340
didn't hit something we're gonna say

1777
01:36:50,579 --> 01:36:56,130
what you should get if you didn't hit

1778
01:36:53,340 --> 01:37:01,800
something which might be nothing or it

1779
01:36:56,130 --> 01:37:05,609
might be the moon right and then I'm

1780
01:37:01,800 --> 01:37:07,320
going to say okay moon contribs goes in

1781
01:37:05,609 --> 01:37:11,099
here for now or something like that

1782
01:37:07,319 --> 01:37:14,759
right and then we overwrite it the grid

1783
01:37:11,100 --> 01:37:16,590
raycast does if it wants to so basically

1784
01:37:14,760 --> 01:37:17,850
it's more like a conditional move that

1785
01:37:16,590 --> 01:37:20,699
just like overrides things that's

1786
01:37:17,850 --> 01:37:23,310
necessary so it's like here's the you

1787
01:37:20,699 --> 01:37:26,189
know transfer PPS the value that's gonna

1788
01:37:23,310 --> 01:37:28,110
right so when it comes through here it's

1789
01:37:26,189 --> 01:37:31,079
gonna say look I'm a write that value

1790
01:37:28,109 --> 01:37:33,179
and that's where we actually do anything

1791
01:37:31,079 --> 01:37:35,519
otherwise we just don't touch it right

1792
01:37:33,180 --> 01:37:39,780
and we're not gonna we're not going to

1793
01:37:35,520 --> 01:37:41,850
return anything at all okay so that

1794
01:37:39,779 --> 01:37:44,519
seems sane so that means like this is

1795
01:37:41,850 --> 01:37:46,740
what we're looking at here so what we

1796
01:37:44,520 --> 01:37:48,750
have to figure out is what are we

1797
01:37:46,739 --> 01:37:51,300
actually doing in terms of omission and

1798
01:37:48,750 --> 01:37:53,369
all this sort of stuff right so when we

1799
01:37:51,300 --> 01:37:55,380
compute the voxel irradiance at a

1800
01:37:53,369 --> 01:37:59,279
particular location and that's like

1801
01:37:55,380 --> 01:38:01,350
where we actually hit the question is do

1802
01:37:59,279 --> 01:38:01,920
we actually want to do this is very

1803
01:38:01,350 --> 01:38:05,610
expensive

1804
01:38:01,920 --> 01:38:08,789
oops and since we only have to do it for

1805
01:38:05,609 --> 01:38:11,219
one like we're only doing one ray at a

1806
01:38:08,789 --> 01:38:13,409
time across multiple stuff here

1807
01:38:11,220 --> 01:38:15,720
presumably what we would want to do is

1808
01:38:13,409 --> 01:38:17,250
actually just test to see whether this

1809
01:38:15,720 --> 01:38:19,470
thing is emissive or not and if it's

1810
01:38:17,250 --> 01:38:21,300
emissive because it its emissive it

1811
01:38:19,470 --> 01:38:22,949
presumably doesn't also reflect light

1812
01:38:21,300 --> 01:38:24,420
but maybe the answer is it does maybe

1813
01:38:22,949 --> 01:38:26,670
it's reflective Animus is like we want

1814
01:38:24,420 --> 01:38:27,960
to have both so I don't know but let's

1815
01:38:26,670 --> 01:38:33,149
say that was the case so let's say

1816
01:38:27,960 --> 01:38:35,909
emission is in here and you can see like

1817
01:38:33,149 --> 01:38:38,069
as the emission gets higher the

1818
01:38:35,909 --> 01:38:40,260
probe gets lower which doesn't make any

1819
01:38:38,069 --> 01:38:42,239
sense because emission should just be

1820
01:38:40,260 --> 01:38:47,060
added right like I don't know that we

1821
01:38:42,239 --> 01:38:47,059
actually want that either

1822
01:38:59,880 --> 01:39:05,819
I guess the problem that we have is the

1823
01:39:02,939 --> 01:39:07,979
way that we do the system if lights

1824
01:39:05,819 --> 01:39:10,019
reflected light back from the things

1825
01:39:07,979 --> 01:39:13,289
when they hit the problem is we're gonna

1826
01:39:10,020 --> 01:39:18,389
have that the lights will feed back on

1827
01:39:13,289 --> 01:39:20,100
themselves right because you it doesn't

1828
01:39:18,389 --> 01:39:22,199
know that the lighting from the probe

1829
01:39:20,100 --> 01:39:24,120
directly under the light source was

1830
01:39:22,198 --> 01:39:26,428
actually just getting all of its light

1831
01:39:24,119 --> 01:39:29,399
from the light source so I guess what we

1832
01:39:26,429 --> 01:39:31,170
need to do here is actually we probably

1833
01:39:29,399 --> 01:39:43,948
just want these things to either be

1834
01:39:31,170 --> 01:39:45,810
emissive or not like I don't I don't

1835
01:39:43,948 --> 01:39:47,819
feel like the way we're doing our

1836
01:39:45,810 --> 01:39:49,679
lighting would allow us to do a surface

1837
01:39:47,819 --> 01:39:53,488
that was partially emissive and

1838
01:39:49,679 --> 01:39:55,800
partially reflect reflective I could

1839
01:39:53,488 --> 01:39:59,629
just be not thinking about it correctly

1840
01:39:55,800 --> 01:39:59,630
but that seems to be true

1841
01:40:16,899 --> 01:40:21,710
so I guess what you could do though is

1842
01:40:19,639 --> 01:40:25,489
instead of adding the emissions together

1843
01:40:21,710 --> 01:40:28,210
you could just min the emissions or max

1844
01:40:25,488 --> 01:40:28,209
the emissions rather

1845
01:40:37,560 --> 01:40:45,900
so I guess that's what you would do you

1846
01:40:40,810 --> 01:40:50,680
would allow lights to reflect light but

1847
01:40:45,899 --> 01:40:54,339
you would also at the same time you

1848
01:40:50,680 --> 01:40:56,650
would make sure that in addition to the

1849
01:40:54,340 --> 01:40:58,930
emission value and the reflected value

1850
01:40:56,649 --> 01:41:00,939
rather than adding them together you

1851
01:40:58,930 --> 01:41:02,829
just take whichever one is maximum of

1852
01:41:00,939 --> 01:41:04,569
each Channel and that would allow you to

1853
01:41:02,829 --> 01:41:06,760
put light into the system and also

1854
01:41:04,569 --> 01:41:08,859
reflect light at the same time without

1855
01:41:06,760 --> 01:41:10,570
feeding back on yourself because at most

1856
01:41:08,859 --> 01:41:19,359
you'll always ever contribute up to your

1857
01:41:10,569 --> 01:41:20,949
maximum that seems right so I think what

1858
01:41:19,359 --> 01:41:23,139
we would want here is if this thing is

1859
01:41:20,949 --> 01:41:25,210
saying look here's the emission level of

1860
01:41:23,140 --> 01:41:27,280
this thing then what you want to do is

1861
01:41:25,210 --> 01:41:29,020
say what's the actual emission that you

1862
01:41:27,279 --> 01:41:31,960
would then what's the actual emission

1863
01:41:29,020 --> 01:41:34,980
that you're actually building right so

1864
01:41:31,960 --> 01:41:41,470
you're building emission times your

1865
01:41:34,979 --> 01:41:43,629
sample ref color right and then that's

1866
01:41:41,470 --> 01:41:49,170
the channel that you have right so you

1867
01:41:43,630 --> 01:41:54,690
have your emission color is your

1868
01:41:49,170 --> 01:42:06,550
emission times your ref color right and

1869
01:41:54,689 --> 01:42:11,109
then your sample right is this is your

1870
01:42:06,550 --> 01:42:15,640
reflect color so you're reflecting this

1871
01:42:11,109 --> 01:42:18,519
and you're emitting this and then you

1872
01:42:15,640 --> 01:42:21,910
just want those two things to be like

1873
01:42:18,520 --> 01:42:26,760
min you know you want to take the

1874
01:42:21,909 --> 01:42:26,760
maximum of each one of those right

1875
01:42:31,329 --> 01:42:34,329
yeah

1876
01:42:38,319 --> 01:42:43,299
so I think that's good and this here

1877
01:42:41,319 --> 01:42:48,269
where we have the clamp that ref

1878
01:42:43,300 --> 01:42:53,680
fall-off is still there so this value is

1879
01:42:48,270 --> 01:43:04,300
just you know it's really just reflect

1880
01:42:53,680 --> 01:43:08,320
color x equals reflect fall-off right so

1881
01:43:04,300 --> 01:43:11,920
you you build up your emission color

1882
01:43:08,319 --> 01:43:14,500
this way your reflection color this way

1883
01:43:11,920 --> 01:43:17,859
you figure out the fall-off is and you

1884
01:43:14,500 --> 01:43:33,060
modulate by the fall-off now you take

1885
01:43:17,859 --> 01:43:33,059
the actual transfer PPS and this

1886
01:43:49,039 --> 01:43:54,989
so there we go okay so the emission is

1887
01:43:52,350 --> 01:43:57,030
off the ref color the reflect fall off

1888
01:43:54,989 --> 01:43:59,539
comes on here too we probably could do

1889
01:43:57,029 --> 01:44:02,219
something where this actually gets

1890
01:43:59,539 --> 01:44:03,960
handled a little bit cleaner but let's

1891
01:44:02,220 --> 01:44:07,199
suppose it looks like that for now and

1892
01:44:03,960 --> 01:44:17,730
then the transfer PPS is just going to

1893
01:44:07,199 --> 01:44:33,569
be like an r g b max right so this is

1894
01:44:17,729 --> 01:44:38,719
going to be like something like this so

1895
01:44:33,569 --> 01:44:38,719
i think that's what we want right I

1896
01:44:40,640 --> 01:44:44,390
think that's what we want

1897
01:44:47,699 --> 01:44:54,059
that all seems good to me so that'll

1898
01:44:50,890 --> 01:44:56,350
write to the transfer PPS RG and B and

1899
01:44:54,060 --> 01:44:57,670
it'll write out whatever the maximum is

1900
01:44:56,350 --> 01:45:00,280
we want to make sure this is actually

1901
01:44:57,670 --> 01:45:03,460
going to use a max PS instruction and

1902
01:45:00,279 --> 01:45:09,729
not if so we're gonna have to do like

1903
01:45:03,460 --> 01:45:11,350
you know as we you know as we go through

1904
01:45:09,729 --> 01:45:12,429
here roll as we clean up the assembly

1905
01:45:11,350 --> 01:45:14,320
that the compiler generates we're gonna

1906
01:45:12,430 --> 01:45:15,360
have to make sure we like to give it the

1907
01:45:14,319 --> 01:45:18,789
right

1908
01:45:15,359 --> 01:45:21,369
foof to do that but everything else

1909
01:45:18,789 --> 01:45:23,829
seems fine the ref color extraction now

1910
01:45:21,369 --> 01:45:25,689
so this part here is a part we actually

1911
01:45:23,829 --> 01:45:28,319
care about if we look at sample ref

1912
01:45:25,689 --> 01:45:31,029
color up sorry get component rather

1913
01:45:28,319 --> 01:45:32,710
that's not particularly compelling so we

1914
01:45:31,029 --> 01:45:33,789
probably don't want to do it that way we

1915
01:45:32,710 --> 01:45:35,739
probably want to do it the way we were

1916
01:45:33,789 --> 01:45:47,199
doing it before so we'd basically do

1917
01:45:35,738 --> 01:45:49,479
like this and this is probably not the

1918
01:45:47,199 --> 01:45:59,380
best way to do it we'll have to think

1919
01:45:49,479 --> 01:46:05,339
about that but I think for now that's

1920
01:45:59,380 --> 01:46:05,340
what we've got to work with right

1921
01:46:05,889 --> 01:46:12,050
okay so these are all still not done yet

1922
01:46:08,719 --> 01:46:16,118
we get down here the ref this is the

1923
01:46:12,050 --> 01:46:16,119
wrong thing it's just called ref color

1924
01:46:19,059 --> 01:46:26,929
or I get I guess this is the hit hit

1925
01:46:21,679 --> 01:46:31,328
this is the hit color the surface color

1926
01:46:26,929 --> 01:46:31,328
I don't know what we call that really

1927
01:46:34,988 --> 01:46:40,488
and so then we just really need to focus

1928
01:46:38,988 --> 01:46:42,738
on how we're gonna get like the normal

1929
01:46:40,488 --> 01:46:46,009
out of this thing which is again pretty

1930
01:46:42,738 --> 01:46:54,169
tough I don't know what max is talking

1931
01:46:46,010 --> 01:46:55,639
about here so those are VIII's so maybe

1932
01:46:54,170 --> 01:46:58,130
maximum is what we need there but we

1933
01:46:55,639 --> 01:47:00,288
really just want so if you look at max

1934
01:46:58,130 --> 01:47:05,109
here I guess that's actually the routine

1935
01:47:00,288 --> 01:47:05,109
we want right

1936
01:47:05,319 --> 01:47:14,109
the v3 for X I mean f3 32 for X there's

1937
01:47:10,460 --> 01:47:18,980
a max on that right somewhere in here I

1938
01:47:14,109 --> 01:47:21,948
assume yeah so this is the routine we

1939
01:47:18,979 --> 01:47:23,509
actually want we want to do the max PSS

1940
01:47:21,948 --> 01:47:24,558
on these things but I guess we can't do

1941
01:47:23,510 --> 01:47:26,059
that right now because you don't really

1942
01:47:24,559 --> 01:47:31,429
have a way of actually telling it look

1943
01:47:26,059 --> 01:47:33,590
please do that for us again we could

1944
01:47:31,429 --> 01:47:37,609
just keep all of these this an f32 X the

1945
01:47:33,590 --> 01:47:38,538
entire way through and then you just

1946
01:47:37,609 --> 01:47:43,549
don't do the extract

1947
01:47:38,538 --> 01:47:47,748
I suppose that's fine let's just try

1948
01:47:43,550 --> 01:47:51,679
that so if we did hit color here so we

1949
01:47:47,748 --> 01:47:58,788
did v3 for X then what we would do is we

1950
01:47:51,679 --> 01:48:01,569
would just say okay just store the P

1951
01:47:58,788 --> 01:48:01,569
chef of this thing

1952
01:48:02,770 --> 01:48:09,850
right and we could also make a pea chef

1953
01:48:07,989 --> 01:48:11,590
be that DP chefs this whole thing but

1954
01:48:09,850 --> 01:48:14,079
that's fine the way we're doing it here

1955
01:48:11,590 --> 01:48:19,110
so we'd pea chef B to make sure the RGB

1956
01:48:14,079 --> 01:48:22,149
now in zero is the one we actually want

1957
01:48:19,109 --> 01:48:23,460
although as I'm saying that now I think

1958
01:48:22,149 --> 01:48:26,829
about it you don't even have to do that

1959
01:48:23,460 --> 01:48:28,480
why did I do that I don't know why I did

1960
01:48:26,829 --> 01:48:29,710
that we literally don't care about that

1961
01:48:28,479 --> 01:48:32,379
that's just dumb

1962
01:48:29,710 --> 01:48:35,409
so hit ref color is actually just all

1963
01:48:32,380 --> 01:48:37,180
you need to do so you just do okay the

1964
01:48:35,409 --> 01:48:40,720
emission color is the hit ref color

1965
01:48:37,180 --> 01:48:41,950
times the emission the reflection color

1966
01:48:40,720 --> 01:48:43,930
comes back here

1967
01:48:41,949 --> 01:48:47,460
and you would just load up that up out

1968
01:48:43,930 --> 01:48:52,510
into four X is the emission you'd leave

1969
01:48:47,460 --> 01:48:54,939
right so that's just hit emission

1970
01:48:52,510 --> 01:48:57,220
actually and then when you come through

1971
01:48:54,939 --> 01:48:59,379
here and you want to build the emission

1972
01:48:57,220 --> 01:49:06,190
color it's just the hit emission times

1973
01:48:59,380 --> 01:49:10,449
the hit ref color right so you don't

1974
01:49:06,189 --> 01:49:12,789
actually have to extract you come down

1975
01:49:10,449 --> 01:49:14,590
here and we need to do the reflect part

1976
01:49:12,789 --> 01:49:18,159
but then when you get to here you just

1977
01:49:14,590 --> 01:49:21,010
say look when we're going to return the

1978
01:49:18,159 --> 01:49:25,599
transfer PBS the transfer of PBS is just

1979
01:49:21,010 --> 01:49:27,880
one color value what we want to do is

1980
01:49:25,600 --> 01:49:31,210
take the maximum value and then extract

1981
01:49:27,880 --> 01:49:36,159
just the bottom so this would just be

1982
01:49:31,210 --> 01:49:38,369
like you know emission color reflect

1983
01:49:36,159 --> 01:49:38,369
color

1984
01:49:42,859 --> 01:49:47,429
so there's the transfer color and then

1985
01:49:45,239 --> 01:49:52,529
we would just do the pea chef beyond

1986
01:49:47,430 --> 01:49:54,539
transfer color right so you you wouldn't

1987
01:49:52,529 --> 01:49:56,909
bother ever extract anything because you

1988
01:49:54,539 --> 01:49:58,560
don't get anything from that so you just

1989
01:49:56,909 --> 01:50:03,779
do it at the latest possible time that

1990
01:49:58,560 --> 01:50:05,910
you that you could that seems to be the

1991
01:50:03,779 --> 01:50:14,219
same thing so this would be an extract

1992
01:50:05,909 --> 01:50:30,389
zero all the way down on the pea chef be

1993
01:50:14,220 --> 01:50:32,310
of transfer color right so that way I

1994
01:50:30,390 --> 01:50:34,020
think this just does everything you

1995
01:50:32,310 --> 01:50:39,380
needed to do and the only problem you

1996
01:50:34,020 --> 01:50:56,210
have is that reflect color at that point

1997
01:50:39,380 --> 01:51:01,730
is not wide so if you made it wide and

1998
01:50:56,210 --> 01:51:01,730
we then say okay the reflect color

1999
01:51:04,399 --> 01:51:10,589
although it looks like so you're gonna

2000
01:51:06,989 --> 01:51:13,380
have to do this in single because probe

2001
01:51:10,590 --> 01:51:15,119
sample and already had to be extracted

2002
01:51:13,380 --> 01:51:17,760
so you don't really care about that so

2003
01:51:15,119 --> 01:51:20,010
once you get reflect fall-off reflect

2004
01:51:17,760 --> 01:51:23,970
color how to mark you might as well just

2005
01:51:20,010 --> 01:51:28,400
wait and do it here right so you might

2006
01:51:23,970 --> 01:51:28,400
as well just do like this

2007
01:51:33,130 --> 01:51:46,770
and I think that's what we need okay so

2008
01:51:36,609 --> 01:51:48,880
what else this is just with shuffler and

2009
01:51:46,770 --> 01:51:53,739
then I think we're back to what I said

2010
01:51:48,880 --> 01:51:57,099
before so hit color in this case okay so

2011
01:51:53,738 --> 01:52:03,009
the Hadamard product here has to be done

2012
01:51:57,099 --> 01:52:06,969
after right because the hit color is

2013
01:52:03,010 --> 01:52:10,329
never extracted so we would want that to

2014
01:52:06,969 --> 01:52:15,639
be had a Martin in there now the hit ref

2015
01:52:10,328 --> 01:52:17,109
color so we could we could actually do

2016
01:52:15,639 --> 01:52:19,000
that at the end though so we don't

2017
01:52:17,109 --> 01:52:20,859
because the hit ref color gets

2018
01:52:19,000 --> 01:52:23,908
multiplied in either case whether it's

2019
01:52:20,859 --> 01:52:23,908
emission or otherwise

2020
01:52:30,158 --> 01:52:35,728
I think you could just save that

2021
01:52:32,439 --> 01:52:35,729
Hadamard product to the end

2022
01:52:40,859 --> 01:52:45,329
right so if you take hit Rhett color and

2023
01:52:44,069 --> 01:52:47,489
look at where you know the two places

2024
01:52:45,329 --> 01:52:51,840
would be used is here in here you know I

2025
01:52:47,489 --> 01:52:57,389
mean if you did that at the end so you

2026
01:52:51,840 --> 01:53:05,310
actually said that you don't do this you

2027
01:52:57,390 --> 01:53:07,140
do it here then what you'd be doing is

2028
01:53:05,310 --> 01:53:15,330
you'd actually be just taking the

2029
01:53:07,140 --> 01:53:18,570
emission so you could just so if I'm

2030
01:53:15,329 --> 01:53:23,399
right about this so you could do all of

2031
01:53:18,569 --> 01:53:25,139
this I think and just do the Hat of our

2032
01:53:23,399 --> 01:53:30,960
product at the end so it'd just be the

2033
01:53:25,140 --> 01:53:36,480
multiplies like you could just do it by

2034
01:53:30,960 --> 01:53:38,869
only actually extracting just the

2035
01:53:36,479 --> 01:53:38,869
emission

2036
01:53:43,179 --> 01:53:55,270
I think that's right I'm not entirely

2037
01:53:52,479 --> 01:53:58,629
sure let's take a look

2038
01:53:55,270 --> 01:54:00,850
so in emission color here we do hit

2039
01:53:58,630 --> 01:54:02,650
emission times hit ref color so what I

2040
01:54:00,850 --> 01:54:04,870
would need to do is say look the

2041
01:54:02,649 --> 01:54:11,589
emission value is actually just going to

2042
01:54:04,869 --> 01:54:15,988
be a value that we do a max width to to

2043
01:54:11,590 --> 01:54:20,909
max against the reflect color right and

2044
01:54:15,988 --> 01:54:20,908
it feels like you could just do this

2045
01:54:21,179 --> 01:54:29,469
like if we loaded this in a packed value

2046
01:54:23,800 --> 01:54:31,449
we could do this directly right so let's

2047
01:54:29,469 --> 01:54:35,980
suppose that you imagined that the

2048
01:54:31,448 --> 01:54:38,460
reflect color was actually came back as

2049
01:54:35,979 --> 01:54:38,459
like

2050
01:54:51,948 --> 01:54:56,098
suppose we did something where the

2051
01:54:53,788 --> 01:54:59,868
reflect color we actually packed up so

2052
01:54:56,099 --> 01:55:03,019
we did at f/32 Forex of this thing and

2053
01:54:59,868 --> 01:55:05,639
we packed up foo

2054
01:55:03,019 --> 01:55:11,039
so we imagined we grabbed that as a

2055
01:55:05,639 --> 01:55:19,769
reflect color right then we imagine we

2056
01:55:11,038 --> 01:55:23,639
take the emission color or reflect level

2057
01:55:19,769 --> 01:55:26,519
and emission level we generate this just

2058
01:55:23,639 --> 01:55:32,998
from the extract zero of the emission so

2059
01:55:26,519 --> 01:55:35,670
we extract zero the emission and we

2060
01:55:32,998 --> 01:55:40,228
replicate it now actually we don't

2061
01:55:35,670 --> 01:55:43,889
extract it we just pfb it right because

2062
01:55:40,229 --> 01:55:46,079
if we P Chef be the hit emission with

2063
01:55:43,889 --> 01:55:49,949
shuffler it's now got emission in all

2064
01:55:46,078 --> 01:55:52,319
four so this is the RGB bla the RGB

2065
01:55:49,948 --> 01:56:03,388
blank and this is the emission emission

2066
01:55:52,319 --> 01:56:11,399
emission we can then do one max on those

2067
01:56:03,389 --> 01:56:13,618
right yeah yep yep yep so let's say we

2068
01:56:11,399 --> 01:56:16,198
need to reflect fall-off here and we do

2069
01:56:13,618 --> 01:56:22,799
reflect color foo x equals reflect fall

2070
01:56:16,198 --> 01:56:27,379
off like so then we do the load up then

2071
01:56:22,800 --> 01:56:27,380
we do the max here

2072
01:56:30,109 --> 01:56:37,519
and then we just know how much we're

2073
01:56:33,380 --> 01:56:39,560
transmitting with our hit ref color so

2074
01:56:37,520 --> 01:56:42,980
then we say our a that's the

2075
01:56:39,560 --> 01:56:46,070
transmission level for RGB now we just

2076
01:56:42,979 --> 01:56:48,439
extract zero one two and go although I

2077
01:56:46,069 --> 01:56:49,969
don't know if we should try to do

2078
01:56:48,439 --> 01:57:09,679
something different there with a hit ref

2079
01:56:49,970 --> 01:57:11,750
color maybe we just do that it's in the

2080
01:57:09,680 --> 01:57:18,079
wrong lanes is the problem there right

2081
01:57:11,750 --> 01:57:19,880
so yeah you can't really you can do the

2082
01:57:18,079 --> 01:57:21,109
max efficiently but you can't really do

2083
01:57:19,880 --> 01:57:23,659
you can't cheat and do what I'm doing

2084
01:57:21,109 --> 01:57:26,179
here you'd have to do like a replicate

2085
01:57:23,659 --> 01:57:29,059
out right so that that does not actually

2086
01:57:26,180 --> 01:57:30,320
help you so we don't care about that we

2087
01:57:29,060 --> 01:57:31,940
don't care about this we don't care

2088
01:57:30,319 --> 01:57:33,679
about that this is our actual

2089
01:57:31,939 --> 01:57:40,609
transmission level here and so then you

2090
01:57:33,680 --> 01:57:47,440
just do like extract zero of this one -

2091
01:57:40,609 --> 01:57:47,439
I think that's it

2092
01:57:53,880 --> 01:57:58,329
all right so you have one extraction

2093
01:57:56,680 --> 01:58:02,350
that you have to do for each color

2094
01:57:58,329 --> 01:58:03,819
channel the RG and the B and then you

2095
01:58:02,350 --> 01:58:08,500
have to figure out how to get the normal

2096
01:58:03,819 --> 01:58:12,569
and the position out and so I think that

2097
01:58:08,500 --> 01:58:12,569
means this does look like this right

2098
01:58:16,680 --> 01:58:22,539
probably although I don't know because

2099
01:58:19,779 --> 01:58:24,250
this also has to happen that way so I'm

2100
01:58:22,539 --> 01:58:27,670
not sure it may be that you extract that

2101
01:58:24,250 --> 01:58:29,319
out I don't know so that's that's kind

2102
01:58:27,670 --> 01:58:31,239
of an open question those are kind of an

2103
01:58:29,319 --> 01:58:33,969
open question but I think this stuff is

2104
01:58:31,239 --> 01:58:38,219
now correct so if I go to extract zero

2105
01:58:33,970 --> 01:58:38,220
and I just make a couple of these

2106
01:58:50,220 --> 01:58:56,789
I'm not sure how to actually ask this

2107
01:58:52,560 --> 01:58:59,070
thing to store later values because like

2108
01:58:56,789 --> 01:59:02,069
I said it for whatever reason doesn't

2109
01:58:59,069 --> 01:59:12,329
seem to want to store anything other

2110
01:59:02,069 --> 01:59:17,250
than oh wait this is not this is not

2111
01:59:12,329 --> 01:59:20,460
what we want so store one's actually a

2112
01:59:17,250 --> 01:59:21,239
replicating store which is not at all

2113
01:59:20,460 --> 01:59:26,369
what I want

2114
01:59:21,239 --> 01:59:30,479
I just want to convert I just want to

2115
01:59:26,369 --> 01:59:35,250
take a float out of this thing

2116
01:59:30,479 --> 01:59:39,209
here it is this is what I actually want

2117
01:59:35,250 --> 01:59:48,689
I won't convert s sf32 that's what I

2118
01:59:39,210 --> 01:59:51,840
actually want now like I said I'm not

2119
01:59:48,689 --> 01:59:54,449
sure about this one because I don't know

2120
01:59:51,840 --> 01:59:56,789
how to get anything else out of this

2121
01:59:54,449 --> 01:59:59,449
thing and it may be that there is no

2122
01:59:56,789 --> 02:00:02,390
real efficient way to actually do that

2123
01:59:59,449 --> 02:00:04,529
we could look but I doubt it right

2124
02:00:02,390 --> 02:00:07,500
because that's like looks like the only

2125
02:00:04,529 --> 02:00:11,099
one that you get right so I could

2126
02:00:07,500 --> 02:00:13,409
extract an int so because there was the

2127
02:00:11,100 --> 02:00:17,940
extract with an immediate that was out

2128
02:00:13,409 --> 02:00:23,510
here so we could extract an integer from

2129
02:00:17,939 --> 02:00:26,039
it and convert that back to a float

2130
02:00:23,510 --> 02:00:28,170
because you can see that it's it's it's

2131
02:00:26,039 --> 02:00:29,699
not doing conversion so it's actually

2132
02:00:28,170 --> 02:00:32,149
just giving you the float back it just

2133
02:00:29,699 --> 02:00:37,639
doesn't return an f32 for some reason

2134
02:00:32,149 --> 02:00:37,639
and i have no idea what the reason is

2135
02:00:39,739 --> 02:00:45,420
until you want to tell me what the

2136
02:00:41,699 --> 02:00:48,119
reason is do you have an explanation for

2137
02:00:45,420 --> 02:00:51,270
that I don't know what their explanation

2138
02:00:48,119 --> 02:00:54,359
is for that but so this so doing a

2139
02:00:51,270 --> 02:00:57,780
convert SS convert as 32 to pull

2140
02:00:54,359 --> 02:01:00,449
something out of there I'm not sure

2141
02:00:57,779 --> 02:01:02,319
exactly how we would do that for the

2142
02:01:00,449 --> 02:01:04,659
other values

2143
02:01:02,319 --> 02:01:05,799
fish as efficiently as possible it might

2144
02:01:04,659 --> 02:01:08,619
be that what you want to do is the

2145
02:01:05,800 --> 02:01:30,489
extract if we did that it would look

2146
02:01:08,619 --> 02:01:33,460
like this and then we would do this so

2147
02:01:30,489 --> 02:01:36,939
we're just like forcing it to do what we

2148
02:01:33,460 --> 02:01:49,149
want I don't actually know if that'll

2149
02:01:36,939 --> 02:01:52,419
work but but we'll see so I would say

2150
02:01:49,149 --> 02:01:54,309
the reasonable progress this is a pretty

2151
02:01:52,420 --> 02:01:57,190
tricky thing to get right because we've

2152
02:01:54,310 --> 02:01:58,900
got sort of scalar and non-scalar mixed

2153
02:01:57,189 --> 02:02:01,029
together it's always that point like it

2154
02:01:58,899 --> 02:02:02,769
when you up shift to packed and then

2155
02:02:01,029 --> 02:02:04,059
down shift to scaler it's those are

2156
02:02:02,770 --> 02:02:07,450
always the hardest parts of your

2157
02:02:04,060 --> 02:02:09,610
routines so I think all we really need

2158
02:02:07,449 --> 02:02:11,859
to do now is to finish that part off I

2159
02:02:09,609 --> 02:02:13,479
can if zero this out for now and do a QA

2160
02:02:11,859 --> 02:02:16,539
and next weekend we'll focus on

2161
02:02:13,479 --> 02:02:18,909
finishing that part testing and then

2162
02:02:16,539 --> 02:02:20,500
we'll move on oh and this can this is no

2163
02:02:18,909 --> 02:02:23,909
longer relevant because I actually did

2164
02:02:20,500 --> 02:02:27,100
make sure the max happens there again

2165
02:02:23,909 --> 02:02:31,300
it's starting to look very clean now and

2166
02:02:27,100 --> 02:02:34,720
I I don't know like but except for this

2167
02:02:31,300 --> 02:02:36,579
which is very expensive obviously I feel

2168
02:02:34,720 --> 02:02:39,220
like we're able to trim a lot of the fat

2169
02:02:36,579 --> 02:02:42,819
out of here and the downshift is still a

2170
02:02:39,220 --> 02:02:45,909
little janky but at least it's like it's

2171
02:02:42,819 --> 02:02:48,989
not as wearable as it could be these

2172
02:02:45,909 --> 02:02:48,989
don't need to be here

2173
02:02:57,720 --> 02:03:26,530
and this is just kind of placeholder for

2174
02:03:01,569 --> 02:03:28,059
now but it's these um yeah nope okay so

2175
02:03:26,529 --> 02:03:29,439
in terms of what we need to pass the

2176
02:03:28,060 --> 02:03:31,360
rate grid grid cast I think that's the

2177
02:03:29,439 --> 02:03:40,719
end to just tie this off it's work its

2178
02:03:31,359 --> 02:03:45,399
diffuse Atlas rare urge and single what

2179
02:03:40,720 --> 02:03:49,180
is the REA origin code here is that a

2180
02:03:45,399 --> 02:03:50,529
thing that we know it's not so we would

2181
02:03:49,180 --> 02:03:54,820
have to do it get component on that as

2182
02:03:50,529 --> 02:03:56,349
well boy I hope this works out if this

2183
02:03:54,819 --> 02:03:58,269
actually turns out to be a good way to

2184
02:03:56,350 --> 02:03:59,890
raycast it's gonna be so nice because so

2185
02:03:58,270 --> 02:04:01,300
much code will go away we can just

2186
02:03:59,890 --> 02:04:03,220
delete like the most of all this stuff

2187
02:04:01,300 --> 02:04:05,079
that we've been using to try and figure

2188
02:04:03,220 --> 02:04:07,510
out what would be the efficient way to

2189
02:04:05,079 --> 02:04:09,760
do it and when we actually hit upon one

2190
02:04:07,510 --> 02:04:13,780
it's gonna feel pretty nice to clean

2191
02:04:09,760 --> 02:04:18,340
everything up this doesn't return a

2192
02:04:13,779 --> 02:04:20,699
value anymore all right let's do brief

2193
02:04:18,340 --> 02:04:20,699
Q&amp;A

2194
02:04:34,100 --> 02:04:38,639
John said you had opinions on signed and

2195
02:04:36,359 --> 02:04:41,539
unsigned he said you said maybe it's the

2196
02:04:38,639 --> 02:04:43,050
wrong complication to have yeah I mean I

2197
02:04:41,539 --> 02:04:45,600
mmm

2198
02:04:43,050 --> 02:04:49,409
my problem with almost all high level

2199
02:04:45,600 --> 02:04:52,469
languages is that rather than making

2200
02:04:49,408 --> 02:04:59,069
decisions that always save you time they

2201
02:04:52,469 --> 02:05:01,139
tend to make decisions that only save

2202
02:04:59,069 --> 02:05:04,049
you time if you happen to program

2203
02:05:01,139 --> 02:05:05,819
exactly this one way and any other way

2204
02:05:04,050 --> 02:05:08,400
you might try to program it just falls

2205
02:05:05,819 --> 02:05:10,109
apart which you know is the nature of

2206
02:05:08,399 --> 02:05:11,759
compressing things down for sure but it

2207
02:05:10,109 --> 02:05:15,779
seems like it's unnecessary in a lot of

2208
02:05:11,760 --> 02:05:22,980
cases so the example in this case would

2209
02:05:15,779 --> 02:05:25,380
be that signed and unsigned arithmetic

2210
02:05:22,979 --> 02:05:28,138
is exactly the same in most places if

2211
02:05:25,380 --> 02:05:29,850
you add two numbers together your CPU

2212
02:05:28,139 --> 02:05:32,270
just adds them together it doesn't care

2213
02:05:29,850 --> 02:05:36,420
whether they're signed or unsigned so

2214
02:05:32,270 --> 02:05:41,610
calling things signed or unsigned it's

2215
02:05:36,420 --> 02:05:45,560
not a type what it is is a default so I

2216
02:05:41,609 --> 02:05:49,349
would prefer if what you said was hmm

2217
02:05:45,560 --> 02:05:51,840
32-bit integer and I'm not going to tell

2218
02:05:49,350 --> 02:05:53,940
you whether it's signed or unsigned that

2219
02:05:51,840 --> 02:05:55,350
all that would do is generate code where

2220
02:05:53,939 --> 02:05:58,019
any time you did something that actually

2221
02:05:55,350 --> 02:06:02,340
did need to know it said please specify

2222
02:05:58,020 --> 02:06:04,980
which operation you want right so if you

2223
02:06:02,340 --> 02:06:07,800
then did something like a shift you

2224
02:06:04,979 --> 02:06:10,468
could say do you want an arithmetic or a

2225
02:06:07,800 --> 02:06:12,659
logical shift normally what happens is

2226
02:06:10,469 --> 02:06:14,550
it uses the signed type to tell it which

2227
02:06:12,658 --> 02:06:16,769
one to do I don't want that most of the

2228
02:06:14,550 --> 02:06:20,489
time I want to tell you which shift to

2229
02:06:16,770 --> 02:06:24,780
do because just cuz the value is signed

2230
02:06:20,488 --> 02:06:27,959
or unsigned that doesn't not that's like

2231
02:06:24,779 --> 02:06:29,789
suggesting that that there's not values

2232
02:06:27,960 --> 02:06:31,380
that take on both characteristics and

2233
02:06:29,789 --> 02:06:35,399
that's wrong when you're actually

2234
02:06:31,380 --> 02:06:37,020
programming their dere fungible I might

2235
02:06:35,399 --> 02:06:38,488
do something in a way that it appears

2236
02:06:37,020 --> 02:06:40,380
like the values signed for three

2237
02:06:38,488 --> 02:06:43,019
instructions and then change to unsigned

2238
02:06:40,380 --> 02:06:45,989
sorry certain things later so it's just

2239
02:06:43,020 --> 02:06:48,090
signed it on sign is not right it's not

2240
02:06:45,989 --> 02:06:50,010
a property of a piece of data signed and

2241
02:06:48,090 --> 02:06:51,960
unsigned is a property of an operation

2242
02:06:50,010 --> 02:06:53,610
and so I think the abstraction that's

2243
02:06:51,960 --> 02:06:56,670
made in all high-level languages is

2244
02:06:53,609 --> 02:06:58,909
wrong i I don't think they did it

2245
02:06:56,670 --> 02:06:58,909
properly

2246
02:07:07,639 --> 02:07:20,719
are you familiar with home assistant no

2247
02:07:09,800 --> 02:07:22,630
I am NOT are there alternatives to

2248
02:07:20,719 --> 02:07:26,149
inline assembly other than intrinsics

2249
02:07:22,630 --> 02:07:28,760
just external assembly right you write

2250
02:07:26,149 --> 02:07:30,349
these you write you a function like we

2251
02:07:28,760 --> 02:07:32,449
could write this grid raycast function

2252
02:07:30,350 --> 02:07:36,350
in assembly language and then link it in

2253
02:07:32,448 --> 02:07:38,178
and that is what you do if you fail like

2254
02:07:36,350 --> 02:07:39,710
what you normally do is you try to get

2255
02:07:38,179 --> 02:07:42,618
the compiler to do something not stupid

2256
02:07:39,710 --> 02:07:45,408
with your code when you're optimizing a

2257
02:07:42,618 --> 02:07:46,789
routine and if you fail like if you just

2258
02:07:45,408 --> 02:07:48,618
can't get the compiler to emit what you

2259
02:07:46,789 --> 02:07:50,719
want then you just write it an assembly

2260
02:07:48,618 --> 02:07:52,759
and link it in that's what you do most

2261
02:07:50,719 --> 02:07:54,770
of the time you can like you know sort

2262
02:07:52,760 --> 02:07:56,119
of fuss with the phrasing and get the

2263
02:07:54,770 --> 02:08:02,810
compiler to eventually do it but if you

2264
02:07:56,118 --> 02:08:03,889
can't then you do it assembly episode 3

2265
02:08:02,810 --> 02:08:04,969
introduced you mentioned that OpenGL is

2266
02:08:03,889 --> 02:08:05,989
much closer to a good graph see if you

2267
02:08:04,969 --> 02:08:06,948
had that something like Vulcan I was

2268
02:08:05,988 --> 02:08:09,289
wondering if other developers you know

2269
02:08:06,948 --> 02:08:10,579
agree with you on this and if so then

2270
02:08:09,289 --> 02:08:12,289
why would something like Vulcan get

2271
02:08:10,579 --> 02:08:13,460
support who exactly makes the design

2272
02:08:12,289 --> 02:08:16,189
adoption decisions for these

2273
02:08:13,460 --> 02:08:17,329
technologies do developer 70 say so

2274
02:08:16,189 --> 02:08:19,428
first of all I guess what I would say is

2275
02:08:17,329 --> 02:08:24,948
Vulcan doesn't have much support like

2276
02:08:19,429 --> 02:08:26,449
it's just not very popular right so I

2277
02:08:24,948 --> 02:08:29,329
wouldn't say people are supporting

2278
02:08:26,448 --> 02:08:30,469
Vulcan but in terms of people who do

2279
02:08:29,329 --> 02:08:32,380
support Vulcan the reason is because

2280
02:08:30,469 --> 02:08:35,750
what else are they gonna use right

2281
02:08:32,380 --> 02:08:38,960
opengl 4.5 isn't well supported at all

2282
02:08:35,750 --> 02:08:42,380
right so it's more about a decision of

2283
02:08:38,960 --> 02:08:44,539
what the ihds choose to give us and they

2284
02:08:42,380 --> 02:08:47,810
chose to give us Vulcan it's a pile of

2285
02:08:44,539 --> 02:08:50,029
crap and it's unfortunate but that's

2286
02:08:47,810 --> 02:08:52,550
what you get so when you program on

2287
02:08:50,029 --> 02:08:55,399
Windows you get two choices dx12 or

2288
02:08:52,550 --> 02:08:57,079
Vulcan personally I had picked dx12 if

2289
02:08:55,399 --> 02:09:05,269
you want to pick Vulcan go right ahead

2290
02:08:57,079 --> 02:09:07,729
right who gets the designer adoption is

2291
02:09:05,270 --> 02:09:13,389
mostly the IH fees it's mostly what the

2292
02:09:07,729 --> 02:09:13,388
yhv is choose right

2293
02:09:15,809 --> 02:09:24,690
so basically like IH V's have - IH V's

2294
02:09:21,788 --> 02:09:28,059
are basically who determines everything

2295
02:09:24,689 --> 02:09:31,779
more or less and platform holders can

2296
02:09:28,059 --> 02:09:33,880
force their hands sometimes so Apple for

2297
02:09:31,779 --> 02:09:36,158
example can just demand that metal is

2298
02:09:33,880 --> 02:09:38,859
the thing now and then the IH fees have

2299
02:09:36,158 --> 02:09:42,189
to live with it but short of that IH v

2300
02:09:38,859 --> 02:09:44,738
is determine what we get and they have a

2301
02:09:42,189 --> 02:09:46,598
fantastically poor track record at

2302
02:09:44,738 --> 02:09:53,819
producing api's that are a good stable

2303
02:09:46,599 --> 02:09:56,819
and long-term there is very bad at that

2304
02:09:53,819 --> 02:09:56,819
so

2305
02:10:03,699 --> 02:10:08,929
why is this loop for the CPU to do

2306
02:10:06,260 --> 02:10:10,310
horizontal assembly operations so the

2307
02:10:08,930 --> 02:10:13,369
reason is because of the way that

2308
02:10:10,310 --> 02:10:17,960
arithmetic logic units are designed for

2309
02:10:13,369 --> 02:10:21,619
high speeds and I guess what I would say

2310
02:10:17,960 --> 02:10:26,630
is it's not slow slow is the wrong term

2311
02:10:21,619 --> 02:10:27,649
to use it's latent horizontal operations

2312
02:10:26,630 --> 02:10:30,140
aren't slow

2313
02:10:27,649 --> 02:10:32,000
they're just latent meaning you don't

2314
02:10:30,140 --> 02:10:34,219
get the results back for a while they

2315
02:10:32,000 --> 02:10:37,340
might be very fast meaning you can do

2316
02:10:34,219 --> 02:10:40,880
lots of them because you can start many

2317
02:10:37,340 --> 02:10:51,140
of them so it's usually very good idea

2318
02:10:40,880 --> 02:10:57,109
to be specific so slow you know what

2319
02:10:51,140 --> 02:11:02,619
does this mean well there's two things

2320
02:10:57,109 --> 02:11:11,829
you could mean by slow slow could mean

2321
02:11:02,619 --> 02:11:19,210
takes a long time to take input and

2322
02:11:11,829 --> 02:11:19,210
produce corresponding output

2323
02:11:22,390 --> 02:11:35,060
and I prefer not to use that term

2324
02:11:26,869 --> 02:11:41,949
because it could also mean does few opps

2325
02:11:35,060 --> 02:11:44,780
per second like per unit time right and

2326
02:11:41,949 --> 02:11:46,250
slow could be either of these and the

2327
02:11:44,779 --> 02:11:48,769
reason that I don't like using the term

2328
02:11:46,250 --> 02:11:50,899
slow or if I do use the term slow I

2329
02:11:48,770 --> 02:11:53,870
usually mean this slow is because this

2330
02:11:50,899 --> 02:11:57,879
slow I can usually program around so I

2331
02:11:53,869 --> 02:12:01,250
prefer to say high latency in this case

2332
02:11:57,880 --> 02:12:03,800
potentially because it's not necessarily

2333
02:12:01,250 --> 02:12:06,050
slow because you may be able if you have

2334
02:12:03,800 --> 02:12:07,340
many independent ones to do you might be

2335
02:12:06,050 --> 02:12:09,890
able to run them at exactly the same

2336
02:12:07,340 --> 02:12:11,659
speed as something else right and so I

2337
02:12:09,890 --> 02:12:16,280
would say that that's what horizontal

2338
02:12:11,659 --> 02:12:21,380
ops are so horizontal equals high

2339
02:12:16,279 --> 02:12:23,779
latency it does not mean slow in a can't

2340
02:12:21,380 --> 02:12:26,480
do many of these per second you can they

2341
02:12:23,779 --> 02:12:28,099
just take awhile to get the results out

2342
02:12:26,479 --> 02:12:33,319
for any individual um but you can

2343
02:12:28,100 --> 02:12:34,550
overlap many of them right so why are

2344
02:12:33,319 --> 02:12:36,549
they high latency well they're high

2345
02:12:34,550 --> 02:12:39,789
latency because this is the way in an

2346
02:12:36,550 --> 02:12:42,619
arithmetic logic unit normally works an

2347
02:12:39,789 --> 02:12:47,979
arithmetic logic unit normally looks

2348
02:12:42,619 --> 02:12:55,369
like this the input comes in in four

2349
02:12:47,979 --> 02:13:05,899
wide lanes right the circuit for doing

2350
02:12:55,369 --> 02:13:07,819
the operation takes a clock right so it

2351
02:13:05,899 --> 02:13:11,420
comes in here and I've got wiring for

2352
02:13:07,819 --> 02:13:14,210
each of these operations and the clock

2353
02:13:11,420 --> 02:13:16,130
does an operation on eat you know in one

2354
02:13:14,210 --> 02:13:18,109
cycle I'm gonna do an operation on each

2355
02:13:16,130 --> 02:13:20,000
of the lanes and those lanes are gonna

2356
02:13:18,109 --> 02:13:25,250
feed forward into the next operation

2357
02:13:20,000 --> 02:13:31,640
right so if I have something like a

2358
02:13:25,250 --> 02:13:33,199
comparison that I need to do right then

2359
02:13:31,640 --> 02:13:34,590
what's going to happen is when this

2360
02:13:33,199 --> 02:13:36,000
input comes in

2361
02:13:34,590 --> 02:13:37,650
the first thing that's going to happen

2362
02:13:36,000 --> 02:13:41,850
is the inputs gonna have to merge

2363
02:13:37,649 --> 02:13:43,920
crosswise so the OP that I actually have

2364
02:13:41,850 --> 02:13:48,030
is going to have to take input from two

2365
02:13:43,920 --> 02:13:49,140
sources right and so income my lanes the

2366
02:13:48,029 --> 02:13:51,719
first thing is going to be like a

2367
02:13:49,140 --> 02:13:59,630
feed-forward thing that produces you

2368
02:13:51,720 --> 02:13:59,630
know an OP like this or something

2369
02:14:03,670 --> 02:14:09,050
so like I do something and I forward

2370
02:14:06,319 --> 02:14:11,449
that result to some other lane right and

2371
02:14:09,050 --> 02:14:21,100
then I do something and I forward that

2372
02:14:11,449 --> 02:14:21,099
result to some other lane again right

2373
02:14:21,789 --> 02:14:27,529
and so what ends up happening is if the

2374
02:14:25,670 --> 02:14:30,289
if you're thinking about it coming in in

2375
02:14:27,529 --> 02:14:32,779
this fashion then if you want something

2376
02:14:30,289 --> 02:14:36,590
that can be answered across all four

2377
02:14:32,779 --> 02:14:39,529
lanes you have to pay the price of the

2378
02:14:36,590 --> 02:14:41,449
furthest cascade so if I need a result

2379
02:14:39,529 --> 02:14:43,880
from three to propagate all the way to

2380
02:14:41,449 --> 02:14:45,500
result from one which is what I need if

2381
02:14:43,880 --> 02:14:48,079
I'm gonna compare all four lanes

2382
02:14:45,500 --> 02:14:51,109
well how many hops does it take right

2383
02:14:48,079 --> 02:14:58,329
here's one cycle here's one cycle here's

2384
02:14:51,109 --> 02:15:01,189
one cycle here's one cycle it is one two

2385
02:14:58,329 --> 02:15:06,079
three and then the fourth operation

2386
02:15:01,189 --> 02:15:07,460
gives me my answer right I mean I should

2387
02:15:06,079 --> 02:15:08,899
write this a little bit differently it

2388
02:15:07,460 --> 02:15:10,939
should be like the cycle is here right

2389
02:15:08,899 --> 02:15:18,559
the cycle is what moves the thing to the

2390
02:15:10,939 --> 02:15:20,149
next phase right so and you could also

2391
02:15:18,560 --> 02:15:21,860
count it as like the input step as a

2392
02:15:20,149 --> 02:15:22,939
cycle I mean I don't I'm not a hardware

2393
02:15:21,859 --> 02:15:24,739
designer so I don't know what the right

2394
02:15:22,939 --> 02:15:26,629
way to write this diagram is but point

2395
02:15:24,739 --> 02:15:28,250
being something comes in on three it has

2396
02:15:26,630 --> 02:15:29,720
to move to two something's on two it has

2397
02:15:28,250 --> 02:15:31,100
to move to one sometimes on one ask to

2398
02:15:29,720 --> 02:15:34,940
move to zero and then it moves to the

2399
02:15:31,100 --> 02:15:37,070
output that's you know for Cascades and

2400
02:15:34,939 --> 02:15:40,879
so when you look up horizontal

2401
02:15:37,069 --> 02:15:43,819
operations usually the cycle counts

2402
02:15:40,880 --> 02:15:46,430
match that cascade pattern really well

2403
02:15:43,819 --> 02:15:48,619
so like for example if I come up on here

2404
02:15:46,430 --> 02:15:51,289
and I say well what's the actual answer

2405
02:15:48,619 --> 02:15:58,420
gonna be for doing something like the

2406
02:15:51,289 --> 02:16:01,640
menu PS mm-hmm sorry I'm in Posie PU 16

2407
02:15:58,420 --> 02:16:05,359
it's like hey it's latency for exactly

2408
02:16:01,640 --> 02:16:09,560
what you would expect right what happens

2409
02:16:05,359 --> 02:16:12,500
if I do the horizontal ad for dot

2410
02:16:09,560 --> 02:16:14,660
products with the H ad right so if you

2411
02:16:12,500 --> 02:16:16,319
do the horizontal ad you can see that

2412
02:16:14,659 --> 02:16:18,389
what these do is they do

2413
02:16:16,319 --> 02:16:20,488
horizontal ads if they only do one step

2414
02:16:18,389 --> 02:16:23,520
of the ad and you can see the latency is

2415
02:16:20,488 --> 02:16:25,919
basically like a little less because it

2416
02:16:23,520 --> 02:16:28,079
doesn't actually have to do all four

2417
02:16:25,920 --> 02:16:30,328
it's not a propagation it just has to

2418
02:16:28,078 --> 02:16:34,228
propagate once and then ad once and then

2419
02:16:30,328 --> 02:16:35,670
out right so again you get down to

2420
02:16:34,228 --> 02:16:36,989
latency three because it doesn't

2421
02:16:35,670 --> 02:16:40,879
actually do the whole ad if you do two

2422
02:16:36,989 --> 02:16:40,879
of them to ad the whole way

2423
02:16:50,540 --> 02:16:54,580
yeah and you can see like basically all

2424
02:16:52,638 --> 02:16:57,228
of these kind of line up that way so

2425
02:16:54,579 --> 02:16:59,959
again take that diagram with a grain of

2426
02:16:57,228 --> 02:17:02,299
salt I'm not a chip engineer so like

2427
02:16:59,959 --> 02:17:04,818
that's probably not a very good

2428
02:17:02,299 --> 02:17:08,959
explanation of what actually happens but

2429
02:17:04,818 --> 02:17:11,179
it's sort of it's vaguely right so the

2430
02:17:08,959 --> 02:17:13,398
point of Cindy is that you have this

2431
02:17:11,179 --> 02:17:15,318
circuitry that doesn't have crosstalk

2432
02:17:13,398 --> 02:17:17,449
and that's why it's fast it knows it can

2433
02:17:15,318 --> 02:17:19,760
just do multiplies in lanes and they're

2434
02:17:17,450 --> 02:17:21,740
all just stamped copies of scalar

2435
02:17:19,760 --> 02:17:23,689
multipliers as soon as you start

2436
02:17:21,739 --> 02:17:25,429
crosstalking with the lanes that whole

2437
02:17:23,689 --> 02:17:26,929
structure breaks down and you need to

2438
02:17:25,429 --> 02:17:29,808
have like a bucket brigade that like

2439
02:17:26,929 --> 02:17:32,568
moves crap around the chip to get it all

2440
02:17:29,808 --> 02:17:34,869
the way over and that's what costs does

2441
02:17:32,568 --> 02:17:34,869
that make sense

2442
02:17:44,439 --> 02:17:47,219
hmm

2443
02:17:51,569 --> 02:17:56,110
wouldn't use Vulcan for cross-platform

2444
02:17:53,620 --> 02:17:57,370
no it's terrible for cross-platform like

2445
02:17:56,110 --> 02:18:00,040
why would you use Vulcan for

2446
02:17:57,370 --> 02:18:01,660
cross-platform you know that it's not an

2447
02:18:00,040 --> 02:18:06,880
API you can actually use to write to

2448
02:18:01,659 --> 02:18:08,500
graphics cards on Mac and what else do

2449
02:18:06,879 --> 02:18:12,629
you have for your platforms you don't

2450
02:18:08,500 --> 02:18:16,239
have Vulcan on like you know the Xbox

2451
02:18:12,629 --> 02:18:18,129
it's it's not a thing right I mean maybe

2452
02:18:16,239 --> 02:18:19,959
they do support Vulcan for X the new

2453
02:18:18,129 --> 02:18:21,849
Xbox I don't know scarlet or something I

2454
02:18:19,959 --> 02:18:24,579
have no idea but it's not cross-platform

2455
02:18:21,850 --> 02:18:26,110
like like Apple requires that metal is

2456
02:18:24,579 --> 02:18:27,399
the driver layer so if you're running

2457
02:18:26,110 --> 02:18:30,010
Vulcan on that it's going through a

2458
02:18:27,399 --> 02:18:31,869
translation that's the opposite of what

2459
02:18:30,010 --> 02:18:34,360
you were trying to do when you wrote to

2460
02:18:31,870 --> 02:18:37,750
Vulcan right fokin supposed to be a bare

2461
02:18:34,360 --> 02:18:40,179
metal API anything and on Windows it's

2462
02:18:37,750 --> 02:18:42,399
like well r8 so if I'm gonna be writing

2463
02:18:40,179 --> 02:18:46,090
metal on Mac I might as well write dx12

2464
02:18:42,399 --> 02:18:50,739
on Windows I ain't gonna write Vulcan

2465
02:18:46,090 --> 02:18:54,309
unlike the PS 5 and Xbox whatever they

2466
02:18:50,739 --> 02:18:56,229
call scarlet xbox 1 X s 12 or whatever

2467
02:18:54,309 --> 02:18:57,090
the next one is it just doesn't really

2468
02:18:56,229 --> 02:18:59,859
make sense

2469
02:18:57,090 --> 02:19:01,750
it's a Vulcan it's like an API that just

2470
02:18:59,860 --> 02:19:04,120
has no point in existing I don't even

2471
02:19:01,750 --> 02:19:06,929
understand why they bothered maybe for

2472
02:19:04,120 --> 02:19:06,929
Linux I don't know

2473
02:19:29,189 --> 02:19:48,729
alright looks like the end of the

2474
02:19:30,879 --> 02:19:49,779
questions alright do-do-do-do-do alright

2475
02:19:48,728 --> 02:19:50,798
thank you everyone for joining me for

2476
02:19:49,779 --> 02:19:52,510
this to the hand-made here that's my

2477
02:19:50,799 --> 02:19:54,369
pleasure coding with you as always if

2478
02:19:52,510 --> 02:19:55,510
you would like to follow on the series

2479
02:19:54,369 --> 02:19:57,189
at home you can always peer to the game

2480
02:19:55,510 --> 02:19:59,289
on hand menhir org and it comes to the

2481
02:19:57,189 --> 02:20:01,539
source code maybe you can go finish the

2482
02:19:59,289 --> 02:20:03,998
grid base lighting this week while you

2483
02:20:01,539 --> 02:20:05,260
wait and that'd be good practice because

2484
02:20:03,998 --> 02:20:06,158
I've sketched out all the routines so

2485
02:20:05,260 --> 02:20:09,189
the question is just getting them

2486
02:20:06,158 --> 02:20:12,639
working right so you could give that a

2487
02:20:09,189 --> 02:20:14,109
shot until then we are doing this is the

2488
02:20:12,639 --> 02:20:15,760
last week of our Kickstarter if you want

2489
02:20:14,109 --> 02:20:17,318
on now the infinite comic your very own

2490
02:20:15,760 --> 02:20:20,228
you can always just click on this banner

2491
02:20:17,318 --> 02:20:21,939
that'll take you right there and we hit

2492
02:20:20,228 --> 02:20:23,349
basically all of our stretch goals I

2493
02:20:21,939 --> 02:20:24,818
guess I don't know there's one more for

2494
02:20:23,350 --> 02:20:26,439
coloring book that but it looks like

2495
02:20:24,818 --> 02:20:28,028
it'll hit that one too so you get a

2496
02:20:26,439 --> 02:20:29,408
whole bunch of cool stuff with it

2497
02:20:28,029 --> 02:20:33,189
definitely check it out if you're into

2498
02:20:29,408 --> 02:20:35,738
comics or space or cats that's it for

2499
02:20:33,189 --> 02:20:39,760
this weekend I don't know if I'll scream

2500
02:20:35,738 --> 02:20:41,588
some more slipways I feel like I don't

2501
02:20:39,760 --> 02:20:43,869
want to put the pressure on John to like

2502
02:20:41,588 --> 02:20:47,978
learn to get good at slipways because

2503
02:20:43,869 --> 02:20:50,229
you know I watched his stream last night

2504
02:20:47,978 --> 02:20:52,238
playing slipways and as like looked a

2505
02:20:50,228 --> 02:20:53,738
lot like naysay looked like a lot like

2506
02:20:52,238 --> 02:20:55,118
kingdoms and castles or it was just a

2507
02:20:53,738 --> 02:20:58,059
really depressing Kingdom that no one

2508
02:20:55,119 --> 02:21:00,100
wanted to live in and so like I'm afraid

2509
02:20:58,059 --> 02:21:02,228
that his galactic empires probably will

2510
02:21:00,100 --> 02:21:03,939
be that way as well so you know maybe

2511
02:21:02,228 --> 02:21:06,338
it's best you just not put the pressure

2512
02:21:03,939 --> 02:21:10,148
on and leave it there that's fine too

2513
02:21:06,338 --> 02:21:11,289
but you know if if we do want to give

2514
02:21:10,148 --> 02:21:14,588
some demonstrations about how

2515
02:21:11,289 --> 02:21:15,909
intergalactic routing is best done then

2516
02:21:14,588 --> 02:21:18,748
maybe I'll stream some of that later I

2517
02:21:15,908 --> 02:21:20,859
don't know we'll see that's it for today

2518
02:21:18,748 --> 02:21:25,600
I'll see everyone back here next week

2519
02:21:20,859 --> 02:21:27,549
it's very least and I'll go check now to

2520
02:21:25,600 --> 02:21:29,588
see if John is streaming right now and

2521
02:21:27,549 --> 02:21:31,829
if so we'll rate them that's it take it

2522
02:21:29,588 --> 02:21:31,828
easy everybody

