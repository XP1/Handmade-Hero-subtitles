1
00:00:00,060 --> 00:00:03,480
hello everyone and welcome to hand made

2
00:00:02,040 --> 00:00:05,040
here the show recode a complete game

3
00:00:03,480 --> 00:00:06,628
live on stream it's the pronoun coding

4
00:00:05,040 --> 00:00:08,519
complete game live on streaming today we

5
00:00:06,628 --> 00:00:11,399
have an interim thing to do which is

6
00:00:08,519 --> 00:00:15,030
load P and G's so we're actually going

7
00:00:11,400 --> 00:00:19,948
to be writing an ID at decompressor live

8
00:00:15,029 --> 00:00:25,439
on stream mmm gotta have coffee for that

9
00:00:19,949 --> 00:00:28,230
my friends so what we did yesterday is

10
00:00:25,439 --> 00:00:29,250
we broke into the PNG spec we figured

11
00:00:28,230 --> 00:00:30,719
pretty much figured out what was going

12
00:00:29,250 --> 00:00:32,308
on at the high level which is pretty

13
00:00:30,719 --> 00:00:35,700
straightforward it's a very simple riff

14
00:00:32,308 --> 00:00:37,229
style format basically and what we did

15
00:00:35,700 --> 00:00:39,059
is we wrote something that parsed that

16
00:00:37,229 --> 00:00:41,759
and found out the data that we needed

17
00:00:39,058 --> 00:00:43,738
and then has the data stream sitting

18
00:00:41,759 --> 00:00:45,929
there that's the actual compressed image

19
00:00:43,738 --> 00:00:47,339
data but we didn't have a chance to

20
00:00:45,929 --> 00:00:49,170
actually get down and dirty with that

21
00:00:47,340 --> 00:00:50,910
and figure out how to decompress that

22
00:00:49,170 --> 00:00:53,460
now we did read about how to decompress

23
00:00:50,909 --> 00:00:55,308
that so we're kind of ready to go but we

24
00:00:53,460 --> 00:00:58,140
didn't have a chance to actually code it

25
00:00:55,308 --> 00:01:00,839
now again we are not trying to write a

26
00:00:58,140 --> 00:01:03,210
complete or even a fast or efficient PNG

27
00:01:00,840 --> 00:01:05,338
reader we just need something that reads

28
00:01:03,210 --> 00:01:06,960
pngs at all and the reason for that is

29
00:01:05,338 --> 00:01:10,289
we want to enable a quick turnaround

30
00:01:06,959 --> 00:01:12,839
time in Photoshop and that's all we're

31
00:01:10,290 --> 00:01:14,939
doing right now all right so what I want

32
00:01:12,840 --> 00:01:18,570
to do here let me go ahead and load this

33
00:01:14,938 --> 00:01:20,639
up here's our parse PNG so what I want

34
00:01:18,569 --> 00:01:23,008
to do here is pick up where we left off

35
00:01:20,640 --> 00:01:24,989
yesterday which is to say that once we

36
00:01:23,009 --> 00:01:26,700
see these I that chunks we now you do

37
00:01:24,989 --> 00:01:28,949
something with them now I'm fairly

38
00:01:26,700 --> 00:01:30,420
certain even though the spec was kind of

39
00:01:28,950 --> 00:01:32,630
caged about this I don't feel like they

40
00:01:30,420 --> 00:01:36,710
set it in a very good or clear way

41
00:01:32,629 --> 00:01:38,879
that's ok because we kind of figured out

42
00:01:36,709 --> 00:01:41,728
we more or less figured out what was

43
00:01:38,879 --> 00:01:44,879
going on what I think is happening here

44
00:01:41,728 --> 00:01:47,429
is when you encounter these I'd add

45
00:01:44,879 --> 00:01:50,009
chunks they're just chunked data that's

46
00:01:47,430 --> 00:01:51,990
actually all one stream right and the

47
00:01:50,009 --> 00:01:54,269
reason that I say that is because the

48
00:01:51,989 --> 00:01:56,609
spec for an IDOT chunk clearly states

49
00:01:54,269 --> 00:01:58,949
that it will have the Z live information

50
00:01:56,609 --> 00:02:01,259
at the front and what we can see is this

51
00:01:58,950 --> 00:02:03,509
even though it's a very simple PNG what

52
00:02:01,259 --> 00:02:06,209
we can see here is that we have four

53
00:02:03,509 --> 00:02:09,209
IDOT chunks and the four I'd add chunks

54
00:02:06,209 --> 00:02:11,389
are not ID at compliant only the first

55
00:02:09,209 --> 00:02:13,930
one is which has the zeal of information

56
00:02:11,389 --> 00:02:15,339
so what that tells me

57
00:02:13,930 --> 00:02:17,469
in terms of how I'm gonna approach this

58
00:02:15,340 --> 00:02:18,969
first is I'm gonna assume even though

59
00:02:17,469 --> 00:02:20,830
the spec I don't feel like was worded

60
00:02:18,969 --> 00:02:22,689
very well so it wasn't clear on this I'm

61
00:02:20,830 --> 00:02:24,670
gonna assume what they meant when they

62
00:02:22,689 --> 00:02:27,129
were talking about iodide chunks was

63
00:02:24,669 --> 00:02:29,559
that actually the Ida chunks are all one

64
00:02:27,129 --> 00:02:31,539
stream that you parse as if it was

65
00:02:29,560 --> 00:02:33,640
contiguous even though it kind of

66
00:02:31,539 --> 00:02:34,989
suggested that I'd act chunks start with

67
00:02:33,639 --> 00:02:36,849
this particular header I think what they

68
00:02:34,989 --> 00:02:39,189
mean is the first I that chunk does and

69
00:02:36,849 --> 00:02:40,780
then it did clearly say in the spec that

70
00:02:39,189 --> 00:02:43,120
I that chunks all have to come together

71
00:02:40,780 --> 00:02:46,150
and that they are interpreted as one

72
00:02:43,120 --> 00:02:48,969
group and so I feel like that was them

73
00:02:46,150 --> 00:02:50,800
trying to say there's only gonna be the

74
00:02:48,969 --> 00:02:53,650
Z Lib header at the on the first one

75
00:02:50,800 --> 00:02:55,780
right so I think what that means unless

76
00:02:53,650 --> 00:02:58,269
I'm very much mistaken is that we read

77
00:02:55,780 --> 00:03:00,370
the Z live header out of the Ida chunk

78
00:02:58,269 --> 00:03:02,110
that comes first and then we just read

79
00:03:00,370 --> 00:03:04,300
the rest of the stream including all

80
00:03:02,110 --> 00:03:07,060
fruits or chunks and all of the data

81
00:03:04,300 --> 00:03:09,910
inside those either chunks as being just

82
00:03:07,060 --> 00:03:12,250
part of a Z Lib deflate stream and we

83
00:03:09,909 --> 00:03:14,409
assume that they don't ever have any

84
00:03:12,250 --> 00:03:16,599
others Delibes tart up information in

85
00:03:14,409 --> 00:03:18,400
them now that could be wrong but that's

86
00:03:16,599 --> 00:03:21,099
what I think they're trying to say and

87
00:03:18,400 --> 00:03:23,530
what that means is that the PMG in this

88
00:03:21,099 --> 00:03:26,620
case can only have one compression mode

89
00:03:23,530 --> 00:03:29,199
or not one compression mode one Z Lib

90
00:03:26,620 --> 00:03:31,509
header for the entire compressed data

91
00:03:29,199 --> 00:03:33,849
section that's what it looks like I

92
00:03:31,509 --> 00:03:36,599
could be very wrong about that we'll

93
00:03:33,849 --> 00:03:40,150
find out as we go forward but that's

94
00:03:36,599 --> 00:03:41,919
what I was able to determine so far and

95
00:03:40,150 --> 00:03:43,569
so that's the assumption that I'm

96
00:03:41,919 --> 00:03:45,369
operating under and you'll see me

97
00:03:43,569 --> 00:03:47,379
operating under that assumption for the

98
00:03:45,370 --> 00:03:48,939
remainder of the stream until we need to

99
00:03:47,379 --> 00:03:57,090
counter something that gives me a clue

100
00:03:48,939 --> 00:04:02,459
that I'm wrong okay

101
00:03:57,090 --> 00:04:05,379
so now jumping back to where we were

102
00:04:02,459 --> 00:04:07,900
when we were decoding this when we

103
00:04:05,379 --> 00:04:10,269
grabbed out all of this information what

104
00:04:07,900 --> 00:04:13,270
we ended up finding was that we have

105
00:04:10,270 --> 00:04:18,280
these sort of Z Lib informational pieces

106
00:04:13,270 --> 00:04:21,730
here and what we are told anyway in the

107
00:04:18,279 --> 00:04:24,549
spec is that the Z the Z Lib information

108
00:04:21,730 --> 00:04:27,400
should never actually allow us to see a

109
00:04:24,550 --> 00:04:28,900
cm value which I believe stands for

110
00:04:27,399 --> 00:04:32,168
compression method or at the very least

111
00:04:28,899 --> 00:04:35,649
means compression method we should never

112
00:04:32,168 --> 00:04:40,049
see a cm value of anything other than 8

113
00:04:35,649 --> 00:04:43,239
so in other words it has to be a cm 8

114
00:04:40,050 --> 00:04:45,759
here there's nothing else that it can

115
00:04:43,240 --> 00:04:47,379
actually be I believe now I could be

116
00:04:45,759 --> 00:04:49,870
wrong about that but if we go back here

117
00:04:47,379 --> 00:04:51,370
to the compression information we'll

118
00:04:49,870 --> 00:04:54,280
just reread it again to make sure I'm

119
00:04:51,370 --> 00:04:57,280
not wrong but here's the compression

120
00:04:54,279 --> 00:04:59,259
section and what it says is only PNG

121
00:04:57,279 --> 00:05:00,789
compression methods zero is defined by

122
00:04:59,259 --> 00:05:01,839
the international standard other values

123
00:05:00,790 --> 00:05:05,290
compression method reserved for future

124
00:05:01,839 --> 00:05:07,149
standardization that zero is the thing

125
00:05:05,290 --> 00:05:09,280
that was in the header so up here right

126
00:05:07,149 --> 00:05:13,209
and you can see when we actually dumped

127
00:05:09,279 --> 00:05:14,709
it we we got exactly that right so then

128
00:05:13,209 --> 00:05:18,099
when we come back here and we look at

129
00:05:14,709 --> 00:05:20,589
the Z Lib information going forwards it

130
00:05:18,100 --> 00:05:22,180
says ok so PNG compression with zero is

131
00:05:20,589 --> 00:05:26,109
deflate inflate compression with sliding

132
00:05:22,180 --> 00:05:27,930
window from the lvl ZZ the lz77 deflate

133
00:05:26,110 --> 00:05:30,790
a standard that comes from the Z Lib

134
00:05:27,930 --> 00:05:32,650
library right so then it says that it

135
00:05:30,790 --> 00:05:34,900
has to come with this header compression

136
00:05:32,649 --> 00:05:36,939
method flags and code is 1 byte

137
00:05:34,899 --> 00:05:39,009
additional flag checkbooks one byte the

138
00:05:36,939 --> 00:05:41,079
compressed data and then the check value

139
00:05:39,009 --> 00:05:43,209
right that's what we're expecting to see

140
00:05:41,079 --> 00:05:45,250
now it's kind of odd that we have a

141
00:05:43,209 --> 00:05:47,319
check value at the end given the fact

142
00:05:45,250 --> 00:05:50,050
that these blocks have a crc themselves

143
00:05:47,319 --> 00:05:53,699
do the PNG don't ask me why that's just

144
00:05:50,050 --> 00:05:57,550
what we've got so off we go right now

145
00:05:53,699 --> 00:05:59,800
what I don't actually know is whether or

146
00:05:57,550 --> 00:06:01,780
not there's additional Z Lib start ups

147
00:05:59,800 --> 00:06:03,939
inside the stream so even though the I

148
00:06:01,779 --> 00:06:05,409
NAT chunks might not have Z Lib restarts

149
00:06:03,939 --> 00:06:07,029
maybe there's Z libri starts

150
00:06:05,410 --> 00:06:09,010
l sort in there I'm not sure we'll look

151
00:06:07,029 --> 00:06:10,149
at that as we kind of go forwards anyway

152
00:06:09,009 --> 00:06:11,740
for PNG compression methods

153
00:06:10,149 --> 00:06:14,978
Zuba compression method flags coats fest

154
00:06:11,740 --> 00:06:18,160
like method eight and not more than 32 k

155
00:06:14,978 --> 00:06:20,019
of window right so that's where I'm

156
00:06:18,160 --> 00:06:22,810
getting the like this has to be eight

157
00:06:20,019 --> 00:06:26,259
thing so I believe we only have to

158
00:06:22,810 --> 00:06:28,089
support cm method eight so what I want

159
00:06:26,259 --> 00:06:30,728
to do here is sort of say all right

160
00:06:28,089 --> 00:06:34,000
let's take a look at this in a slightly

161
00:06:30,728 --> 00:06:35,379
different way what I want to do here is

162
00:06:34,000 --> 00:06:36,519
I want to make something that's gonna

163
00:06:35,379 --> 00:06:38,649
allow me to read from these either

164
00:06:36,519 --> 00:06:41,289
chunks as if they're continuous because

165
00:06:38,649 --> 00:06:43,089
I'm expecting to see this thing want to

166
00:06:41,290 --> 00:06:45,129
read a continuous stream across either

167
00:06:43,089 --> 00:06:49,029
chunks so what I want to do is when I

168
00:06:45,129 --> 00:06:50,709
see the first I that chunk i I kind of

169
00:06:49,029 --> 00:06:52,359
wanna I don't want to start processing

170
00:06:50,709 --> 00:06:55,000
here because don't know where the rest

171
00:06:52,360 --> 00:06:56,530
of the Ida at chunks necessarily are now

172
00:06:55,000 --> 00:06:58,750
it's stayed in the spec that the Ida

173
00:06:56,529 --> 00:07:00,250
chunks have to be contiguous I could

174
00:06:58,750 --> 00:07:01,810
take their word for it or I could just

175
00:07:00,250 --> 00:07:08,769
build a chain of them a priori

176
00:07:01,810 --> 00:07:11,139
which might be what I want to do alright

177
00:07:08,769 --> 00:07:14,740
so if I wanted to do that how would I do

178
00:07:11,139 --> 00:07:18,728
it well let's take a look here so I

179
00:07:14,740 --> 00:07:21,370
think I've got I look up here I've got

180
00:07:18,728 --> 00:07:23,228
this nishan of entire file where we've

181
00:07:21,370 --> 00:07:26,288
got the content size and the contents

182
00:07:23,228 --> 00:07:27,819
here right that sort of stuff I think

183
00:07:26,288 --> 00:07:29,560
what I might want to do is kind of

184
00:07:27,819 --> 00:07:30,788
broaden that a little bit and maybe I'm

185
00:07:29,560 --> 00:07:33,038
just thinking out loud here

186
00:07:30,788 --> 00:07:38,459
but suppose we were to do something like

187
00:07:33,038 --> 00:07:44,709
this where we said like okay we've got

188
00:07:38,459 --> 00:07:47,769
you know I don't know a streaming buffer

189
00:07:44,709 --> 00:07:50,680
and it has something like this and when

190
00:07:47,769 --> 00:07:57,879
we stream stuff maybe we've got a thing

191
00:07:50,680 --> 00:08:00,430
that's like this so we can kind of like

192
00:07:57,879 --> 00:08:02,050
chain these things together where we

193
00:08:00,430 --> 00:08:04,418
could just make like a list of them and

194
00:08:02,050 --> 00:08:06,340
say like oh yeah we're gonna read all

195
00:08:04,418 --> 00:08:07,538
these things in right and I might want

196
00:08:06,339 --> 00:08:09,279
it a little bit different than this

197
00:08:07,538 --> 00:08:11,550
right I might want to do something like

198
00:08:09,279 --> 00:08:11,549
this

199
00:08:20,629 --> 00:08:25,550
so I can just sort of have an idea of

200
00:08:26,779 --> 00:08:29,699
the stream that I'm that I'm reading in

201
00:08:29,279 --> 00:08:32,370
here

202
00:08:29,699 --> 00:08:34,259
I and I can just kind of like navigate

203
00:08:32,370 --> 00:08:37,110
through them in some kind of reasonable

204
00:08:34,259 --> 00:08:38,639
way right and so what this would do is

205
00:08:37,110 --> 00:08:40,970
it would say like oh okay

206
00:08:38,639 --> 00:08:44,250
you know when we read in an entire file

207
00:08:40,970 --> 00:08:46,290
we want a client we want to be able to

208
00:08:44,250 --> 00:08:48,899
just do one of these and and we can

209
00:08:46,289 --> 00:08:52,679
write so when we have a situation where

210
00:08:48,899 --> 00:08:56,340
we're doing a streaming chunk like I'm

211
00:08:52,679 --> 00:08:59,250
sorry a streaming buffer like that we

212
00:08:56,340 --> 00:09:03,530
can read an entire one and just get like

213
00:08:59,250 --> 00:09:03,529
sort of this stuff initialized to zero

214
00:09:11,659 --> 00:09:15,659
so off we go on this it will just it'll

215
00:09:14,279 --> 00:09:19,819
just return exact the same thing that it

216
00:09:15,659 --> 00:09:25,019
was returning and this will operate on

217
00:09:19,820 --> 00:09:27,090
this right why do I keep doing that and

218
00:09:25,019 --> 00:09:29,730
then what we would do is when we get an

219
00:09:27,090 --> 00:09:32,250
underflow what we want to do instead

220
00:09:29,730 --> 00:09:34,050
here is say look if we get an underflow

221
00:09:32,250 --> 00:09:37,470
let's actually try to look at the next

222
00:09:34,049 --> 00:09:39,990
chunk in the thing so what we can do is

223
00:09:37,470 --> 00:09:41,850
say oh well if content size exactly

224
00:09:39,990 --> 00:09:43,230
equals zero we can assume that the

225
00:09:41,850 --> 00:09:45,180
person who is reading out of this thing

226
00:09:43,230 --> 00:09:48,539
was reading out of it in a sensible way

227
00:09:45,179 --> 00:09:51,629
and wants to just get maybe what's in

228
00:09:48,539 --> 00:09:54,929
the next chunk right so what I could do

229
00:09:51,629 --> 00:09:57,169
here let's see maybe I'll do it like

230
00:09:54,929 --> 00:09:57,169
this

231
00:10:02,240 --> 00:10:16,580
I don't really know if I want to do it

232
00:10:09,169 --> 00:10:17,870
like that exactly but maybe like that so

233
00:10:16,580 --> 00:10:20,149
what I want to do here is say all right

234
00:10:17,870 --> 00:10:22,159
look if the content size is enough to

235
00:10:20,149 --> 00:10:24,049
fill the request then do it if the

236
00:10:22,159 --> 00:10:25,429
content size is zero then maybe we want

237
00:10:24,049 --> 00:10:26,990
to advance and get the thing on to the

238
00:10:25,429 --> 00:10:28,399
next chunk we could be even more

239
00:10:26,990 --> 00:10:31,070
creative here and actually try to

240
00:10:28,399 --> 00:10:33,019
assemble things together into pieces I'm

241
00:10:31,070 --> 00:10:35,028
not actually going to do that but we

242
00:10:33,019 --> 00:10:36,708
could I could show how to do that in a

243
00:10:35,028 --> 00:10:38,480
there's other ways we could do that

244
00:10:36,708 --> 00:10:40,369
there's ways to construct buffers for

245
00:10:38,480 --> 00:10:41,810
streaming that do that but what I want

246
00:10:40,370 --> 00:10:42,980
to do here to say looking a look if we

247
00:10:41,809 --> 00:10:44,179
just assume for now that everyone's

248
00:10:42,980 --> 00:10:45,740
reading the right amount of stuff in

249
00:10:44,179 --> 00:10:47,389
then in that case what I'm going to do

250
00:10:45,740 --> 00:10:49,580
is advance to the next one so what I'm

251
00:10:47,389 --> 00:10:57,470
going to do is say in fact I can do this

252
00:10:49,580 --> 00:11:00,889
like this so in that case what we'll do

253
00:10:57,470 --> 00:11:07,149
is say first look we'll grab out

254
00:11:00,889 --> 00:11:12,379
streaming chunk this will set file first

255
00:11:07,149 --> 00:11:14,870
equal to this next and that'll knock out

256
00:11:12,379 --> 00:11:16,309
to zero eventually right and then what

257
00:11:14,870 --> 00:11:19,310
we'll do is say okay when we grab the

258
00:11:16,309 --> 00:11:23,949
first one out of here we'll set the

259
00:11:19,309 --> 00:11:23,949
content size that we're looking at now

260
00:11:26,440 --> 00:11:33,320
and the contents pointer itself to be

261
00:11:29,778 --> 00:11:34,820
the one in the next jump right so this

262
00:11:33,320 --> 00:11:36,110
is just kind of a quick and dirty not

263
00:11:34,820 --> 00:11:38,120
particularly well thought-out or

264
00:11:36,110 --> 00:11:40,039
anything just a random crappy way of

265
00:11:38,120 --> 00:11:42,679
making a buffer that can have multiple

266
00:11:40,039 --> 00:11:46,539
chunks in it right and so if I compile

267
00:11:42,679 --> 00:11:46,539
this now I should be able to do a thing

268
00:11:46,690 --> 00:11:56,120
where we can just recompile what we've

269
00:11:49,700 --> 00:12:01,278
got here and this should still work

270
00:11:56,120 --> 00:12:03,639
hopefully let's see OOP got a bug

271
00:12:01,278 --> 00:12:03,639
somewhere

272
00:12:08,049 --> 00:12:16,870
ah yeah

273
00:12:13,100 --> 00:12:16,870
in fact I suppose what I could do I

274
00:12:17,528 --> 00:12:22,879
suppose what I could do is just do this

275
00:12:21,110 --> 00:12:26,210
again it's short enough that that loop

276
00:12:22,879 --> 00:12:32,629
seems kind of dumb right what I could do

277
00:12:26,210 --> 00:12:56,778
is just say all right look just repeat

278
00:12:32,629 --> 00:13:00,049
this like so like that and I could just

279
00:12:56,778 --> 00:13:03,169
put that at the top in fact now this is

280
00:13:00,049 --> 00:13:05,359
looking much nicer so if the content

281
00:13:03,169 --> 00:13:08,750
size is zero and there's a file first in

282
00:13:05,360 --> 00:13:11,240
fact this is what we'll do we'll just

283
00:13:08,750 --> 00:13:13,278
say all right well in that case we

284
00:13:11,240 --> 00:13:15,019
advanced it and then we try to do the

285
00:13:13,278 --> 00:13:15,559
thing we were going to do that's much

286
00:13:15,019 --> 00:13:22,939
better

287
00:13:15,559 --> 00:13:24,588
right yeah much nicer so we just say all

288
00:13:22,940 --> 00:13:26,540
right look if the content size is zero

289
00:13:24,589 --> 00:13:28,400
and there's another one let's advance to

290
00:13:26,539 --> 00:13:32,629
the next chunk first so that's this

291
00:13:28,399 --> 00:13:34,458
right and then we'll keep going right

292
00:13:32,629 --> 00:13:40,159
let's do what we were going to do before

293
00:13:34,458 --> 00:13:42,289
that's a much saner so now what we can

294
00:13:40,159 --> 00:13:45,379
do is we can build up a one of these

295
00:13:42,289 --> 00:13:51,759
guys we can build up one of these sort

296
00:13:45,379 --> 00:13:56,299
of chains for all the idaite chunks and

297
00:13:51,759 --> 00:14:00,649
then when we're done we can decompress

298
00:13:56,299 --> 00:14:04,159
the image right so what I want to do

299
00:14:00,649 --> 00:14:11,689
here is say all right let's move this

300
00:14:04,159 --> 00:14:13,219
stuff out to something at the end well I

301
00:14:11,690 --> 00:14:16,720
guess you know what I don't need to put

302
00:14:13,220 --> 00:14:16,720
it there it could just be here

303
00:14:17,328 --> 00:14:26,929
so allocate pixels can come here which

304
00:14:24,690 --> 00:14:30,200
is great

305
00:14:26,929 --> 00:14:30,199
here we go

306
00:14:35,458 --> 00:14:39,719
so here we go we say if we got the file

307
00:14:37,708 --> 00:14:42,299
header while we read it assuming that we

308
00:14:39,720 --> 00:14:45,120
end up with one that's supported we will

309
00:14:42,299 --> 00:14:46,948
go ahead and try to decompress it later

310
00:14:45,120 --> 00:14:49,909
and what we'll do is we'll just build up

311
00:14:46,948 --> 00:14:53,009
the Ida chunks that we actually want to

312
00:14:49,909 --> 00:14:54,659
to use here and the way that we'll do

313
00:14:53,009 --> 00:14:59,250
that is we'll just say let's pretend

314
00:14:54,659 --> 00:15:00,778
that we have an IDOT sort of or you know

315
00:14:59,250 --> 00:15:04,379
pixel data I don't know

316
00:15:00,778 --> 00:15:06,000
compressed data or something let's

317
00:15:04,379 --> 00:15:08,009
assume that we have a streaming buffer

318
00:15:06,000 --> 00:15:10,049
of compressed data and all I'm going to

319
00:15:08,009 --> 00:15:12,528
do is every time we get in here and find

320
00:15:10,049 --> 00:15:15,569
one of them I'm gonna add it to this

321
00:15:12,528 --> 00:15:20,220
right so what I'm going to do is say

322
00:15:15,570 --> 00:15:23,760
okay you know here on comp data I'm

323
00:15:20,220 --> 00:15:25,199
going to need a streaming chunk so I'm

324
00:15:23,759 --> 00:15:29,879
going to go ahead and do an allocate

325
00:15:25,198 --> 00:15:31,049
chunk here like so and the reason I'm

326
00:15:29,879 --> 00:15:32,820
putting these out here is because I can

327
00:15:31,049 --> 00:15:35,490
I want to do stuff special with them

328
00:15:32,820 --> 00:15:41,670
when we integrate this code into

329
00:15:35,490 --> 00:15:43,409
handmade hero so what we do here is say

330
00:15:41,669 --> 00:15:45,828
alright when I allocate a streaming

331
00:15:43,409 --> 00:15:45,828
chunk

332
00:15:52,839 --> 00:15:56,470
I'm gonna do it like this

333
00:15:57,698 --> 00:16:02,149
that'll give me back one of those and so

334
00:16:00,019 --> 00:16:04,370
as we encounter each of these I'll just

335
00:16:02,149 --> 00:16:07,220
say allocated chunk and then I'm going

336
00:16:04,370 --> 00:16:10,419
to set the chunk up to be the data

337
00:16:07,220 --> 00:16:13,850
that's that's in this particular I'd at

338
00:16:10,419 --> 00:16:16,458
so as far as I know we use the whole i

339
00:16:13,850 --> 00:16:19,629
dot chunk for the data right

340
00:16:16,458 --> 00:16:25,099
so we basically say okay this Ida chunk

341
00:16:19,629 --> 00:16:27,528
has the the chunk data here and the

342
00:16:25,100 --> 00:16:42,319
chunk size here so I'm just gonna use

343
00:16:27,528 --> 00:16:44,838
that and then I just need to set the

344
00:16:42,318 --> 00:16:46,128
next pointer up it's going to point to

345
00:16:44,839 --> 00:16:48,170
nothing because I want to append at the

346
00:16:46,129 --> 00:16:50,089
end so then when I go to set the

347
00:16:48,169 --> 00:16:52,818
streaming buffer itself which is the

348
00:16:50,089 --> 00:16:57,500
compression data I just need to set the

349
00:16:52,818 --> 00:16:59,509
the first and the last right now that in

350
00:16:57,500 --> 00:17:01,159
any case the last will always be equal

351
00:16:59,509 --> 00:17:03,470
to chunk cuz I'm appending to the end

352
00:17:01,159 --> 00:17:06,168
right so we kind of know that that's

353
00:17:03,470 --> 00:17:12,220
always the case but the first will only

354
00:17:06,169 --> 00:17:16,280
be set in the case where you know if

355
00:17:12,220 --> 00:17:18,769
comp data first is not equal to

356
00:17:16,279 --> 00:17:20,588
something or you know if last is valid

357
00:17:18,769 --> 00:17:26,150
already so I already have one in there

358
00:17:20,588 --> 00:17:28,579
then the comp data first doesn't need to

359
00:17:26,150 --> 00:17:32,840
be set right it's just comp data last

360
00:17:28,579 --> 00:17:35,240
next pickles chunk and then comp data

361
00:17:32,839 --> 00:17:37,759
last equals chunk and then the same

362
00:17:35,240 --> 00:17:41,089
token if it wasn't the case you know if

363
00:17:37,759 --> 00:17:42,679
the first were if the first wasn't set

364
00:17:41,089 --> 00:17:46,129
then I would send it like this right so

365
00:17:42,679 --> 00:17:47,419
this is just a kind of a bigger way of

366
00:17:46,130 --> 00:17:49,549
saying I'm gonna have pend to the end of

367
00:17:47,419 --> 00:17:50,900
the list the next pointer will always be

368
00:17:49,548 --> 00:17:53,089
0 because I'm adding it to the end of

369
00:17:50,900 --> 00:17:55,370
the list but in terms of setting up the

370
00:17:53,089 --> 00:17:57,230
first and last pointers well the last

371
00:17:55,369 --> 00:17:59,389
pointer always needs to point to this

372
00:17:57,230 --> 00:18:01,069
chunk because it is the last one now but

373
00:17:59,390 --> 00:18:03,778
the first pointer only gets set the

374
00:18:01,069 --> 00:18:06,538
first time I do it and the last point

375
00:18:03,778 --> 00:18:08,278
gets its next pointer set if it was set

376
00:18:06,538 --> 00:18:09,960
to anything right I'm in the other case

377
00:18:08,278 --> 00:18:12,778
so these are the two cases I might have

378
00:18:09,960 --> 00:18:14,429
this leads to my favorite ridiculous way

379
00:18:12,778 --> 00:18:17,398
of compressing this code which people

380
00:18:14,429 --> 00:18:22,169
hate but I don't really care which is to

381
00:18:17,398 --> 00:18:25,678
say hey if compte to last is set then

382
00:18:22,169 --> 00:18:29,429
I'm setting this right

383
00:18:25,679 --> 00:18:35,788
but if compte the last isn't set then

384
00:18:29,429 --> 00:18:38,210
I'm setting this right I'm setting these

385
00:18:35,788 --> 00:18:39,329
two and I'm setting them equal to chunk

386
00:18:38,210 --> 00:18:42,749
oops

387
00:18:39,329 --> 00:18:44,368
makes sense right that's what we were

388
00:18:42,749 --> 00:18:47,249
saying so I'm saying like look if the

389
00:18:44,368 --> 00:18:49,439
last thing is set can even do it doesn't

390
00:18:47,249 --> 00:18:51,509
need a parentheses right if the last

391
00:18:49,440 --> 00:18:53,399
thing is already set then I'm going to

392
00:18:51,509 --> 00:18:55,618
set the next pointer equal to chunk if

393
00:18:53,398 --> 00:18:58,288
the last wasn't set that I'm going to

394
00:18:55,618 --> 00:19:00,209
set first equal chunk but in either case

395
00:18:58,288 --> 00:19:02,519
in minute set comp data last equal to

396
00:19:00,210 --> 00:19:06,739
chunk so hey since this whole expression

397
00:19:02,519 --> 00:19:06,739
evaluates to chunk why not

398
00:19:07,519 --> 00:19:18,710
and so that's the ridiculous way of of

399
00:19:12,440 --> 00:19:18,710
doing a singly linked list append at end

400
00:19:19,159 --> 00:19:32,159
in one expression for those of you who

401
00:19:23,429 --> 00:19:34,320
like obtuse code right again just to be

402
00:19:32,159 --> 00:19:38,129
clear on that so it's right comp data

403
00:19:34,319 --> 00:19:40,798
last is always going to be set to chunk

404
00:19:38,128 --> 00:19:42,598
either way and then the question is just

405
00:19:40,798 --> 00:19:44,969
which of these two do we also want to

406
00:19:42,598 --> 00:19:46,588
set to chunk if compte the last was set

407
00:19:44,969 --> 00:19:48,749
we set the next pointer because it means

408
00:19:46,588 --> 00:19:50,210
that first is already set as well cuz

409
00:19:48,749 --> 00:19:52,618
last and first to point the same thing

410
00:19:50,210 --> 00:19:53,940
or well first we'll point something and

411
00:19:52,618 --> 00:19:56,819
last we'll point to something either it

412
00:19:53,940 --> 00:19:59,399
or after it and then comp data first in

413
00:19:56,819 --> 00:20:03,479
this case is just the thing that is

414
00:19:59,398 --> 00:20:05,668
going to be set in the case where we

415
00:20:03,479 --> 00:20:07,080
haven't set anything yet and then in

416
00:20:05,669 --> 00:20:09,499
that case last and first we set to the

417
00:20:07,079 --> 00:20:09,499
same thing

418
00:20:11,839 --> 00:20:17,039
so anyway that's all we need to do there

419
00:20:15,299 --> 00:20:22,049
right so all of that information just

420
00:20:17,039 --> 00:20:23,789
kind of gets buffered up and then what

421
00:20:22,049 --> 00:20:26,279
we can do is from then on we can just

422
00:20:23,789 --> 00:20:28,799
start to look at the stream as it comes

423
00:20:26,279 --> 00:20:31,950
in so what I can do here is change this

424
00:20:28,799 --> 00:20:34,500
to a consume and say well the thing that

425
00:20:31,950 --> 00:20:37,860
I want to consume is the comp data I

426
00:20:34,500 --> 00:20:40,259
want to consume a ping i dot header from

427
00:20:37,859 --> 00:20:42,299
it and read that out and just print out

428
00:20:40,259 --> 00:20:48,029
what happens there right so let's see if

429
00:20:42,299 --> 00:20:49,649
we can make that work we need to store

430
00:20:48,029 --> 00:20:55,980
the width and the height here actually

431
00:20:49,650 --> 00:21:08,910
though those are like two things we

432
00:20:55,980 --> 00:21:12,420
allow to vary and so I'm gonna go ahead

433
00:21:08,910 --> 00:21:17,790
and put those here there we go

434
00:21:12,420 --> 00:21:22,890
ah yeah and what is the four there we go

435
00:21:17,789 --> 00:21:24,509
okay so now if we did that correctly we

436
00:21:22,890 --> 00:21:25,950
should see ourselves read the ID at

437
00:21:24,509 --> 00:21:29,250
chunks and then we should come in here

438
00:21:25,950 --> 00:21:31,110
and decompress them which is exactly

439
00:21:29,250 --> 00:21:33,150
what we did now I'm gonna print out when

440
00:21:31,109 --> 00:21:36,569
I see this it--it chunk I actually want

441
00:21:33,150 --> 00:21:39,330
to see a little bit of information here

442
00:21:36,569 --> 00:21:43,139
as well I think I'd like to see the size

443
00:21:39,329 --> 00:21:45,539
just so I can know like how long each of

444
00:21:43,140 --> 00:21:52,710
these is because I'm curious so when I

445
00:21:45,539 --> 00:21:54,839
do this let's see so that's so again

446
00:21:52,710 --> 00:21:57,650
this gives us a little bit of insight

447
00:21:54,839 --> 00:22:02,339
I guess into what's happening again

448
00:21:57,650 --> 00:22:04,670
which is to say that let me just go

449
00:22:02,339 --> 00:22:04,669
ahead and

450
00:22:13,710 --> 00:22:19,210
what you say that I was wondering what

451
00:22:16,118 --> 00:22:21,099
the idea is behind these ayats' and you

452
00:22:19,210 --> 00:22:22,569
can kind of see from this pattern maybe

453
00:22:21,099 --> 00:22:24,368
something is kind of being suggested

454
00:22:22,569 --> 00:22:27,099
there which is that it looks like for

455
00:22:24,368 --> 00:22:28,808
whatever reason writes these out in

456
00:22:27,099 --> 00:22:34,089
chunks of 8192

457
00:22:28,808 --> 00:22:36,038
right which is 2 4 K pages why it does

458
00:22:34,089 --> 00:22:37,988
that I have no idea but that looks like

459
00:22:36,038 --> 00:22:41,138
what they're effectively using these I

460
00:22:37,989 --> 00:22:45,249
that chunks 4 is buffered i/o so I don't

461
00:22:41,138 --> 00:22:50,558
know if maybe as a buffer if 4 K to

462
00:22:45,249 --> 00:22:52,419
4 K pages so 81 92 or 8k that it just

463
00:22:50,558 --> 00:22:54,700
fills up and then flushes fills up and

464
00:22:52,419 --> 00:22:56,230
flushes fills up and flushes and every

465
00:22:54,700 --> 00:22:58,840
time it flushes it flushes to a new I

466
00:22:56,230 --> 00:23:01,139
dot chunk now why it doesn't just flush

467
00:22:58,839 --> 00:23:03,189
the same might at chunk I have no idea

468
00:23:01,138 --> 00:23:04,148
but it kind of looks like that's what

469
00:23:03,190 --> 00:23:06,399
it's doing

470
00:23:04,148 --> 00:23:07,778
maybe there's something somewhere that

471
00:23:06,398 --> 00:23:09,758
would explain this I don't know what it

472
00:23:07,778 --> 00:23:11,648
is but that's looks like what's

473
00:23:09,759 --> 00:23:13,298
happening so then once we go to

474
00:23:11,648 --> 00:23:14,469
decompress you can see that we get the

475
00:23:13,298 --> 00:23:16,239
same information that we were getting

476
00:23:14,470 --> 00:23:21,220
before right when we were reading the ID

477
00:23:16,239 --> 00:23:22,980
at chunk directly 8 726 0 3 8 7 2003 so

478
00:23:21,220 --> 00:23:26,379
now we're reading out of that stream

479
00:23:22,980 --> 00:23:28,179
nicely and now we can begin to do the

480
00:23:26,378 --> 00:23:30,878
rest of the compression right and so

481
00:23:28,179 --> 00:23:32,259
this is the absolute decompression this

482
00:23:30,878 --> 00:23:34,569
is a part we need to start there now

483
00:23:32,259 --> 00:23:37,569
what the heck they're doing here and so

484
00:23:34,569 --> 00:23:41,200
we know that there's a window size that

485
00:23:37,569 --> 00:23:43,778
we need to be aware of I don't know that

486
00:23:41,200 --> 00:23:46,239
we actually care about the window size

487
00:23:43,778 --> 00:23:49,239
very much other than it may inform how

488
00:23:46,239 --> 00:23:51,669
the bits are encoded as to how many bits

489
00:23:49,239 --> 00:23:53,259
of window back.look we use that's the

490
00:23:51,669 --> 00:23:54,340
only thing I could think of where that's

491
00:23:53,259 --> 00:23:57,099
actually even going to come into play

492
00:23:54,339 --> 00:24:01,569
because we actually support the entire

493
00:23:57,099 --> 00:24:05,469
look back window because we're we're

494
00:24:01,569 --> 00:24:07,569
decompressing this into an image and we

495
00:24:05,470 --> 00:24:09,608
will allow it to look back arbitrarily

496
00:24:07,569 --> 00:24:12,038
far it can look back to any part in the

497
00:24:09,608 --> 00:24:13,239
image and grab any part of it because we

498
00:24:12,038 --> 00:24:16,868
have it all in memory it's not a

499
00:24:13,239 --> 00:24:18,970
streaming decompressor in our case so

500
00:24:16,868 --> 00:24:20,579
what that means is that we don't really

501
00:24:18,970 --> 00:24:23,460
care what the window size is

502
00:24:20,579 --> 00:24:26,250
but it may well us something about how

503
00:24:23,460 --> 00:24:28,620
many bits are encoded in the stream for

504
00:24:26,250 --> 00:24:30,179
certain pieces of information so I don't

505
00:24:28,619 --> 00:24:31,558
know if we might need that later but

506
00:24:30,179 --> 00:24:35,460
that's the only reason we would even

507
00:24:31,558 --> 00:24:37,288
need that anyway so looking at all of

508
00:24:35,460 --> 00:24:41,788
this stuff I think all we really care

509
00:24:37,288 --> 00:24:45,629
about here is to go ahead and use that

510
00:24:41,788 --> 00:24:50,398
data at the head end to start to start

511
00:24:45,630 --> 00:24:56,159
implementing this spec right so looking

512
00:24:50,398 --> 00:24:59,849
through here when we see F level I don't

513
00:24:56,159 --> 00:25:01,380
know that we care about this yeah it

514
00:24:59,849 --> 00:25:04,288
says right here that the F levels not

515
00:25:01,380 --> 00:25:06,480
need a few compression so really all

516
00:25:04,288 --> 00:25:08,220
that's telling us is how hard it tried

517
00:25:06,480 --> 00:25:12,690
to compress this data on the compression

518
00:25:08,220 --> 00:25:16,200
side but we don't care right similarly F

519
00:25:12,690 --> 00:25:20,519
dict I think we read that F nicht was

520
00:25:16,200 --> 00:25:23,730
not allowed to be set so I think this

521
00:25:20,519 --> 00:25:26,579
always has to be zero I could be wrong

522
00:25:23,730 --> 00:25:30,509
about that but I think that's what it

523
00:25:26,579 --> 00:25:33,678
said so I think in here we can actually

524
00:25:30,509 --> 00:25:33,679
do something like this

525
00:25:51,888 --> 00:26:01,368
so this is the this is the zeal impetus

526
00:25:58,888 --> 00:26:06,178
here so I think what we want to say is

527
00:26:01,368 --> 00:26:14,638
that supported is gonna get modified

528
00:26:06,179 --> 00:26:23,429
here so cm has to equal 8f nicht has to

529
00:26:14,638 --> 00:26:25,738
equal zero I think right because I don't

530
00:26:23,429 --> 00:26:29,129
think we're allowing anything else in

531
00:26:25,739 --> 00:26:30,269
here so then moving forwards when we

532
00:26:29,128 --> 00:26:33,028
start to do compressing them we can

533
00:26:30,269 --> 00:26:35,128
allocate the decompressed pixels and I

534
00:26:33,028 --> 00:26:40,229
think then now we're good to go

535
00:26:35,128 --> 00:26:42,628
so looking back at the spec here I think

536
00:26:40,229 --> 00:26:44,759
there's nothing more we can really glean

537
00:26:42,628 --> 00:26:47,148
from this if I remember correctly cuz

538
00:26:44,759 --> 00:26:49,710
this just says go read the other

539
00:26:47,148 --> 00:26:53,928
document for learning how deflate works

540
00:26:49,710 --> 00:26:53,929
right yeah I think so

541
00:26:55,729 --> 00:27:02,580
yep so I think we're just we're just

542
00:26:59,429 --> 00:27:04,919
living here now this is this is our jam

543
00:27:02,579 --> 00:27:10,108
and so this is what we want to actually

544
00:27:04,919 --> 00:27:12,359
do we want to follow this rule so like

545
00:27:10,108 --> 00:27:14,249
read bloc header if store would no

546
00:27:12,358 --> 00:27:17,398
compression whatever like we want to do

547
00:27:14,249 --> 00:27:19,950
this so what we need to do is we need to

548
00:27:17,398 --> 00:27:23,579
start reading said block header right

549
00:27:19,950 --> 00:27:25,019
and we need to figure out how we do that

550
00:27:23,579 --> 00:27:26,848
right what does the block header look

551
00:27:25,019 --> 00:27:29,608
like and how do we determine whether or

552
00:27:26,848 --> 00:27:31,468
not we come we compress or don't

553
00:27:29,608 --> 00:27:32,759
compress so it says each block of

554
00:27:31,469 --> 00:27:37,048
impressed data bits with three header

555
00:27:32,759 --> 00:27:39,179
bits be final and B type and off we go

556
00:27:37,048 --> 00:27:40,888
so that's the first thing that we want

557
00:27:39,179 --> 00:27:45,059
to be able to do is kind of read these

558
00:27:40,888 --> 00:27:47,098
bits now I'm live to make something that

559
00:27:45,058 --> 00:27:48,808
literally reads bits but at the same

560
00:27:47,098 --> 00:27:51,329
time that's what we're gonna basically

561
00:27:48,808 --> 00:27:53,220
dealing with so I think I want to do

562
00:27:51,329 --> 00:27:56,788
something that's like the worst

563
00:27:53,220 --> 00:27:58,740
thing here for a while because again I

564
00:27:56,788 --> 00:28:01,048
don't really care about this code I just

565
00:27:58,740 --> 00:28:03,900
need it to work and if the stupid thing

566
00:28:01,048 --> 00:28:05,879
ends up working fast enough then I'm not

567
00:28:03,900 --> 00:28:08,460
going to touch it right I'm just gonna

568
00:28:05,880 --> 00:28:09,750
let it do its thing so I think we want

569
00:28:08,460 --> 00:28:12,390
to do something that's literally the

570
00:28:09,750 --> 00:28:14,849
dumbest possible thing where we can just

571
00:28:12,390 --> 00:28:17,159
basically say let get bit like literally

572
00:28:14,849 --> 00:28:19,288
right so I kind of want to do something

573
00:28:17,159 --> 00:28:21,780
here that says be fine I'll be type

574
00:28:19,288 --> 00:28:36,298
right I want to do something that

575
00:28:21,779 --> 00:28:38,490
basically just says look I think I want

576
00:28:36,298 --> 00:28:41,960
to do something like that right where I

577
00:28:38,490 --> 00:28:44,190
can actually consume bits at a time and

578
00:28:41,960 --> 00:28:45,538
write the code that way and then just

579
00:28:44,190 --> 00:28:48,870
deal with the fact that that's not very

580
00:28:45,538 --> 00:28:49,798
efficient because again if it doesn't

581
00:28:48,869 --> 00:28:51,329
end up being a problem I'm not gonna

582
00:28:49,798 --> 00:28:53,849
care because this is not code that runs

583
00:28:51,329 --> 00:28:55,829
during the game if it's stored with no

584
00:28:53,849 --> 00:28:58,469
compression skip any remaining bits and

585
00:28:55,829 --> 00:29:01,408
current partially processed byte read

586
00:28:58,470 --> 00:29:03,808
Len and n Len see you next section copy

587
00:29:01,409 --> 00:29:06,090
Len bytes of data to output so this is

588
00:29:03,808 --> 00:29:10,319
the uncompressed case which should be

589
00:29:06,089 --> 00:29:13,829
pretty reasonable right so what I want

590
00:29:10,319 --> 00:29:19,950
to do here is I need a flush byte call I

591
00:29:13,829 --> 00:29:23,189
guess so when when we're doing consume

592
00:29:19,950 --> 00:29:25,558
bits then we have a flush byte call and

593
00:29:23,190 --> 00:29:27,929
the flush byte call is basically saying

594
00:29:25,558 --> 00:29:30,418
look as I'm taking bits out I'm gonna

595
00:29:27,929 --> 00:29:33,179
jump to the next eight

596
00:29:30,419 --> 00:29:35,730
that's just what it says that it wants

597
00:29:33,179 --> 00:29:38,000
to do for whatever reason read Lennon n

598
00:29:35,730 --> 00:29:38,000
Len

599
00:29:41,170 --> 00:29:48,390
I don't know how long those are but

600
00:29:44,890 --> 00:29:48,390
presumably gonna tell us in a second

601
00:29:48,900 --> 00:29:56,410
and this happens if V type equals

602
00:29:51,609 --> 00:29:58,419
something so 0 0 is no compression then

603
00:29:56,410 --> 00:30:01,570
we've got compressed compressed and

604
00:29:58,420 --> 00:30:06,070
reserved right so we basically have a B

605
00:30:01,569 --> 00:30:11,230
type of 0 is going to do something a B

606
00:30:06,069 --> 00:30:14,500
type of 1 is going to do something a B

607
00:30:11,230 --> 00:30:17,019
type of 2 is gonna do something and any

608
00:30:14,500 --> 00:30:26,829
other B type because we don't allow 11

609
00:30:17,019 --> 00:30:29,589
in this case is an error right and so

610
00:30:26,829 --> 00:30:33,009
that's going to be B type 3 is just not

611
00:30:29,589 --> 00:30:36,519
it like the spec doesn't say so we hope

612
00:30:33,009 --> 00:30:39,369
to never encounter this and in theory we

613
00:30:36,519 --> 00:30:42,569
shouldn't write alright so we have B

614
00:30:39,369 --> 00:30:45,759
type 0 B type equals 1 v technicals - I

615
00:30:42,569 --> 00:30:48,369
don't actually know if the fixed Huffman

616
00:30:45,759 --> 00:30:51,250
code version is supposed to happen

617
00:30:48,369 --> 00:30:53,829
because I kind of think we've read

618
00:30:51,250 --> 00:30:56,349
something that says it's not so I'm

619
00:30:53,829 --> 00:31:01,119
gonna assume that the dynamic Huffman

620
00:30:56,349 --> 00:31:02,529
code is the only path for now but I'm

621
00:31:01,119 --> 00:31:07,269
not sure about that because it was kind

622
00:31:02,529 --> 00:31:09,430
of the spec again was really not worded

623
00:31:07,269 --> 00:31:12,670
well I didn't think so I'm gonna just

624
00:31:09,430 --> 00:31:13,840
see if we see any of these if we don't

625
00:31:12,670 --> 00:31:15,279
see any I assume that's the right

626
00:31:13,839 --> 00:31:18,250
reading if we do see something obviously

627
00:31:15,279 --> 00:31:21,940
that was just erroneous so then we've

628
00:31:18,250 --> 00:31:26,920
got the two cases here really the

629
00:31:21,940 --> 00:31:34,029
dynamic Huffman code one is the same

630
00:31:26,920 --> 00:31:37,560
these two are basically the same so I

631
00:31:34,029 --> 00:31:37,559
guess what I could do is this

632
00:31:49,628 --> 00:31:55,759
so if compress with dynamic Huffman code

633
00:31:52,460 --> 00:31:58,429
so if the B type is to this reads the

634
00:31:55,759 --> 00:32:02,179
dynamic Huffman codes and otherwise it

635
00:31:58,429 --> 00:32:08,619
doesn't right and so sort of what we're

636
00:32:02,179 --> 00:32:08,619
saying here is I guess we're saying that

637
00:32:10,028 --> 00:32:19,759
I'm sorry no we're saying this because I

638
00:32:17,179 --> 00:32:21,950
guess the idea here is that we're not

639
00:32:19,759 --> 00:32:24,798
expecting to be using the fixed Huffman

640
00:32:21,950 --> 00:32:27,048
codes but if we do encounter fixed

641
00:32:24,798 --> 00:32:28,579
Huffman codes it's okay we would just

642
00:32:27,048 --> 00:32:39,648
set up the fixed Huffman table here

643
00:32:28,579 --> 00:32:43,989
right so this is like right and so then

644
00:32:39,648 --> 00:32:48,648
we start to do the loop block here and

645
00:32:43,989 --> 00:32:54,069
this loop I guess we look at B final

646
00:32:48,648 --> 00:32:54,069
so in here this is really a while loop

647
00:32:55,628 --> 00:33:04,638
and you know I could literally code it

648
00:32:58,940 --> 00:33:08,379
that way so basically and we're gonna

649
00:33:04,638 --> 00:33:11,719
read in whether or not we should stop

650
00:33:08,378 --> 00:33:13,368
but even if we should stop we're still

651
00:33:11,720 --> 00:33:16,129
going to process the block because the

652
00:33:13,368 --> 00:33:18,408
last block is a valid block the B final

653
00:33:16,128 --> 00:33:22,519
flag if it got set we will then end out

654
00:33:18,409 --> 00:33:25,309
of the loop and go from there if we're

655
00:33:22,519 --> 00:33:28,128
inside we're gonna take a look at the B

656
00:33:25,308 --> 00:33:32,898
type we've got a pretty easy one here

657
00:33:28,128 --> 00:33:35,058
that just doesn't consume and we have to

658
00:33:32,898 --> 00:33:36,768
look up what these mean we don't know

659
00:33:35,058 --> 00:33:39,108
quite yet what these values are how many

660
00:33:36,769 --> 00:33:40,249
bits they are anything like that but

661
00:33:39,108 --> 00:33:41,628
then we've got these sort of two other

662
00:33:40,249 --> 00:33:44,239
things we have the B type equals three

663
00:33:41,628 --> 00:33:45,199
that one is not specified in spec so we

664
00:33:44,239 --> 00:33:47,538
don't know what it is and we're just

665
00:33:45,200 --> 00:33:50,480
gonna bail if we see it otherwise we've

666
00:33:47,538 --> 00:33:52,720
got the B type of one is the one we're

667
00:33:50,480 --> 00:33:55,009
expecting

668
00:33:52,720 --> 00:33:57,259
I'm sorry - is the one were expecting

669
00:33:55,009 --> 00:34:00,289
one we think might not be allowed in

670
00:33:57,259 --> 00:34:01,849
pngs but we don't know and then we

671
00:34:00,289 --> 00:34:05,180
actually have to implement this loop

672
00:34:01,849 --> 00:34:07,459
right so we needed a literal length

673
00:34:05,180 --> 00:34:12,950
value from the input stream and we don't

674
00:34:07,460 --> 00:34:14,960
know how to get that right now right so

675
00:34:12,949 --> 00:34:19,969
we're gonna get that this is probably a

676
00:34:14,960 --> 00:34:23,418
Huffman decode here right then we look

677
00:34:19,969 --> 00:34:27,230
to see what the value that we get out is

678
00:34:23,418 --> 00:34:30,230
if it's less than 256 we copy a literal

679
00:34:27,230 --> 00:34:35,300
byte to the output stream so basically

680
00:34:30,230 --> 00:34:37,699
what that's saying is if we if we read a

681
00:34:35,300 --> 00:34:40,129
Huffman code and that Huffman code has a

682
00:34:37,699 --> 00:34:42,230
value less than 256 it's actually

683
00:34:40,128 --> 00:34:45,589
putting new data that we've never seen

684
00:34:42,230 --> 00:34:48,110
before into the output stream but if

685
00:34:45,590 --> 00:34:50,329
it's greater than 256 or greater than

686
00:34:48,110 --> 00:34:53,090
equal to 56 then we're gonna assume that

687
00:34:50,329 --> 00:34:55,069
it's actually an LZ jump back

688
00:34:53,090 --> 00:34:56,750
information now let me because people

689
00:34:55,070 --> 00:34:58,250
may not have done LZ before let me just

690
00:34:56,750 --> 00:35:01,219
explain how these work they're very

691
00:34:58,250 --> 00:35:04,159
simple but they form the cornerstone of

692
00:35:01,219 --> 00:35:07,599
like call modern compression anyway even

693
00:35:04,159 --> 00:35:07,599
though they're very very basic

694
00:35:28,519 --> 00:35:33,050
so things that conform to LZ style

695
00:35:30,679 --> 00:35:35,329
compression are really very simple in

696
00:35:33,050 --> 00:35:37,940
theory the way that they work is they

697
00:35:35,329 --> 00:35:41,420
basically say look we know that you've

698
00:35:37,940 --> 00:35:43,880
got some data that you're trying to

699
00:35:41,420 --> 00:35:46,039
compress so when you get to the

700
00:35:43,880 --> 00:35:49,789
decompression stage of things you've

701
00:35:46,039 --> 00:35:52,909
basically got a big buffer where you're

702
00:35:49,789 --> 00:35:54,110
gonna store the output right and this

703
00:35:52,909 --> 00:35:55,759
was back in the days when streaming

704
00:35:54,110 --> 00:35:57,860
might've been a thing too so the output

705
00:35:55,760 --> 00:36:00,290
buffer itself can actually be a rolling

706
00:35:57,860 --> 00:36:03,140
window potentially but in almost all

707
00:36:00,289 --> 00:36:05,059
cases nowadays it's not we're literally

708
00:36:03,139 --> 00:36:06,619
talking about the whole data that we're

709
00:36:05,059 --> 00:36:08,210
about to get but this works for

710
00:36:06,619 --> 00:36:09,469
streaming too you just have a limp less

711
00:36:08,210 --> 00:36:11,869
of a look-back this is where they look

712
00:36:09,469 --> 00:36:12,949
back window stuff comes in but anyway we

713
00:36:11,869 --> 00:36:14,809
have an output buffer that's going to

714
00:36:12,949 --> 00:36:16,730
hold the thing so in our case right this

715
00:36:14,809 --> 00:36:19,519
is an image we're trying to like output

716
00:36:16,730 --> 00:36:21,889
this image right so what's gonna happen

717
00:36:19,519 --> 00:36:24,559
is the decompressor is gonna want

718
00:36:21,889 --> 00:36:26,539
information about what it's writing in

719
00:36:24,559 --> 00:36:28,400
here four pixels right that's what it's

720
00:36:26,539 --> 00:36:30,469
trying to do or if it was compressing

721
00:36:28,400 --> 00:36:31,820
something else doesn't matter what it is

722
00:36:30,469 --> 00:36:34,339
it's just going to write into this

723
00:36:31,820 --> 00:36:40,720
output buffer what LZ style compressors

724
00:36:34,340 --> 00:36:48,670
do is they say let's have two modes one

725
00:36:40,719 --> 00:36:48,669
is put new data in to the buffer and

726
00:36:50,139 --> 00:36:58,929
another is copy old data into the buffer

727
00:36:59,349 --> 00:37:05,360
right so these are the two things we

728
00:37:02,300 --> 00:37:07,490
might want to do in an LZ style

729
00:37:05,360 --> 00:37:09,110
compressor and so what they have is they

730
00:37:07,489 --> 00:37:10,969
have a stream of data that says which

731
00:37:09,110 --> 00:37:12,710
one of these things to do am I gonna put

732
00:37:10,969 --> 00:37:14,869
new data into the buffer or make a copy

733
00:37:12,710 --> 00:37:17,900
old data into the buffer if it's one

734
00:37:14,869 --> 00:37:20,659
then what I'll you know imagine a stream

735
00:37:17,900 --> 00:37:23,750
that actually had this if it's one right

736
00:37:20,659 --> 00:37:27,589
if my mode thing says mode one then here

737
00:37:23,750 --> 00:37:30,710
is what's called a literal which just

738
00:37:27,590 --> 00:37:33,200
means some new data right literal is

739
00:37:30,710 --> 00:37:35,179
just a fancy way of saying put some new

740
00:37:33,199 --> 00:37:40,000
data in because hey it's literally this

741
00:37:35,179 --> 00:37:40,000
data so the stream this is the stream of

742
00:37:41,230 --> 00:37:52,090
the input stream to the decompressor has

743
00:37:49,210 --> 00:37:54,010
the mode value followed by the data to

744
00:37:52,090 --> 00:37:55,660
put in there right so in the case of

745
00:37:54,010 --> 00:37:58,300
mode 1 it's just some data this data

746
00:37:55,659 --> 00:38:00,039
just gets copied right BAM wherever

747
00:37:58,300 --> 00:38:02,260
we're writing to it just gets copied

748
00:38:00,039 --> 00:38:03,519
right and we advance the pointer so now

749
00:38:02,260 --> 00:38:06,670
we're writing here right as we're

750
00:38:03,519 --> 00:38:08,530
writing again if on the other hand we

751
00:38:06,670 --> 00:38:10,840
see a 2 right so maybe after this

752
00:38:08,530 --> 00:38:14,440
there's a - there's a twos the Nexen

753
00:38:10,840 --> 00:38:17,740
stream then what we have is two pieces

754
00:38:14,440 --> 00:38:20,409
of data that follow the - which is the

755
00:38:17,739 --> 00:38:23,829
distance it doesn't have to be in this

756
00:38:20,409 --> 00:38:28,599
order the distance and the size right

757
00:38:23,829 --> 00:38:32,170
now in this case the size may or may not

758
00:38:28,599 --> 00:38:33,819
be specified so if it just is a fixed

759
00:38:32,170 --> 00:38:34,659
like you could have an LC compressed or

760
00:38:33,820 --> 00:38:37,090
set of fixed size

761
00:38:34,659 --> 00:38:38,469
it's a byte let's say is all we do so we

762
00:38:37,090 --> 00:38:40,210
output 1 byte whenever I'm putting a

763
00:38:38,469 --> 00:38:41,980
literal sometimes that's true or we

764
00:38:40,210 --> 00:38:43,869
could have like a there could have been

765
00:38:41,980 --> 00:38:46,690
a sizer that says how big the literal is

766
00:38:43,869 --> 00:38:48,340
that depends on which LZ variant you're

767
00:38:46,690 --> 00:38:50,530
using and it just depends on which gives

768
00:38:48,340 --> 00:38:52,900
you better compression right but either

769
00:38:50,530 --> 00:38:55,570
way it's a literal in this case same

770
00:38:52,900 --> 00:38:57,970
thing we could just say that the size is

771
00:38:55,570 --> 00:38:59,380
always the same but usually the size has

772
00:38:57,969 --> 00:39:01,599
to be specified here in order for good

773
00:38:59,380 --> 00:39:03,700
compression so usually when you do copy

774
00:39:01,599 --> 00:39:06,549
old data you specify two things the

775
00:39:03,699 --> 00:39:09,849
distance and the size right and the

776
00:39:06,550 --> 00:39:13,420
distance says how far from where I'm at

777
00:39:09,849 --> 00:39:16,269
how far back into the buffer should I go

778
00:39:13,420 --> 00:39:22,690
to grab the thing that I will then copy

779
00:39:16,269 --> 00:39:24,340
and put here right and so what this is

780
00:39:22,690 --> 00:39:31,570
the reason this is often called

781
00:39:24,340 --> 00:39:33,670
dictionary compression is because it

782
00:39:31,570 --> 00:39:36,880
effectively treats the output that

783
00:39:33,670 --> 00:39:38,710
you've done so far as a dictionary that

784
00:39:36,880 --> 00:39:41,440
you can look up into and grab whole

785
00:39:38,710 --> 00:39:43,210
sections to specify new pieces of the

786
00:39:41,440 --> 00:39:47,200
stream that are not new at all they're

787
00:39:43,210 --> 00:39:50,440
actually old so that's why this kind of

788
00:39:47,199 --> 00:39:53,349
compressor excels on things like large

789
00:39:50,440 --> 00:39:55,179
sections of similar data because it can

790
00:39:53,349 --> 00:39:56,828
just grab old piece

791
00:39:55,179 --> 00:39:59,679
is where it was already specified and

792
00:39:56,829 --> 00:40:09,339
copy it down so for example you know

793
00:39:59,679 --> 00:40:11,769
large runs of the same pattern very good

794
00:40:09,338 --> 00:40:13,449
right so checkerboard or anything like

795
00:40:11,769 --> 00:40:16,500
that you can just grab whole sections

796
00:40:13,449 --> 00:40:20,279
and move it in lots of little gradient

797
00:40:16,500 --> 00:40:22,568
modifying like crazy patterns tie-dye

798
00:40:20,280 --> 00:40:25,210
really bad because there's nowhere to

799
00:40:22,568 --> 00:40:27,400
grab to do it right and so that's why

800
00:40:25,210 --> 00:40:29,470
PNG is very good at compressing some

801
00:40:27,400 --> 00:40:32,019
data and very bad at compressing others

802
00:40:29,469 --> 00:40:34,179
is just because look Dictionary style

803
00:40:32,019 --> 00:40:36,759
compression at the end of the day cannot

804
00:40:34,179 --> 00:40:38,828
do any sorts of fanciness to try and

805
00:40:36,760 --> 00:40:40,960
compress the data if it's not self

806
00:40:38,829 --> 00:40:42,849
similar so it better be somewhat self

807
00:40:40,960 --> 00:40:44,380
similar going into it and by the way we

808
00:40:42,849 --> 00:40:46,630
can apply some transforms to try and

809
00:40:44,380 --> 00:40:48,068
help it be self similar but if we can't

810
00:40:46,630 --> 00:40:50,108
find a transform that makes it more self

811
00:40:48,068 --> 00:40:51,219
similar it's in the PNG spec well then

812
00:40:50,108 --> 00:40:53,049
we're just dead in the water and the

813
00:40:51,219 --> 00:40:56,649
file be huge that's just how it goes

814
00:40:53,050 --> 00:40:58,000
right now one thing that's worth

815
00:40:56,650 --> 00:41:00,010
mentioning with LZ compressors is

816
00:40:58,000 --> 00:41:01,900
there's the hidden ability to do RLE in

817
00:41:00,010 --> 00:41:05,280
here so you know about hourly

818
00:41:01,900 --> 00:41:05,280
compressors right run length encoding

819
00:41:07,019 --> 00:41:12,219
well run length encoding is basically

820
00:41:09,338 --> 00:41:14,949
poor-man's LZ right because run length

821
00:41:12,219 --> 00:41:17,259
encoding says look I'm gonna either I'm

822
00:41:14,949 --> 00:41:19,689
gonna have to same two modes right and

823
00:41:17,260 --> 00:41:24,819
you project this before one is literal

824
00:41:19,690 --> 00:41:26,470
and two is repeat and repeat we'll give

825
00:41:24,818 --> 00:41:29,909
some fixed length thing like a byte and

826
00:41:26,469 --> 00:41:33,098
just say do this byte 500 times right

827
00:41:29,909 --> 00:41:37,899
so what you may ask is is it possible

828
00:41:33,099 --> 00:41:40,660
for the LZ stream to do a repeat because

829
00:41:37,900 --> 00:41:43,358
otherwise RLE is actually better for

830
00:41:40,659 --> 00:41:45,730
some things kind of right well the

831
00:41:43,358 --> 00:41:47,980
answer is yes it is first of all there's

832
00:41:45,730 --> 00:41:50,230
one way it could do a repeat which is

833
00:41:47,980 --> 00:41:51,849
straightforward and if you think about

834
00:41:50,230 --> 00:41:53,949
it you can see that it's not as

835
00:41:51,849 --> 00:41:57,309
efficient as orally that way is well

836
00:41:53,949 --> 00:41:58,899
look I output one literal okay then I

837
00:41:57,309 --> 00:42:01,660
output a second literal of the same kind

838
00:41:58,900 --> 00:42:04,660
now I've got to then I reference the two

839
00:42:01,659 --> 00:42:09,279
to create for right then I reference the

840
00:42:04,659 --> 00:42:11,319
four to create eight right and

841
00:42:09,280 --> 00:42:12,910
you build it up by powers of two so that

842
00:42:11,320 --> 00:42:15,130
would give you a login way of specifying

843
00:42:12,909 --> 00:42:17,469
it but remember our le was able to do it

844
00:42:15,130 --> 00:42:19,390
in one so the question is can we do

845
00:42:17,469 --> 00:42:21,339
better than that and the answer is by

846
00:42:19,389 --> 00:42:25,449
coding the LZ style decompressor

847
00:42:21,340 --> 00:42:30,910
correctly yes you can what you do is you

848
00:42:25,449 --> 00:42:34,019
specify one literal right and then the

849
00:42:30,909 --> 00:42:38,259
next thing you specify is a distance

850
00:42:34,019 --> 00:42:41,259
right to that literal and a size that

851
00:42:38,260 --> 00:42:43,480
actually would have right past where the

852
00:42:41,260 --> 00:42:45,700
cursor currently is so here's the output

853
00:42:43,480 --> 00:42:48,099
cursor right I've read from the input

854
00:42:45,699 --> 00:42:50,829
stream it says go back one and get this

855
00:42:48,099 --> 00:42:53,860
thing right this piece of data then I

856
00:42:50,829 --> 00:42:56,049
put in a size that's one that's that's

857
00:42:53,860 --> 00:42:58,120
my repeat count so literally the repeat

858
00:42:56,050 --> 00:43:00,160
if there Pete was 60,000 I just put

859
00:42:58,119 --> 00:43:02,889
60,000 and it's like well how are you

860
00:43:00,159 --> 00:43:05,469
gonna copy 60,000 there's only one thing

861
00:43:02,889 --> 00:43:05,980
to copy well as long as you copy a bite

862
00:43:05,469 --> 00:43:08,859
at a time

863
00:43:05,980 --> 00:43:11,650
it just works because I copy this byte

864
00:43:08,860 --> 00:43:13,750
into the output position now I move my

865
00:43:11,650 --> 00:43:16,630
copy pointer forward one and what's

866
00:43:13,750 --> 00:43:18,670
there a copy of the byte beforehand so

867
00:43:16,630 --> 00:43:21,190
it copies into the next one right and

868
00:43:18,670 --> 00:43:23,200
that copies into the next one and so it

869
00:43:21,190 --> 00:43:27,220
cascades forward and effectively does

870
00:43:23,199 --> 00:43:33,549
the RLE for you right so it turns out in

871
00:43:27,219 --> 00:43:36,879
just one mode two instruction I can

872
00:43:33,550 --> 00:43:38,980
actually RLE data as well because as

873
00:43:36,880 --> 00:43:42,430
long as I've outputted anywhere in my

874
00:43:38,980 --> 00:43:44,650
back buffer one copy of that thing well

875
00:43:42,429 --> 00:43:47,230
actually that's not true I have to do it

876
00:43:44,650 --> 00:43:49,960
does cost me one literal right I have to

877
00:43:47,230 --> 00:43:52,269
it has to be outputted it has to be

878
00:43:49,960 --> 00:43:55,780
output right at the cursor right it

879
00:43:52,269 --> 00:43:58,329
can't be somewhere else but as long as I

880
00:43:55,780 --> 00:44:02,310
put one literal in then I can specify a

881
00:43:58,329 --> 00:44:02,309
whole run that goes as long as I want

882
00:44:02,909 --> 00:44:08,829
okay so that's just the basics of LZ

883
00:44:05,949 --> 00:44:11,439
it's really just the same as RLE but

884
00:44:08,829 --> 00:44:13,750
instead of always specifying the thing

885
00:44:11,440 --> 00:44:16,389
to repeat like you wouldn't orally you

886
00:44:13,750 --> 00:44:18,579
specify a pointer into the back data to

887
00:44:16,389 --> 00:44:20,440
use it's literally that simple there's

888
00:44:18,579 --> 00:44:22,650
nothing more to it so if you've ever

889
00:44:20,440 --> 00:44:24,559
done orally you've basically done LZ

890
00:44:22,650 --> 00:44:26,789
it's that simple the decoding anyway and

891
00:44:24,559 --> 00:44:28,920
coding as always is really complicated

892
00:44:26,789 --> 00:44:31,019
because you have to start thinking about

893
00:44:28,920 --> 00:44:32,610
what the best way to encode something is

894
00:44:31,019 --> 00:44:33,869
and that involves all these trade-offs

895
00:44:32,610 --> 00:44:35,099
should I put this should I be Bachelor

896
00:44:33,869 --> 00:44:38,250
repeat here should I not repeat here

897
00:44:35,099 --> 00:44:40,619
right and so that's a whole nother can

898
00:44:38,250 --> 00:44:42,389
of worms but for the time being we only

899
00:44:40,619 --> 00:44:43,500
have to write the compressor so we don't

900
00:44:42,389 --> 00:44:47,190
have to care about that we just get the

901
00:44:43,500 --> 00:44:49,440
easy part anyway so we're expecting to

902
00:44:47,190 --> 00:44:51,179
decode something here with the Huffman

903
00:44:49,440 --> 00:44:54,030
table and then we're expected to look at

904
00:44:51,179 --> 00:44:55,829
it and see what it equals so we're

905
00:44:54,030 --> 00:44:58,050
staying basically if it's less than 56

906
00:44:55,829 --> 00:44:59,880
we do one thing if it's greater we do

907
00:44:58,050 --> 00:45:01,620
another so if it's less than 3 6 we're

908
00:44:59,880 --> 00:45:03,809
supposed to copy a literal byte to the

909
00:45:01,619 --> 00:45:06,289
output stream right so what that

910
00:45:03,809 --> 00:45:11,159
suggests to me is we basically say okay

911
00:45:06,289 --> 00:45:19,309
our output is 8 bits that we're going to

912
00:45:11,159 --> 00:45:19,309
write to our out pointer and so you know

913
00:45:19,880 --> 00:45:27,990
we write something there and then

914
00:45:22,710 --> 00:45:31,110
otherwise we've got this sort of we've

915
00:45:27,989 --> 00:45:32,909
got this loop to do here and I'm not

916
00:45:31,110 --> 00:45:36,059
sure I understand exactly the transit if

917
00:45:32,909 --> 00:45:38,159
the value equals the end of block but I

918
00:45:36,059 --> 00:45:41,940
don't know what that means break from

919
00:45:38,159 --> 00:45:44,839
loop otherwise do some stuff here and so

920
00:45:41,940 --> 00:45:44,840
I'm guessing

921
00:46:08,269 --> 00:46:23,000
so I'm guessing what it's basically

922
00:46:11,338 --> 00:46:23,000
saying is actually this that this

923
00:46:29,880 --> 00:46:34,369
I'm guessing it's basically saying this

924
00:46:44,420 --> 00:46:48,329
it seems to me like they're basically

925
00:46:46,650 --> 00:46:48,869
saying look if it's less than six you do

926
00:46:48,329 --> 00:46:50,130
one thing

927
00:46:48,869 --> 00:47:02,969
it's grating 306 you do another thing

928
00:46:50,130 --> 00:47:06,170
otherwise that's the end of it right put

929
00:47:02,969 --> 00:47:06,169
that slightly the wrong place there

930
00:47:07,099 --> 00:47:12,750
that's what looks like to me so that's

931
00:47:10,710 --> 00:47:15,030
what I'm going with so then what we're

932
00:47:12,750 --> 00:47:17,039
gonna say here is like okay

933
00:47:15,030 --> 00:47:19,140
decode the distance value from the input

934
00:47:17,039 --> 00:47:23,639
stream so that's basically saying here

935
00:47:19,139 --> 00:47:26,069
look we we've got the the length out of

936
00:47:23,639 --> 00:47:30,480
the Huffman decode but now we need to

937
00:47:26,070 --> 00:47:34,350
get now we need to get the the distance

938
00:47:30,480 --> 00:47:35,730
that that look back value right

939
00:47:34,349 --> 00:47:37,739
and then move back or just byte in the

940
00:47:35,730 --> 00:47:39,389
output and copy length bytes from this

941
00:47:37,739 --> 00:47:43,669
position to the output stream so then

942
00:47:39,389 --> 00:47:43,670
we're just gonna go like this right

943
00:47:55,809 --> 00:48:09,259
the only thing I don't understand here

944
00:47:57,860 --> 00:48:12,829
is the length the length value

945
00:48:09,260 --> 00:48:20,870
presumably isn't like you would subtract

946
00:48:12,829 --> 00:48:29,989
256 from first wouldn't you look I'm

947
00:48:20,869 --> 00:48:30,469
assuming that little in here no no no

948
00:48:29,989 --> 00:48:34,989
okay

949
00:48:30,469 --> 00:48:34,989
so this year is actually that right

950
00:48:36,219 --> 00:48:41,059
little n presumably wants to have two

951
00:48:39,170 --> 00:48:43,369
and a 56 subtracted from it here

952
00:48:41,059 --> 00:48:45,199
I would think right so I would assume

953
00:48:43,369 --> 00:48:47,179
even though it doesn't look like this

954
00:48:45,199 --> 00:48:52,000
from the pseudocode I would assume that

955
00:48:47,179 --> 00:48:52,000
this is actually what you want right

956
00:48:53,320 --> 00:49:00,440
because you don't want the minimum copy

957
00:48:56,480 --> 00:49:02,960
size to be 256 so in order to get a copy

958
00:49:00,440 --> 00:49:06,200
size of 1 2 3 4 5 which we might want

959
00:49:02,960 --> 00:49:09,079
you're gonna have to subtract from it

960
00:49:06,199 --> 00:49:13,129
right so presumably we do a Huffman

961
00:49:09,079 --> 00:49:16,519
decode on the distance and then we do

962
00:49:13,130 --> 00:49:19,130
with the copy right we do the subtract

963
00:49:16,519 --> 00:49:21,769
distance and then the copy so to do the

964
00:49:19,130 --> 00:49:25,070
copy all we really have to do here again

965
00:49:21,769 --> 00:49:37,429
is just well you know we'll deal with

966
00:49:25,070 --> 00:49:39,080
writing later and I think that's it so

967
00:49:37,429 --> 00:49:41,269
mostly what I want to know here is is

968
00:49:39,079 --> 00:49:43,519
that correct and then how do we do to

969
00:49:41,269 --> 00:49:46,159
the Huffman to code right we also need

970
00:49:43,519 --> 00:49:48,559
to know how many bits these are so let's

971
00:49:46,159 --> 00:49:51,319
take a look so here's a non compressed

972
00:49:48,559 --> 00:49:52,880
block be type 0 any bits of input up to

973
00:49:51,320 --> 00:49:53,900
the next byte don't ignore it the rest

974
00:49:52,880 --> 00:49:57,860
of the block assists the flaw

975
00:49:53,900 --> 00:50:00,320
information and Len and Len Len bytes of

976
00:49:57,860 --> 00:50:02,150
literal data Len is the number of data

977
00:50:00,320 --> 00:50:04,990
bytes in the block and Len is the ones

978
00:50:02,150 --> 00:50:04,990
compliment

979
00:50:05,170 --> 00:50:29,068
what why so that that's just for safety

980
00:50:20,768 --> 00:50:32,368
sake or something that I don't

981
00:50:29,068 --> 00:50:32,369
understand at all

982
00:50:36,389 --> 00:51:09,578
so it sounds like emmalin is literally

983
00:50:40,210 --> 00:51:11,380
useless I mean we can do this because if

984
00:51:09,579 --> 00:51:14,920
it's the ones complement which is you

985
00:51:11,380 --> 00:51:16,420
know not at least if I understand

986
00:51:14,920 --> 00:51:18,009
correctly what they're trying to say

987
00:51:16,420 --> 00:51:22,930
there I assume that that means it's the

988
00:51:18,009 --> 00:51:25,480
knotted value maybe I don't understand

989
00:51:22,929 --> 00:51:29,379
what they're talking about anyway so I

990
00:51:25,480 --> 00:51:30,789
think that's what they mean really

991
00:51:29,380 --> 00:51:32,440
couldn't tell you

992
00:51:30,789 --> 00:51:34,089
so that's looks like what they're doing

993
00:51:32,440 --> 00:51:36,250
there let's see here for compressed

994
00:51:34,088 --> 00:51:37,929
blocks as noted above the coded data

995
00:51:36,250 --> 00:51:39,969
blocks then deflate form ecstasy cos the

996
00:51:37,929 --> 00:51:42,250
symbols drawn from three conceptually

997
00:51:39,969 --> 00:51:45,328
distinct alphabets either literal bytes

998
00:51:42,250 --> 00:51:48,940
from the alphabet of byte values or

999
00:51:45,329 --> 00:51:51,369
lengths backward distance pairs where

1000
00:51:48,940 --> 00:51:56,019
the length is drawn from 3 to 258 and

1001
00:51:51,369 --> 00:51:57,700
the distance is drawn from 1 to 32 768

1002
00:51:56,018 --> 00:52:00,969
in fact the literal of length outputs

1003
00:51:57,699 --> 00:52:04,419
are merged into a single alphabet 0 to

1004
00:52:00,969 --> 00:52:06,489
285 where values 0 to 25 represent

1005
00:52:04,420 --> 00:52:08,798
little bites the value to these 6

1006
00:52:06,489 --> 00:52:10,709
indicates end of block and values 27th

1007
00:52:08,798 --> 00:52:13,690
to the 8th represent length codes

1008
00:52:10,710 --> 00:52:18,460
possibly in conjunction with extra bits

1009
00:52:13,690 --> 00:52:20,608
following the symbol code as follows so

1010
00:52:18,460 --> 00:52:20,608
okay

1011
00:52:32,159 --> 00:52:38,379
hmm the extra bit should be interpreted

1012
00:52:36,969 --> 00:52:42,278
as a machine integers start with the

1013
00:52:38,380 --> 00:52:50,259
most significant bit first bits 1 1 1 0

1014
00:52:42,278 --> 00:52:59,349
represent the value 14 okay so to b7 to

1015
00:52:50,259 --> 00:53:03,210
285 there's all so are they saying this

1016
00:52:59,349 --> 00:53:03,210
is literally just hard coded

1017
00:53:21,590 --> 00:53:25,430
it sure seems that way

1018
00:53:39,789 --> 00:53:43,599
it says the extra bit should be

1019
00:53:41,800 --> 00:53:45,160
interpreted as a machine integers store

1020
00:53:43,599 --> 00:53:46,929
with mr. surrett right I don't know what

1021
00:53:45,159 --> 00:53:49,420
that actually has to do with anything

1022
00:53:46,929 --> 00:53:51,879
but I guess they're trying to say

1023
00:53:49,420 --> 00:53:55,570
because you're talking about more bits

1024
00:53:51,880 --> 00:53:57,930
that are in the stream but just looking

1025
00:53:55,570 --> 00:53:57,930
at this

1026
00:54:13,349 --> 00:54:22,199
so basically they're just saying look we

1027
00:54:16,528 --> 00:54:24,088
have a number from zero to 285 that

1028
00:54:22,199 --> 00:54:28,349
gives you the base value and then we

1029
00:54:24,088 --> 00:54:31,199
grab some extra bits depending on what

1030
00:54:28,349 --> 00:54:34,289
the value is so it's sort of like we

1031
00:54:31,199 --> 00:54:36,900
manually made the huffman table so this

1032
00:54:34,289 --> 00:54:40,109
is not an arbitrary Huffman D code it's

1033
00:54:36,900 --> 00:54:46,108
like a fixed Huffman table we just say

1034
00:54:40,108 --> 00:54:48,838
we use always right and you're just

1035
00:54:46,108 --> 00:54:51,048
suspected to just decode it exactly this

1036
00:54:48,838 --> 00:54:51,048
way

1037
00:54:51,588 --> 00:54:55,548
what is this table

1038
00:54:58,920 --> 00:55:11,608
this is just I don't know what this

1039
00:55:08,280 --> 00:55:14,609
table is supposed to be oh this is for

1040
00:55:11,608 --> 00:55:18,630
the distance so the distance is just 0

1041
00:55:14,608 --> 00:55:21,838
to 29 and then you can have more extra

1042
00:55:18,630 --> 00:55:34,890
bits encoded there so yeah it looks like

1043
00:55:21,838 --> 00:55:39,719
basically the Huffman it looks like the

1044
00:55:34,889 --> 00:55:44,219
Huffman code is always just for the for

1045
00:55:39,719 --> 00:55:47,189
the for the distance in length it's

1046
00:55:44,219 --> 00:55:49,789
always these no matter what even if it's

1047
00:55:47,190 --> 00:55:49,789
dynamic

1048
00:56:01,889 --> 00:56:12,849
okay that's not know so here it says so

1049
00:56:11,650 --> 00:56:16,690
I don't really understand why this is

1050
00:56:12,849 --> 00:56:19,529
written this way here's a bunch of stuff

1051
00:56:16,690 --> 00:56:24,039
that talks about how you would represent

1052
00:56:19,530 --> 00:56:28,119
the length and distance codes right and

1053
00:56:24,039 --> 00:56:30,849
this is basically a fixed decoding it's

1054
00:56:28,119 --> 00:56:33,250
saying here's how to code it but then it

1055
00:56:30,849 --> 00:56:34,809
goes on to say well if you're

1056
00:56:33,250 --> 00:56:37,210
compressing with dynamic Huffman codes

1057
00:56:34,809 --> 00:56:39,610
which is be type 10 which I thought is

1058
00:56:37,210 --> 00:56:40,539
what we were going to be doing the

1059
00:56:39,610 --> 00:56:42,220
huffing codes to the two alphabets

1060
00:56:40,539 --> 00:56:43,690
appear in the block immediately after

1061
00:56:42,219 --> 00:56:45,368
the header bits and before the actual

1062
00:56:43,690 --> 00:56:48,990
compressed data first the literal length

1063
00:56:45,369 --> 00:56:48,990
code and then the distance code

1064
00:57:02,519 --> 00:57:09,869
so it sounds to me like this is just not

1065
00:57:05,639 --> 00:57:12,000
relevant but yet this was defined in a

1066
00:57:09,869 --> 00:57:17,670
section that made it sound like it would

1067
00:57:12,000 --> 00:57:20,670
always do it so I'm not really sure what

1068
00:57:17,670 --> 00:57:23,329
they mean do they mean to say that you

1069
00:57:20,670 --> 00:57:27,809
will always apply this Huffman

1070
00:57:23,329 --> 00:57:37,199
effectively after applying the dynamic

1071
00:57:27,809 --> 00:57:46,949
Huffman that you apply first I really

1072
00:57:37,199 --> 00:57:54,389
couldn't tell you that seems a little

1073
00:57:46,949 --> 00:57:57,239
odd but that seems sort of like what

1074
00:57:54,389 --> 00:57:58,710
they're saying I'm gonna go ahead and

1075
00:57:57,239 --> 00:58:02,459
start investigating that a little bit

1076
00:57:58,710 --> 00:58:03,869
more so if I want to consume bits at a

1077
00:58:02,460 --> 00:58:06,420
time here

1078
00:58:03,869 --> 00:58:09,840
I'm gonna actually do a thing that lets

1079
00:58:06,420 --> 00:58:12,720
me do that so what I want to do is I'm

1080
00:58:09,840 --> 00:58:17,760
gonna go ahead and put a little like

1081
00:58:12,719 --> 00:58:26,489
side path into my consumer thing here

1082
00:58:17,760 --> 00:58:28,470
that lets me consume bits and that way I

1083
00:58:26,489 --> 00:58:30,329
can just see what some of this data is

1084
00:58:28,469 --> 00:58:32,368
because that's just weird

1085
00:58:30,329 --> 00:58:35,730
I don't really understand why they if if

1086
00:58:32,369 --> 00:58:40,400
that was like that's just a really weird

1087
00:58:35,730 --> 00:58:40,400
way for them to describe that

1088
00:58:45,400 --> 00:58:49,568
so let's take a look at that and I'm

1089
00:58:48,219 --> 00:58:53,669
just going to implement these functions

1090
00:58:49,568 --> 00:58:53,670
here so we have to we have consume bits

1091
00:58:57,630 --> 00:59:03,298
why is it my beef final settable there

1092
00:59:00,849 --> 00:59:03,298
what did I do

1093
00:59:32,710 --> 00:59:36,349
all right so we have two functions we

1094
00:59:34,909 --> 01:00:08,509
need to do we need consume bits and

1095
00:59:36,349 --> 01:00:09,500
flush byte at the moment and I'm just

1096
01:00:08,510 --> 01:00:11,450
going to assume that we're not going to

1097
01:00:09,500 --> 01:00:16,818
do anything bigger than a 32-bit thing

1098
01:00:11,449 --> 01:00:18,409
here and that's all I'm gonna support so

1099
01:00:16,818 --> 01:00:20,929
what I want to do here is just say

1100
01:00:18,409 --> 01:00:24,460
alright my streaming buffer is gonna

1101
01:00:20,929 --> 01:00:24,460
have a little thing in it that's like

1102
01:00:28,630 --> 01:00:32,720
maybe something like this not

1103
01:00:31,159 --> 01:00:34,068
particularly good again these are not I

1104
01:00:32,719 --> 01:00:35,480
would not recommend implementing things

1105
01:00:34,068 --> 01:00:37,730
the way I'm doing them here these are

1106
01:00:35,480 --> 01:00:41,179
just for my convenience for getting the

1107
01:00:37,730 --> 01:00:43,039
file parsed if you wanted something fast

1108
01:00:41,179 --> 01:00:45,798
you probably would be thinking along

1109
01:00:43,039 --> 01:00:47,960
very different lines anyways so what I

1110
01:00:45,798 --> 01:00:49,219
want to be able to do here is I want to

1111
01:00:47,960 --> 01:00:52,099
be able to implement these two functions

1112
01:00:49,219 --> 01:00:53,209
in terms of consuming bits what I need

1113
01:00:52,099 --> 01:00:56,180
to do is make sure that I have enough

1114
01:00:53,210 --> 01:00:58,818
bits in my bit buffer basically is what

1115
01:00:56,179 --> 01:01:05,149
I'm trying to do here so what I want to

1116
01:00:58,818 --> 01:01:10,429
do is say alright let's do this what I

1117
01:01:05,150 --> 01:01:13,250
want to do here is say okay if the the

1118
01:01:10,429 --> 01:01:14,769
bit count in my bit buffer is greater

1119
01:01:13,250 --> 01:01:17,510
than equal to the bit count you want

1120
01:01:14,769 --> 01:01:23,588
then I'm gonna be okay I can just

1121
01:01:17,510 --> 01:01:26,329
subtract the bits away from there and

1122
01:01:23,588 --> 01:01:28,519
give you back the bits that I've got

1123
01:01:26,329 --> 01:01:29,269
right that's going to be pretty easy so

1124
01:01:28,519 --> 01:01:47,840
I'll just have a

1125
01:01:29,269 --> 01:01:49,519
here and I guess what I want to do so if

1126
01:01:47,840 --> 01:01:52,820
the buffers bit count is greater than

1127
01:01:49,519 --> 01:01:55,789
equal to the bit count then I'm going to

1128
01:01:52,820 --> 01:02:00,410
subtract the bit count away and I need

1129
01:01:55,789 --> 01:02:08,779
to copy the VAT amount of bits into what

1130
01:02:00,409 --> 01:02:10,429
I'm what I'm returning as the result so

1131
01:02:08,780 --> 01:02:13,460
what I want to do here is I want to copy

1132
01:02:10,429 --> 01:02:16,489
I want to give the results I want it to

1133
01:02:13,460 --> 01:02:18,349
be whatever the bit buffer is obviously

1134
01:02:16,489 --> 01:02:20,029
I'm just gonna make it give the low bits

1135
01:02:18,349 --> 01:02:22,549
right so I'm going to shift in bits at

1136
01:02:20,030 --> 01:02:28,010
the top so I want to give it that many

1137
01:02:22,550 --> 01:02:29,570
bits back I don't I assume these so I

1138
01:02:28,010 --> 01:02:33,010
guess I don't know what order the bits

1139
01:02:29,570 --> 01:02:33,010
are going in and here is the only thing

1140
01:03:00,719 --> 01:03:04,869
increasing bit number within the bite

1141
01:03:03,369 --> 01:03:08,019
are you starting with the least

1142
01:03:04,869 --> 01:03:11,229
significant bit of the byte so I think

1143
01:03:08,018 --> 01:03:13,748
we're just fine so what I want to do is

1144
01:03:11,228 --> 01:03:17,399
I want to take the bit buffer and I want

1145
01:03:13,748 --> 01:03:24,218
to mask off any part of it that's not

1146
01:03:17,400 --> 01:03:26,349
actually requested here so basically if

1147
01:03:24,219 --> 01:03:28,719
you only wanted four bits but there's

1148
01:03:26,349 --> 01:03:32,048
eight bits in the pit buffer I want to

1149
01:03:28,719 --> 01:03:34,869
just give you back that smaller portion

1150
01:03:32,048 --> 01:03:40,018
right so what I want to do is say well

1151
01:03:34,869 --> 01:03:43,170
you asked for this many bits right so

1152
01:03:40,018 --> 01:03:46,629
let's say you asked for only one bit

1153
01:03:43,170 --> 01:03:49,599
then what I want to do is mask off only

1154
01:03:46,630 --> 01:03:55,778
that section so what I could do is I can

1155
01:03:49,599 --> 01:03:56,798
do this right I can shift up whatever

1156
01:03:55,778 --> 01:03:59,798
you asked for the bit count let's say

1157
01:03:56,798 --> 01:04:02,288
yes for one or two I can shift a one up

1158
01:03:59,798 --> 01:04:05,259
that many places which puts the one in

1159
01:04:02,289 --> 01:04:07,839
the next slot the next bit over from the

1160
01:04:05,259 --> 01:04:09,728
last highest bit you requested right

1161
01:04:07,838 --> 01:04:11,369
from the highest bit you requested I can

1162
01:04:09,728 --> 01:04:14,768
subtract one for it which will make

1163
01:04:11,369 --> 01:04:16,539
fffff be all the way on the bottom so if

1164
01:04:14,768 --> 01:04:18,879
I and with that I'll get rid of

1165
01:04:16,539 --> 01:04:21,939
everything on the top that wasn't that

1166
01:04:18,880 --> 01:04:29,559
that that you don't want right and then

1167
01:04:21,938 --> 01:04:32,139
I can shift down the bit buffer by it by

1168
01:04:29,559 --> 01:04:36,989
that many bits right so however any bits

1169
01:04:32,139 --> 01:04:36,989
you read I'll get rid of that many right

1170
01:04:37,228 --> 01:04:49,958
so again this is the same situation as

1171
01:04:40,329 --> 01:04:51,400
before if for some reason I can't read

1172
01:04:49,958 --> 01:04:54,578
that many bits I'm gonna treat that as

1173
01:04:51,400 --> 01:04:55,900
an underflow well in fact you know what

1174
01:04:54,579 --> 01:05:00,599
I don't really need to do that because

1175
01:04:55,900 --> 01:05:03,249
I'm gonna call that function anyway and

1176
01:05:00,599 --> 01:05:07,179
so yeah I guess we don't really need to

1177
01:05:03,248 --> 01:05:09,188
worry about that so what I want to do

1178
01:05:07,179 --> 01:05:10,719
now is say well array what happens if

1179
01:05:09,188 --> 01:05:13,000
the bit count wouldn't have been

1180
01:05:10,719 --> 01:05:16,539
sufficient

1181
01:05:13,000 --> 01:05:18,550
so the bit amount of bits I have in the

1182
01:05:16,539 --> 01:05:20,829
buffer is not going to be enough right

1183
01:05:18,550 --> 01:05:25,359
what I want to do is I want to consume

1184
01:05:20,829 --> 01:05:29,559
as many bytes as necessary to get me to

1185
01:05:25,358 --> 01:05:33,130
the right bit number right so what I can

1186
01:05:29,559 --> 01:05:34,840
do here is I could do a while loop but I

1187
01:05:33,130 --> 01:05:37,180
don't think I really want to because I

1188
01:05:34,840 --> 01:05:41,410
know that my bit count doesn't really go

1189
01:05:37,179 --> 01:05:46,509
above 16 in this case actually so I can

1190
01:05:41,409 --> 01:05:54,339
just use two cases probably or I could

1191
01:05:46,510 --> 01:05:56,200
just always shift in I could always just

1192
01:05:54,340 --> 01:05:59,559
shift 16 in because if you're less than

1193
01:05:56,199 --> 01:06:07,779
16 and I know I can shift in 16 so I'm

1194
01:05:59,559 --> 01:06:11,199
not sure yeah maybe I'll do this and

1195
01:06:07,780 --> 01:06:19,420
I'll just say well let's just assume

1196
01:06:11,199 --> 01:06:21,579
gives less than 16 right something like

1197
01:06:19,420 --> 01:06:23,260
that so assuming that the bit count is

1198
01:06:21,579 --> 01:06:30,900
less than equals 16 then what I want to

1199
01:06:23,260 --> 01:06:35,650
do is I want to shift in the I want to

1200
01:06:30,900 --> 01:06:37,838
grab from the data stream the new bits

1201
01:06:35,650 --> 01:06:41,920
that I'm going to actually process as we

1202
01:06:37,838 --> 01:06:44,139
go forward right and so what I want to

1203
01:06:41,920 --> 01:06:45,880
do is I want to grab those bits and I

1204
01:06:44,139 --> 01:06:47,858
said I don't really know about the least

1205
01:06:45,880 --> 01:06:49,119
significant most significant part of

1206
01:06:47,858 --> 01:06:50,529
this so we're gonna have to see if I'm

1207
01:06:49,119 --> 01:06:54,460
getting the data correctly here we'll

1208
01:06:50,530 --> 01:07:00,359
find out as we go but what I want to do

1209
01:06:54,460 --> 01:07:02,949
is I want to grab the values from the

1210
01:07:00,358 --> 01:07:08,049
from the buffer that I'm trying to

1211
01:07:02,949 --> 01:07:09,579
consume here I want to kind of go right

1212
01:07:08,050 --> 01:07:12,700
and I think I want to go bleh time so

1213
01:07:09,579 --> 01:07:16,319
actually you know what I'm gonna do I'm

1214
01:07:12,699 --> 01:07:16,319
us to do this the pickiest way possible

1215
01:07:24,460 --> 01:07:29,240
so I'm just gonna keep going here and

1216
01:07:27,230 --> 01:07:31,760
I'm gonna say well I can't do it I'm

1217
01:07:29,239 --> 01:07:36,798
gonna start shifting stuff in so I'm

1218
01:07:31,760 --> 01:07:40,010
just gonna say that you know I've got a

1219
01:07:36,798 --> 01:07:45,639
you wait here that's my my bite I'm

1220
01:07:40,010 --> 01:07:49,789
gonna consume one you ate worth of data

1221
01:07:45,639 --> 01:07:52,009
from the buffer and I'm gonna go ahead

1222
01:07:49,789 --> 01:08:00,950
and pack that bite into the correct

1223
01:07:52,010 --> 01:08:04,278
location in the stream so I'm gonna say

1224
01:08:00,949 --> 01:08:06,379
I've got eight more bites right and I

1225
01:08:04,278 --> 01:08:10,068
guess before I do that I want to or in

1226
01:08:06,380 --> 01:08:12,289
this piece of information so that bite

1227
01:08:10,068 --> 01:08:16,548
I'm gonna well you know what I can do

1228
01:08:12,289 --> 01:08:24,679
this so that bite I can shift up by the

1229
01:08:16,548 --> 01:08:26,630
current bit counts and or it in so that

1230
01:08:24,679 --> 01:08:29,210
should allow me to read from the stream

1231
01:08:26,630 --> 01:08:31,789
and pack in exactly as many as as what's

1232
01:08:29,210 --> 01:08:34,880
requested when I go to flush the bite

1233
01:08:31,789 --> 01:08:36,738
that's really simple if flushing a bite

1234
01:08:34,880 --> 01:08:40,390
is just saying look the bit count is now

1235
01:08:36,738 --> 01:08:43,988
zero and the bit buff has nothing in it

1236
01:08:40,390 --> 01:08:47,960
right so that's really pretty trivial

1237
01:08:43,988 --> 01:08:49,968
and I think that's mostly all I need now

1238
01:08:47,960 --> 01:08:51,170
there's probably bugs in there cuz like

1239
01:08:49,969 --> 01:08:53,509
I said and I don't really know for

1240
01:08:51,170 --> 01:08:55,789
tripping spec correctly there so we'll

1241
01:08:53,509 --> 01:08:57,529
see what happens but that's mostly what

1242
01:08:55,789 --> 01:08:59,899
we want so let's just take a look at

1243
01:08:57,529 --> 01:09:02,929
what's going on here so if I want to

1244
01:08:59,899 --> 01:09:06,318
consume one bit from the data stream

1245
01:09:02,929 --> 01:09:08,270
oops I accidentally deleted the B final

1246
01:09:06,319 --> 01:09:14,690
there when I was copying it I still do

1247
01:09:08,270 --> 01:09:19,699
want to set B final so when I want to

1248
01:09:14,689 --> 01:09:21,528
consume one bit let's go in here

1249
01:09:19,698 --> 01:09:23,298
the buffer bit count should be zero in

1250
01:09:21,529 --> 01:09:26,270
the bit count is one so what I want to

1251
01:09:23,298 --> 01:09:28,338
do is read one byte and then what I want

1252
01:09:26,270 --> 01:09:30,359
to do is order that in so it should just

1253
01:09:28,338 --> 01:09:32,939
be equal to the byte now it should just

1254
01:09:30,359 --> 01:09:36,210
2:36 and it is and our bit counter now

1255
01:09:32,939 --> 01:09:37,919
v8 so now I should be able to read it

1256
01:09:36,210 --> 01:09:40,710
the bit count should go down by one to

1257
01:09:37,920 --> 01:09:43,500
seven the result should just be whatever

1258
01:09:40,710 --> 01:09:45,480
the bottom bit is and I think this was a

1259
01:09:43,500 --> 01:09:51,270
even value so the bottom bit must be

1260
01:09:45,479 --> 01:09:53,608
zero right yeah I think that's right and

1261
01:09:51,270 --> 01:09:56,489
so then we just say okay and now we're

1262
01:09:53,609 --> 01:09:59,460
gonna shift it down and process the the

1263
01:09:56,488 --> 01:10:01,769
new value right so I think we're good

1264
01:09:59,460 --> 01:10:03,480
so that just grabs a bit there is my bit

1265
01:10:01,770 --> 01:10:05,190
it's zero which is what we would expect

1266
01:10:03,479 --> 01:10:08,309
cuz this is probably not the last block

1267
01:10:05,189 --> 01:10:09,539
then we need to consume two bits so

1268
01:10:08,310 --> 01:10:11,489
let's take a look at what happens there

1269
01:10:09,539 --> 01:10:13,889
in here we should be fine because we

1270
01:10:11,488 --> 01:10:15,988
consumed a whole byte last time so here

1271
01:10:13,889 --> 01:10:18,329
we say alright as if we're okay

1272
01:10:15,988 --> 01:10:19,678
let's see what the bit count is now well

1273
01:10:18,329 --> 01:10:22,019
the bit count is going to go down again

1274
01:10:19,679 --> 01:10:24,380
it's gonna go into five yep so now let's

1275
01:10:22,020 --> 01:10:27,030
see what our result is a result is two

1276
01:10:24,380 --> 01:10:28,920
hey look that's exactly what we thought

1277
01:10:27,029 --> 01:10:30,899
it should be so we need to read the

1278
01:10:28,920 --> 01:10:35,359
hoffman codes which we're not currently

1279
01:10:30,899 --> 01:10:38,399
doing and then we would keep going right

1280
01:10:35,359 --> 01:10:39,960
so I think we're sort of starting to get

1281
01:10:38,399 --> 01:10:42,089
the hang of it here we're just getting

1282
01:10:39,960 --> 01:10:43,920
to get our minds in the space of the

1283
01:10:42,090 --> 01:10:46,230
pink spec now you know like I said

1284
01:10:43,920 --> 01:10:51,630
there's a long way to go so maybe not

1285
01:10:46,229 --> 01:10:56,158
but we haven't completely been sort of

1286
01:10:51,630 --> 01:10:58,529
confused yet we'll get there

1287
01:10:56,158 --> 01:11:00,509
so when we we do need to read the huff

1288
01:10:58,529 --> 01:11:02,340
and stuff I correctly guessed that it

1289
01:11:00,510 --> 01:11:04,409
would be that type so I think we're

1290
01:11:02,340 --> 01:11:05,699
reading the spec right there so we want

1291
01:11:04,408 --> 01:11:08,879
to look and see what it says about

1292
01:11:05,698 --> 01:11:10,469
reading that data in it was really

1293
01:11:08,880 --> 01:11:13,489
obtuse if I remember correctly the way

1294
01:11:10,469 --> 01:11:13,489
it said it but let's see

1295
01:11:19,770 --> 01:11:22,929
here we go

1296
01:11:21,158 --> 01:11:25,029
the Hoffman codes for the two alphabets

1297
01:11:22,929 --> 01:11:26,649
appear in the block immediately after

1298
01:11:25,029 --> 01:11:28,658
the header bits before the extra

1299
01:11:26,649 --> 01:11:31,210
compressed data first the literal length

1300
01:11:28,658 --> 01:11:32,769
code and then the distance code each

1301
01:11:31,210 --> 01:11:34,448
code is defined by sequence of code

1302
01:11:32,770 --> 01:11:37,870
lengths as discussed in paragraph 3 2 2

1303
01:11:34,448 --> 01:11:39,339
above for even greater compactness the

1304
01:11:37,869 --> 01:11:43,019
code length sequences themselves are

1305
01:11:39,340 --> 01:11:43,020
compressed using a Huffman code

1306
01:11:55,250 --> 01:12:02,340
so it looks like it's just saying use

1307
01:11:58,289 --> 01:12:04,140
this ridiculous nonsense to decrypt what

1308
01:12:02,340 --> 01:12:05,909
we're telling you a code length of zero

1309
01:12:04,140 --> 01:12:07,050
indicates that the corresponding symbol

1310
01:12:05,909 --> 01:12:09,960
in the literal length or distance

1311
01:12:07,050 --> 01:12:11,550
alphabet will not occur in the block and

1312
01:12:09,960 --> 01:12:13,230
should not participate in the Huffman

1313
01:12:11,550 --> 01:12:15,119
code instruction Agra m-- earlier if

1314
01:12:13,229 --> 01:12:17,909
only one distance code is used it is

1315
01:12:15,119 --> 01:12:20,519
encoded using one bit not zero bits in

1316
01:12:17,909 --> 01:12:22,739
this case where it is a single code

1317
01:12:20,520 --> 01:12:24,690
length of one with one unused code the

1318
01:12:22,739 --> 01:12:26,369
distance code of zero bits means that

1319
01:12:24,689 --> 01:12:28,319
there are no distance codes used at all

1320
01:12:26,369 --> 01:12:34,079
we can now define the format of the

1321
01:12:28,319 --> 01:12:36,539
block so there's 5 bits of each lit five

1322
01:12:34,079 --> 01:12:40,399
bits of H dist

1323
01:12:36,539 --> 01:12:40,399
four bits of H Glen

1324
01:12:57,760 --> 01:13:00,869
this is nuts

1325
01:13:03,349 --> 01:13:07,069
this is one of the things where I guess

1326
01:13:05,118 --> 01:13:08,719
they kept tweaking it they were getting

1327
01:13:07,069 --> 01:13:13,058
better compression or something from it

1328
01:13:08,719 --> 01:13:13,059
so you see a lot of this weirdness here

1329
01:13:13,090 --> 01:13:51,878
alright well let's start reading it so

1330
01:13:17,538 --> 01:13:51,878
let's read H lit first H dist n H clay

1331
01:13:53,948 --> 01:13:59,799
so these say the number of literal codes

1332
01:13:56,800 --> 01:14:02,289
- 257 the number of distance codes - 1

1333
01:13:59,800 --> 01:14:04,150
and the number of code lengths - 4 so

1334
01:14:02,289 --> 01:14:06,488
what we want to do to get those to their

1335
01:14:04,149 --> 01:14:13,710
actual values is we want to basically

1336
01:14:06,488 --> 01:14:25,928
say add in the coupe's the 257 add in

1337
01:14:13,710 --> 01:14:29,789
the 1 and add in the 4 we then say

1338
01:14:25,929 --> 01:14:33,600
h.glenn + 4 times 3 bits worth of data

1339
01:14:29,789 --> 01:14:33,600
for the code lengths

1340
01:14:43,389 --> 01:14:49,460
so I think that's just saying we're

1341
01:14:46,130 --> 01:14:51,230
gonna do a loop of h.glenn +4 which I'm

1342
01:14:49,460 --> 01:14:52,489
assuming they actually don't mean

1343
01:14:51,229 --> 01:14:55,339
h.glenn +4

1344
01:14:52,488 --> 01:14:57,468
after adjusted they that's the plus 4

1345
01:14:55,340 --> 01:15:02,809
that we already did so we're gonna read

1346
01:14:57,469 --> 01:15:06,139
3 bits that many times right then we're

1347
01:15:02,809 --> 01:15:09,739
gonna read H lit + 287 which we or again

1348
01:15:06,139 --> 01:15:16,460
already did that many read that many

1349
01:15:09,738 --> 01:15:24,279
read that many right all right so that

1350
01:15:16,460 --> 01:15:24,279
means we start here and we read 2h lit

1351
01:15:29,349 --> 01:15:36,730
like so and what I want to do here is I

1352
01:15:32,929 --> 01:15:36,730
want to consume 3 bits for each of these

1353
01:15:41,948 --> 01:15:48,198
and what that is is the code lengths for

1354
01:15:44,899 --> 01:15:49,009
the code length alphabet which is this

1355
01:15:48,198 --> 01:15:55,969
thing up here

1356
01:15:49,010 --> 01:15:59,119
I guess the lip so code length alphabet

1357
01:15:55,969 --> 01:16:08,529
given just above even the order 16 17 18

1358
01:15:59,118 --> 01:16:08,529
0 8 7 9 6 10 5 11 for 12 3 13 to 14 1 15

1359
01:16:14,130 --> 01:16:20,650
why would it be in that order if this

1360
01:16:17,738 --> 01:16:23,709
data isn't itself compressed why would

1361
01:16:20,649 --> 01:16:26,009
they give it in an arbitrary order

1362
01:16:23,710 --> 01:16:26,010
though

1363
01:16:46,310 --> 01:16:50,380
that's a doozy

1364
01:17:01,310 --> 01:17:18,240
I'm not sure I understand why you would

1365
01:17:04,350 --> 01:17:26,760
like arbitrarily muck with the order if

1366
01:17:18,239 --> 01:17:34,619
I'm reading that right I mean that's

1367
01:17:26,760 --> 01:17:44,220
what we're saying are we I mean is that

1368
01:17:34,619 --> 01:17:50,119
really what we're saying maybe they mean

1369
01:17:44,220 --> 01:17:50,119
something else with that the code links

1370
01:17:52,039 --> 01:17:56,460
our interpreters three bit integers

1371
01:17:54,710 --> 01:18:02,750
equivalent to zero means the

1372
01:17:56,460 --> 01:18:02,750
corresponding symbol it's not used

1373
01:18:05,090 --> 01:18:09,349
I feel like there's no reason for these

1374
01:18:07,550 --> 01:18:12,409
specs to be this obtuse it should just

1375
01:18:09,349 --> 01:18:15,230
be straightforward to explain I don't

1376
01:18:12,408 --> 01:18:17,539
understand this but I guess people don't

1377
01:18:15,229 --> 01:18:18,888
know how to explain things usually the

1378
01:18:17,539 --> 01:18:21,079
Huffman coach the two alphas appear on

1379
01:18:18,889 --> 01:18:22,639
the block immediately after header first

1380
01:18:21,079 --> 01:18:24,829
the literal length code and then the

1381
01:18:22,639 --> 01:18:26,449
distance code each code is defined by

1382
01:18:24,829 --> 01:18:34,539
sequence of code lengths as discussed in

1383
01:18:26,448 --> 01:18:34,539
paragraph 3 2 2 which is this nonsense

1384
01:18:40,380 --> 01:18:44,159
so all we need is the bit links which is

1385
01:18:42,479 --> 01:18:46,949
what we're saying here right we're just

1386
01:18:44,159 --> 01:18:48,930
providing how many bits per thing there

1387
01:18:46,949 --> 01:18:54,329
are right and then we're gonna run this

1388
01:18:48,930 --> 01:18:59,550
constructor on it which seems fine right

1389
01:18:54,329 --> 01:19:00,840
that all makes reasonable sense for even

1390
01:18:59,550 --> 01:19:02,279
going to compacts the code looks suits

1391
01:19:00,840 --> 01:19:04,680
themselves are compressed using admin

1392
01:19:02,279 --> 01:19:08,069
code the alphabet for codes lengths is

1393
01:19:04,680 --> 01:19:11,670
as follows 0 to 15 represent code like 0

1394
01:19:08,069 --> 01:19:15,989
to 15 16 is copy the previous code

1395
01:19:11,670 --> 01:19:23,300
length some number of times right 17 is

1396
01:19:15,989 --> 01:19:23,300
this 18 is that so that's fine

1397
01:19:44,529 --> 01:19:48,800
yeah I just can't quite figure that out

1398
01:19:46,850 --> 01:19:54,710
that the Swizzle thing I just don't get

1399
01:19:48,800 --> 01:20:13,429
16 17 18 0 8 7 9 6 10 5 11 for 12 313

1400
01:19:54,710 --> 01:20:15,109
214 115 so if those okay all right you

1401
01:20:13,429 --> 01:20:15,800
know what I do think I know why they're

1402
01:20:15,109 --> 01:20:21,019
doing that

1403
01:20:15,800 --> 01:20:23,779
so h.glenn probably tries to compress

1404
01:20:21,020 --> 01:20:28,040
how many of the litter of these it

1405
01:20:23,779 --> 01:20:29,630
actually stores by packing in this order

1406
01:20:28,039 --> 01:20:32,719
because they think that if they pack

1407
01:20:29,630 --> 01:20:35,090
them in that order oftentimes this is

1408
01:20:32,719 --> 01:20:39,710
the order that makes it so that you can

1409
01:20:35,090 --> 01:20:42,829
use the repeat codes maximally like 16

1410
01:20:39,710 --> 01:20:47,389
17 and 18 tend to be specified the same

1411
01:20:42,829 --> 01:20:58,069
way so we put them in there usually are

1412
01:20:47,389 --> 01:21:05,300
but yeah okay man oh man all right if

1413
01:20:58,069 --> 01:21:08,059
that's do you want man so all right

1414
01:21:05,300 --> 01:21:10,639
let's see how this needs to be specified

1415
01:21:08,060 --> 01:21:12,679
then because the h.glenn the h.glenn

1416
01:21:10,639 --> 01:21:16,150
is actually telling me how many of the

1417
01:21:12,679 --> 01:21:18,770
things i use pre like when i'm reading

1418
01:21:16,149 --> 01:21:25,549
all right so when i read one of these

1419
01:21:18,770 --> 01:21:27,320
things i know that the so the thing that

1420
01:21:25,550 --> 01:21:28,880
i understand was that the h i was

1421
01:21:27,319 --> 01:21:30,559
assuming like okay you've probably

1422
01:21:28,880 --> 01:21:32,480
specify all of them they don't want to

1423
01:21:30,560 --> 01:21:33,949
actually even specify all of these

1424
01:21:32,479 --> 01:21:36,319
they're trying to compress it below that

1425
01:21:33,948 --> 01:21:38,388
amount so I guess what they're saying is

1426
01:21:36,319 --> 01:21:40,549
like okay the h.glenn will probably

1427
01:21:38,389 --> 01:21:46,000
hopefully most of the time be less than

1428
01:21:40,550 --> 01:21:46,000
that so I mean I can also do this

1429
01:21:56,889 --> 01:22:05,429
I don't know why said H lip there

1430
01:22:01,289 --> 01:22:11,439
Swiss Paige clan so anyway now I say

1431
01:22:05,429 --> 01:22:16,929
read the 33 bit integer right and the

1432
01:22:11,439 --> 01:22:21,819
three bit integer is this thing so this

1433
01:22:16,929 --> 01:22:23,679
is like an encoded length and then I

1434
01:22:21,819 --> 01:22:25,809
want to say like okay if the encoded

1435
01:22:23,679 --> 01:22:28,210
length it's greater than equal to zero I

1436
01:22:25,810 --> 01:22:39,880
don't really do that if it's just less

1437
01:22:28,210 --> 01:22:52,300
than or equal to 15 else if it's 16 17

1438
01:22:39,880 --> 01:23:02,099
or 18 I'm just going to print that out

1439
01:22:52,300 --> 01:23:02,099
and say we're in a bad state right so

1440
01:23:07,248 --> 01:23:23,668
if it's 0 to 15 we just use it right if

1441
01:23:20,219 --> 01:23:25,498
it's 16 we copy whatever the code length

1442
01:23:23,668 --> 01:23:27,448
is we use last time between three and

1443
01:23:25,498 --> 01:23:31,228
six times and the next two bits indicate

1444
01:23:27,448 --> 01:23:40,288
repeat length now what I don't

1445
01:23:31,229 --> 01:23:42,958
understand is are you saying to actually

1446
01:23:40,288 --> 01:23:46,399
use that now or are you saying that will

1447
01:23:42,958 --> 01:23:46,399
come later right

1448
01:23:59,630 --> 01:24:07,469
because if that's the case then that

1449
01:24:01,889 --> 01:24:09,750
means that this actually gets read in

1450
01:24:07,469 --> 01:24:12,719
between the reads for these which it

1451
01:24:09,750 --> 01:24:14,579
doesn't specify here and I'm not sure if

1452
01:24:12,719 --> 01:24:17,520
that's what they mean the next two bits

1453
01:24:14,579 --> 01:24:19,600
indicate the repeat length right there

1454
01:24:17,520 --> 01:24:22,729
it is

1455
01:24:19,600 --> 01:24:22,729
[Music]

1456
01:24:43,779 --> 01:24:48,079
yes so I'm obviously not understanding

1457
01:24:46,220 --> 01:24:50,449
this correctly because let's say you

1458
01:24:48,079 --> 01:24:53,840
were gonna actually implement this right

1459
01:24:50,449 --> 01:24:56,599
off the bat so they must mean after this

1460
01:24:53,840 --> 01:24:58,520
I don't know about the in I so I still

1461
01:24:56,600 --> 01:25:00,620
don't know why this this order would

1462
01:24:58,520 --> 01:25:03,260
make any sense because if you're gonna

1463
01:25:00,619 --> 01:25:08,779
read all of these in why would you care

1464
01:25:03,260 --> 01:25:13,780
what order they were in right why would

1465
01:25:08,779 --> 01:25:13,779
you care to Swizzle them like that

1466
01:25:24,750 --> 01:25:28,470
I just can't get past that if thrown me

1467
01:25:27,149 --> 01:25:30,599
for a loop because I don't understand

1468
01:25:28,470 --> 01:25:31,590
why we need to switch lit each Lippo

1469
01:25:30,600 --> 01:25:33,870
students code likes a little a

1470
01:25:31,590 --> 01:25:40,829
alphabetically those both makes sense to

1471
01:25:33,869 --> 01:25:42,750
me so I feel like there's just there's

1472
01:25:40,829 --> 01:25:44,460
just one thing I'm missing in this steps

1473
01:25:42,750 --> 01:25:46,920
that I don't understand I don't

1474
01:25:44,460 --> 01:25:49,850
understand this swizzle table I just

1475
01:25:46,920 --> 01:25:55,560
don't understand where it where it goes

1476
01:25:49,850 --> 01:26:02,460
what it's whistling but it seems to me

1477
01:25:55,560 --> 01:26:08,220
like I would want to do when we encode

1478
01:26:02,460 --> 01:26:11,520
this stuff here I you know I've read H

1479
01:26:08,220 --> 01:26:13,680
seal and it can only be 16 plus 4 so it

1480
01:26:11,520 --> 01:26:24,390
can only be like 20 or whatever right I

1481
01:26:13,680 --> 01:26:35,400
mean it can't be you can't exceed 20 so

1482
01:26:24,390 --> 01:26:38,160
you know we know that effectively it

1483
01:26:35,399 --> 01:26:41,789
just I don't know seems like they're

1484
01:26:38,159 --> 01:26:45,359
telling me to do this and that those are

1485
01:26:41,789 --> 01:26:50,630
gonna go directly in there and then

1486
01:26:45,359 --> 01:26:52,889
after that we'll be the Decrypter for

1487
01:26:50,630 --> 01:26:55,650
decrypter zip I know the Romberg do you

1488
01:26:52,890 --> 01:26:57,000
compress our quote-unquote these guys

1489
01:26:55,649 --> 01:26:59,420
will definitely go through the other

1490
01:26:57,000 --> 01:26:59,420
code

1491
01:27:23,760 --> 01:27:29,310
the cool negatives can cross from each

1492
01:27:25,829 --> 01:27:31,109
lips into the H just +1 code links in

1493
01:27:29,310 --> 01:27:36,060
other words all code links for a single

1494
01:27:31,109 --> 01:27:37,920
sequence of H lit plus h2 plus okay so

1495
01:27:36,060 --> 01:27:41,160
the other thing it's telling me here is

1496
01:27:37,920 --> 01:27:42,720
that we just have one Huffman table well

1497
01:27:41,159 --> 01:27:44,970
and that one half a table we just have a

1498
01:27:42,720 --> 01:27:47,880
1 decompression block that we're

1499
01:27:44,970 --> 01:27:52,530
basically doing here which is whatever

1500
01:27:47,880 --> 01:27:58,529
this thing is so I also know that I've

1501
01:27:52,529 --> 01:28:01,259
got like my I don't you want to call

1502
01:27:58,529 --> 01:28:06,779
this my lend table or whatever and that

1503
01:28:01,260 --> 01:28:12,030
thing is going to be at a maximum it's

1504
01:28:06,779 --> 01:28:14,550
like so 64 so you know that that thing

1505
01:28:12,029 --> 01:28:16,409
can't be bigger than like 512 or

1506
01:28:14,550 --> 01:28:19,340
whatever right

1507
01:28:16,409 --> 01:28:23,789
so when I come in here I know that I can

1508
01:28:19,340 --> 01:28:26,819
use like when I start decompressing

1509
01:28:23,789 --> 01:28:29,399
these I don't actually have to treat

1510
01:28:26,819 --> 01:28:33,569
these two things separately I can just

1511
01:28:29,399 --> 01:28:39,359
say look the total number of things in

1512
01:28:33,569 --> 01:28:44,549
the length table is just going to be

1513
01:28:39,359 --> 01:28:47,279
equal to the H lit plus the H disc and I

1514
01:28:44,550 --> 01:28:53,820
can do them the whole I can do the whole

1515
01:28:47,279 --> 01:28:55,590
thing so that's nice there's just one

1516
01:28:53,819 --> 01:28:59,039
decompressor that just does the

1517
01:28:55,590 --> 01:29:05,819
decompression directly and that's you

1518
01:28:59,039 --> 01:29:10,229
know way better right so since these are

1519
01:29:05,819 --> 01:29:13,529
all done with the Huffman code and again

1520
01:29:10,229 --> 01:29:16,769
I'm just not sure how this part boils

1521
01:29:13,529 --> 01:29:26,238
down here the alphabet for code lengths

1522
01:29:16,770 --> 01:29:30,260
is this but then I don't really know

1523
01:29:26,238 --> 01:29:30,259
what this tells me

1524
01:29:36,979 --> 01:29:44,429
yes I do okay so what this tells well

1525
01:29:42,390 --> 01:29:45,900
you know what no I still don't because I

1526
01:29:44,430 --> 01:29:47,579
still don't know why you need to swizzle

1527
01:29:45,899 --> 01:29:49,049
it why can't you just put them in the

1528
01:29:47,579 --> 01:29:52,199
order zero one two three four five six

1529
01:29:49,050 --> 01:29:53,430
seven eight nine ten right so even the

1530
01:29:52,199 --> 01:29:55,529
thing that I just thought I was like

1531
01:29:53,430 --> 01:29:58,100
okay no I see what I still don't I still

1532
01:29:55,529 --> 01:29:58,099
just can't see it

1533
01:30:08,329 --> 01:30:11,850
because it looks like they're always

1534
01:30:10,260 --> 01:30:12,960
storing three bits for each one of them

1535
01:30:11,850 --> 01:30:14,340
so if you're always gonna start three

1536
01:30:12,960 --> 01:30:17,630
bits for each one of them then why would

1537
01:30:14,340 --> 01:30:17,630
you ever need to do anything different I

1538
01:30:19,819 --> 01:30:23,719
just can't get past it

1539
01:30:29,069 --> 01:30:54,210
I got nothing everything else in here

1540
01:30:52,529 --> 01:31:00,750
seems to make sense to me but that one I

1541
01:30:54,210 --> 01:31:03,210
just can't figure out why would you

1542
01:31:00,750 --> 01:31:11,250
specify a swizzle table for data that

1543
01:31:03,210 --> 01:31:23,069
you weren't compressing why would you

1544
01:31:11,250 --> 01:31:24,380
ever care what order it was in I've got

1545
01:31:23,069 --> 01:31:27,389
to be missing something

1546
01:31:24,380 --> 01:31:32,699
they must be compressing it or something

1547
01:31:27,389 --> 01:31:39,750
because if you're not compressing it why

1548
01:31:32,698 --> 01:31:43,649
would u s-- whistle it what am I not

1549
01:31:39,750 --> 01:31:44,849
thinking of I can stare at this 1,500

1550
01:31:43,649 --> 01:31:46,979
times but I'm just not say anything

1551
01:31:44,849 --> 01:31:50,489
different it says right here it reads

1552
01:31:46,979 --> 01:31:52,468
three bits for each of these but if it's

1553
01:31:50,488 --> 01:31:54,539
reading three bits for each of them why

1554
01:31:52,469 --> 01:31:56,460
would it maybe it's talking about this

1555
01:31:54,539 --> 01:31:58,880
order as being applied somewhere else

1556
01:31:56,460 --> 01:31:58,880
actually

1557
01:32:04,750 --> 01:32:18,670
or maybe they just Swiss 'old it just

1558
01:32:07,810 --> 01:32:20,530
cuz I don't know I have no idea I mean

1559
01:32:18,670 --> 01:32:28,869
it looks to me like this is what's going

1560
01:32:20,529 --> 01:32:32,380
on right that's what it looks like the

1561
01:32:28,869 --> 01:32:35,710
spec says what is this doing here it

1562
01:32:32,380 --> 01:32:47,079
doesn't do anything right I mean there's

1563
01:32:35,710 --> 01:32:54,310
no point to that look I just don't see I

1564
01:32:47,079 --> 01:32:57,699
don't see how that gets me anything so

1565
01:32:54,310 --> 01:32:59,530
you know we get in here and you know

1566
01:32:57,699 --> 01:33:05,829
assuming that we interpret the rest of

1567
01:32:59,529 --> 01:33:16,050
this correctly here's what we ended up

1568
01:33:05,829 --> 01:33:20,590
with h.glenn specified up I got it I

1569
01:33:16,050 --> 01:33:23,170
finally got it it's because if you

1570
01:33:20,590 --> 01:33:25,300
weren't going to specify all of them

1571
01:33:23,170 --> 01:33:30,869
these are the ones they think you're

1572
01:33:25,300 --> 01:33:35,079
least likely to specify okay so you are

1573
01:33:30,869 --> 01:33:37,029
compressing the lengths some times which

1574
01:33:35,079 --> 01:33:40,869
is to say you're going to truncate them

1575
01:33:37,029 --> 01:33:43,719
right so maybe I only specify up to

1576
01:33:40,869 --> 01:33:46,239
there well if I only specify up to there

1577
01:33:43,720 --> 01:33:50,670
their pre saying the most likely things

1578
01:33:46,239 --> 01:33:50,670
I need to specify are like 16 17 and 18

1579
01:33:52,680 --> 01:33:55,680
okay

1580
01:33:58,390 --> 01:34:02,470
so that's why they okay so that's what

1581
01:34:01,779 --> 01:34:04,229
it's there for

1582
01:34:02,470 --> 01:34:06,100
I should have thought of that before

1583
01:34:04,229 --> 01:34:07,539
makes perfect sense

1584
01:34:06,100 --> 01:34:10,000
it's just saying look we're gonna

1585
01:34:07,539 --> 01:34:13,479
truncate these sometimes here's what

1586
01:34:10,000 --> 01:34:16,229
happens when we truncate did I do

1587
01:34:13,479 --> 01:34:16,229
something wrong here

1588
01:34:16,300 --> 01:34:26,260
so this fills in all the lengths and

1589
01:34:20,819 --> 01:34:35,679
that's fine so we get to here and here

1590
01:34:26,260 --> 01:34:39,039
are our code lengths right for this for

1591
01:34:35,680 --> 01:34:46,000
the for the length compression and

1592
01:34:39,039 --> 01:34:48,729
that's all good and hey 18 is all of

1593
01:34:46,000 --> 01:34:53,920
them one two three four five six seven

1594
01:34:48,729 --> 01:34:58,769
eight nine 10 11 12 13 14 15 16 17 18

1595
01:34:53,920 --> 01:34:58,770
oh wait no it's not

1596
01:35:05,488 --> 01:35:09,738
but 15 did get filled in

1597
01:35:17,010 --> 01:35:25,389
mmm

1598
01:35:18,238 --> 01:35:29,769
it just happened so when did 15 get

1599
01:35:25,389 --> 01:35:30,969
filled in oh that's a Swizzle there we

1600
01:35:29,770 --> 01:35:34,960
go

1601
01:35:30,969 --> 01:35:45,210
so 18 is missing 1 so 15 just doesn't

1602
01:35:34,960 --> 01:35:45,210
get specified can I see this table

1603
01:36:02,868 --> 01:36:07,250
oh of course it won't show me the table

1604
01:36:05,300 --> 01:36:10,099
anymore because it is exited the scope

1605
01:36:07,250 --> 01:36:14,238
Thank You Visual Studio worst feature

1606
01:36:10,099 --> 01:36:20,020
ever all right well anyway I'm satisfied

1607
01:36:14,238 --> 01:36:25,250
now that I was worried that helps me not

1608
01:36:20,020 --> 01:36:27,380
freak out about that I'm okay with that

1609
01:36:25,250 --> 01:36:28,670
so all right so that's all fine so

1610
01:36:27,380 --> 01:36:30,289
that's just telling us what the

1611
01:36:28,670 --> 01:36:33,529
truncated that some of the values are

1612
01:36:30,289 --> 01:36:35,929
might be truncated so I'm cool with that

1613
01:36:33,529 --> 01:36:38,029
now code nicely above code not given in

1614
01:36:35,929 --> 01:36:39,618
this order fine the code lecture trooper

1615
01:36:38,029 --> 01:36:41,210
does three bit integer zero to seven as

1616
01:36:39,618 --> 01:36:43,098
above a code becomes zero means a

1617
01:36:41,210 --> 01:36:45,319
cursing sindelle symbol literal length

1618
01:36:43,099 --> 01:36:47,779
or just the code is not used so

1619
01:36:45,319 --> 01:36:51,279
basically if you read a zero it's not if

1620
01:36:47,779 --> 01:36:55,009
we don't have all of them I'm not sure

1621
01:36:51,279 --> 01:36:57,050
what that would mean I assume it's just

1622
01:36:55,010 --> 01:36:58,820
a zero so it just means like we never

1623
01:36:57,050 --> 01:37:02,599
used one of those lengths or something

1624
01:36:58,819 --> 01:37:04,099
like that right okay so what we need to

1625
01:37:02,599 --> 01:37:05,929
do now is we need to write the thing

1626
01:37:04,099 --> 01:37:07,429
that builds a Huffman table out of one

1627
01:37:05,929 --> 01:37:09,170
of those because all the rest of these

1628
01:37:07,429 --> 01:37:11,960
are going to come from that Huffman

1629
01:37:09,170 --> 01:37:14,389
table right so what we need to do here

1630
01:37:11,960 --> 01:37:18,050
is we need to have something that can

1631
01:37:14,389 --> 01:37:21,469
take the h.glenn table that we read and

1632
01:37:18,050 --> 01:37:25,579
turn it into a Huffman decoder in some

1633
01:37:21,469 --> 01:37:34,908
way right this could really be phrased

1634
01:37:25,579 --> 01:37:39,649
like this because we know that's how

1635
01:37:34,908 --> 01:37:42,589
many we're going to have right so then

1636
01:37:39,649 --> 01:37:53,299
what I want to do say all right let's

1637
01:37:42,590 --> 01:37:56,420
produce or I don't know we want to

1638
01:37:53,300 --> 01:37:59,510
create the Huffman table here so we need

1639
01:37:56,420 --> 01:38:03,020
some way of making one of these so we

1640
01:37:59,510 --> 01:38:05,360
need like a PNG Huffman and this is our

1641
01:38:03,020 --> 01:38:10,060
length Huffman or this is a sorry this

1642
01:38:05,359 --> 01:38:10,059
is our dictionary Huffman

1643
01:38:10,969 --> 01:38:16,559
so we need some way of creating one of

1644
01:38:13,349 --> 01:38:20,460
these up in tables from one of these

1645
01:38:16,559 --> 01:38:23,579
length codes right and so we know that

1646
01:38:20,460 --> 01:38:27,538
this is the length codes that we have we

1647
01:38:23,578 --> 01:38:29,969
know that well I guess I don't know

1648
01:38:27,538 --> 01:38:34,078
exactly what they want they may want

1649
01:38:29,969 --> 01:38:38,698
this or they may want h.glenn I'm not

1650
01:38:34,078 --> 01:38:40,979
sure I'm not 100% clear on that aspect

1651
01:38:38,698 --> 01:38:43,738
of it actually so we'll talk about that

1652
01:38:40,979 --> 01:38:45,448
in a second but then once we're done

1653
01:38:43,738 --> 01:38:48,178
with that then we know that we're gonna

1654
01:38:45,448 --> 01:38:51,649
make another Huffman table and we're

1655
01:38:48,179 --> 01:38:54,059
gonna make another Huffman table out of

1656
01:38:51,649 --> 01:38:55,859
out of the the remaining stuff that we

1657
01:38:54,059 --> 01:38:59,909
get here for literals and distances

1658
01:38:55,859 --> 01:39:06,569
right so once we compute this Huffman

1659
01:38:59,908 --> 01:39:10,848
then what we want to do is we want to do

1660
01:39:06,569 --> 01:39:10,849
a Huffman read from our from our stream

1661
01:39:13,488 --> 01:39:20,939
and we need the to give it this Huffman

1662
01:39:18,179 --> 01:39:23,029
dictionary to operate on so this I would

1663
01:39:20,939 --> 01:39:26,879
say is look to code the next thing here

1664
01:39:23,029 --> 01:39:30,710
and that's going to be decoded as a

1665
01:39:26,880 --> 01:39:33,840
length that gets put into this table and

1666
01:39:30,710 --> 01:39:35,069
what it suggests here is that well

1667
01:39:33,840 --> 01:39:41,159
actually I guess this is still encoded

1668
01:39:35,069 --> 01:39:44,038
length so the encoded length itself is

1669
01:39:41,158 --> 01:39:49,288
then interpreted this way and we write

1670
01:39:44,038 --> 01:39:52,198
that into another table that then does

1671
01:39:49,288 --> 01:39:58,170
the exact same thing so we have like a

1672
01:39:52,198 --> 01:40:03,988
PNG Huffman that's going to be for the

1673
01:39:58,170 --> 01:40:10,500
actual data right and we've got one for

1674
01:40:03,988 --> 01:40:15,689
the literal Huffman and one for the

1675
01:40:10,500 --> 01:40:18,469
length those are going to get generated

1676
01:40:15,689 --> 01:40:18,469
out here somewhere

1677
01:40:20,359 --> 01:40:33,279
and and used yeah so basically this

1678
01:40:29,029 --> 01:40:42,550
should be looking like that more or less

1679
01:40:33,279 --> 01:40:42,550
and I think yeah that's it the distance

1680
01:40:44,500 --> 01:40:54,170
sorry it's lit Len and distance am i

1681
01:40:50,659 --> 01:40:56,059
right yeah yeah so we've got a little an

1682
01:40:54,170 --> 01:40:58,159
Huff in a distance Huffman so what we

1683
01:40:56,060 --> 01:41:01,220
want to do here is when we decode the

1684
01:40:58,159 --> 01:41:08,170
lit Len Huffman is used for the lit Len

1685
01:41:01,220 --> 01:41:08,170
exactly as you would expect and the

1686
01:41:08,409 --> 01:41:14,569
distance Huffman is used for the

1687
01:41:10,279 --> 01:41:25,519
distance so this actually looks like

1688
01:41:14,569 --> 01:41:27,949
that right and this is the thing that

1689
01:41:25,520 --> 01:41:35,690
produces the tables which then are used

1690
01:41:27,949 --> 01:41:38,449
to do the kauffman computation here so

1691
01:41:35,689 --> 01:41:40,189
now I again I'm just not sure about this

1692
01:41:38,449 --> 01:41:42,710
part I don't know whether this should

1693
01:41:40,189 --> 01:41:44,599
really be h.glenn here I don't know how

1694
01:41:42,710 --> 01:41:46,220
we want to do the Huffman in terms of

1695
01:41:44,600 --> 01:41:48,200
the codes because it'll just be zeros

1696
01:41:46,220 --> 01:41:50,329
after I don't know if it's important for

1697
01:41:48,199 --> 01:41:57,649
it to see those zeros after or not

1698
01:41:50,329 --> 01:42:00,170
that's kind of I'm gonna go ahead and

1699
01:41:57,649 --> 01:42:01,969
say not for now so what I'm gonna do is

1700
01:42:00,170 --> 01:42:04,430
I'm just gonna say that H plan comes in

1701
01:42:01,970 --> 01:42:06,520
here so what I'm gonna do is I'm going

1702
01:42:04,430 --> 01:42:10,150
to say for these the same thing is true

1703
01:42:06,520 --> 01:42:14,300
I'm gonna pass the actual ones here so

1704
01:42:10,149 --> 01:42:16,719
we know an H lit and an H dist for the

1705
01:42:14,300 --> 01:42:16,720
two of these

1706
01:42:27,119 --> 01:42:33,579
oops

1707
01:42:30,029 --> 01:42:36,729
so getting those two huffman tables will

1708
01:42:33,579 --> 01:42:39,219
be done by taking the sort of raw table

1709
01:42:36,729 --> 01:42:45,339
here so there's the length table and

1710
01:42:39,219 --> 01:42:48,909
here's the like little end disk table

1711
01:42:45,340 --> 01:42:50,500
for whatever know how we want it's best

1712
01:42:48,909 --> 01:42:54,519
for that I don't need to clear that one

1713
01:42:50,500 --> 01:42:55,750
I guess technically I do need to close

1714
01:42:54,520 --> 01:42:58,690
this one I don't need to clear this one

1715
01:42:55,750 --> 01:43:00,460
I guess because these go in order so

1716
01:42:58,689 --> 01:43:02,619
this one is just however many the

1717
01:43:00,460 --> 01:43:07,619
maximum would it be of these so we know

1718
01:43:02,619 --> 01:43:10,238
that that's not oh I already had that

1719
01:43:07,619 --> 01:43:12,698
right here so I know I've got this and I

1720
01:43:10,238 --> 01:43:14,319
could just write into it as we go so

1721
01:43:12,698 --> 01:43:15,729
what I need to do is do the huffman to

1722
01:43:14,319 --> 01:43:19,329
code and then I need to look right into

1723
01:43:15,729 --> 01:43:24,399
the table this way right

1724
01:43:19,329 --> 01:43:27,219
so yeah this index is not particularly

1725
01:43:24,399 --> 01:43:30,579
useful so really I want little encount

1726
01:43:27,219 --> 01:43:32,800
here to be sort of something that I

1727
01:43:30,579 --> 01:43:38,079
write to and what I need to do is I need

1728
01:43:32,800 --> 01:43:42,219
to do this decoding before I can do the

1729
01:43:38,079 --> 01:43:44,409
rest of this right now in theory if I

1730
01:43:42,219 --> 01:43:46,448
know how many H lit there are that

1731
01:43:44,409 --> 01:43:50,159
doesn't necessarily help me because I

1732
01:43:46,448 --> 01:43:50,159
guess is this always a fixed length

1733
01:44:01,319 --> 01:44:10,719
yes I'm not sure exactly how that table

1734
01:44:05,289 --> 01:44:15,100
gets interpreted necessarily I think

1735
01:44:10,720 --> 01:44:25,090
it's just H litt an H dist is the count

1736
01:44:15,100 --> 01:44:27,730
on each of those so I think but since

1737
01:44:25,090 --> 01:44:36,069
those encoded legs lengths involve reach

1738
01:44:27,729 --> 01:44:39,519
each yeah I'm just not sure about that

1739
01:44:36,069 --> 01:44:41,889
so I'm not sure exactly how they expect

1740
01:44:39,520 --> 01:44:45,930
the table to then be used I don't know

1741
01:44:41,890 --> 01:44:45,930
if what they're saying is that they

1742
01:44:49,859 --> 01:44:56,170
because the H lip here yeah this this

1743
01:44:55,090 --> 01:44:59,020
just really doesn't give you the

1744
01:44:56,170 --> 01:45:00,850
information you need I feel like there's

1745
01:44:59,020 --> 01:45:03,690
a little bit of a subtlety there I'm not

1746
01:45:00,850 --> 01:45:03,690
understanding as well

1747
01:45:14,949 --> 01:45:20,689
so here's what I think it's saying I

1748
01:45:17,800 --> 01:45:23,600
think what it's actually saying is that

1749
01:45:20,689 --> 01:45:27,019
H litt + H disk is actually the output

1750
01:45:23,600 --> 01:45:30,200
size not the input size so I think you

1751
01:45:27,020 --> 01:45:37,610
don't do this what you actually do is

1752
01:45:30,199 --> 01:45:42,130
this right I think that's what it's

1753
01:45:37,609 --> 01:45:42,130
actually saying and then you do this

1754
01:45:49,029 --> 01:45:52,819
does that make sense

1755
01:45:50,750 --> 01:45:55,220
so we're basically saying look here's

1756
01:45:52,819 --> 01:45:57,229
how many you're gonna get but we're not

1757
01:45:55,220 --> 01:45:58,610
going to tell you how many actual pieces

1758
01:45:57,229 --> 01:46:00,439
of information we're gonna use to encode

1759
01:45:58,609 --> 01:46:03,829
that because sometimes we're gonna

1760
01:46:00,439 --> 01:46:05,869
encode repeats in here right so what we

1761
01:46:03,829 --> 01:46:08,960
want you to do is just keep reading from

1762
01:46:05,869 --> 01:46:09,349
your huffman from the table we gave you

1763
01:46:08,960 --> 01:46:14,720
before

1764
01:46:09,350 --> 01:46:17,660
keep reading from that till you filled

1765
01:46:14,720 --> 01:46:20,560
up that table right and we should be

1766
01:46:17,659 --> 01:46:23,960
able to assert here also that it's exact

1767
01:46:20,560 --> 01:46:26,180
because if if we mess up the stream read

1768
01:46:23,960 --> 01:46:29,060
then it won't be exact so that should

1769
01:46:26,180 --> 01:46:30,710
tell us as well and then what I want you

1770
01:46:29,060 --> 01:46:35,390
to do is produce the Huffman from those

1771
01:46:30,710 --> 01:46:38,600
input values that I've given you write

1772
01:46:35,390 --> 01:46:41,270
encode it in this way and these are

1773
01:46:38,600 --> 01:46:42,740
encoded based on this so again if the

1774
01:46:41,270 --> 01:46:44,780
encoded line is is less you're gonna

1775
01:46:42,739 --> 01:46:50,119
feed that 15 that's actually the code

1776
01:46:44,779 --> 01:46:54,380
right so the little end disk table is

1777
01:46:50,119 --> 01:47:02,829
actually going to just include exactly

1778
01:46:54,380 --> 01:47:02,829
that length if the if it's if it's a 16

1779
01:47:03,039 --> 01:47:15,859
these are zeros both of these zeros so

1780
01:47:06,140 --> 01:47:20,180
if it's a 16 we read 2 bits and we can

1781
01:47:15,859 --> 01:47:22,670
also do a well I guess we don't laugh to

1782
01:47:20,180 --> 01:47:26,119
that so we we consume 2 bits from the

1783
01:47:22,670 --> 01:47:28,779
input stream here and we just wrap that

1784
01:47:26,119 --> 01:47:28,779
many times

1785
01:47:34,569 --> 01:47:40,929
this is like an R le so a rep file is

1786
01:47:38,779 --> 01:47:46,038
just whatever the distance tables

1787
01:47:40,929 --> 01:47:47,599
previous value was right now we can

1788
01:47:46,038 --> 01:47:49,340
assert here that the length count is

1789
01:47:47,599 --> 01:47:50,719
greater than zero because if it tells us

1790
01:47:49,340 --> 01:47:52,340
to repeat something and we haven't

1791
01:47:50,719 --> 01:47:54,319
gotten anything that sounds like a bug

1792
01:47:52,340 --> 01:47:57,109
so I'm just going to go ahead and say

1793
01:47:54,319 --> 01:47:59,958
that that has to happen then what we can

1794
01:47:57,109 --> 01:48:18,979
do is is do the zeros really easily

1795
01:47:59,958 --> 01:48:23,029
that's just this right another way to do

1796
01:48:18,979 --> 01:48:26,559
this that's super fancy if you wanted to

1797
01:48:23,029 --> 01:48:26,559
you could do this

1798
01:48:38,639 --> 01:49:05,708
right so this way it's always phrased as

1799
01:49:01,988 --> 01:49:09,578
a rep and we just rep set the rep count

1800
01:49:05,708 --> 01:49:11,738
and the rep value correctly in each of

1801
01:49:09,578 --> 01:49:14,918
these cases in this case we set it to a

1802
01:49:11,738 --> 01:49:16,388
rep count of 1 and encoded length and it

1803
01:49:14,918 --> 01:49:19,208
could and use the encoded like this the

1804
01:49:16,389 --> 01:49:20,618
value in this case you know well you see

1805
01:49:19,208 --> 01:49:22,418
what I'm doing right it's pretty basic

1806
01:49:20,618 --> 01:49:26,589
let me just read these here how this is

1807
01:49:22,418 --> 01:49:28,779
actually like 0 equals 3 3 equals 6 so I

1808
01:49:26,590 --> 01:49:30,880
think this is here the rep count is

1809
01:49:28,779 --> 01:49:44,768
supposed to be 3 plus the value that we

1810
01:49:30,880 --> 01:49:50,168
grabbed right I think so codes 8 16 plus

1811
01:49:44,769 --> 01:49:53,130
2 bits 11 16 plus 2 bits will expand to

1812
01:49:50,168 --> 01:49:53,130
12 codes

1813
01:50:04,069 --> 01:50:13,840
I don't quite get that part 16 plus 2

1814
01:50:07,159 --> 01:50:13,840
bits 1 0 will expand to what

1815
01:50:24,029 --> 01:50:28,500
I mean or that for now we're pretty good

1816
01:50:26,010 --> 01:50:34,560
is it for three to ten times three bits

1817
01:50:28,500 --> 01:50:41,010
of length okay so that's just again this

1818
01:50:34,560 --> 01:50:42,780
is the same thing and then for zero for

1819
01:50:41,010 --> 01:50:57,900
eleven thirty to seven mix of lengths so

1820
01:50:42,779 --> 01:51:01,920
this is just that right so that I guess

1821
01:50:57,899 --> 01:51:04,829
is what they want from us there and so

1822
01:51:01,920 --> 01:51:09,199
then we can make our next weekend's job

1823
01:51:04,829 --> 01:51:12,059
to do the Huffman table construction and

1824
01:51:09,199 --> 01:51:13,800
that'll probably be nasty but that's

1825
01:51:12,060 --> 01:51:15,150
like the last thing then because it

1826
01:51:13,800 --> 01:51:16,680
looks like we've got everything else so

1827
01:51:15,149 --> 01:51:19,309
then we're just on to debugging which of

1828
01:51:16,680 --> 01:51:22,350
course it's going to be in an envious

1829
01:51:19,310 --> 01:51:38,390
situation but you know what are you

1830
01:51:22,350 --> 01:51:46,160
gonna do I should say input count input

1831
01:51:38,390 --> 01:51:46,160
Hoffman results so and then

1832
01:51:56,260 --> 01:52:32,150
yeah and I think that's what we're

1833
01:52:18,229 --> 01:52:43,069
talking about if I'm not very much an

1834
01:52:32,149 --> 01:52:45,649
error uh so there we have it I yeah I

1835
01:52:43,069 --> 01:52:58,039
guess I'll go to a brief Q&amp;A but I think

1836
01:52:45,649 --> 01:53:00,799
that's pretty much it I'm sure we'll end

1837
01:52:58,039 --> 01:53:02,929
up in a debugging nightmare with it as

1838
01:53:00,800 --> 01:53:04,489
we try to figure out you know how all

1839
01:53:02,929 --> 01:53:11,118
these things are coming together but I

1840
01:53:04,488 --> 01:53:12,828
think I think that's everything I think

1841
01:53:11,118 --> 01:53:15,170
that's a complete sketch of the

1842
01:53:12,828 --> 01:53:18,799
algorithm unless I missed something in

1843
01:53:15,170 --> 01:53:21,889
there so we just need to go back and

1844
01:53:18,800 --> 01:53:25,880
implement now that that Huffman code

1845
01:53:21,889 --> 01:53:27,920
decompression step a like calculation

1846
01:53:25,880 --> 01:53:30,969
step and then we have to put it in some

1847
01:53:27,920 --> 01:53:36,849
format that we can easily actually use

1848
01:53:30,969 --> 01:53:36,849
to to implement the Huffman tree

1849
01:53:40,729 --> 01:53:44,789
I'm happy you're doing this I've had

1850
01:53:42,869 --> 01:53:47,699
problems making my inflate decoder for

1851
01:53:44,789 --> 01:53:49,229
fun work and you being a spectacle and

1852
01:53:47,699 --> 01:53:52,519
you being a spectra coder works out

1853
01:53:49,229 --> 01:53:52,519
perfectly okay cool

1854
01:53:56,960 --> 01:54:01,949
ratchet freak says I believe the length

1855
01:53:59,340 --> 01:54:05,390
of the LZ should be interpreted like you

1856
01:54:01,949 --> 01:54:10,909
32 copy length equals length table base

1857
01:54:05,390 --> 01:54:10,910
little n minus 2 to 7 plus consume bits

1858
01:54:11,630 --> 01:54:15,650
do you mean this length

1859
01:54:39,060 --> 01:54:42,270
yeah okay but you're talking about

1860
01:54:40,829 --> 01:54:44,309
you're talking about down in here right

1861
01:54:42,270 --> 01:54:49,680
which we haven't really quite gotten to

1862
01:54:44,310 --> 01:54:50,970
yet how have you found the P&amp;G and zeal

1863
01:54:49,680 --> 01:54:51,960
obsessed vacation compared to other

1864
01:54:50,970 --> 01:55:02,930
associations you have read and

1865
01:54:51,960 --> 01:55:05,640
implemented I guess what I would say is

1866
01:55:02,930 --> 01:55:07,950
there's two ways that specs can be bad

1867
01:55:05,640 --> 01:55:12,030
one is this effect can be incomplete and

1868
01:55:07,949 --> 01:55:13,889
one is the spec can be obtuse I would

1869
01:55:12,029 --> 01:55:17,960
say these seem to be relatively complete

1870
01:55:13,890 --> 01:55:17,960
but quite obtuse for no reason

1871
01:55:19,159 --> 01:55:24,809
you can compare that to for example the

1872
01:55:21,359 --> 01:55:27,239
PSD specification which is the opposite

1873
01:55:24,810 --> 01:55:30,530
it is very easy to understand the

1874
01:55:27,239 --> 01:55:35,250
specification but it is very incomplete

1875
01:55:30,529 --> 01:55:37,259
and so ideally a spec should be both it

1876
01:55:35,250 --> 01:55:39,449
should specify everything and it's just

1877
01:55:37,260 --> 01:55:41,070
specified in a clean and concise way

1878
01:55:39,449 --> 01:55:52,109
that's easy to understand

1879
01:55:41,069 --> 01:55:53,969
right so any way to fix the pink

1880
01:55:52,109 --> 01:55:57,210
flashing it was fairly per se you'd have

1881
01:55:53,970 --> 01:56:04,699
to ask Allen that's that's as far as I

1882
01:55:57,210 --> 01:56:04,699
know that's in for coder I can't fix it

1883
01:56:07,130 --> 01:56:14,520
so no the art will probably not be

1884
01:56:10,890 --> 01:56:17,690
iterated live it's more just for them to

1885
01:56:14,520 --> 01:56:17,690
be able to work on it

1886
01:56:46,159 --> 01:56:50,010
what do you do when you have an

1887
01:56:47,939 --> 01:56:51,269
incomplete specification is it then

1888
01:56:50,010 --> 01:56:52,140
we're just trial and error or their

1889
01:56:51,270 --> 01:56:54,680
takes out of community

1890
01:56:52,140 --> 01:56:56,910
well there's couple things you can do so

1891
01:56:54,680 --> 01:56:58,980
for this particular stream I'm just

1892
01:56:56,909 --> 01:57:02,099
going with the spec for a while and when

1893
01:56:58,979 --> 01:57:04,229
I hit a if I hit a we haven't yet but if

1894
01:57:02,100 --> 01:57:06,780
I hit some part where I cannot figure

1895
01:57:04,229 --> 01:57:08,309
out from the spec what they meant I can

1896
01:57:06,779 --> 01:57:12,329
go look at reference implementations

1897
01:57:08,310 --> 01:57:13,980
which is a good place to go right so I'm

1898
01:57:12,329 --> 01:57:15,479
just showing some different steps here

1899
01:57:13,979 --> 01:57:16,799
and and you know we'll go to that if we

1900
01:57:15,479 --> 01:57:18,238
have to but for the moment I'm just up

1901
01:57:16,800 --> 01:57:22,079
coming from the spec because so far

1902
01:57:18,238 --> 01:57:23,968
we've been able to do so and so far

1903
01:57:22,079 --> 01:57:27,000
we've gotten far enough with that that

1904
01:57:23,969 --> 01:57:28,859
it's fine right but eventually we may

1905
01:57:27,000 --> 01:57:31,319
have to go to reference invitation

1906
01:57:28,859 --> 01:57:32,219
that's the first thing to try to do if

1907
01:57:31,319 --> 01:57:33,779
you don't have a reference

1908
01:57:32,219 --> 01:57:35,100
implementation and you're kind of the

1909
01:57:33,779 --> 01:57:38,789
first person in there trying to like

1910
01:57:35,100 --> 01:57:41,250
hack around then yeah you what you have

1911
01:57:38,789 --> 01:57:42,630
to do is trial and error but you can

1912
01:57:41,250 --> 01:57:45,510
give yourself a little bit of a leg up

1913
01:57:42,630 --> 01:57:48,869
on the trial and error front by trying

1914
01:57:45,510 --> 01:57:51,270
to feed structured art into the thing at

1915
01:57:48,869 --> 01:57:52,829
the head end so that you can its base

1916
01:57:51,270 --> 01:57:55,650
like differential crypt analysis if

1917
01:57:52,829 --> 01:57:58,260
you've ever looked at that differential

1918
01:57:55,649 --> 01:58:00,719
crystal analysis is a way of fussing

1919
01:57:58,260 --> 01:58:03,300
with the input stream to an encrypt or

1920
01:58:00,719 --> 01:58:06,180
and looking how the decrypt what the do

1921
01:58:03,300 --> 01:58:10,440
what the data comes out of the other end

1922
01:58:06,180 --> 01:58:13,789
after encryption that same technique can

1923
01:58:10,439 --> 01:58:16,019
be used to much greater effect on

1924
01:58:13,789 --> 01:58:17,698
reverse engineering right when you're

1925
01:58:16,020 --> 01:58:19,560
trying to figure out how a file spec

1926
01:58:17,698 --> 01:58:22,019
works and you have an end coder you're

1927
01:58:19,560 --> 01:58:23,940
trying to write a decoder what you can

1928
01:58:22,020 --> 01:58:27,920
do is just like feed different art into

1929
01:58:23,939 --> 01:58:30,210
it like a block of Allred you know and

1930
01:58:27,920 --> 01:58:31,710
then a block of all blue and whatever

1931
01:58:30,210 --> 01:58:34,980
and then a block of alternating red and

1932
01:58:31,710 --> 01:58:37,260
blue and right and then you can hope to

1933
01:58:34,979 --> 01:58:38,429
try and get different things to happen

1934
01:58:37,260 --> 01:58:40,079
in the stream that will be clearer to

1935
01:58:38,430 --> 01:58:42,090
you because you know like okay the

1936
01:58:40,079 --> 01:58:44,279
dictionaries only should have like one

1937
01:58:42,090 --> 01:58:47,159
thing in it or whatever so I can help

1938
01:58:44,279 --> 01:58:49,590
you know right you can construct cases

1939
01:58:47,159 --> 01:58:51,719
that you think will create encoding of a

1940
01:58:49,590 --> 01:58:55,829
certain nature and work backwards from

1941
01:58:51,719 --> 01:58:57,329
that right doesn't that you can do is if

1942
01:58:55,829 --> 01:58:59,739
you're a reverse engineering kind of

1943
01:58:57,329 --> 01:59:01,329
person is you can reverse engineer addy

1944
01:58:59,739 --> 01:59:02,619
so if you don't have source to decoder

1945
01:59:01,329 --> 01:59:04,269
but you do have a program that does it

1946
01:59:02,619 --> 01:59:06,789
crack on in there right

1947
01:59:04,270 --> 01:59:08,800
that's a nasty business but there's

1948
01:59:06,789 --> 01:59:11,640
people who do that a lot and get good at

1949
01:59:08,800 --> 01:59:14,890
it so you can do that

1950
01:59:11,640 --> 01:59:31,420
what for coder version are you on on

1951
01:59:14,890 --> 01:59:43,860
stream I don't know is there any way

1952
01:59:31,420 --> 01:59:43,859
it's hell I don't know how to sell

1953
01:59:56,119 --> 01:59:59,670
rational cooter just caught up with a

1954
01:59:58,020 --> 02:00:00,870
stream but I have had a question for a

1955
01:59:59,670 --> 02:00:02,819
while when you come up with a reusable

1956
02:00:00,869 --> 02:00:04,439
data structure and want to share it

1957
02:00:02,819 --> 02:00:06,929
between products and other people how do

1958
02:00:04,439 --> 02:00:08,549
you deal with custom allocation I have

1959
02:00:06,929 --> 02:00:10,560
been writing some hybrid data structures

1960
02:00:08,550 --> 02:00:12,239
and I want to add custom allocation but

1961
02:00:10,560 --> 02:00:18,560
adding a template parameter seems like a

1962
02:00:12,238 --> 02:00:18,559
bad solution to the problem well oh

1963
02:00:18,948 --> 02:00:23,009
sorry just to finish the last question

1964
02:00:21,300 --> 02:00:25,610
you said there's a messages window which

1965
02:00:23,010 --> 02:00:34,530
has it there you go

1966
02:00:25,609 --> 02:00:37,139
402 five so yeah I guess what I would

1967
02:00:34,529 --> 02:00:41,550
say is the first question is are you

1968
02:00:37,140 --> 02:00:42,869
sure that you need to do allocation and

1969
02:00:41,550 --> 02:00:46,110
I know that sounds like an odd question

1970
02:00:42,869 --> 02:00:47,880
but I really mean it are you sure that

1971
02:00:46,109 --> 02:00:57,448
you need to a lot of times you don't

1972
02:00:47,880 --> 02:01:02,279
actually need to this is a little off

1973
02:00:57,448 --> 02:01:05,689
topic but for example the way I did it

1974
02:01:02,279 --> 02:01:08,729
in granny is there's three calls

1975
02:01:05,689 --> 02:01:13,669
basically for everything that allocates

1976
02:01:08,729 --> 02:01:13,669
data and they look like this

1977
02:01:29,760 --> 02:02:17,489
I so this is the way everything worked

1978
02:02:15,029 --> 02:02:19,408
in granny so anyone who just didn't care

1979
02:02:17,488 --> 02:02:21,988
where the memory went it would just go

1980
02:02:19,408 --> 02:02:27,960
create thingy and granny would allocate

1981
02:02:21,988 --> 02:02:29,698
the memory right and if you did care

1982
02:02:27,960 --> 02:02:31,710
where it went you would just call get

1983
02:02:29,698 --> 02:02:33,058
sizeof thingy and you'd pass the same

1984
02:02:31,710 --> 02:02:35,189
parameters you're gonna pass to create

1985
02:02:33,059 --> 02:02:37,619
and then you'd call put thingy in place

1986
02:02:35,189 --> 02:02:39,598
and you'd pass the memory that you

1987
02:02:37,618 --> 02:02:41,399
allocated that was you were basically

1988
02:02:39,599 --> 02:02:46,279
warranting that it would be whatever

1989
02:02:41,399 --> 02:02:48,868
size came back from this right and

1990
02:02:46,279 --> 02:02:51,300
that's just that worked so what would

1991
02:02:48,868 --> 02:02:54,089
happen is when you do construction of

1992
02:02:51,300 --> 02:02:56,519
something you would just say okay I know

1993
02:02:54,090 --> 02:02:59,010
I need this much space to store all the

1994
02:02:56,519 --> 02:03:03,719
parts of it or whatever so I just did

1995
02:02:59,010 --> 02:03:05,190
that and this actually worked for 99% of

1996
02:03:03,719 --> 02:03:06,868
all the things that the library needed

1997
02:03:05,189 --> 02:03:08,638
to do there's once in a while where you

1998
02:03:06,868 --> 02:03:10,229
actually had allocation that wanted to

1999
02:03:08,639 --> 02:03:12,239
happen behind the scenes at arbitrary

2000
02:03:10,229 --> 02:03:14,399
times but a lot of times that's just not

2001
02:03:12,238 --> 02:03:17,250
necessary so the first thing I would say

2002
02:03:14,399 --> 02:03:19,500
is don't actually do custom allocation

2003
02:03:17,250 --> 02:03:21,448
anywhere you don't absolutely have to

2004
02:03:19,500 --> 02:03:23,849
and buy absolutely after what I mean is

2005
02:03:21,448 --> 02:03:26,158
don't do custom allocation anywhere

2006
02:03:23,849 --> 02:03:29,269
where you could have allowed the user to

2007
02:03:26,158 --> 02:03:32,158
pass in the memory that you should use

2008
02:03:29,269 --> 02:03:34,530
almost all things can be done that way

2009
02:03:32,158 --> 02:03:42,149
there are very very very few that

2010
02:03:34,529 --> 02:03:43,328
actually need to have that happen and so

2011
02:03:42,149 --> 02:03:45,338
I would just real

2012
02:03:43,328 --> 02:03:49,628
encourage you to look at that first and

2013
02:03:45,338 --> 02:03:51,849
then then move on only after you've

2014
02:03:49,628 --> 02:03:55,979
completely assured yourself that there

2015
02:03:51,849 --> 02:03:55,979
is no way to implement it in that format

2016
02:04:03,179 --> 02:04:06,699
why does no inspect the simplest

2017
02:04:05,319 --> 02:04:08,710
solution possible so people can easily

2018
02:04:06,698 --> 02:04:10,359
implement the parsers and exporters they

2019
02:04:08,710 --> 02:04:15,880
need in cases where space speed does not

2020
02:04:10,359 --> 02:04:19,689
matter well I think the problem is that

2021
02:04:15,880 --> 02:04:28,210
people drastically over estimate the

2022
02:04:19,689 --> 02:04:31,719
cost of being under flexible so here's

2023
02:04:28,210 --> 02:04:34,630
what generally happens somebody

2024
02:04:31,719 --> 02:04:36,730
specifies a good file format and the

2025
02:04:34,630 --> 02:04:40,029
file formats like hey we want to start

2026
02:04:36,729 --> 02:04:43,359
pixel data so we said the width and the

2027
02:04:40,029 --> 02:04:48,658
height and like one compression format

2028
02:04:43,359 --> 02:04:50,799
and then that was the data right and

2029
02:04:48,658 --> 02:04:52,509
that's super great and it works and

2030
02:04:50,800 --> 02:04:54,909
everyone's happy except now someone's

2031
02:04:52,510 --> 02:04:57,579
like oh but I really wanted to store

2032
02:04:54,908 --> 02:04:59,679
like some copyright information in the

2033
02:04:57,578 --> 02:05:01,840
file or I wanted to store some

2034
02:04:59,679 --> 02:05:05,529
information about my like layer data or

2035
02:05:01,840 --> 02:05:07,239
whatever right and so when that person

2036
02:05:05,529 --> 02:05:09,340
goes to make a new file format because

2037
02:05:07,238 --> 02:05:11,948
they need these things in their head

2038
02:05:09,340 --> 02:05:13,900
what they're thinking is I don't want to

2039
02:05:11,948 --> 02:05:16,419
get in another situation like we got

2040
02:05:13,899 --> 02:05:19,479
into last time where we had to make a

2041
02:05:16,420 --> 02:05:21,880
whole new file format because I wanted

2042
02:05:19,479 --> 02:05:23,589
to add some things so what I'm gonna do

2043
02:05:21,880 --> 02:05:25,210
is I'm gonna make a file format that's

2044
02:05:23,590 --> 02:05:27,159
super flexible and has all these

2045
02:05:25,210 --> 02:05:29,230
different pieces that can be added to it

2046
02:05:27,158 --> 02:05:31,658
so that we never have to have another

2047
02:05:29,229 --> 02:05:34,209
file format again and everything is

2048
02:05:31,658 --> 02:05:38,920
going to be here in the TIFF file format

2049
02:05:34,210 --> 02:05:43,739
right that's like the mpeg-4 spec it's

2050
02:05:38,920 --> 02:05:48,219
like the Tiff's back it's like you know

2051
02:05:43,738 --> 02:05:50,259
aughhh forbus or something right I and

2052
02:05:48,219 --> 02:05:52,920
these are all about packing eight

2053
02:05:50,260 --> 02:05:56,139
billion things into the file format that

2054
02:05:52,920 --> 02:05:59,230
helps nobody these are just not good

2055
02:05:56,139 --> 02:06:01,929
specifications because nobody implements

2056
02:05:59,229 --> 02:06:04,089
complete writers nobody implements

2057
02:06:01,929 --> 02:06:07,690
complete readers because doing so would

2058
02:06:04,090 --> 02:06:10,989
take years right and it's just not

2059
02:06:07,689 --> 02:06:14,799
useful specify something simple that

2060
02:06:10,988 --> 02:06:15,429
gets a job done well and use it and when

2061
02:06:14,800 --> 02:06:18,369
you have something

2062
02:06:15,430 --> 02:06:19,390
else that needs to happen do something

2063
02:06:18,369 --> 02:06:22,210
else right

2064
02:06:19,390 --> 02:06:26,200
that is way better than this whole

2065
02:06:22,210 --> 02:06:27,909
nonsense right I don't even think you

2066
02:06:26,199 --> 02:06:29,250
should do stuff like put indexed and

2067
02:06:27,909 --> 02:06:32,710
true color things the same file format

2068
02:06:29,250 --> 02:06:36,039
why they're totally different right

2069
02:06:32,710 --> 02:06:37,720
they're really very very different we

2070
02:06:36,039 --> 02:06:38,890
don't need that stuff I mean maybe

2071
02:06:37,720 --> 02:06:40,990
that's a bad example because it's not

2072
02:06:38,890 --> 02:06:44,200
that big of a change right but it's just

2073
02:06:40,989 --> 02:06:47,019
like pick a narrow set of things that

2074
02:06:44,199 --> 02:06:50,229
you're trying to solve and just do it

2075
02:06:47,020 --> 02:06:51,550
right and be done with it and then

2076
02:06:50,229 --> 02:06:53,109
everyone can use that if we need

2077
02:06:51,550 --> 02:06:55,029
something else we'll use something else

2078
02:06:53,109 --> 02:06:57,099
but that way we're clear on what this

2079
02:06:55,029 --> 02:07:02,170
thing does and everyone can support it

2080
02:06:57,100 --> 02:07:04,329
easily you know are you going to audio

2081
02:07:02,170 --> 02:07:05,920
formats next no I'm happy with the web

2082
02:07:04,329 --> 02:07:09,390
reader that we've got in there now

2083
02:07:05,920 --> 02:07:09,390
that's that's totally fine

2084
02:07:47,078 --> 02:07:50,799
alright looks like we're all done

2085
02:07:59,159 --> 02:08:02,979
all right thank you everyone for joining

2086
02:08:01,449 --> 02:08:04,119
me for those two the handmade here it's

2087
02:08:02,979 --> 02:08:06,609
been a pleasure coding with you as

2088
02:08:04,119 --> 02:08:08,920
always if you would like to follow along

2089
02:08:06,609 --> 02:08:10,539
with dream at home you always can peer

2090
02:08:08,920 --> 02:08:12,190
to the game on handmade hero or it comes

2091
02:08:10,539 --> 02:08:14,710
with a source code so you can play

2092
02:08:12,189 --> 02:08:16,389
around with it I will be back next week

2093
02:08:14,710 --> 02:08:18,460
when we will take a look at constructing

2094
02:08:16,390 --> 02:08:19,810
those Huffman tables which is the

2095
02:08:18,460 --> 02:08:21,730
primary thing that we're gonna have to

2096
02:08:19,810 --> 02:08:23,590
do in order to decode the rest of the

2097
02:08:21,729 --> 02:08:25,419
data I think we're in pretty good shape

2098
02:08:23,590 --> 02:08:27,310
I'm sure we'll have a lot of debugging

2099
02:08:25,420 --> 02:08:29,079
to do but basically that is the last

2100
02:08:27,310 --> 02:08:31,180
step in the process in order to get a

2101
02:08:29,079 --> 02:08:33,039
decoder functioning although perhaps not

2102
02:08:31,180 --> 02:08:35,470
functioning correctly and then we can go

2103
02:08:33,039 --> 02:08:37,390
through and figure out what what stuff

2104
02:08:35,470 --> 02:08:39,489
we missed but that's really where we're

2105
02:08:37,390 --> 02:08:41,770
at so this hasn't taken too long I'm

2106
02:08:39,488 --> 02:08:43,389
pretty pleased with that but we'll see

2107
02:08:41,770 --> 02:08:45,040
how it goes next weekend maybe creating

2108
02:08:43,390 --> 02:08:46,720
that and using the Huffman tables would

2109
02:08:45,039 --> 02:08:49,539
be a giant disaster who knows we'll find

2110
02:08:46,720 --> 02:08:51,130
out alright hope see everyone back here

2111
02:08:49,539 --> 02:08:52,449
for that next week until then have fun

2112
02:08:51,130 --> 02:08:54,810
programming and I'll see everyone on the

2113
02:08:52,449 --> 02:08:54,809
Internet

