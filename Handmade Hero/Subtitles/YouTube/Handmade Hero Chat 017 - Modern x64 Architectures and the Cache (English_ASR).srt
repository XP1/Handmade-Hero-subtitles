1
00:04:54,598 --> 00:05:12,279
hello whatever foul I'm glad you could

2
00:05:00,158 --> 00:05:14,098
catch a stream live as well never this

3
00:05:12,279 --> 00:05:21,968
feel it's your birthday today

4
00:05:14,098 --> 00:05:24,180
really well happy birthday are you doing

5
00:05:21,968 --> 00:05:26,199
anything special for your birthday

6
00:05:24,180 --> 00:05:29,400
you're still watching handmade here oh

7
00:05:26,199 --> 00:05:29,400
so that's what you normally do

8
00:05:29,459 --> 00:05:34,589
it's like it's a special birthday

9
00:05:31,538 --> 00:05:34,589
handmade here though

10
00:05:47,740 --> 00:05:53,439
I feel like a handmade hero needs like a

11
00:05:50,439 --> 00:05:56,769
sponsor like on podcasts you know like

12
00:05:53,439 --> 00:05:59,439
before the podcast starts they always

13
00:05:56,769 --> 00:06:04,539
say like this episode is brought to you

14
00:05:59,439 --> 00:06:06,009
by hmm you know poo box a box full of

15
00:06:04,540 --> 00:06:13,030
poo that arrives at your door every

16
00:06:06,009 --> 00:06:15,430
month or whatever and I just don't know

17
00:06:13,029 --> 00:06:17,439
what what the box would be like it would

18
00:06:15,430 --> 00:06:22,019
be or could be mattresses I guess

19
00:06:17,439 --> 00:06:26,819
mattresses boxes or website builder

20
00:06:22,019 --> 00:06:29,469
maybe CSS could be our sponsor create

21
00:06:26,819 --> 00:06:35,099
disgusting barely functional web pages

22
00:06:29,470 --> 00:06:35,100
in just several months using CSS

23
00:06:53,509 --> 00:06:56,939
you mentioned on Twitter being

24
00:06:55,560 --> 00:06:59,009
interested in the hiring process that

25
00:06:56,939 --> 00:07:00,209
includes an option for people to record

26
00:06:59,009 --> 00:07:01,740
themselves doing their normal

27
00:07:00,209 --> 00:07:03,989
programming work is there a way you

28
00:07:01,740 --> 00:07:08,310
think the industry could be led to

29
00:07:03,990 --> 00:07:14,220
feasibly adopt that I do think so

30
00:07:08,310 --> 00:07:16,439
actually I so I think it's already

31
00:07:14,220 --> 00:07:20,730
pretty feasible what what I would

32
00:07:16,439 --> 00:07:21,509
recommend doing if someone were so

33
00:07:20,730 --> 00:07:27,780
inclined

34
00:07:21,509 --> 00:07:30,000
I guess maybe handmade network might be

35
00:07:27,779 --> 00:07:32,639
a place for this to happen I'm not sure

36
00:07:30,000 --> 00:07:35,509
but what I would say is there just needs

37
00:07:32,639 --> 00:07:38,629
to be a central place called like

38
00:07:35,509 --> 00:07:41,969
programmers looking for work via streams

39
00:07:38,629 --> 00:07:43,199
dot-com or whatever right but yeah it

40
00:07:41,970 --> 00:07:45,780
could just be like a subsection of

41
00:07:43,199 --> 00:07:49,079
handmade Network right and all it is is

42
00:07:45,779 --> 00:07:50,279
just a listing randomly ordered so like

43
00:07:49,079 --> 00:07:52,349
every time you go there just picks a

44
00:07:50,279 --> 00:07:54,959
random order so there's no like bias in

45
00:07:52,350 --> 00:07:56,640
like you know who you know you you you

46
00:07:54,959 --> 00:07:58,229
don't get a higher placement because

47
00:07:56,639 --> 00:08:00,719
your name starts with a or something

48
00:07:58,230 --> 00:08:02,069
right just a random list of streams of

49
00:08:00,720 --> 00:08:07,830
people who are streaming their

50
00:08:02,069 --> 00:08:09,449
programming regularly so it just links

51
00:08:07,829 --> 00:08:10,769
to their YouTube channel so you can go

52
00:08:09,449 --> 00:08:12,719
watch so that way if you're like I need

53
00:08:10,769 --> 00:08:14,459
to hire an engine person let me go see

54
00:08:12,720 --> 00:08:17,280
what the streams are and like you can

55
00:08:14,459 --> 00:08:19,049
just go do it right if those were like

56
00:08:17,279 --> 00:08:20,699
coalesced in one place I think that

57
00:08:19,050 --> 00:08:22,050
would be all you'd really need I think

58
00:08:20,699 --> 00:08:23,399
people would start going there when they

59
00:08:22,050 --> 00:08:24,449
need to hire engine people cuz they

60
00:08:23,399 --> 00:08:26,159
don't know where to get them I mean

61
00:08:24,449 --> 00:08:27,810
nobody knows right it's like there's not

62
00:08:26,160 --> 00:08:30,360
enough engine programmers out there so

63
00:08:27,810 --> 00:08:31,649
it's hard to find so I think if you just

64
00:08:30,360 --> 00:08:34,139
had a central clearinghouse it was like

65
00:08:31,649 --> 00:08:35,728
look you go to this page and anyone with

66
00:08:34,139 --> 00:08:40,289
a youtube channel that's been updated in

67
00:08:35,729 --> 00:08:41,910
the last 7 days let's say that's a

68
00:08:40,289 --> 00:08:43,829
programming stream that has submitted it

69
00:08:41,909 --> 00:08:46,819
there it goes up on there right and

70
00:08:43,830 --> 00:08:49,410
there's some may be loose curation where

71
00:08:46,820 --> 00:08:50,970
people can flag streams if they don't

72
00:08:49,409 --> 00:08:52,709
appear to actually be programming so if

73
00:08:50,970 --> 00:08:54,629
people like start submitting streams to

74
00:08:52,710 --> 00:08:57,450
it that aren't programming streams then

75
00:08:54,629 --> 00:08:59,580
you can nuke it right but I feel like

76
00:08:57,450 --> 00:09:00,810
that would be sufficient and then people

77
00:08:59,580 --> 00:09:02,400
would just start going I think you have

78
00:09:00,809 --> 00:09:05,659
to tell the industry to do it the

79
00:09:02,399 --> 00:09:05,659
industry wants to find people

80
00:09:05,948 --> 00:09:11,139
I mean they pay headhunters to find

81
00:09:08,139 --> 00:09:14,198
people lots of money so if you just had

82
00:09:11,139 --> 00:09:16,629
a service you could go to find streams

83
00:09:14,198 --> 00:09:18,969
and you know a tech lead can just spend

84
00:09:16,629 --> 00:09:21,778
a day like browsing through people

85
00:09:18,970 --> 00:09:26,470
finding one and that seems fine I don't

86
00:09:21,778 --> 00:09:30,188
think that would just work probably have

87
00:09:26,470 --> 00:09:32,048
I seen the rlm parody rlm I don't think

88
00:09:30,188 --> 00:09:33,938
I know what RAL M is parody of those

89
00:09:32,048 --> 00:09:35,769
nerd box services that send you some

90
00:09:33,938 --> 00:09:41,708
cheap stuff in a box every month I

91
00:09:35,769 --> 00:09:44,259
haven't but I did see like or here I

92
00:09:41,708 --> 00:09:46,979
should say the onion did a fake podcast

93
00:09:44,259 --> 00:09:49,058
one time that was pretty good actually

94
00:09:46,980 --> 00:09:54,039
it's just a parody of all these stupid

95
00:09:49,058 --> 00:09:55,629
podcasts and it was like the they're one

96
00:09:54,039 --> 00:09:57,938
of the things that they had an ad for in

97
00:09:55,629 --> 00:10:00,730
their podcast was box box which is a box

98
00:09:57,938 --> 00:10:02,438
of boxes that comes every month like

99
00:10:00,730 --> 00:10:05,709
different shapes and sizes of box and

100
00:10:02,438 --> 00:10:06,969
like different materials um and I

101
00:10:05,708 --> 00:10:08,918
thought that was really good I haven't

102
00:10:06,970 --> 00:10:12,089
seen the rlm parity because I don't

103
00:10:08,918 --> 00:10:12,088
think I knew what rlm is

104
00:10:30,200 --> 00:10:36,620
I started my first partner job a couple

105
00:10:34,879 --> 00:10:38,179
months ago and have been thrown into an

106
00:10:36,620 --> 00:10:39,528
unfamiliar codebase a couple times now I

107
00:10:38,179 --> 00:10:40,939
would have wouldn't have said sir

108
00:10:39,528 --> 00:10:42,230
previously but now I'd say the hardest

109
00:10:40,940 --> 00:10:44,060
part of learning a new code base is the

110
00:10:42,230 --> 00:10:45,610
threading that's nothing it crazy if

111
00:10:44,059 --> 00:10:46,849
it's not brought out carefully before

112
00:10:45,610 --> 00:10:49,820
yeah

113
00:10:46,850 --> 00:10:57,230
so I 107 agree with you and I would

114
00:10:49,820 --> 00:11:02,060
actually say that threading is a very

115
00:10:57,230 --> 00:11:06,709
large looming issue and the reason I say

116
00:11:02,059 --> 00:11:08,778
that is because there's no question that

117
00:11:06,708 --> 00:11:10,429
single threaded speeds are not really

118
00:11:08,778 --> 00:11:12,289
gonna improve hugely much so it's

119
00:11:10,429 --> 00:11:14,809
obvious that like things are getting

120
00:11:12,289 --> 00:11:18,828
faster mostly because they are able to

121
00:11:14,809 --> 00:11:20,689
run in parallel what that means is that

122
00:11:18,828 --> 00:11:22,578
we have really no choice but to use

123
00:11:20,690 --> 00:11:24,380
parallelization if we're trying to push

124
00:11:22,578 --> 00:11:26,689
any boundaries you know it's just like

125
00:11:24,379 --> 00:11:28,220
web development or whatever where

126
00:11:26,690 --> 00:11:32,630
everything's slow and takes seven years

127
00:11:28,220 --> 00:11:34,879
to complete then maybe not but in the

128
00:11:32,629 --> 00:11:37,669
like world where you're trying to push

129
00:11:34,879 --> 00:11:39,470
some kind of machine performance not

130
00:11:37,669 --> 00:11:42,620
like handmade heroes all right but we're

131
00:11:39,470 --> 00:11:44,750
not you know we're not going for broke

132
00:11:42,620 --> 00:11:47,929
right we're this is a more basic

133
00:11:44,750 --> 00:11:50,720
learning stream we're not trying to

134
00:11:47,929 --> 00:11:52,849
produce world-leading visuals or

135
00:11:50,720 --> 00:11:54,740
anything right or world-leading physics

136
00:11:52,850 --> 00:11:56,959
simulation so when you're trying to like

137
00:11:54,740 --> 00:11:58,730
push those boundaries you end up in a

138
00:11:56,958 --> 00:12:01,458
situation where like you really want

139
00:11:58,730 --> 00:12:04,370
everything to be carefully threaded and

140
00:12:01,458 --> 00:12:06,229
to work really well and to take

141
00:12:04,370 --> 00:12:08,659
advantage of as many courses you can get

142
00:12:06,230 --> 00:12:10,550
sometimes heterogeneously so you know

143
00:12:08,659 --> 00:12:14,990
cores on the CPU and course on the GPU

144
00:12:10,549 --> 00:12:17,289
and the problem is just that threaded

145
00:12:14,990 --> 00:12:19,490
programming is incredibly complicated

146
00:12:17,289 --> 00:12:20,958
single threaded programming takes a lot

147
00:12:19,490 --> 00:12:23,509
of things for granted and a lot of

148
00:12:20,958 --> 00:12:25,969
people can't even do that right you know

149
00:12:23,509 --> 00:12:28,399
it's hard to be good at architect and

150
00:12:25,970 --> 00:12:30,259
code for single threaded once you throw

151
00:12:28,399 --> 00:12:32,929
a multi thread into the mix it's very

152
00:12:30,259 --> 00:12:34,850
difficult and people tend to coalesce

153
00:12:32,929 --> 00:12:37,039
around a couple strategies like you know

154
00:12:34,850 --> 00:12:38,690
job system kind of stuff but job systems

155
00:12:37,039 --> 00:12:43,610
really aren't very good it's the other

156
00:12:38,690 --> 00:12:45,620
thing especially not

157
00:12:43,610 --> 00:12:48,230
Eric job systems that you just kind of

158
00:12:45,620 --> 00:12:50,149
force your multi-threading upon there

159
00:12:48,230 --> 00:12:52,850
they're just not very good and if you

160
00:12:50,149 --> 00:12:55,278
look at some of the more advanced work

161
00:12:52,850 --> 00:12:57,320
that's attempting to get more

162
00:12:55,278 --> 00:12:58,789
utilization and less cost of

163
00:12:57,320 --> 00:13:01,310
synchronization and stuff like this out

164
00:12:58,789 --> 00:13:04,250
of threading you realize it's just a lot

165
00:13:01,309 --> 00:13:06,949
of subtlety there right and so I feel

166
00:13:04,250 --> 00:13:09,620
like it's it's really bad and I've

167
00:13:06,950 --> 00:13:14,720
certainly had a slow painful learning

168
00:13:09,620 --> 00:13:16,669
curve myself on my latest code based

169
00:13:14,720 --> 00:13:21,019
learning how I sort of want to do things

170
00:13:16,669 --> 00:13:22,879
and it's it's just really tough there's

171
00:13:21,019 --> 00:13:26,089
a lot of competing concerns I would say

172
00:13:22,879 --> 00:13:31,278
really the biggest thing that I find is

173
00:13:26,089 --> 00:13:33,320
so demanding about it is that really

174
00:13:31,278 --> 00:13:36,110
there's two sort of separate and

175
00:13:33,320 --> 00:13:38,149
completely opposing forces which is you

176
00:13:36,110 --> 00:13:42,230
want things to be as local as possible

177
00:13:38,149 --> 00:13:44,929
as often as possible which argues for

178
00:13:42,230 --> 00:13:48,139
trying to keep things on a particular

179
00:13:44,929 --> 00:13:50,208
core as much as possible but at the same

180
00:13:48,139 --> 00:13:52,759
time you don't want cores to be idle

181
00:13:50,208 --> 00:13:54,739
which argues for you moving things

182
00:13:52,759 --> 00:14:00,289
around cords as much as possible right

183
00:13:54,740 --> 00:14:02,720
and so I kind of feel like you know a

184
00:14:00,289 --> 00:14:04,730
lot of the techniques that I would

185
00:14:02,720 --> 00:14:06,589
probably advocate now for in single

186
00:14:04,730 --> 00:14:08,600
threaded programming where I'm like you

187
00:14:06,589 --> 00:14:11,630
got to kind of do things custom to the

188
00:14:08,600 --> 00:14:13,040
to the job at hand otherwise you end up

189
00:14:11,629 --> 00:14:15,110
with these big sprawling code bases that

190
00:14:13,039 --> 00:14:17,240
are too slow and too dumb and all this

191
00:14:15,110 --> 00:14:18,528
other stuff I feel like the same thing

192
00:14:17,240 --> 00:14:21,350
kind of applies in multi-threaded

193
00:14:18,528 --> 00:14:23,088
programming and I'm not really at the

194
00:14:21,350 --> 00:14:27,230
point yet where I'm confident in sort of

195
00:14:23,089 --> 00:14:29,029
saying how to do that right but I kind

196
00:14:27,230 --> 00:14:30,528
of feel like we're seeing us probably a

197
00:14:29,028 --> 00:14:32,470
similar pattern developed where it's

198
00:14:30,528 --> 00:14:34,490
like people are throwing these

199
00:14:32,470 --> 00:14:36,410
one-size-fits-all solutions at

200
00:14:34,490 --> 00:14:39,409
multi-threading and that just it doesn't

201
00:14:36,409 --> 00:14:45,159
work if you actually want clean

202
00:14:39,409 --> 00:14:47,389
efficient high-performance programs I

203
00:14:45,159 --> 00:14:48,980
think it's actually really challenging

204
00:14:47,389 --> 00:14:51,078
and it's just saying like I'm gonna have

205
00:14:48,980 --> 00:14:53,629
a job system or Q or whatever the heck

206
00:14:51,078 --> 00:14:56,389
it's just that's not gonna cut it you

207
00:14:53,629 --> 00:14:57,179
really need to think about how you do

208
00:14:56,389 --> 00:15:00,750
your load

209
00:14:57,179 --> 00:15:03,809
saying how you arranged your various

210
00:15:00,750 --> 00:15:05,909
data structures for a locality and who

211
00:15:03,809 --> 00:15:09,869
is gonna manage what and how often other

212
00:15:05,909 --> 00:15:12,809
people are able to steal work from each

213
00:15:09,870 --> 00:15:14,310
other based on which data sets which

214
00:15:12,809 --> 00:15:18,659
data structures their need to inspect

215
00:15:14,309 --> 00:15:19,979
and you know you see it an alarming

216
00:15:18,659 --> 00:15:22,139
number of papers if you read the

217
00:15:19,980 --> 00:15:24,360
literature that are basically of the

218
00:15:22,139 --> 00:15:25,980
form hey if you take a look at the

219
00:15:24,360 --> 00:15:27,389
performance of this thing that people

220
00:15:25,980 --> 00:15:29,700
said was good for multi-threading it's

221
00:15:27,389 --> 00:15:32,939
actually slower than single threading a

222
00:15:29,700 --> 00:15:34,290
lot of the time and you know you have to

223
00:15:32,940 --> 00:15:36,000
be really careful about that sort of

224
00:15:34,289 --> 00:15:37,799
thing you need to actually make sure

225
00:15:36,000 --> 00:15:39,840
you're not spending all of your time in

226
00:15:37,799 --> 00:15:41,849
these generic systems and the way that

227
00:15:39,840 --> 00:15:43,500
they lock each other up you have to

228
00:15:41,850 --> 00:15:47,970
really think about it and I think

229
00:15:43,500 --> 00:15:49,889
customer old stuff is really very

230
00:15:47,970 --> 00:15:51,629
important for multi-threading just like

231
00:15:49,889 --> 00:15:52,830
it is for single threading and we have

232
00:15:51,629 --> 00:15:55,019
to sort of start building up our

233
00:15:52,830 --> 00:15:57,990
repertoire of how to do that easily

234
00:15:55,019 --> 00:16:01,439
efficiently and quickly and nobody is

235
00:15:57,990 --> 00:16:02,789
right like we're very few people are so

236
00:16:01,440 --> 00:16:04,290
I really do think it's a looming issue

237
00:16:02,789 --> 00:16:05,759
and it's gonna I think it's gonna play

238
00:16:04,289 --> 00:16:06,750
out very similar to a single threading

239
00:16:05,759 --> 00:16:08,189
is we're gonna have all these big

240
00:16:06,750 --> 00:16:09,419
bloated systems that claim to be the

241
00:16:08,190 --> 00:16:11,310
right thing to do they're all gonna end

242
00:16:09,419 --> 00:16:13,229
up being really crappy and we're gonna

243
00:16:11,309 --> 00:16:14,819
have to come back around to like okay we

244
00:16:13,230 --> 00:16:16,289
have to we all have to learn how to

245
00:16:14,820 --> 00:16:19,050
actually be good programmers here and

246
00:16:16,289 --> 00:16:20,189
know some basics about how you make

247
00:16:19,049 --> 00:16:22,139
these things you know what are the

248
00:16:20,190 --> 00:16:23,880
fundamental core ways I can distribute

249
00:16:22,139 --> 00:16:27,629
work how do I write those quickly and

250
00:16:23,879 --> 00:16:29,610
custom customize them easily for my job

251
00:16:27,629 --> 00:16:31,470
that I'm trying to accomplish and how do

252
00:16:29,610 --> 00:16:33,000
I measure whether I did a good job like

253
00:16:31,470 --> 00:16:37,860
I think that's what we're gonna have to

254
00:16:33,000 --> 00:16:39,750
look at in the future certainly and I

255
00:16:37,860 --> 00:16:41,909
think the work being done on GPUs kind

256
00:16:39,750 --> 00:16:44,840
of argues for that you've seen them do a

257
00:16:41,909 --> 00:16:47,279
lot of work around how they distribute

258
00:16:44,840 --> 00:16:49,500
stuff on the GPU and it keeps changing

259
00:16:47,279 --> 00:16:51,750
and keeps becoming more specialized to

260
00:16:49,500 --> 00:16:54,059
what exactly what's being done and I

261
00:16:51,750 --> 00:16:56,129
think that just gives you some idea of

262
00:16:54,059 --> 00:16:58,739
how if you actually really want to do a

263
00:16:56,129 --> 00:17:01,110
good job you can't just say I don't know

264
00:16:58,740 --> 00:17:04,740
here's some generic scheduler it's not

265
00:17:01,110 --> 00:17:06,900
generic it's very specific and you're

266
00:17:04,740 --> 00:17:09,480
gonna end up in things like okay on 16

267
00:17:06,900 --> 00:17:11,040
cores I want to dedicate two cores with

268
00:17:09,480 --> 00:17:13,470
that share and l2

269
00:17:11,039 --> 00:17:15,088
to do this one data structure and it's

270
00:17:13,470 --> 00:17:17,459
much more efficient than letting it

271
00:17:15,088 --> 00:17:19,289
bounce around and these other cores can

272
00:17:17,459 --> 00:17:22,350
sort of divide up the work evenly

273
00:17:19,289 --> 00:17:24,629
because that work is very spatially

274
00:17:22,349 --> 00:17:25,828
incoherent so I don't care about whether

275
00:17:24,630 --> 00:17:27,900
the data structure bounces around cuz

276
00:17:25,828 --> 00:17:29,129
unlikely to be in the catch anyway like

277
00:17:27,900 --> 00:17:31,830
you're gonna see a lot of stuff like

278
00:17:29,130 --> 00:17:32,280
that I think and that's just my gut

279
00:17:31,829 --> 00:17:33,929
feeling

280
00:17:32,279 --> 00:17:36,480
I don't have any evidence for any of

281
00:17:33,930 --> 00:17:38,490
this because it's way too early and so

282
00:17:36,480 --> 00:17:40,049
you know I'm not saying this is this is

283
00:17:38,490 --> 00:17:42,559
like obviously the case or anything I

284
00:17:40,049 --> 00:17:44,669
just it seems like the way it's going

285
00:17:42,559 --> 00:17:46,829
and so I would just say yeah

286
00:17:44,670 --> 00:17:49,080
multi-threading is is a huge topic

287
00:17:46,829 --> 00:17:50,519
that's coming down the pipe I'm sure

288
00:17:49,079 --> 00:17:53,819
most people are doing it poorly right

289
00:17:50,519 --> 00:17:55,379
now I'm sure that includes me and you

290
00:17:53,819 --> 00:17:56,789
know ten years from now we're gonna have

291
00:17:55,380 --> 00:17:59,280
some strong opinions about it but we're

292
00:17:56,789 --> 00:18:01,289
just we're just learning like the basics

293
00:17:59,279 --> 00:18:03,329
of how we sit down to make

294
00:18:01,289 --> 00:18:05,009
multi-threaded programs that are where

295
00:18:03,329 --> 00:18:09,240
we've thought about the right stuff

296
00:18:05,009 --> 00:18:11,819
instead of the wrong stuff and so that

297
00:18:09,240 --> 00:18:14,130
we can write them you know bug free

298
00:18:11,819 --> 00:18:15,450
really quickly like you know again a lot

299
00:18:14,130 --> 00:18:16,950
of single threaded techniques I've

300
00:18:15,450 --> 00:18:19,470
developed over programming for a long

301
00:18:16,950 --> 00:18:21,750
time you know I don't get that many bugs

302
00:18:19,470 --> 00:18:23,190
when I write you know code in certain

303
00:18:21,750 --> 00:18:25,769
ways because I've kind of like trained

304
00:18:23,190 --> 00:18:27,000
myself how to avoid a lot of the common

305
00:18:25,769 --> 00:18:29,609
things where I would have had bugs

306
00:18:27,000 --> 00:18:30,990
before right and and none of that's true

307
00:18:29,609 --> 00:18:32,339
in multi-threaded now so if I sit down

308
00:18:30,990 --> 00:18:33,870
to write a multi-threaded thing I'm

309
00:18:32,339 --> 00:18:35,639
probably gonna make a lot of stupid

310
00:18:33,869 --> 00:18:37,949
mistakes right and spend a lot more time

311
00:18:35,640 --> 00:18:39,660
debugging them and I think that that's

312
00:18:37,950 --> 00:18:41,580
again it's like a practice and a

313
00:18:39,660 --> 00:18:44,070
training issue like as I get more

314
00:18:41,579 --> 00:18:46,470
experience with multi-threaded code I

315
00:18:44,069 --> 00:18:47,879
think I would make less mistakes and I

316
00:18:46,470 --> 00:18:51,029
could write a multi-threaded thing

317
00:18:47,880 --> 00:18:56,190
cleanly without a lot of pitfalls more

318
00:18:51,029 --> 00:18:58,589
more likely as you get that practice

319
00:18:56,190 --> 00:19:00,180
right and so you you have to build it up

320
00:18:58,589 --> 00:19:01,559
it's a different discipline in a lot of

321
00:19:00,180 --> 00:19:05,279
ways and you have to learn new

322
00:19:01,559 --> 00:19:07,139
primitives and new ways of writing the

323
00:19:05,279 --> 00:19:09,809
code so that you can still write custom

324
00:19:07,140 --> 00:19:11,610
things that execute quickly but that

325
00:19:09,809 --> 00:19:13,019
don't lead you to obvious

326
00:19:11,609 --> 00:19:15,319
multi-threading pitfalls because there

327
00:19:13,019 --> 00:19:17,879
are so many of them right that exists

328
00:19:15,319 --> 00:19:20,869
either performance pitfalls or just

329
00:19:17,880 --> 00:19:20,870
correctness pitfalls

330
00:19:29,480 --> 00:19:33,960
can you explain cache misses and how to

331
00:19:32,039 --> 00:19:35,099
avoid them I'm coming from the Java

332
00:19:33,960 --> 00:19:40,370
world I've never had to think about that

333
00:19:35,099 --> 00:19:40,369
well so I guess what I would say is you

334
00:19:40,730 --> 00:19:44,400
probably should have thought about them

335
00:19:42,808 --> 00:19:46,079
in the Java world because Java has

336
00:19:44,400 --> 00:19:48,180
plenty of problems with cache misses as

337
00:19:46,079 --> 00:19:50,369
well right any program that runs on a

338
00:19:48,180 --> 00:19:53,340
modern CPU has issues with cache misses

339
00:19:50,369 --> 00:19:56,329
and so if you care about the performance

340
00:19:53,339 --> 00:20:02,970
of a program you do need to think about

341
00:19:56,329 --> 00:20:06,240
how caches affect what you're doing so I

342
00:20:02,970 --> 00:20:08,370
can give a pretty brief overview and I

343
00:20:06,240 --> 00:20:10,500
think we're gonna have a somewhat longer

344
00:20:08,369 --> 00:20:13,500
hand made hero today just because we

345
00:20:10,500 --> 00:20:16,410
didn't have one yesterday let me give

346
00:20:13,500 --> 00:20:18,210
myself a little more time here but I

347
00:20:16,410 --> 00:20:20,600
would like to explain cache misses a

348
00:20:18,210 --> 00:20:20,600
little bit

349
00:20:31,269 --> 00:20:38,960
so the thing to understand with modern

350
00:20:36,559 --> 00:20:41,839
CPU design and and let me just

351
00:20:38,960 --> 00:20:43,970
III have a honestly a better handle on

352
00:20:41,839 --> 00:20:45,470
sort of modern CPUs now than I did when

353
00:20:43,970 --> 00:20:47,630
we started Hammond hero because honestly

354
00:20:45,470 --> 00:20:50,390
we started handmade hero I was still

355
00:20:47,630 --> 00:20:56,420
mostly my brain was in the sort of Xbox

356
00:20:50,390 --> 00:20:58,790
360 Playstation 3 era which honestly I

357
00:20:56,420 --> 00:21:00,710
mean it's it's wrong to not to call

358
00:20:58,789 --> 00:21:03,710
those not modern CPUs and they obviously

359
00:21:00,710 --> 00:21:10,610
are modern CPUs but they don't really

360
00:21:03,710 --> 00:21:11,029
resemble x64 cores of of today hardly at

361
00:21:10,609 --> 00:21:17,299
all

362
00:21:11,029 --> 00:21:20,000
like an Xbox 360 cpu it's it's just I

363
00:21:17,299 --> 00:21:23,919
mean I would say it's it's almost

364
00:21:20,000 --> 00:21:27,980
completely a different mental model

365
00:21:23,920 --> 00:21:30,800
almost but since having to work on meow

366
00:21:27,980 --> 00:21:33,620
hash I had more time to sort of dig in

367
00:21:30,799 --> 00:21:38,089
to how modern CPUs like the modern X 64

368
00:21:33,619 --> 00:21:40,189
cores actually work and so I I

369
00:21:38,089 --> 00:21:42,409
definitely like from when Hannah Hiro

370
00:21:40,190 --> 00:21:44,330
started to now I've had some not related

371
00:21:42,410 --> 00:21:45,710
am a hero experience which allows me to

372
00:21:44,329 --> 00:21:47,929
kind of have a better grip on it I'm

373
00:21:45,710 --> 00:21:50,090
still not I wouldn't consider myself an

374
00:21:47,930 --> 00:21:52,130
expert on modern X 64 cores

375
00:21:50,089 --> 00:21:54,079
by any stretch of the imagination but I

376
00:21:52,130 --> 00:21:57,200
definitely have a lot better feel for

377
00:21:54,079 --> 00:21:58,579
what's going on then I originally did so

378
00:21:57,200 --> 00:22:01,850
I you know I think it's probably a good

379
00:21:58,579 --> 00:22:05,089
time for us to update sort of some of

380
00:22:01,849 --> 00:22:07,699
that discussion right compared to what I

381
00:22:05,089 --> 00:22:14,019
might have said earlier on streams so

382
00:22:07,700 --> 00:22:14,019
here's what I would say about caches

383
00:22:19,109 --> 00:22:27,369
so typically when you think about how a

384
00:22:23,680 --> 00:22:30,400
processor works in general when you

385
00:22:27,369 --> 00:22:32,619
first come at programming you really

386
00:22:30,400 --> 00:22:34,660
don't think about them at all right

387
00:22:32,619 --> 00:22:37,029
you don't even probably think about

388
00:22:34,660 --> 00:22:39,730
memory much other than that there is

389
00:22:37,029 --> 00:22:42,250
something in the computer that stores it

390
00:22:39,730 --> 00:22:44,589
and so when you're dealing with a

391
00:22:42,250 --> 00:22:46,509
language like for example especially in

392
00:22:44,589 --> 00:22:48,609
something like Java where you might not

393
00:22:46,509 --> 00:22:51,279
really even think about memory per se

394
00:22:48,609 --> 00:22:54,549
because Java is not really about

395
00:22:51,279 --> 00:22:57,190
pointers and such so you cut it kind of

396
00:22:54,549 --> 00:22:58,480
abstract away some things that you maybe

397
00:22:57,190 --> 00:23:01,240
if you were programming and see you

398
00:22:58,480 --> 00:23:03,370
would think about when you're looking at

399
00:23:01,240 --> 00:23:05,319
something like that and you start

400
00:23:03,369 --> 00:23:08,679
programming your you oftentimes don't

401
00:23:05,319 --> 00:23:10,869
really internalize what it means to have

402
00:23:08,680 --> 00:23:12,700
memory and caches right so you'll see

403
00:23:10,869 --> 00:23:16,209
things where you know you might think

404
00:23:12,700 --> 00:23:18,009
about having a you know a big array of

405
00:23:16,210 --> 00:23:20,799
integers and you're talking about you

406
00:23:18,009 --> 00:23:23,109
know I've got 4096 of these integers in

407
00:23:20,799 --> 00:23:24,849
here and then you know I can put things

408
00:23:23,109 --> 00:23:27,519
into here by saying oh you know the

409
00:23:24,849 --> 00:23:30,279
sixteenth one of these integers equals

410
00:23:27,519 --> 00:23:32,529
something right and then later you know

411
00:23:30,279 --> 00:23:34,690
I can ask what that is and I can say

412
00:23:32,529 --> 00:23:38,410
like okay I want to extract one of that

413
00:23:34,690 --> 00:23:40,420
you know those things out right and so

414
00:23:38,410 --> 00:23:43,690
when you first start programming you you

415
00:23:40,420 --> 00:23:45,610
think about memory in a pretty abstract

416
00:23:43,690 --> 00:23:48,460
way and maybe not at all where there's

417
00:23:45,609 --> 00:23:52,929
just there's this semantic concept of

418
00:23:48,460 --> 00:23:55,180
storage where I just ask for some number

419
00:23:52,930 --> 00:23:56,740
of things that get remembered I put them

420
00:23:55,180 --> 00:24:01,180
in there and when I ask to them they

421
00:23:56,740 --> 00:24:03,009
come back out right and that's you know

422
00:24:01,180 --> 00:24:05,410
totally fine for understanding the

423
00:24:03,009 --> 00:24:09,309
correctness of a program it allows you

424
00:24:05,410 --> 00:24:12,070
to think about how the program's going

425
00:24:09,309 --> 00:24:14,980
to work but what it doesn't do is tell

426
00:24:12,069 --> 00:24:18,009
you about how fast the program will do

427
00:24:14,980 --> 00:24:20,920
its work right and so that's where you

428
00:24:18,009 --> 00:24:23,440
really start to think about things like

429
00:24:20,920 --> 00:24:26,259
memory bandwidth and caches is when you

430
00:24:23,440 --> 00:24:30,610
go from sort of like the behavior or

431
00:24:26,259 --> 00:24:31,619
maybe I'll just say the correctness when

432
00:24:30,609 --> 00:24:33,599
you think about like the

433
00:24:31,619 --> 00:24:36,449
correctness of a program like what it's

434
00:24:33,599 --> 00:24:37,949
going to do right and you know we I

435
00:24:36,450 --> 00:24:40,470
guess we could use that with the what

436
00:24:37,950 --> 00:24:42,210
here right and then at some point when

437
00:24:40,470 --> 00:24:44,519
you want to get more advanced you have

438
00:24:42,210 --> 00:24:46,319
to start thinking about the how like how

439
00:24:44,519 --> 00:24:50,490
is it going to do that and that's where

440
00:24:46,319 --> 00:24:54,179
the performance aspects of things come

441
00:24:50,490 --> 00:24:58,460
in to play right and so memory bandwidth

442
00:24:54,180 --> 00:25:03,920
and caches are a fairly large part of

443
00:24:58,460 --> 00:25:09,110
how modern CPUs achieve that performance

444
00:25:03,920 --> 00:25:11,700
and so you have to stop thinking about I

445
00:25:09,109 --> 00:25:13,199
just ask for a big array of integers and

446
00:25:11,700 --> 00:25:15,569
I magically get it and some stuff

447
00:25:13,200 --> 00:25:17,670
happens right and you have to start

448
00:25:15,569 --> 00:25:20,220
thinking about where do those integers

449
00:25:17,670 --> 00:25:24,480
live how is the computer actually

450
00:25:20,220 --> 00:25:26,640
remembering what they are and how do

451
00:25:24,480 --> 00:25:29,190
they moving move around during

452
00:25:26,640 --> 00:25:33,090
computation right during the actual work

453
00:25:29,190 --> 00:25:35,670
that the computer is doing okay and so I

454
00:25:33,089 --> 00:25:37,919
think the most productive way to think

455
00:25:35,670 --> 00:25:39,300
about this sort of thing in your first

456
00:25:37,920 --> 00:25:42,240
pass when you're first trying to

457
00:25:39,299 --> 00:25:46,259
understand this stuff is to say all

458
00:25:42,240 --> 00:25:49,799
right I have to imagine that there's

459
00:25:46,259 --> 00:25:53,640
almost individual like people you know

460
00:25:49,799 --> 00:25:56,759
individual like sections where work is

461
00:25:53,640 --> 00:25:58,470
being done in this chip and they have to

462
00:25:56,759 --> 00:26:01,049
communicate with each other and it takes

463
00:25:58,470 --> 00:26:03,870
a while to communicate right so rather

464
00:26:01,049 --> 00:26:06,210
than thinking about the CPU as like some

465
00:26:03,869 --> 00:26:08,279
monolithic structure that's just like I

466
00:26:06,210 --> 00:26:11,400
don't know there's this CPU and it did

467
00:26:08,279 --> 00:26:13,470
some stuff right you need to start

468
00:26:11,400 --> 00:26:16,140
thinking of breaking this piece down

469
00:26:13,470 --> 00:26:19,529
into sections and those sections are

470
00:26:16,140 --> 00:26:21,750
actually separated by physical distance

471
00:26:19,529 --> 00:26:24,480
and they need to communicate right and

472
00:26:21,750 --> 00:26:28,529
so you have to start thinking about the

473
00:26:24,480 --> 00:26:30,420
CPU as having maybe I'll draw this

474
00:26:28,529 --> 00:26:32,490
diagram with a few basic blocks and we

475
00:26:30,420 --> 00:26:36,058
can talk about sort of what they are so

476
00:26:32,490 --> 00:26:38,009
we can think about having a block that

477
00:26:36,058 --> 00:26:40,259
you know of the CPU that we're going to

478
00:26:38,009 --> 00:26:43,049
talk about which is the thing that sort

479
00:26:40,259 --> 00:26:45,480
of decides you know what to do and when

480
00:26:43,049 --> 00:26:48,898
right there's sort of like a scheduler

481
00:26:45,480 --> 00:26:51,839
of some kind okay this is part of our

482
00:26:48,898 --> 00:26:55,319
CPM and then there's a part of the CPU

483
00:26:51,839 --> 00:26:57,509
right that's capable of doing actual

484
00:26:55,319 --> 00:26:58,950
work right there's like a there's like

485
00:26:57,509 --> 00:27:01,769
the the thing that can actually add

486
00:26:58,950 --> 00:27:04,710
numbers together right there it can it

487
00:27:01,769 --> 00:27:08,429
can produce actual results you know I'm

488
00:27:04,710 --> 00:27:10,889
saying then somewhere off in the

489
00:27:08,429 --> 00:27:14,970
distance there's your actual main memory

490
00:27:10,888 --> 00:27:16,918
right and this is the thing that stores

491
00:27:14,970 --> 00:27:20,210
stuff it's when you buy Ram that's where

492
00:27:16,919 --> 00:27:24,570
it goes right this is this is our RAM

493
00:27:20,210 --> 00:27:27,720
over here and then in here we also have

494
00:27:24,569 --> 00:27:29,428
sort of a number of other sort of places

495
00:27:27,720 --> 00:27:31,980
we have to talk to you and we'll draw

496
00:27:29,429 --> 00:27:34,740
those out now right there's a thing

497
00:27:31,980 --> 00:27:38,190
called an l1 there's thing called the l2

498
00:27:34,740 --> 00:27:43,109
there's the thing called an l3 right and

499
00:27:38,190 --> 00:27:46,649
there's a thing called a rat all right

500
00:27:43,109 --> 00:27:49,888
and so the way this stuff works is

501
00:27:46,648 --> 00:27:53,479
there's a bunch of logic inside each CPU

502
00:27:49,888 --> 00:27:55,949
core right so this is a core here

503
00:27:53,480 --> 00:27:58,110
there's a thing inside each CPU core

504
00:27:55,950 --> 00:28:00,360
which is actually looking at the things

505
00:27:58,109 --> 00:28:02,788
you told it to do right so this stuff

506
00:28:00,359 --> 00:28:04,469
here it's actually looking at the

507
00:28:02,788 --> 00:28:09,509
machine code that was generated from

508
00:28:04,470 --> 00:28:11,880
this stuff and it's figuring out what it

509
00:28:09,509 --> 00:28:14,700
should do now I know that sounds a

510
00:28:11,880 --> 00:28:16,559
little bit weird because you told it

511
00:28:14,700 --> 00:28:18,659
what you should do you're like I told

512
00:28:16,558 --> 00:28:20,190
you to put 45 somewhere and then I told

513
00:28:18,659 --> 00:28:21,419
you to get it back for me and I'm gonna

514
00:28:20,190 --> 00:28:26,100
do something with it like I'm gonna add

515
00:28:21,419 --> 00:28:28,049
you know 12 right so it feels like you

516
00:28:26,099 --> 00:28:32,189
already told the CPU what to do you're

517
00:28:28,048 --> 00:28:36,000
like here's the code right but the

518
00:28:32,190 --> 00:28:38,100
problem is a modern CPU is a huge amount

519
00:28:36,000 --> 00:28:40,409
of silicon with tons of stuff it can do

520
00:28:38,099 --> 00:28:42,599
on it tons of ways it can do work and

521
00:28:40,409 --> 00:28:46,409
what it's trying to do is maximize the

522
00:28:42,599 --> 00:28:48,089
use of that silicon right and so when

523
00:28:46,409 --> 00:28:50,100
instructions when it looks at

524
00:28:48,089 --> 00:28:52,829
instructions that you give it it's

525
00:28:50,099 --> 00:28:54,689
actually trying to figure out what of

526
00:28:52,829 --> 00:28:57,449
those instructions it could do right now

527
00:28:54,690 --> 00:28:59,279
and what would it need to do them okay

528
00:28:57,450 --> 00:29:01,680
so let me give you an

529
00:28:59,279 --> 00:29:03,089
example let's suppose that we took this

530
00:29:01,680 --> 00:29:05,820
code over here that I wrote we were

531
00:29:03,089 --> 00:29:08,250
talking about correctness let's suppose

532
00:29:05,819 --> 00:29:10,109
that in this thing I had said maybe

533
00:29:08,250 --> 00:29:11,549
something slightly a little bit more

534
00:29:10,109 --> 00:29:17,309
complicated in this but almost the same

535
00:29:11,549 --> 00:29:20,039
thing so I I did say big 16 equals 45

536
00:29:17,309 --> 00:29:24,960
right somewhere in my program then a

537
00:29:20,039 --> 00:29:27,569
bunch of stuff happened and then later

538
00:29:24,960 --> 00:29:32,579
on down here I said I want to get that

539
00:29:27,569 --> 00:29:36,319
big 16 back right I'm gonna add one

540
00:29:32,579 --> 00:29:36,319
thing up here I'm gonna say that I also

541
00:29:36,410 --> 00:29:43,410
also write here set y equal to something

542
00:29:39,809 --> 00:29:45,329
like 32 so I wanted to get that thing I

543
00:29:43,410 --> 00:29:46,620
stored in a big 16 back I want to

544
00:29:45,329 --> 00:29:48,629
actually do something with it so I'm

545
00:29:46,619 --> 00:29:52,199
gonna do like an S Plus that an X plus

546
00:29:48,630 --> 00:29:57,210
equals 53 and then I'm also gonna do a y

547
00:29:52,200 --> 00:29:59,009
plus equals 12 right so you know even

548
00:29:57,210 --> 00:30:00,329
just the same as Java you wouldn't

549
00:29:59,009 --> 00:30:01,589
really be thinking about much that's

550
00:30:00,329 --> 00:30:02,609
going on here but you wrote this stuff

551
00:30:01,589 --> 00:30:05,519
and this is what you wanted to have

552
00:30:02,609 --> 00:30:07,529
happen right and so why do we have all

553
00:30:05,519 --> 00:30:09,029
this crazy stuff happening here why am I

554
00:30:07,529 --> 00:30:10,589
saying there's this stuff what are all

555
00:30:09,029 --> 00:30:11,819
these things and what's the scheduler

556
00:30:10,589 --> 00:30:15,000
why does it have to exist why does it

557
00:30:11,819 --> 00:30:18,359
just do these things in order right and

558
00:30:15,000 --> 00:30:19,980
the answer is because when this when you

559
00:30:18,359 --> 00:30:24,679
look at how these things are designed

560
00:30:19,980 --> 00:30:28,140
right this part here that can do work is

561
00:30:24,680 --> 00:30:29,640
actually broken up into many parts so

562
00:30:28,140 --> 00:30:32,160
the part of the chip that can actually

563
00:30:29,640 --> 00:30:33,450
do work actually has lots of little

564
00:30:32,160 --> 00:30:35,970
things in it these are typically called

565
00:30:33,450 --> 00:30:37,710
al use but there's other names for

566
00:30:35,970 --> 00:30:39,630
different parts of them al used to

567
00:30:37,710 --> 00:30:42,390
answer arithmetic logic unit but you've

568
00:30:39,630 --> 00:30:45,270
got lots of different pieces of the chip

569
00:30:42,390 --> 00:30:48,800
that can do work and each one of those

570
00:30:45,269 --> 00:30:51,539
pieces has to go through a bunch of

571
00:30:48,799 --> 00:30:54,149
steps in order to produce its results

572
00:30:51,539 --> 00:30:55,680
now I'm kind of getting a little bit

573
00:30:54,150 --> 00:30:57,120
ahead of myself here because I kind of

574
00:30:55,680 --> 00:30:59,430
went down the road opinion rather to the

575
00:30:57,119 --> 00:31:03,119
complete explanation so let me sort of

576
00:30:59,430 --> 00:31:05,789
explain why that is when a CPU needs to

577
00:31:03,119 --> 00:31:07,979
do work you have to imagine that it's

578
00:31:05,789 --> 00:31:10,230
actually electricity flowing through a

579
00:31:07,980 --> 00:31:12,839
piece of silicon right it's not a magic

580
00:31:10,230 --> 00:31:16,048
abstract thing it's actual electrons

581
00:31:12,839 --> 00:31:17,759
moving right well that might not be the

582
00:31:16,048 --> 00:31:23,730
best way to say it but it's electricity

583
00:31:17,759 --> 00:31:26,429
flowing right and so what happens is if

584
00:31:23,730 --> 00:31:27,870
I want to take a number and I want to

585
00:31:26,429 --> 00:31:29,759
add two of those numbers together I

586
00:31:27,869 --> 00:31:31,619
actually have to have a physical

587
00:31:29,759 --> 00:31:33,778
representation of what a number is and

588
00:31:31,619 --> 00:31:35,239
that's where we get binary right and we

589
00:31:33,778 --> 00:31:38,490
get the concept that we can represent

590
00:31:35,240 --> 00:31:41,460
things in electrical form by having a

591
00:31:38,490 --> 00:31:43,679
series of lines each of which can either

592
00:31:41,460 --> 00:31:44,788
be you know charged or not charged

593
00:31:43,679 --> 00:31:46,169
however you want to look at how the

594
00:31:44,788 --> 00:31:48,148
electricity like it's have a certain

595
00:31:46,169 --> 00:31:50,700
amount of current or not or so on and so

596
00:31:48,148 --> 00:31:52,319
forth right and I don't do electrical

597
00:31:50,700 --> 00:31:55,288
stuff so don't ask me to explain that

598
00:31:52,319 --> 00:31:56,849
part but we know that we have a way of

599
00:31:55,288 --> 00:31:59,009
breaking this down and representing

600
00:31:56,849 --> 00:32:02,038
these numbers inside wiring inside a

601
00:31:59,009 --> 00:32:03,749
chip right but that wiring flows at a

602
00:32:02,038 --> 00:32:05,278
certain rate so if I want to do

603
00:32:03,749 --> 00:32:07,950
something like add two numbers together

604
00:32:05,278 --> 00:32:08,609
well I have to do a couple of different

605
00:32:07,950 --> 00:32:11,278
steps right

606
00:32:08,609 --> 00:32:14,128
I've got wires flowing in here that are

607
00:32:11,278 --> 00:32:17,099
binary wire encodings of the number 53

608
00:32:14,128 --> 00:32:19,648
right and I've got binary wire encodings

609
00:32:17,099 --> 00:32:23,069
of whatever was in X and these things

610
00:32:19,648 --> 00:32:24,898
have to merge together right to form an

611
00:32:23,069 --> 00:32:28,528
actual set of wires that's the output

612
00:32:24,898 --> 00:32:30,839
and when I want to do these things in

613
00:32:28,528 --> 00:32:32,970
floating point or when I want to do

614
00:32:30,839 --> 00:32:35,158
relatively complex operations like the

615
00:32:32,970 --> 00:32:37,409
add has to carry right it has to like

616
00:32:35,159 --> 00:32:39,210
know if I add two things and then and

617
00:32:37,409 --> 00:32:40,889
you know I add two binary ones together

618
00:32:39,210 --> 00:32:42,860
it's got to carry to the next one it's

619
00:32:40,888 --> 00:32:45,178
just waterfall pattern whatever right

620
00:32:42,859 --> 00:32:47,189
you have to imagine there's this huge

621
00:32:45,179 --> 00:32:49,679
series of kind of wiring happening on

622
00:32:47,190 --> 00:32:52,558
the chip and the problem is I want to

623
00:32:49,679 --> 00:32:54,119
drive this chip as fast as I can right I

624
00:32:52,558 --> 00:32:56,128
want the clock rate to be as high as

625
00:32:54,118 --> 00:32:57,538
possible and I want data to flow through

626
00:32:56,128 --> 00:33:00,329
it as fast as it can

627
00:32:57,538 --> 00:33:02,368
well let's suppose that I've got these

628
00:33:00,329 --> 00:33:04,408
stages of these wires coming in and they

629
00:33:02,368 --> 00:33:08,158
do a bunch of stuff and eventually out

630
00:33:04,409 --> 00:33:09,659
here I get an answer right so I got this

631
00:33:08,159 --> 00:33:12,330
huge circuit and it's got to go through

632
00:33:09,659 --> 00:33:15,028
these steps get an answer well if I

633
00:33:12,329 --> 00:33:18,058
actually set the clock rate of my chip

634
00:33:15,028 --> 00:33:22,409
such that here is the start of a clock

635
00:33:18,058 --> 00:33:25,980
right clock begins and here is the end

636
00:33:22,409 --> 00:33:27,060
of the clock so when I talk about a five

637
00:33:25,980 --> 00:33:29,339
gigahertz chip

638
00:33:27,059 --> 00:33:31,409
it means that this whole thing is

639
00:33:29,339 --> 00:33:34,439
happening at a rate of five gigahertz

640
00:33:31,410 --> 00:33:36,779
right it becomes almost impossible to

641
00:33:34,440 --> 00:33:39,269
build this circuit that in a way that

642
00:33:36,779 --> 00:33:41,099
doesn't melt the chip down right pushing

643
00:33:39,269 --> 00:33:42,900
enough electricity through a small

644
00:33:41,099 --> 00:33:45,449
enough space to make all this stuff work

645
00:33:42,900 --> 00:33:47,400
is just too it generates too much heat

646
00:33:45,450 --> 00:33:50,640
and it doesn't work right

647
00:33:47,400 --> 00:33:53,130
and so what chip designers do is they

648
00:33:50,640 --> 00:33:56,040
break each operation inside one of these

649
00:33:53,130 --> 00:34:00,240
logical units they break each one up

650
00:33:56,039 --> 00:34:04,170
into a clock so I do an add-in like a B

651
00:34:00,240 --> 00:34:08,280
C and D steps and I say that my ad takes

652
00:34:04,170 --> 00:34:10,200
four clocks to complete right I start

653
00:34:08,280 --> 00:34:12,330
issuing the ad here it goes to the first

654
00:34:10,199 --> 00:34:13,980
part is you the ad the second part of

655
00:34:12,329 --> 00:34:15,480
the ad next then the third part of the

656
00:34:13,980 --> 00:34:20,849
ad then the fourth part of the ad and

657
00:34:15,480 --> 00:34:24,329
it's a pipeline right so I actually take

658
00:34:20,849 --> 00:34:27,750
four clocks to complete my ad but as

659
00:34:24,329 --> 00:34:29,668
soon as the first clock finishes where

660
00:34:27,750 --> 00:34:31,648
this a is done and it comes to here and

661
00:34:29,668 --> 00:34:34,440
goes to B right as soon as the first

662
00:34:31,648 --> 00:34:36,898
clock finishes I can stick another AB in

663
00:34:34,440 --> 00:34:40,139
the beginning so that these things are

664
00:34:36,898 --> 00:34:42,539
constantly flowing through the logic of

665
00:34:40,139 --> 00:34:46,559
the chips one clock at a time like

666
00:34:42,539 --> 00:34:48,418
buckets handing them off right but each

667
00:34:46,559 --> 00:34:50,429
operation takes a certain number of

668
00:34:48,418 --> 00:34:52,168
clocks to complete and this is why when

669
00:34:50,429 --> 00:34:53,398
you go look at instruction tables if you

670
00:34:52,168 --> 00:34:56,250
ever look at the instruction tables for

671
00:34:53,398 --> 00:34:59,339
next 64 it'll say things like well this

672
00:34:56,250 --> 00:35:02,309
instruction has a throughput of one

673
00:34:59,340 --> 00:35:03,660
cycle but a latency of four cycles like

674
00:35:02,309 --> 00:35:07,230
what does that mean

675
00:35:03,659 --> 00:35:09,779
well it means that I can issue one of

676
00:35:07,230 --> 00:35:13,820
these things every cycle if I want I can

677
00:35:09,780 --> 00:35:16,470
keep feeding these into the pipeline but

678
00:35:13,820 --> 00:35:18,840
when I first feed one in I have to wait

679
00:35:16,469 --> 00:35:20,699
for clocks for that one to come out so

680
00:35:18,840 --> 00:35:22,110
as long as I have a lot of them to do it

681
00:35:20,699 --> 00:35:23,879
will appear as if they're getting done

682
00:35:22,110 --> 00:35:25,950
one every clock but if I just wanted to

683
00:35:23,880 --> 00:35:28,079
do one of them and I have to wait for it

684
00:35:25,949 --> 00:35:30,509
to that one to finish I'm gonna wait for

685
00:35:28,079 --> 00:35:32,219
four clocks right so this is a little

686
00:35:30,510 --> 00:35:33,390
bit out of the scope of what we're

687
00:35:32,219 --> 00:35:35,099
talking about I just want you to

688
00:35:33,389 --> 00:35:38,250
appreciate what's getting built here and

689
00:35:35,099 --> 00:35:40,710
how complicated it is right so even

690
00:35:38,250 --> 00:35:42,780
before we get too out of

691
00:35:40,710 --> 00:35:45,210
processors which are processors that can

692
00:35:42,780 --> 00:35:46,619
do things in orders that appear to be

693
00:35:45,210 --> 00:35:48,960
correct but that are not actually the

694
00:35:46,619 --> 00:35:52,920
order you wrote them in even in an

695
00:35:48,960 --> 00:35:56,579
inorder processor you end up with this

696
00:35:52,920 --> 00:35:59,490
part of the CPU because you need to be

697
00:35:56,579 --> 00:36:04,650
able to schedule what's going on even

698
00:35:59,489 --> 00:36:08,519
amongst these deeply pipelined inorder

699
00:36:04,650 --> 00:36:10,619
things right so you need this part of a

700
00:36:08,519 --> 00:36:12,119
chip even if you're in order meaning

701
00:36:10,619 --> 00:36:13,588
even if you're just doing things in the

702
00:36:12,119 --> 00:36:15,930
order the programmer wrote them because

703
00:36:13,588 --> 00:36:19,469
just knowing whether you can issue

704
00:36:15,929 --> 00:36:21,149
another thing require some logic but

705
00:36:19,469 --> 00:36:23,549
things get way more complicated inside

706
00:36:21,150 --> 00:36:25,380
of x64 because in the modern x64 core

707
00:36:23,550 --> 00:36:26,940
it's actually out of order so what does

708
00:36:25,380 --> 00:36:28,769
that mean well let's now go back to what

709
00:36:26,940 --> 00:36:30,510
I was trying to talk about before so

710
00:36:28,769 --> 00:36:32,909
here's the code that we actually wrote

711
00:36:30,510 --> 00:36:35,849
and what you can see in this code is we

712
00:36:32,909 --> 00:36:37,710
assigned some value to something in

713
00:36:35,849 --> 00:36:39,838
memory restoring here's some the

714
00:36:37,710 --> 00:36:42,088
sixteenth element of this big array we

715
00:36:39,838 --> 00:36:45,420
assigned the number 45 to it we did a

716
00:36:42,088 --> 00:36:47,940
bunch of stuff and then later we asked

717
00:36:45,420 --> 00:36:50,849
for that number back and we're gonna do

718
00:36:47,940 --> 00:36:53,940
some work on it right well this

719
00:36:50,849 --> 00:36:56,369
scheduler is actually able to issue

720
00:36:53,940 --> 00:36:57,900
these things in arbitrary orders so long

721
00:36:56,369 --> 00:36:59,970
as they produce the correct result

722
00:36:57,900 --> 00:37:02,910
what that means is when the scheduler

723
00:36:59,969 --> 00:37:05,279
looks at what's available here it's got

724
00:37:02,909 --> 00:37:06,868
some things okay I've got 32 which is a

725
00:37:05,280 --> 00:37:09,030
constant anybody working with I need to

726
00:37:06,869 --> 00:37:12,420
get whatever was in big sixteen I need

727
00:37:09,030 --> 00:37:14,220
to add 53 - oops - this one right here

728
00:37:12,420 --> 00:37:15,900
whatever the result of that is and I

729
00:37:14,219 --> 00:37:19,649
need to add 12 to whatever the result of

730
00:37:15,900 --> 00:37:21,720
this is right it's actually free to

731
00:37:19,650 --> 00:37:24,210
issue these in an arbitrary order which

732
00:37:21,719 --> 00:37:26,579
means it could decide to do this pair of

733
00:37:24,210 --> 00:37:29,369
operations first because it's completely

734
00:37:26,579 --> 00:37:32,519
independent of this pair of operations

735
00:37:29,369 --> 00:37:34,260
right it could also decide to do them in

736
00:37:32,519 --> 00:37:36,088
the other order it could decide to do

737
00:37:34,260 --> 00:37:37,619
this pair of operations first and then

738
00:37:36,088 --> 00:37:40,170
that one why because they're not

739
00:37:37,619 --> 00:37:42,420
dependent on each other so this part of

740
00:37:40,170 --> 00:37:44,670
the chip this scheduler part is capable

741
00:37:42,420 --> 00:37:46,500
of choosing different orders for things

742
00:37:44,670 --> 00:37:50,970
based on what would be the most

743
00:37:46,500 --> 00:37:52,139
efficient at the time okay so why am I

744
00:37:50,969 --> 00:37:54,389
seeing all this when you asked about

745
00:37:52,139 --> 00:37:56,009
caches well the answer is because one

746
00:37:54,389 --> 00:37:57,960
you start to think about caches you have

747
00:37:56,010 --> 00:38:00,720
to understand that this part of the chip

748
00:37:57,960 --> 00:38:03,588
exists there is an actual part of the

749
00:38:00,719 --> 00:38:06,118
chip that's trying to find things to do

750
00:38:03,588 --> 00:38:08,699
this part of the chip is always easier

751
00:38:06,119 --> 00:38:10,440
to understand the work unit because it's

752
00:38:08,699 --> 00:38:12,118
literally just a series of these it's

753
00:38:10,440 --> 00:38:14,309
Leary's just a series of pipelines that

754
00:38:12,119 --> 00:38:15,568
are capable of doing work and you throw

755
00:38:14,309 --> 00:38:19,019
something into them and later on it

756
00:38:15,568 --> 00:38:20,788
comes back out right but this part is

757
00:38:19,018 --> 00:38:22,259
harder and this is the part you need to

758
00:38:20,789 --> 00:38:24,528
start thinking about in order to

759
00:38:22,260 --> 00:38:29,730
understand caching

760
00:38:24,528 --> 00:38:34,278
okay so what's caching well this these

761
00:38:29,730 --> 00:38:35,869
things I wrote in here are the caches

762
00:38:34,278 --> 00:38:38,699
what do they do

763
00:38:35,869 --> 00:38:40,829
well imagine we didn't have them so

764
00:38:38,699 --> 00:38:41,939
let's imagine first that CPU didn't have

765
00:38:40,829 --> 00:38:43,589
him because CPUs didn't used to have

766
00:38:41,940 --> 00:38:45,659
caches back when you had a Commodore 64

767
00:38:43,588 --> 00:38:49,460
there was no cash on that it doesn't

768
00:38:45,659 --> 00:38:52,798
have a cache right 6502 I think that was

769
00:38:49,460 --> 00:38:56,630
or 68000 also the chip in the Amiga

770
00:38:52,798 --> 00:38:59,909
right great chip no cache on this right

771
00:38:56,630 --> 00:39:01,890
so if all you had was Ram what you have

772
00:38:59,909 --> 00:39:04,170
to remember is if you look look at a

773
00:39:01,889 --> 00:39:06,000
motherboard sometime right go look at

774
00:39:04,170 --> 00:39:09,269
the thing that's inside your computer

775
00:39:06,000 --> 00:39:10,949
the CPU is like here right and the main

776
00:39:09,268 --> 00:39:12,328
memory is like here there's like these

777
00:39:10,949 --> 00:39:16,259
sticks of memory that are sitting in

778
00:39:12,329 --> 00:39:19,559
there that distance is massive in CPU

779
00:39:16,259 --> 00:39:21,210
land just getting over there to get

780
00:39:19,559 --> 00:39:23,670
something and bringing it back

781
00:39:21,210 --> 00:39:26,099
takes a long time because we're talking

782
00:39:23,670 --> 00:39:28,619
about five gigahertz the speed of light

783
00:39:26,099 --> 00:39:29,278
at the speed of electrons is not that

784
00:39:28,619 --> 00:39:31,890
fast

785
00:39:29,278 --> 00:39:35,849
when you're talking about five billion

786
00:39:31,889 --> 00:39:37,679
times a second mm-hmm and you start to

787
00:39:35,849 --> 00:39:41,880
talk about inches which is how far these

788
00:39:37,679 --> 00:39:45,419
things are separated right so if every

789
00:39:41,880 --> 00:39:47,608
time the CPU needed some information so

790
00:39:45,420 --> 00:39:49,380
for example you wrote this this thing

791
00:39:47,608 --> 00:39:51,150
here you stored some information

792
00:39:49,380 --> 00:39:53,548
somewhere in memory and now you went to

793
00:39:51,150 --> 00:39:56,630
get it back if every time it needed that

794
00:39:53,548 --> 00:39:58,518
it had to go ask main memory for it and

795
00:39:56,630 --> 00:40:02,548
bring it back

796
00:39:58,518 --> 00:40:05,008
CPUs would just be a crawl they would be

797
00:40:02,548 --> 00:40:06,900
about 300 times I'm not making this

798
00:40:05,009 --> 00:40:07,949
number up they would be literally like

799
00:40:06,900 --> 00:40:12,660
300 times

800
00:40:07,949 --> 00:40:15,929
than they are now it's brutal how slow

801
00:40:12,659 --> 00:40:18,929
it is to go that far to get information

802
00:40:15,929 --> 00:40:22,409
right and so what would typically happen

803
00:40:18,929 --> 00:40:24,599
inside the CPU is the scheduler would do

804
00:40:22,409 --> 00:40:27,059
everything it could to keep things

805
00:40:24,599 --> 00:40:29,759
running so it would look at this piece

806
00:40:27,059 --> 00:40:31,710
of code here right and it would say on

807
00:40:29,760 --> 00:40:33,180
each one of these okay I've got to issue

808
00:40:31,710 --> 00:40:34,559
a memory request for this I got an issue

809
00:40:33,179 --> 00:40:37,199
a memory request for this I got an issue

810
00:40:34,559 --> 00:40:39,539
memory request for it for well not for

811
00:40:37,199 --> 00:40:40,949
this well I guess it does because that's

812
00:40:39,539 --> 00:40:42,420
the write back the values but you know

813
00:40:40,949 --> 00:40:44,669
maybe these are in registers who knows

814
00:40:42,420 --> 00:40:46,079
anyway point being it would be very slow

815
00:40:44,670 --> 00:40:48,000
but it would look for as much as it

816
00:40:46,079 --> 00:40:50,730
could do but it would just constantly

817
00:40:48,000 --> 00:40:52,559
run out right so it would basically it

818
00:40:50,730 --> 00:40:54,090
would issue some instructions but then

819
00:40:52,559 --> 00:40:57,539
it would constantly be sitting there

820
00:40:54,090 --> 00:40:59,640
waiting on that roundtrip why because if

821
00:40:57,539 --> 00:41:02,670
you look at the amount of time it takes

822
00:40:59,639 --> 00:41:06,569
for this this takes like 300 clocks to

823
00:41:02,670 --> 00:41:10,530
do and these operations like to add they

824
00:41:06,570 --> 00:41:12,630
only take like 4 right so every time you

825
00:41:10,530 --> 00:41:14,700
were gonna go do an operation you would

826
00:41:12,630 --> 00:41:15,960
have to wait 300 clocks to get the thing

827
00:41:14,699 --> 00:41:18,269
you're gonna operate on and then you'd

828
00:41:15,960 --> 00:41:21,869
be done like that for clocks to be done

829
00:41:18,269 --> 00:41:24,659
right and so all of this silicon would

830
00:41:21,869 --> 00:41:27,960
just be idle most of the time because it

831
00:41:24,659 --> 00:41:29,940
would have nothing to feed the the units

832
00:41:27,960 --> 00:41:33,840
that do the actual work it just couldn't

833
00:41:29,940 --> 00:41:36,599
do it I'd have no data there's no data

834
00:41:33,840 --> 00:41:39,300
so what the counters are designed to do

835
00:41:36,599 --> 00:41:41,699
is the caches are designed to speed up

836
00:41:39,300 --> 00:41:48,050
this round-trip by exploiting the fact

837
00:41:41,699 --> 00:41:54,989
that most of the time when we do work on

838
00:41:48,050 --> 00:41:57,240
data in a CPU it's predictable which

839
00:41:54,989 --> 00:41:59,939
memory it will operate on right that's

840
00:41:57,239 --> 00:42:04,500
what a cache is a cache is a thing that

841
00:41:59,940 --> 00:42:07,860
tries to predict what Ram the CPU will

842
00:42:04,500 --> 00:42:08,969
ask for and it tries to have that

843
00:42:07,860 --> 00:42:11,730
information

844
00:42:08,969 --> 00:42:16,019
closer to the CPU core that's going to

845
00:42:11,730 --> 00:42:21,210
want it then the actual RAM and so the

846
00:42:16,019 --> 00:42:24,389
clocks for accessing these caches

847
00:42:21,210 --> 00:42:26,639
are much more favorable than the 300

848
00:42:24,389 --> 00:42:29,239
clock round-trip so main memory maybe

849
00:42:26,639 --> 00:42:32,400
takes 300 clocks to get something out of

850
00:42:29,239 --> 00:42:35,429
l1 which is the closest possible type of

851
00:42:32,400 --> 00:42:37,889
cache takes about one sometimes two

852
00:42:35,429 --> 00:42:41,098
depends on the situation but it's very

853
00:42:37,889 --> 00:42:43,199
cheap right so it's even faster than

854
00:42:41,099 --> 00:42:44,730
like sometimes one of these operations

855
00:42:43,199 --> 00:42:47,308
some of these operations can take

856
00:42:44,730 --> 00:42:49,858
several cycles l1 can be even faster

857
00:42:47,309 --> 00:42:54,690
than an operation that's how fast l1 is

858
00:42:49,858 --> 00:42:56,909
l2 is more like 16 clocks right so it's

859
00:42:54,690 --> 00:42:59,608
still it's quite a bit slower but way

860
00:42:56,909 --> 00:43:02,608
faster than this still 10 times faster

861
00:42:59,608 --> 00:43:07,078
20 times faster than a main memory fetch

862
00:43:02,608 --> 00:43:09,420
and then l3 I don't really remember what

863
00:43:07,079 --> 00:43:11,490
the clocks are on it but you know again

864
00:43:09,420 --> 00:43:13,200
it's between these two and it probably

865
00:43:11,489 --> 00:43:14,879
depends on the chip but you know

866
00:43:13,199 --> 00:43:17,489
somewhere in between these two is gonna

867
00:43:14,880 --> 00:43:20,010
be the ll3 rate and then as you might

868
00:43:17,489 --> 00:43:21,989
imagine each of these pieces of memory

869
00:43:20,010 --> 00:43:24,000
because we're like the way these work is

870
00:43:21,989 --> 00:43:25,769
these are actually on the cpu most of

871
00:43:24,000 --> 00:43:29,670
time this one might not be but these two

872
00:43:25,769 --> 00:43:33,599
always are so the l1 in the l2 caches

873
00:43:29,670 --> 00:43:36,809
are like welded on to a cpu or per core

874
00:43:33,599 --> 00:43:39,510
and the way that they work is they are

875
00:43:36,809 --> 00:43:42,089
just like sitting right next to the

876
00:43:39,510 --> 00:43:43,799
compute units feeding them with data as

877
00:43:42,088 --> 00:43:48,210
fast as possible right

878
00:43:43,798 --> 00:43:51,210
as a result they can't be as large this

879
00:43:48,210 --> 00:43:54,298
l1 cache is often something like 32 K

880
00:43:51,210 --> 00:43:57,119
right so you know main memory these days

881
00:43:54,298 --> 00:44:00,420
you might have like 64 gigabytes in even

882
00:43:57,119 --> 00:44:02,460
a home computer right mm-hmm could have

883
00:44:00,420 --> 00:44:03,930
something like that certainly most

884
00:44:02,460 --> 00:44:05,579
computers these they have 4 gigabytes

885
00:44:03,929 --> 00:44:07,949
even a phone will have 4 gigabytes

886
00:44:05,579 --> 00:44:10,920
sometimes right so you've got a ton of

887
00:44:07,949 --> 00:44:12,989
this memory 32 K tiny little bit of

888
00:44:10,920 --> 00:44:14,760
memory right then you've got an l2 cache

889
00:44:12,989 --> 00:44:16,618
who knows how big that is it's usually

890
00:44:14,760 --> 00:44:18,690
on the order of megabytes what 2

891
00:44:16,619 --> 00:44:23,608
megabytes who knows how big it is 1

892
00:44:18,690 --> 00:44:25,349
megabyte something like that right no

893
00:44:23,608 --> 00:44:30,838
that's not I'm wrong about that that's

894
00:44:25,349 --> 00:44:33,470
it's it's more like 256 K I'm sorry I

895
00:44:30,838 --> 00:44:36,559
misspoke it's like 120 26 K I don't know

896
00:44:33,469 --> 00:44:37,969
- usually that's my this is where we're

897
00:44:36,559 --> 00:44:39,858
on the order of mega bytes when we get

898
00:44:37,969 --> 00:44:42,379
up to l3 cache I don't think you

899
00:44:39,858 --> 00:44:43,639
typically have megabyte l two's I could

900
00:44:42,380 --> 00:44:45,829
be wrong about that somebody look it up

901
00:44:43,639 --> 00:44:47,509
there's a good place called wiki chip if

902
00:44:45,829 --> 00:44:49,579
you don't know about it that has like

903
00:44:47,510 --> 00:44:51,290
all processors on it and how big like

904
00:44:49,579 --> 00:44:53,240
their caches are and stuff like that so

905
00:44:51,289 --> 00:44:55,338
you know don't take my poor memory for

906
00:44:53,239 --> 00:44:57,019
it go look it up but anyway point being

907
00:44:55,338 --> 00:45:01,159
whatever CPUs in your machine you can

908
00:44:57,019 --> 00:45:03,380
look up exactly what these are okay so

909
00:45:01,159 --> 00:45:06,799
what actually happens inside the CPU

910
00:45:03,380 --> 00:45:09,410
core is whenever it goes to operate on

911
00:45:06,800 --> 00:45:11,839
data it doesn't ask main memory for

912
00:45:09,409 --> 00:45:14,449
stuff what it does is it asks the cache

913
00:45:11,838 --> 00:45:18,078
so when it comes down here and it says

914
00:45:14,449 --> 00:45:20,899
hey I need this big 16 value I need you

915
00:45:18,079 --> 00:45:24,349
to give me that what it does is it says

916
00:45:20,900 --> 00:45:27,530
ok let me ask the l1 cache and see if

917
00:45:24,349 --> 00:45:29,510
the l1 cache has it if the l1 cache has

918
00:45:27,530 --> 00:45:31,490
it I can get the result back in 1

919
00:45:29,510 --> 00:45:33,560
o'clock that's three hundred times

920
00:45:31,489 --> 00:45:36,858
faster or more than going to main memory

921
00:45:33,559 --> 00:45:38,719
great but the l1 cache may not have it

922
00:45:36,858 --> 00:45:41,289
if the l1 cache doesn't have it what

923
00:45:38,719 --> 00:45:46,068
will the l1 cache do it'll ask the l2

924
00:45:41,289 --> 00:45:50,420
still 16 clocks we saved 20 times the

925
00:45:46,068 --> 00:45:52,009
speed we save right very very good so

926
00:45:50,420 --> 00:45:54,289
we're gonna ask the l2 cache next does

927
00:45:52,010 --> 00:45:55,819
it have it if so then what happens is

928
00:45:54,289 --> 00:46:00,889
there's two types of caches there's

929
00:45:55,818 --> 00:46:03,500
inclusive and exclusive in an inclusive

930
00:46:00,889 --> 00:46:05,719
cache what that means is that the the

931
00:46:03,500 --> 00:46:07,550
data is stored in all the caches so for

932
00:46:05,719 --> 00:46:09,500
example if I ask the l2 for something

933
00:46:07,550 --> 00:46:11,089
and it doesn't have it it's gonna like

934
00:46:09,500 --> 00:46:12,710
figure out what it is and put it in here

935
00:46:11,088 --> 00:46:14,659
and then will also put it in the in the

936
00:46:12,710 --> 00:46:16,550
l1 right whatever the data is will like

937
00:46:14,659 --> 00:46:19,578
get filled into each of these caches and

938
00:46:16,550 --> 00:46:22,789
they'll all hold it whereas an exclusive

939
00:46:19,579 --> 00:46:25,880
catch only one cache holds it right or

940
00:46:22,789 --> 00:46:28,730
and you can you don't have to have them

941
00:46:25,880 --> 00:46:30,050
all operate the same way you can say you

942
00:46:28,730 --> 00:46:32,809
can have different designs where like

943
00:46:30,050 --> 00:46:34,910
the l1 and the l2 are inclusive so it'll

944
00:46:32,809 --> 00:46:37,279
get stored in both of these but the l2

945
00:46:34,909 --> 00:46:39,139
and the l3 are exclusive so it won't

946
00:46:37,280 --> 00:46:41,119
store it here if it's here and it won't

947
00:46:39,139 --> 00:46:43,789
store it in either of these if it's here

948
00:46:41,119 --> 00:46:46,460
right so inclusive and exclusive can can

949
00:46:43,789 --> 00:46:47,210
be across any set of caches that's just

950
00:46:46,460 --> 00:46:49,389
how the hardware

951
00:46:47,210 --> 00:46:51,858
- choose to do it or whatever right and

952
00:46:49,389 --> 00:46:53,000
so what happens is it's like I said at

953
00:46:51,858 --> 00:46:54,079
the beginning it's good to think of

954
00:46:53,000 --> 00:46:55,670
these things as people communicate

955
00:46:54,079 --> 00:46:57,139
mature because they kind of are what

956
00:46:55,670 --> 00:46:58,909
happens is the chips like I need this

957
00:46:57,139 --> 00:47:01,219
piece of data it'll ask the l1 l2

958
00:46:58,909 --> 00:47:03,139
doesn't have it'll be like hey l2 do you

959
00:47:01,219 --> 00:47:05,149
have it the l2 will be like no I don't

960
00:47:03,139 --> 00:47:06,679
l3 do you have it no I don't mean memory

961
00:47:05,150 --> 00:47:07,730
do you have it of course you do because

962
00:47:06,679 --> 00:47:12,348
your main memory you have everything

963
00:47:07,730 --> 00:47:13,760
it'll then come back back back and now

964
00:47:12,349 --> 00:47:17,269
the CPU can have it right

965
00:47:13,760 --> 00:47:22,369
so it's this communication chain right

966
00:47:17,269 --> 00:47:26,210
that that goes and gets it okay um and

967
00:47:22,369 --> 00:47:30,380
so what we're gonna come around full

968
00:47:26,210 --> 00:47:33,108
circle to here right is you wanted to

969
00:47:30,380 --> 00:47:35,210
know what our cache misses and how do I

970
00:47:33,108 --> 00:47:36,469
avoid them well hopefully now you can

971
00:47:35,210 --> 00:47:40,429
almost sort of answer that question for

972
00:47:36,469 --> 00:47:42,649
yourself when we talk about getting when

973
00:47:40,429 --> 00:47:44,449
we talk about that scheduler asking for

974
00:47:42,650 --> 00:47:45,559
this piece of memory that it needs that

975
00:47:44,449 --> 00:47:49,819
it knows it's going to need to execute

976
00:47:45,559 --> 00:47:52,699
something when it asks and the answer is

977
00:47:49,820 --> 00:47:55,070
I don't have it that's a cache miss and

978
00:47:52,699 --> 00:47:57,289
when the answer is yes I do have it

979
00:47:55,070 --> 00:47:58,940
that's a cache hit now when you say

980
00:47:57,289 --> 00:48:00,980
cache miss or cache hit it's an

981
00:47:58,940 --> 00:48:04,309
incomplete statement because there's at

982
00:48:00,980 --> 00:48:08,179
least two often three caches on most

983
00:48:04,309 --> 00:48:10,969
CPUs right so what that means is when

984
00:48:08,179 --> 00:48:13,368
you say cache miss you have to say which

985
00:48:10,969 --> 00:48:15,709
cast you're missing maybe you said meant

986
00:48:13,369 --> 00:48:17,269
you missed all the caches or maybe you

987
00:48:15,710 --> 00:48:20,780
meant you missed only a few of the

988
00:48:17,269 --> 00:48:24,320
caches and which one you miss how many

989
00:48:20,780 --> 00:48:28,839
you miss versus hit determines how slow

990
00:48:24,320 --> 00:48:32,690
that return of information will be right

991
00:48:28,838 --> 00:48:35,449
so let's suppose I ask for a piece of

992
00:48:32,690 --> 00:48:38,750
memory this memory I need here where I

993
00:48:35,449 --> 00:48:41,088
put 45 in so what happens when I put 45

994
00:48:38,750 --> 00:48:42,769
into that piece of memory well when I

995
00:48:41,088 --> 00:48:46,670
need to actually write this back there's

996
00:48:42,769 --> 00:48:48,259
actually a thing here there's things

997
00:48:46,670 --> 00:48:50,480
called right back tables and there's

998
00:48:48,260 --> 00:48:52,130
these there's lines that actually come

999
00:48:50,480 --> 00:48:53,539
here somebody we should do like I'm

1000
00:48:52,130 --> 00:48:56,329
going to spend three hours talking about

1001
00:48:53,539 --> 00:48:58,039
how an X 64 works because it's there's

1002
00:48:56,329 --> 00:49:00,619
all these parts in here but basically

1003
00:48:58,039 --> 00:49:03,079
what happens is there's a

1004
00:49:00,619 --> 00:49:04,940
piece of the chip that's responsible for

1005
00:49:03,079 --> 00:49:06,710
like handing things back to the l1

1006
00:49:04,940 --> 00:49:09,889
that's actually like rights that are

1007
00:49:06,710 --> 00:49:11,510
going back right so there's read lines

1008
00:49:09,889 --> 00:49:13,069
and write lines and what happens is you

1009
00:49:11,510 --> 00:49:14,900
know we end up building up these things

1010
00:49:13,070 --> 00:49:16,580
that have to go out to the l1 when they

1011
00:49:14,900 --> 00:49:19,010
go out to the l1 so like I did this

1012
00:49:16,579 --> 00:49:21,079
right I changed some values I put 45

1013
00:49:19,010 --> 00:49:22,970
into some piece of memory it's got to go

1014
00:49:21,079 --> 00:49:25,069
out here into these cache like there's

1015
00:49:22,969 --> 00:49:27,739
the 45 eventually gets written out to

1016
00:49:25,070 --> 00:49:30,559
the l1 there's the 45 the l1 informs the

1017
00:49:27,739 --> 00:49:32,750
l2 there's the 45 the L the l2 informs

1018
00:49:30,559 --> 00:49:34,659
the l3 there's the 45 it reforms to

1019
00:49:32,750 --> 00:49:41,030
memory there's the 45 it's stored there

1020
00:49:34,659 --> 00:49:46,460
later as we're doing stuff we only have

1021
00:49:41,030 --> 00:49:49,490
32 K of cash in our l1 right so what

1022
00:49:46,460 --> 00:49:51,740
happens is eventually it gets used it

1023
00:49:49,489 --> 00:49:54,319
gets used up we're doing stuff and we're

1024
00:49:51,739 --> 00:49:56,089
swapping things in and out right the

1025
00:49:54,320 --> 00:49:58,130
chip is trying to predict what you're

1026
00:49:56,090 --> 00:50:01,100
going to need and keep this l1 as filled

1027
00:49:58,130 --> 00:50:03,470
as possible with stuff but eventually

1028
00:50:01,099 --> 00:50:05,299
things have to get removed there's only

1029
00:50:03,469 --> 00:50:07,069
32 K and you're accessing all this

1030
00:50:05,300 --> 00:50:08,600
memory eventually what happens is

1031
00:50:07,070 --> 00:50:10,970
something gets removed from the cache

1032
00:50:08,599 --> 00:50:12,440
that you actually wanted that 45 we're

1033
00:50:10,969 --> 00:50:13,849
gonna use again but it gets removed

1034
00:50:12,440 --> 00:50:16,309
because there wasn't room for it right

1035
00:50:13,849 --> 00:50:19,279
and maybe it also gets removed from the

1036
00:50:16,309 --> 00:50:20,539
l2 because again we just we you we were

1037
00:50:19,280 --> 00:50:23,150
touching all this memory and doing

1038
00:50:20,539 --> 00:50:25,159
operations like right in here in this

1039
00:50:23,150 --> 00:50:27,470
stuff we're doing a bunch of stuff we

1040
00:50:25,159 --> 00:50:30,379
used a bunch of axis you know we ax

1041
00:50:27,469 --> 00:50:32,389
bunch of memory and then eventually we

1042
00:50:30,380 --> 00:50:34,940
come around and we want the 45 again

1043
00:50:32,389 --> 00:50:37,309
right here's our here's our code big 16

1044
00:50:34,940 --> 00:50:39,380
we're asking for that 45 again again

1045
00:50:37,309 --> 00:50:41,239
even in Java you know there's no Polly

1046
00:50:39,380 --> 00:50:43,130
nur's here or anything it's just I

1047
00:50:41,239 --> 00:50:47,599
needed some values that I that you know

1048
00:50:43,130 --> 00:50:49,130
I was using before right so I go to ask

1049
00:50:47,599 --> 00:50:52,489
for it what do I find

1050
00:50:49,130 --> 00:50:54,740
well the l1 is a Miss right I get a Miss

1051
00:50:52,489 --> 00:50:56,809
on l1 because that 45 is gone it's out

1052
00:50:54,739 --> 00:50:58,879
of there I asked the l2 what happens

1053
00:50:56,809 --> 00:51:02,989
that's a Miss as well so I've missed the

1054
00:50:58,880 --> 00:51:06,740
l1 and the l2 but I asked the l3 it's

1055
00:51:02,989 --> 00:51:09,469
still in there so what was my cache miss

1056
00:51:06,739 --> 00:51:12,529
sure miss or cache hit I missed the l1 I

1057
00:51:09,469 --> 00:51:14,539
missed the l2 but I hit the l3 and

1058
00:51:12,530 --> 00:51:16,430
that's the first thing to understand

1059
00:51:14,539 --> 00:51:17,960
these cache misses and hits when you say

1060
00:51:16,429 --> 00:51:19,969
I'm gonna miss the cache or hit the

1061
00:51:17,960 --> 00:51:21,230
cache you're actually need to be more

1062
00:51:19,969 --> 00:51:23,659
specific if you're actually talking

1063
00:51:21,230 --> 00:51:25,940
about for us reading which passes caches

1064
00:51:23,659 --> 00:51:29,059
did you miss and which caches did you

1065
00:51:25,940 --> 00:51:32,119
hit it's very likely to have an l1 cache

1066
00:51:29,059 --> 00:51:34,400
mish cache miss there's only 32 K in

1067
00:51:32,119 --> 00:51:36,319
there it's less likely to have an l2

1068
00:51:34,400 --> 00:51:38,389
cache miss but it's still very possible

1069
00:51:36,320 --> 00:51:40,970
to descend it's very unlikely to have an

1070
00:51:38,389 --> 00:51:42,500
l3 cache miss but if you're actually

1071
00:51:40,969 --> 00:51:44,239
working a large amount of memory then

1072
00:51:42,500 --> 00:51:50,860
you can and so then you're out to main

1073
00:51:44,239 --> 00:51:56,539
memory and that's the slowest right okay

1074
00:51:50,860 --> 00:52:00,019
so let's talk about a more complete

1075
00:51:56,539 --> 00:52:04,340
picture of what's going on as I said

1076
00:52:00,019 --> 00:52:06,349
we've got a scheduler this scheduler is

1077
00:52:04,340 --> 00:52:10,850
looking at all of the things that you've

1078
00:52:06,349 --> 00:52:12,829
put into it that it can do what it's

1079
00:52:10,849 --> 00:52:18,500
looking for are things that are

1080
00:52:12,829 --> 00:52:27,559
independent right or what we could call

1081
00:52:18,500 --> 00:52:29,960
dependency chains which are syriza's of

1082
00:52:27,559 --> 00:52:33,079
instructions that require the results of

1083
00:52:29,960 --> 00:52:39,980
each other to execute right so if I say

1084
00:52:33,079 --> 00:52:45,969
int X equals 5x plus equals 17 x equals

1085
00:52:39,980 --> 00:52:49,579
x shifted by 2 x equals x plus 5 right

1086
00:52:45,969 --> 00:52:51,379
if I talk about these kinds of things

1087
00:52:49,579 --> 00:52:52,549
now obviously they're all constants so

1088
00:52:51,380 --> 00:52:55,610
actually the compiler could all do this

1089
00:52:52,550 --> 00:53:00,550
but you know let me try giving you

1090
00:52:55,610 --> 00:53:00,550
something a little bit more realistic

1091
00:53:00,670 --> 00:53:08,059
let's suppose we have some function of x

1092
00:53:05,599 --> 00:53:11,539
and y and I'm going to do some stuff

1093
00:53:08,059 --> 00:53:17,269
here I'm going to say X plus equals Y X

1094
00:53:11,539 --> 00:53:21,529
shifted up by 7 X mod Y something like

1095
00:53:17,269 --> 00:53:24,679
this not equals Y these are all

1096
00:53:21,530 --> 00:53:27,470
dependent instructions I need to do this

1097
00:53:24,679 --> 00:53:28,219
ad before I can do this shift before I

1098
00:53:27,469 --> 00:53:31,368
can do this

1099
00:53:28,219 --> 00:53:34,939
maude right so what this looks like to a

1100
00:53:31,369 --> 00:53:38,510
modern CPU is a series of dependent

1101
00:53:34,940 --> 00:53:41,030
instructions it can only issue them in

1102
00:53:38,510 --> 00:53:43,760
order because it can never it can't

1103
00:53:41,030 --> 00:53:45,470
start this till it knows what this is

1104
00:53:43,760 --> 00:53:46,060
going to evaluate to and the same is

1105
00:53:45,469 --> 00:53:49,669
true here

1106
00:53:46,059 --> 00:53:54,380
on the other hand a similar function f

1107
00:53:49,670 --> 00:53:58,970
of XY that looked like this s x plus

1108
00:53:54,380 --> 00:54:03,769
equals 5 y by itself shifted up 7 x mod

1109
00:53:58,969 --> 00:54:06,348
y right this instruction and this

1110
00:54:03,769 --> 00:54:08,358
instruction are linearly questions are

1111
00:54:06,349 --> 00:54:12,410
linearly that's majors on the turn are

1112
00:54:08,358 --> 00:54:15,858
independent I don't need to know this to

1113
00:54:12,409 --> 00:54:18,769
start computing this right and so the

1114
00:54:15,858 --> 00:54:21,380
scheduler knows it will need the result

1115
00:54:18,769 --> 00:54:23,358
of both of these to compute this but it

1116
00:54:21,380 --> 00:54:25,070
will not need the result of this to

1117
00:54:23,358 --> 00:54:26,630
compute this nor will it need the result

1118
00:54:25,070 --> 00:54:28,400
of this to compute this so these are

1119
00:54:26,630 --> 00:54:32,530
independent why am I talking about this

1120
00:54:28,400 --> 00:54:35,630
well this is what actually determines

1121
00:54:32,530 --> 00:54:40,099
whether a cache miss of any of these

1122
00:54:35,630 --> 00:54:43,150
caches l1 l2 or l3 actually causes a

1123
00:54:40,099 --> 00:54:47,440
performance stall in your program

1124
00:54:43,150 --> 00:54:50,088
because when you look at a block of code

1125
00:54:47,440 --> 00:54:52,250
what you need to know as to whether

1126
00:54:50,088 --> 00:54:54,219
cache misses will actually affect that

1127
00:54:52,250 --> 00:54:58,280
piece of code significantly or not is

1128
00:54:54,219 --> 00:55:02,209
you have to know what will the CPU

1129
00:54:58,280 --> 00:55:06,859
actually be able to execute at the time

1130
00:55:02,210 --> 00:55:08,929
when the cache miss occurs ok so let's

1131
00:55:06,858 --> 00:55:11,659
talk about each of these if you've

1132
00:55:08,929 --> 00:55:13,579
missed the l1 cache write or let me

1133
00:55:11,659 --> 00:55:17,179
rephrase it a little bit more positively

1134
00:55:13,579 --> 00:55:20,150
if I hit the l1 cache basically there's

1135
00:55:17,179 --> 00:55:22,460
no very little chance that you can stall

1136
00:55:20,150 --> 00:55:24,410
the processor at all right and the

1137
00:55:22,460 --> 00:55:28,059
reason is because the l1 cache can

1138
00:55:24,409 --> 00:55:33,949
deliver information to me at 1 o'clock

1139
00:55:28,059 --> 00:55:35,570
latency so basically every cycle that

1140
00:55:33,949 --> 00:55:38,149
I'm issuing that I'm trying to do work

1141
00:55:35,570 --> 00:55:42,200
the l1 is there ready to provide

1142
00:55:38,150 --> 00:55:43,700
information now I say sort of

1143
00:55:42,199 --> 00:55:48,189
because there's one more thing we didn't

1144
00:55:43,699 --> 00:55:54,139
talk about which is a thing called IPC

1145
00:55:48,190 --> 00:55:55,970
IPC is instructions per clock and what

1146
00:55:54,139 --> 00:55:58,519
ends up happening inside modern

1147
00:55:55,969 --> 00:56:02,088
processors like the modern x64 course is

1148
00:55:58,519 --> 00:56:04,550
this scheduler doesn't have to eliminate

1149
00:56:02,088 --> 00:56:06,619
it doesn't have to limit itself to only

1150
00:56:04,550 --> 00:56:11,630
issuing one piece of work to the cores

1151
00:56:06,619 --> 00:56:13,430
every to the work units every cycle in a

1152
00:56:11,630 --> 00:56:17,260
modern x64 a core it can actually issue

1153
00:56:13,429 --> 00:56:20,118
up to four instructions per cycle okay

1154
00:56:17,260 --> 00:56:22,900
so there are additional complexities

1155
00:56:20,119 --> 00:56:25,338
even when analyzing l1 cache usage and

1156
00:56:22,900 --> 00:56:29,869
those additional complexities are of the

1157
00:56:25,338 --> 00:56:32,719
form because the l1 can only supply two

1158
00:56:29,869 --> 00:56:35,269
cache lines per clock back to the CPU

1159
00:56:32,719 --> 00:56:38,838
core in most architectures I think now I

1160
00:56:35,269 --> 00:56:40,969
I don't know about Zen 3 your Zen

1161
00:56:38,838 --> 00:56:43,789
whatever the new Zen is that they just

1162
00:56:40,969 --> 00:56:47,358
released I actually don't know what that

1163
00:56:43,789 --> 00:56:51,949
l1 CAC cache providing is but at least

1164
00:56:47,358 --> 00:56:53,989
on skylake and sky like X and coffee

1165
00:56:51,949 --> 00:56:56,299
like in all the lakes all those new

1166
00:56:53,989 --> 00:56:59,659
Lakes from Intel

1167
00:56:56,300 --> 00:57:03,550
so the l1 cache can actually only

1168
00:56:59,659 --> 00:57:07,909
provide to the CPU core 2 cache lines

1169
00:57:03,550 --> 00:57:09,200
worth of data so again just to give you

1170
00:57:07,909 --> 00:57:12,108
a more complete picture because I'm in

1171
00:57:09,199 --> 00:57:14,739
the mood to explain what does this mean

1172
00:57:12,108 --> 00:57:14,739
well

1173
00:57:21,519 --> 00:57:25,969
what it means is we now have to start

1174
00:57:24,260 --> 00:57:27,500
talking because in all of that

1175
00:57:25,969 --> 00:57:29,239
discussion you'll notice I never said

1176
00:57:27,500 --> 00:57:30,980
what it means I me just said Kanna we

1177
00:57:29,239 --> 00:57:33,619
store the number 45 and it comes back

1178
00:57:30,980 --> 00:57:35,150
right but well what do you mean the

1179
00:57:33,619 --> 00:57:35,839
number 45 I mean that's not very

1180
00:57:35,150 --> 00:57:37,490
specific

1181
00:57:35,840 --> 00:57:39,230
what are these caches actually storing

1182
00:57:37,489 --> 00:57:41,269
and how are they storing them well you

1183
00:57:39,230 --> 00:57:43,789
wouldn't really need to know if there

1184
00:57:41,269 --> 00:57:45,860
wasn't such a thing as a cache line but

1185
00:57:43,789 --> 00:57:47,199
there is and so you do and so here's how

1186
00:57:45,860 --> 00:57:51,079
that works

1187
00:57:47,199 --> 00:57:54,799
caches don't move things around on the

1188
00:57:51,079 --> 00:57:59,299
order of bits so when you say 45 well I

1189
00:57:54,800 --> 00:58:02,930
could encode 45 in six bits right I mean

1190
00:57:59,300 --> 00:58:05,240
that's just basic binary math but the

1191
00:58:02,929 --> 00:58:07,009
question is how many bits is the cache

1192
00:58:05,239 --> 00:58:10,369
going to move when I ask for the number

1193
00:58:07,010 --> 00:58:12,800
45 from memory right and the answer is

1194
00:58:10,369 --> 00:58:17,420
the cache always treats things in

1195
00:58:12,800 --> 00:58:19,900
multiples of 64 bytes it just doesn't

1196
00:58:17,420 --> 00:58:25,369
know whether to quote there it just does

1197
00:58:19,900 --> 00:58:28,430
64 bytes is called a cache line and the

1198
00:58:25,369 --> 00:58:32,299
cache will never to the best of my

1199
00:58:28,429 --> 00:58:37,940
knowledge move something smaller than 64

1200
00:58:32,300 --> 00:58:42,140
bytes around so now we get into some of

1201
00:58:37,940 --> 00:58:46,010
the subtleties of the way that this data

1202
00:58:42,139 --> 00:58:49,190
is partitioned what this means is when I

1203
00:58:46,010 --> 00:58:51,050
look at my instructions for clock and my

1204
00:58:49,190 --> 00:58:54,200
cache line size these things start to

1205
00:58:51,050 --> 00:58:56,170
become very relevant why because when I

1206
00:58:54,199 --> 00:58:59,869
talk about a cache miss or a cache hit

1207
00:58:56,170 --> 00:59:02,750
I'm not just talking about the one byte

1208
00:58:59,869 --> 00:59:04,339
the four bytes the eight bytes I might

1209
00:59:02,750 --> 00:59:07,070
have needed for the particular

1210
00:59:04,340 --> 00:59:11,030
instruction that the CPU is executing at

1211
00:59:07,070 --> 00:59:13,880
that time like my ad right I'm actually

1212
00:59:11,030 --> 00:59:15,920
talking about moving a whole 64 bytes

1213
00:59:13,880 --> 00:59:17,990
around and because I'm talking about

1214
00:59:15,920 --> 00:59:20,570
moving a whole 64 bytes around it starts

1215
00:59:17,989 --> 00:59:23,839
to matter how my data is arranged in

1216
00:59:20,570 --> 00:59:27,380
memory because if I ask for even just

1217
00:59:23,840 --> 00:59:29,809
one bite of a 64 byte chunk I'm gonna

1218
00:59:27,380 --> 00:59:32,720
get the whole 64 bytes back and it's

1219
00:59:29,809 --> 00:59:35,239
gonna evict a whole 64 bytes

1220
00:59:32,719 --> 00:59:38,359
from the l1 the l2 and the l3 to make

1221
00:59:35,239 --> 00:59:40,279
room for this new 64 bytes of memory

1222
00:59:38,360 --> 00:59:44,030
that I asked for if it's you know if

1223
00:59:40,280 --> 00:59:47,630
it's not in the caches so whole chunks

1224
00:59:44,030 --> 00:59:52,760
in 64 byte groups are getting moved in

1225
00:59:47,630 --> 00:59:54,470
and out okay so what that means is when

1226
00:59:52,760 --> 00:59:55,760
I look at stuff like cache performance I

1227
00:59:54,469 --> 00:59:59,389
have to start thinking about these

1228
00:59:55,760 --> 01:00:04,420
things on a modern CPU I have an IPC of

1229
00:59:59,389 --> 01:00:12,559
4 that means the maximum instructions I

1230
01:00:04,420 --> 01:00:14,000
can issue in one cycle right is for each

1231
01:00:12,559 --> 01:00:16,460
of those instructions have operands

1232
01:00:14,000 --> 01:00:18,829
write an instruction can like add two

1233
01:00:16,460 --> 01:00:22,070
things together that means it needs two

1234
01:00:18,829 --> 01:00:25,779
inputs right I can issue four of them

1235
01:00:22,070 --> 01:00:32,480
that means I can have up to eight inputs

1236
01:00:25,780 --> 01:00:34,790
right on one cycle so when you start to

1237
01:00:32,480 --> 01:00:37,880
look at this 64 bytes right of a cache

1238
01:00:34,789 --> 01:00:39,259
line and we can get even worse than this

1239
01:00:37,880 --> 01:00:42,559
I'll talk about that a second or even

1240
01:00:39,260 --> 01:00:43,670
more demanding right so when I start to

1241
01:00:42,559 --> 01:00:49,480
talk about this cache lines what did I

1242
01:00:43,670 --> 01:00:57,019
say I said the l1 right can provide two

1243
01:00:49,480 --> 01:01:00,289
cache lines per clock that means my l1

1244
01:00:57,019 --> 01:01:03,619
cache even if it's completely hitting

1245
01:01:00,289 --> 01:01:07,369
the cache so I'm 100% in the l1 cache

1246
01:01:03,619 --> 01:01:09,529
I'm not missing I can still only provide

1247
01:01:07,369 --> 01:01:11,329
two cache lines per clock that's the

1248
01:01:09,530 --> 01:01:14,450
maximum rate it can send the stuff back

1249
01:01:11,329 --> 01:01:18,289
right what that means is I can operate

1250
01:01:14,449 --> 01:01:22,369
on at 128 bytes per clock out of the l1

1251
01:01:18,289 --> 01:01:24,650
cache and a maximum well 128 bytes

1252
01:01:22,369 --> 01:01:28,250
whether or not that's going to be enough

1253
01:01:24,650 --> 01:01:30,980
as a lot of ramifications first of all

1254
01:01:28,250 --> 01:01:34,309
even with an IPC of 4

1255
01:01:30,980 --> 01:01:36,289
let's say I'm going to issue well now we

1256
01:01:34,309 --> 01:01:39,230
get into some other things about how

1257
01:01:36,289 --> 01:01:42,380
many units we actually have but let's

1258
01:01:39,230 --> 01:01:45,740
suppose we're going to do try to issue

1259
01:01:42,380 --> 01:01:47,750
three instructions okay

1260
01:01:45,739 --> 01:01:52,669
and I'm gonna pick an instruction that

1261
01:01:47,750 --> 01:01:57,409
actually can issue properly across

1262
01:01:52,670 --> 01:02:00,650
across three across one cycle three of

1263
01:01:57,409 --> 01:02:03,500
them so I'm gonna do three things called

1264
01:02:00,650 --> 01:02:07,910
a P ad and what a P ad is it's basically

1265
01:02:03,500 --> 01:02:10,369
the sim D units adder right so I'm going

1266
01:02:07,909 --> 01:02:13,629
to do P AB and I'm gonna do three of

1267
01:02:10,369 --> 01:02:17,269
these P ad calls right

1268
01:02:13,630 --> 01:02:20,599
okay so one of the things about a P ad

1269
01:02:17,269 --> 01:02:22,909
is that a P ad can take a memory operand

1270
01:02:20,599 --> 01:02:25,400
but it also needs to have a register

1271
01:02:22,909 --> 01:02:27,289
involved so for example let's say I'm

1272
01:02:25,400 --> 01:02:29,450
gonna do P ads and I've got a register

1273
01:02:27,289 --> 01:02:33,800
in here so the registers are going to be

1274
01:02:29,449 --> 01:02:37,399
whatever I don't know XM m 0 XM m 1x m

1275
01:02:33,800 --> 01:02:39,950
m2 right and then the thing I'm going to

1276
01:02:37,400 --> 01:02:41,869
be adding in each of these cases is

1277
01:02:39,949 --> 01:02:45,199
going to be some piece of memory right

1278
01:02:41,869 --> 01:02:54,200
so there's some memory there's some

1279
01:02:45,199 --> 01:02:56,949
memory it's a memory alright so what

1280
01:02:54,199 --> 01:03:00,139
actually happens here well first of all

1281
01:02:56,949 --> 01:03:02,509
we've got some limitations and I'll talk

1282
01:03:00,139 --> 01:03:04,069
about each of those limitations in turn

1283
01:03:02,510 --> 01:03:05,240
just cuz we're fully down the rabbit

1284
01:03:04,070 --> 01:03:08,690
hole now so you might as well get in

1285
01:03:05,239 --> 01:03:10,608
there so when we look at what happens we

1286
01:03:08,690 --> 01:03:13,820
know that the l1 cache is sitting over

1287
01:03:10,608 --> 01:03:16,069
here right and it's ready to go

1288
01:03:13,820 --> 01:03:18,559
we know that the scheduler is looking at

1289
01:03:16,070 --> 01:03:20,539
this stuff and it's trying to figure out

1290
01:03:18,559 --> 01:03:23,599
what it can do and we know we've got our

1291
01:03:20,539 --> 01:03:26,300
you know our actual work units down here

1292
01:03:23,599 --> 01:03:27,530
and they want stuff to do right and so

1293
01:03:26,300 --> 01:03:31,640
what's gonna happen when I look at this

1294
01:03:27,530 --> 01:03:33,859
code well the first thing that we could

1295
01:03:31,639 --> 01:03:36,559
say about it is that looking at these 3

1296
01:03:33,858 --> 01:03:38,389
P adds this apart we're not really

1297
01:03:36,559 --> 01:03:40,759
talking about just mention it offhand so

1298
01:03:38,389 --> 01:03:45,199
it's on the table we would need at least

1299
01:03:40,760 --> 01:03:48,290
3 P ad units down here right in order to

1300
01:03:45,199 --> 01:03:50,419
issue 3 P ads in one cycle if I wanted

1301
01:03:48,289 --> 01:03:52,969
all of these things to issue I need at

1302
01:03:50,420 --> 01:03:54,559
least 3 P ad units down in the work part

1303
01:03:52,969 --> 01:03:55,969
of the chip to actually send them to

1304
01:03:54,559 --> 01:03:57,380
because otherwise when I send the first

1305
01:03:55,969 --> 01:03:59,239
one in the second one on this cycle

1306
01:03:57,380 --> 01:04:00,170
there's nowhere to send the third one

1307
01:03:59,239 --> 01:04:02,479
right

1308
01:04:00,170 --> 01:04:05,829
now fortunately I picked an instruction

1309
01:04:02,480 --> 01:04:08,210
that has three units P ad is a unit that

1310
01:04:05,829 --> 01:04:09,679
P is something that there are three work

1311
01:04:08,210 --> 01:04:11,750
units in the chip that can actually

1312
01:04:09,679 --> 01:04:14,480
field so that would be fine so I could

1313
01:04:11,750 --> 01:04:17,929
send all 3x down to the work units no

1314
01:04:14,480 --> 01:04:19,610
problem okay next thing we look at need

1315
01:04:17,929 --> 01:04:22,609
to look at is register usage are these

1316
01:04:19,610 --> 01:04:24,890
all independent xmm 0 X and M 1 M 2 they

1317
01:04:22,610 --> 01:04:26,630
all are so I don't need to really like

1318
01:04:24,889 --> 01:04:29,449
worry about dependencies here because

1319
01:04:26,630 --> 01:04:31,970
I'm not writing to my registers well I

1320
01:04:29,449 --> 01:04:33,349
could talk about the rat up here where

1321
01:04:31,969 --> 01:04:36,980
did I put the rat the rats here

1322
01:04:33,349 --> 01:04:38,210
somewhere this guy the register

1323
01:04:36,980 --> 01:04:40,010
allocation table is the thing that's

1324
01:04:38,210 --> 01:04:41,119
responsible for that part of the the

1325
01:04:40,010 --> 01:04:41,800
process but we're kind of skipping it

1326
01:04:41,119 --> 01:04:43,900
for now

1327
01:04:41,800 --> 01:04:45,890
it's not really related to cash

1328
01:04:43,900 --> 01:04:48,920
performance but it is an interesting

1329
01:04:45,889 --> 01:04:51,259
part of the chip so anyway we're gonna

1330
01:04:48,920 --> 01:04:54,760
ask you three of these P adds great

1331
01:04:51,260 --> 01:04:58,340
we got three work units no problem right

1332
01:04:54,760 --> 01:05:01,460
but each of these P adds requires us to

1333
01:04:58,340 --> 01:05:04,850
look at some memory and actually get the

1334
01:05:01,460 --> 01:05:06,829
memory that we need right and who knows

1335
01:05:04,849 --> 01:05:12,159
what these are so maybe these are like I

1336
01:05:06,829 --> 01:05:17,900
don't know I I need to look at like EAX

1337
01:05:12,159 --> 01:05:21,710
plus like 50 and EI x plus 256 and like

1338
01:05:17,900 --> 01:05:25,010
EI x plus 5/12 something like that right

1339
01:05:21,710 --> 01:05:27,619
so I'm gonna go look at memory I'm gonna

1340
01:05:25,010 --> 01:05:30,320
do some ads it's gonna be great I know I

1341
01:05:27,619 --> 01:05:32,750
can issue all three you'll be good but

1342
01:05:30,320 --> 01:05:35,030
when I look at this part suddenly we've

1343
01:05:32,750 --> 01:05:36,889
got issues okay

1344
01:05:35,030 --> 01:05:39,019
so what are our issues well there's

1345
01:05:36,889 --> 01:05:42,529
actually two reasons that we won't be

1346
01:05:39,019 --> 01:05:47,239
able to issue all three of these in one

1347
01:05:42,530 --> 01:05:48,620
cycle I could I think even do something

1348
01:05:47,239 --> 01:05:53,389
a little more squirrelly here but I'm

1349
01:05:48,619 --> 01:05:56,829
not going to cuz well what happens is

1350
01:05:53,389 --> 01:05:59,000
first of all you look and the l1 cache

1351
01:05:56,829 --> 01:06:01,159
wouldn't actually be able to help us

1352
01:05:59,000 --> 01:06:02,599
here we couldn't get this information

1353
01:06:01,159 --> 01:06:08,779
out of the l1 cache in time

1354
01:06:02,599 --> 01:06:13,670
why because ax + 50 e^x + 56 + EI x + 5

1355
01:06:08,780 --> 01:06:17,569
12 these are all on separate cache lines

1356
01:06:13,670 --> 01:06:20,450
right remember a cache line is only 64

1357
01:06:17,568 --> 01:06:22,788
bytes so this would require one cache

1358
01:06:20,449 --> 01:06:24,558
line this is clearly on another one

1359
01:06:22,789 --> 01:06:27,019
because it's more than 64 bytes away

1360
01:06:24,559 --> 01:06:29,869
from this and this is more than 64 bytes

1361
01:06:27,018 --> 01:06:31,639
away from this so the l1 cache actually

1362
01:06:29,869 --> 01:06:33,500
wouldn't be able to hand us the memory

1363
01:06:31,639 --> 01:06:36,710
in time and this instruction stream

1364
01:06:33,500 --> 01:06:37,909
would stall just on the l1 cache but

1365
01:06:36,710 --> 01:06:42,019
there's actually another reason it would

1366
01:06:37,909 --> 01:06:44,358
stall right it would stall because there

1367
01:06:42,018 --> 01:06:48,048
actually aren't three address generation

1368
01:06:44,358 --> 01:06:50,719
units inside the the X's before anyway

1369
01:06:48,048 --> 01:06:53,179
there's a thing called an address

1370
01:06:50,719 --> 01:06:55,219
generation unit and what that is is the

1371
01:06:53,179 --> 01:06:57,500
thing that actually handles the cache

1372
01:06:55,219 --> 01:07:00,558
line like filling and matching and

1373
01:06:57,500 --> 01:07:04,400
determining what this AB even produces

1374
01:07:00,559 --> 01:07:06,829
right so in order to produce a fetch

1375
01:07:04,400 --> 01:07:11,510
from memory you need to have a free a GU

1376
01:07:06,829 --> 01:07:14,089
there's only two AG use on modern x64

1377
01:07:11,510 --> 01:07:18,430
like skylight cores right so actually

1378
01:07:14,088 --> 01:07:24,469
there's two reasons that we can't issue

1379
01:07:18,429 --> 01:07:25,219
three of these per cycle right so what

1380
01:07:24,469 --> 01:07:28,278
does this tell us

1381
01:07:25,219 --> 01:07:30,558
well it tells us you know someone didn't

1382
01:07:28,278 --> 01:07:33,949
tell you know was pretty smart in a

1383
01:07:30,559 --> 01:07:36,950
sense because if the l1 could issue more

1384
01:07:33,949 --> 01:07:39,068
than two cache lines per clock chances

1385
01:07:36,949 --> 01:07:41,838
are it would never get the chance to

1386
01:07:39,068 --> 01:07:44,538
because since there aren't enough AG use

1387
01:07:41,838 --> 01:07:47,690
on the chip in order to actually send

1388
01:07:44,539 --> 01:07:49,278
three memory requests to the l1 what

1389
01:07:47,690 --> 01:07:51,528
good is it gonna do that it could

1390
01:07:49,278 --> 01:07:54,048
fulfill three right so you would tend to

1391
01:07:51,528 --> 01:07:55,028
call that a very balanced architecture

1392
01:07:54,048 --> 01:07:58,369
right

1393
01:07:55,028 --> 01:08:00,469
you didn't provide too many AG use or

1394
01:07:58,369 --> 01:08:02,088
too many cache line fills so that your

1395
01:08:00,469 --> 01:08:04,129
silicon is just sitting dead that would

1396
01:08:02,088 --> 01:08:06,500
be considered a mistake probably right

1397
01:08:04,130 --> 01:08:08,210
because we over engineered one part of

1398
01:08:06,500 --> 01:08:10,429
the chip to deliver things more quickly

1399
01:08:08,210 --> 01:08:17,569
but the other part of the chip can't do

1400
01:08:10,429 --> 01:08:22,908
it right it doesn't work so that you

1401
01:08:17,569 --> 01:08:26,179
know keeping that in mind right there

1402
01:08:22,908 --> 01:08:28,849
are limitations that the l1 can impose

1403
01:08:26,179 --> 01:08:31,310
but oftentimes they're simply not going

1404
01:08:28,850 --> 01:08:34,400
to occur because actually the aju

1405
01:08:31,310 --> 01:08:38,480
becomes the blocking factor in in the

1406
01:08:34,399 --> 01:08:41,899
first place now there is one other

1407
01:08:38,479 --> 01:08:43,548
reason that I should mention specific to

1408
01:08:41,899 --> 01:08:45,769
Intel chips as far as I know I don't

1409
01:08:43,548 --> 01:08:50,019
know if it's true on AMT so I've never

1410
01:08:45,770 --> 01:08:50,020
tested it but actually on Intel chips

1411
01:08:52,210 --> 01:09:04,429
there's a weird thing which is there's

1412
01:09:01,250 --> 01:09:07,908
an l1 l2 fill penalty that is

1413
01:09:04,429 --> 01:09:11,119
undocumented I have no I've never gotten

1414
01:09:07,908 --> 01:09:13,129
someone at Intel to confirm it they

1415
01:09:11,119 --> 01:09:17,689
literally don't return my emails when I

1416
01:09:13,130 --> 01:09:22,869
ask them about this don't ask me why but

1417
01:09:17,689 --> 01:09:22,869
it turns out when you actually ask for

1418
01:09:24,819 --> 01:09:34,100
memory at a rate that the l1 should be

1419
01:09:30,710 --> 01:09:38,899
able to achieve and the l2 should be

1420
01:09:34,100 --> 01:09:42,620
able to achieve you can't actually get

1421
01:09:38,899 --> 01:09:45,469
the l1 to give you back data at the

1422
01:09:42,619 --> 01:09:50,119
speed it should because if it needs to

1423
01:09:45,469 --> 01:09:52,670
take to accept incoming data from the l2

1424
01:09:50,119 --> 01:09:56,448
on a particular cycle it seems like it

1425
01:09:52,670 --> 01:09:59,630
can only provide one cache line so

1426
01:09:56,448 --> 01:10:04,388
normally if the l1 is not receiving a

1427
01:09:59,630 --> 01:10:14,659
fill from l2 it can do two cache lines

1428
01:10:04,389 --> 01:10:16,190
per clock but if it's receiving data

1429
01:10:14,658 --> 01:10:19,460
from the l2 it seems like you can only

1430
01:10:16,189 --> 01:10:24,229
do one cache line per clock so it's like

1431
01:10:19,460 --> 01:10:27,170
one cache one of those cache line fills

1432
01:10:24,229 --> 01:10:31,718
it should be able to do is like taken up

1433
01:10:27,170 --> 01:10:33,920
with an l2 receive that makes sense

1434
01:10:31,719 --> 01:10:35,539
again this is completely undocumented

1435
01:10:33,920 --> 01:10:36,260
I've never seen it mentioned anywhere

1436
01:10:35,539 --> 01:10:38,869
but it

1437
01:10:36,260 --> 01:10:40,250
absolutely happens and most people will

1438
01:10:38,869 --> 01:10:42,979
never know about it because they're not

1439
01:10:40,250 --> 01:10:44,630
usually doing things at a speed that's

1440
01:10:42,979 --> 01:10:46,579
tweaked enough to actually need this

1441
01:10:44,630 --> 01:10:49,909
it's pretty hard to get the chip into

1442
01:10:46,579 --> 01:10:52,279
this state but if you do it doesn't work

1443
01:10:49,909 --> 01:10:54,949
right you end up with with not getting

1444
01:10:52,279 --> 01:11:00,380
the l2 bandwidth you expect because of

1445
01:10:54,949 --> 01:11:02,239
that l2 l1 fill alright so hopefully

1446
01:11:00,380 --> 01:11:04,310
have given you a sense of just how

1447
01:11:02,239 --> 01:11:06,349
complex all this stuff is if you want to

1448
01:11:04,310 --> 01:11:10,850
start actually looking into it so the

1449
01:11:06,350 --> 01:11:14,870
answer in the specific of how do I avoid

1450
01:11:10,850 --> 01:11:18,110
cache misses is incredibly complicated

1451
01:11:14,869 --> 01:11:22,789
the real answer is learn everything you

1452
01:11:18,109 --> 01:11:25,729
can about the CPU architecture you're on

1453
01:11:22,789 --> 01:11:29,569
and actually work out what it's going to

1454
01:11:25,729 --> 01:11:32,409
have to do when you're working on what's

1455
01:11:29,569 --> 01:11:35,569
working on the code you're writing and

1456
01:11:32,409 --> 01:11:37,430
figure out exactly how those misses

1457
01:11:35,569 --> 01:11:40,039
might affect you and how you could avoid

1458
01:11:37,430 --> 01:11:41,570
them I realize that's not a very good

1459
01:11:40,039 --> 01:11:42,949
answer to give to someone who's just

1460
01:11:41,569 --> 01:11:45,380
starting out because that's a lot of

1461
01:11:42,949 --> 01:11:49,399
work and it's very complicated so how do

1462
01:11:45,380 --> 01:11:51,949
we generalize some rules of thumb for

1463
01:11:49,399 --> 01:11:57,079
the beginner well the first thing is

1464
01:11:51,949 --> 01:11:59,689
learn the cache sizes that's the most

1465
01:11:57,079 --> 01:12:02,029
basic thing you can do learn the cache

1466
01:11:59,689 --> 01:12:05,029
sizes for the CPUs you're targeting

1467
01:12:02,029 --> 01:12:09,229
learn how big is the l1 how big is the

1468
01:12:05,029 --> 01:12:11,239
l2 how big is the l3 why because you

1469
01:12:09,229 --> 01:12:14,209
want to start thinking about how to

1470
01:12:11,239 --> 01:12:18,469
organize your data so that data that's

1471
01:12:14,210 --> 01:12:21,949
accessed frequently can fit inside these

1472
01:12:18,470 --> 01:12:23,960
caches right try to start packing your

1473
01:12:21,949 --> 01:12:25,489
data down so that if you have stuff

1474
01:12:23,960 --> 01:12:29,270
that's pretty random access that you're

1475
01:12:25,489 --> 01:12:31,489
doing a bunch of work on right try to

1476
01:12:29,270 --> 01:12:35,750
get it under 32 K try to get it under

1477
01:12:31,489 --> 01:12:38,500
256 K right try to fit it into a smaller

1478
01:12:35,750 --> 01:12:41,569
amount of space because the smaller that

1479
01:12:38,500 --> 01:12:44,239
frequently-asked access data is the more

1480
01:12:41,569 --> 01:12:47,259
cache hits you can get the more

1481
01:12:44,239 --> 01:12:50,889
sprawling the data is the worse right

1482
01:12:47,260 --> 01:12:50,890
so that's thing one

1483
01:12:57,760 --> 01:13:04,880
think to is try to arrange your data so

1484
01:13:02,930 --> 01:13:06,770
that things that will be looked at at

1485
01:13:04,880 --> 01:13:09,220
the same time are close to each other

1486
01:13:06,770 --> 01:13:13,730
and things that are not are far away

1487
01:13:09,220 --> 01:13:16,280
right so remember the cache is not just

1488
01:13:13,729 --> 01:13:19,369
about size it's also about arrangement

1489
01:13:16,279 --> 01:13:21,769
the cache must move 64 bytes

1490
01:13:19,369 --> 01:13:25,159
every time you ask it to do something

1491
01:13:21,770 --> 01:13:28,390
right it cannot move a subsection of

1492
01:13:25,159 --> 01:13:33,050
that so I'll give you a simple example

1493
01:13:28,390 --> 01:13:34,640
let's suppose I make a linked list right

1494
01:13:33,050 --> 01:13:37,239
actually you know we know ninda how do

1495
01:13:34,640 --> 01:13:40,250
you know let's suppose I make an array

1496
01:13:37,239 --> 01:13:43,210
okay I'm going to make an array of data

1497
01:13:40,250 --> 01:13:47,270
and I'm gonna operate on that data I'm

1498
01:13:43,210 --> 01:13:50,329
creating a struct that's in that array

1499
01:13:47,270 --> 01:14:00,940
and that struct has the following stuff

1500
01:13:50,329 --> 01:14:07,809
in it int X care name I don't know it's

1501
01:14:00,939 --> 01:14:07,809
64 into y okay

1502
01:14:08,649 --> 01:14:14,779
so let's suppose I've got this struct I

1503
01:14:12,109 --> 01:14:16,579
want to make an array of these actually

1504
01:14:14,779 --> 01:14:18,769
I'll use big again I like that name I've

1505
01:14:16,579 --> 01:14:22,220
got a big array and I've just got a ton

1506
01:14:18,770 --> 01:14:24,260
of these right I've got 6 5 5 3 6 of

1507
01:14:22,220 --> 01:14:26,750
them so I'm just got a ton of these

1508
01:14:24,260 --> 01:14:29,539
things right and I'm operating on I'm

1509
01:14:26,750 --> 01:14:32,659
doing all kinds of stuff well let's

1510
01:14:29,539 --> 01:14:35,119
suppose I have a important loop in my

1511
01:14:32,659 --> 01:14:38,149
code and it looks something like this

1512
01:14:35,119 --> 01:14:41,079
you know for everything inside big I'm

1513
01:14:38,149 --> 01:14:46,159
gonna go through and I'm going to take

1514
01:14:41,079 --> 01:14:50,000
you know particular big dot X and I'm

1515
01:14:46,159 --> 01:14:53,059
going to add you know 5 to it and I'm

1516
01:14:50,000 --> 01:14:55,609
going to take a particular part of Y

1517
01:14:53,060 --> 01:14:58,400
there and take Y and add 7 to it and

1518
01:14:55,609 --> 01:15:03,019
this is like super performance critical

1519
01:14:58,399 --> 01:15:03,379
right I'm doing a ton of these I do it

1520
01:15:03,020 --> 01:15:05,330
all

1521
01:15:03,380 --> 01:15:08,980
all the time it's a really hot part of

1522
01:15:05,329 --> 01:15:12,679
the code well look at what happened here

1523
01:15:08,979 --> 01:15:16,399
because this structure is organized such

1524
01:15:12,679 --> 01:15:19,340
that I have X right where is X it's at

1525
01:15:16,399 --> 01:15:21,529
offset zero from the struct so wherever

1526
01:15:19,340 --> 01:15:24,170
the struct is it's at the very first

1527
01:15:21,529 --> 01:15:26,420
byte of the struct where is name well I

1528
01:15:24,170 --> 01:15:31,310
know that this is 32 bits of an integer

1529
01:15:26,420 --> 01:15:36,889
right so that's 4 bytes so name is at +4

1530
01:15:31,310 --> 01:15:40,100
off of my struct where is y y is 64 of

1531
01:15:36,889 --> 01:15:42,230
the name right in between in and X so

1532
01:15:40,100 --> 01:15:45,350
it's going to be the plus 4 of name plus

1533
01:15:42,229 --> 01:15:48,799
the 64 that it took up so it's actually

1534
01:15:45,350 --> 01:15:52,280
going to be at plus 68 right do you see

1535
01:15:48,800 --> 01:15:54,980
where this is going this and this are

1536
01:15:52,279 --> 01:15:59,300
the two things that I use inside this

1537
01:15:54,979 --> 01:16:07,099
loop but they are on different cache

1538
01:15:59,300 --> 01:16:10,969
lines right so how concerned should I be

1539
01:16:07,100 --> 01:16:13,820
about this well the first thing you

1540
01:16:10,969 --> 01:16:16,609
might say to me is okay Casey I can

1541
01:16:13,819 --> 01:16:20,149
solve that all this move into X up here

1542
01:16:16,609 --> 01:16:23,689
right so now I've got int X int int Y

1543
01:16:20,149 --> 01:16:26,329
right and that way haha they're both on

1544
01:16:23,689 --> 01:16:29,359
the same cache line because now x and y

1545
01:16:26,329 --> 01:16:32,988
are at 0 and plus 4 and the next thing

1546
01:16:29,359 --> 01:16:34,460
is actually at plus 668 right I'm sorry

1547
01:16:32,988 --> 01:16:37,579
the next thing is actually a plus 8 and

1548
01:16:34,460 --> 01:16:40,130
runs out to the end right but actually

1549
01:16:37,579 --> 01:16:42,439
that didn't do anything why didn't it do

1550
01:16:40,130 --> 01:16:46,279
anything because now all you've actually

1551
01:16:42,439 --> 01:16:48,229
done is you've you know you've changed

1552
01:16:46,279 --> 01:16:50,300
what the alignment might be but it

1553
01:16:48,229 --> 01:16:52,250
probably still isn't that good you're

1554
01:16:50,300 --> 01:16:53,750
still you know like think about how this

1555
01:16:52,250 --> 01:16:55,760
would have laid out in memory if I'd had

1556
01:16:53,750 --> 01:16:57,948
two foods next to each other even before

1557
01:16:55,760 --> 01:17:00,230
I did that swap the next in X was coming

1558
01:16:57,948 --> 01:17:01,729
here so the Y in the X were actually

1559
01:17:00,229 --> 01:17:04,369
gonna still be on the same cache line

1560
01:17:01,729 --> 01:17:05,448
secretly right the X of the next one

1561
01:17:04,369 --> 01:17:09,439
would have been on the same cache line

1562
01:17:05,448 --> 01:17:11,479
right so how can I fix this well the

1563
01:17:09,439 --> 01:17:14,359
right thing to do was to say let's split

1564
01:17:11,479 --> 01:17:16,618
these up right just split these up into

1565
01:17:14,359 --> 01:17:19,288
big one in big two

1566
01:17:16,618 --> 01:17:23,578
phoo one in food too and so then I've

1567
01:17:19,288 --> 01:17:27,179
got here struct through one that's just

1568
01:17:23,578 --> 01:17:29,788
gonna have my XY right and then futu

1569
01:17:27,179 --> 01:17:33,118
we'll just have name what does that

1570
01:17:29,788 --> 01:17:38,158
allowed me to do well now right I can

1571
01:17:33,118 --> 01:17:41,128
actually fit eight pairs of XY z-- into

1572
01:17:38,158 --> 01:17:42,958
one cache line and this big name

1573
01:17:41,128 --> 01:17:44,609
structure that I'm not even touching on

1574
01:17:42,958 --> 01:17:46,800
this particular time in this particular

1575
01:17:44,609 --> 01:17:52,529
hot piece of code that's going to some

1576
01:17:46,800 --> 01:17:55,320
totally separate cache line right so

1577
01:17:52,529 --> 01:17:58,198
that has dramatically reduced the number

1578
01:17:55,319 --> 01:18:00,179
of cache lines I have had to touch in

1579
01:17:58,198 --> 01:18:02,759
order to do the work that I was trying

1580
01:18:00,179 --> 01:18:04,319
to do before how much well if you look

1581
01:18:02,760 --> 01:18:10,168
at how many cache lines I was processing

1582
01:18:04,319 --> 01:18:12,049
before I was processing 65536 right how

1583
01:18:10,168 --> 01:18:18,179
many cache lines each of these things

1584
01:18:12,050 --> 01:18:23,820
was what like this is 0 this is for 864

1585
01:18:18,179 --> 01:18:29,038
so it's like 72 bytes right for each of

1586
01:18:23,819 --> 01:18:32,308
these so it's that right

1587
01:18:29,038 --> 01:18:34,050
it's 6.5 to 6 times 72 over 64 this is

1588
01:18:32,309 --> 01:18:37,489
how many cache lines I had to touch

1589
01:18:34,050 --> 01:18:40,110
before right that's what was happening

1590
01:18:37,488 --> 01:18:41,698
now arguably maybe there were times when

1591
01:18:40,109 --> 01:18:43,708
it would have lined up and you wouldn't

1592
01:18:41,698 --> 01:18:45,948
have had to touch this particular one so

1593
01:18:43,708 --> 01:18:48,929
it's maybe a little less than this

1594
01:18:45,948 --> 01:18:50,908
potentially there you go whereas in the

1595
01:18:48,929 --> 01:18:54,989
other case when this thing is only 8

1596
01:18:50,908 --> 01:18:58,888
long right then I've got 6 5 5 3 6 times

1597
01:18:54,988 --> 01:19:04,168
8 over 64 right this is way more

1598
01:18:58,889 --> 01:19:06,979
favorable it's basically 72 over 8 it

1599
01:19:04,168 --> 01:19:10,828
was this many times more cache lines

1600
01:19:06,979 --> 01:19:13,349
roughly speaking right so I would expect

1601
01:19:10,828 --> 01:19:16,349
this to actually run like nine times

1602
01:19:13,349 --> 01:19:17,729
faster in some cases right because the

1603
01:19:16,349 --> 01:19:20,760
or I shouldn't say nine times faster

1604
01:19:17,729 --> 01:19:22,889
it's touching nine times more cache

1605
01:19:20,760 --> 01:19:25,949
lines in this case so depending on how

1606
01:19:22,889 --> 01:19:28,319
much cash bandwidth is compared to what

1607
01:19:25,948 --> 01:19:30,359
I'm doing I could expect a massive speed

1608
01:19:28,319 --> 01:19:34,079
up just by this small organisation

1609
01:19:30,359 --> 01:19:39,689
right reorganisation so that's number

1610
01:19:34,079 --> 01:19:42,420
two you know organize for the cash and

1611
01:19:39,689 --> 01:19:46,859
that just involves what do you actually

1612
01:19:42,420 --> 01:19:49,590
use often together put those together

1613
01:19:46,859 --> 01:19:51,988
and get the other things out of the way

1614
01:19:49,590 --> 01:19:55,500
so that each 64 byte cache line you're

1615
01:19:51,988 --> 01:19:58,529
actually using is filled with good stuff

1616
01:19:55,500 --> 01:20:02,189
right and sometimes this requires you to

1617
01:19:58,529 --> 01:20:04,618
do alignment you also want to make sure

1618
01:20:02,189 --> 01:20:06,509
that you don't spread across cache lines

1619
01:20:04,618 --> 01:20:09,269
unnecessarily so you want to try and

1620
01:20:06,510 --> 01:20:12,630
align things to the cache line

1621
01:20:09,270 --> 01:20:14,460
boundaries right and we've shown how to

1622
01:20:12,630 --> 01:20:16,829
do alignment memory linemen on handmade

1623
01:20:14,460 --> 01:20:18,929
here oh you don't know what that is and

1624
01:20:16,829 --> 01:20:22,590
so there's one more rule of thumb that I

1625
01:20:18,929 --> 01:20:29,908
add in there and that is do you have a

1626
01:20:22,590 --> 01:20:32,219
Prefecture right now not all CPUs have a

1627
01:20:29,908 --> 01:20:36,000
prefecture so it depends on your

1628
01:20:32,219 --> 01:20:38,550
platform but x64 CPUs definitely do what

1629
01:20:36,000 --> 01:20:41,639
is a Prefecture well if you take a look

1630
01:20:38,550 --> 01:20:44,070
at what goes on inside the CPU when

1631
01:20:41,639 --> 01:20:46,139
you're trying to get really good usage

1632
01:20:44,069 --> 01:20:49,710
out of these caches one of the things

1633
01:20:46,139 --> 01:20:51,300
that's typically true is your memory

1634
01:20:49,710 --> 01:20:54,118
usage patterns are typically not

1635
01:20:51,300 --> 01:20:57,029
completely random right so oftentimes

1636
01:20:54,118 --> 01:20:59,158
what a CPU will have in it is something

1637
01:20:57,029 --> 01:21:01,590
that looks at which cache lines you're

1638
01:20:59,158 --> 01:21:03,658
asking for and tries to extrapolate

1639
01:21:01,590 --> 01:21:13,409
which ones you will need and it will

1640
01:21:03,658 --> 01:21:17,789
pre-fill the cash or prefetch as the

1641
01:21:13,408 --> 01:21:20,549
case may be right so what is a

1642
01:21:17,789 --> 01:21:23,939
Prefecture do a Prefecture will look and

1643
01:21:20,550 --> 01:21:26,610
say are you you know accessing every

1644
01:21:23,939 --> 01:21:29,099
eight cache line in a row right like I'm

1645
01:21:26,609 --> 01:21:32,009
asked I asked for cache line zero then 8

1646
01:21:29,100 --> 01:21:33,750
then 16 and you know blah blah blah am I

1647
01:21:32,010 --> 01:21:35,850
asking for them in strictly decreasing

1648
01:21:33,750 --> 01:21:37,529
order did I ask for zero negative one

1649
01:21:35,850 --> 01:21:40,380
name to name three and a 45 right from

1650
01:21:37,529 --> 01:21:43,800
my pointer like how am i accessing these

1651
01:21:40,380 --> 01:21:48,900
cache lines if you can provide a

1652
01:21:43,800 --> 01:21:51,570
dick table simple access pattern the

1653
01:21:48,899 --> 01:21:54,420
prefetcher will be able to ask for

1654
01:21:51,569 --> 01:22:00,719
memory long in advance of being needed

1655
01:21:54,420 --> 01:22:08,940
and pre fill your caches right so linear

1656
01:22:00,719 --> 01:22:12,029
you know simple access patterns can help

1657
01:22:08,939 --> 01:22:14,848
you take advantage of that prefecture

1658
01:22:12,029 --> 01:22:17,309
and ensure that all of the caches get

1659
01:22:14,849 --> 01:22:20,400
filled before you ever ask for them

1660
01:22:17,309 --> 01:22:22,949
right so this helps a lot when you're

1661
01:22:20,399 --> 01:22:25,019
processing bulk data I got a run through

1662
01:22:22,948 --> 01:22:27,000
a gigabyte of data well guess what a

1663
01:22:25,020 --> 01:22:29,730
gigabyte of data don't fit in the cache

1664
01:22:27,000 --> 01:22:31,020
so it doesn't matter if I you know try

1665
01:22:29,729 --> 01:22:32,578
to organize it or any of these other

1666
01:22:31,020 --> 01:22:34,770
things there's only so much I can do

1667
01:22:32,578 --> 01:22:37,319
it's got to feed a gigabyte data through

1668
01:22:34,770 --> 01:22:38,940
main memory how do I try to make it so

1669
01:22:37,319 --> 01:22:41,670
that I'm not constantly waiting on main

1670
01:22:38,939 --> 01:22:44,339
memory well this is how you want to try

1671
01:22:41,670 --> 01:22:46,500
and make as straightforward of an access

1672
01:22:44,340 --> 01:22:50,460
pattern as possible so the prefecture

1673
01:22:46,500 --> 01:22:52,198
can do the work of pre filling the cache

1674
01:22:50,460 --> 01:22:55,050
what does this do for you

1675
01:22:52,198 --> 01:22:57,509
well main memory can operate at pretty

1676
01:22:55,050 --> 01:23:02,699
high speeds these days you can get

1677
01:22:57,510 --> 01:23:05,190
somewhere around so let me think of what

1678
01:23:02,698 --> 01:23:09,238
this is it sits around to get get a

1679
01:23:05,189 --> 01:23:11,729
cache line back you can do that in like

1680
01:23:09,238 --> 01:23:18,928
in like five-and-a-half clocks use like

1681
01:23:11,729 --> 01:23:20,759
six six four o'clock I'm sorry I just

1682
01:23:18,929 --> 01:23:33,989
don't remember the main memory per clock

1683
01:23:20,760 --> 01:23:35,520
rate right now so if I have well

1684
01:23:33,988 --> 01:23:39,448
actually I guess I kind of do I think

1685
01:23:35,520 --> 01:23:43,050
it's like 5.5 bytes per clock some

1686
01:23:39,448 --> 01:23:44,460
around there six bytes per clock I don't

1687
01:23:43,050 --> 01:23:46,679
really remember exactly what the main

1688
01:23:44,460 --> 01:23:48,599
memory speed is but it's not that bad

1689
01:23:46,679 --> 01:23:53,190
it's something like six bytes per clock

1690
01:23:48,599 --> 01:23:55,319
let's say and so what you want to do is

1691
01:23:53,189 --> 01:23:57,178
when you know you're gonna be throttled

1692
01:23:55,319 --> 01:23:59,998
by main memory because you're just your

1693
01:23:57,179 --> 01:24:01,708
plowing through a crap-ton of data you

1694
01:23:59,998 --> 01:24:03,630
still don't want to give up on the

1695
01:24:01,708 --> 01:24:06,359
caches because they're still actually

1696
01:24:03,630 --> 01:24:08,279
important because the prefecture can

1697
01:24:06,359 --> 01:24:12,058
move things so that you're not waiting

1698
01:24:08,279 --> 01:24:15,448
the full 300 clocks right 300 clocks to

1699
01:24:12,059 --> 01:24:18,420
retrieve a single cache line would be

1700
01:24:15,448 --> 01:24:23,569
horrific for the actual speed of the CPU

1701
01:24:18,420 --> 01:24:27,090
right at 16 bytes I'm sorry 64 bytes

1702
01:24:23,569 --> 01:24:29,880
back to the core in 300 clocks would be

1703
01:24:27,090 --> 01:24:32,729
point 2 bytes per clock that's terrible

1704
01:24:29,880 --> 01:24:34,708
right so you can do way better than that

1705
01:24:32,729 --> 01:24:36,869
by just making sure that you actually

1706
01:24:34,708 --> 01:24:42,958
kind of inform the chip ahead of time

1707
01:24:36,868 --> 01:24:44,399
and that's where you can get that's what

1708
01:24:42,958 --> 01:24:46,170
what these linear simple access patterns

1709
01:24:44,399 --> 01:24:48,238
are for now what if you don't have a

1710
01:24:46,170 --> 01:24:49,618
simple linear access pattern there's one

1711
01:24:48,238 --> 01:24:52,319
other thing you can do they're called

1712
01:24:49,618 --> 01:24:54,420
prefetch instructions and what you can

1713
01:24:52,319 --> 01:24:56,038
do is you can use prefetch instructions

1714
01:24:54,420 --> 01:24:59,309
which are literally just things you

1715
01:24:56,038 --> 01:25:01,069
insert into a loop to tell the processor

1716
01:24:59,309 --> 01:25:05,159
what you're going to be working on next

1717
01:25:01,069 --> 01:25:07,738
right and you try to give it something

1718
01:25:05,158 --> 01:25:09,138
fairly far out so it can go to main

1719
01:25:07,738 --> 01:25:11,998
memory and get it prepared for you

1720
01:25:09,139 --> 01:25:14,849
insert prefetch instructions that's a

1721
01:25:11,998 --> 01:25:16,679
way of telling the prefetcher look this

1722
01:25:14,849 --> 01:25:17,788
is not a simple access pattern I know

1723
01:25:16,679 --> 01:25:22,649
there's no way you're gonna be able to

1724
01:25:17,788 --> 01:25:28,859
guess it so try to use my hints about

1725
01:25:22,649 --> 01:25:31,948
what to grab right ok so that these are

1726
01:25:28,859 --> 01:25:34,198
the three like simple rules of how to

1727
01:25:31,948 --> 01:25:36,509
start avoiding cache misses learn what

1728
01:25:34,198 --> 01:25:38,308
the sizes are and pack your data as

1729
01:25:36,510 --> 01:25:41,909
tightly as possible to try and get under

1730
01:25:38,309 --> 01:25:43,498
those sizes organize your data so that

1731
01:25:41,908 --> 01:25:45,719
things that are likely to be used

1732
01:25:43,498 --> 01:25:48,809
together are close together and you're

1733
01:25:45,719 --> 01:25:50,998
not wasting those 64 byte fetches on

1734
01:25:48,809 --> 01:25:52,920
crap you don't need just to get a little

1735
01:25:50,998 --> 01:25:56,038
bit you do need right trying to make all

1736
01:25:52,920 --> 01:25:58,800
64 bytes actually important and then

1737
01:25:56,038 --> 01:26:01,018
fine finally use simple access patterns

1738
01:25:58,800 --> 01:26:03,449
or insert 3 fetches into your code to

1739
01:26:01,019 --> 01:26:08,369
inform the CPU ahead of time what you

1740
01:26:03,448 --> 01:26:10,409
will need right ok so I realize that's a

1741
01:26:08,368 --> 01:26:12,569
ton of stuff to talk about but it

1742
01:26:10,409 --> 01:26:14,250
really all important there's so much

1743
01:26:12,569 --> 01:26:16,439
more in here we haven't covered all of

1744
01:26:14,250 --> 01:26:17,819
it's important you can actually get

1745
01:26:16,439 --> 01:26:19,710
problems with the register allocation

1746
01:26:17,819 --> 01:26:22,590
table you can get problems with these

1747
01:26:19,710 --> 01:26:24,000
things here there's there's a thing that

1748
01:26:22,590 --> 01:26:25,460
happens in that part of the chip

1749
01:26:24,000 --> 01:26:28,229
actually that's pretty interesting

1750
01:26:25,460 --> 01:26:34,500
itself which is you've got sort of these

1751
01:26:28,229 --> 01:26:38,039
work units and then you've got the l1

1752
01:26:34,500 --> 01:26:39,449
cache and in between there there's

1753
01:26:38,039 --> 01:26:42,060
actually these things called line

1754
01:26:39,449 --> 01:26:46,739
buffers and basically what happens is as

1755
01:26:42,060 --> 01:26:50,550
you sort of fill up work that's you know

1756
01:26:46,739 --> 01:26:52,439
I've modified memory that goes out to

1757
01:26:50,550 --> 01:26:53,730
these thing called line buffers and what

1758
01:26:52,439 --> 01:26:56,849
the line buffers are is they're

1759
01:26:53,729 --> 01:26:58,859
assembling up pieces of cache lines so

1760
01:26:56,850 --> 01:27:01,110
that it can later tell the l1 cache to

1761
01:26:58,859 --> 01:27:03,239
do an update of a full search before

1762
01:27:01,109 --> 01:27:05,099
bytes rather than like taking just like

1763
01:27:03,239 --> 01:27:07,439
four bytes of output that this thing did

1764
01:27:05,100 --> 01:27:09,030
you know and sending just four bytes

1765
01:27:07,439 --> 01:27:11,399
over so it's it's kind of like an

1766
01:27:09,029 --> 01:27:12,899
assembly station that tries to put

1767
01:27:11,399 --> 01:27:15,629
things together and what's interesting

1768
01:27:12,899 --> 01:27:17,759
about these line buffers is there's a

1769
01:27:15,630 --> 01:27:20,909
limited number so you can end up

1770
01:27:17,760 --> 01:27:23,430
throttling in here on line buffers that

1771
01:27:20,909 --> 01:27:25,889
are going out you can also throttle on

1772
01:27:23,430 --> 01:27:28,380
line buffers coming back so basically

1773
01:27:25,890 --> 01:27:30,510
what happens is these work units when

1774
01:27:28,380 --> 01:27:32,489
they need to do work that scheduler is

1775
01:27:30,510 --> 01:27:34,619
trying to find the results of things

1776
01:27:32,489 --> 01:27:35,969
sometimes it gets an instruction and it

1777
01:27:34,619 --> 01:27:37,769
goes where's the data for that

1778
01:27:35,970 --> 01:27:39,930
instruction oh the data for this are

1779
01:27:37,770 --> 01:27:43,110
just actually out in a line buffer let

1780
01:27:39,930 --> 01:27:44,520
me grab that back out of the line buffer

1781
01:27:43,109 --> 01:27:46,649
because I don't need to go to the cache

1782
01:27:44,520 --> 01:27:49,410
to get it and then I'll feed that

1783
01:27:46,649 --> 01:27:50,969
through the work unit right so there's

1784
01:27:49,409 --> 01:27:52,170
all these sorts of things gonna be

1785
01:27:50,970 --> 01:27:55,280
happening in there and it's fairly

1786
01:27:52,170 --> 01:27:57,569
complicated of what's happening right

1787
01:27:55,279 --> 01:27:59,489
all this stuff is really really

1788
01:27:57,569 --> 01:28:01,319
interesting and when you go down looking

1789
01:27:59,489 --> 01:28:03,630
at it it's incredible all the stuff

1790
01:28:01,319 --> 01:28:05,309
that's going on inside the CPU and all

1791
01:28:03,630 --> 01:28:07,710
of its both incredible and very

1792
01:28:05,310 --> 01:28:10,500
primitive when I say things like it's

1793
01:28:07,710 --> 01:28:14,399
looking for it's not looking for

1794
01:28:10,500 --> 01:28:16,619
anything it's a really like tight little

1795
01:28:14,399 --> 01:28:18,659
set of circuits that just do the best

1796
01:28:16,619 --> 01:28:20,670
they can at sort of heuristic aliy

1797
01:28:18,659 --> 01:28:23,220
grabbing things as they're necessary it

1798
01:28:20,670 --> 01:28:23,949
can fail all the time it actually has a

1799
01:28:23,220 --> 01:28:26,829
number of fail

1800
01:28:23,948 --> 01:28:28,899
cases where it doesn't assign things in

1801
01:28:26,828 --> 01:28:30,969
the optimal way and so things that

1802
01:28:28,899 --> 01:28:33,368
should reach a certain peak throughput

1803
01:28:30,969 --> 01:28:36,908
won't because the scheduler just it

1804
01:28:33,368 --> 01:28:38,259
isn't like a huge logic system it's not

1805
01:28:36,908 --> 01:28:40,388
like a program that in there that's

1806
01:28:38,260 --> 01:28:42,369
super comp K that's running it has to be

1807
01:28:40,389 --> 01:28:44,170
incredibly fast so it's actually fairly

1808
01:28:42,368 --> 01:28:47,679
simple circuits that are just kind of

1809
01:28:44,170 --> 01:28:49,179
doing basic work that happens to usually

1810
01:28:47,679 --> 01:28:52,899
end up picking the right instructions

1811
01:28:49,179 --> 01:28:54,880
but sometimes it just doesn't right and

1812
01:28:52,899 --> 01:28:56,768
the reason for that is just because it's

1813
01:28:54,880 --> 01:29:00,159
it's a guessing game right without

1814
01:28:56,769 --> 01:29:01,630
perfect knowledge if I have three units

1815
01:29:00,158 --> 01:29:03,458
that can do this particular instruction

1816
01:29:01,630 --> 01:29:06,400
and two units that can do this other one

1817
01:29:03,458 --> 01:29:08,738
but one of them is the same so one of

1818
01:29:06,399 --> 01:29:10,868
the units is shared between the two well

1819
01:29:08,738 --> 01:29:14,049
if I need to do this instruction stream

1820
01:29:10,868 --> 01:29:16,420
perfectly I may need to guess to not put

1821
01:29:14,050 --> 01:29:17,349
it on the shared one now because another

1822
01:29:16,420 --> 01:29:19,208
instruction is going to come down the

1823
01:29:17,349 --> 01:29:20,920
pipe that needs to use that shared one

1824
01:29:19,208 --> 01:29:23,559
so I should really do it on one of the

1825
01:29:20,920 --> 01:29:25,420
other ones right but maybe that same

1826
01:29:23,559 --> 01:29:27,070
choice would have been a mistake at a

1827
01:29:25,420 --> 01:29:28,538
different time because the shared ones

1828
01:29:27,069 --> 01:29:31,179
gonna be used for a different thing

1829
01:29:28,538 --> 01:29:33,069
right so when you have work units that

1830
01:29:31,179 --> 01:29:35,679
can execute multiple different things

1831
01:29:33,069 --> 01:29:37,658
and they're overlapping it's a very hard

1832
01:29:35,679 --> 01:29:39,368
scheduling problem we could all write a

1833
01:29:37,658 --> 01:29:41,198
program that would do it perfectly I'm

1834
01:29:39,368 --> 01:29:43,149
sure but it would be very expensive and

1835
01:29:41,198 --> 01:29:44,948
could never be made in the small amount

1836
01:29:43,149 --> 01:29:46,388
of silicon that's necessary to keep this

1837
01:29:44,948 --> 01:29:48,248
thing running at a super high rate of

1838
01:29:46,389 --> 01:29:50,260
four instructions per clock so you can

1839
01:29:48,248 --> 01:29:52,420
see why you get these sort of

1840
01:29:50,260 --> 01:29:58,510
interesting failure cases out of

1841
01:29:52,420 --> 01:30:01,719
something like this right okay so again

1842
01:29:58,510 --> 01:30:03,519
cache misses incredibly complicated to

1843
01:30:01,719 --> 01:30:05,408
analyze why are they so complicated

1844
01:30:03,519 --> 01:30:08,650
analyze because the chip is super

1845
01:30:05,408 --> 01:30:11,439
complex and a cache miss all it means is

1846
01:30:08,649 --> 01:30:14,198
that a particular set of an instruction

1847
01:30:11,439 --> 01:30:18,069
dependencies have to stall until we get

1848
01:30:14,198 --> 01:30:20,469
the results that either is or isn't a

1849
01:30:18,069 --> 01:30:23,319
huge deal for your algorithm depending

1850
01:30:20,469 --> 01:30:25,389
on what else can be executed right so

1851
01:30:23,319 --> 01:30:28,509
that's why I say it's not trivial to

1852
01:30:25,389 --> 01:30:30,699
understand when a cache misses costly or

1853
01:30:28,510 --> 01:30:34,239
when it isn't or how to architect better

1854
01:30:30,698 --> 01:30:36,069
to get less cache miss penalties because

1855
01:30:34,238 --> 01:30:37,089
it's all dependent on what else to the

1856
01:30:36,069 --> 01:30:39,340
scheduler do

1857
01:30:37,090 --> 01:30:41,739
maybe you've got 300 cycle cache misses

1858
01:30:39,340 --> 01:30:43,360
going on all the time but the algorithm

1859
01:30:41,739 --> 01:30:45,489
that you actually executing every time

1860
01:30:43,359 --> 01:30:48,309
you get one of those pieces of data back

1861
01:30:45,489 --> 01:30:50,079
actually takes 300 cycles itself because

1862
01:30:48,310 --> 01:30:53,380
it's really complicated right you may

1863
01:30:50,079 --> 01:30:54,939
never see the cache miss right you may

1864
01:30:53,380 --> 01:30:57,880
never see it because the amount of work

1865
01:30:54,939 --> 01:31:00,129
you're doing is more than the cost of

1866
01:30:57,880 --> 01:31:02,650
getting the memory so the chip because

1867
01:31:00,130 --> 01:31:04,930
of the scheduler is good at hiding cache

1868
01:31:02,649 --> 01:31:07,389
misses from you as well this gets even

1869
01:31:04,930 --> 01:31:11,530
more complicated once you get into hyper

1870
01:31:07,390 --> 01:31:13,119
threading right so if you have a chip

1871
01:31:11,529 --> 01:31:15,579
that's capable hypo threading but you

1872
01:31:13,119 --> 01:31:18,130
may or may not have but a hyper

1873
01:31:15,579 --> 01:31:19,600
threading chip is a chip whose scheduler

1874
01:31:18,130 --> 01:31:22,210
can scheduler from more than one thread

1875
01:31:19,600 --> 01:31:25,570
at a time so I have you know thread a

1876
01:31:22,210 --> 01:31:30,010
coming in here and I have thread B

1877
01:31:25,569 --> 01:31:32,199
coming in here thread a hits a 300 cycle

1878
01:31:30,010 --> 01:31:36,340
cache miss no big deal I just start

1879
01:31:32,199 --> 01:31:39,479
executing thread B right and so hyper

1880
01:31:36,340 --> 01:31:42,520
threading can even make it less obvious

1881
01:31:39,479 --> 01:31:43,929
how a cache miss will affect the

1882
01:31:42,520 --> 01:31:46,690
performance of your processor because

1883
01:31:43,930 --> 01:31:49,539
now it's fight it's it's basically like

1884
01:31:46,689 --> 01:31:51,969
filling work from two threads at once

1885
01:31:49,539 --> 01:31:54,699
and that ping pong in between those two

1886
01:31:51,970 --> 01:32:02,789
threads is actually super important

1887
01:31:54,699 --> 01:32:08,289
right and so that's really the you know

1888
01:32:02,789 --> 01:32:12,939
that's really the the truth about caches

1889
01:32:08,289 --> 01:32:16,539
they're incredibly incredibly hard to to

1890
01:32:12,939 --> 01:32:19,929
really to really explain how to avoid

1891
01:32:16,539 --> 01:32:22,689
right there is not much of an answer

1892
01:32:19,930 --> 01:32:27,340
beyond really learn your chip I mean

1893
01:32:22,689 --> 01:32:30,159
learn it inside it out and then find out

1894
01:32:27,340 --> 01:32:31,989
by actually doing profiling looking at

1895
01:32:30,159 --> 01:32:35,470
performance counters you can use like

1896
01:32:31,989 --> 01:32:37,689
vtune or perf on linux to actually look

1897
01:32:35,470 --> 01:32:39,420
how many cache misses i'm getting how

1898
01:32:37,689 --> 01:32:42,009
much am i stalling on those cache misses

1899
01:32:39,420 --> 01:32:43,390
are they actually costing me time or

1900
01:32:42,010 --> 01:32:46,090
aren't they well how many instructions

1901
01:32:43,390 --> 01:32:47,650
per clock am i issuing right until you

1902
01:32:46,090 --> 01:32:50,980
actually dig down in there it may be

1903
01:32:47,649 --> 01:32:53,079
impossible to really know until you

1904
01:32:50,979 --> 01:32:55,859
she look at the raw data and the

1905
01:32:53,079 --> 01:32:58,510
performance numbers you know it's it's

1906
01:32:55,859 --> 01:33:00,219
it's something that that is not obvious

1907
01:32:58,510 --> 01:33:01,989
until you actually start to look into it

1908
01:33:00,220 --> 01:33:03,760
how much you may or may not be affected

1909
01:33:01,988 --> 01:33:05,679
by caste because it's not as simple as

1910
01:33:03,760 --> 01:33:07,630
simply counting the amount of memory you

1911
01:33:05,680 --> 01:33:13,180
use because there's so much more going

1912
01:33:07,630 --> 01:33:15,100
into it because of that scheduler let me

1913
01:33:13,180 --> 01:33:18,640
try to since we've gone all the way down

1914
01:33:15,100 --> 01:33:20,110
this rathole let me try to answer the

1915
01:33:18,640 --> 01:33:21,489
questions that I've got this is kind of

1916
01:33:20,109 --> 01:33:23,769
turning into a handmaid job that's how

1917
01:33:21,488 --> 01:33:26,109
it goes sometimes let me try to scroll

1918
01:33:23,770 --> 01:33:27,700
through those questions that have to do

1919
01:33:26,109 --> 01:33:35,639
with cashing and I'm gonna try to answer

1920
01:33:27,699 --> 01:33:35,639
those let's see

1921
01:33:57,578 --> 01:34:08,299
okay is there a way to transfer data to

1922
01:34:03,559 --> 01:34:13,369
the cache manually so that answer

1923
01:34:08,300 --> 01:34:17,590
depends entirely on the CPU and I guess

1924
01:34:13,368 --> 01:34:20,630
the way I would say it is on the x64

1925
01:34:17,590 --> 01:34:23,958
there really isn't a way to transfer

1926
01:34:20,630 --> 01:34:28,630
data to the cache manually in a

1927
01:34:23,958 --> 01:34:37,099
mandatory fashion meaning you can't

1928
01:34:28,630 --> 01:34:40,400
force the x64 to do something with the

1929
01:34:37,099 --> 01:34:41,569
cache look like I just don't know any

1930
01:34:40,399 --> 01:34:44,679
way of doing that I don't think it's

1931
01:34:41,569 --> 01:34:48,618
possible but what you can do is is

1932
01:34:44,679 --> 01:34:51,109
suggest to it what to do and that's like

1933
01:34:48,618 --> 01:34:51,618
that prefetch instruction that I talked

1934
01:34:51,109 --> 01:34:54,828
about

1935
01:34:51,618 --> 01:34:58,179
so the the prefetch instruction is an

1936
01:34:54,828 --> 01:35:01,429
example of instruction that gives you a

1937
01:34:58,179 --> 01:35:04,729
it's and one of that in a new tab there

1938
01:35:01,429 --> 01:35:07,429
we go um the prefetch instruction is

1939
01:35:04,729 --> 01:35:10,789
example of a way to strongly suggest

1940
01:35:07,429 --> 01:35:14,328
that it do that and so in that sense you

1941
01:35:10,788 --> 01:35:17,238
can sort of force it right it's just not

1942
01:35:14,328 --> 01:35:20,238
mandatory so what you can see here is

1943
01:35:17,238 --> 01:35:24,348
this mm prefetch instruction basically

1944
01:35:20,238 --> 01:35:28,129
says I'm gonna give you a pointer and

1945
01:35:24,349 --> 01:35:29,900
you know I don't love I'm gonna use the

1946
01:35:28,130 --> 01:35:31,779
you ops table I don't love the intrinsic

1947
01:35:29,899 --> 01:35:34,549
guide for talking about actual

1948
01:35:31,779 --> 01:35:38,029
instructions because that's intrinsic so

1949
01:35:34,550 --> 01:35:40,279
I kind of prefer I kind of prefer the

1950
01:35:38,029 --> 01:35:47,719
you up table for that so I'm gonna I'm

1951
01:35:40,279 --> 01:35:49,658
gonna load up all the goodness here all

1952
01:35:47,719 --> 01:35:51,939
right

1953
01:35:49,658 --> 01:35:56,649
so these are the actual instructions

1954
01:35:51,939 --> 01:36:01,779
prefetch MTA prefetch t0 prefetch t1

1955
01:35:56,649 --> 01:36:05,799
prefetch t2 so what these instructions

1956
01:36:01,779 --> 01:36:09,099
do is they say look i'ma tell you that I

1957
01:36:05,800 --> 01:36:10,810
need to use a particular cache line I'm

1958
01:36:09,100 --> 01:36:12,489
telling you I'm gonna need it later and

1959
01:36:10,810 --> 01:36:14,590
I'm gonna try and give you enough

1960
01:36:12,488 --> 01:36:15,939
advance notice that it's long enough to

1961
01:36:14,590 --> 01:36:18,460
go to main memory to get it if you need

1962
01:36:15,939 --> 01:36:22,079
to and then furthermore depending on

1963
01:36:18,460 --> 01:36:25,270
whether but I use MTA t0 t1 or t2 I'm

1964
01:36:22,079 --> 01:36:27,219
also gonna try to tell you what I think

1965
01:36:25,270 --> 01:36:31,239
you might need to do with that cache

1966
01:36:27,219 --> 01:36:33,579
line right so prefetch t0 is basically

1967
01:36:31,238 --> 01:36:37,689
saying I think we're going to need this

1968
01:36:33,579 --> 01:36:39,579
in the like closest level right I don't

1969
01:36:37,689 --> 01:36:43,359
know that this has exclamations of the

1970
01:36:39,579 --> 01:36:46,000
instructions in here I guess when I said

1971
01:36:43,359 --> 01:36:49,389
that this was the best thing to use what

1972
01:36:46,000 --> 01:36:54,389
I actually meant is totally not that so

1973
01:36:49,389 --> 01:36:56,409
sorry about that we load it up in here

1974
01:36:54,389 --> 01:36:58,770
actually I guess I can just jump to it

1975
01:36:56,408 --> 01:36:58,769
straight here

1976
01:37:03,880 --> 01:37:12,199
where is my pre-fit there it is okay so

1977
01:37:10,369 --> 01:37:14,840
what you can see here is here's the

1978
01:37:12,199 --> 01:37:16,069
prefetch instructions and I've got a

1979
01:37:14,840 --> 01:37:18,650
couple different ones they all take a

1980
01:37:16,069 --> 01:37:21,170
memory pointer it doesn't matter what

1981
01:37:18,649 --> 01:37:23,359
that pointers bottom bits are because

1982
01:37:21,170 --> 01:37:26,300
it's just going to fetch that cache line

1983
01:37:23,359 --> 01:37:29,569
right so remember a cache line is a 64

1984
01:37:26,300 --> 01:37:33,440
byte chunk of memory aligned to 64 bytes

1985
01:37:29,569 --> 01:37:35,000
so the bottom six bits are irrelevant

1986
01:37:33,439 --> 01:37:36,649
doesn't matter what they are they're

1987
01:37:35,000 --> 01:37:39,409
right sorry bottom five bits are

1988
01:37:36,649 --> 01:37:42,139
irrelevant it only matters what the high

1989
01:37:39,409 --> 01:37:46,340
bits are because they come in chunks of

1990
01:37:42,140 --> 01:37:49,550
64 right and so when we actually fetch

1991
01:37:46,340 --> 01:37:52,789
we're gonna say the pointer to this

1992
01:37:49,550 --> 01:37:54,829
cache line no matter where the is inside

1993
01:37:52,789 --> 01:37:56,930
the cache line doesn't matter that whole

1994
01:37:54,829 --> 01:37:59,989
cache line I want you to know I'm gonna

1995
01:37:56,930 --> 01:38:03,800
use it soon and then based on which of

1996
01:37:59,989 --> 01:38:05,750
these hints I use t0 t1 or t2 or the

1997
01:38:03,800 --> 01:38:10,760
special NTA which we'll talk about a

1998
01:38:05,750 --> 01:38:14,300
second this tells me how I expect to use

1999
01:38:10,760 --> 01:38:16,369
it a t0 fetch says give it to me

2000
01:38:14,300 --> 01:38:18,980
everywhere I want the t0

2001
01:38:16,369 --> 01:38:22,399
I want the the l1 the l2 and the l3

2002
01:38:18,979 --> 01:38:22,819
cache is all filled if I say t1 that

2003
01:38:22,399 --> 01:38:26,809
means

2004
01:38:22,819 --> 01:38:29,899
well I'm not quite sure it needs to be

2005
01:38:26,810 --> 01:38:33,230
all the way down to the 32k l1 cache so

2006
01:38:29,899 --> 01:38:36,859
maybe don't bother right put it only up

2007
01:38:33,229 --> 01:38:41,959
in the l2 and l3 and then t2 is saying

2008
01:38:36,859 --> 01:38:46,869
just the l3 right NTA is different than

2009
01:38:41,960 --> 01:38:50,720
these what empty what MTA says is look

2010
01:38:46,869 --> 01:38:53,829
I'm gonna use this thing real soon I

2011
01:38:50,720 --> 01:38:56,840
need you to make it be available to me

2012
01:38:53,829 --> 01:39:00,319
but I'm never gonna use it after that

2013
01:38:56,840 --> 01:39:03,949
for a long time so don't put it in the

2014
01:39:00,319 --> 01:39:05,929
l3 don't put it in the l2 if somehow you

2015
01:39:03,949 --> 01:39:08,869
can not put it in the l1 go ahead and

2016
01:39:05,930 --> 01:39:10,670
don't but maybe just put it in the l1 so

2017
01:39:08,869 --> 01:39:12,859
I can use it right away and then let's

2018
01:39:10,670 --> 01:39:14,659
get rid of it so don't pollute anything

2019
01:39:12,859 --> 01:39:17,329
else right

2020
01:39:14,659 --> 01:39:20,569
so basically it's saying this data gets

2021
01:39:17,329 --> 01:39:22,850
used once and not multiple times don't

2022
01:39:20,569 --> 01:39:25,639
pollute the cache minimize the cache

2023
01:39:22,850 --> 01:39:27,470
pollution now that may mean it can use

2024
01:39:25,640 --> 01:39:28,820
some special side Channel who knows when

2025
01:39:27,470 --> 01:39:31,070
the processor architects are free to do

2026
01:39:28,819 --> 01:39:32,869
whatever they want or it may mean it has

2027
01:39:31,069 --> 01:39:34,699
to fill the whole thing it depends on

2028
01:39:32,869 --> 01:39:37,519
the architecture whether it can do

2029
01:39:34,699 --> 01:39:39,559
anything with that NT a hint but it's a

2030
01:39:37,520 --> 01:39:41,090
hint it's it's you announcing what

2031
01:39:39,560 --> 01:39:42,289
you're going to do and the degree to

2032
01:39:41,090 --> 01:39:43,970
which the processor can actually do

2033
01:39:42,289 --> 01:39:46,699
something about that depends on the

2034
01:39:43,970 --> 01:39:49,550
processor right so that's one way

2035
01:39:46,699 --> 01:39:56,179
there's another way it can do it it's

2036
01:39:49,550 --> 01:39:59,869
called a non temporal store can't

2037
01:39:56,180 --> 01:40:00,380
remember the instruction for that there

2038
01:39:59,869 --> 01:40:08,300
you go

2039
01:40:00,380 --> 01:40:10,789
so some of the when you're working with

2040
01:40:08,300 --> 01:40:12,829
bulk data like that and sort of in a

2041
01:40:10,789 --> 01:40:14,269
similar situation where the prefetch NTA

2042
01:40:12,829 --> 01:40:17,269
might be involved where you're saying

2043
01:40:14,270 --> 01:40:20,210
look I don't need you to fill these

2044
01:40:17,270 --> 01:40:22,250
caches because I'm not gonna touch this

2045
01:40:20,210 --> 01:40:25,399
data multiple times I'm loading it in

2046
01:40:22,250 --> 01:40:26,479
once and then I'm writing it out and

2047
01:40:25,399 --> 01:40:29,779
then we're never gonna see it again

2048
01:40:26,479 --> 01:40:32,899
right so don't pretend I'm gonna keep

2049
01:40:29,779 --> 01:40:34,849
accessing because I'm not the same is

2050
01:40:32,899 --> 01:40:36,500
true for right pollution so you could

2051
01:40:34,850 --> 01:40:38,870
think of that as read as cache pollution

2052
01:40:36,500 --> 01:40:41,029
that happens on a read I'm reading data

2053
01:40:38,869 --> 01:40:42,559
the CPU goes oh he's reading this data

2054
01:40:41,029 --> 01:40:45,319
let me feel the caches but you're like

2055
01:40:42,560 --> 01:40:47,120
no I I'm never gonna use this again

2056
01:40:45,319 --> 01:40:49,519
don't pollute the caches if it's not in

2057
01:40:47,119 --> 01:40:51,859
there already don't put it in there just

2058
01:40:49,520 --> 01:40:55,520
give it to me once and we're done right

2059
01:40:51,859 --> 01:40:58,250
and so the same thing is true for right

2060
01:40:55,520 --> 01:41:01,430
pollution and so these are ways of

2061
01:40:58,250 --> 01:41:03,170
writing to memory and saying don't put

2062
01:41:01,430 --> 01:41:05,270
them in the cache just write them to

2063
01:41:03,170 --> 01:41:07,699
memory I'm not gonna ask for them again

2064
01:41:05,270 --> 01:41:11,360
for a long time so don't pollute my

2065
01:41:07,699 --> 01:41:14,840
cache with them right so those are the

2066
01:41:11,359 --> 01:41:18,409
two ways that you can try to micromanage

2067
01:41:14,840 --> 01:41:20,090
the cache but again these are hits the

2068
01:41:18,409 --> 01:41:23,029
processor is it's you're not really

2069
01:41:20,090 --> 01:41:25,279
telling the processor what to do you're

2070
01:41:23,029 --> 01:41:27,800
telling the plus sir what you want and

2071
01:41:25,279 --> 01:41:31,789
it may or may not do something

2072
01:41:27,800 --> 01:41:33,949
based on that so that's probably about

2073
01:41:31,789 --> 01:41:36,439
all you can say there are other

2074
01:41:33,948 --> 01:41:40,098
processors so for example let's suppose

2075
01:41:36,439 --> 01:41:42,319
we take the dolphin processor is a

2076
01:41:40,099 --> 01:41:44,300
processor that was in a machine called

2077
01:41:42,319 --> 01:41:46,849
the GameCube from Nintendo which you may

2078
01:41:44,300 --> 01:41:49,789
have or may not have heard of or used if

2079
01:41:46,849 --> 01:41:53,210
depending on how old you are that

2080
01:41:49,789 --> 01:41:58,090
process or did have manual cache control

2081
01:41:53,210 --> 01:42:01,429
I believe it had a 64 K cache I think

2082
01:41:58,090 --> 01:42:05,119
and the way it worked was you could

2083
01:42:01,429 --> 01:42:09,289
treat as 64 K of cash or 32 K of cash

2084
01:42:05,118 --> 01:42:11,359
and 32k of local memory basically so

2085
01:42:09,289 --> 01:42:15,559
when you put the machine into that mode

2086
01:42:11,359 --> 01:42:17,149
it would say 32k of my 64 K cash I'm

2087
01:42:15,559 --> 01:42:19,579
just gonna trust that you know what to

2088
01:42:17,149 --> 01:42:22,819
do with it and you could tell it exactly

2089
01:42:19,578 --> 01:42:30,069
how you wanted it filled so that's an

2090
01:42:22,819 --> 01:42:33,279
example of as a PowerPC derived chip

2091
01:42:30,069 --> 01:42:35,779
with manual cash control for real right

2092
01:42:33,279 --> 01:42:39,019
another good example of that would be

2093
01:42:35,779 --> 01:42:42,500
the PlayStation 3 the PlayStation 3 had

2094
01:42:39,020 --> 01:42:44,599
regular caching on its main processor of

2095
01:42:42,500 --> 01:42:46,969
which had only had one core but then it

2096
01:42:44,599 --> 01:42:48,619
had these things called SPU's which were

2097
01:42:46,969 --> 01:42:51,739
the main workhorses of the processor

2098
01:42:48,618 --> 01:42:55,039
they were effectively very fast DSPs and

2099
01:42:51,738 --> 01:43:02,259
those actually literally only have

2100
01:42:55,039 --> 01:43:07,399
manual cache they were literally a 64 no

2101
01:43:02,260 --> 01:43:10,520
256 K I think they were 256 K of local

2102
01:43:07,399 --> 01:43:13,339
strapped on memory to each one of these

2103
01:43:10,520 --> 01:43:17,630
SP use of which there were eight seven

2104
01:43:13,340 --> 01:43:21,889
something like that and all of it was

2105
01:43:17,630 --> 01:43:23,510
manual so you basically would queue up

2106
01:43:21,889 --> 01:43:24,710
you were like here's the memory I'm

2107
01:43:23,510 --> 01:43:26,929
gonna need the axe power I'm going to

2108
01:43:24,710 --> 01:43:28,639
need you did work and it was very

2109
01:43:26,929 --> 01:43:30,020
predictable so you tried to like do the

2110
01:43:28,639 --> 01:43:31,760
exact amount of work and then a new

2111
01:43:30,020 --> 01:43:37,820
piece of member would come in and you do

2112
01:43:31,760 --> 01:43:39,980
work right and so basically like the

2113
01:43:37,819 --> 01:43:41,329
SPU's on a Playstation 3 are a good

2114
01:43:39,979 --> 01:43:46,219
example of

2115
01:43:41,329 --> 01:43:51,519
manual cash there was no cash on those

2116
01:43:46,220 --> 01:43:55,100
SPU's that was controlled by like a

2117
01:43:51,520 --> 01:43:56,450
CPU logic thing I don't think could be

2118
01:43:55,100 --> 01:44:01,010
wrong about that though I never really

2119
01:43:56,449 --> 01:44:05,510
program SPU's all right you 64 bytes the

2120
01:44:01,010 --> 01:44:07,150
cache line size on every CPU yes

2121
01:44:05,510 --> 01:44:10,190
actually

2122
01:44:07,149 --> 01:44:13,369
so historically speaking no obviously

2123
01:44:10,189 --> 01:44:16,219
those cache line sizes have varied

2124
01:44:13,369 --> 01:44:20,359
throughout history certainly but

2125
01:44:16,220 --> 01:44:22,570
nowadays for whatever reason maybe it's

2126
01:44:20,359 --> 01:44:24,739
just the optimal number I don't know

2127
01:44:22,569 --> 01:44:28,989
you'd have to ask a hardware designer

2128
01:44:24,739 --> 01:44:32,689
maybe Y 64 bytes tends to be it but

2129
01:44:28,989 --> 01:44:35,750
you'd be hard-pressed to find a consumer

2130
01:44:32,689 --> 01:44:37,879
machine without a 64 byte cache all of

2131
01:44:35,750 --> 01:44:40,909
the modern AMD chips are 64 byte cache

2132
01:44:37,880 --> 01:44:43,010
all of the modern intel chip repair

2133
01:44:40,909 --> 01:44:47,359
tests I think even all of the typical

2134
01:44:43,010 --> 01:44:50,270
ARM chips on like an iPhone are 64 byte

2135
01:44:47,359 --> 01:44:53,119
caches so there's probably something out

2136
01:44:50,270 --> 01:44:56,150
there that's not but like yeah it's 64

2137
01:44:53,119 --> 01:44:57,829
bytes which is great we happen to be

2138
01:44:56,149 --> 01:44:59,899
living in that rare time period where

2139
01:44:57,829 --> 01:45:03,019
everything you program for is 64 byte

2140
01:44:59,899 --> 01:45:05,210
caches little-endian what a great world

2141
01:45:03,020 --> 01:45:08,090
right I'm sure it's not gonna last cuz

2142
01:45:05,210 --> 01:45:09,680
some friggin hardware guys gonna come

2143
01:45:08,090 --> 01:45:13,190
along and decide to do big endian again

2144
01:45:09,680 --> 01:45:14,810
or change the cache size to 26 bytes or

2145
01:45:13,189 --> 01:45:16,989
I don't know what but you happen to be

2146
01:45:14,810 --> 01:45:19,640
in a time right now where it just like

2147
01:45:16,989 --> 01:45:21,340
it happens to be 64 byte little endian

2148
01:45:19,640 --> 01:45:23,750
everywhere and that's really nice it

2149
01:45:21,340 --> 01:45:25,310
simplifies things for a programmer who's

2150
01:45:23,750 --> 01:45:27,439
trying to do performance oriented code

2151
01:45:25,310 --> 01:45:28,850
takes some things out of the equation

2152
01:45:27,439 --> 01:45:32,809
when you're doing cross-platform

2153
01:45:28,850 --> 01:45:34,760
targeting I tested me on the news energy

2154
01:45:32,810 --> 01:45:36,380
processors I have not I would love to I

2155
01:45:34,760 --> 01:45:39,020
don't have one someone wants to send me

2156
01:45:36,380 --> 01:45:41,270
a computer I'd be happy to test them AMD

2157
01:45:39,020 --> 01:45:43,310
if you're out there send me as some of

2158
01:45:41,270 --> 01:45:45,800
your latest machines and I'd be happy to

2159
01:45:43,310 --> 01:45:48,100
test me on hash it's the fastest hash on

2160
01:45:45,800 --> 01:45:48,100
Intel

2161
01:45:53,210 --> 01:46:04,010
let's see this is also important for DMA

2162
01:46:00,439 --> 01:46:05,299
memory yes well so the SPU that's sort

2163
01:46:04,010 --> 01:46:07,280
of how it worked right and it's

2164
01:46:05,300 --> 01:46:09,470
important to remember that DMA memory is

2165
01:46:07,279 --> 01:46:11,539
just is really no different from regular

2166
01:46:09,470 --> 01:46:14,000
memory that we have in aces before it's

2167
01:46:11,539 --> 01:46:16,430
just a little more explicit about how

2168
01:46:14,000 --> 01:46:18,470
its programmed but you actually kind of

2169
01:46:16,430 --> 01:46:22,010
need to think about it the same way even

2170
01:46:18,470 --> 01:46:24,619
on a processor such as the x64 skylights

2171
01:46:22,010 --> 01:46:27,590
that we're using here that don't feature

2172
01:46:24,619 --> 01:46:30,649
explicit DMA memory it's still sort of

2173
01:46:27,590 --> 01:46:33,500
is the same thing you're still trying to

2174
01:46:30,649 --> 01:46:35,539
schedule memory to get into the CPU at

2175
01:46:33,500 --> 01:46:37,729
the right time to use it which is what

2176
01:46:35,539 --> 01:46:40,250
DMA is all about and so your thought

2177
01:46:37,729 --> 01:46:42,979
process between an explicit DMA chip

2178
01:46:40,250 --> 01:46:44,239
like the SPU where there's no behind

2179
01:46:42,979 --> 01:46:46,219
your back caching it everything's

2180
01:46:44,239 --> 01:46:48,439
explicit you have to set up chains and

2181
01:46:46,220 --> 01:46:50,780
tell them when to come in it's really

2182
01:46:48,439 --> 01:46:53,059
not that different today because you

2183
01:46:50,779 --> 01:46:55,729
still now today just have to think how

2184
01:46:53,060 --> 01:46:58,340
do I get the CPU to basically do the

2185
01:46:55,729 --> 01:47:01,459
right DMA schedule that I wanted right

2186
01:46:58,340 --> 01:47:02,989
and so it's very similar thought process

2187
01:47:01,460 --> 01:47:04,760
and a very similar optimization you're

2188
01:47:02,989 --> 01:47:06,529
trying to think about how to structure

2189
01:47:04,760 --> 01:47:10,250
your code so the right stuff comes in at

2190
01:47:06,529 --> 01:47:11,840
the right time how does the processor

2191
01:47:10,250 --> 01:47:15,229
handle multiple programs right at the

2192
01:47:11,840 --> 01:47:18,500
same time in regards to the cache so the

2193
01:47:15,229 --> 01:47:21,259
answer there is I it depends really what

2194
01:47:18,500 --> 01:47:26,539
you're talking about when you say what

2195
01:47:21,260 --> 01:47:27,920
gets handled so inside so let's let's

2196
01:47:26,539 --> 01:47:29,930
just go this is turned into an all-day

2197
01:47:27,920 --> 01:47:33,140
cache solution so let's just go why

2198
01:47:29,930 --> 01:47:34,789
leave anything out right so let's

2199
01:47:33,140 --> 01:47:36,740
broaden our picture and start talking

2200
01:47:34,789 --> 01:47:37,819
about even more complicated crap that

2201
01:47:36,739 --> 01:47:38,679
goes on in here because it's really

2202
01:47:37,819 --> 01:47:41,750
complicated

2203
01:47:38,680 --> 01:47:46,670
so let's suppose we look at a block

2204
01:47:41,750 --> 01:47:48,949
diagram of a modern CPU right um well

2205
01:47:46,670 --> 01:47:55,279
you know what we can instead of my

2206
01:47:48,949 --> 01:47:58,449
crappy drawing die pictures of am teeth

2207
01:47:55,279 --> 01:47:58,449
red refer to

2208
01:48:03,689 --> 01:48:10,009
let's see so I want that's what I want

2209
01:48:07,670 --> 01:48:12,029
[Music]

2210
01:48:10,010 --> 01:48:15,510
can I get someone who's actually

2211
01:48:12,029 --> 01:48:17,789
highlighted them cuz I'm not you know

2212
01:48:15,510 --> 01:48:22,980
like I said I'm not a chip guy I'm not

2213
01:48:17,789 --> 01:48:27,719
qualified to walk you through the die on

2214
01:48:22,979 --> 01:48:34,829
a on a send chip just from looking at it

2215
01:48:27,719 --> 01:48:42,899
right but but sometimes you can find

2216
01:48:34,829 --> 01:48:47,100
people who have who have got the die can

2217
01:48:42,899 --> 01:48:49,579
I get us into in today did they do is

2218
01:48:47,100 --> 01:48:49,579
into

2219
01:48:53,779 --> 01:48:59,250
here we go do they have oh but they okay

2220
01:48:57,989 --> 01:49:01,260
so they don't they don't have the dye

2221
01:48:59,250 --> 01:49:03,750
shots on here though so I guess I guess

2222
01:49:01,260 --> 01:49:05,369
we're sticking with this um so I I may

2223
01:49:03,750 --> 01:49:08,939
not be able to find a good one here us

2224
01:49:05,369 --> 01:49:11,420
that's kind of hoping for a good a good

2225
01:49:08,939 --> 01:49:11,419
dye shot

2226
01:49:21,198 --> 01:49:25,689
so there's some good ones here ok ok ok

2227
01:49:26,710 --> 01:49:35,420
so this is an example of a die shot of a

2228
01:49:32,390 --> 01:49:37,730
CPU core right and hopefully what you

2229
01:49:35,420 --> 01:49:40,159
can see here is that these things these

2230
01:49:37,729 --> 01:49:42,678
boxes that I'm drawing when I say like

2231
01:49:40,159 --> 01:49:44,179
here's a box of you know logical

2232
01:49:42,679 --> 01:49:46,940
processing unit or whatever crap like

2233
01:49:44,179 --> 01:49:49,730
that is I'm drawing a semantic picture

2234
01:49:46,939 --> 01:49:52,488
of a CPU and so I'm not trying to draw

2235
01:49:49,729 --> 01:49:55,639
like what's actually the desired CP or

2236
01:49:52,488 --> 01:49:58,698
anything but actually if you go look at

2237
01:49:55,640 --> 01:50:01,160
an actual CPU it's actually kind of like

2238
01:49:58,698 --> 01:50:02,899
that it's not it's different but it's

2239
01:50:01,159 --> 01:50:05,719
not that different and what you can see

2240
01:50:02,899 --> 01:50:08,599
is things actually are a bunch of blocks

2241
01:50:05,719 --> 01:50:11,090
like they actually are regions of the

2242
01:50:08,600 --> 01:50:13,370
chip that do actually function as

2243
01:50:11,090 --> 01:50:15,260
coherent units that have to literally

2244
01:50:13,369 --> 01:50:19,069
talk to each other and so what you can

2245
01:50:15,260 --> 01:50:21,610
see here is it's not marked but I'm

2246
01:50:19,069 --> 01:50:25,009
assuming this is the l2 cache here right

2247
01:50:21,609 --> 01:50:27,279
kind of strapped on to the l3 so you

2248
01:50:25,010 --> 01:50:29,900
know you can kind of see how this works

2249
01:50:27,279 --> 01:50:32,359
depending on how the chip is configured

2250
01:50:29,899 --> 01:50:34,849
you can see that each of your cores has

2251
01:50:32,359 --> 01:50:38,719
some of its own cache and some of the

2252
01:50:34,850 --> 01:50:42,520
cache is shared right and so typically

2253
01:50:38,719 --> 01:50:45,800
what happens in a modern course is

2254
01:50:42,520 --> 01:50:48,949
because the core count tends to keep

2255
01:50:45,800 --> 01:50:51,380
increasing this kind of structure

2256
01:50:48,948 --> 01:50:53,839
becomes more and more complicated you

2257
01:50:51,380 --> 01:50:59,659
tend to have actually fairly difficult

2258
01:50:53,840 --> 01:51:01,369
work you you tend to have to do a lot

2259
01:50:59,659 --> 01:51:03,319
more thinking about how the memory is

2260
01:51:01,369 --> 01:51:04,880
going to get routed now in this case

2261
01:51:03,319 --> 01:51:06,979
it's pretty simple you can see what

2262
01:51:04,880 --> 01:51:08,359
would happen if a particular core wanted

2263
01:51:06,979 --> 01:51:11,119
a particular piece of memory it would

2264
01:51:08,359 --> 01:51:13,759
ask its l1 which I don't know where that

2265
01:51:11,119 --> 01:51:16,909
is actually on here but I assume this is

2266
01:51:13,760 --> 01:51:17,989
the l2 it would ask its l1 maybe that's

2267
01:51:16,909 --> 01:51:22,119
this stuff here

2268
01:51:17,988 --> 01:51:22,119
I don't know does anyone have

2269
01:51:27,079 --> 01:51:31,409
yeah so you can so you can see I was

2270
01:51:29,220 --> 01:51:34,409
right about the l2 but I don't see the

2271
01:51:31,409 --> 01:51:36,090
l1 in here so I don't really know like I

2272
01:51:34,409 --> 01:51:38,430
said I'm not qualified to analyze dye

2273
01:51:36,090 --> 01:51:39,930
shots so I'm not gonna try and guess but

2274
01:51:38,430 --> 01:51:41,730
you know somewhere in here there's an l1

2275
01:51:39,930 --> 01:51:44,880
when it misses it's going to hit this l2

2276
01:51:41,729 --> 01:51:47,699
the l2 is gonna ask the l3 when it

2277
01:51:44,880 --> 01:51:49,380
misses and the l3 because it's the thing

2278
01:51:47,699 --> 01:51:52,199
that's shared is sort of like the

2279
01:51:49,380 --> 01:51:54,510
central arbiter so the l3 is the thing

2280
01:51:52,199 --> 01:51:56,579
that's going to say oh you know what you

2281
01:51:54,510 --> 01:51:58,890
wanted this piece of memory bad news

2282
01:51:56,579 --> 01:52:00,449
core zeros using it right now and you

2283
01:51:58,890 --> 01:52:04,440
can't have it or something like that

2284
01:52:00,449 --> 01:52:06,449
right before I go into talking about how

2285
01:52:04,439 --> 01:52:08,129
that sort of thing works which is

2286
01:52:06,449 --> 01:52:13,159
germane your question I would really

2287
01:52:08,130 --> 01:52:13,159
like to find a die shot of as n2 CPU

2288
01:52:16,220 --> 01:52:21,449
because I wanted to show you this

2289
01:52:18,750 --> 01:52:25,170
getting worse because that was actually

2290
01:52:21,449 --> 01:52:34,859
simpler and this is as n2 CPU is gonna

2291
01:52:25,170 --> 01:52:37,010
have a more a more complex die gosh darn

2292
01:52:34,859 --> 01:52:37,009
it

2293
01:53:00,960 --> 01:53:06,539
okay okay okay this is be good enough

2294
01:53:03,329 --> 01:53:17,039
it's not really a diet though well maybe

2295
01:53:06,539 --> 01:53:18,300
this would have it not sure okay so the

2296
01:53:17,039 --> 01:53:19,920
only thing that I wanted to kind of talk

2297
01:53:18,300 --> 01:53:22,010
about before I got into like what

2298
01:53:19,920 --> 01:53:27,480
actually happens with the cash there is

2299
01:53:22,010 --> 01:53:28,980
that if you look at this sort of block

2300
01:53:27,479 --> 01:53:32,729
diagram which is not as good as a die

2301
01:53:28,979 --> 01:53:39,929
shot but if you look at how the new like

2302
01:53:32,729 --> 01:53:41,669
Zen's architected let me start by

2303
01:53:39,930 --> 01:53:43,289
talking about yield because this is a

2304
01:53:41,670 --> 01:53:44,819
Mira Torre answer so we're just we're

2305
01:53:43,289 --> 01:53:46,909
going all over the place and I apologize

2306
01:53:44,819 --> 01:53:50,869
but I'm just giving you the full thing

2307
01:53:46,909 --> 01:53:55,889
computing is complicated what can I say

2308
01:53:50,869 --> 01:53:58,649
so modern CPUs are incredibly hard to

2309
01:53:55,890 --> 01:54:02,820
make and if you don't believe me I would

2310
01:53:58,649 --> 01:54:05,819
highly encourage you to just go look in

2311
01:54:02,819 --> 01:54:08,519
fact Fabien Giessen and myself have

2312
01:54:05,819 --> 01:54:13,829
recently been trading links about what's

2313
01:54:08,520 --> 01:54:15,300
called extreme UV lithography which is

2314
01:54:13,829 --> 01:54:17,760
something that they're having to do now

2315
01:54:15,300 --> 01:54:21,239
in order to try and get chip production

2316
01:54:17,760 --> 01:54:23,610
speed fast enough that small at the

2317
01:54:21,239 --> 01:54:26,579
really small feature sizes that they're

2318
01:54:23,609 --> 01:54:28,369
trying to do and I would highly

2319
01:54:26,579 --> 01:54:32,819
recommend going and reading about

2320
01:54:28,369 --> 01:54:34,319
extreme UV lithography not because it's

2321
01:54:32,819 --> 01:54:38,880
really all that important to know but

2322
01:54:34,319 --> 01:54:43,409
rather because if you just take a second

2323
01:54:38,880 --> 01:54:46,859
to think about just how nuts it is to

2324
01:54:43,409 --> 01:54:49,649
make a chip nowadays that can kind of

2325
01:54:46,859 --> 01:54:51,119
help inform your thinking about why some

2326
01:54:49,649 --> 01:54:55,409
of these things are the way they are

2327
01:54:51,119 --> 01:55:00,210
right it's just hard to give you a

2328
01:54:55,409 --> 01:55:02,789
slight example extreme UV lithography is

2329
01:55:00,210 --> 01:55:04,109
a way to well let's look at let's just

2330
01:55:02,789 --> 01:55:07,199
this is all just reinforcing stuff so

2331
01:55:04,109 --> 01:55:09,299
I'm just going to talk about it alright

2332
01:55:07,199 --> 01:55:12,510
so how do I make a chip how do we how do

2333
01:55:09,300 --> 01:55:16,320
we just make a chip at all right

2334
01:55:12,510 --> 01:55:19,800
uh well you know you go read online and

2335
01:55:16,319 --> 01:55:25,259
they're like hey we got this new 7

2336
01:55:19,800 --> 01:55:28,139
nanometre fab right at TSMC right this

2337
01:55:25,260 --> 01:55:31,710
is the kind of stuff you'd read this is

2338
01:55:28,139 --> 01:55:35,340
our new 7 nanometre fab TSMC and we're

2339
01:55:31,710 --> 01:55:40,170
using it for making the you know the the

2340
01:55:35,340 --> 01:55:43,650
new rising chips you know and blah blah

2341
01:55:40,170 --> 01:55:47,190
blah right what what is what does that

2342
01:55:43,649 --> 01:55:49,078
mean what's TSMC what is seven nanometer

2343
01:55:47,189 --> 01:55:51,029
what's a fab I don't know right

2344
01:55:49,078 --> 01:55:53,219
well obviously the easiest thing is well

2345
01:55:51,029 --> 01:55:57,090
TSMC is a company right you can look at

2346
01:55:53,219 --> 01:55:59,519
them here they are right they're a

2347
01:55:57,090 --> 01:56:01,920
company in Taiwan and they make chips

2348
01:55:59,519 --> 01:56:09,059
right they actually make the physical

2349
01:56:01,920 --> 01:56:10,230
chips that you use so they're a like I

2350
01:56:09,059 --> 01:56:11,730
don't know what you call them a

2351
01:56:10,229 --> 01:56:13,888
third-party fab I don't know how you

2352
01:56:11,729 --> 01:56:15,779
would describe it but you know a company

2353
01:56:13,889 --> 01:56:17,460
like Intel they have their own fab and

2354
01:56:15,779 --> 01:56:20,340
their own fab technology which means

2355
01:56:17,460 --> 01:56:22,198
that when they go to make the latest eye

2356
01:56:20,340 --> 01:56:24,869
9 chip that you're going to buy and put

2357
01:56:22,198 --> 01:56:27,719
your desktop processor Intel itself owns

2358
01:56:24,868 --> 01:56:30,389
the fabrication facility they're

2359
01:56:27,719 --> 01:56:32,158
actually here in the u.s. usually I and

2360
01:56:30,389 --> 01:56:33,269
they will go with there's something I

2361
01:56:32,158 --> 01:56:34,710
think they have them in Isreal as well I

2362
01:56:33,269 --> 01:56:38,550
remember all the locations they have

2363
01:56:34,710 --> 01:56:39,809
fabs now until does but they'll go they

2364
01:56:38,550 --> 01:56:40,920
they may have some in China I don't even

2365
01:56:39,809 --> 01:56:42,779
really know where they all are but point

2366
01:56:40,920 --> 01:56:44,340
being they they've got their own fabs

2367
01:56:42,779 --> 01:56:48,448
owned by Intel operated by Intel

2368
01:56:44,340 --> 01:56:50,670
employees right they will make the chip

2369
01:56:48,448 --> 01:56:53,578
they're tsmc is an example of a

2370
01:56:50,670 --> 01:56:56,038
contractual fab you send them the chip

2371
01:56:53,578 --> 01:56:57,719
to fab they send you back the silicon

2372
01:56:56,038 --> 01:57:01,050
right so they're making the chips

2373
01:56:57,719 --> 01:57:02,939
they're on your design so what that

2374
01:57:01,050 --> 01:57:05,038
means is any of you out there anyone

2375
01:57:02,939 --> 01:57:06,808
listening to the stream you could fab

2376
01:57:05,038 --> 01:57:09,238
your own chip that's as good as a

2377
01:57:06,809 --> 01:57:10,769
zambese chip right now

2378
01:57:09,238 --> 01:57:13,259
TSM see it's probably not I'm gonna take

2379
01:57:10,769 --> 01:57:15,119
your order for one chip no one's gonna

2380
01:57:13,260 --> 01:57:16,500
want that right they want you to place

2381
01:57:15,118 --> 01:57:19,049
an order for a million chips or

2382
01:57:16,500 --> 01:57:22,109
something right but if you could find a

2383
01:57:19,050 --> 01:57:24,690
way if you ran a Kickstarter and you had

2384
01:57:22,109 --> 01:57:26,409
your own chip design TSMC will found

2385
01:57:24,689 --> 01:57:29,710
that chip for you and they'll

2386
01:57:26,409 --> 01:57:32,019
the best stuff they've got right so so

2387
01:57:29,710 --> 01:57:35,920
unlike Intel who couldn't care less

2388
01:57:32,020 --> 01:57:39,370
about your chip design tsmc is an a

2389
01:57:35,920 --> 01:57:40,750
place that is literally there to handle

2390
01:57:39,369 --> 01:57:42,369
chip times to and back comes a chip it's

2391
01:57:40,750 --> 01:57:43,689
great anyone can do it anyone can get

2392
01:57:42,369 --> 01:57:45,130
into the chip business if you want and

2393
01:57:43,689 --> 01:57:46,539
have access to some of the best fabs in

2394
01:57:45,130 --> 01:57:47,980
the world the Taiwanese are very good at

2395
01:57:46,539 --> 01:57:51,039
making chips TSMC is an excellent

2396
01:57:47,979 --> 01:57:53,819
foundry right it used to be that Intel

2397
01:57:51,039 --> 01:57:58,210
was way ahead they're not anymore

2398
01:57:53,819 --> 01:58:01,719
it's a bit of a it's a bit of a race now

2399
01:57:58,210 --> 01:58:05,529
but but you know Intel used to be way

2400
01:58:01,720 --> 01:58:07,150
ahead but now it's not as bad largely

2401
01:58:05,529 --> 01:58:09,340
because Intel's moved to ten nanometer

2402
01:58:07,149 --> 01:58:11,739
was what they call ten nanometer which

2403
01:58:09,340 --> 01:58:13,480
is basically actually the same size more

2404
01:58:11,739 --> 01:58:18,869
or less as TSM see seven nanometers so

2405
01:58:13,479 --> 01:58:18,869
they're not the names are confusing but

2406
01:58:19,470 --> 01:58:23,619
okay so first of all there is a company

2407
01:58:21,939 --> 01:58:26,019
somewhere maybe it's in tell me miss TSM

2408
01:58:23,619 --> 01:58:29,619
see there's also a company called global

2409
01:58:26,020 --> 01:58:31,210
I think that does this there's a bunch

2410
01:58:29,619 --> 01:58:33,609
of places in the world and what they do

2411
01:58:31,210 --> 01:58:36,880
is they actually make the chip they

2412
01:58:33,609 --> 01:58:39,849
actually make a physical thing that is

2413
01:58:36,880 --> 01:58:42,789
the chip and how do they do this well

2414
01:58:39,850 --> 01:58:44,500
they take a ridiculous absolutely absurd

2415
01:58:42,789 --> 01:58:47,619
thing I think it's called a silicon

2416
01:58:44,500 --> 01:58:49,319
ingot but it might not be called that

2417
01:58:47,619 --> 01:58:51,880
[Music]

2418
01:58:49,319 --> 01:58:56,769
let me see if I can find a picture one

2419
01:58:51,880 --> 01:58:58,840
of these things there it is they take

2420
01:58:56,770 --> 01:59:01,150
something that looks like that and I'm

2421
01:58:58,840 --> 01:59:04,510
not kidding it's actually like this

2422
01:59:01,149 --> 01:59:07,210
incredibly freaky looking it looks like

2423
01:59:04,510 --> 01:59:09,280
somebody did like a rendering it looks

2424
01:59:07,210 --> 01:59:11,380
like when they first introduced

2425
01:59:09,279 --> 01:59:13,479
reflection mapping into video games it

2426
01:59:11,380 --> 01:59:14,710
looks like that that is what it looks

2427
01:59:13,479 --> 01:59:18,759
like it's bizarre

2428
01:59:14,710 --> 01:59:22,439
right and what this is is an incredibly

2429
01:59:18,760 --> 01:59:26,260
incredibly incredibly pure piece of

2430
01:59:22,439 --> 01:59:30,009
silicon I have absolutely no idea how

2431
01:59:26,260 --> 01:59:33,539
they are made I don't know if anyone

2432
01:59:30,010 --> 01:59:33,539
knows how they're made

2433
01:59:39,850 --> 01:59:44,949
and I'm not really making that up like

2434
01:59:42,340 --> 01:59:50,710
there's some kind of crazy process

2435
01:59:44,948 --> 01:59:52,689
that's like they take this sand they

2436
01:59:50,710 --> 01:59:56,170
mined from certain places and they make

2437
01:59:52,689 --> 01:59:59,948
them into these things and like you know

2438
01:59:56,170 --> 02:00:01,690
the basic idea is known but the places

2439
01:59:59,948 --> 02:00:03,609
don't tell you how they do it because

2440
02:00:01,689 --> 02:00:05,500
certain places get really really pure so

2441
02:00:03,609 --> 02:00:08,559
I don't know maybe everyone knows now

2442
02:00:05,500 --> 02:00:10,510
but there was a time I I want to say and

2443
02:00:08,560 --> 02:00:12,400
you know I almost want I wish Fabien was

2444
02:00:10,510 --> 02:00:14,409
here I'd ask him for backup on this cuz

2445
02:00:12,399 --> 02:00:17,670
he follows this stuff too and he follows

2446
02:00:14,408 --> 02:00:20,019
it probably more closely than I do but I

2447
02:00:17,670 --> 02:00:21,279
want to say at least for a time there

2448
02:00:20,020 --> 02:00:23,320
were some companies that made the

2449
02:00:21,279 --> 02:00:25,149
silicon ingots and like nobody there was

2450
02:00:23,319 --> 02:00:27,460
like - and like nobody knows how they

2451
02:00:25,149 --> 02:00:31,529
did it like it was just like these

2452
02:00:27,460 --> 02:00:34,060
places make this really pure silicon and

2453
02:00:31,529 --> 02:00:35,500
like nobody else can make it as pure

2454
02:00:34,060 --> 02:00:38,139
right it's just this weird like trade

2455
02:00:35,500 --> 02:00:39,279
secret thing so I may be way off base on

2456
02:00:38,139 --> 02:00:41,289
that but I want to say that was the case

2457
02:00:39,279 --> 02:00:44,229
it may not be the case anymore but point

2458
02:00:41,289 --> 02:00:47,979
being somebody makes these silicon

2459
02:00:44,229 --> 02:00:55,029
ingots and then these silicon ingots are

2460
02:00:47,979 --> 02:00:57,279
turned into wafers and what that is is

2461
02:00:55,029 --> 02:01:00,670
it's a thing where you basically slice

2462
02:00:57,279 --> 02:01:03,729
and I again don't know how that process

2463
02:01:00,670 --> 02:01:05,520
works but that's not so that that I

2464
02:01:03,729 --> 02:01:14,669
don't think process is so bizarre you

2465
02:01:05,520 --> 02:01:18,969
slice off a circular section right now I

2466
02:01:14,670 --> 02:01:20,920
don't know why it's not a square because

2467
02:01:18,969 --> 02:01:22,329
that would fit more chips on it but I

2468
02:01:20,920 --> 02:01:24,340
assume it has something to do with the

2469
02:01:22,329 --> 02:01:26,529
fact that maybe silicon crystals can't

2470
02:01:24,340 --> 02:01:29,289
be made in a square or maybe there's

2471
02:01:26,529 --> 02:01:30,670
some other reason you know I've never

2472
02:01:29,289 --> 02:01:31,899
really thought about that before but

2473
02:01:30,670 --> 02:01:34,210
that would be a good thing to go look up

2474
02:01:31,899 --> 02:01:36,689
I bet there's an answer somewhere as to

2475
02:01:34,210 --> 02:01:39,399
why they're circular but they always are

2476
02:01:36,689 --> 02:01:42,339
you always see it's a cert it's always

2477
02:01:39,399 --> 02:01:45,039
circular so it's not the shape is not

2478
02:01:42,340 --> 02:01:45,909
arbitrary its circular and so there's a

2479
02:01:45,039 --> 02:01:48,519
reason for that

2480
02:01:45,908 --> 02:01:49,368
nothing in the CPU fabrication world is

2481
02:01:48,520 --> 02:01:52,129
accidental

2482
02:01:49,368 --> 02:01:54,109
so trust me there's a reason I just

2483
02:01:52,128 --> 02:01:55,908
don't know what it is and it's either

2484
02:01:54,109 --> 02:01:57,228
that there's some reason the machine

2485
02:01:55,908 --> 02:01:59,598
needs it that way

2486
02:01:57,229 --> 02:02:01,579
or it's because they can't grow silicon

2487
02:01:59,599 --> 02:02:04,069
in any other way and so I just don't

2488
02:02:01,578 --> 02:02:06,648
know but it's obviously not great I

2489
02:02:04,069 --> 02:02:08,929
would think because you know all chips

2490
02:02:06,649 --> 02:02:12,139
are designed to fit inside a regular

2491
02:02:08,929 --> 02:02:17,300
square region for tiling and so I would

2492
02:02:12,139 --> 02:02:18,399
think you would want it to be I would

2493
02:02:17,300 --> 02:02:21,079
think that you'd want it to be

2494
02:02:18,399 --> 02:02:23,570
rectangular in the optimal case but it

2495
02:02:21,078 --> 02:02:24,918
ain't so there you go anyway so in order

2496
02:02:23,569 --> 02:02:26,929
to fab a chip you gotta have this

2497
02:02:24,918 --> 02:02:29,958
looking and get you slice that into a

2498
02:02:26,929 --> 02:02:33,800
silicon wafer and then we have to

2499
02:02:29,958 --> 02:02:35,809
actually manufacture something on the

2500
02:02:33,800 --> 02:02:38,479
silicon wafer right it doesn't help us

2501
02:02:35,809 --> 02:02:39,800
just have a silicon wafer we have to put

2502
02:02:38,479 --> 02:02:43,070
a chip on there somehow

2503
02:02:39,800 --> 02:02:48,829
right we have to get an actual chip to

2504
02:02:43,069 --> 02:02:50,628
form on this silicon wafer hmm now again

2505
02:02:48,828 --> 02:02:52,128
I'm not a hardware guy so take my

2506
02:02:50,628 --> 02:02:53,090
explanations with a grain of salt and if

2507
02:02:52,128 --> 02:02:54,439
you're really interested in this I

2508
02:02:53,090 --> 02:02:56,119
really encourage you to go read about it

2509
02:02:54,439 --> 02:02:58,099
there's tons of great stuff it's you you

2510
02:02:56,118 --> 02:02:59,359
can spend a whole day just reading about

2511
02:02:58,099 --> 02:03:01,788
this stuff that's really entertaining

2512
02:02:59,359 --> 02:03:02,839
even if you just are never gonna do

2513
02:03:01,788 --> 02:03:05,090
anything with it it's just a really

2514
02:03:02,840 --> 02:03:07,899
entertaining really educational thing to

2515
02:03:05,090 --> 02:03:10,159
go explore so I highly recommend it but

2516
02:03:07,899 --> 02:03:12,378
what are you gonna do you've got this

2517
02:03:10,158 --> 02:03:16,219
silicon and we're starting to talk about

2518
02:03:12,378 --> 02:03:18,229
things that are so so darn tiny so let's

2519
02:03:16,219 --> 02:03:20,269
go back to that thing seven nanometer

2520
02:03:18,229 --> 02:03:24,249
fab well what is that seven nanometer

2521
02:03:20,269 --> 02:03:26,899
part now right well seven nanometers is

2522
02:03:24,248 --> 02:03:31,010
some name they give to a particular

2523
02:03:26,899 --> 02:03:34,959
process where you can put things onto

2524
02:03:31,010 --> 02:03:37,309
the silicon where the smallest detail

2525
02:03:34,958 --> 02:03:39,708
measured somehow and we'll get to that

2526
02:03:37,309 --> 02:03:45,229
hand waving in a second measured somehow

2527
02:03:39,708 --> 02:03:47,748
is 7 nanometers across ok so you'll see

2528
02:03:45,229 --> 02:03:51,378
different claims Intel currently claims

2529
02:03:47,748 --> 02:03:54,828
to be on 14 plus plus I want to say

2530
02:03:51,378 --> 02:03:58,819
they're trying to go to 10 nanometer and

2531
02:03:54,828 --> 02:04:00,049
then 10 plus + 10 + + you you think I'm

2532
02:03:58,819 --> 02:04:02,869
making these up when I say these things

2533
02:04:00,050 --> 02:04:07,310
it's it's like C++ or something right

2534
02:04:02,869 --> 02:04:13,039
Intel fab roadmap I swear I am not

2535
02:04:07,310 --> 02:04:17,090
making this stuff up right right there

2536
02:04:13,039 --> 02:04:19,819
on 14 plus plus right now they want to

2537
02:04:17,090 --> 02:04:22,100
be they wanted to be on 10 so this is

2538
02:04:19,819 --> 02:04:24,460
what they wanted they wanted tend to be

2539
02:04:22,100 --> 02:04:27,770
here it got slid out to here where is it

2540
02:04:24,460 --> 02:04:29,390
this is what they wanted right they had

2541
02:04:27,770 --> 02:04:31,910
wanted to be on 10 nanometer what

2542
02:04:29,390 --> 02:04:35,270
they're calling 10 nanometer in 2017

2543
02:04:31,909 --> 02:04:38,479
they totally failed it was a disaster it

2544
02:04:35,270 --> 02:04:41,240
didn't work at all and so they had to

2545
02:04:38,479 --> 02:04:43,309
basically slip out and so this is what

2546
02:04:41,239 --> 02:04:47,659
they're trying to do now they're trying

2547
02:04:43,310 --> 02:04:49,130
to do 10 in 2019 10 plus next year 10

2548
02:04:47,659 --> 02:04:50,659
plus plus in 2021

2549
02:04:49,130 --> 02:04:53,270
at which point they're hoping 7

2550
02:04:50,659 --> 02:04:54,920
nanometers on scale 7 plus 7 plus plus

2551
02:04:53,270 --> 02:04:59,750
now you may look at this and say well if

2552
02:04:54,920 --> 02:05:01,340
TSM sees on 7 nanometre now in 2019 what

2553
02:04:59,750 --> 02:05:03,920
the hey they're not going in 70 animator

2554
02:05:01,340 --> 02:05:07,220
till 2021 aren't they way behind no the

2555
02:05:03,920 --> 02:05:10,010
reason is because what you pick for that

2556
02:05:07,220 --> 02:05:12,619
nanometer it could be anything

2557
02:05:10,010 --> 02:05:15,530
how big is one transistor how big is one

2558
02:05:12,619 --> 02:05:18,109
gap of one transistor how big is the

2559
02:05:15,529 --> 02:05:19,579
this the bat right if you're a chip guy

2560
02:05:18,109 --> 02:05:22,460
you know what all these things are I'm

2561
02:05:19,579 --> 02:05:24,800
not but the point is different people

2562
02:05:22,460 --> 02:05:27,369
measure in different ways and so it's

2563
02:05:24,800 --> 02:05:30,440
very much like any kind of tech

2564
02:05:27,369 --> 02:05:32,809
marketing speak it doesn't mean anything

2565
02:05:30,439 --> 02:05:35,000
it's just a label they put on a fab and

2566
02:05:32,810 --> 02:05:37,130
what you really care about most of the

2567
02:05:35,000 --> 02:05:40,550
time is something called transistor

2568
02:05:37,130 --> 02:05:44,150
density and now maybe that even that's a

2569
02:05:40,550 --> 02:05:46,820
little bit wrong but what you're really

2570
02:05:44,149 --> 02:05:49,789
talking about is how much can I fit in a

2571
02:05:46,819 --> 02:05:51,019
particular unit of space right and so if

2572
02:05:49,789 --> 02:05:54,019
you look at the transistor density

2573
02:05:51,020 --> 02:05:56,030
that's really a better measure of what

2574
02:05:54,020 --> 02:05:59,450
we've got here and you can kind of see

2575
02:05:56,029 --> 02:06:01,579
here's a graph for 1971 to 2011 you can

2576
02:05:59,449 --> 02:06:04,819
see how many transistors were packing in

2577
02:06:01,579 --> 02:06:07,970
there and you can see it's a pre linear

2578
02:06:04,819 --> 02:06:09,979
progression on a logarithmic scale right

2579
02:06:07,970 --> 02:06:14,119
so this scale is not linear you can see

2580
02:06:09,979 --> 02:06:16,399
it going up by tens not not linear at

2581
02:06:14,119 --> 02:06:20,269
all there right that's to that

2582
02:06:16,399 --> 02:06:21,710
out to there this should only be 190

2583
02:06:20,270 --> 02:06:23,719
right it said it's a million so you can

2584
02:06:21,710 --> 02:06:26,569
see it's a logarithmic scale so that's

2585
02:06:23,719 --> 02:06:27,590
that doubling that Moore's Law curve you

2586
02:06:26,569 --> 02:06:31,099
hear about so this is a logarithmic

2587
02:06:27,590 --> 02:06:32,869
scale so it goes up linearly and you can

2588
02:06:31,100 --> 02:06:35,120
see they just keep trying to pack more

2589
02:06:32,869 --> 02:06:37,099
transistors in there over and over and

2590
02:06:35,119 --> 02:06:39,109
over right so that's what you're really

2591
02:06:37,100 --> 02:06:41,120
looking at more is that transistor count

2592
02:06:39,109 --> 02:06:46,279
and so if we look at seven nanometer

2593
02:06:41,119 --> 02:06:52,760
transistor density versus Intel 10

2594
02:06:46,279 --> 02:06:57,399
nanometer transistor and so if we just

2595
02:06:52,760 --> 02:07:02,420
come by if we like kind of look at these

2596
02:06:57,399 --> 02:07:04,250
lithography processors I'm not sure

2597
02:07:02,420 --> 02:07:07,899
where a good place to look at the table

2598
02:07:04,250 --> 02:07:07,899
would be but

2599
02:07:18,639 --> 02:07:22,600
I feel like these tables if they weren't

2600
02:07:20,800 --> 02:07:24,190
quoted was exactly what I wanted but

2601
02:07:22,600 --> 02:07:26,369
unfortunately they're kind of all messed

2602
02:07:24,189 --> 02:07:26,368
up

2603
02:07:33,418 --> 02:07:38,880
so I guess I I'm sorry I just offhand

2604
02:07:35,880 --> 02:07:43,939
I'm not sure exactly where to find the

2605
02:07:38,880 --> 02:07:43,939
transistor densities of the various fabs

2606
02:07:58,920 --> 02:08:03,690
yes so I mean here's Intel's marketing

2607
02:08:01,800 --> 02:08:06,029
gunk anyway right

2608
02:08:03,689 --> 02:08:11,669
I mean go find the transistor densities

2609
02:08:06,029 --> 02:08:14,550
but the point is those labels are

2610
02:08:11,670 --> 02:08:16,649
meaningless labels so you have to go

2611
02:08:14,550 --> 02:08:18,840
look up something else to find out what

2612
02:08:16,649 --> 02:08:21,479
really is going on there and transistor

2613
02:08:18,840 --> 02:08:23,850
density is a good way to do it so that's

2614
02:08:21,479 --> 02:08:27,209
one metric you can kind of use to

2615
02:08:23,850 --> 02:08:31,490
equalize across what is TM SMC versus

2616
02:08:27,210 --> 02:08:34,230
Intel versus whatever right but anyway

2617
02:08:31,489 --> 02:08:36,420
we're going bring it back around when

2618
02:08:34,229 --> 02:08:38,639
we're talking about actually fabricating

2619
02:08:36,420 --> 02:08:42,090
one of these chips what we're talking

2620
02:08:38,640 --> 02:08:44,850
about is we have a particular process

2621
02:08:42,090 --> 02:08:47,850
and that process is a series of machines

2622
02:08:44,850 --> 02:08:50,820
and steps that we go through in order to

2623
02:08:47,850 --> 02:08:54,150
produce a image of a trace you know a

2624
02:08:50,819 --> 02:08:57,840
series of lines on the silicon features

2625
02:08:54,149 --> 02:08:59,819
on the silicon that will then be able to

2626
02:08:57,840 --> 02:09:02,640
have electricity flow through it to do

2627
02:08:59,819 --> 02:09:05,489
the thing we want it produces the actual

2628
02:09:02,640 --> 02:09:09,470
chip the integrated circuit on that

2629
02:09:05,489 --> 02:09:13,380
silicon and the smaller the feature size

2630
02:09:09,470 --> 02:09:15,869
that process can produce the more we can

2631
02:09:13,380 --> 02:09:18,420
pack into the same space the more we can

2632
02:09:15,869 --> 02:09:20,789
pack in the same space the less power is

2633
02:09:18,420 --> 02:09:22,380
consumed the faster it could run at the

2634
02:09:20,789 --> 02:09:24,269
same power because it has you know the

2635
02:09:22,380 --> 02:09:25,440
electrons have less distance to move

2636
02:09:24,270 --> 02:09:28,260
right or however you want to look at

2637
02:09:25,439 --> 02:09:30,029
that and so we're trying to shrink it

2638
02:09:28,260 --> 02:09:32,310
down because we get more performance or

2639
02:09:30,029 --> 02:09:33,899
more power savings every time we do and

2640
02:09:32,310 --> 02:09:35,880
so when we look at something like a 7

2641
02:09:33,899 --> 02:09:37,710
nanometer fab a 10 minute meter fab

2642
02:09:35,880 --> 02:09:39,690
whatever we're talking about what we're

2643
02:09:37,710 --> 02:09:42,359
talking about is a specific

2644
02:09:39,689 --> 02:09:45,079
configuration of machines that will take

2645
02:09:42,359 --> 02:09:48,149
a silicon ingot into a silicon wafer

2646
02:09:45,079 --> 02:09:49,710
into a machine put the stuff on it that

2647
02:09:48,149 --> 02:09:55,799
needs to get put on it and kick it out

2648
02:09:49,710 --> 02:09:58,319
and then that thing on that wafer is the

2649
02:09:55,800 --> 02:10:02,789
chip we use now those wafers are huge

2650
02:09:58,319 --> 02:10:06,299
you saw them in there you know they're

2651
02:10:02,789 --> 02:10:08,909
like that big so eating one chip per

2652
02:10:06,300 --> 02:10:11,529
wafer it's lots of little chips and then

2653
02:10:08,909 --> 02:10:15,139
we cut them out right

2654
02:10:11,529 --> 02:10:17,059
so what happens is the fab silicon ingot

2655
02:10:15,140 --> 02:10:18,470
comes in we chop it into wafers the

2656
02:10:17,060 --> 02:10:21,440
wafers go into our machines the machines

2657
02:10:18,470 --> 02:10:23,030
image the chip chips on there we take

2658
02:10:21,439 --> 02:10:24,979
the wafer out it's got tons of chip we

2659
02:10:23,029 --> 02:10:26,800
cut up the chips and now we have the

2660
02:10:24,979 --> 02:10:29,949
chips and we sell them to you right no

2661
02:10:26,800 --> 02:10:31,640
problem is some of the chips won't work

2662
02:10:29,949 --> 02:10:35,809
these won't work

2663
02:10:31,640 --> 02:10:37,850
why won't they work well let's talk

2664
02:10:35,810 --> 02:10:43,789
about the actual fab process and why

2665
02:10:37,850 --> 02:10:46,700
stuff doesn't work okay so in order to

2666
02:10:43,789 --> 02:10:48,229
fabricate a chip when you're talking

2667
02:10:46,699 --> 02:10:58,239
about something like seven nanometers as

2668
02:10:48,229 --> 02:10:58,239
a feature size let's see here

2669
02:11:07,140 --> 02:11:33,400
can let's do this for me okay 2.82

2670
02:11:31,569 --> 02:11:35,469
I think does that do that right meters

2671
02:11:33,399 --> 02:11:39,339
is too greater than a six ten to the six

2672
02:11:35,470 --> 02:11:42,820
nanometers okay good so we are talking

2673
02:11:39,340 --> 02:11:44,170
about something in this case I guess

2674
02:11:42,819 --> 02:11:45,849
obvious meaning I kind of wanted it to

2675
02:11:44,170 --> 02:11:47,829
not do it in scientific notation I was

2676
02:11:45,850 --> 02:11:53,560
hoping for but ten to the negative six

2677
02:11:47,829 --> 02:11:55,930
so let's see here so that is one two

2678
02:11:53,560 --> 02:11:57,820
three four five six they do that right

2679
02:11:55,930 --> 02:12:01,810
we're looking at something that's about

2680
02:11:57,819 --> 02:12:04,710
that big right an electron a single

2681
02:12:01,810 --> 02:12:11,850
electron is about that big right

2682
02:12:04,710 --> 02:12:14,829
wavelength of Tron so here we go mm-hmm

2683
02:12:11,850 --> 02:12:16,930
again not my strong suit so those of you

2684
02:12:14,829 --> 02:12:19,000
who are physicists I don't know if

2685
02:12:16,930 --> 02:12:20,380
around the stream right now I may be

2686
02:12:19,000 --> 02:12:22,210
doing this kind of wrong and I apologize

2687
02:12:20,380 --> 02:12:23,800
so I encourage you to look at this all

2688
02:12:22,210 --> 02:12:25,060
yourself I'm not a hardware person I'm

2689
02:12:23,800 --> 02:12:26,829
not capable of explaining this stuff

2690
02:12:25,060 --> 02:12:29,740
correctly so take a look and salt but

2691
02:12:26,829 --> 02:12:33,819
the wavelength of an electron right this

2692
02:12:29,739 --> 02:12:38,500
is how big it is right this is the

2693
02:12:33,819 --> 02:12:40,779
wavelength okay now what you'll notice

2694
02:12:38,500 --> 02:12:45,069
that's so that's its oscillation right

2695
02:12:40,779 --> 02:12:48,579
the region an electron oscillates in one

2696
02:12:45,069 --> 02:12:50,739
point two three nanometers we're talking

2697
02:12:48,579 --> 02:12:56,170
about fabricating features that are only

2698
02:12:50,739 --> 02:13:00,250
about five times larger than the actual

2699
02:12:56,170 --> 02:13:03,940
movement of an electron that's how small

2700
02:13:00,250 --> 02:13:06,970
this crap is right very very very very

2701
02:13:03,939 --> 02:13:11,469
very very very small is what we're

2702
02:13:06,970 --> 02:13:16,140
targeting here right so what does this

2703
02:13:11,470 --> 02:13:18,880
mean it means that literally anything

2704
02:13:16,140 --> 02:13:22,780
that goes wrong

2705
02:13:18,880 --> 02:13:27,609
anything will ruin the chip a single

2706
02:13:22,779 --> 02:13:32,259
tiny little speck of dust will ruin the

2707
02:13:27,609 --> 02:13:36,069
chip a vibration at all will ruin the

2708
02:13:32,260 --> 02:13:40,329
chip anything that happens during the

2709
02:13:36,069 --> 02:13:45,099
imaging of that chip that the tiniest

2710
02:13:40,329 --> 02:13:51,760
little blip and it will be completely

2711
02:13:45,100 --> 02:13:54,460
ruined I'm not sure what the best way to

2712
02:13:51,760 --> 02:13:55,960
underscore this would be other than

2713
02:13:54,460 --> 02:13:58,510
saying a speck of dust will ruin the

2714
02:13:55,960 --> 02:14:00,189
chip that's a good example that's why

2715
02:13:58,510 --> 02:14:11,260
they all where you see they when they

2716
02:14:00,189 --> 02:14:14,199
into fabs this is what everyone looks

2717
02:14:11,260 --> 02:14:18,010
like because any piece of skin that

2718
02:14:14,199 --> 02:14:19,929
flaked off dandruff a piece of lint from

2719
02:14:18,010 --> 02:14:25,030
your clothing that will ruin the entire

2720
02:14:19,930 --> 02:14:27,430
batch right and so everyone is basically

2721
02:14:25,029 --> 02:14:31,500
asked to wear you know what's it's not a

2722
02:14:27,430 --> 02:14:35,289
hazmat suit but it's not far right and

2723
02:14:31,500 --> 02:14:37,920
so it's so sensitive another way to look

2724
02:14:35,289 --> 02:14:37,920
at it would be

2725
02:14:44,130 --> 02:14:50,670
if anything happens right this is a

2726
02:14:47,850 --> 02:14:55,579
point zero second point zero seven

2727
02:14:50,670 --> 02:14:59,489
second power outage anything an entire

2728
02:14:55,579 --> 02:15:00,779
like months of chip output because they

2729
02:14:59,489 --> 02:15:04,939
go through these like stages of

2730
02:15:00,779 --> 02:15:11,819
production can be ruined it's so precise

2731
02:15:04,939 --> 02:15:14,039
it's so precise okay and so again that

2732
02:15:11,819 --> 02:15:15,750
it's just so important to understand so

2733
02:15:14,039 --> 02:15:17,519
let me just walk you through we were

2734
02:15:15,750 --> 02:15:20,939
talking about this extreme ultra ultra

2735
02:15:17,520 --> 02:15:22,920
violet ography so how do we actually

2736
02:15:20,939 --> 02:15:24,449
start putting things on to the silicon

2737
02:15:22,920 --> 02:15:30,329
or creating features on the silicon

2738
02:15:24,449 --> 02:15:32,309
right well what what they have to do one

2739
02:15:30,329 --> 02:15:33,659
way we could do it right yes they use

2740
02:15:32,310 --> 02:15:36,170
what's basically like an electron

2741
02:15:33,659 --> 02:15:40,349
microscope kind of right we could shoot

2742
02:15:36,170 --> 02:15:42,930
focused electrons in a beam and we could

2743
02:15:40,350 --> 02:15:46,020
literally like X out the entire chip

2744
02:15:42,930 --> 02:15:48,150
like right like almost like a television

2745
02:15:46,020 --> 02:15:49,680
used to do with the scanning CRT we

2746
02:15:48,149 --> 02:15:52,739
could like literally carve into the

2747
02:15:49,680 --> 02:15:54,030
thing like with a literally just you

2748
02:15:52,739 --> 02:15:58,139
know it's thinking like a laser cutting

2749
02:15:54,029 --> 02:16:01,319
things right we could do that and that

2750
02:15:58,140 --> 02:16:05,960
would probably be like the most precise

2751
02:16:01,319 --> 02:16:08,429
we could get right and the problem is

2752
02:16:05,960 --> 02:16:10,560
this would take forever if you were

2753
02:16:08,430 --> 02:16:12,750
literally carving every little thing was

2754
02:16:10,560 --> 02:16:14,190
like electron forget it right that would

2755
02:16:12,750 --> 02:16:16,619
just take forever

2756
02:16:14,189 --> 02:16:19,649
each chip would take so long to make

2757
02:16:16,619 --> 02:16:22,710
that they would cost tens of thousands

2758
02:16:19,649 --> 02:16:25,710
of dollars for like one chip right like

2759
02:16:22,710 --> 02:16:28,079
the cost of today's most expensive CPUs

2760
02:16:25,710 --> 02:16:29,699
would be the cost would be how much the

2761
02:16:28,079 --> 02:16:31,350
least expensive CPUs would cost if we

2762
02:16:29,699 --> 02:16:34,559
were making them that way it just takes

2763
02:16:31,350 --> 02:16:37,200
too long so what we need is something

2764
02:16:34,559 --> 02:16:38,968
that can image a chip quickly it's got

2765
02:16:37,200 --> 02:16:43,679
to be able to carve way more than just

2766
02:16:38,968 --> 02:16:46,138
generating like a single little like a

2767
02:16:43,679 --> 02:16:48,388
single little point all the time right

2768
02:16:46,138 --> 02:16:50,039
and so what we're looking at doing is

2769
02:16:48,388 --> 02:16:54,449
we're trying to create something that

2770
02:16:50,040 --> 02:16:57,350
can do a lot of you know fire a lot of

2771
02:16:54,450 --> 02:16:59,990
carving at one chip at the same time

2772
02:16:57,350 --> 02:17:02,809
kind of more like the way that you would

2773
02:16:59,989 --> 02:17:05,180
imagine silk-screening a t-shirt or

2774
02:17:02,809 --> 02:17:10,219
something so you end up with something

2775
02:17:05,180 --> 02:17:12,710
that's called like a mask and the mask

2776
02:17:10,219 --> 02:17:15,079
is something that's designed to have a

2777
02:17:12,709 --> 02:17:18,379
whole bunch of stuff on it that we can

2778
02:17:15,079 --> 02:17:20,780
shine something through and carve a

2779
02:17:18,379 --> 02:17:22,969
bunch of the chip at one time so it's a

2780
02:17:20,780 --> 02:17:25,400
speech really is a speed issue if you

2781
02:17:22,969 --> 02:17:28,699
went to a hardware guy today and say I

2782
02:17:25,399 --> 02:17:31,550
want to pay you a billion dollars and I

2783
02:17:28,700 --> 02:17:33,680
want you to fab at like five nanometer

2784
02:17:31,550 --> 02:17:34,309
for me they could probably just say sure

2785
02:17:33,680 --> 02:17:36,020
no problem

2786
02:17:34,309 --> 02:17:37,609
I can I can make one chip at five

2787
02:17:36,020 --> 02:17:38,690
nanometers out it's a no problem we've

2788
02:17:37,610 --> 02:17:43,190
been able do that forever

2789
02:17:38,690 --> 02:17:45,710
right but it would take a huge amount of

2790
02:17:43,190 --> 02:17:47,390
time and energy and expense to do it

2791
02:17:45,709 --> 02:17:48,679
because they'd have to do it in like one

2792
02:17:47,389 --> 02:17:51,229
of these ways that would you know be

2793
02:17:48,680 --> 02:17:53,780
very slow in carving so fab technology

2794
02:17:51,229 --> 02:17:55,699
is not just about can we make something

2795
02:17:53,780 --> 02:17:57,980
that small the answer is of course we

2796
02:17:55,700 --> 02:18:01,100
can we are good enough to do that now

2797
02:17:57,979 --> 02:18:04,670
the problem is it's too friggin slow

2798
02:18:01,100 --> 02:18:06,620
right okay so what is extreme

2799
02:18:04,670 --> 02:18:09,800
ultraviolet lithography well extreme

2800
02:18:06,620 --> 02:18:15,110
ultraviolet lithography is trying to

2801
02:18:09,800 --> 02:18:17,719
make wavelengths of light that are very

2802
02:18:15,110 --> 02:18:19,190
narrow right so we want the again

2803
02:18:17,719 --> 02:18:20,840
because the wavelength of the light is

2804
02:18:19,190 --> 02:18:23,390
going to determine what kind of feature

2805
02:18:20,840 --> 02:18:25,880
it can cut if it's wildly oscillating

2806
02:18:23,389 --> 02:18:28,340
hugely that's gonna be only be able to

2807
02:18:25,879 --> 02:18:29,839
cut fairly large features if it's nice

2808
02:18:28,340 --> 02:18:32,780
if it's more narrowly oscillating can

2809
02:18:29,840 --> 02:18:34,460
cut much more narrow features right so

2810
02:18:32,780 --> 02:18:39,051
we're trying to do is let's generate

2811
02:18:34,459 --> 02:18:41,779
some light with extremely short period

2812
02:18:39,050 --> 02:18:43,939
wavelengths coming narrow and we'll

2813
02:18:41,780 --> 02:18:47,329
shine that through a mask and cut the

2814
02:18:43,940 --> 02:18:48,920
chip that way right so what's extreme

2815
02:18:47,329 --> 02:18:54,590
ultraviolet lithography well as you

2816
02:18:48,920 --> 02:18:58,489
might expect if we look at the spectrum

2817
02:18:54,590 --> 02:19:00,950
of light here's an example the light

2818
02:18:58,489 --> 02:19:03,559
that we can see is within a spectrum

2819
02:19:00,950 --> 02:19:07,190
that goes from high energy to low energy

2820
02:19:03,559 --> 02:19:09,800
low energy spectra anything down in the

2821
02:19:07,190 --> 02:19:10,550
Reds we see into infrared and all this

2822
02:19:09,800 --> 02:19:13,549
stuff

2823
02:19:10,549 --> 02:19:18,739
Aref mtv shortwave am right this stuff

2824
02:19:13,549 --> 02:19:20,779
here that stuff is wide you wouldn't

2825
02:19:18,739 --> 02:19:26,478
want to cut a chip with radar because

2826
02:19:20,780 --> 02:19:30,679
the beams are huge right but the other

2827
02:19:26,478 --> 02:19:32,510
side the purples where we stop seeing

2828
02:19:30,679 --> 02:19:37,179
purple and can't see it at all and it

2829
02:19:32,510 --> 02:19:40,579
goes up into ultraviolet UV light is

2830
02:19:37,179 --> 02:19:41,719
perfect for cutting it gets smaller and

2831
02:19:40,579 --> 02:19:42,620
smaller and smaller and smaller and

2832
02:19:41,718 --> 02:19:44,750
smaller and smaller

2833
02:19:42,620 --> 02:19:48,170
really really tiny right up till you get

2834
02:19:44,750 --> 02:19:50,478
to x-rays now I assume and I couldn't

2835
02:19:48,170 --> 02:19:52,309
tell you I just assume that the reason

2836
02:19:50,478 --> 02:19:54,799
we don't cut chips with x-rays is

2837
02:19:52,309 --> 02:19:57,409
because x-rays pass right through stuff

2838
02:19:54,799 --> 02:19:59,449
so you can't cut a piece of silicon with

2839
02:19:57,409 --> 02:20:01,789
an x-ray probably because you don't know

2840
02:19:59,450 --> 02:20:02,120
if the x-ray will even hit it that's my

2841
02:20:01,790 --> 02:20:05,270
desk

2842
02:20:02,120 --> 02:20:07,460
I don't know that could be complete load

2843
02:20:05,270 --> 02:20:09,620
of horse poop and I apologize but I'm

2844
02:20:07,459 --> 02:20:10,818
guessing that's walk but I don't know it

2845
02:20:09,620 --> 02:20:12,350
might just be that we haven't quite got

2846
02:20:10,818 --> 02:20:14,750
it right yet and pretty soon maybe in

2847
02:20:12,350 --> 02:20:17,059
ten years we will be favics with x-rays

2848
02:20:14,750 --> 02:20:18,200
but I don't know there must be a reason

2849
02:20:17,059 --> 02:20:19,818
we're not doing it because obviously we

2850
02:20:18,200 --> 02:20:21,350
know how to make second x-rays but we

2851
02:20:19,818 --> 02:20:23,148
ain't using enough lab chips so there's

2852
02:20:21,350 --> 02:20:26,780
no reason for it but what we are doing

2853
02:20:23,148 --> 02:20:30,049
is we're trying to get right up to there

2854
02:20:26,780 --> 02:20:32,649
so extreme ultraviolet is like trying to

2855
02:20:30,049 --> 02:20:37,129
fab a chip with a wavelength of light

2856
02:20:32,648 --> 02:20:39,889
that is almost an x-ray like it really

2857
02:20:37,129 --> 02:20:42,949
it's almost an x-ray but it's just

2858
02:20:39,889 --> 02:20:45,170
barely not why that's the smallest

2859
02:20:42,950 --> 02:20:48,020
wavelength we could use that isn't an

2860
02:20:45,170 --> 02:20:50,840
x-ray right and then we're gonna use

2861
02:20:48,020 --> 02:20:55,359
that to image our chip well isn't that

2862
02:20:50,840 --> 02:20:55,359
great here's the problem how do you make

2863
02:20:55,540 --> 02:21:04,729
light that high of a wavelength

2864
02:20:59,959 --> 02:21:06,919
how do we get some of that right well I

2865
02:21:04,728 --> 02:21:11,148
don't want to pretend to be a physics

2866
02:21:06,920 --> 02:21:14,870
guy so I can't really tell you how the

2867
02:21:11,148 --> 02:21:18,978
best ways are to make light that's in

2868
02:21:14,870 --> 02:21:22,040
that spectrum you know I got no idea I

2869
02:21:18,978 --> 02:21:24,170
just don't even have the faintest idea

2870
02:21:22,040 --> 02:21:26,930
of the sort of stuff that goes into this

2871
02:21:24,170 --> 02:21:28,460
but here's what I can tell you in the

2872
02:21:26,930 --> 02:21:30,670
fabs that are trying to do extreme

2873
02:21:28,459 --> 02:21:34,818
ultraviolet lithography right now

2874
02:21:30,670 --> 02:21:39,559
they're literally doing something like

2875
02:21:34,818 --> 02:21:45,398
this they have a laser in the bottom of

2876
02:21:39,559 --> 02:21:50,840
their fab that they amplify to

2877
02:21:45,398 --> 02:21:55,278
psychotically high-power just big old

2878
02:21:50,840 --> 02:21:57,408
laser it generates a beam of light it

2879
02:21:55,279 --> 02:22:00,620
goes through amplification stages to

2880
02:21:57,408 --> 02:22:03,590
make it extremely extremely powerful if

2881
02:22:00,620 --> 02:22:07,159
that gets routed up into the fab the

2882
02:22:03,590 --> 02:22:10,850
actual fab floor where they have a

2883
02:22:07,158 --> 02:22:12,439
precisely timed aperture for this laser

2884
02:22:10,850 --> 02:22:14,540
I shouldn't call it an aperture don't

2885
02:22:12,439 --> 02:22:18,738
know that's what it is but timing system

2886
02:22:14,540 --> 02:22:21,560
I should say where the laser is designed

2887
02:22:18,738 --> 02:22:23,329
to DoubleTap and I mean this literally

2888
02:22:21,559 --> 02:22:26,448
like the way you kill a zombie like

2889
02:22:23,329 --> 02:22:29,959
DoubleTap like shooting twice at little

2890
02:22:26,449 --> 02:22:32,270
tiny droplets of tin that fall down into

2891
02:22:29,959 --> 02:22:35,719
a chamber and the laser hits the tin

2892
02:22:32,270 --> 02:22:39,260
twice one time flattens the tin and the

2893
02:22:35,719 --> 02:22:45,019
next shatters the tin out into a cloud

2894
02:22:39,260 --> 02:22:46,609
of tin little tiny teen atoms I wish I

2895
02:22:45,020 --> 02:22:48,170
was making this up but I think I'm

2896
02:22:46,609 --> 02:22:49,460
actually describing this correctly ask a

2897
02:22:48,170 --> 02:22:53,930
fab guy but I'm pretty sure I'm getting

2898
02:22:49,459 --> 02:22:58,039
this roughly right when the tin is

2899
02:22:53,930 --> 02:23:00,818
destroyed in this way that laser hits

2900
02:22:58,040 --> 02:23:03,500
tin and destroys it happens to produce

2901
02:23:00,818 --> 02:23:05,658
extreme ultraviolet wavelength light but

2902
02:23:03,500 --> 02:23:08,350
it produce it in all directions so then

2903
02:23:05,658 --> 02:23:11,539
there's this big parabolic collector

2904
02:23:08,350 --> 02:23:16,430
that tries to take all of that light and

2905
02:23:11,540 --> 02:23:20,810
focus it back into the fab machine it's

2906
02:23:16,430 --> 02:23:22,639
actually gonna use it okay focus it back

2907
02:23:20,809 --> 02:23:24,978
into the fab machine and now the fabrics

2908
02:23:22,639 --> 02:23:29,478
you got to control it what's the problem

2909
02:23:24,978 --> 02:23:35,478
well here's the thing there's really no

2910
02:23:29,478 --> 02:23:37,970
way to reflect extreme ultraviolet light

2911
02:23:35,478 --> 02:23:40,779
really it's too small it'll just

2912
02:23:37,970 --> 02:23:43,640
get absorbed in almost anything so

2913
02:23:40,780 --> 02:23:46,761
actually they have to build these really

2914
02:23:43,640 --> 02:23:49,449
special mirrors I can't remember what

2915
02:23:46,761 --> 02:23:49,450
they're called

2916
02:24:04,549 --> 02:24:07,689
[Music]

2917
02:24:09,239 --> 02:24:13,219
I'm sorry I just can't remember the name

2918
02:24:21,110 --> 02:24:25,790
[Music]

2919
02:24:27,390 --> 02:24:30,959
save and find it

2920
02:24:47,690 --> 02:24:51,530
so I'm sorry I can't remember how you

2921
02:24:50,000 --> 02:24:54,290
build these mirrors but they're called

2922
02:24:51,530 --> 02:24:58,010
something like a Murphy mirror or they

2923
02:24:54,290 --> 02:24:59,750
have this weird name that you have to

2924
02:24:58,010 --> 02:25:01,579
use there's a couple different kinds I

2925
02:24:59,750 --> 02:25:03,979
think you can use and they use a

2926
02:25:01,579 --> 02:25:07,200
particular one

2927
02:25:03,979 --> 02:25:07,199
[Music]

2928
02:25:27,209 --> 02:25:33,550
so yeah I'm sorry I guess I can't

2929
02:25:30,488 --> 02:25:35,129
remember the name of it but anyway point

2930
02:25:33,549 --> 02:25:40,328
being you have to construct these things

2931
02:25:35,129 --> 02:25:42,278
incredibly carefully and just to

2932
02:25:40,328 --> 02:25:44,189
underscore how ridiculous the wavelength

2933
02:25:42,279 --> 02:25:47,560
of light is that they're working with

2934
02:25:44,189 --> 02:25:50,340
normally in a lithography machine you

2935
02:25:47,559 --> 02:25:53,049
use a combinate

2936
02:25:50,340 --> 02:25:56,168
you don't have to use mirrors for

2937
02:25:53,049 --> 02:25:59,019
everything you can use lenses so you can

2938
02:25:56,168 --> 02:26:01,078
use things that like refract light and

2939
02:25:59,020 --> 02:26:04,779
focus it in different ways

2940
02:26:01,078 --> 02:26:08,379
apparently UV light is so the wavelength

2941
02:26:04,779 --> 02:26:10,619
is so high that actually you cannot they

2942
02:26:08,379 --> 02:26:14,948
don't know how to build a lens that will

2943
02:26:10,619 --> 02:26:16,869
work with it so you can actually when I

2944
02:26:14,949 --> 02:26:20,430
say they use a mirrors they actually can

2945
02:26:16,869 --> 02:26:26,109
only use mirrors apparently you cannot

2946
02:26:20,430 --> 02:26:27,609
use a lens so anyway shatters the Tim

2947
02:26:26,109 --> 02:26:29,289
produces the UV light they have

2948
02:26:27,609 --> 02:26:32,078
specially purpose mirrors that will

2949
02:26:29,289 --> 02:26:34,659
focus it and then the mirrors try to

2950
02:26:32,078 --> 02:26:36,100
bounce the light into the pattern that

2951
02:26:34,658 --> 02:26:38,228
will then flow through a specially

2952
02:26:36,100 --> 02:26:42,699
created mask onto the silicon to

2953
02:26:38,228 --> 02:26:46,510
actually image the chip right now keep

2954
02:26:42,699 --> 02:26:49,658
in mind this is just one pass all of

2955
02:26:46,510 --> 02:26:52,898
that has to happen just for one imaging

2956
02:26:49,658 --> 02:26:55,299
pass on the silicon typically you

2957
02:26:52,898 --> 02:26:57,969
actually end up having to do multiple

2958
02:26:55,299 --> 02:26:59,948
passes onto each piece of silicon to lay

2959
02:26:57,969 --> 02:27:02,049
down different features and their

2960
02:26:59,949 --> 02:27:04,720
reasons for that are will blow your mind

2961
02:27:02,049 --> 02:27:07,389
even more it's because when you're

2962
02:27:04,719 --> 02:27:09,458
shooting things at it obviously because

2963
02:27:07,389 --> 02:27:10,748
you're the light is not coming straight

2964
02:27:09,459 --> 02:27:13,149
down it's coming down at different

2965
02:27:10,748 --> 02:27:16,029
angles the pits and values form

2966
02:27:13,148 --> 02:27:18,578
shadowing regions and so you have to

2967
02:27:16,029 --> 02:27:21,279
like put different parts in different

2968
02:27:18,578 --> 02:27:22,958
times and to try and make sure you can

2969
02:27:21,279 --> 02:27:24,340
create the features of the right shape

2970
02:27:22,959 --> 02:27:27,539
without shadowing from where the light

2971
02:27:24,340 --> 02:27:30,039
comes in and all it's it's nuts I mean

2972
02:27:27,539 --> 02:27:31,209
again I really encourage you to read

2973
02:27:30,039 --> 02:27:33,729
about this stuff if you care about

2974
02:27:31,209 --> 02:27:35,050
computing it's so fascinating you you

2975
02:27:33,728 --> 02:27:38,408
will find it really interesting I

2976
02:27:35,049 --> 02:27:39,788
promise just go on a random tour of the

2977
02:27:38,408 --> 02:27:40,478
internet and see where it takes you on

2978
02:27:39,789 --> 02:27:42,310
that stuff and

2979
02:27:40,478 --> 02:27:46,929
you will really it's really fascinating

2980
02:27:42,309 --> 02:27:48,309
stuff okay so anyway how do we go down

2981
02:27:46,930 --> 02:27:51,818
this rattle and why did I want you to

2982
02:27:48,309 --> 02:27:53,408
understand just how hard it is well once

2983
02:27:51,818 --> 02:27:55,840
you get an appreciation for just how

2984
02:27:53,408 --> 02:27:57,728
crazy hard it is to fab these things

2985
02:27:55,840 --> 02:28:03,068
that are in your phone and in your

2986
02:27:57,728 --> 02:28:05,920
computer and everywhere else well you

2987
02:28:03,068 --> 02:28:07,840
start to understand just how easy it is

2988
02:28:05,920 --> 02:28:10,840
for something to go wrong so when you

2989
02:28:07,840 --> 02:28:13,840
take that wafer of chips they're not all

2990
02:28:10,840 --> 02:28:16,539
kind of work right you're deep you're

2991
02:28:13,840 --> 02:28:18,699
dealing with such precision engineering

2992
02:28:16,539 --> 02:28:22,149
like kind of which we cannot relate to

2993
02:28:18,699 --> 02:28:25,498
it all in the software world any little

2994
02:28:22,148 --> 02:28:28,059
tiny defect and that chip won't work

2995
02:28:25,498 --> 02:28:30,328
what that means is one of the biggest

2996
02:28:28,059 --> 02:28:32,978
things that a fab has to care about

2997
02:28:30,328 --> 02:28:35,038
after that first thing which is how fast

2998
02:28:32,978 --> 02:28:38,528
the chips can be made so that fab speed

2999
02:28:35,039 --> 02:28:41,859
is what's called the yield the yield is

3000
02:28:38,529 --> 02:28:44,350
one of the most important parts of fab

3001
02:28:41,859 --> 02:28:47,020
technology and it's like once we image

3002
02:28:44,350 --> 02:28:49,270
one of these wafers that has you know 50

3003
02:28:47,020 --> 02:28:52,090
chips on it how many of them will work

3004
02:28:49,270 --> 02:28:54,279
how many that will actually work and for

3005
02:28:52,090 --> 02:28:56,199
those that don't work can we fix them

3006
02:28:54,279 --> 02:28:58,449
right because sometimes you can go in

3007
02:28:56,199 --> 02:29:01,949
and correct a defect and then then it's

3008
02:28:58,449 --> 02:29:04,869
not a wasted chip so that yield is a

3009
02:29:01,949 --> 02:29:07,390
hugely important factor and that's a

3010
02:29:04,869 --> 02:29:17,640
percentage twenty five percent yield

3011
02:29:07,389 --> 02:29:20,948
right means one out of four chips work

3012
02:29:17,639 --> 02:29:23,189
right that's low we you would not want

3013
02:29:20,949 --> 02:29:29,890
to see a twenty five percent yield

3014
02:29:23,189 --> 02:29:33,970
alright so if you imagine the defects

3015
02:29:29,889 --> 02:29:36,969
are distributed on a chip right I want

3016
02:29:33,969 --> 02:29:40,688
to give you some perspective about what

3017
02:29:36,969 --> 02:29:44,920
happens when you change the surface area

3018
02:29:40,689 --> 02:29:53,161
of a particular chip right so let's

3019
02:29:44,920 --> 02:29:55,591
suppose that I found a wafer

3020
02:29:53,161 --> 02:29:59,101
I'm just make these numbers up let's

3021
02:29:55,591 --> 02:30:00,690
suppose that I have 50 chips well let's

3022
02:29:59,101 --> 02:30:01,740
do it 100 to make it easy on myself even

3023
02:30:00,690 --> 02:30:03,990
though that me I don't know if that's

3024
02:30:01,740 --> 02:30:12,149
the time out realistic number but let's

3025
02:30:03,990 --> 02:30:15,149
say I have 50 chips on a wafer okay so I

3026
02:30:12,149 --> 02:30:16,411
want to make these I'm sorry hundred

3027
02:30:15,149 --> 02:30:18,421
tips on a wafer I make these hundred

3028
02:30:16,411 --> 02:30:23,161
ships and I know that my yield rate

3029
02:30:18,421 --> 02:30:29,461
right is 75 percent right so out of a

3030
02:30:23,161 --> 02:30:39,331
hundred ships 25 will be defective and

3031
02:30:29,460 --> 02:30:42,001
75 will work right that's just what's

3032
02:30:39,331 --> 02:30:44,581
happening so off these roll from the

3033
02:30:42,001 --> 02:30:47,851
production line every time i image one

3034
02:30:44,581 --> 02:30:51,060
of my wafers i have 25 defective chips

3035
02:30:47,851 --> 02:30:55,591
and 75 working chips that's what i'm

3036
02:30:51,060 --> 02:30:58,671
gonna get right but now let's say i want

3037
02:30:55,591 --> 02:31:01,440
to ship a higher-end chip and that

3038
02:30:58,671 --> 02:31:05,791
higher-end chip is basically just the

3039
02:31:01,440 --> 02:31:09,181
same chip but it has more right so

3040
02:31:05,790 --> 02:31:11,790
previously i was taking up the space of

3041
02:31:09,181 --> 02:31:14,281
one of these chips but now what I want

3042
02:31:11,790 --> 02:31:18,060
is a chip that's actually two of these

3043
02:31:14,281 --> 02:31:19,711
chips together right so I'm doing a

3044
02:31:18,060 --> 02:31:22,020
bigger chip but it's gonna have more

3045
02:31:19,710 --> 02:31:24,149
cores so each of my chips before I had

3046
02:31:22,021 --> 02:31:27,271
eight cores now I'm gonna make it twice

3047
02:31:24,149 --> 02:31:29,011
as large let's go have 16 cores and I

3048
02:31:27,271 --> 02:31:30,570
can sell it for more money that's why

3049
02:31:29,011 --> 02:31:32,281
I'm doing my enterprise customers will

3050
02:31:30,570 --> 02:31:36,601
pay more than twice the cost for this

3051
02:31:32,281 --> 02:31:41,341
right well what happens now well now

3052
02:31:36,601 --> 02:31:43,980
I've got 50 chips right and if you think

3053
02:31:41,341 --> 02:31:46,621
about what have happened here what's the

3054
02:31:43,979 --> 02:31:48,479
yield on those 50 chips that rolled out

3055
02:31:46,620 --> 02:31:51,270
so instead of a hundred ships I had 50

3056
02:31:48,479 --> 02:31:55,921
well in order for one of these chips to

3057
02:31:51,271 --> 02:31:59,551
actually work it means both of the chips

3058
02:31:55,921 --> 02:32:02,461
on the original had to work if either

3059
02:31:59,550 --> 02:32:04,200
one is defective I can't sell the chip

3060
02:32:02,460 --> 02:32:06,719
as an expensive chip anymore maybe I can

3061
02:32:04,200 --> 02:32:08,458
sell it as one of the cheaper ones right

3062
02:32:06,719 --> 02:32:09,929
but I can't sell it as one of the higher

3063
02:32:08,459 --> 02:32:10,920
end ones so when I want to produce one

3064
02:32:09,930 --> 02:32:13,170
of these higher end ones

3065
02:32:10,920 --> 02:32:17,068
what happens to my defect rate here I

3066
02:32:13,170 --> 02:32:18,568
know before that my chance was 75% of

3067
02:32:17,068 --> 02:32:20,850
getting a working one of these chips

3068
02:32:18,568 --> 02:32:23,879
well on the same process with just a

3069
02:32:20,850 --> 02:32:24,840
wider chip what's going to happen two of

3070
02:32:23,879 --> 02:32:31,488
my chips

3071
02:32:24,840 --> 02:32:36,779
have to work so it's 75% times 75% right

3072
02:32:31,488 --> 02:32:46,760
0.75 times 0.75 that leaves me with the

3073
02:32:36,779 --> 02:32:48,899
yield of was it 56% I remember 56% I

3074
02:32:46,760 --> 02:32:55,578
think I'm doing that right if you're a

3075
02:32:48,898 --> 02:33:00,930
hardware guy correct me okay

3076
02:32:55,578 --> 02:33:04,379
so when I do one of these wafers right

3077
02:33:00,930 --> 02:33:07,680
and I started with 50 chips I was going

3078
02:33:04,379 --> 02:33:12,719
to fab I'm only gonna get 25 best case

3079
02:33:07,680 --> 02:33:14,248
probably 24 chips out of this but look

3080
02:33:12,719 --> 02:33:19,108
at what had happened up here

3081
02:33:14,248 --> 02:33:27,208
I had 75 working chips and 75 divided by

3082
02:33:19,109 --> 02:33:29,998
2 it's 37 so if I could have just taken

3083
02:33:27,209 --> 02:33:31,739
this this run of a hundred before if I

3084
02:33:29,998 --> 02:33:35,189
could have just taken the 75 working

3085
02:33:31,738 --> 02:33:37,198
chips and welded them together rather

3086
02:33:35,189 --> 02:33:41,220
than having to count on them being next

3087
02:33:37,199 --> 02:33:45,420
to each other and working my yield went

3088
02:33:41,219 --> 02:33:46,799
from 24 chips out of a 50 chip run to 37

3089
02:33:45,420 --> 02:33:52,889
chips out of a hundred chip run through

3090
02:33:46,799 --> 02:33:55,438
the same wafer size right so it's hard

3091
02:33:52,889 --> 02:34:00,170
to overstate just how much better this

3092
02:33:55,439 --> 02:34:00,170
is it's not 2x but it's close right

3093
02:34:00,529 --> 02:34:05,930
it's like 1.5 X 1.6 X what is it

3094
02:34:09,590 --> 02:34:14,159
yeah 1.5 X that's really good I

3095
02:34:12,840 --> 02:34:16,978
shouldn't say close to 2x but I mean you

3096
02:34:14,159 --> 02:34:20,369
know it's really good oh my god

3097
02:34:16,978 --> 02:34:22,559
right I mean just imagine the difference

3098
02:34:20,370 --> 02:34:25,649
you know if you had a chip that cost a

3099
02:34:22,559 --> 02:34:29,250
thousand dollars right you're talking

3100
02:34:25,648 --> 02:34:32,129
about having to sell it for if it's if

3101
02:34:29,250 --> 02:34:34,109
it's 1.5 X more yield right you're

3102
02:34:32,129 --> 02:34:35,969
talking about being able to reduce that

3103
02:34:34,109 --> 02:34:38,520
price or keep that much more profit

3104
02:34:35,969 --> 02:34:44,129
right 1.5 X more of that or maybe even

3105
02:34:38,520 --> 02:34:46,290
$500 chip right that's really good okay

3106
02:34:44,129 --> 02:34:47,579
again why am I telling you all this what

3107
02:34:46,290 --> 02:34:49,319
the heck does this have to do with cash

3108
02:34:47,579 --> 02:34:53,219
sizes or how they work on multiple chips

3109
02:34:49,318 --> 02:34:56,549
well guess what this is exactly what AMD

3110
02:34:53,219 --> 02:34:58,889
did okay they literally did what I just

3111
02:34:56,549 --> 02:35:00,929
said here instead of producing their

3112
02:34:58,889 --> 02:35:04,289
chips as saying let me produce a chip

3113
02:35:00,930 --> 02:35:06,510
with 16 cores on it by producing a chip

3114
02:35:04,290 --> 02:35:09,300
with 16 cores on it they said let me

3115
02:35:06,510 --> 02:35:18,559
produce 2 chips with 8 cores and weld

3116
02:35:09,299 --> 02:35:18,559
them together that's what they call

3117
02:35:18,920 --> 02:35:22,909
infinity fabric

3118
02:35:28,300 --> 02:35:37,060
they got some stupid name for it I think

3119
02:35:32,950 --> 02:35:39,751
it's called infinity fabric maybe that's

3120
02:35:37,060 --> 02:35:39,751
not what it's called

3121
02:35:55,760 --> 02:36:02,510
yes I think so maybe it's not called

3122
02:36:00,590 --> 02:36:04,010
infinity fabric I don't remember what

3123
02:36:02,510 --> 02:36:08,869
the welding is called if any fact might

3124
02:36:04,010 --> 02:36:10,789
just be the exterior bus way to see what

3125
02:36:08,869 --> 02:36:14,380
I don't remember there buzzer sir what's

3126
02:36:10,789 --> 02:36:14,380
the infinity fabric is that the welding

3127
02:36:17,529 --> 02:36:20,680
all right

3128
02:36:34,228 --> 02:36:40,259
okay I think that's what we're talking

3129
02:36:36,299 --> 02:36:42,180
about then yeah that looks right but

3130
02:36:40,259 --> 02:36:42,658
anyway who cares what it's called point

3131
02:36:42,180 --> 02:36:46,199
being

3132
02:36:42,658 --> 02:36:48,478
that's what AMG does right so they have

3133
02:36:46,199 --> 02:36:50,430
things they have what's called a chiclet

3134
02:36:48,478 --> 02:36:52,918
process I think is what's usually called

3135
02:36:50,430 --> 02:36:55,168
in ministry which is to say rather than

3136
02:36:52,918 --> 02:36:57,088
thinking about fabbing chips which has a

3137
02:36:55,168 --> 02:36:59,128
poor yield rate when you try to make

3138
02:36:57,088 --> 02:37:01,109
them bigger let's think about having

3139
02:36:59,129 --> 02:37:03,088
small things and welding them together

3140
02:37:01,109 --> 02:37:04,408
and let's focus on making a technology

3141
02:37:03,088 --> 02:37:08,248
that allows us to weld them together in

3142
02:37:04,408 --> 02:37:11,458
a way that can work right okay so

3143
02:37:08,248 --> 02:37:15,628
hopefully now you can start to see what

3144
02:37:11,459 --> 02:37:24,439
I'm bringing this back to right now we

3145
02:37:15,629 --> 02:37:27,659
can talk about cash between cores okay

3146
02:37:24,439 --> 02:37:29,668
SIPP lit based designs are going to win

3147
02:37:27,658 --> 02:37:31,228
I think we can pretty much just say that

3148
02:37:29,668 --> 02:37:34,588
and the reason is the thing that I've

3149
02:37:31,228 --> 02:37:37,618
just said before you just get more

3150
02:37:34,588 --> 02:37:39,689
working chips out of the fab period so

3151
02:37:37,619 --> 02:37:42,719
you're simply going to always be able to

3152
02:37:39,689 --> 02:37:45,209
deliver more cores for your dollar in a

3153
02:37:42,718 --> 02:37:48,118
chiclet based design Intel's gonna do it

3154
02:37:45,209 --> 02:37:50,009
AMD's in the lead right now because

3155
02:37:48,119 --> 02:37:52,699
they're doing it they can offer these

3156
02:37:50,009 --> 02:37:56,668
like huge core chips for way cheaper

3157
02:37:52,699 --> 02:37:59,248
it's how it's gonna go right what this

3158
02:37:56,668 --> 02:38:02,908
means is that caching between chords

3159
02:37:59,248 --> 02:38:04,949
even though it was fairly simple a few

3160
02:38:02,908 --> 02:38:07,648
generations ago is now even more

3161
02:38:04,949 --> 02:38:09,869
complicated so the way you typically

3162
02:38:07,648 --> 02:38:12,059
have to think about these things is you

3163
02:38:09,869 --> 02:38:18,838
have to think about them as what's

3164
02:38:12,059 --> 02:38:23,338
called a Numa architecture a new Numa

3165
02:38:18,838 --> 02:38:31,318
architecture is a non-uniform memory

3166
02:38:23,338 --> 02:38:35,068
access architecture and what it means is

3167
02:38:31,318 --> 02:38:37,408
that increasingly true on the CPUs of

3168
02:38:35,068 --> 02:38:41,009
the future and even the ones from today

3169
02:38:37,408 --> 02:38:44,009
from Andy for example or there's a whole

3170
02:38:41,009 --> 02:38:46,770
variety of chips which this is true the

3171
02:38:44,009 --> 02:38:47,970
organization of the caches and how they

3172
02:38:46,770 --> 02:38:53,341
talk to main memory

3173
02:38:47,970 --> 02:38:54,899
is not symmetric procore okay so just

3174
02:38:53,341 --> 02:38:57,931
like I told you that the right way to

3175
02:38:54,899 --> 02:39:00,359
think about you know the CPU is to say

3176
02:38:57,931 --> 02:39:07,530
break it apart say that there's work

3177
02:39:00,360 --> 02:39:10,110
units and a scheduler and l1 l2 l3 main

3178
02:39:07,530 --> 02:39:12,360
memory right

3179
02:39:10,110 --> 02:39:15,181
just like I said start thinking about

3180
02:39:12,360 --> 02:39:17,671
these boxes as separate things that have

3181
02:39:15,181 --> 02:39:21,841
to do work and talk to each other the

3182
02:39:17,671 --> 02:39:32,159
same thing is true for multi-core so

3183
02:39:21,841 --> 02:39:36,950
think about cores themselves as being

3184
02:39:32,159 --> 02:39:38,880
scattered around here's my cores right

3185
02:39:36,950 --> 02:39:41,851
memories out here somewhere

3186
02:39:38,880 --> 02:39:44,671
maybe memories out here maybe it's

3187
02:39:41,851 --> 02:39:47,579
easier for these two chips to talk to

3188
02:39:44,671 --> 02:39:50,940
this bank of memory than these 2 chips

3189
02:39:47,579 --> 02:39:52,890
right maybe this part of the l3 is

3190
02:39:50,940 --> 02:39:55,409
closer to these chips and this part of

3191
02:39:52,890 --> 02:39:57,359
the l3 is closer to those maybe the l2

3192
02:39:55,409 --> 02:40:02,101
is shared between these two chips and

3193
02:39:57,360 --> 02:40:03,391
the altitude right who knows but what

3194
02:40:02,101 --> 02:40:07,921
you have to start getting comfortable

3195
02:40:03,390 --> 02:40:10,709
with if you actually care is that you

3196
02:40:07,921 --> 02:40:13,021
have to start drawing diagrams of who

3197
02:40:10,709 --> 02:40:15,600
can access which memory quickest right

3198
02:40:13,021 --> 02:40:18,271
and what happens on for example a thread

3199
02:40:15,601 --> 02:40:20,641
ripper which is a huge high leak or

3200
02:40:18,271 --> 02:40:22,829
count but highly memory constrained chip

3201
02:40:20,640 --> 02:40:23,880
i believe it actually starts looking

3202
02:40:22,829 --> 02:40:26,101
something like this

3203
02:40:23,880 --> 02:40:29,189
and forgive me if this diagram is not

3204
02:40:26,101 --> 02:40:31,730
great but i believe it looks something

3205
02:40:29,190 --> 02:40:31,730
like this

3206
02:40:43,700 --> 02:40:47,990
so I think this is not a complete

3207
02:40:46,459 --> 02:40:49,250
diagraph thread Ripper or anything like

3208
02:40:47,989 --> 02:40:50,930
that it just I'm trying to give you the

3209
02:40:49,250 --> 02:40:53,450
idea of what some of the memory access

3210
02:40:50,930 --> 02:40:57,800
patterns look like I think they have

3211
02:40:53,450 --> 02:41:00,740
cores that actually can't talk to memory

3212
02:40:57,799 --> 02:41:04,938
and cores that can so like you have a

3213
02:41:00,739 --> 02:41:08,659
core that sits behind another cores l2

3214
02:41:04,939 --> 02:41:12,010
and it's got to kind of go through it to

3215
02:41:08,659 --> 02:41:13,850
get to the l3 or something like this I

3216
02:41:12,010 --> 02:41:15,050
don't want to try to explain this

3217
02:41:13,850 --> 02:41:16,970
because again I haven't studied the

3218
02:41:15,049 --> 02:41:17,478
thread Ripper it's not exactly what I'm

3219
02:41:16,969 --> 02:41:20,659
saying

3220
02:41:17,478 --> 02:41:22,489
but it's it's something that complicated

3221
02:41:20,659 --> 02:41:25,579
you actually to start realizing that

3222
02:41:22,489 --> 02:41:27,049
certain of your cores literally can't

3223
02:41:25,579 --> 02:41:29,600
get to memory without going through

3224
02:41:27,049 --> 02:41:31,519
another core so that means these cores

3225
02:41:29,600 --> 02:41:33,220
are tightly coupled together with what

3226
02:41:31,520 --> 02:41:37,069
they're going to have to be doing and

3227
02:41:33,219 --> 02:41:40,728
these are completely not right and so

3228
02:41:37,069 --> 02:41:42,500
again Numa non-uniform memory access you

3229
02:41:40,728 --> 02:41:45,679
have to start getting the thinking into

3230
02:41:42,500 --> 02:41:47,659
okay I gotta learn if I really want to

3231
02:41:45,680 --> 02:41:50,360
get the maximum performance I'll ship I

3232
02:41:47,659 --> 02:41:51,260
got to learn where these caches are how

3233
02:41:50,360 --> 02:41:53,210
big they are

3234
02:41:51,260 --> 02:41:55,728
which course there's a tear attached to

3235
02:41:53,209 --> 02:41:59,569
and what the cost is for moving memory

3236
02:41:55,728 --> 02:42:06,109
between them right similarly Intel chips

3237
02:41:59,569 --> 02:42:11,239
you know like Knights landing this is

3238
02:42:06,110 --> 02:42:15,860
like a Xeon oops I think they're called

3239
02:42:11,239 --> 02:42:18,860
a Xeon Phi chips they have a thing

3240
02:42:15,860 --> 02:42:20,000
called a ring bus architecture on them

3241
02:42:18,860 --> 02:42:22,600
and what they look like is something

3242
02:42:20,000 --> 02:42:22,600
like this

3243
02:42:27,420 --> 02:42:34,559
so here's my course 0 1 2 3 4 5 6 7 8 9

3244
02:42:33,270 --> 02:42:38,699
of course I don't know how many cores I

3245
02:42:34,559 --> 02:42:42,719
have they go around in like a bucket

3246
02:42:38,699 --> 02:42:46,500
brigade so the time it takes core 8 to

3247
02:42:42,719 --> 02:42:48,629
talk to core 4 is like drastically more

3248
02:42:46,500 --> 02:42:52,199
than the time it takes for 8 to talk to

3249
02:42:48,629 --> 02:42:55,920
9 because it like stuff goes in this

3250
02:42:52,199 --> 02:42:58,140
order always right these are like not

3251
02:42:55,920 --> 02:42:59,908
gonna work I don't think anyone's

3252
02:42:58,139 --> 02:43:02,129
pursuing rim buss ring bus architectures

3253
02:42:59,908 --> 02:43:04,139
anymore but I like I don't think but

3254
02:43:02,129 --> 02:43:07,618
that was a real thing so you had like

3255
02:43:04,139 --> 02:43:08,969
actual like motion of the memory

3256
02:43:07,619 --> 02:43:15,380
information and kind of a circular

3257
02:43:08,969 --> 02:43:18,358
pattern anyway so you need to know Numa

3258
02:43:15,379 --> 02:43:20,759
right that's one thing you need to start

3259
02:43:18,359 --> 02:43:22,559
understanding where the caches are how

3260
02:43:20,760 --> 02:43:24,930
they're arranged and which cores talk to

3261
02:43:22,559 --> 02:43:26,639
which caches and how and then you all

3262
02:43:24,930 --> 02:43:28,350
end memory banks as well because you can

3263
02:43:26,639 --> 02:43:30,180
have multiple memory banks - especially

3264
02:43:28,350 --> 02:43:32,550
on multiprocessor systems you will have

3265
02:43:30,180 --> 02:43:34,500
like certain prosecco processors are

3266
02:43:32,549 --> 02:43:36,209
closer to certain memory banks and they

3267
02:43:34,500 --> 02:43:38,279
need to talk to each other to send data

3268
02:43:36,209 --> 02:43:39,898
from the either banks across right so

3269
02:43:38,279 --> 02:43:42,060
Numa very important start to learn the

3270
02:43:39,898 --> 02:43:43,858
block diagram of your system but then

3271
02:43:42,059 --> 02:43:48,028
you've also got another thing which is

3272
02:43:43,859 --> 02:43:50,550
called meze meze is the protocol by

3273
02:43:48,029 --> 02:43:52,079
which caches and cores talk to each

3274
02:43:50,549 --> 02:43:55,019
other and talk about who can access

3275
02:43:52,079 --> 02:44:00,209
which cache lines at which time ok and

3276
02:43:55,020 --> 02:44:04,979
what this means I believe is like what's

3277
02:44:00,209 --> 02:44:09,709
the different ones it's like shared CMA

3278
02:44:04,978 --> 02:44:09,709
these I can get right exclusive

3279
02:44:17,851 --> 02:44:28,530
mutated and then you know I should

3280
02:44:25,239 --> 02:44:28,530
remember these by now I never do

3281
02:44:28,800 --> 02:44:32,850
modified an invalid yeah I knew it's

3282
02:44:31,000 --> 02:44:39,159
like I knew it something that invalid

3283
02:44:32,851 --> 02:44:40,659
and modify okay so there's a thing

3284
02:44:39,159 --> 02:44:43,931
called the meze protocol and this is the

3285
02:44:40,659 --> 02:44:47,079
actual logic by which the cache knows

3286
02:44:43,931 --> 02:44:48,971
what to do and so that cores can operate

3287
02:44:47,079 --> 02:44:52,810
on the same information and not get

3288
02:44:48,970 --> 02:44:54,850
woefully out of sync so what happens is

3289
02:44:52,810 --> 02:44:57,011
remember I told you that there are 64

3290
02:44:54,851 --> 02:45:01,721
bytes that move around in chunks and

3291
02:44:57,011 --> 02:45:03,489
these things are called cache lines well

3292
02:45:01,720 --> 02:45:04,779
once you start thinking about two cores

3293
02:45:03,489 --> 02:45:08,261
here's core zero

3294
02:45:04,780 --> 02:45:12,221
here's core one well maybe these both

3295
02:45:08,261 --> 02:45:16,120
have their own l1 cache and maybe they

3296
02:45:12,220 --> 02:45:19,989
each even have their own two then they

3297
02:45:16,120 --> 02:45:23,829
share in l3 right so what ends up

3298
02:45:19,989 --> 02:45:27,399
happening is the l3 sort of becomes like

3299
02:45:23,829 --> 02:45:31,989
an arbiter for who can do what with

3300
02:45:27,399 --> 02:45:35,229
cache lines and win if core one needs to

3301
02:45:31,989 --> 02:45:38,319
read from a particular cache line then

3302
02:45:35,229 --> 02:45:40,091
rather than saying I need to have this

3303
02:45:38,319 --> 02:45:42,149
cache line and I'm the only person who

3304
02:45:40,091 --> 02:45:45,040
should ever have this cache line right

3305
02:45:42,149 --> 02:45:46,449
maybe core zero also needs to read from

3306
02:45:45,040 --> 02:45:47,650
a particular cache line it's the same

3307
02:45:46,450 --> 02:45:51,101
one so we're both going to read from

3308
02:45:47,649 --> 02:45:54,431
cache line a right we would like both

3309
02:45:51,101 --> 02:45:57,040
cores to be able to do that so what we

3310
02:45:54,431 --> 02:45:59,500
do is we have the concept of a shared

3311
02:45:57,040 --> 02:46:01,750
cache line which is to say both of these

3312
02:45:59,500 --> 02:46:06,671
people say I'm just going to read so we

3313
02:46:01,750 --> 02:46:11,530
can share this cache line right and when

3314
02:46:06,671 --> 02:46:15,370
we do we mark it with an S right it is

3315
02:46:11,530 --> 02:46:18,841
shared what does that mean well it means

3316
02:46:15,370 --> 02:46:21,910
if I need to modify the cache line now I

3317
02:46:18,841 --> 02:46:25,569
can't really necessarily do that because

3318
02:46:21,909 --> 02:46:27,610
I know core 1 is using it as well right

3319
02:46:25,569 --> 02:46:30,379
or somebody else is that's what that

3320
02:46:27,610 --> 02:46:32,750
shared mark means right

3321
02:46:30,379 --> 02:46:35,509
so what we need to do is we need to have

3322
02:46:32,750 --> 02:46:37,728
a way of invalidating that through the

3323
02:46:35,510 --> 02:46:39,590
cash so what will happen is if cor one

3324
02:46:37,728 --> 02:46:42,408
now needs to do a write to that cash

3325
02:46:39,590 --> 02:46:44,029
line that means core zero better not use

3326
02:46:42,408 --> 02:46:46,908
it that way anymore because it's stale

3327
02:46:44,029 --> 02:46:50,540
data so what happens is it says I need

3328
02:46:46,908 --> 02:46:52,430
this line exclusively now right what

3329
02:46:50,540 --> 02:46:54,350
that will do is that will propagate out

3330
02:46:52,430 --> 02:46:55,850
it will wait

3331
02:46:54,350 --> 02:46:57,680
it will allow core zero to basically

3332
02:46:55,850 --> 02:47:01,488
take an accord want to take an exclusive

3333
02:46:57,680 --> 02:47:03,770
luck on that cash line and so that will

3334
02:47:01,488 --> 02:47:06,228
force this into an invalid state of the

3335
02:47:03,770 --> 02:47:07,970
cash line right what that means is now

3336
02:47:06,228 --> 02:47:09,590
when this person needs to read it it

3337
02:47:07,969 --> 02:47:12,260
will have to go back and get it because

3338
02:47:09,590 --> 02:47:15,500
it knows that it's wrong now I don't

3339
02:47:12,260 --> 02:47:17,329
actually know the complete transition

3340
02:47:15,500 --> 02:47:20,148
diagram for how these work inside the

3341
02:47:17,329 --> 02:47:20,988
cash but it's probably in here right

3342
02:47:20,148 --> 02:47:22,549
yeah here you go

3343
02:47:20,988 --> 02:47:27,279
there for me to the states of the cash

3344
02:47:22,549 --> 02:47:31,219
line can be each of these things right

3345
02:47:27,279 --> 02:47:33,560
so if I modify a line in the cash

3346
02:47:31,219 --> 02:47:36,408
someone else has to marketing theirs is

3347
02:47:33,559 --> 02:47:37,818
invalid right if they market is modified

3348
02:47:36,408 --> 02:47:40,068
I've got a marked mine is invalid and so

3349
02:47:37,818 --> 02:47:41,778
on that meze protocol here oh this is

3350
02:47:40,068 --> 02:47:44,629
the thing I want the state diagram the

3351
02:47:41,779 --> 02:47:46,760
meze protocol tells you what the states

3352
02:47:44,629 --> 02:47:48,969
of the cache lines will be and how they

3353
02:47:46,760 --> 02:47:52,939
will be moved through and that is

3354
02:47:48,969 --> 02:47:55,398
exactly how your processor is thinking

3355
02:47:52,939 --> 02:47:57,290
about how to move the caches around so

3356
02:47:55,398 --> 02:47:59,269
if you want to understand what happens

3357
02:47:57,290 --> 02:48:00,680
with multiple cores you need two things

3358
02:47:59,270 --> 02:48:02,750
you need to understand your Numa

3359
02:48:00,680 --> 02:48:03,949
understand what diagram the cache how

3360
02:48:02,750 --> 02:48:06,139
the cache is float throughout the course

3361
02:48:03,949 --> 02:48:08,960
and you got understand meze how the

3362
02:48:06,139 --> 02:48:10,459
caches will invalidate each other's how

3363
02:48:08,959 --> 02:48:12,259
the cores will in valley each other each

3364
02:48:10,459 --> 02:48:15,228
other's cache is such that they can

3365
02:48:12,260 --> 02:48:16,189
maintain right consistency right and so

3366
02:48:15,228 --> 02:48:18,079
when you're programming from

3367
02:48:16,189 --> 02:48:20,869
multi-threading that becomes very

3368
02:48:18,079 --> 02:48:22,969
important you don't want your cores to

3369
02:48:20,869 --> 02:48:25,100
have to keep stealing each other's cache

3370
02:48:22,969 --> 02:48:26,868
lines for exclusive writing so you want

3371
02:48:25,100 --> 02:48:29,300
to try and maximize the degree to which

3372
02:48:26,869 --> 02:48:31,040
cores that do writes are writing the

3373
02:48:29,299 --> 02:48:33,429
cache lines other people aren't trying

3374
02:48:31,040 --> 02:48:33,430
to use

3375
02:48:39,800 --> 02:48:46,560
Coulter fig says 64 byte cache lines are

3376
02:48:44,069 --> 02:48:48,960
pervasive due to the burst size of DDR

3377
02:48:46,560 --> 02:48:51,060
controllers so basically what called I

3378
02:48:48,960 --> 02:48:53,069
forget suggesting here our cult of

3379
02:48:51,060 --> 02:48:55,529
rigged I guess it's probably how it is

3380
02:48:53,069 --> 02:48:59,581
maybe cult cult to frig I don't know

3381
02:48:55,530 --> 02:49:02,190
call tough rig is saying I is that DDR

3382
02:48:59,581 --> 02:49:04,681
controllers want to want to send things

3383
02:49:02,190 --> 02:49:06,030
in 64 byte sizes and hence you want cash

3384
02:49:04,681 --> 02:49:07,591
signs to be had science makes perfect

3385
02:49:06,030 --> 02:49:09,511
sense again I don't know enough but hard

3386
02:49:07,591 --> 02:49:12,661
to say but that would make perfect sense

3387
02:49:09,511 --> 02:49:14,310
right arm also moved from 32 bytes to 64

3388
02:49:12,661 --> 02:49:26,251
bytes so yeah so I guess episode

3389
02:49:14,310 --> 02:49:27,841
everyone's on 64 bytes now I guess row

3390
02:49:26,251 --> 02:49:31,860
said the process for the silicon Inga's

3391
02:49:27,841 --> 02:49:37,621
is called the crawl ski process again

3392
02:49:31,860 --> 02:49:39,631
don't know anything about that Sancho

3393
02:49:37,620 --> 02:49:41,010
Panza asks why don't they focus on

3394
02:49:39,630 --> 02:49:43,199
increasing the cache sizes is there a

3395
02:49:41,011 --> 02:49:46,560
hard limit to it or are they happy with

3396
02:49:43,200 --> 02:49:48,900
the sizes as they are so there's a

3397
02:49:46,560 --> 02:49:50,610
number of reasons why they can't just

3398
02:49:48,899 --> 02:49:56,130
arbitrarily make the cache sizes bigger

3399
02:49:50,610 --> 02:49:58,261
and they are as follows one I again the

3400
02:49:56,130 --> 02:50:00,149
more cash you include on chip the bigger

3401
02:49:58,261 --> 02:50:03,360
the chip gets so that defect rate

3402
02:50:00,149 --> 02:50:07,380
increases and it's right it's just cost

3403
02:50:03,360 --> 02:50:09,421
more right - the bigger the cache is the

3404
02:50:07,380 --> 02:50:12,540
harder it is to make it fast because

3405
02:50:09,421 --> 02:50:16,530
again you have a cache is large there's

3406
02:50:12,540 --> 02:50:18,180
more routes that you know you need to ok

3407
02:50:16,530 --> 02:50:19,921
it's a physical thing it's got to get

3408
02:50:18,181 --> 02:50:22,890
actually it's got a store charge and

3409
02:50:19,921 --> 02:50:25,229
return charge back to the chip went back

3410
02:50:22,890 --> 02:50:29,161
to the processing units right the actual

3411
02:50:25,229 --> 02:50:31,680
processing logic the bigger it is the

3412
02:50:29,161 --> 02:50:34,979
less able you are to make it fast right

3413
02:50:31,681 --> 02:50:38,819
so having 32k a fast memory isn't that

3414
02:50:34,979 --> 02:50:40,560
hard to do on a chip 64k harder 64 sorry

3415
02:50:38,819 --> 02:50:42,690
128 K very hard to tease Kate

3416
02:50:40,560 --> 02:50:46,290
extraordinarily hard right you start

3417
02:50:42,690 --> 02:50:48,239
just running into the square size law is

3418
02:50:46,290 --> 02:50:49,020
just really making it hard for you to

3419
02:50:48,239 --> 02:50:50,880
make sure that

3420
02:50:49,021 --> 02:50:54,001
you actually get the data in so there's

3421
02:50:50,880 --> 02:50:56,460
a there's a hard speed limit as well as

3422
02:50:54,001 --> 02:50:58,319
a yield problem that you fight so

3423
02:50:56,460 --> 02:51:00,720
they're always trying to give us the

3424
02:50:58,319 --> 02:51:05,520
biggest cash as they can it's just it's

3425
02:51:00,720 --> 02:51:07,319
expensive and difficult to do isn't the

3426
02:51:05,521 --> 02:51:09,721
wavelength and science electron kind of

3427
02:51:07,319 --> 02:51:13,369
the same just different models no idea

3428
02:51:09,720 --> 02:51:13,369
not if his guy couldn't tell you Oh

3429
02:51:17,460 --> 02:51:21,779
print if Armen said they they had the

3430
02:51:19,501 --> 02:51:23,399
privilege of wearing in a bunny suit at

3431
02:51:21,780 --> 02:51:35,940
an it was that was you think at that in

3432
02:51:23,399 --> 02:51:37,409
at Infineon that's awesome cubic Caleb

3433
02:51:35,940 --> 02:51:39,360
says if the probability of failure for

3434
02:51:37,409 --> 02:51:42,931
one ship is PF and the probably feather

3435
02:51:39,360 --> 02:51:54,271
of two combined chips is denoted PFC

3436
02:51:42,931 --> 02:52:02,341
then PFC is two times pf- PF x PF okay

3437
02:51:54,271 --> 02:52:11,329
so you're saying that if the probability

3438
02:52:02,341 --> 02:52:23,101
of failure of one ship is PF then PFC is

3439
02:52:11,329 --> 02:52:29,579
two x PF - PF x PF okay so I only did

3440
02:52:23,101 --> 02:52:31,620
this one part here wait why is this the

3441
02:52:29,579 --> 02:52:35,011
case you're gonna have to explain it to

3442
02:52:31,620 --> 02:52:37,551
me though cuz I'm not sure why that

3443
02:52:35,011 --> 02:52:37,551
would be

3444
02:53:07,250 --> 02:53:12,300
hmm so yeah I mean I guess I don't know

3445
02:53:10,261 --> 02:53:13,681
why I'm willing to take your word for it

3446
02:53:12,300 --> 02:53:16,159
was like I said I don't know the extra

3447
02:53:13,681 --> 02:53:18,810
math but I just giving example there

3448
02:53:16,159 --> 02:53:21,720
because shouldn't it be the case that if

3449
02:53:18,810 --> 02:53:26,220
we imagine defects being placed on the

3450
02:53:21,720 --> 02:53:28,529
die isn't the chance that I end up with

3451
02:53:26,220 --> 02:53:30,539
a defect on one of the two chips just

3452
02:53:28,530 --> 02:53:32,489
going to be the same as it would have

3453
02:53:30,540 --> 02:53:36,561
been for one of the chip I don't quite

3454
02:53:32,489 --> 02:53:36,560
get it but I guess maybe it's because

3455
02:53:42,890 --> 02:53:48,390
your chance of getting two working ones

3456
02:53:45,720 --> 02:53:50,520
is higher due to the fact that the

3457
02:53:48,390 --> 02:53:53,479
distribution of defects is more than

3458
02:53:50,521 --> 02:54:01,710
just random in that sense

3459
02:53:53,479 --> 02:54:05,091
see if I can work that out so let's say

3460
02:54:01,709 --> 02:54:05,090
I had

3461
02:54:14,559 --> 02:54:26,028
eight chips on here right one two three

3462
02:54:19,609 --> 02:54:28,609
four well let's do one two three four

3463
02:54:26,029 --> 02:54:32,600
five six seven eight nine ten let's say

3464
02:54:28,609 --> 02:54:36,649
I had ten here I and I was saying that I

3465
02:54:32,600 --> 02:54:41,600
had a 75% chance of getting a working

3466
02:54:36,648 --> 02:54:47,209
chip right so what that means is I've

3467
02:54:41,600 --> 02:54:48,859
got well I guess that's bad because I'm

3468
02:54:47,209 --> 02:54:53,448
cinnamon so let's say have an 80% chance

3469
02:54:48,859 --> 02:54:56,809
so eight of my chips will work right I'm

3470
02:54:53,449 --> 02:55:00,590
expecting to have a twerk and to fail

3471
02:54:56,809 --> 02:55:05,359
right so that means that I there is a

3472
02:55:00,590 --> 02:55:08,449
defect on two of their two defects that

3473
02:55:05,359 --> 02:55:11,029
will fall somewhere in this chip and so

3474
02:55:08,449 --> 02:55:12,560
I'll get like one here and I expect to

3475
02:55:11,029 --> 02:55:15,620
get like one here or something like this

3476
02:55:12,559 --> 02:55:18,920
right and so these two chips will be out

3477
02:55:15,620 --> 02:55:22,670
but my other chips will still work right

3478
02:55:18,920 --> 02:55:27,620
so assuming that I then changed to

3479
02:55:22,670 --> 02:55:31,639
taking these chips two at a time right

3480
02:55:27,620 --> 02:55:36,040
so now I'm saying I've got a b c d e

3481
02:55:31,639 --> 02:55:39,978
only five chips that i'm manufacturing

3482
02:55:36,040 --> 02:55:44,390
then what are the chances i guess that

3483
02:55:39,978 --> 02:55:47,028
the that these chips work I would expect

3484
02:55:44,389 --> 02:55:49,549
two of the chips to not work in the case

3485
02:55:47,029 --> 02:55:51,620
that I have above but how many times

3486
02:55:49,549 --> 02:55:55,340
with the defect fall on the same chip

3487
02:55:51,620 --> 02:55:59,149
right I guess would be the saving grace

3488
02:55:55,340 --> 02:56:01,520
right well the times we can enumerate

3489
02:55:59,148 --> 02:56:03,500
how many times there that the defects

3490
02:56:01,520 --> 02:56:06,590
will fall in the same chip it would be

3491
02:56:03,500 --> 02:56:08,449
when it's a B right I mean another way

3492
02:56:06,590 --> 02:56:10,939
say it would be like I got a place to

3493
02:56:08,449 --> 02:56:14,720
defects how many ways can I place two

3494
02:56:10,939 --> 02:56:16,398
defects on these chips total so they

3495
02:56:14,719 --> 02:56:17,658
would fall on the same ones so there's

3496
02:56:16,398 --> 02:56:21,049
the a B defect

3497
02:56:17,658 --> 02:56:23,600
there's the CD defect the EF defect the

3498
02:56:21,049 --> 02:56:25,009
gh defect and the IJ defect those are

3499
02:56:23,600 --> 02:56:26,300
the only ways that I can really place

3500
02:56:25,010 --> 02:56:28,010
them right

3501
02:56:26,299 --> 02:56:30,590
but I could place them in either order

3502
02:56:28,010 --> 02:56:32,449
there I suppose so if I just look at how

3503
02:56:30,590 --> 02:56:38,510
many there's going to be there's going

3504
02:56:32,449 --> 02:56:40,399
to be five defect patterns or you can

3505
02:56:38,510 --> 02:56:45,920
look at this ten if I swapped which

3506
02:56:40,398 --> 02:56:51,349
order they were in in which I would only

3507
02:56:45,920 --> 02:56:54,020
lose one of my chips right the rest of

3508
02:56:51,350 --> 02:57:00,828
my defect patterns which is going to be

3509
02:56:54,020 --> 02:57:02,600
what I have to put a defect down on one

3510
02:57:00,828 --> 02:57:05,719
of these and so I can

3511
02:57:02,600 --> 02:57:12,020
my first defect can go down on any one

3512
02:57:05,719 --> 02:57:15,889
of ten right and then I put another one

3513
02:57:12,020 --> 02:57:19,279
down on any one of nine so I've got 90

3514
02:57:15,889 --> 02:57:19,849
possible ways I could do that I think

3515
02:57:19,279 --> 02:57:23,960
that's right

3516
02:57:19,850 --> 02:57:26,199
my probabilities are always bad so I've

3517
02:57:23,959 --> 02:57:30,429
got 90 possible ways there in ten of

3518
02:57:26,199 --> 02:57:36,670
ways that I could end up with only one

3519
02:57:30,430 --> 02:57:44,180
defect so in one out of nine times I

3520
02:57:36,670 --> 02:57:51,129
would get four chips right and eight out

3521
02:57:44,180 --> 02:57:55,809
of nine times I would get three chips

3522
02:57:51,129 --> 02:57:55,809
does that make sense I think

3523
02:57:56,250 --> 02:58:01,681
seems seems right and so what I was

3524
02:57:59,851 --> 02:58:03,841
saying before where it's like well if

3525
02:58:01,681 --> 02:58:07,971
the probability is is you know if it's

3526
02:58:03,841 --> 02:58:10,681
80 percent or rather so it's 8 out of 10

3527
02:58:07,970 --> 02:58:12,659
to get a working ship before

3528
02:58:10,681 --> 02:58:16,980
now I'm gonna say that it's 8 out of 10

3529
02:58:12,659 --> 02:58:19,500
times 8 out of 10 right which is going

3530
02:58:16,979 --> 02:58:33,779
to be 64 out of a hundred

3531
02:58:19,500 --> 02:58:35,370
right or sort of like 6.4 out of 10 so I

3532
02:58:33,780 --> 02:58:37,230
think that's roughly what I'm talking

3533
02:58:35,370 --> 02:58:38,190
about here so 6.4 out of 10 I guess I

3534
02:58:37,229 --> 02:58:44,550
really want to know what this thing is

3535
02:58:38,190 --> 02:58:46,620
out of nine though so that's not quite

3536
02:58:44,550 --> 02:58:48,149
as good I'd like the tsunami to be the

3537
02:58:46,620 --> 02:58:50,301
same but I'll just divide that divide

3538
02:58:48,149 --> 02:58:57,600
them out and see what I get

3539
02:58:50,300 --> 02:59:04,800
this is not great math here folks this

3540
02:58:57,601 --> 02:59:07,040
is point one one this is point eight

3541
02:59:04,800 --> 02:59:07,039
eight

3542
02:59:09,190 --> 02:59:16,180
this is point 64 right okay

3543
02:59:14,409 --> 02:59:17,351
so I've got a point 1 1 chance of

3544
02:59:16,180 --> 02:59:20,560
getting four chips a point eight eight

3545
02:59:17,351 --> 02:59:21,851
chance of getting three chips well

3546
02:59:20,560 --> 02:59:22,719
actually I guess I shouldn't have done

3547
02:59:21,851 --> 02:59:24,130
it this way because we don't care about

3548
02:59:22,719 --> 02:59:26,560
that number what we know right now is

3549
02:59:24,129 --> 02:59:30,969
that we're going to get one of these two

3550
02:59:26,560 --> 02:59:32,829
cases each of these times right so what

3551
02:59:30,969 --> 02:59:35,049
I can do here instead is just say let's

3552
02:59:32,829 --> 02:59:39,700
multiply this out one out of four times

3553
02:59:35,049 --> 02:59:47,679
I get oh and and here I'm getting I in

3554
02:59:39,700 --> 02:59:49,210
this case I'm getting an 80% chance of

3555
02:59:47,680 --> 02:59:51,399
the yield so if I I have to actually

3556
02:59:49,209 --> 02:59:53,739
multiply this out to figure out how many

3557
02:59:51,399 --> 02:59:56,500
chips I'm actually gonna get so out of

3558
02:59:53,739 --> 02:59:59,229
the nine times I do this I'm gonna get

3559
02:59:56,500 --> 03:00:03,521
four chips once plus eight times three

3560
02:59:59,229 --> 03:00:07,239
chips or 24 right so that's 28 chips in

3561
03:00:03,521 --> 03:00:09,040
this case out of that run right whereas

3562
03:00:07,239 --> 03:00:10,629
here what I would have expected to get

3563
03:00:09,040 --> 03:00:19,930
for the number of chips I'm gonna get

3564
03:00:10,629 --> 03:00:29,289
here if I'm doing nine nine batches of

3565
03:00:19,930 --> 03:00:31,239
five chips at a point eight times point

3566
03:00:29,290 --> 03:00:32,891
a failure rate I'm expecting me at

3567
03:00:31,239 --> 03:00:35,369
twenty eight point eight chips or twenty

3568
03:00:32,890 --> 03:00:38,440
eight chips are you sure I'm wrong I

3569
03:00:35,370 --> 03:00:41,311
must be missing something so why is it

3570
03:00:38,440 --> 03:00:41,310
why is that the case

3571
03:00:47,610 --> 03:00:53,500
it's the union of either chip being a

3572
03:00:50,560 --> 03:00:55,029
dud - the intersection of both chips

3573
03:00:53,500 --> 03:01:06,069
being a dud since this is already

3574
03:00:55,030 --> 03:01:07,870
accounted for in the Union okay all

3575
03:01:06,069 --> 03:01:10,539
right well anyway point being my math is

3576
03:01:07,870 --> 03:01:12,100
too weak and I'm too tired right now to

3577
03:01:10,540 --> 03:01:13,690
really work that out but I will take

3578
03:01:12,100 --> 03:01:15,880
your word for that that that's actually

3579
03:01:13,690 --> 03:01:22,810
the equation is is actually supposed to

3580
03:01:15,879 --> 03:01:24,879
be this for the defect rate so I think I

3581
03:01:22,810 --> 03:01:26,350
may have over counted slightly so if the

3582
03:01:24,879 --> 03:01:29,129
probability of failure in this case like

3583
03:01:26,350 --> 03:01:29,130
we're saying before

3584
03:01:38,209 --> 03:01:42,199
Kirito i oversimplify it should just be

3585
03:01:40,521 --> 03:01:43,579
Bayes theorem and these events should be

3586
03:01:42,200 --> 03:01:49,370
independent so just multiply the favor

3587
03:01:43,579 --> 03:01:52,101
right but that's what I did right let's

3588
03:01:49,370 --> 03:01:57,021
end it this way since we're basically

3589
03:01:52,101 --> 03:01:58,790
done now I am like I said many many

3590
03:01:57,021 --> 03:02:00,261
times during this I'm a harder person

3591
03:01:58,790 --> 03:02:02,450
I'm just trying to give you overview I

3592
03:02:00,261 --> 03:02:03,890
don't know what the actual defect rate

3593
03:02:02,450 --> 03:02:06,650
could be there all I can tell you is the

3594
03:02:03,890 --> 03:02:07,399
defect rate is substantially worse that

3595
03:02:06,649 --> 03:02:10,489
is for sure

3596
03:02:07,399 --> 03:02:13,819
if you're trying to fab a larger

3597
03:02:10,489 --> 03:02:15,530
pristine chip versus smaller chips you

3598
03:02:13,819 --> 03:02:17,091
can combine the working ones together

3599
03:02:15,530 --> 03:02:19,400
after you already know they're working

3600
03:02:17,091 --> 03:02:21,560
right and the reason like I said it is

3601
03:02:19,399 --> 03:02:23,810
kind of obvious even if you don't know

3602
03:02:21,560 --> 03:02:26,649
the exact details because that's not

3603
03:02:23,810 --> 03:02:31,550
what we do here on handmade here oh um

3604
03:02:26,649 --> 03:02:33,261
because yeah you can first fab smaller

3605
03:02:31,550 --> 03:02:35,390
chips see which one's worked and put

3606
03:02:33,261 --> 03:02:36,920
those together and if your way of

3607
03:02:35,390 --> 03:02:39,770
putting them together is more foolproof

3608
03:02:36,920 --> 03:02:42,261
doesn't have as high a defect rate then

3609
03:02:39,771 --> 03:02:43,311
you get o in right and so that's you

3610
03:02:42,261 --> 03:02:47,500
know where that comes from

3611
03:02:43,310 --> 03:02:47,500
alright so

3612
03:02:52,959 --> 03:02:57,010
close this down that ended up being a

3613
03:02:55,810 --> 03:02:58,091
handmade chat we did not do any

3614
03:02:57,011 --> 03:03:00,610
programming today but that's okay

3615
03:02:58,091 --> 03:03:01,030
sometimes we don't so I'm gonna wind it

3616
03:03:00,610 --> 03:03:03,940
down

3617
03:03:01,030 --> 03:03:06,131
it's been fun chatting with you we will

3618
03:03:03,940 --> 03:03:08,200
not actually call this day 5:45 this

3619
03:03:06,130 --> 03:03:12,510
will not be a hammy hero day this will

3620
03:03:08,200 --> 03:03:16,420
just be a handmade chat about caches

3621
03:03:12,511 --> 03:03:20,190
I'll be back next weekend to actually do

3622
03:03:16,420 --> 03:03:22,540
some programming and then on that

3623
03:03:20,190 --> 03:03:25,149
weekend we will not be chatting instead

3624
03:03:22,540 --> 03:03:28,210
what we'll do is we will use our new

3625
03:03:25,149 --> 03:03:29,949
entity structure where we actually use

3626
03:03:28,209 --> 03:03:33,069
some caching but that was not the CPU

3627
03:03:29,950 --> 03:03:35,620
kind of caching to start improving our

3628
03:03:33,069 --> 03:03:37,630
entity system and our lighting system so

3629
03:03:35,620 --> 03:03:39,120
that's we're gonna be doing next week on

3630
03:03:37,630 --> 03:03:41,079
here I hope you'll join me for that

3631
03:03:39,120 --> 03:03:43,660
until then

3632
03:03:41,079 --> 03:03:44,920
yeah if you do want to work on the

3633
03:03:43,659 --> 03:03:46,209
source code of handmade hero obviously

3634
03:03:44,920 --> 03:03:49,390
as I say every time you can always

3635
03:03:46,209 --> 03:03:52,180
pre-order it on handmade hero org but

3636
03:03:49,390 --> 03:03:54,761
that's more for next weekend until then

3637
03:03:52,181 --> 03:03:58,739
I hope you've had fun discussing caching

3638
03:03:54,761 --> 03:04:02,101
with me and I will see you next weekend

3639
03:03:58,739 --> 03:04:02,101
take it easy everybody

