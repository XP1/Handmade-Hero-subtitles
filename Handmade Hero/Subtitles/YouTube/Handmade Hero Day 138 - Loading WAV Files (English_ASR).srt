1
00:00:00,350 --> 00:00:06,389
like so alright hello everyone and

2
00:00:04,950 --> 00:00:08,940
welcome to handmade Hero the show where

3
00:00:06,389 --> 00:00:11,849
we code a complete game live on Twitch

4
00:00:08,939 --> 00:00:15,029
no engines no libraries our goal is to

5
00:00:11,849 --> 00:00:17,730
show the complete set of things that

6
00:00:15,029 --> 00:00:19,320
happen when a game runs right down to

7
00:00:17,730 --> 00:00:21,539
how pixels are rendered even without a

8
00:00:19,320 --> 00:00:23,219
GPU we did our own renderer we've done

9
00:00:21,539 --> 00:00:25,380
all our own stuff and today we're

10
00:00:23,219 --> 00:00:27,239
actually starting because it seemed like

11
00:00:25,379 --> 00:00:28,829
a good time to get this in there we're

12
00:00:27,239 --> 00:00:30,389
sort of doing a quick run through things

13
00:00:28,829 --> 00:00:34,738
to sort of pull stuff together a little

14
00:00:30,390 --> 00:00:37,620
bit I wanted to start getting sound in

15
00:00:34,738 --> 00:00:39,570
there and sound is again one of those

16
00:00:37,619 --> 00:00:40,949
things like graphics and where a lot of

17
00:00:39,570 --> 00:00:42,119
people just use a library or something

18
00:00:40,950 --> 00:00:43,469
and don't think too much about it but

19
00:00:42,119 --> 00:00:44,549
again I'm hand made here our point is to

20
00:00:43,469 --> 00:00:46,679
be educational to show everything

21
00:00:44,549 --> 00:00:49,049
involved so that people understand

22
00:00:46,679 --> 00:00:51,570
exactly how all of these things work and

23
00:00:49,049 --> 00:00:53,549
sound is actually one of those things

24
00:00:51,570 --> 00:00:55,049
that's worth understanding because

25
00:00:53,549 --> 00:00:57,179
there's a lot of stuff you can do when

26
00:00:55,049 --> 00:00:58,589
you understand it that you might not be

27
00:00:57,179 --> 00:00:59,579
able to do if you just kind of use a

28
00:00:58,590 --> 00:01:02,520
library and don't really know what's

29
00:00:59,579 --> 00:01:06,659
going on so what we'd like to do now is

30
00:01:02,520 --> 00:01:08,790
get a little bit further into that so to

31
00:01:06,659 --> 00:01:11,070
that end I have updated the witness ask

32
00:01:08,790 --> 00:01:12,840
them sources the witness I'm talking

33
00:01:11,069 --> 00:01:14,699
about the witness a lot in the pre

34
00:01:12,840 --> 00:01:17,549
stream I'm I've got witness on the brain

35
00:01:14,700 --> 00:01:20,490
we've updated the handmade hero our

36
00:01:17,549 --> 00:01:22,439
asset pack and you can see there's now a

37
00:01:20,489 --> 00:01:24,059
test3 directory in there so it's just

38
00:01:22,438 --> 00:01:26,489
it's got all the test directories but

39
00:01:24,060 --> 00:01:28,590
before there was just test in test2 and

40
00:01:26,489 --> 00:01:30,839
now there's a test3 I'm going to go

41
00:01:28,590 --> 00:01:32,939
ahead and copy that test three out into

42
00:01:30,840 --> 00:01:34,920
here so that now we've got it and really

43
00:01:32,938 --> 00:01:36,449
there's nothing particularly interesting

44
00:01:34,920 --> 00:01:39,629
about this it's just a bunch of wav

45
00:01:36,450 --> 00:01:42,509
files that I had which I had made myself

46
00:01:39,629 --> 00:01:44,219
so I know that they are not copyrighted

47
00:01:42,509 --> 00:01:46,950
by anything so they can be included in

48
00:01:44,219 --> 00:01:50,759
here for free and freely copied which is

49
00:01:46,950 --> 00:01:53,460
what I wanted so here they are and what

50
00:01:50,759 --> 00:01:55,829
I what I wanted to do today was I wanted

51
00:01:53,459 --> 00:01:58,139
to get us loading WAV files so that we

52
00:01:55,828 --> 00:02:00,750
could have something to play back so

53
00:01:58,140 --> 00:02:02,129
that we could a finish up our asset

54
00:02:00,750 --> 00:02:03,509
loading system because our asset loading

55
00:02:02,129 --> 00:02:05,489
system is dealing with bitmaps now but

56
00:02:03,509 --> 00:02:07,170
it's not doing with WAV files so we kind

57
00:02:05,489 --> 00:02:08,939
of needed to push that out a little

58
00:02:07,170 --> 00:02:10,800
further but in order to have it deal

59
00:02:08,939 --> 00:02:13,439
with WAV files we are going to need to

60
00:02:10,800 --> 00:02:14,850
you have it some idea of what you wave

61
00:02:13,439 --> 00:02:16,859
files even our look we got to implement

62
00:02:14,849 --> 00:02:18,810
that because we didn't have that yet and

63
00:02:16,860 --> 00:02:20,910
then also we're gonna want to make our

64
00:02:18,810 --> 00:02:22,890
own sound mixer and stuff and so we kind

65
00:02:20,909 --> 00:02:25,680
of need as a first step to any of that

66
00:02:22,889 --> 00:02:28,349
the ability to just load some kind of

67
00:02:25,680 --> 00:02:29,909
wave data in to work with and so what I

68
00:02:28,349 --> 00:02:31,109
chose for that is WAV files just because

69
00:02:29,909 --> 00:02:32,460
they're easy to produce just about

70
00:02:31,110 --> 00:02:36,300
anywhere and they are fairly

71
00:02:32,460 --> 00:02:38,270
straightforward to work with so they're

72
00:02:36,300 --> 00:02:42,300
not quite as easy to read as being piece

73
00:02:38,270 --> 00:02:44,280
but they're pretty easy and so I'm gonna

74
00:02:42,300 --> 00:02:48,240
go ahead and show you how that worked we

75
00:02:44,280 --> 00:02:50,219
got started a little bit yesterday and

76
00:02:48,240 --> 00:02:52,320
by the way it's day 138 so if you've

77
00:02:50,219 --> 00:02:54,210
pre-ordered the source code at home you

78
00:02:52,319 --> 00:02:55,519
want to unpack day 137 source code

79
00:02:54,210 --> 00:02:58,710
that's what I'm working with now

80
00:02:55,520 --> 00:03:00,390
but anyway so if I go in here to our

81
00:02:58,710 --> 00:03:03,990
asset loader and I take a look at the

82
00:03:00,389 --> 00:03:06,000
load wave right there it is somebody was

83
00:03:03,990 --> 00:03:07,800
saying that I did a miss type in here I

84
00:03:06,000 --> 00:03:09,300
don't remember which one it was they

85
00:03:07,800 --> 00:03:12,120
were saying that I was as I was making

86
00:03:09,300 --> 00:03:14,820
the the header I got one of the things

87
00:03:12,120 --> 00:03:18,239
wrong perhaps in the format chunk I

88
00:03:14,819 --> 00:03:20,699
think but I'm not sure which one it was

89
00:03:18,239 --> 00:03:26,189
valid bits for samples so it's two - two

90
00:03:20,699 --> 00:03:28,169
- two - two - yes so block a line is two

91
00:03:26,189 --> 00:03:30,959
and I had it as four so thank you for

92
00:03:28,169 --> 00:03:33,539
catching that saves a little bit of

93
00:03:30,959 --> 00:03:34,979
debugging work here but yeah so what we

94
00:03:33,539 --> 00:03:36,090
did yesterday is we just kind of started

95
00:03:34,979 --> 00:03:38,340
with the basis we really didn't do

96
00:03:36,090 --> 00:03:41,819
anything all we did was start to copy in

97
00:03:38,340 --> 00:03:44,159
the the sort of structure of a wave file

98
00:03:41,819 --> 00:03:46,259
in here and so I'm gonna go ahead and

99
00:03:44,159 --> 00:03:48,419
kind of pull this stuff up a little bit

100
00:03:46,259 --> 00:03:49,739
into the same location as we define our

101
00:03:48,419 --> 00:03:52,109
bitmap stuff so that it can be inside

102
00:03:49,739 --> 00:03:53,250
the same pragma pack there because again

103
00:03:52,110 --> 00:03:55,170
we want to make sure that these are

104
00:03:53,250 --> 00:03:57,840
pragma pack 1 so if the compiler doesn't

105
00:03:55,169 --> 00:03:59,458
insert any additional spacing so for

106
00:03:57,840 --> 00:04:03,420
example if you take a look in here right

107
00:03:59,459 --> 00:04:09,239
these you in 16 they would actually get

108
00:04:03,419 --> 00:04:11,759
padded out probably to thirty twos at

109
00:04:09,239 --> 00:04:12,950
some point well in this case they

110
00:04:11,759 --> 00:04:15,509
probably wouldn't because they're packed

111
00:04:12,949 --> 00:04:18,509
okay so actually to be honest this this

112
00:04:15,509 --> 00:04:21,689
probably wouldn't changed but just in

113
00:04:18,509 --> 00:04:23,069
case I want to make sure that it

114
00:04:21,689 --> 00:04:24,100
wouldn't so I'm gonna go ahead and put

115
00:04:23,069 --> 00:04:25,930
that in the private pack so

116
00:04:24,100 --> 00:04:28,420
compiler doesn't fuss around with it at

117
00:04:25,930 --> 00:04:29,980
all so anyway what I'd like to do now is

118
00:04:28,420 --> 00:04:32,319
I'd like to go ahead and find a way to

119
00:04:29,980 --> 00:04:33,879
test this stuff and so what I'm going to

120
00:04:32,319 --> 00:04:35,649
do is I'm just going to insert so that

121
00:04:33,879 --> 00:04:37,420
we can start testing and not have to

122
00:04:35,649 --> 00:04:38,649
worry about running the game and doing

123
00:04:37,420 --> 00:04:41,110
anything in particular

124
00:04:38,649 --> 00:04:42,669
in right when we actually do our update

125
00:04:41,110 --> 00:04:47,080
and render call right at the beginning

126
00:04:42,670 --> 00:04:49,210
of that I'm just going to make it do a

127
00:04:47,079 --> 00:04:51,839
debug load wave right there right so I'm

128
00:04:49,209 --> 00:04:56,979
just gonna have it do a loaded sound

129
00:04:51,839 --> 00:04:58,239
like so and I'm gonna have it load some

130
00:04:56,980 --> 00:05:00,520
sound out of here

131
00:04:58,240 --> 00:05:05,350
say bloop zero zero or something like

132
00:05:00,519 --> 00:05:07,060
this so bloop zero zero that Wow and

133
00:05:05,350 --> 00:05:09,490
that way I can set a breakpoint and have

134
00:05:07,060 --> 00:05:11,769
it just kind of you know start right out

135
00:05:09,490 --> 00:05:14,889
at the code that we're trying to test so

136
00:05:11,769 --> 00:05:17,319
that we can you know be more efficient

137
00:05:14,889 --> 00:05:18,879
about the testing since presumably we're

138
00:05:17,319 --> 00:05:21,490
gonna have to debug some stuff and test

139
00:05:18,879 --> 00:05:24,879
some stuff right so what I'd like to do

140
00:05:21,490 --> 00:05:27,280
is I'd like to go ahead and step in to

141
00:05:24,879 --> 00:05:29,800
break that to step into that our well

142
00:05:27,279 --> 00:05:31,449
looks like I named I think debug load

143
00:05:29,800 --> 00:05:36,069
wave my bad

144
00:05:31,449 --> 00:05:37,990
let's try that again build I wonder if

145
00:05:36,069 --> 00:05:40,540
that should actually be the name debug

146
00:05:37,990 --> 00:05:43,750
load sound what did I actually call the

147
00:05:40,540 --> 00:05:46,510
other one what did I call debug load BMP

148
00:05:43,750 --> 00:05:52,689
was it BMP it is BMP all right so debug

149
00:05:46,509 --> 00:05:55,959
load wave is correct debug load lab so

150
00:05:52,689 --> 00:05:58,420
as I run this let's just make sure we

151
00:05:55,959 --> 00:05:59,919
get the whole file first we do and let's

152
00:05:58,420 --> 00:06:01,240
take a look at that header and see if

153
00:05:59,920 --> 00:06:04,390
we're actually getting something that we

154
00:06:01,240 --> 00:06:06,970
think makes some sense so here is our

155
00:06:04,389 --> 00:06:10,329
display here that size parameter looks

156
00:06:06,970 --> 00:06:12,790
in theoretically correct and let's take

157
00:06:10,329 --> 00:06:17,409
a look and see if the Rif ID makes sense

158
00:06:12,790 --> 00:06:20,500
right what's our know what that's why is

159
00:06:17,410 --> 00:06:22,090
it inserting two of those that's really

160
00:06:20,500 --> 00:06:25,959
annoying when did it start doing that

161
00:06:22,089 --> 00:06:30,159
did you see that when I hit one of those

162
00:06:25,959 --> 00:06:32,319
it inserts two of them that's awful whoo

163
00:06:30,160 --> 00:06:33,880
who thought that was a good idea I don't

164
00:06:32,319 --> 00:06:36,759
know what that is but I wish it would

165
00:06:33,879 --> 00:06:37,860
stop anyway you can see we have our iff

166
00:06:36,759 --> 00:06:39,598
here

167
00:06:37,860 --> 00:06:43,530
and these are the character codes and

168
00:06:39,598 --> 00:06:45,538
hey there they are 42 49 46 46 so it

169
00:06:43,529 --> 00:06:48,089
looks like it does go in little-endian

170
00:06:45,538 --> 00:06:50,158
order like we surmise that it would so

171
00:06:48,089 --> 00:06:52,019
our macro is probably fine too and then

172
00:06:50,158 --> 00:07:02,788
we've got that wave ID there I believe

173
00:06:52,019 --> 00:07:04,560
that's just what is it W a V I don't

174
00:07:02,788 --> 00:07:06,509
think it's e I don't think it's e it

175
00:07:04,560 --> 00:07:10,848
might just be wave I forget what we said

176
00:07:06,509 --> 00:07:14,908
that it actually was in the actual

177
00:07:10,848 --> 00:07:19,918
loader here I don't know it is WAV e so

178
00:07:14,908 --> 00:07:21,779
yeah so 5741 5645 and so that is exactly

179
00:07:19,918 --> 00:07:23,788
what we would expected the header to

180
00:07:21,779 --> 00:07:26,250
have so that all looks good so our

181
00:07:23,788 --> 00:07:27,810
assertion should work they do so now we

182
00:07:26,250 --> 00:07:30,149
have to do is actually get down to the

183
00:07:27,810 --> 00:07:31,500
business of parsing the actual file

184
00:07:30,149 --> 00:07:33,839
obviously which is something that we

185
00:07:31,500 --> 00:07:37,439
want to be able to do so I'm gonna jump

186
00:07:33,839 --> 00:07:39,060
over here to that that function and I'm

187
00:07:37,439 --> 00:07:40,319
just gonna stop start implementing it

188
00:07:39,060 --> 00:07:44,990
now like I was saying on the other

189
00:07:40,319 --> 00:07:44,990
stream essentially what happens here is

190
00:07:47,778 --> 00:07:53,399
you've you've got these chunks in the

191
00:07:50,639 --> 00:07:55,829
file and those chunks say how big they

192
00:07:53,399 --> 00:07:57,989
are and so what we want to be able to do

193
00:07:55,829 --> 00:07:59,848
is we want to be able to have like

194
00:07:57,990 --> 00:08:02,788
convenient perhaps a little cursor that

195
00:07:59,848 --> 00:08:04,459
we can kind of move around that will

196
00:08:02,788 --> 00:08:07,079
just help us with the bookkeeping of

197
00:08:04,459 --> 00:08:09,478
reading through the file so what I'm

198
00:08:07,079 --> 00:08:13,198
gonna do is I'm gonna have something

199
00:08:09,478 --> 00:08:15,689
like a RIF iterator and remember these

200
00:08:13,199 --> 00:08:17,639
are with file format is the file format

201
00:08:15,689 --> 00:08:21,778
that we're talking about and what I want

202
00:08:17,639 --> 00:08:24,120
to do there is I want to have a pointer

203
00:08:21,778 --> 00:08:26,968
to some bits which is just where we

204
00:08:24,120 --> 00:08:31,050
currently are in the file and then I

205
00:08:26,968 --> 00:08:33,389
also want to have something that I guess

206
00:08:31,050 --> 00:08:36,448
that lets me know what my current RIF

207
00:08:33,389 --> 00:08:39,778
chunk actually is and you can see that

208
00:08:36,448 --> 00:08:42,359
we've got these these sort of wave chunk

209
00:08:39,778 --> 00:08:45,389
things here so I kind of want to have

210
00:08:42,360 --> 00:08:46,639
whatever the current chunk is as well if

211
00:08:45,389 --> 00:08:49,649
that makes sense

212
00:08:46,639 --> 00:08:52,198
so let's start off with that I'm gonna

213
00:08:49,649 --> 00:08:53,818
go ahead and say once we parse that

214
00:08:52,198 --> 00:08:58,139
I'm gonna say that we have our riff

215
00:08:53,818 --> 00:08:59,628
iterator and tears are our riff or I

216
00:08:58,139 --> 00:09:04,528
definitely let's call it hitter right

217
00:08:59,629 --> 00:09:07,709
and the inner is going to assume that I

218
00:09:04,528 --> 00:09:10,708
guess we could do parse chunk at

219
00:09:07,708 --> 00:09:13,198
something like that and when I do parse

220
00:09:10,708 --> 00:09:16,109
chunk at I'm going to say I want you to

221
00:09:13,198 --> 00:09:19,378
start at header plus 1 which is just

222
00:09:16,110 --> 00:09:21,568
whatever's right after the header and

223
00:09:19,379 --> 00:09:23,249
and I want you to assume that that is

224
00:09:21,568 --> 00:09:25,528
the chunk that we're gonna start working

225
00:09:23,249 --> 00:09:29,009
on ok so again what I'm doing here is

226
00:09:25,528 --> 00:09:32,909
just making a little utility that I hope

227
00:09:29,009 --> 00:09:35,220
will be useful in making it easy to read

228
00:09:32,909 --> 00:09:36,539
this this thing right so I'd have

229
00:09:35,220 --> 00:09:38,699
something like that in fact you know

230
00:09:36,539 --> 00:09:40,289
I'll just go ahead and and read they

231
00:09:38,698 --> 00:09:43,169
used to do the usage code first like I

232
00:09:40,289 --> 00:09:44,730
normally say so if we do this something

233
00:09:43,169 --> 00:09:46,828
like this I'd probably want to write a

234
00:09:44,730 --> 00:09:49,589
for loop say you know parse the chunk

235
00:09:46,828 --> 00:09:52,888
there and then I'd want to do something

236
00:09:49,589 --> 00:09:56,879
like is valid you know and then I'd want

237
00:09:52,889 --> 00:09:59,539
to do I guess just get to the next chunk

238
00:09:56,879 --> 00:10:01,800
write it or equals the next chunk

239
00:09:59,539 --> 00:10:04,500
something like that something that just

240
00:10:01,799 --> 00:10:06,359
moves through those chunks like so and

241
00:10:04,500 --> 00:10:08,698
so this would just be each chunk would

242
00:10:06,360 --> 00:10:12,509
kind of be a thing right then we could

243
00:10:08,698 --> 00:10:14,698
switch on whatever the chunk actually

244
00:10:12,509 --> 00:10:17,339
had is it's tight right so I could do

245
00:10:14,698 --> 00:10:20,909
something like like this switch on get

246
00:10:17,339 --> 00:10:22,529
type and then I could have the different

247
00:10:20,909 --> 00:10:26,129
types in here that I wanted to check

248
00:10:22,528 --> 00:10:28,740
right so if I had something like a

249
00:10:26,129 --> 00:10:30,480
format chunk I could get that and I

250
00:10:28,740 --> 00:10:32,490
think let's just take a quick scan

251
00:10:30,480 --> 00:10:35,688
through the file format here and see

252
00:10:32,490 --> 00:10:42,209
what the other chunks are that we need

253
00:10:35,688 --> 00:10:43,049
mmm a fact chunk I don't think we care

254
00:10:42,208 --> 00:10:44,278
about because we're not going to read

255
00:10:43,049 --> 00:10:45,828
compress for your files we're just

256
00:10:44,278 --> 00:10:48,360
reading regular WAV files at the moment

257
00:10:45,828 --> 00:10:50,308
the data chunk looks like what we want

258
00:10:48,360 --> 00:10:52,528
for the sample data which we want which

259
00:10:50,308 --> 00:10:57,240
we definitely want to be able to read

260
00:10:52,528 --> 00:11:01,678
right so let's go ahead and and and get

261
00:10:57,240 --> 00:11:03,330
that that's dat a lowercase so that

262
00:11:01,678 --> 00:11:12,819
would be in here

263
00:11:03,330 --> 00:11:15,100
Eata and so we'd have that one and what

264
00:11:12,820 --> 00:11:23,850
else we have here

265
00:11:15,100 --> 00:11:29,259
PCM data is is inside here WAV format

266
00:11:23,850 --> 00:11:30,790
the cheque size pad bytes so that these

267
00:11:29,259 --> 00:11:36,309
are just examples these are not

268
00:11:30,789 --> 00:11:39,490
additional chunks yeah so I think that

269
00:11:36,309 --> 00:11:42,549
may be it that really may be all there

270
00:11:39,490 --> 00:11:44,139
is that we actually care about so all we

271
00:11:42,549 --> 00:11:45,879
have to read is we have to read a format

272
00:11:44,139 --> 00:11:48,069
chunk which will tell us what we're

273
00:11:45,879 --> 00:11:50,919
looking at and then a data chunk which

274
00:11:48,070 --> 00:11:53,980
will actually have the the actual sound

275
00:11:50,919 --> 00:11:56,049
information in it and so I think that's

276
00:11:53,980 --> 00:11:58,420
really all we would need to do so maybe

277
00:11:56,049 --> 00:12:01,419
we'll just go ahead and get that going

278
00:11:58,419 --> 00:12:04,029
here so if we have that then what I want

279
00:12:01,419 --> 00:12:06,729
to do here is say get me the actual data

280
00:12:04,029 --> 00:12:08,889
for this this format shop as one of

281
00:12:06,730 --> 00:12:14,800
these right so I could do something like

282
00:12:08,889 --> 00:12:17,379
WAV format FM t equals get you know get

283
00:12:14,799 --> 00:12:20,919
chunk data and I'll just say that I want

284
00:12:17,379 --> 00:12:24,759
a WAV format out of that iterator like

285
00:12:20,919 --> 00:12:27,759
so and then when I have the data chunk

286
00:12:24,759 --> 00:12:31,179
here same thing although I guess the

287
00:12:27,759 --> 00:12:33,189
data chunk itself doesn't really have

288
00:12:31,179 --> 00:12:36,189
anything in it other than just the bits

289
00:12:33,190 --> 00:12:41,130
right and so what I want to do there is

290
00:12:36,190 --> 00:12:48,070
is probably something like this data or

291
00:12:41,129 --> 00:12:55,809
sample data equals get chunk data like

292
00:12:48,070 --> 00:12:57,490
so write something like this yeah yeah

293
00:12:55,809 --> 00:12:59,079
so we'll go a little bit further with

294
00:12:57,490 --> 00:13:01,720
this in a second but that looks like

295
00:12:59,080 --> 00:13:03,400
roughly what I want and so then we'd

296
00:13:01,720 --> 00:13:05,560
save the sample data out here right so

297
00:13:03,399 --> 00:13:07,779
there's our sample data ok so let's take

298
00:13:05,559 --> 00:13:09,279
a look at what's going on there so for

299
00:13:07,779 --> 00:13:10,389
our first chunk out what we want to do

300
00:13:09,279 --> 00:13:13,870
is create one of these little riff

301
00:13:10,389 --> 00:13:15,159
iterators right that we can use and what

302
00:13:13,870 --> 00:13:16,360
it's going to do is assume that it's

303
00:13:15,159 --> 00:13:19,240
pointing

304
00:13:16,360 --> 00:13:25,200
at an actual one of you know at

305
00:13:19,240 --> 00:13:28,690
something useful here like so wait chunk

306
00:13:25,200 --> 00:13:31,990
and that's really all it needs to do for

307
00:13:28,690 --> 00:13:35,080
now and then we can return that result

308
00:13:31,990 --> 00:13:37,480
and I guess there's one of the things

309
00:13:35,080 --> 00:13:40,180
that I do need to do which is it needs

310
00:13:37,480 --> 00:13:42,460
to know when it would be out of space if

311
00:13:40,179 --> 00:13:44,589
that makes sense so it also would need

312
00:13:42,460 --> 00:13:47,759
and here are some it would need to use

313
00:13:44,590 --> 00:13:50,560
the size of this thing to know you know

314
00:13:47,759 --> 00:13:52,960
when it runs out of room if that makes

315
00:13:50,559 --> 00:13:55,179
sense so we'll take a look at that in a

316
00:13:52,960 --> 00:13:56,259
second as well so then we've got a next

317
00:13:55,179 --> 00:13:58,719
chunk which is something that would

318
00:13:56,259 --> 00:14:02,559
advance one chunk forward so here's riff

319
00:13:58,720 --> 00:14:05,710
iterator next chunk likes em off there's

320
00:14:02,559 --> 00:14:08,559
our input iterator and so what I want to

321
00:14:05,710 --> 00:14:11,650
do there is I want to say okay the app

322
00:14:08,559 --> 00:14:16,119
pointer at this point now is going to

323
00:14:11,649 --> 00:14:18,970
advance by whatever the chunk size was

324
00:14:16,120 --> 00:14:20,740
right it's gonna go ahead and move

325
00:14:18,970 --> 00:14:24,430
forward by that now what I don't know is

326
00:14:20,740 --> 00:14:29,320
if the size includes the header it looks

327
00:14:24,429 --> 00:14:32,189
like it doesn't to me it looks like the

328
00:14:29,320 --> 00:14:38,410
size is like how much is is like after

329
00:14:32,190 --> 00:14:40,960
right is after the header part we see if

330
00:14:38,409 --> 00:14:43,929
anyone says that specifically I don't

331
00:14:40,960 --> 00:14:47,730
know if they do or not but like for

332
00:14:43,929 --> 00:14:50,949
example it says chunk size is 16

333
00:14:47,730 --> 00:14:53,409
potentially and so if the chunk size was

334
00:14:50,950 --> 00:14:54,970
16 that means you could only have 8 that

335
00:14:53,409 --> 00:14:59,019
means that would be the biggest it could

336
00:14:54,970 --> 00:15:01,779
possibly be at 16 because if you had

337
00:14:59,019 --> 00:15:03,490
here's 8 and here is 8 I get actually

338
00:15:01,779 --> 00:15:06,159
it's it's less than that you would only

339
00:15:03,490 --> 00:15:08,669
you would only have that much right so I

340
00:15:06,159 --> 00:15:11,469
think the chunk size is only is

341
00:15:08,669 --> 00:15:13,539
non-inclusive of that wave chunk header

342
00:15:11,470 --> 00:15:15,519
so what I want to do here is say that

343
00:15:13,539 --> 00:15:17,439
we're gonna advance and this is just a

344
00:15:15,519 --> 00:15:20,079
kind of guess but that seems like dead

345
00:15:17,440 --> 00:15:21,640
reckoning what what that would be so I

346
00:15:20,080 --> 00:15:26,370
want to go ahead and do it that way

347
00:15:21,639 --> 00:15:26,370
right something like that

348
00:15:26,539 --> 00:15:35,899
I think that looks good I'll put in a

349
00:15:33,620 --> 00:15:37,549
stop parameter there so we do parse

350
00:15:35,899 --> 00:15:43,100
chunk out I'm gonna do something like

351
00:15:37,549 --> 00:15:45,019
this right so now we have two pointers

352
00:15:43,100 --> 00:15:47,029
one that's where we're at one where we

353
00:15:45,019 --> 00:15:50,029
want to stop then we can go ahead and do

354
00:15:47,029 --> 00:15:52,939
our next chunk stuff and then I'll just

355
00:15:50,029 --> 00:15:54,799
do a thing here where the is valid on

356
00:15:52,940 --> 00:15:57,710
the iterator right to know whether or

357
00:15:54,799 --> 00:16:00,289
not the iterator is valid or not

358
00:15:57,710 --> 00:16:02,000
what did I do I forgot some kind of

359
00:16:00,289 --> 00:16:04,059
something here Mighty Max is not

360
00:16:02,000 --> 00:16:11,210
indenting why is it indenting their

361
00:16:04,059 --> 00:16:16,069
compiler tell me there it is let's see

362
00:16:11,210 --> 00:16:19,129
oops sighs oh yeah so in here in my is

363
00:16:16,070 --> 00:16:21,650
valid right all I'm gonna do is I'm

364
00:16:19,129 --> 00:16:24,470
going to take this riff iterator and I'm

365
00:16:21,649 --> 00:16:26,750
just gonna see whether or not the app is

366
00:16:24,470 --> 00:16:29,420
underneath is lower than the stopping

367
00:16:26,750 --> 00:16:31,399
point right so the result is just gonna

368
00:16:29,419 --> 00:16:33,889
be if the inner at is less than the

369
00:16:31,399 --> 00:16:34,309
inner stop and if it is then we're all

370
00:16:33,889 --> 00:16:36,649
good

371
00:16:34,309 --> 00:16:39,500
if it's not then well we're not so good

372
00:16:36,649 --> 00:16:41,929
right so that'll let us either iterate

373
00:16:39,500 --> 00:16:44,539
through these guys and that means that

374
00:16:41,929 --> 00:16:47,959
when I do parse chunk at I also have to

375
00:16:44,539 --> 00:16:50,779
do you know something like say you know

376
00:16:47,960 --> 00:16:53,660
something like this where I'm gonna go

377
00:16:50,779 --> 00:16:55,730
ahead and say whatever the the data was

378
00:16:53,659 --> 00:16:57,709
where I was starting we're gonna go

379
00:16:55,730 --> 00:16:59,450
however big the header says after that

380
00:16:57,710 --> 00:17:00,950
right and I again I don't know if that's

381
00:16:59,450 --> 00:17:01,820
inclusive or not so in other words I

382
00:17:00,950 --> 00:17:04,400
don't know whether it should be header

383
00:17:01,820 --> 00:17:05,930
plus 1 or just header here + Enter sighs

384
00:17:04,400 --> 00:17:08,390
that's something that I couldn't quite

385
00:17:05,930 --> 00:17:09,680
see in the docs but we'll be able to

386
00:17:08,390 --> 00:17:12,890
figure it out when we actually step

387
00:17:09,680 --> 00:17:14,870
through it and then we'll be fine all

388
00:17:12,890 --> 00:17:16,370
right so then we've got a little thing

389
00:17:14,869 --> 00:17:18,500
here and I guess now that I look at it

390
00:17:16,369 --> 00:17:20,209
because we only use one of these I was

391
00:17:18,500 --> 00:17:21,589
gonna do a little type safety thing here

392
00:17:20,210 --> 00:17:22,880
but we really don't need to because it

393
00:17:21,589 --> 00:17:25,549
turns out that we really don't ever call

394
00:17:22,880 --> 00:17:28,310
this in any particular way so anyway

395
00:17:25,549 --> 00:17:30,319
what we want to do here is just say that

396
00:17:28,309 --> 00:17:32,089
get chunk data is something that gives

397
00:17:30,319 --> 00:17:35,960
back whatever the contents of the chunk

398
00:17:32,089 --> 00:17:39,049
was right oops again with that annoying

399
00:17:35,960 --> 00:17:39,650
insert there so what I want to do is say

400
00:17:39,049 --> 00:17:41,569
if

401
00:17:39,650 --> 00:17:42,950
you asked me on an iterator what the

402
00:17:41,569 --> 00:17:44,179
chunk data is also I suppose these

403
00:17:42,950 --> 00:17:46,039
should all be in line they're tiny

404
00:17:44,180 --> 00:17:47,960
little they're really just utilities

405
00:17:46,039 --> 00:17:51,680
they don't do anything so they should

406
00:17:47,960 --> 00:17:53,750
probably be inlined completely so get

407
00:17:51,680 --> 00:17:56,150
chunk data is going to go ahead and

408
00:17:53,750 --> 00:17:58,849
return that app pointer

409
00:17:56,150 --> 00:18:00,080
plus the just a header part right so

410
00:17:58,849 --> 00:18:03,679
it's going to be whatever is after the

411
00:18:00,079 --> 00:18:05,809
header is presumably the actual data

412
00:18:03,680 --> 00:18:12,590
that the chunk contains right that's the

413
00:18:05,809 --> 00:18:15,619
specification all right so get type is

414
00:18:12,589 --> 00:18:18,889
going to give us back some kind of a um

415
00:18:15,619 --> 00:18:22,279
32 that says what the type is now the

416
00:18:18,890 --> 00:18:24,200
wave chunk itself I don't remember how

417
00:18:22,279 --> 00:18:28,609
this actually worked let's take a look

418
00:18:24,200 --> 00:18:31,250
here it looks like the wave chunk has an

419
00:18:28,609 --> 00:18:34,429
ID in a size so what we want to do there

420
00:18:31,250 --> 00:18:36,559
is we want to return that ID right so we

421
00:18:34,430 --> 00:18:40,549
want to be able to say that the result

422
00:18:36,559 --> 00:18:42,500
here is the iterator chunk ID right and

423
00:18:40,549 --> 00:18:45,799
then we can return that and that should

424
00:18:42,500 --> 00:18:48,529
tell us what it is all right so let's

425
00:18:45,799 --> 00:18:51,109
take a look at how we did in terms of

426
00:18:48,529 --> 00:18:53,149
our first pass and and shake try to

427
00:18:51,109 --> 00:18:55,819
shake the bugs out a little bit here so

428
00:18:53,150 --> 00:18:57,560
we go ahead and read that in and then

429
00:18:55,819 --> 00:19:00,200
we're gonna we're going to start to

430
00:18:57,559 --> 00:19:02,899
parse this file so we we produce an

431
00:19:00,200 --> 00:19:05,690
iterator here and let's see what the

432
00:19:02,900 --> 00:19:08,600
iterator says it's got a chunk the chunk

433
00:19:05,690 --> 00:19:10,610
ID is is this right here I don't

434
00:19:08,599 --> 00:19:12,980
actually know what our various chunk IDs

435
00:19:10,609 --> 00:19:14,839
actually are but I suppose you know what

436
00:19:12,980 --> 00:19:17,870
I could do is something like this I

437
00:19:14,839 --> 00:19:19,000
could just do a Cara star and I could do

438
00:19:17,869 --> 00:19:29,319
chunk

439
00:19:19,000 --> 00:19:29,319
ID like oops Peter chunk ID right

440
00:19:29,609 --> 00:19:34,319
there we go and so if we take a look at

441
00:19:33,058 --> 00:19:36,389
this that will show us what the ID

442
00:19:34,319 --> 00:19:37,710
actually is right and of course it's

443
00:19:36,390 --> 00:19:39,330
where we're at as well so I guess I

444
00:19:37,710 --> 00:19:40,769
could have just used that now that I

445
00:19:39,329 --> 00:19:42,928
think about it points to the first thing

446
00:19:40,769 --> 00:19:45,150
but this is a little more specific so at

447
00:19:42,929 --> 00:19:48,240
least we know so the first one there is

448
00:19:45,150 --> 00:19:50,730
that format chunk so presumably we want

449
00:19:48,240 --> 00:19:53,308
to go ahead and go into this branch we

450
00:19:50,730 --> 00:19:54,990
actually do get that format chunk out so

451
00:19:53,308 --> 00:19:58,740
let's see if we can view it of course we

452
00:19:54,990 --> 00:20:00,390
can't because visual studio you know in

453
00:19:58,740 --> 00:20:02,099
their relentless upgrading to make

454
00:20:00,390 --> 00:20:03,480
things slower and less useful made it so

455
00:20:02,099 --> 00:20:06,178
that when you get to the closing brace

456
00:20:03,480 --> 00:20:08,579
of something you can't actually view any

457
00:20:06,179 --> 00:20:10,798
of its variables which is fantastic

458
00:20:08,579 --> 00:20:13,349
I think everyone deserves a big round of

459
00:20:10,798 --> 00:20:14,400
applause for that good job guys let's go

460
00:20:13,349 --> 00:20:19,678
ahead and insert something so they can

461
00:20:14,400 --> 00:20:21,780
actually read it there we go so now

462
00:20:19,679 --> 00:20:26,250
we're here in fmt let's see what

463
00:20:21,779 --> 00:20:28,129
everything says so here is our oops I

464
00:20:26,250 --> 00:20:32,609
did not mean to do that

465
00:20:28,130 --> 00:20:34,850
here is our spec for this wave 48

466
00:20:32,609 --> 00:20:37,849
kilohertz which is our audio sample rate

467
00:20:34,849 --> 00:20:39,839
we have two channels so it's stereo

468
00:20:37,849 --> 00:20:41,490
which actually I didn't know it was I

469
00:20:39,839 --> 00:20:43,829
didn't mean to make a stereo wave I

470
00:20:41,490 --> 00:20:46,289
guess it is a stereo wave we've got a

471
00:20:43,829 --> 00:20:48,960
format tag here which is gonna tell us

472
00:20:46,289 --> 00:20:50,428
which format it is hopefully that's PCM

473
00:20:48,960 --> 00:20:51,900
because that's the only thing that we're

474
00:20:50,429 --> 00:20:54,059
planning on reading but I believe I I

475
00:20:51,900 --> 00:20:56,610
didn't compress any of these I'll

476
00:20:54,058 --> 00:20:58,558
double-check here there was they had

477
00:20:56,609 --> 00:20:59,609
them listed somewhere so yeah that's PCM

478
00:20:58,558 --> 00:21:01,200
which is good

479
00:20:59,609 --> 00:21:03,109
I believe that stands for pulse code

480
00:21:01,200 --> 00:21:05,580
modulation which is the standard

481
00:21:03,109 --> 00:21:08,759
uncompressed audio file format we could

482
00:21:05,579 --> 00:21:10,829
talk about that in a second but what

483
00:21:08,759 --> 00:21:12,298
else what else do we have here

484
00:21:10,829 --> 00:21:14,369
block Ally we don't care about just

485
00:21:12,298 --> 00:21:15,418
saying it's aligned to four bytes which

486
00:21:14,369 --> 00:21:17,459
is fine

487
00:21:15,419 --> 00:21:19,710
we've got bits per sample at 16 which is

488
00:21:17,460 --> 00:21:22,079
what we want and then we've just got

489
00:21:19,710 --> 00:21:23,190
some some other stuff that we really

490
00:21:22,079 --> 00:21:24,779
just don't care about it all I don't

491
00:21:23,190 --> 00:21:25,890
think most of this stuff just shouldn't

492
00:21:24,779 --> 00:21:28,649
shouldn't matter too much to us I don't

493
00:21:25,890 --> 00:21:29,790
know what CV size actually develops for

494
00:21:28,650 --> 00:21:33,240
sample I don't know if we care about

495
00:21:29,789 --> 00:21:35,700
that stuff very much but anyway so the

496
00:21:33,240 --> 00:21:38,429
format chunk looks good let's go through

497
00:21:35,700 --> 00:21:40,259
here move to the next chunk we have

498
00:21:38,429 --> 00:21:41,880
another format chunk that doesn't seem

499
00:21:40,259 --> 00:21:44,250
right

500
00:21:41,880 --> 00:21:47,850
what did I do wrong I did something

501
00:21:44,250 --> 00:21:51,359
wrong unless we have to format chunks

502
00:21:47,849 --> 00:21:54,359
which just does not seem right yeah that

503
00:21:51,359 --> 00:21:58,589
seems busted what happened oh I know

504
00:21:54,359 --> 00:22:00,179
what happened I know what happened well

505
00:21:58,589 --> 00:22:03,629
and you know what we can fix this we

506
00:22:00,180 --> 00:22:05,460
should probably fix this right this this

507
00:22:03,630 --> 00:22:06,990
chunk thing here is a redundant pointer

508
00:22:05,460 --> 00:22:09,059
and of course I didn't update it when I

509
00:22:06,990 --> 00:22:11,160
actually went to move so I wonder if we

510
00:22:09,059 --> 00:22:13,109
should just get rid of that right just

511
00:22:11,160 --> 00:22:16,410
get rid of that entirely since at is the

512
00:22:13,109 --> 00:22:18,439
chunk header you know it we should

513
00:22:16,410 --> 00:22:21,810
probably just do something like this

514
00:22:18,440 --> 00:22:25,559
where we are just constantly looking at

515
00:22:21,809 --> 00:22:27,329
it this way since that's you know the

516
00:22:25,559 --> 00:22:30,179
majority of what we actually needed to

517
00:22:27,329 --> 00:22:32,220
do right that seems like a good idea to

518
00:22:30,180 --> 00:22:36,630
me so I'm gonna I'm gonna go ahead and

519
00:22:32,220 --> 00:22:39,089
say that for now and that will prevent

520
00:22:36,630 --> 00:22:43,290
us from doing something stupid like we

521
00:22:39,089 --> 00:22:45,389
did so there we go all right so let's go

522
00:22:43,289 --> 00:22:47,430
to the next type the next one's the data

523
00:22:45,390 --> 00:22:49,890
chunk which is where we get the sound

524
00:22:47,430 --> 00:22:51,870
samples from theirs it looks like

525
00:22:49,890 --> 00:22:54,300
there's some others in there but just

526
00:22:51,869 --> 00:22:55,769
one other one and we didn't read it it

527
00:22:54,299 --> 00:22:57,659
was not a type we understood and that's

528
00:22:55,769 --> 00:22:59,819
fine maybe let's go through there and

529
00:22:57,660 --> 00:23:01,740
just see what the type actually was just

530
00:22:59,819 --> 00:23:04,769
for our own edification there's the data

531
00:23:01,740 --> 00:23:06,569
chunk and so now in here let's take a

532
00:23:04,769 --> 00:23:11,609
look and see what that that chunk

533
00:23:06,569 --> 00:23:13,200
actually is at it looks like zero so

534
00:23:11,609 --> 00:23:15,409
that's a little bit odd I wonder why

535
00:23:13,200 --> 00:23:22,650
we're at a zero chunk does that mean

536
00:23:15,410 --> 00:23:29,820
that we oh we're mmm well we're four

537
00:23:22,650 --> 00:23:31,590
bytes from the end is there some kind of

538
00:23:29,819 --> 00:23:33,980
a specification that says that the file

539
00:23:31,589 --> 00:23:36,730
ends with zeros or something like this I

540
00:23:33,980 --> 00:23:40,630
wonder

541
00:23:36,730 --> 00:23:42,880
I wonder I just want to make sure we

542
00:23:40,630 --> 00:23:44,440
don't have a bug right if that's what's

543
00:23:42,880 --> 00:23:49,120
supposed to be there then that's totally

544
00:23:44,440 --> 00:23:51,400
fine but just just don't want to I just

545
00:23:49,119 --> 00:23:56,219
don't want to have any kind of a an

546
00:23:51,400 --> 00:23:58,750
error there let's see if I'll format

547
00:23:56,220 --> 00:24:02,589
right there are three variants of the

548
00:23:58,750 --> 00:24:04,179
chunk right the obsolete formats blah

549
00:24:02,589 --> 00:24:06,669
blah blah this doesn't really tell us

550
00:24:04,179 --> 00:24:09,548
much about that I suppose we could take

551
00:24:06,670 --> 00:24:14,130
a look at one of these things well or

552
00:24:09,548 --> 00:24:20,889
maybe not take a look at this I guess

553
00:24:14,130 --> 00:24:24,669
let's see what's supposed to happen we

554
00:24:20,890 --> 00:24:32,040
got a big old document going on here

555
00:24:24,669 --> 00:24:37,020
resource interchange file format yeah

556
00:24:32,039 --> 00:24:43,000
yeah let's see I registered chunk types

557
00:24:37,019 --> 00:24:46,720
basic notation escape sequences blah

558
00:24:43,000 --> 00:24:48,210
blah blah blah blah storage strings we

559
00:24:46,720 --> 00:24:54,069
don't care about any of this stuff

560
00:24:48,210 --> 00:24:56,048
country code structural overview the C

561
00:24:54,069 --> 00:25:00,269
talked chunk we don't care about this

562
00:24:56,048 --> 00:25:03,789
stuff at all we just want to know really

563
00:25:00,269 --> 00:25:06,789
I just want to know what the end of the

564
00:25:03,789 --> 00:25:09,668
file should look like right I just want

565
00:25:06,789 --> 00:25:10,839
to kind of know if they've got anything

566
00:25:09,669 --> 00:25:14,590
that says specifically what should

567
00:25:10,839 --> 00:25:17,409
happen they're basically in a closed

568
00:25:14,589 --> 00:25:20,159
chunk a for CCS representative that's

569
00:25:17,410 --> 00:25:23,980
right yes I understand that

570
00:25:20,160 --> 00:25:26,440
yep I get that a reform is a chunk with

571
00:25:23,980 --> 00:25:27,910
a RIF chunk ID term also refers to a

572
00:25:26,440 --> 00:25:32,610
file format that files with framework

573
00:25:27,910 --> 00:25:34,800
that's all good let's see seek a size

574
00:25:32,609 --> 00:25:36,389
firm type

575
00:25:34,799 --> 00:25:38,279
yeah listen man attracts listen I was

576
00:25:36,390 --> 00:25:40,560
possibly a required order for the chunks

577
00:25:38,279 --> 00:25:43,079
defining you're registering them we

578
00:25:40,559 --> 00:25:44,490
don't care about that yeah so I don't

579
00:25:43,079 --> 00:25:48,839
see anything here that really talks

580
00:25:44,490 --> 00:25:53,240
about that the other part of it which is

581
00:25:48,839 --> 00:25:54,929
unfortunate because I guess I don't know

582
00:25:53,240 --> 00:25:56,970
hmm

583
00:25:54,930 --> 00:25:58,500
Hey look they said in Electronic Arts

584
00:25:56,970 --> 00:26:06,120
iff file which is what I was mentioning

585
00:25:58,500 --> 00:26:18,059
before let's see a counter part a little

586
00:26:06,119 --> 00:26:20,699
bit label yeah star this ticket is a

587
00:26:18,059 --> 00:26:23,129
word aligned with respect to the start

588
00:26:20,700 --> 00:26:25,920
of the riff file if the chunk size is an

589
00:26:23,130 --> 00:26:31,590
odd number of bytes a pad byte with a

590
00:26:25,920 --> 00:26:34,050
zero value is written after ck data so

591
00:26:31,589 --> 00:26:37,139
we're not really obeying that which is

592
00:26:34,049 --> 00:26:38,789
not good right so we probably should do

593
00:26:37,140 --> 00:26:41,580
that

594
00:26:38,789 --> 00:26:44,159
but that wouldn't really explain what

595
00:26:41,579 --> 00:26:47,429
we're seeing either that's like not

596
00:26:44,160 --> 00:26:49,400
sufficient right but you can see there

597
00:26:47,430 --> 00:26:51,810
we're not actually obeying that

598
00:26:49,400 --> 00:26:55,410
basically what it's saying is if the

599
00:26:51,809 --> 00:26:59,129
chunk size right if the chunk size would

600
00:26:55,410 --> 00:27:02,460
have been odd there then we have to you

601
00:26:59,130 --> 00:27:08,250
know Pat it out so you know something

602
00:27:02,460 --> 00:27:13,670
like you know size equals chunk size

603
00:27:08,250 --> 00:27:20,099
like so and then we need to do if sighs

604
00:27:13,670 --> 00:27:22,490
you know I guess and one we rounded up

605
00:27:20,099 --> 00:27:27,509
right or we could we could even do it

606
00:27:22,490 --> 00:27:29,970
something like this right just to round

607
00:27:27,509 --> 00:27:32,670
that size out and then we go ahead and

608
00:27:29,970 --> 00:27:35,430
advance by that instead that would be

609
00:27:32,670 --> 00:27:36,870
how we would be that that element of the

610
00:27:35,430 --> 00:27:39,450
specification but again that doesn't

611
00:27:36,869 --> 00:27:40,729
really answer our question at least it

612
00:27:39,450 --> 00:27:44,039
doesn't answer my question

613
00:27:40,730 --> 00:27:45,960
which is just why we were seeing what we

614
00:27:44,039 --> 00:27:48,250
were seeing there I suppose

615
00:27:45,960 --> 00:27:50,679
what it could be is if the header

616
00:27:48,250 --> 00:27:53,980
if I'm not correctly interpreting what

617
00:27:50,679 --> 00:27:57,070
that header size includes so what I what

618
00:27:53,980 --> 00:28:01,929
I might do here's here's what I might

619
00:27:57,069 --> 00:28:05,829
propose is happening so this chunk size

620
00:28:01,929 --> 00:28:09,370
here in the Rif thing right

621
00:28:05,829 --> 00:28:11,829
it does say 4 + n so maybe what they

622
00:28:09,369 --> 00:28:14,619
mean is this is not included and we we

623
00:28:11,829 --> 00:28:17,019
were including it right and so if we

624
00:28:14,619 --> 00:28:19,269
wanted to if that was the assumption

625
00:28:17,019 --> 00:28:21,730
that that would make sense that's

626
00:28:19,269 --> 00:28:23,980
probably what happened right so what we

627
00:28:21,730 --> 00:28:26,740
would want to do there is say okay the

628
00:28:23,980 --> 00:28:29,980
actual size of this thing in terms of

629
00:28:26,740 --> 00:28:32,140
stopping is going to be the header size

630
00:28:29,980 --> 00:28:35,159
minus 4 because we need to take out that

631
00:28:32,140 --> 00:28:39,100
that wave part that we skipped right

632
00:28:35,159 --> 00:28:42,640
that seems like maybe maybe the smarter

633
00:28:39,099 --> 00:28:44,949
way to go about it so let's see let's

634
00:28:42,640 --> 00:28:48,220
see now if that makes things a little

635
00:28:44,950 --> 00:28:50,500
cleaner so we'll jump in here there's

636
00:28:48,220 --> 00:28:52,659
our format chunk there's our data chunk

637
00:28:50,500 --> 00:28:54,069
and there's no other chunks so hey we

638
00:28:52,659 --> 00:28:55,360
don't even have to deal with we don't

639
00:28:54,069 --> 00:28:57,730
even have to really skip any chunks

640
00:28:55,359 --> 00:28:59,979
because it turns out that I saved these

641
00:28:57,730 --> 00:29:02,048
out of a program called goldwave it

642
00:28:59,980 --> 00:29:03,610
turns out that we don't actually have

643
00:29:02,048 --> 00:29:10,569
any other chunks other than the ones we

644
00:29:03,609 --> 00:29:13,928
specifically wanted okay so when we load

645
00:29:10,569 --> 00:29:17,019
this in here what I want to do is I want

646
00:29:13,929 --> 00:29:18,759
to now remember the actual salient data

647
00:29:17,019 --> 00:29:21,940
the the data that we actually wanted to

648
00:29:18,759 --> 00:29:26,230
get right and so what I'm going to do is

649
00:29:21,940 --> 00:29:28,120
I'm going to try to find specifically

650
00:29:26,230 --> 00:29:28,509
what what the data is that we're looking

651
00:29:28,119 --> 00:29:31,178
for

652
00:29:28,509 --> 00:29:33,339
I want to assert any of the stuff that

653
00:29:31,179 --> 00:29:35,590
you know we're just expecting these to

654
00:29:33,339 --> 00:29:37,658
be the correct format obviously so

655
00:29:35,589 --> 00:29:44,048
something like the WM Dobie before I tag

656
00:29:37,659 --> 00:29:46,990
we want to assert it's PCM right we want

657
00:29:44,048 --> 00:29:48,970
the the channel count we want the

658
00:29:46,990 --> 00:29:51,130
channel count to either be 1 or 2 we

659
00:29:48,970 --> 00:29:53,650
want the samples to per second to always

660
00:29:51,130 --> 00:29:55,750
be our preferred samples for a second

661
00:29:53,650 --> 00:29:58,210
and then we also want

662
00:29:55,750 --> 00:29:59,210
I guess the we don't care about the

663
00:29:58,210 --> 00:30:01,519
block aligned I guess

664
00:29:59,210 --> 00:30:03,620
think about it bits per sample left to

665
00:30:01,519 --> 00:30:08,898
look at see maybe we do we want the bits

666
00:30:03,619 --> 00:30:11,209
per sample to always be 16 right and I

667
00:30:08,898 --> 00:30:14,148
don't know what channel mask actually

668
00:30:11,210 --> 00:30:15,470
means speak your position math I don't

669
00:30:14,148 --> 00:30:17,658
think we care about that

670
00:30:15,470 --> 00:30:20,690
now we don't care about sub format so

671
00:30:17,659 --> 00:30:23,570
what is any block a line data block size

672
00:30:20,690 --> 00:30:25,940
in bytes like what does that mean

673
00:30:23,569 --> 00:30:29,859
is there some documentation for what M

674
00:30:25,940 --> 00:30:32,000
block a line actually means here we go

675
00:30:29,859 --> 00:30:33,408
the first part of the format chunk

676
00:30:32,000 --> 00:30:34,909
reduce noise PCM data after boosting day

677
00:30:33,409 --> 00:30:36,169
at the format chunk in the header

678
00:30:34,909 --> 00:30:37,850
declares the number of bits per sample

679
00:30:36,169 --> 00:30:39,169
we got that the original documentation

680
00:30:37,849 --> 00:30:40,908
specified that the number of bits per

681
00:30:39,169 --> 00:30:43,070
sample to be rounded up to the next

682
00:30:40,909 --> 00:30:44,480
multiple of 8 bits this rounded values a

683
00:30:43,069 --> 00:30:46,428
container size this information is

684
00:30:44,480 --> 00:30:47,990
redundant in the container for each

685
00:30:46,429 --> 00:30:49,970
sample can also be determined from the

686
00:30:47,990 --> 00:30:52,419
block size divided by the number of

687
00:30:49,970 --> 00:30:54,589
channels ok this redundancy has been

688
00:30:52,419 --> 00:30:55,880
appropriated to define new formats for

689
00:30:54,589 --> 00:30:57,678
example Cool Edit use the four which

690
00:30:55,880 --> 00:30:58,880
declares the sample size of 24 bits the

691
00:30:57,679 --> 00:31:00,860
other looking at size of 4 bytes

692
00:30:58,880 --> 00:31:05,020
determine from the block size and of our

693
00:31:00,859 --> 00:31:09,079
channels with this combination huh ok

694
00:31:05,019 --> 00:31:12,019
well alright so I guess in block a line

695
00:31:09,079 --> 00:31:13,759
divided by a number of channels tells us

696
00:31:12,019 --> 00:31:16,009
how many bits per sample it actually is

697
00:31:13,759 --> 00:31:18,528
is the idea or how many bytes per sample

698
00:31:16,009 --> 00:31:22,640
I should say so I guess we want to

699
00:31:18,528 --> 00:31:27,500
basically say that that that end block

700
00:31:22,640 --> 00:31:29,929
aligned has to be either 2 or 4 right

701
00:31:27,500 --> 00:31:32,390
we basically want it to be however many

702
00:31:29,929 --> 00:31:33,890
channels there are we want and block the

703
00:31:32,390 --> 00:31:35,419
line to be the number of channels times

704
00:31:33,890 --> 00:31:38,720
2 because we're saying it's got to be 16

705
00:31:35,419 --> 00:31:41,299
bit right so we essentially want to to

706
00:31:38,720 --> 00:31:42,620
guarantee that we have 16 bits per

707
00:31:41,298 --> 00:31:43,970
channel because that's the only thing

708
00:31:42,619 --> 00:31:45,439
that we're going to support so we

709
00:31:43,970 --> 00:31:46,278
distort that we have all of those things

710
00:31:45,440 --> 00:31:48,769
to be true

711
00:31:46,278 --> 00:31:50,419
right and then really the only

712
00:31:48,769 --> 00:31:53,119
information that I think we need here is

713
00:31:50,419 --> 00:31:55,970
the number of channels so I'm gonna have

714
00:31:53,119 --> 00:31:58,189
a channel count out here right and I'm

715
00:31:55,970 --> 00:32:01,038
gonna set that to 0 and here I'm going

716
00:31:58,190 --> 00:32:04,940
to say the channel count equals and

717
00:32:01,038 --> 00:32:06,679
channels like so I don't know that we

718
00:32:04,940 --> 00:32:07,860
care about any of these other things

719
00:32:06,679 --> 00:32:09,179
then

720
00:32:07,859 --> 00:32:10,798
I don't think we need to know anything

721
00:32:09,179 --> 00:32:11,820
else we just need that channel count

722
00:32:10,798 --> 00:32:14,639
because we're only supporting everything

723
00:32:11,819 --> 00:32:17,369
else this way then when we do the wave

724
00:32:14,640 --> 00:32:25,950
chunk ID data there what I'm going to do

725
00:32:17,369 --> 00:32:30,239
is I'm going to I'm going to go ahead

726
00:32:25,950 --> 00:32:31,920
and and grab out the actual wave data so

727
00:32:30,240 --> 00:32:34,500
the sample data I think just is just

728
00:32:31,920 --> 00:32:36,509
straight ahead in the actual I don't

729
00:32:34,500 --> 00:32:38,160
think the PCM does it actually does the

730
00:32:36,509 --> 00:32:40,200
PCM form and actually have anything else

731
00:32:38,160 --> 00:32:42,600
in it I don't think it does

732
00:32:40,200 --> 00:32:45,840
I think the PCM format literally is just

733
00:32:42,599 --> 00:32:46,949
a size and then the data yeah so so this

734
00:32:45,839 --> 00:32:49,949
is literally the data that we actually

735
00:32:46,950 --> 00:32:51,509
want and so there's our sampled data and

736
00:32:49,950 --> 00:32:54,509
so then we actually have everything that

737
00:32:51,509 --> 00:32:55,890
we need at the end of that to know and

738
00:32:54,509 --> 00:32:58,710
so what I'm going to do is I'm going to

739
00:32:55,890 --> 00:33:01,860
say assert right that the channel count

740
00:32:58,710 --> 00:33:04,769
and the sample data are both valid so we

741
00:33:01,859 --> 00:33:07,319
have an actual valid file and now I want

742
00:33:04,769 --> 00:33:09,839
to actually make that loaded sound thing

743
00:33:07,319 --> 00:33:12,509
right I wanted to make the load sound

744
00:33:09,839 --> 00:33:16,189
actually work so let's go ahead in here

745
00:33:12,509 --> 00:33:16,190
and say all right we've got loaded sound

746
00:33:16,640 --> 00:33:23,429
where is that what we're returning our

747
00:33:20,819 --> 00:33:24,928
result there it is we've got our result

748
00:33:23,429 --> 00:33:26,940
we need to know what the sample count is

749
00:33:24,929 --> 00:33:29,840
and we need to know where the memory is

750
00:33:26,940 --> 00:33:33,630
the memory is just the sample data right

751
00:33:29,839 --> 00:33:34,879
but I may want to do something with this

752
00:33:33,630 --> 00:33:36,980
first

753
00:33:34,880 --> 00:33:41,090
[Music]

754
00:33:36,980 --> 00:33:43,440
in fact I strongly suggest that I am I

755
00:33:41,089 --> 00:33:45,990
think what I would rather do is

756
00:33:43,440 --> 00:33:48,298
something like this let's just say that

757
00:33:45,990 --> 00:33:49,500
our samples or you know 16-bit samples

758
00:33:48,298 --> 00:33:50,910
or something like that this is the way

759
00:33:49,500 --> 00:33:53,730
it's working well you know what now to

760
00:33:50,910 --> 00:33:55,350
say they're voids and what I want to do

761
00:33:53,730 --> 00:33:57,150
is I want to introduce the concept that

762
00:33:55,349 --> 00:33:59,548
the loaded sound can have one or two

763
00:33:57,150 --> 00:34:01,048
channels so I'm gonna say that we have a

764
00:33:59,548 --> 00:34:03,750
channel counting here as well as a

765
00:34:01,048 --> 00:34:05,759
sample count and so you can you can

766
00:34:03,750 --> 00:34:07,798
actually have a stereo or announcer or

767
00:34:05,759 --> 00:34:09,148
mono sound I think we might just go

768
00:34:07,798 --> 00:34:10,378
ahead and support both of those for now

769
00:34:09,148 --> 00:34:11,730
like because music will probably want to

770
00:34:10,378 --> 00:34:13,019
come in stereo and sound effects will

771
00:34:11,730 --> 00:34:16,079
probably want to come in mono at the end

772
00:34:13,019 --> 00:34:18,239
of the day mm-hmm and that would also

773
00:34:16,079 --> 00:34:19,769
let us extend it to like Dolby fot you

774
00:34:18,239 --> 00:34:21,089
know if we wanted to have more channels

775
00:34:19,769 --> 00:34:21,389
in there it's obvious how it would

776
00:34:21,090 --> 00:34:23,159
happen

777
00:34:21,389 --> 00:34:25,378
rather than just having no I you know no

778
00:34:23,159 --> 00:34:28,619
plan for what we would do to solve that

779
00:34:25,378 --> 00:34:30,179
problem right so what I want to do here

780
00:34:28,619 --> 00:34:32,278
is I want to actually set this stuff up

781
00:34:30,179 --> 00:34:34,559
correctly then because we're gonna have

782
00:34:32,278 --> 00:34:36,059
to do a sort of a tedious whistling

783
00:34:34,559 --> 00:34:37,559
operation I guess the other thing I'd

784
00:34:36,059 --> 00:34:39,690
like to know is how do I determine the

785
00:34:37,559 --> 00:34:41,460
sample count - any weird rounding that

786
00:34:39,690 --> 00:34:45,000
they may have done does this stuff

787
00:34:41,460 --> 00:34:49,769
saying here how that would work in some

788
00:34:45,000 --> 00:34:51,659
way bits per sample or do am I just

789
00:34:49,768 --> 00:34:54,328
supposed to divide to figure it out like

790
00:34:51,659 --> 00:34:56,519
does the format chunk CB size size the

791
00:34:54,329 --> 00:34:58,798
extension that doesn't help us valid

792
00:34:56,518 --> 00:35:01,828
bits block size data rates sampling

793
00:34:58,798 --> 00:35:05,608
rates so you know it looks to me like we

794
00:35:01,829 --> 00:35:07,710
just have to divide to figure out what

795
00:35:05,608 --> 00:35:10,980
that sample - it is so it looks to me

796
00:35:07,710 --> 00:35:12,960
like the sample count right is going to

797
00:35:10,980 --> 00:35:15,269
be the channel count whatever the

798
00:35:12,960 --> 00:35:18,298
channel count actually is right it's

799
00:35:15,268 --> 00:35:23,038
going to be the channel count times size

800
00:35:18,298 --> 00:35:26,509
of unit 16 like so right I guess we

801
00:35:23,039 --> 00:35:28,619
should probably also use that up here

802
00:35:26,509 --> 00:35:29,699
that's what the sample counts going to

803
00:35:28,619 --> 00:35:31,680
be it's going to be the channel count

804
00:35:29,699 --> 00:35:35,699
size that you're in steam divided by

805
00:35:31,679 --> 00:35:37,739
however big the sample data was right so

806
00:35:35,699 --> 00:35:40,108
we need to also keep that sample data

807
00:35:37,739 --> 00:35:42,268
size in there right so I'm gonna go

808
00:35:40,108 --> 00:35:48,838
ahead and get that get chunk data size

809
00:35:42,268 --> 00:35:50,818
as well like that and in here when we do

810
00:35:48,838 --> 00:35:52,768
get chunk data I'm just gonna do another

811
00:35:50,818 --> 00:35:54,719
one here which is get chunk size

812
00:35:52,768 --> 00:36:01,889
actually I guess that would be this good

813
00:35:54,719 --> 00:36:04,230
chunk size and that is not inclusive of

814
00:36:01,889 --> 00:36:06,420
the header correct because we were yet

815
00:36:04,230 --> 00:36:08,460
it's not inclusive of the header so

816
00:36:06,420 --> 00:36:10,470
that's good all right so what we want to

817
00:36:08,460 --> 00:36:12,210
do here is we want to go ahead and say

818
00:36:10,469 --> 00:36:16,618
that we've got that that chunk size

819
00:36:12,210 --> 00:36:18,509
coming back so we can get it let's see

820
00:36:16,619 --> 00:36:22,410
get chunk data size I guess is what I

821
00:36:18,509 --> 00:36:24,119
said J design so if we get chunk data

822
00:36:22,409 --> 00:36:28,949
size now we have the sample data size as

823
00:36:24,119 --> 00:36:30,180
well sample data size and now we can

824
00:36:28,949 --> 00:36:31,259
actually go ahead and do this

825
00:36:30,179 --> 00:36:33,899
computation and figure out what our

826
00:36:31,259 --> 00:36:35,170
sample count is we then are going to

827
00:36:33,900 --> 00:36:40,440
need

828
00:36:35,170 --> 00:36:40,440
to create arrays for our sample data and

829
00:36:41,730 --> 00:36:51,039
if we only have one channel right

830
00:36:45,818 --> 00:36:52,599
so if our channel count equals one we

831
00:36:51,039 --> 00:36:57,298
don't have very much work to do if our

832
00:36:52,599 --> 00:37:05,380
channel count equals two we do invalid

833
00:36:57,298 --> 00:37:07,030
channel count and WAV file right so if

834
00:37:05,380 --> 00:37:12,130
the channel count is one this is really

835
00:37:07,030 --> 00:37:16,230
easy right results channel count equals

836
00:37:12,130 --> 00:37:19,329
channel count always good the samples

837
00:37:16,230 --> 00:37:22,179
are going to point to reasonable things

838
00:37:19,329 --> 00:37:24,460
here right the samples are going to

839
00:37:22,179 --> 00:37:26,048
point to the sample data in one case and

840
00:37:24,460 --> 00:37:28,298
0 and the other right because all the

841
00:37:26,048 --> 00:37:30,789
samples are in an order just the way we

842
00:37:28,298 --> 00:37:34,389
would want them to be stored but if it's

843
00:37:30,789 --> 00:37:37,449
if the sample count equals 2 I'm sorry

844
00:37:34,389 --> 00:37:39,159
the channel count equals 2 they're going

845
00:37:37,449 --> 00:37:41,439
to be interleaved like left right left

846
00:37:39,159 --> 00:37:43,029
right left right left right but we don't

847
00:37:41,440 --> 00:37:44,230
actually want that probably when we're

848
00:37:43,030 --> 00:37:47,019
dealing with them we want to be able to

849
00:37:44,230 --> 00:37:58,358
deal with each channel individually so

850
00:37:47,019 --> 00:38:01,179
what I'd rather do is unintel so in

851
00:37:58,358 --> 00:38:03,308
order to do that that's I don't know

852
00:38:01,179 --> 00:38:10,440
that there's a lot of ways to interleave

853
00:38:03,309 --> 00:38:12,940
to unintel I have to think about that

854
00:38:10,440 --> 00:38:24,068
gosh can you do a none interleave in

855
00:38:12,940 --> 00:38:25,630
place hmmm so let me talk about exactly

856
00:38:24,068 --> 00:38:27,009
what has to happen here I don't know

857
00:38:25,630 --> 00:38:28,510
that I have I don't think I have

858
00:38:27,010 --> 00:38:30,579
anything clever up my sleeve for this

859
00:38:28,510 --> 00:38:33,940
maybe somebody else out there does but I

860
00:38:30,579 --> 00:38:35,140
don't so here we are at day 138 and

861
00:38:33,940 --> 00:38:36,940
here's the problem that we're talking

862
00:38:35,139 --> 00:38:39,759
about what we would like to have is we

863
00:38:36,940 --> 00:38:43,230
would like to have two pointers right

864
00:38:39,760 --> 00:38:47,290
this is channel 0 this is channel 1

865
00:38:43,230 --> 00:38:48,820
samples and what I'd like to see right I

866
00:38:47,289 --> 00:38:50,800
would like to see

867
00:38:48,820 --> 00:38:54,160
my sample is looking like this left zero

868
00:38:50,800 --> 00:38:56,789
left 1 left 2 left three left four and

869
00:38:54,159 --> 00:38:59,889
then you know the same thing over here

870
00:38:56,789 --> 00:39:01,179
right zero right one right two right

871
00:38:59,889 --> 00:39:03,839
three right four

872
00:39:01,179 --> 00:39:07,210
right that's what I would like to see

873
00:39:03,840 --> 00:39:09,190
and so the problem is right now what we

874
00:39:07,210 --> 00:39:13,300
actually have is something that looks

875
00:39:09,190 --> 00:39:17,110
like this doo doo doo doo we've got some

876
00:39:13,300 --> 00:39:22,600
that looks like L 0 R 0 L 1 R 1 l 2 and

877
00:39:17,110 --> 00:39:24,550
so on right now the problem is this L 0

878
00:39:22,599 --> 00:39:26,199
and L 1 right if I wanted to D

879
00:39:24,550 --> 00:39:27,760
interleave just the left channel it

880
00:39:26,199 --> 00:39:31,480
wouldn't be very difficult because all I

881
00:39:27,760 --> 00:39:33,580
do you just go through and you know copy

882
00:39:31,480 --> 00:39:38,230
this L 1 into here and then I'd copy

883
00:39:33,579 --> 00:39:46,779
this L 2 back into here right that's not

884
00:39:38,230 --> 00:39:50,320
particularly difficult but if I want to

885
00:39:46,780 --> 00:39:52,180
like Unsworth all these things in place

886
00:39:50,320 --> 00:39:55,300
I'm not sure how I would actually do

887
00:39:52,179 --> 00:39:58,509
that like okay you know I would I guess

888
00:39:55,300 --> 00:40:03,180
swap those two and then move this I

889
00:39:58,510 --> 00:40:05,920
don't I don't know how you would do that

890
00:40:03,179 --> 00:40:07,299
probably would take more than one pass

891
00:40:05,920 --> 00:40:08,740
over the buffer I don't know it just

892
00:40:07,300 --> 00:40:11,230
seems ugly like how am I going to do

893
00:40:08,739 --> 00:40:13,750
that in place because what I want to do

894
00:40:11,230 --> 00:40:18,550
is sort it all so basically you know at

895
00:40:13,750 --> 00:40:20,230
the end this buffer basically is at the

896
00:40:18,550 --> 00:40:23,289
end of this buffer right so I can just

897
00:40:20,230 --> 00:40:26,619
point to here for my for my second

898
00:40:23,289 --> 00:40:29,559
channel so I kind of need to migrate all

899
00:40:26,619 --> 00:40:31,869
the ours out there while migrating the L

900
00:40:29,559 --> 00:40:33,639
once in while compacting the L ones in

901
00:40:31,869 --> 00:40:35,039
and I don't really see

902
00:40:33,639 --> 00:40:38,609
[Music]

903
00:40:35,039 --> 00:40:44,070
a smart way to do that right if if I

904
00:40:38,610 --> 00:40:46,650
swap if I do the swaps that's just gonna

905
00:40:44,070 --> 00:40:48,300
do weird stuff I would think I don't

906
00:40:46,650 --> 00:40:51,030
know maybe it doesn't so let's see what

907
00:40:48,300 --> 00:40:52,530
actually happens I'm just gonna see what

908
00:40:51,030 --> 00:40:54,540
happens here because I don't super

909
00:40:52,530 --> 00:40:59,280
understand it let's say this is the

910
00:40:54,539 --> 00:41:06,719
buffer right and let's say I've got L 0

911
00:40:59,280 --> 00:41:08,180
R 0 L 1 R 1 L 2 R 2 L 3 R 3 L 4 R for

912
00:41:06,719 --> 00:41:10,439
like this

913
00:41:08,179 --> 00:41:12,000
so what we're at what would happen if

914
00:41:10,440 --> 00:41:16,139
all I did was just winning a straight-up

915
00:41:12,000 --> 00:41:20,280
swapped right so I come in here and I

916
00:41:16,139 --> 00:41:24,000
swap these two right so now I have L 1 R

917
00:41:20,280 --> 00:41:27,000
0 right then I come here and I need to

918
00:41:24,000 --> 00:41:30,750
swap these two so I would have L 2 and

919
00:41:27,000 --> 00:41:33,150
our zeroes out here right then I would

920
00:41:30,750 --> 00:41:34,110
come here and I would swap this one with

921
00:41:33,150 --> 00:41:36,990
this one

922
00:41:34,110 --> 00:41:41,370
so this would become L 3 right and this

923
00:41:36,989 --> 00:41:43,949
would become R 1 like so then I would

924
00:41:41,369 --> 00:41:50,369
come to here and I would swap what's

925
00:41:43,949 --> 00:41:54,439
this this is l2 so so it's already been

926
00:41:50,369 --> 00:41:57,929
swapped with r0 and it needs to have l3

927
00:41:54,440 --> 00:42:00,690
actually in it right so it needs to swap

928
00:41:57,929 --> 00:42:02,069
with the one before it if that makes

929
00:42:00,690 --> 00:42:08,670
sense

930
00:42:02,070 --> 00:42:12,600
so this one wait no this says l2 l3 this

931
00:42:08,670 --> 00:42:14,220
one is R 0 and R 0 needs to swap with l4

932
00:42:12,599 --> 00:42:16,949
right it's already placed the rest of

933
00:42:14,219 --> 00:42:20,339
them right so we need to stop with l4 so

934
00:42:16,949 --> 00:42:26,039
here's our 0 r 0 goes out there l4 comes

935
00:42:20,340 --> 00:42:28,740
in here right l4 so what does this end

936
00:42:26,039 --> 00:42:35,789
up looking like at the end of the day

937
00:42:28,739 --> 00:42:43,049
it's R 2 R 1 R 3 R 0 R for right which

938
00:42:35,789 --> 00:42:45,000
is pretty random and what is there some

939
00:42:43,050 --> 00:42:48,760
kind of magic to that ordering that

940
00:42:45,000 --> 00:42:51,250
would allow me to then on the Swizzle it

941
00:42:48,760 --> 00:42:57,599
you'd have to swap this here right so

942
00:42:51,250 --> 00:43:00,159
this would go here this would go here

943
00:42:57,599 --> 00:43:03,250
that would stay where it was and that

944
00:43:00,159 --> 00:43:06,368
would stay where it was so you have to

945
00:43:03,250 --> 00:43:13,230
swap 0 &amp; 2

946
00:43:06,369 --> 00:43:18,338
I'm sorry you have to swap is that right

947
00:43:13,230 --> 00:43:20,349
are two needs to go here are three needs

948
00:43:18,338 --> 00:43:22,630
to go here so it's like a ring swap

949
00:43:20,349 --> 00:43:24,190
right are two would go here are three

950
00:43:22,630 --> 00:43:27,190
would go here and are zero would come

951
00:43:24,190 --> 00:43:28,990
back to the beginning so yeah I mean

952
00:43:27,190 --> 00:43:31,030
gosh that doesn't seem very

953
00:43:28,989 --> 00:43:33,879
straightforward the initial swaps going

954
00:43:31,030 --> 00:43:35,829
through here seem okay like that's that

955
00:43:33,880 --> 00:43:37,660
would just work I guess you'd just step

956
00:43:35,829 --> 00:43:39,700
through and you just grab and you'd swap

957
00:43:37,659 --> 00:43:44,230
into place whatever was there beforehand

958
00:43:39,699 --> 00:43:46,058
you'd just keep doing the swapping but

959
00:43:44,230 --> 00:43:48,099
just sorting out those are samples at

960
00:43:46,059 --> 00:43:51,089
the end I'm not sure if there's a

961
00:43:48,099 --> 00:43:57,400
straightforward way to do it

962
00:43:51,088 --> 00:43:59,789
can anyone think of one it'd be

963
00:43:57,400 --> 00:44:02,010
interesting to see a longer series here

964
00:43:59,789 --> 00:44:05,639
right it'd be interesting to see a

965
00:44:02,010 --> 00:44:08,099
longer series of what this looks like

966
00:44:05,639 --> 00:44:10,420
maybe we should just write it and see

967
00:44:08,099 --> 00:44:14,289
because maybe that's maybe that's

968
00:44:10,420 --> 00:44:17,650
interesting right maybe I'll do exactly

969
00:44:14,289 --> 00:44:23,650
that so yeah so if we were to do it this

970
00:44:17,650 --> 00:44:25,750
way I'm also gonna I guess say that the

971
00:44:23,650 --> 00:44:27,639
sample data is gonna be you in 16 since

972
00:44:25,750 --> 00:44:34,780
that's what we're working on right so

973
00:44:27,639 --> 00:44:37,000
sample data at 16 okay so in here we've

974
00:44:34,780 --> 00:44:39,760
got the the right stuff that's all good

975
00:44:37,000 --> 00:44:41,739
for getting that sample data and and

976
00:44:39,760 --> 00:44:44,319
then in here what we need we need to do

977
00:44:41,739 --> 00:44:46,750
is we'd say the sample data plus and

978
00:44:44,318 --> 00:44:50,588
then we'd have half the total size right

979
00:44:46,750 --> 00:44:53,530
so something like this those would be

980
00:44:50,588 --> 00:44:54,519
the two buffers and what we would then

981
00:44:53,530 --> 00:44:59,079
have to do is we'd have to go through

982
00:44:54,519 --> 00:45:00,130
and do this this Schwing like I say so

983
00:44:59,079 --> 00:45:01,560
we have to do something that basically

984
00:45:00,130 --> 00:45:04,349
step through all the samples so

985
00:45:01,559 --> 00:45:10,860
have our sample index right we want to

986
00:45:04,349 --> 00:45:14,940
step through the sample count and for

987
00:45:10,860 --> 00:45:18,059
each one of these guys right we want to

988
00:45:14,940 --> 00:45:22,769
take basically that that sample data

989
00:45:18,059 --> 00:45:25,920
right the sample data at the current

990
00:45:22,769 --> 00:45:30,389
sample index right and so we're trying

991
00:45:25,920 --> 00:45:35,430
to put ELLs in place right so we have l0

992
00:45:30,389 --> 00:45:39,359
l1 l2 l3 and so on right so the location

993
00:45:35,429 --> 00:45:42,869
of the one that we want this is the one

994
00:45:39,360 --> 00:45:46,140
we want so this is the source right the

995
00:45:42,869 --> 00:45:49,769
location of the one we want is actually

996
00:45:46,139 --> 00:45:52,980
going to be at sample data times 2 right

997
00:45:49,769 --> 00:45:55,019
because it's it's going by twos in in

998
00:45:52,980 --> 00:45:59,460
the buffer like it's l0 are zero

999
00:45:55,019 --> 00:46:01,619
we didn't want then l1 we want right so

1000
00:45:59,460 --> 00:46:05,250
grabbing that out we then want to put

1001
00:46:01,619 --> 00:46:08,699
that into the current location right

1002
00:46:05,250 --> 00:46:11,969
like so but first we need to save out

1003
00:46:08,699 --> 00:46:16,799
our information into that location right

1004
00:46:11,969 --> 00:46:20,849
so we're doing the swap like this makes

1005
00:46:16,800 --> 00:46:23,519
sense so yeah so that would do that that

1006
00:46:20,849 --> 00:46:26,519
would do this the swap and that would

1007
00:46:23,519 --> 00:46:29,159
put our left channel in you know into

1008
00:46:26,519 --> 00:46:31,469
the proper format right but it wouldn't

1009
00:46:29,159 --> 00:46:34,440
actually do anything else what is this

1010
00:46:31,469 --> 00:46:44,519
saying sample index or boots set to be

1011
00:46:34,440 --> 00:46:46,829
115 okay so if I if I do that right now

1012
00:46:44,519 --> 00:46:49,019
when I load any kind of WAV file that's

1013
00:46:46,829 --> 00:46:50,309
it's doubled it should unsociable the

1014
00:46:49,019 --> 00:46:51,449
left channel properly but the right

1015
00:46:50,309 --> 00:46:54,090
channel is going to be total garbage

1016
00:46:51,449 --> 00:46:55,710
right so what I want to do is I just

1017
00:46:54,090 --> 00:46:59,700
want to take a look at what the right

1018
00:46:55,710 --> 00:47:01,320
channel actually ends up being right and

1019
00:46:59,699 --> 00:47:02,879
I guess for now I said I was going to

1020
00:47:01,320 --> 00:47:07,080
leave it as a void but I might change it

1021
00:47:02,880 --> 00:47:09,390
to a unit 16 just just for a second so

1022
00:47:07,079 --> 00:47:10,440
we can view it a little more easily so

1023
00:47:09,389 --> 00:47:14,618
what I'm going to do is I'm actually

1024
00:47:10,440 --> 00:47:19,420
going to spam in beforehand

1025
00:47:14,619 --> 00:47:22,210
I'm gonna spam in actually the like

1026
00:47:19,420 --> 00:47:24,009
specific a specific set of values if

1027
00:47:22,210 --> 00:47:25,599
that makes sense so what I'm going to do

1028
00:47:24,009 --> 00:47:30,730
is I'm going to say the sample data

1029
00:47:25,599 --> 00:47:33,818
right sample index is going to be equal

1030
00:47:30,730 --> 00:47:35,769
to the sample index always so on so

1031
00:47:33,818 --> 00:47:41,018
basically it's like I'm just writing in

1032
00:47:35,768 --> 00:47:43,808
0 0 1 1 two 2 three 3 four 4 five 5 six

1033
00:47:41,018 --> 00:47:46,328
6 so we can analyze it after and see

1034
00:47:43,809 --> 00:47:49,778
what we end up getting because I don't

1035
00:47:46,329 --> 00:47:53,289
actually know right I've never thought

1036
00:47:49,778 --> 00:47:55,440
about this problem before pretty much

1037
00:47:53,289 --> 00:47:58,059
ever all right

1038
00:47:55,440 --> 00:47:59,380
it just kind of interested me what can I

1039
00:47:58,059 --> 00:48:00,789
say

1040
00:47:59,380 --> 00:48:08,890
so let's take a look at that result

1041
00:48:00,789 --> 00:48:11,019
right here is our samples 0 which is un

1042
00:48:08,889 --> 00:48:14,528
16s right and I'm gonna just take a look

1043
00:48:11,018 --> 00:48:16,328
at the first 32 and you can see that

1044
00:48:14,528 --> 00:48:18,849
those are correct which is what we would

1045
00:48:16,329 --> 00:48:20,470
have expected right so the question is

1046
00:48:18,849 --> 00:48:21,548
what happens with that second channel

1047
00:48:20,469 --> 00:48:24,219
and I don't know

1048
00:48:21,548 --> 00:48:25,630
so there's oh well that's not

1049
00:48:24,219 --> 00:48:28,538
particularly useful why are they all

1050
00:48:25,630 --> 00:48:29,769
zeroes did we mess something up I feel

1051
00:48:28,539 --> 00:48:31,720
like what I feel like I messed something

1052
00:48:29,768 --> 00:48:35,919
up there that should not have been the

1053
00:48:31,719 --> 00:48:40,439
case right how did that happen

1054
00:48:35,920 --> 00:48:40,440
so we go through the sample sample data

1055
00:48:40,579 --> 00:48:48,090
sample data plus sample data size over -

1056
00:48:43,710 --> 00:48:50,070
ah that is the problem this should this

1057
00:48:48,090 --> 00:48:55,700
is actually just should just be the

1058
00:48:50,070 --> 00:48:58,070
sample count right like so yeah my bad

1059
00:48:55,699 --> 00:49:01,879
my bad

1060
00:48:58,070 --> 00:49:01,880
all right let's try that one more time

1061
00:49:04,130 --> 00:49:11,519
so yeah quite the interesting spread

1062
00:49:08,670 --> 00:49:14,608
there so there again is after we do our

1063
00:49:11,519 --> 00:49:18,050
Swizzle there is the you know the left

1064
00:49:14,608 --> 00:49:21,630
channel and here is the right channel I

1065
00:49:18,050 --> 00:49:28,590
don't know what you make of that that's

1066
00:49:21,630 --> 00:49:31,010
just crazy so it's 97 98 99 it's very

1067
00:49:28,590 --> 00:49:37,880
interesting that so those go up in order

1068
00:49:31,010 --> 00:49:42,030
these also go up in order and then these

1069
00:49:37,880 --> 00:49:45,059
don't seem to have oh every other one

1070
00:49:42,030 --> 00:49:46,920
that's like this and half of that so man

1071
00:49:45,059 --> 00:49:50,130
I mean just look at that just looking at

1072
00:49:46,920 --> 00:49:51,659
that I don't know it seems like figuring

1073
00:49:50,130 --> 00:49:53,608
out what the right way to do that Swiss

1074
00:49:51,659 --> 00:49:56,250
emplace would actually be fairly

1075
00:49:53,608 --> 00:49:59,909
complicated I mean if you just look at

1076
00:49:56,250 --> 00:50:02,119
look at how that's going right it's just

1077
00:49:59,909 --> 00:50:05,118
so bizarre

1078
00:50:02,119 --> 00:50:05,119
seven

1079
00:50:05,630 --> 00:50:12,390
yeah so I don't know so there's probably

1080
00:50:10,500 --> 00:50:14,250
like I'm guessing there is a smart way

1081
00:50:12,389 --> 00:50:16,589
to do this I just don't know what it is

1082
00:50:14,250 --> 00:50:20,539
so maybe we're just going to go ahead

1083
00:50:16,590 --> 00:50:24,059
and say that will bite some additional

1084
00:50:20,539 --> 00:50:26,449
memory or something like this or we

1085
00:50:24,059 --> 00:50:29,969
could just even just only load the left

1086
00:50:26,449 --> 00:50:32,909
the left channel for now something like

1087
00:50:29,969 --> 00:50:35,369
this you know we could just always say

1088
00:50:32,909 --> 00:50:38,099
that we only load one of the channels

1089
00:50:35,369 --> 00:50:41,789
right so we could just say to do Casey

1090
00:50:38,099 --> 00:50:45,049
load right channels and we could just

1091
00:50:41,789 --> 00:50:50,340
say result channel count equals one

1092
00:50:45,050 --> 00:50:52,170
right so I guess to be completely honest

1093
00:50:50,340 --> 00:50:55,530
with you I don't really know where we

1094
00:50:52,170 --> 00:50:58,650
left things at the moment in terms of

1095
00:50:55,530 --> 00:51:02,280
sound playing we have game output sound

1096
00:50:58,650 --> 00:51:05,130
the moment is still being called and I

1097
00:51:02,280 --> 00:51:12,960
guess we actually are outputting

1098
00:51:05,130 --> 00:51:17,610
something here which is I guess this T

1099
00:51:12,960 --> 00:51:23,720
sign we don't actually have I could make

1100
00:51:17,610 --> 00:51:27,269
that though let's see game state T sign

1101
00:51:23,719 --> 00:51:32,189
game state T sign does that ever get

1102
00:51:27,269 --> 00:51:39,000
incremented + tab 32 wave period game

1103
00:51:32,190 --> 00:51:42,090
city sign 1032 all right so I guess we

1104
00:51:39,000 --> 00:51:43,800
would just put this back in right for

1105
00:51:42,090 --> 00:51:45,600
testing purposes I don't know what else

1106
00:51:43,800 --> 00:51:48,120
to do at the moment so I'm gonna go and

1107
00:51:45,599 --> 00:51:49,710
put that in just so we can see if our

1108
00:51:48,119 --> 00:51:52,559
sound output is still working first with

1109
00:51:49,710 --> 00:51:57,650
the sound what's with a sine wave before

1110
00:51:52,559 --> 00:52:00,489
we do anything else so here's our T sine

1111
00:51:57,650 --> 00:52:03,670
and I'll go ahead and

1112
00:52:00,489 --> 00:52:09,129
run that and see if we have any sound we

1113
00:52:03,670 --> 00:52:12,180
do all right so that's all good so if we

1114
00:52:09,130 --> 00:52:14,769
want to play an actual sound wave now

1115
00:52:12,179 --> 00:52:16,569
that's you know if we were gonna do game

1116
00:52:14,769 --> 00:52:18,009
output sound for something else I guess

1117
00:52:16,570 --> 00:52:20,350
what I could do is just say well let's

1118
00:52:18,010 --> 00:52:24,400
say we've got a loaded sound here called

1119
00:52:20,349 --> 00:52:27,429
test sound all right and I'm gonna go

1120
00:52:24,400 --> 00:52:31,630
into to the place where we loaded the

1121
00:52:27,429 --> 00:52:34,480
sound their load Wow and I'm gonna say

1122
00:52:31,630 --> 00:52:37,990
that game state test sound equals that

1123
00:52:34,480 --> 00:52:39,760
sound so when we come in here and was

1124
00:52:37,989 --> 00:52:41,019
that so I had that at the beginning so

1125
00:52:39,760 --> 00:52:42,850
that was actually loading the sound

1126
00:52:41,019 --> 00:52:45,550
every frame and apparently that was fine

1127
00:52:42,849 --> 00:52:47,589
that's kind of crazy anyway so I'm gonna

1128
00:52:45,550 --> 00:52:49,750
put that in here when we actually do

1129
00:52:47,590 --> 00:52:52,600
this this is just you know to test the

1130
00:52:49,750 --> 00:52:54,789
debug loading that'll go ahead and load

1131
00:52:52,599 --> 00:52:58,868
it into test sound and then what we can

1132
00:52:54,789 --> 00:53:00,670
do if we want to is we can have this

1133
00:52:58,869 --> 00:53:02,730
game app that sound thing actually do

1134
00:53:00,670 --> 00:53:06,460
something a little more useful

1135
00:53:02,730 --> 00:53:08,039
potentially I don't actually know why I

1136
00:53:06,460 --> 00:53:12,220
have a separate function called game

1137
00:53:08,039 --> 00:53:14,349
output sound but yeah whatever so if we

1138
00:53:12,219 --> 00:53:15,789
actually get rid of this I'm just gonna

1139
00:53:14,349 --> 00:53:18,190
say that that's not getting called

1140
00:53:15,789 --> 00:53:21,940
anymore if I actually just come in here

1141
00:53:18,190 --> 00:53:23,650
and put put this in here I'm gonna go

1142
00:53:21,940 --> 00:53:27,940
ahead and say we we're gonna output to

1143
00:53:23,650 --> 00:53:29,470
the sound buffer like so and the sample

1144
00:53:27,940 --> 00:53:32,740
value that we're gonna output is just

1145
00:53:29,469 --> 00:53:36,279
going to come from that debug sound that

1146
00:53:32,739 --> 00:53:41,199
we loaded right so I'm going to say that

1147
00:53:36,280 --> 00:53:44,380
the game state test sound what do we

1148
00:53:41,199 --> 00:53:47,469
call it samples I think we're gonna say

1149
00:53:44,380 --> 00:53:50,680
the samples zero that first channel I'm

1150
00:53:47,469 --> 00:53:53,319
going to grab the the sample index of

1151
00:53:50,679 --> 00:53:54,819
that and put it into the buffer now of

1152
00:53:53,320 --> 00:53:57,369
course we want the sound to continue

1153
00:53:54,820 --> 00:54:00,369
playing over time so I need some notion

1154
00:53:57,369 --> 00:54:02,079
of the global sample index right so I

1155
00:54:00,369 --> 00:54:07,809
want to do something like you and 32

1156
00:54:02,079 --> 00:54:10,389
sample index or test sample index like

1157
00:54:07,809 --> 00:54:12,429
this so what I want to do is say okay

1158
00:54:10,389 --> 00:54:14,049
you know it's actually going to be the

1159
00:54:12,429 --> 00:54:14,369
game state plus wherever we were in the

1160
00:54:14,050 --> 00:54:15,860
same

1161
00:54:14,369 --> 00:54:18,839
plus the sample index then at the end

1162
00:54:15,860 --> 00:54:21,630
we'll go ahead and advance that by

1163
00:54:18,840 --> 00:54:25,200
however many samples we actually retired

1164
00:54:21,630 --> 00:54:28,470
like so and then all I want to do in

1165
00:54:25,199 --> 00:54:29,819
here is say oh you know I I never want

1166
00:54:28,469 --> 00:54:32,819
you to play more than whatever the

1167
00:54:29,820 --> 00:54:35,640
sample count was obviously right so

1168
00:54:32,820 --> 00:54:40,289
whatever it's sample count was only only

1169
00:54:35,639 --> 00:54:43,199
play that many right so let's take a

1170
00:54:40,289 --> 00:54:49,380
look what did i do there game state test

1171
00:54:43,199 --> 00:54:53,369
sample index right mod test sound sample

1172
00:54:49,380 --> 00:54:54,349
counts missing you're right I am there

1173
00:54:53,369 --> 00:54:58,969
we go

1174
00:54:54,349 --> 00:55:03,750
or maybe not what did I do game state Oh

1175
00:54:58,969 --> 00:55:07,819
sample value that's what I wanted and so

1176
00:55:03,750 --> 00:55:10,739
that was actually correct sample out

1177
00:55:07,820 --> 00:55:12,570
whoops did I did I not copy the thing

1178
00:55:10,739 --> 00:55:15,569
that actually does figure that where

1179
00:55:12,570 --> 00:55:23,690
we're writing in the buffer sample out

1180
00:55:15,570 --> 00:55:26,400
there it is okay okay so let's see that

1181
00:55:23,690 --> 00:55:28,170
does not sound particularly good I'll

1182
00:55:26,400 --> 00:55:30,329
give you that

1183
00:55:28,170 --> 00:55:31,680
so let me actually go through and step

1184
00:55:30,329 --> 00:55:37,849
through here so this is going to be our

1185
00:55:31,679 --> 00:55:43,159
sample index or our test sound sample is

1186
00:55:37,849 --> 00:55:47,389
index it's going to be this guy right

1187
00:55:43,159 --> 00:55:50,489
like so and then our sample value I

1188
00:55:47,389 --> 00:55:52,379
guess the Q&amp;A doesn't quite begin now so

1189
00:55:50,489 --> 00:55:53,549
I wasn't quite ready yet let's go ahead

1190
00:55:52,380 --> 00:55:56,480
and save that I just want to go ahead

1191
00:55:53,550 --> 00:55:56,480
and step into this guy

1192
00:56:04,019 --> 00:56:08,769
okay

1193
00:56:06,219 --> 00:56:10,329
so let's see what we've got here what's

1194
00:56:08,769 --> 00:56:12,639
our test sound sample index it's zero

1195
00:56:10,329 --> 00:56:14,920
what's our sample value also zero so

1196
00:56:12,639 --> 00:56:16,989
we're gonna output Pat come through

1197
00:56:14,920 --> 00:56:19,838
again what's our test sample index right

1198
00:56:16,989 --> 00:56:24,629
and so on do we ever have any sample

1199
00:56:19,838 --> 00:56:29,289
values here before yeah that's good oh I

1200
00:56:24,630 --> 00:56:30,789
don't know why that's that's kind of not

1201
00:56:29,289 --> 00:56:34,108
what I meant to do it all there these

1202
00:56:30,789 --> 00:56:37,029
are supposed to be in 16s not UN 16s

1203
00:56:34,108 --> 00:56:38,079
yeah sound value is encoded as signed so

1204
00:56:37,030 --> 00:56:40,210
I don't know why I did that that's

1205
00:56:38,079 --> 00:56:42,098
probably half the battle right there but

1206
00:56:40,210 --> 00:56:43,929
let me just make sure this part works as

1207
00:56:42,099 --> 00:56:48,369
well what's the sample count supposedly

1208
00:56:43,929 --> 00:56:50,409
1066 so there's that that goes up so

1209
00:56:48,369 --> 00:56:55,269
that looks relatively correct actually

1210
00:56:50,409 --> 00:56:59,230
but I did not mean to make those the

1211
00:56:55,269 --> 00:57:01,449
human 16s that that was a mistake again

1212
00:56:59,230 --> 00:57:03,909
just guess it's been a while since I've

1213
00:57:01,449 --> 00:57:06,969
coded sound I just didn't think of it

1214
00:57:03,909 --> 00:57:09,549
for some reason so yes so you meant 16s

1215
00:57:06,969 --> 00:57:12,039
that was unintentional all of these

1216
00:57:09,550 --> 00:57:14,440
places that are using UN 16s they should

1217
00:57:12,039 --> 00:57:17,139
have been in 16s because that's actually

1218
00:57:14,440 --> 00:57:22,990
the way we're encoding that sound to be

1219
00:57:17,139 --> 00:57:26,250
sure so yeah that is more what we're

1220
00:57:22,989 --> 00:57:26,250
looking for all right

1221
00:57:27,630 --> 00:57:31,920
but I still haven't gotten anywhere

1222
00:57:33,690 --> 00:57:38,849
it just sounds like clicking to me right

1223
00:57:36,380 --> 00:57:40,829
and let's actually verify which one are

1224
00:57:38,849 --> 00:57:44,099
we loading again and actually remember

1225
00:57:40,829 --> 00:57:45,719
we're loading like bloop zero zero I

1226
00:57:44,099 --> 00:57:51,659
think so let's just see what that's

1227
00:57:45,719 --> 00:57:56,449
supposed to sound like let's see can we

1228
00:57:51,659 --> 00:57:56,449
hear that here we go

1229
00:57:58,460 --> 00:58:03,420
of course VLC also seems to have an

1230
00:58:01,230 --> 00:58:06,179
audio bug where it's clicking but you

1231
00:58:03,420 --> 00:58:07,409
can hear the at least the bloop part let

1232
00:58:06,179 --> 00:58:11,519
me try it with a different player that

1233
00:58:07,409 --> 00:58:20,549
maybe won't be quite so bad at actually

1234
00:58:11,519 --> 00:58:23,190
playing it okay

1235
00:58:20,550 --> 00:58:25,260
so let's figure out what we've done

1236
00:58:23,190 --> 00:58:28,200
wrong here we can go a little bit into

1237
00:58:25,260 --> 00:58:30,600
the QA I think won't hurt anything might

1238
00:58:28,199 --> 00:58:33,059
as well just get this up to a reasonable

1239
00:58:30,599 --> 00:58:35,690
state before we break so that tomorrow

1240
00:58:33,059 --> 00:58:37,739
we can start by talking about sound

1241
00:58:35,690 --> 00:58:39,300
because we'll actually have stuff loaded

1242
00:58:37,739 --> 00:58:44,309
and we can you know go over a little bit

1243
00:58:39,300 --> 00:58:46,530
more okay so here we go with the samples

1244
00:58:44,309 --> 00:58:48,630
right it's stereo out so we're writing

1245
00:58:46,530 --> 00:58:49,980
these guys and that's all fine and I

1246
00:58:48,630 --> 00:58:50,880
were just writing the same thing to the

1247
00:58:49,980 --> 00:58:53,699
left channel and the right channel

1248
00:58:50,880 --> 00:58:56,910
should be fine we're grabbing out of

1249
00:58:53,699 --> 00:58:59,129
test sound the out of the first sample

1250
00:58:56,909 --> 00:59:01,529
channel which is what we were expected

1251
00:58:59,130 --> 00:59:03,809
we're grabbing them in order and we're

1252
00:59:01,530 --> 00:59:05,840
just looping the buffer right so it

1253
00:59:03,809 --> 00:59:08,610
should just you know give us the sound

1254
00:59:05,840 --> 00:59:13,650
repeated over and over and over again

1255
00:59:08,610 --> 00:59:16,650
right so that looks you know that looks

1256
00:59:13,650 --> 00:59:19,470
relatively sane to me like I don't see

1257
00:59:16,650 --> 00:59:21,960
much in the way of nonsense going on

1258
00:59:19,469 --> 00:59:24,779
there so I want to go like double check

1259
00:59:21,960 --> 00:59:27,300
the loading code first as the first

1260
00:59:24,780 --> 00:59:29,490
thing we do because I'm a little I'm a

1261
00:59:27,300 --> 00:59:31,260
little more concerned about that at the

1262
00:59:29,489 --> 00:59:33,179
moment than I am about the playback code

1263
00:59:31,260 --> 00:59:35,400
but you know that that's just my that's

1264
00:59:33,179 --> 00:59:40,109
just my guess that's just my hunch if

1265
00:59:35,400 --> 00:59:42,269
you will so okay so if we come in here

1266
00:59:40,110 --> 00:59:44,670
what I want to do is I want to take a

1267
00:59:42,269 --> 00:59:47,230
look at that sample data I just want to

1268
00:59:44,670 --> 00:59:48,309
see what it kind of looks like right

1269
00:59:47,230 --> 00:59:52,420
so I'm just looking at what those

1270
00:59:48,309 --> 00:59:55,480
samples are so that fat looks like

1271
00:59:52,420 --> 00:59:56,849
plausible sound data to me right like I

1272
00:59:55,480 --> 01:00:00,519
could I could believe that

1273
00:59:56,849 --> 01:00:04,989
was plausible sound data to some degree

1274
01:00:00,519 --> 01:00:08,429
that that seems that that seems with

1275
01:00:04,989 --> 01:00:11,108
within reason anyway right

1276
01:00:08,429 --> 01:00:17,019
let's take a look at it a little further

1277
01:00:11,108 --> 01:00:19,779
down the road right so that again seems

1278
01:00:17,019 --> 01:00:25,509
seems pretty plausible you can kind of

1279
01:00:19,780 --> 01:00:34,600
see well that does oscillate rather

1280
01:00:25,510 --> 01:00:37,540
quickly but yeah yeah I mean it could be

1281
01:00:34,599 --> 01:00:39,279
true it is just rather quickly

1282
01:00:37,539 --> 01:00:41,710
offsetting so these are packed together

1283
01:00:39,280 --> 01:00:43,570
right so these are stereo samples so

1284
01:00:41,710 --> 01:00:45,849
these are samples that follow each other

1285
01:00:43,570 --> 01:00:49,480
negative 21 negative 11 negative 24

1286
01:00:45,849 --> 01:00:52,029
forty to sixty four writes negative 60

1287
01:00:49,480 --> 01:00:57,880
they just they seem a little odd to me

1288
01:00:52,030 --> 01:01:00,820
and I'm wondering they seem just a

1289
01:00:57,880 --> 01:01:02,320
little bit odd let me go back and

1290
01:01:00,820 --> 01:01:04,330
double-check that we did not miss

1291
01:01:02,320 --> 01:01:06,190
something about the format let's take a

1292
01:01:04,329 --> 01:01:14,980
look at what the PCM data actually says

1293
01:01:06,190 --> 01:01:19,150
here let's see non PCM data we want PCM

1294
01:01:14,980 --> 01:01:25,559
data channel interleaved M byte samples

1295
01:01:19,150 --> 01:01:29,349
right and bits per sample eight times M

1296
01:01:25,559 --> 01:01:32,320
so I feel like that we are interpreting

1297
01:01:29,349 --> 01:01:34,750
it correctly are we not I guess there's

1298
01:01:32,320 --> 01:01:37,510
that Swizzle miss to it I wonder if any

1299
01:01:34,750 --> 01:01:41,489
of these are not dual channel so we

1300
01:01:37,510 --> 01:01:43,930
would know whether or not we would have

1301
01:01:41,489 --> 01:01:45,909
we would have a we could test whether

1302
01:01:43,929 --> 01:01:49,569
it's just our Swizzle code that's wrong

1303
01:01:45,909 --> 01:01:51,159
right but yeah but this is before we

1304
01:01:49,570 --> 01:01:53,830
fizzled it so let's double check and

1305
01:01:51,159 --> 01:01:55,329
make sure that the Swizzle is operating

1306
01:01:53,829 --> 01:01:56,889
as we would expect I mean I think we

1307
01:01:55,329 --> 01:01:59,940
checked it pretty well with the zero one

1308
01:01:56,889 --> 01:01:59,940
two three four thing Oh

1309
01:02:01,699 --> 01:02:10,500
that's what it is we just never removed

1310
01:02:04,920 --> 01:02:13,139
the test code hahaha that's great yeah

1311
01:02:10,500 --> 01:02:15,239
well you know if you write a bunch of

1312
01:02:13,139 --> 01:02:19,440
garbage into the thing as part of the

1313
01:02:15,239 --> 01:02:24,199
test code don't be too surprised when it

1314
01:02:19,440 --> 01:02:31,250
doesn't sound like a sound when when you

1315
01:02:24,199 --> 01:02:31,250
oh that's funny that's that's funny okay

1316
01:02:33,230 --> 01:02:37,829
so we're still a little messed up there

1317
01:02:35,400 --> 01:02:39,889
but but but now we're loading and

1318
01:02:37,829 --> 01:02:42,119
playing the sound correctly I think

1319
01:02:39,889 --> 01:02:45,239
we're not hitting our frame rate so I

1320
01:02:42,119 --> 01:02:47,490
suppose I suspect if we if we go ahead

1321
01:02:45,239 --> 01:02:49,729
and build that's something that hits

1322
01:02:47,489 --> 01:02:53,429
frame right now will probably be fine

1323
01:02:49,730 --> 01:02:55,740
although we also have to we have to now

1324
01:02:53,429 --> 01:03:00,239
make sure we sink to the proper frame

1325
01:02:55,739 --> 01:03:04,769
rate instead of doing 60 Hertz so let's

1326
01:03:00,239 --> 01:03:08,659
take a look let's go let's go back to

1327
01:03:04,769 --> 01:03:12,710
that first of all and and and reset it

1328
01:03:08,659 --> 01:03:15,598
yeah so anyway let's see we've got

1329
01:03:12,710 --> 01:03:17,400
monitor refresh rate is 60 Hertz right

1330
01:03:15,599 --> 01:03:21,420
refresh rate so we want to go ahead and

1331
01:03:17,400 --> 01:03:34,230
set this guy in here really for now so

1332
01:03:21,420 --> 01:03:37,680
that should be better okay now we can go

1333
01:03:34,230 --> 01:03:39,539
to the Q&amp;A although maybe we'll change

1334
01:03:37,679 --> 01:03:43,460
it to playing piano music so that we

1335
01:03:39,539 --> 01:03:47,880
don't drive everyone completely nuts

1336
01:03:43,460 --> 01:03:51,990
with that sound I think I threw in

1337
01:03:47,880 --> 01:03:57,329
something from the ad-lib library in

1338
01:03:51,989 --> 01:04:01,219
here where is it data test three music

1339
01:03:57,329 --> 01:04:04,699
underscore test music underscore test

1340
01:04:01,219 --> 01:04:07,209
all right so so let's let's try that

1341
01:04:04,699 --> 01:04:11,049
there we go

1342
01:04:07,210 --> 01:04:13,079
okay so now it'll just kind of play

1343
01:04:11,050 --> 01:04:16,269
something that's that's a little more

1344
01:04:13,079 --> 01:04:18,700
innocuous and that'll be fine all right

1345
01:04:16,269 --> 01:04:25,539
okay so now we can actually go to the QA

1346
01:04:18,699 --> 01:04:26,710
oops I double Q&amp;A there and and that's

1347
01:04:25,539 --> 01:04:28,210
good because now we're in a good

1348
01:04:26,710 --> 01:04:29,949
position for tomorrow I can just talk

1349
01:04:28,210 --> 01:04:32,170
about sound we've got some sound loading

1350
01:04:29,949 --> 01:04:34,118
so I can talk about it and we can

1351
01:04:32,170 --> 01:04:35,440
introduce like how we'll do the mixing

1352
01:04:34,119 --> 01:04:38,130
and that sort of stuff so that that's

1353
01:04:35,440 --> 01:04:41,280
good I glad we got to that point today

1354
01:04:38,130 --> 01:04:41,280
so yeah

1355
01:04:45,030 --> 01:04:49,690
robot Java Dino says you could try on

1356
01:04:47,619 --> 01:04:54,130
interleaving the channels in place like

1357
01:04:49,690 --> 01:04:55,750
this and he he sent a link address let

1358
01:04:54,130 --> 01:05:01,318
me take a look and see what that link

1359
01:04:55,750 --> 01:05:01,318
address actually is let's see

1360
01:05:01,630 --> 01:05:05,619
[Music]

1361
01:05:08,588 --> 01:05:14,679
swap Arzu are too thin swap oh so you're

1362
01:05:12,458 --> 01:05:18,669
saying like inside outside swap so go

1363
01:05:14,679 --> 01:05:22,149
from the go from the beginning and the

1364
01:05:18,670 --> 01:05:23,650
end inside does that work

1365
01:05:22,150 --> 01:05:29,108
did you actually see if that worked

1366
01:05:23,650 --> 01:05:31,630
maybe it does does that work for long

1367
01:05:29,108 --> 01:05:48,130
sequences I guess it's the only thing I

1368
01:05:31,630 --> 01:05:48,910
don't know sudonym 73 I feel like that I

1369
01:05:48,130 --> 01:05:50,199
don't know if that works for long

1370
01:05:48,909 --> 01:05:50,828
sequences robot rocket now that's my

1371
01:05:50,199 --> 01:05:53,079
only concern

1372
01:05:50,829 --> 01:05:54,939
soon as ac3 says probably the second

1373
01:05:53,079 --> 01:06:00,068
easiest way to do interleave is multi

1374
01:05:54,938 --> 01:06:02,438
pass swap R 0 R 1 R 0 l1 r2 l3 l4 l5

1375
01:06:00,068 --> 01:06:04,599
then do the same with two sample blocks

1376
01:06:02,438 --> 01:06:06,399
for sample blocks etc easiest way is to

1377
01:06:04,599 --> 01:06:08,769
D interleaved directly into mix output

1378
01:06:06,400 --> 01:06:10,389
buffer yeah we don't really want to do

1379
01:06:08,768 --> 01:06:12,608
that because we can just do the the D

1380
01:06:10,389 --> 01:06:15,548
interleave at construction time so our

1381
01:06:12,608 --> 01:06:19,748
art pack will just have the D entry

1382
01:06:15,548 --> 01:06:21,548
leave already done why do you need to

1383
01:06:19,748 --> 01:06:23,078
unintel Eve the sound when you play it

1384
01:06:21,548 --> 01:06:25,688
you still have to read both left and

1385
01:06:23,079 --> 01:06:27,969
right values the reason is because we

1386
01:06:25,688 --> 01:06:31,808
don't process the values the same way

1387
01:06:27,969 --> 01:06:35,159
and we're going to want to be wide we're

1388
01:06:31,809 --> 01:06:35,160
going to want to be Cindy

1389
01:06:39,000 --> 01:06:44,559
abner Cumbre people are asking about the

1390
01:06:42,190 --> 01:06:47,440
benefits of extra and see what issues

1391
01:06:44,559 --> 01:06:54,130
does it address well it addresses a

1392
01:06:47,440 --> 01:06:57,340
bunch of things and a partial list of

1393
01:06:54,130 --> 01:07:00,160
them would be first of all it prevents

1394
01:06:57,340 --> 01:07:02,079
the names from getting mangled so you

1395
01:07:00,159 --> 01:07:04,059
know normally when you link it mangles

1396
01:07:02,079 --> 01:07:05,829
the names for C++ so that you can have

1397
01:07:04,059 --> 01:07:07,360
operator overloading work properly with

1398
01:07:05,829 --> 01:07:11,590
linkers that don't know about it right

1399
01:07:07,360 --> 01:07:14,769
and that it goes for dynamic linkage too

1400
01:07:11,590 --> 01:07:16,720
so if you do a DLL export right like we

1401
01:07:14,769 --> 01:07:18,639
have a DLL exported thing right our

1402
01:07:16,719 --> 01:07:22,119
entry point to our game is exported as

1403
01:07:18,639 --> 01:07:24,159
part of the DLL in order to do that

1404
01:07:22,119 --> 01:07:26,799
export the name would have been mangled

1405
01:07:24,159 --> 01:07:30,549
in the DLL import table if we had enough

1406
01:07:26,800 --> 01:07:32,980
extra and seat it right so there's that

1407
01:07:30,550 --> 01:07:37,300
the next thing is it implies a calling

1408
01:07:32,980 --> 01:07:38,679
convention so on 64-bit X 60 X 64 on

1409
01:07:37,300 --> 01:07:41,800
Windows there is only one column

1410
01:07:38,679 --> 01:07:44,230
convention really it's standard call and

1411
01:07:41,800 --> 01:07:47,080
there's ways to maybe force other things

1412
01:07:44,230 --> 01:07:49,659
like with compiler stuff but in general

1413
01:07:47,079 --> 01:07:53,500
as standard calls used everywhere that's

1414
01:07:49,659 --> 01:07:54,989
not true on 32-bit on 32-bit there's

1415
01:07:53,500 --> 01:07:57,550
multiple Kallang conventions

1416
01:07:54,989 --> 01:08:00,339
there's Pascal and there c style and so

1417
01:07:57,550 --> 01:08:01,750
on and extra and C lets you know that

1418
01:08:00,340 --> 01:08:04,660
it's a C deckle which is this Pacific

1419
01:08:01,750 --> 01:08:06,010
call calling convention as well right

1420
01:08:04,659 --> 01:08:10,869
it's the calling convention that allows

1421
01:08:06,010 --> 01:08:13,630
VAR args if that makes sense

1422
01:08:10,869 --> 01:08:16,599
so you know there's there's a bunch of

1423
01:08:13,630 --> 01:08:17,500
things like that that happened and so

1424
01:08:16,600 --> 01:08:19,390
when you're trying to do

1425
01:08:17,500 --> 01:08:21,789
interoperability stuff that's when you

1426
01:08:19,390 --> 01:08:23,860
have to use extra and see if you're just

1427
01:08:21,789 --> 01:08:25,720
compiling within your own code and you

1428
01:08:23,859 --> 01:08:28,389
don't need to like if then linking is

1429
01:08:25,720 --> 01:08:30,640
not an issue typically extra and C is

1430
01:08:28,390 --> 01:08:32,980
not really necessary like there aren't a

1431
01:08:30,640 --> 01:08:34,810
lot of uses for it when you're just

1432
01:08:32,979 --> 01:08:37,649
talking about your own code then it just

1433
01:08:34,810 --> 01:08:37,650
typically doesn't matter

1434
01:08:43,810 --> 01:08:47,839
constantinople Casey can you please

1435
01:08:45,770 --> 01:08:48,230
explain chunk size plus one and negative

1436
01:08:47,838 --> 01:08:52,130
one

1437
01:08:48,229 --> 01:08:54,319
yes so let me show you what it does

1438
01:08:52,130 --> 01:08:58,520
because it's pretty easy to understand

1439
01:08:54,319 --> 01:09:01,369
if you if you see it Tappin rather than

1440
01:08:58,520 --> 01:09:05,810
me just sort of staying talking at you

1441
01:09:01,369 --> 01:09:13,608
why it happened so if you take a look at

1442
01:09:05,810 --> 01:09:16,220
this code okay if you switch to

1443
01:09:13,609 --> 01:09:18,010
compiling in a build where that code is

1444
01:09:16,220 --> 01:09:22,940
not completely inlined

1445
01:09:18,010 --> 01:09:25,010
and then look at this function so what

1446
01:09:22,939 --> 01:09:29,239
happens here right is you have a chunk

1447
01:09:25,010 --> 01:09:30,800
size and that size is some value now if

1448
01:09:29,239 --> 01:09:40,130
you consider what this looks like in

1449
01:09:30,800 --> 01:09:42,859
binary right you can imagine that I've

1450
01:09:40,130 --> 01:09:44,750
got my bits right here's the one bit the

1451
01:09:42,859 --> 01:09:47,838
two bit the for a bit the 8 bit the

1452
01:09:44,750 --> 01:09:50,930
16-bit 32-bit and so on right if this

1453
01:09:47,838 --> 01:09:53,779
bit is set the number is odd right

1454
01:09:50,930 --> 01:09:57,530
because all of these other values are

1455
01:09:53,779 --> 01:10:00,229
even and a sum any sum of even numbers

1456
01:09:57,529 --> 01:10:03,800
is going to be even right so no matter

1457
01:10:00,229 --> 01:10:06,889
what the rest of the bits are it doesn't

1458
01:10:03,800 --> 01:10:09,409
matter all I need to know is this bit

1459
01:10:06,890 --> 01:10:12,320
will tell me if it's odd or not right

1460
01:10:09,409 --> 01:10:13,970
and what the spec said when we were

1461
01:10:12,319 --> 01:10:17,449
reading the spec is it said that chunk

1462
01:10:13,970 --> 01:10:22,190
sizes are always padded if they are odd

1463
01:10:17,449 --> 01:10:24,739
so if the chunk size was say 15 it would

1464
01:10:22,189 --> 01:10:26,539
actually insert one blank byte at the

1465
01:10:24,739 --> 01:10:30,050
end of the chunk before the next chunk

1466
01:10:26,539 --> 01:10:33,649
to make sure that it rounds out to an

1467
01:10:30,050 --> 01:10:36,170
even number of bytes so what I wanted to

1468
01:10:33,649 --> 01:10:38,239
do was I wanted to make sure that this

1469
01:10:36,170 --> 01:10:40,520
bite was was clear I wanted to do that

1470
01:10:38,239 --> 01:10:43,639
rounding so if I had 15 I want it to

1471
01:10:40,520 --> 01:10:45,650
round to 16 right so one way I could do

1472
01:10:43,640 --> 01:10:49,250
that is I could just clear this bit I

1473
01:10:45,649 --> 01:10:51,259
could and the bit and knock it out right

1474
01:10:49,250 --> 01:10:53,930
and what would I hand it with well I

1475
01:10:51,260 --> 01:10:54,409
would end it with not one because not

1476
01:10:53,930 --> 01:10:56,780
one

1477
01:10:54,409 --> 01:10:58,579
is all the other bits set but not this

1478
01:10:56,779 --> 01:11:01,609
one so if I ended them I would know I

1479
01:10:58,579 --> 01:11:03,559
would clear this one right and that

1480
01:11:01,609 --> 01:11:05,089
would get rid of the bottom bit but the

1481
01:11:03,560 --> 01:11:08,900
problem is now my size is too small

1482
01:11:05,090 --> 01:11:12,050
right if I have 15 right that would take

1483
01:11:08,899 --> 01:11:14,689
me to 14 so yes I made the number even

1484
01:11:12,050 --> 01:11:17,690
but I've made it too small it needs to

1485
01:11:14,689 --> 01:11:20,389
be rounded up not rounded down so the

1486
01:11:17,689 --> 01:11:23,299
easiest way to make sure that you do the

1487
01:11:20,390 --> 01:11:25,160
rounding up is to first add one to the

1488
01:11:23,300 --> 01:11:27,770
number right because if there was

1489
01:11:25,159 --> 01:11:30,079
already a one in here then adding one to

1490
01:11:27,770 --> 01:11:31,880
the number right will cause it to carry

1491
01:11:30,079 --> 01:11:34,069
and round up to the next value if it was

1492
01:11:31,880 --> 01:11:35,659
15 it will round up to 16 right and

1493
01:11:34,069 --> 01:11:38,719
clear the bit for you automatically

1494
01:11:35,659 --> 01:11:41,569
right if on the other hand this bit was

1495
01:11:38,720 --> 01:11:43,310
already 0 so it was already 16 adding 1

1496
01:11:41,569 --> 01:11:47,329
will merely bring it to the next odd

1497
01:11:43,310 --> 01:11:49,820
number so then I can and and clear out

1498
01:11:47,329 --> 01:11:53,779
the bit knowing that if the bit was set

1499
01:11:49,819 --> 01:11:57,889
was one that I added so a number plus

1500
01:11:53,779 --> 01:12:00,590
one right andddd oops ANDed with

1501
01:11:57,890 --> 01:12:02,360
negative one is just the same alignment

1502
01:12:00,590 --> 01:12:04,489
pattern that we've been using all along

1503
01:12:02,359 --> 01:12:07,099
but for for aligning two even numbers

1504
01:12:04,489 --> 01:12:11,119
like remember we did stuff like plus 15

1505
01:12:07,100 --> 01:12:13,400
and not 15 to align to 16 byte

1506
01:12:11,119 --> 01:12:16,099
boundaries so it's just that same

1507
01:12:13,399 --> 01:12:20,059
pattern again and you can see it work

1508
01:12:16,100 --> 01:12:21,590
here right let's say in fact let me let

1509
01:12:20,060 --> 01:12:23,090
me just make it a little even more

1510
01:12:21,590 --> 01:12:31,610
explicit so I can when I walk through it

1511
01:12:23,090 --> 01:12:33,350
it's really clear right let's go so

1512
01:12:31,609 --> 01:12:36,559
let's go ahead and do first the first

1513
01:12:33,350 --> 01:12:39,110
step and then the second step right

1514
01:12:36,560 --> 01:12:42,410
let's do it like that

1515
01:12:39,109 --> 01:12:44,960
and so if I go in here now and I step

1516
01:12:42,409 --> 01:12:48,619
into it right you can see what happens

1517
01:12:44,960 --> 01:12:51,199
so the chunk size is 16 we first add 1

1518
01:12:48,619 --> 01:12:52,970
to it to make it 17 and then we clear

1519
01:12:51,199 --> 01:12:56,840
out the bottom bit which brings it back

1520
01:12:52,970 --> 01:13:01,340
to 16 right now if instead of doing that

1521
01:12:56,840 --> 01:13:06,170
right if instead the size had actually

1522
01:13:01,340 --> 01:13:07,930
been 17 right okay now what you can see

1523
01:13:06,170 --> 01:13:10,090
happen is when I add 1

1524
01:13:07,930 --> 01:13:11,890
to it I rounded up to 18 the bottom bits

1525
01:13:10,090 --> 01:13:14,680
already cleared so this function this

1526
01:13:11,890 --> 01:13:17,020
step will have no effect right so

1527
01:13:14,680 --> 01:13:21,010
whether it was even or odd he always

1528
01:13:17,020 --> 01:13:22,810
does the proper up rounding when you

1529
01:13:21,010 --> 01:13:25,900
write it that way and so that is just a

1530
01:13:22,810 --> 01:13:28,480
general pattern for doing rounding to a

1531
01:13:25,899 --> 01:13:31,750
power of two any even power of two

1532
01:13:28,479 --> 01:13:33,369
because of the way binary works you can

1533
01:13:31,750 --> 01:13:36,399
do rounding to Indian power of two by

1534
01:13:33,369 --> 01:13:39,460
just adding one you could think of it

1535
01:13:36,399 --> 01:13:41,920
this way it's really adding the thing

1536
01:13:39,460 --> 01:13:43,810
you want to align to minus one so just

1537
01:13:41,920 --> 01:13:45,130
enough that you would bump it to the

1538
01:13:43,810 --> 01:13:48,610
next one if you were anywhere in that

1539
01:13:45,130 --> 01:13:51,760
range and then clearing all that

1540
01:13:48,609 --> 01:13:53,469
clearing all the other bits right so

1541
01:13:51,760 --> 01:13:55,659
it's really that it's really like the

1542
01:13:53,470 --> 01:13:57,579
number you want to align to minus 1 and

1543
01:13:55,659 --> 01:13:59,590
then ANDed with not the number you want

1544
01:13:57,579 --> 01:14:04,050
align to minus 1 and so that works with

1545
01:13:59,590 --> 01:14:04,050
any with any power too

1546
01:14:14,619 --> 01:14:19,880
popcorn Oh 9o x9e

1547
01:14:17,869 --> 01:14:22,340
why did they put in that order and not

1548
01:14:19,880 --> 01:14:24,800
just bunch it up so he's saying why are

1549
01:14:22,340 --> 01:14:26,779
they interleaved and not flat the reason

1550
01:14:24,800 --> 01:14:29,390
is probably because that's the way sound

1551
01:14:26,779 --> 01:14:31,969
cards used to take the data usually I

1552
01:14:29,390 --> 01:14:33,560
think that's how it used to be sort of

1553
01:14:31,970 --> 01:14:36,730
sent down the stream nowadays it doesn't

1554
01:14:33,560 --> 01:14:38,870
make any sense to do it that way because

1555
01:14:36,729 --> 01:14:42,769
really and I think we'll probably see

1556
01:14:38,869 --> 01:14:46,039
this later I would expect but all of

1557
01:14:42,770 --> 01:14:48,200
your processing happens on a variable

1558
01:14:46,039 --> 01:14:50,510
number of channels usually so you don't

1559
01:14:48,199 --> 01:14:52,189
want to have interleaving or you end up

1560
01:14:50,510 --> 01:14:53,840
having to do a ton of extra work usually

1561
01:14:52,189 --> 01:14:56,089
that you don't want to actually have to

1562
01:14:53,840 --> 01:14:57,980
do in order to support more flexible

1563
01:14:56,090 --> 01:15:01,250
like my two channel output or five

1564
01:14:57,979 --> 01:15:02,569
channel output or whatever right but

1565
01:15:01,250 --> 01:15:05,229
yeah so nowadays doesn't make as much

1566
01:15:02,569 --> 01:15:05,229
sense but

1567
01:15:17,658 --> 01:15:22,109
now our moto if you think of your

1568
01:15:19,889 --> 01:15:24,868
implement or leave data as an N by 2

1569
01:15:22,109 --> 01:15:28,738
matrix then transposition can be viewed

1570
01:15:24,868 --> 01:15:40,768
as interleaving here is an in-place way

1571
01:15:28,738 --> 01:15:43,498
to do it let's see for each length

1572
01:15:40,769 --> 01:15:46,650
greater than one cycle see of the

1573
01:15:43,498 --> 01:15:49,260
permutation pick a starting address S&amp;C

1574
01:15:46,649 --> 01:15:53,759
let d equal the data at s let X go to

1575
01:15:49,260 --> 01:15:56,190
preserve s in the cycle while X is not

1576
01:15:53,760 --> 01:15:58,230
equal to s move data from X a successor

1577
01:15:56,189 --> 01:15:59,908
of s let x equals predecessor risk move

1578
01:15:58,229 --> 01:16:01,018
data from D to testers I'm gonna have to

1579
01:15:59,908 --> 01:16:09,210
read that that looks like I'm gonna have

1580
01:16:01,019 --> 01:16:12,570
to read a little more carefully RPG

1581
01:16:09,210 --> 01:16:13,710
Ignace I just wanna stop it and say

1582
01:16:12,569 --> 01:16:15,058
thank you so much what you're doing here

1583
01:16:13,710 --> 01:16:16,170
putting all this effort in time to

1584
01:16:15,059 --> 01:16:17,909
teaching us all this stuff is highly

1585
01:16:16,170 --> 01:16:20,190
appreciated sometimes seeing stuff like

1586
01:16:17,908 --> 01:16:21,988
this may feel normal and we don't stop

1587
01:16:20,189 --> 01:16:23,759
to think about how much time effort

1588
01:16:21,988 --> 01:16:24,868
energy teaching stuff like this takes so

1589
01:16:23,760 --> 01:16:26,039
I just wanted to thank you once again

1590
01:16:24,868 --> 01:16:27,808
and say that everything you do is like

1591
01:16:26,038 --> 01:16:28,859
they show you thank you you are very

1592
01:16:27,809 --> 01:16:30,150
welcome

1593
01:16:28,859 --> 01:16:32,399
it's wonderful to know that you were

1594
01:16:30,149 --> 01:16:41,839
enjoying it that makes doing it totally

1595
01:16:32,399 --> 01:16:44,158
worthwhile so thank you very much yeah

1596
01:16:41,840 --> 01:16:45,389
you know what I don't see any more

1597
01:16:44,158 --> 01:16:47,248
questions right now so I want to go and

1598
01:16:45,389 --> 01:16:50,670
address a bug that somebody had posted

1599
01:16:47,248 --> 01:16:53,550
on the forums since we have a second in

1600
01:16:50,670 --> 01:16:55,980
the asset loader I think I when I was

1601
01:16:53,550 --> 01:16:59,369
cut and pasting I made a mistake

1602
01:16:55,979 --> 01:17:04,678
when I was doing stuff you can see in

1603
01:16:59,368 --> 01:17:08,339
here when we use the arena we make a sub

1604
01:17:04,679 --> 01:17:13,230
arena for our game assets and we don't

1605
01:17:08,340 --> 01:17:15,059
grab any of these out of there and you

1606
01:17:13,229 --> 01:17:19,018
know actually I don't know that that's

1607
01:17:15,059 --> 01:17:22,130
really a bug in any particular way but

1608
01:17:19,019 --> 01:17:24,539
you know we could consider making

1609
01:17:22,130 --> 01:17:26,190
everything go you know including these

1610
01:17:24,538 --> 01:17:27,569
arrays go in there I just I just don't

1611
01:17:26,189 --> 01:17:33,359
know if we want to do that

1612
01:17:27,569 --> 01:17:35,309
not so now that I look at it I think I

1613
01:17:33,359 --> 01:17:38,609
think that's probably what we meant to

1614
01:17:35,310 --> 01:17:40,500
do to be honest with you because this is

1615
01:17:38,609 --> 01:17:43,198
structural information and this is the

1616
01:17:40,500 --> 01:17:45,750
data information so I don't know I don't

1617
01:17:43,198 --> 01:17:47,759
know that we want to do what you were

1618
01:17:45,750 --> 01:17:49,649
suggesting actually sorry so that may

1619
01:17:47,760 --> 01:17:51,570
not actually be a bug I think that's

1620
01:17:49,649 --> 01:17:55,578
actually just probably what was supposed

1621
01:17:51,569 --> 01:17:55,578
to happen if that makes sense

1622
01:18:05,229 --> 01:18:09,590
why do you want to change the PCM data

1623
01:18:07,578 --> 01:18:10,878
in place instead of compacting it to

1624
01:18:09,590 --> 01:18:17,119
just the information you need in

1625
01:18:10,878 --> 01:18:19,090
allocating extra space well we it was

1626
01:18:17,118 --> 01:18:21,738
really more of a curiosity question

1627
01:18:19,090 --> 01:18:23,719
because the answer is we won't be doing

1628
01:18:21,738 --> 01:18:25,518
that at runtime anyway because the asset

1629
01:18:23,719 --> 01:18:27,979
processor will already have put it into

1630
01:18:25,519 --> 01:18:30,110
channel order for us so it's really

1631
01:18:27,979 --> 01:18:31,668
doesn't matter that's why I didn't

1632
01:18:30,109 --> 01:18:33,198
really care and I was like forget it

1633
01:18:31,668 --> 01:18:36,050
we'll just load just one channel it's

1634
01:18:33,198 --> 01:18:37,609
fine because the asset processor will

1635
01:18:36,050 --> 01:18:40,699
actually be the thing that takes care of

1636
01:18:37,609 --> 01:18:42,948
that for us so it was more of a

1637
01:18:40,698 --> 01:18:44,808
curiosity I was like mmm how would you

1638
01:18:42,948 --> 01:18:47,238
do this interleave and the answer

1639
01:18:44,809 --> 01:18:48,949
appears to be that you can do it but you

1640
01:18:47,238 --> 01:18:50,299
have to be a little more clever about it

1641
01:18:48,948 --> 01:18:51,549
than something simple like what I was

1642
01:18:50,300 --> 01:18:58,820
doing

1643
01:18:51,550 --> 01:19:04,429
that make sense all right running out of

1644
01:18:58,819 --> 01:19:11,808
questions it seems it does seem so it

1645
01:19:04,429 --> 01:19:16,748
does seem so all right okay folks let's

1646
01:19:11,809 --> 01:19:16,748
wrap it up let's wrap it up

1647
01:19:20,010 --> 01:19:26,489
or not there we go okay thank you very

1648
01:19:24,960 --> 01:19:27,810
much for joining me for another episode

1649
01:19:26,488 --> 01:19:29,579
of hand made here at some pleasure

1650
01:19:27,810 --> 01:19:30,810
coating with you as always we got our

1651
01:19:29,579 --> 01:19:34,109
sound loading working today which is

1652
01:19:30,810 --> 01:19:38,670
pretty cool and so I think tomorrow what

1653
01:19:34,109 --> 01:19:43,199
we'll do is you know we we will make a

1654
01:19:38,670 --> 01:19:46,289
decision about whether to go and do our

1655
01:19:43,199 --> 01:19:48,689
sound mixing code or whether we want to

1656
01:19:46,289 --> 01:19:50,970
go back and do the load asset stuff

1657
01:19:48,689 --> 01:19:53,250
whether we have enough information for

1658
01:19:50,970 --> 01:19:57,030
that right now to do the load asset

1659
01:19:53,250 --> 01:19:58,079
stuff instead now I don't know which one

1660
01:19:57,029 --> 01:19:59,399
of those will be so probably what we'll

1661
01:19:58,079 --> 01:20:00,840
do tomorrow is a little black board work

1662
01:19:59,399 --> 01:20:02,429
we'll think about which one we want to

1663
01:20:00,840 --> 01:20:03,539
do next and what makes sense whether we

1664
01:20:02,430 --> 01:20:04,829
have enough information do the load

1665
01:20:03,539 --> 01:20:07,710
asset stuff or whether we should do the

1666
01:20:04,829 --> 01:20:09,539
mixer first we'll make a judgement call

1667
01:20:07,710 --> 01:20:10,800
them we'll start in on one of those so I

1668
01:20:09,539 --> 01:20:12,930
hope to see you back here for that 5

1669
01:20:10,800 --> 01:20:15,500
p.m. Pacific Daylight Time right here on

1670
01:20:12,930 --> 01:20:17,700
Twitch it'll be good to see you all

1671
01:20:15,500 --> 01:20:18,960
until then if you want to follow along

1672
01:20:17,699 --> 01:20:20,099
at home with a source code and play

1673
01:20:18,960 --> 01:20:21,569
around with it yourself you can always

1674
01:20:20,100 --> 01:20:22,739
go to hand mate here at work and free

1675
01:20:21,569 --> 01:20:24,449
order the game it comes with a source

1676
01:20:22,738 --> 01:20:27,149
code you can download it every night

1677
01:20:24,449 --> 01:20:28,500
after I'm done I upload it if you want

1678
01:20:27,149 --> 01:20:30,000
to support the video series also we do

1679
01:20:28,500 --> 01:20:32,310
have a patreon page you can pledge to

1680
01:20:30,000 --> 01:20:34,020
it's very much appreciated we also have

1681
01:20:32,310 --> 01:20:35,840
a forum you can go to ask questions if

1682
01:20:34,020 --> 01:20:38,280
you have questions that outside the QA

1683
01:20:35,840 --> 01:20:40,079
it also has ports to Mac and Linux if

1684
01:20:38,279 --> 01:20:41,460
you need help running on a different

1685
01:20:40,079 --> 01:20:42,899
platform you can look there for

1686
01:20:41,460 --> 01:20:45,539
community members have contributed

1687
01:20:42,899 --> 01:20:47,099
information now how do that it also has

1688
01:20:45,539 --> 01:20:49,079
the anti episode guide maintained by the

1689
01:20:47,100 --> 01:20:51,390
community that's really pretty cool for

1690
01:20:49,079 --> 01:20:52,590
catching up on old episodes and we also

1691
01:20:51,390 --> 01:20:53,700
have a tweet bot which will tweet the

1692
01:20:52,590 --> 01:20:54,869
schedule at you so if you want to know

1693
01:20:53,699 --> 01:20:56,340
when the series is gonna be live and you

1694
01:20:54,869 --> 01:20:58,619
want to catch it that's the place to

1695
01:20:56,340 --> 01:21:00,810
check out for that so that's everything

1696
01:20:58,619 --> 01:21:02,849
I hope to see you back here tomorrow

1697
01:21:00,810 --> 01:21:05,900
until then take it easy everyone and

1698
01:21:02,850 --> 01:21:05,900
have fun coding

