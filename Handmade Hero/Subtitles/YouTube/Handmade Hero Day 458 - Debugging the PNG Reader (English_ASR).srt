1
00:00:01,189 --> 00:00:05,910
hello welcome to handmade here I'll show

2
00:00:03,569 --> 00:00:08,039
the codes it can play well the show that

3
00:00:05,910 --> 00:00:09,419
codes a complete PNG reader live on

4
00:00:08,039 --> 00:00:12,058
stream because we wanted add a PNG

5
00:00:09,419 --> 00:00:15,359
reader to our game for a live art asset

6
00:00:12,058 --> 00:00:17,399
updating and we've written all most of

7
00:00:15,359 --> 00:00:18,899
the code we have not written the fixed

8
00:00:17,399 --> 00:00:21,209
Huffman table version we didn't actually

9
00:00:18,899 --> 00:00:23,669
have any files at the moment that use

10
00:00:21,210 --> 00:00:24,750
the fixed Huffman table version so we

11
00:00:23,670 --> 00:00:26,279
don't actually know maybe we'll never

12
00:00:24,750 --> 00:00:27,599
actually do that I don't know it could

13
00:00:26,278 --> 00:00:28,948
turn out to be that we don't ever

14
00:00:27,599 --> 00:00:31,079
actually get any files that have that

15
00:00:28,949 --> 00:00:33,870
and this is only for our files so we

16
00:00:31,079 --> 00:00:36,170
don't really need to but so we've

17
00:00:33,869 --> 00:00:38,578
written all of the code for a PNG

18
00:00:36,170 --> 00:00:43,050
decompressor including the transforms

19
00:00:38,579 --> 00:00:46,200
which we wrote yesterday but we are not

20
00:00:43,049 --> 00:00:49,229
quite correct yet we have a bug or

21
00:00:46,200 --> 00:00:51,719
multiple bugs in the code that we now

22
00:00:49,229 --> 00:00:55,979
have to debug in order to get proper PNG

23
00:00:51,719 --> 00:00:58,079
images out the other end that is all

24
00:00:55,979 --> 00:01:00,058
we're doing today so we're just going to

25
00:00:58,079 --> 00:01:03,840
look at that code and figure out what's

26
00:01:00,058 --> 00:01:09,298
wrong with it now if you remember

27
00:01:03,840 --> 00:01:11,520
correctly we are going in phases right

28
00:01:09,299 --> 00:01:13,229
now we have not really looked very

29
00:01:11,519 --> 00:01:15,658
carefully at trying to make sure that

30
00:01:13,228 --> 00:01:19,319
our output is correct we sort of

31
00:01:15,659 --> 00:01:22,140
cursorily inspected it but we haven't

32
00:01:19,319 --> 00:01:25,199
really taken the time to test to make

33
00:01:22,140 --> 00:01:26,728
sure it's exactly right and so that's

34
00:01:25,200 --> 00:01:28,950
something we might do a little later on

35
00:01:26,728 --> 00:01:30,929
right now what we're doing is trying to

36
00:01:28,950 --> 00:01:33,560
figure out how to make sure our

37
00:01:30,930 --> 00:01:36,270
decompressor produces consistent output

38
00:01:33,560 --> 00:01:38,430
what I mean by that is that it should

39
00:01:36,269 --> 00:01:41,789
always produce an image of the size that

40
00:01:38,430 --> 00:01:44,220
we were told that we had and the reason

41
00:01:41,790 --> 00:01:46,860
that this is a difficult problem is

42
00:01:44,219 --> 00:01:48,840
because if you think about what happens

43
00:01:46,859 --> 00:01:51,450
with a Huffman encoder or other kinds of

44
00:01:48,840 --> 00:01:55,680
things like that like are in play with

45
00:01:51,450 --> 00:01:58,530
PNG compressed file formats and like any

46
00:01:55,680 --> 00:02:01,409
little bug that you have in interpreting

47
00:01:58,530 --> 00:02:04,890
how many times to replicate a symbol or

48
00:02:01,409 --> 00:02:07,350
what the particular symbol code should

49
00:02:04,890 --> 00:02:10,199
be or any of those sorts of things they

50
00:02:07,349 --> 00:02:12,120
will lead to you misinterpreting the

51
00:02:10,199 --> 00:02:13,479
data stream which will lead to producing

52
00:02:12,120 --> 00:02:16,539
too much or too little

53
00:02:13,479 --> 00:02:19,479
data and so what we will find when we

54
00:02:16,539 --> 00:02:21,729
debug this situation for example is that

55
00:02:19,479 --> 00:02:23,500
something we have done incorrectly in

56
00:02:21,729 --> 00:02:25,988
how we are handling the data stream is

57
00:02:23,500 --> 00:02:28,239
causing us to produce say too much

58
00:02:25,989 --> 00:02:29,378
information or it's causing us to try to

59
00:02:28,239 --> 00:02:31,420
because remember this is a dictionary

60
00:02:29,378 --> 00:02:35,378
compressor so we read from our output to

61
00:02:31,419 --> 00:02:37,628
produce new output so we read from both

62
00:02:35,378 --> 00:02:40,239
the input and the output when we have

63
00:02:37,628 --> 00:02:41,798
look backs we may if we misinterpret the

64
00:02:40,239 --> 00:02:45,009
look backs we will jump too far

65
00:02:41,799 --> 00:02:47,860
backwards all of those sorts of things

66
00:02:45,009 --> 00:02:49,989
they're very twiki and very finicky you

67
00:02:47,860 --> 00:02:52,540
can get just one little bit wrong and

68
00:02:49,989 --> 00:02:54,909
you can still decode several images

69
00:02:52,539 --> 00:02:58,358
perhaps but when you get a particular

70
00:02:54,909 --> 00:03:00,459
image that has some aspect to it that

71
00:02:58,359 --> 00:03:04,359
that hits upon the thing that you've

72
00:03:00,459 --> 00:03:06,370
done incorrectly that case will lead you

73
00:03:04,359 --> 00:03:08,200
to produce too much too little data read

74
00:03:06,370 --> 00:03:10,120
outside the image whatever so what we're

75
00:03:08,199 --> 00:03:11,439
trying to do right now is get our system

76
00:03:10,120 --> 00:03:13,180
to the point where we don't do that

77
00:03:11,439 --> 00:03:15,280
anymore that doesn't mean we're

78
00:03:13,180 --> 00:03:18,549
producing the right images we can still

79
00:03:15,280 --> 00:03:23,169
have bugs that are unrelated to properly

80
00:03:18,549 --> 00:03:24,430
decompressing the literal bit stream but

81
00:03:23,169 --> 00:03:26,519
right now we're trying to do is get to

82
00:03:24,430 --> 00:03:30,459
that point so we want our Huffman

83
00:03:26,519 --> 00:03:34,719
decoder to always produce the right

84
00:03:30,459 --> 00:03:39,579
number of bytes when we get an input

85
00:03:34,719 --> 00:03:41,799
stream from a PNG so what we want to do

86
00:03:39,579 --> 00:03:45,250
today is to start working towards that

87
00:03:41,799 --> 00:03:46,930
and we're not that far but even though I

88
00:03:45,250 --> 00:03:49,959
think we're not very far from a working

89
00:03:46,930 --> 00:03:51,099
PNG compressor this is hard debugging

90
00:03:49,959 --> 00:03:52,750
this is the kind of onion that's

91
00:03:51,098 --> 00:03:54,759
difficult because we didn't write the

92
00:03:52,750 --> 00:03:56,259
file format we're just going based off

93
00:03:54,759 --> 00:03:57,638
what we think we understand from the

94
00:03:56,259 --> 00:04:00,638
spec which we don't actually know that

95
00:03:57,639 --> 00:04:03,040
we do right and so we're constantly not

96
00:04:00,639 --> 00:04:05,859
sure exactly what we should or shouldn't

97
00:04:03,039 --> 00:04:08,789
see in any particular place that makes

98
00:04:05,859 --> 00:04:08,790
debugging difficult

99
00:04:14,039 --> 00:04:20,709
now I will also point out the fact that

100
00:04:17,548 --> 00:04:25,959
if you had to write your own PNG reader

101
00:04:20,709 --> 00:04:29,459
at home for some reason and you it was

102
00:04:25,959 --> 00:04:31,930
not about a programming exercise a

103
00:04:29,459 --> 00:04:35,919
perfectly reasonable thing to do is to

104
00:04:31,930 --> 00:04:38,590
look at someone else's PNG reader run

105
00:04:35,920 --> 00:04:40,990
that PNG reader to the same point in the

106
00:04:38,589 --> 00:04:42,639
output as yours see if your output

107
00:04:40,990 --> 00:04:44,829
matches this can help you figure out

108
00:04:42,639 --> 00:04:46,449
where you've gone wrong so having a

109
00:04:44,829 --> 00:04:49,149
working version can be a very valuable

110
00:04:46,449 --> 00:04:52,149
way to debug something I don't want to

111
00:04:49,149 --> 00:04:53,799
do that because I want to show you the

112
00:04:52,149 --> 00:04:55,569
process and this is why I've done it

113
00:04:53,800 --> 00:04:58,689
this way so far the process of going

114
00:04:55,569 --> 00:05:00,579
from just a speck because if you are

115
00:04:58,689 --> 00:05:01,930
someone who programs new stuff does

116
00:05:00,579 --> 00:05:03,550
engine programming that starts before

117
00:05:01,930 --> 00:05:06,000
living you will often come into

118
00:05:03,550 --> 00:05:08,650
circumstances where you do not have

119
00:05:06,000 --> 00:05:12,879
working versions of something that you

120
00:05:08,649 --> 00:05:14,439
need to load so I don't mean to imply

121
00:05:12,879 --> 00:05:16,839
that you shouldn't do that

122
00:05:14,439 --> 00:05:18,339
you should it's a useful technique it's

123
00:05:16,839 --> 00:05:18,729
just I won't trying to show at this

124
00:05:18,339 --> 00:05:20,889
point

125
00:05:18,730 --> 00:05:22,629
how did debug or what the process looks

126
00:05:20,889 --> 00:05:24,909
like when you're trying to bug something

127
00:05:22,629 --> 00:05:27,040
where you don't have the luxury of just

128
00:05:24,910 --> 00:05:28,810
being able to go and look response code

129
00:05:27,040 --> 00:05:30,310
same without hand mate how in hammer

130
00:05:28,810 --> 00:05:32,139
here we will often rewrite something

131
00:05:30,310 --> 00:05:33,790
maybe we could have gone and gotten code

132
00:05:32,139 --> 00:05:36,849
to do for example something that was in

133
00:05:33,790 --> 00:05:38,710
an STB library again the reason for that

134
00:05:36,850 --> 00:05:39,939
is because this is educational we're

135
00:05:38,709 --> 00:05:42,728
supposed to be showing how to do these

136
00:05:39,939 --> 00:05:44,978
things because you don't always have one

137
00:05:42,728 --> 00:05:46,449
available if you are a programmer who's

138
00:05:44,978 --> 00:05:48,430
you know pushing the boundary is working

139
00:05:46,449 --> 00:05:50,560
on a new engine working on things that

140
00:05:48,430 --> 00:05:51,939
people haven't done before you don't

141
00:05:50,560 --> 00:05:55,540
have the luxury of going Stack Exchange

142
00:05:51,939 --> 00:06:01,120
and posting a stupid question so let's

143
00:05:55,540 --> 00:06:03,640
go ahead and finish with that this is

144
00:06:01,120 --> 00:06:06,819
the broken file and just to refresh your

145
00:06:03,639 --> 00:06:09,310
memory when we run it what we see when

146
00:06:06,819 --> 00:06:12,519
we get to this point you can see that we

147
00:06:09,310 --> 00:06:14,139
have two our two pointers here right

148
00:06:12,519 --> 00:06:16,478
we've got the source that we're supposed

149
00:06:14,139 --> 00:06:18,668
to be reppin from we have the desk that

150
00:06:16,478 --> 00:06:21,250
we are writing to and when we look at

151
00:06:18,668 --> 00:06:24,728
these two what we see here actually is

152
00:06:21,250 --> 00:06:25,930
that the source is not actually off the

153
00:06:24,728 --> 00:06:28,269
end

154
00:06:25,930 --> 00:06:32,079
so you can kind of see here I don't know

155
00:06:28,269 --> 00:06:35,319
if this will let me do this huh that's

156
00:06:32,079 --> 00:06:38,349
what I wanted what you can see here is

157
00:06:35,319 --> 00:06:40,469
that the source technically this line

158
00:06:38,350 --> 00:06:43,000
will not crash the source the source

159
00:06:40,470 --> 00:06:45,670
technically is still readable it looks

160
00:06:43,000 --> 00:06:47,740
like here right because the the the very

161
00:06:45,670 --> 00:06:50,710
specific one it is reading is actually

162
00:06:47,740 --> 00:06:51,519
still valid now it would have crashed

163
00:06:50,709 --> 00:06:54,189
right

164
00:06:51,519 --> 00:06:56,649
it still has 46 ago it would have

165
00:06:54,189 --> 00:07:00,069
crashed the source but it's actually the

166
00:06:56,649 --> 00:07:04,000
dest that crashed first so you can see

167
00:07:00,069 --> 00:07:05,620
here that it wrote the 243 out let me

168
00:07:04,000 --> 00:07:09,009
just take a look here let's let's take a

169
00:07:05,620 --> 00:07:11,920
look at what was was in the previous

170
00:07:09,009 --> 00:07:15,269
wrap of both of these guys just so we

171
00:07:11,920 --> 00:07:15,270
can get an idea what that was

172
00:07:15,360 --> 00:07:24,340
yeah so it copied this 243 to this 243

173
00:07:20,620 --> 00:07:27,250
it did that copy right but then when it

174
00:07:24,339 --> 00:07:30,429
went to advance the source it was like

175
00:07:27,250 --> 00:07:31,959
oh I could read you know another 243

176
00:07:30,430 --> 00:07:34,660
that would be just fine

177
00:07:31,959 --> 00:07:39,399
and then the desk was like I can't read

178
00:07:34,660 --> 00:07:41,320
the memory now what I want you to build

179
00:07:39,399 --> 00:07:42,909
in your mind here because again we're

180
00:07:41,319 --> 00:07:44,920
trying to debug a fairly complex

181
00:07:42,910 --> 00:07:48,130
circumstance so I would encourage you to

182
00:07:44,920 --> 00:07:50,110
really try to visualize in your head as

183
00:07:48,129 --> 00:07:53,670
you're going through this what is

184
00:07:50,110 --> 00:08:00,180
actually literally happening here right

185
00:07:53,670 --> 00:08:02,830
well what you can see is res an LZ

186
00:08:00,180 --> 00:08:05,230
compressor right it's an LZ style

187
00:08:02,829 --> 00:08:08,800
compressor what that means is when I'm

188
00:08:05,230 --> 00:08:11,170
reading source and destination in like

189
00:08:08,800 --> 00:08:14,430
this case here right what I'm doing is

190
00:08:11,170 --> 00:08:17,230
I'm reading from the destination and

191
00:08:14,430 --> 00:08:19,150
copying it into the destination right I

192
00:08:17,230 --> 00:08:20,950
know it seems weird because normally we

193
00:08:19,149 --> 00:08:22,929
think of copying from one place to

194
00:08:20,949 --> 00:08:25,120
another and they're different in this

195
00:08:22,930 --> 00:08:28,000
case they're the same now I'm copying

196
00:08:25,120 --> 00:08:30,160
slightly offset right so that's why it

197
00:08:28,000 --> 00:08:31,420
works I'm not copying from literally the

198
00:08:30,160 --> 00:08:33,279
same place to the same place otherwise

199
00:08:31,420 --> 00:08:35,379
we'd do nothing right I'm copying from a

200
00:08:33,279 --> 00:08:36,879
little bit offset so I'm just a little

201
00:08:35,379 --> 00:08:38,409
bit back I'm reading a little bit

202
00:08:36,879 --> 00:08:39,909
backwards and writing a little bit

203
00:08:38,409 --> 00:08:42,759
forwards right

204
00:08:39,909 --> 00:08:44,168
or maybe a lot depending on the jump but

205
00:08:42,759 --> 00:08:45,669
what I want you understand is so the

206
00:08:44,168 --> 00:08:49,419
source and destination are the same

207
00:08:45,669 --> 00:08:54,159
block of memory and if we look at what

208
00:08:49,419 --> 00:08:57,639
their actual values are do you see this

209
00:08:54,159 --> 00:09:00,189
they're very close right what's the

210
00:08:57,639 --> 00:09:05,169
source plus one it's the destination

211
00:09:00,190 --> 00:09:10,150
right so even just from this one stop

212
00:09:05,169 --> 00:09:12,279
here I can see the thing that we that we

213
00:09:10,149 --> 00:09:13,569
sort of went out on now we don't know

214
00:09:12,279 --> 00:09:15,159
this was the cause of the error because

215
00:09:13,570 --> 00:09:16,840
it could have been multiple compounding

216
00:09:15,159 --> 00:09:20,019
errors going forward we have no idea

217
00:09:16,840 --> 00:09:24,100
where the actual bug is but the actual

218
00:09:20,019 --> 00:09:27,340
cause of the stoppage was a rep

219
00:09:24,100 --> 00:09:30,700
instruction where we were told to

220
00:09:27,340 --> 00:09:33,009
basically copy a byte many many many

221
00:09:30,700 --> 00:09:35,140
times now what do I mean by that well in

222
00:09:33,009 --> 00:09:36,639
an LZ compressor and I covered this

223
00:09:35,139 --> 00:09:38,350
before so hopefully those of you who

224
00:09:36,639 --> 00:09:40,659
have your thinking caps on will remember

225
00:09:38,350 --> 00:09:43,930
what I'm talking about in an LZ

226
00:09:40,659 --> 00:09:48,100
compressor it can go ahead and encode

227
00:09:43,929 --> 00:09:50,919
effectively a run length encoding LZ

228
00:09:48,100 --> 00:09:53,230
compressor is normally made to take

229
00:09:50,919 --> 00:09:56,349
chunks of data and move them forward

230
00:09:53,230 --> 00:09:57,940
right oh I see this thing and I want to

231
00:09:56,350 --> 00:10:01,899
copy it here because I'm repeating

232
00:09:57,940 --> 00:10:06,250
myself right but it is not limited to

233
00:10:01,899 --> 00:10:09,309
that it can also repeat the most recent

234
00:10:06,250 --> 00:10:12,190
chunk of data however long you want the

235
00:10:09,309 --> 00:10:14,889
most recent thing that thing can be

236
00:10:12,190 --> 00:10:16,600
repeated at infinity of times well not

237
00:10:14,889 --> 00:10:19,569
infinity whatever the maximum repeat

238
00:10:16,600 --> 00:10:23,470
count is right how do I do that well

239
00:10:19,570 --> 00:10:24,970
let's say that I copied ABCD efg right

240
00:10:23,470 --> 00:10:26,620
and that's what's sitting in the

241
00:10:24,970 --> 00:10:30,190
destination and now I'm going to write

242
00:10:26,620 --> 00:10:34,899
after it right well if I just tell you

243
00:10:30,190 --> 00:10:36,850
to go back to the a and copy 20,000

244
00:10:34,899 --> 00:10:40,209
characters what will you do well you'll

245
00:10:36,850 --> 00:10:41,769
write ABCD efg into the output then

246
00:10:40,210 --> 00:10:44,620
you'll start reading from the place that

247
00:10:41,769 --> 00:10:47,379
you just wrote ABCD efg which will cause

248
00:10:44,620 --> 00:10:49,450
you to write another ABCD efg and you'll

249
00:10:47,379 --> 00:10:51,879
just keep rewriting the thing you just

250
00:10:49,450 --> 00:10:52,710
wrote over and over and over again so in

251
00:10:51,879 --> 00:10:55,620
LG Chem

252
00:10:52,710 --> 00:10:58,019
sir has a way of encoding effectively a

253
00:10:55,620 --> 00:11:02,429
block that just repeats many many times

254
00:10:58,019 --> 00:11:05,189
all it has to do is first do one copy

255
00:11:02,429 --> 00:11:08,009
from somewhere way back into the stream

256
00:11:05,190 --> 00:11:11,790
to find the block it needs copy it once

257
00:11:08,009 --> 00:11:13,850
now it just says go back however many

258
00:11:11,789 --> 00:11:16,588
long that block was and then just

259
00:11:13,850 --> 00:11:18,659
however many copies it wants it can just

260
00:11:16,589 --> 00:11:20,520
kind of copy it ad infinitum bla bla bla

261
00:11:18,659 --> 00:11:22,980
bla baby my baby my plan right so just

262
00:11:20,519 --> 00:11:24,838
keep taking the block writing it into

263
00:11:22,980 --> 00:11:26,278
the destination now it'll start reading

264
00:11:24,839 --> 00:11:27,630
from that place right into the

265
00:11:26,278 --> 00:11:30,389
destination reads in that plate right

266
00:11:27,629 --> 00:11:32,580
it's always one block behind itself

267
00:11:30,389 --> 00:11:35,759
reading and one block behind itself

268
00:11:32,580 --> 00:11:36,180
writing that's exactly what we went out

269
00:11:35,759 --> 00:11:39,720
on

270
00:11:36,179 --> 00:11:42,629
so we faulted on a place where we had

271
00:11:39,720 --> 00:11:48,000
some kind of a length where we were told

272
00:11:42,629 --> 00:11:50,549
you need to repeat the value 243 for a

273
00:11:48,000 --> 00:11:55,230
long long long long long long long long

274
00:11:50,549 --> 00:11:59,039
time right so we need at least 46 of

275
00:11:55,230 --> 00:12:00,950
these right who knows how many it

276
00:11:59,039 --> 00:12:07,949
actually was we don't have an original

277
00:12:00,950 --> 00:12:09,930
length here the Len tab symbol was 258

278
00:12:07,950 --> 00:12:17,910
so I think that means we were it was at

279
00:12:09,929 --> 00:12:21,179
least yeah it's at least 258 long and

280
00:12:17,909 --> 00:12:24,929
the distance here was what we know what

281
00:12:21,179 --> 00:12:26,399
this is was it was one backward right so

282
00:12:24,929 --> 00:12:27,750
we don't know what the actual length is

283
00:12:26,399 --> 00:12:29,699
because we don't know what the extra

284
00:12:27,750 --> 00:12:31,950
bits are because obviously you know how

285
00:12:29,700 --> 00:12:33,778
good visual studio ever show us the

286
00:12:31,950 --> 00:12:35,190
value of extra bits because it was in

287
00:12:33,778 --> 00:12:36,870
this other block I mean it's impossible

288
00:12:35,190 --> 00:12:40,440
right I mean how could you ever do it

289
00:12:36,870 --> 00:12:41,850
let's not ask for miracles inspecting a

290
00:12:40,440 --> 00:12:43,709
variable that was used just a few lines

291
00:12:41,850 --> 00:12:46,500
before is probably completely out of the

292
00:12:43,708 --> 00:12:53,719
question I don't know if even in debug

293
00:12:46,500 --> 00:12:56,190
mode don't ask me it used to work I

294
00:12:53,720 --> 00:12:57,810
don't know if the compiler now over

295
00:12:56,190 --> 00:12:59,370
writes those values even in debug mode

296
00:12:57,809 --> 00:13:01,289
or something I'm not sure but anyway

297
00:12:59,370 --> 00:13:05,519
neither here nor there Visual Studio as

298
00:13:01,289 --> 00:13:06,009
always happy did not help you but point

299
00:13:05,519 --> 00:13:10,829
being

300
00:13:06,009 --> 00:13:14,350
length was not 46 it was 258 or more

301
00:13:10,830 --> 00:13:18,520
originally and then we started copying

302
00:13:14,350 --> 00:13:20,409
that 243 and we just kept on copying so

303
00:13:18,519 --> 00:13:23,139
instead of stopping at the end of the

304
00:13:20,409 --> 00:13:26,829
buffer where we should have stopped

305
00:13:23,139 --> 00:13:30,069
we just didn't write so what I want to

306
00:13:26,830 --> 00:13:32,170
do very quickly is I want to go ahead

307
00:13:30,070 --> 00:13:34,930
and see what happens next

308
00:13:32,169 --> 00:13:39,610
so I'm going to go ahead and set length

309
00:13:34,929 --> 00:13:44,439
equal to zero all right guess I'll do

310
00:13:39,610 --> 00:13:48,759
now I'll do zero and then I'm going to

311
00:13:44,440 --> 00:13:54,040
go ahead and let this thing bottom out

312
00:13:48,759 --> 00:13:56,169
so now we're outside of this function I

313
00:13:54,039 --> 00:14:10,029
want to see what comes next

314
00:13:56,169 --> 00:14:12,519
right so it's another 258 oso cubed e

315
00:14:10,029 --> 00:14:14,860
bits used as 0 so I guess there would be

316
00:14:12,519 --> 00:14:18,429
no extra bits anyway so visual studio

317
00:14:14,860 --> 00:14:20,560
doesn't really didn't really screw us

318
00:14:18,429 --> 00:14:23,439
too hard there because it turns out that

319
00:14:20,559 --> 00:14:25,869
extra bits would have wouldn't have been

320
00:14:23,440 --> 00:14:27,160
necessary so the fact that it never lets

321
00:14:25,870 --> 00:14:28,720
us inspect any of these variables

322
00:14:27,159 --> 00:14:30,639
doesn't matter because they weren't

323
00:14:28,720 --> 00:14:37,060
actually used in that case so we know it

324
00:14:30,639 --> 00:14:39,069
actually was 258 was the Rob right the

325
00:14:37,059 --> 00:14:45,189
distance is 1 again and off we go

326
00:14:39,070 --> 00:14:48,040
ok so what we're looking at here is a

327
00:14:45,190 --> 00:14:51,880
bunch of Rob's that seem to be going too

328
00:14:48,039 --> 00:14:53,709
far I'm gonna start I'm gonna just start

329
00:14:51,879 --> 00:14:56,409
by looking at this routine a little bit

330
00:14:53,710 --> 00:14:58,870
more closely this is not because I

331
00:14:56,409 --> 00:15:01,750
suspect if the bug is here I just we

332
00:14:58,870 --> 00:15:02,590
haven't really spent much time looking

333
00:15:01,750 --> 00:15:05,049
at it

334
00:15:02,590 --> 00:15:07,269
I just want to quickly before I start

335
00:15:05,049 --> 00:15:09,909
digging deeper and making some test

336
00:15:07,269 --> 00:15:12,370
cases in here and stuff like that I just

337
00:15:09,909 --> 00:15:14,860
want to quickly verify to myself because

338
00:15:12,370 --> 00:15:17,500
I don't really know that I didn't do

339
00:15:14,860 --> 00:15:19,850
anything obviously stupid with like

340
00:15:17,500 --> 00:15:21,379
those tables or

341
00:15:19,850 --> 00:15:24,050
the way that we're decoding these things

342
00:15:21,379 --> 00:15:28,669
so I want to kind of I want to just look

343
00:15:24,049 --> 00:15:34,429
at this and get a sense for whether or

344
00:15:28,669 --> 00:15:39,078
not I've you know I've whether or not

345
00:15:34,429 --> 00:15:41,000
I've decoded this properly right so

346
00:15:39,078 --> 00:15:43,849
we're doing a lip a literal or length

347
00:15:41,000 --> 00:15:45,708
Huffman de code here and that you know

348
00:15:43,850 --> 00:15:47,300
one thing we could have screwed up is

349
00:15:45,708 --> 00:15:50,328
these Huffman tables so we're doing that

350
00:15:47,299 --> 00:15:52,969
that decode here and then we're going to

351
00:15:50,328 --> 00:15:56,208
output literals in the case where we

352
00:15:52,970 --> 00:15:58,670
ended up with binary codes less than two

353
00:15:56,208 --> 00:16:01,778
to five right we're gonna write those

354
00:15:58,669 --> 00:16:04,068
out so that seems pretty straightforward

355
00:16:01,778 --> 00:16:07,009
that case doesn't seem like it's

356
00:16:04,068 --> 00:16:09,379
probably all that unlikely 256 is

357
00:16:07,009 --> 00:16:11,120
actually our stoppage case so you'll

358
00:16:09,379 --> 00:16:14,049
notice too many six just falls out to

359
00:16:11,120 --> 00:16:17,509
nothing in the case that we're over 256

360
00:16:14,049 --> 00:16:19,250
we then have this sort of lend tabindex

361
00:16:17,509 --> 00:16:21,470
thing I don't do we use little n

362
00:16:19,250 --> 00:16:23,179
anywhere else we don't so basically we

363
00:16:21,470 --> 00:16:24,970
immediately take that and turn it into

364
00:16:23,179 --> 00:16:28,129
something we can look up into the table

365
00:16:24,970 --> 00:16:32,209
you can see us looking it up here and

366
00:16:28,129 --> 00:16:34,909
basically what we want is our length to

367
00:16:32,208 --> 00:16:36,919
be read out of there now I want to go

368
00:16:34,909 --> 00:16:38,600
back and look at that table calculation

369
00:16:36,919 --> 00:16:40,879
I want to look at all of this stuff I

370
00:16:38,600 --> 00:16:44,170
want to make sure that this makes sense

371
00:16:40,879 --> 00:16:46,938
because I don't know that it does right

372
00:16:44,169 --> 00:16:49,059
so I want to kind of get a sense of

373
00:16:46,938 --> 00:16:53,539
whether this is working properly or not

374
00:16:49,059 --> 00:16:55,758
so here's the length extra lookup table

375
00:16:53,539 --> 00:16:57,889
that we've got here here's the PNG dis

376
00:16:55,759 --> 00:17:00,620
extra these are the two things that

377
00:16:57,889 --> 00:17:05,150
we're looking up into so if I look into

378
00:17:00,620 --> 00:17:06,828
this table looking up the bits here so

379
00:17:05,150 --> 00:17:09,949
that means we jumped all the way to like

380
00:17:06,828 --> 00:17:11,720
this one right if it was 258 with zero

381
00:17:09,949 --> 00:17:14,689
extra bits that means that we were

382
00:17:11,720 --> 00:17:16,970
encoding value 285 into the table all

383
00:17:14,689 --> 00:17:19,788
the time which was this one right here

384
00:17:16,970 --> 00:17:23,779
right and that again doesn't consume any

385
00:17:19,788 --> 00:17:27,349
extra bits it just uses the straight 258

386
00:17:23,779 --> 00:17:29,569
length value so I'm gonna go again I

387
00:17:27,349 --> 00:17:31,699
want to like just validate this table

388
00:17:29,569 --> 00:17:33,168
and I also want to look to make sure

389
00:17:31,700 --> 00:17:35,840
that

390
00:17:33,169 --> 00:17:38,450
I'm interpreting that case correctly and

391
00:17:35,839 --> 00:17:42,769
and not doing anything stupid in this

392
00:17:38,450 --> 00:17:45,679
case right alright so here's that

393
00:17:42,769 --> 00:17:48,288
deflate algorithm here and here's that

394
00:17:45,679 --> 00:17:51,080
table that we looked at before so if we

395
00:17:48,288 --> 00:17:53,480
got value 257 we expect extra bits of

396
00:17:51,079 --> 00:17:55,609
zero and a length of three right so

397
00:17:53,480 --> 00:17:57,140
here's three zero right it's like three

398
00:17:55,609 --> 00:17:59,298
four five six seven eight nine ten to go

399
00:17:57,140 --> 00:18:01,820
to leave to 64 so three four five six

400
00:17:59,298 --> 00:18:03,440
seven eight nine ten goes to 264 and

401
00:18:01,819 --> 00:18:08,769
that's good right

402
00:18:03,440 --> 00:18:08,769
then we have 265 it starts at one and

403
00:18:12,278 --> 00:18:23,898
sorry it starts at eleven yeah starts at

404
00:18:18,859 --> 00:18:32,269
eleven and reads one bit 13 15 17 19 15

405
00:18:23,898 --> 00:18:34,658
17 19 23 27 31 and those were four twos

406
00:18:32,269 --> 00:18:36,950
right - two - two

407
00:18:34,659 --> 00:18:40,600
then we go to the threes thirty-five and

408
00:18:36,950 --> 00:18:58,389
forty three thirty five forty three

409
00:18:40,599 --> 00:18:58,388
fifty one fifty nine yeah 67 83 99 115

410
00:19:00,069 --> 00:19:11,569
those are our forests 131 163 195 227

411
00:19:07,419 --> 00:19:13,100
258 okay so I just want to spot check

412
00:19:11,569 --> 00:19:17,148
that table you know we hadn't really

413
00:19:13,099 --> 00:19:19,329
looked at it much looks reasonable let

414
00:19:17,148 --> 00:19:23,449
me just take a look at this one as well

415
00:19:19,329 --> 00:19:25,849
again make sure we've got our extra bits

416
00:19:23,450 --> 00:19:26,990
here there's four zeros and the distance

417
00:19:25,849 --> 00:19:31,158
is one two three four

418
00:19:26,990 --> 00:19:33,319
just before then we've got let's see

419
00:19:31,159 --> 00:19:37,580
what we got here five seven nine I'm

420
00:19:33,319 --> 00:19:41,059
sorry five and seven yep 9 13

421
00:19:37,579 --> 00:19:41,059
[Music]

422
00:19:41,519 --> 00:19:58,639
yeah 17:25 let's see we got 33 4965 97

423
00:19:58,880 --> 00:20:29,490
129 and 193 57 385 yeah 513 769 let's

424
00:20:17,730 --> 00:20:38,789
see 1025 1537 240 not 2049 3073 both

425
00:20:29,490 --> 00:20:52,710
tens 4097 6145 those are both 1180 193

426
00:20:38,789 --> 00:20:58,579
is a 12 1 2 2 8 9 12 16 385 13 and 24

427
00:20:52,710 --> 00:21:00,710
577 so 13 okay so I think those are

428
00:20:58,579 --> 00:21:04,139
right

429
00:21:00,710 --> 00:21:04,140
[Music]

430
00:21:09,890 --> 00:21:13,950
Cephas was drafted because secretary

431
00:21:12,119 --> 00:21:15,539
cigarettes either literal bytes from the

432
00:21:13,950 --> 00:21:17,279
alphabet of byte valiance lengths

433
00:21:15,539 --> 00:21:20,279
backward distance pairs where the length

434
00:21:17,279 --> 00:21:23,399
is drawn from 358 and the distance is

435
00:21:20,279 --> 00:21:25,170
drawn from 1 to 32 blah

436
00:21:23,400 --> 00:21:27,570
in fact the literal in length outfits

437
00:21:25,170 --> 00:21:30,660
are merged into a single alphabet we're

438
00:21:27,569 --> 00:21:34,319
evaluating the value to said block 27 to

439
00:21:30,660 --> 00:21:43,610
delink codes extra bits follows blah

440
00:21:34,319 --> 00:21:46,169
blah blah okay

441
00:21:43,609 --> 00:21:49,729
the co-surgeon extra code straight above

442
00:21:46,170 --> 00:21:49,730
we show the code feel for added clarity

443
00:21:55,910 --> 00:22:09,870
literal length values 286 &amp; 287 will

444
00:22:06,390 --> 00:22:13,880
never actually occur in the compressed

445
00:22:09,869 --> 00:22:20,929
data but participate in the code

446
00:22:13,880 --> 00:22:20,930
construction okay

447
00:22:29,000 --> 00:22:33,049
what is meant by that

448
00:22:38,940 --> 00:22:50,720
our distance code 0 through 31 are

449
00:22:48,119 --> 00:22:53,189
represented by fixed length 5 bit codes

450
00:22:50,720 --> 00:23:00,779
with possible additional bits as shown

451
00:22:53,190 --> 00:23:13,049
in the table and 30 and 31 will never

452
00:23:00,779 --> 00:23:15,480
occur alright so I just want to make

453
00:23:13,049 --> 00:23:18,029
sure I understand that last part there

454
00:23:15,480 --> 00:23:22,700
so when we're creating these tables for

455
00:23:18,029 --> 00:23:25,649
the literal length Huffman's here so

456
00:23:22,700 --> 00:23:29,610
when we create these Huffman tables

457
00:23:25,650 --> 00:23:39,259
we're gonna read in how long the table

458
00:23:29,609 --> 00:23:39,259
was so

459
00:23:49,410 --> 00:23:56,940
so basically I don't know that we care

460
00:23:54,369 --> 00:23:59,918
about that part because it seems like

461
00:23:56,940 --> 00:24:02,650
they would have told us whether or not

462
00:23:59,919 --> 00:24:07,270
those things like when we actually read

463
00:24:02,650 --> 00:24:10,540
the H lit value in the H lit value will

464
00:24:07,269 --> 00:24:14,829
tell us how many things participate in

465
00:24:10,539 --> 00:24:25,509
the table construction so don't quite

466
00:24:14,829 --> 00:24:31,529
get that part of it not feeling great

467
00:24:25,509 --> 00:24:31,529
about that not feeling great about that

468
00:24:42,210 --> 00:24:48,340
yeah I might want to look at that anyway

469
00:24:46,359 --> 00:24:55,449
we have the little end this table the

470
00:24:48,339 --> 00:24:59,109
little end disable let's see so it's 32

471
00:24:55,450 --> 00:25:01,930
64 plus 2 57 yeah that's gonna fit in

472
00:24:59,109 --> 00:25:09,039
there just fine I

473
00:25:01,930 --> 00:25:18,250
I should probably assert here what did I

474
00:25:09,039 --> 00:25:21,039
just do so I'm gonna go ahead and just

475
00:25:18,250 --> 00:25:23,140
assert in here that the length count is

476
00:25:21,039 --> 00:25:26,079
less than or equal to the array account

477
00:25:23,140 --> 00:25:27,370
of the whittlin disc table just because

478
00:25:26,079 --> 00:25:29,230
I didn't don't know why I didn't put my

479
00:25:27,369 --> 00:25:35,109
name before but that's like a hard bound

480
00:25:29,230 --> 00:25:36,819
on that obviously so yeah so coming

481
00:25:35,109 --> 00:25:40,479
through here where I do the compute huff

482
00:25:36,819 --> 00:25:43,629
man we should look at those Huffman

483
00:25:40,480 --> 00:25:49,960
codes so the Huffman decode then when we

484
00:25:43,630 --> 00:26:03,220
grab out these this part here we look up

485
00:25:49,960 --> 00:26:05,350
the Hoffman decode so we subtract 257

486
00:26:03,220 --> 00:26:08,500
from it because that's the base value

487
00:26:05,349 --> 00:26:10,509
that seems correct when we look up into

488
00:26:08,500 --> 00:26:12,549
our length table we start with whatever

489
00:26:10,509 --> 00:26:16,240
the base value has to be we then look at

490
00:26:12,549 --> 00:26:20,549
how many bits we consume extra from the

491
00:26:16,240 --> 00:26:23,289
input data we grab those bits and we

492
00:26:20,549 --> 00:26:25,960
just add that in as the additional

493
00:26:23,289 --> 00:26:32,170
length value we then go into the dist

494
00:26:25,960 --> 00:26:39,029
tab index that Huffman 2 code is using

495
00:26:32,170 --> 00:26:42,810
the other Huffman table this one so I

496
00:26:39,029 --> 00:26:46,649
feel like and maybe I'm being premature

497
00:26:42,809 --> 00:26:53,079
but I feel like this part is not

498
00:26:46,650 --> 00:26:55,269
relevant well that's not true so this

499
00:26:53,079 --> 00:26:57,669
part cannot cause us to be

500
00:26:55,269 --> 00:27:00,639
wrong in the way that we were wrong

501
00:26:57,670 --> 00:27:02,410
meaning we weren't fetching off the

502
00:27:00,640 --> 00:27:05,650
beginning of the buffer so our distance

503
00:27:02,410 --> 00:27:09,160
value even if it was wrong isn't causing

504
00:27:05,650 --> 00:27:11,080
the problem but I shouldn't say that it

505
00:27:09,160 --> 00:27:13,180
can't still be the cause of the problem

506
00:27:11,079 --> 00:27:16,319
and the reason for that is because if

507
00:27:13,180 --> 00:27:20,259
you look at this extra bit situation

508
00:27:16,319 --> 00:27:23,889
because reading the Huffman out of here

509
00:27:20,259 --> 00:27:26,769
then tells us how many extra bits we

510
00:27:23,890 --> 00:27:29,320
should read if this is done incorrectly

511
00:27:26,769 --> 00:27:33,240
it's the like the Huffman table was

512
00:27:29,319 --> 00:27:36,549
built incorrectly we will get the wrong

513
00:27:33,240 --> 00:27:39,370
symbol value out and that will then

514
00:27:36,549 --> 00:27:41,529
cause us to read the wrong number of

515
00:27:39,369 --> 00:27:45,369
bits when we read the wrong number of

516
00:27:41,529 --> 00:27:48,430
bits we put our stream off by some

517
00:27:45,369 --> 00:27:49,899
number of bits and then everything

518
00:27:48,430 --> 00:27:53,410
subsequent will be wrong

519
00:27:49,900 --> 00:27:56,290
you know I'm saying so even though this

520
00:27:53,410 --> 00:27:58,210
itself getting the distance wrong is not

521
00:27:56,289 --> 00:28:04,149
relevant getting this this number wrong

522
00:27:58,210 --> 00:28:08,519
is not relevant to the - getting the

523
00:28:04,150 --> 00:28:12,640
wrong number of bytes in the output but

524
00:28:08,519 --> 00:28:14,889
it still can be the cause of that

525
00:28:12,640 --> 00:28:25,180
problem because of the stream offset

526
00:28:14,890 --> 00:28:33,180
right uh so yeah so what I could do here

527
00:28:25,180 --> 00:28:33,180
- we can stop a little earlier

528
00:28:46,160 --> 00:28:52,620
we can basically say like we want to

529
00:28:49,829 --> 00:28:56,159
make sure that the decompressed pixel

530
00:28:52,619 --> 00:29:18,139
ending is not going to be something that

531
00:28:56,160 --> 00:29:18,140
gets exceeded so as I can do this right

532
00:29:20,390 --> 00:29:26,340
and so that should I think if I wrote

533
00:29:24,029 --> 00:29:30,029
that correctly that should assert prior

534
00:29:26,339 --> 00:29:31,709
to us writing off the buffer so here we

535
00:29:30,029 --> 00:29:34,109
can look at what the values were gonna

536
00:29:31,710 --> 00:29:38,809
be right like we surmised it was 258 it

537
00:29:34,109 --> 00:29:43,379
is this allows us to see who is about to

538
00:29:38,809 --> 00:29:45,929
produce the problem and so in this case

539
00:29:43,380 --> 00:29:47,790
actually everyone will like the desk and

540
00:29:45,930 --> 00:29:51,210
the source will both exceed the deaths

541
00:29:47,789 --> 00:29:53,460
will exceed at first but the source will

542
00:29:51,210 --> 00:29:55,680
exceed it as well right so they both

543
00:29:53,460 --> 00:29:59,850
would have written would have gone off

544
00:29:55,680 --> 00:30:02,549
the end in either case right so the

545
00:29:59,849 --> 00:30:04,829
other thing we can look at here is I'm

546
00:30:02,549 --> 00:30:11,759
interested to know as well the

547
00:30:04,829 --> 00:30:13,500
decompressed pixels end now I guess I

548
00:30:11,759 --> 00:30:17,549
guess that's all I really know all right

549
00:30:13,500 --> 00:30:20,339
so I would say that we kind of have two

550
00:30:17,549 --> 00:30:24,629
avenues to go down now to try and figure

551
00:30:20,339 --> 00:30:27,779
out what is causing the problem

552
00:30:24,630 --> 00:30:30,930
one thing route is to go down looking at

553
00:30:27,779 --> 00:30:33,960
the Huffman table calculation and see if

554
00:30:30,930 --> 00:30:36,090
we have problems with it seems plausible

555
00:30:33,960 --> 00:30:40,410
that there'd be a bug in there it's a

556
00:30:36,089 --> 00:30:42,539
little bit of a weird routine however I

557
00:30:40,410 --> 00:30:47,790
don't have anything to compare it

558
00:30:42,539 --> 00:30:50,430
against right so my main problem was

559
00:30:47,789 --> 00:30:51,460
starting with the Huffman table is I

560
00:30:50,430 --> 00:30:56,440
don't have

561
00:30:51,460 --> 00:30:59,069
a way to take some known good data for

562
00:30:56,440 --> 00:31:02,320
what the Huffman table should be and

563
00:30:59,069 --> 00:31:07,230
actually look at what mine is and go oh

564
00:31:02,319 --> 00:31:10,720
there's the problem right so that seems

565
00:31:07,230 --> 00:31:13,480
implausible as an Avenue so the first

566
00:31:10,720 --> 00:31:15,940
thing I might do instead is actually

567
00:31:13,480 --> 00:31:20,278
just look at the little end part of

568
00:31:15,940 --> 00:31:24,880
things and see if I can't get that to

569
00:31:20,278 --> 00:31:29,849
give me a clue right so the first thing

570
00:31:24,880 --> 00:31:29,850
that I wanted you here is I want to take

571
00:31:30,000 --> 00:31:36,970
the images that we have and I well I've

572
00:31:34,480 --> 00:31:39,970
got myself into a situation right that

573
00:31:36,970 --> 00:31:42,610
that's a little bit unwieldy all of

574
00:31:39,970 --> 00:31:46,839
these nice tiny easy to inspect images

575
00:31:42,609 --> 00:31:48,069
they don't have any bugs right or well I

576
00:31:46,839 --> 00:31:50,168
shouldn't say that they don't have any

577
00:31:48,069 --> 00:31:52,480
of this bug the kind that we're looking

578
00:31:50,169 --> 00:31:54,490
for maybe they don't produce the right

579
00:31:52,480 --> 00:31:57,339
image we haven't tested yet but they

580
00:31:54,490 --> 00:31:59,740
don't have any obvious bugs this one

581
00:31:57,339 --> 00:32:01,178
does but it's huge right I mean we look

582
00:31:59,740 --> 00:32:03,970
at the properties of this thing it's a

583
00:32:01,179 --> 00:32:07,120
monster it's 1024 I'm not gonna inspect

584
00:32:03,970 --> 00:32:12,308
all that so my first question is can I

585
00:32:07,119 --> 00:32:16,359
make this error occur without needing

586
00:32:12,308 --> 00:32:19,418
the full image in question and so I want

587
00:32:16,359 --> 00:32:21,788
to basically try just dicing this image

588
00:32:19,419 --> 00:32:25,149
up and seeing whether a smaller version

589
00:32:21,788 --> 00:32:26,619
of the image will cause the problem so

590
00:32:25,148 --> 00:32:29,648
what I'm going to do is I'm just gonna

591
00:32:26,619 --> 00:32:32,259
take the crop tool and I'm gonna split

592
00:32:29,648 --> 00:32:34,148
the image in half and see if it's still

593
00:32:32,259 --> 00:32:36,579
I'm basically going to do a manual

594
00:32:34,148 --> 00:32:38,379
binary search to see whether I can

595
00:32:36,579 --> 00:32:40,629
produce a smaller image that still

596
00:32:38,380 --> 00:32:42,940
reproduces the problem but that I can

597
00:32:40,630 --> 00:32:44,980
visually inspect so I know sort of

598
00:32:42,940 --> 00:32:46,870
what's going on now they changed all the

599
00:32:44,980 --> 00:32:50,190
icons and so honestly I don't know

600
00:32:46,869 --> 00:32:50,189
where the crop is anymore

601
00:32:50,339 --> 00:32:56,278
probably that that's not at all what it

602
00:32:53,798 --> 00:32:56,278
used to look like

603
00:32:57,179 --> 00:33:04,169
all right so what I'm gonna do is I'm

604
00:32:58,648 --> 00:33:05,548
going to take a 512 by 512 sub piece you

605
00:33:04,169 --> 00:33:08,339
can see down here there's a pixel

606
00:33:05,548 --> 00:33:13,618
counter so I'm going to look for 512 on

607
00:33:08,338 --> 00:33:14,788
both axes and I'm taking the top corner

608
00:33:13,618 --> 00:33:16,648
and I probably could have done this just

609
00:33:14,788 --> 00:33:18,719
with the in fact you know what here's an

610
00:33:16,648 --> 00:33:23,008
easier way to do it if we just did

611
00:33:18,719 --> 00:33:24,929
canvassize I can do 512 by 512 and we'll

612
00:33:23,009 --> 00:33:27,628
just take that upper that upper corner

613
00:33:24,929 --> 00:33:30,089
right so now I'm gonna say like okay

614
00:33:27,628 --> 00:33:32,668
resize it we've just got this so now I'm

615
00:33:30,088 --> 00:33:36,678
going to save this as just a generic

616
00:33:32,669 --> 00:33:40,139
name test to write or maybe test small

617
00:33:36,679 --> 00:33:41,788
and I'm going to export that so now what

618
00:33:40,138 --> 00:33:48,468
I'm going to do is I'm going to keep

619
00:33:41,788 --> 00:33:51,239
loading this in until I can get it to

620
00:33:48,469 --> 00:33:52,769
I'm gonna keep making it smaller until

621
00:33:51,239 --> 00:33:54,629
it doesn't crash and it would take the

622
00:33:52,769 --> 00:33:55,679
one that's just a little bigger than

623
00:33:54,628 --> 00:34:00,988
that right

624
00:33:55,679 --> 00:34:05,759
oops that's not what's called all right

625
00:34:00,989 --> 00:34:10,019
so let's see it go through here so now I

626
00:34:05,759 --> 00:34:12,838
don't crash so even just that split even

627
00:34:10,019 --> 00:34:16,889
that just that split by itself causes us

628
00:34:12,838 --> 00:34:19,108
not to crash that again pretty rough on

629
00:34:16,889 --> 00:34:21,358
us it basically means that we're in a

630
00:34:19,108 --> 00:34:24,318
situation where this is a little this

631
00:34:21,358 --> 00:34:27,210
must be a fairly subtle problem we have

632
00:34:24,318 --> 00:34:30,088
but hey we've got a few we've gotta fix

633
00:34:27,210 --> 00:34:32,490
subtle problems we can't only fix

634
00:34:30,088 --> 00:34:34,469
clearing problems so let's go for it so

635
00:34:32,489 --> 00:34:36,568
I'm gonna try a different thing now I'm

636
00:34:34,469 --> 00:34:38,699
going to try having the image only this

637
00:34:36,568 --> 00:34:41,369
way so that we still have runs that are

638
00:34:38,699 --> 00:34:44,298
large in that direction on see if that

639
00:34:41,369 --> 00:34:44,298
helps right

640
00:34:52,960 --> 00:35:02,059
are we still are we actually parsing

641
00:34:55,519 --> 00:35:04,750
this thing yep we are all right so it

642
00:35:02,059 --> 00:35:09,199
doesn't crash in that case either okay

643
00:35:04,750 --> 00:35:13,789
not a good start for us here folks try

644
00:35:09,199 --> 00:35:24,469
one more thing let's look at the bottom

645
00:35:13,789 --> 00:35:26,980
of the image okay so this is good we've

646
00:35:24,469 --> 00:35:29,869
produced a potentially different error

647
00:35:26,980 --> 00:35:31,820
it's not necessarily the same but it is

648
00:35:29,869 --> 00:35:33,469
still an error that's good because they

649
00:35:31,820 --> 00:35:36,680
probably both come from the same place

650
00:35:33,469 --> 00:35:38,719
which is probably a corrupted read like

651
00:35:36,679 --> 00:35:41,629
a read that reads too many or too few

652
00:35:38,719 --> 00:35:45,289
bits and gets the whole stream out of

653
00:35:41,630 --> 00:35:47,869
whack right so what I do know is that I

654
00:35:45,289 --> 00:35:51,170
can use this smaller image so let's keep

655
00:35:47,869 --> 00:35:55,150
trying again to get it smaller and

656
00:35:51,170 --> 00:35:57,559
smaller so I'm gonna go ahead and try to

657
00:35:55,150 --> 00:36:04,250
I'm gonna go ahead and try to make it

658
00:35:57,559 --> 00:36:05,420
even smaller than this and so the first

659
00:36:04,250 --> 00:36:08,389
thing I'm going to do is I'm going to

660
00:36:05,420 --> 00:36:12,320
try just the white part here so get rid

661
00:36:08,389 --> 00:36:14,449
of that the actual data I'm assuming

662
00:36:12,320 --> 00:36:17,030
that the problem is in the actual data

663
00:36:14,449 --> 00:36:19,819
part not in this but we don't know maybe

664
00:36:17,030 --> 00:36:21,620
it's a problem with our large runs you

665
00:36:19,820 --> 00:36:23,380
know and in which case it could be that

666
00:36:21,619 --> 00:36:26,449
this part is the important part

667
00:36:23,380 --> 00:36:28,190
so that part read through just fine

668
00:36:26,449 --> 00:36:30,379
that also collapses down to a single

669
00:36:28,190 --> 00:36:32,720
it--at chunk I don't know if that's

670
00:36:30,380 --> 00:36:33,829
relevant at all it's worth noting all

671
00:36:32,719 --> 00:36:37,819
right so now I'm gonna do the same thing

672
00:36:33,829 --> 00:36:39,860
again but I'm gonna try just with the

673
00:36:37,820 --> 00:36:42,050
upper chunk right so now I'm going to

674
00:36:39,860 --> 00:36:44,660
try just this top chunk here so there's

675
00:36:42,050 --> 00:36:47,289
my resize again now I'm gonna go ahead

676
00:36:44,659 --> 00:36:52,129
and do an export to small again and

677
00:36:47,289 --> 00:36:54,349
run okay same problem this is good again

678
00:36:52,130 --> 00:36:54,800
we're narrowing down the size of this

679
00:36:54,349 --> 00:36:58,519
thing

680
00:36:54,800 --> 00:37:01,550
I'm gonna get it even smaller now let's

681
00:36:58,519 --> 00:37:11,509
get it down to 128 again bisecting

682
00:37:01,550 --> 00:37:13,400
keep the top part still has the bug I'm

683
00:37:11,510 --> 00:37:14,840
now going to split because I've gotten

684
00:37:13,400 --> 00:37:18,230
it well you know what let's just see how

685
00:37:14,840 --> 00:37:22,940
small we can make it this way why not go

686
00:37:18,230 --> 00:37:23,329
down to 64 okay so I can peat the top or

687
00:37:22,940 --> 00:37:29,599
the bottom

688
00:37:23,329 --> 00:37:33,279
gonna keep the top okay so the top

689
00:37:29,599 --> 00:37:33,279
didn't work let's keep the bottom

690
00:37:42,039 --> 00:37:50,659
awesome still buggy so we've got a bug

691
00:37:48,739 --> 00:37:55,009
case here that's that's getting quite

692
00:37:50,659 --> 00:38:05,139
small let me keep going down to 32 right

693
00:37:55,010 --> 00:38:05,140
pretty tiny keeping the top not buggy

694
00:38:06,099 --> 00:38:09,519
keeping the bottom

695
00:38:17,429 --> 00:38:23,309
okay so we've gotten to a place where it

696
00:38:20,519 --> 00:38:25,920
looks like we sort of have to have both

697
00:38:23,309 --> 00:38:28,559
of these or at least something else I

698
00:38:25,920 --> 00:38:33,030
don't know I mean I could just for sake

699
00:38:28,559 --> 00:38:41,489
of argument try keeping the middle part

700
00:38:33,030 --> 00:38:44,100
of it like so this so that's just the

701
00:38:41,489 --> 00:38:45,899
middle you know who knows maybe but it

702
00:38:44,099 --> 00:38:48,719
looks like we needed at least that big

703
00:38:45,900 --> 00:38:54,119
in order to get repro yeah so it looks

704
00:38:48,719 --> 00:38:57,089
like this is our test case here and that

705
00:38:54,119 --> 00:38:58,230
gives us an error right so now we've got

706
00:38:57,090 --> 00:39:00,870
something at least much smaller we can

707
00:38:58,230 --> 00:39:04,250
look at I will now try to bisect it the

708
00:39:00,869 --> 00:39:07,079
other direction this probably won't work

709
00:39:04,250 --> 00:39:08,670
to to reproduce the problem but I'm

710
00:39:07,079 --> 00:39:16,319
gonna try it anyway so we're gonna try

711
00:39:08,670 --> 00:39:18,740
just the left side and now just the

712
00:39:16,320 --> 00:39:18,740
right side

713
00:39:27,809 --> 00:39:36,519
yeah all right so this is what I've got

714
00:39:32,829 --> 00:39:40,090
it's not that small but it's at least

715
00:39:36,519 --> 00:39:43,090
you know let me see what happens here

716
00:39:40,090 --> 00:39:45,280
too with this so I will note that again

717
00:39:43,090 --> 00:39:55,750
that the multiple i dapped chunk thing

718
00:39:45,280 --> 00:39:59,110
is interesting like I I just want to

719
00:39:55,750 --> 00:40:02,679
know I'm so interested to know if that's

720
00:39:59,110 --> 00:40:05,289
related so if I take it down to the 512

721
00:40:02,679 --> 00:40:09,719
like I was doing before and I export it

722
00:40:05,289 --> 00:40:14,529
is it still to I that chunks it's not

723
00:40:09,719 --> 00:40:18,399
that's so suspicious all right so let me

724
00:40:14,530 --> 00:40:19,420
go ahead and cuz like I'm just wondering

725
00:40:18,400 --> 00:40:23,230
if that's all it is

726
00:40:19,420 --> 00:40:26,800
is it just that we have a multi I that

727
00:40:23,230 --> 00:40:29,380
chunk bug i I can't imagine it is but

728
00:40:26,800 --> 00:40:31,900
I'm just I'm really curious now so I'm

729
00:40:29,380 --> 00:40:34,750
gonna take this down a little bit more

730
00:40:31,900 --> 00:40:38,200
see if I can generate one that still has

731
00:40:34,750 --> 00:40:45,880
two I'd out chunks in it and does that

732
00:40:38,199 --> 00:40:50,529
reproduce the problem trying to find one

733
00:40:45,880 --> 00:40:53,079
that still has two I that chunks I mean

734
00:40:50,530 --> 00:41:00,090
don't you think that's really suspicious

735
00:40:53,079 --> 00:41:03,119
I mean it just seems really suspicious

736
00:41:00,090 --> 00:41:03,120
to me

737
00:41:06,809 --> 00:41:20,070
I mean that is just so suspicious like I

738
00:41:16,610 --> 00:41:25,110
just don't know what to make of that

739
00:41:20,070 --> 00:41:36,269
but it sure looks like something that's

740
00:41:25,110 --> 00:41:40,309
wrong with the AI datte chunks I feel

741
00:41:36,269 --> 00:41:46,199
like we need to look at those Ida chunks

742
00:41:40,309 --> 00:41:48,179
in the spec so you know good news is

743
00:41:46,199 --> 00:41:51,109
we've got this down to a much simpler

744
00:41:48,179 --> 00:42:00,329
test case right I mean that's way more

745
00:41:51,110 --> 00:42:02,849
straightforward than it was before I'm

746
00:42:00,329 --> 00:42:05,759
gonna now try one more thing before I go

747
00:42:02,849 --> 00:42:08,009
look at anything else so I'm gonna

748
00:42:05,760 --> 00:42:09,960
assume let's suppose that we had highly

749
00:42:08,010 --> 00:42:12,390
uncompressible data data that doesn't

750
00:42:09,960 --> 00:42:15,829
compress particularly well it looks like

751
00:42:12,389 --> 00:42:21,289
rates into either chunks of 8192

752
00:42:15,829 --> 00:42:24,809
right so 81 92 divided by 4 is 2048

753
00:42:21,289 --> 00:42:30,809
right and this is this the square root

754
00:42:24,809 --> 00:42:34,920
button it's like 45 so a 64 by 64 should

755
00:42:30,809 --> 00:42:38,159
be big enough that I break into multiple

756
00:42:34,920 --> 00:42:43,619
adept chunks right if the data is not

757
00:42:38,159 --> 00:42:46,440
compressible so here's a 64 by 64 I'm

758
00:42:43,619 --> 00:42:48,750
gonna create something here and I'm just

759
00:42:46,440 --> 00:42:51,559
gonna paint a bunch of nonsense in here

760
00:42:48,750 --> 00:42:51,559
oops not with that

761
00:43:04,039 --> 00:43:11,590
I want this to have an alpha Channel

762
00:43:07,480 --> 00:43:11,590
I'm gonna erase some stuff too

763
00:43:18,619 --> 00:43:24,170
so I'm just going for something just

764
00:43:20,449 --> 00:43:26,659
hard to compress that not hard to

765
00:43:24,170 --> 00:43:30,880
compress for you know any compressor but

766
00:43:26,659 --> 00:43:30,879
specifically hard to compress for ping

767
00:43:41,739 --> 00:43:45,149
all right I'm gonna blur this

768
00:43:50,260 --> 00:43:54,400
so all the values are kind of wonky

769
00:44:06,099 --> 00:44:22,480
all right and now I'm going to try to

770
00:44:08,440 --> 00:44:24,329
see if I if I have made one okay I want

771
00:44:22,480 --> 00:44:29,260
to try and see if I can make one here

772
00:44:24,329 --> 00:44:31,840
that is still - itit jumps right a

773
00:44:29,260 --> 00:44:36,810
totally different file but that has two

774
00:44:31,840 --> 00:44:36,809
IDOT chunks so this is Gibbs 64 by 64

775
00:44:44,039 --> 00:44:54,550
and it helps if I don't type the name

776
00:44:50,250 --> 00:44:58,360
okay so did I make - I that chunks yes I

777
00:44:54,550 --> 00:45:02,769
did and doobie crash yes we do totally

778
00:44:58,360 --> 00:45:04,240
different file right and the only thing

779
00:45:02,769 --> 00:45:10,210
is it has two different Ayodhya chunks

780
00:45:04,239 --> 00:45:13,359
in it so I'm gonna go ahead and say that

781
00:45:10,210 --> 00:45:16,329
I am now fairly certain we have at least

782
00:45:13,360 --> 00:45:18,340
one I that chunk related bug in here I

783
00:45:16,329 --> 00:45:20,889
don't know what it is yet but I think we

784
00:45:18,340 --> 00:45:23,200
probably have one so the first thing I'm

785
00:45:20,889 --> 00:45:25,469
gonna look at is how I'm handling those

786
00:45:23,199 --> 00:45:27,789
IDOT chunks and am i potentially

787
00:45:25,469 --> 00:45:30,219
misinterpreting the length so for

788
00:45:27,789 --> 00:45:32,949
example in here when we get this content

789
00:45:30,219 --> 00:45:34,750
size for the Ida chunk right is it

790
00:45:32,949 --> 00:45:37,419
possible that that length gets rounded

791
00:45:34,750 --> 00:45:40,719
and I need to unrounded or something

792
00:45:37,420 --> 00:45:44,440
like that to a certain bit length or

793
00:45:40,719 --> 00:45:45,489
things like this so I wanna to basically

794
00:45:44,440 --> 00:45:48,519
read the Ida

795
00:45:45,489 --> 00:45:50,859
chunk part of the ping spec and see if

796
00:45:48,519 --> 00:45:52,750
there was something we forgot because

797
00:45:50,860 --> 00:45:53,769
there it's been a while since we read

798
00:45:52,750 --> 00:45:55,630
that part and there may have been

799
00:45:53,769 --> 00:46:00,880
something in there that was like and we

800
00:45:55,630 --> 00:46:02,470
round up to blah or whatever right so

801
00:46:00,880 --> 00:46:03,940
anyway a for beta so given number of

802
00:46:02,469 --> 00:46:06,279
bytes that chunks data field the length

803
00:46:03,940 --> 00:46:09,190
counts only the data field not itself

804
00:46:06,280 --> 00:46:11,170
the chunk type or the CRT zero is a

805
00:46:09,190 --> 00:46:13,000
valid length it kotas guys should treat

806
00:46:11,170 --> 00:46:15,460
the link that's unsigned and it

807
00:46:13,000 --> 00:46:18,909
shouldn't exceed two to the 31st - one

808
00:46:15,460 --> 00:46:23,440
bit okay so we prop

809
00:46:18,909 --> 00:46:26,409
we use the chunk header length which has

810
00:46:23,440 --> 00:46:30,519
been swapped as the size of the data and

811
00:46:26,409 --> 00:46:33,190
we use the chunk data as the data that's

812
00:46:30,519 --> 00:46:35,048
what we'd expect so that's good let's

813
00:46:33,190 --> 00:46:38,608
look at the Ida chunk information and

814
00:46:35,048 --> 00:46:41,409
see what it says about how they work so

815
00:46:38,608 --> 00:46:46,328
the four bytes shunk type field contains

816
00:46:41,409 --> 00:46:50,230
decimal values 73 68 65 84

817
00:46:46,329 --> 00:46:51,400
I assume that's just I'd at write that a

818
00:46:50,230 --> 00:46:52,929
chunk contains the actual image data

819
00:46:51,400 --> 00:46:54,849
which the output stream of the

820
00:46:52,929 --> 00:46:56,440
compression I go to see Clause 9 and

821
00:46:54,849 --> 00:46:57,789
compressor details to me about I checked

822
00:46:56,440 --> 00:46:59,889
if so they should be consecutive with no

823
00:46:57,789 --> 00:47:01,630
other debris chunks the compressed data

824
00:46:59,889 --> 00:47:04,989
stream is then the concatenation of the

825
00:47:01,630 --> 00:47:07,900
contents of the data fields of all the i

826
00:47:04,989 --> 00:47:10,750
dot chunks which is what I think we were

827
00:47:07,900 --> 00:47:13,210
trying to do here right so we put

828
00:47:10,750 --> 00:47:14,199
together chunks of that size right we

829
00:47:13,210 --> 00:47:17,318
say here's the length

830
00:47:14,199 --> 00:47:21,038
here's the data and we put it in there

831
00:47:17,318 --> 00:47:23,079
right and you know it can only be the

832
00:47:21,039 --> 00:47:26,020
length it's it's not bit length it's a

833
00:47:23,079 --> 00:47:29,048
byte length so that's how many there are

834
00:47:26,019 --> 00:47:33,338
when we look at the last pointer we

835
00:47:29,048 --> 00:47:36,099
string them together so are we correctly

836
00:47:33,338 --> 00:47:37,690
appending these we say the last pointer

837
00:47:36,099 --> 00:47:41,048
is going to be equal to the chunk that's

838
00:47:37,690 --> 00:47:43,358
what we want we set the next pointer on

839
00:47:41,048 --> 00:47:45,028
the last one to this one or the first

840
00:47:43,358 --> 00:47:48,548
depending on whether there is one or not

841
00:47:45,028 --> 00:47:50,260
that seems right as well so that should

842
00:47:48,548 --> 00:47:55,778
produce a singly linked list of all them

843
00:47:50,260 --> 00:47:59,589
I so that seems good okay so in here

844
00:47:55,778 --> 00:48:02,798
where we do I'd app headers here's the

845
00:47:59,588 --> 00:48:06,190
I'd app header that comes in I thought

846
00:48:02,798 --> 00:48:09,190
and maybe I'm wrong about this but my

847
00:48:06,190 --> 00:48:11,528
recollection was that when you move to

848
00:48:09,190 --> 00:48:13,298
another I don't head err they did not

849
00:48:11,528 --> 00:48:19,719
have any more header information I'm

850
00:48:13,298 --> 00:48:23,250
almost positive that that was true so

851
00:48:19,719 --> 00:48:26,969
I'm pretty sure that that that's correct

852
00:48:23,250 --> 00:48:26,969
all right

853
00:48:53,989 --> 00:49:00,299
it is important to emphasize that the

854
00:48:58,199 --> 00:49:03,809
boundaries between Ida chunks are

855
00:49:00,300 --> 00:49:05,910
arbitrary and can fall anywhere in the Z

856
00:49:03,809 --> 00:49:08,099
live data stream there is not

857
00:49:05,909 --> 00:49:10,619
necessarily any correlation between Ida

858
00:49:08,099 --> 00:49:15,719
chunk boundaries and deflate block

859
00:49:10,619 --> 00:49:17,849
boundaries or any other feature of the

860
00:49:15,719 --> 00:49:19,799
zeal of data for example isn't entirely

861
00:49:17,849 --> 00:49:21,480
possible the terminating Z lib check

862
00:49:19,800 --> 00:49:24,780
value to be split across

863
00:49:21,480 --> 00:49:26,760
IDOT chunks similarly there is no

864
00:49:24,780 --> 00:49:28,530
required Crowley should be the structure

865
00:49:26,760 --> 00:49:30,600
of the image data and deflate block

866
00:49:28,530 --> 00:49:32,100
boundaries or as Yuma is a complete

867
00:49:30,599 --> 00:49:33,569
filtered PNG which is represented by a

868
00:49:32,099 --> 00:49:37,009
single zeal of data stream that's stored

869
00:49:33,570 --> 00:49:37,010
in a number of I dot chunks

870
00:50:06,289 --> 00:50:09,289
well

871
00:50:17,110 --> 00:50:23,650
I guess the first thing I should do is

872
00:50:21,119 --> 00:50:30,869
just look at how these are constructed

873
00:50:23,650 --> 00:50:30,869
and when they're read from so

874
00:50:57,110 --> 00:51:02,269
so when we're reading these it's pretty

875
00:50:59,309 --> 00:51:06,289
straightforward right we consume bits

876
00:51:02,269 --> 00:51:06,289
looking for the B final

877
00:51:16,789 --> 00:51:27,259
so it looks like here we've got a

878
00:51:19,619 --> 00:51:27,260
Huffman decode within the first block

879
00:51:32,300 --> 00:51:36,710
and we read an invalid symbol

880
00:51:52,670 --> 00:51:59,000
yeah hmm hmm so

881
00:52:06,298 --> 00:52:13,909
at the point where we read the invalid

882
00:52:08,639 --> 00:52:13,909
symbol which buffer are we on

883
00:52:21,420 --> 00:52:24,289
oh my

884
00:52:27,860 --> 00:52:38,180
so yeah that I mean in case I was

885
00:52:34,650 --> 00:52:38,180
wondering that's not good

886
00:52:47,880 --> 00:52:57,510
so yeah it under flowed

887
00:53:09,809 --> 00:53:14,299
so this is just busted

888
00:53:19,030 --> 00:53:28,470
kind of says you're on the Anfal first

889
00:53:21,789 --> 00:53:38,039
this equals file first content size

890
00:53:28,469 --> 00:53:38,038
let's step through that so did this hit

891
00:53:40,889 --> 00:53:51,489
it did well but that's the first one so

892
00:53:46,239 --> 00:53:57,519
that never got hit even though we under

893
00:53:51,489 --> 00:54:00,159
set the underflow flag so so what we

894
00:53:57,519 --> 00:54:12,940
really want here is to look at this

895
00:54:00,159 --> 00:54:19,598
under flip flag yep yep yep yep yep yep

896
00:54:12,940 --> 00:54:21,420
that's a bug folks you saw it too I'm

897
00:54:19,599 --> 00:54:24,250
sure

898
00:54:21,420 --> 00:54:34,690
well MTS MOC saw it because he said he'd

899
00:54:24,250 --> 00:54:36,670
to bug this earlier so this is wrong so

900
00:54:34,690 --> 00:54:38,500
basically what's happening the problem

901
00:54:36,670 --> 00:54:40,659
here is consumed is the thing that can

902
00:54:38,500 --> 00:54:42,639
advance we wrote this before we

903
00:54:40,659 --> 00:54:45,548
supported multiple eyelet chunks Whedon

904
00:54:42,639 --> 00:54:47,949
failed to actually write it correctly so

905
00:54:45,548 --> 00:54:50,048
what we're trying to do here is we're

906
00:54:47,949 --> 00:54:52,838
trying to loop until we don't have as

907
00:54:50,048 --> 00:54:58,329
many bits as we think that we need you

908
00:54:52,838 --> 00:55:00,548
know also I'm gonna put an assert in

909
00:54:58,329 --> 00:55:04,660
there it would have caught this bug

910
00:55:00,548 --> 00:55:07,509
earlier so if you look at this bit count

911
00:55:04,659 --> 00:55:10,629
less and pick this part here it needs to

912
00:55:07,510 --> 00:55:17,260
at least try to call consume or it won't

913
00:55:10,630 --> 00:55:18,700
refill the buffer right so once we try

914
00:55:17,260 --> 00:55:23,020
it here

915
00:55:18,699 --> 00:55:25,088
we could say like oh okay you know if we

916
00:55:23,019 --> 00:55:27,519
succeeded in getting a bite then that's

917
00:55:25,088 --> 00:55:32,679
fine if we didn't get succeed in getting

918
00:55:27,519 --> 00:55:39,559
a bite then then we break right

919
00:55:32,679 --> 00:55:41,419
um so that's it really is looking like

920
00:55:39,559 --> 00:55:43,429
that this isn't right because if the

921
00:55:41,420 --> 00:55:46,369
buffer was only one big we don't want to

922
00:55:43,429 --> 00:55:49,819
break out so it's like we need some way

923
00:55:46,369 --> 00:55:52,730
of consume actually telling us whether

924
00:55:49,820 --> 00:55:56,600
or not there's anything that we got and

925
00:55:52,730 --> 00:56:02,300
so right we need some information from

926
00:55:56,599 --> 00:56:10,719
consume about what it actually what it

927
00:56:02,300 --> 00:56:10,720
actually returned right so you know

928
00:56:29,268 --> 00:56:42,588
I'm gonna go like this and say that this

929
00:56:38,068 --> 00:56:48,858
flag is now like a thing that we have

930
00:56:42,588 --> 00:56:48,858
that's part of the consumed call so like

931
00:57:08,119 --> 00:57:18,180
something like that so basically now the

932
00:57:15,688 --> 00:57:20,308
underflow flag gets set outside and

933
00:57:18,179 --> 00:57:24,088
consumed sighs this thing will keep

934
00:57:20,309 --> 00:57:26,160
going trying to get more bits until the

935
00:57:24,088 --> 00:57:33,478
underflow flag gets set at which point

936
00:57:26,159 --> 00:57:36,420
you will bail and off we go so now let's

937
00:57:33,478 --> 00:57:37,919
see if we get any more love here

938
00:57:36,420 --> 00:57:41,369
hopefully we can start to figure out

939
00:57:37,920 --> 00:57:43,219
what's going on um I love better all

940
00:57:41,369 --> 00:57:45,449
right so I maybe I don't know if I still

941
00:57:43,219 --> 00:57:48,208
screwed it up there let me make sure we

942
00:57:45,449 --> 00:57:49,349
recompiled this here but let me see if I

943
00:57:48,208 --> 00:57:50,698
can get it now to the point we're

944
00:57:49,349 --> 00:57:54,088
actually reading that because that was

945
00:57:50,699 --> 00:57:56,579
definitely a bug all right so now we're

946
00:57:54,088 --> 00:58:00,389
at least actually reading the real bits

947
00:57:56,579 --> 00:58:03,568
in we did actually advance what I don't

948
00:58:00,389 --> 00:58:10,009
know is did we advance correctly so

949
00:58:03,568 --> 00:58:11,880
we're still it's a little bit odd here I

950
00:58:10,009 --> 00:58:21,329
still think we might have a little bit

951
00:58:11,880 --> 00:58:23,608
bucks we did advance this doesn't really

952
00:58:21,329 --> 00:58:30,410
matter we did advance and we read all

953
00:58:23,608 --> 00:58:32,980
the way till 13 bytes from the end and

954
00:58:30,409 --> 00:58:39,789
then we got in

955
00:58:32,980 --> 00:58:41,800
a bogus symbol I think right that looks

956
00:58:39,789 --> 00:58:45,389
like what happened here to master why I

957
00:58:41,800 --> 00:58:48,490
had that in their choice so that got us

958
00:58:45,389 --> 00:58:52,089
significantly further right so that was

959
00:58:48,489 --> 00:58:56,729
at least that was a pretty major bug I'm

960
00:58:52,090 --> 00:59:04,660
also assuming that that was not the bug

961
00:58:56,730 --> 00:59:07,389
from this one but I don't know it was

962
00:59:04,659 --> 00:59:10,509
okay so that was actually the bug we

963
00:59:07,389 --> 00:59:22,379
were having on the test case what the

964
00:59:10,510 --> 00:59:22,380
heck what is scripted sandbox 64

965
00:59:35,858 --> 00:59:39,489
just what is it

966
00:59:43,670 --> 00:59:55,909
oh boy anyway so I guess that was the

967
00:59:54,590 --> 00:59:57,380
bug that was causing stuff with the

968
00:59:55,909 --> 01:00:00,349
wrong number symbols in there so I guess

969
00:59:57,380 --> 01:00:02,690
now we actually have to focus on this

970
01:00:00,349 --> 01:00:04,130
other case because now that case is

971
01:00:02,690 --> 01:00:07,970
actually not buggy anymore which is

972
01:00:04,130 --> 01:00:10,220
great so never mind but I do want to

973
01:00:07,969 --> 01:00:11,629
find out why our 64 by 64 is wrong so

974
01:00:10,219 --> 01:00:14,569
let's go ahead and get that one going

975
01:00:11,630 --> 01:00:18,769
now - all right so this one is reading

976
01:00:14,570 --> 01:00:20,210
an incorrect symbol at the end where you

977
01:00:18,769 --> 01:00:21,349
know it's it's we're getting some symbol

978
01:00:20,210 --> 01:00:23,300
that we don't think we should be getting

979
01:00:21,349 --> 01:00:28,279
one that wasn't supposed to actually

980
01:00:23,300 --> 01:00:29,990
occur in the input stream so the I don't

981
01:00:28,280 --> 01:00:34,220
know what the bytes we actually got here

982
01:00:29,989 --> 01:00:40,639
okay so we got one one two seven six as

983
01:00:34,219 --> 01:00:43,009
the bits that we got 15 bit

984
01:00:40,639 --> 01:00:46,190
we got one one two seven six as the bits

985
01:00:43,010 --> 01:00:48,170
that we got those bits are not don't map

986
01:00:46,190 --> 01:00:52,130
to anything that's like they were not

987
01:00:48,170 --> 01:00:56,869
bits we actually expected to see so

988
01:00:52,130 --> 01:01:04,400
we're like what happened right okay

989
01:00:56,869 --> 01:01:08,480
now I still don't really know that we

990
01:01:04,400 --> 01:01:10,340
fixed the bug that we had I tried to fix

991
01:01:08,480 --> 01:01:13,610
the bug that we had but I don't know

992
01:01:10,340 --> 01:01:16,550
that we did so what I would like to do

993
01:01:13,610 --> 01:01:19,570
is just verify that I think that that

994
01:01:16,550 --> 01:01:19,570
loop still works

995
01:01:23,030 --> 01:01:29,220
so while the bit count is insufficient

996
01:01:26,550 --> 01:01:31,470
and we have not yet under flowed the

997
01:01:29,219 --> 01:01:35,519
buffer it will try to consume new bytes

998
01:01:31,469 --> 01:01:37,980
and shift them in right and that seems

999
01:01:35,519 --> 01:01:40,380
relatively straightforward it will then

1000
01:01:37,980 --> 01:01:45,179
take the bit buffer and yeah the peak

1001
01:01:40,380 --> 01:01:49,590
bits it just uses those bits and that's

1002
01:01:45,179 --> 01:01:51,779
it right and then you can discard the

1003
01:01:49,590 --> 01:01:55,579
number of bits that you actually used

1004
01:01:51,780 --> 01:01:55,580
you know however many that was

1005
01:02:04,210 --> 01:02:09,210
and that seems reasonable I guess

1006
01:02:14,739 --> 01:02:23,229
all right so now I'm gonna have to

1007
01:02:19,989 --> 01:02:26,909
progress through this one as if it's a

1008
01:02:23,230 --> 01:02:30,670
totally new test case though because

1009
01:02:26,909 --> 01:02:32,319
although I fixed one underflow problem

1010
01:02:30,670 --> 01:02:33,940
with the idea let me just meet I also

1011
01:02:32,320 --> 01:02:37,900
want to make sure I did that test right

1012
01:02:33,940 --> 01:02:40,559
we had two of these right we had

1013
01:02:37,900 --> 01:02:40,559
test small

1014
01:02:48,389 --> 01:02:53,670
yeah

1015
01:02:50,969 --> 01:02:56,500
so and you know what else I wanna do too

1016
01:02:53,670 --> 01:02:57,730
while we're at it just to see if these

1017
01:02:56,500 --> 01:02:58,329
test cases are really freezing they're

1018
01:02:57,730 --> 01:03:02,500
out of my data

1019
01:02:58,329 --> 01:03:05,920
I wanna assert that the destination

1020
01:03:02,500 --> 01:03:07,840
equals the end so when we get here I

1021
01:03:05,920 --> 01:03:14,110
want to assert that the last thing we

1022
01:03:07,840 --> 01:03:16,420
wrote is where the end of the buffer

1023
01:03:14,110 --> 01:03:18,789
should have been right because maybe

1024
01:03:16,420 --> 01:03:21,639
it's not actually producing it okay so

1025
01:03:18,789 --> 01:03:23,529
now we actually we've made quite a bit

1026
01:03:21,639 --> 01:03:25,719
of progress I'm pretty happy about that

1027
01:03:23,530 --> 01:03:27,640
that was a pretty stupid bug to have but

1028
01:03:25,719 --> 01:03:29,619
it's just because we wrote that we

1029
01:03:27,639 --> 01:03:31,750
updated that thing right and didn't

1030
01:03:29,619 --> 01:03:36,429
update the part of the code that

1031
01:03:31,750 --> 01:03:40,079
actually needed to care about it so now

1032
01:03:36,429 --> 01:03:42,219
it looks like we've pretty much got

1033
01:03:40,079 --> 01:03:46,739
everybody producing the right amount of

1034
01:03:42,219 --> 01:03:50,799
data except for our 64 by 64 friend here

1035
01:03:46,739 --> 01:03:54,669
right and our 64 by 64 a friend here is

1036
01:03:50,800 --> 01:03:56,950
actually really close to the end I think

1037
01:03:54,670 --> 01:04:03,369
let me see I don't know how close to the

1038
01:03:56,949 --> 01:04:07,299
end of the output it actually is so it's

1039
01:04:03,369 --> 01:04:09,069
only 9 bytes away from the end when it

1040
01:04:07,300 --> 01:04:10,930
encounters the bad symbol of course it

1041
01:04:09,070 --> 01:04:13,660
may be totally wrong data so that may

1042
01:04:10,929 --> 01:04:17,619
not mean a thing but it's just worth

1043
01:04:13,659 --> 01:04:19,359
noting and also as we know the input

1044
01:04:17,619 --> 01:04:24,699
that's actually reading from the comp

1045
01:04:19,360 --> 01:04:27,360
data the comp date has actually been

1046
01:04:24,699 --> 01:04:37,389
processed almost entirely it's got 13

1047
01:04:27,360 --> 01:04:41,789
left 4 9 9 actual bytes all right so

1048
01:04:37,389 --> 01:04:45,099
this one's gonna be rough because this

1049
01:04:41,789 --> 01:04:48,269
so I guess there's still two things that

1050
01:04:45,099 --> 01:04:48,269
could be wrong here

1051
01:04:53,000 --> 01:04:59,039
so one could be that the huffman table

1052
01:04:55,858 --> 01:05:01,769
was built incorrectly and this symbol

1053
01:04:59,039 --> 01:05:04,470
that we actually got is a symbol that

1054
01:05:01,769 --> 01:05:06,449
could be encoded so you know it's

1055
01:05:04,469 --> 01:05:09,358
possible that the data stream is now

1056
01:05:06,449 --> 01:05:13,618
functioning correctly but the Huffman

1057
01:05:09,358 --> 01:05:15,659
table is functioning wrong however it is

1058
01:05:13,619 --> 01:05:18,088
also the case that that's not true and

1059
01:05:15,659 --> 01:05:23,940
that what actually happened is we still

1060
01:05:18,088 --> 01:05:27,389
have a bug in the bit stream reading

1061
01:05:23,940 --> 01:05:31,500
across either chunks that only happens

1062
01:05:27,389 --> 01:05:35,190
at certain times so I'm a check for that

1063
01:05:31,500 --> 01:05:37,469
first and here's I'm in do and it's

1064
01:05:35,190 --> 01:05:39,000
gonna look a little weird but what I

1065
01:05:37,469 --> 01:05:42,118
want to do is I want look at the peek

1066
01:05:39,000 --> 01:05:47,900
bits call and you can see where we're

1067
01:05:42,119 --> 01:05:50,220
doing this consume here I want to know

1068
01:05:47,900 --> 01:05:58,950
when we do

1069
01:05:50,219 --> 01:06:01,889
so if buff content size is less than

1070
01:05:58,949 --> 01:06:06,480
eight so if we're going to advance

1071
01:06:01,889 --> 01:06:11,058
forward I just want to know how many

1072
01:06:06,480 --> 01:06:11,059
bits were in the bit buffer that's it

1073
01:06:20,280 --> 01:06:29,940
so I just want to say look here's how

1074
01:06:24,130 --> 01:06:33,090
many bits I had when I went to rap I

1075
01:06:29,940 --> 01:06:37,960
just I'm just curious

1076
01:06:33,090 --> 01:06:40,600
don't ask me why I just want to know if

1077
01:06:37,960 --> 01:06:49,599
there's a difference between the cases

1078
01:06:40,599 --> 01:06:53,339
that do work in that dough so so that

1079
01:06:49,599 --> 01:06:58,539
tells me something right there that oh

1080
01:06:53,340 --> 01:07:01,269
sorry I mentioned one so I guess it's

1081
01:06:58,539 --> 01:07:03,599
just zero if I was about to advance the

1082
01:07:01,269 --> 01:07:03,599
buffer

1083
01:07:10,170 --> 01:07:16,818
so there were 12 bits in the bit buffer

1084
01:07:13,170 --> 01:07:16,818
before I went to advance

1085
01:07:23,449 --> 01:07:35,159
fixed huffman not yet oh yeah

1086
01:07:31,860 --> 01:07:44,900
so that's actually just one that we

1087
01:07:35,159 --> 01:07:47,989
don't handle no problem it's fine

1088
01:07:44,900 --> 01:07:50,820
well I'm glad I looked at the output

1089
01:07:47,989 --> 01:07:53,489
good that gives us an excuse to go do

1090
01:07:50,820 --> 01:07:56,220
that now so maybe we don't have a bug

1091
01:07:53,489 --> 01:07:59,159
we don't know maybe we don't have a bug

1092
01:07:56,219 --> 01:08:01,769
at all what we do know is that we need

1093
01:07:59,159 --> 01:08:04,619
to put the fixed huffin tables in now so

1094
01:08:01,769 --> 01:08:06,019
let's put them in seems like as good a

1095
01:08:04,619 --> 01:08:13,049
time as any

1096
01:08:06,019 --> 01:08:16,770
looking back at our specification we

1097
01:08:13,050 --> 01:08:19,048
have to find sir okay here we go the

1098
01:08:16,770 --> 01:08:21,000
Huffman codes for the two alphabets are

1099
01:08:19,048 --> 01:08:23,189
fixed and are not represented in the

1100
01:08:21,000 --> 01:08:26,399
data the Huffman code lengths for the

1101
01:08:23,189 --> 01:08:28,969
literal length alphabet are 0 through

1102
01:08:26,399 --> 01:08:33,629
143 get 8 bits

1103
01:08:28,970 --> 01:08:40,350
144 through 25 get 9 to be 6 through 279

1104
01:08:33,630 --> 01:08:42,180
gets 7 and 280 through 287 get 8 I mean

1105
01:08:40,350 --> 01:08:52,620
is that as simple as it sounds is that

1106
01:08:42,180 --> 01:08:57,659
all I have to do I mean I'll just try it

1107
01:08:52,619 --> 01:09:00,528
I guess can't hurt to try it so

1108
01:08:57,659 --> 01:09:07,079
basically what I'm trying to do here is

1109
01:09:00,529 --> 01:09:11,819
just seed this Huffman table so you know

1110
01:09:07,079 --> 01:09:14,909
the this nonsense here I still want to

1111
01:09:11,819 --> 01:09:20,720
do this you know this bit right bit

1112
01:09:14,909 --> 01:09:29,630
right here so I still want to produce

1113
01:09:20,720 --> 01:09:29,630
these too but I don't really need to

1114
01:09:36,539 --> 01:09:59,930
he says I don't really need to look at

1115
01:09:46,500 --> 01:10:04,409
the hold on

1116
01:09:59,930 --> 01:10:13,200
so where is where does the distance

1117
01:10:04,409 --> 01:10:15,689
huffman oh here it is love of ice okay

1118
01:10:13,199 --> 01:10:17,340
so that's when I read this before and

1119
01:10:15,689 --> 01:10:21,119
didn't it was talking about it's talking

1120
01:10:17,340 --> 01:10:23,430
about this only this only the fixed

1121
01:10:21,119 --> 01:10:25,439
codes this is not a new header that's

1122
01:10:23,430 --> 01:10:27,930
just the page break threw me off

1123
01:10:25,439 --> 01:10:30,599
please go 303 one over fix like five bit

1124
01:10:27,930 --> 01:10:36,600
codes distance Co straighter it never

1125
01:10:30,600 --> 01:10:45,590
occurred in the compressed data okay so

1126
01:10:36,600 --> 01:10:49,170
let's start so 287 okay okay okay so

1127
01:10:45,590 --> 01:10:53,340
what I want to do here is just see these

1128
01:10:49,170 --> 01:10:59,670
in so let's go ahead and actually do

1129
01:10:53,340 --> 01:11:04,050
this here's the little end disk table in

1130
01:10:59,670 --> 01:11:08,819
fact I can just you know we can just

1131
01:11:04,050 --> 01:11:11,460
make this thing happen out here so

1132
01:11:08,819 --> 01:11:14,429
here's a little in dis table I can go

1133
01:11:11,460 --> 01:11:16,829
ahead and just fill that thing out we

1134
01:11:14,430 --> 01:11:20,159
now know that H lit will basically be

1135
01:11:16,829 --> 01:11:22,949
fixed so the number of each lip codes

1136
01:11:20,159 --> 01:11:24,869
there R is now non-variable right

1137
01:11:22,949 --> 01:11:27,720
because it's a fixed up in code to don't

1138
01:11:24,869 --> 01:11:31,279
read it from anywhere and so we know

1139
01:11:27,720 --> 01:11:36,720
that the H lit value actually goes up to

1140
01:11:31,279 --> 01:11:40,199
280 what 288 right is the first one

1141
01:11:36,720 --> 01:11:43,680
because 27 is the last code that

1142
01:11:40,199 --> 01:11:46,829
actually participates yeah 387 so tweety

1143
01:11:43,680 --> 01:11:49,460
eight is the first distance code if I'm

1144
01:11:46,829 --> 01:11:49,460
understanding that correctly

1145
01:11:49,829 --> 01:11:53,720
so I'm gonna go like this

1146
01:12:03,029 --> 01:12:17,729
and I'm just going to write stuff into

1147
01:12:05,039 --> 01:12:19,859
that little end table and so I'm going

1148
01:12:17,729 --> 01:12:21,149
to do here is just say well the bit

1149
01:12:19,859 --> 01:12:23,009
count I don't remember what we actually

1150
01:12:21,149 --> 01:12:25,609
made these things you three twos so the

1151
01:12:23,010 --> 01:12:28,829
bit count here is gonna just be based on

1152
01:12:25,609 --> 01:12:31,380
where we are in the actual stream in

1153
01:12:28,829 --> 01:12:32,939
there in the thing right and you could

1154
01:12:31,380 --> 01:12:36,359
make these into multiple ones if you

1155
01:12:32,939 --> 01:12:37,889
wanted to multiple 4i loops but I'm not

1156
01:12:36,359 --> 01:12:40,949
even gonna well yeah I mean I guess I

1157
01:12:37,890 --> 01:12:43,610
could do that I mean let's just do this

1158
01:12:40,949 --> 01:12:43,609
right

1159
01:12:52,139 --> 01:12:57,029
so what I'm going to do here is I'm just

1160
01:12:54,118 --> 01:13:05,939
gonna do like this stopping point and

1161
01:12:57,029 --> 01:13:07,800
the bit count right so I'm just gonna

1162
01:13:05,939 --> 01:13:11,698
say what this thing says

1163
01:13:07,800 --> 01:13:13,670
so it's like okay we've got zero to one

1164
01:13:11,698 --> 01:13:21,448
forty three are gonna be eight bits

1165
01:13:13,670 --> 01:13:27,359
right so I'll just do like zero to one

1166
01:13:21,448 --> 01:13:34,979
forty three or eight bits 144 to 255 is

1167
01:13:27,359 --> 01:13:40,799
nine bits 256 to 279 so that's just to

1168
01:13:34,979 --> 01:13:48,589
79 is seven bits to 82 to 87 is eight

1169
01:13:40,800 --> 01:14:01,250
bits right and then the length values

1170
01:13:48,590 --> 01:14:08,449
which go on which going after that are

1171
01:14:01,250 --> 01:14:08,448
32 is that correct so it'd just be like

1172
01:14:10,609 --> 01:14:26,299
319 so I think that's what we're talking

1173
01:14:18,719 --> 01:14:26,300
about here don't quote me on that

1174
01:14:38,439 --> 01:14:52,238
so if I want to set the bit count index

1175
01:14:41,649 --> 01:14:54,799
maybe we'll do it like this oops uh so

1176
01:14:52,238 --> 01:15:02,959
here's what I'll say

1177
01:14:54,800 --> 01:15:30,679
I guess we'll call these range in the

1178
01:15:02,960 --> 01:15:35,210
C's so yeah how's this how's this boy

1179
01:15:30,679 --> 01:15:39,288
think of this it's not fabulous but I

1180
01:15:35,210 --> 01:15:40,819
think I get the job done so basically

1181
01:15:39,288 --> 01:15:42,889
what we do is we start at bit County

1182
01:15:40,819 --> 01:15:45,469
index zero we need to fill out the ho

1183
01:15:42,889 --> 01:15:47,359
table we have a little cheat sheet here

1184
01:15:45,469 --> 01:15:54,158
that tells us like we're to what to go

1185
01:15:47,359 --> 01:15:59,960
up through right and so wait a minute so

1186
01:15:54,158 --> 01:16:02,839
288 + 32 320 yep so we're good so you

1187
01:15:59,960 --> 01:16:05,599
know we just read out okay what's the

1188
01:16:02,840 --> 01:16:08,929
stopping value for this range of bits

1189
01:16:05,599 --> 01:16:13,550
and we just rub that value in there then

1190
01:16:08,929 --> 01:16:15,649
we do the Huffman table based on that

1191
01:16:13,550 --> 01:16:17,510
the exact same way we would have done

1192
01:16:15,649 --> 01:16:21,038
the Huffman table which is good because

1193
01:16:17,510 --> 01:16:25,039
I think that means we can just do this

1194
01:16:21,038 --> 01:16:28,698
and get rid of this part here and that

1195
01:16:25,038 --> 01:16:32,389
way we can just have H lit and H dist B

1196
01:16:28,698 --> 01:16:34,808
variables that actually get set

1197
01:16:32,389 --> 01:16:34,809
separately

1198
01:16:39,849 --> 01:16:50,469
and off we go okay so wait what index

1199
01:16:45,130 --> 01:16:56,498
undeclared it what where is that where

1200
01:16:50,469 --> 01:16:59,130
are you seeing index from that line so

1201
01:16:56,498 --> 01:16:59,130
confused right now

1202
01:17:24,090 --> 01:17:28,279
did I do something really strange here

1203
01:17:34,340 --> 01:17:44,000
whoa whoa how did that get over there my

1204
01:17:41,819 --> 01:17:44,000
bad

1205
01:17:51,809 --> 01:17:59,130
all right so now that we got a fixed

1206
01:17:54,689 --> 01:18:03,089
huffin case here let me just step into

1207
01:17:59,130 --> 01:18:06,118
this one time and see what we get out of

1208
01:18:03,090 --> 01:18:11,880
it so I'm gonna look at this little n

1209
01:18:06,118 --> 01:18:15,089
just table nonsense and just see if if

1210
01:18:11,880 --> 01:18:18,389
it set up what the spec says or at least

1211
01:18:15,090 --> 01:18:23,250
is what I configure so we expect to see

1212
01:18:18,389 --> 01:18:28,199
8 going from 0 to 143 so here is a bunch

1213
01:18:23,250 --> 01:18:38,550
of 8 and there's 143 right now we've got

1214
01:18:28,198 --> 01:18:46,379
1 44 55 should be nines okay now we've

1215
01:18:38,550 --> 01:18:51,690
got 256 to 279 should be 7s and now I

1216
01:18:46,380 --> 01:18:53,909
got to 82 to 87 should be 8 and then

1217
01:18:51,689 --> 01:18:55,710
everything after that should be fives I

1218
01:18:53,908 --> 01:18:59,788
just don't know how far up the 5 should

1219
01:18:55,710 --> 01:19:10,618
go I think my like my feeling on that is

1220
01:18:59,788 --> 01:19:12,960
that it should go up to 3 19 by oh no we

1221
01:19:10,618 --> 01:19:20,368
exited properly so you know maybe we're

1222
01:19:12,960 --> 01:19:23,520
good I don't know so at this point we're

1223
01:19:20,368 --> 01:19:30,299
kind of now at a place where we need to

1224
01:19:23,520 --> 01:19:32,670
start figuring out okay we we're not

1225
01:19:30,300 --> 01:19:36,659
like obviously erroring out in the

1226
01:19:32,670 --> 01:19:39,380
middle of stuff but we don't actually

1227
01:19:36,658 --> 01:19:39,379
know

1228
01:19:39,859 --> 01:19:44,819
look we don't actually know if we are

1229
01:19:43,078 --> 01:19:46,889
producing reasonable images at all right

1230
01:19:44,819 --> 01:19:48,268
we did some little hand inspection but

1231
01:19:46,889 --> 01:19:52,229
it would be nice now if we could like

1232
01:19:48,269 --> 01:19:55,380
diff the image or something to determine

1233
01:19:52,229 --> 01:19:58,439
whether or not we actually have an exact

1234
01:19:55,380 --> 01:20:01,050
replica or if we've got pixel errors so

1235
01:19:58,439 --> 01:20:02,969
I don't know where we are on time I

1236
01:20:01,050 --> 01:20:07,168
think we're almost out of time actually

1237
01:20:02,969 --> 01:20:11,179
I think we're only ten minutes to go so

1238
01:20:07,168 --> 01:20:13,559
what I think I'll probably do is just

1239
01:20:11,179 --> 01:20:15,958
run a few more tests images through it

1240
01:20:13,559 --> 01:20:18,418
first what we'll do next weekend is

1241
01:20:15,958 --> 01:20:20,550
we'll actually just put in start putting

1242
01:20:18,418 --> 01:20:23,908
in real images to it and test them

1243
01:20:20,550 --> 01:20:26,458
versus like a bitmap version of them

1244
01:20:23,908 --> 01:20:28,978
that we can load exactly and diff them

1245
01:20:26,458 --> 01:20:32,519
so that we can then just verify that we

1246
01:20:28,979 --> 01:20:34,889
actually have what we think we have if I

1247
01:20:32,519 --> 01:20:36,630
remember correctly we've got a case that

1248
01:20:34,889 --> 01:20:42,449
still asserted out and we've never

1249
01:20:36,630 --> 01:20:49,739
called it so this guy the averaging guy

1250
01:20:42,448 --> 01:20:51,388
never gets got used so I don't know what

1251
01:20:49,738 --> 01:20:53,458
to make of that like we still haven't

1252
01:20:51,389 --> 01:20:56,639
asserted in there I'll go ahead and

1253
01:20:53,458 --> 01:20:57,988
remove that assertion temporarily but

1254
01:20:56,639 --> 01:20:59,248
like I'm gonna leave it to do in there

1255
01:20:57,988 --> 01:21:03,348
because at some point would really nice

1256
01:20:59,248 --> 01:21:09,438
to figure out whether that works right

1257
01:21:03,349 --> 01:21:12,510
so let's go ahead and take I don't know

1258
01:21:09,439 --> 01:21:18,179
the best way to do this here but let's

1259
01:21:12,510 --> 01:21:23,399
suppose that we went to twitch.tv slash

1260
01:21:18,179 --> 01:21:27,408
handmade hero and just took a look at

1261
01:21:23,399 --> 01:21:32,389
this nonsense that's going on here

1262
01:21:27,408 --> 01:21:36,118
surely we want the 1080p version right

1263
01:21:32,389 --> 01:21:42,149
and then what I could do is just capture

1264
01:21:36,118 --> 01:21:45,509
this and try to save it right so what

1265
01:21:42,149 --> 01:21:50,119
I'm gonna do is screenshot snipping

1266
01:21:45,510 --> 01:21:51,179
tool' let's go ahead and let that play

1267
01:21:50,118 --> 01:21:55,578
well

1268
01:21:51,179 --> 01:21:59,248
to a new here we'll grab it there we go

1269
01:21:55,578 --> 01:22:06,078
let's go ahead and now we'll save that

1270
01:21:59,248 --> 01:22:09,149
out as an image and we'll save it from a

1271
01:22:06,078 --> 01:22:10,670
you know as a PNG from a different

1272
01:22:09,149 --> 01:22:12,888
program this is from the snipping tool

1273
01:22:10,670 --> 01:22:15,090
just to get something like totally

1274
01:22:12,889 --> 01:22:25,529
different in the mix that I can test

1275
01:22:15,090 --> 01:22:26,969
against - all right um so let's see what

1276
01:22:25,529 --> 01:22:29,340
happens when we throw that at it maybe

1277
01:22:26,969 --> 01:22:32,368
that'll expose some more bugs in our

1278
01:22:29,340 --> 01:22:35,429
stream handling that we haven't thought

1279
01:22:32,368 --> 01:22:38,848
about yet sorry as I forget literally

1280
01:22:35,429 --> 01:22:45,899
the file name I just typed in a chat

1281
01:22:38,849 --> 01:22:48,449
underscore capture so that's good it

1282
01:22:45,899 --> 01:22:50,248
looks like we ran okay so I think we're

1283
01:22:48,448 --> 01:22:52,738
at the point now where our stream

1284
01:22:50,248 --> 01:22:55,559
handling isn't too bad a lot of I dot

1285
01:22:52,738 --> 01:22:57,748
chunks in there we decompressed we

1286
01:22:55,559 --> 01:23:00,900
didn't exceed our boundaries we produced

1287
01:22:57,748 --> 01:23:03,658
the exact right amount of data so that

1288
01:23:00,899 --> 01:23:09,388
to me suggests that we are in reasonable

1289
01:23:03,658 --> 01:23:14,759
shape right okay so let me go ahead and

1290
01:23:09,389 --> 01:23:17,969
put a key way up on there let me also

1291
01:23:14,760 --> 01:23:20,369
ask so MTS mocks you said in the in the

1292
01:23:17,969 --> 01:23:23,639
pre stream that you had worked to find

1293
01:23:20,368 --> 01:23:31,219
the bug so did you find it was that the

1294
01:23:23,639 --> 01:23:31,219
one that you found I'm curious to know

1295
01:23:37,939 --> 01:23:44,279
awesome okay so Dee do you think that

1296
01:23:41,399 --> 01:23:47,129
took me a reasonable amount of time to

1297
01:23:44,279 --> 01:23:48,599
find too long or not I don't know you

1298
01:23:47,130 --> 01:23:53,010
said you thought it took a long time to

1299
01:23:48,600 --> 01:23:54,750
find for you I don't know you could use

1300
01:23:53,010 --> 01:23:56,850
the Ray casting code for save image

1301
01:23:54,750 --> 01:23:59,100
files so we can see what happens it

1302
01:23:56,850 --> 01:24:01,550
should be a quick thing to do that's a

1303
01:23:59,100 --> 01:24:01,550
good point

1304
01:24:01,789 --> 01:24:06,989
handmade ray which we did when we were

1305
01:24:05,640 --> 01:24:12,170
starting to test this new streaming

1306
01:24:06,989 --> 01:24:16,439
machine does have images that we can use

1307
01:24:12,170 --> 01:24:20,850
so here's an example of a bitmap version

1308
01:24:16,439 --> 01:24:26,159
of the image and oops know what I just

1309
01:24:20,850 --> 01:24:30,380
did there oh it's just this I just want

1310
01:24:26,159 --> 01:24:30,380
you to use this Microsoft

1311
01:24:32,449 --> 01:24:39,649
where's why isn't on there

1312
01:24:45,710 --> 01:24:54,779
alright so here's like a thing that was

1313
01:24:50,399 --> 01:25:01,729
produced by the raytracer and here I'll

1314
01:24:54,779 --> 01:25:15,599
export that to the test directory as a

1315
01:25:01,729 --> 01:25:20,759
PNG yes I don't really know what stuff

1316
01:25:15,600 --> 01:25:22,970
to put in here but sure see how that

1317
01:25:20,760 --> 01:25:22,970
does

1318
01:25:34,199 --> 01:25:39,429
so great I'm really happy about that

1319
01:25:36,699 --> 01:25:41,439
that seems pretty robust now in terms of

1320
01:25:39,430 --> 01:25:45,280
handling the stream I mean that was a

1321
01:25:41,439 --> 01:25:48,369
lot of stuff to get right and we got

1322
01:25:45,279 --> 01:25:50,739
right we only had one real nasty bit

1323
01:25:48,369 --> 01:25:55,000
there we do have to give credit where

1324
01:25:50,739 --> 01:25:57,329
credit is due to somebody who probably

1325
01:25:55,000 --> 01:26:00,279
saved us some debugging work coming up

1326
01:25:57,329 --> 01:26:02,170
because remember our filters could all

1327
01:26:00,279 --> 01:26:06,420
be totally busted right now we have no

1328
01:26:02,170 --> 01:26:10,329
idea we haven't really checked but I

1329
01:26:06,420 --> 01:26:12,130
guess what I would say is we somebody

1330
01:26:10,329 --> 01:26:14,380
mentioned the fact that I had read the

1331
01:26:12,130 --> 01:26:17,949
spec wrong about the B value being too

1332
01:26:14,380 --> 01:26:22,090
high up being up one above not two

1333
01:26:17,949 --> 01:26:26,380
behind so for the C value rather so that

1334
01:26:22,090 --> 01:26:28,739
one was somebody somebody treated me on

1335
01:26:26,380 --> 01:26:28,739
that one

1336
01:26:32,579 --> 01:26:37,750
do you purposely screenshot my message

1337
01:26:35,319 --> 01:26:40,529
saying you are handsome no I didn't I

1338
01:26:37,750 --> 01:26:40,529
didn't even notice that

1339
01:26:41,850 --> 01:26:46,030
frosty ninja I think he meant save out

1340
01:26:43,960 --> 01:26:49,539
the decoded p.m. geez as a rub bitmap so

1341
01:26:46,029 --> 01:26:51,039
we can see the result oh I see what

1342
01:26:49,539 --> 01:26:54,310
you're saying you're saying use the

1343
01:26:51,039 --> 01:26:58,600
bitmap saving code you know what that's

1344
01:26:54,310 --> 01:27:02,320
also a good idea that both the ideas

1345
01:26:58,600 --> 01:27:04,510
that you that I interpreted you as

1346
01:27:02,319 --> 01:27:07,119
saying and the idea you actually had

1347
01:27:04,510 --> 01:27:10,539
which not the same are both good ideas

1348
01:27:07,119 --> 01:27:14,529
yes we could we did write on handmade

1349
01:27:10,539 --> 01:27:17,289
ray a bitmap thing here somewhere

1350
01:27:14,529 --> 01:27:21,489
I don't remember where but we do have

1351
01:27:17,289 --> 01:27:27,090
one in there that saves a bitmap anyone

1352
01:27:21,489 --> 01:27:27,090
remember where that is here it is

1353
01:27:32,698 --> 01:27:38,038
so yeah we couldn't we could totally do

1354
01:27:34,618 --> 01:27:41,608
that that's pretty trivial to do so if

1355
01:27:38,038 --> 01:27:43,768
we want to dump that in here we would

1356
01:27:41,609 --> 01:27:45,989
just need the bitmap header struct that

1357
01:27:43,769 --> 01:27:48,539
bitmap header struct I don't know if

1358
01:27:45,988 --> 01:27:51,088
it's already in here it might be yeah it

1359
01:27:48,538 --> 01:27:55,228
is so all we would really need to do is

1360
01:27:51,088 --> 01:28:10,769
like put the width and the height in

1361
01:27:55,229 --> 01:28:21,079
here and then put that in here we don't

1362
01:28:10,769 --> 01:28:21,079
have the bitmap header but we do now

1363
01:28:31,930 --> 01:28:37,250
there we go

1364
01:28:34,189 --> 01:28:38,929
and then this image pixels bit here is

1365
01:28:37,250 --> 01:28:53,630
just gonna have to be something that we

1366
01:28:38,930 --> 01:29:02,659
pass in yeah so that seems good maybe I

1367
01:28:53,630 --> 01:29:07,300
don't know but yeah so after PNG filter

1368
01:29:02,659 --> 01:29:13,130
reconstruct here where we are what

1369
01:29:07,300 --> 01:29:20,329
what's going on here so we can do W do

1370
01:29:13,130 --> 01:29:23,590
we have a tempter we do although it's

1371
01:29:20,329 --> 01:29:28,119
filled with other stuff in it though

1372
01:29:23,590 --> 01:29:29,390
maybe it's time to clean that out move

1373
01:29:28,119 --> 01:29:39,079
rename

1374
01:29:29,390 --> 01:29:44,480
temp to old temp make your temp so you

1375
01:29:39,079 --> 01:29:45,829
know something like this ish so that'd

1376
01:29:44,479 --> 01:29:50,239
be pretty easy for us to implement right

1377
01:29:45,829 --> 01:29:53,539
we can just say like if argh count is

1378
01:29:50,239 --> 01:29:57,019
greater than equal to 2 or equals 3

1379
01:29:53,539 --> 01:30:01,039
right then we say like okay the you know

1380
01:29:57,020 --> 01:30:04,630
in file name and the out file name so

1381
01:30:01,039 --> 01:30:04,630
then we do like that

1382
01:30:10,000 --> 01:30:25,869
uh and just you know pass this thing in

1383
01:30:23,470 --> 01:30:28,270
here so honestly I think actually the

1384
01:30:25,869 --> 01:30:29,920
waitest thing had it before though with

1385
01:30:28,270 --> 01:30:33,040
having a package that you return is

1386
01:30:29,920 --> 01:30:36,359
probably a good idea right so we

1387
01:30:33,039 --> 01:30:39,010
probably actually want to keep that

1388
01:30:36,359 --> 01:30:43,659
thing that had before to a certain

1389
01:30:39,010 --> 01:30:46,119
extent because this read this thing here

1390
01:30:43,659 --> 01:30:49,930
this parse P&amp;G is gonna have to return

1391
01:30:46,119 --> 01:30:52,510
something and you know it would be nice

1392
01:30:49,930 --> 01:30:55,930
if you could return the metrics of the

1393
01:30:52,510 --> 01:30:57,880
file as well so you know this image u-32

1394
01:30:55,930 --> 01:31:00,520
nonsense that we introduced in here

1395
01:30:57,880 --> 01:31:02,920
somewhere is actually probably the right

1396
01:31:00,520 --> 01:31:05,950
thing or not necessarily the right thing

1397
01:31:02,920 --> 01:31:07,899
but like it's useful so we know we can

1398
01:31:05,949 --> 01:31:10,179
just dump that in here and say like okay

1399
01:31:07,899 --> 01:31:13,809
yeah you know this thing returns one of

1400
01:31:10,180 --> 01:31:15,579
this these and then you can just do this

1401
01:31:13,810 --> 01:31:17,620
and you know it's good to still have

1402
01:31:15,579 --> 01:31:18,729
this take the broken out pieces I kind

1403
01:31:17,619 --> 01:31:20,739
of feel like because there's no sense

1404
01:31:18,729 --> 01:31:22,750
and not how do you do that but it's good

1405
01:31:20,739 --> 01:31:24,369
to have this for the return value so

1406
01:31:22,750 --> 01:31:27,220
that seemed useful to me so I'm going to

1407
01:31:24,369 --> 01:31:29,229
keep that as it is so if this returns an

1408
01:31:27,220 --> 01:31:31,570
image u-32 I'm just gonna say that

1409
01:31:29,229 --> 01:31:33,609
there's a result one here when we come

1410
01:31:31,569 --> 01:31:36,009
through here we've got the final pixels

1411
01:31:33,609 --> 01:31:38,500
the width and the height are things that

1412
01:31:36,010 --> 01:31:40,800
need to be out here but at this point

1413
01:31:38,500 --> 01:31:46,050
now when we come down here I can just

1414
01:31:40,800 --> 01:31:46,050
basically romp those in and

1415
01:31:49,618 --> 01:31:58,488
I don't know why define it at the top

1416
01:32:04,368 --> 01:32:08,488
yeah that was not necessary so this this

1417
01:32:06,840 --> 01:32:09,989
could actually just happen down here

1418
01:32:08,488 --> 01:32:14,789
it's just like a way to bundle up the

1419
01:32:09,988 --> 01:32:22,549
information that comes back like so and

1420
01:32:14,789 --> 01:32:22,550
so now at that point that should be fine

1421
01:32:26,599 --> 01:32:33,650
and maybe that'll work I don't know

1422
01:32:35,719 --> 01:32:46,649
let's see so there's our temp file whoa

1423
01:32:41,609 --> 01:32:50,429
okay so it looks like we have a couple

1424
01:32:46,649 --> 01:32:53,039
problems so all of these I think are not

1425
01:32:50,429 --> 01:32:56,429
problems with our reader though so first

1426
01:32:53,039 --> 01:32:59,010
of all the PNG comes in RGBA the bitmap

1427
01:32:56,429 --> 01:33:02,399
goes out the other bitmaps have the

1428
01:32:59,010 --> 01:33:08,190
white reversed version so there's that

1429
01:33:02,399 --> 01:33:09,960
bitmaps also flip upside down so those

1430
01:33:08,189 --> 01:33:11,250
two things we would have to handle but

1431
01:33:09,960 --> 01:33:14,039
otherwise I think we're good

1432
01:33:11,250 --> 01:33:20,969
like I think that's just correct so

1433
01:33:14,039 --> 01:33:25,769
that's yeah so when we let's call this

1434
01:33:20,969 --> 01:33:27,929
right image top-down rgba what this

1435
01:33:25,770 --> 01:33:34,949
would have to do here I think you can do

1436
01:33:27,929 --> 01:33:37,560
that I think we can do that if we want

1437
01:33:34,948 --> 01:33:40,289
to but since we have to reverse the

1438
01:33:37,560 --> 01:33:44,070
channels anyway what I could do here is

1439
01:33:40,289 --> 01:33:48,269
just do the row swap at the same time I

1440
01:33:44,069 --> 01:33:51,479
do the bit swap so what I could do is

1441
01:33:48,270 --> 01:33:53,659
say all right you know row equals zero

1442
01:33:51,479 --> 01:34:02,569
or I should people should do this y

1443
01:33:53,658 --> 01:34:02,569
equals 0 less than header height

1444
01:34:02,920 --> 01:34:19,690
/ - I want to round that up I'll do

1445
01:34:13,210 --> 01:34:24,060
midpoint sue based I'm gonna do is say

1446
01:34:19,689 --> 01:34:24,059
like look let's go to the halfway point

1447
01:34:24,238 --> 01:34:35,609
here and what I could do is take two

1448
01:34:31,960 --> 01:34:41,380
rows swap the two rows and swap the Arn

1449
01:34:35,609 --> 01:34:45,219
and swap the R and B channels which

1450
01:34:41,380 --> 01:34:49,539
should give me a valid bit map out in

1451
01:34:45,219 --> 01:34:55,899
theory right so basically I can say is

1452
01:34:49,539 --> 01:34:58,618
like you know row 0 equals well I can do

1453
01:34:55,899 --> 01:34:58,618
it like this actually

1454
01:34:59,859 --> 01:35:11,139
so row 0 equals pixels row you know 1

1455
01:35:06,158 --> 01:35:24,009
equals pixels plus the height times the

1456
01:35:11,139 --> 01:35:26,109
width like that so just get me to the

1457
01:35:24,010 --> 01:35:31,119
last row so now I've got pointed it to

1458
01:35:26,109 --> 01:35:33,880
either right either one and then each

1459
01:35:31,118 --> 01:35:35,259
time through I can just do like in fact

1460
01:35:33,880 --> 01:35:43,270
it you know

1461
01:35:35,260 --> 01:35:45,130
yeah well row so step one you know from

1462
01:35:43,270 --> 01:35:48,219
the top down dealer from the bottom up

1463
01:35:45,130 --> 01:35:52,989
right and then we can just go through

1464
01:35:48,219 --> 01:36:00,130
and and do the pixels right pick 0

1465
01:35:52,988 --> 01:36:04,259
equals row zero picks one row one for

1466
01:36:00,130 --> 01:36:09,159
you 32 X equals zero X is less than with

1467
01:36:04,260 --> 01:36:15,789
plus plus X and here I just need to swap

1468
01:36:09,158 --> 01:36:16,649
the two right so C 0 equals pics 0 C 1

1469
01:36:15,789 --> 01:36:19,039
equals

1470
01:36:16,649 --> 01:36:23,629
six-one I've read out both the colors

1471
01:36:19,039 --> 01:36:23,630
then I will just write them back

1472
01:36:23,840 --> 01:36:28,619
together here although actually I guess

1473
01:36:26,250 --> 01:36:31,380
we'll just swap them right and so now

1474
01:36:28,619 --> 01:36:41,550
what I need to do is swap the R and the

1475
01:36:31,380 --> 01:36:56,720
B of each of them maybe I'd do it like

1476
01:36:41,550 --> 01:36:56,720
this no I do it like this

1477
01:36:56,779 --> 01:37:01,649
so I'll swap the R &amp; B of this I'll swap

1478
01:37:00,060 --> 01:37:03,440
the R &amp; B of that and then I'll just

1479
01:37:01,649 --> 01:37:08,969
write them out in the opposite order

1480
01:37:03,439 --> 01:37:13,139
right so that flips the image I believe

1481
01:37:08,970 --> 01:37:15,090
and flips that are in B channels which I

1482
01:37:13,140 --> 01:37:18,450
need it to do so then all I need here is

1483
01:37:15,090 --> 01:37:24,060
a thing that will do that swap so when I

1484
01:37:18,449 --> 01:37:28,409
say swap R&amp;B like there's the color for

1485
01:37:24,060 --> 01:37:31,410
the input and so if you think about

1486
01:37:28,409 --> 01:37:34,470
what's gonna happen to to these top tip

1487
01:37:31,409 --> 01:37:36,960
the values right the Alpha and the green

1488
01:37:34,470 --> 01:37:41,820
stay in the same place and only the R

1489
01:37:36,960 --> 01:37:45,750
and the B swap right so to produce the

1490
01:37:41,819 --> 01:37:47,969
result value if I just start writing

1491
01:37:45,750 --> 01:37:51,479
this out longhand I know that I can

1492
01:37:47,970 --> 01:37:54,060
knock out the values in question like

1493
01:37:51,479 --> 01:37:56,099
that so this will leave me with just the

1494
01:37:54,060 --> 01:38:03,510
Alpha and green channels intact

1495
01:37:56,100 --> 01:38:05,789
oops sorry little fat finger today so

1496
01:38:03,510 --> 01:38:08,820
then the question is just what else do I

1497
01:38:05,789 --> 01:38:11,159
have to put in here well I need the red

1498
01:38:08,819 --> 01:38:11,670
channel to swell depends how you wanna

1499
01:38:11,159 --> 01:38:15,420
look at it

1500
01:38:11,670 --> 01:38:17,069
I need the input that went here to slide

1501
01:38:15,420 --> 01:38:20,609
down I need the input the weight here to

1502
01:38:17,069 --> 01:38:25,469
slide up right so I need to slide down

1503
01:38:20,609 --> 01:38:29,369
16 bits and or in what would it be in

1504
01:38:25,470 --> 01:38:30,449
the low at that point right so just slot

1505
01:38:29,369 --> 01:38:32,670
in whatever

1506
01:38:30,448 --> 01:38:37,979
that's taking what was here and sliding

1507
01:38:32,670 --> 01:38:40,770
it there right so that's one part of it

1508
01:38:37,979 --> 01:38:44,099
then I need to take the bottom part and

1509
01:38:40,770 --> 01:38:47,040
slide it up right and what I can do

1510
01:38:44,100 --> 01:38:50,219
there is just end it with oxf FF first

1511
01:38:47,039 --> 01:38:53,399
then slide it up so that I still use the

1512
01:38:50,219 --> 01:38:56,310
same mask both times right it's pretty

1513
01:38:53,399 --> 01:39:03,479
simple I think that swaps them we'll

1514
01:38:56,310 --> 01:39:08,850
have to double check I meant to type

1515
01:39:03,479 --> 01:39:10,709
that and so now that was pretty quick

1516
01:39:08,850 --> 01:39:15,210
and dirty I admit that but I think that

1517
01:39:10,710 --> 01:39:18,239
might be what we wanted let's take a

1518
01:39:15,210 --> 01:39:24,840
look okay there's no way that produced

1519
01:39:18,238 --> 01:39:29,579
exactly the same image oh I forgot to

1520
01:39:24,840 --> 01:39:31,560
advance those pointers it didn't produce

1521
01:39:29,579 --> 01:39:34,319
exactly the same age it produced almost

1522
01:39:31,560 --> 01:39:40,219
exactly the same image it only did the

1523
01:39:34,319 --> 01:39:43,399
first column um so yeah right there

1524
01:39:40,219 --> 01:39:43,399
sorry about that

1525
01:39:43,488 --> 01:39:57,329
one more time so there's the you know

1526
01:39:53,698 --> 01:40:02,609
there's there's the image that we

1527
01:39:57,329 --> 01:40:05,729
produced from the ping and if I go look

1528
01:40:02,609 --> 01:40:11,579
at the test data that we got here's the

1529
01:40:05,729 --> 01:40:17,488
input ping now I'm not really sure how

1530
01:40:11,579 --> 01:40:20,899
to diff these two exactly if we had like

1531
01:40:17,488 --> 01:40:24,019
beyond compare or like one of those

1532
01:40:20,899 --> 01:40:29,939
utilities we could just ask it to diff I

1533
01:40:24,020 --> 01:40:35,150
don't know if Kemp can diff it's sort of

1534
01:40:29,939 --> 01:40:41,119
good right like what I could do is this

1535
01:40:35,149 --> 01:40:41,119
open hand made ray open

1536
01:40:42,800 --> 01:40:55,849
you know temp oops I meant open as

1537
01:40:48,090 --> 01:41:06,569
layers temp and then set this layer to

1538
01:40:55,849 --> 01:41:08,880
subtract and see what we get so that's

1539
01:41:06,569 --> 01:41:10,738
what the difference says I don't know if

1540
01:41:08,880 --> 01:41:18,090
that means we've got some bugs on the

1541
01:41:10,738 --> 01:41:26,368
outline here if I don't set it to

1542
01:41:18,090 --> 01:41:33,690
difference can we see those bugs oh it

1543
01:41:26,368 --> 01:41:36,889
looks like we shifted the image I wonder

1544
01:41:33,689 --> 01:41:36,888
if that's because my swap

1545
01:41:40,770 --> 01:41:45,120
like we shifted the image did you notice

1546
01:41:43,199 --> 01:41:51,079
that is that true

1547
01:41:45,119 --> 01:41:51,079
let's take a look I'm look at the top

1548
01:41:52,760 --> 01:41:59,400
yeah so the image is shifted up by one

1549
01:41:56,600 --> 01:42:00,840
what happened at the bottom oh there's

1550
01:41:59,399 --> 01:42:10,159
no way to tell is there because there's

1551
01:42:00,840 --> 01:42:13,590
nothing on the bottom there it's blank

1552
01:42:10,159 --> 01:42:17,279
so uh so that's I think we're good it's

1553
01:42:13,590 --> 01:42:22,159
just we this right bitmap is off by one

1554
01:42:17,279 --> 01:42:22,159
here so let's see

1555
01:42:45,989 --> 01:42:48,989
so

1556
01:43:01,300 --> 01:43:09,520
I can't I'm sure that I should be able

1557
01:43:07,750 --> 01:43:15,939
to immediately see what the problem is

1558
01:43:09,520 --> 01:43:19,170
up there just straight-up typos don't

1559
01:43:15,939 --> 01:43:23,049
ask me why that was doing that all right

1560
01:43:19,170 --> 01:43:31,960
so if I now run this we should now have

1561
01:43:23,050 --> 01:43:33,970
an exact version hopefully hopefully so

1562
01:43:31,960 --> 01:43:35,920
that's the one in the actual temp

1563
01:43:33,970 --> 01:43:38,650
directory so that's the one we produced

1564
01:43:35,920 --> 01:43:44,529
let me open as layers the original one

1565
01:43:38,649 --> 01:43:47,579
that's an handmade test handmade ray and

1566
01:43:44,529 --> 01:43:50,859
so let me set that to difference now

1567
01:43:47,579 --> 01:43:52,779
this is not really correct because it

1568
01:43:50,859 --> 01:43:54,489
won't handle overflow and underflow but

1569
01:43:52,779 --> 01:43:57,099
at least now we can see that there's no

1570
01:43:54,489 --> 01:44:05,349
obvious glaring errors so we're doing

1571
01:43:57,100 --> 01:44:07,920
pretty good not bad for a Sunday let me

1572
01:44:05,350 --> 01:44:07,920
take some questions

1573
01:44:08,609 --> 01:44:12,909
isn't it true the compiler optimizations

1574
01:44:10,840 --> 01:44:14,170
of your code and the way the CPU works

1575
01:44:12,909 --> 01:44:15,789
the sometimes cause instructions to

1576
01:44:14,170 --> 01:44:18,819
happen in a different order than you

1577
01:44:15,789 --> 01:44:23,470
wrote them if so won't that screw up

1578
01:44:18,819 --> 01:44:26,799
profiling measurements I yes and yes I

1579
01:44:23,470 --> 01:44:28,869
guess is what I'd say this is off topic

1580
01:44:26,800 --> 01:44:30,699
right because we're not doing profiling

1581
01:44:28,869 --> 01:44:32,019
measurements today I mean I you're not

1582
01:44:30,699 --> 01:44:33,220
you're not asking question about what

1583
01:44:32,020 --> 01:44:35,680
we're doing here right that's just a

1584
01:44:33,220 --> 01:44:38,820
general question the answer is yes it

1585
01:44:35,680 --> 01:44:38,820
can and yes it can

1586
01:44:39,000 --> 01:44:46,270
those are those things are true can you

1587
01:44:44,140 --> 01:44:50,380
quantify how fast you type not

1588
01:44:46,270 --> 01:44:52,210
particularly easily because most typing

1589
01:44:50,380 --> 01:44:54,130
thing measurements just give you words

1590
01:44:52,210 --> 01:44:56,199
to type which are different than typing

1591
01:44:54,130 --> 01:44:57,640
code so it's a little hard to say it's

1592
01:44:56,199 --> 01:44:59,979
like what do you mean by how fast can

1593
01:44:57,640 --> 01:45:04,030
you type you know would you say that for

1594
01:44:59,979 --> 01:45:06,819
coder is the ideal text editor well

1595
01:45:04,029 --> 01:45:10,239
probably not the ideal text editor but

1596
01:45:06,819 --> 01:45:11,739
it's like the one that I prefer I mean

1597
01:45:10,239 --> 01:45:13,119
the ideal text editor would have all

1598
01:45:11,739 --> 01:45:15,038
sorts of crazy stuff in it

1599
01:45:13,119 --> 01:45:17,078
I mean Alan's only been

1600
01:45:15,038 --> 01:45:23,679
working on for coder for not that many

1601
01:45:17,078 --> 01:45:25,118
hours right so I feel like I don't think

1602
01:45:23,679 --> 01:45:26,679
he thinks it's the ideal text editor

1603
01:45:25,118 --> 01:45:31,108
either he's got tons of things planned

1604
01:45:26,679 --> 01:45:34,449
for it that you know will make it better

1605
01:45:31,109 --> 01:45:36,819
how often do I work out I do not really

1606
01:45:34,448 --> 01:45:39,748
work out per se I go rock climbing which

1607
01:45:36,819 --> 01:45:41,979
kind of just ends up being your work out

1608
01:45:39,748 --> 01:45:43,269
in the bitmap write routine I think you

1609
01:45:41,979 --> 01:45:45,010
have a bug you advanced rozier too soon

1610
01:45:43,269 --> 01:45:47,949
yes you are correct we just found that

1611
01:45:45,010 --> 01:45:50,409
one double check the shifting it's not a

1612
01:45:47,948 --> 01:45:57,608
git pastry error it's not it was just us

1613
01:45:50,408 --> 01:45:58,748
it's just us it's just us just trying a

1614
01:45:57,609 --> 01:46:00,159
week ago and having that time to go fill

1615
01:45:58,748 --> 01:46:01,658
a serious can you say in overall what

1616
01:46:00,158 --> 01:46:03,818
have you done on the product and what is

1617
01:46:01,658 --> 01:46:06,668
left to do so at this point we're

1618
01:46:03,819 --> 01:46:08,260
basically putting art in after we're

1619
01:46:06,668 --> 01:46:10,208
done putting art in we're gonna base

1620
01:46:08,260 --> 01:46:11,798
we're going to mostly be doing gameplay

1621
01:46:10,208 --> 01:46:18,818
programming which is like programming

1622
01:46:11,798 --> 01:46:20,979
like you know NPCs hopping around and

1623
01:46:18,819 --> 01:46:23,199
you interacting with the world in ways

1624
01:46:20,979 --> 01:46:26,559
to stuff like that that's that's what we

1625
01:46:23,198 --> 01:46:28,238
have to do now and along with that

1626
01:46:26,559 --> 01:46:29,739
there'll be world generation code stuff

1627
01:46:28,238 --> 01:46:31,088
because we don't have we just have a

1628
01:46:29,738 --> 01:46:35,648
very simple world generation in there

1629
01:46:31,088 --> 01:46:38,229
right now we will do some passes on the

1630
01:46:35,649 --> 01:46:40,749
graphics later to add more stuff like

1631
01:46:38,229 --> 01:46:42,668
more like good particles and stuff we we

1632
01:46:40,748 --> 01:46:43,958
have like some sort of placeholder stuff

1633
01:46:42,668 --> 01:46:46,889
in there for some things and those

1634
01:46:43,958 --> 01:46:46,889
things will have to improve

1635
01:47:08,970 --> 01:47:14,579
do you have any project recommendations

1636
01:47:11,079 --> 01:47:14,579
for beginner intermediate C programmers

1637
01:47:14,819 --> 01:47:22,899
which kind so the one I usually say for

1638
01:47:19,659 --> 01:47:25,599
game programming is asteroids it's like

1639
01:47:22,899 --> 01:47:28,839
the easiest game to write so it's a good

1640
01:47:25,600 --> 01:47:32,260
one to start with if you're not talking

1641
01:47:28,840 --> 01:47:34,060
about real time and you and/or you want

1642
01:47:32,260 --> 01:47:46,750
something that's not has no platform

1643
01:47:34,060 --> 01:47:49,090
dependent parts raytracer is good seems

1644
01:47:46,750 --> 01:47:51,840
a bit casual today what's your favorite

1645
01:47:49,090 --> 01:47:51,840
album Oh

1646
01:48:13,210 --> 01:48:23,170
what's my favorite album you know that's

1647
01:48:20,238 --> 01:48:23,169
real tough

1648
01:49:37,420 --> 01:49:50,949
I don't think I can pick a favorite

1649
01:49:40,270 --> 01:49:55,060
album I really just don't think I don't

1650
01:49:50,948 --> 01:49:58,859
think it could pick one I'm sorry what

1651
01:49:55,060 --> 01:49:58,860
is the craziest file format to parse

1652
01:50:00,489 --> 01:50:03,710
[Music]

1653
01:50:05,279 --> 01:50:13,779
well I guess I don't know what you mean

1654
01:50:07,920 --> 01:50:20,980
so the craziest file format you might

1655
01:50:13,779 --> 01:50:26,319
try to parse in practice would probably

1656
01:50:20,979 --> 01:50:31,919
be 3d studio max because there is no

1657
01:50:26,319 --> 01:50:35,380
text version it is binary it is

1658
01:50:31,920 --> 01:50:39,819
undocumented and it depends entirely on

1659
01:50:35,380 --> 01:50:43,750
which plugins are active and it changes

1660
01:50:39,819 --> 01:50:46,389
with every revision so probably like

1661
01:50:43,750 --> 01:50:48,219
reading max files directly would be like

1662
01:50:46,390 --> 01:50:48,989
one of the most nuts of things you could

1663
01:50:48,219 --> 01:50:51,579
do

1664
01:50:48,988 --> 01:50:54,399
I'm sure there's harder but that's just

1665
01:50:51,579 --> 01:50:55,899
the one that comes to mind what is the

1666
01:50:54,399 --> 01:50:57,549
most difficult file format to read have

1667
01:50:55,899 --> 01:50:58,750
you ever tried to read PDF files and try

1668
01:50:57,550 --> 01:51:03,969
doing a vector renderer for those no

1669
01:50:58,750 --> 01:51:05,619
Brasil TDF files aren't bad no there's

1670
01:51:03,969 --> 01:51:14,340
there's way worse stuff out there than

1671
01:51:05,619 --> 01:51:23,159
that what's my favorite pasta dish so I

1672
01:51:14,340 --> 01:51:31,329
think I would say that a straightforward

1673
01:51:23,159 --> 01:51:35,050
sausage rigatoni would probably it like

1674
01:51:31,329 --> 01:51:37,890
a red sauce sausage in rigatoni like

1675
01:51:35,050 --> 01:51:40,500
it's a pretty standard Italian dish I

1676
01:51:37,890 --> 01:51:42,610
like that a lot

1677
01:51:40,500 --> 01:51:45,159
how come no one is me I saw a debugger

1678
01:51:42,609 --> 01:51:46,750
is it difficult no it's not particularly

1679
01:51:45,159 --> 01:51:49,500
difficult I think the problem is it's

1680
01:51:46,750 --> 01:51:49,500
not particularly profitable

1681
01:51:50,750 --> 01:52:02,170
I think one of the main issues that we

1682
01:51:53,899 --> 01:52:02,170
face these days I guess I would say

1683
01:52:03,010 --> 01:52:10,940
developers don't pay for software much

1684
01:52:07,899 --> 01:52:15,529
they expect everything to be open source

1685
01:52:10,939 --> 01:52:17,509
and free now to a large extent and the

1686
01:52:15,529 --> 01:52:22,039
problem ends up being that there's no

1687
01:52:17,510 --> 01:52:24,590
money in it to make these tools so as a

1688
01:52:22,039 --> 01:52:26,600
result no one does and you just end up

1689
01:52:24,590 --> 01:52:29,510
with like crappy free stuff that isn't

1690
01:52:26,600 --> 01:52:34,370
very good or like the one remaining tool

1691
01:52:29,510 --> 01:52:37,909
from Microsoft or something well the

1692
01:52:34,369 --> 01:52:40,309
game the only room based I don't know

1693
01:52:37,909 --> 01:52:42,789
we have scrolling in there so I don't

1694
01:52:40,310 --> 01:52:46,760
really we I don't know

1695
01:52:42,789 --> 01:52:48,890
am i musician not really I can play the

1696
01:52:46,760 --> 01:52:52,250
piano though did you write music for

1697
01:52:48,890 --> 01:52:55,400
handmade here oh no I'm not writing

1698
01:52:52,250 --> 01:52:56,899
music for handmade hero how can I send

1699
01:52:55,399 --> 01:52:59,449
data over the internet for a game that

1700
01:52:56,899 --> 01:53:03,199
can be picked up in a code that I write

1701
01:52:59,449 --> 01:53:10,699
well usually you use sockets for that so

1702
01:53:03,199 --> 01:53:15,050
usually you use like rect V or send to

1703
01:53:10,699 --> 01:53:16,849
send packets I mean I'm not sure what

1704
01:53:15,050 --> 01:53:19,670
you're asking but that's how that's done

1705
01:53:16,850 --> 01:53:22,000
usually we'll be parsing compiler debug

1706
01:53:19,670 --> 01:53:24,920
output for cool game game devices no

1707
01:53:22,000 --> 01:53:28,130
we're not get a parse dwarf dwarf

1708
01:53:24,920 --> 01:53:32,960
speaking of disasters file formats 3ds

1709
01:53:28,130 --> 01:53:35,569
is worse than PCSO three not 3ds max 3ds

1710
01:53:32,960 --> 01:53:37,760
files aren't aren't awful 3d spells

1711
01:53:35,569 --> 01:53:42,859
aren't great but they're not awful max

1712
01:53:37,760 --> 01:53:48,860
files are awful dot ma x way worse than

1713
01:53:42,859 --> 01:53:50,059
PSD way worse we've had a handmaid ray

1714
01:53:48,859 --> 01:53:51,799
bonus series what about having asteroids

1715
01:53:50,060 --> 01:53:57,670
maybe someday I don't know no promises

1716
01:53:51,800 --> 01:53:57,670
all right I'm calling it a day

1717
01:53:59,729 --> 01:54:06,189
hey we made a PNG reader that was cool

1718
01:54:03,630 --> 01:54:08,140
first time I ever parsed PNG never had

1719
01:54:06,189 --> 01:54:10,719
to write it before I will probably go

1720
01:54:08,140 --> 01:54:12,220
move that into my codebase - because why

1721
01:54:10,720 --> 01:54:14,440
not now I don't have to use other

1722
01:54:12,220 --> 01:54:17,110
people's code to read a PNG if I want to

1723
01:54:14,439 --> 01:54:20,199
I could also make something that writes

1724
01:54:17,109 --> 01:54:21,819
of PNG now that I think about it because

1725
01:54:20,199 --> 01:54:31,019
it wouldn't be very hard to reverse and

1726
01:54:21,819 --> 01:54:34,539
to go the other direction anyway alright

1727
01:54:31,020 --> 01:54:35,920
so I want to close this down because we

1728
01:54:34,539 --> 01:54:39,100
don't need all these specs anymore but

1729
01:54:35,920 --> 01:54:40,960
if we encounter bugs in the future in

1730
01:54:39,100 --> 01:54:43,000
our PNG reader it'd be nice to have them

1731
01:54:40,960 --> 01:54:45,730
so what I might do is just say like

1732
01:54:43,000 --> 01:54:47,590
let's make a little PNG Doc's thing here

1733
01:54:45,729 --> 01:54:50,199
so we don't have to go dig these up

1734
01:54:47,590 --> 01:54:55,480
again and let's just drop these in there

1735
01:54:50,199 --> 01:54:58,079
the links oh you know what be even

1736
01:54:55,479 --> 01:55:03,299
better let's just save the documents

1737
01:54:58,079 --> 01:55:03,300
because these are text files aren't they

1738
01:55:03,600 --> 01:55:13,240
so can I just save this thing of course

1739
01:55:11,229 --> 01:55:21,639
this wouldn't have the diagrams would it

1740
01:55:13,239 --> 01:55:23,469
like what's this thing okay well I mean

1741
01:55:21,640 --> 01:55:27,850
it could still load the pings I guess I

1742
01:55:23,470 --> 01:55:31,420
don't know so all of these are just

1743
01:55:27,850 --> 01:55:33,190
would just save right we wouldn't have

1744
01:55:31,420 --> 01:55:35,460
to save the links we could just save the

1745
01:55:33,189 --> 01:55:35,460
file

1746
01:56:04,300 --> 01:56:08,210
so anyway now we've got those in there

1747
01:56:06,590 --> 01:56:12,880
at least these two we can open up as

1748
01:56:08,210 --> 01:56:12,880
text which is nice these two not so much

1749
01:56:21,998 --> 01:56:32,359
looks like that worked okay yeah so I'll

1750
01:56:29,809 --> 01:56:35,239
just leave those there because you know

1751
01:56:32,359 --> 01:56:37,549
we only know that a small smattering of

1752
01:56:35,238 --> 01:56:39,799
tests seem to work properly we have not

1753
01:56:37,550 --> 01:56:41,599
done any robust validation of this PNG

1754
01:56:39,800 --> 01:56:43,309
reader so we don't really know that

1755
01:56:41,599 --> 01:56:45,739
we've handled all the cases correctly

1756
01:56:43,309 --> 01:56:47,719
and we could in practice as we start

1757
01:56:45,738 --> 01:56:49,279
using this in the game find that we've

1758
01:56:47,719 --> 01:56:51,170
got some art assets that don't load

1759
01:56:49,279 --> 01:56:52,550
properly because maybe Photoshop does

1760
01:56:51,170 --> 01:56:54,440
some slightly different things then

1761
01:56:52,550 --> 01:56:56,479
does and it does compression it so etc

1762
01:56:54,439 --> 01:56:57,529
so we want those documents handy because

1763
01:56:56,479 --> 01:57:00,139
we're gonna have to refer to them again

1764
01:56:57,529 --> 01:57:02,268
when we hit a bug right so we'll leave

1765
01:57:00,139 --> 01:57:04,010
those there for now but that way I don't

1766
01:57:02,269 --> 01:57:06,349
have to keep them up here all the time

1767
01:57:04,010 --> 01:57:07,789
all right thank you for one for joining

1768
01:57:06,349 --> 01:57:09,199
me for the handmade hero so in pleasure

1769
01:57:07,788 --> 01:57:10,788
code with you as always I'm glad that

1770
01:57:09,198 --> 01:57:12,439
that PNG reader went pretty smoothly I

1771
01:57:10,788 --> 01:57:14,689
don't know we only spent what eight

1772
01:57:12,439 --> 01:57:15,379
hours on it twelve hours on it from

1773
01:57:14,689 --> 01:57:18,558
start to finish

1774
01:57:15,380 --> 01:57:20,630
PNG reader that's pretty cool and now we

1775
01:57:18,559 --> 01:57:21,650
can load p.m. cheese immediately so

1776
01:57:20,630 --> 01:57:23,300
that'll allow us to have a nice

1777
01:57:21,649 --> 01:57:24,978
Photoshop turnaround time so we can go

1778
01:57:23,300 --> 01:57:27,949
ahead and started playing that next

1779
01:57:24,979 --> 01:57:31,280
weekend just roll that into the asset

1780
01:57:27,948 --> 01:57:34,969
system so we can just import assets on

1781
01:57:31,279 --> 01:57:38,149
the fly alright that's it if you want to

1782
01:57:34,969 --> 01:57:39,649
follow along at home obviously as I say

1783
01:57:38,149 --> 01:57:41,420
all the time you go here to the game on

1784
01:57:39,649 --> 01:57:43,598
handmade hero org it comes with source

1785
01:57:41,420 --> 01:57:47,479
code so you can play around it yourself

1786
01:57:43,599 --> 01:57:50,538
so yeah if you want to take a shot at

1787
01:57:47,479 --> 01:57:53,090
adding hot loading of PNG s before I do

1788
01:57:50,538 --> 01:57:54,550
next weekend you could dig out the asset

1789
01:57:53,090 --> 01:57:56,630
system and give it a give it a shot

1790
01:57:54,550 --> 01:57:58,010
alright until then have fun program

1791
01:57:56,630 --> 01:58:00,400
everyone I'll see you on the Internet

1792
01:57:58,010 --> 01:58:02,929
I'll be back here next week to start

1793
01:58:00,399 --> 01:58:05,478
rolling that that PNG reader into our

1794
01:58:02,929 --> 01:58:07,248
mainline code we'll try to do that in a

1795
01:58:05,479 --> 01:58:09,409
way that allows us to still keep the

1796
01:58:07,248 --> 01:58:10,880
test cases running again specifically

1797
01:58:09,408 --> 01:58:13,998
because I don't want to run this

1798
01:58:10,880 --> 01:58:15,260
situation where we hit some new bug and

1799
01:58:13,998 --> 01:58:17,569
we don't have an easy way to bug it so

1800
01:58:15,260 --> 01:58:18,050
we'll do that sorry next weekend hope

1801
01:58:17,569 --> 01:58:20,719
see you back

1802
01:58:18,050 --> 01:58:23,170
that till then take these everybody I'll

1803
01:58:20,719 --> 01:58:23,170
see you any minute

