1
00:00:00,770 --> 00:00:04,650
okay hello everyone and welcome to

2
00:00:03,240 --> 00:00:07,080
handmade Hero the show we code a

3
00:00:04,650 --> 00:00:10,230
complete game live on Twitch no engine

4
00:00:07,080 --> 00:00:12,089
no libraries it's the complete set of

5
00:00:10,230 --> 00:00:14,070
codes that's necessary to run a game and

6
00:00:12,089 --> 00:00:16,469
we do this for both educational purposes

7
00:00:14,070 --> 00:00:18,778
and also just because hey it's kind of

8
00:00:16,469 --> 00:00:19,589
fun to do this kind of code if you're

9
00:00:18,778 --> 00:00:22,109
the type of person that likes

10
00:00:19,589 --> 00:00:23,518
programming oftentimes it's kind of fun

11
00:00:22,109 --> 00:00:25,050
to get down into the guts of things

12
00:00:23,518 --> 00:00:26,339
because it can be a lot more rewarding

13
00:00:25,050 --> 00:00:27,689
and a lot more interesting to kind of

14
00:00:26,339 --> 00:00:29,789
see how things work and also kind of

15
00:00:27,689 --> 00:00:32,549
tinker with them right now we're doing

16
00:00:29,789 --> 00:00:35,039
some work on we just started yesterday

17
00:00:32,549 --> 00:00:36,209
on multi-threading our application and

18
00:00:35,039 --> 00:00:37,738
the reason that we're doing

19
00:00:36,210 --> 00:00:39,539
multi-threading we covered yesterday

20
00:00:37,738 --> 00:00:42,750
basically the problem with processors

21
00:00:39,539 --> 00:00:46,558
these days is they are out of places to

22
00:00:42,750 --> 00:00:48,899
add speed in terms of clock rate that is

23
00:00:46,558 --> 00:00:51,769
just they hit a kind of a thermodynamic

24
00:00:48,899 --> 00:00:55,469
wall somewhere around the four gigahertz

25
00:00:51,770 --> 00:00:58,469
range and so now a lot of the speed that

26
00:00:55,469 --> 00:01:00,590
you get from modern processors comes in

27
00:00:58,469 --> 00:01:02,879
the form of other things such as wide

28
00:01:00,590 --> 00:01:05,308
registers like Cindy which we did

29
00:01:02,878 --> 00:01:06,478
operations for a couple weeks back and

30
00:01:05,308 --> 00:01:09,629
things like what we're doing now which

31
00:01:06,478 --> 00:01:11,489
is multi-core where you can run several

32
00:01:09,629 --> 00:01:13,199
different streams of execution in

33
00:01:11,489 --> 00:01:15,449
parallel at the same time and leverage

34
00:01:13,200 --> 00:01:17,969
that to make your application go faster

35
00:01:15,450 --> 00:01:19,680
so what we're doing is we're showing how

36
00:01:17,969 --> 00:01:21,450
to multi thread some of the stuff in the

37
00:01:19,680 --> 00:01:22,740
renderer and yesterday I gave an

38
00:01:21,450 --> 00:01:23,969
overview of what multi-threading was if

39
00:01:22,739 --> 00:01:26,030
you missed that please check it out

40
00:01:23,969 --> 00:01:27,780
because it contains all the fundamental

41
00:01:26,030 --> 00:01:29,728
things that we'll be referring to

42
00:01:27,780 --> 00:01:31,109
throughout the week as I show different

43
00:01:29,728 --> 00:01:32,429
things and we also at the end of the day

44
00:01:31,109 --> 00:01:35,549
yesterday showed how to create a thread

45
00:01:32,430 --> 00:01:37,290
in win32 so now we need to do today is

46
00:01:35,549 --> 00:01:39,540
talk about how we will actually use

47
00:01:37,290 --> 00:01:41,909
those threads to do something useful for

48
00:01:39,540 --> 00:01:43,290
us and in order to do that obviously we

49
00:01:41,909 --> 00:01:45,840
need to start talking about how threads

50
00:01:43,290 --> 00:01:47,189
communicate with each other and how they

51
00:01:45,840 --> 00:01:48,359
know what work to do and that sort of

52
00:01:47,188 --> 00:01:50,309
thing so we're gonna do another

53
00:01:48,359 --> 00:01:53,489
blackboard session today possibly not as

54
00:01:50,310 --> 00:01:55,049
long as a previous one but another

55
00:01:53,489 --> 00:01:57,509
blackboard session today that talks

56
00:01:55,049 --> 00:01:58,860
about the sorts of stuff we need to do

57
00:01:57,509 --> 00:02:01,649
in order for threads to work together

58
00:01:58,859 --> 00:02:03,239
and then again we'll pop back over win32

59
00:02:01,649 --> 00:02:05,790
and show how we could do some of those

60
00:02:03,239 --> 00:02:08,758
things in win32 and that should set us

61
00:02:05,790 --> 00:02:10,679
up for at least by tomorrow actually

62
00:02:08,758 --> 00:02:12,628
having the threads do some real work for

63
00:02:10,679 --> 00:02:13,280
us maybe we'll get to that today but I

64
00:02:12,628 --> 00:02:14,659
don't know sometime

65
00:02:13,280 --> 00:02:16,879
the Blackbird sessions take a while to

66
00:02:14,659 --> 00:02:18,650
really thoroughly explain things so you

67
00:02:16,879 --> 00:02:21,349
know that that tends to eat up a lot of

68
00:02:18,650 --> 00:02:25,010
time but anyway so here we are on day

69
00:02:21,349 --> 00:02:28,310
123 so let me go ahead and and give a

70
00:02:25,009 --> 00:02:29,568
little bit of a have an overview here I

71
00:02:28,310 --> 00:02:31,099
don't know why we are locked in that

72
00:02:29,568 --> 00:02:34,488
mode there we go all right now we're out

73
00:02:31,099 --> 00:02:40,789
of it so yeah all right so here we are

74
00:02:34,489 --> 00:02:49,759
on day 123 and let's talk about like

75
00:02:40,789 --> 00:02:53,500
thread synchronization and also I guess

76
00:02:49,759 --> 00:02:58,129
we might want to call it communication

77
00:02:53,500 --> 00:03:01,280
right so where we left things yesterday

78
00:02:58,129 --> 00:03:03,379
I showed how easy it was and 132 to just

79
00:03:01,280 --> 00:03:04,849
create more threads so basically we

80
00:03:03,379 --> 00:03:08,000
could create as many threads as we want

81
00:03:04,849 --> 00:03:09,680
that's really not a problem and it's

82
00:03:08,000 --> 00:03:10,759
obviously very easy for us and went

83
00:03:09,680 --> 00:03:13,099
through YouTube to create as many

84
00:03:10,759 --> 00:03:15,439
threads as there are processors in the

85
00:03:13,099 --> 00:03:16,789
system will show a little later on a

86
00:03:15,439 --> 00:03:18,139
little further down the line how to

87
00:03:16,789 --> 00:03:19,310
query the system to find out how many

88
00:03:18,139 --> 00:03:20,869
threads we should create and that sort

89
00:03:19,310 --> 00:03:22,340
of thing but obviously it's very easy

90
00:03:20,870 --> 00:03:24,650
for us to just go ahead and create these

91
00:03:22,340 --> 00:03:26,509
threats but where we left it yesterday

92
00:03:24,650 --> 00:03:28,939
it was not clear how those threads

93
00:03:26,509 --> 00:03:30,349
actually start doing useful work for us

94
00:03:28,939 --> 00:03:32,319
so we need to think about a couple

95
00:03:30,349 --> 00:03:35,030
things now the first thing that I said

96
00:03:32,319 --> 00:03:37,639
yesterday that comes into play here was

97
00:03:35,030 --> 00:03:40,009
that threads and processes are not the

98
00:03:37,639 --> 00:03:41,988
same thing right because remember we

99
00:03:40,009 --> 00:03:44,298
talked about processes and processes are

100
00:03:41,989 --> 00:03:46,849
different memory spaces so two processes

101
00:03:44,299 --> 00:03:49,969
in order to share work with each other

102
00:03:46,849 --> 00:03:51,199
have to do a lot of special things in

103
00:03:49,969 --> 00:03:53,569
order to make that happen they have to

104
00:03:51,199 --> 00:03:55,179
set up some kind of pipe between

105
00:03:53,569 --> 00:03:57,919
themselves in the operating system or

106
00:03:55,180 --> 00:03:59,359
explicitly request that the operating

107
00:03:57,919 --> 00:04:01,488
system allow them to share certain

108
00:03:59,359 --> 00:04:04,010
memory ranges so stuff has to happen in

109
00:04:01,489 --> 00:04:05,900
order for processes to see the work that

110
00:04:04,009 --> 00:04:07,719
each other does or to get the data that

111
00:04:05,900 --> 00:04:10,519
each other produce that sort of thing

112
00:04:07,719 --> 00:04:13,310
but threads are not processes threads

113
00:04:10,519 --> 00:04:15,590
inside a single process all actually run

114
00:04:13,310 --> 00:04:17,089
in the same memory space so what that

115
00:04:15,590 --> 00:04:19,340
means and we showed a little bit of that

116
00:04:17,089 --> 00:04:22,009
yesterday actually but what that means

117
00:04:19,339 --> 00:04:24,319
is that our threads can all work on the

118
00:04:22,009 --> 00:04:26,300
same data right so basically if we have

119
00:04:24,319 --> 00:04:26,959
a bunch of data here like in the case of

120
00:04:26,300 --> 00:04:29,930
the renderer

121
00:04:26,959 --> 00:04:31,819
right we had our push buffer which is

122
00:04:29,930 --> 00:04:34,370
what we need to operate on and then we

123
00:04:31,819 --> 00:04:37,099
had like our frame buffer you know right

124
00:04:34,370 --> 00:04:39,860
and then we had you know our bitmaps and

125
00:04:37,100 --> 00:04:41,449
stuff and what that means is these are

126
00:04:39,860 --> 00:04:43,189
all laid out already and they are

127
00:04:41,449 --> 00:04:45,710
accessible by our main thread when we

128
00:04:43,189 --> 00:04:48,439
create new threads those threads can

129
00:04:45,709 --> 00:04:50,388
actually all read these just fine and so

130
00:04:48,439 --> 00:04:52,160
if we just pass in remember when we

131
00:04:50,389 --> 00:04:53,629
created the thread we were able to share

132
00:04:52,160 --> 00:04:55,880
global variables with it and we're also

133
00:04:53,629 --> 00:04:57,409
able to pass in one pointer and 132 it's

134
00:04:55,879 --> 00:04:59,389
startup so there's actually plenty of

135
00:04:57,410 --> 00:05:00,650
ways we can we can sort of tell the

136
00:04:59,389 --> 00:05:04,069
thread hey here's where the data lives

137
00:05:00,649 --> 00:05:05,538
right so it's actually pretty easy for

138
00:05:04,069 --> 00:05:07,639
this thread to get access to all of the

139
00:05:05,538 --> 00:05:10,038
information that it needs so we won't

140
00:05:07,639 --> 00:05:13,220
have to do any real work to make sure

141
00:05:10,038 --> 00:05:14,750
that each individual thread can see the

142
00:05:13,220 --> 00:05:17,449
things that it needs to see because

143
00:05:14,750 --> 00:05:19,819
unlike processes threads always have

144
00:05:17,449 --> 00:05:23,840
access to all of the memory that's in

145
00:05:19,819 --> 00:05:26,120
our process so that's not a problem but

146
00:05:23,839 --> 00:05:29,859
there are two problems that do have to

147
00:05:26,120 --> 00:05:36,288
do with threads okay so number one is

148
00:05:29,860 --> 00:05:37,939
knowing what work to do okay because

149
00:05:36,288 --> 00:05:41,598
once we have multiple threads of

150
00:05:37,939 --> 00:05:43,250
execution right it's a nebulous problem

151
00:05:41,598 --> 00:05:45,800
how do they know what they should be

152
00:05:43,250 --> 00:05:47,449
doing right implicit in all of the work

153
00:05:45,800 --> 00:05:48,560
that we've done in handmade hero so far

154
00:05:47,449 --> 00:05:50,419
and if you've never written

155
00:05:48,560 --> 00:05:52,519
multi-threaded code implicit in all of

156
00:05:50,418 --> 00:05:53,719
the code that you've ever written is the

157
00:05:52,519 --> 00:05:55,969
fact that you've never had to think

158
00:05:53,720 --> 00:05:57,259
about who was actually executing the

159
00:05:55,970 --> 00:05:59,960
code that she wrote right

160
00:05:57,259 --> 00:06:02,180
you just wrote all the code line by line

161
00:05:59,959 --> 00:06:04,279
and assumed that we executed in order by

162
00:06:02,180 --> 00:06:06,560
one person right by one core that would

163
00:06:04,279 --> 00:06:08,689
come along and executed in order but

164
00:06:06,560 --> 00:06:10,728
once we have multiple threads that's not

165
00:06:08,689 --> 00:06:13,038
the case anymore all of the code that we

166
00:06:10,728 --> 00:06:15,079
have written could be executed by anyone

167
00:06:13,038 --> 00:06:16,848
at any time and we have to start

168
00:06:15,079 --> 00:06:19,399
thinking about how we would like to tell

169
00:06:16,848 --> 00:06:21,348
each thread where it should do its work

170
00:06:19,399 --> 00:06:23,029
like what is what are the routines they

171
00:06:21,348 --> 00:06:25,430
should run what are the data they should

172
00:06:23,029 --> 00:06:28,250
run them on we need some way of actually

173
00:06:25,430 --> 00:06:30,319
making that work literally physically in

174
00:06:28,250 --> 00:06:31,430
the code so that these threads know what

175
00:06:30,319 --> 00:06:33,500
to do right

176
00:06:31,430 --> 00:06:35,478
and again it's implicit in everything

177
00:06:33,500 --> 00:06:37,310
we've done so far because our code just

178
00:06:35,478 --> 00:06:39,408
started at one place and we just kept

179
00:06:37,310 --> 00:06:40,399
calling functions right and that's how

180
00:06:39,408 --> 00:06:43,009
all the work done

181
00:06:40,399 --> 00:06:45,409
but now we have multiple people

182
00:06:43,009 --> 00:06:46,610
essentially multiple of these places in

183
00:06:45,410 --> 00:06:49,490
the code that are running at any given

184
00:06:46,610 --> 00:06:52,639
time we have to fundamentally rethink

185
00:06:49,490 --> 00:06:54,530
our model right for how code works

186
00:06:52,639 --> 00:06:56,120
because now there isn't just one big

187
00:06:54,529 --> 00:06:57,978
long chain of people calling functions

188
00:06:56,120 --> 00:06:59,870
and returning and doing loops there's

189
00:06:57,978 --> 00:07:02,000
multiple of these and we have to have

190
00:06:59,870 --> 00:07:06,379
some model for knowing who should do

191
00:07:02,000 --> 00:07:10,310
what work when okay so that's one thing

192
00:07:06,379 --> 00:07:13,788
and number two we need to make sure that

193
00:07:10,310 --> 00:07:16,610
people are sort of how should I say this

194
00:07:13,788 --> 00:07:19,250
it's it's it's synchronization but it's

195
00:07:16,610 --> 00:07:20,720
also the concept that different people

196
00:07:19,250 --> 00:07:24,560
are doing different work at different

197
00:07:20,720 --> 00:07:30,740
times so we need a notion of when work

198
00:07:24,560 --> 00:07:31,639
is done right or visible because there's

199
00:07:30,740 --> 00:07:33,978
a problem that I'm going to talk about

200
00:07:31,639 --> 00:07:35,269
in detail now that happens with

201
00:07:33,978 --> 00:07:36,288
multi-threading that you'd simply don't

202
00:07:35,269 --> 00:07:37,639
have to think about when you're doing

203
00:07:36,288 --> 00:07:40,129
single threading and it's very important

204
00:07:37,639 --> 00:07:41,389
okay so I'm gonna expand on this because

205
00:07:40,129 --> 00:07:43,519
number one is pretty I think

206
00:07:41,389 --> 00:07:45,800
self-explanatory what I said it's just a

207
00:07:43,519 --> 00:07:47,000
logistical problem and so we can look at

208
00:07:45,800 --> 00:07:48,259
how we solved that a little bit later

209
00:07:47,000 --> 00:07:50,269
but hopefully you understand what the

210
00:07:48,259 --> 00:07:51,740
problem is the problem is all the code

211
00:07:50,269 --> 00:07:53,930
we've written so far is just about us

212
00:07:51,740 --> 00:07:55,189
calling functions that's not going to

213
00:07:53,930 --> 00:07:56,689
cut it when we have multiple threads we

214
00:07:55,189 --> 00:07:58,069
need ways of distributing work out to

215
00:07:56,689 --> 00:08:00,110
these other threads so obviously the

216
00:07:58,069 --> 00:08:02,240
easy problem to understand maybe not

217
00:08:00,110 --> 00:08:04,250
super easy necessarily to solve but you

218
00:08:02,240 --> 00:08:05,509
know it's clear number two is a little

219
00:08:04,250 --> 00:08:07,220
harder to understand so now I want to

220
00:08:05,509 --> 00:08:10,399
talk about what that is all right

221
00:08:07,220 --> 00:08:12,380
so currently the way that we do stuff in

222
00:08:10,399 --> 00:08:15,529
our code implicit is we'll do stuff like

223
00:08:12,379 --> 00:08:19,089
function a we'll call it then we'll do

224
00:08:15,529 --> 00:08:21,348
function B right and we'll call that an

225
00:08:19,089 --> 00:08:24,138
implicit in this is that this will

226
00:08:21,348 --> 00:08:26,959
happen before this so anything in our

227
00:08:24,139 --> 00:08:28,460
code that had an order dependency the

228
00:08:26,959 --> 00:08:30,649
only thing we ever have thought about

229
00:08:28,459 --> 00:08:32,569
before is what we just put it before the

230
00:08:30,649 --> 00:08:35,240
thing that it's that depends on it right

231
00:08:32,570 --> 00:08:36,770
if function B needs to use the results

232
00:08:35,240 --> 00:08:38,389
of function a we know we just need to

233
00:08:36,769 --> 00:08:43,069
call function a before we call function

234
00:08:38,389 --> 00:08:45,559
B done right but once we start talking

235
00:08:43,070 --> 00:08:48,320
about multi-threading we start noting to

236
00:08:45,559 --> 00:08:51,849
ask the question what if we want these

237
00:08:48,320 --> 00:08:54,200
to happen on separate threads right and

238
00:08:51,850 --> 00:08:55,909
more specifically just again

239
00:08:54,200 --> 00:08:58,220
an example of why this might be the case

240
00:08:55,909 --> 00:09:01,429
let's say we had something that actually

241
00:08:58,220 --> 00:09:04,460
looked more like this right let's say

242
00:09:01,429 --> 00:09:06,799
that we had you know multiple different

243
00:09:04,460 --> 00:09:09,680
ways we wanted to invoke function a

244
00:09:06,799 --> 00:09:11,629
right and then at the end of them all we

245
00:09:09,679 --> 00:09:13,459
have function B which takes all of these

246
00:09:11,629 --> 00:09:15,710
in right all of the things that these

247
00:09:13,460 --> 00:09:17,690
guys did they all wire into here

248
00:09:15,710 --> 00:09:20,840
eventually right so this is the results

249
00:09:17,690 --> 00:09:24,350
of it this a 0 a 1 a 2 the results of

250
00:09:20,840 --> 00:09:27,710
all these right whatever they are all

251
00:09:24,350 --> 00:09:29,180
get wired in here now if each one of

252
00:09:27,710 --> 00:09:30,560
these functions is very expensive let's

253
00:09:29,179 --> 00:09:33,259
say function a takes you know a

254
00:09:30,559 --> 00:09:35,089
millisecond to compute yeah so we may

255
00:09:33,259 --> 00:09:37,639
look at this and go oh you know what we

256
00:09:35,090 --> 00:09:39,940
want to do right we would like to be

257
00:09:37,639 --> 00:09:43,220
able to have all of these things run

258
00:09:39,940 --> 00:09:45,350
concurrently so I'll put a thread you

259
00:09:43,220 --> 00:09:47,300
know thread zero will do the first time

260
00:09:45,350 --> 00:09:50,300
thread one will do the second time

261
00:09:47,299 --> 00:09:52,219
thread two will do the third time and

262
00:09:50,299 --> 00:09:53,839
then some other thread and we don't care

263
00:09:52,220 --> 00:09:55,519
that is maybe it's one of these guys or

264
00:09:53,840 --> 00:09:56,930
maybe it's a fourth thread even we don't

265
00:09:55,519 --> 00:10:00,559
care really right

266
00:09:56,929 --> 00:10:02,089
we'll run function B ok so we assume

267
00:10:00,559 --> 00:10:04,189
that we have some solution to this

268
00:10:02,090 --> 00:10:05,660
problem right we've already solved it we

269
00:10:04,190 --> 00:10:07,720
know how we're gonna dispatch these

270
00:10:05,659 --> 00:10:10,189
things they get dispatched and whatever

271
00:10:07,720 --> 00:10:12,490
there's another problem again the Coasta

272
00:10:10,190 --> 00:10:15,400
related which is that we can't actually

273
00:10:12,490 --> 00:10:18,740
whoever's gonna run this function B

274
00:10:15,399 --> 00:10:20,929
cannot actually run until all of these

275
00:10:18,740 --> 00:10:23,600
other things have been completed right

276
00:10:20,929 --> 00:10:25,279
until all until we know that all of

277
00:10:23,600 --> 00:10:27,409
these have been completed we can't run

278
00:10:25,279 --> 00:10:30,319
this one which means that we have this

279
00:10:27,409 --> 00:10:32,719
other problem when we do multi-threading

280
00:10:30,320 --> 00:10:35,600
which is that threads that need to use

281
00:10:32,720 --> 00:10:37,430
the work of other threads had better

282
00:10:35,600 --> 00:10:41,360
have a way of knowing that those other

283
00:10:37,429 --> 00:10:42,859
threads have finished right so these are

284
00:10:41,360 --> 00:10:45,110
the two things that we kind of need to

285
00:10:42,860 --> 00:10:47,870
keep in mind as we expand our threat our

286
00:10:45,110 --> 00:10:49,700
code to be thread aware and to work with

287
00:10:47,870 --> 00:10:51,289
threads this is what we will start to be

288
00:10:49,700 --> 00:10:53,240
working on we are starting in a very

289
00:10:51,289 --> 00:10:55,159
easy place which is the renderer which

290
00:10:53,240 --> 00:10:56,899
is a very easy thing to multi multi

291
00:10:55,159 --> 00:10:59,389
thread because we're just going to do it

292
00:10:56,899 --> 00:11:00,769
in sort of buckets so we won't have to

293
00:10:59,389 --> 00:11:02,240
confront some of the harder problems of

294
00:11:00,769 --> 00:11:04,309
multi-threading that you know might

295
00:11:02,240 --> 00:11:07,129
occur if you're working with a less

296
00:11:04,309 --> 00:11:07,919
partition about problem let's say but we

297
00:11:07,129 --> 00:11:10,230
will still have

298
00:11:07,919 --> 00:11:12,120
do the basic work of doing these two

299
00:11:10,230 --> 00:11:16,050
things and so we'll show how to sort of

300
00:11:12,120 --> 00:11:20,610
work through that now the problem here

301
00:11:16,049 --> 00:11:21,689
becomes a little more complicated or I

302
00:11:20,610 --> 00:11:23,550
shouldn't say the problem becomes more

303
00:11:21,690 --> 00:11:26,010
complicated what I should say is the way

304
00:11:23,549 --> 00:11:27,929
that you have to solve this problem is a

305
00:11:26,009 --> 00:11:30,120
little bit complicated the reason it's a

306
00:11:27,929 --> 00:11:31,649
little bit complicated is because when

307
00:11:30,120 --> 00:11:34,860
you are dealing with a multi processing

308
00:11:31,649 --> 00:11:37,528
system you no longer even have a

309
00:11:34,860 --> 00:11:39,778
guarantee about certain basic things

310
00:11:37,528 --> 00:11:41,970
that you might have taken for granted so

311
00:11:39,778 --> 00:11:43,980
what I want to do is talk about this

312
00:11:41,970 --> 00:11:46,079
sort of fundamental model of how you

313
00:11:43,980 --> 00:11:48,300
have to think about how threads work and

314
00:11:46,078 --> 00:11:49,708
how they see each other's results with

315
00:11:48,299 --> 00:11:52,379
an eye towards how we're going to do

316
00:11:49,708 --> 00:11:53,879
this right so let's take this very

317
00:11:52,379 --> 00:11:56,009
simple example well I've got some

318
00:11:53,879 --> 00:11:57,600
functions a a and a you know and I've

319
00:11:56,009 --> 00:11:59,039
got one should be here and we want to

320
00:11:57,600 --> 00:12:00,540
start actually like thinking about how

321
00:11:59,039 --> 00:12:02,189
we would actually implement something if

322
00:12:00,539 --> 00:12:03,809
this is what's going on because really

323
00:12:02,190 --> 00:12:05,490
if you think about it this is actually a

324
00:12:03,809 --> 00:12:08,250
lot like what's going on if you imagine

325
00:12:05,490 --> 00:12:11,850
that function a was like render one tile

326
00:12:08,250 --> 00:12:15,000
right and function B was blit to the

327
00:12:11,850 --> 00:12:16,320
screen then this is basically what the

328
00:12:15,000 --> 00:12:18,240
first sort of thing we do have to do

329
00:12:16,320 --> 00:12:19,860
with our render right we need some way

330
00:12:18,240 --> 00:12:21,209
of a bunch of threads coming in and

331
00:12:19,860 --> 00:12:22,769
realizing that each of them should be

332
00:12:21,208 --> 00:12:24,509
rendering some different tile on the

333
00:12:22,769 --> 00:12:26,519
screen and then at the end we need a

334
00:12:24,509 --> 00:12:28,948
final thread to go oh okay everyone's

335
00:12:26,519 --> 00:12:30,929
done now I can like sort of commit that

336
00:12:28,948 --> 00:12:32,278
change out say like okay let's let's get

337
00:12:30,929 --> 00:12:37,649
that out to the screen we know all the

338
00:12:32,278 --> 00:12:39,899
tiles are there okay so what I want to

339
00:12:37,649 --> 00:12:42,570
talk about here we'll talk about sort of

340
00:12:39,899 --> 00:12:44,100
the first part of the problem right so

341
00:12:42,570 --> 00:12:47,670
let's say I have all of these threads

342
00:12:44,100 --> 00:12:50,220
okay I've got all these threads and I

343
00:12:47,669 --> 00:12:53,549
don't care for a moment about melting my

344
00:12:50,220 --> 00:12:56,730
CPU I just don't care I'm gonna just

345
00:12:53,549 --> 00:12:59,129
full-on spin up all of the cores of the

346
00:12:56,730 --> 00:13:00,839
CPU and they are going to just do what's

347
00:12:59,129 --> 00:13:03,720
called a busy wait they're gonna sit in

348
00:13:00,839 --> 00:13:05,790
a while loop just waiting for there to

349
00:13:03,720 --> 00:13:08,430
be work for them to do okay so we're not

350
00:13:05,789 --> 00:13:09,809
trying to be polite citizens here we

351
00:13:08,429 --> 00:13:11,189
will literally just go ahead and melt

352
00:13:09,809 --> 00:13:13,349
the CPU it will never go into a

353
00:13:11,190 --> 00:13:16,860
low-power state it'll all be crazy town

354
00:13:13,350 --> 00:13:18,690
okay so suppose I was to write something

355
00:13:16,860 --> 00:13:20,579
like a for I loop right that just goes

356
00:13:18,690 --> 00:13:21,769
forever so my threads you know you saw

357
00:13:20,578 --> 00:13:22,938
how we create a thread gesture

358
00:13:21,769 --> 00:13:25,100
they just start Xtreme like everybody

359
00:13:22,938 --> 00:13:27,889
else so we have some threads here right

360
00:13:25,100 --> 00:13:30,350
and what we all we want to do is be able

361
00:13:27,889 --> 00:13:32,448
to basically have something occur right

362
00:13:30,350 --> 00:13:35,600
which basically says if there is work

363
00:13:32,448 --> 00:13:39,919
for me to do right if work exists for me

364
00:13:35,600 --> 00:13:42,678
to do right then I do it that's it and

365
00:13:39,919 --> 00:13:44,419
we just if there's work to do I do it if

366
00:13:42,678 --> 00:13:45,649
there isn't I just go back at the top of

367
00:13:44,419 --> 00:13:47,328
the loop and look again to see if

368
00:13:45,649 --> 00:13:49,308
there's work right so it's just that a

369
00:13:47,328 --> 00:13:53,058
full-on busy wait loop and we want to

370
00:13:49,308 --> 00:13:57,338
see if work exists right well in a

371
00:13:53,058 --> 00:14:00,230
thread right inside a given thread

372
00:13:57,339 --> 00:14:02,179
having multiple threads is no different

373
00:14:00,230 --> 00:14:03,920
than having a single thread in terms of

374
00:14:02,178 --> 00:14:06,980
the capabilities that that thread has

375
00:14:03,919 --> 00:14:09,438
our thread is just executing x64 code

376
00:14:06,980 --> 00:14:11,600
just like everything else in our program

377
00:14:09,438 --> 00:14:12,948
was executing xst for code back when we

378
00:14:11,600 --> 00:14:15,079
were only thinking about programming one

379
00:14:12,948 --> 00:14:17,599
thread and so what that means is this

380
00:14:15,078 --> 00:14:21,588
operation here where I have to say does

381
00:14:17,600 --> 00:14:23,569
work exist right that operation has to

382
00:14:21,589 --> 00:14:26,089
essentially be done in the exact same

383
00:14:23,568 --> 00:14:28,519
manner as anything else might be done it

384
00:14:26,089 --> 00:14:30,079
has to be done by looking at memory

385
00:14:28,519 --> 00:14:31,938
pulling things into registers doing

386
00:14:30,078 --> 00:14:34,099
operations on those registers it has to

387
00:14:31,938 --> 00:14:36,198
be done in a way that a CPU can just do

388
00:14:34,100 --> 00:14:37,369
it doesn't magically get any different

389
00:14:36,198 --> 00:14:38,419
because there are threads we have to

390
00:14:37,369 --> 00:14:42,499
construct this out of the same

391
00:14:38,419 --> 00:14:44,899
primitives and what I want to show here

392
00:14:42,499 --> 00:14:48,439
is that that is actually a relatively

393
00:14:44,899 --> 00:14:51,198
tricky problem okay the reason it is a

394
00:14:48,438 --> 00:14:53,778
very tricky problem is let's say that

395
00:14:51,198 --> 00:14:56,479
our solution to this is just to make a

396
00:14:53,778 --> 00:14:58,249
pointer right out in space somewhere so

397
00:14:56,480 --> 00:15:00,889
we've got some pointer here it is and

398
00:14:58,249 --> 00:15:03,528
that pointer we will set to zero if

399
00:15:00,889 --> 00:15:05,808
there is nothing to do or we will set it

400
00:15:03,528 --> 00:15:08,480
if there is something to do to point off

401
00:15:05,808 --> 00:15:11,058
to like the render buffer right so the

402
00:15:08,480 --> 00:15:14,569
buffer is out here so all we want to do

403
00:15:11,058 --> 00:15:16,249
is we want a thread to come along and

404
00:15:14,568 --> 00:15:17,628
see if there is work there if there is

405
00:15:16,249 --> 00:15:19,369
we want it to pick it up and we want it

406
00:15:17,629 --> 00:15:20,839
to do it okay that's all we're trying to

407
00:15:19,369 --> 00:15:22,100
do very very straightforward doesn't

408
00:15:20,839 --> 00:15:23,839
even totally solve the problem we were

409
00:15:22,100 --> 00:15:27,259
talking about all we're trying to do is

410
00:15:23,839 --> 00:15:29,480
just that right so if we were to write

411
00:15:27,259 --> 00:15:34,490
that right this code would look

412
00:15:29,480 --> 00:15:36,009
something you know like if pointer right

413
00:15:34,490 --> 00:15:40,850
Renne

414
00:15:36,009 --> 00:15:42,919
Poynter okay that would work just fine

415
00:15:40,850 --> 00:15:44,659
for a single thread it would loop

416
00:15:42,919 --> 00:15:45,740
through I would just sit there and as

417
00:15:44,659 --> 00:15:47,389
soon as we stuck some work in that

418
00:15:45,740 --> 00:15:50,089
pointer it would come along and it would

419
00:15:47,389 --> 00:15:52,009
render what was in the pointer right now

420
00:15:50,089 --> 00:15:54,199
the problem is if we had more than one

421
00:15:52,009 --> 00:15:57,230
thread who were sitting in this loop

422
00:15:54,198 --> 00:15:58,609
right well multiple of those people

423
00:15:57,230 --> 00:16:00,170
would come they would see that the

424
00:15:58,610 --> 00:16:01,249
pointer was pointing to the work and

425
00:16:00,169 --> 00:16:03,229
they would start doing it which would

426
00:16:01,249 --> 00:16:06,199
mean that more than one thread would

427
00:16:03,230 --> 00:16:07,369
start doing the same work right and we

428
00:16:06,198 --> 00:16:09,049
don't want that to happen because if

429
00:16:07,369 --> 00:16:10,550
we're gonna make a good system for

430
00:16:09,049 --> 00:16:12,349
distributing work here one of the basic

431
00:16:10,549 --> 00:16:14,568
things we have to do is make sure that

432
00:16:12,350 --> 00:16:16,278
no two threads do exactly the same work

433
00:16:14,568 --> 00:16:17,419
and like you know waste all of that time

434
00:16:16,278 --> 00:16:20,149
right we want to make sure that threads

435
00:16:17,419 --> 00:16:22,669
are always doing new work so what we

436
00:16:20,149 --> 00:16:24,318
might think of is say well okay if we

437
00:16:22,669 --> 00:16:25,878
see that there is a pointer pointing to

438
00:16:24,318 --> 00:16:28,009
some work then what we'll do is right

439
00:16:25,879 --> 00:16:31,459
away after we see that will set that

440
00:16:28,009 --> 00:16:33,110
pointer equal to zero so that now no

441
00:16:31,458 --> 00:16:35,149
other thread will see the work that

442
00:16:33,110 --> 00:16:36,829
we're going to do right so we'll

443
00:16:35,149 --> 00:16:38,119
essentially do you know we'll save the

444
00:16:36,828 --> 00:16:40,998
point of ourselves so we'll kind of do

445
00:16:38,119 --> 00:16:43,999
like work equals pointer right pointer

446
00:16:40,999 --> 00:16:45,649
equals zero and then we'll call you know

447
00:16:43,999 --> 00:16:47,360
render work so we'll clear out that

448
00:16:45,649 --> 00:16:49,159
pointer as soon as we see it all right

449
00:16:47,360 --> 00:16:50,329
and this is the part that I want to talk

450
00:16:49,159 --> 00:16:51,708
about right here because while that

451
00:16:50,328 --> 00:16:53,539
seems like it would work it won't

452
00:16:51,708 --> 00:16:54,678
actually work and the reason that it

453
00:16:53,539 --> 00:16:56,748
won't actually work is because

454
00:16:54,678 --> 00:16:59,539
multi-threading introduces like I said a

455
00:16:56,749 --> 00:17:00,920
whole nother set of subtleties that you

456
00:16:59,539 --> 00:17:02,539
don't know let me think about when you

457
00:17:00,919 --> 00:17:04,548
think about single threaded code and the

458
00:17:02,539 --> 00:17:06,798
reason is because if you look at this

459
00:17:04,548 --> 00:17:08,298
from the perspective of two separate

460
00:17:06,798 --> 00:17:10,519
threads that might be sitting in this

461
00:17:08,298 --> 00:17:14,048
loop waiting to do whatever work comes

462
00:17:10,519 --> 00:17:17,778
there they would look like this right

463
00:17:14,048 --> 00:17:20,269
both of them have an if pointer both of

464
00:17:17,778 --> 00:17:22,818
them try to save the pointer work equals

465
00:17:20,269 --> 00:17:25,818
pointer both of them try to set it to

466
00:17:22,818 --> 00:17:30,068
zero and both of them try to do render

467
00:17:25,818 --> 00:17:30,068
right like so

468
00:17:30,220 --> 00:17:38,410
okay so the problem here and I'll just

469
00:17:37,029 --> 00:17:41,440
put little braces around there as you

470
00:17:38,410 --> 00:17:43,540
can see it so the problem here is that

471
00:17:41,440 --> 00:17:45,910
if one or the other of these blocks

472
00:17:43,539 --> 00:17:48,250
happens to execute is SEC essentially

473
00:17:45,910 --> 00:17:51,100
all by itself we don't have a problem if

474
00:17:48,250 --> 00:17:52,869
this thread here says if pointer working

475
00:17:51,099 --> 00:17:55,869
this pointer pointer equals zero and

476
00:17:52,869 --> 00:17:59,979
manages to get here before this thread

477
00:17:55,869 --> 00:18:01,599
ever does anything we're fine but what

478
00:17:59,980 --> 00:18:03,279
could easily happen because these two

479
00:18:01,599 --> 00:18:04,869
cores are both running at the exact same

480
00:18:03,279 --> 00:18:06,819
time and could be executing any of their

481
00:18:04,869 --> 00:18:09,699
instructions at the exact same time is

482
00:18:06,819 --> 00:18:12,399
they both could look and say if pointer

483
00:18:09,700 --> 00:18:13,750
right and before this guy has cleared

484
00:18:12,400 --> 00:18:16,000
out the pointer to zero

485
00:18:13,750 --> 00:18:18,519
this guy actually advances inside the if

486
00:18:16,000 --> 00:18:20,140
right and he goes ahead and takes a copy

487
00:18:18,519 --> 00:18:21,910
and they both overwrite the pointer with

488
00:18:20,140 --> 00:18:26,050
zero but it's too late now and they both

489
00:18:21,910 --> 00:18:28,720
go and do the work right so essentially

490
00:18:26,049 --> 00:18:30,609
what I hope you will sort of appreciate

491
00:18:28,720 --> 00:18:33,970
when I when I'm what I'm illustrating

492
00:18:30,609 --> 00:18:35,679
here is that actually given the

493
00:18:33,970 --> 00:18:40,299
primitives that we've worked with so far

494
00:18:35,680 --> 00:18:42,789
in C C actually doesn't really give you

495
00:18:40,299 --> 00:18:44,740
any way to even create something where

496
00:18:42,789 --> 00:18:48,190
you can guarantee that two threads won't

497
00:18:44,740 --> 00:18:49,690
do the same work right in fact I don't

498
00:18:48,190 --> 00:18:50,830
even think there is a way to do it in

499
00:18:49,690 --> 00:18:53,160
any in C at all

500
00:18:50,829 --> 00:18:56,970
without going to like C++ or some fuzz

501
00:18:53,160 --> 00:18:56,970
C++ 11 or something

502
00:18:57,329 --> 00:19:03,099
but as you know multi-threaded code does

503
00:19:01,599 --> 00:19:04,779
actually work and people ship it all the

504
00:19:03,099 --> 00:19:08,409
time so how is that happening the reason

505
00:19:04,779 --> 00:19:11,379
is because x64 actually provides a

506
00:19:08,410 --> 00:19:12,790
number of instructions that help with

507
00:19:11,380 --> 00:19:15,550
this right so there are basically

508
00:19:12,789 --> 00:19:19,089
special instructions that are designed

509
00:19:15,549 --> 00:19:22,569
to facilitate the fact that you need to

510
00:19:19,089 --> 00:19:24,490
write code that looks this way in order

511
00:19:22,569 --> 00:19:26,740
to make multi-threading code function

512
00:19:24,490 --> 00:19:29,970
properly and the way that these special

513
00:19:26,740 --> 00:19:32,890
instructions work is they typically put

514
00:19:29,970 --> 00:19:35,799
operations into a context where you can

515
00:19:32,890 --> 00:19:39,460
guarantee that only one thread will see

516
00:19:35,799 --> 00:19:41,349
a particular result and no two threads

517
00:19:39,460 --> 00:19:42,759
will actually see that same result so

518
00:19:41,349 --> 00:19:43,659
I'm going to give you a very simple

519
00:19:42,759 --> 00:19:47,799
example

520
00:19:43,660 --> 00:19:51,850
of that right now there is a function

521
00:19:47,799 --> 00:19:54,069
that the x64 there is a instruction that

522
00:19:51,849 --> 00:19:57,939
ecstasy 4 can do for example which is a

523
00:19:54,069 --> 00:19:59,649
lot increment it's called a locked

524
00:19:57,940 --> 00:20:01,779
increment you can access it by using

525
00:19:59,650 --> 00:20:03,280
interlocked increment in win32 which we

526
00:20:01,779 --> 00:20:04,420
may or may not use we can probably won't

527
00:20:03,279 --> 00:20:07,690
actually use that one why was gonna give

528
00:20:04,420 --> 00:20:10,570
that example and what a lot increment is

529
00:20:07,690 --> 00:20:12,850
is let's suppose that I wanted to well

530
00:20:10,569 --> 00:20:14,169
actually no what let me wash it out why

531
00:20:12,849 --> 00:20:15,459
would I introduce that one when I have

532
00:20:14,170 --> 00:20:16,900
the one that I'm that would actually

533
00:20:15,460 --> 00:20:18,789
solve the exact problem that I wrote so

534
00:20:16,900 --> 00:20:23,890
let's call let's do this one locked

535
00:20:18,789 --> 00:20:27,819
exchange okay what a locked exchange

536
00:20:23,890 --> 00:20:30,880
does is it says I would like to replace

537
00:20:27,819 --> 00:20:34,509
a location in memory with a new value

538
00:20:30,880 --> 00:20:37,030
and I would like to ensure that nobody

539
00:20:34,509 --> 00:20:40,690
else will be able to perform the same

540
00:20:37,029 --> 00:20:42,609
operation at the same time ok so what it

541
00:20:40,690 --> 00:20:43,539
does if we were to change this here

542
00:20:42,609 --> 00:20:45,309
right because you could look at what

543
00:20:43,539 --> 00:20:48,250
we're doing here what we're trying to do

544
00:20:45,309 --> 00:20:50,529
is exchange whatever is in pointer with

545
00:20:48,250 --> 00:20:52,660
zero we're trying to put a 0 in and get

546
00:20:50,529 --> 00:20:54,399
whatever was in there out and we want to

547
00:20:52,660 --> 00:20:56,470
make sure that we are the only person

548
00:20:54,400 --> 00:20:58,780
who can do that right we want to make

549
00:20:56,470 --> 00:21:00,279
sure that when we do it nobody else will

550
00:20:58,779 --> 00:21:02,139
be observing the value that pointer

551
00:21:00,279 --> 00:21:04,329
actually is at that time before we stuff

552
00:21:02,140 --> 00:21:07,420
the zero in there right that's what we

553
00:21:04,329 --> 00:21:08,859
want to make sure happens so what the

554
00:21:07,420 --> 00:21:12,400
locked exchange does is it says all

555
00:21:08,859 --> 00:21:15,309
right I can do a lot exchange right and

556
00:21:12,400 --> 00:21:17,830
I can say the location that I'm trying

557
00:21:15,309 --> 00:21:19,210
to exchange is pointer and the new value

558
00:21:17,829 --> 00:21:22,240
that I would like to put in there is

559
00:21:19,210 --> 00:21:25,150
zero this locked exchange will provide

560
00:21:22,240 --> 00:21:27,759
me the result which is whatever was in

561
00:21:25,150 --> 00:21:30,940
the location pointed to by pointer right

562
00:21:27,759 --> 00:21:32,980
at the time and it will put a 0 in there

563
00:21:30,940 --> 00:21:35,920
before anyone else can observe that

564
00:21:32,980 --> 00:21:39,490
result so if some other thread at the

565
00:21:35,920 --> 00:21:41,950
exact same time he's also executing

566
00:21:39,490 --> 00:21:43,299
locked exchange right so if we have

567
00:21:41,950 --> 00:21:45,340
another thread that's also doing a lot

568
00:21:43,299 --> 00:21:48,039
to strange over here it will guarantee

569
00:21:45,339 --> 00:21:50,439
that one or the other of them will

570
00:21:48,039 --> 00:21:53,049
actually get pointer what was in pointer

571
00:21:50,440 --> 00:21:55,390
and replace it with a zero before the

572
00:21:53,049 --> 00:21:58,000
other one gets the value so if the other

573
00:21:55,390 --> 00:22:02,020
one will get that zero swap right

574
00:21:58,000 --> 00:22:04,450
that makes sense so what we can do is we

575
00:22:02,019 --> 00:22:06,579
can rewrite this routine to make that we

576
00:22:04,450 --> 00:22:08,110
can rewrite it to make it work right by

577
00:22:06,579 --> 00:22:10,539
saying okay instead of doing it that way

578
00:22:08,109 --> 00:22:12,219
what we'll do is we'll say all right we

579
00:22:10,539 --> 00:22:14,139
you know we have whatever the work

580
00:22:12,220 --> 00:22:15,910
pointer is up here we've got work right

581
00:22:14,140 --> 00:22:21,370
and what we'll do is we'll say work

582
00:22:15,910 --> 00:22:25,680
equals interlock exchange write the

583
00:22:21,369 --> 00:22:29,859
pointer and zero we can then say if work

584
00:22:25,680 --> 00:22:32,620
happens to actually be valid then do the

585
00:22:29,859 --> 00:22:36,099
work right and what this will guarantee

586
00:22:32,619 --> 00:22:39,129
for us is that if work comes back with a

587
00:22:36,099 --> 00:22:42,399
valid value as long as everybody else

588
00:22:39,130 --> 00:22:45,010
who was ever trying to observe that

589
00:22:42,400 --> 00:22:46,450
value didn't just cold read it because

590
00:22:45,009 --> 00:22:47,769
other people could cold read it they

591
00:22:46,450 --> 00:22:49,390
could do star work they could just look

592
00:22:47,769 --> 00:22:51,220
at the pointer and they'd see what was

593
00:22:49,390 --> 00:22:53,920
ever is in there but as long as everyone

594
00:22:51,220 --> 00:22:56,529
else is also only doing it with an

595
00:22:53,920 --> 00:22:58,750
interlock exchange we know that only one

596
00:22:56,529 --> 00:23:00,910
person will ever be able to actually get

597
00:22:58,750 --> 00:23:02,079
back the value because as soon as they

598
00:23:00,910 --> 00:23:06,279
get back the value it will get

599
00:23:02,079 --> 00:23:08,409
overwritten with that zero right so that

600
00:23:06,279 --> 00:23:10,660
is how multi-threading code works

601
00:23:08,410 --> 00:23:12,400
essentially in a nutshell the

602
00:23:10,660 --> 00:23:15,490
synchronization primitives how they work

603
00:23:12,400 --> 00:23:18,940
they are all based around using special

604
00:23:15,490 --> 00:23:22,480
versions of functions that are that are

605
00:23:18,940 --> 00:23:24,490
coded in X 64 to ensure that no matter

606
00:23:22,480 --> 00:23:25,870
how many cores happen to be banging on

607
00:23:24,490 --> 00:23:28,930
this piece of memory at any given time

608
00:23:25,869 --> 00:23:31,959
they will all serialize themselves into

609
00:23:28,930 --> 00:23:33,850
a line properly and retire in a

610
00:23:31,960 --> 00:23:36,490
particular order that guarantees that no

611
00:23:33,849 --> 00:23:38,740
two people will be able to do that same

612
00:23:36,490 --> 00:23:39,670
operation so that's very good and like I

613
00:23:38,740 --> 00:23:42,460
said there's other ones like ink

614
00:23:39,670 --> 00:23:44,380
interlocked increment which will take a

615
00:23:42,460 --> 00:23:46,000
location increment whatever the values

616
00:23:44,380 --> 00:23:47,680
in it and return you whatever the old

617
00:23:46,000 --> 00:23:49,269
value was it will guarantee that if

618
00:23:47,680 --> 00:23:51,610
everyone is doing interlocked increments

619
00:23:49,269 --> 00:23:54,309
you will only ever see each person will

620
00:23:51,609 --> 00:23:56,169
see a unique value in the series right

621
00:23:54,309 --> 00:23:57,579
so you can kind of produce like an

622
00:23:56,170 --> 00:24:02,410
escalating series of integers for

623
00:23:57,579 --> 00:24:08,740
example now the granddaddy of all of

624
00:24:02,410 --> 00:24:10,390
these the big poppa right is a function

625
00:24:08,740 --> 00:24:11,680
called interlocked well an instruction

626
00:24:10,390 --> 00:24:14,710
interlocked compare

627
00:24:11,680 --> 00:24:17,110
exchange and I want to mention this one

628
00:24:14,710 --> 00:24:19,740
because this is probably the one if you

629
00:24:17,109 --> 00:24:22,750
only learned ever how to program one

630
00:24:19,740 --> 00:24:24,579
thread synchronization instruction in

631
00:24:22,750 --> 00:24:27,869
x64 this is probably the one you would

632
00:24:24,579 --> 00:24:31,089
want to use because it is crazy powerful

633
00:24:27,869 --> 00:24:33,159
interlocked compare exchange allows you

634
00:24:31,089 --> 00:24:34,839
to do essentially the same operation as

635
00:24:33,160 --> 00:24:38,350
an interlocked exchange but it allows

636
00:24:34,839 --> 00:24:41,919
you to do it predicated so in most

637
00:24:38,349 --> 00:24:44,379
circumstances where you don't super care

638
00:24:41,920 --> 00:24:47,650
about the absolute maximum performance

639
00:24:44,380 --> 00:24:49,030
of the interlocked point right because

640
00:24:47,650 --> 00:24:50,560
these instructions keep in mind these

641
00:24:49,029 --> 00:24:52,599
instructions are on the order of like

642
00:24:50,559 --> 00:24:53,769
100 cycles or something I don't even

643
00:24:52,599 --> 00:24:57,250
know what they are nowadays but they're

644
00:24:53,769 --> 00:24:58,960
not many right but if you were doing

645
00:24:57,250 --> 00:25:00,400
tons and tons and tons and tons of these

646
00:24:58,960 --> 00:25:01,630
right we're not probably gonna be doing

647
00:25:00,400 --> 00:25:03,220
tons and tons of these you know we'll be

648
00:25:01,630 --> 00:25:05,020
doing 50 of these or something or a

649
00:25:03,220 --> 00:25:07,990
hundred of these right we won't be doing

650
00:25:05,019 --> 00:25:10,180
that many so we don't super care how

651
00:25:07,990 --> 00:25:13,509
fast the interchange happens to be

652
00:25:10,180 --> 00:25:15,400
because our goal is to do very few we

653
00:25:13,509 --> 00:25:17,230
want to basically partition the work

654
00:25:15,400 --> 00:25:19,600
into very large chunks so we're not

655
00:25:17,230 --> 00:25:21,309
spending a ton of time figuring out

656
00:25:19,599 --> 00:25:22,990
who's supposed to do the work right

657
00:25:21,309 --> 00:25:25,659
that's not really where we want to be

658
00:25:22,990 --> 00:25:27,309
but if you are in that situation then

659
00:25:25,660 --> 00:25:29,650
maybe interlock compare exchange is not

660
00:25:27,309 --> 00:25:32,379
for you but in circumstances where you

661
00:25:29,650 --> 00:25:34,920
have a reasonable a number of cycles to

662
00:25:32,380 --> 00:25:37,180
spend doing your thread synchronization

663
00:25:34,920 --> 00:25:38,500
interlock compare exchange is kind of

664
00:25:37,180 --> 00:25:41,200
amazing because it lets you write

665
00:25:38,500 --> 00:25:44,769
basically any old janky crappy code that

666
00:25:41,200 --> 00:25:46,450
you want and still have it work I know

667
00:25:44,769 --> 00:25:50,200
that sounds a bit strange but it kind of

668
00:25:46,450 --> 00:25:52,240
is actually true why is it true well the

669
00:25:50,200 --> 00:25:53,559
reason it's true is because if you take

670
00:25:52,240 --> 00:25:56,289
a look at how this code was working

671
00:25:53,559 --> 00:25:57,639
right you can sort of start to think

672
00:25:56,289 --> 00:25:58,960
about I know it's a little bit hard for

673
00:25:57,640 --> 00:25:59,860
you to conceive because you haven't done

674
00:25:58,960 --> 00:26:01,120
a lot of monkey friend coding before

675
00:25:59,859 --> 00:26:02,619
you're not really thinking through all

676
00:26:01,119 --> 00:26:04,239
of the possibilities here and you know

677
00:26:02,619 --> 00:26:07,029
whatever but you can sort of kind of

678
00:26:04,240 --> 00:26:08,559
extrapolate that well ok if this is the

679
00:26:07,029 --> 00:26:11,289
operation that I had to work with

680
00:26:08,559 --> 00:26:13,509
interlock exchange well basically I have

681
00:26:11,289 --> 00:26:16,149
to phrase every last little thing that I

682
00:26:13,509 --> 00:26:18,160
might want to do as a single swap right

683
00:26:16,150 --> 00:26:20,110
I have to kind of make this single swap

684
00:26:18,160 --> 00:26:21,940
do all of the work so I have to prepare

685
00:26:20,109 --> 00:26:24,159
things so that it all just spits through

686
00:26:21,940 --> 00:26:25,420
there so it's kind of hard for me to

687
00:26:24,160 --> 00:26:27,130
figure out like oh if this 3

688
00:26:25,420 --> 00:26:29,529
wants to go look for things and decide

689
00:26:27,130 --> 00:26:31,720
what it wants to do and then maybe do it

690
00:26:29,529 --> 00:26:33,639
how do I boil all that down to like the

691
00:26:31,720 --> 00:26:35,890
single swap it's a little annoying you

692
00:26:33,640 --> 00:26:37,240
know I don't know maybe like complicated

693
00:26:35,890 --> 00:26:38,170
work distribution schemes how am I going

694
00:26:37,240 --> 00:26:39,700
to write them etcetera there's like

695
00:26:38,170 --> 00:26:40,990
there's a lot of thinking that might go

696
00:26:39,700 --> 00:26:43,769
into that and you might have to do a lot

697
00:26:40,990 --> 00:26:45,970
of cleverness to make this happen right

698
00:26:43,769 --> 00:26:48,700
interlocked compare exchange is not that

699
00:26:45,970 --> 00:26:51,819
interlocked compare exchange is a thing

700
00:26:48,700 --> 00:26:53,740
that lets you be super piggy you can put

701
00:26:51,819 --> 00:26:55,059
on the pig hat for example I'll put on

702
00:26:53,740 --> 00:26:56,319
the pig hat while we're even talking

703
00:26:55,059 --> 00:26:58,960
about it because it basically enables

704
00:26:56,319 --> 00:27:01,059
some pretty piggy behavior and and

705
00:26:58,960 --> 00:27:04,630
doesn't really make it into too much of

706
00:27:01,059 --> 00:27:06,369
a problem right so how does this work

707
00:27:04,630 --> 00:27:07,600
well what this does is it's essentially

708
00:27:06,369 --> 00:27:09,099
the exact same thing I just said it's

709
00:27:07,599 --> 00:27:11,409
the same as the interlocked exchange but

710
00:27:09,099 --> 00:27:15,099
what it does is it takes a value that

711
00:27:11,410 --> 00:27:17,769
you are expecting to see in pointer and

712
00:27:15,099 --> 00:27:22,230
if that is not the value that is already

713
00:27:17,769 --> 00:27:24,609
there it does not do the exchange right

714
00:27:22,230 --> 00:27:26,620
so basically what happens is with

715
00:27:24,609 --> 00:27:28,359
interlocked compare exchange you can

716
00:27:26,619 --> 00:27:30,579
essentially write code the same way

717
00:27:28,359 --> 00:27:33,939
you've always been writing it you can do

718
00:27:30,579 --> 00:27:36,429
something like okay you know if there's

719
00:27:33,940 --> 00:27:38,529
work there no thread synchronization is

720
00:27:36,430 --> 00:27:43,810
gonna look and see if there's work scan

721
00:27:38,529 --> 00:27:46,720
like through the work you know figure

722
00:27:43,809 --> 00:27:49,899
out the ones I want to do you know

723
00:27:46,720 --> 00:27:51,579
rearrange some things in my own store

724
00:27:49,900 --> 00:27:53,440
you know whatever do a bunch of stuff

725
00:27:51,579 --> 00:27:53,919
here and then when you get to the very

726
00:27:53,440 --> 00:27:56,970
end

727
00:27:53,920 --> 00:28:00,880
right you can then go okay if

728
00:27:56,970 --> 00:28:02,589
interlocked compare exchange right I'm

729
00:28:00,880 --> 00:28:04,270
gonna call that ice interlocked compare

730
00:28:02,589 --> 00:28:06,490
exchange to this cool acronym if

731
00:28:04,269 --> 00:28:09,009
interlocked compare exchange do the

732
00:28:06,490 --> 00:28:12,700
actual swap to move out the work right

733
00:28:09,009 --> 00:28:16,420
and do some stuff and what this does is

734
00:28:12,700 --> 00:28:19,559
allows you to go oh if some other thread

735
00:28:16,420 --> 00:28:22,060
actually got there before I did and

736
00:28:19,559 --> 00:28:25,059
replace the value that used to be in

737
00:28:22,059 --> 00:28:27,759
work with some other thing now I'll know

738
00:28:25,059 --> 00:28:30,220
because this won't succeed the could

739
00:28:27,759 --> 00:28:32,859
exchange won't go through and I can

740
00:28:30,220 --> 00:28:35,259
actually just not do any of this stuff I

741
00:28:32,859 --> 00:28:36,969
was planning to do right and let this

742
00:28:35,259 --> 00:28:38,619
come back around right because usually

743
00:28:36,970 --> 00:28:39,309
like I said these are in loops waiting

744
00:28:38,619 --> 00:28:41,259
for work

745
00:28:39,309 --> 00:28:44,529
let this come back around and try the

746
00:28:41,259 --> 00:28:46,089
whole thing again right so what you can

747
00:28:44,529 --> 00:28:47,470
actually do with interlock compare

748
00:28:46,089 --> 00:28:48,789
exchange if you don't mind being a

749
00:28:47,470 --> 00:28:52,150
little bit picking is you can actually

750
00:28:48,789 --> 00:28:56,440
write some pretty crappy thread code and

751
00:28:52,150 --> 00:28:58,509
it actually can work thread safe just by

752
00:28:56,440 --> 00:29:00,640
keeping it arranged relatively smartly

753
00:28:58,509 --> 00:29:02,230
with interlock compare exchange whereas

754
00:29:00,640 --> 00:29:04,330
if you are using one of the other

755
00:29:02,230 --> 00:29:06,160
primitives that is not the case you

756
00:29:04,329 --> 00:29:09,429
pretty much always have to be sly fox

757
00:29:06,160 --> 00:29:11,279
and sly fox it around right because if

758
00:29:09,430 --> 00:29:13,870
you don't have it worked out just right

759
00:29:11,279 --> 00:29:17,440
if there's any work that you were doing

760
00:29:13,869 --> 00:29:19,719
at all that that is sort of counting on

761
00:29:17,440 --> 00:29:21,460
being done outside the interlock

762
00:29:19,720 --> 00:29:23,350
exchange but not while the other thread

763
00:29:21,460 --> 00:29:25,630
sees it you will end up with some kind

764
00:29:23,349 --> 00:29:27,250
of the bad synchronization problem or

765
00:29:25,630 --> 00:29:30,090
crash or anything else who knows

766
00:29:27,250 --> 00:29:32,200
depending on what the what the

767
00:29:30,089 --> 00:29:38,649
particular circumstance actually is

768
00:29:32,200 --> 00:29:39,730
right so that that is basically that is

769
00:29:38,650 --> 00:29:41,140
basically that for thread

770
00:29:39,730 --> 00:29:43,420
synchronization so what we are going to

771
00:29:41,140 --> 00:29:45,550
do is we are gonna try to use these to

772
00:29:43,420 --> 00:29:48,310
build some way of us having our multiple

773
00:29:45,549 --> 00:29:51,190
threads to do the work that they need to

774
00:29:48,309 --> 00:29:54,129
do and there's only one of the thing

775
00:29:51,190 --> 00:29:55,420
I've got I want to reserve a fair bit of

776
00:29:54,130 --> 00:29:56,410
time to go back there so I'll spend

777
00:29:55,420 --> 00:29:57,820
another five minutes now and just

778
00:29:56,410 --> 00:29:59,710
briefly mentioned what other things

779
00:29:57,819 --> 00:30:06,369
since we're on that topic and that is

780
00:29:59,710 --> 00:30:09,160
simply sort of about reads and writes in

781
00:30:06,369 --> 00:30:11,829
a multi-threaded context I want to just

782
00:30:09,160 --> 00:30:13,330
sort of preload this we probably will

783
00:30:11,829 --> 00:30:16,389
talk a little bit more detail about it

784
00:30:13,329 --> 00:30:19,449
further down the line but what you have

785
00:30:16,390 --> 00:30:21,940
to understand with threading is that

786
00:30:19,450 --> 00:30:23,200
once this sort of concept is on the

787
00:30:21,940 --> 00:30:25,210
table and we and you know I've done it

788
00:30:23,200 --> 00:30:26,590
once for you here but we're gonna talk

789
00:30:25,210 --> 00:30:29,710
about this a lot and you have to be

790
00:30:26,589 --> 00:30:31,569
aware of where of it once we you know

791
00:30:29,710 --> 00:30:32,680
our multi-threaded this is always the

792
00:30:31,569 --> 00:30:34,299
way you have to think about things you

793
00:30:32,680 --> 00:30:36,100
always have to think about things away I

794
00:30:34,299 --> 00:30:38,289
was thinking about it here where any

795
00:30:36,099 --> 00:30:41,019
thread could be at any point in its

796
00:30:38,289 --> 00:30:42,730
execution at any time right so you

797
00:30:41,019 --> 00:30:45,099
always have to think about what might

798
00:30:42,730 --> 00:30:46,930
happen if two threads are trying to do

799
00:30:45,099 --> 00:30:50,199
something with the same piece of memory

800
00:30:46,930 --> 00:30:53,140
at the same time right and what this

801
00:30:50,200 --> 00:30:55,360
means is that reads to stuff this

802
00:30:53,140 --> 00:30:57,130
constants are always fine if I have a

803
00:30:55,359 --> 00:30:59,259
bunch of threads that are doing work and

804
00:30:57,130 --> 00:31:02,350
they want to read from some database of

805
00:30:59,259 --> 00:31:05,339
values that never changes then I don't

806
00:31:02,349 --> 00:31:09,399
have to worry a read just always works

807
00:31:05,339 --> 00:31:11,980
rights on the other hand right anytime

808
00:31:09,400 --> 00:31:14,769
two threads might write to the same

809
00:31:11,980 --> 00:31:16,360
place you have a problem because if two

810
00:31:14,769 --> 00:31:18,460
threads might write to the same place

811
00:31:16,359 --> 00:31:19,750
you have to ask yourself which one of

812
00:31:18,460 --> 00:31:21,100
the results did you actually want to

813
00:31:19,750 --> 00:31:23,349
happen now if they're both gonna write

814
00:31:21,099 --> 00:31:24,730
the same result that's not a problem hey

815
00:31:23,349 --> 00:31:26,379
two threads could overwrite the same

816
00:31:24,730 --> 00:31:28,360
value with a new value that happens to

817
00:31:26,380 --> 00:31:30,880
be the same that's not a problem right

818
00:31:28,359 --> 00:31:32,289
but once threads are writing to the same

819
00:31:30,880 --> 00:31:33,550
place you have a problem and you have a

820
00:31:32,289 --> 00:31:34,659
synchronization problem so that's

821
00:31:33,549 --> 00:31:35,919
something you need to keep aware of

822
00:31:34,660 --> 00:31:37,630
because obviously you know whoever

823
00:31:35,920 --> 00:31:41,140
writes last will be the value that gets

824
00:31:37,630 --> 00:31:42,340
stored there that's an issue right but

825
00:31:41,140 --> 00:31:47,259
it gets even a little more complicated

826
00:31:42,339 --> 00:31:49,329
than that and that is because once you

827
00:31:47,259 --> 00:31:51,579
start talking about threads that are

828
00:31:49,329 --> 00:31:53,919
writing to places where other threads

829
00:31:51,579 --> 00:31:57,039
might also write even if they don't

830
00:31:53,920 --> 00:31:59,560
really read from them you may actually

831
00:31:57,039 --> 00:32:01,059
have secret places where they do in fact

832
00:31:59,559 --> 00:32:02,950
read and the reason for that is because

833
00:32:01,059 --> 00:32:06,190
the processor actually thinks about

834
00:32:02,950 --> 00:32:07,630
things in terms of cache lines okay now

835
00:32:06,190 --> 00:32:08,920
we haven't talked very much about cache

836
00:32:07,630 --> 00:32:10,600
lines in the past because we haven't

837
00:32:08,920 --> 00:32:12,490
really had to we've talked a lot about

838
00:32:10,599 --> 00:32:15,219
the cache and we say things like the l1

839
00:32:12,490 --> 00:32:16,690
cache and the l2 cache right and we

840
00:32:15,220 --> 00:32:18,579
talked about these being things where

841
00:32:16,690 --> 00:32:19,210
you know you go out to the cache and go

842
00:32:18,579 --> 00:32:21,970
out to the memory

843
00:32:19,210 --> 00:32:23,950
well the cache as it turns out is the

844
00:32:21,970 --> 00:32:26,319
primary place where synchronization

845
00:32:23,950 --> 00:32:28,750
happens in the processor meaning when

846
00:32:26,319 --> 00:32:31,779
the processor cores think about

847
00:32:28,750 --> 00:32:33,400
coordinating things themselves like for

848
00:32:31,779 --> 00:32:34,930
example these locked increments and

849
00:32:33,400 --> 00:32:36,880
stuff right interlock and pair exchange

850
00:32:34,930 --> 00:32:39,600
and those sorts of things even though

851
00:32:36,880 --> 00:32:44,530
those things appear to be operating on

852
00:32:39,599 --> 00:32:46,179
64 32 or 64 bit values really processors

853
00:32:44,529 --> 00:32:47,470
when they're thinking the cores when

854
00:32:46,180 --> 00:32:49,960
they're thinking about this are thinking

855
00:32:47,470 --> 00:32:54,009
about them in terms of who owns what

856
00:32:49,960 --> 00:32:56,289
cache lines right and a cache line is

857
00:32:54,009 --> 00:32:58,539
some size that's much larger than 64

858
00:32:56,289 --> 00:33:00,279
bits right and it depends on the size of

859
00:32:58,539 --> 00:33:02,079
the processor how big the cache line is

860
00:33:00,279 --> 00:33:04,149
but you know it could be something like

861
00:33:02,079 --> 00:33:05,980
128 bytes or tunafish these bytes or

862
00:33:04,150 --> 00:33:07,030
find 12 bytes right there's some number

863
00:33:05,980 --> 00:33:10,029
of bytes that come

864
00:33:07,029 --> 00:33:11,950
a cache line and what happens during

865
00:33:10,029 --> 00:33:13,990
these reads and writes is that

866
00:33:11,950 --> 00:33:16,480
processors try to take ownership of

867
00:33:13,990 --> 00:33:18,609
lines of particular segments of memory

868
00:33:16,480 --> 00:33:20,259
in terms of a cache line boundary which

869
00:33:18,609 --> 00:33:24,369
they then operate on and then commit

870
00:33:20,259 --> 00:33:27,789
right and what this means is that you in

871
00:33:24,369 --> 00:33:29,739
you know in your code may think oh you

872
00:33:27,789 --> 00:33:32,139
know here's what's happening in my code

873
00:33:29,740 --> 00:33:34,750
I've got this struct and there's you

874
00:33:32,140 --> 00:33:37,630
know an int here and in a and there's an

875
00:33:34,750 --> 00:33:40,059
int B you know in the code and you know

876
00:33:37,630 --> 00:33:42,100
oh one of my guys is just it's just

877
00:33:40,059 --> 00:33:43,839
reading and writing from this a and

878
00:33:42,099 --> 00:33:45,849
another one of these guys is reading and

879
00:33:43,839 --> 00:33:47,589
writing from B so there's no problem

880
00:33:45,849 --> 00:33:48,789
it's fine I don't need to do any

881
00:33:47,589 --> 00:33:50,319
interlocking I don't need to do any

882
00:33:48,789 --> 00:33:52,389
synchronization I can just use standard

883
00:33:50,319 --> 00:33:56,409
old C and read and write from a and B

884
00:33:52,390 --> 00:33:57,850
all I want that may not actually be true

885
00:33:56,410 --> 00:33:59,320
because depending on the processor and

886
00:33:57,849 --> 00:34:02,669
depending on the situation in blah blah

887
00:33:59,319 --> 00:34:05,049
blah blah blah you may be in a situation

888
00:34:02,670 --> 00:34:08,200
where since you have not told the

889
00:34:05,049 --> 00:34:09,969
processor about this these may be on the

890
00:34:08,199 --> 00:34:13,388
same cache line which means you could

891
00:34:09,969 --> 00:34:15,759
get crazy stuff happening such as you

892
00:34:13,389 --> 00:34:19,000
know here's core one here's core two

893
00:34:15,760 --> 00:34:21,250
right core one goes oh I'm supposed to

894
00:34:19,000 --> 00:34:23,079
read and write from a so it loads in

895
00:34:21,250 --> 00:34:27,190
this cache line into its cache and

896
00:34:23,079 --> 00:34:28,929
here's a and here's B right and we'll

897
00:34:27,190 --> 00:34:30,700
say that these are a 0 B 0 then the

898
00:34:28,929 --> 00:34:33,148
state of this thing at some time and

899
00:34:30,699 --> 00:34:35,230
core to happen to be executing some code

900
00:34:33,148 --> 00:34:37,299
totally in parallel it's like oh I've

901
00:34:35,230 --> 00:34:40,418
got to read and write from B so it loads

902
00:34:37,300 --> 00:34:43,289
this into its cache right so it's got

903
00:34:40,418 --> 00:34:46,658
here's our a and here's our B right now

904
00:34:43,289 --> 00:34:49,628
they go oh you know what cool dude I

905
00:34:46,659 --> 00:34:52,090
just got a modify a so I execute a piece

906
00:34:49,628 --> 00:34:53,980
of code and I end up with a 1 so it's

907
00:34:52,090 --> 00:34:57,309
like you know this is some other version

908
00:34:53,980 --> 00:35:00,309
here I've got a 1 a 0 B 0 right and B it

909
00:34:57,309 --> 00:35:03,009
still be 0 Core 2 goes oh you know what

910
00:35:00,309 --> 00:35:06,309
cool dude I got this I'm gonna modify B

911
00:35:03,010 --> 00:35:08,350
so now it's B 1 right later on when they

912
00:35:06,309 --> 00:35:11,590
go to commit these cache lines to memory

913
00:35:08,349 --> 00:35:12,639
right again depending on the

914
00:35:11,590 --> 00:35:15,280
architecture and depending on all all

915
00:35:12,639 --> 00:35:17,230
sorts of other things they may then go

916
00:35:15,280 --> 00:35:19,060
oh okay let's just commit these guys

917
00:35:17,230 --> 00:35:20,369
back to memory they commit them back to

918
00:35:19,059 --> 00:35:22,409
memory right

919
00:35:20,369 --> 00:35:24,779
and what happens is one of these two

920
00:35:22,409 --> 00:35:26,579
cache line commits just overwrites the

921
00:35:24,780 --> 00:35:28,530
other one right or something equally

922
00:35:26,579 --> 00:35:30,449
heinous so you just end up with a 1 B 0

923
00:35:28,530 --> 00:35:34,740
or something like this or you end up

924
00:35:30,449 --> 00:35:36,149
with a 0 B 1 right so that's bad and you

925
00:35:34,739 --> 00:35:38,939
have to know you have to essentially

926
00:35:36,150 --> 00:35:42,210
know again information about your your

927
00:35:38,940 --> 00:35:43,650
particular processor whatever on x64 my

928
00:35:42,210 --> 00:35:45,240
recollection is that this is not

929
00:35:43,650 --> 00:35:47,340
something that you have to particularly

930
00:35:45,239 --> 00:35:50,459
care about right because in general I'm

931
00:35:47,340 --> 00:35:54,840
pretty sure that it guarantees that

932
00:35:50,460 --> 00:35:57,539
right always that rights are always

933
00:35:54,840 --> 00:35:59,190
visible to other processors so it as far

934
00:35:57,539 --> 00:36:00,449
as I am aware and someone on the stream

935
00:35:59,190 --> 00:36:03,480
can connect me out this time wrong as

936
00:36:00,449 --> 00:36:05,039
far as I am aware on x64 you never have

937
00:36:03,480 --> 00:36:14,579
to think about weird stuff like this

938
00:36:05,039 --> 00:36:17,360
happening right let me think about this

939
00:36:14,579 --> 00:36:17,360
before I say that

940
00:36:18,159 --> 00:36:28,119
I feel like that's correct I feel like

941
00:36:25,659 --> 00:36:30,579
that's correct we'll double-check it but

942
00:36:28,119 --> 00:36:32,019
I'm pretty sure that the way the x64

943
00:36:30,579 --> 00:36:34,690
memory coherent works

944
00:36:32,019 --> 00:36:37,719
it's that rights are always visible in a

945
00:36:34,690 --> 00:36:40,300
particular order and so you don't have

946
00:36:37,719 --> 00:36:44,379
to actually worry about that particular

947
00:36:40,300 --> 00:36:46,450
case happening I believe I could be

948
00:36:44,380 --> 00:36:48,519
wrong about that but I believe it's

949
00:36:46,449 --> 00:36:48,909
buried in the Intel system architecture

950
00:36:48,519 --> 00:36:50,199
manual

951
00:36:48,909 --> 00:36:51,940
I remember reading this very carefully

952
00:36:50,199 --> 00:36:53,949
when I first started doing both my throw

953
00:36:51,940 --> 00:36:55,720
into programming and I believe that

954
00:36:53,949 --> 00:36:57,730
unlike other processors which actually

955
00:36:55,719 --> 00:36:59,769
you have to be more careful about this

956
00:36:57,730 --> 00:37:01,869
sort of thing that Intel has a very

957
00:36:59,769 --> 00:37:04,329
strong memory ordering model that

958
00:37:01,869 --> 00:37:06,849
prevents this this actual pattern from

959
00:37:04,329 --> 00:37:08,739
ever occurring it just knows it's smart

960
00:37:06,849 --> 00:37:10,750
enough about those rights that it will

961
00:37:08,739 --> 00:37:13,089
it won't do that particular operation on

962
00:37:10,750 --> 00:37:15,670
the cache lines but again could be wrong

963
00:37:13,090 --> 00:37:17,890
about that point being you have to think

964
00:37:15,670 --> 00:37:20,590
about these sorts of things at the very

965
00:37:17,889 --> 00:37:22,529
least again even if you weren't going to

966
00:37:20,590 --> 00:37:25,930
think about them from the perspective of

967
00:37:22,530 --> 00:37:27,010
just oh you know on some processors I

968
00:37:25,929 --> 00:37:28,899
may have to think about this because

969
00:37:27,010 --> 00:37:30,160
I'll get wrong results you still want to

970
00:37:28,900 --> 00:37:32,349
think about them formant for another

971
00:37:30,159 --> 00:37:35,589
reason altogether which is that if two

972
00:37:32,349 --> 00:37:37,539
cores are starting to have contention

973
00:37:35,590 --> 00:37:39,820
for a particular piece of memory again

974
00:37:37,539 --> 00:37:41,800
that you know it's not free it's not

975
00:37:39,820 --> 00:37:43,269
like the processor internally has some

976
00:37:41,800 --> 00:37:46,780
magic way of making all these things

977
00:37:43,269 --> 00:37:48,670
work out at no cost it's still all of

978
00:37:46,780 --> 00:37:50,920
the synchronization still has to happen

979
00:37:48,670 --> 00:37:52,329
somewhere so even if you're on an

980
00:37:50,920 --> 00:37:54,849
architecture which guarantees that you

981
00:37:52,329 --> 00:37:56,860
can do stuff that will not be a problem

982
00:37:54,849 --> 00:37:59,349
as far as these kind of rights are

983
00:37:56,860 --> 00:38:01,390
concerned you may still want to be aware

984
00:37:59,349 --> 00:38:04,029
of it because you don't want to have to

985
00:38:01,389 --> 00:38:05,469
processor 2 cores constantly pounding on

986
00:38:04,030 --> 00:38:07,330
the same cache lines because that will

987
00:38:05,469 --> 00:38:08,679
create synchronization work for the

988
00:38:07,329 --> 00:38:09,909
processors where they have to constantly

989
00:38:08,679 --> 00:38:11,919
talk to each other to shuttle their

990
00:38:09,909 --> 00:38:15,730
results back and forth and that is again

991
00:38:11,920 --> 00:38:17,050
not free typically so again just want to

992
00:38:15,730 --> 00:38:20,320
bring that up there's things you have to

993
00:38:17,050 --> 00:38:22,930
think about and so if you can most of

994
00:38:20,320 --> 00:38:25,600
the time what you will want to do is you

995
00:38:22,929 --> 00:38:26,949
will want your cache lines to you want

996
00:38:25,599 --> 00:38:28,599
you want to think about things in terms

997
00:38:26,949 --> 00:38:30,879
of cache lines and you will want to try

998
00:38:28,599 --> 00:38:31,779
as hard as you can to make sure that the

999
00:38:30,880 --> 00:38:34,360
primary were

1000
00:38:31,780 --> 00:38:37,180
that your cores are doing line up along

1001
00:38:34,360 --> 00:38:38,860
separate cache line boundaries so that

1002
00:38:37,179 --> 00:38:40,989
while your two threads are executing

1003
00:38:38,860 --> 00:38:42,610
either a you're guaranteed correct

1004
00:38:40,989 --> 00:38:43,419
results on platforms where you have to

1005
00:38:42,610 --> 00:38:44,920
make sure that that's not the case

1006
00:38:43,420 --> 00:38:46,570
you're guaranteed correct results

1007
00:38:44,920 --> 00:38:48,070
without having to start using a bunch of

1008
00:38:46,570 --> 00:38:52,420
synchronization primitives like the

1009
00:38:48,070 --> 00:38:54,250
locked versions right or on an

1010
00:38:52,420 --> 00:38:55,480
architecture which gives you strong

1011
00:38:54,250 --> 00:38:56,949
memory ordering and you don't have to

1012
00:38:55,480 --> 00:38:58,420
worry about getting incorrect results

1013
00:38:56,949 --> 00:39:00,159
you still may want to do it because your

1014
00:38:58,420 --> 00:39:01,780
performance may suffer if you're sitting

1015
00:39:00,159 --> 00:39:03,190
there forcing the CPU to constantly talk

1016
00:39:01,780 --> 00:39:05,320
and say oh hey I got that cache line

1017
00:39:03,190 --> 00:39:06,909
here you go oh wait I need it back I

1018
00:39:05,320 --> 00:39:08,410
gotta update the value oh wait you need

1019
00:39:06,909 --> 00:39:11,230
back ok great and they're shuffling it

1020
00:39:08,409 --> 00:39:12,190
around all the time right not free so

1021
00:39:11,230 --> 00:39:14,199
that's something to think about there

1022
00:39:12,190 --> 00:39:15,820
we'll be talking more about this because

1023
00:39:14,199 --> 00:39:17,169
there's things like memory barriers and

1024
00:39:15,820 --> 00:39:19,900
fences and all these other sorts of

1025
00:39:17,170 --> 00:39:21,099
things that happen in terms of write

1026
00:39:19,900 --> 00:39:22,059
coherence we'll be talking about that

1027
00:39:21,099 --> 00:39:23,829
sort of stuff

1028
00:39:22,059 --> 00:39:26,799
a little bit later probably tomorrow

1029
00:39:23,829 --> 00:39:28,659
when we get to when we actually have our

1030
00:39:26,800 --> 00:39:30,370
routine fleshed out and we need to talk

1031
00:39:28,659 --> 00:39:33,429
about how to make sure that it operates

1032
00:39:30,369 --> 00:39:37,500
correctly but for now we'll we'll leave

1033
00:39:33,429 --> 00:39:37,500
that all right so let's slip back here

1034
00:39:39,360 --> 00:39:44,910
I'll take off the pig hat because I'm

1035
00:39:41,409 --> 00:39:48,609
not actually doing anything piggy right

1036
00:39:44,909 --> 00:39:50,349
and let's go ahead and man that pick out

1037
00:39:48,610 --> 00:39:52,090
is hot I sweat when that pick out is on

1038
00:39:50,349 --> 00:39:53,559
I guess that's good you don't want to be

1039
00:39:52,090 --> 00:39:56,800
piggy so I guess that's a good penalty

1040
00:39:53,559 --> 00:39:58,509
for if we ever be picking in the code to

1041
00:39:56,800 --> 00:40:01,090
try to convince us not to be so piggy

1042
00:39:58,510 --> 00:40:02,860
all the time so all right let's open

1043
00:40:01,090 --> 00:40:06,309
this up here and let's go back to our

1044
00:40:02,860 --> 00:40:07,780
thread proc we created yesterday and we

1045
00:40:06,309 --> 00:40:09,909
got about 15 minutes here so I want to

1046
00:40:07,780 --> 00:40:13,510
kind of show how to actually start doing

1047
00:40:09,909 --> 00:40:14,949
some work with the threads very basic

1048
00:40:13,510 --> 00:40:17,440
but just try to get it so you can sort

1049
00:40:14,949 --> 00:40:19,059
of see how that's working right so what

1050
00:40:17,440 --> 00:40:20,380
I'd like to do is I would like to make

1051
00:40:19,059 --> 00:40:22,809
something and we'll just make a very

1052
00:40:20,380 --> 00:40:24,820
simple toy thing right now I want to

1053
00:40:22,809 --> 00:40:27,429
make something where we can make four

1054
00:40:24,820 --> 00:40:29,590
threads that each do some work and they

1055
00:40:27,429 --> 00:40:31,839
do different work ok that's what we want

1056
00:40:29,590 --> 00:40:34,780
to do and so what I'd like to do is

1057
00:40:31,840 --> 00:40:36,460
something where for example maybe each

1058
00:40:34,780 --> 00:40:40,390
of the threads prints out a different

1059
00:40:36,460 --> 00:40:42,869
string right after the fact so for

1060
00:40:40,389 --> 00:40:45,589
example we do these create threads here

1061
00:40:42,869 --> 00:40:47,179
this this great stud stuff here

1062
00:40:45,590 --> 00:40:48,380
right now we're passing a string I want

1063
00:40:47,179 --> 00:40:49,699
to make it so I can basically make a

1064
00:40:48,380 --> 00:40:50,960
little cue where I maybe put some

1065
00:40:49,699 --> 00:40:53,419
strings in and they'll print out the

1066
00:40:50,960 --> 00:40:54,710
strings something like this right so

1067
00:40:53,420 --> 00:40:56,180
what I'm going to do is I'm going to

1068
00:40:54,710 --> 00:40:57,530
create a little thing that's like thread

1069
00:40:56,179 --> 00:40:59,569
info here or something like this just

1070
00:40:57,530 --> 00:41:01,790
temporarily we mate we probably want

1071
00:40:59,570 --> 00:41:03,230
something actually like this eventually

1072
00:41:01,789 --> 00:41:05,179
but it's going to be just a little

1073
00:41:03,230 --> 00:41:07,369
placeholder for now and all I'm going to

1074
00:41:05,179 --> 00:41:09,440
do here is I'm going to put in something

1075
00:41:07,369 --> 00:41:11,210
like a logical thread index which is

1076
00:41:09,440 --> 00:41:14,090
basically just a value which says this

1077
00:41:11,210 --> 00:41:16,400
particular thread is number 0 or number

1078
00:41:14,090 --> 00:41:18,019
1 or whatever right so that we know what

1079
00:41:16,400 --> 00:41:20,150
they are and what I'm going to do is I'm

1080
00:41:18,019 --> 00:41:23,750
going to say that that win32 thread info

1081
00:41:20,150 --> 00:41:26,240
right it's gonna get passed in here - to

1082
00:41:23,750 --> 00:41:27,829
the function as that LP parameter so I

1083
00:41:26,239 --> 00:41:29,239
can basically and I can use this in the

1084
00:41:27,829 --> 00:41:30,590
future to pass anything else that I want

1085
00:41:29,239 --> 00:41:34,639
to the start of thread so it kind of

1086
00:41:30,590 --> 00:41:36,289
knows what's going on right so then what

1087
00:41:34,639 --> 00:41:37,819
I'm going to do is I'm just going to

1088
00:41:36,289 --> 00:41:38,869
create some of these threads right I'm

1089
00:41:37,820 --> 00:41:40,700
just going to go ahead and make this a

1090
00:41:38,869 --> 00:41:42,289
loop I don't know how many threads we

1091
00:41:40,699 --> 00:41:44,329
want I guess we said there were 16 cores

1092
00:41:42,289 --> 00:41:47,029
maybe I'll create 15 of them let's say

1093
00:41:44,329 --> 00:41:49,809
so I'll do a thread index equal 0

1094
00:41:47,030 --> 00:41:52,790
thread index is less than six 15 rather

1095
00:41:49,809 --> 00:41:54,289
and then we'll do thread index plus plus

1096
00:41:52,789 --> 00:41:56,989
and then when we're in here we'll do

1097
00:41:54,289 --> 00:41:58,969
win32 thread info we'll make that info

1098
00:41:56,989 --> 00:42:00,859
struct and then what we'll do is we'll

1099
00:41:58,969 --> 00:42:05,239
set the the thread the logical thread

1100
00:42:00,860 --> 00:42:08,960
index logical thread index we'll set

1101
00:42:05,239 --> 00:42:10,039
that equal to whatever number it was in

1102
00:42:08,960 --> 00:42:12,440
our in our array so we're going to

1103
00:42:10,039 --> 00:42:14,690
create 15 threads and then what we do

1104
00:42:12,440 --> 00:42:16,760
instead of passing 0 here

1105
00:42:14,690 --> 00:42:18,889
I'm sorry so tossing parameter which was

1106
00:42:16,760 --> 00:42:20,480
this this thread started thing we're

1107
00:42:18,889 --> 00:42:22,460
actually gonna pass an address of that

1108
00:42:20,480 --> 00:42:25,579
struct and so as you can see you know

1109
00:42:22,460 --> 00:42:28,220
oops it's no good to do that there we go

1110
00:42:25,579 --> 00:42:29,719
as you can see this will just pass

1111
00:42:28,219 --> 00:42:31,549
through to here so we can pick up that

1112
00:42:29,719 --> 00:42:35,000
thread info it's just we're just passing

1113
00:42:31,550 --> 00:42:37,850
this through to this routine right so

1114
00:42:35,000 --> 00:42:39,500
once we do that we then have a bunch of

1115
00:42:37,849 --> 00:42:42,049
these guys and for right now they're all

1116
00:42:39,500 --> 00:42:44,239
just gonna sleep right and so if I run

1117
00:42:42,050 --> 00:42:46,640
handmade hero now again nothing in

1118
00:42:44,239 --> 00:42:48,529
particular really will happen because

1119
00:42:46,639 --> 00:42:50,029
those threads will just sit there doing

1120
00:42:48,530 --> 00:42:52,670
absolutely nothing they're just sleeping

1121
00:42:50,030 --> 00:42:54,710
and our hand mate here runs as it

1122
00:42:52,670 --> 00:42:56,389
normally would would run right no big

1123
00:42:54,710 --> 00:42:58,579
deal and I and I exit but those threads

1124
00:42:56,389 --> 00:42:59,268
are being created so now what I want to

1125
00:42:58,579 --> 00:43:01,369
do is I

1126
00:42:59,268 --> 00:43:03,889
to take these threads and I want them to

1127
00:43:01,369 --> 00:43:05,298
actually look for some work to do right

1128
00:43:03,889 --> 00:43:06,949
that's what I would like them to do and

1129
00:43:05,298 --> 00:43:10,248
I want to make sure that each of them

1130
00:43:06,949 --> 00:43:11,389
gets the right work to do right so what

1131
00:43:10,248 --> 00:43:16,308
we're gonna do curious we're going to

1132
00:43:11,389 --> 00:43:18,548
have something like I guess maybe just

1133
00:43:16,309 --> 00:43:21,109
an array let's say something very simple

1134
00:43:18,548 --> 00:43:25,099
and what this array will be is it will

1135
00:43:21,108 --> 00:43:26,929
be it will be like a little mini queue

1136
00:43:25,099 --> 00:43:29,059
right it'll be like a mini queue so I'm

1137
00:43:26,929 --> 00:43:31,189
gonna do like a work queue entry thing

1138
00:43:29,059 --> 00:43:33,499
something like this and I'm going to

1139
00:43:31,188 --> 00:43:35,148
have in that work queue entry I'm going

1140
00:43:33,498 --> 00:43:38,868
to have a care pointer which is like the

1141
00:43:35,148 --> 00:43:41,088
string to print right and we can put

1142
00:43:38,869 --> 00:43:42,108
other work here that we wanted to do you

1143
00:43:41,088 --> 00:43:43,278
know anything like that

1144
00:43:42,108 --> 00:43:45,469
and then what I'm going to do is I'm

1145
00:43:43,278 --> 00:43:47,509
just gonna make this work queue entry

1146
00:43:45,469 --> 00:43:49,338
I'm going to make some number of these

1147
00:43:47,509 --> 00:43:52,130
right I'm just gonna make a bunch of

1148
00:43:49,338 --> 00:43:55,068
them I don't know how many I'll make

1149
00:43:52,130 --> 00:43:56,739
maybe I'll make 256 of them and then I'm

1150
00:43:55,068 --> 00:44:01,518
gonna have an index into them that says

1151
00:43:56,739 --> 00:44:04,519
here is the current count of them right

1152
00:44:01,518 --> 00:44:07,488
and so I'm gonna do an entry count like

1153
00:44:04,518 --> 00:44:13,038
so make sense and this is obviously a

1154
00:44:07,489 --> 00:44:18,759
you know this is obviously a value

1155
00:44:13,039 --> 00:44:22,278
because specialized zero start okay so

1156
00:44:18,759 --> 00:44:23,599
the first question is what happens if I

1157
00:44:22,278 --> 00:44:25,099
just start pushing things in here so

1158
00:44:23,599 --> 00:44:26,509
let's just write the code with no

1159
00:44:25,099 --> 00:44:30,139
thought to threaten thread

1160
00:44:26,509 --> 00:44:34,429
synchronization whatsoever and we will

1161
00:44:30,139 --> 00:44:36,108
see what happens right so first we're

1162
00:44:34,429 --> 00:44:37,818
gonna start up and inside each of these

1163
00:44:36,108 --> 00:44:40,068
threads what I want to do is I want the

1164
00:44:37,818 --> 00:44:42,168
thread to basically just go through and

1165
00:44:40,068 --> 00:44:44,088
do any work that happened to be there

1166
00:44:42,168 --> 00:44:45,648
right and so I guess what I should do

1167
00:44:44,088 --> 00:44:47,418
first is I should put push some things

1168
00:44:45,648 --> 00:44:51,130
on there so let me just do it like a

1169
00:44:47,418 --> 00:44:55,868
push string and and I'll you know put in

1170
00:44:51,130 --> 00:44:58,869
string zero right something like this

1171
00:44:55,869 --> 00:44:58,869
right

1172
00:45:00,458 --> 00:45:08,868
two three four right and what I'll do

1173
00:45:07,338 --> 00:45:10,909
here is I'm just you know again I'm just

1174
00:45:08,869 --> 00:45:12,410
going through and putting some in maybe

1175
00:45:10,909 --> 00:45:14,118
we'll do you know what I'll do ten of

1176
00:45:12,409 --> 00:45:16,578
them so there we go

1177
00:45:14,119 --> 00:45:19,939
we've got ten of those guys so we've got

1178
00:45:16,579 --> 00:45:20,989
ten strings in there and now what I want

1179
00:45:19,938 --> 00:45:22,458
to do is I want to make a little

1180
00:45:20,989 --> 00:45:24,528
function I want to implement this push

1181
00:45:22,458 --> 00:45:26,208
string so what I want to do is make that

1182
00:45:24,528 --> 00:45:27,679
so it just goes ahead and adds one of

1183
00:45:26,208 --> 00:45:29,328
these into these entries right so I'll

1184
00:45:27,679 --> 00:45:33,198
just go ahead and say we've got internal

1185
00:45:29,329 --> 00:45:37,459
void right forget you know I had a value

1186
00:45:33,199 --> 00:45:48,139
for this right just global right yeah

1187
00:45:37,458 --> 00:45:53,989
okay good mmm maybe not platform what is

1188
00:45:48,139 --> 00:45:55,098
global global variable oops okay I don't

1189
00:45:53,989 --> 00:45:56,719
like to use where it's static because it

1190
00:45:55,099 --> 00:46:01,338
means too many different things all

1191
00:45:56,719 --> 00:46:01,999
right so inside push string right very

1192
00:46:01,338 --> 00:46:03,650
very simple

1193
00:46:01,998 --> 00:46:06,048
it's taking some string that's gonna

1194
00:46:03,650 --> 00:46:07,369
push on here all I wanted to do is

1195
00:46:06,048 --> 00:46:09,588
basically say all right I've got a work

1196
00:46:07,369 --> 00:46:11,420
queue entry right it's gonna be whatever

1197
00:46:09,588 --> 00:46:13,278
the entries are you know entry count

1198
00:46:11,420 --> 00:46:15,739
plus plus right maybe I'll start here

1199
00:46:13,278 --> 00:46:17,719
that the entry count is less than the

1200
00:46:15,739 --> 00:46:19,670
size of this guy right so I don't want

1201
00:46:17,719 --> 00:46:20,958
it to ever overflow the array for now or

1202
00:46:19,670 --> 00:46:23,179
not the word I'm gonna push that many on

1203
00:46:20,958 --> 00:46:24,409
for this this test code but still and

1204
00:46:23,179 --> 00:46:26,599
then we're gonna have that string to

1205
00:46:24,409 --> 00:46:29,208
print is going to be equal to the string

1206
00:46:26,599 --> 00:46:32,929
that gets passed in there right so that

1207
00:46:29,208 --> 00:46:33,768
actually works now oops did that wrong

1208
00:46:32,929 --> 00:46:36,528
way there we go

1209
00:46:33,768 --> 00:46:38,149
so that actually works now and now the

1210
00:46:36,528 --> 00:46:40,309
strings will get pushed on there right

1211
00:46:38,150 --> 00:46:42,079
but we need to actually pull them off

1212
00:46:40,309 --> 00:46:44,209
and so what we need is we don't really

1213
00:46:42,079 --> 00:46:46,579
know where to pull these guys off right

1214
00:46:44,208 --> 00:46:47,899
so we kind of need we have the count of

1215
00:46:46,579 --> 00:46:50,209
entries but we don't actually know we

1216
00:46:47,900 --> 00:46:53,119
need like a second variable right which

1217
00:46:50,208 --> 00:46:55,159
is like the the last printed entry or

1218
00:46:53,119 --> 00:46:56,028
the or the next entry to print might be

1219
00:46:55,159 --> 00:46:58,518
the right thing right

1220
00:46:56,028 --> 00:47:00,798
so it's entry zero right now and

1221
00:46:58,518 --> 00:47:03,048
basically as long as this is below this

1222
00:47:00,798 --> 00:47:04,699
value we need to print out a thing right

1223
00:47:03,048 --> 00:47:06,889
so in here what we want to do is we want

1224
00:47:04,699 --> 00:47:09,650
to say okay if the next entry to print

1225
00:47:06,889 --> 00:47:11,719
is less than the entry count right then

1226
00:47:09,650 --> 00:47:13,070
we want to go ahead and end

1227
00:47:11,719 --> 00:47:17,169
print it so we want to go ahead and grab

1228
00:47:13,070 --> 00:47:20,450
it whatever it is will work queue entry

1229
00:47:17,170 --> 00:47:25,039
the entries equals the entries plus the

1230
00:47:20,449 --> 00:47:28,250
next entry print should say to print to

1231
00:47:25,039 --> 00:47:30,880
print or I should say X you know next I

1232
00:47:28,250 --> 00:47:32,690
need to do might be the better thing

1233
00:47:30,880 --> 00:47:34,760
because in case there was something I've

1234
00:47:32,690 --> 00:47:36,170
been printing in there so yeah next if

1235
00:47:34,760 --> 00:47:37,520
the next entry to do is less than the

1236
00:47:36,170 --> 00:47:39,230
total number of counts I'm going to pull

1237
00:47:37,519 --> 00:47:41,659
it off right and increment this value

1238
00:47:39,230 --> 00:47:47,019
and then I'm going to actually do the

1239
00:47:41,659 --> 00:47:50,049
output debug string for the entry write

1240
00:47:47,019 --> 00:47:52,699
print and while I'm at it

1241
00:47:50,050 --> 00:47:55,220
what I'd like to do actually I think is

1242
00:47:52,699 --> 00:47:57,559
I'd like to go ahead and actually build

1243
00:47:55,219 --> 00:47:58,699
a buffer here that actually has some

1244
00:47:57,559 --> 00:48:00,500
more information in it because I'd like

1245
00:47:58,699 --> 00:48:02,000
to know which thread actually did it so

1246
00:48:00,500 --> 00:48:04,159
I'm gonna call Windows and say why don't

1247
00:48:02,000 --> 00:48:06,710
you prepare this buffer for me right

1248
00:48:04,159 --> 00:48:09,108
which says like thread and it gives the

1249
00:48:06,710 --> 00:48:11,690
number right of the thread and then it

1250
00:48:09,108 --> 00:48:13,009
does the the string that that got output

1251
00:48:11,690 --> 00:48:14,480
right so I'm gonna actually create a

1252
00:48:13,010 --> 00:48:16,190
thing here so we have that logical

1253
00:48:14,480 --> 00:48:18,650
thread index there's the thread info

1254
00:48:16,190 --> 00:48:20,809
logical thread index right and then I've

1255
00:48:18,650 --> 00:48:22,400
got that entry screen to print it's

1256
00:48:20,809 --> 00:48:25,670
gonna form that up and then it's gonna

1257
00:48:22,400 --> 00:48:28,608
output that buffer to the debug console

1258
00:48:25,670 --> 00:48:30,920
right so there we go

1259
00:48:28,608 --> 00:48:32,000
and one thing - well I want to mention

1260
00:48:30,920 --> 00:48:32,809
that now you know it doesn't even matter

1261
00:48:32,000 --> 00:48:34,940
so there we go

1262
00:48:32,809 --> 00:48:38,000
we'll build that up logical thread index

1263
00:48:34,940 --> 00:48:39,588
oops sorry that's a pointer yeah and

1264
00:48:38,000 --> 00:48:41,119
we'll get this working right and again

1265
00:48:39,588 --> 00:48:43,299
we've done no synchronization now so

1266
00:48:41,119 --> 00:48:45,380
this code is totally not actually safe

1267
00:48:43,300 --> 00:48:47,839
but I wanted to show you the unsafe

1268
00:48:45,380 --> 00:48:49,608
version first so that you kind of get a

1269
00:48:47,838 --> 00:48:54,139
feel for where we're going with you each

1270
00:48:49,608 --> 00:48:56,750
of the changes right so off we go

1271
00:48:54,139 --> 00:48:59,150
I don't know exactly what is happening

1272
00:48:56,750 --> 00:49:05,000
there actually let's go ahead and close

1273
00:48:59,150 --> 00:49:08,780
that out so let's take a look so this is

1274
00:49:05,000 --> 00:49:14,269
pretty weird if you take a look at what

1275
00:49:08,780 --> 00:49:16,310
actually got printed there right I I

1276
00:49:14,269 --> 00:49:18,530
think I may have had a bug in there cuz

1277
00:49:16,309 --> 00:49:20,179
that's actually that's even weirder than

1278
00:49:18,530 --> 00:49:23,579
what I thought it would originally print

1279
00:49:20,179 --> 00:49:26,629
which is thread 14 printing

1280
00:49:23,579 --> 00:49:31,310
all kinds of weird things in that string

1281
00:49:26,630 --> 00:49:39,440
which should have pushed them all on

1282
00:49:31,309 --> 00:49:45,320
and I feel like that actually shouldn't

1283
00:49:39,440 --> 00:50:01,820
have printed something so odd that is

1284
00:49:45,320 --> 00:50:03,320
very strange if I do say so myself yes

1285
00:50:01,820 --> 00:50:06,970
if that is actually not what I would

1286
00:50:03,320 --> 00:50:11,990
have expected from the unsafe version I

1287
00:50:06,969 --> 00:50:13,879
would have expected if one thread

1288
00:50:11,989 --> 00:50:20,389
printed out all of the things I would

1289
00:50:13,880 --> 00:50:22,190
have expected it to Oh duh okay good I

1290
00:50:20,389 --> 00:50:24,589
thought I was going crazy there for a

1291
00:50:22,190 --> 00:50:27,320
second I forgot that I need to let these

1292
00:50:24,590 --> 00:50:28,220
guys persist so you see what was

1293
00:50:27,320 --> 00:50:30,620
happening there right

1294
00:50:28,219 --> 00:50:32,000
each of these thread infos I want these

1295
00:50:30,619 --> 00:50:34,519
thread and for us to persist so these

1296
00:50:32,000 --> 00:50:35,960
guys could use them right but what's

1297
00:50:34,519 --> 00:50:37,969
happening is I only have one on the

1298
00:50:35,960 --> 00:50:42,740
stack here right so what I actually

1299
00:50:37,969 --> 00:50:44,779
wanted I want this right which is you

1300
00:50:42,739 --> 00:50:47,209
know however many threads there going to

1301
00:50:44,780 --> 00:50:50,560
be or whatever right there's 15 I want

1302
00:50:47,210 --> 00:50:53,059
to do it this way so that each of these

1303
00:50:50,559 --> 00:50:54,559
still exists and these guys can continue

1304
00:50:53,059 --> 00:50:56,150
to reference them because otherwise they

1305
00:50:54,559 --> 00:50:59,809
just keep betting room so that's that

1306
00:50:56,150 --> 00:51:03,530
was discouraged that is just me that was

1307
00:50:59,809 --> 00:51:05,090
just just mental mental stupid dude

1308
00:51:03,530 --> 00:51:07,940
they're so we've got these thread infos

1309
00:51:05,090 --> 00:51:09,590
right so all I need to do is just make

1310
00:51:07,940 --> 00:51:12,559
sure that they all continue to persist

1311
00:51:09,590 --> 00:51:14,510
and then we're fine so no big deal but

1312
00:51:12,559 --> 00:51:15,650
that I was gonna say there's definitely

1313
00:51:14,510 --> 00:51:17,870
a bug in there somewhere because like

1314
00:51:15,650 --> 00:51:19,730
that even even though this is not the

1315
00:51:17,869 --> 00:51:20,480
safe code it should not be printing out

1316
00:51:19,730 --> 00:51:23,059
something like that

1317
00:51:20,480 --> 00:51:25,099
okay so let's let's give that one more

1318
00:51:23,059 --> 00:51:30,009
go here after we create all these

1319
00:51:25,099 --> 00:51:30,009
threads let's see

1320
00:51:31,019 --> 00:51:38,769
all right so there we go let's see what

1321
00:51:35,559 --> 00:51:40,630
we actually printed out all right so

1322
00:51:38,769 --> 00:51:42,670
here you could kind of see and in fact

1323
00:51:40,630 --> 00:51:45,430
this is this is now roughly what I would

1324
00:51:42,670 --> 00:51:48,010
have expected to see printing out you

1325
00:51:45,429 --> 00:51:49,809
can kind of see you know the results

1326
00:51:48,010 --> 00:51:53,320
that we end up getting basically thread

1327
00:51:49,809 --> 00:51:55,389
14 printed out sort of the three of

1328
00:51:53,320 --> 00:51:59,650
these guys here thread 13 printed out

1329
00:51:55,389 --> 00:52:02,409
these two thread 5 2 &amp; 0 &amp; 4 all got the

1330
00:51:59,650 --> 00:52:07,030
same string at the beginning right

1331
00:52:02,409 --> 00:52:10,750
and thread 1 got string 4 somehow right

1332
00:52:07,030 --> 00:52:11,980
so I mean you know again I have to check

1333
00:52:10,750 --> 00:52:13,929
to make sure I don't have any other bugs

1334
00:52:11,980 --> 00:52:16,480
in here but this is a totally plausible

1335
00:52:13,929 --> 00:52:19,449
thing that could have happened even if

1336
00:52:16,480 --> 00:52:22,840
there are no bugs in this code right and

1337
00:52:19,449 --> 00:52:25,869
it's totally wrong but this is what

1338
00:52:22,840 --> 00:52:28,420
happens when you don't take the proper

1339
00:52:25,869 --> 00:52:30,609
care to have your threads actually

1340
00:52:28,420 --> 00:52:34,510
synchronize and look at the proper work

1341
00:52:30,610 --> 00:52:36,340
right so what are all the things that

1342
00:52:34,510 --> 00:52:38,230
are happening here in three minutes I'm

1343
00:52:36,340 --> 00:52:41,620
going to say what they all are

1344
00:52:38,230 --> 00:52:43,240
and then tomorrow we will start actually

1345
00:52:41,619 --> 00:52:45,009
just fixing them all they're not

1346
00:52:43,239 --> 00:52:47,379
particularly hard to fix but you know

1347
00:52:45,010 --> 00:52:51,930
well we'll get started on it since we're

1348
00:52:47,380 --> 00:52:57,970
almost out of time so the first thing is

1349
00:52:51,929 --> 00:53:00,279
right here right so with our next entry

1350
00:52:57,969 --> 00:53:01,869
to do I'm going to pull that out into a

1351
00:53:00,280 --> 00:53:04,870
thing so I'm going to do like entry

1352
00:53:01,869 --> 00:53:06,609
index equals next entry to do plus plus

1353
00:53:04,869 --> 00:53:09,759
entry index right

1354
00:53:06,610 --> 00:53:16,240
okay so the first problem is this line

1355
00:53:09,760 --> 00:53:21,160
right is not interlocked right so two

1356
00:53:16,239 --> 00:53:24,069
threads could see the same value at the

1357
00:53:21,159 --> 00:53:25,779
processor level right this is what I was

1358
00:53:24,070 --> 00:53:27,700
saying before right this this thing

1359
00:53:25,780 --> 00:53:29,950
right here where I do the plus plus we

1360
00:53:27,699 --> 00:53:31,929
have not told the x64 processor that it

1361
00:53:29,949 --> 00:53:35,500
needs to worry about other people who

1362
00:53:31,929 --> 00:53:38,139
may be doing the same thing right and so

1363
00:53:35,500 --> 00:53:40,420
that is obviously going to create a

1364
00:53:38,139 --> 00:53:42,799
problem on the same line we have another

1365
00:53:40,420 --> 00:53:47,130
problem which is that the compile

1366
00:53:42,800 --> 00:53:50,870
doesn't know that this that multiple

1367
00:53:47,130 --> 00:53:55,320
threads could write this value right and

1368
00:53:50,869 --> 00:53:57,900
what that means is that even after we

1369
00:53:55,320 --> 00:54:00,420
were to take care of this right in

1370
00:53:57,900 --> 00:54:02,820
theory and this actually isn't really

1371
00:54:00,420 --> 00:54:04,320
true because it will you'll see it

1372
00:54:02,820 --> 00:54:07,830
automatically does this for us in a way

1373
00:54:04,320 --> 00:54:11,550
that will be clear in a second but if

1374
00:54:07,829 --> 00:54:14,130
the compiler is not made aware of the

1375
00:54:11,550 --> 00:54:17,070
fact that this value could be getting

1376
00:54:14,130 --> 00:54:19,470
changed by other threads it may just

1377
00:54:17,070 --> 00:54:21,990
optimize this out it will look at this

1378
00:54:19,469 --> 00:54:24,089
loop and go oh he's the only person who

1379
00:54:21,989 --> 00:54:26,609
changes you know this value or this

1380
00:54:24,090 --> 00:54:28,200
value or something so I can just hoist

1381
00:54:26,610 --> 00:54:31,170
it out or do other things with it and

1382
00:54:28,199 --> 00:54:32,730
and it's fine right and the answer is no

1383
00:54:31,170 --> 00:54:34,650
but it's not fine I need you to check

1384
00:54:32,730 --> 00:54:36,360
that value when I tell you to

1385
00:54:34,650 --> 00:54:38,610
you can't go moving it around or

1386
00:54:36,360 --> 00:54:40,110
changing what it actually does and so

1387
00:54:38,610 --> 00:54:41,460
there's a C keyword that we need to put

1388
00:54:40,110 --> 00:54:42,900
in there to make sure that it

1389
00:54:41,460 --> 00:54:51,030
understands that as well so that's

1390
00:54:42,900 --> 00:54:52,470
another thing that's problem right the

1391
00:54:51,030 --> 00:54:57,390
other problem that we have is here input

1392
00:54:52,469 --> 00:55:01,109
string so input string right this entry

1393
00:54:57,389 --> 00:55:08,400
count plus plus we've got another thing

1394
00:55:01,110 --> 00:55:11,670
here which is that these rights are not

1395
00:55:08,400 --> 00:55:13,829
in order right so if you take a look at

1396
00:55:11,670 --> 00:55:17,010
what happens here you can see what i'm

1397
00:55:13,829 --> 00:55:19,440
doing i do the entries plus the entry

1398
00:55:17,010 --> 00:55:22,470
count and then I have the string to

1399
00:55:19,440 --> 00:55:26,130
print that gets set there so first of

1400
00:55:22,469 --> 00:55:28,079
all what you may notice is as soon as

1401
00:55:26,130 --> 00:55:30,680
this value goes up right

1402
00:55:28,079 --> 00:55:33,119
as soon as entry count gets incremented

1403
00:55:30,679 --> 00:55:36,719
one of these threads could look and see

1404
00:55:33,119 --> 00:55:39,119
it right whenever this process this

1405
00:55:36,719 --> 00:55:41,309
processor core decides to put this value

1406
00:55:39,119 --> 00:55:43,230
out one of these guys will look and it

1407
00:55:41,309 --> 00:55:44,579
may see the entry count has gone up and

1408
00:55:43,230 --> 00:55:48,559
it will start doing this work and

1409
00:55:44,579 --> 00:55:51,599
loading this in if that's the case right

1410
00:55:48,559 --> 00:55:53,340
then I had better make sure that string

1411
00:55:51,599 --> 00:55:54,960
to print is already filled out because

1412
00:55:53,340 --> 00:55:56,010
otherwise it's going to go and get

1413
00:55:54,960 --> 00:55:58,679
garbage

1414
00:55:56,010 --> 00:56:00,830
right this value will be garbage because

1415
00:55:58,679 --> 00:56:03,000
it hasn't actually been written here so

1416
00:56:00,829 --> 00:56:04,440
the other thing that we need to do the

1417
00:56:03,000 --> 00:56:06,539
final thing that we need to do is make

1418
00:56:04,440 --> 00:56:09,809
sure that the rights to these things

1419
00:56:06,539 --> 00:56:12,119
happen in order so that by the time it's

1420
00:56:09,809 --> 00:56:14,480
possible for one of these threads to see

1421
00:56:12,119 --> 00:56:17,009
that entry count has been incremented

1422
00:56:14,480 --> 00:56:18,780
there is no chance that the work that

1423
00:56:17,010 --> 00:56:21,780
they are going to go and get has not

1424
00:56:18,780 --> 00:56:24,150
already been flushed out to memory right

1425
00:56:21,780 --> 00:56:26,610
I shouldn't say left out to memory that

1426
00:56:24,150 --> 00:56:28,950
that is not already properly notate

1427
00:56:26,610 --> 00:56:30,480
noted in the architecture however that

1428
00:56:28,949 --> 00:56:33,750
has to be notated in the particular

1429
00:56:30,480 --> 00:56:35,909
architecture that we're on right so just

1430
00:56:33,750 --> 00:56:38,099
in this very simple piece of code and I

1431
00:56:35,909 --> 00:56:39,269
hope this underscores just how important

1432
00:56:38,099 --> 00:56:41,880
it is to be careful when you're doing

1433
00:56:39,269 --> 00:56:43,980
multi-threading just in this very very

1434
00:56:41,880 --> 00:56:47,099
simple piece of code there are actually

1435
00:56:43,980 --> 00:56:50,360
three totally separate things that are

1436
00:56:47,099 --> 00:56:55,409
not correct that have to be rectified

1437
00:56:50,360 --> 00:56:57,809
and we will sort of talk about them in

1438
00:56:55,409 --> 00:57:05,339
order and technically there really is

1439
00:56:57,809 --> 00:57:06,750
one more and I'm gonna put in here which

1440
00:57:05,340 --> 00:57:09,600
is that the same thing that happens with

1441
00:57:06,750 --> 00:57:11,579
those rights there's the same problem

1442
00:57:09,599 --> 00:57:12,989
with the reads which is that technically

1443
00:57:11,579 --> 00:57:15,150
and especially if you're talking about

1444
00:57:12,989 --> 00:57:16,859
the compiler again certain architectures

1445
00:57:15,150 --> 00:57:18,510
guarantee strong ordering for different

1446
00:57:16,860 --> 00:57:21,030
things so this may not actually be a

1447
00:57:18,510 --> 00:57:22,650
problem on the x64 architecture at the

1448
00:57:21,030 --> 00:57:24,810
architecture level but the compiler

1449
00:57:22,650 --> 00:57:26,460
level it may be important what you have

1450
00:57:24,809 --> 00:57:28,409
to remember is the compiler is

1451
00:57:26,460 --> 00:57:31,530
technically free to hoist things like

1452
00:57:28,409 --> 00:57:33,329
these reads outside above things what we

1453
00:57:31,530 --> 00:57:35,490
want to make sure is that it never does

1454
00:57:33,329 --> 00:57:37,440
things like that so technically we may

1455
00:57:35,489 --> 00:57:38,459
want to also put in things that prevent

1456
00:57:37,440 --> 00:57:43,590
that from happening

1457
00:57:38,460 --> 00:57:45,480
okay so yeah again this is one of the

1458
00:57:43,590 --> 00:57:47,820
reasons why you tend to want to write a

1459
00:57:45,480 --> 00:57:49,230
few very simple primitives like a work

1460
00:57:47,820 --> 00:57:50,880
queue or things like this like sort of

1461
00:57:49,230 --> 00:57:52,380
what we're working towards in order to

1462
00:57:50,880 --> 00:57:54,450
facilitate your multi-threading because

1463
00:57:52,380 --> 00:57:55,980
once you start talking about threads

1464
00:57:54,449 --> 00:57:57,629
having to do work with each other it

1465
00:57:55,980 --> 00:58:00,119
gets very complicated and so you want to

1466
00:57:57,630 --> 00:58:02,340
typically solve that problem once in a

1467
00:58:00,119 --> 00:58:03,779
coherent way and not have to keep doing

1468
00:58:02,340 --> 00:58:06,180
it all throughout your code because

1469
00:58:03,780 --> 00:58:08,010
you're very liable to make mistakes and

1470
00:58:06,179 --> 00:58:10,049
you would rather only make those things

1471
00:58:08,010 --> 00:58:11,400
once and fix them once rather than

1472
00:58:10,050 --> 00:58:13,320
having them strewn throughout your code

1473
00:58:11,400 --> 00:58:15,240
that in a way that constantly causes you

1474
00:58:13,320 --> 00:58:31,370
bugs and headaches all right so with

1475
00:58:15,239 --> 00:58:31,369
that let's go to the QA and let's see

1476
00:58:35,858 --> 00:58:43,818
questions is your use of force semicolon

1477
00:58:42,289 --> 00:58:45,469
semicolon instead of wild one a

1478
00:58:43,818 --> 00:58:48,768
stylistic choice or is they benefit

1479
00:58:45,469 --> 00:58:51,289
drawback that I'm missing it is actually

1480
00:58:48,768 --> 00:58:53,149
just to shut up stupid compilers so for

1481
00:58:51,289 --> 00:58:56,509
some reason a lot of compilers if you do

1482
00:58:53,150 --> 00:58:58,548
this will complain at you right and what

1483
00:58:56,509 --> 00:59:03,519
they'll say is conditional expression is

1484
00:58:58,548 --> 00:59:09,079
constant it'll be a warning I probably

1485
00:59:03,518 --> 00:59:16,639
probably I don't actually know I can do

1486
00:59:09,079 --> 00:59:18,859
this - all there we go so let's see if I

1487
00:59:16,639 --> 00:59:21,259
turn on the the most strict warning

1488
00:59:18,858 --> 00:59:25,009
level here which of course I can't do

1489
00:59:21,259 --> 00:59:28,608
because the windows headers oh well you

1490
00:59:25,009 --> 00:59:32,298
know what well yeah the windows headers

1491
00:59:28,608 --> 00:59:34,608
are a problematic and I'm in that file I

1492
00:59:32,298 --> 00:59:36,528
guess but let me just take a look and

1493
00:59:34,608 --> 00:59:39,018
see if it has it here oh you know what I

1494
00:59:36,528 --> 00:59:41,739
may have disabled it even let me see if

1495
00:59:39,018 --> 00:59:44,508
I get rid of our warning disables

1496
00:59:41,739 --> 00:59:45,949
conditional expression is tough yeah so

1497
00:59:44,509 --> 00:59:48,588
that's the warning it's conditional

1498
00:59:45,949 --> 00:59:49,969
expression is not constant I disabled

1499
00:59:48,588 --> 00:59:55,219
that wording because it's the stupidest

1500
00:59:49,969 --> 00:59:56,659
warning but but that's why I tend to

1501
00:59:55,219 --> 00:59:58,639
prefer this is because if I'm running

1502
00:59:56,659 --> 00:59:59,868
code especially in another code base

1503
00:59:58,639 --> 01:00:01,759
like you know I'm working on the witness

1504
00:59:59,869 --> 01:00:04,459
or something and they don't have that

1505
01:00:01,759 --> 01:00:05,900
warning disabled I just try to make sure

1506
01:00:04,458 --> 01:00:08,149
that I don't introduce any spurious

1507
01:00:05,900 --> 01:00:13,420
warnings into the code right so I'll try

1508
01:00:08,150 --> 01:00:13,420
to prefer that that's the only reason

1509
01:00:16,579 --> 01:00:21,059
what's the problem with not being

1510
01:00:18,780 --> 01:00:25,440
interlocked and seeing the same value as

1511
01:00:21,059 --> 01:00:27,150
your to do suggests this one right here

1512
01:00:25,440 --> 01:00:29,130
so that's the one that we went over on

1513
01:00:27,150 --> 01:00:34,349
the blackboard in detail right it's that

1514
01:00:29,130 --> 01:00:39,150
we want only one thread we want only one

1515
01:00:34,349 --> 01:00:41,849
thread to actually see the value say

1516
01:00:39,150 --> 01:00:43,470
zero right because our goal is to do

1517
01:00:41,849 --> 01:00:45,510
each of these units of work once and

1518
01:00:43,469 --> 01:00:46,139
what we see already right is that's not

1519
01:00:45,510 --> 01:00:48,450
happening

1520
01:00:46,139 --> 01:00:52,829
thread five two and zero all did the

1521
01:00:48,449 --> 01:00:54,659
wrong piece of work here right which is

1522
01:00:52,829 --> 01:01:01,108
not good at all

1523
01:00:54,659 --> 01:01:02,940
and yeah I feel like again I feel like

1524
01:01:01,108 --> 01:01:05,190
there's still some some janky Nissen

1525
01:01:02,940 --> 01:01:06,960
here I got to see what happens let me

1526
01:01:05,190 --> 01:01:09,420
see what happens if I do only one of

1527
01:01:06,960 --> 01:01:12,990
these threads just want to make sure

1528
01:01:09,420 --> 01:01:15,539
before I start talking about this that

1529
01:01:12,989 --> 01:01:18,209
we're all good here yes you can see

1530
01:01:15,539 --> 01:01:19,769
these this with one thread it prints out

1531
01:01:18,210 --> 01:01:21,389
the number of zero to nine in order

1532
01:01:19,769 --> 01:01:27,210
right so each thing is being done once

1533
01:01:21,389 --> 01:01:31,440
if I make two threads now right we go up

1534
01:01:27,210 --> 01:01:36,210
here and they're still doing ok right 0

1535
01:01:31,440 --> 01:01:38,159
1 2 3 4 5 6 7 8 9 and thread one did two

1536
01:01:36,210 --> 01:01:39,630
of the units of work thread 0 did some

1537
01:01:38,159 --> 01:01:42,088
other ones probably because it had time

1538
01:01:39,630 --> 01:01:44,130
to do those before thread 1 got created

1539
01:01:42,088 --> 01:01:50,750
or something like this will step up the

1540
01:01:44,130 --> 01:01:53,400
number one more time and 0 1 2 3 4 5 6 7

1541
01:01:50,750 --> 01:01:55,829
string 6 you can see thread one actually

1542
01:01:53,400 --> 01:01:57,780
got string 6 but printed it out later

1543
01:01:55,829 --> 01:02:00,449
just to the way these these guys ended

1544
01:01:57,780 --> 01:02:03,060
up happening having to go but again

1545
01:02:00,449 --> 01:02:05,250
still all good there so we're looking

1546
01:02:03,059 --> 01:02:06,690
out pretty well as as we have this but

1547
01:02:05,250 --> 01:02:10,130
again it's really just luck it's also

1548
01:02:06,690 --> 01:02:13,139
helped a little by the fact that the

1549
01:02:10,130 --> 01:02:14,700
there's a string synchronization this

1550
01:02:13,139 --> 01:02:16,348
output debug string actually

1551
01:02:14,699 --> 01:02:18,389
synchronizes because only one person can

1552
01:02:16,349 --> 01:02:19,559
write to that debug sync at a time so

1553
01:02:18,389 --> 01:02:21,179
you kind of have a low but synchronized

1554
01:02:19,559 --> 01:02:23,338
snip but what you can see is here is

1555
01:02:21,179 --> 01:02:28,199
once we get up to 4 you can see that we

1556
01:02:23,338 --> 01:02:31,559
got we got pwned right 0 1 1 2 3 4

1557
01:02:28,199 --> 01:02:33,868
four five six seven eight nine so we did

1558
01:02:31,559 --> 01:02:38,358
one set of work twice both red zero and

1559
01:02:33,869 --> 01:02:41,490
thread one both saw work unit one right

1560
01:02:38,358 --> 01:02:44,210
so what happened there here's what

1561
01:02:41,489 --> 01:02:47,729
happened there right

1562
01:02:44,210 --> 01:02:50,820
remember how CPUs work right they have

1563
01:02:47,730 --> 01:02:57,030
registers so here is core zero here is

1564
01:02:50,820 --> 01:02:59,930
core one okay here is entry count out in

1565
01:02:57,030 --> 01:03:05,400
memory somewhere okay

1566
01:02:59,929 --> 01:03:07,529
core zero says oh I need to do this

1567
01:03:05,400 --> 01:03:12,050
operation right oh I should say entry

1568
01:03:07,530 --> 01:03:19,950
count my bad I want next entry to do

1569
01:03:12,050 --> 01:03:23,940
right so next entry to do and next entry

1570
01:03:19,949 --> 01:03:26,399
to zoo in this case make sure I did the

1571
01:03:23,940 --> 01:03:28,650
right one so is the is the work unit one

1572
01:03:26,400 --> 01:03:30,720
right so next entry to do in this case

1573
01:03:28,650 --> 01:03:36,420
the value that's stored in this location

1574
01:03:30,719 --> 01:03:39,750
is one right so here's what happens core

1575
01:03:36,420 --> 01:03:43,108
zero goes oh I got a go check next entry

1576
01:03:39,750 --> 01:03:45,059
to do and potentially increment it so

1577
01:03:43,108 --> 01:03:47,759
I'm going to load it in here so now it

1578
01:03:45,059 --> 01:03:50,088
goes into a register right so inside the

1579
01:03:47,760 --> 01:03:53,280
register of course zero there's a one

1580
01:03:50,088 --> 01:03:54,900
core one goes oh I got a load that in

1581
01:03:53,280 --> 01:03:57,210
let me load that in so now in the

1582
01:03:54,900 --> 01:04:00,480
register of core one there's a one

1583
01:03:57,210 --> 01:04:02,670
because remember processors don't

1584
01:04:00,480 --> 01:04:04,920
necessarily operate on memory there are

1585
01:04:02,670 --> 01:04:06,630
such things as memory ops in x64

1586
01:04:04,920 --> 01:04:07,829
but a lot of times what they do is they

1587
01:04:06,630 --> 01:04:08,940
move something into a register do a

1588
01:04:07,829 --> 01:04:12,359
bunch of work with it and then put it

1589
01:04:08,940 --> 01:04:14,369
out so remember it's a copy it

1590
01:04:12,358 --> 01:04:16,980
effectively copied these values right

1591
01:04:14,369 --> 01:04:20,460
these odds that copied they got cloned

1592
01:04:16,980 --> 01:04:23,068
into the registers of the cores and then

1593
01:04:20,460 --> 01:04:24,659
does a test it says oh you know I don't

1594
01:04:23,068 --> 01:04:27,239
know what's entry count is this greater

1595
01:04:24,659 --> 01:04:28,440
you know entry count is maybe four at

1596
01:04:27,239 --> 01:04:30,479
this point or something who knows what

1597
01:04:28,440 --> 01:04:32,670
it is so it's like oh okay yeah you know

1598
01:04:30,480 --> 01:04:34,369
what I gotta increment this so it

1599
01:04:32,670 --> 01:04:38,490
increments it and it makes it a two

1600
01:04:34,369 --> 01:04:40,588
right core one goes oh you know what I

1601
01:04:38,489 --> 01:04:41,429
got to do that same thing increments

1602
01:04:40,588 --> 01:04:45,150
that and makes it

1603
01:04:41,429 --> 01:04:47,699
as well right they then go and they both

1604
01:04:45,150 --> 01:04:49,440
write out the value and they overwrite

1605
01:04:47,699 --> 01:04:53,039
this value with two and they both write

1606
01:04:49,440 --> 01:04:56,940
two back onto it so both of these cores

1607
01:04:53,039 --> 01:04:59,130
now think right that work unit one is

1608
01:04:56,940 --> 01:05:01,108
the one they should do and they both

1609
01:04:59,130 --> 01:05:03,630
think that they updated the value to two

1610
01:05:01,108 --> 01:05:05,549
which they did but what that means is

1611
01:05:03,630 --> 01:05:07,588
that work unit one is actually getting

1612
01:05:05,550 --> 01:05:11,099
done twice now by each these of these

1613
01:05:07,588 --> 01:05:14,279
cores each dozen right and that is bad

1614
01:05:11,099 --> 01:05:16,289
if that was rendering we just lost 1/16

1615
01:05:14,280 --> 01:05:19,290
of our performance because we rendered a

1616
01:05:16,289 --> 01:05:20,400
tile twice in we instead of having two

1617
01:05:19,289 --> 01:05:22,108
different tiles being rendered by two

1618
01:05:20,400 --> 01:05:25,050
different cores we rendered the same

1619
01:05:22,108 --> 01:05:27,078
tile on both cores so does that make

1620
01:05:25,050 --> 01:05:27,079
sense

1621
01:05:29,210 --> 01:05:33,119
do mutex is that I've seen used for

1622
01:05:31,739 --> 01:05:34,919
multi-threading code in other places

1623
01:05:33,119 --> 01:05:36,000
rely on those interlocking instructions

1624
01:05:34,920 --> 01:05:36,780
or are they something completely

1625
01:05:36,000 --> 01:05:39,480
different

1626
01:05:36,780 --> 01:05:41,220
yes mutexes are actually just operating

1627
01:05:39,480 --> 01:05:43,230
system primitives that are built off of

1628
01:05:41,219 --> 01:05:45,689
interlocked primitives in the end the

1629
01:05:43,230 --> 01:05:49,019
ecstacy for processor the ecstacy for

1630
01:05:45,690 --> 01:05:51,659
processor I I guess I don't

1631
01:05:49,019 --> 01:05:53,159
I can't think if there's anything else

1632
01:05:51,659 --> 01:05:54,899
that might be relevant there but on the

1633
01:05:53,159 --> 01:05:57,480
on the whole the mutexes are usually

1634
01:05:54,900 --> 01:06:00,960
built off of interlocked instructions on

1635
01:05:57,480 --> 01:06:02,429
the ecstacy for a processor but there is

1636
01:06:00,960 --> 01:06:03,780
also another thing called transactional

1637
01:06:02,429 --> 01:06:05,159
memory which is coming out Intel

1638
01:06:03,780 --> 01:06:06,869
processors now that's a different way of

1639
01:06:05,159 --> 01:06:09,358
doing it it's not really about mutexes

1640
01:06:06,869 --> 01:06:12,059
and then quite the same way but there's

1641
01:06:09,358 --> 01:06:13,199
there are some other new synchronization

1642
01:06:12,059 --> 01:06:15,298
primitives that do some slightly

1643
01:06:13,199 --> 01:06:17,338
different things but at the moment as

1644
01:06:15,298 --> 01:06:18,449
far as I know like mutexes in general

1645
01:06:17,338 --> 01:06:23,909
are just implemented on top of the

1646
01:06:18,449 --> 01:06:26,969
interlocking instructions what is your

1647
01:06:23,909 --> 01:06:28,649
opinion on lock liske use so I'll be

1648
01:06:26,969 --> 01:06:31,588
honest with you I don't really know what

1649
01:06:28,650 --> 01:06:34,559
people mean when they say lock liske use

1650
01:06:31,588 --> 01:06:35,989
a lot of the time I don't actually know

1651
01:06:34,559 --> 01:06:39,630
which which one they're referring to

1652
01:06:35,989 --> 01:06:41,250
like if someone says a lock Liske you do

1653
01:06:39,630 --> 01:06:44,720
they mean that they don't use any

1654
01:06:41,250 --> 01:06:47,159
interlocked instructions at all right

1655
01:06:44,719 --> 01:06:48,929
and if they do mean any interlocked or

1656
01:06:47,159 --> 01:06:50,789
not using any interlocked instructions

1657
01:06:48,929 --> 01:06:53,480
at all then I guess I would say well

1658
01:06:50,789 --> 01:06:55,318
it's interesting probably in some

1659
01:06:53,480 --> 01:06:58,380
circumstances

1660
01:06:55,318 --> 01:07:01,469
which is that if you if you care about

1661
01:06:58,380 --> 01:07:03,890
the speed if you if you have to queue a

1662
01:07:01,469 --> 01:07:06,719
ton of things and DQ a ton of things

1663
01:07:03,889 --> 01:07:10,679
then that may be worth it to you

1664
01:07:06,719 --> 01:07:14,879
right that may be something that that is

1665
01:07:10,679 --> 01:07:17,818
valuable right but if you don't then I

1666
01:07:14,880 --> 01:07:19,318
would question you know a lot increment

1667
01:07:17,818 --> 01:07:22,469
is really not very expensive out an

1668
01:07:19,318 --> 01:07:25,650
ecstasy for a processor so you know if

1669
01:07:22,469 --> 01:07:29,848
the complexity of that queue at all is

1670
01:07:25,650 --> 01:07:31,108
more than just the cycles of doing the

1671
01:07:29,849 --> 01:07:34,769
lock increment or whatever it ends up

1672
01:07:31,108 --> 01:07:36,119
being is it really such a good idea

1673
01:07:34,769 --> 01:07:37,650
because a locked increment queue is

1674
01:07:36,119 --> 01:07:39,390
really easy to implement and pretty hard

1675
01:07:37,650 --> 01:07:41,700
to mess up

1676
01:07:39,389 --> 01:07:43,858
whereas trying to do it without that

1677
01:07:41,699 --> 01:07:45,929
seems a little trickier but I don't know

1678
01:07:43,858 --> 01:07:50,460
so I don't have a strong opinion about

1679
01:07:45,929 --> 01:07:52,710
them I am not I do not try to do fancy

1680
01:07:50,460 --> 01:07:54,059
multi-threaded code usually I just do

1681
01:07:52,710 --> 01:07:55,349
standard work queue stuff and I make

1682
01:07:54,059 --> 01:07:59,579
sure the work queue elements are pretty

1683
01:07:55,349 --> 01:08:01,530
big and I don't I don't have to deal

1684
01:07:59,579 --> 01:08:03,660
with stuff like oh my god what if we

1685
01:08:01,530 --> 01:08:05,190
have to you know make this the

1686
01:08:03,659 --> 01:08:07,078
granularity of this multi-threading be

1687
01:08:05,190 --> 01:08:09,019
like millions of work units so a second

1688
01:08:07,079 --> 01:08:11,130
or something or weird stuff like that so

1689
01:08:09,019 --> 01:08:13,369
you know it doesn't tend to be a thing I

1690
01:08:11,130 --> 01:08:13,369
think about

1691
01:08:17,789 --> 01:08:21,880
what's the point of an infinite loop to

1692
01:08:20,199 --> 01:08:25,119
begin with it ends at some point doesn't

1693
01:08:21,880 --> 01:08:27,430
it well at some point not really I mean

1694
01:08:25,119 --> 01:08:30,970
you know we could very well make this

1695
01:08:27,430 --> 01:08:33,730
this loop be infinite for reals

1696
01:08:30,970 --> 01:08:37,119
like because the thread will get killed

1697
01:08:33,729 --> 01:08:38,679
in exit process so we may never really

1698
01:08:37,119 --> 01:08:41,409
care about having it closed down

1699
01:08:38,680 --> 01:08:42,909
so yeah in the case of threading you

1700
01:08:41,409 --> 01:08:47,769
really can't have literally infinite

1701
01:08:42,909 --> 01:08:50,079
loops what threading libraries do you

1702
01:08:47,770 --> 01:08:52,299
recommend and why I never use any

1703
01:08:50,079 --> 01:08:55,359
threading libraries locked increment is

1704
01:08:52,298 --> 01:08:57,269
so easy I find that I've always just

1705
01:08:55,359 --> 01:08:59,950
been able to use locked increment or

1706
01:08:57,270 --> 01:09:02,230
sorry I shouldn't say just locking right

1707
01:08:59,949 --> 01:09:04,838
lock compare exchange lock exchange lock

1708
01:09:02,229 --> 01:09:06,189
increment I just use those and it's

1709
01:09:04,838 --> 01:09:09,010
really easy to build a queue with them

1710
01:09:06,189 --> 01:09:10,059
so I don't I never use like as far as

1711
01:09:09,010 --> 01:09:12,338
I'm concerned using someone else's

1712
01:09:10,060 --> 01:09:14,440
multi-threading libraries is probably

1713
01:09:12,338 --> 01:09:18,059
just an invitation to inherit a bunch of

1714
01:09:14,439 --> 01:09:22,719
crappy bugs that are in there from them

1715
01:09:18,060 --> 01:09:25,420
because like I've seen boost and I'm I

1716
01:09:22,720 --> 01:09:27,880
mean I would not trust the people who

1717
01:09:25,420 --> 01:09:29,619
coded boost to write single-threaded

1718
01:09:27,880 --> 01:09:31,650
code for me let alone multi-threaded

1719
01:09:29,619 --> 01:09:31,649
code

1720
01:09:36,850 --> 01:09:41,480
what's better a job scheduler from where

1721
01:09:39,470 --> 01:09:47,090
each thread can get a job or separate

1722
01:09:41,479 --> 01:09:50,569
queues for each thread so basically it

1723
01:09:47,090 --> 01:09:54,980
depends on the workload so taking the

1724
01:09:50,569 --> 01:09:57,099
render as an example you might say well

1725
01:09:54,979 --> 01:09:59,899
why would you have a queue at all

1726
01:09:57,100 --> 01:10:01,850
because we know we have X number of

1727
01:09:59,899 --> 01:10:04,849
threads why don't we just have each

1728
01:10:01,850 --> 01:10:05,810
thread do a specific set of tiles and

1729
01:10:04,850 --> 01:10:09,800
that way they don't have to communicate

1730
01:10:05,810 --> 01:10:12,020
at all right and that's a perfectly

1731
01:10:09,800 --> 01:10:13,400
valid strategy and we may find that

1732
01:10:12,020 --> 01:10:16,490
that's a better strategy than what we're

1733
01:10:13,399 --> 01:10:19,159
doing I don't know I kind of want to

1734
01:10:16,489 --> 01:10:20,420
show the work cube version just for

1735
01:10:19,159 --> 01:10:23,449
educational purposes because it's more

1736
01:10:20,420 --> 01:10:24,859
general and applies to more things but

1737
01:10:23,449 --> 01:10:28,789
you know it could be fine to do it that

1738
01:10:24,859 --> 01:10:30,979
way but even in the renderer case it may

1739
01:10:28,789 --> 01:10:32,840
not be true that that is the right way

1740
01:10:30,979 --> 01:10:35,149
to thread it and the reason is because

1741
01:10:32,840 --> 01:10:37,220
different tiles may take different

1742
01:10:35,149 --> 01:10:39,769
amounts of time okay

1743
01:10:37,220 --> 01:10:43,490
so consider the following circumstance

1744
01:10:39,770 --> 01:10:45,620
right and so so just to give you just to

1745
01:10:43,489 --> 01:10:47,899
tie it in to your question right so

1746
01:10:45,619 --> 01:10:50,779
you're saying what's the difference

1747
01:10:47,899 --> 01:10:52,989
right between I have something that

1748
01:10:50,779 --> 01:11:00,590
looks like this right

1749
01:10:52,989 --> 01:11:02,869
q q q q q right and each thread pulls

1750
01:11:00,590 --> 01:11:05,000
from a different queue so when I go to

1751
01:11:02,869 --> 01:11:07,550
distribute my render jobs I take the

1752
01:11:05,000 --> 01:11:10,970
screen and I break it up into tiles oops

1753
01:11:07,550 --> 01:11:13,489
and I break it up into tiles and I

1754
01:11:10,970 --> 01:11:15,860
assign each of those tiles to different

1755
01:11:13,489 --> 01:11:18,380
threads right and they each get their

1756
01:11:15,859 --> 01:11:19,729
own queue so we like queue up tiles in

1757
01:11:18,380 --> 01:11:21,260
each of the thread queues or something

1758
01:11:19,729 --> 01:11:22,609
like this or better yet we do away with

1759
01:11:21,260 --> 01:11:24,500
this entirely and we just have each

1760
01:11:22,609 --> 01:11:26,659
thread knows which tiles it does and it

1761
01:11:24,500 --> 01:11:28,369
just iterates over them right what's the

1762
01:11:26,659 --> 01:11:31,340
difference between that and just having

1763
01:11:28,369 --> 01:11:33,170
one queue right where each of the tiles

1764
01:11:31,340 --> 01:11:35,449
piles into it and all of the threads

1765
01:11:33,170 --> 01:11:37,880
pull out of it right and just to give

1766
01:11:35,449 --> 01:11:43,039
you some nominal Eicher here this is

1767
01:11:37,880 --> 01:11:46,159
typically called single producer single

1768
01:11:43,039 --> 01:11:47,960
consumer right these are consumers of

1769
01:11:46,159 --> 01:11:50,239
the queue and these are producers of the

1770
01:11:47,960 --> 01:11:53,090
queue single producer single

1771
01:11:50,239 --> 01:11:54,559
Zoomer so basically like HQ only has one

1772
01:11:53,090 --> 01:11:57,260
thread writing to it and one thread

1773
01:11:54,560 --> 01:11:58,700
reading from it and this is called

1774
01:11:57,260 --> 01:12:00,230
single producer because it's the same

1775
01:11:58,699 --> 01:12:02,750
here as here there's only one thread

1776
01:12:00,229 --> 01:12:05,449
that's driving the house multiple

1777
01:12:02,750 --> 01:12:07,819
pre-consumer so this is this is single

1778
01:12:05,449 --> 01:12:11,750
multiple right and you can look those up

1779
01:12:07,819 --> 01:12:14,659
those are standard terms that you can

1780
01:12:11,750 --> 01:12:16,880
read about well the reason to prefer

1781
01:12:14,659 --> 01:12:20,180
this method is that what if say this

1782
01:12:16,880 --> 01:12:21,770
tile takes a hell of a long time right

1783
01:12:20,180 --> 01:12:23,210
so this tile takes a hundred

1784
01:12:21,770 --> 01:12:25,280
milliseconds and that that'd be too much

1785
01:12:23,210 --> 01:12:29,569
this Kyle takes ten milliseconds but the

1786
01:12:25,279 --> 01:12:32,289
rest of these I'll take one right well

1787
01:12:29,569 --> 01:12:35,539
what we'd like to have happen ideally is

1788
01:12:32,289 --> 01:12:38,689
we would like to have the rest of the

1789
01:12:35,539 --> 01:12:41,029
threads be able to do all the other work

1790
01:12:38,689 --> 01:12:43,399
while whoever unfortunately got stuck

1791
01:12:41,029 --> 01:12:45,409
with the 10 millisecond tile does that

1792
01:12:43,399 --> 01:12:47,329
work right because think about what

1793
01:12:45,409 --> 01:12:49,159
would happen in this queue case what

1794
01:12:47,329 --> 01:12:52,159
would happen in this queue case is one

1795
01:12:49,159 --> 01:12:54,649
thread gets say this tile this tile this

1796
01:12:52,159 --> 01:12:56,539
tile this tile and this tile right and

1797
01:12:54,649 --> 01:12:58,339
worse yet let's say that the 10

1798
01:12:56,539 --> 01:13:00,829
millisecond tile was actually up here in

1799
01:12:58,340 --> 01:13:01,970
our worst case right so now we got one

1800
01:13:00,829 --> 01:13:04,130
millisecond one looks like we'll mix

1801
01:13:01,970 --> 01:13:05,860
again so let's say this whole row this

1802
01:13:04,130 --> 01:13:08,480
whole column of tiles went to this queue

1803
01:13:05,859 --> 01:13:10,729
that means that as the first this thread

1804
01:13:08,479 --> 01:13:12,889
here he pulls off the first thing it

1805
01:13:10,729 --> 01:13:14,989
takes him 10 milliseconds he then still

1806
01:13:12,890 --> 01:13:16,220
has to pull off these other four so it's

1807
01:13:14,989 --> 01:13:17,630
still gonna take him another 4

1808
01:13:16,220 --> 01:13:19,640
milliseconds meaning that the total

1809
01:13:17,630 --> 01:13:22,310
frame time will be 14 milliseconds for

1810
01:13:19,640 --> 01:13:24,950
this guy all the rest of these guys only

1811
01:13:22,310 --> 01:13:28,190
had one millisecond tiles let's say so

1812
01:13:24,949 --> 01:13:29,059
they all completed in 5 milliseconds but

1813
01:13:28,189 --> 01:13:30,439
it doesn't matter that they all

1814
01:13:29,060 --> 01:13:32,120
completed in 5 milliseconds because this

1815
01:13:30,439 --> 01:13:33,379
guy took 14 so that means our total

1816
01:13:32,119 --> 01:13:35,149
frame time is still going to be on the

1817
01:13:33,380 --> 01:13:37,940
order of 14 milliseconds on the other

1818
01:13:35,149 --> 01:13:40,670
hand if this had been a general work

1819
01:13:37,939 --> 01:13:42,919
queue this guy would have gotten stuck

1820
01:13:40,670 --> 01:13:45,109
with a 10 millisecond guy yes but all

1821
01:13:42,920 --> 01:13:47,449
the rest of these guys would have been

1822
01:13:45,109 --> 01:13:50,989
done by other threads by the time he

1823
01:13:47,449 --> 01:13:52,609
completed right so our total frame time

1824
01:13:50,989 --> 01:13:54,500
drops from 14 milliseconds to 10

1825
01:13:52,609 --> 01:13:57,439
milliseconds in the single producer

1826
01:13:54,500 --> 01:13:59,479
multiple consumer case so when you know

1827
01:13:57,439 --> 01:14:00,949
that you don't have too many work units

1828
01:13:59,479 --> 01:14:03,289
like when you have on the order of a

1829
01:14:00,949 --> 01:14:04,069
hundred work units or something it's

1830
01:14:03,289 --> 01:14:07,368
usually

1831
01:14:04,069 --> 01:14:09,769
not worth the extra time savings in

1832
01:14:07,368 --> 01:14:11,779
terms of in queuing and D queuing that

1833
01:14:09,770 --> 01:14:13,130
you get from going with the single

1834
01:14:11,779 --> 01:14:14,359
producer single consumer because now you

1835
01:14:13,130 --> 01:14:15,618
don't have to do LOC increments or

1836
01:14:14,359 --> 01:14:17,420
anything right because you always know

1837
01:14:15,618 --> 01:14:18,920
that there's only one thread reading so

1838
01:14:17,420 --> 01:14:21,849
you can actually you can actually do a

1839
01:14:18,920 --> 01:14:23,960
lock free queue trivially in this case

1840
01:14:21,849 --> 01:14:25,489
but if you know that you have a small

1841
01:14:23,960 --> 01:14:26,989
number of work units it's almost always

1842
01:14:25,488 --> 01:14:28,519
better to go a single producer multiple

1843
01:14:26,988 --> 01:14:30,859
consumer because it means that you get

1844
01:14:28,520 --> 01:14:32,540
this free spreading of the work that you

1845
01:14:30,859 --> 01:14:36,698
would not have gotten in the case where

1846
01:14:32,539 --> 01:14:36,698
you've got this this queueing happening

1847
01:14:39,368 --> 01:14:43,399
sudonym 73 I think that the point of

1848
01:14:41,929 --> 01:14:45,440
lock las' is that it doesn't use an

1849
01:14:43,399 --> 01:14:47,149
operating system level lock if that's

1850
01:14:45,439 --> 01:14:49,368
all people mean by lock free queues then

1851
01:14:47,149 --> 01:14:51,500
that's the kind I always use so I would

1852
01:14:49,368 --> 01:14:53,479
say I'm in favor of them but i but it

1853
01:14:51,500 --> 01:14:56,328
technically you know you can have like

1854
01:14:53,479 --> 01:14:58,669
it's possible to do so just to make this

1855
01:14:56,328 --> 01:14:59,929
absolutely explicit so this is why I say

1856
01:14:58,670 --> 01:15:01,940
I never know what people mean when they

1857
01:14:59,929 --> 01:15:04,270
say lock free because there's two kinds

1858
01:15:01,939 --> 01:15:08,319
of lock free there's literally

1859
01:15:04,270 --> 01:15:11,929
completely lock free right there's like

1860
01:15:08,319 --> 01:15:16,488
meaning the processor its processor lock

1861
01:15:11,929 --> 01:15:18,618
free okay and that's actually possible

1862
01:15:16,488 --> 01:15:20,448
so for example in the single producer

1863
01:15:18,618 --> 01:15:22,969
single consumer case you could do a

1864
01:15:20,448 --> 01:15:24,888
processor lock free queue that's totally

1865
01:15:22,969 --> 01:15:26,868
plausible all you have to do is make

1866
01:15:24,889 --> 01:15:29,000
sure that you write to the index

1867
01:15:26,868 --> 01:15:30,259
variable on one thread after you've done

1868
01:15:29,000 --> 01:15:31,789
all the rights it needs to do and you

1869
01:15:30,260 --> 01:15:33,199
read from that on the other thread and

1870
01:15:31,789 --> 01:15:36,590
then you never have to do an interlock

1871
01:15:33,198 --> 01:15:39,348
right so that's actually possible right

1872
01:15:36,590 --> 01:15:42,650
then there's the other lock free which

1873
01:15:39,349 --> 01:15:45,469
means that no threads ever stall okay

1874
01:15:42,649 --> 01:15:47,839
and that's a very different thing what

1875
01:15:45,469 --> 01:15:50,328
that means that is like cheesy lock free

1876
01:15:47,840 --> 01:15:51,770
all that means is that you're using lock

1877
01:15:50,328 --> 01:15:53,719
you're using the processor it's got

1878
01:15:51,770 --> 01:15:54,619
processor locks in it right so it has

1879
01:15:53,719 --> 01:15:57,469
processor locks

1880
01:15:54,618 --> 01:15:58,819
I don't usually call that lock free

1881
01:15:57,469 --> 01:16:01,460
because it still has a processor lock

1882
01:15:58,819 --> 01:16:03,979
all it means is that you're not sitting

1883
01:16:01,460 --> 01:16:06,109
there stalling other threads waiting for

1884
01:16:03,979 --> 01:16:08,839
another proffer for this process to

1885
01:16:06,109 --> 01:16:10,368
finish right so the kind of thing that

1886
01:16:08,840 --> 01:16:12,349
we're writing here is actually locked

1887
01:16:10,368 --> 01:16:14,598
free by that definition because it

1888
01:16:12,349 --> 01:16:16,460
doesn't stall the other threads waiting

1889
01:16:14,599 --> 01:16:17,960
for one thread to finish D queuing all

1890
01:16:16,460 --> 01:16:20,210
the threads can DQ Simon

1891
01:16:17,960 --> 01:16:22,460
Dainius Lee using the processor locked

1892
01:16:20,210 --> 01:16:24,949
synchronization primitive primitives so

1893
01:16:22,460 --> 01:16:27,140
yeah this kind of lock three pretty

1894
01:16:24,949 --> 01:16:29,149
difficult pretty limiting I don't tend

1895
01:16:27,140 --> 01:16:30,770
to do it this kind of lock free pretty

1896
01:16:29,149 --> 01:16:32,569
cheesy use of the term lock free in my

1897
01:16:30,770 --> 01:16:35,950
opinion but this is the kind I normally

1898
01:16:32,569 --> 01:16:35,949
do so yes I am in favor of it

1899
01:16:45,939 --> 01:16:52,789
so Fabien says the terminology the

1900
01:16:49,369 --> 01:16:55,639
original term was non-blocking which is

1901
01:16:52,789 --> 01:16:57,710
more more useful for lock-free

1902
01:16:55,639 --> 01:16:59,539
and I would like that to be much better

1903
01:16:57,710 --> 01:17:02,539
because if that was a terminology then

1904
01:16:59,539 --> 01:17:06,350
that makes sense right if you call this

1905
01:17:02,539 --> 01:17:08,840
lock free and this non-blocking then now

1906
01:17:06,350 --> 01:17:10,969
I feel like that makes a lot of sense

1907
01:17:08,840 --> 01:17:13,940
but when you start using lock free for

1908
01:17:10,969 --> 01:17:16,670
this I just it's still doing a lock like

1909
01:17:13,939 --> 01:17:19,669
that's a lock it's not the processors

1910
01:17:16,670 --> 01:17:22,789
doing the stall for you in there so I

1911
01:17:19,670 --> 01:17:24,710
don't know but but yeah so yes so both

1912
01:17:22,789 --> 01:17:26,750
pseudonym 73 and Fabien said that

1913
01:17:24,710 --> 01:17:28,670
normally people when they typically say

1914
01:17:26,750 --> 01:17:32,000
lock free they're actually referring to

1915
01:17:28,670 --> 01:17:33,380
this case so yeah if that's the case

1916
01:17:32,000 --> 01:17:35,929
that the original questioner was asking

1917
01:17:33,380 --> 01:17:42,770
about then I that's what I tend to do

1918
01:17:35,929 --> 01:17:46,480
actually is it reasonable to synchronize

1919
01:17:42,770 --> 01:17:53,179
the receiving of network packets on one

1920
01:17:46,479 --> 01:17:55,129
synchronized thread sure I mean the

1921
01:17:53,179 --> 01:17:57,800
network card can't produce packets fast

1922
01:17:55,130 --> 01:17:59,719
enough for for an x64 a process for an

1923
01:17:57,800 --> 01:18:01,789
ecstacy for a court of choke on them the

1924
01:17:59,719 --> 01:18:03,920
xst for a processor can read much faster

1925
01:18:01,789 --> 01:18:06,619
than that so in order for you need to

1926
01:18:03,920 --> 01:18:10,190
need multiple threads simply to receive

1927
01:18:06,619 --> 01:18:13,340
network packets in if you were talking

1928
01:18:10,189 --> 01:18:15,979
about like a low-level thing sure it

1929
01:18:13,340 --> 01:18:18,110
would be fine right unless you had some

1930
01:18:15,979 --> 01:18:21,919
kind of amazing network card that was

1931
01:18:18,109 --> 01:18:23,329
like just crazy out super fast and you

1932
01:18:21,920 --> 01:18:26,179
were sitting right on some kind of fiber

1933
01:18:23,329 --> 01:18:28,488
link right but almost always in network

1934
01:18:26,179 --> 01:18:30,230
packet receipt case it's gonna be the

1935
01:18:28,488 --> 01:18:32,359
outbound link the inbound link rather

1936
01:18:30,229 --> 01:18:36,859
that's the that's the slow part not UD

1937
01:18:32,359 --> 01:18:38,000
queuing them now what is not always the

1938
01:18:36,859 --> 01:18:39,889
case is that the stuff that has to

1939
01:18:38,000 --> 01:18:42,560
happen with those network packets like

1940
01:18:39,889 --> 01:18:45,679
the crappy tcp/ip stack on Windows or

1941
01:18:42,560 --> 01:18:47,780
something or you know what you need to

1942
01:18:45,679 --> 01:18:49,670
do to actually process each packet that

1943
01:18:47,779 --> 01:18:51,859
may be a lot of work and that may be

1944
01:18:49,670 --> 01:18:53,329
slower than inbound and at that point

1945
01:18:51,859 --> 01:18:56,689
you need to make sure that you handle

1946
01:18:53,329 --> 01:18:58,649
them on multiple threads potentially but

1947
01:18:56,689 --> 01:19:02,069
the action will just

1948
01:18:58,649 --> 01:19:03,869
getting the packets off of the Nick like

1949
01:19:02,069 --> 01:19:06,658
you have to be on the world's most

1950
01:19:03,869 --> 01:19:10,079
amazing internet connection before that

1951
01:19:06,658 --> 01:19:13,759
is gonna outstrip in X 64 because X 64

1952
01:19:10,079 --> 01:19:13,760
could handle that no problem

1953
01:19:16,279 --> 01:19:19,829
later in the development cycle will you

1954
01:19:18,448 --> 01:19:23,039
go over threading for other operating

1955
01:19:19,829 --> 01:19:25,109
systems like Mac and Linux so it's yes

1956
01:19:23,039 --> 01:19:26,819
but there's really not much to it you

1957
01:19:25,109 --> 01:19:28,469
just it's the same as the wind three to

1958
01:19:26,819 --> 01:19:31,349
one you just call like this function

1959
01:19:28,469 --> 01:19:33,840
that's like start threading usually on

1960
01:19:31,350 --> 01:19:35,610
most of them so it's not that hard but

1961
01:19:33,840 --> 01:19:38,869
that won't be for a while because that's

1962
01:19:35,609 --> 01:19:38,869
only when we start doing ports

1963
01:19:44,729 --> 01:19:48,880
what are the advantages of having a

1964
01:19:47,109 --> 01:19:50,948
queue of jobs instead of creating a

1965
01:19:48,880 --> 01:19:54,038
thread every time you add a job well

1966
01:19:50,948 --> 01:19:56,799
okay so that is because we are not

1967
01:19:54,038 --> 01:19:58,300
queueing we are not queuing for overlap

1968
01:19:56,800 --> 01:20:01,449
we are queuing for performance and it's

1969
01:19:58,300 --> 01:20:06,760
porting to understand what these two

1970
01:20:01,448 --> 01:20:07,928
different things are okay so I want to

1971
01:20:06,760 --> 01:20:08,979
talk about these because this is I'm

1972
01:20:07,929 --> 01:20:10,449
glad you in fact I'm really glad you

1973
01:20:08,979 --> 01:20:11,769
asked that question because we didn't we

1974
01:20:10,448 --> 01:20:17,408
never really came right out and said

1975
01:20:11,769 --> 01:20:19,269
this okay so what I want to underscore

1976
01:20:17,408 --> 01:20:21,359
here is there's two totally separate

1977
01:20:19,269 --> 01:20:24,340
reasons you might want to thread okay

1978
01:20:21,359 --> 01:20:28,328
one is because you are trying to overlap

1979
01:20:24,340 --> 01:20:30,699
work all right and in that case let's

1980
01:20:28,328 --> 01:20:34,389
say that we just have we have 30 things

1981
01:20:30,698 --> 01:20:37,228
that need to happen right one of those

1982
01:20:34,389 --> 01:20:40,420
things is the UI for our application

1983
01:20:37,229 --> 01:20:42,039
okay and we're not a high performance

1984
01:20:40,420 --> 01:20:43,929
application we really don't care

1985
01:20:42,038 --> 01:20:45,488
we're Apple or somebody we don't really

1986
01:20:43,929 --> 01:20:47,349
care or you know what I shouldn't blame

1987
01:20:45,488 --> 01:20:48,788
app oh we're Android we're the people

1988
01:20:47,349 --> 01:20:50,619
who write Android so we don't care about

1989
01:20:48,788 --> 01:20:52,569
these experience at all if it's laggy or

1990
01:20:50,618 --> 01:20:54,788
whatever so we're just running the Java

1991
01:20:52,569 --> 01:20:57,759
VM and having a UI party and stuffs just

1992
01:20:54,788 --> 01:20:59,198
going nuts oeid right but we've got

1993
01:20:57,760 --> 01:21:00,248
these 30 things that we want to do and

1994
01:20:59,198 --> 01:21:03,638
we know they're all going to take a

1995
01:21:00,248 --> 01:21:05,469
second for something right a totally

1996
01:21:03,639 --> 01:21:07,599
valid use of threading is just a kick

1997
01:21:05,469 --> 01:21:09,698
off 30 threads let them go do their

1998
01:21:07,599 --> 01:21:11,619
thing and let and then we'll at least

1999
01:21:09,698 --> 01:21:13,029
know that that UI thread will get some

2000
01:21:11,618 --> 01:21:15,038
time now and again and it'll be Jack

2001
01:21:13,029 --> 01:21:16,420
tastic but at least run so the user will

2002
01:21:15,038 --> 01:21:19,149
still be able to do some input and it's

2003
01:21:16,420 --> 01:21:21,359
fine right so this is threading for

2004
01:21:19,149 --> 01:21:23,948
overlapping the goal here is not

2005
01:21:21,359 --> 01:21:27,219
performance the goal is simply to have

2006
01:21:23,948 --> 01:21:29,439
30 things that happen simultaneously and

2007
01:21:27,219 --> 01:21:32,739
not have one of them stall completely

2008
01:21:29,439 --> 01:21:35,558
while they happen right threading for

2009
01:21:32,738 --> 01:21:38,109
performance means we are trying to get

2010
01:21:35,559 --> 01:21:40,498
the maximum number of cycles of work out

2011
01:21:38,109 --> 01:21:44,738
of this processor as we possibly can so

2012
01:21:40,498 --> 01:21:48,998
if this processor right if the CPU has

2013
01:21:44,738 --> 01:21:51,069
16 cores or I should say 16 hyper cores

2014
01:21:48,998 --> 01:21:52,929
because we this processor actually has

2015
01:21:51,069 --> 01:21:54,609
eight cores I believe but they have to I

2016
01:21:52,929 --> 01:21:57,039
put threads each or something like this

2017
01:21:54,609 --> 01:21:59,500
you know something like that if the CPU

2018
01:21:57,039 --> 01:22:00,970
has 16 high per course but we create 30

2019
01:21:59,500 --> 01:22:03,310
threads because that's how many things

2020
01:22:00,970 --> 01:22:06,070
we have to do then what we are

2021
01:22:03,310 --> 01:22:09,670
essentially doing is we're forcing the

2022
01:22:06,069 --> 01:22:12,549
operating system to do our job queue for

2023
01:22:09,670 --> 01:22:16,180
us right these 30 threads will all go

2024
01:22:12,550 --> 01:22:17,619
into the OS scheduler right as if they

2025
01:22:16,180 --> 01:22:20,170
were a job queue that's what's gonna

2026
01:22:17,619 --> 01:22:22,840
happen now the OS knows absolutely

2027
01:22:20,170 --> 01:22:25,180
nothing about these threads it does not

2028
01:22:22,840 --> 01:22:26,289
know that they should be that we are

2029
01:22:25,180 --> 01:22:28,270
trying to have the maximum performance

2030
01:22:26,289 --> 01:22:29,890
possible it may think that we're trying

2031
01:22:28,270 --> 01:22:31,210
to interleave them so that they all get

2032
01:22:29,890 --> 01:22:34,180
a little bit of time it could think all

2033
01:22:31,210 --> 01:22:37,119
sorts of things it has to save all kinds

2034
01:22:34,180 --> 01:22:40,240
of register state right it has to do

2035
01:22:37,119 --> 01:22:42,189
interrupts to switch them there's all

2036
01:22:40,239 --> 01:22:47,199
this stuff that the OS scheduler has to

2037
01:22:42,189 --> 01:22:51,279
do if we instead were to create 30 work

2038
01:22:47,199 --> 01:22:54,090
units on our queue all we have to do to

2039
01:22:51,279 --> 01:22:57,309
DQ them is that interlocked exchange

2040
01:22:54,090 --> 01:22:58,720
right that's 100 cycles or something on

2041
01:22:57,310 --> 01:23:01,090
that order depending on the processor

2042
01:22:58,720 --> 01:23:03,039
right I think sometimes it was as much

2043
01:23:01,090 --> 01:23:07,630
as 300 cycles so I shouldn't say 100

2044
01:23:03,039 --> 01:23:09,010
something like 300 cycles but it's never

2045
01:23:07,630 --> 01:23:13,869
I don't think it was ever worse than

2046
01:23:09,010 --> 01:23:17,050
that let's put it that way we know that

2047
01:23:13,869 --> 01:23:18,550
we can totally beat all of this crazy

2048
01:23:17,050 --> 01:23:20,860
work the operating system s the doer it

2049
01:23:18,550 --> 01:23:23,110
has no information it will switch these

2050
01:23:20,859 --> 01:23:25,239
out multiple times potentially it'll do

2051
01:23:23,109 --> 01:23:26,589
register saving and restoring it will

2052
01:23:25,239 --> 01:23:27,849
have to you know it's using the

2053
01:23:26,590 --> 01:23:29,680
scheduled interrupt to do those things

2054
01:23:27,850 --> 01:23:32,320
all of this stuff that doesn't ask to

2055
01:23:29,680 --> 01:23:36,250
happen right we can save all of that

2056
01:23:32,319 --> 01:23:37,719
work by just doing our own job queue so

2057
01:23:36,250 --> 01:23:41,470
because what we care about is

2058
01:23:37,720 --> 01:23:43,300
performance we care about saving all of

2059
01:23:41,470 --> 01:23:45,670
the cycles that would be blown that

2060
01:23:43,300 --> 01:23:47,199
would be wasted and getting it down to

2061
01:23:45,670 --> 01:23:49,060
just that at most you know something

2062
01:23:47,199 --> 01:23:51,789
like 300 cycles that it actually costs

2063
01:23:49,060 --> 01:23:55,660
us to do this thing right and that's

2064
01:23:51,789 --> 01:23:57,250
really important and so what I want to

2065
01:23:55,659 --> 01:23:59,500
underscore there is there really are two

2066
01:23:57,250 --> 01:24:01,989
things that threading does and we care

2067
01:23:59,500 --> 01:24:03,819
almost not at all about this one there

2068
01:24:01,989 --> 01:24:05,079
will be once in a while where we do care

2069
01:24:03,819 --> 01:24:07,509
about this one and that'll be when we're

2070
01:24:05,079 --> 01:24:08,229
doing async i/o which will probably be

2071
01:24:07,510 --> 01:24:09,579
coming up shortly

2072
01:24:08,229 --> 01:24:13,719
actually once we got threads in there we

2073
01:24:09,579 --> 01:24:14,800
might as well get our IO asynchronous so

2074
01:24:13,720 --> 01:24:16,570
there are times when what we care about

2075
01:24:14,800 --> 01:24:18,039
is actually the overlap this because we

2076
01:24:16,569 --> 01:24:19,869
want to wait for like the disk to do

2077
01:24:18,039 --> 01:24:21,159
things or we want to do other stuff so

2078
01:24:19,869 --> 01:24:22,689
there may be other times when there are

2079
01:24:21,159 --> 01:24:24,550
threads either the operating systems or

2080
01:24:22,689 --> 01:24:25,988
our own that are executing on our behalf

2081
01:24:24,550 --> 01:24:28,420
we're really it's not about performance

2082
01:24:25,988 --> 01:24:29,649
is about overlap but for the majority of

2083
01:24:28,420 --> 01:24:31,449
the work that we do what we care about

2084
01:24:29,649 --> 01:24:33,009
is threading for performance which means

2085
01:24:31,449 --> 01:24:34,090
that we don't want to then go turn

2086
01:24:33,010 --> 01:24:37,150
around and give a bunch of that

2087
01:24:34,090 --> 01:24:38,890
performance away because the scheduler

2088
01:24:37,149 --> 01:24:40,238
because we're letting the OS do a bunch

2089
01:24:38,890 --> 01:24:41,619
of work and it doesn't have the

2090
01:24:40,238 --> 01:24:51,609
information necessary to do the right

2091
01:24:41,619 --> 01:24:52,960
thing all right we all done there looks

2092
01:24:51,609 --> 01:24:55,469
like we're out of questions and that's

2093
01:24:52,960 --> 01:24:57,909
good because we're also out of time

2094
01:24:55,470 --> 01:24:59,230
good good I'm glad this is a good

2095
01:24:57,909 --> 01:25:00,699
stopping point for today too because it

2096
01:24:59,229 --> 01:25:03,339
means tomorrow we will basically be able

2097
01:25:00,699 --> 01:25:05,710
to implement our work queue and yeah

2098
01:25:03,340 --> 01:25:07,659
start to actually do stuff because

2099
01:25:05,710 --> 01:25:09,430
basically it hopefully you saw you know

2100
01:25:07,659 --> 01:25:11,619
kind of when I ran this you could kind

2101
01:25:09,430 --> 01:25:13,210
of see how these problems that I'm

2102
01:25:11,619 --> 01:25:15,670
talking about we're not theoretical like

2103
01:25:13,210 --> 01:25:17,380
we actually did have exactly the kind of

2104
01:25:15,670 --> 01:25:18,789
problems that I was saying where people

2105
01:25:17,380 --> 01:25:20,980
get the wrong values and stuff gets

2106
01:25:18,789 --> 01:25:22,840
overwritten and it's not good

2107
01:25:20,979 --> 01:25:25,179
so yeah you saw what kind of happens

2108
01:25:22,840 --> 01:25:26,619
here basically our job for tomorrow will

2109
01:25:25,180 --> 01:25:28,060
be to fix that and then just kind of

2110
01:25:26,619 --> 01:25:30,519
abstract this out into something that we

2111
01:25:28,060 --> 01:25:32,020
can actually use in the game to

2112
01:25:30,520 --> 01:25:33,970
distribute our work at which point we

2113
01:25:32,020 --> 01:25:35,890
will have multi-threading in the

2114
01:25:33,970 --> 01:25:37,210
renderer now there is one other problem

2115
01:25:35,890 --> 01:25:39,910
we'll have in the renderer that has to

2116
01:25:37,210 --> 01:25:41,649
do with that cache line problem but we

2117
01:25:39,909 --> 01:25:43,779
can start talking about that a little

2118
01:25:41,649 --> 01:25:45,189
bit later that just gets into memory

2119
01:25:43,779 --> 01:25:46,238
alignment the fact that we need to make

2120
01:25:45,189 --> 01:25:48,669
sure that our loops don't kind of

2121
01:25:46,238 --> 01:25:50,079
overwrite each other's memory bounds I

2122
01:25:48,670 --> 01:25:52,480
didn't want to talk too much about that

2123
01:25:50,079 --> 01:25:54,550
before because it wasn't applicable in

2124
01:25:52,479 --> 01:25:55,629
single threading but now that we're

2125
01:25:54,550 --> 01:25:57,670
gonna introduce multi-threading we'll

2126
01:25:55,630 --> 01:26:00,640
will see this or at least we should see

2127
01:25:57,670 --> 01:26:01,989
it I think again until one of the things

2128
01:26:00,640 --> 01:26:03,940
I know it sounded kind of hand-wavy

2129
01:26:01,988 --> 01:26:05,589
today when I said it but this was

2130
01:26:03,939 --> 01:26:08,289
something that actually even when I

2131
01:26:05,590 --> 01:26:09,699
first learned multi-threading our first

2132
01:26:08,289 --> 01:26:11,920
I should say did multi-threading on

2133
01:26:09,699 --> 01:26:13,389
ecstasy for this actually surprised some

2134
01:26:11,920 --> 01:26:14,590
people that I programmed with who had

2135
01:26:13,390 --> 01:26:16,329
been doing multi-threading much longer

2136
01:26:14,590 --> 01:26:19,659
than I was because I actually went and

2137
01:26:16,329 --> 01:26:21,179
read the x64 manual x64 is a weird

2138
01:26:19,659 --> 01:26:23,368
processor multi-threading wise

2139
01:26:21,179 --> 01:26:25,260
it actually does synchronization stuff

2140
01:26:23,368 --> 01:26:26,728
that a lot of other processors just

2141
01:26:25,260 --> 01:26:29,248
don't do

2142
01:26:26,729 --> 01:26:31,019
it's got weird strong right ordering and

2143
01:26:29,248 --> 01:26:34,078
stuff like this that's like way better

2144
01:26:31,019 --> 01:26:35,248
than like there let me put it this way

2145
01:26:34,078 --> 01:26:36,808
we're gonna be talking about things like

2146
01:26:35,248 --> 01:26:39,779
memory barriers and this sort of stuff

2147
01:26:36,809 --> 01:26:43,949
the ecstasy for actually that I've for

2148
01:26:39,779 --> 01:26:45,719
what I've seen requires the least out of

2149
01:26:43,948 --> 01:26:47,248
you as a programmer in terms of

2150
01:26:45,719 --> 01:26:50,788
enforcing the memory ordering and

2151
01:26:47,248 --> 01:26:52,170
enforcement stuff happens so actually

2152
01:26:50,788 --> 01:26:53,488
when I say that we're gonna have this

2153
01:26:52,170 --> 01:26:54,689
problem or that we'll have to work

2154
01:26:53,488 --> 01:26:56,788
around this problem what I actually mean

2155
01:26:54,689 --> 01:26:58,559
is we will theoretically have this

2156
01:26:56,788 --> 01:26:59,969
problem and I assume that it will be a

2157
01:26:58,559 --> 01:27:02,219
problem Nexus before but since it's been

2158
01:26:59,969 --> 01:27:04,260
a long time since I read that for all I

2159
01:27:02,219 --> 01:27:06,538
know maybe the x64 actually just comes

2160
01:27:04,260 --> 01:27:09,570
in and is like nope guess what surprise

2161
01:27:06,538 --> 01:27:11,219
folks it's not a problem so I don't know

2162
01:27:09,569 --> 01:27:12,630
but in theory we could have the problem

2163
01:27:11,219 --> 01:27:14,939
so I'm gonna go over it as well and show

2164
01:27:12,630 --> 01:27:17,069
you what we would have to do to fix it

2165
01:27:14,939 --> 01:27:18,689
because at the very least for porting

2166
01:27:17,069 --> 01:27:20,728
sake we probably don't want to put

2167
01:27:18,689 --> 01:27:22,739
ourselves in a situation where we're

2168
01:27:20,729 --> 01:27:24,780
counting on all kinds of x64 stuff and

2169
01:27:22,738 --> 01:27:27,478
then all of a sudden it turns out that

2170
01:27:24,779 --> 01:27:31,309
you know you know people in the

2171
01:27:27,479 --> 01:27:34,619
community get that big contract from

2172
01:27:31,309 --> 01:27:36,208
from from Google to do an android port

2173
01:27:34,618 --> 01:27:37,558
of something and and then it's all

2174
01:27:36,208 --> 01:27:40,319
ruined because neon doesn't have these

2175
01:27:37,559 --> 01:27:42,630
or something at it so point being I want

2176
01:27:40,319 --> 01:27:45,029
to show you that either way and we'll do

2177
01:27:42,630 --> 01:27:46,949
that we'll take care of that so well

2178
01:27:45,029 --> 01:27:48,420
we'll be working on that tomorrow we'll

2179
01:27:46,948 --> 01:27:49,408
get the job keep going and then the days

2180
01:27:48,420 --> 01:27:50,519
forward we'll just make sure the

2181
01:27:49,408 --> 01:27:51,988
renderer is working kosher and we'll

2182
01:27:50,519 --> 01:27:53,670
touch up a few of those things memory

2183
01:27:51,988 --> 01:27:54,859
alignment that we want to make sure

2184
01:27:53,670 --> 01:27:57,059
aren't going to cause any problems

2185
01:27:54,859 --> 01:27:59,880
whether or not they do happen to cause a

2186
01:27:57,059 --> 01:28:03,179
problem on x64 because like I said

2187
01:27:59,880 --> 01:28:05,939
sometimes x64 can save you because it's

2188
01:28:03,179 --> 01:28:07,199
got it's got stronger memory ordering in

2189
01:28:05,939 --> 01:28:09,749
certain cases than a lot of other

2190
01:28:07,198 --> 01:28:13,379
processors do all right so I'm gonna go

2191
01:28:09,748 --> 01:28:16,708
ahead and close things down here for the

2192
01:28:13,380 --> 01:28:18,029
day close it up and also I think we've

2193
01:28:16,708 --> 01:28:19,139
gotten most of our blackboard stuff

2194
01:28:18,029 --> 01:28:22,130
we'll have to do one more blackboard

2195
01:28:19,139 --> 01:28:24,569
session on write read and write barriers

2196
01:28:22,130 --> 01:28:25,739
but I think we've gotten most of the

2197
01:28:24,569 --> 01:28:26,759
black boarding for from all the

2198
01:28:25,738 --> 01:28:28,109
threading out too so that means we

2199
01:28:26,760 --> 01:28:29,699
should be able to make much faster

2200
01:28:28,109 --> 01:28:31,139
progress for the rest of the week

2201
01:28:29,698 --> 01:28:32,998
because I won't have to spend the bulk

2202
01:28:31,139 --> 01:28:35,199
of the time drawing stuff we'll just be

2203
01:28:32,998 --> 01:28:37,149
able to do it so that'll be good too

2204
01:28:35,198 --> 01:28:38,829
so I hope you come back tomorrow and

2205
01:28:37,149 --> 01:28:40,448
join me for the next step in our

2206
01:28:38,829 --> 01:28:41,979
multi-threading which I think will go

2207
01:28:40,448 --> 01:28:43,059
pretty pretty smoothly hopefully but you

2208
01:28:41,979 --> 01:28:46,959
never know with multi-threading it's

2209
01:28:43,060 --> 01:28:48,370
complicated so yes please come back

2210
01:28:46,960 --> 01:28:50,170
tomorrow Android it'll be same time same

2211
01:28:48,369 --> 01:28:52,210
place 5:00 p.m. Pacific Daylight Time

2212
01:28:50,170 --> 01:28:53,350
tomorrow in the meantime if you do want

2213
01:28:52,210 --> 01:28:55,689
to follow along at home you can always

2214
01:28:53,350 --> 01:28:58,929
go to handmade hero org and if you order

2215
01:28:55,689 --> 01:29:00,639
the game you you get the source code all

2216
01:28:58,929 --> 01:29:01,690
throughout its development so you can go

2217
01:29:00,640 --> 01:29:03,550
ahead and check that off you want to do

2218
01:29:01,689 --> 01:29:04,629
the pre-order you could do that we also

2219
01:29:03,550 --> 01:29:05,679
have a patreon if you want support a

2220
01:29:04,630 --> 01:29:07,750
video series it's always much

2221
01:29:05,679 --> 01:29:10,029
appreciated we have a forum site where

2222
01:29:07,750 --> 01:29:12,010
you can go and ask questions and also

2223
01:29:10,029 --> 01:29:14,289
get resources like Mac and Linux ports

2224
01:29:12,010 --> 01:29:16,300
and stuff that the community do and

2225
01:29:14,289 --> 01:29:18,399
stuff like this and finally there's a

2226
01:29:16,300 --> 01:29:21,100
tweet bot which you can check out it

2227
01:29:18,399 --> 01:29:22,899
tweets the schedule at you and we also

2228
01:29:21,100 --> 01:29:24,100
have this live button which thanks to

2229
01:29:22,899 --> 01:29:28,409
some folks who contributed the

2230
01:29:24,100 --> 01:29:30,250
JavaScript code Reni Remy and Jakob

2231
01:29:28,409 --> 01:29:32,050
again don't know how to pronounce either

2232
01:29:30,250 --> 01:29:34,179
of their names but thanks to them this

2233
01:29:32,050 --> 01:29:35,409
now also is pretty accurate so you can

2234
01:29:34,179 --> 01:29:37,869
actually check the schedule for the week

2235
01:29:35,409 --> 01:29:38,800
with a tweet bot and and the schedule

2236
01:29:37,869 --> 01:29:41,890
for the day and stuff like that but you

2237
01:29:38,800 --> 01:29:43,060
also within the window of time when the

2238
01:29:41,890 --> 01:29:44,199
thing is going to be live it actually

2239
01:29:43,060 --> 01:29:45,520
says a little countdown there which is

2240
01:29:44,198 --> 01:29:48,069
pretty cool so thank you guys for that

2241
01:29:45,520 --> 01:29:50,410
it's been pretty sweet yeah

2242
01:29:48,069 --> 01:29:51,609
so thank you all for joining me I hope

2243
01:29:50,409 --> 01:29:54,819
you see you back here tomorrow until

2244
01:29:51,609 --> 01:29:58,509
then please have a wonderful day or

2245
01:29:54,819 --> 01:30:00,309
wonderful programming I should say and I

2246
01:29:58,510 --> 01:30:02,610
will see you back here then take it easy

2247
01:30:00,310 --> 01:30:02,610
everyone

