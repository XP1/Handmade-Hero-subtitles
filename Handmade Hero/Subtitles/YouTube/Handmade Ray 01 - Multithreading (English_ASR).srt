1
00:00:03,080 --> 00:00:07,379
okay hello everyone and welcome to

2
00:00:05,730 --> 00:00:09,480
handmade Hero the show where we code a

3
00:00:07,378 --> 00:00:12,210
complete game live on stream we are

4
00:00:09,480 --> 00:00:14,429
gonna do one more day of raycasting

5
00:00:12,210 --> 00:00:15,870
programming just because people seem to

6
00:00:14,429 --> 00:00:19,769
like it from yesterday and so we figured

7
00:00:15,869 --> 00:00:21,149
we'd do one weekend of it and yeah and

8
00:00:19,769 --> 00:00:24,509
that's about it next weekend we will

9
00:00:21,149 --> 00:00:26,159
return to handmade hero as normal unless

10
00:00:24,510 --> 00:00:27,660
something catastrophic happens which I'm

11
00:00:26,160 --> 00:00:28,740
not willing to rule out based on how

12
00:00:27,660 --> 00:00:31,018
much trouble I had getting this

13
00:00:28,739 --> 00:00:33,929
streaming setup to work even though it

14
00:00:31,018 --> 00:00:36,509
should have been simple so let's take a

15
00:00:33,929 --> 00:00:39,600
look at where we left off from yesterday

16
00:00:36,509 --> 00:00:42,299
oops that's for UNIX we're not on UNIX

17
00:00:39,600 --> 00:00:43,530
right now let's go to the handmade ray

18
00:00:42,299 --> 00:00:46,859
directory this is what we wrote

19
00:00:43,530 --> 00:00:48,899
yesterday on stream and you can see if I

20
00:00:46,859 --> 00:00:51,299
open up the project here it's a very

21
00:00:48,899 --> 00:00:54,840
simple to file project there's like an H

22
00:00:51,299 --> 00:00:56,519
file and a CPP file let me go ahead and

23
00:00:54,840 --> 00:00:57,930
show you those and I'm running it right

24
00:00:56,520 --> 00:01:01,350
now you can see it ray casting over

25
00:00:57,929 --> 00:01:03,509
there and what you can see is we just

26
00:01:01,350 --> 00:01:06,150
have a really really simple program very

27
00:01:03,509 --> 00:01:09,929
very straightforward all it does is set

28
00:01:06,150 --> 00:01:12,030
up a little you know world model here

29
00:01:09,930 --> 00:01:14,810
that's got some materials in it with

30
00:01:12,030 --> 00:01:17,670
some planes and some spheres and so on

31
00:01:14,810 --> 00:01:19,350
and then it just has a simple ray

32
00:01:17,670 --> 00:01:21,359
casting loop it goes through and ask

33
00:01:19,349 --> 00:01:22,679
this little ray caster here to trace

34
00:01:21,359 --> 00:01:24,840
some rays for it

35
00:01:22,680 --> 00:01:26,670
the Rays this is really I don't know why

36
00:01:24,840 --> 00:01:29,728
we call this ray count it's really

37
00:01:26,670 --> 00:01:31,650
bounce count it's how many bounces the

38
00:01:29,728 --> 00:01:34,950
Ray has done has nothing to do with rate

39
00:01:31,650 --> 00:01:36,780
count so it's how many bounces ray has

40
00:01:34,950 --> 00:01:38,189
done it just goes through in Casa ray it

41
00:01:36,780 --> 00:01:40,349
looks at all the planes and spheres in

42
00:01:38,188 --> 00:01:42,959
the world sees if it hits them takes the

43
00:01:40,349 --> 00:01:45,899
closest hit and then processes the

44
00:01:42,959 --> 00:01:48,298
material on that hit and that's it right

45
00:01:45,899 --> 00:01:50,879
we write out a bitmap at the end here

46
00:01:48,299 --> 00:01:53,130
just a simple bitmap image that we could

47
00:01:50,879 --> 00:01:54,539
view and we made a batch file that runs

48
00:01:53,129 --> 00:01:56,640
the ray caster which you see running in

49
00:01:54,540 --> 00:01:58,200
the left hand side of the screen and

50
00:01:56,640 --> 00:02:06,519
then outputs the final image which you

51
00:01:58,200 --> 00:02:09,110
can see here right and that's about it

52
00:02:06,519 --> 00:02:12,469
so what I'd like to do probably today I

53
00:02:09,110 --> 00:02:14,209
think is we've got sort of two things we

54
00:02:12,469 --> 00:02:16,000
need to do to this rate caster in order

55
00:02:14,209 --> 00:02:18,739
to make it like a useful rate caster

56
00:02:16,000 --> 00:02:20,598
really technically three but the third

57
00:02:18,739 --> 00:02:25,069
one I don't know that we'd ever do I

58
00:02:20,598 --> 00:02:26,780
mean maybe we will but this is just kind

59
00:02:25,068 --> 00:02:28,339
of a toy project could people wanted me

60
00:02:26,780 --> 00:02:29,300
to make so I made it so I don't know

61
00:02:28,340 --> 00:02:31,250
that we're really gonna try and make it

62
00:02:29,300 --> 00:02:34,010
into something much more than that

63
00:02:31,250 --> 00:02:38,150
but that those those two things are

64
00:02:34,009 --> 00:02:39,889
better material processing right because

65
00:02:38,150 --> 00:02:41,689
right now we don't really do like

66
00:02:39,889 --> 00:02:43,219
transport for real it's not physically

67
00:02:41,689 --> 00:02:45,348
simulated we don't have a real material

68
00:02:43,219 --> 00:02:48,379
model we're not like handling like the

69
00:02:45,348 --> 00:02:52,280
Fornell equations or you know any kind

70
00:02:48,379 --> 00:02:54,079
of of real computation of what happens

71
00:02:52,280 --> 00:02:56,989
with like it's a surface or a transports

72
00:02:54,080 --> 00:02:59,299
along array and so the results while

73
00:02:56,989 --> 00:03:02,030
they look sort of pseudo real like they

74
00:02:59,299 --> 00:03:04,010
have some of the properties that you

75
00:03:02,030 --> 00:03:06,229
might expect from real light there's a

76
00:03:04,009 --> 00:03:09,318
bunch of like errors in there about how

77
00:03:06,229 --> 00:03:12,159
it's been computed so the results just

78
00:03:09,318 --> 00:03:14,929
aren't very good right there they're not

79
00:03:12,159 --> 00:03:16,818
gonna provide that like realistic look

80
00:03:14,930 --> 00:03:18,469
that you can get from a ray tracer

81
00:03:16,818 --> 00:03:20,839
without too much effort as long as you

82
00:03:18,469 --> 00:03:22,459
obey the correct physical equations so

83
00:03:20,840 --> 00:03:26,590
that's something that's worth doing and

84
00:03:22,459 --> 00:03:29,569
some weekend we'll do that in the future

85
00:03:26,590 --> 00:03:30,560
the second thing is just making it

86
00:03:29,568 --> 00:03:34,699
properly

87
00:03:30,560 --> 00:03:36,469
sim D and parallel which is something

88
00:03:34,699 --> 00:03:38,208
that makes the speed work well and

89
00:03:36,469 --> 00:03:40,789
that's something we really want to do

90
00:03:38,209 --> 00:03:42,620
because especially once you start

91
00:03:40,789 --> 00:03:43,909
working on adding better lighting and

92
00:03:42,620 --> 00:03:46,340
that's our stuff and you want to test it

93
00:03:43,909 --> 00:03:48,469
you don't really want to sit around all

94
00:03:46,340 --> 00:03:50,299
the time waiting a long time for the

95
00:03:48,469 --> 00:03:52,818
results to see what worked and what

96
00:03:50,299 --> 00:03:55,939
didn't or any of that sort of stuff so

97
00:03:52,818 --> 00:03:58,869
we'd also like to speed up the ray

98
00:03:55,939 --> 00:04:01,159
tracing considerably if we can and

99
00:03:58,870 --> 00:04:03,230
decrease that turnaround time so

100
00:04:01,159 --> 00:04:04,039
optimization is the other one those are

101
00:04:03,229 --> 00:04:05,659
the two big ones

102
00:04:04,039 --> 00:04:07,098
and I'd like to do both of those I think

103
00:04:05,659 --> 00:04:10,459
I might do optimization today or try

104
00:04:07,098 --> 00:04:13,459
some optimization today like try to get

105
00:04:10,459 --> 00:04:16,459
threading working for example now the

106
00:04:13,459 --> 00:04:17,959
problem that we have with the third one

107
00:04:16,459 --> 00:04:19,399
which is one I probably don't want to do

108
00:04:17,959 --> 00:04:20,329
that would make this a complete ray

109
00:04:19,399 --> 00:04:23,000
tracer you could actually

110
00:04:20,329 --> 00:04:25,310
use for something is some way of loading

111
00:04:23,000 --> 00:04:29,269
real scenes and creating an actual

112
00:04:25,310 --> 00:04:31,879
spatial accelerator right and that one

113
00:04:29,269 --> 00:04:34,008
is a much more complex undertaking so

114
00:04:31,879 --> 00:04:36,800
that involves picking some kind of file

115
00:04:34,009 --> 00:04:43,400
format like you know wavefront obj files

116
00:04:36,800 --> 00:04:45,319
or I don't know some kind of an

117
00:04:43,399 --> 00:04:47,779
interchange format there's a lot of them

118
00:04:45,319 --> 00:04:49,280
out there and reading in the data from

119
00:04:47,779 --> 00:04:52,008
that which is probably gonna be triangle

120
00:04:49,279 --> 00:04:55,369
meshes or displacement meshes or

121
00:04:52,009 --> 00:04:58,788
something and then processing those into

122
00:04:55,370 --> 00:05:00,709
a ray casting format that is bin so that

123
00:04:58,788 --> 00:05:02,060
Ray's don't you know because we're gonna

124
00:05:00,709 --> 00:05:03,799
be loading like at that point

125
00:05:02,060 --> 00:05:06,288
millions of triangles or something you

126
00:05:03,800 --> 00:05:08,629
can't test every one every ray it would

127
00:05:06,288 --> 00:05:11,209
you know you'd be way too slow so you

128
00:05:08,629 --> 00:05:15,259
need an acceleration structure that that

129
00:05:11,209 --> 00:05:18,318
allows Ray's to only test triangles or

130
00:05:15,259 --> 00:05:20,449
seen elements that they may come close

131
00:05:18,319 --> 00:05:23,778
to hitting rather than all the ones in

132
00:05:20,449 --> 00:05:25,430
the scene and if we wanted to increase

133
00:05:23,778 --> 00:05:26,569
the number of spheres we would want to

134
00:05:25,430 --> 00:05:28,699
do that as well like the number of

135
00:05:26,569 --> 00:05:30,110
spheres in here is very tiny if we

136
00:05:28,699 --> 00:05:32,210
wanted to increase the number of spheres

137
00:05:30,110 --> 00:05:34,759
to you know a hundred thousand seers or

138
00:05:32,209 --> 00:05:37,788
something we would have the same concern

139
00:05:34,759 --> 00:05:39,408
right we would need to put in some kind

140
00:05:37,788 --> 00:05:40,579
of spatial hierarchy to reduce the

141
00:05:39,408 --> 00:05:42,139
number of spirit checks we have to do

142
00:05:40,579 --> 00:05:44,930
per rate test in order to make it run

143
00:05:42,139 --> 00:05:48,379
reasonably and that's a whole nother

144
00:05:44,930 --> 00:05:51,740
sort of huge undertaking that is the the

145
00:05:48,379 --> 00:05:54,169
vast vast vast majority of work in a

146
00:05:51,740 --> 00:05:56,810
real ray caster is that that is where

147
00:05:54,168 --> 00:06:00,668
the work is the work is not so much in

148
00:05:56,810 --> 00:06:04,370
the light transport parallelization

149
00:06:00,668 --> 00:06:06,588
stuff because that is just a more well

150
00:06:04,370 --> 00:06:08,750
understood it's usually the that

151
00:06:06,588 --> 00:06:11,718
bounding hierarchy building the bounding

152
00:06:08,750 --> 00:06:13,459
hierarchically you what kind of bounding

153
00:06:11,718 --> 00:06:17,149
Arkadiy is most effective usually KD

154
00:06:13,459 --> 00:06:19,128
trees how to test triangles efficiently

155
00:06:17,149 --> 00:06:21,620
with you know look them up and gather

156
00:06:19,129 --> 00:06:23,750
them quickly the ones you need to test

157
00:06:21,620 --> 00:06:25,550
how you deal with the fact that you're

158
00:06:23,750 --> 00:06:27,050
trying to do sim D but different people

159
00:06:25,550 --> 00:06:30,968
are looking at different triangle lists

160
00:06:27,050 --> 00:06:30,968
and ba-ba-ba-ba-ba it's just it's very

161
00:06:31,120 --> 00:06:35,850
it's just very much

162
00:06:33,839 --> 00:06:37,409
a serious programming undertaking once

163
00:06:35,850 --> 00:06:39,330
you bring that into it so I'll probably

164
00:06:37,410 --> 00:06:41,669
skip that part since this is not the

165
00:06:39,329 --> 00:06:43,529
main focus of handmade hero and will

166
00:06:41,668 --> 00:06:48,629
just focus on the other two which I

167
00:06:43,529 --> 00:06:50,399
think we can do relatively simply and

168
00:06:48,629 --> 00:06:52,589
I'll take the easier of the two today

169
00:06:50,399 --> 00:06:57,899
which is just figuring out how we're

170
00:06:52,589 --> 00:07:00,509
going to do some sort of optimization

171
00:06:57,899 --> 00:07:02,789
for this so if you take a look at what's

172
00:07:00,509 --> 00:07:04,709
going on here in the code you can see

173
00:07:02,790 --> 00:07:06,270
already you know the slowness of it is

174
00:07:04,709 --> 00:07:08,759
largely becoming from this race per

175
00:07:06,269 --> 00:07:11,069
pixel because if we set the Rays per

176
00:07:08,759 --> 00:07:13,168
pixel to one it would finish almost

177
00:07:11,069 --> 00:07:15,089
immediately right and you can see the

178
00:07:13,168 --> 00:07:17,370
problem of having raised per pixel up

179
00:07:15,089 --> 00:07:20,069
being one and that is that we don't get

180
00:07:17,370 --> 00:07:23,310
enough samples to really get a smooth

181
00:07:20,069 --> 00:07:25,139
image now we get roughly a correct image

182
00:07:23,310 --> 00:07:27,209
right I mean we are producing something

183
00:07:25,139 --> 00:07:30,410
that looks reasonable because you know

184
00:07:27,209 --> 00:07:32,909
one ray does produce a reasonable result

185
00:07:30,410 --> 00:07:35,939
but it's just not a smooth nice

186
00:07:32,910 --> 00:07:38,250
continuous image like we would like and

187
00:07:35,939 --> 00:07:40,589
there are a lot of ways of producing

188
00:07:38,250 --> 00:07:43,139
better results even from lower sampling

189
00:07:40,589 --> 00:07:45,029
rates and that's something we can look

190
00:07:43,139 --> 00:07:47,310
into in terms of when we go to start

191
00:07:45,029 --> 00:07:48,959
doing the lighting sampling and stuff

192
00:07:47,310 --> 00:07:50,939
like that there's ways of using better

193
00:07:48,959 --> 00:07:54,120
reconstruction from the samples that you

194
00:07:50,939 --> 00:07:55,228
do take and also in in figure out how

195
00:07:54,120 --> 00:07:56,939
you take your samples

196
00:07:55,228 --> 00:07:58,589
there are ways you can improve the

197
00:07:56,939 --> 00:08:02,519
quality without improving the number of

198
00:07:58,589 --> 00:08:03,839
rays and so again when we start to look

199
00:08:02,519 --> 00:08:05,728
at material stuff that's something we

200
00:08:03,839 --> 00:08:07,259
can look at as well but for right now

201
00:08:05,728 --> 00:08:08,339
what we want to do is just set up the

202
00:08:07,259 --> 00:08:10,348
structure of our program a little bit

203
00:08:08,339 --> 00:08:12,598
better so that we're getting more

204
00:08:10,348 --> 00:08:14,159
performance in terms of just how many

205
00:08:12,598 --> 00:08:17,038
rays we do take so for example if I

206
00:08:14,160 --> 00:08:19,740
raise 4 pixel 1 and I switch to raise 4

207
00:08:17,038 --> 00:08:21,269
pixel being 8 you can see that the

208
00:08:19,740 --> 00:08:24,360
difference in speed is already pretty

209
00:08:21,269 --> 00:08:26,370
dramatic right and you know it's

210
00:08:24,360 --> 00:08:28,348
probably roughly eight times slower now

211
00:08:26,370 --> 00:08:30,180
how much slower is it well it would be

212
00:08:28,348 --> 00:08:31,800
nice if we actually knew how much slower

213
00:08:30,180 --> 00:08:33,778
it was so I think what I'm probably

214
00:08:31,800 --> 00:08:36,870
gonna do here is I'm gonna first

215
00:08:33,778 --> 00:08:40,439
introduce a timer so we can actually see

216
00:08:36,870 --> 00:08:42,570
how long we're taking as we go now

217
00:08:40,440 --> 00:08:44,430
because we're timing an entire ray cast

218
00:08:42,570 --> 00:08:47,670
we don't really have to appeal to

219
00:08:44,429 --> 00:08:51,929
Windows functions yet we can use a low

220
00:08:47,669 --> 00:08:54,629
great timer so we can take a look at the

221
00:08:51,929 --> 00:08:56,429
C runtime library again and look at the

222
00:08:54,629 --> 00:08:57,750
functions involved there and see if

223
00:08:56,429 --> 00:08:58,529
there are any that will be good enough

224
00:08:57,750 --> 00:09:00,899
for us

225
00:08:58,529 --> 00:09:03,449
so for example the time function is one

226
00:09:00,899 --> 00:09:05,970
that's available everywhere and this

227
00:09:03,450 --> 00:09:08,640
returns the number of seconds elapsed

228
00:09:05,970 --> 00:09:10,680
for example so we could get the number

229
00:09:08,639 --> 00:09:12,750
of seconds elapsed pretty easily from

230
00:09:10,679 --> 00:09:14,519
the C runtime library and if since our

231
00:09:12,750 --> 00:09:17,490
things takes it tend to take multiple

232
00:09:14,519 --> 00:09:19,399
seconds that could be enough there's

233
00:09:17,490 --> 00:09:22,230
also other functions that might be

234
00:09:19,399 --> 00:09:23,789
reasonable that could give us a little

235
00:09:22,230 --> 00:09:26,279
bit more resolution unfortunately don't

236
00:09:23,789 --> 00:09:30,480
know how many of them are portable for

237
00:09:26,279 --> 00:09:33,059
example the you time functions I'm not

238
00:09:30,480 --> 00:09:35,759
sure that's not what I wanted the you

239
00:09:33,059 --> 00:09:38,750
time functions are 4 files do we have

240
00:09:35,759 --> 00:09:47,429
anything slightly better time management

241
00:09:38,750 --> 00:09:50,190
clock so clock is clocks per second

242
00:09:47,429 --> 00:09:53,669
which might be reasonable let's just

243
00:09:50,190 --> 00:09:57,810
take a look at what it is that may give

244
00:09:53,669 --> 00:10:08,399
us a little bit better resolution here

245
00:09:57,809 --> 00:10:11,250
we go let's do a printf here per sec I

246
00:10:08,399 --> 00:10:13,470
don't know what clock is per second what

247
00:10:11,250 --> 00:10:15,679
the clock T value is actually defined to

248
00:10:13,470 --> 00:10:15,680
be

249
00:10:22,960 --> 00:10:28,089
so I'm not sure exactly how I would

250
00:10:25,240 --> 00:10:30,519
print it out but what I can do here if

251
00:10:28,089 --> 00:10:31,930
we want to is I could find clocks for a

252
00:10:30,519 --> 00:10:32,620
second and in fact why don't I just go

253
00:10:31,929 --> 00:10:36,429
ahead and do that

254
00:10:32,620 --> 00:10:39,549
so if i open up ms dev actually we have

255
00:10:36,429 --> 00:10:43,539
a project that we had created for this

256
00:10:39,549 --> 00:10:45,129
purpose but i think it's we didn't copy

257
00:10:43,539 --> 00:10:47,860
it to the new machine i'm just gonna

258
00:10:45,129 --> 00:10:51,299
create a Windows desktop application

259
00:10:47,860 --> 00:10:54,490
here using the stupid application wizard

260
00:10:51,299 --> 00:10:57,250
and I don't care where it puts it so

261
00:10:54,490 --> 00:10:59,709
this is in Windows project 1 in some

262
00:10:57,250 --> 00:11:01,419
users KC source repos I don't care I

263
00:10:59,708 --> 00:11:03,369
don't care where the stupid wizard puts

264
00:11:01,419 --> 00:11:05,049
it it doesn't matter all I want to do is

265
00:11:03,370 --> 00:11:07,000
get the Browse info thing working that

266
00:11:05,049 --> 00:11:09,250
this thing builds by default right and

267
00:11:07,000 --> 00:11:12,519
so what I can do here is I can say clock

268
00:11:09,250 --> 00:11:16,330
T in this project right why is it

269
00:11:12,519 --> 00:11:17,919
capitalizing that like so and then if I

270
00:11:16,330 --> 00:11:19,629
take a look at this I should be able to

271
00:11:17,919 --> 00:11:21,490
do a go to definition now it can't

272
00:11:19,629 --> 00:11:23,259
locate it but I assume that's just

273
00:11:21,490 --> 00:11:23,860
because I haven't included the right

274
00:11:23,259 --> 00:11:25,809
file

275
00:11:23,860 --> 00:11:29,200
so if we take a look at what it requires

276
00:11:25,809 --> 00:11:31,469
4 o'clock tea where was that I had that

277
00:11:29,200 --> 00:11:33,550
a minute ago

278
00:11:31,470 --> 00:11:36,850
here it is

279
00:11:33,549 --> 00:11:38,949
I assume yeah it's just in time dot H I

280
00:11:36,850 --> 00:11:42,550
assume that if I just put time dot H in

281
00:11:38,950 --> 00:11:44,500
here right as an include file and and

282
00:11:42,549 --> 00:11:47,469
save that then it should be able to find

283
00:11:44,500 --> 00:11:48,789
this and hey lo and behold it does so if

284
00:11:47,470 --> 00:11:50,200
we take a look at it it's just a long

285
00:11:48,789 --> 00:11:53,289
value which means I can print it out

286
00:11:50,200 --> 00:11:55,900
with a % D just fine so if I come back

287
00:11:53,289 --> 00:11:58,149
here to our Rea program I should be able

288
00:11:55,899 --> 00:12:00,819
to run it and see what the clocks per

289
00:11:58,149 --> 00:12:02,919
second is now I'm getting the same error

290
00:12:00,820 --> 00:12:07,440
here but that's like rather obvious why

291
00:12:02,919 --> 00:12:10,539
I need that was it called time that H I

292
00:12:07,440 --> 00:12:15,959
need that time that H so you can see

293
00:12:10,539 --> 00:12:19,000
that the clocks per second it looks like

294
00:12:15,958 --> 00:12:21,129
there's a thousand clocks per second

295
00:12:19,000 --> 00:12:23,889
that means it's a millisecond clock that

296
00:12:21,129 --> 00:12:26,799
is fine for our purposes right because

297
00:12:23,889 --> 00:12:27,669
we're timing huge loops here so the fact

298
00:12:26,799 --> 00:12:31,689
that this is a fairly low-resolution

299
00:12:27,669 --> 00:12:33,490
timer I don't care I'm totally fine with

300
00:12:31,690 --> 00:12:36,500
that that will be fine for our purposes

301
00:12:33,490 --> 00:12:38,090
and it will remain platform-independent

302
00:12:36,500 --> 00:12:40,820
I'm kind of trying to do on this project

303
00:12:38,090 --> 00:12:44,330
so that we don't have to have additional

304
00:12:40,820 --> 00:12:45,530
libraries or anything involved how we're

305
00:12:44,330 --> 00:12:47,060
gonna do threading that way I don't know

306
00:12:45,529 --> 00:12:49,519
I don't really want to use standard

307
00:12:47,059 --> 00:12:51,289
thread but maybe we might have to that's

308
00:12:49,519 --> 00:12:56,960
gonna be the worst thing that's ever

309
00:12:51,289 --> 00:12:59,929
happened to me but okay so if we take a

310
00:12:56,960 --> 00:13:02,180
look at the start time here it looks

311
00:12:59,929 --> 00:13:05,329
like we could just get this by calling

312
00:13:02,179 --> 00:13:09,620
clock like so and then we can make an

313
00:13:05,330 --> 00:13:16,930
end time by calling clock here and then

314
00:13:09,620 --> 00:13:19,700
we can just sort of go through this as

315
00:13:16,929 --> 00:13:22,219
we start our loop we can just go through

316
00:13:19,700 --> 00:13:24,590
the loop and we'll ignore it like the

317
00:13:22,220 --> 00:13:26,509
right image time so as we get a start

318
00:13:24,590 --> 00:13:29,050
and end and maybe I'll call these start

319
00:13:26,509 --> 00:13:29,049
and end clock

320
00:13:31,639 --> 00:13:36,100
there's our start clock there's our end

321
00:13:33,379 --> 00:13:39,100
clock what I should be able to do is say

322
00:13:36,100 --> 00:13:39,100
okay

323
00:13:45,940 --> 00:13:50,180
here's the number of milliseconds that

324
00:13:48,169 --> 00:13:56,240
this took let me go to the other pane

325
00:13:50,179 --> 00:13:59,750
here so we're not getting up into the

326
00:13:56,240 --> 00:14:02,389
KC's head area if I take the end clock

327
00:13:59,750 --> 00:14:03,620
and the start clock and difference them

328
00:14:02,389 --> 00:14:06,319
together I should get how many

329
00:14:03,620 --> 00:14:10,399
milliseconds it took it to do the rate

330
00:14:06,320 --> 00:14:12,740
casting right and so you know there's

331
00:14:10,399 --> 00:14:14,539
the image it looks like it took two

332
00:14:12,740 --> 00:14:16,399
thousand fifty nine milliseconds so

333
00:14:14,539 --> 00:14:18,169
that's a pretty easy way for us to

334
00:14:16,399 --> 00:14:20,899
determine how long it took and

335
00:14:18,169 --> 00:14:24,139
furthermore what I could do is count the

336
00:14:20,899 --> 00:14:33,230
bounces so if I introduce here some kind

337
00:14:24,139 --> 00:14:37,399
of a global variable I'm just going to

338
00:14:33,230 --> 00:14:39,620
define global variable term they're not

339
00:14:37,399 --> 00:14:41,509
just again so I can see it if I

340
00:14:39,620 --> 00:14:44,899
introduce a global variable here that's

341
00:14:41,509 --> 00:14:53,958
like how many Rays have I cast I'm gonna

342
00:14:44,899 --> 00:14:55,190
say like so well you know what I don't

343
00:14:53,958 --> 00:14:58,039
even have to make it a global I could

344
00:14:55,190 --> 00:15:00,790
just put it in the world actually all

345
00:14:58,039 --> 00:15:00,789
right let's just do that

346
00:15:06,778 --> 00:15:12,749
if I go ahead and accumulate how many

347
00:15:09,480 --> 00:15:14,339
rays are cast then I can have some idea

348
00:15:12,749 --> 00:15:17,129
of what's going on right so if I come in

349
00:15:14,339 --> 00:15:20,220
here and say every time I enter this

350
00:15:17,129 --> 00:15:27,028
loop I'm casting array not so I will go

351
00:15:20,220 --> 00:15:29,428
world raised cast we can say how many or

352
00:15:27,028 --> 00:15:37,129
I should say like bounces computed or

353
00:15:29,428 --> 00:15:37,129
like let's call it that

354
00:15:44,339 --> 00:15:52,860
so I need some way of printing this out

355
00:15:48,629 --> 00:15:56,188
and in general I always forget that I

356
00:15:52,860 --> 00:16:00,629
think it's L LD or ll you I guess for a

357
00:15:56,188 --> 00:16:01,289
long for a you 64 I don't really

358
00:16:00,629 --> 00:16:05,699
remember

359
00:16:01,289 --> 00:16:11,159
let's take a look also let me let me go

360
00:16:05,698 --> 00:16:16,798
ahead and grab from handmade here of the

361
00:16:11,159 --> 00:16:19,230
you 64 definition I think it's standard

362
00:16:16,798 --> 00:16:20,879
def that has these in there well I

363
00:16:19,230 --> 00:16:23,909
forgot about standard def this whole

364
00:16:20,879 --> 00:16:25,230
time I actually defined these myself but

365
00:16:23,909 --> 00:16:27,808
I didn't really need to because we are

366
00:16:25,230 --> 00:16:29,759
using the standard library so I guess I

367
00:16:27,808 --> 00:16:33,318
shouldn't have bothered with that I

368
00:16:29,759 --> 00:16:33,318
guess I could have just done

369
00:16:33,509 --> 00:16:45,808
you win 8 t can I do that now you at 16

370
00:16:40,798 --> 00:16:52,619
T 32 T you are

371
00:16:45,808 --> 00:16:57,600
oops into 8 T in 16 T 15 I forgot about

372
00:16:52,619 --> 00:17:00,809
this so I don't need to change that one

373
00:16:57,600 --> 00:17:02,278
so yeah in theory I can just make 64-bit

374
00:17:00,808 --> 00:17:05,548
types here without having to do anything

375
00:17:02,278 --> 00:17:07,140
fancy and then we can count the total

376
00:17:05,548 --> 00:17:12,439
number of rays even if that number Co

377
00:17:07,140 --> 00:17:12,439
comes very high in theory oops

378
00:17:12,929 --> 00:17:26,519
what is this complaining about doesn't

379
00:17:22,349 --> 00:17:40,158
standard F include these did I mess

380
00:17:26,519 --> 00:17:42,648
something up oh it's standard int my bad

381
00:17:40,159 --> 00:17:45,480
there we go

382
00:17:42,648 --> 00:17:48,209
all right so let's see where we're at

383
00:17:45,480 --> 00:17:50,460
here let me go ahead and finish this up

384
00:17:48,210 --> 00:17:52,880
there we go

385
00:17:50,460 --> 00:17:55,230
so now we should get a thing that says

386
00:17:52,880 --> 00:17:57,528
how many bounces we have don't ask me

387
00:17:55,230 --> 00:18:01,288
why the millisecond number is in there

388
00:17:57,528 --> 00:18:07,278
here's how many bounces we did here's

389
00:18:01,288 --> 00:18:07,278
how many rays we cast put this in here

390
00:18:07,398 --> 00:18:14,668
cleaner so now we can print out the

391
00:18:11,669 --> 00:18:24,840
number of milliseconds per bounce or

392
00:18:14,669 --> 00:18:30,509
something similar right so you know the

393
00:18:24,839 --> 00:18:35,548
performance was you know point something

394
00:18:30,509 --> 00:18:41,908
milliseconds per bounce so if I go ahead

395
00:18:35,548 --> 00:18:49,250
and say all right we've got a a total

396
00:18:41,909 --> 00:18:49,250
time like so

397
00:18:52,038 --> 00:18:56,250
so we've got a time elapsed this is the

398
00:18:54,659 --> 00:19:00,000
number of milliseconds that have elapsed

399
00:18:56,250 --> 00:19:02,849
and then we want to take how many

400
00:19:00,000 --> 00:19:04,200
milliseconds per bounce I just divide

401
00:19:02,849 --> 00:19:06,388
the number of milliseconds by the number

402
00:19:04,200 --> 00:19:07,710
of bounces I'm gonna cast them to double

403
00:19:06,388 --> 00:19:10,528
so that we'll get a fret that's going to

404
00:19:07,710 --> 00:19:19,558
be a fractional number then we should be

405
00:19:10,528 --> 00:19:21,509
good to go so there we go

406
00:19:19,558 --> 00:19:24,829
so now we can sort of see how many

407
00:19:21,509 --> 00:19:24,829
milliseconds for bounce we're taking

408
00:19:25,190 --> 00:19:31,379
right in our goal obviously is to drive

409
00:19:29,909 --> 00:19:35,129
that number as low as possible as well

410
00:19:31,378 --> 00:19:37,288
as the total recasting time as well now

411
00:19:35,128 --> 00:19:39,119
in theory that milliseconds for bounce

412
00:19:37,288 --> 00:19:41,099
numbers should remain relatively

413
00:19:39,119 --> 00:19:43,258
constant I mean it's not going to be

414
00:19:41,099 --> 00:19:46,408
perfect but for example if I was to

415
00:19:43,259 --> 00:19:49,349
crank up the number of rays to pixel 216

416
00:19:46,409 --> 00:19:52,019
you know here's the number of bounces

417
00:19:49,349 --> 00:19:57,719
we've had so far right so you know roll

418
00:19:52,019 --> 00:20:01,620
ups we're looking at this number if I

419
00:19:57,720 --> 00:20:04,649
recompile it and rerun a slower one you

420
00:20:01,619 --> 00:20:06,719
know the total time will change right it

421
00:20:04,648 --> 00:20:09,109
doubled roughly but you can see that the

422
00:20:06,720 --> 00:20:13,019
performance number was pretty darn

423
00:20:09,109 --> 00:20:15,658
consistent right so as I you know

424
00:20:13,019 --> 00:20:18,388
increase the number of rays I can make

425
00:20:15,659 --> 00:20:20,519
the total time slow down but if we just

426
00:20:18,388 --> 00:20:23,128
look at how long it's taking us in

427
00:20:20,519 --> 00:20:24,720
general per bounce that number should be

428
00:20:23,128 --> 00:20:26,908
roughly the same you can see that it

429
00:20:24,720 --> 00:20:28,589
does and that's why I divided those out

430
00:20:26,909 --> 00:20:30,059
was just because we're a little bit

431
00:20:28,589 --> 00:20:32,250
early in the process here but it just

432
00:20:30,058 --> 00:20:34,980
gives me a starting number I can look at

433
00:20:32,250 --> 00:20:37,079
to see you know whether I'm making some

434
00:20:34,980 --> 00:20:37,829
progress or not and driving that number

435
00:20:37,079 --> 00:20:40,230
down

436
00:20:37,829 --> 00:20:42,918
I can fuss with different things here

437
00:20:40,230 --> 00:20:45,690
and change which images we're creating

438
00:20:42,919 --> 00:20:48,929
without having a huge effect on that

439
00:20:45,690 --> 00:20:50,278
number which is good so that way I know

440
00:20:48,929 --> 00:20:52,620
whether you know I have a sort of a

441
00:20:50,278 --> 00:20:54,859
stable version of the performance there

442
00:20:52,619 --> 00:20:57,869
okay

443
00:20:54,859 --> 00:21:00,689
so let's start by taking a look at how

444
00:20:57,869 --> 00:21:03,538
these loops are working here we are

445
00:21:00,690 --> 00:21:04,419
already compiling in release mode to a

446
00:21:03,538 --> 00:21:06,970
certain extent and

447
00:21:04,419 --> 00:21:10,269
way and you know we don't need these

448
00:21:06,970 --> 00:21:11,649
handmade defines in there because

449
00:21:10,269 --> 00:21:14,649
there's no there's none of that that's

450
00:21:11,648 --> 00:21:16,238
happening now so you know we're already

451
00:21:14,648 --> 00:21:19,268
compiling in release mode so we're

452
00:21:16,239 --> 00:21:20,739
already getting some performance the

453
00:21:19,269 --> 00:21:22,440
compiler is already doing some basic

454
00:21:20,739 --> 00:21:24,608
stuff here for us and that's all good

455
00:21:22,440 --> 00:21:26,970
but you know there's a bunch of stuff

456
00:21:24,608 --> 00:21:29,769
that we need to start thinking about now

457
00:21:26,970 --> 00:21:31,298
in terms of what we want to do so the

458
00:21:29,769 --> 00:21:33,638
first thing I'd like to do is I'd like

459
00:21:31,298 --> 00:21:37,058
to break this up into chunk in chunks

460
00:21:33,638 --> 00:21:39,219
right I'd like to be able to in a little

461
00:21:37,058 --> 00:21:40,690
bit hand this off to let's say I think

462
00:21:39,220 --> 00:21:43,480
this machine handles eight threads

463
00:21:40,690 --> 00:21:44,919
simultaneously if I remember correctly

464
00:21:43,480 --> 00:21:47,528
let's take a look

465
00:21:44,919 --> 00:21:51,399
change graph to logical processors so

466
00:21:47,528 --> 00:21:53,829
this is a 777 hundred K it's a four core

467
00:21:51,398 --> 00:21:56,949
machine each core has two hyper threads

468
00:21:53,829 --> 00:22:00,189
that's why you're seeing an eight wide

469
00:21:56,950 --> 00:22:01,869
graph here and hyper threads in our case

470
00:22:00,190 --> 00:22:05,019
may or may not help the performance

471
00:22:01,868 --> 00:22:08,349
significantly to be honest I don't I'm

472
00:22:05,019 --> 00:22:11,319
not super familiar with the 7700 K core

473
00:22:08,349 --> 00:22:13,888
i7 I don't know to what extent

474
00:22:11,319 --> 00:22:16,960
ray-tracing is going to saturate the

475
00:22:13,888 --> 00:22:20,319
arithmetic units on a single core we are

476
00:22:16,960 --> 00:22:22,960
not under memory pressure right now we

477
00:22:20,319 --> 00:22:25,298
are not only not modifying any memory at

478
00:22:22,960 --> 00:22:27,399
all but we have very little memory to

479
00:22:25,298 --> 00:22:29,319
read so all of its gonna pretty much fit

480
00:22:27,398 --> 00:22:31,569
in a very small cache it'll probably

481
00:22:29,319 --> 00:22:33,460
just stay in l1 the entire time would be

482
00:22:31,569 --> 00:22:37,058
my guess the only thing that wouldn't

483
00:22:33,460 --> 00:22:39,220
was is the output image itself so you

484
00:22:37,058 --> 00:22:41,470
know I think we're looking at a

485
00:22:39,220 --> 00:22:42,639
situation where we're probably gonna be

486
00:22:41,470 --> 00:22:44,499
able to get the memory traffic down

487
00:22:42,638 --> 00:22:46,058
quite a bit which means that the hyper

488
00:22:44,499 --> 00:22:47,858
threads are not going to be covering for

489
00:22:46,058 --> 00:22:51,190
latency bubbles one of the things that

490
00:22:47,858 --> 00:22:53,019
hyper threats often do is hyper threads

491
00:22:51,190 --> 00:22:56,379
will allow you to cover long memory

492
00:22:53,019 --> 00:23:00,038
latency bubbles by giving you know one

493
00:22:56,378 --> 00:23:01,689
thread will will execute inside the

494
00:23:00,038 --> 00:23:03,849
other threads memory bubble well it's

495
00:23:01,690 --> 00:23:05,798
waiting for some memory to come in the

496
00:23:03,849 --> 00:23:08,888
other thread could execute and use the

497
00:23:05,798 --> 00:23:09,999
ALUs and whatever during that time we're

498
00:23:08,888 --> 00:23:13,058
probably not gonna get much of that

499
00:23:09,999 --> 00:23:15,700
because we don't have very much to read

500
00:23:13,058 --> 00:23:18,129
from in a ray tracer that actually was

501
00:23:15,700 --> 00:23:21,038
using a real scene we absolutely would

502
00:23:18,130 --> 00:23:22,990
because a lot of that time is pulling in

503
00:23:21,038 --> 00:23:25,210
stuff from the bounding volume hierarchy

504
00:23:22,990 --> 00:23:27,700
and getting new triangles into rate cast

505
00:23:25,210 --> 00:23:30,730
against so that is not necessarily the

506
00:23:27,700 --> 00:23:32,470
case in a flow rate tracer so to take

507
00:23:30,730 --> 00:23:34,269
that the grain of salt but in our case

508
00:23:32,470 --> 00:23:37,450
we're mostly talking about trying to use

509
00:23:34,269 --> 00:23:38,859
the Ale use I think and so I don't know

510
00:23:37,450 --> 00:23:40,480
whether or not we will really be getting

511
00:23:38,859 --> 00:23:43,979
much mileage out of it or not we will

512
00:23:40,480 --> 00:23:46,960
find out as we go so we'll see but

513
00:23:43,980 --> 00:23:48,279
either way even if we weren't gonna get

514
00:23:46,960 --> 00:23:49,569
anything out of hyper threads at all and

515
00:23:48,279 --> 00:23:51,009
determined that they we wouldn't which

516
00:23:49,569 --> 00:23:52,269
is probably not a case but let's say we

517
00:23:51,009 --> 00:23:55,269
completely weren't able to down the high

518
00:23:52,269 --> 00:23:59,440
scratch we still want four threads

519
00:23:55,269 --> 00:24:01,750
operating at the same time right we want

520
00:23:59,440 --> 00:24:05,380
to have four threads doing things at the

521
00:24:01,750 --> 00:24:07,450
same time now there's a couple different

522
00:24:05,380 --> 00:24:09,909
ways that we might want to do this and

523
00:24:07,450 --> 00:24:11,700
again it's a little bit tricky to think

524
00:24:09,909 --> 00:24:16,840
through exactly how we want to do it

525
00:24:11,700 --> 00:24:18,640
because as we go a little further in how

526
00:24:16,839 --> 00:24:20,019
we're gonna do the ray tracing and so on

527
00:24:18,640 --> 00:24:22,179
we don't know whether or not we really

528
00:24:20,019 --> 00:24:23,859
want to separate out into pieces of the

529
00:24:22,179 --> 00:24:26,320
image or not I suspect though that we

530
00:24:23,859 --> 00:24:28,329
probably do so I think what we probably

531
00:24:26,319 --> 00:24:30,849
want to do is just divide the image up

532
00:24:28,329 --> 00:24:32,230
into little chunks and possibly if we're

533
00:24:30,849 --> 00:24:34,029
gonna be operating on those chunks

534
00:24:32,230 --> 00:24:36,069
repeatedly and summing together the

535
00:24:34,029 --> 00:24:38,440
results we may even want to make the

536
00:24:36,069 --> 00:24:41,710
chunks small enough that that the output

537
00:24:38,440 --> 00:24:45,759
stays inside of the cache so for example

538
00:24:41,710 --> 00:24:50,950
the l1 cache is 256 K if we were summing

539
00:24:45,759 --> 00:24:52,839
up samples in there we may want to try

540
00:24:50,950 --> 00:24:54,340
doing if we're out putting them

541
00:24:52,839 --> 00:24:56,500
successively we may want to try to keep

542
00:24:54,339 --> 00:24:58,750
the size small right now we're just

543
00:24:56,500 --> 00:25:01,119
summing we're doing an entire pixel

544
00:24:58,750 --> 00:25:03,548
completely first rather than producing

545
00:25:01,119 --> 00:25:05,678
out intermediate output images as a

546
00:25:03,548 --> 00:25:06,970
preview to the user so right now we

547
00:25:05,679 --> 00:25:08,500
don't really have to care about that and

548
00:25:06,970 --> 00:25:10,000
we know that we're not having any cache

549
00:25:08,500 --> 00:25:12,880
problems at all I think cuz it's really

550
00:25:10,000 --> 00:25:14,470
just nothing to load so I don't know

551
00:25:12,880 --> 00:25:16,840
first things first I'm just gonna divide

552
00:25:14,470 --> 00:25:20,589
us up into some tiles to do so that

553
00:25:16,839 --> 00:25:22,869
basically every CPU core can have its

554
00:25:20,589 --> 00:25:26,558
own tile that's completely separate for

555
00:25:22,869 --> 00:25:30,959
anyone else's tile right so that's what

556
00:25:26,558 --> 00:25:33,210
I'd like to do now and because

557
00:25:30,960 --> 00:25:34,380
I'm gonna do this in a way that's more

558
00:25:33,210 --> 00:25:36,390
like what you would do in a real

559
00:25:34,380 --> 00:25:37,919
raytracer rather than take advantage of

560
00:25:36,390 --> 00:25:39,899
the fact that we don't have a bounding

561
00:25:37,919 --> 00:25:42,330
volume Hart gate normally what you would

562
00:25:39,898 --> 00:25:44,038
do is you use tiles that are square

563
00:25:42,329 --> 00:25:46,710
shaped and the reason for that is

564
00:25:44,038 --> 00:25:50,339
because you assume that the kind of

565
00:25:46,710 --> 00:25:52,890
traversal through the grid the bounding

566
00:25:50,339 --> 00:25:55,019
valve our key will be more coherent in a

567
00:25:52,890 --> 00:25:58,919
square than in a row if I just gave

568
00:25:55,019 --> 00:26:00,960
every CPU a row because you figured that

569
00:25:58,919 --> 00:26:02,399
rays cast in a similar direction will

570
00:26:00,960 --> 00:26:04,919
hit similar things and bounce and

571
00:26:02,398 --> 00:26:06,869
similar ways prohibit entually now

572
00:26:04,919 --> 00:26:08,970
that's only true to a certain extent

573
00:26:06,869 --> 00:26:10,319
when you have a lot of diffuse surfaces

574
00:26:08,970 --> 00:26:12,659
rays tend to bounce in all directions

575
00:26:10,319 --> 00:26:14,849
and that doesn't always happen but you

576
00:26:12,659 --> 00:26:16,350
still will probably get more in a square

577
00:26:14,849 --> 00:26:18,509
than you would otherwise although it

578
00:26:16,349 --> 00:26:19,918
won't be that much more as it is if

579
00:26:18,509 --> 00:26:23,398
everything was perfectly coherent

580
00:26:19,919 --> 00:26:26,190
obviously so anyway sorry to dump too

581
00:26:23,398 --> 00:26:27,209
much information on you there anyway so

582
00:26:26,190 --> 00:26:29,840
what I'm gonna do here is I'm just gonna

583
00:26:27,210 --> 00:26:34,470
break this up into a couple different

584
00:26:29,839 --> 00:26:37,139
tiles so what I want to do here is I

585
00:26:34,470 --> 00:26:40,940
want to introduce a function that I can

586
00:26:37,140 --> 00:26:45,360
do which is sort of like render tile

587
00:26:40,940 --> 00:26:49,048
right and that will take one of these

588
00:26:45,359 --> 00:26:53,158
saucy fellows here where I you know will

589
00:26:49,048 --> 00:27:03,000
sort of grab you know this sort of thing

590
00:26:53,159 --> 00:27:07,320
like this I and we want this render tile

591
00:27:03,000 --> 00:27:09,898
function to take the range for X&amp;Y that

592
00:27:07,319 --> 00:27:12,178
it's actually going to use and it's

593
00:27:09,898 --> 00:27:14,099
going to need to be smarter about how it

594
00:27:12,179 --> 00:27:17,309
writes to the output value because of

595
00:27:14,099 --> 00:27:19,889
that right this line can stay the same

596
00:27:17,308 --> 00:27:23,009
because X outputs will march along it

597
00:27:19,890 --> 00:27:26,940
uniformly but Y outputs will have to do

598
00:27:23,009 --> 00:27:30,359
something different right so we need to

599
00:27:26,940 --> 00:27:32,519
do to make that change as well so for

600
00:27:30,359 --> 00:27:37,609
example where is the output pixels line

601
00:27:32,519 --> 00:27:37,609
here it's somewhere

602
00:27:39,880 --> 00:27:45,890
right here so this line will have to

603
00:27:44,180 --> 00:27:48,950
change but everything else could

604
00:27:45,890 --> 00:27:51,759
probably say the same all right so what

605
00:27:48,950 --> 00:27:57,080
I want to pass in here is like the Y min

606
00:27:51,759 --> 00:28:01,359
and the Y count and the x-men and the X

607
00:27:57,079 --> 00:28:01,359
count something like this

608
00:28:04,369 --> 00:28:15,919
and I might do this maybe I'll do this

609
00:28:06,230 --> 00:28:21,650
like like this and I also want to pass

610
00:28:15,920 --> 00:28:25,220
in the image that we're going to write

611
00:28:21,650 --> 00:28:27,380
to and the world so I'm gonna say

612
00:28:25,220 --> 00:28:29,480
raycast this world into this image and I

613
00:28:27,380 --> 00:28:32,120
want you to just do this tile right so

614
00:28:29,480 --> 00:28:34,309
this Y here is actually going to be like

615
00:28:32,119 --> 00:28:37,369
hey start from Y min or actually I guess

616
00:28:34,309 --> 00:28:38,990
that won't quite do it that way you know

617
00:28:37,369 --> 00:28:41,259
what why don't I just do this fine do Y

618
00:28:38,990 --> 00:28:41,259
min

619
00:28:51,740 --> 00:28:55,220
so do it like this

620
00:28:57,829 --> 00:29:02,819
so this will basically say let's do a

621
00:28:59,970 --> 00:29:05,370
subset of the image again the X will

622
00:29:02,819 --> 00:29:07,139
work just fine inside gets loop but the

623
00:29:05,369 --> 00:29:09,539
outer Y loop is going to have to have

624
00:29:07,140 --> 00:29:11,309
some specificity to it so the first

625
00:29:09,539 --> 00:29:14,240
thing we need to do is we probably want

626
00:29:11,308 --> 00:29:18,240
to do a thing that's like get pixel

627
00:29:14,240 --> 00:29:20,220
pointer and we want to say like hey give

628
00:29:18,240 --> 00:29:22,410
me the pixel pointer at this location

629
00:29:20,220 --> 00:29:24,419
and that'll move the pixel pointer to

630
00:29:22,410 --> 00:29:26,880
the right place for that

631
00:29:24,419 --> 00:29:30,720
x and y min and then what we need to do

632
00:29:26,880 --> 00:29:32,340
is every time we do the Y we got a go

633
00:29:30,720 --> 00:29:34,169
and you know what we we probably don't

634
00:29:32,339 --> 00:29:36,178
need to be to it because the inner loop

635
00:29:34,169 --> 00:29:37,710
is gonna be so costly it's okay we can

636
00:29:36,179 --> 00:29:40,410
probably just use get pixel pointer here

637
00:29:37,710 --> 00:29:43,470
where we say all right get the wat X min

638
00:29:40,410 --> 00:29:45,419
and the Y that we're on right now just

639
00:29:43,470 --> 00:29:48,660
give me that out planar and then I'll

640
00:29:45,419 --> 00:29:50,520
you know increment along it right all of

641
00:29:48,660 --> 00:29:52,380
these equations should in theory now

642
00:29:50,519 --> 00:29:56,900
stay the same there shouldn't be

643
00:29:52,380 --> 00:29:56,900
anything weird going on there at all and

644
00:29:57,619 --> 00:30:05,959
so if I go up here and just implement

645
00:30:00,058 --> 00:30:05,960
this get pixel pointer function

646
00:30:17,549 --> 00:30:23,319
what I should be able to do is just

647
00:30:21,369 --> 00:30:24,869
compute where the pointer would be in

648
00:30:23,319 --> 00:30:27,429
the image so I know I have an image

649
00:30:24,869 --> 00:30:29,799
here's the pixel pointer to the image I

650
00:30:27,430 --> 00:30:32,289
know that I want to go xpick CIL's in

651
00:30:29,799 --> 00:30:34,899
and I know that I want to go Y pixels up

652
00:30:32,289 --> 00:30:37,569
right so I just need to multiply by the

653
00:30:34,900 --> 00:30:39,460
width to move me up Y pixels that number

654
00:30:37,569 --> 00:30:41,859
of rows and then just use the X I'd

655
00:30:39,460 --> 00:30:43,480
probably write it this way just to get

656
00:30:41,859 --> 00:30:45,189
me to the right X right but that should

657
00:30:43,480 --> 00:30:52,120
give me a pixel anywhere in the image

658
00:30:45,190 --> 00:30:53,680
and off we go now sorry what is this

659
00:30:52,119 --> 00:30:56,019
complaining about left two pixels

660
00:30:53,680 --> 00:31:00,910
must have a oops that's what I didn't

661
00:30:56,019 --> 00:31:06,430
want that there there we go in fact I

662
00:31:00,910 --> 00:31:07,840
can just do this and we need some of

663
00:31:06,430 --> 00:31:11,980
these other values to be computed in

664
00:31:07,839 --> 00:31:14,829
here so 1/2 pix w that sort of stuff all

665
00:31:11,980 --> 00:31:21,549
of these sorts of things think all of

666
00:31:14,829 --> 00:31:24,519
this stuff wants to be up in here go and

667
00:31:21,549 --> 00:31:27,730
the camera we need to pass in as well

668
00:31:24,519 --> 00:31:30,849
now the camera at the moment since we

669
00:31:27,730 --> 00:31:33,099
don't care I'm gonna let that happen up

670
00:31:30,849 --> 00:31:36,399
in here as well because we're not really

671
00:31:33,099 --> 00:31:37,779
fussing with that yet in the future we

672
00:31:36,400 --> 00:31:40,560
probably want that to be passed in as

673
00:31:37,779 --> 00:31:43,930
part of the world or something right

674
00:31:40,559 --> 00:31:47,289
but it doesn't really matter

675
00:31:43,930 --> 00:31:48,190
rate cats cannot convert argument -

676
00:31:47,289 --> 00:31:53,920
there we go

677
00:31:48,190 --> 00:31:55,570
let's get that going all right so now we

678
00:31:53,920 --> 00:31:57,250
just have to as you can see we don't get

679
00:31:55,569 --> 00:31:59,500
any image now because we're not calling

680
00:31:57,250 --> 00:32:01,180
this but what I would like to do now is

681
00:31:59,500 --> 00:32:08,829
I'd like to actually call this raycast

682
00:32:01,180 --> 00:32:11,110
function to render the world like so and

683
00:32:08,829 --> 00:32:13,269
I'm just gonna do image width image

684
00:32:11,109 --> 00:32:15,159
height and have it just render the image

685
00:32:13,269 --> 00:32:16,660
as it was rendering before and if we

686
00:32:15,160 --> 00:32:19,990
didn't mess anything up we should just

687
00:32:16,660 --> 00:32:23,650
get the same image right and it looks

688
00:32:19,990 --> 00:32:24,549
like we basically did that looks right

689
00:32:23,650 --> 00:32:26,200
to me

690
00:32:24,549 --> 00:32:30,490
and so now what we want to do is say

691
00:32:26,200 --> 00:32:36,039
okay can we break this up into multiple

692
00:32:30,490 --> 00:32:38,558
tiles now yeah I don't have a way of

693
00:32:36,039 --> 00:32:40,990
getting the number of CPUs here but I

694
00:32:38,558 --> 00:32:44,410
could pretend that I did so let's say I

695
00:32:40,990 --> 00:32:46,179
said core count equals 8 here and maybe

696
00:32:44,410 --> 00:32:47,860
if we wanted to add something in the

697
00:32:46,179 --> 00:32:50,500
future that could query the number of

698
00:32:47,859 --> 00:32:51,729
logical cores by calling Windows since

699
00:32:50,500 --> 00:32:53,859
we're not calling Windows right now I

700
00:32:51,730 --> 00:32:55,599
don't want to do that but you know the

701
00:32:53,859 --> 00:32:57,879
user could say maybe the core count then

702
00:32:55,599 --> 00:32:59,949
that they want to use what I want to do

703
00:32:57,880 --> 00:33:05,290
is I want to break up the image into

704
00:32:59,950 --> 00:33:07,179
that many tiles right and so I guess the

705
00:33:05,289 --> 00:33:09,279
other way we could do it is just use a

706
00:33:07,179 --> 00:33:12,519
tile count I don't know we kind of need

707
00:33:09,279 --> 00:33:13,899
a core count though so let's go ahead

708
00:33:12,519 --> 00:33:16,920
and say that we could specify a core

709
00:33:13,900 --> 00:33:20,140
count and then we might have a tile with

710
00:33:16,920 --> 00:33:21,970
tile height kind of a situation right

711
00:33:20,140 --> 00:33:24,850
and we want to compute what these are

712
00:33:21,970 --> 00:33:26,650
and so maybe what we say is maybe we

713
00:33:24,849 --> 00:33:29,169
want to just take however many cores

714
00:33:26,650 --> 00:33:32,500
there are and we want to kind of break

715
00:33:29,170 --> 00:33:33,940
up every row into that many tiles or

716
00:33:32,500 --> 00:33:37,089
something I don't know I'm making this

717
00:33:33,940 --> 00:33:39,250
up but let's say we took the image width

718
00:33:37,089 --> 00:33:42,909
and we divided it by the core count

719
00:33:39,250 --> 00:33:45,910
right and let's say we wanted to round

720
00:33:42,910 --> 00:33:48,100
up so that we wouldn't have too few we'd

721
00:33:45,910 --> 00:33:50,650
have too many if there if it wasn't an

722
00:33:48,099 --> 00:33:52,959
even divisor so let's say we took the

723
00:33:50,650 --> 00:33:55,090
image width and we added the core count

724
00:33:52,960 --> 00:33:58,029
minus 1 and then we divided by the core

725
00:33:55,089 --> 00:34:00,279
count to give us a number that we knew

726
00:33:58,029 --> 00:34:03,849
would sort of like get us to the end of

727
00:34:00,279 --> 00:34:06,220
a row always and let's say we always use

728
00:34:03,849 --> 00:34:09,069
square tiles so we have tile with M tile

729
00:34:06,220 --> 00:34:14,679
height equaling the same amount let's go

730
00:34:09,070 --> 00:34:19,059
ahead and print that out so here's the

731
00:34:14,679 --> 00:34:22,358
configuration MIT cores with D by D

732
00:34:19,059 --> 00:34:24,039
tiles right so just so we can see what

733
00:34:22,358 --> 00:34:26,909
it is so here's our core count goes our

734
00:34:24,039 --> 00:34:26,909
tile width oops

735
00:34:29,780 --> 00:34:35,040
so we can actually see what that ends up

736
00:34:32,099 --> 00:34:43,380
being and then what I'm going to do is

737
00:34:35,039 --> 00:34:45,929
just render one of those tiles right and

738
00:34:43,380 --> 00:34:48,210
so that's it that's all I wanted but you

739
00:34:45,929 --> 00:34:50,760
can see we do we this is 160 by 160

740
00:34:48,210 --> 00:34:53,820
tiles and you know what maybe I'll

741
00:34:50,760 --> 00:35:01,050
actually also put the the bytes per tile

742
00:34:53,820 --> 00:35:02,400
in here or the Cape or tile and what

743
00:35:01,050 --> 00:35:03,720
that's going to tell me is just how big

744
00:35:02,400 --> 00:35:05,039
the tile is relative to the cache now

745
00:35:03,719 --> 00:35:06,539
again it shouldn't matter because we're

746
00:35:05,039 --> 00:35:07,679
not actually updating tiles in a

747
00:35:06,539 --> 00:35:10,409
particular way but I'm just gonna print

748
00:35:07,679 --> 00:35:14,059
it out anyway so that's tile width times

749
00:35:10,409 --> 00:35:17,389
tile height times 4 or size of you 32

750
00:35:14,059 --> 00:35:17,389
divided by 1024

751
00:35:28,989 --> 00:35:37,629
what is it Oh because of size of all

752
00:35:31,570 --> 00:35:40,119
right fine so now it'll tell us like

753
00:35:37,630 --> 00:35:41,920
okay it's 100k per tile that would be

754
00:35:40,119 --> 00:35:44,108
that would fit in the l1 just fine

755
00:35:41,920 --> 00:35:46,960
because it's 2 and 56 K l1 on this

756
00:35:44,108 --> 00:35:48,848
particular chip so you know there we go

757
00:35:46,960 --> 00:35:51,250
right and we know the world is pretty

758
00:35:48,849 --> 00:35:52,599
tiny as well we could actually print out

759
00:35:51,250 --> 00:35:54,760
the size of that if we wanted to but I

760
00:35:52,599 --> 00:35:57,760
think we're basically good so now let's

761
00:35:54,760 --> 00:36:03,490
just make a loop that will render all of

762
00:35:57,760 --> 00:36:06,310
our tiles for us right like so so here

763
00:36:03,489 --> 00:36:09,848
we go with this render tile function we

764
00:36:06,309 --> 00:36:16,349
just need to go okay we've got tile

765
00:36:09,849 --> 00:36:18,910
index for tile X tile X is less than

766
00:36:16,349 --> 00:36:21,760
well actually I don't know how exactly I

767
00:36:18,909 --> 00:36:33,549
want to do this I guess we could just

768
00:36:21,760 --> 00:36:42,570
say what the tile count was not sure how

769
00:36:33,550 --> 00:36:46,320
I want to do this exactly you'll see

770
00:36:42,570 --> 00:36:46,320
you'll see as I write it

771
00:36:47,909 --> 00:36:51,029
so what I want to do here is say all

772
00:36:49,559 --> 00:36:54,840
right let's suppose that I'm gonna go

773
00:36:51,030 --> 00:36:57,300
over all of the tiles right and what I

774
00:36:54,840 --> 00:36:59,820
want to do here is I want to say that

775
00:36:57,300 --> 00:37:01,950
I'm gonna produce them in Y and that's

776
00:36:59,820 --> 00:37:07,620
going to be the tile Y times the tile

777
00:37:01,949 --> 00:37:11,189
height right so as we go through here

778
00:37:07,619 --> 00:37:13,559
I'm gonna like you know I'm gonna

779
00:37:11,190 --> 00:37:14,940
basically you know I can just I I think

780
00:37:13,559 --> 00:37:16,199
I can just figure this out ahead of time

781
00:37:14,940 --> 00:37:17,429
because I can just do the divide and

782
00:37:16,199 --> 00:37:18,719
round up and then I know that's how many

783
00:37:17,429 --> 00:37:21,389
tiles there are so it should be pretty

784
00:37:18,719 --> 00:37:23,699
straightforward right in fact I don't

785
00:37:21,389 --> 00:37:31,980
really even need to quite do it this way

786
00:37:23,699 --> 00:37:33,689
because I mean I could just do the

787
00:37:31,980 --> 00:37:35,820
straight divide without right rounding

788
00:37:33,690 --> 00:37:37,139
the divide up as well and it wouldn't

789
00:37:35,820 --> 00:37:43,350
matter you just have a fractional at the

790
00:37:37,139 --> 00:37:49,019
end so the rounded up version is just

791
00:37:43,349 --> 00:37:52,380
saying like hey you know 160 times 8 is

792
00:37:49,019 --> 00:37:53,940
1280 it gets the well I'm always going

793
00:37:52,380 --> 00:37:55,289
to get that much even if we had an image

794
00:37:53,940 --> 00:37:56,579
that was slightly bigger it would it

795
00:37:55,289 --> 00:37:58,469
would bump the tile size up so that we'd

796
00:37:56,579 --> 00:38:04,650
only have that many we'd only have the

797
00:37:58,469 --> 00:38:05,939
core count number of tiles there so but

798
00:38:04,650 --> 00:38:08,760
I don't really know that we care about

799
00:38:05,940 --> 00:38:10,800
that so maybe I'll just won't care about

800
00:38:08,760 --> 00:38:12,930
that for now and just say well just do

801
00:38:10,800 --> 00:38:17,370
this and then what I'll say is let's

802
00:38:12,929 --> 00:38:20,219
compute the tile count X and the tile

803
00:38:17,369 --> 00:38:23,329
count Y and just know those at a time

804
00:38:20,219 --> 00:38:23,329
[Applause]

805
00:38:26,389 --> 00:38:33,199
right so the tile count X is just going

806
00:38:29,340 --> 00:38:35,730
to be however big the image width is

807
00:38:33,199 --> 00:38:37,379
divided by the tile width it's gonna

808
00:38:35,730 --> 00:38:40,949
tell us how many of these we have to do

809
00:38:37,380 --> 00:38:43,559
but that would be if we skipped like any

810
00:38:40,949 --> 00:38:47,069
remainder so this is where we want to do

811
00:38:43,559 --> 00:38:48,929
sort of a plus tile with minus one thing

812
00:38:47,070 --> 00:38:51,990
to make sure that we count for the

813
00:38:48,929 --> 00:38:54,739
remainder so we'll get an extra tile

814
00:38:51,989 --> 00:38:57,239
that's like smaller if we need it right

815
00:38:54,739 --> 00:39:01,129
to fill in the gap and the same is true

816
00:38:57,239 --> 00:39:01,129
of the height here so there we go

817
00:39:01,798 --> 00:39:07,679
so this way we can know that that's

818
00:39:04,139 --> 00:39:15,000
going to cover the entire image when we

819
00:39:07,679 --> 00:39:16,469
do the min X min Y those are just going

820
00:39:15,000 --> 00:39:17,969
to be straight multiples so we know that

821
00:39:16,469 --> 00:39:19,769
our minimum Y is going to be however

822
00:39:17,969 --> 00:39:23,699
many tiles we've gone times a tile

823
00:39:19,769 --> 00:39:27,000
height same with the min X the max X on

824
00:39:23,699 --> 00:39:29,548
the other hand is going to be the min

825
00:39:27,000 --> 00:39:31,679
you know we take the min and go one tile

826
00:39:29,548 --> 00:39:33,239
height forward that would be how big it

827
00:39:31,679 --> 00:39:35,940
would be if we didn't ever have

828
00:39:33,239 --> 00:39:41,189
remainder tiles but sometimes we do so

829
00:39:35,940 --> 00:39:43,920
if max X is going is going to be greater

830
00:39:41,190 --> 00:39:47,490
than the image height we need to clamp

831
00:39:43,920 --> 00:39:49,740
it right we don't want to you know if we

832
00:39:47,489 --> 00:39:51,750
have a tile where we need to do a

833
00:39:49,739 --> 00:39:54,088
fractional tile to fill in like the top

834
00:39:51,750 --> 00:39:56,460
row of the image we want to clamp it

835
00:39:54,088 --> 00:40:00,509
down so we don't overwrite the image you

836
00:39:56,460 --> 00:40:04,230
know go go further out of the image then

837
00:40:00,510 --> 00:40:07,400
then there actually exists image don't

838
00:40:04,230 --> 00:40:07,400
ask you why I wrote X there

839
00:40:13,369 --> 00:40:17,579
so here we're computing those values we

840
00:40:15,900 --> 00:40:22,318
now can use those values here's the min

841
00:40:17,579 --> 00:40:24,690
X min Y max X max Y and I really

842
00:40:22,318 --> 00:40:26,159
sometimes I just like to be careful

843
00:40:24,690 --> 00:40:31,170
about this and say it's well it's really

844
00:40:26,159 --> 00:40:33,719
one past the max X because we're not

845
00:40:31,170 --> 00:40:36,210
it's not really the maximum X value X

846
00:40:33,719 --> 00:40:39,328
we'll never take that actual value right

847
00:40:36,210 --> 00:40:41,480
it's one past max X and so sometimes I

848
00:40:39,329 --> 00:40:43,890
just like to say that so that it's clear

849
00:40:41,480 --> 00:40:46,380
because again the loop doesn't actually

850
00:40:43,889 --> 00:40:47,699
use that value so it's important to note

851
00:40:46,380 --> 00:40:50,309
right because it's a fencepost error

852
00:40:47,699 --> 00:40:55,288
otherwise we never compute the actual

853
00:40:50,309 --> 00:40:57,030
image height row that is one passed the

854
00:40:55,289 --> 00:41:00,410
last row the last row is image height

855
00:40:57,030 --> 00:41:03,260
minus one that's the index for it right

856
00:41:00,409 --> 00:41:11,338
so sometimes I just like to say that

857
00:41:03,260 --> 00:41:16,890
anyway let's do that so now we're doing

858
00:41:11,338 --> 00:41:18,750
each of those tiles separately and it

859
00:41:16,889 --> 00:41:21,028
looks like that reassembled properly

860
00:41:18,750 --> 00:41:28,170
which is nice we now have a problem

861
00:41:21,028 --> 00:41:32,059
which is like this printout is kind of

862
00:41:28,170 --> 00:41:32,059
printing out in the wrong place

863
00:41:37,469 --> 00:41:49,289
I don't know how we want to print out

864
00:41:44,838 --> 00:41:53,789
percent done yet that's kind of a tough

865
00:41:49,289 --> 00:42:00,389
one I guess we could just print out how

866
00:41:53,789 --> 00:42:02,400
many tiles we'd done but that might be a

867
00:42:00,389 --> 00:42:11,519
little too granular I don't know I mean

868
00:42:02,400 --> 00:42:13,818
let's try it for now and we'll see how

869
00:42:11,519 --> 00:42:13,818
it goes

870
00:42:31,019 --> 00:42:38,409
something like this maybe even total

871
00:42:35,920 --> 00:42:41,710
tile count equals tile count x times

872
00:42:38,409 --> 00:42:45,809
child count Y and then in here I'll just

873
00:42:41,710 --> 00:42:50,500
say tiles right retired divided by total

874
00:42:45,809 --> 00:42:53,949
tile count right so that'll just print

875
00:42:50,500 --> 00:42:59,289
out that percentage I and let us know

876
00:42:53,949 --> 00:43:00,969
how far we've gone and yeah we'll just

877
00:42:59,289 --> 00:43:12,009
keep track of how many tiles you've

878
00:43:00,969 --> 00:43:14,469
retired retired count zero and so every

879
00:43:12,010 --> 00:43:19,560
time I render a tile I'll do tile

880
00:43:14,469 --> 00:43:19,559
retired count plus plus and off we go

881
00:43:21,570 --> 00:43:27,130
so there you go

882
00:43:23,440 --> 00:43:29,700
that looked a bit strange oh right that

883
00:43:27,130 --> 00:43:34,019
needs to be inside this loop there we go

884
00:43:29,699 --> 00:43:38,619
so there's the tiles as they retire and

885
00:43:34,019 --> 00:43:42,699
they're we're done so that's fine and

886
00:43:38,619 --> 00:43:48,880
dandy now we know we can do this in

887
00:43:42,699 --> 00:43:53,759
tiles and we've got one or two things

888
00:43:48,880 --> 00:43:53,760
that are slightly busted at the moment

889
00:43:53,880 --> 00:43:59,769
here in our world structure where we've

890
00:43:56,199 --> 00:44:04,089
got bounces computed and I'm gonna do a

891
00:43:59,769 --> 00:44:05,409
tile retired count in here as well I'm

892
00:44:04,090 --> 00:44:07,120
just going to go ahead and put that in

893
00:44:05,409 --> 00:44:08,649
the world structure and the reason I

894
00:44:07,119 --> 00:44:12,219
want to do that we'll see you in a

895
00:44:08,650 --> 00:44:17,829
second where we go ahead and do where's

896
00:44:12,219 --> 00:44:22,179
that bounces bit bounce computed will

897
00:44:17,829 --> 00:44:24,460
put tile retired in here I'm gonna move

898
00:44:22,179 --> 00:44:26,589
these to the end so when we complete a

899
00:44:24,460 --> 00:44:29,130
tile we're gonna take the bounces

900
00:44:26,590 --> 00:44:29,130
computed

901
00:44:30,400 --> 00:44:36,160
and put it in here so what I want to do

902
00:44:33,639 --> 00:44:40,179
is locally in here use a local variable

903
00:44:36,159 --> 00:44:44,469
that's not in that structure for bounces

904
00:44:40,179 --> 00:44:46,449
computed and I'm just gonna add in here

905
00:44:44,469 --> 00:44:48,699
every time we do a bounce I'm gonna

906
00:44:46,449 --> 00:44:50,859
increment that I think it would be

907
00:44:48,699 --> 00:44:52,359
sufficient I mean I'll make it a 64 it

908
00:44:50,860 --> 00:44:53,800
would probably be sufficient to do a 32

909
00:44:52,360 --> 00:44:55,300
inside here because it's just in the

910
00:44:53,800 --> 00:44:57,400
tile but who knows maybe it'll overflow

911
00:44:55,300 --> 00:44:58,840
we don't want to guarantee that so we'll

912
00:44:57,400 --> 00:44:59,170
just make it be a 64 and we'll do it

913
00:44:58,840 --> 00:45:01,170
here

914
00:44:59,170 --> 00:45:03,670
at the end we'll sum these two together

915
00:45:01,170 --> 00:45:06,309
for our statistic gathering purposes at

916
00:45:03,670 --> 00:45:07,750
I retired camp and then in here when we

917
00:45:06,309 --> 00:45:10,029
print things out we should be able to

918
00:45:07,750 --> 00:45:12,059
print out the correct values I think

919
00:45:10,030 --> 00:45:14,080
oops

920
00:45:12,059 --> 00:45:20,889
of course I have to actually get them

921
00:45:14,079 --> 00:45:27,489
out here we go piling up preview windows

922
00:45:20,889 --> 00:45:32,289
here and world's is a dot what else we

923
00:45:27,489 --> 00:45:40,989
got what else you got for me uh-oh those

924
00:45:32,289 --> 00:45:43,989
were all from one thing Jesus okay that

925
00:45:40,989 --> 00:45:50,739
is a pretty bogus value what is what's

926
00:45:43,989 --> 00:45:53,529
going on here tile retired count times

927
00:45:50,739 --> 00:45:57,000
100 divided by total tile count total

928
00:45:53,530 --> 00:45:57,000
tile count is valid

929
00:46:00,050 --> 00:46:03,760
child retired count

930
00:46:20,960 --> 00:46:35,838
is a you 64 I mean is you 32 why did

931
00:46:28,519 --> 00:46:36,530
that get grumpy all of a sudden I must

932
00:46:35,838 --> 00:46:44,108
have missed it

933
00:46:36,530 --> 00:46:48,080
let's take a look it slipped by me

934
00:46:44,108 --> 00:46:56,838
here's the red caster no switch real

935
00:46:48,079 --> 00:47:03,619
quick to debug mode so you can see that

936
00:46:56,838 --> 00:47:11,179
this value is highly bogus here let me

937
00:47:03,619 --> 00:47:15,410
go down here and take a look I don't

938
00:47:11,179 --> 00:47:22,098
really want this to keep going I'm gonna

939
00:47:15,409 --> 00:47:26,269
kill it and task okay and I am going to

940
00:47:22,099 --> 00:47:34,640
go ahead and compile oh no I did it

941
00:47:26,269 --> 00:47:37,519
again that I just want to run it from

942
00:47:34,639 --> 00:47:39,379
here all right so when I run it from

943
00:47:37,519 --> 00:47:41,329
here I do not know why this window

944
00:47:39,380 --> 00:47:43,220
consists on continuously coming up this

945
00:47:41,329 --> 00:47:48,159
Diagnostics tools things I think we just

946
00:47:43,219 --> 00:47:50,419
want to kill it because it's bugging me

947
00:47:48,159 --> 00:47:52,608
so I want to look at the world structure

948
00:47:50,420 --> 00:47:56,420
you can see the tile retired count is

949
00:47:52,608 --> 00:47:59,239
zero here I'm gonna go into one of these

950
00:47:56,420 --> 00:48:02,920
and I don't really want any of this

951
00:47:59,239 --> 00:48:06,108
stuff so let's just go to the watch

952
00:48:02,920 --> 00:48:08,088
here's a towel retired count I'm gonna

953
00:48:06,108 --> 00:48:10,429
do rendered tile I'm gonna see what that

954
00:48:08,088 --> 00:48:13,279
actually so tower retired count gets

955
00:48:10,429 --> 00:48:15,649
incremented by a huge number there which

956
00:48:13,280 --> 00:48:17,089
isn't what I intended so I probably just

957
00:48:15,650 --> 00:48:23,750
put that in the wrong place

958
00:48:17,088 --> 00:48:27,039
oh I put it all that would explain it

959
00:48:23,750 --> 00:48:27,039
I put it in raycast

960
00:48:28,929 --> 00:48:32,679
don't ask me why I did that

961
00:48:37,750 --> 00:48:42,679
so yeah inside render tile I really want

962
00:48:40,608 --> 00:48:43,730
it in here is where I would like it to

963
00:48:42,679 --> 00:48:46,759
be

964
00:48:43,730 --> 00:48:50,210
when raycast returns this value what I

965
00:48:46,760 --> 00:48:52,789
would prefer is that I since this bounce

966
00:48:50,210 --> 00:48:54,679
count is like pretty low here I would

967
00:48:52,789 --> 00:48:58,190
like this to be returned as part of the

968
00:48:54,679 --> 00:49:01,730
raycast and really this can be inlined

969
00:48:58,190 --> 00:49:03,380
inside of render tile it doesn't

970
00:49:01,730 --> 00:49:06,740
actually need to be its own function

971
00:49:03,380 --> 00:49:09,318
call because really it's like it's just

972
00:49:06,739 --> 00:49:14,000
this loop here right it's just this

973
00:49:09,318 --> 00:49:15,889
thing so if we want to we don't really

974
00:49:14,000 --> 00:49:18,829
need this to be a separate raycast

975
00:49:15,889 --> 00:49:21,230
function and I don't know that I want to

976
00:49:18,829 --> 00:49:23,390
inline it like that for now but it's

977
00:49:21,230 --> 00:49:26,719
hard to say how I want to do it you know

978
00:49:23,389 --> 00:49:32,679
I sort of do I sort of don't for right

979
00:49:26,719 --> 00:49:36,288
now I'll cheese it i'll go ahead and say

980
00:49:32,679 --> 00:49:38,598
bounce is computed well yeah you know

981
00:49:36,289 --> 00:49:42,099
I'm just gonna inline it it's going in

982
00:49:38,599 --> 00:49:42,099
line that's what's happening

983
00:49:52,059 --> 00:49:58,279
so raycast is going away goodbye

984
00:49:56,619 --> 00:50:01,940
so here we are

985
00:49:58,280 --> 00:50:03,980
so inside contrib here as you can see

986
00:50:01,940 --> 00:50:06,619
we've got kind of our array index

987
00:50:03,980 --> 00:50:09,289
happening we compute all these values

988
00:50:06,619 --> 00:50:11,449
here and we compute our very origin in

989
00:50:09,289 --> 00:50:15,349
ray direction then we go through the

990
00:50:11,449 --> 00:50:22,539
bounces and we'll do our bounce computed

991
00:50:15,349 --> 00:50:27,469
there this will come out to the outside

992
00:50:22,539 --> 00:50:30,460
and we'll do our bounce computed that

993
00:50:27,469 --> 00:50:35,119
way that will go through each of these

994
00:50:30,460 --> 00:50:39,949
computations and in the end we will do

995
00:50:35,119 --> 00:50:41,869
our color sum this way so here's where

996
00:50:39,949 --> 00:50:43,969
we were doing the raycast before so

997
00:50:41,869 --> 00:50:45,769
we'll get rid of it here we have this

998
00:50:43,969 --> 00:50:48,409
contrib value which is the amount that

999
00:50:45,769 --> 00:50:50,840
it will be contributed to so what we can

1000
00:50:48,409 --> 00:50:53,989
do is just come in here and say color

1001
00:50:50,840 --> 00:50:57,380
equals country times how to Mart there's

1002
00:50:53,989 --> 00:51:01,699
that summation that we need to do and

1003
00:50:57,380 --> 00:51:03,320
that should give us what we need for

1004
00:51:01,699 --> 00:51:05,149
color right

1005
00:51:03,320 --> 00:51:15,830
we don't need result there so that

1006
00:51:05,150 --> 00:51:17,869
should give us what we want right and if

1007
00:51:15,829 --> 00:51:19,219
we needed to we could also sort of

1008
00:51:17,869 --> 00:51:21,199
separate those out a little bit more

1009
00:51:19,219 --> 00:51:24,169
cleanly so that contrib is multiplied

1010
00:51:21,199 --> 00:51:25,879
once at the end rather than every time

1011
00:51:24,170 --> 00:51:30,730
here which does kind of seem like a

1012
00:51:25,880 --> 00:51:30,730
little bit better so what we could do is

1013
00:51:35,849 --> 00:51:40,499
say that when we get the color out it's

1014
00:51:38,039 --> 00:51:42,479
it's like as it summed up at the very

1015
00:51:40,498 --> 00:52:09,778
end we just do a color of x equals

1016
00:51:42,478 --> 00:52:11,728
contribs something like that right so

1017
00:52:09,778 --> 00:52:14,369
that way we have sort of two separate

1018
00:52:11,728 --> 00:52:16,679
things we've got the you know the result

1019
00:52:14,369 --> 00:52:18,809
here and we've got the sample now this

1020
00:52:16,679 --> 00:52:21,659
probably shouldn't be called color this

1021
00:52:18,809 --> 00:52:34,229
should probably be called like final

1022
00:52:21,659 --> 00:52:38,728
color or something like that all right

1023
00:52:34,228 --> 00:52:44,218
so let's see what we've got here did I

1024
00:52:38,728 --> 00:52:48,088
say that was a v4 it was my mistake all

1025
00:52:44,219 --> 00:52:50,759
right so now we've kind of got a closed

1026
00:52:48,088 --> 00:52:53,369
loop here which should be about right

1027
00:52:50,759 --> 00:52:55,469
bass is computed is now gonna be

1028
00:52:53,369 --> 00:52:57,930
accurate I think and we retire both of

1029
00:52:55,469 --> 00:53:02,568
those things here with a tile so that's

1030
00:52:57,929 --> 00:53:02,568
good let's wait till that finishes up

1031
00:53:06,730 --> 00:53:20,050
okay come on mr. ray caster don't make

1032
00:53:14,300 --> 00:53:25,720
me kill your task I'll do it

1033
00:53:20,050 --> 00:53:25,720
here we go alright so

1034
00:53:43,780 --> 00:53:52,609
all right so the sample is summed here

1035
00:53:47,179 --> 00:53:55,219
like so and the final color is summed in

1036
00:53:52,608 --> 00:54:01,460
here that is how that should work I am

1037
00:53:55,219 --> 00:54:09,649
gonna kill you this time ray and now I

1038
00:54:01,460 --> 00:54:13,460
think we're good there we go okay so now

1039
00:54:09,650 --> 00:54:20,539
we're pretty good to go here most of the

1040
00:54:13,460 --> 00:54:23,599
most of most of what we have does what

1041
00:54:20,539 --> 00:54:25,250
we needed to do our problem now as you

1042
00:54:23,599 --> 00:54:27,079
can see the way I've set it up our

1043
00:54:25,250 --> 00:54:28,940
problem now is we want each of these

1044
00:54:27,079 --> 00:54:33,260
render tile calls to run on a separate

1045
00:54:28,940 --> 00:54:36,619
CPU right that's what we would like it

1046
00:54:33,260 --> 00:54:38,930
to do so rather than calling render tile

1047
00:54:36,619 --> 00:54:41,329
like this what we would like to do is

1048
00:54:38,929 --> 00:54:44,328
basically push these tiles onto a list

1049
00:54:41,329 --> 00:54:49,519
and then we would like to DQ them from

1050
00:54:44,329 --> 00:54:52,700
the list as we go right so you know

1051
00:54:49,519 --> 00:54:54,500
that's that's the goal anyway so what

1052
00:54:52,699 --> 00:54:56,838
I'd like to do here is say all right

1053
00:54:54,500 --> 00:54:59,028
we've got a total tile count I'm just

1054
00:54:56,838 --> 00:55:01,190
gonna record all of the ones that need

1055
00:54:59,028 --> 00:55:08,119
to happen into a queue and then I'm just

1056
00:55:01,190 --> 00:55:10,250
gonna have that queue sort of ready to

1057
00:55:08,119 --> 00:55:13,369
go that can be processed in a multi

1058
00:55:10,250 --> 00:55:19,159
processing environment right so I'm

1059
00:55:13,369 --> 00:55:22,099
gonna have like a little work you think

1060
00:55:19,159 --> 00:55:24,858
here and it's gonna store the stats so

1061
00:55:22,099 --> 00:55:28,910
that world is now separate and it's also

1062
00:55:24,858 --> 00:55:30,679
gonna have a work order and that work

1063
00:55:28,909 --> 00:55:33,009
order is just going to store the things

1064
00:55:30,679 --> 00:55:38,568
that we needed to do to render the tile

1065
00:55:33,010 --> 00:55:41,140
right I so what we're gonna have here is

1066
00:55:38,568 --> 00:55:45,288
essentially all of this this stuff here

1067
00:55:41,139 --> 00:55:48,288
here's the output image here's the x-men

1068
00:55:45,289 --> 00:55:51,049
the wyman the one pass like all this

1069
00:55:48,289 --> 00:55:54,980
stuff is just going to be in there like

1070
00:55:51,048 --> 00:56:06,469
that and then the work queue is just

1071
00:55:54,980 --> 00:56:07,820
gonna have some number of these and all

1072
00:56:06,469 --> 00:56:09,889
of this stuff is gonna become

1073
00:56:07,820 --> 00:56:15,230
multi-threaded so I'm gonna label it as

1074
00:56:09,889 --> 00:56:18,049
volatile and what that is instructing it

1075
00:56:15,230 --> 00:56:19,490
just so we're clear when we went over

1076
00:56:18,050 --> 00:56:23,600
the stuff on handmade Hiro for some

1077
00:56:19,489 --> 00:56:25,608
reason and I do not know the reason not

1078
00:56:23,599 --> 00:56:27,650
only is everyone on the Internet

1079
00:56:25,608 --> 00:56:30,199
wrong about what volatile does but

1080
00:56:27,650 --> 00:56:31,880
everyone who ever writes in to me about

1081
00:56:30,199 --> 00:56:33,919
volatile is also wrong about what it

1082
00:56:31,880 --> 00:56:37,460
does and I do not know why it is the

1083
00:56:33,920 --> 00:56:40,550
simplest possible thing to understand

1084
00:56:37,460 --> 00:56:44,300
please just trust me when I tell you I

1085
00:56:40,550 --> 00:56:47,450
am NOT wrong volatile is an instruction

1086
00:56:44,300 --> 00:56:50,090
to the compiler that the value may have

1087
00:56:47,449 --> 00:56:52,250
been changed by someone other than the

1088
00:56:50,090 --> 00:56:55,039
code generated by the compiler that's

1089
00:56:52,250 --> 00:56:57,608
all it's doing it is required for

1090
00:56:55,039 --> 00:57:00,559
multi-threaded programming because

1091
00:56:57,608 --> 00:57:02,090
otherwise the compiler may not reread

1092
00:57:00,559 --> 00:57:05,329
the value when it has been changed by

1093
00:57:02,090 --> 00:57:07,880
somebody else so it's required it is not

1094
00:57:05,329 --> 00:57:10,340
sufficient meaning labeling something

1095
00:57:07,880 --> 00:57:12,619
volatile does not make the code work

1096
00:57:10,340 --> 00:57:14,840
multi-threaded it's simply required to

1097
00:57:12,619 --> 00:57:17,930
make code work multi-threaded so if you

1098
00:57:14,840 --> 00:57:19,880
have a value that multiple threads may

1099
00:57:17,929 --> 00:57:21,349
touch you probably need to call it

1100
00:57:19,880 --> 00:57:23,990
volatile now there are times that you

1101
00:57:21,349 --> 00:57:25,368
don't need to call it volatile and the

1102
00:57:23,989 --> 00:57:26,750
reason that sometimes you don't need to

1103
00:57:25,369 --> 00:57:29,900
call it volatile is sometimes the

1104
00:57:26,750 --> 00:57:33,440
functions you use to operate on them

1105
00:57:29,900 --> 00:57:36,289
imply volatility so if you use a locked

1106
00:57:33,440 --> 00:57:38,599
increment function it may have the

1107
00:57:36,289 --> 00:57:40,880
notion of volatility baked into it in

1108
00:57:38,599 --> 00:57:44,118
some way that forces the compiler to

1109
00:57:40,880 --> 00:57:47,750
treat it that way it can't hurt to add

1110
00:57:44,119 --> 00:57:51,160
another volatile however so in this case

1111
00:57:47,750 --> 00:57:51,159
I'm going to label these volatile

1112
00:57:58,018 --> 00:58:03,178
and the reason that I'm labeling all of

1113
00:57:59,759 --> 00:58:05,278
these volatile is because when we go to

1114
00:58:03,179 --> 00:58:07,289
make this multi-threaded each of these

1115
00:58:05,278 --> 00:58:09,659
values may be touched by multiple

1116
00:58:07,289 --> 00:58:11,789
threats none of the other values will

1117
00:58:09,659 --> 00:58:13,409
ever be touched by two threads at once

1118
00:58:11,789 --> 00:58:14,849
ever right

1119
00:58:13,409 --> 00:58:16,889
and when I say touched I mean written

1120
00:58:14,849 --> 00:58:18,630
too right

1121
00:58:16,889 --> 00:58:20,818
and so as long as you're only ever

1122
00:58:18,630 --> 00:58:24,630
reading and writing values from a single

1123
00:58:20,818 --> 00:58:26,880
thread even if there's thousands of

1124
00:58:24,630 --> 00:58:29,160
threads operating any value that's only

1125
00:58:26,880 --> 00:58:31,528
read read and read from and written to

1126
00:58:29,159 --> 00:58:33,629
by a single thread that is not volatile

1127
00:58:31,528 --> 00:58:36,509
right the only things that need to be

1128
00:58:33,630 --> 00:58:39,088
mark volatile are things where inside a

1129
00:58:36,509 --> 00:58:41,429
particular operation of a given thread

1130
00:58:39,088 --> 00:58:42,869
as far as the compiler is concerned some

1131
00:58:41,429 --> 00:58:44,818
other thread may come and touch the

1132
00:58:42,869 --> 00:58:46,920
value that needs to be marked volatile

1133
00:58:44,818 --> 00:58:49,739
to prevent the compiler from cashing its

1134
00:58:46,920 --> 00:58:53,219
value in a register and not reading it

1135
00:58:49,739 --> 00:58:54,778
back for example right because that is

1136
00:58:53,219 --> 00:58:57,119
something the compiler will do right the

1137
00:58:54,778 --> 00:58:59,579
compiler me like let's say we're looking

1138
00:58:57,119 --> 00:59:01,709
at next work order index the compiler

1139
00:58:59,579 --> 00:59:03,660
may go ahead our bounces computed right

1140
00:59:01,708 --> 00:59:04,848
the compiler may go ahead and pull

1141
00:59:03,659 --> 00:59:07,379
bounce of computing into a register

1142
00:59:04,849 --> 00:59:08,130
operate on at a bunch and then put it

1143
00:59:07,380 --> 00:59:10,289
back out again

1144
00:59:08,130 --> 00:59:13,108
well if another thread might come along

1145
00:59:10,289 --> 00:59:15,028
and also change bounces computed now

1146
00:59:13,108 --> 00:59:16,739
that value is wrong even if our

1147
00:59:15,028 --> 00:59:18,150
multi-threading is correct and

1148
00:59:16,739 --> 00:59:21,119
everything works exactly as it should

1149
00:59:18,150 --> 00:59:23,670
the compilers caching of the value in a

1150
00:59:21,119 --> 00:59:25,048
register will create a bug in the code

1151
00:59:23,670 --> 00:59:27,479
that wouldn't have been there otherwise

1152
00:59:25,048 --> 00:59:29,788
and that is what volatile prevents

1153
00:59:27,478 --> 00:59:33,208
volatile prevents register caching or

1154
00:59:29,789 --> 00:59:34,619
stack caching of a global and it doesn't

1155
00:59:33,208 --> 00:59:36,778
have to be global in the CEPA fluff

1156
00:59:34,619 --> 00:59:39,959
scheme but in a visible from multiple

1157
00:59:36,778 --> 00:59:41,518
threads value that is changing on more

1158
00:59:39,958 --> 00:59:43,739
than one thread at a time right

1159
00:59:41,518 --> 00:59:48,748
so what cumulate errs are generally

1160
00:59:43,739 --> 00:59:51,449
where that happens please just believe

1161
00:59:48,748 --> 00:59:52,708
me when I say that I really don't want

1162
00:59:51,449 --> 00:59:54,209
to get another 100 emails from people

1163
00:59:52,708 --> 00:59:56,368
who don't know what volatile means

1164
00:59:54,208 --> 00:59:59,248
telling me that I got it wrong because I

1165
00:59:56,369 --> 01:00:02,269
didn't that is what it actually means

1166
00:59:59,248 --> 01:00:02,268
for real

1167
01:00:02,849 --> 01:00:06,789
that was very annoying the first time we

1168
01:00:05,079 --> 01:00:09,039
went over that on handmade hero I don't

1169
01:00:06,789 --> 01:00:10,539
mind getting corrected by people who

1170
01:00:09,039 --> 01:00:12,759
know what they're talking about but that

1171
01:00:10,539 --> 01:00:13,960
one was particularly bad where hundreds

1172
01:00:12,760 --> 01:00:16,570
of people were trying to correct me on

1173
01:00:13,960 --> 01:00:19,269
something that was correct that and the

1174
01:00:16,570 --> 01:00:20,740
locked increment thing you don't know

1175
01:00:19,269 --> 01:00:21,849
how many people wrote to me telling me

1176
01:00:20,739 --> 01:00:23,139
there was a raised condition in handmade

1177
01:00:21,849 --> 01:00:25,539
hero and there wasn't a race condition

1178
01:00:23,139 --> 01:00:27,849
and I have to go back and forth on email

1179
01:00:25,539 --> 01:00:30,400
like 20 times then be like no that's not

1180
01:00:27,849 --> 01:00:32,380
a race condition this is how x64 works

1181
01:00:30,400 --> 01:00:35,110
this is how locked increment works this

1182
01:00:32,380 --> 01:00:36,789
is not a race condition right like it's

1183
01:00:35,110 --> 01:00:38,170
good to get you know I guess I should

1184
01:00:36,789 --> 01:00:40,269
take the good with the bad it's good to

1185
01:00:38,170 --> 01:00:41,380
get people who actually tell me when

1186
01:00:40,269 --> 01:00:43,300
there's a bug in the hand made hero

1187
01:00:41,380 --> 01:00:45,280
multi-threading code but the problem is

1188
01:00:43,300 --> 01:00:47,019
for every one person who correctly

1189
01:00:45,280 --> 01:00:49,690
identifies a problem in the handmade

1190
01:00:47,019 --> 01:00:51,130
hero code most of the time people write

1191
01:00:49,690 --> 01:00:52,360
in and there's they're just right it's

1192
01:00:51,130 --> 01:00:54,849
like oh here's the thing I found out

1193
01:00:52,360 --> 01:00:56,829
like oh yeah that's wrong for some

1194
01:00:54,849 --> 01:00:59,799
reason multi-threading is like unique in

1195
01:00:56,829 --> 01:01:01,329
that tons of people seem to think they

1196
01:00:59,800 --> 01:01:02,710
understand it well enough to point out a

1197
01:01:01,329 --> 01:01:04,869
bug and some else's code when they

1198
01:01:02,710 --> 01:01:06,519
actually don't and there is no bug and I

1199
01:01:04,869 --> 01:01:08,909
don't know why that is I guess it's just

1200
01:01:06,519 --> 01:01:12,519
poorly understood topic it's weird

1201
01:01:08,909 --> 01:01:14,319
anyway so here we go with render tile

1202
01:01:12,519 --> 01:01:15,489
I'm marking this volatile now because I

1203
01:01:14,320 --> 01:01:16,780
know they will be volatile because

1204
01:01:15,489 --> 01:01:18,399
multiple threads will operate from them

1205
01:01:16,780 --> 01:01:20,140
my work queue I'm just gonna basically

1206
01:01:18,400 --> 01:01:21,730
make an array of work orders I know

1207
01:01:20,139 --> 01:01:22,869
exactly how many there are ahead of time

1208
01:01:21,730 --> 01:01:25,150
because I know how many tiles we've

1209
01:01:22,869 --> 01:01:26,679
broken the scene up into so what I'm

1210
01:01:25,150 --> 01:01:28,750
gonna do is when we start we have a

1211
01:01:26,679 --> 01:01:31,239
total tile count number here I'm going

1212
01:01:28,750 --> 01:01:32,530
to go ahead and set the world I'm sorry

1213
01:01:31,239 --> 01:01:36,509
I'm going to go ahead and create a work

1214
01:01:32,530 --> 01:01:38,950
queue here's my queue I'm gonna clear it

1215
01:01:36,510 --> 01:01:40,900
I'm going to set the work order count

1216
01:01:38,949 --> 01:01:43,539
thought to be the total tile count I'm

1217
01:01:40,900 --> 01:01:48,910
going to set the work orders to be an

1218
01:01:43,539 --> 01:01:51,759
array that will have the correct number

1219
01:01:48,909 --> 01:01:53,170
of these so it's going to have the

1220
01:01:51,760 --> 01:01:55,330
number of work orders that they're

1221
01:01:53,170 --> 01:01:58,570
supposed to be in the queue it's gonna

1222
01:01:55,329 --> 01:02:02,440
have those like so and then what I'm

1223
01:01:58,570 --> 01:02:04,059
going to do is I'm gonna each each time

1224
01:02:02,440 --> 01:02:06,760
through this loop rather than calling

1225
01:02:04,059 --> 01:02:11,079
render tile I'm just going to move that

1226
01:02:06,760 --> 01:02:13,630
render tile out here into a different

1227
01:02:11,079 --> 01:02:14,469
for loop and instead and you know this

1228
01:02:13,630 --> 01:02:18,050
is going to print out

1229
01:02:14,469 --> 01:02:20,929
status here I and what I'm gonna do here

1230
01:02:18,050 --> 01:02:22,910
is for these tiles as we go I'm instead

1231
01:02:20,929 --> 01:02:24,919
of actually computing any given tile of

1232
01:02:22,909 --> 01:02:26,239
time I'm just gonna take what I would

1233
01:02:24,920 --> 01:02:28,338
have done to compute the tile and I'll

1234
01:02:26,239 --> 01:02:31,189
put that into the work queue so I'm

1235
01:02:28,338 --> 01:02:32,570
gonna say here's a work order right and

1236
01:02:31,190 --> 01:02:34,130
in fact you know what I could do this is

1237
01:02:32,570 --> 01:02:36,829
just a poops that's good I can do that

1238
01:02:34,130 --> 01:02:39,970
just a pointer where we start out here

1239
01:02:36,829 --> 01:02:46,280
with just like work order you know

1240
01:02:39,969 --> 01:02:51,319
Brooke order equals recorders so and as

1241
01:02:46,280 --> 01:02:52,760
we go you know that I could do here just

1242
01:02:51,320 --> 01:02:54,829
to make sure - this would be an

1243
01:02:52,760 --> 01:02:57,230
interesting way probably to prevent bugs

1244
01:02:54,829 --> 01:03:00,289
you know what I'll do I'll do total work

1245
01:02:57,230 --> 01:03:02,449
order count or it'll be total tile count

1246
01:03:00,289 --> 01:03:03,650
will be the number here so we'll just

1247
01:03:02,449 --> 01:03:05,358
say okay

1248
01:03:03,650 --> 01:03:06,800
the total tile count is how many of

1249
01:03:05,358 --> 01:03:08,719
these we're going to have but the work

1250
01:03:06,800 --> 01:03:09,950
order count will leave at zero and then

1251
01:03:08,719 --> 01:03:12,078
when I come in here what I'll say is

1252
01:03:09,949 --> 01:03:15,409
work order count plus plus will be where

1253
01:03:12,079 --> 01:03:18,440
we are we can assert here that the work

1254
01:03:15,409 --> 01:03:21,769
order count is always less than the

1255
01:03:18,440 --> 01:03:23,750
total town that we attic allocated right

1256
01:03:21,769 --> 01:03:31,519
just to just to make sure that that

1257
01:03:23,750 --> 01:03:33,829
we're not doing anything weird so we

1258
01:03:31,519 --> 01:03:37,909
have a work order we need to fill out so

1259
01:03:33,829 --> 01:03:42,980
here's the order it's going to be the

1260
01:03:37,909 --> 01:03:45,259
queue work borders plus the record

1261
01:03:42,980 --> 01:03:46,818
account we're then going to fill it out

1262
01:03:45,260 --> 01:03:50,150
with all of the values that we would

1263
01:03:46,818 --> 01:03:52,338
have used to render the tile right so in

1264
01:03:50,150 --> 01:03:54,730
fact here they all are right we're just

1265
01:03:52,338 --> 01:04:01,599
going to do these world those worlds

1266
01:03:54,730 --> 01:04:06,588
image equals image min x equals min X

1267
01:04:01,599 --> 01:04:08,180
oops that's I guess it's X min and you

1268
01:04:06,588 --> 01:04:11,230
know and I guess these are I named them

1269
01:04:08,179 --> 01:04:11,230
differently don't ask me why

1270
01:04:16,130 --> 01:04:33,960
right and so all we're doing going to do

1271
01:04:19,170 --> 01:04:38,400
here is just copy in these values like

1272
01:04:33,960 --> 01:04:39,659
so okay so that's the thing that's going

1273
01:04:38,400 --> 01:04:42,780
to go through and get us all of our

1274
01:04:39,659 --> 01:04:44,639
tiles that we wanted into the work queue

1275
01:04:42,780 --> 01:04:46,440
so we have an array of all of the things

1276
01:04:44,639 --> 01:04:48,029
that we need to do to complete the image

1277
01:04:46,440 --> 01:04:49,860
like all of the tiles that we need to

1278
01:04:48,030 --> 01:04:52,950
render in order to complete the image

1279
01:04:49,860 --> 01:04:55,800
and then all I'm gonna do is loop

1280
01:04:52,949 --> 01:04:57,089
through them from you know zero to

1281
01:04:55,800 --> 01:05:00,660
however many there

1282
01:04:57,090 --> 01:05:08,190
turned out to be and at the end here i

1283
01:05:00,659 --> 01:05:10,799
could also assert the equivalent that

1284
01:05:08,190 --> 01:05:17,760
it's equal all right I'm gonna go ahead

1285
01:05:10,800 --> 01:05:21,960
to array dot H I like capitalizing

1286
01:05:17,760 --> 01:05:24,360
assert myself and I'm gonna go ahead and

1287
01:05:21,960 --> 01:05:28,199
include the default C runtime library

1288
01:05:24,360 --> 01:05:31,700
sir there it is okay and so I'm going to

1289
01:05:28,199 --> 01:05:31,699
go through each of the work orders here

1290
01:05:32,360 --> 01:05:42,599
and I'm gonna grab the correct one out

1291
01:05:36,150 --> 01:05:44,579
so work orders like so we're gonna grab

1292
01:05:42,599 --> 01:05:47,159
each of the work orders out in series

1293
01:05:44,579 --> 01:05:57,989
and then I'm just going to use the

1294
01:05:47,159 --> 01:06:00,839
parameters of the work order like so to

1295
01:05:57,989 --> 01:06:03,599
render the tile now the work order

1296
01:06:00,840 --> 01:06:06,470
itself is the other way round

1297
01:06:03,599 --> 01:06:06,469
I don't know why

1298
01:06:09,460 --> 01:06:17,260
but it is so there we go and now what we

1299
01:06:13,510 --> 01:06:20,170
need to do is now what we need to do is

1300
01:06:17,260 --> 01:06:22,599
when we call render tile we want to pass

1301
01:06:20,170 --> 01:06:25,059
the work queue here because that has the

1302
01:06:22,599 --> 01:06:27,130
accumulators in it now so what I'm going

1303
01:06:25,059 --> 01:06:33,880
to do is go up to our render tile call

1304
01:06:27,130 --> 01:06:35,650
here it is and when this goes to to

1305
01:06:33,880 --> 01:06:36,970
implement stuff to increment stuff in

1306
01:06:35,650 --> 01:06:38,829
the world it's really gonna increment

1307
01:06:36,969 --> 01:06:43,209
stuff on the world on the queue just

1308
01:06:38,829 --> 01:06:46,329
that's where the stats will live and it

1309
01:06:43,210 --> 01:06:49,050
looks like I also have to change didn't

1310
01:06:46,329 --> 01:06:54,250
print out of course there we go

1311
01:06:49,050 --> 01:06:57,580
that'll be here and here and here there

1312
01:06:54,250 --> 01:07:02,380
we go and so now we're using the work

1313
01:06:57,579 --> 01:07:04,210
queue and looks like everything's good

1314
01:07:02,380 --> 01:07:06,010
so you'll notice how I did this right I

1315
01:07:04,210 --> 01:07:09,220
took a single-threaded program and I

1316
01:07:06,010 --> 01:07:11,140
never made it multi-threaded I just did

1317
01:07:09,219 --> 01:07:13,029
a series of steps to transform it into

1318
01:07:11,139 --> 01:07:15,699
something that could be multi-threaded

1319
01:07:13,030 --> 01:07:18,190
right so now we just have an array and

1320
01:07:15,699 --> 01:07:20,379
that array has all of the work that

1321
01:07:18,190 --> 01:07:22,929
needs to be done and what that means is

1322
01:07:20,380 --> 01:07:25,809
now if I did have a way to launch

1323
01:07:22,929 --> 01:07:28,269
multiple threads I could actually make

1324
01:07:25,809 --> 01:07:31,108
this work so let's see how I would do

1325
01:07:28,269 --> 01:07:33,608
that specifically here is render tile

1326
01:07:31,108 --> 01:07:36,159
what if I wanted to get rid of all of

1327
01:07:33,608 --> 01:07:39,190
this stuff here right well what I could

1328
01:07:36,159 --> 01:07:42,309
do is I could say well let's just do a

1329
01:07:39,190 --> 01:07:44,230
while loop here for example that said

1330
01:07:42,309 --> 01:07:46,659
while the queue

1331
01:07:44,230 --> 01:07:48,880
you know I think I even made a thing for

1332
01:07:46,659 --> 01:07:51,699
here next work order index that's gonna

1333
01:07:48,880 --> 01:08:00,539
start at 0 while the next work order

1334
01:07:51,699 --> 01:08:04,480
index is less than or I could say work

1335
01:08:00,539 --> 01:08:07,440
retired or total tiles retired I guess I

1336
01:08:04,480 --> 01:08:11,679
could say while the tile retired count

1337
01:08:07,440 --> 01:08:13,769
is less than the work order count or

1338
01:08:11,679 --> 01:08:18,159
even I could say total tile count right

1339
01:08:13,769 --> 01:08:20,048
I know that we're not done so while it's

1340
01:08:18,159 --> 01:08:23,329
not done I'm just gonna call render tile

1341
01:08:20,048 --> 01:08:26,630
and I'm not gonna do any of this stuff

1342
01:08:23,329 --> 01:08:30,529
I'm gonna pull this out into a separate

1343
01:08:26,630 --> 01:08:34,940
sort of thing right so out here at the

1344
01:08:30,529 --> 01:08:36,739
top of render tile I'm gonna say what if

1345
01:08:34,939 --> 01:08:39,469
I just took all of the information that

1346
01:08:36,739 --> 01:08:42,079
render tile was previously getting

1347
01:08:39,470 --> 01:08:44,060
passed and instead of that I just

1348
01:08:42,079 --> 01:08:46,039
actually pretended that I had a work

1349
01:08:44,060 --> 01:08:49,760
order here that would tell me what it

1350
01:08:46,039 --> 01:08:54,170
was right so I'm gonna say okay let's go

1351
01:08:49,760 --> 01:09:00,980
ahead and get you know border world's

1352
01:08:54,170 --> 01:09:07,149
let's get image you 32 for the image

1353
01:09:00,979 --> 01:09:07,149
let's get X min close border x-men

1354
01:09:07,300 --> 01:09:17,739
border Y min boarded one past X Max

1355
01:09:15,159 --> 01:09:23,989
order oops

1356
01:09:17,739 --> 01:09:25,699
one past y max so if I did something

1357
01:09:23,989 --> 01:09:27,800
like this now I have all of the

1358
01:09:25,699 --> 01:09:31,338
information that I actually need to get

1359
01:09:27,800 --> 01:09:33,320
right and so all I need to know is what

1360
01:09:31,338 --> 01:09:36,079
work order index I should use and in

1361
01:09:33,319 --> 01:09:38,420
order to know what order I should use I

1362
01:09:36,079 --> 01:09:41,899
actually have this next work order index

1363
01:09:38,420 --> 01:09:44,359
thing here so what I can do is take next

1364
01:09:41,899 --> 01:09:46,309
work order index use that to tell me

1365
01:09:44,359 --> 01:09:49,130
which order to use and do the rest from

1366
01:09:46,310 --> 01:09:50,900
here so now the render tile call itself

1367
01:09:49,130 --> 01:09:52,640
is sort of like a multi-threaded thing

1368
01:09:50,899 --> 01:09:54,859
that just isn't multi running on

1369
01:09:52,640 --> 01:09:57,110
multiple threads it can just take a

1370
01:09:54,859 --> 01:09:59,889
queue figure out which work order it's

1371
01:09:57,109 --> 01:10:02,509
supposed to do and it will automatically

1372
01:09:59,890 --> 01:10:04,820
tell me when we're done because every

1373
01:10:02,510 --> 01:10:07,579
time I do tile retired count less than

1374
01:10:04,819 --> 01:10:10,460
total tile count I'll know that you know

1375
01:10:07,579 --> 01:10:12,380
it was correct right now the other thing

1376
01:10:10,460 --> 01:10:14,779
I can do here is I can be a little bit

1377
01:10:12,380 --> 01:10:17,510
more careful with this I can take the

1378
01:10:14,779 --> 01:10:20,170
next work order index here and say this

1379
01:10:17,510 --> 01:10:24,650
is my work before it or index like so

1380
01:10:20,170 --> 01:10:29,750
and I can say if right the work order

1381
01:10:24,649 --> 01:10:32,239
index itself is greater than or equal to

1382
01:10:29,750 --> 01:10:36,020
the work order count so the total number

1383
01:10:32,239 --> 01:10:36,789
to do then I can just return immediately

1384
01:10:36,020 --> 01:10:40,030
I can

1385
01:10:36,789 --> 01:10:41,619
just say don't don't do the rest of the

1386
01:10:40,029 --> 01:10:44,859
thing right don't do the rest of the

1387
01:10:41,619 --> 01:10:46,569
function so only if the work order that

1388
01:10:44,859 --> 01:10:48,429
I got back so this way even I can just

1389
01:10:46,569 --> 01:10:52,630
keep calling it over and over again and

1390
01:10:48,430 --> 01:10:54,010
it's not a problem right so now we're

1391
01:10:52,630 --> 01:10:55,359
just calling that one function it's

1392
01:10:54,010 --> 01:10:58,270
responsible for getting something off

1393
01:10:55,359 --> 01:10:59,949
the queue itself and it will work and do

1394
01:10:58,270 --> 01:11:04,000
it and you know off we go now you notice

1395
01:10:59,949 --> 01:11:05,109
we've got a little my head is in the way

1396
01:11:04,000 --> 01:11:07,329
here so we can't really see if we

1397
01:11:05,109 --> 01:11:08,710
finished the last tile so I want to just

1398
01:11:07,329 --> 01:11:11,829
make sure that we're not missing a tile

1399
01:11:08,710 --> 01:11:12,670
there is there some way I can maybe make

1400
01:11:11,829 --> 01:11:15,550
this there we go

1401
01:11:12,670 --> 01:11:16,810
I want to there we go I want to make

1402
01:11:15,550 --> 01:11:22,680
sure we don't miss a tile so there

1403
01:11:16,810 --> 01:11:22,680
that's good right okay

1404
01:11:23,579 --> 01:11:28,229
I'd also like to print out the number of

1405
01:11:25,989 --> 01:11:28,229
tiles

1406
01:11:41,579 --> 01:11:47,979
there we go so we're currently doing 40

1407
01:11:44,800 --> 01:11:49,840
tiles right which is not quite perfectly

1408
01:11:47,979 --> 01:11:50,919
balanced for the number of CPU cores we

1409
01:11:49,840 --> 01:11:52,150
have we'd probably like the number of

1410
01:11:50,920 --> 01:11:53,649
tiles to be equal to the number of cores

1411
01:11:52,149 --> 01:11:55,119
but who cares we don't really know that

1412
01:11:53,649 --> 01:12:02,049
that's true because each tile could take

1413
01:11:55,119 --> 01:12:06,359
longer shorter or longer so there's that

1414
01:12:02,050 --> 01:12:06,360
but hold on one second here what's the

1415
01:12:07,739 --> 01:12:15,609
all right so hmm what we would like to

1416
01:12:13,750 --> 01:12:17,260
do now is we'd like to actually get

1417
01:12:15,609 --> 01:12:19,899
multiple threads hitting that render

1418
01:12:17,260 --> 01:12:23,680
tile function right so what I'd like to

1419
01:12:19,899 --> 01:12:25,809
do here is say well okay when we start

1420
01:12:23,680 --> 01:12:28,230
up here and I do this work queue thing I

1421
01:12:25,810 --> 01:12:31,240
want to basically create you know four

1422
01:12:28,229 --> 01:12:33,159
core index equals zero core index is

1423
01:12:31,239 --> 01:12:36,399
less than blah plus plus core index

1424
01:12:33,159 --> 01:12:40,809
right and what I'd like to do here is

1425
01:12:36,399 --> 01:12:42,449
actually say well I want to do the court

1426
01:12:40,810 --> 01:12:45,370
I guess there's a core count there it is

1427
01:12:42,449 --> 01:12:48,130
I want to create threads I want to

1428
01:12:45,369 --> 01:12:51,489
create one thread per core to start

1429
01:12:48,130 --> 01:12:53,590
doing the work here the problem I have

1430
01:12:51,489 --> 01:12:56,439
is that I don't actually want to create

1431
01:12:53,590 --> 01:12:59,190
one per core because I still am in the

1432
01:12:56,439 --> 01:13:02,229
main loop here I want to have one core

1433
01:12:59,189 --> 01:13:05,679
that's the one core is is this extra

1434
01:13:02,229 --> 01:13:07,839
miss right so I really want to do I want

1435
01:13:05,680 --> 01:13:10,090
to assume that core 0 is doing me and

1436
01:13:07,840 --> 01:13:14,739
then the rest of the cores will you know

1437
01:13:10,090 --> 01:13:16,779
spin up now right so what I want to do

1438
01:13:14,739 --> 01:13:20,289
here is go through the core in each of

1439
01:13:16,779 --> 01:13:22,210
the course I want to create threads for

1440
01:13:20,289 --> 01:13:26,260
each of these and I want those threads

1441
01:13:22,210 --> 01:13:28,600
to basically be able to call render tile

1442
01:13:26,260 --> 01:13:32,020
so I want to create a thread and I want

1443
01:13:28,600 --> 01:13:34,420
to pass this as the special value to the

1444
01:13:32,020 --> 01:13:36,670
thread is going to be this this queue

1445
01:13:34,420 --> 01:13:38,829
here right and then the rest of this

1446
01:13:36,670 --> 01:13:40,840
code should actually just work the only

1447
01:13:38,829 --> 01:13:42,819
thing that we're gonna have to do that

1448
01:13:40,840 --> 01:13:47,829
we're gonna have to change is we're

1449
01:13:42,819 --> 01:13:50,019
gonna have to go look at these two

1450
01:13:47,829 --> 01:13:51,158
functions here these are gonna have to

1451
01:13:50,020 --> 01:13:53,409
be functions

1452
01:13:51,158 --> 01:13:55,688
that will carefully update these values

1453
01:13:53,408 --> 01:13:58,538
because they they need to be told that

1454
01:13:55,689 --> 01:14:11,168
these are you know these are basically

1455
01:13:58,538 --> 01:14:12,880
have to be locked ads right because now

1456
01:14:11,168 --> 01:14:14,078
these values are getting updated for

1457
01:14:12,880 --> 01:14:16,179
multiple threads they're actually the

1458
01:14:14,078 --> 01:14:18,130
only values that are getting updated for

1459
01:14:16,179 --> 01:14:22,199
multiple threads are these ones that

1460
01:14:18,130 --> 01:14:26,019
I've mocked about marked volatile so

1461
01:14:22,198 --> 01:14:27,819
we'll do this all of those volatiles

1462
01:14:26,019 --> 01:14:29,050
have to be behind locked ads the reason

1463
01:14:27,819 --> 01:14:31,179
for that again is multiple CPUs you

1464
01:14:29,050 --> 01:14:32,918
touching it once the CPUs themselves

1465
01:14:31,179 --> 01:14:34,899
therefore need to be told that they

1466
01:14:32,918 --> 01:14:36,998
cannot just update what's in their cache

1467
01:14:34,899 --> 01:14:38,618
they have to go out and make sure that

1468
01:14:36,998 --> 01:14:42,760
they have exclusive access to that cache

1469
01:14:38,618 --> 01:14:44,948
line to update it properly without

1470
01:14:42,760 --> 01:14:46,539
stepping on someone else's value right

1471
01:14:44,948 --> 01:14:52,178
so we have to tell them that it's a lock

1472
01:14:46,538 --> 01:14:54,368
that okay so those locked ads have to be

1473
01:14:52,179 --> 01:14:55,958
in place and I don't really like to use

1474
01:14:54,368 --> 01:14:57,399
the term lock that necessarily because

1475
01:14:55,958 --> 01:14:59,288
it doesn't say what's gonna be the

1476
01:14:57,399 --> 01:15:01,839
return value and you can see in this

1477
01:14:59,288 --> 01:15:04,179
case in the case down here where we do

1478
01:15:01,840 --> 01:15:05,739
lock dad I don't have to care too much

1479
01:15:04,179 --> 01:15:07,090
about what happens you can see this is

1480
01:15:05,738 --> 01:15:09,248
just incrementing these values and

1481
01:15:07,090 --> 01:15:12,748
nobody cares what happened to the actual

1482
01:15:09,248 --> 01:15:14,498
value right but in the case of here

1483
01:15:12,748 --> 01:15:16,179
where I do lock dad

1484
01:15:14,498 --> 01:15:18,158
I actually need to know what the value

1485
01:15:16,179 --> 01:15:21,309
was and I want to know what the value

1486
01:15:18,158 --> 01:15:23,799
was before the ad took place so I want

1487
01:15:21,309 --> 01:15:26,918
to do a locked ad and return previous

1488
01:15:23,800 --> 01:15:29,320
value right is actually what I want to

1489
01:15:26,918 --> 01:15:31,538
call this function so that I know what's

1490
01:15:29,319 --> 01:15:33,399
actually coming back from it because the

1491
01:15:31,538 --> 01:15:35,438
other thing it could do is do a lock tab

1492
01:15:33,399 --> 01:15:37,238
and return the new value after the ad

1493
01:15:35,439 --> 01:15:39,159
now I don't care which one it returns me

1494
01:15:37,238 --> 01:15:40,808
I could compute either one by just doing

1495
01:15:39,158 --> 01:15:42,339
a subtraction after the fact of the

1496
01:15:40,809 --> 01:15:43,900
number that I know that I added so

1497
01:15:42,340 --> 01:15:45,729
they're really equivalent functions I

1498
01:15:43,899 --> 01:15:47,259
just want to make sure we know which one

1499
01:15:45,729 --> 01:15:49,030
it is so that you don't get little bugs

1500
01:15:47,260 --> 01:15:50,889
where you think that you're calling

1501
01:15:49,029 --> 01:15:52,328
locked ad that returns the new value or

1502
01:15:50,889 --> 01:15:54,489
lock title value and turns out you

1503
01:15:52,328 --> 01:16:00,359
actually have the other one so we're

1504
01:15:54,488 --> 01:16:00,359
gonna need one of these for each right

1505
01:16:09,210 --> 01:16:21,300
we're gonna need values that increment

1506
01:16:17,670 --> 01:16:24,060
you 64's and you know when we look at

1507
01:16:21,300 --> 01:16:25,650
this we're like well if we wanted to

1508
01:16:24,060 --> 01:16:29,340
make this program simpler we could just

1509
01:16:25,649 --> 01:16:32,039
only use you 64's for this right we

1510
01:16:29,340 --> 01:16:34,230
could say that we just do that and if we

1511
01:16:32,039 --> 01:16:38,698
want to do that I would just end up with

1512
01:16:34,229 --> 01:16:41,339
this right that's all there really is to

1513
01:16:38,698 --> 01:16:42,149
it and what I can do is I can just cast

1514
01:16:41,340 --> 01:16:44,010
these down

1515
01:16:42,149 --> 01:16:47,219
let me when we actually use it the one

1516
01:16:44,010 --> 01:16:48,750
time we use the tau tau retired and it's

1517
01:16:47,219 --> 01:16:50,399
no big deal and the integral promotion

1518
01:16:48,750 --> 01:16:53,868
everything else should work fine there I

1519
01:16:50,399 --> 01:16:56,099
think so that should just be you know

1520
01:16:53,868 --> 01:17:08,639
totally reasonable I'm going to stub

1521
01:16:56,100 --> 01:17:09,960
this function out right now and so these

1522
01:17:08,639 --> 01:17:13,350
are the two functions that we really

1523
01:17:09,960 --> 01:17:16,380
need to create at the moment we can just

1524
01:17:13,350 --> 01:17:17,820
do this but you know we're gonna have to

1525
01:17:16,380 --> 01:17:22,710
do something better when we actually

1526
01:17:17,819 --> 01:17:24,630
want them to work right okay so our work

1527
01:17:22,710 --> 01:17:26,730
order index is a 64-bit value now I

1528
01:17:24,630 --> 01:17:29,639
think that's the only change we actually

1529
01:17:26,729 --> 01:17:36,899
need let me kill these dudes that are

1530
01:17:29,639 --> 01:17:39,810
popping up there where's the poops must

1531
01:17:36,899 --> 01:17:41,698
return of value right you are sir

1532
01:17:39,810 --> 01:17:43,980
so when we actually get the value out

1533
01:17:41,698 --> 01:17:46,529
here we want to return the previous

1534
01:17:43,979 --> 01:17:48,269
value so we'll grab out the value first

1535
01:17:46,529 --> 01:17:52,289
then we'll add to it and return the

1536
01:17:48,270 --> 01:17:54,869
result there we go so now we have what I

1537
01:17:52,289 --> 01:17:57,689
think at barring any bugs that we may

1538
01:17:54,868 --> 01:18:01,618
have here we I have what I think would

1539
01:17:57,689 --> 01:18:03,738
be a correctly written program for

1540
01:18:01,618 --> 01:18:07,170
multi-threading without the actual

1541
01:18:03,738 --> 01:18:09,809
multi-threading and so what we need to

1542
01:18:07,170 --> 01:18:11,639
do at this point is we need to have and

1543
01:18:09,810 --> 01:18:12,120
there is one thing we probably want to

1544
01:18:11,639 --> 01:18:14,640
do here

1545
01:18:12,119 --> 01:18:16,559
which is it's really not super necessary

1546
01:18:14,640 --> 01:18:19,230
but we probably want to just make sure

1547
01:18:16,560 --> 01:18:21,950
after we fill out all the work orders

1548
01:18:19,229 --> 01:18:24,299
and start creating the threads

1549
01:18:21,949 --> 01:18:28,970
technically we want to say here that

1550
01:18:24,300 --> 01:18:28,970
there's a memory fence now you know

1551
01:18:41,390 --> 01:18:45,570
technically we might want to do that

1552
01:18:43,409 --> 01:18:50,220
here I don't want to introduce a

1553
01:18:45,569 --> 01:18:52,130
separate memory fence so what I can do

1554
01:18:50,220 --> 01:18:55,470
is I could increment a dummy variable

1555
01:18:52,130 --> 01:18:57,569
right what I could do is I could do a

1556
01:18:55,470 --> 01:19:00,210
lock dad and return previous value of

1557
01:18:57,569 --> 01:19:18,299
one of these volatiles here let's say

1558
01:19:00,210 --> 01:19:19,680
next work order index and what I'm doing

1559
01:19:18,300 --> 01:19:22,140
curious I just I don't want to introduce

1560
01:19:19,680 --> 01:19:23,700
extra complexity program which has I

1561
01:19:22,140 --> 01:19:25,079
don't want to find more stuff than I

1562
01:19:23,699 --> 01:19:26,460
need to so I don't want to rely on a

1563
01:19:25,079 --> 01:19:28,470
fence but I need a fence here and what

1564
01:19:26,460 --> 01:19:30,119
do I mean by that well all of these work

1565
01:19:28,470 --> 01:19:32,640
orders are getting written by core zero

1566
01:19:30,119 --> 01:19:33,989
right whoever's running the main code

1567
01:19:32,640 --> 01:19:38,130
and then I'm going to create a bunch of

1568
01:19:33,989 --> 01:19:40,500
threads technically core zero is under

1569
01:19:38,130 --> 01:19:43,949
no obligation to have flushed those

1570
01:19:40,500 --> 01:19:46,079
actual results out and so if another

1571
01:19:43,949 --> 01:19:48,869
thread were to come along and look at

1572
01:19:46,079 --> 01:19:51,029
the Q net it may not have actually

1573
01:19:48,869 --> 01:19:53,059
fleshed out the results that it wrote so

1574
01:19:51,029 --> 01:19:55,619
we want a fence there that just says hey

1575
01:19:53,060 --> 01:19:57,360
complete all of the rights you were

1576
01:19:55,619 --> 01:19:59,099
going to write here before those other

1577
01:19:57,359 --> 01:20:03,000
threads start to come because

1578
01:19:59,100 --> 01:20:06,180
technically creating a thread is sort of

1579
01:20:03,000 --> 01:20:07,770
not really a right now it actually is a

1580
01:20:06,180 --> 01:20:09,750
right that will be serious because I

1581
01:20:07,770 --> 01:20:15,440
know that Windows has to do rights to

1582
01:20:09,750 --> 01:20:18,090
create the thread so really you know

1583
01:20:15,439 --> 01:20:20,279
this this fence is probably just not

1584
01:20:18,090 --> 01:20:22,140
necessary but I'm just doing it there to

1585
01:20:20,279 --> 01:20:23,609
just be complete right because create

1586
01:20:22,140 --> 01:20:25,560
thread is almost certainly gonna fence

1587
01:20:23,609 --> 01:20:26,819
itself and so you

1588
01:20:25,560 --> 01:20:28,860
really don't need an extra fence here

1589
01:20:26,819 --> 01:20:31,769
but just to be extra secure I'm just

1590
01:20:28,859 --> 01:20:33,239
saying hey technically speaking since

1591
01:20:31,770 --> 01:20:36,030
there's no other rights happening

1592
01:20:33,239 --> 01:20:40,590
subsequent to this that our multi thread

1593
01:20:36,029 --> 01:20:42,239
where you should probably write fence to

1594
01:20:40,590 --> 01:20:46,800
make sure that the work orders all got

1595
01:20:42,239 --> 01:20:50,429
filled out beforehand that's all so

1596
01:20:46,800 --> 01:20:52,529
anyway I all we really need now is to

1597
01:20:50,430 --> 01:20:57,810
implement these two functions so I think

1598
01:20:52,529 --> 01:21:00,689
we're pretty good to go you know address

1599
01:20:57,810 --> 01:21:02,580
there I think we now have a fairly

1600
01:21:00,689 --> 01:21:03,989
correctly written program we got a maybe

1601
01:21:02,579 --> 01:21:07,109
pig lil closer attention to and make

1602
01:21:03,989 --> 01:21:12,510
sure it really is correctly written but

1603
01:21:07,109 --> 01:21:15,569
we we should be good for for everything

1604
01:21:12,510 --> 01:21:18,780
else in the program now except for the

1605
01:21:15,569 --> 01:21:20,460
fact that we don't actually create any

1606
01:21:18,779 --> 01:21:22,800
threads and we don't actually have a

1607
01:21:20,460 --> 01:21:26,460
lock increment so what I'm gonna do here

1608
01:21:22,800 --> 01:21:28,460
is because I don't want to use the C++

1609
01:21:26,460 --> 01:21:31,529
runtime libraries thread stuff yet

1610
01:21:28,460 --> 01:21:33,630
because I'm not super familiar with it

1611
01:21:31,529 --> 01:21:36,329
and I never actually use it I'm gonna

1612
01:21:33,630 --> 01:21:37,710
first use the Windows ones and then I

1613
01:21:36,329 --> 01:21:40,859
don't think we have time today but in

1614
01:21:37,710 --> 01:21:43,140
some future time when I'm feeling like

1615
01:21:40,859 --> 01:21:44,939
getting disgusting stru strip all over

1616
01:21:43,140 --> 01:21:47,340
me and taking a shower immediately

1617
01:21:44,939 --> 01:21:49,229
afterwards we'll try using standard

1618
01:21:47,340 --> 01:21:51,720
thread just to make it so that this

1619
01:21:49,229 --> 01:21:56,699
compiles on more than just Windows I

1620
01:21:51,720 --> 01:22:00,180
really don't want to do that like I

1621
01:21:56,699 --> 01:22:03,899
really don't want to do that but I will

1622
01:22:00,180 --> 01:22:06,390
do it just for fun so I'm gonna include

1623
01:22:03,899 --> 01:22:12,019
Windows here and I'm gonna have create

1624
01:22:06,390 --> 01:22:12,020
thread actually do a create thread call

1625
01:22:15,649 --> 01:22:21,479
I'm gonna call this like I don't know

1626
01:22:18,689 --> 01:22:24,659
great work thread maybe just to not come

1627
01:22:21,479 --> 01:22:26,189
conflict with a create thread call for

1628
01:22:24,659 --> 01:22:28,109
you want to use the regular create

1629
01:22:26,189 --> 01:22:30,089
thread call

1630
01:22:28,109 --> 01:22:32,250
although overloading should take care of

1631
01:22:30,090 --> 01:22:34,560
it but sometimes they use macros and

1632
01:22:32,250 --> 01:22:36,420
things like this so I want to create a

1633
01:22:34,560 --> 01:22:37,890
work thread cure so I'm going to go

1634
01:22:36,420 --> 01:22:40,399
ahead and use the windows call for

1635
01:22:37,890 --> 01:22:40,400
create thread

1636
01:22:42,600 --> 01:22:50,780
here's the function so what I need to do

1637
01:22:45,448 --> 01:22:50,779
is I just need to call this guy here and

1638
01:22:51,260 --> 01:22:55,860
it's relatively straightforward I don't

1639
01:22:53,488 --> 01:22:58,379
care about Security Act attributes I can

1640
01:22:55,859 --> 01:22:59,908
use the default stack size we need the

1641
01:22:58,380 --> 01:23:05,579
starting address here which is going to

1642
01:22:59,908 --> 01:23:07,469
be the worker thread function we need

1643
01:23:05,579 --> 01:23:09,420
the parameter which is the one that

1644
01:23:07,469 --> 01:23:11,250
we've passed here we need the creation

1645
01:23:09,420 --> 01:23:13,289
flags which I don't know if there's

1646
01:23:11,250 --> 01:23:15,750
anything we actually care about I don't

1647
01:23:13,289 --> 01:23:17,969
think we do we can just let it go we

1648
01:23:15,750 --> 01:23:19,439
don't need to suspend or anything and we

1649
01:23:17,969 --> 01:23:20,369
need to know what the thread ID is we

1650
01:23:19,439 --> 01:23:23,309
don't really need to know what the

1651
01:23:20,369 --> 01:23:27,349
thread ID is but you know so we'll go

1652
01:23:23,310 --> 01:23:27,350
ahead and and grab the thread ID here

1653
01:23:33,649 --> 01:23:41,250
like so and I think we can close the

1654
01:23:39,389 --> 01:23:42,619
thread handle immediately afterwards but

1655
01:23:41,250 --> 01:23:49,079
I don't think we care about it at all

1656
01:23:42,619 --> 01:23:52,829
right so in theory that's all fine that

1657
01:23:49,079 --> 01:23:54,658
should all work I think and there

1658
01:23:52,829 --> 01:24:02,158
shouldn't be anything particularly saucy

1659
01:23:54,658 --> 01:24:03,689
going on here yeah so that should create

1660
01:24:02,158 --> 01:24:07,920
a work thread we just now need a

1661
01:24:03,689 --> 01:24:11,369
function that uses the sort of the

1662
01:24:07,920 --> 01:24:13,319
thread start routine right we just need

1663
01:24:11,369 --> 01:24:15,809
to go look up what the thread start

1664
01:24:13,319 --> 01:24:17,309
routine definition is so we can make a

1665
01:24:15,810 --> 01:24:21,770
call back there that Windows will call

1666
01:24:17,310 --> 01:24:26,489
us back at that's not what I wanted

1667
01:24:21,770 --> 01:24:27,929
there it is this is the thread so as you

1668
01:24:26,488 --> 01:24:29,729
can see all it is is just something that

1669
01:24:27,929 --> 01:24:32,908
passes that one parameter that we have

1670
01:24:29,729 --> 01:24:34,769
there to us as a void star this LP void

1671
01:24:32,908 --> 01:24:36,839
is just I don't know why they insist on

1672
01:24:34,770 --> 01:24:41,219
defining everything in Windows but

1673
01:24:36,840 --> 01:24:44,400
there's the thread callback looks like

1674
01:24:41,219 --> 01:24:45,300
that so when we create the thread it

1675
01:24:44,399 --> 01:24:47,399
will get called back here with the

1676
01:24:45,300 --> 01:24:49,880
parameter we know that parameter is our

1677
01:24:47,399 --> 01:24:49,879
work queue

1678
01:24:53,198 --> 01:24:58,789
and so all we have to do here is just

1679
01:24:56,658 --> 01:25:00,349
call our actual function that we wanted

1680
01:24:58,789 --> 01:25:10,390
to have happen which is render tile

1681
01:25:00,350 --> 01:25:12,650
right yeah I love jumping around there

1682
01:25:10,390 --> 01:25:19,969
so I'm gonna go ahead and put this here

1683
01:25:12,649 --> 01:25:25,039
and be like do Casey a twin I feel like

1684
01:25:19,969 --> 01:25:28,609
taking a long long shower afterward go

1685
01:25:25,039 --> 01:25:39,130
ahead and port this to standard thread

1686
01:25:28,609 --> 01:25:45,139
maybe no promises so anyway I we need to

1687
01:25:39,130 --> 01:25:47,090
have this called render tile so what we

1688
01:25:45,140 --> 01:25:48,619
want to do here is inside the thread

1689
01:25:47,090 --> 01:25:50,810
proper you want to call render tile on

1690
01:25:48,619 --> 01:25:53,329
the work queue and what we'd like to do

1691
01:25:50,810 --> 01:25:55,640
is we want this thread to run for as

1692
01:25:53,329 --> 01:25:57,679
long as render tile could potentially do

1693
01:25:55,640 --> 01:25:59,600
something right

1694
01:25:57,679 --> 01:26:02,210
so render tile right now doesn't return

1695
01:25:59,600 --> 01:26:04,010
anything what I'd like to do is make it

1696
01:26:02,210 --> 01:26:07,219
so render tile does return something

1697
01:26:04,010 --> 01:26:11,260
right so in this case it will return

1698
01:26:07,219 --> 01:26:11,260
false in this case it will return true

1699
01:26:13,899 --> 01:26:22,399
so what I'll do is I'll just say while

1700
01:26:18,140 --> 01:26:23,960
render tile off we go right so we'll

1701
01:26:22,399 --> 01:26:25,460
just keep calling render tile until it

1702
01:26:23,960 --> 01:26:26,869
returns false which means it couldn't do

1703
01:26:25,460 --> 01:26:29,149
any more work and at that point we'll

1704
01:26:26,869 --> 01:26:32,920
just return out of thread and say we're

1705
01:26:29,149 --> 01:26:34,069
done right and that's all its gonna do

1706
01:26:32,920 --> 01:26:38,899
okay

1707
01:26:34,069 --> 01:26:46,359
uh so I forgot to name this worker

1708
01:26:38,899 --> 01:26:51,099
thread but now it should be correct and

1709
01:26:46,359 --> 01:26:51,099
yeah I got to fix this function here so

1710
01:26:51,130 --> 01:26:56,779
whenever we succeed in rendering a tile

1711
01:26:54,189 --> 01:26:58,309
I'll do the printf because otherwise

1712
01:26:56,779 --> 01:26:59,569
it's going to end up at the end when

1713
01:26:58,310 --> 01:27:01,100
it's waiting on the last tiles other

1714
01:26:59,569 --> 01:27:02,750
threads may have taken those tiles and

1715
01:27:01,100 --> 01:27:05,000
we just print out ray casting a ton of

1716
01:27:02,750 --> 01:27:06,500
so I only want to print it out if we

1717
01:27:05,000 --> 01:27:10,488
actually finish the tile just to gate

1718
01:27:06,500 --> 01:27:14,210
that a little bit so off we go and you

1719
01:27:10,488 --> 01:27:18,349
can see now that the speed has improved

1720
01:27:14,210 --> 01:27:20,420
rather dramatically right if we don't

1721
01:27:18,350 --> 01:27:26,570
create work with threads so if we if we

1722
01:27:20,420 --> 01:27:29,060
don't want a thread our system we're

1723
01:27:26,569 --> 01:27:30,979
we're much slower let's like to take a

1724
01:27:29,060 --> 01:27:33,110
look at the total time here right it

1725
01:27:30,979 --> 01:27:36,079
took us four thousand sixty three

1726
01:27:33,109 --> 01:27:38,509
milliseconds to compute our image so

1727
01:27:36,079 --> 01:27:42,769
about four thousand milliseconds or four

1728
01:27:38,510 --> 01:27:48,409
seconds right if we do multi thread it

1729
01:27:42,770 --> 01:27:52,000
takes 823 milliseconds right it's so if

1730
01:27:48,409 --> 01:27:56,500
we look at the speed up there

1731
01:27:52,000 --> 01:27:58,130
it's about 5x which isn't bad right

1732
01:27:56,500 --> 01:28:00,020
that's not bad

1733
01:27:58,130 --> 01:28:01,489
now we don't know that this is working

1734
01:28:00,020 --> 01:28:03,469
properly yet it's kind of just

1735
01:28:01,488 --> 01:28:05,988
accidentally working properly probably

1736
01:28:03,469 --> 01:28:09,050
and the reason for that is I haven't

1737
01:28:05,988 --> 01:28:10,819
implemented the lock bad yet right so if

1738
01:28:09,050 --> 01:28:13,400
we take a look at locked out a return

1739
01:28:10,819 --> 01:28:14,809
previous value this is still not it's

1740
01:28:13,399 --> 01:28:16,729
not actually safe it's not actually

1741
01:28:14,810 --> 01:28:19,160
doing a lock that so to finish our

1742
01:28:16,729 --> 01:28:26,349
program we just need to do interlock to

1743
01:28:19,159 --> 01:28:29,960
adhere right so here's our windows

1744
01:28:26,350 --> 01:28:33,310
here's the interlocked API what I want

1745
01:28:29,960 --> 01:28:33,310
is an interlocked ad

1746
01:28:34,539 --> 01:28:41,269
interlock exchange ad that looks good

1747
01:28:39,250 --> 01:28:42,380
the value of the strain will replace

1748
01:28:41,270 --> 01:28:44,120
with result the operation that's what we

1749
01:28:42,380 --> 01:28:45,469
want the function returns a initial

1750
01:28:44,119 --> 01:28:47,359
value that appears so this is exactly

1751
01:28:45,469 --> 01:28:51,409
what we want is interlocked exchanged ad

1752
01:28:47,359 --> 01:28:53,420
we want the 64-bit value version so we

1753
01:28:51,409 --> 01:28:55,880
want this one but this is exactly what

1754
01:28:53,420 --> 01:28:58,520
we want so inside here what we want to

1755
01:28:55,880 --> 01:29:00,469
do is the interlock exchange ad here's

1756
01:28:58,520 --> 01:29:02,510
the value that we're actually using they

1757
01:29:00,469 --> 01:29:03,430
named these opposite sorry about that

1758
01:29:02,510 --> 01:29:09,320
folks

1759
01:29:03,430 --> 01:29:11,750
just my bad there and the result comes

1760
01:29:09,319 --> 01:29:15,649
out here so now it's an actual interlock

1761
01:29:11,750 --> 01:29:19,159
dad looks like cuz yeah we're not a long

1762
01:29:15,649 --> 01:29:20,809
64 were au 64 those were going to be

1763
01:29:19,159 --> 01:29:24,529
equivalent in terms of behavior so we

1764
01:29:20,810 --> 01:29:28,420
can we should be able to cast that just

1765
01:29:24,529 --> 01:29:30,769
fine like that and off we go

1766
01:29:28,420 --> 01:29:32,329
sooo hey that's pretty good we've got a

1767
01:29:30,770 --> 01:29:36,469
five-time speed-up just from

1768
01:29:32,329 --> 01:29:38,000
multi-threading which is great it's you

1769
01:29:36,469 --> 01:29:40,069
know we might be able to get more out of

1770
01:29:38,000 --> 01:29:42,770
that I don't know let's take a look here

1771
01:29:40,069 --> 01:29:44,569
so I you can see we got about seven

1772
01:29:42,770 --> 01:29:47,660
hundred and ninety milliseconds to

1773
01:29:44,569 --> 01:29:55,670
render the whole thing eight hundred and

1774
01:29:47,659 --> 01:29:56,869
twenty eight thirty six eight sixteen so

1775
01:29:55,670 --> 01:29:59,630
we're hovering around the eight hundred

1776
01:29:56,869 --> 01:30:01,849
millisecond mark there right and now I

1777
01:29:59,630 --> 01:30:04,670
don't know whether or not having more or

1778
01:30:01,850 --> 01:30:06,860
less of these tiles would be better or

1779
01:30:04,670 --> 01:30:08,090
worse and I don't know that we've really

1780
01:30:06,859 --> 01:30:10,039
got a completely well functioning

1781
01:30:08,090 --> 01:30:11,690
program at this point either I also

1782
01:30:10,039 --> 01:30:13,460
don't know what the optimal number of

1783
01:30:11,689 --> 01:30:15,559
cores is and blah blah blah so we

1784
01:30:13,460 --> 01:30:17,180
haven't done a lot of the work that we

1785
01:30:15,560 --> 01:30:21,920
might want to do to make sure that all

1786
01:30:17,180 --> 01:30:23,450
of this is working properly but that is

1787
01:30:21,920 --> 01:30:25,550
neither here nor there

1788
01:30:23,449 --> 01:30:27,260
we you know we we've done a reasonable

1789
01:30:25,550 --> 01:30:29,239
job for just you know two hours of work

1790
01:30:27,260 --> 01:30:31,430
or whatever we're at least in sort of

1791
01:30:29,238 --> 01:30:34,399
okay position what I would like to do

1792
01:30:31,430 --> 01:30:36,950
here is just say like hey maybe we

1793
01:30:34,399 --> 01:30:38,659
should double check some of these tile

1794
01:30:36,949 --> 01:30:40,699
counts or core counts here let's try

1795
01:30:38,659 --> 01:30:43,579
setting the cork out to only before I

1796
01:30:40,699 --> 01:30:45,409
just see what the effect is on the image

1797
01:30:43,579 --> 01:30:48,019
so you can see that it definitely got

1798
01:30:45,409 --> 01:30:48,439
slower in that case let's try making

1799
01:30:48,020 --> 01:30:51,800
like

1800
01:30:48,439 --> 01:30:55,339
too many threads and see what happens

1801
01:30:51,800 --> 01:30:57,409
that didn't really affect the time oddly

1802
01:30:55,340 --> 01:31:00,170
enough and I guess that's just because

1803
01:30:57,409 --> 01:31:02,269
Windows just hey it's smart enough to

1804
01:31:00,170 --> 01:31:03,590
you know each of our threads is doing as

1805
01:31:02,270 --> 01:31:05,150
fast as they can Windows is smart enough

1806
01:31:03,590 --> 01:31:07,489
not to start up those other threads I

1807
01:31:05,149 --> 01:31:09,259
guess I don't really know but it looks

1808
01:31:07,489 --> 01:31:11,599
like there's not a lot of gain to be had

1809
01:31:09,260 --> 01:31:14,030
here by fussing with the cork out

1810
01:31:11,600 --> 01:31:15,560
specifically it looks like the number

1811
01:31:14,029 --> 01:31:18,050
being the number of cores equal to the

1812
01:31:15,560 --> 01:31:21,440
number of actual course is about right

1813
01:31:18,050 --> 01:31:24,619
it produces about the right number here

1814
01:31:21,439 --> 01:31:26,479
now in terms of the tile width and

1815
01:31:24,619 --> 01:31:28,010
height here I'm interested to know if I

1816
01:31:26,479 --> 01:31:30,549
just kind of fuss with it a little is

1817
01:31:28,010 --> 01:31:35,150
there anything you know like let's say I

1818
01:31:30,550 --> 01:31:39,619
I change it around kind of arbitrarily

1819
01:31:35,149 --> 01:31:42,920
poke at the tile numbers do I get much

1820
01:31:39,619 --> 01:31:48,349
of a change there and I don't know it

1821
01:31:42,920 --> 01:31:50,119
looks like you know not really it looks

1822
01:31:48,350 --> 01:31:56,810
like maybe a smaller tile is a little

1823
01:31:50,119 --> 01:32:01,099
bit better the process cannot what file

1824
01:31:56,810 --> 01:32:04,060
is being used by another I don't know

1825
01:32:01,100 --> 01:32:04,060
what that's complaining about

1826
01:32:06,399 --> 01:32:09,309
yeah I have no idea what that was either

1827
01:32:07,809 --> 01:32:11,168
complaining about but it looks like

1828
01:32:09,309 --> 01:32:13,059
maybe there's a little bit of a win to

1829
01:32:11,168 --> 01:32:18,788
be had there were smaller tile sizes I'm

1830
01:32:13,059 --> 01:32:21,128
not sure but that looks like on average

1831
01:32:18,788 --> 01:32:23,018
it is faster right with a smaller tile

1832
01:32:21,128 --> 01:32:23,378
size for whatever reason I have no idea

1833
01:32:23,019 --> 01:32:25,748
why

1834
01:32:23,378 --> 01:32:28,599
better finer grained multi-threading

1835
01:32:25,748 --> 01:32:30,099
perhaps but it does look like you know

1836
01:32:28,599 --> 01:32:32,349
if you if you kind of drop that tile

1837
01:32:30,099 --> 01:32:35,340
size down a little bit maybe because you

1838
01:32:32,349 --> 01:32:39,189
can get more at the end like you know

1839
01:32:35,340 --> 01:32:43,840
the the there's the sort of this concept

1840
01:32:39,189 --> 01:32:45,070
of drain out right just it just to kind

1841
01:32:43,840 --> 01:32:51,729
of give you a perspective some

1842
01:32:45,069 --> 01:32:53,978
perspective here so you know we're going

1843
01:32:51,729 --> 01:32:55,929
through here and we're doing these tiles

1844
01:32:53,979 --> 01:32:58,628
right and we're you know we're retiring

1845
01:32:55,929 --> 01:33:00,639
tiles retiring tiles at the end you know

1846
01:32:58,628 --> 01:33:03,189
there's some tiles left over if there's

1847
01:33:00,639 --> 01:33:05,859
only two tiles left over here but I've

1848
01:33:03,189 --> 01:33:07,300
got eight threads well one thread is

1849
01:33:05,859 --> 01:33:08,648
gonna pick up this tile one thread is

1850
01:33:07,300 --> 01:33:09,639
gonna pick up this out and then six

1851
01:33:08,649 --> 01:33:12,489
threads are gonna sit around doing

1852
01:33:09,639 --> 01:33:16,389
nothing right so the smaller the tiles

1853
01:33:12,488 --> 01:33:18,488
are the smaller the individual work unit

1854
01:33:16,389 --> 01:33:20,439
is and the less total drain out time

1855
01:33:18,488 --> 01:33:23,468
there is because let's say each tile

1856
01:33:20,439 --> 01:33:26,739
takes you know ten milliseconds to

1857
01:33:23,469 --> 01:33:28,389
compute right or something like this if

1858
01:33:26,738 --> 01:33:30,848
each tile takes eight ten milliseconds

1859
01:33:28,389 --> 01:33:33,519
to compute then that means during this

1860
01:33:30,849 --> 01:33:37,748
time here I'm gonna wait ten

1861
01:33:33,519 --> 01:33:39,458
milliseconds of drain out because the

1862
01:33:37,748 --> 01:33:41,438
other six threads are can't do anything

1863
01:33:39,458 --> 01:33:42,578
and so we're just waiting for the ten

1864
01:33:41,439 --> 01:33:46,269
milliseconds for each of these to

1865
01:33:42,578 --> 01:33:49,208
compute if I make the tile smaller right

1866
01:33:46,269 --> 01:33:50,769
so that each one of the tiles only takes

1867
01:33:49,208 --> 01:33:52,809
like four milliseconds to compute then

1868
01:33:50,769 --> 01:33:54,998
even when I eventually get to the end

1869
01:33:52,809 --> 01:33:57,159
and end on if there was only two tiles

1870
01:33:54,998 --> 01:33:58,748
then the ending is only four

1871
01:33:57,158 --> 01:34:01,299
milliseconds that can't be overlapped

1872
01:33:58,748 --> 01:34:03,309
right so the total amount of time that

1873
01:34:01,300 --> 01:34:05,378
can't be overlap is equal to however

1874
01:34:03,309 --> 01:34:07,449
much time it takes to do one work unit

1875
01:34:05,378 --> 01:34:09,578
in the worst case because at the end

1876
01:34:07,448 --> 01:34:12,009
when you get to the end you can't divide

1877
01:34:09,578 --> 01:34:13,840
up that work unit any smaller so even if

1878
01:34:12,010 --> 01:34:15,729
there's you know if a tile takes however

1879
01:34:13,840 --> 01:34:17,168
long it takes even if there's a ton of

1880
01:34:15,729 --> 01:34:19,000
thread sitting around with nothing to do

1881
01:34:17,168 --> 01:34:22,750
they can't help on

1882
01:34:19,000 --> 01:34:27,460
Tyl at all right so making the tile

1883
01:34:22,750 --> 01:34:29,710
smaller makes the worst case time on

1884
01:34:27,460 --> 01:34:31,359
overlapped time smaller and smaller and

1885
01:34:29,710 --> 01:34:33,909
smaller so as you get to the end you

1886
01:34:31,359 --> 01:34:36,399
avoid that drain out however you do have

1887
01:34:33,909 --> 01:34:38,439
overhead in the dispatch so that

1888
01:34:36,399 --> 01:34:40,119
overhead in the dispatch does get worse

1889
01:34:38,439 --> 01:34:41,229
as you go so you can't just make them

1890
01:34:40,119 --> 01:34:43,059
arbitrarily small you can't make them

1891
01:34:41,229 --> 01:34:45,099
one pixel because the overhead of

1892
01:34:43,060 --> 01:34:46,390
dispatching the pixel then becomes you

1893
01:34:45,100 --> 01:34:50,890
know that locked increment and all that

1894
01:34:46,390 --> 01:34:52,780
stuff starts to get in the way right so

1895
01:34:50,890 --> 01:34:55,180
you know just something to be aware of

1896
01:34:52,779 --> 01:34:58,889
so we may want to just sort of prescribe

1897
01:34:55,180 --> 01:34:58,890
the tile height here like

1898
01:35:23,319 --> 01:35:37,699
since we included windows we can also

1899
01:35:25,609 --> 01:35:39,829
get the get that quark down in here so

1900
01:35:37,699 --> 01:35:42,170
what I can do here is just have a thing

1901
01:35:39,829 --> 01:35:45,800
which is like winter you'd get poor

1902
01:35:42,170 --> 01:36:01,569
account I can't remember what the that

1903
01:35:45,800 --> 01:36:06,670
is this is not what I wanted

1904
01:36:01,569 --> 01:36:06,670
PS not what I wanted

1905
01:36:08,380 --> 01:36:17,960
let's go to get CPU can we already did

1906
01:36:16,789 --> 01:36:20,810
this in Hammett here I should just look

1907
01:36:17,960 --> 01:36:22,960
in there it's not get current processor

1908
01:36:20,810 --> 01:36:22,960
number

1909
01:36:39,840 --> 01:36:44,800
and I don't really know to need to know

1910
01:36:42,340 --> 01:36:46,659
about NEMA groups at the moment because

1911
01:36:44,800 --> 01:36:48,038
we don't have that kind of Numa groups

1912
01:36:46,658 --> 01:36:50,348
or not this that says we're a

1913
01:36:48,038 --> 01:36:53,309
non-uniform memory access and the idea

1914
01:36:50,349 --> 01:36:53,309
is there as sometimes you have like

1915
01:36:55,019 --> 01:37:00,789
processors that have localized memory to

1916
01:36:58,809 --> 01:37:02,769
them so like you know one gigabyte of

1917
01:37:00,788 --> 01:37:04,118
memory is closer to this processor and

1918
01:37:02,769 --> 01:37:05,070
can be activate this processor more

1919
01:37:04,118 --> 01:37:07,299
quickly

1920
01:37:05,069 --> 01:37:08,889
you know another gigabyte of memory is

1921
01:37:07,300 --> 01:37:11,650
more close to this processor and you

1922
01:37:08,889 --> 01:37:13,809
want to manage that so you put the

1923
01:37:11,649 --> 01:37:15,038
memory and the processors together so

1924
01:37:13,809 --> 01:37:16,719
that they're not like split you don't

1925
01:37:15,038 --> 01:37:18,069
have this processor using the memory

1926
01:37:16,719 --> 01:37:19,809
that's closer to that processor and vice

1927
01:37:18,069 --> 01:37:21,340
versa so non-uniform memory access

1928
01:37:19,809 --> 01:37:23,019
groups are important in certain services

1929
01:37:21,340 --> 01:37:24,309
in this case we just don't have that

1930
01:37:23,019 --> 01:37:27,309
because we're not really sharing memory

1931
01:37:24,309 --> 01:37:38,340
in that way but you know that's what

1932
01:37:27,309 --> 01:37:38,340
that is so I just want to get this

1933
01:37:49,609 --> 01:37:54,960
can you just tell me I just want you to

1934
01:37:52,619 --> 01:37:58,130
tell me how many processors there are

1935
01:37:54,960 --> 01:37:58,130
that's all I wanted

1936
01:38:05,289 --> 01:38:11,350
I'm just gonna use this so I'm going to

1937
01:38:09,100 --> 01:38:13,360
use VW number of processors and for now

1938
01:38:11,350 --> 01:38:21,490
we'll just call that good so here's the

1939
01:38:13,359 --> 01:38:25,769
system info get system info because I

1940
01:38:21,489 --> 01:38:30,539
don't remember how to get it on Windows

1941
01:38:25,770 --> 01:38:41,590
number processors done

1942
01:38:30,539 --> 01:38:43,899
oops so let me just take a look at what

1943
01:38:41,590 --> 01:38:46,090
that actually gave me because I don't

1944
01:38:43,899 --> 01:38:47,079
actually know oh wait we are printing

1945
01:38:46,090 --> 01:38:49,390
that out nevermind

1946
01:38:47,079 --> 01:38:51,579
so that correctly got the number so hey

1947
01:38:49,390 --> 01:38:53,530
that's good enough for now so this way

1948
01:38:51,579 --> 01:38:55,119
if we ran it on a you know maybe some of

1949
01:38:53,529 --> 01:38:56,619
you at home have saucy err machines than

1950
01:38:55,119 --> 01:39:01,319
I do that have like 32 cards or

1951
01:38:56,619 --> 01:39:01,319
something that way we would create more

1952
01:39:01,800 --> 01:39:07,210
more threads in those circumstances

1953
01:39:04,210 --> 01:39:09,369
which is what we would like to do so

1954
01:39:07,210 --> 01:39:16,210
that is the multi-threaded version of

1955
01:39:09,369 --> 01:39:18,760
the situation and yeah so we're now

1956
01:39:16,210 --> 01:39:20,920
pretty well multi-threaded so what we

1957
01:39:18,760 --> 01:39:26,070
need to do now is kind of extract this

1958
01:39:20,920 --> 01:39:29,319
part out a little bit and and you know

1959
01:39:26,069 --> 01:39:31,960
sort of make it clear what's win32 and

1960
01:39:29,319 --> 01:39:33,549
what's not so I may do that I might just

1961
01:39:31,960 --> 01:39:35,649
say you know because I hate to see

1962
01:39:33,550 --> 01:39:38,310
runtime library and I and I strongly

1963
01:39:35,649 --> 01:39:40,929
dislike the C Standards Committee and

1964
01:39:38,310 --> 01:39:42,580
sort of their bumbling around so I

1965
01:39:40,930 --> 01:39:47,500
really don't want to be involved in that

1966
01:39:42,579 --> 01:39:55,600
so I might just make a win32 Rea dot cpp

1967
01:39:47,500 --> 01:39:59,229
and put these functions in there so and

1968
01:39:55,600 --> 01:40:02,950
make it someone else's problem to port

1969
01:39:59,229 --> 01:40:09,369
it to their disaster so let's go ahead

1970
01:40:02,949 --> 01:40:12,970
and and put these in here and so this is

1971
01:40:09,369 --> 01:40:14,710
all we really need to do here and what

1972
01:40:12,970 --> 01:40:18,390
we can do is sort of define the

1973
01:40:14,710 --> 01:40:18,390
functions that we actually care about

1974
01:40:18,760 --> 01:40:57,610
raid on H where is that interlocked guy

1975
01:40:39,369 --> 01:41:03,399
ah we're behind my head no okay so in

1976
01:40:57,609 --> 01:41:06,779
theory that should be good all we now

1977
01:41:03,399 --> 01:41:12,219
need to do is actually use that win32

1978
01:41:06,779 --> 01:41:16,449
bit in there and so all we need to do

1979
01:41:12,220 --> 01:41:18,340
here is say like alright we need

1980
01:41:16,449 --> 01:41:21,010
something here that just tells us which

1981
01:41:18,340 --> 01:41:22,960
of these things we're gonna include so

1982
01:41:21,010 --> 01:41:27,039
we can say like you know maybe at the

1983
01:41:22,960 --> 01:41:31,390
bottom will just say include win32 array

1984
01:41:27,039 --> 01:41:41,380
dot cpp and we can even do this in the

1985
01:41:31,390 --> 01:41:44,530
build here we could say - d win32 plus 1

1986
01:41:41,380 --> 01:41:48,420
or something like this right rate

1987
01:41:44,529 --> 01:41:48,420
132-pound if

1988
01:41:56,618 --> 01:42:15,438
right uh and then like something like

1989
01:42:13,429 --> 01:42:19,368
this so if I don't have one in the build

1990
01:42:15,439 --> 01:42:20,809
its if I don't have one in ability it'll

1991
01:42:19,368 --> 01:42:22,038
say you need to define a platform if I

1992
01:42:20,809 --> 01:42:25,820
do have one in the build

1993
01:42:22,038 --> 01:42:30,108
it'll be fine and then people can port

1994
01:42:25,819 --> 01:42:32,688
those functions as necessary now the

1995
01:42:30,109 --> 01:42:35,149
raven 32 thing here one of the things i

1996
01:42:32,689 --> 01:42:39,320
would like this to have a last error

1997
01:42:35,149 --> 01:42:41,628
situation i think probably so i'm gonna

1998
01:42:39,319 --> 01:42:44,569
go ahead and crib off the handmade hero

1999
01:42:41,628 --> 01:42:47,979
build here and do one of those last

2000
01:42:44,569 --> 01:42:51,738
arrow jumps so after we do the compile

2001
01:42:47,979 --> 01:42:54,708
I'm gonna do a set last error and then

2002
01:42:51,738 --> 01:42:57,468
I'm gonna do a jump around it so where's

2003
01:42:54,708 --> 01:42:59,840
the last error here I want to do one of

2004
01:42:57,469 --> 01:43:04,059
those last error jumps so I'm gonna put

2005
01:42:59,840 --> 01:43:07,578
a thing here that like jumps around the

2006
01:43:04,059 --> 01:43:10,668
this thing that runs the actual ray

2007
01:43:07,578 --> 01:43:14,238
tracer so what I'd like to do is jump

2008
01:43:10,668 --> 01:43:20,229
around that last error now it gets it

2009
01:43:14,238 --> 01:43:26,178
guess we don't do that in here anywhere

2010
01:43:20,229 --> 01:43:28,099
and I forget the syntax that file jump

2011
01:43:26,179 --> 01:43:33,229
on last year

2012
01:43:28,099 --> 01:43:40,219
oh boy I'm on stackoverflow this may go

2013
01:43:33,229 --> 01:43:44,260
poorly uh I just want the if no I don't

2014
01:43:40,219 --> 01:43:44,260
want this is not what I wanted

2015
01:43:47,819 --> 01:43:52,049
this is not what I wanted all

2016
01:44:08,958 --> 01:44:24,769
I just want the jump call I just want

2017
01:44:16,340 --> 01:44:37,510
this so I assume I can do if last error

2018
01:44:24,769 --> 01:44:37,510
go to no streaming or go to and right I

2019
01:44:39,578 --> 01:44:50,228
assume I don't actually know going to

2020
01:44:47,538 --> 01:44:50,228
bend in there

2021
01:44:55,270 --> 01:45:18,880
ah let's see

2022
01:44:59,079 --> 01:45:20,710
I hate batch file syntax so I guess I

2023
01:45:18,880 --> 01:45:32,500
can just do equals equals zero I don't

2024
01:45:20,710 --> 01:45:37,260
know or not do I have to do that okay so

2025
01:45:32,500 --> 01:45:39,890
let me see now if I insert an error that

2026
01:45:37,260 --> 01:45:42,949
didn't work at all

2027
01:45:39,890 --> 01:45:42,949
[Music]

2028
01:45:51,899 --> 01:46:01,089
what does faster equal it equals zero so

2029
01:45:56,710 --> 01:46:09,399
why did oh I guess I want not equal to

2030
01:46:01,090 --> 01:46:18,489
zero is what I actually want so I'm

2031
01:46:09,399 --> 01:46:21,479
assuming I can do a knot there yeah so I

2032
01:46:18,489 --> 01:46:21,479
can do an if not

2033
01:46:32,210 --> 01:46:45,480
but it does equal zero I don't

2034
01:46:36,840 --> 01:46:49,050
understand there we go all right we

2035
01:46:45,479 --> 01:46:51,059
finally got the magic so I just wanted

2036
01:46:49,050 --> 01:46:52,560
to since we had some extra time I just

2037
01:46:51,060 --> 01:46:56,430
wanted to make it so it wouldn't run the

2038
01:46:52,560 --> 01:46:59,550
program any more if we weren't actually

2039
01:46:56,430 --> 01:47:01,470
using if we weren't actually using a

2040
01:46:59,550 --> 01:47:03,449
valid program all right so now we should

2041
01:47:01,470 --> 01:47:05,010
be able to crank up the hoop that's not

2042
01:47:03,449 --> 01:47:11,159
what I wanted we should be able to crank

2043
01:47:05,010 --> 01:47:13,530
up the Rea count here a bit for each of

2044
01:47:11,159 --> 01:47:16,710
the tiles so if we want to do raise four

2045
01:47:13,529 --> 01:47:19,050
pixel is like something high the

2046
01:47:16,710 --> 01:47:21,000
multi-threading should help us here so

2047
01:47:19,050 --> 01:47:23,070
you can see it still runs pretty quickly

2048
01:47:21,000 --> 01:47:26,460
like it's you know it's certainly a

2049
01:47:23,069 --> 01:47:28,979
useable speed with and we never like

2050
01:47:26,460 --> 01:47:32,130
that would have taken forever before

2051
01:47:28,979 --> 01:47:36,599
because 256 which was you know even half

2052
01:47:32,130 --> 01:47:38,699
of it was like barely working right so

2053
01:47:36,600 --> 01:47:40,740
just the multi-threading alone gets this

2054
01:47:38,699 --> 01:47:43,170
up to a much more usable level which is

2055
01:47:40,739 --> 01:47:45,449
nice and that's a pretty smooth image

2056
01:47:43,170 --> 01:47:51,630
you know like that's super useable we

2057
01:47:45,449 --> 01:47:54,149
haven't put in like actual like we

2058
01:47:51,630 --> 01:47:59,369
haven't put in any kind of real light

2059
01:47:54,149 --> 01:48:01,829
transfer so it's a little iffy in terms

2060
01:47:59,369 --> 01:48:03,000
of how slow that will become but at

2061
01:48:01,829 --> 01:48:07,590
least we're you know we're getting

2062
01:48:03,000 --> 01:48:10,680
better here right and yeah and so that's

2063
01:48:07,590 --> 01:48:14,819
nice it would be nice to put in a better

2064
01:48:10,680 --> 01:48:16,260
random number generator certainly but I

2065
01:48:14,819 --> 01:48:17,579
think we're basically out of time so I'm

2066
01:48:16,260 --> 01:48:20,010
gonna go overhead and go to the

2067
01:48:17,579 --> 01:48:27,019
questions and we'll leave it at that

2068
01:48:20,010 --> 01:48:32,329
let's verify that our that are sort of

2069
01:48:27,020 --> 01:48:32,330
here let's verify that our sort of test

2070
01:48:32,390 --> 01:48:38,010
runs well if I if I run it from the

2071
01:48:36,569 --> 01:48:40,139
command line like the printout still

2072
01:48:38,010 --> 01:48:42,600
works properly so it should like show us

2073
01:48:40,140 --> 01:48:45,860
a percentage here cleanly right and

2074
01:48:42,600 --> 01:48:45,860
printout properly and all that

2075
01:48:54,260 --> 01:48:57,130
off we go

2076
01:49:09,960 --> 01:49:13,719
and we should have we can sort of see

2077
01:49:12,219 --> 01:49:17,500
here is our first day's one you can see

2078
01:49:13,719 --> 01:49:23,109
that it gets a good bit smoother on our

2079
01:49:17,500 --> 01:49:25,929
next one right if we were saucy we could

2080
01:49:23,109 --> 01:49:28,658
like try to write out as well like what

2081
01:49:25,929 --> 01:49:33,789
the what the timing cat was so maybe

2082
01:49:28,658 --> 01:49:37,509
we'll do that let's let's just add one

2083
01:49:33,789 --> 01:49:39,969
more thing real quick well we can inside

2084
01:49:37,510 --> 01:49:46,750
the work you let's parameterize like the

2085
01:49:39,969 --> 01:49:53,368
rays per pixel in the bounces right so

2086
01:49:46,750 --> 01:49:53,368
let's use Q raised four pixel

2087
01:49:59,619 --> 01:50:11,840
what I might do here is actually let's

2088
01:50:02,239 --> 01:50:14,090
just do it this way so that way the race

2089
01:50:11,840 --> 01:50:24,560
for pixel's set that way and the bounce

2090
01:50:14,090 --> 01:50:33,789
count will be the same also sure but to

2091
01:50:24,560 --> 01:50:37,100
do it here just so we remember there's a

2092
01:50:33,789 --> 01:50:39,439
thing with not with needing to randomly

2093
01:50:37,100 --> 01:50:41,270
terminate it's a long story

2094
01:50:39,439 --> 01:50:45,529
we'll discuss that some day when we do

2095
01:50:41,270 --> 01:50:47,990
better light transport so if we set the

2096
01:50:45,529 --> 01:50:58,039
max bounce count and the rays per pixel

2097
01:50:47,989 --> 01:51:10,179
both in the queue right q max bounce

2098
01:50:58,039 --> 01:51:13,100
count just 8q graze pixel let's go 1024

2099
01:51:10,180 --> 01:51:18,140
the reason I wanted to do this was

2100
01:51:13,100 --> 01:51:22,160
because I'd like to print it out and I'm

2101
01:51:18,140 --> 01:51:26,050
gonna move the clock down to past the

2102
01:51:22,159 --> 01:51:26,050
business so we're just gonna do

2103
01:51:26,079 --> 01:51:31,100
basically everything after the sync

2104
01:51:29,319 --> 01:51:33,469
right so we're just going to time this

2105
01:51:31,100 --> 01:51:35,660
part of it

2106
01:51:33,470 --> 01:51:43,369
so I'm gonna go ahead here and say

2107
01:51:35,659 --> 01:51:48,430
configuration is this quality is raised

2108
01:51:43,369 --> 01:51:48,430
for pixel bounces

2109
01:52:10,319 --> 01:52:15,880
so now when we run it it should give us

2110
01:52:13,869 --> 01:52:19,239
like all the information that we need

2111
01:52:15,880 --> 01:52:24,359
right and it does so it's like says 1024

2112
01:52:19,239 --> 01:52:24,359
rays per pixel 8 max bounces per ray

2113
01:52:30,750 --> 01:52:45,399
maybe I should rephrase that to 8

2114
01:52:33,039 --> 01:52:47,970
bounces max and I think we're good I

2115
01:52:45,399 --> 01:52:47,969
think that's

2116
01:52:51,969 --> 01:52:55,140
that's sufficient

2117
01:52:59,760 --> 01:53:04,020
and so now yet we can produce a really

2118
01:53:02,340 --> 01:53:08,159
nice and smooth image right I mean it's

2119
01:53:04,020 --> 01:53:09,510
pretty good and you know mostly we're

2120
01:53:08,159 --> 01:53:11,760
just didn't want of lighting now that

2121
01:53:09,510 --> 01:53:13,440
doesn't take very long to do and the

2122
01:53:11,760 --> 01:53:16,170
other thing is we haven't sin deed yet

2123
01:53:13,439 --> 01:53:18,929
so the next thing we can do is is make

2124
01:53:16,170 --> 01:53:25,529
its indie and I think that will improve

2125
01:53:18,930 --> 01:53:29,880
it quite a bit so I think that's all

2126
01:53:25,529 --> 01:53:34,949
good let me go ahead and we'll save an

2127
01:53:29,880 --> 01:53:36,840
image off for this as well yeah all

2128
01:53:34,949 --> 01:53:46,050
right so let's go ahead and go to the

2129
01:53:36,840 --> 01:53:47,550
Q&amp;A here duratorq could you please make

2130
01:53:46,050 --> 01:53:49,020
a portal changing the rate position

2131
01:53:47,550 --> 01:53:50,909
orientation upon hitting the portal to

2132
01:53:49,020 --> 01:53:53,820
come out of the second portal and that's

2133
01:53:50,909 --> 01:53:56,119
I mean if we ever do geometry stuff sure

2134
01:53:53,819 --> 01:54:01,979
but that's kind of not really in line of

2135
01:53:56,119 --> 01:54:04,529
what we're doing here psionics do you

2136
01:54:01,979 --> 01:54:10,189
assume the x86 memory model in your code

2137
01:54:04,529 --> 01:54:13,159
I assume x86 arm basically because

2138
01:54:10,189 --> 01:54:16,589
there's nothing else to run on anymore

2139
01:54:13,159 --> 01:54:18,180
game code or server code doesn't run on

2140
01:54:16,590 --> 01:54:21,180
anything other than those two processors

2141
01:54:18,180 --> 01:54:29,039
so that's the memory model that I tend

2142
01:54:21,180 --> 01:54:30,180
to assume what about Const volatile and

2143
01:54:29,039 --> 01:54:32,460
register together in a circular

2144
01:54:30,180 --> 01:54:35,670
christian register is ignored register

2145
01:54:32,460 --> 01:54:38,180
doesn't doesn't do anything anymore for

2146
01:54:35,670 --> 01:54:38,180
most compilers

2147
01:54:40,139 --> 01:54:48,958
uh okay let me just get one more thing

2148
01:54:44,279 --> 01:54:56,578
done here let's close this down I'm

2149
01:54:48,958 --> 01:55:02,809
gonna go ahead and do build array oops

2150
01:54:56,578 --> 01:55:12,658
no I'm going to build Rea to 2017 10 22

2151
01:55:02,809 --> 01:55:17,599
second day commands text I suppose

2152
01:55:12,658 --> 01:55:17,598
standard error should really print out

2153
01:55:18,078 --> 01:55:23,248
so that we can capture the output that's

2154
01:55:21,328 --> 01:55:25,859
the stats and have standard error still

2155
01:55:23,248 --> 01:55:28,769
print out the rest of it you know what I

2156
01:55:25,859 --> 01:55:41,398
took it back I'm not quite done let me

2157
01:55:28,769 --> 01:55:45,439
do one more thing so let me just print a

2158
01:55:41,399 --> 01:55:45,439
standard error the status stuff

2159
01:55:54,319 --> 01:56:00,979
like so and that way we can pipe the

2160
01:55:58,829 --> 01:56:05,550
results if we want to capture them

2161
01:56:00,979 --> 01:56:07,109
configuration and quality and all that

2162
01:56:05,550 --> 01:56:13,369
stuff should go to standard print def

2163
01:56:07,109 --> 01:56:13,369
all right let me see here

2164
01:56:18,510 --> 01:56:23,600
so I assume that will work properly I'm

2165
01:56:20,520 --> 01:56:29,810
not 100% certain let's take a look here

2166
01:56:23,600 --> 01:56:33,750
so let's go to data now build rated X E

2167
01:56:29,810 --> 01:56:35,400
and that and we'll see if we get yeah

2168
01:56:33,750 --> 01:56:37,409
there we go

2169
01:56:35,399 --> 01:56:39,719
so I just wanted the status to always

2170
01:56:37,409 --> 01:56:41,279
print out here and thus all the rest of

2171
01:56:39,719 --> 01:56:44,189
the output goes to standard its standard

2172
01:56:41,279 --> 01:56:48,599
out what is there between path tracing

2173
01:56:44,189 --> 01:56:51,479
and ray tracing so really those are kind

2174
01:56:48,600 --> 01:56:53,430
of just like arbitrary terms because

2175
01:56:51,479 --> 01:56:55,019
path tracing still does do ray tracing

2176
01:56:53,430 --> 01:57:00,440
but they're generally used to

2177
01:56:55,020 --> 01:57:04,739
distinguish the difference between a a

2178
01:57:00,439 --> 01:57:07,259
ray tracer generally just is forward

2179
01:57:04,738 --> 01:57:09,179
doing bounces where it cast out array

2180
01:57:07,260 --> 01:57:12,949
sees what it hits casts and other races

2181
01:57:09,180 --> 01:57:15,600
what it hits cast another ray right and

2182
01:57:12,948 --> 01:57:19,738
it doesn't really consider the whole

2183
01:57:15,600 --> 01:57:22,949
path in any particular way path tracers

2184
01:57:19,738 --> 01:57:24,179
actually do so what a path tracer

2185
01:57:22,948 --> 01:57:25,979
there's a couple different kinds but

2186
01:57:24,180 --> 01:57:31,199
what a path tracer might do for example

2187
01:57:25,979 --> 01:57:33,899
is take a start the camera and a light

2188
01:57:31,198 --> 01:57:36,960
source and do rake casts that try to

2189
01:57:33,899 --> 01:57:39,779
connect the two of them together another

2190
01:57:36,960 --> 01:57:42,810
way might be to start with a ray tracer

2191
01:57:39,779 --> 01:57:46,409
that produces a bounce that goes from a

2192
01:57:42,810 --> 01:57:48,930
camera to an emitter but then after it

2193
01:57:46,409 --> 01:57:51,479
goes from a camera to an emitter it will

2194
01:57:48,930 --> 01:57:52,829
permute the path by taking things in the

2195
01:57:51,479 --> 01:57:55,049
middle of the path like bounce of the

2196
01:57:52,829 --> 01:58:00,149
middle path and re shooting to try and

2197
01:57:55,050 --> 01:58:03,179
connect those two right and so a path

2198
01:58:00,149 --> 01:58:04,379
tracer generally implies a ray tracer

2199
01:58:03,179 --> 01:58:07,800
that

2200
01:58:04,380 --> 01:58:09,569
thinks about the whole path somehow in a

2201
01:58:07,800 --> 01:58:12,840
way that an that just straightforward

2202
01:58:09,569 --> 01:58:16,079
bouncing wouldn't do so it tries to do

2203
01:58:12,840 --> 01:58:18,150
some permutations or some multi-sided

2204
01:58:16,079 --> 01:58:20,430
like by directionality you know things

2205
01:58:18,149 --> 01:58:25,199
like that it will try to take us an

2206
01:58:20,430 --> 01:58:26,730
account right so you know like a very

2207
01:58:25,199 --> 01:58:29,039
sophisticated version would be like

2208
01:58:26,729 --> 01:58:32,069
metropolis light transport for example

2209
01:58:29,039 --> 01:58:34,319
where it finds a stable path and then

2210
01:58:32,069 --> 01:58:36,299
does permutations on the path based on

2211
01:58:34,319 --> 01:58:41,609
probabilities that it thinks they will

2212
01:58:36,300 --> 01:58:44,640
that will create likely contributions to

2213
01:58:41,609 --> 01:58:46,739
the lighting equation as proportional to

2214
01:58:44,640 --> 01:58:49,260
their value proportional to their likely

2215
01:58:46,739 --> 01:58:51,329
contribution there's things like

2216
01:58:49,260 --> 01:58:54,090
manifold exploration where they'll try

2217
01:58:51,329 --> 01:58:56,760
to use they'll try to take one path from

2218
01:58:54,090 --> 01:59:00,420
an emitter to a to the camera and figure

2219
01:58:56,760 --> 01:59:03,239
out the boundaries around where the

2220
01:59:00,420 --> 01:59:07,710
various paths could work for that

2221
01:59:03,239 --> 01:59:09,510
emitter to to hit the camera right so

2222
01:59:07,710 --> 01:59:11,250
there's like a bunch of things you can

2223
01:59:09,510 --> 01:59:13,280
do there that are like sophisticated

2224
01:59:11,250 --> 01:59:15,810
ways of treating the light transport

2225
01:59:13,279 --> 01:59:18,979
exploration that don't just randomly

2226
01:59:15,810 --> 01:59:18,980
bounce around the scene

2227
01:59:24,220 --> 01:59:27,880
now that they're raised for pixel in max

2228
01:59:26,260 --> 01:59:29,050
bats count our parameters you could

2229
01:59:27,880 --> 01:59:30,640
potentially give different tiles

2230
01:59:29,050 --> 01:59:32,140
different settings to compare quality

2231
01:59:30,640 --> 01:59:34,360
side by side and say marriage that's

2232
01:59:32,140 --> 01:59:36,730
true you could if you wanted to you

2233
01:59:34,359 --> 01:59:38,729
could put raised four pics on max that's

2234
01:59:36,729 --> 01:59:41,799
count you could put those into the work

2235
01:59:38,729 --> 01:59:45,729
order if you wanted the different ones

2236
01:59:41,800 --> 01:59:48,659
to be different what do you think about

2237
01:59:45,729 --> 01:59:54,759
OpenMP I've never used it

2238
01:59:48,659 --> 01:59:57,399
what is Cindy Cindy is SMBs IMD single

2239
01:59:54,760 --> 01:59:59,199
instruction multiple data it just means

2240
01:59:57,399 --> 02:00:03,219
utilizing the fact that modern

2241
01:59:59,199 --> 02:00:06,119
processors both arm and x86 or x64 I

2242
02:00:03,220 --> 02:00:08,800
should say although x86 at it as well

2243
02:00:06,119 --> 02:00:11,619
they both have the concept of wide

2244
02:00:08,800 --> 02:00:14,440
instructions which are instructions that

2245
02:00:11,619 --> 02:00:18,099
do for example a floating put multiply

2246
02:00:14,439 --> 02:00:20,469
they do eight numbers times eight other

2247
02:00:18,100 --> 02:00:21,760
numbers at once or sixteen numbers times

2248
02:00:20,470 --> 02:00:25,780
sixteen other numbers at once with a

2249
02:00:21,760 --> 02:00:28,810
single instruction and so if you've got

2250
02:00:25,779 --> 02:00:30,759
perfect speed up by using those

2251
02:00:28,810 --> 02:00:32,680
instructions you could have eight times

2252
02:00:30,760 --> 02:00:34,600
faster or sixteen times faster execution

2253
02:00:32,680 --> 02:00:40,030
of your code or four times faster of

2254
02:00:34,600 --> 02:00:42,760
using the older sse stuff avx2 and

2255
02:00:40,029 --> 02:00:47,889
avx-512 are the eight they go 8 and 16

2256
02:00:42,760 --> 02:00:49,480
wide um so that's a good way to increase

2257
02:00:47,890 --> 02:00:51,369
for entry code you usually don't get the

2258
02:00:49,479 --> 02:00:53,409
full 8x or 16x is usually there's a

2259
02:00:51,369 --> 02:00:54,880
bunch of stuff that's not expandable to

2260
02:00:53,409 --> 02:00:56,199
the full width and there's work that has

2261
02:00:54,880 --> 02:00:58,359
to be done there so you don't typically

2262
02:00:56,199 --> 02:01:00,939
get a full speed up but you do get a

2263
02:00:58,359 --> 02:01:06,189
significant speed up usually and so

2264
02:01:00,939 --> 02:01:08,559
that's what Cindy is do you get effects

2265
02:01:06,189 --> 02:01:10,779
like bloom or lens there for free if you

2266
02:01:08,560 --> 02:01:16,539
implement more realistic camera stuff

2267
02:01:10,779 --> 02:01:20,079
yes if you if you leave those scare

2268
02:01:16,539 --> 02:01:21,550
quotes on for free you do but it's

2269
02:01:20,079 --> 02:01:25,420
important to know what those scare

2270
02:01:21,550 --> 02:01:30,550
quotes mean so if you implement a real

2271
02:01:25,420 --> 02:01:31,840
lens and film aperture then bloom and

2272
02:01:30,550 --> 02:01:34,869
lens flare and things like that will

2273
02:01:31,840 --> 02:01:36,828
happen automatically the problem is that

2274
02:01:34,869 --> 02:01:40,340
it isn't

2275
02:01:36,828 --> 02:01:42,649
in terms of computation right so things

2276
02:01:40,340 --> 02:01:46,909
like bloom happened because of halation

2277
02:01:42,649 --> 02:01:48,948
on the image plane and you have to that

2278
02:01:46,908 --> 02:01:52,219
means you have to actually raycast

2279
02:01:48,948 --> 02:01:54,138
hail hail ation raised right you have to

2280
02:01:52,219 --> 02:01:59,230
actually penetrate the film back and

2281
02:01:54,139 --> 02:02:02,659
bounce back up into the the film

2282
02:01:59,229 --> 02:02:04,939
substrate you for things like lens star

2283
02:02:02,658 --> 02:02:09,769
you have to be accurately modeling the

2284
02:02:04,939 --> 02:02:11,178
optics of the lens through the glass in

2285
02:02:09,770 --> 02:02:16,250
multiple places in order to get the

2286
02:02:11,179 --> 02:02:17,599
flare to occur so you know it's for free

2287
02:02:16,250 --> 02:02:19,578
in the sense that if you model

2288
02:02:17,599 --> 02:02:22,219
everything accurately you'll get those

2289
02:02:19,578 --> 02:02:24,139
effects but it's in no way free in terms

2290
02:02:22,219 --> 02:02:25,670
of sampling cost the same thing cost

2291
02:02:24,139 --> 02:02:27,618
goes up dramatically in order to capture

2292
02:02:25,670 --> 02:02:29,300
those effects because you have to

2293
02:02:27,618 --> 02:02:31,819
actually simulate those things so

2294
02:02:29,300 --> 02:02:34,309
oftentimes it will behoove you to not do

2295
02:02:31,819 --> 02:02:36,679
them 100% realistically anyway because

2296
02:02:34,309 --> 02:02:38,659
you'd get a lot faster image for the

2297
02:02:36,679 --> 02:02:46,849
same quality as if you tried to actually

2298
02:02:38,658 --> 02:02:48,408
simulate like real halation isn't

2299
02:02:46,849 --> 02:02:49,880
uniform random sampling bad I thought

2300
02:02:48,408 --> 02:02:50,960
you need to use blue noise or prasanta

2301
02:02:49,880 --> 02:02:52,940
sampling or something

2302
02:02:50,960 --> 02:02:55,760
yes uniform random sampling is not a

2303
02:02:52,939 --> 02:02:58,399
good idea for two reasons one is because

2304
02:02:55,760 --> 02:03:01,460
yeah you would like to use sampling

2305
02:02:58,399 --> 02:03:04,759
patterns that are more suited to

2306
02:03:01,460 --> 02:03:06,939
avoiding ringing artifacts or bar

2307
02:03:04,760 --> 02:03:10,579
banding artifacts or things like that so

2308
02:03:06,939 --> 02:03:13,279
yes and also the other thing that's bad

2309
02:03:10,578 --> 02:03:16,908
about uniform random sampling is right

2310
02:03:13,279 --> 02:03:20,868
now we are not doing any work to try and

2311
02:03:16,908 --> 02:03:26,319
get the samples to properly sample the

2312
02:03:20,868 --> 02:03:28,848
space based on importance or anything so

2313
02:03:26,319 --> 02:03:30,380
generally speaking as you go and

2314
02:03:28,849 --> 02:03:32,420
implement better material handling

2315
02:03:30,380 --> 02:03:34,789
you're gonna want to put good sampling

2316
02:03:32,420 --> 02:03:36,849
in there right we are not doing any of

2317
02:03:34,789 --> 02:03:36,849
that

2318
02:03:39,890 --> 02:03:44,900
sigh knocks our memory model is

2319
02:03:42,020 --> 02:03:52,520
extremely relaxed though I don't think

2320
02:03:44,899 --> 02:03:57,049
it's extremely relaxed arm has a pretty

2321
02:03:52,520 --> 02:03:58,490
reasonable memory model so you mentioned

2322
02:03:57,050 --> 02:04:00,710
that hyper threading can schedule

2323
02:03:58,489 --> 02:04:03,079
instructions on separate bail use of the

2324
02:04:00,710 --> 02:04:04,699
same core did I hear that correctly or

2325
02:04:03,079 --> 02:04:12,590
did I miss construe what you said in my

2326
02:04:04,699 --> 02:04:16,279
mind I'm not sure exactly how to

2327
02:04:12,590 --> 02:04:22,640
interpret the question a core has some

2328
02:04:16,279 --> 02:04:26,630
number of ail use on it right so if you

2329
02:04:22,640 --> 02:04:28,760
take a single core let's say it has 2

2330
02:04:26,630 --> 02:04:30,260
units that can issue a multiply so it's

2331
02:04:28,760 --> 02:04:31,340
got 2 multipliers on it or something

2332
02:04:30,260 --> 02:04:34,430
right

2333
02:04:31,340 --> 02:04:37,039
whatever making this up so let's say

2334
02:04:34,430 --> 02:04:39,200
it's got two multiplied units on it then

2335
02:04:37,039 --> 02:04:41,239
what that means is that if I'm looking

2336
02:04:39,199 --> 02:04:43,819
at the instruction window for one of my

2337
02:04:41,239 --> 02:04:45,769
threads and I see two multiplies that I

2338
02:04:43,819 --> 02:04:48,920
can issue I can issue them both and

2339
02:04:45,770 --> 02:04:50,990
they'll just go start doing the work but

2340
02:04:48,920 --> 02:04:53,420
then if I need to issue a third multiply

2341
02:04:50,989 --> 02:04:55,039
that multiply can't issue into one of

2342
02:04:53,420 --> 02:04:56,989
those other multiplies completes because

2343
02:04:55,039 --> 02:05:00,500
there are no more arithmetic logic units

2344
02:04:56,989 --> 02:05:04,609
available so if the instruction window

2345
02:05:00,500 --> 02:05:06,590
is large enough and there's enough

2346
02:05:04,609 --> 02:05:08,929
multiply stacked up without other things

2347
02:05:06,590 --> 02:05:11,390
happening that might block them then a

2348
02:05:08,930 --> 02:05:14,270
single thread can utilize all the

2349
02:05:11,390 --> 02:05:16,940
multiply units of a core and you don't

2350
02:05:14,270 --> 02:05:19,820
have to worry about it right however if

2351
02:05:16,939 --> 02:05:21,500
there's stuff in between there that

2352
02:05:19,819 --> 02:05:23,630
would stall it so there aren't enough

2353
02:05:21,500 --> 02:05:26,390
multiplies to feed the number of

2354
02:05:23,630 --> 02:05:28,400
multiply units that are there then what

2355
02:05:26,390 --> 02:05:31,220
hyper threading could do is it can look

2356
02:05:28,399 --> 02:05:32,539
to the other thread on that core because

2357
02:05:31,220 --> 02:05:35,840
hyper threading remember there's two

2358
02:05:32,539 --> 02:05:37,159
threads on a core right it can look at

2359
02:05:35,840 --> 02:05:40,640
the instruction window from the other

2360
02:05:37,159 --> 02:05:44,210
thread and if that one has a multiply it

2361
02:05:40,640 --> 02:05:48,050
can issue that multiply on the ALU that

2362
02:05:44,210 --> 02:05:49,579
is that is currently fallow so what you

2363
02:05:48,050 --> 02:05:51,440
can think of hyper threading is doing is

2364
02:05:49,579 --> 02:05:53,869
hyper threading is basically a way of

2365
02:05:51,439 --> 02:05:57,379
pulling instructions

2366
02:05:53,869 --> 02:05:59,329
from two threads at once based on what

2367
02:05:57,380 --> 02:06:01,550
is available on the chip to execute and

2368
02:05:59,329 --> 02:06:06,470
this is true for things that are not L

2369
02:06:01,550 --> 02:06:09,470
use as well basically any execution port

2370
02:06:06,470 --> 02:06:11,690
on the CPU that can do something if they

2371
02:06:09,470 --> 02:06:14,030
can find and available ready to execute

2372
02:06:11,689 --> 02:06:16,369
instruction on either of the two hyper

2373
02:06:14,029 --> 02:06:18,050
threads it can start utilizing that

2374
02:06:16,369 --> 02:06:20,390
instruction port that otherwise would

2375
02:06:18,050 --> 02:06:23,050
have gone fallow because the other core

2376
02:06:20,390 --> 02:06:27,460
just doesn't have a need for it right

2377
02:06:23,050 --> 02:06:27,460
and so that's what hyper threading does

2378
02:06:29,590 --> 02:06:33,470
would you change anything if you're

2379
02:06:31,550 --> 02:06:37,430
using a Rison thread Ripper CPU that has

2380
02:06:33,470 --> 02:06:39,199
four core core complexes um no but only

2381
02:06:37,430 --> 02:06:42,289
because I have never programmed their

2382
02:06:39,199 --> 02:06:47,389
eyes and thread Ripper before so I don't

2383
02:06:42,289 --> 02:06:51,170
know what its behavior is like when I

2384
02:06:47,390 --> 02:06:53,240
get more experience with that CPU

2385
02:06:51,170 --> 02:06:55,369
architecture I may have more opinions on

2386
02:06:53,239 --> 02:06:56,659
it but at the moment I wouldn't suspect

2387
02:06:55,369 --> 02:06:57,710
you need to do anything really much

2388
02:06:56,659 --> 02:07:00,019
because this is a pretty simple

2389
02:06:57,710 --> 02:07:01,699
multi-threaded program in that the cores

2390
02:07:00,020 --> 02:07:03,650
are completely that the threads are

2391
02:07:01,699 --> 02:07:05,869
completely disagree today don't share

2392
02:07:03,649 --> 02:07:07,460
memory almost at all so in theory you

2393
02:07:05,869 --> 02:07:08,689
should shouldn't have to worry too much

2394
02:07:07,460 --> 02:07:10,300
about the underlying architecture

2395
02:07:08,689 --> 02:07:12,349
because this is a very simple program

2396
02:07:10,300 --> 02:07:13,760
typically you only need to start

2397
02:07:12,350 --> 02:07:14,990
thinking about other architectures

2398
02:07:13,760 --> 02:07:16,550
really hard when you have a lot of

2399
02:07:14,989 --> 02:07:21,649
memory sharing or complicated stuff

2400
02:07:16,550 --> 02:07:22,970
happening can you give a quick overview

2401
02:07:21,649 --> 02:07:26,539
of how important Symphony works

2402
02:07:22,970 --> 02:07:28,220
no because it's very complicated why

2403
02:07:26,539 --> 02:07:33,409
were you trying to kill me I was working

2404
02:07:28,220 --> 02:07:36,680
very hard from Ray caster because I

2405
02:07:33,409 --> 02:07:38,389
needed to make changes to you could you

2406
02:07:36,680 --> 02:07:42,680
maybe do a GTA information on test rooms

2407
02:07:38,390 --> 02:07:46,250
sometime maybe in the future but that

2408
02:07:42,680 --> 02:07:49,400
that'd be a ways off is avx2 khan enough

2409
02:07:46,250 --> 02:07:50,510
to use it in a game probably not at this

2410
02:07:49,399 --> 02:07:52,399
point

2411
02:07:50,510 --> 02:07:54,320
it's common enough that you might want

2412
02:07:52,399 --> 02:07:57,349
to use it in advanced features in a game

2413
02:07:54,319 --> 02:07:58,880
so for example if you have an ability to

2414
02:07:57,350 --> 02:08:01,280
test you you could just look at the CPU

2415
02:07:58,880 --> 02:08:03,560
doesn't have a DX to use this fast path

2416
02:08:01,279 --> 02:08:05,569
for X some extra bonus feature like

2417
02:08:03,560 --> 02:08:07,370
better blah or whatever like faster

2418
02:08:05,569 --> 02:08:09,619
physics more physics I don't

2419
02:08:07,369 --> 02:08:11,180
no but whatever you're doing if it's an

2420
02:08:09,619 --> 02:08:13,039
optional feature you can turn on and off

2421
02:08:11,180 --> 02:08:16,880
that might be a reason to use a VX - I

2422
02:08:13,039 --> 02:08:18,560
wouldn't require it unless you're just a

2423
02:08:16,880 --> 02:08:21,680
strictly unless your game already

2424
02:08:18,560 --> 02:08:23,300
requires a CPU so powerful that you know

2425
02:08:21,680 --> 02:08:25,280
it will always have it right what you

2426
02:08:23,300 --> 02:08:26,570
might you might already be doing that so

2427
02:08:25,279 --> 02:08:28,639
you have to kind of make that call there

2428
02:08:26,569 --> 02:08:32,420
well the ratio HR program in the future

2429
02:08:28,640 --> 02:08:34,640
use GPU does rate races nope where can

2430
02:08:32,420 --> 02:08:36,199
we find the code the next time I update

2431
02:08:34,640 --> 02:08:38,329
the handmade hero code so next weekend

2432
02:08:36,199 --> 02:08:40,399
when I up load the next day of handmade

2433
02:08:38,329 --> 02:08:47,269
hero code it will be in the repository

2434
02:08:40,399 --> 02:08:49,489
and the downloadable would it be more

2435
02:08:47,270 --> 02:08:51,350
sufficient to make an entry for each ray

2436
02:08:49,489 --> 02:08:53,689
to split up the work more evenly and

2437
02:08:51,350 --> 02:08:55,820
also this could work on the GPU no you

2438
02:08:53,689 --> 02:08:58,129
never want to go per ray that's too

2439
02:08:55,819 --> 02:09:01,519
granular so the amount of overhead and

2440
02:08:58,130 --> 02:09:04,420
dispatching per ray is is not good right

2441
02:09:01,520 --> 02:09:07,040
you need to have a much bigger bundle

2442
02:09:04,420 --> 02:09:09,079
than a single ray because otherwise the

2443
02:09:07,039 --> 02:09:12,050
overhead of work management and dispatch

2444
02:09:09,079 --> 02:09:17,239
becomes dominant and you don't really

2445
02:09:12,050 --> 02:09:19,340
want that how much different is this ray

2446
02:09:17,239 --> 02:09:20,479
tracer to those that with live previews

2447
02:09:19,340 --> 02:09:22,640
where you see the image get better

2448
02:09:20,479 --> 02:09:24,049
starting low res and go higher and

2449
02:09:22,640 --> 02:09:26,360
higher I assume they don't render line

2450
02:09:24,050 --> 02:09:28,699
by line so the way you would do that is

2451
02:09:26,359 --> 02:09:30,759
you just do one ray per pixel for all

2452
02:09:28,699 --> 02:09:35,149
pixels and then go back and do another

2453
02:09:30,760 --> 02:09:38,210
pass right so you're constantly doing

2454
02:09:35,149 --> 02:09:41,229
one ray per pixel over and over and over

2455
02:09:38,210 --> 02:09:45,470
and so right now right like you can see

2456
02:09:41,229 --> 02:09:48,859
the way that we're doing that in in here

2457
02:09:45,470 --> 02:09:51,409
we've got a loop raised per pixel right

2458
02:09:48,859 --> 02:09:53,179
and we just accumulate the Rays for

2459
02:09:51,409 --> 02:09:56,869
pixel and then output a single value

2460
02:09:53,180 --> 02:09:59,030
what you do instead is you save this

2461
02:09:56,869 --> 02:10:01,369
final color plus config sample what you

2462
02:09:59,029 --> 02:10:02,869
actually do is you make final color be

2463
02:10:01,369 --> 02:10:08,000
you basically make an image that's a

2464
02:10:02,869 --> 02:10:08,300
float image and you do this contribute a

2465
02:10:08,000 --> 02:10:11,149
s--t

2466
02:10:08,300 --> 02:10:13,220
you do that accumulation right and then

2467
02:10:11,149 --> 02:10:15,259
you just every time you finish one pass

2468
02:10:13,220 --> 02:10:19,550
for the image one ray per pixel which is

2469
02:10:15,260 --> 02:10:20,940
relatively quick right you output a new

2470
02:10:19,550 --> 02:10:22,630
preview

2471
02:10:20,939 --> 02:10:25,269
that's what that's the only difference

2472
02:10:22,630 --> 02:10:26,800
are there any things that you need to do

2473
02:10:25,270 --> 02:10:28,090
take advantage of hyper-threading CPUs

2474
02:10:26,800 --> 02:10:29,920
or do you treat threading the same as a

2475
02:10:28,090 --> 02:10:32,409
non hyper threading CPU yeah you don't

2476
02:10:29,920 --> 02:10:34,770
really need to do anything specific for

2477
02:10:32,409 --> 02:10:37,329
this usage case because of the memory

2478
02:10:34,770 --> 02:10:38,680
pattern is very simple if you have more

2479
02:10:37,329 --> 02:10:41,619
complex memory patterns you do have to

2480
02:10:38,680 --> 02:10:44,260
think about it because since cores two

2481
02:10:41,619 --> 02:10:46,119
hyper threads on one core share a cache

2482
02:10:44,260 --> 02:10:49,000
they share that least the l1 cache and

2483
02:10:46,119 --> 02:10:51,550
probably the l2 cache so what that means

2484
02:10:49,000 --> 02:10:53,020
is that in that scenario you want to

2485
02:10:51,550 --> 02:10:55,060
make sure that those two hyper threads

2486
02:10:53,020 --> 02:10:59,200
as much as possible are using the same

2487
02:10:55,060 --> 02:11:01,780
memory areas so if you have a more

2488
02:10:59,199 --> 02:11:04,479
complex memory layout and usage then we

2489
02:11:01,779 --> 02:11:06,329
have in this example where you're

2490
02:11:04,479 --> 02:11:09,639
actually caring about how cache

2491
02:11:06,329 --> 02:11:11,229
utilization is working meaning if you

2492
02:11:09,640 --> 02:11:13,090
have a work set that's bigger than the

2493
02:11:11,229 --> 02:11:16,000
cache then you want to try and keep

2494
02:11:13,090 --> 02:11:19,029
things that use similar memory access

2495
02:11:16,000 --> 02:11:20,649
patterns on the same core so those two

2496
02:11:19,029 --> 02:11:23,309
hyper threads should be similar memory

2497
02:11:20,649 --> 02:11:23,309
access patterns

2498
02:11:32,470 --> 02:11:38,960
all right so someone was asking about

2499
02:11:36,890 --> 02:11:43,940
that memory writer was posting a thing

2500
02:11:38,960 --> 02:11:45,199
for our memory model let me take me open

2501
02:11:43,939 --> 02:11:51,159
that up real quick here and then I'm

2502
02:11:45,199 --> 02:11:51,159
gonna end the stream here we go

2503
02:11:51,430 --> 02:11:55,630
doot doot doot doot doot

2504
02:12:04,239 --> 02:12:09,199
there's a lot of this is a bit big you

2505
02:12:07,100 --> 02:12:19,420
said page 20 so hopefully I can skip to

2506
02:12:09,199 --> 02:12:19,420
just page 20 here where is that

2507
02:12:21,199 --> 02:12:25,609
this is not a very concise summary

2508
02:12:31,779 --> 02:12:36,639
where am I supposed to be looking this

2509
02:12:33,619 --> 02:12:39,380
is way too big I don't really need this

2510
02:12:36,640 --> 02:12:41,119
the only thing you care about is whether

2511
02:12:39,380 --> 02:12:46,100
or not it Rio doors around a locked

2512
02:12:41,119 --> 02:12:47,809
increment right that's it

2513
02:12:46,100 --> 02:12:50,210
if it doesn't reorder around a locked

2514
02:12:47,810 --> 02:12:51,710
increment that's all you need to know or

2515
02:12:50,210 --> 02:12:53,239
I'm sorry like a like a locked

2516
02:12:51,710 --> 02:12:55,100
instruction right so whatever it's

2517
02:12:53,239 --> 02:12:57,079
compare exchange a stretch instruction

2518
02:12:55,100 --> 02:12:58,579
is if it doesn't reorder around the

2519
02:12:57,079 --> 02:13:01,100
compare exchange you're pretty much done

2520
02:12:58,579 --> 02:13:02,479
right if it does reorder around the

2521
02:13:01,100 --> 02:13:05,510
compare exchange then you have

2522
02:13:02,479 --> 02:13:08,299
additional issues to worry about and so

2523
02:13:05,510 --> 02:13:12,260
that's most of what I would say you care

2524
02:13:08,300 --> 02:13:13,579
about if arms memory model is relaxed

2525
02:13:12,260 --> 02:13:18,680
enough that it reorder is around a

2526
02:13:13,579 --> 02:13:20,809
compare exchange then I would just which

2527
02:13:18,680 --> 02:13:23,570
I don't think it does but if it does you

2528
02:13:20,810 --> 02:13:25,970
just include a barrier you include a

2529
02:13:23,569 --> 02:13:28,549
fence when you call that function and

2530
02:13:25,970 --> 02:13:30,020
then you're done so that's really all

2531
02:13:28,550 --> 02:13:32,630
you need to know about the memory model

2532
02:13:30,020 --> 02:13:35,450
because I'm pretty sure arm will not do

2533
02:13:32,630 --> 02:13:38,270
that right it will not reorder it's

2534
02:13:35,449 --> 02:13:44,420
trivial to just fence your mutex and

2535
02:13:38,270 --> 02:13:46,010
then you're done so the only CPUs that

2536
02:13:44,420 --> 02:13:47,300
we're really weird is like the power pcs

2537
02:13:46,010 --> 02:13:50,960
and things like that where you had all

2538
02:13:47,300 --> 02:13:52,460
kinds of weird sorts of read things you

2539
02:13:50,960 --> 02:13:55,300
had to manage and just strange things

2540
02:13:52,460 --> 02:13:58,359
going on and those were just yeah

2541
02:13:55,300 --> 02:14:00,710
nowadays you really just don't have to

2542
02:13:58,359 --> 02:14:02,979
worry about that particularly much I

2543
02:14:00,710 --> 02:14:02,980
don't think

2544
02:14:03,010 --> 02:14:06,699
page 349

2545
02:14:07,979 --> 02:14:33,199
okay I'll take a quick look 349 is where

2546
02:14:19,979 --> 02:14:35,579
is 349 nope nope ah let's see

2547
02:14:33,198 --> 02:14:42,678
dependent those rear atomic instructions

2548
02:14:35,578 --> 02:14:42,679
reordered with stores here we go

2549
02:14:49,659 --> 02:14:57,939
so armed 64 AR is the one we're looking

2550
02:14:55,659 --> 02:15:00,119
at here I assume the rest of these we

2551
02:14:57,939 --> 02:15:04,960
don't care about right like MIPS

2552
02:15:00,119 --> 02:15:07,269
whatever so it looks like with atomic

2553
02:15:04,960 --> 02:15:09,010
instructions reordered with stores is

2554
02:15:07,270 --> 02:15:10,990
the one you care about so I would say

2555
02:15:09,010 --> 02:15:12,610
all you have to do yeah

2556
02:15:10,989 --> 02:15:15,760
like literally all you have to do is

2557
02:15:12,609 --> 02:15:18,549
just put in the fence put in a store

2558
02:15:15,760 --> 02:15:21,699
fence and I probably put in a load fence

2559
02:15:18,550 --> 02:15:23,860
to a low defense in a store fence right

2560
02:15:21,699 --> 02:15:26,260
next to your atomic increment your

2561
02:15:23,859 --> 02:15:27,369
atomic exchange and then that's it right

2562
02:15:26,260 --> 02:15:30,070
you don't have to worry about it

2563
02:15:27,369 --> 02:15:31,689
assuming that they allow you to do that

2564
02:15:30,069 --> 02:15:33,819
that's really the only thing you have to

2565
02:15:31,689 --> 02:15:37,619
do and then you're pretty much done

2566
02:15:33,819 --> 02:15:40,719
because that's what you worry about on

2567
02:15:37,619 --> 02:15:48,309
x64 as well or AMD 64 is what they call

2568
02:15:40,720 --> 02:15:51,119
it on this on this list right and then

2569
02:15:48,310 --> 02:15:51,120
and then you're good to go

2570
02:16:01,920 --> 02:16:05,250
yeah and in like I saying you just want

2571
02:16:03,988 --> 02:16:07,678
to make sure that your interlock

2572
02:16:05,250 --> 02:16:11,460
function does that that's all you need

2573
02:16:07,679 --> 02:16:17,389
to do and then off you go

2574
02:16:11,460 --> 02:16:23,219
I generally yeah I generally don't I I

2575
02:16:17,389 --> 02:16:27,029
try not to write code that cleverly

2576
02:16:23,219 --> 02:16:29,149
works without an interlock function if

2577
02:16:27,029 --> 02:16:34,199
that makes sense

2578
02:16:29,149 --> 02:16:38,159
not so much I guess because I'm worried

2579
02:16:34,200 --> 02:16:39,840
about arm or something but more because

2580
02:16:38,159 --> 02:16:43,648
or you know a weaker memory model the

2581
02:16:39,840 --> 02:16:48,030
NEX 64 but more just because I don't

2582
02:16:43,648 --> 02:16:53,308
want I find that I may miss something in

2583
02:16:48,030 --> 02:16:55,739
that case if that's you know like I feel

2584
02:16:53,308 --> 02:16:57,449
like it's too easy to be overly clever

2585
02:16:55,739 --> 02:16:58,709
and then make some change the code and

2586
02:16:57,450 --> 02:17:01,200
forget that that will break it or

2587
02:16:58,709 --> 02:17:04,558
something so I you generally try to make

2588
02:17:01,200 --> 02:17:09,870
my stuff work around work with a compare

2589
02:17:04,558 --> 02:17:11,459
exchange and have that be a sync point

2590
02:17:09,870 --> 02:17:13,439
where I just assume everything

2591
02:17:11,459 --> 02:17:16,079
synchronized at that point and I don't

2592
02:17:13,439 --> 02:17:18,510
assume anything in particular happens

2593
02:17:16,079 --> 02:17:20,189
outside that point because I find that

2594
02:17:18,510 --> 02:17:21,780
if I try to be more clever than that

2595
02:17:20,189 --> 02:17:24,090
which you can be right

2596
02:17:21,780 --> 02:17:26,309
especially on x64 you could be way more

2597
02:17:24,090 --> 02:17:29,250
clever than that because it almost it

2598
02:17:26,308 --> 02:17:33,449
basically has extremely enforced memory

2599
02:17:29,250 --> 02:17:38,040
ordering most of the time like it's the

2600
02:17:33,450 --> 02:17:39,120
most enforced you can pretty much be you

2601
02:17:38,040 --> 02:17:41,910
can be way cleverer than that I just

2602
02:17:39,120 --> 02:17:43,740
don't tend to do that because I feel

2603
02:17:41,909 --> 02:17:46,289
like it's too easy to make a mistake and

2604
02:17:43,739 --> 02:17:48,478
think that you did it right but you

2605
02:17:46,290 --> 02:17:50,729
really didn't so I don't really tend to

2606
02:17:48,478 --> 02:17:53,358
do that code and I tend to assume that

2607
02:17:50,728 --> 02:17:56,968
my lock increment will include a barrier

2608
02:17:53,359 --> 02:18:00,090
which it automatically will on Intel in

2609
02:17:56,968 --> 02:18:03,598
all cases but yeah it looks like maybe

2610
02:18:00,090 --> 02:18:05,219
arm doesn't I didn't think that was true

2611
02:18:03,599 --> 02:18:09,079
of harm but it's been a while

2612
02:18:05,218 --> 02:18:12,058
so I'm actually surprised at that I

2613
02:18:09,079 --> 02:18:15,420
didn't think they did do that reordering

2614
02:18:12,058 --> 02:18:18,009
but maybe they do now so you know

2615
02:18:15,420 --> 02:18:24,550
next time I program an arm I'll take a

2616
02:18:18,010 --> 02:18:29,729
look alright so you know what we also

2617
02:18:24,550 --> 02:18:29,729
should I guess I'll notate that as well

2618
02:18:41,850 --> 02:18:45,149
so there we go

2619
02:18:45,159 --> 02:18:50,979
all right I think oops did I not save

2620
02:18:48,489 --> 02:18:51,940
that there we go I think that's it for

2621
02:18:50,979 --> 02:18:55,090
today

2622
02:18:51,940 --> 02:19:00,340
I'm gonna save off our second day image

2623
02:18:55,090 --> 02:19:02,050
here as well so our first day's image

2624
02:19:00,340 --> 02:19:03,579
and our second day's image are really no

2625
02:19:02,050 --> 02:19:05,379
different other than the fact that we

2626
02:19:03,579 --> 02:19:07,440
sped it up quite a bit and I also saved

2627
02:19:05,379 --> 02:19:12,069
here what the configuration was we used

2628
02:19:07,440 --> 02:19:14,440
so we know we have eight cores see far

2629
02:19:12,069 --> 02:19:16,690
so tiles we did 1024 rays per pixel with

2630
02:19:14,440 --> 02:19:18,040
eight maximum bounces the total number

2631
02:19:16,690 --> 02:19:22,210
of bounces that we ended up recording

2632
02:19:18,040 --> 02:19:26,051
was this many and here's our performance

2633
02:19:22,209 --> 02:19:29,409
per bounce right and so we think we did

2634
02:19:26,050 --> 02:19:31,180
all that correctly hopefully and you

2635
02:19:29,409 --> 02:19:32,379
know someday when we decide to do a

2636
02:19:31,180 --> 02:19:35,680
little bit more work on the Ray tracer

2637
02:19:32,379 --> 02:19:37,000
we can implement better lighting

2638
02:19:35,680 --> 02:19:39,399
calculations and we'll see how that

2639
02:19:37,000 --> 02:19:41,350
effects it we could also sim the eyes it

2640
02:19:39,399 --> 02:19:44,260
at some point when we're in the mood to

2641
02:19:41,350 --> 02:19:46,450
make it Cindy and then we can make it

2642
02:19:44,260 --> 02:19:48,640
again maybe four times faster or

2643
02:19:46,450 --> 02:19:52,181
something like that hopefully so we get

2644
02:19:48,640 --> 02:19:56,310
another speed boost there before laying

2645
02:19:52,181 --> 02:20:00,790
in a bunch of gnarly math computations

2646
02:19:56,310 --> 02:20:03,399
for doing our images right anyway that's

2647
02:20:00,790 --> 02:20:07,030
it for handmade Hiro for today thanks

2648
02:20:03,399 --> 02:20:09,369
everyone for joining me - next weekend I

2649
02:20:07,030 --> 02:20:11,261
think we'll go back to doing regular

2650
02:20:09,370 --> 02:20:14,190
handmade Hiro programming where we'll

2651
02:20:11,261 --> 02:20:17,801
try to get some lighting again actually

2652
02:20:14,190 --> 02:20:19,840
working in the game now which we wanted

2653
02:20:17,800 --> 02:20:21,159
to do GPU accelerated which does a

2654
02:20:19,840 --> 02:20:25,030
little bit of red casting actually just

2655
02:20:21,159 --> 02:20:26,560
not for the entire image so we'll be

2656
02:20:25,030 --> 02:20:27,550
back on that next weekend hopefully I'd

2657
02:20:26,560 --> 02:20:30,788
be here

2658
02:20:27,549 --> 02:20:32,288
for that till then keep in mind if you

2659
02:20:30,789 --> 02:20:35,229
would like to play around with handmade

2660
02:20:32,289 --> 02:20:36,729
hero source code and I will next weekend

2661
02:20:35,228 --> 02:20:39,129
when the source code gets updated I will

2662
02:20:36,728 --> 02:20:41,438
also include the raycasting source so

2663
02:20:39,129 --> 02:20:42,608
that if you want play around that you

2664
02:20:41,439 --> 02:20:43,869
can always pro2 the game on handmade

2665
02:20:42,609 --> 02:20:46,090
hero dot oregon it will come with all

2666
02:20:43,869 --> 02:20:47,050
that good stuff for you we also have a

2667
02:20:46,090 --> 02:20:48,880
forum site if you want to ask questions

2668
02:20:47,049 --> 02:20:50,679
we have a patreon page you want support

2669
02:20:48,879 --> 02:20:52,328
the video series a schedule bot it tells

2670
02:20:50,680 --> 02:20:54,578
you where we're gonna be live and an

2671
02:20:52,328 --> 02:20:58,809
episode guide you can use to catch up on

2672
02:20:54,578 --> 02:21:02,139
old editions of the series that's it for

2673
02:20:58,809 --> 02:21:04,269
me I will be back next week till then

2674
02:21:02,139 --> 02:21:04,898
take care everyone and I'll see you on

2675
02:21:04,270 --> 02:21:07,680
the Internet

2676
02:21:04,898 --> 02:21:07,680
thank you everybody

