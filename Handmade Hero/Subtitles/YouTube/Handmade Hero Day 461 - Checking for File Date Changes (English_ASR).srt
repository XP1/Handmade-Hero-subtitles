1
00:00:00,030 --> 00:00:03,688
hello everyone and welcome to hand made

2
00:00:02,129 --> 00:00:08,220
here the show Rico to complete game live

3
00:00:03,689 --> 00:00:11,280
on stream we have to go put PNG reading

4
00:00:08,220 --> 00:00:14,940
integrated into our game we already

5
00:00:11,279 --> 00:00:19,049
wrote the reader and now our goal is to

6
00:00:14,939 --> 00:00:21,600
sort of retrofit that into our existing

7
00:00:19,050 --> 00:00:23,580
asset system which loads out of our own

8
00:00:21,600 --> 00:00:27,720
file format and so what we want to do

9
00:00:23,579 --> 00:00:30,389
now is support the ability to take PNG

10
00:00:27,719 --> 00:00:34,289
files that an artist drops into say a

11
00:00:30,390 --> 00:00:37,920
directory somewhere and import them into

12
00:00:34,289 --> 00:00:40,259
our data files so that we know that

13
00:00:37,920 --> 00:00:42,420
they've been processed and can now be

14
00:00:40,259 --> 00:00:45,808
used as regular game assets in the

15
00:00:42,420 --> 00:00:50,789
course of running the game you know as

16
00:00:45,808 --> 00:00:53,789
normal so that's our goal let's see last

17
00:00:50,789 --> 00:00:56,160
week we made an extension to our

18
00:00:53,789 --> 00:01:00,000
platform layer to support our ability to

19
00:00:56,159 --> 00:01:01,288
watch files and this is important

20
00:01:00,000 --> 00:01:03,869
because what we would like to do

21
00:01:01,289 --> 00:01:07,200
eventually is make it so that the artist

22
00:01:03,869 --> 00:01:09,810
can just save a new PNG over an old PNG

23
00:01:07,200 --> 00:01:12,060
and it'll just magically appear in the

24
00:01:09,810 --> 00:01:15,210
game because that's generally what you

25
00:01:12,060 --> 00:01:17,850
expect from like a hot loading system it

26
00:01:15,209 --> 00:01:19,709
basically it's exactly analogous to how

27
00:01:17,849 --> 00:01:21,329
we do our code right the way we do our

28
00:01:19,709 --> 00:01:24,959
code currently is when you compile the

29
00:01:21,329 --> 00:01:26,640
code the game looks and sees if a the

30
00:01:24,959 --> 00:01:28,199
game DLL has changed and if it has it

31
00:01:26,640 --> 00:01:30,420
just loads it in and runs with that

32
00:01:28,200 --> 00:01:32,009
instead of the old one and that's

33
00:01:30,420 --> 00:01:34,049
exactly what we want to do with our PNG

34
00:01:32,009 --> 00:01:35,819
s now we want to make it so that if it

35
00:01:34,049 --> 00:01:37,829
sees that there's a change we load it

36
00:01:35,819 --> 00:01:40,258
but obviously we don't want to load

37
00:01:37,828 --> 00:01:41,519
every PNG every time to see if there's a

38
00:01:40,259 --> 00:01:43,799
change because that's going to be too

39
00:01:41,519 --> 00:01:46,618
slow so what we did instead is made it

40
00:01:43,799 --> 00:01:49,950
so that we can actually see what the

41
00:01:46,618 --> 00:01:52,590
date stamps are on the p on the PNG

42
00:01:49,950 --> 00:01:54,659
files themselves and then if we see one

43
00:01:52,590 --> 00:01:56,640
of those date stamps change we then know

44
00:01:54,659 --> 00:01:58,560
that we should look at that PNG to see

45
00:01:56,640 --> 00:02:00,540
whether it the contents of it have also

46
00:01:58,560 --> 00:02:02,310
changed we don't know when the date

47
00:02:00,540 --> 00:02:03,868
changes that the PNG has actually

48
00:02:02,310 --> 00:02:06,540
changed in any meaningful way right you

49
00:02:03,868 --> 00:02:07,828
can do something you could open up a PNG

50
00:02:06,540 --> 00:02:10,080
and resave it over itself but not

51
00:02:07,828 --> 00:02:11,650
actually change the data so we do want

52
00:02:10,080 --> 00:02:13,390
to actually compare the

53
00:02:11,650 --> 00:02:14,920
when we load it in we probably want to

54
00:02:13,389 --> 00:02:16,899
look to see if it's actually change

55
00:02:14,919 --> 00:02:19,149
because if it hasn't changed then we

56
00:02:16,900 --> 00:02:22,060
don't actually need to update the art

57
00:02:19,150 --> 00:02:23,620
pack file at all but we do need to at

58
00:02:22,060 --> 00:02:25,658
least look at it once the date changes

59
00:02:23,620 --> 00:02:27,099
because it means that the contents may

60
00:02:25,658 --> 00:02:29,348
have changed so the way to think about

61
00:02:27,098 --> 00:02:32,979
the date is that the date is something

62
00:02:29,348 --> 00:02:35,378
that is sort of a marker that just says

63
00:02:32,979 --> 00:02:37,628
could the contents have changed and then

64
00:02:35,378 --> 00:02:39,789
once we see that marker we then know

65
00:02:37,628 --> 00:02:42,009
okay we have to go do further

66
00:02:39,789 --> 00:02:43,568
investigation but it's not actually

67
00:02:42,009 --> 00:02:45,340
telling us that the file changed it's

68
00:02:43,568 --> 00:02:48,628
just telling it us it might have changed

69
00:02:45,340 --> 00:02:52,120
so that's what we're gonna look at now

70
00:02:48,628 --> 00:02:55,780
let's go ahead and and get started on

71
00:02:52,120 --> 00:02:59,650
that so if I load up our current state

72
00:02:55,780 --> 00:03:02,979
of affairs here what we did sorry the

73
00:02:59,650 --> 00:03:06,010
project file what we did with our PNG

74
00:03:02,979 --> 00:03:09,158
reader is we first of all extracted the

75
00:03:06,009 --> 00:03:11,649
PNG reader into a useable chunk here so

76
00:03:09,158 --> 00:03:13,449
now we've got sort of this bit right

77
00:03:11,650 --> 00:03:15,370
here where you can call parse PNG

78
00:03:13,449 --> 00:03:19,298
passage memory Reena and you get back

79
00:03:15,370 --> 00:03:20,590
the image so that's been we did a good

80
00:03:19,299 --> 00:03:22,599
job like pulling that out that's all

81
00:03:20,590 --> 00:03:24,310
ready to go so now what we're just

82
00:03:22,598 --> 00:03:26,738
looking for is when do we actually call

83
00:03:24,310 --> 00:03:28,989
it how do we use that feature now that

84
00:03:26,739 --> 00:03:32,259
we have it and the answer to that is

85
00:03:28,989 --> 00:03:35,620
okay inside our asset system as you may

86
00:03:32,259 --> 00:03:39,370
recall we sort of have this notion that

87
00:03:35,620 --> 00:03:41,590
we at startup look through the assets

88
00:03:39,370 --> 00:03:45,549
that we have you can see here we loop

89
00:03:41,590 --> 00:03:49,658
over them and we create sort of like a

90
00:03:45,549 --> 00:03:51,579
indexing of what the tags are for each

91
00:03:49,658 --> 00:03:53,739
of our assets and that sort of thing and

92
00:03:51,579 --> 00:03:55,900
that is immutable

93
00:03:53,739 --> 00:03:57,609
it doesn't change for the entirety of

94
00:03:55,900 --> 00:03:59,560
the run of the program and that's the

95
00:03:57,609 --> 00:04:01,269
part that we need to expand now because

96
00:03:59,560 --> 00:04:03,969
when we look in here right we've got

97
00:04:01,269 --> 00:04:06,400
this game assets you can see we have

98
00:04:03,969 --> 00:04:08,439
some set of loaded files we have some

99
00:04:06,400 --> 00:04:13,439
set of loaded tags and some set of

100
00:04:08,439 --> 00:04:17,048
loaded assets and what those are is

101
00:04:13,439 --> 00:04:19,870
they're basically a raised we use to

102
00:04:17,048 --> 00:04:22,089
look up into when the game asks for a

103
00:04:19,870 --> 00:04:24,509
particular thing it jumps in there to

104
00:04:22,089 --> 00:04:24,509
use it

105
00:04:26,100 --> 00:04:35,439
now we have two distinct jobs now two

106
00:04:31,509 --> 00:04:39,099
that we want to tackle to modify what

107
00:04:35,439 --> 00:04:41,469
we're looking at here and the reason

108
00:04:39,100 --> 00:04:44,140
that we want to modify what we're

109
00:04:41,470 --> 00:04:48,940
looking at here is because in addition

110
00:04:44,139 --> 00:04:52,810
to now sort of having an artist who can

111
00:04:48,939 --> 00:04:54,279
work on the project directly we also are

112
00:04:52,810 --> 00:04:56,170
in a situation where we know more

113
00:04:54,279 --> 00:04:59,139
specifically what that artist is

114
00:04:56,170 --> 00:05:02,230
producing so oops let me go in the art

115
00:04:59,139 --> 00:05:04,899
director here so if you look for example

116
00:05:02,230 --> 00:05:09,670
at some of the test art that we have

117
00:05:04,899 --> 00:05:12,519
here that is you know indicative of what

118
00:05:09,670 --> 00:05:13,930
we might see in the game you can see

119
00:05:12,519 --> 00:05:17,259
that there is various structural

120
00:05:13,930 --> 00:05:19,449
concerns so we have a type of image

121
00:05:17,259 --> 00:05:22,360
that's just what a block looks like

122
00:05:19,449 --> 00:05:24,879
right and you can see that like a block

123
00:05:22,360 --> 00:05:26,800
has different components there's like

124
00:05:24,879 --> 00:05:30,279
different sightedness to blocks and

125
00:05:26,800 --> 00:05:31,930
stuff like that and so you know then we

126
00:05:30,279 --> 00:05:33,399
look at something like a character and a

127
00:05:31,930 --> 00:05:36,100
character has like a head and a body

128
00:05:33,399 --> 00:05:38,739
right and stuff like this and different

129
00:05:36,100 --> 00:05:41,350
facing directions and that's what's

130
00:05:38,740 --> 00:05:43,540
gonna get added into the game now right

131
00:05:41,350 --> 00:05:46,689
so we kind of know exactly what's being

132
00:05:43,540 --> 00:05:48,550
put in there now we have two ways we can

133
00:05:46,689 --> 00:05:51,939
go about tackling this particular

134
00:05:48,550 --> 00:05:55,329
problem one is that we can just

135
00:05:51,939 --> 00:05:57,759
translate those into tags right which is

136
00:05:55,329 --> 00:06:00,039
maybe what we should do the other is now

137
00:05:57,759 --> 00:06:02,740
we can also take this opportunity to

138
00:06:00,040 --> 00:06:05,080
refine our tag system to more closely

139
00:06:02,740 --> 00:06:09,370
approximate what it is we're actually

140
00:06:05,079 --> 00:06:11,500
doing now because you know we now know a

141
00:06:09,370 --> 00:06:13,930
lot more because once an artist is

142
00:06:11,500 --> 00:06:15,819
making art assets for something we now

143
00:06:13,930 --> 00:06:22,180
know a lot more about what's going on

144
00:06:15,819 --> 00:06:30,089
right so we have we can sort of look a

145
00:06:22,180 --> 00:06:30,090
little bit - we can

146
00:06:31,588 --> 00:06:37,168
not try to say this we can envision

147
00:06:34,249 --> 00:06:40,439
making changes to how the assets are

148
00:06:37,168 --> 00:06:43,079
stored in something that makes it more

149
00:06:40,439 --> 00:06:46,379
specific now and more efficient with the

150
00:06:43,079 --> 00:06:48,809
tag system it's very generic you can do

151
00:06:46,379 --> 00:06:51,359
whatever you want with it but it's more

152
00:06:48,809 --> 00:06:54,809
expensive right you have to do matching

153
00:06:51,358 --> 00:06:56,998
on values and it creates sort of a more

154
00:06:54,809 --> 00:06:58,379
extensive process for the game to figure

155
00:06:56,999 --> 00:07:01,799
out what asset you're actually talking

156
00:06:58,379 --> 00:07:04,468
about and so we have to kind of make a

157
00:07:01,798 --> 00:07:06,988
decision at some point whether we really

158
00:07:04,468 --> 00:07:08,459
care about that anymore if we have a set

159
00:07:06,988 --> 00:07:10,108
of art assets and we now are going to

160
00:07:08,459 --> 00:07:12,959
just lock it down and say this is how

161
00:07:10,108 --> 00:07:15,088
assets will come into the game then we

162
00:07:12,959 --> 00:07:18,959
really don't have to worry anymore very

163
00:07:15,088 --> 00:07:23,548
much about those assets being tagged in

164
00:07:18,959 --> 00:07:27,598
arbitrary ways we can simplify that

165
00:07:23,548 --> 00:07:32,698
system to a more direct indexing that

166
00:07:27,598 --> 00:07:37,199
wouldn't require us to have tag matching

167
00:07:32,699 --> 00:07:40,949
per se okay so I really don't know what

168
00:07:37,199 --> 00:07:43,799
we want to do about that but it's kind

169
00:07:40,949 --> 00:07:46,169
of a good idea to keep that in the back

170
00:07:43,798 --> 00:07:49,288
of our heads now because we definitely

171
00:07:46,168 --> 00:07:56,668
have the opportunity to change how that

172
00:07:49,288 --> 00:08:01,038
works so that's what I would say all

173
00:07:56,668 --> 00:08:01,038
right so let's move forward here

174
00:08:03,759 --> 00:08:10,990
so if we take a look at the assets that

175
00:08:07,610 --> 00:08:13,939
we're actually storing right now an

176
00:08:10,990 --> 00:08:16,160
asset is defined right here it has a

177
00:08:13,939 --> 00:08:18,168
state and that state has to do with

178
00:08:16,160 --> 00:08:21,889
whether or not it's like what we've done

179
00:08:18,168 --> 00:08:22,939
with it right so so if we do a live VSS

180
00:08:21,889 --> 00:08:25,220
state here we can have something that's

181
00:08:22,939 --> 00:08:26,569
unloaded something that is trying to be

182
00:08:25,220 --> 00:08:30,380
loaded and something that is loaded

183
00:08:26,569 --> 00:08:34,429
right and what that does is it basically

184
00:08:30,379 --> 00:08:36,168
allows us to determine whether we need

185
00:08:34,429 --> 00:08:38,989
to load it from disk or not when it gets

186
00:08:36,168 --> 00:08:40,460
used right because if it gets if it's

187
00:08:38,990 --> 00:08:42,139
going to be used we need it to be in a

188
00:08:40,460 --> 00:08:43,310
loaded state if it's not in a loaded

189
00:08:42,139 --> 00:08:44,419
state we need to do something about it

190
00:08:43,309 --> 00:08:46,879
if it's queued we can just wait because

191
00:08:44,419 --> 00:08:49,610
it'll will get loaded if it's not loaded

192
00:08:46,879 --> 00:08:51,830
yet we need to queue it so that's our

193
00:08:49,610 --> 00:08:54,230
you know that's the way the state works

194
00:08:51,830 --> 00:08:56,180
we then have a memory header the memory

195
00:08:54,230 --> 00:08:57,830
header I think probably can go away now

196
00:08:56,179 --> 00:08:59,359
and the reason that I think the memory

197
00:08:57,830 --> 00:09:01,040
header can probably go away now is

198
00:08:59,360 --> 00:09:03,470
because all of our stuff is going to be

199
00:09:01,039 --> 00:09:07,278
the same size now one of the nice things

200
00:09:03,470 --> 00:09:08,990
that we did with now that we moved to

201
00:09:07,278 --> 00:09:11,570
OpenGL is we can just introduce a

202
00:09:08,990 --> 00:09:16,519
constant size for asset stuff we can

203
00:09:11,570 --> 00:09:20,860
just I had Anna put them into fixed size

204
00:09:16,519 --> 00:09:22,879
boxes so that we can do more reliable

205
00:09:20,860 --> 00:09:24,950
memory allocation on them and stuff like

206
00:09:22,879 --> 00:09:29,028
that so I think we can probably get rid

207
00:09:24,950 --> 00:09:32,509
of this asset memory header idea in the

208
00:09:29,028 --> 00:09:35,570
future I mean not get rid of the not get

209
00:09:32,509 --> 00:09:37,909
rid of the information in here like the

210
00:09:35,570 --> 00:09:39,470
total size and stuff probably well we

211
00:09:37,909 --> 00:09:40,969
might be only over that as well but I'm

212
00:09:39,470 --> 00:09:44,750
just talking about the fact that we had

213
00:09:40,970 --> 00:09:47,089
to look at memory to reuse it in a non

214
00:09:44,750 --> 00:09:49,250
direct free list kind of way

215
00:09:47,089 --> 00:09:51,110
that stuff we can probably simplify

216
00:09:49,250 --> 00:09:55,610
quite considerably now if we would like

217
00:09:51,110 --> 00:09:58,580
so that's nice so anyway inside here

218
00:09:55,610 --> 00:09:59,810
we've got this this asset it's got a

219
00:09:58,580 --> 00:10:02,360
point to the memory header there and

220
00:09:59,809 --> 00:10:04,729
then it's got the actual asset in

221
00:10:02,360 --> 00:10:07,159
question which is this information here

222
00:10:04,730 --> 00:10:08,959
and a file index as to which file that

223
00:10:07,159 --> 00:10:10,399
came out of right so if it needs to get

224
00:10:08,958 --> 00:10:14,809
reloaded that's where that would come

225
00:10:10,399 --> 00:10:16,189
from so what we need to do now is start

226
00:10:14,809 --> 00:10:17,029
thinking about how this is going to have

227
00:10:16,190 --> 00:10:18,680
to change

228
00:10:17,029 --> 00:10:21,019
so you can see here we've got first tag

229
00:10:18,679 --> 00:10:26,689
index and one passed last tag index

230
00:10:21,019 --> 00:10:29,539
right we really four in our first

231
00:10:26,690 --> 00:10:31,670
attempt we really can if we want to just

232
00:10:29,539 --> 00:10:33,079
not touch the tag system at all and the

233
00:10:31,669 --> 00:10:35,269
reason for that is even though this

234
00:10:33,080 --> 00:10:37,700
seems like a tightly packed system its

235
00:10:35,269 --> 00:10:40,370
indirectly offset so what you can see

236
00:10:37,700 --> 00:10:43,670
here is these are indexes not pointers

237
00:10:40,370 --> 00:10:45,169
which means that if we wanted to when we

238
00:10:43,669 --> 00:10:47,750
look at this tagger right here and we've

239
00:10:45,169 --> 00:10:50,509
got a tag count in a tag array what we

240
00:10:47,750 --> 00:10:52,549
can do is it startup allocate vastly

241
00:10:50,509 --> 00:10:55,429
more tags than we actually need and just

242
00:10:52,549 --> 00:10:57,649
leave Headroom there to put more tags in

243
00:10:55,429 --> 00:11:02,779
so then every time we load an asset we

244
00:10:57,649 --> 00:11:05,409
just blast tags in there right and so

245
00:11:02,779 --> 00:11:08,389
that's a pretty straightforward way of

246
00:11:05,409 --> 00:11:10,339
making the system expandable that

247
00:11:08,389 --> 00:11:12,769
actually doesn't really cost us anything

248
00:11:10,340 --> 00:11:14,840
and I know that that sounds a little bit

249
00:11:12,769 --> 00:11:17,449
cheesy at first because you may be

250
00:11:14,840 --> 00:11:19,310
thinking well if you were to do that

251
00:11:17,450 --> 00:11:20,629
what happens if the artist is just

252
00:11:19,309 --> 00:11:23,359
running the game for a really long time

253
00:11:20,629 --> 00:11:25,580
and eventually they reload the art

254
00:11:23,360 --> 00:11:28,310
enough times to hit the top of a tag

255
00:11:25,580 --> 00:11:32,000
count well guess what

256
00:11:28,309 --> 00:11:34,609
no one cares why because the game assets

257
00:11:32,000 --> 00:11:36,860
could just be restarted right remember

258
00:11:34,610 --> 00:11:39,379
we have a way already of just

259
00:11:36,860 --> 00:11:41,629
reinitializing the art asset system at

260
00:11:39,379 --> 00:11:44,899
startup it just looks through the files

261
00:11:41,629 --> 00:11:47,809
and loads the indexes out of the files

262
00:11:44,899 --> 00:11:49,370
right that's all it would have to do we

263
00:11:47,809 --> 00:11:52,279
can just do that again and then we have

264
00:11:49,370 --> 00:11:54,460
a nice tightly compacted tag set that

265
00:11:52,279 --> 00:11:58,819
just is exactly the right number of tags

266
00:11:54,460 --> 00:12:02,240
without we you know without having all

267
00:11:58,820 --> 00:12:04,550
that dead zone in there right so I think

268
00:12:02,240 --> 00:12:08,659
our main problem that we're going to

269
00:12:04,549 --> 00:12:10,819
have is is not with that right it

270
00:12:08,659 --> 00:12:13,399
wouldn't be with with dealing with

271
00:12:10,820 --> 00:12:15,520
in-memory tag stuff I think the problem

272
00:12:13,399 --> 00:12:18,470
that we're more going to have is the

273
00:12:15,519 --> 00:12:24,649
fact that when we replace a particular

274
00:12:18,470 --> 00:12:27,589
set of of assets that already exist

275
00:12:24,649 --> 00:12:30,750
we need to reuse the tags from that

276
00:12:27,589 --> 00:12:32,370
asset or remember that we

277
00:12:30,750 --> 00:12:34,950
freed it to put other tags in there

278
00:12:32,370 --> 00:12:37,980
eventually for the permanently stored

279
00:12:34,950 --> 00:12:40,050
file so it's really updating the

280
00:12:37,980 --> 00:12:43,019
permanently stored file that's the hard

281
00:12:40,049 --> 00:12:46,969
part because that's the thing that has

282
00:12:43,019 --> 00:12:49,649
to have the data actually correct now I

283
00:12:46,970 --> 00:12:52,290
that and that's also like I was saying

284
00:12:49,649 --> 00:12:54,870
why I think it might be nice if we had a

285
00:12:52,289 --> 00:12:57,029
different way of indexing things since

286
00:12:54,870 --> 00:13:01,320
we know that we don't really need the

287
00:12:57,029 --> 00:13:03,779
tag stuff now I don't think based on

288
00:13:01,320 --> 00:13:07,440
just the kind of our assets that we have

289
00:13:03,779 --> 00:13:09,779
and we'll have it doesn't look like it's

290
00:13:07,440 --> 00:13:12,990
super necessary so it may that's the

291
00:13:09,779 --> 00:13:15,389
reason I say we may want to move away

292
00:13:12,990 --> 00:13:16,980
from that going forwards just because it

293
00:13:15,389 --> 00:13:20,610
doesn't seem like something that's

294
00:13:16,980 --> 00:13:24,659
really necessary and it will create

295
00:13:20,610 --> 00:13:26,220
headaches for us on for management I

296
00:13:24,659 --> 00:13:27,899
mean you could just never deal with it

297
00:13:26,220 --> 00:13:29,610
and let the tag array just get massive

298
00:13:27,899 --> 00:13:32,490
but that's just you know that doesn't

299
00:13:29,610 --> 00:13:34,169
seem very efficient and you're just

300
00:13:32,490 --> 00:13:35,460
blurting things out for no reason when

301
00:13:34,169 --> 00:13:37,439
we I think we could probably do

302
00:13:35,460 --> 00:13:39,480
something better and the thing that we

303
00:13:37,440 --> 00:13:42,120
would probably do better here right is

304
00:13:39,480 --> 00:13:43,860
again it depends really on how we're

305
00:13:42,120 --> 00:13:45,990
gonna use these I had originally

306
00:13:43,860 --> 00:13:48,990
envisioned a system that maybe was a

307
00:13:45,990 --> 00:13:51,870
little bit more arbitrary with how

308
00:13:48,990 --> 00:13:54,029
things were loaded but looking at how we

309
00:13:51,870 --> 00:13:58,320
ended up kind of going with it just in

310
00:13:54,029 --> 00:14:03,139
terms of how the art wanted to be made

311
00:13:58,320 --> 00:14:07,200
it seems like it kind of wants to be I

312
00:14:03,139 --> 00:14:10,470
don't know it's I think that that we may

313
00:14:07,200 --> 00:14:12,450
want to rethink the tagging from a

314
00:14:10,470 --> 00:14:15,839
standpoint of rather than having a

315
00:14:12,450 --> 00:14:18,390
collection of tags in that sense you may

316
00:14:15,839 --> 00:14:24,150
just want to have more of a fixed set of

317
00:14:18,389 --> 00:14:25,980
tags that aren't arbitrary and yeah I

318
00:14:24,149 --> 00:14:28,709
really just don't know so when you're

319
00:14:25,980 --> 00:14:31,200
picking something like a hat there's

320
00:14:28,710 --> 00:14:32,879
just two parameters or three parameters

321
00:14:31,200 --> 00:14:34,020
or something that define hat I don't

322
00:14:32,879 --> 00:14:35,730
know when you pick them I'm not sure

323
00:14:34,019 --> 00:14:38,129
again like I said it's it's really kind

324
00:14:35,730 --> 00:14:40,500
of confusing to me how this is actually

325
00:14:38,129 --> 00:14:42,000
gonna shake out and so we may have to

326
00:14:40,500 --> 00:14:44,399
get a little further down the road till

327
00:14:42,000 --> 00:14:46,919
we really know

328
00:14:44,399 --> 00:14:48,870
but yeah anyway that's that's the

329
00:14:46,919 --> 00:14:51,360
situation and we'll have to think about

330
00:14:48,870 --> 00:14:52,950
it a little more so anyway that's the

331
00:14:51,360 --> 00:14:58,019
only part that I think is going to be

332
00:14:52,950 --> 00:14:59,009
particularly problematic for us there

333
00:14:58,019 --> 00:15:01,649
where we're gonna have to start thinking

334
00:14:59,009 --> 00:15:11,460
about things a little bit more carefully

335
00:15:01,649 --> 00:15:13,439
so yeah we've got like yet we've got

336
00:15:11,460 --> 00:15:16,350
these types here and these will now

337
00:15:13,440 --> 00:15:26,130
start to reflect what we actually have

338
00:15:16,350 --> 00:15:28,560
in the art in the art itself yeah anyway

339
00:15:26,129 --> 00:15:30,480
so thinking about those tags is sort of

340
00:15:28,559 --> 00:15:31,619
something I guess I my brain keeps kind

341
00:15:30,480 --> 00:15:33,379
of going there and I don't know that I

342
00:15:31,620 --> 00:15:35,580
really want to do that yet

343
00:15:33,379 --> 00:15:36,809
but anyway now that I've got that all

344
00:15:35,580 --> 00:15:39,150
out in the open and you can think about

345
00:15:36,809 --> 00:15:40,979
it - I'm gonna go ahead and do the stuff

346
00:15:39,149 --> 00:15:42,389
we actually know how to do and then

347
00:15:40,980 --> 00:15:43,560
we'll come back to how we want to be the

348
00:15:42,389 --> 00:15:45,689
tags which I don't think we know how to

349
00:15:43,559 --> 00:15:47,819
do yet because I mean obviously we know

350
00:15:45,690 --> 00:15:50,220
how to do any particular implementation

351
00:15:47,820 --> 00:15:53,340
of it of we want it's not hard the

352
00:15:50,220 --> 00:15:56,700
question is what is the correct design

353
00:15:53,340 --> 00:15:58,590
for that that makes us have the minimal

354
00:15:56,700 --> 00:16:00,930
amount of frustration for what we

355
00:15:58,590 --> 00:16:02,280
actually want the game to query and it

356
00:16:00,929 --> 00:16:05,159
may be that we just need to wait a

357
00:16:02,279 --> 00:16:06,990
little longer and start doing stuff like

358
00:16:05,159 --> 00:16:10,199
putting some of those little orphans in

359
00:16:06,990 --> 00:16:11,970
the game and having you be able to wear

360
00:16:10,200 --> 00:16:13,650
different hats and stuff and then when

361
00:16:11,970 --> 00:16:16,769
we see what the code looks like that

362
00:16:13,649 --> 00:16:18,209
does that in the entity system we can

363
00:16:16,769 --> 00:16:20,850
have a better understanding of how we

364
00:16:18,210 --> 00:16:23,220
actually want to query these things that

365
00:16:20,850 --> 00:16:26,639
will be the least amount of frustration

366
00:16:23,220 --> 00:16:28,110
for both sides of the system right we

367
00:16:26,639 --> 00:16:30,360
want the entity system to have an easy

368
00:16:28,110 --> 00:16:32,100
time saying what it's trying to do and

369
00:16:30,360 --> 00:16:37,080
then we also want the asset system to

370
00:16:32,100 --> 00:16:41,550
have an easy time managing it so we'll

371
00:16:37,080 --> 00:16:43,200
look at it all that being said let's go

372
00:16:41,549 --> 00:16:49,169
ahead and look at what we actually want

373
00:16:43,200 --> 00:16:53,040
to do here so what we've got do you

374
00:16:49,169 --> 00:16:55,370
think is the ability to loop over these

375
00:16:53,039 --> 00:16:55,370
files

376
00:17:00,639 --> 00:17:04,299
we have the ability to loop over these

377
00:17:03,100 --> 00:17:05,318
files and we have you build to see

378
00:17:04,299 --> 00:17:07,959
what's changed but one of the things

379
00:17:05,318 --> 00:17:11,139
we're gonna have to do is keep a record

380
00:17:07,959 --> 00:17:12,720
of what those were so at the very least

381
00:17:11,140 --> 00:17:17,709
I know I'm gonna have to do something

382
00:17:12,720 --> 00:17:20,410
like this where I have a file that I

383
00:17:17,709 --> 00:17:22,568
know that I'm watching and I know that

384
00:17:20,410 --> 00:17:24,430
I've got some date that's involved that

385
00:17:22,568 --> 00:17:26,740
I can look at so if I go here to the

386
00:17:24,430 --> 00:17:28,690
platform layer if you remember we sort

387
00:17:26,740 --> 00:17:31,299
of made this platform file info here we

388
00:17:28,690 --> 00:17:33,700
had this file date so I know that there

389
00:17:31,299 --> 00:17:36,069
is a file date involved right and

390
00:17:33,700 --> 00:17:38,799
furthermore I know that there was a file

391
00:17:36,069 --> 00:17:42,819
name right so there was some kind of a

392
00:17:38,799 --> 00:17:45,940
name that I was looking at there that

393
00:17:42,819 --> 00:17:50,349
that I need to like be aware of right so

394
00:17:45,940 --> 00:17:52,600
I've got something like this where we've

395
00:17:50,349 --> 00:17:55,029
we've got a name that says what the file

396
00:17:52,599 --> 00:17:57,279
is and we've got a date that says what

397
00:17:55,029 --> 00:17:59,529
we think the last time the file in

398
00:17:57,279 --> 00:18:07,299
question you know when we think that

399
00:17:59,529 --> 00:18:08,529
actually was last changed and so then

400
00:18:07,299 --> 00:18:10,149
what we want to do is we want to be able

401
00:18:08,529 --> 00:18:12,490
to do something where we kind of check

402
00:18:10,150 --> 00:18:14,890
these things periodically for updates

403
00:18:12,490 --> 00:18:16,240
right so when we have one of these watch

404
00:18:14,890 --> 00:18:18,130
files and got a base name and a file

405
00:18:16,240 --> 00:18:20,349
date I can use something like this to

406
00:18:18,130 --> 00:18:21,610
check to trigger it now I'm gonna want

407
00:18:20,349 --> 00:18:22,959
to look it up on the base name because

408
00:18:21,609 --> 00:18:25,449
that's what's gonna be coming back and I

409
00:18:22,960 --> 00:18:33,850
want to match that out so I'm probably

410
00:18:25,450 --> 00:18:36,400
gonna want something like this where I

411
00:18:33,849 --> 00:18:38,980
just have a hash of the of the names and

412
00:18:36,400 --> 00:18:40,360
I can look them up in there via some

413
00:18:38,980 --> 00:18:43,390
kind of a string hash right so I can

414
00:18:40,359 --> 00:18:46,389
look these up I can get information

415
00:18:43,390 --> 00:18:48,100
about them as I go so when I have this

416
00:18:46,390 --> 00:18:50,050
information and I do the watched file

417
00:18:48,099 --> 00:18:53,019
stuff what I want to be able to do after

418
00:18:50,049 --> 00:18:54,669
that process is I want to be able to

419
00:18:53,019 --> 00:18:56,259
reload a file if it's changed so the

420
00:18:54,670 --> 00:18:58,450
additional thing that this watch file

421
00:18:56,259 --> 00:19:02,289
would have to have is it has to have

422
00:18:58,450 --> 00:19:07,360
some knowledge of what assets came from

423
00:19:02,289 --> 00:19:08,950
this watch file right so inside here

424
00:19:07,359 --> 00:19:11,589
we've got some number of

425
00:19:08,950 --> 00:19:14,710
that's those assets correspond to what

426
00:19:11,589 --> 00:19:16,449
was in the file so for example if we

427
00:19:14,710 --> 00:19:21,490
look at one of these files here at you

428
00:19:16,450 --> 00:19:26,890
know I should load one of these

429
00:19:21,490 --> 00:19:29,019
templates like this so when we load up a

430
00:19:26,890 --> 00:19:31,540
PNG we've got something looks like this

431
00:19:29,019 --> 00:19:34,900
and each of these squares is a different

432
00:19:31,539 --> 00:19:36,629
art asset right so for example up in

433
00:19:34,900 --> 00:19:40,690
here we have the rightward facing

434
00:19:36,630 --> 00:19:41,650
default body leftward facing default

435
00:19:40,690 --> 00:19:44,680
body and so on

436
00:19:41,650 --> 00:19:46,890
right I'm sorry dodging left leftward

437
00:19:44,680 --> 00:19:49,840
facing default body right blah blah blah

438
00:19:46,890 --> 00:19:53,080
and then if you take a look at the

439
00:19:49,839 --> 00:19:57,309
actual monsters and stuff that are in

440
00:19:53,079 --> 00:19:59,139
here or whatever you know the whatever

441
00:19:57,309 --> 00:20:04,000
are the various like things are that

442
00:19:59,140 --> 00:20:07,300
you've got to go into that slot right

443
00:20:04,000 --> 00:20:09,250
here's one that's a mummy again I don't

444
00:20:07,299 --> 00:20:11,159
we have to look at these and something

445
00:20:09,250 --> 00:20:13,930
that actually knows how to look at

446
00:20:11,160 --> 00:20:15,490
transparency what the heck is this

447
00:20:13,930 --> 00:20:17,529
alright I've never seen this program

448
00:20:15,490 --> 00:20:23,880
before but anyway at least it handled

449
00:20:17,529 --> 00:20:26,470
the transparency properly all right I

450
00:20:23,880 --> 00:20:29,230
don't know who mate who makes an art

451
00:20:26,470 --> 00:20:32,350
package that actually has stuff that

452
00:20:29,230 --> 00:20:36,160
isn't in the art sort of like showing up

453
00:20:32,349 --> 00:20:39,909
I yeah alright Microsoft was the answer

454
00:20:36,160 --> 00:20:41,830
so looking at this and here you can see

455
00:20:39,910 --> 00:20:43,540
like we've got the different bodies of

456
00:20:41,829 --> 00:20:48,429
this thing but a bunch of them are are

457
00:20:43,539 --> 00:20:51,099
left empty this is by design so when we

458
00:20:48,430 --> 00:20:55,060
look at one of these things we don't

459
00:20:51,099 --> 00:20:56,109
want let me get that template back when

460
00:20:55,059 --> 00:20:57,879
we looking at one of these things we

461
00:20:56,109 --> 00:21:00,039
don't want the artists to have to do any

462
00:20:57,880 --> 00:21:02,320
more work than necessary for a

463
00:21:00,039 --> 00:21:04,809
particular character so a lot of times

464
00:21:02,319 --> 00:21:07,179
characters might just have say this part

465
00:21:04,809 --> 00:21:09,009
here in fact sometimes if the character

466
00:21:07,180 --> 00:21:12,100
for example doesn't have a head that

467
00:21:09,009 --> 00:21:13,960
really turns there might only just be

468
00:21:12,099 --> 00:21:16,419
one right look maybe there's only this

469
00:21:13,960 --> 00:21:18,220
one so it might have all the bodies with

470
00:21:16,420 --> 00:21:20,440
just that one or maybe just this and

471
00:21:18,220 --> 00:21:22,779
this there might be only two in there so

472
00:21:20,440 --> 00:21:26,470
every one of these squares is a

473
00:21:22,779 --> 00:21:29,230
potential asset but only you know maybe

474
00:21:26,470 --> 00:21:32,529
even just two or one of those squares is

475
00:21:29,230 --> 00:21:33,430
actually required to make a usable

476
00:21:32,529 --> 00:21:34,990
monster or something like that

477
00:21:33,430 --> 00:21:36,490
potentially right because some monsters

478
00:21:34,990 --> 00:21:39,970
may be very simple while others might

479
00:21:36,490 --> 00:21:42,789
have more stuff in them right so what we

480
00:21:39,970 --> 00:21:45,839
want to do here is we want to categorize

481
00:21:42,789 --> 00:21:51,609
the we want to put these things in

482
00:21:45,839 --> 00:21:54,159
categorically so that we extract the

483
00:21:51,609 --> 00:21:57,029
squares put them into assets and we want

484
00:21:54,160 --> 00:22:00,940
to remember for any given one of these

485
00:21:57,029 --> 00:22:04,559
files we want to remember where we put

486
00:22:00,940 --> 00:22:07,240
everything right that's kind of crucial

487
00:22:04,559 --> 00:22:08,919
so what I want to do here is I want to

488
00:22:07,240 --> 00:22:11,529
say all right we know there's

489
00:22:08,920 --> 00:22:13,990
effectively a maximum because those

490
00:22:11,529 --> 00:22:17,710
tiles there it's like an 8x8 grid right

491
00:22:13,990 --> 00:22:21,730
the maximum thing is an 8x8 grid of

492
00:22:17,710 --> 00:22:23,410
things so there's no more than 64 actual

493
00:22:21,730 --> 00:22:25,809
assets that could have come out of here

494
00:22:23,410 --> 00:22:27,430
so there's sort of an asset count if you

495
00:22:25,809 --> 00:22:29,710
will but I'm not gonna even have an

496
00:22:27,430 --> 00:22:32,560
asset count I'm just gonna say like

497
00:22:29,710 --> 00:22:33,340
asset indices I'm gonna say there's 64

498
00:22:32,559 --> 00:22:36,129
of them right

499
00:22:33,339 --> 00:22:38,169
we can even say 8x8 if we want it to be

500
00:22:36,130 --> 00:22:42,010
a little bit more specific about what we

501
00:22:38,170 --> 00:22:45,039
were doing here and note which one it is

502
00:22:42,009 --> 00:22:46,629
right so it's like X and then Y or let's

503
00:22:45,039 --> 00:22:50,440
do Y the next cuz that's how we would do

504
00:22:46,630 --> 00:22:51,910
it if it's pixels right and what I want

505
00:22:50,440 --> 00:22:53,620
to do here is when we load in one of

506
00:22:51,910 --> 00:22:55,540
those files and I look through all of

507
00:22:53,619 --> 00:22:57,759
the squares what I'm gonna do is every

508
00:22:55,539 --> 00:22:59,559
time there's an asset in one of them I'm

509
00:22:57,759 --> 00:23:02,379
gonna record that so this will be all

510
00:22:59,559 --> 00:23:05,079
zeros but initially and every time I see

511
00:23:02,380 --> 00:23:11,370
want to record that I'm gonna say what

512
00:23:05,079 --> 00:23:16,529
asset then takes that place right and

513
00:23:11,369 --> 00:23:20,289
fortunately for me I think and I'm just

514
00:23:16,529 --> 00:23:23,289
guessing here but I think our tag

515
00:23:20,289 --> 00:23:26,289
problem is kind of not that big of a

516
00:23:23,289 --> 00:23:30,190
deal here because if you think about

517
00:23:26,289 --> 00:23:33,159
what's gonna happen anytime you look at

518
00:23:30,190 --> 00:23:35,558
an asset the tags that go with that

519
00:23:33,160 --> 00:23:40,919
asset are the same no matter

520
00:23:35,558 --> 00:23:43,720
what square they're in in a sense right

521
00:23:40,919 --> 00:23:47,350
that's and I said that exactly backwards

522
00:23:43,720 --> 00:23:50,259
the tags that go with an asset are the

523
00:23:47,349 --> 00:23:54,278
same for that square no matter what the

524
00:23:50,259 --> 00:23:58,419
asset is that's what I was trying to say

525
00:23:54,278 --> 00:24:01,869
and failing to say unfortunately so if

526
00:23:58,419 --> 00:24:06,759
you yeah if you think about what that

527
00:24:01,869 --> 00:24:09,849
means when you look at one of these this

528
00:24:06,759 --> 00:24:11,919
asset here that's from this square if I

529
00:24:09,849 --> 00:24:14,709
replace this asset with a different

530
00:24:11,919 --> 00:24:17,080
image the tags don't change the tags are

531
00:24:14,710 --> 00:24:20,860
the same so I can literally replace the

532
00:24:17,079 --> 00:24:23,349
asset and just refer to the same set of

533
00:24:20,859 --> 00:24:26,908
tags I originally added which stops the

534
00:24:23,349 --> 00:24:31,689
tag bloat from happening pretty

535
00:24:26,909 --> 00:24:32,330
conveniently right so that's something

536
00:24:31,690 --> 00:24:34,558
good too

537
00:24:32,329 --> 00:24:36,548
[Music]

538
00:24:34,558 --> 00:24:40,089
that's something pretty good to keep in

539
00:24:36,548 --> 00:24:41,950
mind right again I'm not sure we really

540
00:24:40,089 --> 00:24:44,648
want to have the tags go down that far

541
00:24:41,950 --> 00:24:46,090
because we know that this is a fixed

542
00:24:44,648 --> 00:24:48,398
layout so in the future we probably just

543
00:24:46,089 --> 00:24:51,548
want to use a fixed layout for it

544
00:24:48,398 --> 00:24:54,959
and we'll have to think about how we

545
00:24:51,548 --> 00:24:59,859
want to do that going forward but yeah

546
00:24:54,960 --> 00:25:01,419
there you go okay so I think this would

547
00:24:59,859 --> 00:25:03,219
tell us what we need to know so we could

548
00:25:01,419 --> 00:25:05,769
look at a watch file we could say okay

549
00:25:03,220 --> 00:25:07,720
if it changed these are the assets that

550
00:25:05,769 --> 00:25:11,138
need to be replaced we loop through all

551
00:25:07,720 --> 00:25:13,298
of the the new file any plate time we

552
00:25:11,138 --> 00:25:15,908
see an asset we will put that asset into

553
00:25:13,298 --> 00:25:18,609
place and replace the old assets

554
00:25:15,909 --> 00:25:22,059
information with it and we can probably

555
00:25:18,609 --> 00:25:25,319
use reuse the same asset as well so

556
00:25:22,058 --> 00:25:28,240
that's probably easy to do I don't know

557
00:25:25,319 --> 00:25:31,480
we'll see but when we take a look at the

558
00:25:28,240 --> 00:25:37,109
asset itself let me take a look at where

559
00:25:31,480 --> 00:25:37,110
that is here this is the wrong file

560
00:25:39,650 --> 00:25:44,070
we take a look at the asset itself in

561
00:25:42,630 --> 00:25:46,620
the case of a bitmap which is the thing

562
00:25:44,069 --> 00:25:51,659
that we're working with here when we

563
00:25:46,619 --> 00:25:53,729
look at the way this is stored it looks

564
00:25:51,660 --> 00:25:55,080
like we just have a header that's the

565
00:25:53,730 --> 00:25:56,640
dimension in the line percentage and

566
00:25:55,079 --> 00:25:58,669
then we have the pixels that come after

567
00:25:56,640 --> 00:25:58,670
it

568
00:26:00,319 --> 00:26:06,589
so what we would need to do there for

569
00:26:03,059 --> 00:26:06,589
the HHA bitmap

570
00:26:06,799 --> 00:26:14,490
just thinking it through is when we look

571
00:26:09,930 --> 00:26:16,830
at the asset it's gonna have this stuff

572
00:26:14,490 --> 00:26:18,660
here

573
00:26:16,829 --> 00:26:23,369
oh it no it doesn't nevermind data

574
00:26:18,660 --> 00:26:25,170
offset tells where it goes yeah so it

575
00:26:23,369 --> 00:26:28,859
looks like the main problem we would get

576
00:26:25,170 --> 00:26:31,019
there is that the data offset would have

577
00:26:28,859 --> 00:26:33,089
to potentially be changed but again the

578
00:26:31,019 --> 00:26:34,950
nice thing here is if all of our assets

579
00:26:33,089 --> 00:26:36,779
are the same size and we store them

580
00:26:34,950 --> 00:26:39,509
uncompressed at least during development

581
00:26:36,779 --> 00:26:42,289
like we could try to do compression on

582
00:26:39,509 --> 00:26:44,789
them later when it comes time to ship

583
00:26:42,289 --> 00:26:46,079
but when we're just during development

584
00:26:44,789 --> 00:26:48,569
we can leave them uncompressed if we

585
00:26:46,079 --> 00:26:51,269
want to if we leave them uncompressed

586
00:26:48,569 --> 00:26:53,279
that means that any asset that replaces

587
00:26:51,269 --> 00:26:55,470
another asset came from the same

588
00:26:53,279 --> 00:26:57,240
location in the bitmap file which means

589
00:26:55,470 --> 00:26:58,950
it's still the same dimensions which

590
00:26:57,240 --> 00:27:01,500
means that the data offset already

591
00:26:58,950 --> 00:27:04,319
points to exactly enough space to hold

592
00:27:01,500 --> 00:27:09,509
it so we shouldn't actually have to do

593
00:27:04,319 --> 00:27:11,689
any reallocation you know I'm Sam so I

594
00:27:09,509 --> 00:27:11,690
think

595
00:27:15,259 --> 00:27:18,890
I think this part of the process is

596
00:27:17,750 --> 00:27:19,670
actually going to be pretty

597
00:27:18,890 --> 00:27:22,730
straightforward

598
00:27:19,670 --> 00:27:24,440
I think reorganizing the tags is gonna

599
00:27:22,730 --> 00:27:26,120
be the hard part here because we need

600
00:27:24,440 --> 00:27:28,490
the really because it's it's something

601
00:27:26,119 --> 00:27:31,250
we need to think of hard about an

602
00:27:28,490 --> 00:27:35,319
experiment with but I think the asset

603
00:27:31,250 --> 00:27:42,019
part is actually pretty straightforward

604
00:27:35,319 --> 00:27:46,579
all right so I'm just gonna make a

605
00:27:42,019 --> 00:27:48,799
standard half set up here exactly we've

606
00:27:46,579 --> 00:27:50,059
done it many times before so what we'll

607
00:27:48,799 --> 00:27:51,950
do is we'll just look in the hash file

608
00:27:50,059 --> 00:27:53,419
we'll see when when we get something

609
00:27:51,950 --> 00:27:58,190
that has changed we'll just go in there

610
00:27:53,420 --> 00:28:00,860
we'll modify it this HHA asset is just

611
00:27:58,190 --> 00:28:04,100
inside the asset system here right where

612
00:28:00,859 --> 00:28:05,269
we have that asset listed the only thing

613
00:28:04,099 --> 00:28:08,569
that I think we're gonna have to be

614
00:28:05,269 --> 00:28:14,960
aware of is when we look at this h/h a

615
00:28:08,569 --> 00:28:18,079
asset here this part this may need to be

616
00:28:14,960 --> 00:28:23,809
a more extended piece of information so

617
00:28:18,079 --> 00:28:27,849
this HHA asset is telling us where to

618
00:28:23,809 --> 00:28:34,069
put the new the replacement data but

619
00:28:27,849 --> 00:28:39,259
that data that we're over writing I'm

620
00:28:34,069 --> 00:28:42,829
not explaining myself well an hh8 asset

621
00:28:39,259 --> 00:28:44,869
comes potentially originally from a data

622
00:28:42,829 --> 00:28:48,349
file that we don't know how it got there

623
00:28:44,869 --> 00:28:50,929
right when we boot up the game

624
00:28:48,349 --> 00:28:53,059
our HHA assets that we have right now

625
00:28:50,930 --> 00:28:56,450
for example that did not come from the

626
00:28:53,059 --> 00:28:59,559
hot loading system in any way those

627
00:28:56,450 --> 00:29:04,190
assets we don't know anything about them

628
00:28:59,559 --> 00:29:08,419
right this this assets pointer here is

629
00:29:04,190 --> 00:29:13,009
just a big list of these things I wear

630
00:29:08,420 --> 00:29:15,529
was that right here right so we don't

631
00:29:13,009 --> 00:29:19,640
know where it came from we copy this

632
00:29:15,529 --> 00:29:21,799
information out of the file and then we

633
00:29:19,640 --> 00:29:25,220
don't have it we don't know where it

634
00:29:21,799 --> 00:29:27,619
came from so when we go to replace one

635
00:29:25,220 --> 00:29:28,789
of those assets we're in trouble

636
00:29:27,619 --> 00:29:32,209
because we don't know where

637
00:29:28,789 --> 00:29:34,250
overwrite the file to tell us so in a

638
00:29:32,210 --> 00:29:36,140
sense we actually need to store an

639
00:29:34,250 --> 00:29:38,029
additional piece of information here

640
00:29:36,140 --> 00:29:41,990
that tells us how to overwrite this

641
00:29:38,029 --> 00:29:44,119
particular asset now what I'm gonna

642
00:29:41,990 --> 00:29:45,529
propose is that since all of our assets

643
00:29:44,119 --> 00:29:47,809
going forwards go through the watched

644
00:29:45,529 --> 00:29:50,960
file system I think maybe that's the

645
00:29:47,809 --> 00:29:52,579
right way to do that because we know

646
00:29:50,960 --> 00:29:56,180
that we're never going to replace an old

647
00:29:52,579 --> 00:29:58,129
asset with a new asset in the this way

648
00:29:56,180 --> 00:30:00,140
that what wasn't through the watched

649
00:29:58,130 --> 00:30:02,030
file system because all of our old

650
00:30:00,140 --> 00:30:05,710
assets are the wrong dimensions anyway

651
00:30:02,029 --> 00:30:08,629
so we can't reuse an old asset header

652
00:30:05,710 --> 00:30:11,180
anyway so we could do it through here

653
00:30:08,630 --> 00:30:16,580
the only thing that I think maybe trips

654
00:30:11,180 --> 00:30:19,130
us up there is that we still need to go

655
00:30:16,579 --> 00:30:21,439
back and nerf the old asset so that it

656
00:30:19,130 --> 00:30:29,300
doesn't participate in matching if we

657
00:30:21,440 --> 00:30:31,309
want to overwrite it so that part yeah

658
00:30:29,299 --> 00:30:34,149
that part seems like something that we

659
00:30:31,309 --> 00:30:34,149
just have to deal with

660
00:30:53,319 --> 00:30:58,700
so I guess I guess I will just put it

661
00:30:56,390 --> 00:31:00,049
here so everything every time an asset

662
00:30:58,700 --> 00:31:00,880
gets loaded I'm just gonna remember

663
00:31:00,048 --> 00:31:04,099
where it came from

664
00:31:00,880 --> 00:31:07,519
I'm just gonna say that that's something

665
00:31:04,099 --> 00:31:09,379
that it has to has to record and I think

666
00:31:07,519 --> 00:31:38,778
like I said I think this part can

667
00:31:09,380 --> 00:31:40,669
simpkin get simplified in the future so

668
00:31:38,778 --> 00:31:42,710
basically what I would propose proposed

669
00:31:40,669 --> 00:31:44,419
is eventually we probably want to just

670
00:31:42,710 --> 00:31:47,179
move to a fixed size system where we

671
00:31:44,419 --> 00:31:49,940
just have like a couple different buffer

672
00:31:47,179 --> 00:31:52,610
types and the reason for that is we want

673
00:31:49,940 --> 00:31:55,278
to kind of use the texture memory this

674
00:31:52,609 --> 00:31:59,319
way and move things into the texture

675
00:31:55,278 --> 00:32:01,940
system in a way that doesn't require

676
00:31:59,319 --> 00:32:06,200
redraw restarts all the time and stuff

677
00:32:01,940 --> 00:32:09,200
like that so I feel like we kind of want

678
00:32:06,200 --> 00:32:12,288
to play with that a little bit and I

679
00:32:09,200 --> 00:32:13,909
think we're gonna get to a point where

680
00:32:12,288 --> 00:32:16,369
we can sort of collapse this stuff down

681
00:32:13,909 --> 00:32:18,260
in a nice way we're not there yet but

682
00:32:16,369 --> 00:32:20,268
we're gonna want to I'm gonna leave that

683
00:32:18,259 --> 00:32:22,759
alone for now and just work with the

684
00:32:20,269 --> 00:32:25,308
asset reload for right now because that

685
00:32:22,759 --> 00:32:28,879
needs to get into place either way so

686
00:32:25,308 --> 00:32:31,490
this is like asset in mexican file that

687
00:32:28,880 --> 00:32:35,110
just tells us for this file here's which

688
00:32:31,490 --> 00:32:38,528
one of the assets we need to overwrite

689
00:32:35,109 --> 00:32:38,528
in that case

690
00:32:40,788 --> 00:32:51,509
I'm also gonna make a note here that

691
00:32:48,628 --> 00:32:54,388
we're talking about this right here this

692
00:32:51,509 --> 00:32:56,669
assets array because asset index now as

693
00:32:54,388 --> 00:32:59,038
a phrase is ambiguous do I mean the

694
00:32:56,669 --> 00:33:02,399
asset index in the final that it came

695
00:32:59,038 --> 00:33:04,048
from or do I mean the asset index in the

696
00:33:02,398 --> 00:33:05,579
global assets array which has had all of

697
00:33:04,048 --> 00:33:06,599
those merged together right because

698
00:33:05,579 --> 00:33:10,319
those are two different things

699
00:33:06,599 --> 00:33:15,178
and in this case I'm talking about the

700
00:33:10,319 --> 00:33:17,519
global one right okay so let's do the

701
00:33:15,179 --> 00:33:21,028
watch fineness right now and what I'm

702
00:33:17,519 --> 00:33:23,659
gonna do is I'm gonna make it so that at

703
00:33:21,028 --> 00:33:26,548
first what we'll do is if you hit a key

704
00:33:23,659 --> 00:33:28,169
it'll do the reload so basically like

705
00:33:26,548 --> 00:33:29,398
you can save as much as you want and

706
00:33:28,169 --> 00:33:31,740
then you hit a key and it'll do the

707
00:33:29,398 --> 00:33:33,359
reload eventually what I'd like to do is

708
00:33:31,740 --> 00:33:35,519
probably just put it on a background

709
00:33:33,359 --> 00:33:38,519
task so that it'll just automatically

710
00:33:35,519 --> 00:33:42,419
reload right one of the nice things

711
00:33:38,519 --> 00:33:44,099
about dev machines nowadays is we've

712
00:33:42,419 --> 00:33:45,629
gotten back to the point where a

713
00:33:44,099 --> 00:33:47,069
consumer machine is underpowered

714
00:33:45,628 --> 00:33:50,668
compared to a developer's machine

715
00:33:47,069 --> 00:33:53,668
usually right so typically for example

716
00:33:50,669 --> 00:33:56,850
an end users machine you're not going to

717
00:33:53,669 --> 00:33:58,830
be counting on having you know 24 cores

718
00:33:56,849 --> 00:34:01,558
or something but a dev machine you can

719
00:33:58,829 --> 00:34:02,908
you can buy a 24 core dev machine or

720
00:34:01,558 --> 00:34:05,548
something ridiculous like this if you

721
00:34:02,909 --> 00:34:07,289
really want to in theory right isn't

722
00:34:05,548 --> 00:34:16,139
there some nutso thread Ripper thing

723
00:34:07,288 --> 00:34:21,300
coming to like so 32 cores in a thread

724
00:34:16,139 --> 00:34:25,649
Ripper - right so eventually what we

725
00:34:21,300 --> 00:34:27,060
will definitely see is if not today at

726
00:34:25,648 --> 00:34:30,118
least a little bit down the road but I

727
00:34:27,059 --> 00:34:33,299
would argue today any artists machine

728
00:34:30,119 --> 00:34:36,599
can trivially be made to have a ton of

729
00:34:33,300 --> 00:34:38,669
course right so you can't afford to have

730
00:34:36,599 --> 00:34:40,919
a background core doing nothing but

731
00:34:38,668 --> 00:34:43,049
reloading artwork 24/7 if that's what

732
00:34:40,918 --> 00:34:44,299
you want and will not really materially

733
00:34:43,050 --> 00:34:47,429
affect the performance of the game

734
00:34:44,300 --> 00:34:50,760
because even if your game scales

735
00:34:47,429 --> 00:34:53,869
perfectly and scales to all 64 threads

736
00:34:50,760 --> 00:34:53,869
on a thread Ripper 2

737
00:34:54,130 --> 00:34:59,720
causing one of those threads to have to

738
00:34:56,750 --> 00:35:03,019
sit around reloading artwork is only

739
00:34:59,719 --> 00:35:05,659
gonna slow your game down by 1/64 of its

740
00:35:03,019 --> 00:35:07,519
speed right now that's not entirely true

741
00:35:05,659 --> 00:35:09,980
because loading artwork involves the

742
00:35:07,519 --> 00:35:12,710
disk inin but right bla bla bla like who

743
00:35:09,980 --> 00:35:15,829
knows how it might affect it a little

744
00:35:12,710 --> 00:35:18,199
bit but we're splitting hairs the

745
00:35:15,829 --> 00:35:20,569
machine power is such that if you would

746
00:35:18,199 --> 00:35:22,759
like to you can easily just say on a

747
00:35:20,570 --> 00:35:24,410
developer's machine we have a something

748
00:35:22,760 --> 00:35:27,500
in the background sitting around that

749
00:35:24,409 --> 00:35:29,089
does nothing but developer work and it

750
00:35:27,500 --> 00:35:30,980
won't really make it so that the artist

751
00:35:29,090 --> 00:35:34,309
can't play the game as intended it

752
00:35:30,980 --> 00:35:38,409
should be fine right that was not the

753
00:35:34,309 --> 00:35:42,289
case you know maybe 10 years ago right

754
00:35:38,409 --> 00:35:44,389
but it is now so anyway so we have one

755
00:35:42,289 --> 00:35:45,529
of these watch files and what I want to

756
00:35:44,389 --> 00:35:48,049
do is make it so that maybe you had a

757
00:35:45,530 --> 00:35:49,519
key and then we reload some stuff so

758
00:35:48,050 --> 00:35:52,190
what I'm going to do here is gonna make

759
00:35:49,519 --> 00:35:54,409
a little thing that's like checked for

760
00:35:52,190 --> 00:35:56,720
art changes or something I don't know

761
00:35:54,409 --> 00:35:58,670
I'm just making up this name and what I

762
00:35:56,719 --> 00:36:01,309
want to do is pass it the game assets

763
00:35:58,670 --> 00:36:03,200
structure and what it's going to do is

764
00:36:01,309 --> 00:36:06,920
it's going to petition the file system

765
00:36:03,199 --> 00:36:09,529
again and say a operating system layer

766
00:36:06,920 --> 00:36:13,130
can you tell me what all the files are

767
00:36:09,530 --> 00:36:15,350
that are in the art directory I might

768
00:36:13,130 --> 00:36:18,349
want to reload some of them right and

769
00:36:15,349 --> 00:36:20,599
we've already got the we're already sort

770
00:36:18,349 --> 00:36:24,949
of doing one of those in here already

771
00:36:20,599 --> 00:36:28,460
this file loading part here you can see

772
00:36:24,949 --> 00:36:32,299
oh this was snuffleupagus oriented

773
00:36:28,460 --> 00:36:34,280
programming by the way so what I want to

774
00:36:32,300 --> 00:36:37,220
do is I want to you know load that in I

775
00:36:34,280 --> 00:36:40,550
want to ask the platform to get me all

776
00:36:37,219 --> 00:36:43,849
of the type files that are pngs I

777
00:36:40,550 --> 00:36:46,340
believe yeah and so I want to say how

778
00:36:43,849 --> 00:36:53,110
many P and G's are there I want to go

779
00:36:46,340 --> 00:36:57,980
ahead and loop through each of those

780
00:36:53,110 --> 00:37:01,640
like so and then every time we get one

781
00:36:57,980 --> 00:37:04,309
of those out it's gonna have a base name

782
00:37:01,639 --> 00:37:06,199
what I want to do is I want to create a

783
00:37:04,309 --> 00:37:07,369
stat a standing structure that will

784
00:37:06,199 --> 00:37:09,469
never go away it's just a

785
00:37:07,369 --> 00:37:12,559
permanent record of the fact that this

786
00:37:09,469 --> 00:37:14,149
file existed right what I want to do is

787
00:37:12,559 --> 00:37:18,470
I want to create a permanent record of

788
00:37:14,150 --> 00:37:25,720
the file so what its name was what its

789
00:37:18,469 --> 00:37:29,808
date was and what assets it used right

790
00:37:25,719 --> 00:37:33,199
so I want to make this and then I want

791
00:37:29,809 --> 00:37:36,259
to see for anyone that I have that

792
00:37:33,199 --> 00:37:38,838
appears to have changed I want to

793
00:37:36,259 --> 00:37:42,528
actually ask the PNG loader to load it

794
00:37:38,838 --> 00:37:47,018
and then I want to look through each of

795
00:37:42,528 --> 00:37:50,778
the chunks in the file looking to see

796
00:37:47,018 --> 00:37:56,058
what information there is about look

797
00:37:50,778 --> 00:37:59,389
like I want to see what I should I say

798
00:37:56,059 --> 00:38:02,150
this I want to see what assets actually

799
00:37:59,389 --> 00:38:04,338
exist in the grid and whether or not

800
00:38:02,150 --> 00:38:06,798
those assets are different from ones

801
00:38:04,338 --> 00:38:09,230
that I have already in my permanent

802
00:38:06,798 --> 00:38:11,179
storage now one of the things that I

803
00:38:09,230 --> 00:38:13,278
probably should do is instead of calling

804
00:38:11,179 --> 00:38:15,078
this a watch file I might call this

805
00:38:13,278 --> 00:38:21,440
something slightly different I might

806
00:38:15,079 --> 00:38:26,210
call this a source file and the reason

807
00:38:21,440 --> 00:38:28,190
I'm gonna call it that is because I want

808
00:38:26,210 --> 00:38:31,220
to think of this as something that

809
00:38:28,190 --> 00:38:36,048
probably has a broader scope than just

810
00:38:31,219 --> 00:38:39,108
watching the file so for example we may

811
00:38:36,048 --> 00:38:43,038
want a bunch of information like tweaks

812
00:38:39,108 --> 00:38:48,588
and stuff to apply to the things in this

813
00:38:43,039 --> 00:38:50,569
file you remember us mentioning maybe it

814
00:38:48,588 --> 00:38:52,568
was last weekend I think when we were

815
00:38:50,568 --> 00:38:55,369
sort of doing some preliminary work here

816
00:38:52,568 --> 00:38:59,568
there's information that may need to be

817
00:38:55,369 --> 00:39:05,680
added that is additional on this file so

818
00:38:59,568 --> 00:39:10,778
you know if we look at this for example

819
00:39:05,679 --> 00:39:10,778
I really need something that's gonna

820
00:39:14,639 --> 00:39:20,639
what's paint 3d though that's this thing

821
00:39:18,250 --> 00:39:23,920
all right

822
00:39:20,639 --> 00:39:28,509
so check it out of curiosity what is 3d

823
00:39:23,920 --> 00:39:31,570
about this like what what happens in 3d

824
00:39:28,510 --> 00:39:56,440
here does anyone know like how did how

825
00:39:31,570 --> 00:40:04,030
do I make this 3d exactly okay all right

826
00:39:56,440 --> 00:40:08,730
so what why was it only painting on the

827
00:40:04,030 --> 00:40:08,730
plane is that can I paint on this block

828
00:40:13,530 --> 00:40:18,790
they're just trolling at this point are

829
00:40:17,139 --> 00:40:20,920
they just trolling me at this point

830
00:40:18,789 --> 00:40:23,469
they made a 3d paint program that can't

831
00:40:20,920 --> 00:40:24,760
paint in 3d and I mean am i missing is

832
00:40:23,469 --> 00:40:27,009
that actually what I'm looking at right

833
00:40:24,760 --> 00:40:27,910
now or is that I just do I just not know

834
00:40:27,010 --> 00:40:37,000
how to use the program

835
00:40:27,909 --> 00:40:38,980
I mean if it's 3d paint I should be able

836
00:40:37,000 --> 00:40:41,260
to paint on the cube right I mean that's

837
00:40:38,980 --> 00:40:46,750
like the minimum that would be necessary

838
00:40:41,260 --> 00:40:48,910
to make this a 3d paint program am I

839
00:40:46,750 --> 00:40:49,300
just am I am i way off in the field here

840
00:40:48,909 --> 00:40:51,460
folks

841
00:40:49,300 --> 00:40:53,890
please please tell me if I'm being

842
00:40:51,460 --> 00:40:56,139
unreasonable but it kind of feels to me

843
00:40:53,889 --> 00:40:59,429
like to call something paint 3d you have

844
00:40:56,139 --> 00:41:01,659
to be able to paint outside of the plane

845
00:40:59,429 --> 00:41:04,179
but maybe I'm missing something

846
00:41:01,659 --> 00:41:06,309
like can i is there a way to get some

847
00:41:04,179 --> 00:41:08,619
other plane so I can have like two

848
00:41:06,309 --> 00:41:16,239
planes or something oh I can have a

849
00:41:08,619 --> 00:41:20,489
little sticky star can i okay so so I

850
00:41:16,239 --> 00:41:20,489
can stamp things on to it

851
00:41:23,500 --> 00:41:29,019
but I just can't draw onto it

852
00:41:42,150 --> 00:41:49,389
it's fine I don't know why I even bother

853
00:41:46,349 --> 00:41:51,400
all right so let's just go back to

854
00:41:49,389 --> 00:41:54,639
something I don't know what about this

855
00:41:51,400 --> 00:42:04,358
is this a normal can't read that file

856
00:41:54,639 --> 00:42:09,819
okay you know what developer studio can

857
00:42:04,358 --> 00:42:13,559
read these although it may roll over and

858
00:42:09,820 --> 00:42:13,559
die if it tries to read a file that big

859
00:42:15,960 --> 00:42:27,699
I'll load it with I tell you

860
00:42:22,869 --> 00:42:28,990
Windows 10 never stops trolling me it

861
00:42:27,699 --> 00:42:31,149
reboots whenever it wants and it

862
00:42:28,989 --> 00:42:33,039
installs a program called paint 3d that

863
00:42:31,150 --> 00:42:34,750
can't paint in three dimensions that's

864
00:42:33,039 --> 00:42:36,699
that's that's a new one

865
00:42:34,750 --> 00:42:38,170
I guess that's kind of the same as

866
00:42:36,699 --> 00:42:40,329
calling Windows 10 profession of Windows

867
00:42:38,170 --> 00:42:41,769
10 professional when it is like like one

868
00:42:40,329 --> 00:42:47,650
of the most unprofessional things I've

869
00:42:41,769 --> 00:42:49,358
ever seen okay so here is ya all right

870
00:42:47,650 --> 00:42:51,639
so here is an example of one of our

871
00:42:49,358 --> 00:42:55,358
files right what I was trying to say

872
00:42:51,639 --> 00:42:59,349
before I was interrupted by that sort of

873
00:42:55,358 --> 00:43:01,090
like that Microsoft role is we may need

874
00:42:59,349 --> 00:43:03,969
to annotate this with additional

875
00:43:01,090 --> 00:43:06,880
information so for example if I wanted

876
00:43:03,969 --> 00:43:11,319
to say like this is the ground put like

877
00:43:06,880 --> 00:43:12,910
this is where this thing sits on a hard

878
00:43:11,320 --> 00:43:15,250
point so like you know if this is where

879
00:43:12,909 --> 00:43:18,009
it's supposed to be hopping to or

880
00:43:15,250 --> 00:43:20,969
whatever that it hops to right you know

881
00:43:18,010 --> 00:43:25,780
that's the alignment of that thing

882
00:43:20,969 --> 00:43:27,519
versus a ground point or similarly if I

883
00:43:25,780 --> 00:43:29,170
wanted to say here's the neck like

884
00:43:27,519 --> 00:43:31,869
that's where the head attaches to

885
00:43:29,170 --> 00:43:34,480
there's you know so if we want to

886
00:43:31,869 --> 00:43:37,539
annotate these with particular pieces of

887
00:43:34,480 --> 00:43:41,199
information that information really

888
00:43:37,539 --> 00:43:43,539
isn't super plausible to edit in pngs

889
00:43:41,199 --> 00:43:48,279
now it's not that you can't

890
00:43:43,539 --> 00:43:50,889
so p.m. G's as we saw can have

891
00:43:48,280 --> 00:43:54,220
information embedded in them so you know

892
00:43:50,889 --> 00:43:55,598
for example if Photoshop were a nice

893
00:43:54,219 --> 00:43:58,118
easy to use program that

894
00:43:55,599 --> 00:44:00,039
artists had fun with it would have

895
00:43:58,119 --> 00:44:02,200
things like alignment point as an easy

896
00:44:00,039 --> 00:44:04,210
thing to do and then it could store that

897
00:44:02,199 --> 00:44:05,649
into when it exported a PNG could store

898
00:44:04,210 --> 00:44:06,869
that into the text fields or something

899
00:44:05,650 --> 00:44:09,639
right

900
00:44:06,869 --> 00:44:11,289
but even though Photoshop does sort of

901
00:44:09,639 --> 00:44:12,699
have some features like that that you

902
00:44:11,289 --> 00:44:14,349
can kind of co-op for this purpose

903
00:44:12,699 --> 00:44:15,960
they're not easy for artists to use and

904
00:44:14,349 --> 00:44:18,160
artists don't know how to use them

905
00:44:15,960 --> 00:44:20,429
they're not intuitive and they don't

906
00:44:18,159 --> 00:44:23,679
really do that sort of stuff very well

907
00:44:20,429 --> 00:44:24,818
and so you typically don't find artists

908
00:44:23,679 --> 00:44:27,098
who would know how to do that

909
00:44:24,818 --> 00:44:30,219
necessarily you could force them to

910
00:44:27,099 --> 00:44:31,930
learn but usually it's better not to

911
00:44:30,219 --> 00:44:35,078
make an artist life miserable and make

912
00:44:31,929 --> 00:44:37,778
them use problematic pieces of a tool if

913
00:44:35,079 --> 00:44:40,950
you don't have to so an easier thing to

914
00:44:37,778 --> 00:44:43,210
do because of Photoshop sort of lack of

915
00:44:40,949 --> 00:44:46,689
really targeting the game industry as a

916
00:44:43,210 --> 00:44:49,539
thing what we want to do is add our own

917
00:44:46,690 --> 00:44:51,509
ability to specify this markup but then

918
00:44:49,539 --> 00:44:54,160
that means where does it go

919
00:44:51,509 --> 00:44:55,778
it won't go back into the Photoshop

920
00:44:54,159 --> 00:44:58,989
files that the artist was using to make

921
00:44:55,778 --> 00:45:00,608
it so the onus becomes on us to store

922
00:44:58,989 --> 00:45:04,929
that information somewhere meaningful

923
00:45:00,608 --> 00:45:08,318
right and so what we need to do is we

924
00:45:04,929 --> 00:45:10,868
need to keep this information around so

925
00:45:08,318 --> 00:45:14,759
what I'd like to do is say that we

926
00:45:10,869 --> 00:45:14,759
probably want something like this

927
00:45:27,519 --> 00:45:48,230
right and so this way in addition to

928
00:45:45,559 --> 00:45:50,170
storing where I put everything I can

929
00:45:48,230 --> 00:45:54,349
also store some additional information

930
00:45:50,170 --> 00:45:59,358
that means something to me now when I

931
00:45:54,349 --> 00:46:02,359
look back and go what's the actual data

932
00:45:59,358 --> 00:46:04,219
that we're using here that should

933
00:46:02,358 --> 00:46:08,659
hopefully give me some information so we

934
00:46:04,219 --> 00:46:10,000
see in here for the HHA bitmap which is

935
00:46:08,659 --> 00:46:12,799
the thing that we're talking about now

936
00:46:10,000 --> 00:46:16,068
we've got these two things the dimension

937
00:46:12,800 --> 00:46:17,809
the align percentage right so what I

938
00:46:16,068 --> 00:46:19,940
could do is just store this exactly this

939
00:46:17,809 --> 00:46:21,559
way right I could store the align

940
00:46:19,940 --> 00:46:26,950
percentage in here and that's like the

941
00:46:21,559 --> 00:46:29,750
marked up alignment percentage I suppose

942
00:46:26,949 --> 00:46:32,269
maybe what I could do as well is just

943
00:46:29,750 --> 00:46:33,559
say look you know maybe this is it this

944
00:46:32,269 --> 00:46:35,989
doesn't actually need to be done this

945
00:46:33,559 --> 00:46:37,400
way maybe I could say hey look that's

946
00:46:35,989 --> 00:46:39,318
just stored in the file

947
00:46:37,400 --> 00:46:48,010
so the HHA bit map tells us that

948
00:46:39,318 --> 00:46:48,009
information how do I feel about that

949
00:47:02,000 --> 00:47:07,599
I guess that's fine so I guess I guess

950
00:47:04,429 --> 00:47:07,599
maybe this was not really that necessary

951
00:47:08,650 --> 00:47:13,369
because what we can do is we can just go

952
00:47:11,119 --> 00:47:14,900
back in there and get it right we can

953
00:47:13,369 --> 00:47:16,279
just go back in there and look up what

954
00:47:14,900 --> 00:47:17,840
the align percentage was because

955
00:47:16,280 --> 00:47:19,760
anything that we needed to mark up get

956
00:47:17,840 --> 00:47:20,930
stored in the file by default so it's

957
00:47:19,760 --> 00:47:25,040
really this thing that we would have to

958
00:47:20,929 --> 00:47:26,839
change seems reasonable to me and that's

959
00:47:25,039 --> 00:47:28,909
really the only thing that we've got we

960
00:47:26,840 --> 00:47:39,170
don't really mark up anything else I

961
00:47:28,909 --> 00:47:45,230
don't think yeah so I think that should

962
00:47:39,170 --> 00:47:50,380
probably be fine I think that should

963
00:47:45,230 --> 00:47:54,559
probably be fine all right so anyway

964
00:47:50,380 --> 00:47:56,180
looking through here we've got the asset

965
00:47:54,559 --> 00:47:57,739
indices in the file date base name and

966
00:47:56,179 --> 00:47:59,719
the hash that should be sufficient for

967
00:47:57,739 --> 00:48:01,129
doing what we want to do so when we do

968
00:47:59,719 --> 00:48:04,719
our check for our changes and we come

969
00:48:01,130 --> 00:48:09,590
through here we're gonna do our platform

970
00:48:04,719 --> 00:48:14,539
get all file to files of type begin get

971
00:48:09,590 --> 00:48:18,860
all files of type and I think we passed

972
00:48:14,539 --> 00:48:22,429
this back in right so here's our actual

973
00:48:18,860 --> 00:48:24,860
change check when we come through here

974
00:48:22,429 --> 00:48:26,869
to look up something for the base name

975
00:48:24,860 --> 00:48:31,329
we're going to want to hash this string

976
00:48:26,869 --> 00:48:35,019
I believe we already have a string hash

977
00:48:31,329 --> 00:48:35,019
if we look here

978
00:48:38,829 --> 00:48:55,940
ya know if we actually have any string

979
00:48:51,559 --> 00:48:57,849
hashes besides that custom one I know I

980
00:48:55,940 --> 00:49:00,320
can search for a better hash function

981
00:48:57,849 --> 00:49:03,230
and see it but it looks like it's only

982
00:49:00,320 --> 00:49:11,030
in the yeah so I guess we don't we never

983
00:49:03,230 --> 00:49:13,608
really had one yeah so I guess I will

984
00:49:11,030 --> 00:49:16,730
add one here that's just a way to do a

985
00:49:13,608 --> 00:49:19,579
generic string hash in here that's used

986
00:49:16,730 --> 00:49:21,670
the same way because it doesn't look

987
00:49:19,579 --> 00:49:25,069
like we've ever done any string hashing

988
00:49:21,670 --> 00:49:28,010
that wasn't custom that wasn't specific

989
00:49:25,070 --> 00:49:30,289
to some part of the system like the

990
00:49:28,010 --> 00:49:31,640
debug system that was trying to loop

991
00:49:30,289 --> 00:49:36,889
through and do other things at the same

992
00:49:31,639 --> 00:49:38,629
time that's a pointer hash this is looks

993
00:49:36,889 --> 00:49:42,079
like this is the only string hash we

994
00:49:38,630 --> 00:49:44,000
have and it's doing other stuff at the

995
00:49:42,079 --> 00:49:48,079
same time which we don't really want to

996
00:49:44,000 --> 00:49:52,429
do in this case what we could do is sort

997
00:49:48,079 --> 00:50:00,409
of localize this hash function a little

998
00:49:52,429 --> 00:50:03,108
bit here which is to say that the update

999
00:50:00,409 --> 00:50:05,088
mode of this is something we could break

1000
00:50:03,108 --> 00:50:12,069
out so we could make a thing here that

1001
00:50:05,088 --> 00:50:12,070
was like in line void update string hash

1002
00:50:12,219 --> 00:50:24,379
that you know that I think just works so

1003
00:50:21,858 --> 00:50:27,650
we could do something like this where

1004
00:50:24,380 --> 00:50:29,480
you could do this update step and that

1005
00:50:27,650 --> 00:50:31,099
way everyone just uses it so that if we

1006
00:50:29,480 --> 00:50:33,409
do make a better hash function someday

1007
00:50:31,099 --> 00:50:35,619
everyone would get it so that seems kind

1008
00:50:33,409 --> 00:50:35,618
of nice

1009
00:50:38,769 --> 00:50:55,119
right and then this sort of thing just

1010
00:50:42,409 --> 00:50:57,529
does update string hash and off you go

1011
00:50:55,119 --> 00:50:58,940
so that seems kind of nice to me because

1012
00:50:57,530 --> 00:51:02,119
it occurred to me as I was doing that

1013
00:50:58,940 --> 00:51:05,630
that actually this is going to be the

1014
00:51:02,119 --> 00:51:07,910
same sort of thing so where we where we

1015
00:51:05,630 --> 00:51:10,640
actually go through here we probably do

1016
00:51:07,909 --> 00:51:12,108
want to do two different operations one

1017
00:51:10,639 --> 00:51:14,539
of which is we're going to actually

1018
00:51:12,108 --> 00:51:17,269
produce the string hash that we would

1019
00:51:14,539 --> 00:51:19,039
need to look it up quickly but the other

1020
00:51:17,269 --> 00:51:21,259
one is we're going to want to look at

1021
00:51:19,039 --> 00:51:23,269
the file name to figure out what it is

1022
00:51:21,260 --> 00:51:24,920
that we're looking at because that's the

1023
00:51:23,269 --> 00:51:28,159
only information that we actually have

1024
00:51:24,920 --> 00:51:31,068
to figure out what this should be block

1025
00:51:28,159 --> 00:51:32,659
underscore character underscore cover

1026
00:51:31,068 --> 00:51:35,659
underscore hand underscore item

1027
00:51:32,659 --> 00:51:37,848
underscore obstacles underscore or none

1028
00:51:35,659 --> 00:51:39,199
of the above so for example the title

1029
00:51:37,849 --> 00:51:43,190
screen is kind of just its own thing

1030
00:51:39,199 --> 00:51:45,250
here all of those different pieces of

1031
00:51:43,190 --> 00:51:48,740
information are gonna have to be

1032
00:51:45,250 --> 00:51:50,539
parceled out because that's the only way

1033
00:51:48,739 --> 00:51:54,250
we really know what we're looking at

1034
00:51:50,539 --> 00:51:57,829
here and so we kind of need some

1035
00:51:54,250 --> 00:52:05,030
scanning that's kind of in line with

1036
00:51:57,829 --> 00:52:08,930
this so we are gonna do an update string

1037
00:52:05,030 --> 00:52:09,980
hash here but while we're doing it we're

1038
00:52:08,929 --> 00:52:15,919
probably going to look for some other

1039
00:52:09,980 --> 00:52:19,789
things that's just how it's gonna go

1040
00:52:15,920 --> 00:52:23,710
right okay so coming through here let's

1041
00:52:19,789 --> 00:52:23,710
take a little bit more of

1042
00:52:29,300 --> 00:52:39,500
let's take a little bit more of an

1043
00:52:31,309 --> 00:52:42,409
excursion in here so looking at the

1044
00:52:39,500 --> 00:52:43,820
platform information that we get I think

1045
00:52:42,409 --> 00:52:45,139
it's just a date in the base name that

1046
00:52:43,820 --> 00:52:49,039
we actually need I don't think we need

1047
00:52:45,139 --> 00:52:50,719
anything else right well I mean the size

1048
00:52:49,039 --> 00:52:52,250
we would use once we actually go to read

1049
00:52:50,719 --> 00:52:56,359
it I suppose but that's about it

1050
00:52:52,250 --> 00:52:58,960
actually so what we want to do here is

1051
00:52:56,360 --> 00:53:12,110
we're gonna have to take the base name

1052
00:52:58,960 --> 00:53:13,699
let's actually scan over that so we'll

1053
00:53:12,110 --> 00:53:16,430
look so we get to the null terminator on

1054
00:53:13,699 --> 00:53:18,109
that so looking over the base name that

1055
00:53:16,429 --> 00:53:20,569
will allow us to Britt bring up our hash

1056
00:53:18,110 --> 00:53:23,990
value we're gonna want some extra

1057
00:53:20,570 --> 00:53:25,550
information here as well and I think one

1058
00:53:23,989 --> 00:53:27,679
of the things that we probably want and

1059
00:53:25,550 --> 00:53:28,970
I talked about this before is that I

1060
00:53:27,679 --> 00:53:31,849
think we're gonna want to start actually

1061
00:53:28,969 --> 00:53:37,189
having a real string here the reason for

1062
00:53:31,849 --> 00:53:39,259
that again is just because Jimmy once

1063
00:53:37,190 --> 00:53:41,059
you start picking like plucking pieces

1064
00:53:39,260 --> 00:53:43,820
out of things you tend to want to just

1065
00:53:41,059 --> 00:53:46,429
have like non null term and strings null

1066
00:53:43,820 --> 00:53:48,170
terminated strings are not good I wish

1067
00:53:46,429 --> 00:53:50,059
they had not been the standard and see

1068
00:53:48,170 --> 00:53:53,420
they're not a good way of storing

1069
00:53:50,059 --> 00:53:56,179
strings strings should be stored as a

1070
00:53:53,420 --> 00:53:58,670
length plus the pointer to the actual

1071
00:53:56,179 --> 00:54:01,159
value the reason for this is because

1072
00:53:58,670 --> 00:54:03,260
once you do any non-trivial operations

1073
00:54:01,159 --> 00:54:05,449
with strings whatsoever you typically

1074
00:54:03,260 --> 00:54:08,900
want to start talking about sub regions

1075
00:54:05,449 --> 00:54:11,149
of the string and null termination does

1076
00:54:08,900 --> 00:54:14,210
not allow you to do that null

1077
00:54:11,150 --> 00:54:15,349
termination just to give you a little

1078
00:54:14,210 --> 00:54:17,420
bit of a background here of what I'm

1079
00:54:15,349 --> 00:54:19,779
talking about go ahead and move this out

1080
00:54:17,420 --> 00:54:19,780
of the way

1081
00:54:31,039 --> 00:54:34,730
so null termination

1082
00:54:56,949 --> 00:55:03,369
so what are the advantages of melter

1083
00:55:00,400 --> 00:55:04,360
mination versus length plus of military

1084
00:55:03,369 --> 00:55:05,679
of Riesling sprinter and what are the

1085
00:55:04,360 --> 00:55:07,030
advantages like 4e versus an alternation

1086
00:55:05,679 --> 00:55:12,849
like look what's better and how does it

1087
00:55:07,030 --> 00:55:15,850
work so this C style is null termination

1088
00:55:12,849 --> 00:55:19,659
right it says that you have an 8 byte

1089
00:55:15,849 --> 00:55:21,219
pointer right that points to just some

1090
00:55:19,659 --> 00:55:28,379
series of characters and we know that

1091
00:55:21,219 --> 00:55:32,649
the last one is well one byte of zeros

1092
00:55:28,380 --> 00:55:36,880
so what that means is it takes I guess

1093
00:55:32,650 --> 00:55:40,300
you might say 10 bytes to store the most

1094
00:55:36,880 --> 00:55:43,780
minimal string right because the minimal

1095
00:55:40,300 --> 00:55:46,360
string would be one character long we

1096
00:55:43,780 --> 00:55:48,519
won't really talk about the null string

1097
00:55:46,360 --> 00:55:51,130
because the null string in C style is

1098
00:55:48,519 --> 00:55:53,829
difficult to define you could argue that

1099
00:55:51,130 --> 00:55:56,110
the null string is takes 8 bytes to

1100
00:55:53,829 --> 00:55:58,389
store or 9 bytes to store depending on

1101
00:55:56,110 --> 00:56:01,720
whether you're talking about a valid

1102
00:55:58,389 --> 00:56:04,420
string that has nothing in it or a zero

1103
00:56:01,719 --> 00:56:06,069
pointer which maybe you consider valid

1104
00:56:04,420 --> 00:56:08,260
or not so there's actually multiple

1105
00:56:06,070 --> 00:56:15,480
states there with C style it's worth

1106
00:56:08,260 --> 00:56:18,100
noting so ignoring that for one second

1107
00:56:15,480 --> 00:56:20,440
the minimal string let's say of one

1108
00:56:18,099 --> 00:56:22,509
character is 10 bytes long and generally

1109
00:56:20,440 --> 00:56:26,309
speaking right the overhead is 9 bytes

1110
00:56:22,510 --> 00:56:31,630
so it's 9 bytes plus the character count

1111
00:56:26,309 --> 00:56:35,309
for the string right so for a length

1112
00:56:31,630 --> 00:56:37,300
plus pointer it's usually going to be

1113
00:56:35,309 --> 00:56:39,519
depending on how big you want your

1114
00:56:37,300 --> 00:56:41,650
string Maxon to be you could say that

1115
00:56:39,519 --> 00:56:44,829
you only have a 16-bit count and a

1116
00:56:41,650 --> 00:56:47,050
pointer but typically you use more of a

1117
00:56:44,829 --> 00:56:54,429
4 byte count at a pointer because why

1118
00:56:47,050 --> 00:56:57,640
not allow gigantic strings right because

1119
00:56:54,429 --> 00:56:58,750
remember the C style could have you

1120
00:56:57,639 --> 00:57:00,339
could have pointed to something that

1121
00:56:58,750 --> 00:57:02,559
happened to be 4 gigabytes long it would

1122
00:57:00,340 --> 00:57:04,900
be just fine the seesaw doesn't care how

1123
00:57:02,559 --> 00:57:07,929
long it is so in order to be able to

1124
00:57:04,900 --> 00:57:10,450
store very large strings you would want

1125
00:57:07,929 --> 00:57:12,338
at least a 4 byte count

1126
00:57:10,449 --> 00:57:14,199
and then you have an 8-byte pointer

1127
00:57:12,338 --> 00:57:17,048
which means that you actually have a 12

1128
00:57:14,199 --> 00:57:18,730
light overhead right so it's three more

1129
00:57:17,048 --> 00:57:20,980
bytes of overhead than the other one did

1130
00:57:18,730 --> 00:57:23,079
and if you really wanted the same

1131
00:57:20,980 --> 00:57:26,230
flexibility as a c-- style you would

1132
00:57:23,079 --> 00:57:29,109
technically need the eight bytes on a

1133
00:57:26,230 --> 00:57:30,969
64-bit machine now to be fair it would

1134
00:57:29,108 --> 00:57:33,279
never really be that many it would be

1135
00:57:30,969 --> 00:57:36,669
more like six bytes because there is no

1136
00:57:33,280 --> 00:57:39,190
machine that can actually have 64 bits

1137
00:57:36,670 --> 00:57:41,710
of actual memory in it so you're never

1138
00:57:39,190 --> 00:57:43,929
really gonna have that so it's more like

1139
00:57:41,710 --> 00:57:47,588
maybe fourteen bytes versus nine bytes

1140
00:57:43,929 --> 00:57:50,739
but whatever either way what I would

1141
00:57:47,588 --> 00:57:52,179
like to make very clear here is you're

1142
00:57:50,739 --> 00:57:54,189
dealing with just a few bytes of

1143
00:57:52,179 --> 00:57:57,578
difference between the two so there's

1144
00:57:54,190 --> 00:57:59,679
very little overhead in either case that

1145
00:57:57,579 --> 00:58:04,690
you really care about you're pretty good

1146
00:57:59,679 --> 00:58:06,338
to go in either one and if you really

1147
00:58:04,690 --> 00:58:07,869
cared about overhead all that much you

1148
00:58:06,338 --> 00:58:10,029
would probably have to do something

1149
00:58:07,869 --> 00:58:11,970
different altogether anyway that was

1150
00:58:10,030 --> 00:58:14,530
more about storing the thing inside the

1151
00:58:11,969 --> 00:58:15,699
space itself or other kind of bit

1152
00:58:14,530 --> 00:58:17,650
encoding and all these other sorts of

1153
00:58:15,699 --> 00:58:20,949
things so ignoring that assuming you're

1154
00:58:17,650 --> 00:58:23,530
just doing the generic version you don't

1155
00:58:20,949 --> 00:58:25,659
suffer that much more overhead in terms

1156
00:58:23,530 --> 00:58:29,109
of actual memory you're gonna care about

1157
00:58:25,659 --> 00:58:31,629
like with the the count string because

1158
00:58:29,108 --> 00:58:35,078
you just don't typically have this many

1159
00:58:31,630 --> 00:58:36,789
of these anyway so the reason that I

1160
00:58:35,079 --> 00:58:38,798
don't like the null termination is

1161
00:58:36,789 --> 00:58:43,108
pretty simple usually you have things

1162
00:58:38,798 --> 00:58:50,909
like you know character underscore

1163
00:58:43,108 --> 00:58:55,719
orphan underscore o 2 dot PNG right and

1164
00:58:50,909 --> 00:59:00,129
so this for example is a string it's the

1165
00:58:55,719 --> 00:59:03,009
file name let's say I want to parse this

1166
00:59:00,130 --> 00:59:05,730
file name so what I typically want to

1167
00:59:03,010 --> 00:59:12,960
produce oops

1168
00:59:05,730 --> 00:59:20,199
are things like this you know string

1169
00:59:12,960 --> 00:59:24,610
type equals character right string

1170
00:59:20,199 --> 00:59:27,909
name equals orphan my hand ranks really

1171
00:59:24,610 --> 00:59:34,260
bad today even worse than normal string

1172
00:59:27,909 --> 00:59:39,429
number equals o to write string

1173
00:59:34,260 --> 00:59:41,320
extension equals PNG right so typically

1174
00:59:39,429 --> 00:59:43,710
what we want to do is like parse these

1175
00:59:41,320 --> 00:59:47,050
things out so they look like this

1176
00:59:43,710 --> 00:59:48,970
now the nonsense way to do this is to

1177
00:59:47,050 --> 00:59:50,830
actually allocate strings all the time

1178
00:59:48,969 --> 00:59:53,319
so you actually go through and you parse

1179
00:59:50,829 --> 00:59:55,029
this out you allocate a new string you

1180
00:59:53,320 --> 00:59:56,170
copy it into here and it's just a

1181
00:59:55,030 --> 01:00:00,370
disaster

1182
00:59:56,170 --> 01:00:02,650
right tons of allocations tons of memory

1183
01:00:00,369 --> 01:00:04,239
copies blah blah blah blah blah but

1184
01:00:02,650 --> 01:00:08,170
there's really not much other way to do

1185
01:00:04,239 --> 01:00:09,609
it if you're forcing to you if you're

1186
01:00:08,170 --> 01:00:11,349
going to use a null terminator version

1187
01:00:09,610 --> 01:00:12,430
because the null terminator version the

1188
01:00:11,349 --> 01:00:14,500
only way it could do it without

1189
01:00:12,429 --> 01:00:17,139
allocation would be to overwrite the

1190
01:00:14,500 --> 01:00:20,469
string so you'd have to actually insert

1191
01:00:17,139 --> 01:00:22,539
null terminators into these locations in

1192
01:00:20,469 --> 01:00:24,730
order to point directly into the

1193
01:00:22,539 --> 01:00:27,610
original string at these to give you

1194
01:00:24,730 --> 01:00:29,590
these results right and once you do that

1195
01:00:27,610 --> 01:00:29,980
you can't use the original string

1196
01:00:29,590 --> 01:00:31,480
anymore

1197
01:00:29,980 --> 01:00:33,670
because now the original string

1198
01:00:31,480 --> 01:00:36,340
character or 4 no 2 dot PNG has been

1199
01:00:33,670 --> 01:00:38,740
corrupted so you couldn't then go use it

1200
01:00:36,340 --> 01:00:39,910
to say load the file off disk by saying

1201
01:00:38,739 --> 01:00:41,529
here is the file I wanted to load

1202
01:00:39,909 --> 01:00:43,569
because now it just points to something

1203
01:00:41,530 --> 01:00:46,600
that just says character and then

1204
01:00:43,570 --> 01:00:48,580
there's a null terminator right however

1205
01:00:46,599 --> 01:00:50,739
if you use length strings all of this

1206
01:00:48,579 --> 01:00:52,719
stuff becomes trivial you this is just a

1207
01:00:50,739 --> 01:00:54,699
block of memory it has the original

1208
01:00:52,719 --> 01:00:56,500
stuff in it these now just become length

1209
01:00:54,699 --> 01:00:58,239
strings that point to here and have the

1210
01:00:56,500 --> 01:01:00,070
length point to here has the length

1211
01:00:58,239 --> 01:01:02,649
point to here has the length point to

1212
01:01:00,070 --> 01:01:05,289
here has the length right so length

1213
01:01:02,650 --> 01:01:08,170
strings allow you to break up blocks of

1214
01:01:05,289 --> 01:01:10,599
memory into regions extremely trivially

1215
01:01:08,170 --> 01:01:19,530
and then you don't have any of these

1216
01:01:10,599 --> 01:01:19,529
problems so what I would like to say

1217
01:01:21,820 --> 01:01:27,370
is that if you are programming in C and

1218
01:01:25,719 --> 01:01:29,589
you're using the built-in kind of

1219
01:01:27,369 --> 01:01:31,210
functions that they use then you end up

1220
01:01:29,590 --> 01:01:32,740
with a null Terminator system like we

1221
01:01:31,210 --> 01:01:35,769
have on handmade hero because we haven't

1222
01:01:32,739 --> 01:01:38,259
really cared much we don't do a lot of

1223
01:01:35,769 --> 01:01:39,909
operations with strings but once you

1224
01:01:38,260 --> 01:01:41,410
start doing a lot of operations on

1225
01:01:39,909 --> 01:01:42,789
strings like we're sort of storing you

1226
01:01:41,409 --> 01:01:46,989
now we're gonna parse this file name

1227
01:01:42,789 --> 01:01:48,969
into pieces and do stuff with it having

1228
01:01:46,989 --> 01:01:51,579
a length string becomes very important

1229
01:01:48,969 --> 01:01:54,609
because length strings are way way way

1230
01:01:51,579 --> 01:01:56,440
way way better than null terminated

1231
01:01:54,610 --> 01:01:59,980
strings for just about everything you

1232
01:01:56,440 --> 01:02:02,380
might want to do the only thing that

1233
01:01:59,980 --> 01:02:04,659
gets a little bit harder is you have to

1234
01:02:02,380 --> 01:02:08,019
actually check against the count when

1235
01:02:04,659 --> 01:02:09,899
you're processing them and occasionally

1236
01:02:08,019 --> 01:02:12,099
that's a little bit harder like

1237
01:02:09,900 --> 01:02:14,230
sometimes when you're just ingesting

1238
01:02:12,099 --> 01:02:21,549
characters just checking for null is

1239
01:02:14,230 --> 01:02:24,639
easier I'm not sure if we'll actually

1240
01:02:21,550 --> 01:02:27,430
see this occur in practice in what we're

1241
01:02:24,639 --> 01:02:30,099
about to do probably not but I can give

1242
01:02:27,429 --> 01:02:34,449
you a simple example let's suppose you

1243
01:02:30,099 --> 01:02:39,219
wanted to parse a number and I just want

1244
01:02:34,449 --> 01:02:42,159
to say hey let's take the as much of the

1245
01:02:39,219 --> 01:02:46,509
string as has numbers in it and turn

1246
01:02:42,159 --> 01:02:48,309
that into a number right so what I might

1247
01:02:46,510 --> 01:02:50,590
do there if I was using an ultra

1248
01:02:48,309 --> 01:02:55,329
measuring is just say while the

1249
01:02:50,590 --> 01:02:58,059
character is a digit continue because I

1250
01:02:55,329 --> 01:03:00,639
know that if I hit the end of the string

1251
01:02:58,059 --> 01:03:04,539
I will get a character that isn't a

1252
01:03:00,639 --> 01:03:08,319
digit the null character right so I

1253
01:03:04,539 --> 01:03:10,329
don't have to also check for the end of

1254
01:03:08,320 --> 01:03:13,300
the string because checking to see if

1255
01:03:10,329 --> 01:03:18,009
something's a digit also checks if it's

1256
01:03:13,300 --> 01:03:20,560
the end of the string that convenience

1257
01:03:18,010 --> 01:03:23,080
goes away when you have length strings

1258
01:03:20,559 --> 01:03:24,969
because length strings do not have any

1259
01:03:23,079 --> 01:03:27,219
special character at the end of them

1260
01:03:24,969 --> 01:03:29,289
they simply told you where the end was

1261
01:03:27,219 --> 01:03:31,269
and they expect you to observe it which

1262
01:03:29,289 --> 01:03:34,059
means that every operation that you do

1263
01:03:31,269 --> 01:03:36,849
of that form has to have an

1264
01:03:34,059 --> 01:03:39,190
additional check sometimes that check is

1265
01:03:36,849 --> 01:03:40,809
free because the way you would have been

1266
01:03:39,190 --> 01:03:42,940
checking before would have been to check

1267
01:03:40,809 --> 01:03:44,829
explicitly for the null terminator in

1268
01:03:42,940 --> 01:03:48,039
which case it costs you effectively

1269
01:03:44,829 --> 01:03:49,779
nothing but in other cases you could

1270
01:03:48,039 --> 01:03:51,489
have gotten the check for free because

1271
01:03:49,780 --> 01:03:53,470
you were doing let's say a bounced check

1272
01:03:51,489 --> 01:03:55,899
on a character to see whether or not it

1273
01:03:53,469 --> 01:03:57,639
fell within a range already that check

1274
01:03:55,900 --> 01:04:01,119
will also check for the null terminator

1275
01:03:57,639 --> 01:04:04,029
for you for free so you've added one

1276
01:04:01,119 --> 01:04:10,289
additional bit operation on there that

1277
01:04:04,030 --> 01:04:13,540
has to get ended in and that's kind of

1278
01:04:10,289 --> 01:04:16,900
yeah that's kind of what I would point

1279
01:04:13,539 --> 01:04:17,679
out there as a downside to this part of

1280
01:04:16,900 --> 01:04:19,420
the process

1281
01:04:17,679 --> 01:04:24,449
so what I'm gonna do here is I'm just

1282
01:04:19,420 --> 01:04:24,450
gonna say that there's a struct string

1283
01:04:27,360 --> 01:04:33,510
and what I might do is I may even go a

1284
01:04:30,070 --> 01:04:36,700
little bit further and just call this

1285
01:04:33,510 --> 01:04:39,880
unify this actually with what we had I

1286
01:04:36,699 --> 01:04:42,879
think we've got one in here yeah so we

1287
01:04:39,880 --> 01:04:46,059
have this this sort of concept in here

1288
01:04:42,880 --> 01:04:48,610
of these stream chunks right what I

1289
01:04:46,059 --> 01:04:53,019
might do is say that let's just call

1290
01:04:48,610 --> 01:04:54,550
this actually you know a buffer or

1291
01:04:53,019 --> 01:04:57,280
something like this let's just let's

1292
01:04:54,550 --> 01:04:58,930
just make this fairly generic and say

1293
01:04:57,280 --> 01:05:01,269
that maybe we'll actually just make this

1294
01:04:58,929 --> 01:05:04,449
16 bytes long so it's you know a nice

1295
01:05:01,269 --> 01:05:08,349
aligned little thing and it can remember

1296
01:05:04,449 --> 01:05:10,359
any size plus a region right and then

1297
01:05:08,349 --> 01:05:13,259
inside here where we have this content

1298
01:05:10,360 --> 01:05:18,490
size and contents I could just make this

1299
01:05:13,260 --> 01:05:20,830
like that right something like this so

1300
01:05:18,489 --> 01:05:30,489
that's what I'm gonna do and so here

1301
01:05:20,829 --> 01:05:36,389
we'll do this like so go in there

1302
01:05:30,489 --> 01:05:36,388
[Music]

1303
01:05:44,099 --> 01:05:51,369
Oh

1304
01:05:45,248 --> 01:05:52,449
whoops what is this what is this stream

1305
01:05:51,369 --> 01:05:54,338
file bit

1306
01:05:52,449 --> 01:05:59,739
that's so this is the same thing here so

1307
01:05:54,338 --> 01:06:01,389
this should just be one of these and

1308
01:05:59,739 --> 01:06:07,478
then this gets even better because then

1309
01:06:01,389 --> 01:06:16,259
that just works right all right

1310
01:06:07,478 --> 01:06:16,259
so contents count and that's all good

1311
01:06:17,940 --> 01:06:29,548
contents count contents data contents

1312
01:06:26,130 --> 01:06:29,548
got data

1313
01:06:32,469 --> 01:06:44,949
this is just advancing this so actually

1314
01:06:35,679 --> 01:06:46,598
this is now just that right like so and

1315
01:06:44,949 --> 01:06:48,069
what you can see they're actually also

1316
01:06:46,599 --> 01:06:49,660
that is if I start to do this you can

1317
01:06:48,070 --> 01:06:58,660
see some operations that actually

1318
01:06:49,659 --> 01:07:00,429
already make sense right so I can do a

1319
01:06:58,659 --> 01:07:03,039
thing where I just say like okay I've

1320
01:07:00,429 --> 01:07:05,649
got a buffer I want to advance it by a

1321
01:07:03,039 --> 01:07:07,690
certain amount and what I can do here is

1322
01:07:05,650 --> 01:07:09,608
actually just do something like this

1323
01:07:07,690 --> 01:07:11,710
where I say if you want to advance a

1324
01:07:09,608 --> 01:07:13,480
buffer by a certain amount I can

1325
01:07:11,710 --> 01:07:17,470
actually just make this be sort of the

1326
01:07:13,480 --> 01:07:23,320
operation in question so assume if you

1327
01:07:17,469 --> 01:07:25,149
know this buffer can support in advance

1328
01:07:23,320 --> 01:07:31,019
by the count that we're talking about

1329
01:07:25,150 --> 01:07:34,300
then we then it does right whereas if

1330
01:07:31,019 --> 01:07:36,340
you know if it can't it can't and I

1331
01:07:34,300 --> 01:07:39,910
could also make that so that it you know

1332
01:07:36,340 --> 01:07:47,800
returns the the result here in this

1333
01:07:39,909 --> 01:07:49,750
fashion right so if you want the old

1334
01:07:47,800 --> 01:07:52,990
pointer you can have the old pointer

1335
01:07:49,750 --> 01:07:58,000
back if it returns zero that means that

1336
01:07:52,989 --> 01:08:02,519
you weren't able to it will suck up that

1337
01:07:58,000 --> 01:08:02,519
amount of data here we go

1338
01:08:10,358 --> 01:08:22,838
and in the case where it can't do it

1339
01:08:13,869 --> 01:08:25,719
it'll just say that you know it'll say

1340
01:08:22,838 --> 01:08:30,548
that it's at the end what I might do to

1341
01:08:25,719 --> 01:08:33,039
is put it at the end so that will

1342
01:08:30,548 --> 01:08:35,259
basically just advance the pointer by

1343
01:08:33,039 --> 01:08:42,159
exactly how much there actually was

1344
01:08:35,259 --> 01:08:43,689
right not sure if that's exactly the

1345
01:08:42,159 --> 01:08:46,858
function I want but it seems reasonable

1346
01:08:43,689 --> 01:08:50,588
so here we could just say like oh yeah

1347
01:08:46,859 --> 01:08:53,289
you know do you feel if necessary file

1348
01:08:50,588 --> 01:08:57,519
here's my results my results is just

1349
01:08:53,289 --> 01:09:02,560
advanced by whatever this count is the

1350
01:08:57,520 --> 01:09:06,219
file contents and then if you know the

1351
01:09:02,560 --> 01:09:09,850
result comes back null then I want to

1352
01:09:06,219 --> 01:09:13,119
just you know mark that down as a bad

1353
01:09:09,850 --> 01:09:18,910
situation that we didn't want to have

1354
01:09:13,119 --> 01:09:22,028
happen right and then off we go let's

1355
01:09:18,909 --> 01:09:24,548
see here I feel like is Alan on today

1356
01:09:22,029 --> 01:09:27,489
Alan is probably not I think he's on

1357
01:09:24,548 --> 01:09:31,180
vacation I have noticed that for some

1358
01:09:27,488 --> 01:09:32,769
reason I've been having for kotor jump

1359
01:09:31,180 --> 01:09:35,020
to the second error in the stream

1360
01:09:32,770 --> 01:09:38,859
sometimes i didn't know if that got

1361
01:09:35,020 --> 01:09:41,380
fixed yet i wanted to check like it

1362
01:09:38,859 --> 01:09:43,569
doesn't jump to this it jumps to this

1363
01:09:41,380 --> 01:09:47,529
for some reason sometimes i'm not sure

1364
01:09:43,569 --> 01:09:49,569
why because it didn't used to do that i

1365
01:09:47,529 --> 01:09:50,890
don't know why it does that I do have to

1366
01:09:49,569 --> 01:09:53,350
update this for coder so it may already

1367
01:09:50,890 --> 01:09:55,539
be fixed I should probably update this

1368
01:09:53,350 --> 01:09:57,789
for a coder I've been waiting till the

1369
01:09:55,539 --> 01:09:59,560
next or code or update because it's a

1370
01:09:57,789 --> 01:10:00,909
pretty big one it's got the list or API

1371
01:09:59,560 --> 01:10:03,640
so I'm probably gonna do a pretty big

1372
01:10:00,909 --> 01:10:08,130
update at that point but figured I'd

1373
01:10:03,640 --> 01:10:11,950
check anyway all right so but moving on

1374
01:10:08,130 --> 01:10:14,920
so let me just finish porting this here

1375
01:10:11,949 --> 01:10:18,029
so at content size again that's actually

1376
01:10:14,920 --> 01:10:18,029
going to be contents count

1377
01:10:19,789 --> 01:10:31,760
comdata count with intense count count

1378
01:10:31,819 --> 01:10:53,039
Count count contents count that'll

1379
01:10:51,390 --> 01:10:56,430
probably air out because we can't

1380
01:10:53,039 --> 01:11:08,609
actually this won't support a 64-bit

1381
01:10:56,430 --> 01:11:11,210
read what's safe what's our safe

1382
01:11:08,609 --> 01:11:11,210
truncate

1383
01:11:17,000 --> 01:11:23,079
I feel like that should really be safe

1384
01:11:18,800 --> 01:11:31,190
truncate to you at 32 to you 32 like so

1385
01:11:23,079 --> 01:11:33,340
um so I'm gonna rename it that there we

1386
01:11:31,189 --> 01:11:33,339
go

1387
01:11:38,289 --> 01:11:43,640
buffer - oh no that's not true

1388
01:11:42,109 --> 01:11:46,250
who's complaining about something else I

1389
01:11:43,640 --> 01:11:50,240
think it does accept a size T there so

1390
01:11:46,250 --> 01:11:54,260
that's great even better so those are

1391
01:11:50,239 --> 01:11:57,880
64-bit now oh that's great good job see

1392
01:11:54,260 --> 01:12:05,270
runtime library content stuff data

1393
01:11:57,880 --> 01:12:07,000
contents count all right so now these

1394
01:12:05,270 --> 01:12:10,070
are just safe truncate to you thirty-two

1395
01:12:07,000 --> 01:12:13,760
safe truncate to you thirty-two and

1396
01:12:10,069 --> 01:12:15,799
we're so I think that's all we need

1397
01:12:13,760 --> 01:12:17,150
I'm gonna go ahead and run just to make

1398
01:12:15,800 --> 01:12:18,829
sure that I didn't break anything with

1399
01:12:17,149 --> 01:12:21,379
that change I'm gonna make sure that the

1400
01:12:18,829 --> 01:12:24,640
PNG reader runs and doesn't you know

1401
01:12:21,380 --> 01:12:24,640
roll over and die or anything like that

1402
01:12:26,829 --> 01:12:36,309
so there we go all good I think let me

1403
01:12:31,340 --> 01:12:36,310
just verify that it actually was oh good

1404
01:12:37,029 --> 01:12:41,239
delete those and make it rewrite them

1405
01:12:39,529 --> 01:12:45,500
just to prove to ourselves that it's not

1406
01:12:41,239 --> 01:12:49,149
busted yeah I also should double check

1407
01:12:45,500 --> 01:12:49,149
the output make sure there's no errors

1408
01:12:49,689 --> 01:12:54,559
yeah so good while I'm in there I can

1409
01:12:52,850 --> 01:12:59,720
fix the error that someone mentioned on

1410
01:12:54,560 --> 01:13:04,580
the pre stream in the the PNG the test

1411
01:12:59,720 --> 01:13:08,930
PNG reader it it swaps as you can see

1412
01:13:04,579 --> 01:13:10,609
here right and so one of the problems is

1413
01:13:08,930 --> 01:13:13,700
that if you swap twice you get an

1414
01:13:10,609 --> 01:13:16,579
upside-down alpha right because you've

1415
01:13:13,699 --> 01:13:18,949
swapped once and then you swap again we

1416
01:13:16,579 --> 01:13:26,050
might as well put the Alpha allow the

1417
01:13:18,949 --> 01:13:26,050
alpha be right call this invert

1418
01:13:31,199 --> 01:13:41,159
we can trivially just not convert so if

1419
01:13:36,720 --> 01:13:53,670
I add that as a pixel up pixel up invert

1420
01:13:41,159 --> 01:13:58,289
go x8 then when we do this I can say oh

1421
01:13:53,670 --> 01:14:03,210
yeah first time pixel up invert second

1422
01:13:58,289 --> 01:14:05,489
time don't right now

1423
01:14:03,210 --> 01:14:07,079
these are upside-down or what the alphas

1424
01:14:05,489 --> 01:14:15,630
upside down if I run it now hopefully

1425
01:14:07,079 --> 01:14:17,850
the Alpha will be right side up and in

1426
01:14:15,630 --> 01:14:23,900
it is right so there that's actually

1427
01:14:17,850 --> 01:14:28,770
much nicer right uh so there you go

1428
01:14:23,899 --> 01:14:31,409
that's that's that change so if I now

1429
01:14:28,770 --> 01:14:32,940
have one of these little buffer doodads

1430
01:14:31,409 --> 01:14:35,069
in there you can see how that's kind of

1431
01:14:32,939 --> 01:14:36,779
just a little bit nicer and you can sort

1432
01:14:35,069 --> 01:14:41,509
of see how it actually also opens up the

1433
01:14:36,779 --> 01:14:41,509
door to having some other nice

1434
01:14:41,569 --> 01:14:50,219
opportunities here like things that

1435
01:14:44,310 --> 01:14:52,170
operate on regional data we can sort of

1436
01:14:50,220 --> 01:14:54,750
create utility functions now that

1437
01:14:52,170 --> 01:14:57,720
operate on those conveniently that saves

1438
01:14:54,750 --> 01:15:00,479
us some typing so that's all nice and

1439
01:14:57,720 --> 01:15:05,070
good and what I'd like to do is come on

1440
01:15:00,479 --> 01:15:07,319
in here to the asset system part that

1441
01:15:05,069 --> 01:15:09,389
we're talking about and I want to go

1442
01:15:07,319 --> 01:15:13,469
ahead and parse out this name into

1443
01:15:09,390 --> 01:15:16,650
pieces so I'm gonna have some different

1444
01:15:13,470 --> 01:15:18,090
pieces here that go along with sort of

1445
01:15:16,649 --> 01:15:22,079
the stuff that we know is in there at

1446
01:15:18,090 --> 01:15:24,690
the moment and what you can see is we've

1447
01:15:22,079 --> 01:15:27,630
sort of got underscores separating

1448
01:15:24,689 --> 01:15:30,419
different parts what I'm gonna do is

1449
01:15:27,630 --> 01:15:33,710
just say look what we have is up to

1450
01:15:30,420 --> 01:15:37,529
three of these

1451
01:15:33,710 --> 01:15:38,939
underscore separated pieces so I'm gonna

1452
01:15:37,529 --> 01:15:42,479
just call these

1453
01:15:38,939 --> 01:15:46,319
like pieces here and say that there's

1454
01:15:42,479 --> 01:15:49,139
three of them and the first three

1455
01:15:46,319 --> 01:15:51,090
underscore based pieces that we have I'm

1456
01:15:49,140 --> 01:15:55,170
going to separate out into those strings

1457
01:15:51,090 --> 01:15:59,029
for us to use later as token values

1458
01:15:55,170 --> 01:16:01,829
because we're gonna potentially want to

1459
01:15:59,029 --> 01:16:04,198
have a sort of pseudo parser it's not

1460
01:16:01,829 --> 01:16:06,180
really a parser in the strict sense of

1461
01:16:04,198 --> 01:16:09,299
the term because it only is doing very

1462
01:16:06,180 --> 01:16:12,300
basic matching but it is more or less a

1463
01:16:09,300 --> 01:16:14,159
parser trying to guess what the artist

1464
01:16:12,300 --> 01:16:16,440
was trying to tell us with the filename

1465
01:16:14,159 --> 01:16:19,289
so that we know how to interpret the

1466
01:16:16,439 --> 01:16:22,529
file that we get at the very least we

1467
01:16:19,289 --> 01:16:25,829
need to know obstacles item and cover

1468
01:16:22,529 --> 01:16:28,649
character and block need to be handled

1469
01:16:25,829 --> 01:16:31,529
specially what we do with the rest of

1470
01:16:28,649 --> 01:16:36,869
the information is kind of a different

1471
01:16:31,529 --> 01:16:38,909
story so you know that's yeah we'll see

1472
01:16:36,869 --> 01:16:40,769
what we want to do with that a little

1473
01:16:38,909 --> 01:16:44,399
bit later we also want to ignore

1474
01:16:40,770 --> 01:16:47,270
anything called template so blank

1475
01:16:44,399 --> 01:16:50,009
template needs to be not processed

1476
01:16:47,270 --> 01:16:52,460
because those are just there for our

1477
01:16:50,010 --> 01:16:57,300
reference they don't actually

1478
01:16:52,460 --> 01:17:00,300
participate in in the end like in the

1479
01:16:57,300 --> 01:17:02,690
final sort of finished product that we

1480
01:17:00,300 --> 01:17:05,100
ship to people so they shouldn't be

1481
01:17:02,689 --> 01:17:08,789
extracted by this reader they should be

1482
01:17:05,100 --> 01:17:10,260
ignored completely so when we scan

1483
01:17:08,789 --> 01:17:12,180
through here I'm gonna want to gather

1484
01:17:10,260 --> 01:17:16,409
those pieces so let's go ahead and do

1485
01:17:12,180 --> 01:17:18,300
that I'm gonna go ahead and and have an

1486
01:17:16,409 --> 01:17:23,639
anchor here if the anchor is gonna start

1487
01:17:18,300 --> 01:17:25,980
at the base name itself and then what

1488
01:17:23,640 --> 01:17:29,039
I'm gonna do is say alright we've got

1489
01:17:25,979 --> 01:17:33,689
the scan I'm coming through here I look

1490
01:17:29,039 --> 01:17:34,979
at the hash value I update that every

1491
01:17:33,689 --> 01:17:36,659
time through the loop with the new

1492
01:17:34,979 --> 01:17:39,509
character that I see and I'm gonna use

1493
01:17:36,659 --> 01:17:41,250
this hash value later on outside in the

1494
01:17:39,510 --> 01:17:43,949
meantime what I'm gonna do here is I'm

1495
01:17:41,250 --> 01:17:47,429
going to look to see if the scan value

1496
01:17:43,948 --> 01:17:49,139
happens to be an underscore if the scan

1497
01:17:47,429 --> 01:17:51,600
value does happen to be an underscore

1498
01:17:49,140 --> 01:17:54,079
I'm going to take a look to see about a

1499
01:17:51,600 --> 01:17:54,079
piece count

1500
01:17:54,958 --> 01:17:58,979
if the piece count is less than the

1501
01:17:57,328 --> 01:18:00,929
array count of pieces then I'm going to

1502
01:17:58,979 --> 01:18:04,619
consider this a piece and I'm going to

1503
01:18:00,929 --> 01:18:07,439
retire it so I want to do this in one of

1504
01:18:04,618 --> 01:18:10,198
two cases if there is an underscore then

1505
01:18:07,439 --> 01:18:13,199
I want to do it but also if there's

1506
01:18:10,198 --> 01:18:16,649
going to be a null I want to do it so if

1507
01:18:13,198 --> 01:18:18,328
star scan equals that or and in the one

1508
01:18:16,649 --> 01:18:22,259
way to write this perhaps a little bit

1509
01:18:18,328 --> 01:18:23,639
nicer is if this value is I'm looking at

1510
01:18:22,260 --> 01:18:27,389
right now the reason for that is then I

1511
01:18:23,639 --> 01:18:28,949
can look at this next value as well so

1512
01:18:27,389 --> 01:18:32,189
if the next value would have been a null

1513
01:18:28,948 --> 01:18:38,219
Terminator then I want to end as well

1514
01:18:32,189 --> 01:18:39,780
right in either case so looking at these

1515
01:18:38,219 --> 01:18:41,849
two we have the differentiate between

1516
01:18:39,779 --> 01:18:43,708
them eventually but for the moment we

1517
01:18:41,849 --> 01:18:48,208
can do the same code path on either one

1518
01:18:43,708 --> 01:18:50,998
so pieces piece count plus plus will get

1519
01:18:48,208 --> 01:18:55,559
retired here that's going to be the

1520
01:18:50,998 --> 01:18:58,170
string that I'm writing like that so

1521
01:18:55,559 --> 01:19:00,479
this string needs to get a count and it

1522
01:18:58,170 --> 01:19:04,229
needs to get data we know what the data

1523
01:19:00,479 --> 01:19:07,320
is the data is the anchor value right

1524
01:19:04,229 --> 01:19:09,570
that's this right here similarly as soon

1525
01:19:07,319 --> 01:19:11,458
as we're done with this the anchor value

1526
01:19:09,569 --> 01:19:13,438
can be equal to skin plus one because

1527
01:19:11,458 --> 01:19:15,599
that's where the next anchor would be

1528
01:19:13,439 --> 01:19:17,280
assuming that we continue it's only

1529
01:19:15,599 --> 01:19:18,569
really relevant in this case but we can

1530
01:19:17,279 --> 01:19:21,268
set it in either case and it's not a

1531
01:19:18,569 --> 01:19:24,988
problem so when we look at the piece

1532
01:19:21,269 --> 01:19:26,130
count here and we say what is the you

1533
01:19:24,988 --> 01:19:29,638
know what is the next one going to be

1534
01:19:26,130 --> 01:19:32,550
well the count is going to be everywhere

1535
01:19:29,639 --> 01:19:34,170
from where we're at now back all the way

1536
01:19:32,550 --> 01:19:37,800
to the anchor right so it's gonna be

1537
01:19:34,170 --> 01:19:40,139
scan - anchor however in the case where

1538
01:19:37,800 --> 01:19:42,719
we're actually looking at the null

1539
01:19:40,139 --> 01:19:45,118
Terminator here it actually needs to be

1540
01:19:42,719 --> 01:19:47,340
one further than that right because the

1541
01:19:45,118 --> 01:19:51,118
null Terminator happened actually on the

1542
01:19:47,340 --> 01:19:53,729
next one so in the case where I'm not

1543
01:19:51,118 --> 01:19:56,759
looking at an underscore I need to

1544
01:19:53,729 --> 01:19:59,849
advance my count to account for one more

1545
01:19:56,760 --> 01:20:03,630
so I need to basically say if this was

1546
01:19:59,849 --> 01:20:06,210
an underscore then I need one more

1547
01:20:03,630 --> 01:20:09,690
character otherwise everything's

1548
01:20:06,210 --> 01:20:11,760
we're so off I go that's all fine

1549
01:20:09,689 --> 01:20:13,769
that'll break it up into pieces and then

1550
01:20:11,760 --> 01:20:15,750
I also have the hash value at the end so

1551
01:20:13,770 --> 01:20:19,020
now I've got just like the chunks and

1552
01:20:15,750 --> 01:20:22,619
the hash and I'm ready to go so assuming

1553
01:20:19,020 --> 01:20:25,050
that I see this hash value here and I'm

1554
01:20:22,619 --> 01:20:27,180
ready to reload this what I then need to

1555
01:20:25,050 --> 01:20:30,659
do is I need to find out if I've already

1556
01:20:27,180 --> 01:20:34,469
got one of these or not so what I can do

1557
01:20:30,659 --> 01:20:36,439
there is I can just say for remember we

1558
01:20:34,469 --> 01:20:39,960
made this asset source file thing here

1559
01:20:36,439 --> 01:20:44,339
so for each source file that might match

1560
01:20:39,960 --> 01:20:46,230
the hash and I could just I might just

1561
01:20:44,340 --> 01:20:47,699
again keep changing the names here to

1562
01:20:46,229 --> 01:20:49,379
just say okay this is these are source

1563
01:20:47,699 --> 01:20:50,670
files it's not really about the fact

1564
01:20:49,380 --> 01:20:54,300
that they're watched they're just source

1565
01:20:50,670 --> 01:20:56,819
files so sorry for each source file that

1566
01:20:54,300 --> 01:21:00,449
the asset system is aware of off of this

1567
01:20:56,819 --> 01:21:05,509
hash value if that makes sense then I'm

1568
01:21:00,449 --> 01:21:05,510
just gonna loop through and check them

1569
01:21:08,510 --> 01:21:25,920
like so so what I want to do here is

1570
01:21:17,069 --> 01:21:26,579
match if I find one that matches and how

1571
01:21:25,920 --> 01:21:30,779
would I do that

1572
01:21:26,579 --> 01:21:33,329
well I have here a base name right and

1573
01:21:30,779 --> 01:21:35,969
that base name has to match the base

1574
01:21:33,329 --> 01:21:38,510
name that I was given so what I want to

1575
01:21:35,969 --> 01:21:42,510
do is say if you know strings are equal

1576
01:21:38,510 --> 01:21:45,949
if the base name that I have is going to

1577
01:21:42,510 --> 01:21:49,079
match the base name that I got from the

1578
01:21:45,949 --> 01:21:51,979
from the file system if those two things

1579
01:21:49,079 --> 01:21:55,859
are equal then these are the same file

1580
01:21:51,979 --> 01:21:59,729
now there is one sort of bizarre feature

1581
01:21:55,859 --> 01:22:01,439
that we might want to consider here and

1582
01:21:59,729 --> 01:22:06,539
it's difficult to say whether we want to

1583
01:22:01,439 --> 01:22:09,299
or not on a linux like machine you would

1584
01:22:06,539 --> 01:22:12,238
have files be treated the same if they

1585
01:22:09,300 --> 01:22:15,329
have the exact same file name but no

1586
01:22:12,238 --> 01:22:17,519
other time on a Windows like machine

1587
01:22:15,329 --> 01:22:19,689
files are considered the same file name

1588
01:22:17,520 --> 01:22:24,730
if the lowercase

1589
01:22:19,689 --> 01:22:26,919
version of the file name matches the

1590
01:22:24,729 --> 01:22:29,349
lowercase version of the other like if

1591
01:22:26,920 --> 01:22:33,010
they would be the same if converted to

1592
01:22:29,350 --> 01:22:34,810
lowercase right so capitalization is not

1593
01:22:33,010 --> 01:22:38,409
relevant to the matching in a

1594
01:22:34,810 --> 01:22:40,840
windows-based file name it's kind of

1595
01:22:38,409 --> 01:22:43,750
busted best just how it is how do I want

1596
01:22:40,840 --> 01:22:47,170
to deal with that well I don't want the

1597
01:22:43,750 --> 01:22:49,180
game to think about that because the

1598
01:22:47,170 --> 01:22:50,739
game would then have to understand what

1599
01:22:49,180 --> 01:22:53,530
platform it was running on to a greater

1600
01:22:50,738 --> 01:22:57,218
extent than I feel is necessary so what

1601
01:22:53,529 --> 01:23:02,469
I'm gonna claim instead what I'm gonna

1602
01:22:57,219 --> 01:23:04,420
claim instead is that what we will do is

1603
01:23:02,469 --> 01:23:11,230
we will force the operating system layer

1604
01:23:04,420 --> 01:23:14,199
to prepare that for us basically so down

1605
01:23:11,229 --> 01:23:15,789
there on win32 handmade when it's

1606
01:23:14,198 --> 01:23:20,529
actually doing like so here we've got

1607
01:23:15,789 --> 01:23:22,000
our situation with with win32 get all

1608
01:23:20,529 --> 01:23:24,309
files of type again and so on right

1609
01:23:22,000 --> 01:23:27,340
we're coming through here we get all

1610
01:23:24,310 --> 01:23:30,310
these things and then we do wild card

1611
01:23:27,340 --> 01:23:32,529
and multi-byte right here and we produce

1612
01:23:30,310 --> 01:23:34,360
the base name and that's the thing that

1613
01:23:32,529 --> 01:23:37,899
we pay back to the app and blah blah

1614
01:23:34,359 --> 01:23:39,759
blah well right there we are now in a

1615
01:23:37,899 --> 01:23:46,659
perfect position to lowercase eyes this

1616
01:23:39,760 --> 01:23:51,579
name right now I don't know if we have a

1617
01:23:46,659 --> 01:23:55,029
lowercase or we don't it's a little

1618
01:23:51,579 --> 01:23:58,029
right one but right here that's one

1619
01:23:55,029 --> 01:24:00,359
thing that we can do so I'm gonna go

1620
01:23:58,029 --> 01:24:00,359
through

1621
01:24:04,500 --> 01:24:13,770
and make each one of these lowercase now

1622
01:24:10,510 --> 01:24:18,640
the problem with this is that it's not

1623
01:24:13,770 --> 01:24:32,400
quite right if you use Unicode so I'm

1624
01:24:18,640 --> 01:24:32,400
gonna I don't know if wipe

1625
01:24:33,510 --> 01:24:40,440
let me check to make sure wide care

1626
01:24:36,210 --> 01:24:43,420
doesn't do that I don't think it can I

1627
01:24:40,439 --> 01:24:45,750
don't think it the OS can do that for us

1628
01:24:43,420 --> 01:24:45,750
unfortunately

1629
01:24:59,109 --> 01:25:02,438
it is

1630
01:25:17,039 --> 01:25:20,189
[Applause]

1631
01:25:24,029 --> 01:25:28,439
and this is notice as useful

1632
01:25:42,988 --> 01:25:50,998
I just wanted to check to see if they

1633
01:25:44,550 --> 01:25:56,998
had one I'll skip it for now

1634
01:25:50,998 --> 01:26:00,569
um so I'm not a language expert so I

1635
01:25:56,998 --> 01:26:03,569
have no idea but if you convert

1636
01:26:00,569 --> 01:26:06,058
something to utf-8 it's safe to convert

1637
01:26:03,569 --> 01:26:08,340
it to lowercase and it will do an ASCII

1638
01:26:06,059 --> 01:26:10,980
based lowercase because anything that

1639
01:26:08,340 --> 01:26:16,498
was extended will have the high bit set

1640
01:26:10,979 --> 01:26:18,388
so you won't accidentally lowercase a

1641
01:26:16,498 --> 01:26:22,010
value that shouldn't have been a lower

1642
01:26:18,389 --> 01:26:26,159
cased right you won't corrupt the string

1643
01:26:22,010 --> 01:26:29,639
however what I don't know is to what

1644
01:26:26,158 --> 01:26:32,429
extent lower casing needs to be Unicode

1645
01:26:29,639 --> 01:26:38,819
aware so if you actually want to produce

1646
01:26:32,429 --> 01:26:41,279
the lowercase version of a Unicode

1647
01:26:38,819 --> 01:26:46,698
string that would have to include lower

1648
01:26:41,279 --> 01:26:53,009
casing four characters above the base

1649
01:26:46,698 --> 01:26:54,928
127 character set right and so we're not

1650
01:26:53,010 --> 01:26:57,780
doing that so we're not technically

1651
01:26:54,929 --> 01:26:59,460
doing the full Unicode lowercase I don't

1652
01:26:57,779 --> 01:27:02,309
care because our artists are never going

1653
01:26:59,460 --> 01:27:03,809
to produce anything like that and it's

1654
01:27:02,309 --> 01:27:06,119
not a particularly bad bug even if we

1655
01:27:03,809 --> 01:27:07,920
did it just means if they use two

1656
01:27:06,118 --> 01:27:11,729
different cases the files would maybe I

1657
01:27:07,920 --> 01:27:15,840
don't even know it's it's not a

1658
01:27:11,729 --> 01:27:18,118
particularly bad bug either way but it

1659
01:27:15,840 --> 01:27:19,440
would create issues with our asset

1660
01:27:18,118 --> 01:27:23,248
system until they went in and actually

1661
01:27:19,439 --> 01:27:26,158
deleted one of the two files right or

1662
01:27:23,248 --> 01:27:29,010
restored the case to the correct case so

1663
01:27:26,158 --> 01:27:32,460
Darius that it's worth noting so if you

1664
01:27:29,010 --> 01:27:36,239
actually want a good eunuch good Unicode

1665
01:27:32,460 --> 01:27:38,010
lower case you can't assume that the

1666
01:27:36,238 --> 01:27:39,899
characters are only ANSI because you may

1667
01:27:38,010 --> 01:27:41,880
have extended ones that are multibyte

1668
01:27:39,899 --> 01:27:45,929
long that's just the nature of the beast

1669
01:27:41,880 --> 01:27:51,739
right however if you just want to do a

1670
01:27:45,929 --> 01:27:51,739
basic one it's actually pretty simple

1671
01:27:52,789 --> 01:27:57,800
all you have to do is say if the

1672
01:27:56,180 --> 01:28:03,230
character that you're talking about is

1673
01:27:57,800 --> 01:28:05,510
greater than equal to capital a and it's

1674
01:28:03,229 --> 01:28:09,849
less than or equal to capital Z then you

1675
01:28:05,510 --> 01:28:12,949
know that's inside the range of

1676
01:28:09,850 --> 01:28:15,260
characters right and this works because

1677
01:28:12,949 --> 01:28:18,949
you know fortunately people who designed

1678
01:28:15,260 --> 01:28:21,020
ASCII how to clue if you go look at what

1679
01:28:18,949 --> 01:28:24,289
an ASCII table looks like what you can

1680
01:28:21,020 --> 01:28:27,320
see is that all of the you know capital

1681
01:28:24,289 --> 01:28:29,210
letters can occur contiguously and all

1682
01:28:27,319 --> 01:28:30,049
of the lowercase letters occur

1683
01:28:29,210 --> 01:28:33,920
contiguously

1684
01:28:30,050 --> 01:28:36,020
so all we have to do once we look for a

1685
01:28:33,920 --> 01:28:39,529
range check and see that it's in between

1686
01:28:36,020 --> 01:28:42,080
these is we just have to apply the

1687
01:28:39,529 --> 01:28:46,340
offset so all we have to do is then say

1688
01:28:42,079 --> 01:28:50,050
okay just add however much it takes to

1689
01:28:46,340 --> 01:28:54,409
change a capital into a lowercase right

1690
01:28:50,050 --> 01:28:57,020
so I want to change capital A into a

1691
01:28:54,409 --> 01:28:59,359
lowercase a however much that distance

1692
01:28:57,020 --> 01:29:01,070
is just adding that will automatically

1693
01:28:59,359 --> 01:29:04,369
lowercase it because no matter where you

1694
01:29:01,069 --> 01:29:07,119
are in the table that same stride will

1695
01:29:04,369 --> 01:29:11,390
get you to the right lowercase value

1696
01:29:07,119 --> 01:29:15,500
right so you can kind you can see it

1697
01:29:11,390 --> 01:29:18,710
even in the numbers 41 maps to 61 42

1698
01:29:15,500 --> 01:29:20,659
maps to 62 in hex right so you can see

1699
01:29:18,710 --> 01:29:22,789
that you're just twiddling some bits at

1700
01:29:20,659 --> 01:29:26,779
the high end and you've changed it from

1701
01:29:22,789 --> 01:29:28,399
uppercase to lowercase right and and

1702
01:29:26,779 --> 01:29:29,869
again that's because the people who

1703
01:29:28,399 --> 01:29:32,449
design ASCII they knew what they were

1704
01:29:29,869 --> 01:29:39,380
doing they made it nice and easy to use

1705
01:29:32,449 --> 01:29:42,019
in that way okay

1706
01:29:39,380 --> 01:29:44,300
so this will lowercase those file names

1707
01:29:42,020 --> 01:29:48,410
that we don't actually care and then

1708
01:29:44,300 --> 01:29:51,680
when we string match we're fine right if

1709
01:29:48,409 --> 01:29:54,319
we find that we actually have a match we

1710
01:29:51,680 --> 01:29:56,210
can stop and we now know that this file

1711
01:29:54,319 --> 01:29:59,299
is a file we were already aware of on

1712
01:29:56,210 --> 01:30:02,029
the way out if we don't know about this

1713
01:29:59,300 --> 01:30:04,279
file so we didn't find a match then what

1714
01:30:02,029 --> 01:30:07,309
we need to do is actually create one of

1715
01:30:04,279 --> 01:30:10,729
them and we need to initialize it into a

1716
01:30:07,310 --> 01:30:12,710
state where it appears to be completely

1717
01:30:10,729 --> 01:30:14,569
not to not have not had any data in it

1718
01:30:12,710 --> 01:30:17,359
because we're going to want to then load

1719
01:30:14,569 --> 01:30:19,279
the file and actually process it so that

1720
01:30:17,359 --> 01:30:22,579
turns out to be pretty easy right so

1721
01:30:19,279 --> 01:30:25,340
anyway if we push a struct here where we

1722
01:30:22,579 --> 01:30:27,050
have an asset source file a new one what

1723
01:30:25,340 --> 01:30:29,329
we can do here and and we're gonna this

1724
01:30:27,050 --> 01:30:31,880
will clear it as well what we can do

1725
01:30:29,329 --> 01:30:39,850
here is then put the copy of the string

1726
01:30:31,880 --> 01:30:39,850
on why don't you just a push copy

1727
01:30:40,229 --> 01:30:43,659
[Music]

1728
01:30:41,770 --> 01:30:47,290
actually I guess I can do a pushing I'll

1729
01:30:43,659 --> 01:30:49,809
terminate well actually what what's my

1730
01:30:47,289 --> 01:30:51,939
easiest thing to do here for copying

1731
01:30:49,810 --> 01:31:05,770
this string I know we had a couple

1732
01:30:51,939 --> 01:31:07,119
different ones here there it is so I'm

1733
01:31:05,770 --> 01:31:08,440
just gonna do a push string here it's a

1734
01:31:07,119 --> 01:31:10,329
little inefficient because technically I

1735
01:31:08,439 --> 01:31:11,589
should just save the scan value because

1736
01:31:10,329 --> 01:31:13,390
then I know how long it is and I can

1737
01:31:11,590 --> 01:31:14,710
just do it in one go but I'm not going

1738
01:31:13,390 --> 01:31:16,750
to because it's not really going to

1739
01:31:14,710 --> 01:31:18,760
matter at all

1740
01:31:16,750 --> 01:31:20,710
so anyway pushing in the source here I'm

1741
01:31:18,760 --> 01:31:24,520
just gonna say okay there's my base name

1742
01:31:20,710 --> 01:31:26,590
I'm gonna push this string on and so I

1743
01:31:24,520 --> 01:31:32,170
just need my memory Rini here now we've

1744
01:31:26,590 --> 01:31:34,900
got a bunch of stuff pointed to here

1745
01:31:32,170 --> 01:31:39,730
this is the non restored memory and then

1746
01:31:34,899 --> 01:31:42,759
we've got I guess so when you reset the

1747
01:31:39,729 --> 01:31:46,238
game it's non restored memory because we

1748
01:31:42,760 --> 01:31:47,260
don't yeah so this is the non restored

1749
01:31:46,238 --> 01:31:48,609
memory Reena and that's where we

1750
01:31:47,260 --> 01:31:50,409
actually want this because we don't want

1751
01:31:48,609 --> 01:31:51,909
this tracked across like loop code

1752
01:31:50,409 --> 01:31:53,849
editing because this is for assets which

1753
01:31:51,909 --> 01:31:59,559
are not don't participate in that stuff

1754
01:31:53,850 --> 01:32:02,469
so here we could just say all right give

1755
01:31:59,560 --> 01:32:04,840
us a new one of these now it's there we

1756
01:32:02,469 --> 01:32:08,199
leave the file date at zero because we

1757
01:32:04,840 --> 01:32:11,170
now want them to not match so by now we

1758
01:32:08,199 --> 01:32:14,590
have to assert that we do have a match

1759
01:32:11,170 --> 01:32:20,850
and we now want to say has it changed so

1760
01:32:14,590 --> 01:32:26,409
if the match file date is not equal to

1761
01:32:20,850 --> 01:32:30,520
the current file date then what we want

1762
01:32:26,409 --> 01:32:34,359
to do is update this file and remember

1763
01:32:30,520 --> 01:32:38,469
that fact right that's what we're trying

1764
01:32:34,359 --> 01:32:44,889
to do here so in addition to and this is

1765
01:32:38,469 --> 01:32:46,600
like a to-do update the actual assets

1766
01:32:44,890 --> 01:32:49,060
that's the part that we now want to

1767
01:32:46,600 --> 01:32:50,560
write so the other thing we have to do

1768
01:32:49,060 --> 01:32:52,330
here is actually store it into the hash

1769
01:32:50,560 --> 01:32:55,630
show the source file hash at the hash

1770
01:32:52,329 --> 01:32:59,469
value right that thing is gonna

1771
01:32:55,630 --> 01:33:02,050
to the end like so and then the source

1772
01:32:59,469 --> 01:33:03,460
file hash itself is going to point to

1773
01:33:02,050 --> 01:33:05,560
this as our first one but that's it

1774
01:33:03,460 --> 01:33:08,100
right so it's pretty simple that builds

1775
01:33:05,560 --> 01:33:11,590
up the entire hash so now we just know

1776
01:33:08,100 --> 01:33:14,650
what we've got and this now tracks

1777
01:33:11,590 --> 01:33:19,630
everything right that's all we needed to

1778
01:33:14,649 --> 01:33:22,509
basically have a change processor now

1779
01:33:19,630 --> 01:33:24,190
the more complicated part is to actually

1780
01:33:22,510 --> 01:33:28,179
go through and process the individual

1781
01:33:24,189 --> 01:33:29,169
assets that are part of file right and

1782
01:33:28,179 --> 01:33:34,119
we've got a couple different things that

1783
01:33:29,170 --> 01:33:37,569
we're gonna have to do there and yeah I

1784
01:33:34,119 --> 01:33:49,329
want to kind of go through those more

1785
01:33:37,569 --> 01:33:52,389
specifically so not sure exactly I want

1786
01:33:49,329 --> 01:33:53,859
to structure this suffice to say this

1787
01:33:52,389 --> 01:33:57,639
call right here is the call that

1788
01:33:53,859 --> 01:34:02,439
actually needs to do the processing so

1789
01:33:57,639 --> 01:34:10,029
here we have a update you know asset

1790
01:34:02,439 --> 01:34:16,269
package from PNG we're gonna pass that

1791
01:34:10,029 --> 01:34:17,469
file info actually I you know I probably

1792
01:34:16,270 --> 01:34:19,480
won't quite do that so what I'll

1793
01:34:17,469 --> 01:34:23,350
probably do here is load the file and

1794
01:34:19,479 --> 01:34:26,079
then call this with the file data so

1795
01:34:23,350 --> 01:34:30,400
what I probably do here is push a

1796
01:34:26,079 --> 01:34:34,929
temporary on and then rescind that

1797
01:34:30,399 --> 01:34:38,049
temporary right so I'm gonna want to

1798
01:34:34,929 --> 01:34:43,869
load in a block trying to think of what

1799
01:34:38,050 --> 01:34:46,060
I want there but the long and short of

1800
01:34:43,869 --> 01:34:49,119
it is I'm going to call this stuff so

1801
01:34:46,060 --> 01:34:56,670
when we actually go to load a file here

1802
01:34:49,119 --> 01:34:56,670
I want to call this

1803
01:34:59,329 --> 01:35:05,970
to load it in so I have a platform file

1804
01:35:03,600 --> 01:35:22,620
handle so what I need to do here is I

1805
01:35:05,970 --> 01:35:26,280
need to open it like so and this would

1806
01:35:22,619 --> 01:35:28,199
be platform this is open file so that

1807
01:35:26,279 --> 01:35:36,300
will open the file then I would do a

1808
01:35:28,199 --> 01:35:39,329
platform close file like so and I would

1809
01:35:36,300 --> 01:35:43,260
just issue one read here platform read

1810
01:35:39,329 --> 01:35:50,550
data from file and that'd just passed

1811
01:35:43,260 --> 01:35:51,750
the handle offset size test and we know

1812
01:35:50,550 --> 01:35:54,680
that we're reading the entire thing so

1813
01:35:51,750 --> 01:36:01,949
it's really just the file info file size

1814
01:35:54,680 --> 01:36:04,590
and this destination here is gonna be a

1815
01:36:01,949 --> 01:36:09,989
buffer that is however big the file size

1816
01:36:04,590 --> 01:36:14,060
was so we just need a temporary we need

1817
01:36:09,989 --> 01:36:14,059
to push a temporary on and then we can

1818
01:36:17,180 --> 01:36:21,480
after we load it into that temporary

1819
01:36:19,439 --> 01:36:27,299
storage then we can just get rid of that

1820
01:36:21,479 --> 01:36:31,259
right so this is our file buffer that

1821
01:36:27,300 --> 01:36:32,489
file buffer will then be passed here and

1822
01:36:31,260 --> 01:36:34,470
the other thing that I would mention is

1823
01:36:32,489 --> 01:36:37,800
this gives us yet another place we can

1824
01:36:34,470 --> 01:36:39,659
actually use this system like I said

1825
01:36:37,800 --> 01:36:42,630
having one of these comes in handy

1826
01:36:39,659 --> 01:36:44,989
pretty frequently so I can just say like

1827
01:36:42,630 --> 01:36:44,989
alright

1828
01:36:53,689 --> 01:37:00,569
got to get to memory from somewhere but

1829
01:36:56,819 --> 01:37:03,539
otherwise once we figure out where we

1830
01:37:00,569 --> 01:37:05,909
want to store that that's all we have to

1831
01:37:03,539 --> 01:37:08,219
do then we pass that file buffer to

1832
01:37:05,909 --> 01:37:11,340
update asset package from ping and what

1833
01:37:08,219 --> 01:37:15,329
we want to send that is the match that

1834
01:37:11,340 --> 01:37:18,150
we used the asset system obviously and

1835
01:37:15,329 --> 01:37:22,260
we're going to let that function take it

1836
01:37:18,149 --> 01:37:24,599
from there I this update here tells us

1837
01:37:22,260 --> 01:37:27,060
what the file date change was I don't

1838
01:37:24,600 --> 01:37:34,590
know whether we want to do that before

1839
01:37:27,060 --> 01:37:44,760
or after you know do we want to do this

1840
01:37:34,590 --> 01:37:46,170
before or after I'm not sure you know I

1841
01:37:44,760 --> 01:37:51,119
think I do want that on the same line so

1842
01:37:46,170 --> 01:37:53,300
it doesn't get separated so I'm not 100%

1843
01:37:51,119 --> 01:37:57,000
sure what I want to do there but

1844
01:37:53,300 --> 01:37:59,219
something like that and then once the

1845
01:37:57,000 --> 01:38:01,409
update once the package is updated I

1846
01:37:59,219 --> 01:38:04,189
also kind of want to record the fact

1847
01:38:01,409 --> 01:38:04,189
that it's dirty

1848
01:38:04,909 --> 01:38:11,399
because I think we're probably going to

1849
01:38:06,960 --> 01:38:14,640
want to do here is have a like made

1850
01:38:11,399 --> 01:38:17,009
changes thing and in here I guess I

1851
01:38:14,640 --> 01:38:21,000
would say this thing maybe returns

1852
01:38:17,010 --> 01:38:24,289
whether it made changes and in the case

1853
01:38:21,000 --> 01:38:24,289
that we made changes

1854
01:38:30,319 --> 01:38:37,979
we probably need there to then update

1855
01:38:33,899 --> 01:38:39,569
like some kind of asset information file

1856
01:38:37,979 --> 01:38:42,779
that we have and what that asset

1857
01:38:39,569 --> 01:38:45,558
information file is going to be is just

1858
01:38:42,779 --> 01:38:49,559
something that sits there telling us

1859
01:38:45,559 --> 01:38:54,000
what the source files are what their

1860
01:38:49,559 --> 01:38:55,590
dates were so that when and and that

1861
01:38:54,000 --> 01:38:59,099
information about what assets went with

1862
01:38:55,590 --> 01:39:02,130
them so that when we close the game and

1863
01:38:59,099 --> 01:39:03,840
reload the game back in it will know

1864
01:39:02,130 --> 01:39:17,760
that information right

1865
01:39:03,840 --> 01:39:20,909
I think that's it yeah so I think that's

1866
01:39:17,760 --> 01:39:23,369
everything that we need there in our

1867
01:39:20,908 --> 01:39:28,710
shared directory so it's not a string

1868
01:39:23,368 --> 01:39:30,569
it's a buffer like so and I you know

1869
01:39:28,710 --> 01:39:32,158
what I could do I can also make it so

1870
01:39:30,569 --> 01:39:36,920
that buffer and string are the same

1871
01:39:32,158 --> 01:39:36,920
thing like we can do this as well

1872
01:39:40,039 --> 01:39:44,550
because sometimes I'd like to be able to

1873
01:39:42,479 --> 01:39:46,198
say string because it's just a note to

1874
01:39:44,550 --> 01:39:51,020
myself what's going on even though those

1875
01:39:46,198 --> 01:39:54,019
two things are exactly the same anyway

1876
01:39:51,020 --> 01:39:54,020
so

1877
01:40:02,929 --> 01:40:26,219
Jimmy I think that's just about

1878
01:40:10,859 --> 01:40:29,789
everything so I think the only problem

1879
01:40:26,219 --> 01:40:32,599
is now getting that actual data out let

1880
01:40:29,789 --> 01:40:32,599
me make sure that's true

1881
01:40:41,810 --> 01:40:56,449
all right uh so then we just have the

1882
01:40:48,029 --> 01:40:56,448
actual update happen here oops that

1883
01:41:00,560 --> 01:41:04,770
needs to take the assets it needs to

1884
01:41:03,569 --> 01:41:13,469
take the source file

1885
01:41:04,770 --> 01:41:19,790
oops source a source file in the

1886
01:41:13,469 --> 01:41:27,599
contents then when we look at the PNG

1887
01:41:19,789 --> 01:41:33,840
reader here when that takes the Parsis

1888
01:41:27,599 --> 01:41:39,090
PNG bit here like so that's going to

1889
01:41:33,840 --> 01:41:40,440
take one of these file streams and again

1890
01:41:39,090 --> 01:41:46,170
that's something that we can pretty

1891
01:41:40,439 --> 01:41:48,000
easily that's something that we can

1892
01:41:46,170 --> 01:41:49,529
generate trivially from one of these

1893
01:41:48,000 --> 01:41:51,590
little buffers so you should be good to

1894
01:41:49,529 --> 01:41:51,590
go

1895
01:42:03,569 --> 01:42:11,189
so I think that's just about everything

1896
01:42:05,789 --> 01:42:14,550
we need for the change management and so

1897
01:42:11,189 --> 01:42:17,388
the one thing we don't know is how we

1898
01:42:14,550 --> 01:42:24,139
want to deal with that temporary there

1899
01:42:17,389 --> 01:42:33,810
so we have obviously in the in the game

1900
01:42:24,139 --> 01:42:40,560
proper we have the notion here oops it's

1901
01:42:33,810 --> 01:42:43,800
not the file I wanted inside the game

1902
01:42:40,560 --> 01:42:49,289
state we have you know various arenas

1903
01:42:43,800 --> 01:42:50,849
that store stuff and so I'm not sure

1904
01:42:49,289 --> 01:42:52,649
what we want to do for the temporary

1905
01:42:50,849 --> 01:42:54,449
memory here I kind of feel like we

1906
01:42:52,649 --> 01:42:59,039
probably just want to allocate and

1907
01:42:54,448 --> 01:43:00,988
deallocate it directly from the platform

1908
01:42:59,039 --> 01:43:03,389
because there's no reason not to its

1909
01:43:00,988 --> 01:43:10,408
development only so I feel like we

1910
01:43:03,389 --> 01:43:17,099
almost want to just do that by just

1911
01:43:10,408 --> 01:43:21,049
doing a platform allocate memory and

1912
01:43:17,099 --> 01:43:21,050
then a platform do allocate memory

1913
01:43:27,500 --> 01:43:31,159
and that should be fine

1914
01:43:40,100 --> 01:43:46,890
so there's memory block that's our tenth

1915
01:43:43,949 --> 01:43:54,659
lock allocate memory takes the size and

1916
01:43:46,890 --> 01:44:04,410
the flags we don't care about that so

1917
01:43:54,659 --> 01:44:05,659
the size is just that and that's it so I

1918
01:44:04,409 --> 01:44:09,479
think that's all we need

1919
01:44:05,659 --> 01:44:14,099
pretty sure anyway and I think that just

1920
01:44:09,479 --> 01:44:18,149
does everything we want so the next step

1921
01:44:14,100 --> 01:44:21,360
is to go in here right into update asset

1922
01:44:18,149 --> 01:44:24,089
package from PNG and loop through all of

1923
01:44:21,359 --> 01:44:25,739
those tiles so this is going to be like

1924
01:44:24,090 --> 01:44:33,720
a for loop right it's going to first

1925
01:44:25,739 --> 01:44:40,590
call handmade PNG you know in here you

1926
01:44:33,720 --> 01:44:42,630
know what now I think about it we

1927
01:44:40,590 --> 01:44:44,430
actually can do this this this isn't

1928
01:44:42,630 --> 01:44:47,369
this is not necessary yeah I think about

1929
01:44:44,430 --> 01:44:50,310
it this is not necessary at all we can

1930
01:44:47,369 --> 01:44:53,880
actually just have this be a temporary

1931
01:44:50,310 --> 01:45:00,660
arena right so basically everything that

1932
01:44:53,880 --> 01:45:02,690
it does in here can just be done like

1933
01:45:00,659 --> 01:45:02,689
this

1934
01:45:06,529 --> 01:45:22,769
right because that'll just automatically

1935
01:45:20,250 --> 01:45:25,140
do it and then when we come up here and

1936
01:45:22,770 --> 01:45:27,900
we need to push a memory arena in here

1937
01:45:25,140 --> 01:45:32,880
we can also just say we can say what the

1938
01:45:27,899 --> 01:45:34,139
memory arena is that gets used for

1939
01:45:32,880 --> 01:45:36,060
everything for all the temporary

1940
01:45:34,140 --> 01:45:38,460
processing and that gets nicely cleaned

1941
01:45:36,060 --> 01:45:43,250
up everything works just fine

1942
01:45:38,460 --> 01:45:43,250
trivial no code everyone's happy

1943
01:45:43,350 --> 01:45:49,710
so really what we need is just the file

1944
01:45:45,239 --> 01:45:52,649
stream here the info bits here is for

1945
01:45:49,710 --> 01:45:53,220
the error so but I'm not gonna do that

1946
01:45:52,649 --> 01:45:55,710
right now

1947
01:45:53,220 --> 01:45:56,610
that'll be tomorrow's job but that's how

1948
01:45:55,710 --> 01:46:01,020
that's gonna work

1949
01:45:56,609 --> 01:46:02,729
and so we would just pass that temporary

1950
01:46:01,020 --> 01:46:04,170
nough in and then I think we're good to

1951
01:46:02,729 --> 01:46:07,859
go so I think that's the whole

1952
01:46:04,170 --> 01:46:09,449
superstructure for it right now that

1953
01:46:07,859 --> 01:46:11,819
pretty much does everything we want in

1954
01:46:09,449 --> 01:46:14,010
here we'll have the four I loop that

1955
01:46:11,819 --> 01:46:15,719
will loop over each of the tiles we'll

1956
01:46:14,010 --> 01:46:18,360
look to see if there's any data in that

1957
01:46:15,720 --> 01:46:20,640
tile if there is any data in the tile we

1958
01:46:18,359 --> 01:46:23,489
will record it as a new asset if the

1959
01:46:20,640 --> 01:46:29,630
data doesn't match the asset that's in

1960
01:46:23,489 --> 01:46:29,630
there currently I think that's it

1961
01:46:33,538 --> 01:46:39,618
all right let's Q&amp;A

1962
01:47:18,479 --> 01:47:30,338
thoughts on the use of persistent memory

1963
01:47:20,889 --> 01:47:35,199
eg in to obtain in game programming so I

1964
01:47:30,338 --> 01:47:39,179
guess what I would say is I don't have a

1965
01:47:35,198 --> 01:47:41,228
lot of thoughts on it because it's not

1966
01:47:39,179 --> 01:47:44,469
really different from what you already

1967
01:47:41,229 --> 01:47:48,429
have to deal with so it should slot into

1968
01:47:44,469 --> 01:47:50,229
your system pretty routinely without a

1969
01:47:48,429 --> 01:47:52,269
lot of effort the reason I say that is

1970
01:47:50,229 --> 01:47:59,439
because game developers are already used

1971
01:47:52,269 --> 01:48:02,649
to nonsense like there's a server and

1972
01:47:59,439 --> 01:48:05,469
the server sends you no data to the

1973
01:48:02,649 --> 01:48:07,899
client where it has to write it to a

1974
01:48:05,469 --> 01:48:10,300
harddrive cache where it has to move it

1975
01:48:07,899 --> 01:48:13,659
into memory where it has to move it into

1976
01:48:10,300 --> 01:48:16,088
texture memory right and you're used to

1977
01:48:13,658 --> 01:48:19,088
all of these like different levels of

1978
01:48:16,088 --> 01:48:21,878
locality it's just something that game

1979
01:48:19,088 --> 01:48:23,349
developers have to live with you know

1980
01:48:21,878 --> 01:48:25,719
that other developers too often don't

1981
01:48:23,349 --> 01:48:27,878
think about but game developers have to

1982
01:48:25,719 --> 01:48:29,229
constantly think about making sure

1983
01:48:27,878 --> 01:48:32,378
things are in the right place the right

1984
01:48:29,229 --> 01:48:34,088
time so if you want to slot another

1985
01:48:32,378 --> 01:48:36,849
thing in there that's like a different

1986
01:48:34,088 --> 01:48:38,318
level of cache along the way it usually

1987
01:48:36,849 --> 01:48:40,748
doesn't really change the design of your

1988
01:48:38,319 --> 01:48:44,019
system a whole heck of a lot it's just

1989
01:48:40,748 --> 01:48:47,349
adding some other cache that has a

1990
01:48:44,019 --> 01:48:53,679
little bit faster speed and a little bit

1991
01:48:47,349 --> 01:48:55,418
smaller size right Martens are you sure

1992
01:48:53,679 --> 01:48:57,189
always lowering finite file name to

1993
01:48:55,418 --> 01:48:58,748
lowercase is a good solution because

1994
01:48:57,189 --> 01:49:01,269
case sensitivity is a feature of the

1995
01:48:58,748 --> 01:49:03,158
file system not the whole OS on NTFS you

1996
01:49:01,269 --> 01:49:05,739
can enable case sensitivity individually

1997
01:49:03,158 --> 01:49:08,648
per folder you can mount NTFS disk on

1998
01:49:05,738 --> 01:49:10,478
Linux Mac and on Apple HFS+ or a FPS can

1999
01:49:08,649 --> 01:49:13,989
be both case incitive case insensitive

2000
01:49:10,479 --> 01:49:16,389
depends on how you format it yet I know

2001
01:49:13,988 --> 01:49:18,338
I mean like I said I'm not sure I'm also

2002
01:49:16,389 --> 01:49:20,529
just not sure there is a good solution I

2003
01:49:18,338 --> 01:49:22,179
don't know what the right solution is

2004
01:49:20,529 --> 01:49:24,969
for this case because the file name

2005
01:49:22,179 --> 01:49:27,550
actually means something so you're just

2006
01:49:24,969 --> 01:49:29,559
not really allowed to save to files that

2007
01:49:27,550 --> 01:49:31,000
have the same file name and just

2008
01:49:29,559 --> 01:49:34,119
different case and expect

2009
01:49:31,000 --> 01:49:36,520
to the game to care about that right one

2010
01:49:34,119 --> 01:49:38,109
is gonna have to overwrite the other so

2011
01:49:36,520 --> 01:49:40,630
I think what I want is to just always

2012
01:49:38,109 --> 01:49:44,829
flatten it down I think I may want it to

2013
01:49:40,630 --> 01:49:47,770
flatten always period meaning the OS

2014
01:49:44,829 --> 01:49:50,729
layer even on a case where it does

2015
01:49:47,770 --> 01:49:55,030
differentiate by case still shouldn't

2016
01:49:50,729 --> 01:49:57,419
because we we can only pick one if that

2017
01:49:55,029 --> 01:49:57,420
makes sense

2018
01:49:59,310 --> 01:50:03,310
long billion I can't remember are the

2019
01:50:01,569 --> 01:50:05,259
bitmap assets stored next to the audio

2020
01:50:03,310 --> 01:50:06,640
and font cliff assets in memory this may

2021
01:50:05,260 --> 01:50:09,070
be relevant if those are not the same

2022
01:50:06,640 --> 01:50:11,619
size as the bitmaps it's not really

2023
01:50:09,069 --> 01:50:13,090
relevant no the reason for that is if a

2024
01:50:11,619 --> 01:50:14,979
bitmap is always replacing another

2025
01:50:13,090 --> 01:50:16,539
bitmap you don't care where it is you

2026
01:50:14,979 --> 01:50:20,709
just care that the size was that big

2027
01:50:16,539 --> 01:50:22,899
right so all we really care about is

2028
01:50:20,710 --> 01:50:25,359
that the hot loadable assets slot into a

2029
01:50:22,899 --> 01:50:27,250
particular size type because that allows

2030
01:50:25,359 --> 01:50:30,369
us to overwrite the old version without

2031
01:50:27,250 --> 01:50:31,989
having to do a lot of memory without

2032
01:50:30,369 --> 01:50:34,869
having to do analysis of a free store

2033
01:50:31,989 --> 01:50:36,550
which is not the end of the world anyway

2034
01:50:34,869 --> 01:50:37,989
like we could just do that it's just

2035
01:50:36,550 --> 01:50:39,579
it's a waste of time if you don't

2036
01:50:37,989 --> 01:50:43,170
actually need it and a lot of times you

2037
01:50:39,579 --> 01:50:45,579
don't because you need to end up with

2038
01:50:43,170 --> 01:50:47,949
unit size like things that are a

2039
01:50:45,579 --> 01:50:49,600
particular size for the texture on the

2040
01:50:47,949 --> 01:50:53,470
core the texture memory on the graphics

2041
01:50:49,600 --> 01:50:59,130
card anyway so a lot of times it's not

2042
01:50:53,470 --> 01:50:59,130
really up to you if that makes sense

2043
01:51:24,010 --> 01:51:29,119
what's the mnemonic device used in ummm

2044
01:51:27,050 --> 01:51:31,190
I get that it's a size T but what does

2045
01:51:29,119 --> 01:51:35,210
um M stand for quite a few people in the

2046
01:51:31,189 --> 01:51:39,799
stream ask so the reason for that is

2047
01:51:35,210 --> 01:51:41,480
that the convention that I had for using

2048
01:51:39,800 --> 01:51:42,500
signed and unsigned was the first thing

2049
01:51:41,479 --> 01:51:45,949
tells you whether it's signed or

2050
01:51:42,500 --> 01:51:47,899
unsigned so SRU and then the number

2051
01:51:45,949 --> 01:51:54,559
tells you how many bits it is 32-bit

2052
01:51:47,899 --> 01:51:56,869
64-bit 16 bits 8 bits the problem then

2053
01:51:54,560 --> 01:51:59,090
becomes when you get something that you

2054
01:51:56,869 --> 01:52:03,500
just want to say I need this to be the

2055
01:51:59,090 --> 01:52:06,800
same size as some logical thing so in

2056
01:52:03,500 --> 01:52:10,479
the case of you mmm it's like I need to

2057
01:52:06,800 --> 01:52:13,640
say that it's the size that a pointer is

2058
01:52:10,479 --> 01:52:15,469
and so I just picked memory model like

2059
01:52:13,640 --> 01:52:21,100
it's the size of whatever the memory

2060
01:52:15,470 --> 01:52:22,940
model needs it to be so it's just you mM

2061
01:52:21,100 --> 01:52:24,740
and that's it

2062
01:52:22,939 --> 01:52:30,489
I don't have a strong opinion about that

2063
01:52:24,739 --> 01:52:30,489
you PTR would be another reasonable one

2064
01:52:32,680 --> 01:52:41,150
UST if you wanted to be like use size T

2065
01:52:37,119 --> 01:52:43,309
UPP for put you know pointer Oh

2066
01:52:41,149 --> 01:52:49,519
anything is fine as long as you remember

2067
01:52:43,310 --> 01:52:53,930
it yeah pick whatever you want just as

2068
01:52:49,520 --> 01:52:56,060
long as you remember it thoughts on use

2069
01:52:53,930 --> 01:53:01,329
of Vulcan for a 2.5 do you gain like

2070
01:52:56,060 --> 01:53:03,920
this is it over killers or a benefit so

2071
01:53:01,329 --> 01:53:05,779
again I don't think Vulcans particularly

2072
01:53:03,920 --> 01:53:08,210
useful it kind of is an API they don't

2073
01:53:05,779 --> 01:53:09,500
see the point of anymore but I'll get to

2074
01:53:08,210 --> 01:53:11,810
the more general question should you

2075
01:53:09,500 --> 01:53:16,220
write like a metal version of the game

2076
01:53:11,810 --> 01:53:21,470
on Mac and a d3 12 or you know 11

2077
01:53:16,220 --> 01:53:23,360
version on the PC yes it's valuable like

2078
01:53:21,470 --> 01:53:25,610
with d3 d12 you could definitely do some

2079
01:53:23,359 --> 01:53:27,469
things with how you overlap the texture

2080
01:53:25,609 --> 01:53:30,769
downloads and things like that you could

2081
01:53:27,470 --> 01:53:35,030
definitely do useful things with it so

2082
01:53:30,770 --> 01:53:37,790
it's not overkill on the other hand is

2083
01:53:35,029 --> 01:53:43,309
it strictly necessary probably not

2084
01:53:37,789 --> 01:53:46,519
because well no you know I mean I think

2085
01:53:43,310 --> 01:53:48,020
it is so for example say you want to

2086
01:53:46,520 --> 01:53:52,210
keep pushing on the lighting quality

2087
01:53:48,020 --> 01:53:55,100
which we might want to do later on right

2088
01:53:52,210 --> 01:53:58,159
you know maybe we want two modes of the

2089
01:53:55,100 --> 01:53:59,690
game in the final version one that's you

2090
01:53:58,159 --> 01:54:01,880
know can be run on low-end systems and

2091
01:53:59,689 --> 01:54:04,159
the Lighting's kind of crappy and one

2092
01:54:01,880 --> 01:54:06,020
that runs on high-end systems only like

2093
01:54:04,159 --> 01:54:08,090
you know GeForce Titan or something

2094
01:54:06,020 --> 01:54:09,740
right but that has really cool lighting

2095
01:54:08,090 --> 01:54:11,710
and doing all this ray tracing and stuff

2096
01:54:09,739 --> 01:54:14,689
on the graphics card or something right

2097
01:54:11,710 --> 01:54:16,850
those things are typically good to

2098
01:54:14,689 --> 01:54:22,149
program in like a d3 d12 or whatever

2099
01:54:16,850 --> 01:54:24,350
right that would be my guess

2100
01:54:22,149 --> 01:54:27,589
and on the Vulcan front the reason I say

2101
01:54:24,350 --> 01:54:29,300
it's not useful anymore is because Apple

2102
01:54:27,590 --> 01:54:29,690
made it clear that metals the only game

2103
01:54:29,300 --> 01:54:32,720
in town

2104
01:54:29,689 --> 01:54:34,819
so for Mac OS 10 and iOS you're gonna be

2105
01:54:32,720 --> 01:54:37,159
programming metal full-stop

2106
01:54:34,819 --> 01:54:39,889
nobody cares about Android unless you

2107
01:54:37,159 --> 01:54:42,170
ship free-to-play nonsense games so

2108
01:54:39,890 --> 01:54:43,910
which we don't write they don't have a

2109
01:54:42,170 --> 01:54:46,069
market for paid games on Android pretty

2110
01:54:43,909 --> 01:54:48,739
much period so hand made heroes not an

2111
01:54:46,069 --> 01:54:52,759
issue on Android neither is anything

2112
01:54:48,739 --> 01:54:54,199
anyone would ship probably as a game you

2113
01:54:52,760 --> 01:54:55,960
have to be shipping like free-to-play

2114
01:54:54,199 --> 01:54:57,710
nonsense if you want to be on Android so

2115
01:54:55,960 --> 01:54:59,449
assuming you charging money for your

2116
01:54:57,710 --> 01:55:01,310
game you're talking about iOS you have

2117
01:54:59,449 --> 01:55:02,929
to use metal same with Mac OS 10

2118
01:55:01,310 --> 01:55:04,700
that's the only game in town now they

2119
01:55:02,930 --> 01:55:07,010
have officially said that OpenGL is gone

2120
01:55:04,699 --> 01:55:08,779
right so if you're programming metal on

2121
01:55:07,010 --> 01:55:11,300
that it only leaves one other platform

2122
01:55:08,779 --> 01:55:13,460
for you besides consoles which are all

2123
01:55:11,300 --> 01:55:17,090
custom and the other platform you have

2124
01:55:13,460 --> 01:55:18,920
is Windows and Windows is d3d there's no

2125
01:55:17,090 --> 01:55:21,230
point in Vulcan right there literally

2126
01:55:18,920 --> 01:55:23,840
doesn't give you anything you can't use

2127
01:55:21,229 --> 01:55:28,369
it for cross-platform because it's gonna

2128
01:55:23,840 --> 01:55:32,360
be it's gonna be a cruft layer on top of

2129
01:55:28,369 --> 01:55:34,220
anything you use on an apple platform so

2130
01:55:32,359 --> 01:55:37,670
you might as well just use the actual

2131
01:55:34,220 --> 01:55:39,920
thing that the operating system supports

2132
01:55:37,670 --> 01:55:42,890
and get rid of the Vulcan layer which is

2133
01:55:39,920 --> 01:55:44,930
just cruft right it's no longer the

2134
01:55:42,890 --> 01:55:46,430
direct layer it's it's bulkan is

2135
01:55:44,930 --> 01:55:48,640
basically OpenGL now it's a thing that

2136
01:55:46,430 --> 01:55:51,170
sits on top of the actual graphic system

2137
01:55:48,640 --> 01:55:54,400
and probably will

2138
01:55:51,170 --> 01:55:56,600
you know not be nearly as

2139
01:55:54,399 --> 01:55:57,799
well-maintained as the official thing

2140
01:55:56,600 --> 01:56:00,920
that the operating system itself is

2141
01:55:57,800 --> 01:56:02,539
running through so as far as I'm sure

2142
01:56:00,920 --> 01:56:04,850
you could forget Vulcan I mean Vulcans a

2143
01:56:02,539 --> 01:56:06,859
non-issue maybe on Linux and Android it

2144
01:56:04,850 --> 01:56:08,570
matters but it it's completely

2145
01:56:06,859 --> 01:56:11,029
irrelevant I think for the future of

2146
01:56:08,569 --> 01:56:15,109
games at this point unless there's some

2147
01:56:11,029 --> 01:56:17,899
major change in the future and and one

2148
01:56:15,109 --> 01:56:19,039
of the platform holders adopts it but

2149
01:56:17,899 --> 01:56:20,539
assuming that neither Apple nor

2150
01:56:19,039 --> 01:56:22,369
Microsoft adopt Vulkan

2151
01:56:20,539 --> 01:56:25,310
it's it's dead I mean it's it's a

2152
01:56:22,369 --> 01:56:27,439
non-issue it literally won't matter to

2153
01:56:25,310 --> 01:56:29,030
anybody people might use it as a

2154
01:56:27,439 --> 01:56:30,589
compatibility layer the same way they

2155
01:56:29,029 --> 01:56:33,139
were using OpenGL but if you're looking

2156
01:56:30,590 --> 01:56:34,789
for something that's a smart way to

2157
01:56:33,140 --> 01:56:38,150
partition your games rendering system

2158
01:56:34,789 --> 01:56:38,630
it's gonna be metal D 3d and end of

2159
01:56:38,149 --> 01:56:42,589
story

2160
01:56:38,630 --> 01:56:44,359
right and I really don't see any

2161
01:56:42,590 --> 01:56:46,400
arguments the other way if Vulcans

2162
01:56:44,359 --> 01:56:48,198
certainly not a good API so you're not

2163
01:56:46,399 --> 01:56:50,599
getting anything there either it's it's

2164
01:56:48,198 --> 01:56:52,309
it's a bad it's a lousy API so you're

2165
01:56:50,600 --> 01:56:54,110
not getting like any kind of good like

2166
01:56:52,310 --> 01:56:57,380
ease of use or like well-thought-out

2167
01:56:54,109 --> 01:57:03,649
clean bonus from it it's it's you know

2168
01:56:57,380 --> 01:57:07,239
it's it's a giant tangled mess oh yes

2169
01:57:03,649 --> 01:57:07,238
someone just pointed out a typo

2170
01:57:19,960 --> 01:57:29,199
uh but that is what I did sorry I'm not

2171
01:57:27,760 --> 01:57:31,659
sure what you're talking about

2172
01:57:29,199 --> 01:57:34,988
I think you meant to add two string

2173
01:57:31,659 --> 01:57:42,389
count when scan zero is not equal to

2174
01:57:34,988 --> 01:57:42,389
oh yes yes sorry yes that was the typo

2175
01:58:17,260 --> 01:58:22,690
alright looks like that's like the end

2176
01:58:19,399 --> 01:58:22,689
of the questions

2177
01:58:27,159 --> 01:58:31,069
I've been listening to early episodes of

2178
01:58:29,239 --> 01:58:32,840
Jeff and Casey podcast and wanted to ask

2179
01:58:31,069 --> 01:58:42,099
me feel guilty for giving ei all the

2180
01:58:32,840 --> 01:58:42,100
advice which they definitely follow I

2181
01:58:42,250 --> 01:58:46,489
feel like I'm absolved because I feel

2182
01:58:45,380 --> 01:58:48,079
like they would have come with it

2183
01:58:46,489 --> 01:58:50,300
themselves there are some very smart

2184
01:58:48,079 --> 01:58:53,329
people there those people are not

2185
01:58:50,300 --> 01:58:56,360
necessarily putting their smarts to

2186
01:58:53,329 --> 01:58:58,159
ethical use per se but they're smart I

2187
01:58:56,359 --> 01:59:01,059
think they would have come up with it

2188
01:58:58,159 --> 01:59:03,289
themselves I think they would have I

2189
01:59:01,060 --> 01:59:11,330
don't think they needed to take advice

2190
01:59:03,289 --> 01:59:12,800
from me so I my hands clean of that some

2191
01:59:11,329 --> 01:59:13,789
Suzy thanks a lot for all these great

2192
01:59:12,800 --> 01:59:15,440
educational materials

2193
01:59:13,789 --> 01:59:17,689
you're very welcome thank you for saying

2194
01:59:15,439 --> 01:59:25,219
so could you explain why open jail is a

2195
01:59:17,689 --> 01:59:28,250
state machine I guess I'm not sure what

2196
01:59:25,220 --> 01:59:32,800
you mean by that question couldn't you

2197
01:59:28,250 --> 01:59:34,880
be a little bit more specific about that

2198
01:59:32,800 --> 01:59:38,199
do you have a particular piece of

2199
01:59:34,880 --> 01:59:38,199
documentation to which you're referring

2200
01:59:42,819 --> 01:59:49,849
Brian why is scan one equal zero and not

2201
01:59:46,159 --> 01:59:51,349
scan Oh so in this case so what what

2202
01:59:49,850 --> 01:59:52,370
this is doing here and I probably should

2203
01:59:51,350 --> 01:59:54,380
have explained this a little bit more

2204
01:59:52,369 --> 01:59:58,909
carefully I just kind of wrote it out in

2205
01:59:54,380 --> 02:00:01,730
a hurry what I want to do is I want to

2206
01:59:58,909 --> 02:00:04,250
separate something out into chunks based

2207
02:00:01,729 --> 02:00:06,379
on where the underscores are so if I see

2208
02:00:04,250 --> 02:00:09,979
an underscore I want to record a chunk

2209
02:00:06,380 --> 02:00:13,550
but the last character in the file name

2210
02:00:09,979 --> 02:00:16,909
will not be an underscore probably it

2211
02:00:13,550 --> 02:00:22,310
will just be a regular character and so

2212
02:00:16,909 --> 02:00:25,789
I want to also record that as a chunk or

2213
02:00:22,310 --> 02:00:28,400
a piece I should say so I want to do is

2214
02:00:25,789 --> 02:00:29,229
look to see am i on and underscore if I

2215
02:00:28,399 --> 02:00:33,279
am then

2216
02:00:29,229 --> 02:00:38,049
hit the end of a chunk or is the next

2217
02:00:33,279 --> 02:00:40,179
one a zero and if so then I've hit the

2218
02:00:38,050 --> 02:00:43,750
chunk hit the end of a chunk as well

2219
02:00:40,180 --> 02:00:47,289
right so there's two ways to write this

2220
02:00:43,750 --> 02:00:50,140
I could write it looking at the current

2221
02:00:47,289 --> 02:00:53,890
one to see if it's zero but then I would

2222
02:00:50,140 --> 02:00:57,850
need it and if in here that does if you

2223
02:00:53,890 --> 02:01:01,060
know if stars' can break right here or I

2224
02:00:57,850 --> 02:01:05,140
can use a for loop that checks it here

2225
02:01:01,060 --> 02:01:10,720
and then do the the plus plus string

2226
02:01:05,140 --> 02:01:11,710
count thing it's six of one half dozen

2227
02:01:10,720 --> 02:01:19,090
of the other

2228
02:01:11,710 --> 02:01:21,130
I don't know that that there's strong

2229
02:01:19,090 --> 02:01:22,510
opinion about it I'm happy to write it

2230
02:01:21,130 --> 02:01:28,840
the other way as well

2231
02:01:22,510 --> 02:01:31,090
so like the just show what the other way

2232
02:01:28,840 --> 02:01:34,480
would be what I mean by that is I could

2233
02:01:31,090 --> 02:01:39,039
take scan and move it outside right I

2234
02:01:34,479 --> 02:01:42,309
and then I would say that this is just a

2235
02:01:39,039 --> 02:01:44,949
four i looped it looks like that every

2236
02:01:42,310 --> 02:01:48,700
time through here I do a plus plus scan

2237
02:01:44,949 --> 02:01:53,139
like so and then here I do a thing that

2238
02:01:48,699 --> 02:01:58,380
says you know if scan zero or equals

2239
02:01:53,140 --> 02:02:02,440
zero break and then this thing does like

2240
02:01:58,380 --> 02:02:06,190
if you know scan zero equals zero then

2241
02:02:02,439 --> 02:02:16,119
I'm also at the end and we always do the

2242
02:02:06,189 --> 02:02:19,389
count like that right I don't know that

2243
02:02:16,119 --> 02:02:24,539
there's necessarily like a clear reason

2244
02:02:19,390 --> 02:02:24,539
to prefer one over the other

2245
02:02:25,710 --> 02:02:28,970
[Music]

2246
02:02:31,270 --> 02:02:38,120
yeah I don't know furthermore you could

2247
02:02:34,569 --> 02:02:40,340
technically you could still put the wat

2248
02:02:38,119 --> 02:02:44,510
you could put the wild down here if you

2249
02:02:40,340 --> 02:02:50,449
wanted get rid of this and actually just

2250
02:02:44,510 --> 02:02:53,030
count it but you know anyway that's the

2251
02:02:50,449 --> 02:02:54,859
other way to write it if you like that

2252
02:02:53,029 --> 02:02:56,509
one better by all means write it that

2253
02:02:54,859 --> 02:02:59,500
way I don't know that there's a clear

2254
02:02:56,510 --> 02:02:59,500
reason to write it one way or the other

2255
02:02:59,979 --> 02:03:06,500
so because the answer is still no to

2256
02:03:04,279 --> 02:03:07,729
doing my Comp Sci homework for me yes it

2257
02:03:06,500 --> 02:03:08,960
is I'm not gonna do your Comp Sci

2258
02:03:07,729 --> 02:03:10,429
homework for you have to do it yourself

2259
02:03:08,960 --> 02:03:13,010
you're not gonna learn anything if you

2260
02:03:10,430 --> 02:03:14,270
don't do it yourself Brian okay sorry I

2261
02:03:13,010 --> 02:03:15,650
missed the scan check first which of

2262
02:03:14,270 --> 02:03:16,040
course would mean scan zero would never

2263
02:03:15,649 --> 02:03:18,829
happen

2264
02:03:16,039 --> 02:03:21,109
yes exactly a bit off-topic birthday

2265
02:03:18,829 --> 02:03:23,659
intrinsics 4-bit interleaving I can't

2266
02:03:21,109 --> 02:03:25,399
find on the Intel intrinsic web pages

2267
02:03:23,659 --> 02:03:28,960
but thinking they might not have named

2268
02:03:25,399 --> 02:03:28,960
it interleave or somesuch

2269
02:03:29,229 --> 02:03:34,189
can you be more specific about bit

2270
02:03:31,729 --> 02:03:38,089
interleaving do you mean literally

2271
02:03:34,189 --> 02:03:40,039
taking every other bit so like take one

2272
02:03:38,090 --> 02:03:41,900
bit from one value one bit from another

2273
02:03:40,039 --> 02:03:47,630
value one bit from one value like that

2274
02:03:41,899 --> 02:03:49,960
like each individual bit is that is that

2275
02:03:47,630 --> 02:03:49,960
what you're asking

2276
02:03:52,850 --> 02:03:57,530
once the game is completed and I know

2277
02:03:55,340 --> 02:03:58,909
that will take a long while are there

2278
02:03:57,529 --> 02:04:02,659
any plans to do similar educational

2279
02:03:58,909 --> 02:04:05,149
series no should those pieces also be

2280
02:04:02,659 --> 02:04:06,769
passed to update asset package from PNG

2281
02:04:05,149 --> 02:04:10,059
as far as I can tell you're pricing them

2282
02:04:06,770 --> 02:04:13,130
out but using them yeah I don't think so

2283
02:04:10,060 --> 02:04:17,060
so I think what's probably gonna happen

2284
02:04:13,130 --> 02:04:19,640
not to you know spoiler warning up the

2285
02:04:17,060 --> 02:04:23,960
asset package from PNG is probably gonna

2286
02:04:19,640 --> 02:04:26,270
take something we could pass it don't

2287
02:04:23,960 --> 02:04:29,239
get me wrong maybe we will but probably

2288
02:04:26,270 --> 02:04:33,110
what I'll do is have a parsing function

2289
02:04:29,239 --> 02:04:35,029
I call here that produces a 8x8 that

2290
02:04:33,109 --> 02:04:38,719
says what all of the tags should be

2291
02:04:35,029 --> 02:04:41,119
based on these names and then that that

2292
02:04:38,720 --> 02:04:43,940
is probably what I'll pass to update

2293
02:04:41,119 --> 02:04:45,250
asset package from ping probably don't

2294
02:04:43,939 --> 02:04:47,809
quote me on that

2295
02:04:45,250 --> 02:04:50,869
but that's probably what will happen

2296
02:04:47,810 --> 02:04:53,600
they will get used though they're just I

2297
02:04:50,869 --> 02:04:58,869
don't have anything yet for it

2298
02:04:53,600 --> 02:04:58,870
VT element yes yes every other bit mm

2299
02:05:04,960 --> 02:05:08,739
every other get huh

2300
02:05:17,739 --> 02:05:26,449
so I'll be honest nothing comes to mind

2301
02:05:21,670 --> 02:05:29,590
but for pretty much the entire almost

2302
02:05:26,449 --> 02:05:34,909
the entirety of my sim deprogramming

2303
02:05:29,590 --> 02:05:37,190
I've always been confined to sse2 and I

2304
02:05:34,909 --> 02:05:39,050
don't remember there being one in sse2

2305
02:05:37,189 --> 02:05:42,529
but it may just be that I never needed

2306
02:05:39,050 --> 02:05:44,060
to use that I can't think offhand of any

2307
02:05:42,529 --> 02:05:47,809
time I would have had to do that so I

2308
02:05:44,060 --> 02:05:49,520
think I probably wouldn't remember it I

2309
02:05:47,810 --> 02:05:51,200
probably would have seen it if it was

2310
02:05:49,520 --> 02:05:53,740
there but I probably wouldn't remember

2311
02:05:51,199 --> 02:05:53,739
it was there

2312
02:06:05,569 --> 02:06:15,139
uh so I'm assuming so which I don't know

2313
02:06:13,130 --> 02:06:18,409
which you're talking about here but

2314
02:06:15,140 --> 02:06:26,030
let's say you're talking about modern

2315
02:06:18,409 --> 02:06:30,229
ships so we're looking at these and you

2316
02:06:26,029 --> 02:06:35,619
know you want to see if what with the

2317
02:06:30,229 --> 02:06:37,939
unpack with the unpack stuff is so

2318
02:06:35,619 --> 02:06:40,069
obviously you can in you can interleave

2319
02:06:37,939 --> 02:06:52,309
byte at a time that's what the unpacked

2320
02:06:40,069 --> 02:06:54,819
low epi8 would do yeah not not looking

2321
02:06:52,310 --> 02:06:54,820
great

2322
02:07:05,430 --> 02:07:08,680
[Music]

2323
02:07:10,210 --> 02:07:13,599
trying to think

2324
02:07:47,170 --> 02:07:54,050
wait what did that really suggest that

2325
02:07:51,710 --> 02:08:01,970
there's no bit manipulation in any of

2326
02:07:54,050 --> 02:08:04,460
these other ones all right that seems a

2327
02:08:01,970 --> 02:08:13,699
bit weird because masks move is that is

2328
02:08:04,460 --> 02:08:16,630
a bit manipulation in a sense right yeah

2329
02:08:13,699 --> 02:08:16,630
I don't know um

2330
02:08:23,109 --> 02:08:31,939
so I'm thinking that insert is probably

2331
02:08:26,180 --> 02:08:33,650
the only thing I've never looked at that

2332
02:08:31,939 --> 02:08:42,529
could do something like that

2333
02:08:33,649 --> 02:08:44,659
and I don't think it does so all I can

2334
02:08:42,529 --> 02:08:46,279
say is I don't remember one but there's

2335
02:08:44,659 --> 02:08:48,289
definitely some of these that I never

2336
02:08:46,279 --> 02:08:51,079
looked at because they weren't available

2337
02:08:48,289 --> 02:08:54,170
at the time and there might be something

2338
02:08:51,079 --> 02:08:55,319
in here that can help you so I would

2339
02:08:54,170 --> 02:08:58,420
just keep that in mind

2340
02:08:55,319 --> 02:08:58,420
[Music]

2341
02:09:06,929 --> 02:09:12,779
insert still only works on on bytes at a

2342
02:09:10,750 --> 02:09:12,779
time

2343
02:09:21,600 --> 02:09:24,960
yeah I know

2344
02:09:27,310 --> 02:09:47,510
sorry I really don't know blend

2345
02:09:43,520 --> 02:09:50,320
also is only bytes at a time if I

2346
02:09:47,510 --> 02:09:50,320
remember correctly

2347
02:09:51,640 --> 02:10:03,320
pretty sure gathers are only bytes at a

2348
02:09:54,500 --> 02:10:04,460
time - I just I don't know so the one

2349
02:10:03,319 --> 02:10:16,969
thing I could think of was the mask

2350
02:10:04,460 --> 02:10:19,279
moves and it's not that it's it's not

2351
02:10:16,970 --> 02:10:22,100
mask move it's it's move mask it's the

2352
02:10:19,279 --> 02:10:23,750
it's the opposite it moved these the one

2353
02:10:22,100 --> 02:10:26,570
thing I could think of was these and

2354
02:10:23,750 --> 02:10:28,220
they don't really do what you want but

2355
02:10:26,569 --> 02:10:32,109
they're at least something that actually

2356
02:10:28,220 --> 02:10:32,110
it actually takes bits

2357
02:10:37,180 --> 02:10:43,550
unfortunately it it's going out to the

2358
02:10:39,920 --> 02:10:46,369
general-purpose registers if I remember

2359
02:10:43,550 --> 02:10:49,489
correctly I so it's designed for

2360
02:10:46,369 --> 02:10:51,619
branching and stuff like that so I still

2361
02:10:49,489 --> 02:10:54,409
it probably really just doesn't help you

2362
02:10:51,619 --> 02:11:02,059
but it does do that interleave so let's

2363
02:10:54,409 --> 02:11:04,309
say you've got you know 16 bytes in a

2364
02:11:02,060 --> 02:11:06,770
register you wish you a move mask you

2365
02:11:04,310 --> 02:11:10,430
get the top bit of each you can then

2366
02:11:06,770 --> 02:11:16,730
shift it one over do it again and get

2367
02:11:10,430 --> 02:11:24,050
the top bit of each right so that does

2368
02:11:16,729 --> 02:11:27,289
do a bit interleave but I don't know the

2369
02:11:24,050 --> 02:11:30,920
speed of it and it's not it's not

2370
02:11:27,289 --> 02:11:36,710
internal to the like you want I think

2371
02:11:30,920 --> 02:11:39,739
wants something internal to the xmm

2372
02:11:36,710 --> 02:11:42,619
registers and this goes from xmm to

2373
02:11:39,738 --> 02:11:44,289
purpose which is not probably not not

2374
02:11:42,619 --> 02:11:47,420
what you want at all

2375
02:11:44,289 --> 02:11:48,710
so yeah I'm sorry I'm just I'm having

2376
02:11:47,420 --> 02:11:57,940
trouble thinking of anything that's

2377
02:11:48,710 --> 02:11:57,939
gonna help sorry

2378
02:11:58,460 --> 02:12:01,750
it could be that once you go up to

2379
02:12:00,380 --> 02:12:07,699
avx-512

2380
02:12:01,750 --> 02:12:10,930
you know it's in the mix sorry I I

2381
02:12:07,699 --> 02:12:10,929
really I can't think anything

2382
02:12:22,510 --> 02:12:24,570
you

2383
02:12:24,890 --> 02:12:29,220
Brian I seem to have missed a lot of the

2384
02:12:27,779 --> 02:12:31,469
memory arena work but you create a

2385
02:12:29,220 --> 02:12:32,789
temporary memory Reena where do you pass

2386
02:12:31,470 --> 02:12:34,829
in the original memory that you've

2387
02:12:32,789 --> 02:12:36,569
allocated normally I would think global

2388
02:12:34,829 --> 02:12:39,239
variable but if in the game layer that

2389
02:12:36,569 --> 02:12:43,939
would get your set when you reloaded so

2390
02:12:39,239 --> 02:12:46,949
currently the way it works is it just if

2391
02:12:43,939 --> 02:12:50,299
if you don't provide any memory it just

2392
02:12:46,949 --> 02:12:54,659
asks the platform layer for it

2393
02:12:50,300 --> 02:12:55,680
and that's it Geoff Phoenix I don't know

2394
02:12:54,659 --> 02:12:57,750
if this has been asked for but would you

2395
02:12:55,680 --> 02:13:01,740
consider having your vods do reruns on

2396
02:12:57,750 --> 02:13:04,199
days you aren't going to stream just so

2397
02:13:01,739 --> 02:13:06,599
people can still participate in the chat

2398
02:13:04,199 --> 02:13:08,609
you mean like why wouldn't they just go

2399
02:13:06,600 --> 02:13:13,140
to the episode guide and watch them

2400
02:13:08,609 --> 02:13:14,670
whenever they want like look what would

2401
02:13:13,140 --> 02:13:21,450
be the point of the rerun is it just to

2402
02:13:14,670 --> 02:13:23,039
have the chat or on my day to day I find

2403
02:13:21,449 --> 02:13:24,599
myself using standard string very often

2404
02:13:23,039 --> 02:13:25,890
should I write my own string library or

2405
02:13:24,600 --> 02:13:28,380
what other options would you recommend

2406
02:13:25,890 --> 02:13:29,820
if so how do I handle allocations a

2407
02:13:28,380 --> 02:13:30,989
single huge allocation doesn't seem to

2408
02:13:29,819 --> 02:13:35,880
the right choice since I'm not writing

2409
02:13:30,989 --> 02:13:37,349
game allocations are obviously something

2410
02:13:35,880 --> 02:13:38,699
that's kind of a broader topics is kind

2411
02:13:37,350 --> 02:13:41,610
of hard for me to discuss without

2412
02:13:38,699 --> 02:13:43,319
knowing what you're doing but standard

2413
02:13:41,609 --> 02:13:47,819
string is a piece of garbage and you

2414
02:13:43,319 --> 02:13:51,509
should never use it for anything it's

2415
02:13:47,819 --> 02:13:53,579
it's just terrible so yeah definitely

2416
02:13:51,510 --> 02:13:54,720
don't use standard string I would highly

2417
02:13:53,579 --> 02:13:58,140
recommend writing your own string

2418
02:13:54,720 --> 02:14:01,020
library even if that string library just

2419
02:13:58,140 --> 02:14:02,250
does raw allocations anyway it's still

2420
02:14:01,020 --> 02:14:03,840
gonna be better than standard string

2421
02:14:02,250 --> 02:14:07,319
because standard string is absolutely

2422
02:14:03,840 --> 02:14:09,600
horrid it does everything wrong that you

2423
02:14:07,319 --> 02:14:15,000
can do wrong don't ever touch it it's

2424
02:14:09,600 --> 02:14:16,440
awful just absolutely terrible I would

2425
02:14:15,000 --> 02:14:19,890
use something very much like the buffer

2426
02:14:16,439 --> 02:14:21,750
struct that I just wrote out there and

2427
02:14:19,890 --> 02:14:24,630
write a little library that works with

2428
02:14:21,750 --> 02:14:26,430
those and how you want to do your memory

2429
02:14:24,630 --> 02:14:28,170
allocation is kind of a broader topic

2430
02:14:26,430 --> 02:14:30,350
that isn't really restricted to string

2431
02:14:28,170 --> 02:14:33,930
libraries what I would point out is that

2432
02:14:30,350 --> 02:14:35,610
once you have a count string where you

2433
02:14:33,930 --> 02:14:38,249
say here's the number of characters and

2434
02:14:35,609 --> 02:14:40,049
here's a string you find that you really

2435
02:14:38,248 --> 02:14:41,488
have to allocate memory all that often

2436
02:14:40,050 --> 02:14:44,940
when you concatenate two strings

2437
02:14:41,488 --> 02:14:46,799
together you do but that's about it for

2438
02:14:44,939 --> 02:14:49,488
absolutely everything else you can just

2439
02:14:46,800 --> 02:14:53,460
use sub-regions and it works pretty well

2440
02:14:49,488 --> 02:14:57,029
so you'll find your allocation count

2441
02:14:53,460 --> 02:14:58,889
goes down dramatically when you stop

2442
02:14:57,029 --> 02:15:01,139
using the old terminated strings which

2443
02:14:58,889 --> 02:15:03,179
helps make the memory less of an issue

2444
02:15:01,139 --> 02:15:04,859
because even if you just use a

2445
02:15:03,179 --> 02:15:07,498
general-purpose allocator and allocate

2446
02:15:04,859 --> 02:15:13,018
every time you're still probably going

2447
02:15:07,498 --> 02:15:13,889
to be fine I'll just have the Kaval so I

2448
02:15:13,019 --> 02:15:15,539
was curious why you don't have your

2449
02:15:13,889 --> 02:15:16,949
marquessate on twitch say someone misses

2450
02:15:15,538 --> 02:15:18,448
something you said wrote and wants to go

2451
02:15:16,948 --> 02:15:19,710
back in this and watch quickly there's

2452
02:15:18,448 --> 02:15:21,719
no way to do that until the basel on

2453
02:15:19,710 --> 02:15:23,630
youtube because the pre streams are

2454
02:15:21,719 --> 02:15:26,698
supposed to be just for people who watch

2455
02:15:23,630 --> 02:15:30,659
they if you want to hear the pre stream

2456
02:15:26,698 --> 02:15:32,428
you gotta show up if some I related

2457
02:15:30,658 --> 02:15:33,808
thought to Gigi Nate have you ever

2458
02:15:32,429 --> 02:15:35,819
considered using a program that overlays

2459
02:15:33,809 --> 02:15:37,380
the twitch chat into OBS I see

2460
02:15:35,819 --> 02:15:39,090
entertainment focused streamers using

2461
02:15:37,380 --> 02:15:40,469
them and it's really nice for when they

2462
02:15:39,090 --> 02:15:41,788
reference something from chat and you're

2463
02:15:40,469 --> 02:15:43,618
watching the YouTube app allows for you

2464
02:15:41,788 --> 02:15:46,288
know I don't like that because that

2465
02:15:43,618 --> 02:15:49,698
allows other people to basically post

2466
02:15:46,288 --> 02:15:51,389
into the video which I don't allow

2467
02:15:49,698 --> 02:15:52,859
months ago when you were playing

2468
02:15:51,389 --> 02:15:54,328
intrinsic you added one to use this a

2469
02:15:52,859 --> 02:15:56,158
four point two instruction this isn't

2470
02:15:54,328 --> 02:15:57,768
supported by most older AMD chips like

2471
02:15:56,158 --> 02:16:08,089
mine we consider workaround for this

2472
02:15:57,769 --> 02:16:08,090
possibly but no guarantees all right

2473
02:16:08,179 --> 02:16:17,940
let's take a look here looks like we

2474
02:16:15,569 --> 02:16:20,420
need to update Google Chrome maybe I'll

2475
02:16:17,939 --> 02:16:20,419
do that later

2476
02:16:23,899 --> 02:16:27,809
all right thanks everyone for joining me

2477
02:16:26,429 --> 02:16:29,099
for an episode of handmade hero it's

2478
02:16:27,810 --> 02:16:31,409
been a pleasure coding with you as

2479
02:16:29,099 --> 02:16:33,510
always if you would like to follow along

2480
02:16:31,408 --> 02:16:36,359
with the series at home you can always

2481
02:16:33,510 --> 02:16:38,429
hear the game on handmade hero org and

2482
02:16:36,359 --> 02:16:39,899
it comes with the source code so you can

2483
02:16:38,429 --> 02:16:44,969
play around with it

2484
02:16:39,898 --> 02:16:46,978
we also now have some random new website

2485
02:16:44,968 --> 02:16:49,409
stuff that you can go to which is kind

2486
02:16:46,978 --> 02:16:50,938
of fun we've got the handmade fund which

2487
02:16:49,409 --> 02:16:52,079
is a thing that supports community

2488
02:16:50,939 --> 02:16:53,609
projects I would highly recommend

2489
02:16:52,079 --> 02:16:55,109
checking that out and you get a little

2490
02:16:53,609 --> 02:16:56,460
bonus pack that's fun with a bunch of

2491
02:16:55,109 --> 02:16:58,559
different source code things from old

2492
02:16:56,459 --> 02:17:00,358
products of mine that's definitely

2493
02:16:58,558 --> 02:17:02,489
something to check out we also have a

2494
02:17:00,359 --> 02:17:04,829
watch page now that has the live stream

2495
02:17:02,489 --> 02:17:08,218
on it when it's when it's streaming and

2496
02:17:04,829 --> 02:17:09,898
also it has the episode guide integrated

2497
02:17:08,218 --> 02:17:13,379
into it so that's like kind of a nice

2498
02:17:09,898 --> 02:17:16,079
place you can go to watch stuff and yeah

2499
02:17:13,379 --> 02:17:18,148
it all works pretty well it also has the

2500
02:17:16,079 --> 02:17:20,968
schedule posted on here so as soon as I

2501
02:17:18,148 --> 02:17:22,260
go off the air this stream is replaced

2502
02:17:20,968 --> 02:17:24,029
with something that tells you when I'm

2503
02:17:22,260 --> 02:17:25,670
going to be on the air again which is

2504
02:17:24,030 --> 02:17:27,780
pretty handy

2505
02:17:25,670 --> 02:17:31,138
so yeah highly recommend checking that

2506
02:17:27,780 --> 02:17:33,719
out as well and it has hot links on it

2507
02:17:31,138 --> 02:17:35,250
for other things like pre or in the game

2508
02:17:33,718 --> 02:17:36,839
we're signing up for the mailing list or

2509
02:17:35,250 --> 02:17:39,090
going to the forum's that sort of stuff

2510
02:17:36,840 --> 02:17:40,500
so definitely check out the new website

2511
02:17:39,090 --> 02:17:41,939
and also you can check out any of our

2512
02:17:40,500 --> 02:17:43,590
Molly Rocket websites just by clicking

2513
02:17:41,939 --> 02:17:46,530
on the little icon at the top and that

2514
02:17:43,590 --> 02:17:48,329
goes to all of our pages for quick links

2515
02:17:46,530 --> 02:17:50,760
as well so anything that you might want

2516
02:17:48,329 --> 02:17:52,739
to do we've got up there and now for you

2517
02:17:50,760 --> 02:17:54,950
because we move the handmade hero

2518
02:17:52,739 --> 02:17:57,058
website over to our general website

2519
02:17:54,950 --> 02:17:58,409
stuff that handles all the stuff on

2520
02:17:57,058 --> 02:18:00,000
Molly rockets so it's a lot more

2521
02:17:58,409 --> 02:18:03,090
functional and interesting now that used

2522
02:18:00,000 --> 02:18:04,950
to be so check that out I'll be back

2523
02:18:03,090 --> 02:18:07,019
here tomorrow to do some more on the

2524
02:18:04,950 --> 02:18:09,149
asset loading we've got our stuff self

2525
02:18:07,019 --> 02:18:11,280
in position to actually process the PNG

2526
02:18:09,148 --> 02:18:13,279
data now and put it into the asset file

2527
02:18:11,280 --> 02:18:15,329
so that's what we want to do next time

2528
02:18:13,280 --> 02:18:16,889
that should be pretty straightforward

2529
02:18:15,329 --> 02:18:18,450
but then I think when we get to the tags

2530
02:18:16,888 --> 02:18:19,829
part that's when we're gonna have to

2531
02:18:18,450 --> 02:18:20,280
start really putting on our thinking

2532
02:18:19,829 --> 02:18:22,530
caps

2533
02:18:20,280 --> 02:18:24,450
so tomorrow should probably be pretty

2534
02:18:22,530 --> 02:18:27,469
straightforward but next weekend that

2535
02:18:24,450 --> 02:18:29,880
might be a little bit saucy ER so

2536
02:18:27,468 --> 02:18:31,799
definitely you'll you'll be able to have

2537
02:18:29,879 --> 02:18:34,920
a couple days of rest before we head

2538
02:18:31,799 --> 02:18:35,579
into that next week but tomorrow should

2539
02:18:34,920 --> 02:18:37,500
be pretty straight

2540
02:18:35,579 --> 02:18:39,959
we already wrote the PNG reader so we're

2541
02:18:37,500 --> 02:18:42,359
just doing something that scans those

2542
02:18:39,959 --> 02:18:44,518
blocks and and looks at when it actually

2543
02:18:42,359 --> 02:18:44,969
needs to update stuff shouldn't be too

2544
02:18:44,519 --> 02:18:47,010
hard

2545
02:18:44,968 --> 02:18:48,419
hopes me back here for that till then

2546
02:18:47,010 --> 02:18:49,889
have fun programming and I'll see

2547
02:18:48,420 --> 02:18:52,489
everyone on the Internet take it easy

2548
02:18:49,888 --> 02:18:52,489
everybody

