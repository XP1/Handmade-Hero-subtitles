1
00:00:00,560 --> 00:00:04,080
hello everyone and welcome to hand made

2
00:00:02,850 --> 00:00:09,960
here oh sure we could a complete-game

3
00:00:04,080 --> 00:00:11,910
live on stream we today are just gonna

4
00:00:09,960 --> 00:00:13,920
pick up where we left off yesterday and

5
00:00:11,910 --> 00:00:17,579
it was actually kind of very fortuitous

6
00:00:13,919 --> 00:00:20,160
day to be completely honest with you we

7
00:00:17,579 --> 00:00:22,979
are starting to do the final performance

8
00:00:20,160 --> 00:00:25,589
pass over our grid raytracer and I had

9
00:00:22,980 --> 00:00:27,000
planned on yesterday doing some changes

10
00:00:25,589 --> 00:00:28,379
to the way we're doing good ray casting

11
00:00:27,000 --> 00:00:31,710
which I think will speed up the grid ray

12
00:00:28,379 --> 00:00:35,488
caster quite a bit but in so doing we

13
00:00:31,710 --> 00:00:36,899
discovered that actually our voxel

14
00:00:35,488 --> 00:00:38,488
sampling was a lot slower than I thought

15
00:00:36,899 --> 00:00:39,808
I thought I had tested the voxel

16
00:00:38,488 --> 00:00:42,058
sampling because I assumed that it was

17
00:00:39,808 --> 00:00:43,259
slow before and found that it wasn't

18
00:00:42,058 --> 00:00:45,479
really affecting the performance that

19
00:00:43,259 --> 00:00:47,729
much maybe that was erroneous because

20
00:00:45,479 --> 00:00:50,909
we've tested it now and when we test the

21
00:00:47,729 --> 00:00:52,198
full cycle but just don't do the ray

22
00:00:50,909 --> 00:00:54,269
cast and we let it fall through to just

23
00:00:52,198 --> 00:00:55,920
the sampling it turns out it actually

24
00:00:54,270 --> 00:00:58,050
takes quite a bit of time that's great

25
00:00:55,920 --> 00:01:01,289
news because that was sort of a piece of

26
00:00:58,049 --> 00:01:02,399
code we'd left to optimize for later and

27
00:01:01,289 --> 00:01:04,680
so what that means is we're probably

28
00:01:02,399 --> 00:01:06,210
gonna get a big free speed boost here

29
00:01:04,680 --> 00:01:11,250
probably I mean we don't know for sure

30
00:01:06,209 --> 00:01:12,859
but it's entirely possible that we're

31
00:01:11,250 --> 00:01:15,509
gonna get a bunch of performance here

32
00:01:12,859 --> 00:01:18,810
that I wasn't anticipating getting and

33
00:01:15,509 --> 00:01:21,329
so it's really nice sometimes when you

34
00:01:18,810 --> 00:01:23,519
start to profile a piece of code and

35
00:01:21,329 --> 00:01:25,769
you're anticipating having to work on a

36
00:01:23,519 --> 00:01:27,420
particular piece of it and then you find

37
00:01:25,769 --> 00:01:28,890
out that another piece of it that you

38
00:01:27,420 --> 00:01:31,200
hadn't optimized yet or even looked at

39
00:01:28,890 --> 00:01:33,780
yet is taking a significant chunk of the

40
00:01:31,200 --> 00:01:35,969
time because again it just makes your

41
00:01:33,780 --> 00:01:37,079
job easier since optimizing something

42
00:01:35,969 --> 00:01:39,688
you've literally never touched before

43
00:01:37,078 --> 00:01:41,938
there's always so much more fat in it

44
00:01:39,688 --> 00:01:43,709
that you could potentially remove it's

45
00:01:41,938 --> 00:01:45,868
always easier to do that low-hanging

46
00:01:43,709 --> 00:01:47,250
first-pass than it is to do like the

47
00:01:45,868 --> 00:01:52,228
subsequent passes where you really have

48
00:01:47,250 --> 00:01:54,359
to sort of buckle down right and so it's

49
00:01:52,228 --> 00:01:56,549
really good for us because this means

50
00:01:54,359 --> 00:01:59,700
that we have the potential here to maybe

51
00:01:56,549 --> 00:02:02,100
do to get a good speed win for not that

52
00:01:59,700 --> 00:02:04,469
much creativity so that's kind of a nice

53
00:02:02,099 --> 00:02:07,438
a nice side bonus we don't know that we

54
00:02:04,468 --> 00:02:09,899
will but we might and so that potential

55
00:02:07,438 --> 00:02:11,459
is nice what we did yesterday is we

56
00:02:09,899 --> 00:02:13,259
started rewriting this part of the code

57
00:02:11,459 --> 00:02:18,569
you can see here how it works

58
00:02:13,259 --> 00:02:20,188
it's getting the relative position for a

59
00:02:18,568 --> 00:02:23,188
particular sample point it figures that

60
00:02:20,188 --> 00:02:26,370
where it is in the grid it gets the

61
00:02:23,188 --> 00:02:29,039
tiles that surround that particular

62
00:02:26,370 --> 00:02:32,989
sample point so this is an octave this

63
00:02:29,039 --> 00:02:36,810
is this is a an eight-way so a trilinear

64
00:02:32,989 --> 00:02:39,090
sample and then it produces some weights

65
00:02:36,810 --> 00:02:41,489
and blends them together via the weights

66
00:02:39,090 --> 00:02:43,620
and this was just the main line written

67
00:02:41,489 --> 00:02:46,560
out code there's you know there's

68
00:02:43,620 --> 00:02:48,390
nothing up we didn't try to optimize

69
00:02:46,560 --> 00:02:51,420
this in any way right so this was just

70
00:02:48,389 --> 00:02:52,738
us writing literally exactly what the

71
00:02:51,419 --> 00:02:55,649
code should do in the most

72
00:02:52,739 --> 00:02:57,420
straightforward possible way with no

73
00:02:55,650 --> 00:02:59,219
attempt at optimization and so all I

74
00:02:57,419 --> 00:03:02,789
started doing yesterday was saying okay

75
00:02:59,219 --> 00:03:04,680
look if we wanted to go ahead and try to

76
00:03:02,789 --> 00:03:07,530
improve this piece of code what could we

77
00:03:04,680 --> 00:03:10,049
do to it and what I'd like to do here is

78
00:03:07,530 --> 00:03:10,739
maybe since we have the opportunity to

79
00:03:10,049 --> 00:03:13,560
do so

80
00:03:10,739 --> 00:03:15,209
what I might want to do is because this

81
00:03:13,560 --> 00:03:17,430
code is fairly subtle and we don't

82
00:03:15,209 --> 00:03:19,729
really have a good way of testing it I'd

83
00:03:17,430 --> 00:03:22,079
like to go ahead and just run these two

84
00:03:19,729 --> 00:03:24,988
pieces of code against each other I

85
00:03:22,079 --> 00:03:26,909
think I think that's going to be the

86
00:03:24,989 --> 00:03:29,329
sane astray to kind of do what I want to

87
00:03:26,909 --> 00:03:32,609
do so I basically just want to say look

88
00:03:29,329 --> 00:03:35,040
is there some way that I can run this

89
00:03:32,609 --> 00:03:35,639
code twice so every time we ask for a

90
00:03:35,039 --> 00:03:38,159
sample

91
00:03:35,639 --> 00:03:41,159
you know I'll run this side of it and

92
00:03:38,159 --> 00:03:43,709
rather than an if/else until I actually

93
00:03:41,159 --> 00:03:47,128
want to test the performance of it I'm

94
00:03:43,709 --> 00:03:50,098
actually just going to run both both

95
00:03:47,128 --> 00:03:51,929
sides right so want to run both sides of

96
00:03:50,098 --> 00:03:55,048
the code and what I'll do is we'll have

97
00:03:51,930 --> 00:03:58,949
a result here so we'll say look there's

98
00:03:55,049 --> 00:04:00,840
going to be a result value and the

99
00:03:58,949 --> 00:04:04,650
result value will get assigned by the

100
00:04:00,840 --> 00:04:07,169
first piece of code like this right and

101
00:04:04,650 --> 00:04:09,299
then all I really want to do is for this

102
00:04:07,169 --> 00:04:12,150
new piece of code I just want to check

103
00:04:09,299 --> 00:04:15,650
to see that the result that we compute

104
00:04:12,150 --> 00:04:15,650
is very close to the original

105
00:04:21,139 --> 00:04:28,169
so what we really want to do here is we

106
00:04:23,790 --> 00:04:31,439
just want to have a we just want to have

107
00:04:28,170 --> 00:04:35,060
some idea of whether we've got bugs in

108
00:04:31,439 --> 00:04:37,110
our optimized routine and so as I go

109
00:04:35,060 --> 00:04:39,509
finish this top part because you can see

110
00:04:37,110 --> 00:04:41,040
we actually wrote most of the routine we

111
00:04:39,509 --> 00:04:43,069
actually now just have this sort of top

112
00:04:41,040 --> 00:04:45,330
part where we're gonna have to do that

113
00:04:43,069 --> 00:04:46,920
the tile fetching which will be the

114
00:04:45,329 --> 00:04:49,349
slowest part because it cannot be done

115
00:04:46,920 --> 00:04:56,040
wide unless you have like a V X cat or

116
00:04:49,350 --> 00:04:59,670
gather or something an Intel chips uh

117
00:04:56,040 --> 00:05:01,800
cats cat or gather anyway but in here we

118
00:04:59,670 --> 00:05:03,990
basically have the ability to to do that

119
00:05:01,800 --> 00:05:06,329
we'll have to get optimized slightly

120
00:05:03,990 --> 00:05:09,540
because this get clamped we could do a

121
00:05:06,329 --> 00:05:12,779
lot better you don't really need to

122
00:05:09,540 --> 00:05:15,000
clamp each one of these we could do one

123
00:05:12,779 --> 00:05:17,849
or two quick checks and then know all of

124
00:05:15,000 --> 00:05:20,129
the offsets so get tile clamped is much

125
00:05:17,850 --> 00:05:24,000
slower than it needs to be so we can fix

126
00:05:20,129 --> 00:05:26,790
that part for sure then in here this C

127
00:05:24,000 --> 00:05:30,000
computation this C computation we should

128
00:05:26,790 --> 00:05:32,220
be able to do very cleanly as well you

129
00:05:30,000 --> 00:05:34,230
can see here that basically what we've

130
00:05:32,220 --> 00:05:36,720
got when we're working through this here

131
00:05:34,230 --> 00:05:40,290
is we just assume we have C 0 3 and C 4

132
00:05:36,720 --> 00:05:42,270
7 and we don't have either of those so

133
00:05:40,290 --> 00:05:45,240
that's the thing the main thing we've

134
00:05:42,269 --> 00:05:47,699
got to produce now is that this part

135
00:05:45,240 --> 00:05:50,040
here we could even use the slow part

136
00:05:47,699 --> 00:05:53,339
first just so we can debug the second

137
00:05:50,040 --> 00:05:55,350
half of the routine and that may be what

138
00:05:53,339 --> 00:05:56,609
I do because I'd like to debug this in

139
00:05:55,350 --> 00:05:58,620
waves

140
00:05:56,610 --> 00:06:01,110
I'd like to basically do something where

141
00:05:58,620 --> 00:06:03,509
we can get in fact you know you can see

142
00:06:01,110 --> 00:06:06,720
how I would do this I would like to do

143
00:06:03,509 --> 00:06:12,050
something where I stuck each part so for

144
00:06:06,720 --> 00:06:15,120
example at any given time here I could I

145
00:06:12,050 --> 00:06:16,590
could keep any of these pieces of

146
00:06:15,120 --> 00:06:19,920
information in fact you know I could

147
00:06:16,589 --> 00:06:22,439
even do something more like this so

148
00:06:19,920 --> 00:06:24,270
instead of having the v3 result be the

149
00:06:22,439 --> 00:06:29,339
only thing that persists I could just

150
00:06:24,269 --> 00:06:30,329
you know make the entire thing right and

151
00:06:29,339 --> 00:06:33,119
then oops

152
00:06:30,329 --> 00:06:37,079
and then here

153
00:06:33,120 --> 00:06:39,478
I can do is since I've done the entire

154
00:06:37,079 --> 00:06:43,409
computation here in the original scalar

155
00:06:39,478 --> 00:06:45,629
version I can then at each point in here

156
00:06:43,410 --> 00:06:48,510
where I want to do like sort of a check

157
00:06:45,629 --> 00:06:51,389
I can check my intermediate results to

158
00:06:48,509 --> 00:06:55,829
ensure that they line up with the

159
00:06:51,389 --> 00:06:58,470
existing answers right and so that'll

160
00:06:55,829 --> 00:07:00,899
give me a much faster way of verifying

161
00:06:58,470 --> 00:07:03,270
this routine against the previous code

162
00:07:00,899 --> 00:07:05,489
not that the previous code is special in

163
00:07:03,269 --> 00:07:06,870
any way but we ran a bunch of stuff with

164
00:07:05,490 --> 00:07:09,300
the previous code and we liked the

165
00:07:06,870 --> 00:07:11,550
results we got so at the very least we

166
00:07:09,300 --> 00:07:14,699
know it's not broken to the point of not

167
00:07:11,550 --> 00:07:18,090
actually producing usable like shippable

168
00:07:14,699 --> 00:07:19,770
results at some point we may want to try

169
00:07:18,089 --> 00:07:22,259
a way to you know figure out a good

170
00:07:19,769 --> 00:07:25,129
stress test for this like create scenes

171
00:07:22,259 --> 00:07:32,699
that have very specific lights reading

172
00:07:25,129 --> 00:07:36,120
behavior so you know there's stuff we

173
00:07:32,699 --> 00:07:37,830
could do there but at the moment all I

174
00:07:36,120 --> 00:07:39,810
want to do is make sure that I'm not

175
00:07:37,829 --> 00:07:42,209
making the situation worse with my

176
00:07:39,810 --> 00:07:44,069
optimization so that's really the only

177
00:07:42,209 --> 00:07:45,870
thing I want to make sure of because

178
00:07:44,069 --> 00:07:48,329
again we don't really know that this

179
00:07:45,870 --> 00:07:51,090
routine is working as well as it could

180
00:07:48,329 --> 00:07:53,189
because we have no real testing for it

181
00:07:51,089 --> 00:07:54,779
and in fact I don't really even know

182
00:07:53,189 --> 00:07:56,370
exactly how we would test it but if we

183
00:07:54,779 --> 00:07:58,319
sat down and tried I'm sure we could

184
00:07:56,370 --> 00:08:00,449
find a way to sort of bulletproof this

185
00:07:58,319 --> 00:08:03,990
routine more even if that just meant

186
00:08:00,449 --> 00:08:06,240
plugging in some values that some cases

187
00:08:03,990 --> 00:08:07,259
that we think should do something and me

188
00:08:06,240 --> 00:08:09,689
stepping through them to verify that

189
00:08:07,259 --> 00:08:11,909
they do right so you know at the very

190
00:08:09,689 --> 00:08:13,860
least we could and you know another

191
00:08:11,910 --> 00:08:15,300
example would be like if we if we took

192
00:08:13,860 --> 00:08:16,620
the voxels and flooded them with

193
00:08:15,300 --> 00:08:18,060
structured light so we basically said

194
00:08:16,620 --> 00:08:21,329
like okay this one's full red this one's

195
00:08:18,060 --> 00:08:24,418
full green this one's full blue and we

196
00:08:21,329 --> 00:08:26,639
put sample points and sample normals in

197
00:08:24,418 --> 00:08:29,339
there and looked at what came came out

198
00:08:26,639 --> 00:08:31,288
we could look at those channels and

199
00:08:29,339 --> 00:08:32,788
verify that like okay if the normals

200
00:08:31,288 --> 00:08:34,799
pointed away from the red light it

201
00:08:32,788 --> 00:08:35,729
doesn't sample the red light and if it's

202
00:08:34,799 --> 00:08:38,218
pointed towards the blue light samples

203
00:08:35,729 --> 00:08:40,229
the blue light you know so we certainly

204
00:08:38,219 --> 00:08:41,729
can do more and so at some point we may

205
00:08:40,229 --> 00:08:43,020
want to do some better testing here and

206
00:08:41,729 --> 00:08:44,550
that's just part of like improving

207
00:08:43,019 --> 00:08:45,159
letting quality ensuring that there

208
00:08:44,549 --> 00:08:48,309
aren't

209
00:08:45,159 --> 00:08:52,419
obvious bugs in the sampling routines

210
00:08:48,309 --> 00:08:54,189
that's something we can do so I don't

211
00:08:52,419 --> 00:08:55,599
want to tackle that part yet I just want

212
00:08:54,190 --> 00:08:58,060
to be able to verify it so I know that

213
00:08:55,600 --> 00:09:00,069
I'm doing the same algorithm in either

214
00:08:58,059 --> 00:09:03,578
case and so in order to do that we're

215
00:09:00,068 --> 00:09:06,490
just gonna put in some structured checks

216
00:09:03,578 --> 00:09:11,888
here and I'm gonna do those once we're

217
00:09:06,490 --> 00:09:14,470
ready for the moment all I want to do is

218
00:09:11,889 --> 00:09:15,879
finish this part of the code so if you

219
00:09:14,470 --> 00:09:20,350
take a look at what we haven't done yet

220
00:09:15,879 --> 00:09:24,009
it's this C right here so we have to

221
00:09:20,350 --> 00:09:25,600
recreate the C values here and these C

222
00:09:24,009 --> 00:09:27,818
values are again fairly highly

223
00:09:25,600 --> 00:09:29,500
structured you can see the way that they

224
00:09:27,818 --> 00:09:31,328
work and what we want to try and produce

225
00:09:29,500 --> 00:09:35,470
here just because this is the way we

226
00:09:31,328 --> 00:09:40,708
decided to make it work at first is what

227
00:09:35,470 --> 00:09:42,730
we want to produce Jimmy man I

228
00:09:40,708 --> 00:09:43,088
definitely have Kobe 19 let's just face

229
00:09:42,730 --> 00:09:51,459
it

230
00:09:43,089 --> 00:09:53,380
I am the plague bear all right so what I

231
00:09:51,458 --> 00:09:56,258
want to do here is I want to go ahead

232
00:09:53,379 --> 00:09:59,708
and recreate each of these things with

233
00:09:56,259 --> 00:10:04,778
the end goal of having the first three

234
00:09:59,708 --> 00:10:08,229
so these here are gonna come through as

235
00:10:04,778 --> 00:10:11,198
C 0 3 and again that's because the

236
00:10:08,230 --> 00:10:17,829
inputs are here in here so C 0 3 and C 4

237
00:10:11,198 --> 00:10:21,219
7 so we have C 0 3 and C 4 7 and what I

238
00:10:17,828 --> 00:10:23,649
want to do is produce these answers here

239
00:10:21,220 --> 00:10:30,220
so the inner product of each of these

240
00:10:23,649 --> 00:10:31,688
right and so again I'm the best way to

241
00:10:30,220 --> 00:10:33,579
do this routine if you really knew that

242
00:10:31,688 --> 00:10:34,899
it was like the most important thing and

243
00:10:33,578 --> 00:10:37,239
we were gonna try and do the best

244
00:10:34,899 --> 00:10:39,370
possible job is we would analyze all the

245
00:10:37,240 --> 00:10:41,198
scalar dependency flows and all the

246
00:10:39,370 --> 00:10:43,899
operations that were in them and then we

247
00:10:41,198 --> 00:10:45,669
would try to arrange our lanes so that

248
00:10:43,899 --> 00:10:47,318
they minimize the number of shuffles

249
00:10:45,669 --> 00:10:50,289
we're not doing that okay we're just

250
00:10:47,318 --> 00:10:52,448
doing a first pass simple implementation

251
00:10:50,289 --> 00:10:54,219
of this routine wide to get what we can

252
00:10:52,448 --> 00:10:55,838
get out of it and to reduce the amount

253
00:10:54,220 --> 00:10:58,499
of compiler craft because when I looked

254
00:10:55,839 --> 00:11:01,919
at this routine the compiler was doing

255
00:10:58,499 --> 00:11:03,569
absolutely bonkers stuff for no reason

256
00:11:01,918 --> 00:11:05,489
and so I think we can speed it up just

257
00:11:03,568 --> 00:11:07,649
by doing something basic and so that's

258
00:11:05,489 --> 00:11:09,569
all we're doing here we're not trying to

259
00:11:07,649 --> 00:11:10,668
do the fastest possible version of this

260
00:11:09,568 --> 00:11:13,068
routine

261
00:11:10,668 --> 00:11:15,359
so I'm just gonna do a straight ahead

262
00:11:13,068 --> 00:11:17,788
implementation to try and get these two

263
00:11:15,359 --> 00:11:19,739
pieces of information here and so if you

264
00:11:17,788 --> 00:11:22,859
take a look at what we would need what

265
00:11:19,739 --> 00:11:24,179
we want to achieve here you can see that

266
00:11:22,859 --> 00:11:26,099
in here I've got some things that look

267
00:11:24,178 --> 00:11:31,108
like this this is how we want to load

268
00:11:26,099 --> 00:11:34,349
these up right so these are not you know

269
00:11:31,109 --> 00:11:36,799
this is not really this is not actual

270
00:11:34,349 --> 00:11:39,959
code right this is Nayan this is nothing

271
00:11:36,798 --> 00:11:42,269
so these right here are things that we

272
00:11:39,958 --> 00:11:43,978
actually have to prepare and in fact

273
00:11:42,269 --> 00:11:45,568
those can kind of float to the top where

274
00:11:43,979 --> 00:11:48,869
this sort of thing is happening because

275
00:11:45,568 --> 00:11:50,668
you know it's totally fine but the rest

276
00:11:48,869 --> 00:11:52,048
of this is actual code right the rest of

277
00:11:50,668 --> 00:11:53,578
this is actual code we intend to

278
00:11:52,048 --> 00:11:55,708
implement and it might not be quite

279
00:11:53,578 --> 00:11:57,358
written as actual code yet but most of

280
00:11:55,708 --> 00:11:59,098
it actually is there's a couple things

281
00:11:57,359 --> 00:12:00,839
like we didn't define a one vector and

282
00:11:59,099 --> 00:12:03,799
we we want to make that a floor or

283
00:12:00,839 --> 00:12:08,639
function and so on but for the most part

284
00:12:03,798 --> 00:12:10,759
it's all fine so if I then go through

285
00:12:08,639 --> 00:12:14,788
and take a look at what's happening here

286
00:12:10,759 --> 00:12:17,009
what you can see is I I want to know

287
00:12:14,788 --> 00:12:18,899
what these C values should actually look

288
00:12:17,009 --> 00:12:23,389
like and what you can see is all of them

289
00:12:18,899 --> 00:12:26,519
end in a clamp zero one so one of the

290
00:12:23,389 --> 00:12:30,089
interviews is things I can do here is I

291
00:12:26,519 --> 00:12:32,999
can just make sure that we do well in

292
00:12:30,089 --> 00:12:35,339
fact I think do we actually have a clamp

293
00:12:32,999 --> 00:12:38,729
zero one for these we should I don't

294
00:12:35,339 --> 00:12:40,589
know if we do yeah so we don't actually

295
00:12:38,729 --> 00:12:42,749
even have a clamp zero one for these we

296
00:12:40,589 --> 00:12:44,369
should because it's a very simple

297
00:12:42,749 --> 00:12:46,829
function so I think I might just go

298
00:12:44,369 --> 00:12:48,149
ahead and implement that so in here

299
00:12:46,828 --> 00:12:50,399
where we've got you know all of these

300
00:12:48,149 --> 00:12:56,068
pieces of code that we were writing to

301
00:12:50,399 --> 00:12:58,048
handle our various math ops right in

302
00:12:56,068 --> 00:12:59,788
here where we have all these I don't

303
00:12:58,048 --> 00:13:01,288
know if we have them in max we do so you

304
00:12:59,788 --> 00:13:04,678
can see we have like a min Max here

305
00:13:01,288 --> 00:13:08,399
right we've got these values so it's

306
00:13:04,678 --> 00:13:10,318
pretty straightforward for us to do once

307
00:13:08,399 --> 00:13:11,578
you have a min and the max clamp zero

308
00:13:10,318 --> 00:13:12,120
one's really easy because it's just a

309
00:13:11,578 --> 00:13:14,939
min file

310
00:13:12,120 --> 00:13:21,810
by a max or vice-versa right so if we

311
00:13:14,940 --> 00:13:25,020
just do a clamp 0 1 and we pass in some

312
00:13:21,809 --> 00:13:31,619
value then the result here is just gonna

313
00:13:25,019 --> 00:13:35,399
be the min max of a where the min is

314
00:13:31,620 --> 00:13:37,980
with 0 and the max is with 1 right I'm

315
00:13:35,399 --> 00:13:40,079
sorry the other way around so this needs

316
00:13:37,980 --> 00:13:42,839
to be a 0 vector and this needs to be a

317
00:13:40,080 --> 00:13:47,610
1 vector right so we would just have

318
00:13:42,839 --> 00:13:49,950
something like this I don't know if we

319
00:13:47,610 --> 00:13:50,310
have a 0 here so I guess I'll just do

320
00:13:49,950 --> 00:13:52,500
this

321
00:13:50,309 --> 00:14:01,289
we'll see what if this actually does the

322
00:13:52,500 --> 00:14:03,839
right thing let's look at the code so if

323
00:14:01,289 --> 00:14:05,278
we have a clamp 0 1 here all this is

324
00:14:03,839 --> 00:14:07,680
going to do right is this going to say

325
00:14:05,278 --> 00:14:09,870
look if I take the maximum value between

326
00:14:07,679 --> 00:14:12,389
0 and this thing then if it's less than

327
00:14:09,870 --> 00:14:14,070
0 that will bring it up to 0 if I take

328
00:14:12,389 --> 00:14:15,449
the minimum of this thing in 1 that

329
00:14:14,070 --> 00:14:18,060
means if it's over 1 it'll come down to

330
00:14:15,450 --> 00:14:20,759
1 so in just two instructions I can do a

331
00:14:18,059 --> 00:14:23,250
clamp 0 1 and there's no test right and

332
00:14:20,759 --> 00:14:26,159
so there's no control flow here it just

333
00:14:23,250 --> 00:14:27,330
works and you can contrast that with

334
00:14:26,159 --> 00:14:31,500
what would happen if the compiler

335
00:14:27,330 --> 00:14:33,389
literally interpret interpreted you know

336
00:14:31,500 --> 00:14:34,769
rather than doing a seamoth which you

337
00:14:33,389 --> 00:14:36,059
know I don't know whether I miss VC will

338
00:14:34,769 --> 00:14:38,789
actually generate a seam out for this

339
00:14:36,059 --> 00:14:39,629
but if you look at what actually has to

340
00:14:38,789 --> 00:14:42,360
happen here

341
00:14:39,629 --> 00:14:43,950
you know this less than min result

342
00:14:42,360 --> 00:14:46,649
equals manual greater than max values

343
00:14:43,950 --> 00:14:53,450
max if you actually wrote this code out

344
00:14:46,649 --> 00:14:57,569
that's actually two jumps right and

345
00:14:53,450 --> 00:15:00,420
that's really expensive because they're

346
00:14:57,570 --> 00:15:10,110
not going to be predictable so basically

347
00:15:00,419 --> 00:15:12,059
this is I mean yeah this is incredibly

348
00:15:10,110 --> 00:15:13,709
expensive and this is basically free is

349
00:15:12,059 --> 00:15:15,359
I guess what I'm trying to say and so

350
00:15:13,708 --> 00:15:16,739
it's worth understanding like the

351
00:15:15,360 --> 00:15:19,440
difference between those two things of

352
00:15:16,740 --> 00:15:21,089
why I care about them the compiler could

353
00:15:19,440 --> 00:15:24,630
generate this pretty efficiently in

354
00:15:21,089 --> 00:15:25,500
scaler and in fact could even use the

355
00:15:24,629 --> 00:15:27,960
min and Max

356
00:15:25,500 --> 00:15:29,700
use the minimax operations to do it if

357
00:15:27,960 --> 00:15:31,350
it was smart enough to analyze that

358
00:15:29,700 --> 00:15:33,090
piece of code but it's just usually a

359
00:15:31,350 --> 00:15:34,529
bad idea to rely on the compiler to do

360
00:15:33,090 --> 00:15:40,110
something smart cuz often times it

361
00:15:34,529 --> 00:15:43,949
doesn't that's just you know writing

362
00:15:40,110 --> 00:15:45,090
optimizers is hard and especially the

363
00:15:43,950 --> 00:15:47,990
way that compilers do it where they do

364
00:15:45,090 --> 00:15:50,820
it in a you know in line with the actual

365
00:15:47,990 --> 00:15:54,060
compilation pass where you're like you

366
00:15:50,820 --> 00:15:55,470
know it can't take an hour right well

367
00:15:54,059 --> 00:15:57,779
missus tensorflow but can't take an hour

368
00:15:55,470 --> 00:16:01,139
to like analyze that this little piece

369
00:15:57,779 --> 00:16:02,819
of code right so that can't do like

370
00:16:01,139 --> 00:16:04,649
super optimization or sorts of things

371
00:16:02,820 --> 00:16:07,650
that would make it fairly easy to write

372
00:16:04,649 --> 00:16:08,879
a compiler right it's just because it's

373
00:16:07,649 --> 00:16:10,679
structured wrong and the way we

374
00:16:08,879 --> 00:16:12,000
currently have tools made is wrong and

375
00:16:10,679 --> 00:16:13,500
everything's wrong right so the way they

376
00:16:12,000 --> 00:16:15,210
currently make optimizer is if you want

377
00:16:13,500 --> 00:16:17,009
it actually ship one the way that they

378
00:16:15,210 --> 00:16:18,360
do it is actually pretty hard and so I

379
00:16:17,009 --> 00:16:20,100
don't blame them for not getting stuff

380
00:16:18,360 --> 00:16:21,379
right and so my opinion I should just

381
00:16:20,100 --> 00:16:24,180
write the code right in the first place

382
00:16:21,379 --> 00:16:25,830
so that they can produce reasonable code

383
00:16:24,179 --> 00:16:26,729
from it without having to you know do

384
00:16:25,830 --> 00:16:29,220
anything crazy

385
00:16:26,730 --> 00:16:32,159
so anyway assuming that we just clamp

386
00:16:29,220 --> 00:16:34,200
these two then what we really are

387
00:16:32,159 --> 00:16:37,980
talking about now if I peel away the

388
00:16:34,200 --> 00:16:46,110
part of C that's actually now been done

389
00:16:37,980 --> 00:16:48,240
we're left with this part okay and what

390
00:16:46,110 --> 00:16:50,850
you can see here is all of these are

391
00:16:48,240 --> 00:16:53,100
just inner products with n right and so

392
00:16:50,850 --> 00:16:55,950
we could actually keep the control flow

393
00:16:53,100 --> 00:16:57,330
fairly similar if you look at what's

394
00:16:55,950 --> 00:17:00,420
happening in each of these channels

395
00:16:57,330 --> 00:17:03,180
because it's not that complicated as to

396
00:17:00,419 --> 00:17:05,818
what's going on in the result at the end

397
00:17:03,179 --> 00:17:07,859
so if we take a look at what we would

398
00:17:05,818 --> 00:17:09,990
produce for each of these you can sort

399
00:17:07,859 --> 00:17:12,869
of imagine expanding one of these out

400
00:17:09,990 --> 00:17:14,549
and because in each case it's minus zero

401
00:17:12,869 --> 00:17:17,818
or one there's never anything else

402
00:17:14,549 --> 00:17:19,879
that's - so it's always fairly

403
00:17:17,818 --> 00:17:24,149
straightforward as to what's actually

404
00:17:19,880 --> 00:17:25,910
happening there right so if we look at

405
00:17:24,150 --> 00:17:29,490
the series of operation that's

406
00:17:25,910 --> 00:17:30,990
operations that's going to happen each

407
00:17:29,490 --> 00:17:34,279
one of these is actually doing

408
00:17:30,990 --> 00:17:39,058
effectively the same thing it's taking

409
00:17:34,279 --> 00:17:42,778
uvw X right UVW Y you

410
00:17:39,058 --> 00:17:46,288
you see in each case right and it's

411
00:17:42,778 --> 00:17:48,898
subtracting from them something right so

412
00:17:46,288 --> 00:17:53,730
it's either subtracting zero or it's

413
00:17:48,898 --> 00:17:58,768
subtracting one in each case for each of

414
00:17:53,730 --> 00:18:00,720
these then it's doing four for after

415
00:17:58,769 --> 00:18:02,940
we've done that it's doing various

416
00:18:00,720 --> 00:18:08,788
products with those in occlusion n right

417
00:18:02,940 --> 00:18:11,519
so after it does that in each case we're

418
00:18:08,788 --> 00:18:17,099
doing times the corresponding member of

419
00:18:11,519 --> 00:18:20,519
occlusion n right and then we're just

420
00:18:17,099 --> 00:18:24,509
summing those up so each one of these is

421
00:18:20,519 --> 00:18:26,038
like a plus so that's really very

422
00:18:24,509 --> 00:18:30,058
straightforward for us to actually

423
00:18:26,038 --> 00:18:32,638
implement in fact right because we can

424
00:18:30,058 --> 00:18:36,648
literally just do that as like a series

425
00:18:32,638 --> 00:18:41,699
of steps one right after the other and

426
00:18:36,648 --> 00:18:45,469
we probably don't have to really do much

427
00:18:41,700 --> 00:18:49,319
else to be completely honest with you

428
00:18:45,470 --> 00:18:52,409
let's take a look here so like you can

429
00:18:49,319 --> 00:18:54,538
see that the X is a 0 1 0 pattern and

430
00:18:52,409 --> 00:19:00,028
that's pretty easy for us to make right

431
00:18:54,538 --> 00:19:03,240
so we can do something like this where

432
00:19:00,028 --> 00:19:06,720
we just try to load that up so it's like

433
00:19:03,240 --> 00:19:12,329
that right

434
00:19:06,720 --> 00:19:15,868
I don't know it seems pretty easy and so

435
00:19:12,329 --> 00:19:25,128
we know we have 0 1 0 pattern of 0 0 1 1

436
00:19:15,868 --> 00:19:25,128
pattern you know what

437
00:19:27,730 --> 00:19:33,470
how about that little easier to read

438
00:19:30,200 --> 00:19:37,970
right so we have a 0 0 1 1 pattern and

439
00:19:33,470 --> 00:19:40,490
then we have a well we just have 0 &amp; 1

440
00:19:37,970 --> 00:19:41,960
which we kind of already know we wanted

441
00:19:40,490 --> 00:19:44,599
because we actually use those for

442
00:19:41,960 --> 00:19:46,900
clamping and it should be able to do the

443
00:19:44,599 --> 00:19:50,149
basic common sub-expression elimination

444
00:19:46,900 --> 00:19:51,590
for that so I don't anticipate us having

445
00:19:50,150 --> 00:19:53,150
to go out of our way to make sure that

446
00:19:51,589 --> 00:19:55,609
the thing knows that doesn't have to

447
00:19:53,150 --> 00:19:57,950
produce those values like it should know

448
00:19:55,609 --> 00:19:59,179
in general that zero can just be an X or

449
00:19:57,950 --> 00:20:03,440
register free clear

450
00:19:59,180 --> 00:20:05,779
I hope Microsoft's optimizer at this

451
00:20:03,440 --> 00:20:07,910
point is really just struggles a lot

452
00:20:05,779 --> 00:20:10,190
with sim D code doesn't really

453
00:20:07,910 --> 00:20:12,950
understand it doesn't know some of the

454
00:20:10,190 --> 00:20:15,860
basic things that you would want it to

455
00:20:12,950 --> 00:20:17,960
know and so because we're on like clang

456
00:20:15,859 --> 00:20:23,899
does a much better job with this with

457
00:20:17,960 --> 00:20:28,370
SSE code Visual Studio really struggles

458
00:20:23,900 --> 00:20:31,610
with it it really has a hard time so you

459
00:20:28,369 --> 00:20:36,829
know like I'm saying that but it's not

460
00:20:31,609 --> 00:20:38,899
necessarily true but anyway so in this

461
00:20:36,829 --> 00:20:40,879
case we have 0 &amp; 1 we don't really need

462
00:20:38,900 --> 00:20:42,560
the 0 we might need it for other things

463
00:20:40,880 --> 00:20:45,020
later but we don't need to run a

464
00:20:42,559 --> 00:20:47,509
subtraction pass for 0 right because

465
00:20:45,019 --> 00:20:49,759
that doesn't do anything so we only

466
00:20:47,509 --> 00:20:52,339
really need the 1 here so these are the

467
00:20:49,759 --> 00:20:54,980
three things that we actually needed and

468
00:20:52,339 --> 00:20:56,959
then if we go ahead and create like I

469
00:20:54,980 --> 00:20:58,940
said exactly what we actually wanted to

470
00:20:56,960 --> 00:21:02,960
do here it's actually not that hard

471
00:20:58,940 --> 00:21:05,720
right if we assume that UVW has been

472
00:21:02,960 --> 00:21:07,700
broadcasted out so you know this is this

473
00:21:05,720 --> 00:21:11,329
is that part of the code that we would

474
00:21:07,700 --> 00:21:13,580
actually need we have a 1 - u VW but we

475
00:21:11,329 --> 00:21:16,250
don't have a u VW minus 1 unfortunately

476
00:21:13,579 --> 00:21:19,549
they're you know not quite the same so

477
00:21:16,250 --> 00:21:22,369
if we start up here and we say here's

478
00:21:19,549 --> 00:21:24,980
the code that we need to do to produce

479
00:21:22,369 --> 00:21:27,079
the UVW and then we just do the

480
00:21:24,980 --> 00:21:30,890
broadcast so that the u VW's are kind of

481
00:21:27,079 --> 00:21:34,289
out again i don't really know if there's

482
00:21:30,890 --> 00:21:39,750
something we can do here to make this

483
00:21:34,289 --> 00:21:41,369
stuff go cleaner I don't think there is

484
00:21:39,750 --> 00:21:44,250
because it seems like you really want to

485
00:21:41,369 --> 00:21:47,549
do these here but it's possible that you

486
00:21:44,250 --> 00:21:49,319
could untwist your you VW's in some way

487
00:21:47,549 --> 00:21:52,889
I don't know we can think about the

488
00:21:49,319 --> 00:21:54,059
bottom half of the routine later someone

489
00:21:52,890 --> 00:21:55,410
asked yesterday whether it makes more

490
00:21:54,059 --> 00:21:58,200
sense to do the bottom half with you

491
00:21:55,410 --> 00:22:00,470
VW's replicated and I just don't know we

492
00:21:58,200 --> 00:22:03,500
could just look and see if it does

493
00:22:00,470 --> 00:22:07,410
because I don't know if it does or not

494
00:22:03,500 --> 00:22:09,900
so anyway so up here you can see if we

495
00:22:07,410 --> 00:22:12,029
wanted to do a replication pass now then

496
00:22:09,900 --> 00:22:14,880
basically what we would have is uvw X

497
00:22:12,029 --> 00:22:18,720
right but we can just call those UV and

498
00:22:14,880 --> 00:22:21,480
W because that's what they are so these

499
00:22:18,720 --> 00:22:23,339
would just be what are they broadcast

500
00:22:21,480 --> 00:22:26,130
works yeah so these are just broadcast

501
00:22:23,339 --> 00:22:30,509
for X instructions that broadcast the

502
00:22:26,130 --> 00:22:33,830
various values out so here we've

503
00:22:30,509 --> 00:22:35,910
extracted the different components and

504
00:22:33,829 --> 00:22:41,879
then all we need to do is actually do

505
00:22:35,910 --> 00:22:45,060
this computation so for c03 if we take a

506
00:22:41,880 --> 00:22:50,070
look at what we're doing we want to

507
00:22:45,059 --> 00:22:54,899
subtract 0 1 0 from X so we have 0 1 0

508
00:22:50,069 --> 00:22:57,990
so we want you - right that's the X part

509
00:22:54,900 --> 00:23:02,670
and the X part is then going to get

510
00:22:57,990 --> 00:23:04,980
multiplied by occlusion NX right so here

511
00:23:02,670 --> 00:23:08,640
I probably need something that's called

512
00:23:04,980 --> 00:23:13,069
you know o n X right or something like

513
00:23:08,640 --> 00:23:16,860
this because again that's going to be a

514
00:23:13,069 --> 00:23:20,069
we need to replicate that value out if

515
00:23:16,859 --> 00:23:22,199
we want that to work right so we're

516
00:23:20,069 --> 00:23:24,689
gonna have to multiply by that and then

517
00:23:22,200 --> 00:23:30,590
we do the Y pass next so that's the

518
00:23:24,690 --> 00:23:30,590
Pat's 0 0 1 1 times ony

519
00:23:31,390 --> 00:23:38,020
and then the final one is the W and this

520
00:23:36,279 --> 00:23:39,160
would be minus zero but in this case we

521
00:23:38,019 --> 00:23:41,470
don't actually have to do that

522
00:23:39,160 --> 00:23:45,279
so it's literally just gonna be W times

523
00:23:41,470 --> 00:23:47,230
the onz right and I think that should

524
00:23:45,279 --> 00:23:49,599
get us what we want right because here's

525
00:23:47,230 --> 00:23:53,230
the zero one zero so we're - in that

526
00:23:49,599 --> 00:23:55,750
part apiece this C zero three and then

527
00:23:53,230 --> 00:23:57,250
here we're doing the V - to produce zero

528
00:23:55,750 --> 00:23:58,539
one one and then times the collision and

529
00:23:57,250 --> 00:24:01,750
right so you can see it's it's pretty

530
00:23:58,539 --> 00:24:04,690
straightforward the next one is exactly

531
00:24:01,750 --> 00:24:08,170
the same actually and so when we look at

532
00:24:04,690 --> 00:24:10,570
what's happening here we should be able

533
00:24:08,170 --> 00:24:12,880
to just factor this out right because

534
00:24:10,569 --> 00:24:22,049
you can see that this it's either gonna

535
00:24:12,880 --> 00:24:26,280
add that where is the value it's just 1

536
00:24:22,049 --> 00:24:31,089
so it's either gonna add that or that

537
00:24:26,279 --> 00:24:32,950
right that's all that's gonna happen and

538
00:24:31,089 --> 00:24:36,250
if you take a look at what this

539
00:24:32,950 --> 00:24:40,180
expression would presumably produce at

540
00:24:36,250 --> 00:24:42,730
that point at least unless I'm sorely

541
00:24:40,180 --> 00:24:45,549
mistaken if you multiple if you're just

542
00:24:42,730 --> 00:24:48,990
distributive property this sausage

543
00:24:45,549 --> 00:24:56,069
gentlemen here it should just be that

544
00:24:48,990 --> 00:24:59,109
right which is the same as that yeah I

545
00:24:56,069 --> 00:25:03,279
mean at least that's what it looks like

546
00:24:59,109 --> 00:25:07,299
to me so I I don't see anything else

547
00:25:03,279 --> 00:25:10,170
there that's particularly interesting I

548
00:25:07,299 --> 00:25:12,730
mean that just looks fine so I think

549
00:25:10,170 --> 00:25:16,840
these two values are actually the same

550
00:25:12,730 --> 00:25:21,059
right and all we have to do is say well

551
00:25:16,839 --> 00:25:23,649
in order to get the c-47 one you just do

552
00:25:21,059 --> 00:25:26,679
the you know it's just the same as this

553
00:25:23,650 --> 00:25:32,769
and before you clamp it you just do an

554
00:25:26,680 --> 00:25:35,460
offset of the onz value right so I think

555
00:25:32,769 --> 00:25:35,460
that's fine

556
00:25:36,250 --> 00:25:48,319
and again like just a lot of broadcasts

557
00:25:39,679 --> 00:25:50,150
here and it's not great but one of the

558
00:25:48,319 --> 00:25:52,490
things you have to remember is the not

559
00:25:50,150 --> 00:25:54,019
greatness of this may be mitigated by

560
00:25:52,490 --> 00:25:56,569
the fact that this may already actually

561
00:25:54,019 --> 00:25:59,629
exist so if you take a look this

562
00:25:56,569 --> 00:26:01,519
broadcast oh well but if you take a look

563
00:25:59,630 --> 00:26:03,770
at what happens with the other broadcast

564
00:26:01,519 --> 00:26:07,490
well down here where we actually process

565
00:26:03,769 --> 00:26:13,279
the hit what you can kind of see is that

566
00:26:07,490 --> 00:26:16,730
where we do the compute values at the

567
00:26:13,279 --> 00:26:19,910
occlusion D and the probe sample ends

568
00:26:16,730 --> 00:26:22,099
single here one of the things you can

569
00:26:19,910 --> 00:26:24,890
see is they're actually coming from

570
00:26:22,099 --> 00:26:29,359
things that probably were already

571
00:26:24,890 --> 00:26:31,640
duplicated and spread because we

572
00:26:29,359 --> 00:26:34,159
probably already P shift B some of these

573
00:26:31,640 --> 00:26:36,380
things anyway and if you already P chef

574
00:26:34,160 --> 00:26:37,970
to be them they're already in order so

575
00:26:36,380 --> 00:26:40,640
we may actually be able to do eliminate

576
00:26:37,970 --> 00:26:43,789
some of the pressure on port five on

577
00:26:40,640 --> 00:26:47,150
skylake by just recognizing that we

578
00:26:43,789 --> 00:26:49,879
already freaking did it right so some of

579
00:26:47,150 --> 00:26:52,509
these may be duplicated and I'll just

580
00:26:49,880 --> 00:26:52,510
make a note of that

581
00:27:07,069 --> 00:27:13,558
and so it's entirely possible that we

582
00:27:10,890 --> 00:27:17,040
can do you know like I said a much

583
00:27:13,558 --> 00:27:18,599
faster sample by just eliminating a ton

584
00:27:17,039 --> 00:27:19,980
of the port 5 pressure here because we

585
00:27:18,599 --> 00:27:25,668
may already have those things replicated

586
00:27:19,980 --> 00:27:27,960
in their own channels right so so again

587
00:27:25,669 --> 00:27:30,390
you can see why I think there's gonna be

588
00:27:27,960 --> 00:27:31,710
a lot of a speed wind to be had here

589
00:27:30,390 --> 00:27:33,030
because the compiler wasn't doing a

590
00:27:31,710 --> 00:27:35,220
particularly good job on it and if you

591
00:27:33,029 --> 00:27:37,109
look at you know with the exception of

592
00:27:35,220 --> 00:27:38,519
maybe the broadcast instructions which

593
00:27:37,109 --> 00:27:41,039
are kind of annoying in line up behind

594
00:27:38,519 --> 00:27:42,629
port 5 if you look at what else is

595
00:27:41,039 --> 00:27:45,029
happening here these are just constants

596
00:27:42,630 --> 00:27:46,530
they can be done with memory ops even so

597
00:27:45,029 --> 00:27:49,759
if you look at this it's like one two

598
00:27:46,529 --> 00:27:52,649
three four five six seven operations

599
00:27:49,759 --> 00:27:54,298
seven total like instructions there

600
00:27:52,650 --> 00:27:57,720
right

601
00:27:54,298 --> 00:28:01,079
to replicate this entire thing and this

602
00:27:57,720 --> 00:28:02,308
entire thing like this alone just

603
00:28:01,079 --> 00:28:05,069
calling that would have probably been

604
00:28:02,308 --> 00:28:06,869
about seven instructions right just

605
00:28:05,069 --> 00:28:10,139
welding in that part of the equation and

606
00:28:06,869 --> 00:28:11,819
so you know we're talking about you know

607
00:28:10,140 --> 00:28:13,710
could be as much as eight times faster

608
00:28:11,819 --> 00:28:15,779
just doing this here and that's before

609
00:28:13,710 --> 00:28:17,400
the Clint wiet the clamp was in here too

610
00:28:15,779 --> 00:28:18,509
so this could be this could be many

611
00:28:17,400 --> 00:28:20,730
times faster right

612
00:28:18,509 --> 00:28:24,470
so again just writing it sensibly giving

613
00:28:20,730 --> 00:28:24,470
the compiler a chance to do okay

614
00:28:39,369 --> 00:28:52,669
all right hmm what is going on chat over

615
00:28:46,009 --> 00:29:01,609
there everyone calm down

616
00:28:52,670 --> 00:29:04,970
um all right so in here I think I now

617
00:29:01,609 --> 00:29:06,799
have just about all of the computation

618
00:29:04,970 --> 00:29:12,500
stuff done let me get rid of this stuff

619
00:29:06,799 --> 00:29:14,899
for a moment and all of this code is

620
00:29:12,500 --> 00:29:16,849
actually real with the exception of the

621
00:29:14,900 --> 00:29:18,590
MM floor that I stuck in there that

622
00:29:16,849 --> 00:29:20,209
actually probably wants to go into an

623
00:29:18,589 --> 00:29:24,740
actual function right because I don't

624
00:29:20,210 --> 00:29:27,558
think we ever put an mm floor PS in here

625
00:29:24,740 --> 00:29:30,440
and we should have but we just didn't

626
00:29:27,558 --> 00:29:32,149
right it looks like we have a set zero

627
00:29:30,440 --> 00:29:38,330
in here so I probably should do that one

628
00:29:32,150 --> 00:29:39,980
actually let me just drop that in and

629
00:29:38,329 --> 00:29:41,569
that's just because again I don't know

630
00:29:39,980 --> 00:29:44,929
how done the compiler is I don't know if

631
00:29:41,569 --> 00:29:46,730
this if it reliably detects loads of

632
00:29:44,929 --> 00:29:48,710
zero and replaces them with X source or

633
00:29:46,730 --> 00:29:57,920
other reasonable ways of clearing the

634
00:29:48,710 --> 00:29:59,808
register so yeah so we're good also by

635
00:29:57,920 --> 00:30:00,890
the way chat no I did not delete from

636
00:29:59,808 --> 00:30:06,710
the original code this is the original

637
00:30:00,890 --> 00:30:11,210
code right all right so anyway if we go

638
00:30:06,710 --> 00:30:16,069
ahead and look at what we've got here we

639
00:30:11,210 --> 00:30:18,558
just never added a floor function to

640
00:30:16,069 --> 00:30:23,450
this for reasons that I don't actually

641
00:30:18,558 --> 00:30:25,609
know what they are so yeah I don't know

642
00:30:23,450 --> 00:30:28,610
we haven't really done a particularly

643
00:30:25,609 --> 00:30:30,019
good attempt at assembly library here it

644
00:30:28,609 --> 00:30:32,899
was just kind of whatever we needed at

645
00:30:30,019 --> 00:30:35,150
the time so that's fine but if we want

646
00:30:32,900 --> 00:30:38,300
to make this a little bit more complete

647
00:30:35,150 --> 00:30:40,759
here we should have a floor for sure

648
00:30:38,299 --> 00:30:42,169
because we use it all the time and so if

649
00:30:40,759 --> 00:30:43,609
we want to do that it's pretty

650
00:30:42,170 --> 00:30:45,529
straightforward again it's literally

651
00:30:43,609 --> 00:30:49,178
just the same as any one of these there

652
00:30:45,529 --> 00:30:49,178
we're just proxying you

653
00:30:49,930 --> 00:30:58,700
the floor function right and I don't

654
00:30:54,589 --> 00:31:00,429
know so if we look I don't remember this

655
00:30:58,700 --> 00:31:04,370
is an ssa whoa hello

656
00:31:00,430 --> 00:31:06,620
so if you look at mm floor PS it is a

657
00:31:04,369 --> 00:31:08,149
higher end function but I think we

658
00:31:06,619 --> 00:31:10,399
already decided we are using the later

659
00:31:08,150 --> 00:31:11,900
SSC stuff at least at the moment and if

660
00:31:10,400 --> 00:31:13,730
we have to downgrade it later I guess we

661
00:31:11,900 --> 00:31:16,250
will but you can see here that you know

662
00:31:13,730 --> 00:31:21,769
this just does the basic floor operation

663
00:31:16,250 --> 00:31:23,539
it's what you want so you know we can

664
00:31:21,769 --> 00:31:25,279
just use it directly and and it's pretty

665
00:31:23,539 --> 00:31:27,740
much available on just about everything

666
00:31:25,279 --> 00:31:29,359
that we'll probably ever ship on at

667
00:31:27,740 --> 00:31:30,829
least that could possibly run this

668
00:31:29,359 --> 00:31:32,299
lighting right because this is a pretty

669
00:31:30,829 --> 00:31:34,609
heavyweight thing so you're not gonna be

670
00:31:32,299 --> 00:31:37,930
running this lighting on like 15 year

671
00:31:34,609 --> 00:31:42,819
old machines that's not gonna fly

672
00:31:37,930 --> 00:31:49,910
okay I don't know why C is still here

673
00:31:42,819 --> 00:31:52,189
that okay so now we've got a couple

674
00:31:49,910 --> 00:31:54,470
things we got to do so first of all

675
00:31:52,190 --> 00:31:55,820
these loads don't actually really exist

676
00:31:54,470 --> 00:31:58,190
at all so we're gonna have to actually

677
00:31:55,819 --> 00:32:00,619
fix we're gonna have to eventually fix

678
00:31:58,190 --> 00:32:04,009
those I don't know what's it complaining

679
00:32:00,619 --> 00:32:07,129
about for this the question of W oh I've

680
00:32:04,009 --> 00:32:10,910
already got a W up here I guess that

681
00:32:07,130 --> 00:32:15,290
somebody's using is that true yes we

682
00:32:10,910 --> 00:32:17,900
were using that for the weights so maybe

683
00:32:15,289 --> 00:32:20,109
UVW was not the best choice thing even

684
00:32:17,900 --> 00:32:22,730
though that's what those actually were

685
00:32:20,109 --> 00:32:23,629
that's a little bit of an issue so you

686
00:32:22,730 --> 00:32:27,620
know oops

687
00:32:23,630 --> 00:32:29,740
but I guess I can just use lowercase for

688
00:32:27,619 --> 00:32:29,739
now

689
00:32:33,119 --> 00:32:38,119
here we come and so if we take a look at

690
00:32:36,630 --> 00:32:46,110
what we've got here it looks like

691
00:32:38,119 --> 00:32:49,379
occlusion and he is not a member of what

692
00:32:46,109 --> 00:32:51,719
is it complaining about you Oh cuz

693
00:32:49,380 --> 00:32:55,110
occlusion and is actually just a regular

694
00:32:51,720 --> 00:32:58,410
v3 okay so yeah in this case we don't

695
00:32:55,109 --> 00:33:00,779
actually have an F and F 3 v4 for this

696
00:32:58,410 --> 00:33:02,370
it's actually just a regular v3 so at

697
00:33:00,779 --> 00:33:04,200
the moment I guess what we would

698
00:33:02,369 --> 00:33:06,209
probably want to do is actually just use

699
00:33:04,200 --> 00:33:08,340
our load function it's not a broadcast

700
00:33:06,210 --> 00:33:11,370
it's an actual load because this is not

701
00:33:08,339 --> 00:33:13,259
coming from like the to do says it's not

702
00:33:11,369 --> 00:33:14,969
coming from the actual correct place you

703
00:33:13,259 --> 00:33:16,650
can see here we've got a set one PS in

704
00:33:14,970 --> 00:33:24,210
there so we should be able to just do

705
00:33:16,650 --> 00:33:28,559
like f3 load on that like so and that's

706
00:33:24,210 --> 00:33:31,289
fine so that'll do and so let's take a

707
00:33:28,558 --> 00:33:35,099
look down here so what's the problem

708
00:33:31,289 --> 00:33:39,139
undeclared identifier good point didn't

709
00:33:35,099 --> 00:33:39,139
tell the compiler about that one my bad

710
00:33:41,869 --> 00:33:46,439
so again problem with just the fact that

711
00:33:44,759 --> 00:33:49,650
we called this some I was trying to have

712
00:33:46,440 --> 00:33:51,990
these line up and so I'll just call this

713
00:33:49,650 --> 00:33:54,240
some zero because it's fine and I'll

714
00:33:51,990 --> 00:33:55,890
call this inves some zero and again

715
00:33:54,240 --> 00:33:58,019
that's really just normally we wouldn't

716
00:33:55,890 --> 00:33:59,850
have the same code twice but it's just

717
00:33:58,019 --> 00:34:01,379
for verification purposes I would prefer

718
00:33:59,849 --> 00:34:04,769
that so I'm going to leave it that way

719
00:34:01,380 --> 00:34:07,080
for now we don't have any of the tile

720
00:34:04,769 --> 00:34:09,509
samples that we need so that's fine and

721
00:34:07,079 --> 00:34:11,460
then at the end here it looks like we

722
00:34:09,510 --> 00:34:13,169
just probably want to do because we're

723
00:34:11,460 --> 00:34:14,398
gonna use this for testing so this is

724
00:34:13,168 --> 00:34:16,769
really just going to be called check

725
00:34:14,398 --> 00:34:19,980
probably because we're just gonna use it

726
00:34:16,769 --> 00:34:21,418
to check our answer so the only thing

727
00:34:19,980 --> 00:34:23,820
we're really missing is we have to load

728
00:34:21,418 --> 00:34:26,309
in the initial values this by the way

729
00:34:23,820 --> 00:34:32,129
needs to be the floor function that I

730
00:34:26,309 --> 00:34:34,349
just implemented and this UVW here again

731
00:34:32,128 --> 00:34:37,019
we have that that hiding problem which

732
00:34:34,349 --> 00:34:39,029
is kind of annoying but yeah I'm not

733
00:34:37,019 --> 00:34:41,099
sure what I want to do about that

734
00:34:39,030 --> 00:34:43,379
I'm just kind of hacking this in right

735
00:34:41,099 --> 00:34:44,940
now because I don't I don't really want

736
00:34:43,378 --> 00:34:47,128
to change the names of these I want them

737
00:34:44,940 --> 00:34:48,450
to stay the same but

738
00:34:47,128 --> 00:34:51,568
there's not a lot I can really do about

739
00:34:48,449 --> 00:34:52,918
it right now because I I want them you

740
00:34:51,568 --> 00:34:55,288
know I would just turn that error off

741
00:34:52,918 --> 00:34:56,788
but I like that error normally so I'm

742
00:34:55,289 --> 00:34:58,650
just going to hide their names real

743
00:34:56,789 --> 00:35:00,480
quick and then we can restore the names

744
00:34:58,650 --> 00:35:01,950
later once I pull out the older teen

745
00:35:00,480 --> 00:35:06,599
because we're not going to run them both

746
00:35:01,949 --> 00:35:09,808
in place you know forever so now we just

747
00:35:06,599 --> 00:35:11,250
have loading which we have to do right I

748
00:35:09,809 --> 00:35:13,920
actually don't know what's wrong with

749
00:35:11,250 --> 00:35:15,298
this one though Oh inva seldom is not

750
00:35:13,920 --> 00:35:18,119
supposed to be off of grid it's supposed

751
00:35:15,298 --> 00:35:21,268
to be using these so we just have to

752
00:35:18,119 --> 00:35:22,619
load in our initial values now and then

753
00:35:21,268 --> 00:35:27,239
we have to figure out a way to get our

754
00:35:22,619 --> 00:35:28,650
tile information in here right and like

755
00:35:27,239 --> 00:35:29,669
I said getting the tile information in

756
00:35:28,650 --> 00:35:31,259
here is probably going to be the worst

757
00:35:29,670 --> 00:35:33,509
part you can see that now this has been

758
00:35:31,259 --> 00:35:35,670
streamlined to at least a first

759
00:35:33,509 --> 00:35:37,528
approximation there's actually not very

760
00:35:35,670 --> 00:35:38,568
many instructions in here compared to

761
00:35:37,528 --> 00:35:40,619
how many there were

762
00:35:38,568 --> 00:35:43,349
could we do better than what we've got

763
00:35:40,619 --> 00:35:45,390
here absolutely you know there's a lot

764
00:35:43,349 --> 00:35:48,298
of broadcasting in here and there's no

765
00:35:45,389 --> 00:35:54,179
question that we could improve how this

766
00:35:48,298 --> 00:35:57,298
is actually working so I mean just to

767
00:35:54,179 --> 00:35:59,669
give a simple example you know this is

768
00:35:57,298 --> 00:36:01,349
this is also kind of why program stream

769
00:35:59,670 --> 00:36:02,789
was kind of hard so I would probably

770
00:36:01,349 --> 00:36:03,900
never have written this if I wasn't

771
00:36:02,789 --> 00:36:05,579
programming on stream it's just it's

772
00:36:03,900 --> 00:36:06,960
hard for my brain to keep up sometimes

773
00:36:05,579 --> 00:36:08,579
when trying to explain things and do

774
00:36:06,960 --> 00:36:09,778
them your that part of your brain that

775
00:36:08,579 --> 00:36:11,880
would be a little bit more creative and

776
00:36:09,778 --> 00:36:15,420
a little bit more observant is not

777
00:36:11,880 --> 00:36:17,160
really capable of delivering what it

778
00:36:15,420 --> 00:36:18,630
normally would but you can see that this

779
00:36:17,159 --> 00:36:20,489
is really stupid right because what's

780
00:36:18,630 --> 00:36:21,809
what do we do here well we broadcast out

781
00:36:20,489 --> 00:36:23,729
these things 8 wide and then we

782
00:36:21,809 --> 00:36:24,900
immediately send them together it

783
00:36:23,730 --> 00:36:26,608
doesn't really make any sense because

784
00:36:24,900 --> 00:36:30,930
why wouldn't you just add them together

785
00:36:26,608 --> 00:36:33,028
first right so you know the sensible

786
00:36:30,929 --> 00:36:37,500
thing to do here would be just to do

787
00:36:33,028 --> 00:36:44,670
like you know that or something and and

788
00:36:37,500 --> 00:36:48,059
add these to write some kind of a

789
00:36:44,670 --> 00:36:50,900
composite because that takes care of

790
00:36:48,059 --> 00:36:54,240
this first round of pluses right away

791
00:36:50,900 --> 00:36:56,309
you and I'm saying so it don't make no

792
00:36:54,239 --> 00:36:58,139
sense like I don't know why you would

793
00:36:56,309 --> 00:37:00,600
ever do that

794
00:36:58,139 --> 00:37:03,210
there's there's no point there's no

795
00:37:00,599 --> 00:37:07,039
point to it right because you might as

796
00:37:03,210 --> 00:37:09,480
well start with just one with one vector

797
00:37:07,039 --> 00:37:10,590
instead of two I mean I did you know

798
00:37:09,480 --> 00:37:13,590
what I'm saying like this doesn't make

799
00:37:10,590 --> 00:37:17,400
any sense so this is is silly and I'm

800
00:37:13,590 --> 00:37:19,380
not sure why we were broadcasting out

801
00:37:17,400 --> 00:37:21,059
instead of just adding first because

802
00:37:19,380 --> 00:37:23,519
since you know you're gonna add all of

803
00:37:21,059 --> 00:37:26,549
these things together that's what you

804
00:37:23,519 --> 00:37:27,869
would do um so at that point we we

805
00:37:26,550 --> 00:37:30,180
actually probably want to look at a

806
00:37:27,869 --> 00:37:31,920
different broadcast seem right and we

807
00:37:30,179 --> 00:37:33,750
could still broadcast this way meaning

808
00:37:31,920 --> 00:37:37,320
we could just broadcast these out like

809
00:37:33,750 --> 00:37:41,579
this and then sum them right but again

810
00:37:37,320 --> 00:37:43,800
you would only need to do just you would

811
00:37:41,579 --> 00:37:46,739
only need to do this one step right so

812
00:37:43,800 --> 00:37:49,890
it would be first you'd sum to 0 1 and

813
00:37:46,739 --> 00:37:53,579
then you would sum the zero one and the

814
00:37:49,889 --> 00:37:56,009
two three together and and that would

815
00:37:53,579 --> 00:37:58,110
that would be it right there isn't a

816
00:37:56,010 --> 00:38:01,020
there isn't another sum because now

817
00:37:58,110 --> 00:38:13,530
you've added everything that you needed

818
00:38:01,019 --> 00:38:14,730
to add right so again just tons of fat

819
00:38:13,530 --> 00:38:15,960
in here these are not the kinds of

820
00:38:14,730 --> 00:38:18,139
routines you can really write on stream

821
00:38:15,960 --> 00:38:18,139
bro

822
00:38:19,489 --> 00:38:27,929
that general thing so I'll just sort of

823
00:38:23,280 --> 00:38:30,300
say a sort of a separate philosophical

824
00:38:27,929 --> 00:38:33,869
point here so one of the reasons that

825
00:38:30,300 --> 00:38:35,640
sim D is a crap instruction set is all

826
00:38:33,869 --> 00:38:40,019
of this crap that I'm doing here right

827
00:38:35,639 --> 00:38:42,710
so in order to create good sim decode

828
00:38:40,019 --> 00:38:45,179
you actually need to be thinking and

829
00:38:42,710 --> 00:38:47,400
when a human being needs to be thinking

830
00:38:45,179 --> 00:38:49,259
that also means the compiler needs to be

831
00:38:47,400 --> 00:38:51,900
thinking and both of those things are

832
00:38:49,260 --> 00:38:53,550
expensive it costs to have a human being

833
00:38:51,900 --> 00:38:56,490
spend time thinking about this routine

834
00:38:53,550 --> 00:38:58,320
it costs to have compiler vendors have

835
00:38:56,489 --> 00:39:02,369
to try and figure out how to do that

836
00:38:58,320 --> 00:39:05,760
sort of thinking in code and as a result

837
00:39:02,369 --> 00:39:07,920
the the binary is produced by modern

838
00:39:05,760 --> 00:39:10,410
compilers have a hard time taking

839
00:39:07,920 --> 00:39:11,840
advantage of sim D with the SSE

840
00:39:10,409 --> 00:39:14,759
instruction set

841
00:39:11,840 --> 00:39:18,690
if you compare that to something like

842
00:39:14,760 --> 00:39:21,810
avx-512 one of the reasons that a lot of

843
00:39:18,690 --> 00:39:23,760
programmers like the avx-512 instruction

844
00:39:21,809 --> 00:39:24,659
set is because it's actually complete

845
00:39:23,760 --> 00:39:28,140
instruction set

846
00:39:24,659 --> 00:39:31,909
it has scatter gather so it can bind and

847
00:39:28,139 --> 00:39:34,379
unbind stuff to the right lanes without

848
00:39:31,909 --> 00:39:36,929
having ridiculous pattern shuffle

849
00:39:34,380 --> 00:39:39,450
questions abound

850
00:39:36,929 --> 00:39:41,460
it has masking so it can do branching

851
00:39:39,449 --> 00:39:45,480
properly without having to worry too

852
00:39:41,460 --> 00:39:49,619
much about what's going on and without

853
00:39:45,480 --> 00:39:52,320
costing registers it's just easy to like

854
00:39:49,619 --> 00:39:54,690
if you have a piece of code and if in

855
00:39:52,320 --> 00:39:58,440
you had a full performance avx-512

856
00:39:54,690 --> 00:40:01,440
pipeline it's actually really

857
00:39:58,440 --> 00:40:04,980
straightforward to change the code into

858
00:40:01,440 --> 00:40:09,329
that format right whereas getting

859
00:40:04,980 --> 00:40:10,920
optimal SSE for code from a routine is

860
00:40:09,329 --> 00:40:12,420
actually something that requires a

861
00:40:10,920 --> 00:40:15,780
trained professional to a certain degree

862
00:40:12,420 --> 00:40:17,610
and we're doing a basic job of

863
00:40:15,780 --> 00:40:19,380
transforming this routine right now but

864
00:40:17,610 --> 00:40:21,000
I guarantee you it is a far cry from

865
00:40:19,380 --> 00:40:23,640
what I probably could do if I sat down

866
00:40:21,000 --> 00:40:26,099
and thought about this code exclusively

867
00:40:23,639 --> 00:40:28,829
for a weekend I could do a much better

868
00:40:26,099 --> 00:40:34,219
job and so that's just not a good

869
00:40:28,829 --> 00:40:37,829
instruction set right because the more

870
00:40:34,219 --> 00:40:41,279
like the more Rockstar assembly language

871
00:40:37,829 --> 00:40:42,779
jockey you have to be to get maximum

872
00:40:41,280 --> 00:40:45,510
performance out of an instruction set

873
00:40:42,780 --> 00:40:47,130
the worse it is because only so many

874
00:40:45,510 --> 00:40:48,960
people are capable of doing that and

875
00:40:47,130 --> 00:40:51,030
even the people who are capable of doing

876
00:40:48,960 --> 00:40:54,599
that can only afford to do it on so many

877
00:40:51,030 --> 00:40:57,180
pieces of code right and so it's just

878
00:40:54,599 --> 00:40:58,949
SSE is a very bad instruction set it's

879
00:40:57,179 --> 00:41:02,579
one of the worst wide instruction sets

880
00:40:58,949 --> 00:41:03,779
I've seen avx-512 is significantly

881
00:41:02,579 --> 00:41:07,920
better unfortunately it doesn't

882
00:41:03,780 --> 00:41:11,670
currently exist really in most CPUs that

883
00:41:07,920 --> 00:41:14,340
anyone has and neon is much better as

884
00:41:11,670 --> 00:41:16,710
well so neon did this stuff much closer

885
00:41:14,340 --> 00:41:19,740
to like how avx-512 sort of does it and

886
00:41:16,710 --> 00:41:21,389
so if you're using an arm neon chip and

887
00:41:19,739 --> 00:41:24,329
modern our neon chip it doesn't have

888
00:41:21,389 --> 00:41:25,500
these problems either so it's just worth

889
00:41:24,329 --> 00:41:27,539
noting that we happen

890
00:41:25,500 --> 00:41:32,070
programming on the worst instruction set

891
00:41:27,539 --> 00:41:33,630
designed the most poorly an SSC as far

892
00:41:32,070 --> 00:41:35,610
as I can tell was mostly just designed

893
00:41:33,630 --> 00:41:37,320
to make Intel's engineering job easier

894
00:41:35,610 --> 00:41:38,789
and not really designed to have

895
00:41:37,320 --> 00:41:40,800
programmers actually be able to output

896
00:41:38,789 --> 00:41:42,029
code which was unfortunate and the

897
00:41:40,800 --> 00:41:44,010
results speak for themselves

898
00:41:42,030 --> 00:41:47,010
very few programs are actually able to

899
00:41:44,010 --> 00:41:48,990
take advantage of the actual power

900
00:41:47,010 --> 00:41:50,340
behind sse because in order to do so you

901
00:41:48,989 --> 00:41:55,579
have to like restructure your entire

902
00:41:50,340 --> 00:41:55,579
frickin codebase anyway that rant aside

903
00:42:00,559 --> 00:42:06,119
let's move on so assuming that we

904
00:42:04,139 --> 00:42:08,159
finished the some stuff here which like

905
00:42:06,119 --> 00:42:10,289
I said was just kind of done stupidly so

906
00:42:08,159 --> 00:42:12,170
let's just we can leave it sort of semi

907
00:42:10,289 --> 00:42:14,279
stupid but at least we remove the one

908
00:42:12,170 --> 00:42:18,990
absolutely absurd thing that we

909
00:42:14,280 --> 00:42:20,610
definitely shouldn't have done so at

910
00:42:18,989 --> 00:42:24,839
that point what we really want to do

911
00:42:20,610 --> 00:42:27,000
here is just say well you know and just

912
00:42:24,840 --> 00:42:28,860
just to keep going if you think about

913
00:42:27,000 --> 00:42:30,300
all the opportunities we ever since all

914
00:42:28,860 --> 00:42:31,650
this stuff gets some together you can

915
00:42:30,300 --> 00:42:33,360
basically reorganize any of the lanes

916
00:42:31,650 --> 00:42:34,740
for free to so you know there's stuff we

917
00:42:33,360 --> 00:42:35,849
could pull out here that would be more

918
00:42:34,739 --> 00:42:38,159
efficient blah blah blah blah blah right

919
00:42:35,849 --> 00:42:40,409
so you can kind of tell that there's a

920
00:42:38,159 --> 00:42:41,879
plenty of things here that can be done

921
00:42:40,409 --> 00:42:43,049
we're not going to do them we're just

922
00:42:41,880 --> 00:42:44,309
gonna leave it for now because it's

923
00:42:43,050 --> 00:42:46,200
already gonna be massively better than

924
00:42:44,309 --> 00:42:49,469
what we had before so we'll just ignore

925
00:42:46,199 --> 00:42:52,169
that part but so may come through here

926
00:42:49,469 --> 00:42:54,779
we then have this problem that really

927
00:42:52,170 --> 00:42:58,440
what we need is we need the tiles here

928
00:42:54,780 --> 00:43:00,630
right we need these values and so that's

929
00:42:58,440 --> 00:43:03,119
the one missing part of the equation so

930
00:43:00,630 --> 00:43:04,800
basically if you add that to these

931
00:43:03,119 --> 00:43:06,980
simple parts up here what you basically

932
00:43:04,800 --> 00:43:09,360
have is just like our loading process

933
00:43:06,980 --> 00:43:11,670
loading the data into this routine is

934
00:43:09,360 --> 00:43:13,079
really what we haven't done yet and so

935
00:43:11,670 --> 00:43:14,280
what we need to do is start to take a

936
00:43:13,079 --> 00:43:16,799
look at this part

937
00:43:14,280 --> 00:43:21,990
these ones are trivial like those are

938
00:43:16,800 --> 00:43:24,870
not hard to load but these are going to

939
00:43:21,989 --> 00:43:26,489
be substantially more difficult so if

940
00:43:24,869 --> 00:43:28,799
you take a look at what has to happen

941
00:43:26,489 --> 00:43:30,199
forget clamped you can see here that

942
00:43:28,800 --> 00:43:33,480
what we're doing is we're basically

943
00:43:30,199 --> 00:43:35,069
making sure that we never sample outside

944
00:43:33,480 --> 00:43:37,969
of where the voxel is actually legal

945
00:43:35,070 --> 00:43:37,970
right

946
00:43:41,840 --> 00:43:49,440
and so what we want to do here is say

947
00:43:44,610 --> 00:43:52,050
okay we probably want to call

948
00:43:49,440 --> 00:43:58,050
exclusively this like right look what we

949
00:43:52,050 --> 00:44:04,140
basically need to do is this and we need

950
00:43:58,050 --> 00:44:07,019
to do it a bunch of times right now

951
00:44:04,139 --> 00:44:11,009
because we know the dimensions of this

952
00:44:07,019 --> 00:44:14,090
voxel we actually know the values that

953
00:44:11,010 --> 00:44:18,510
we need to add for each of these offsets

954
00:44:14,090 --> 00:44:23,450
so what we can do is we can compute one

955
00:44:18,510 --> 00:44:26,340
pointer hmm and then we can just take

956
00:44:23,449 --> 00:44:30,149
that pointer and offset it eight times

957
00:44:26,340 --> 00:44:32,880
right so we shouldn't actually have to

958
00:44:30,150 --> 00:44:34,889
do what we're doing here we should be

959
00:44:32,880 --> 00:44:43,820
able to actually load this stuff up in a

960
00:44:34,889 --> 00:44:47,400
much more direct fashion sampling these

961
00:44:43,820 --> 00:44:51,450
tile locations is is just fundamentally

962
00:44:47,400 --> 00:44:54,180
much easier than that right now what I'm

963
00:44:51,449 --> 00:44:57,509
not sure about yes so you can see 60y

964
00:44:54,179 --> 00:45:00,719
here too right now the other nice thing

965
00:44:57,510 --> 00:45:03,450
about this is that we don't have to

966
00:45:00,719 --> 00:45:05,369
worry about being offset in ways that

967
00:45:03,449 --> 00:45:06,809
would cause us to fault because we know

968
00:45:05,369 --> 00:45:08,339
that we're that we have a one pixel

969
00:45:06,809 --> 00:45:10,469
apron around the whole thing

970
00:45:08,340 --> 00:45:11,970
so we're also in a really good state

971
00:45:10,469 --> 00:45:13,969
where we don't have to worry we can

972
00:45:11,969 --> 00:45:17,309
actually do a flat load of this thing

973
00:45:13,969 --> 00:45:20,219
and when we do the load we don't have to

974
00:45:17,309 --> 00:45:21,570
worry about that extra part so if you

975
00:45:20,219 --> 00:45:23,339
look at what's gonna happen here we're

976
00:45:21,570 --> 00:45:26,039
basically blowing a lane like there's

977
00:45:23,340 --> 00:45:28,350
one lane just not used we don't care

978
00:45:26,039 --> 00:45:29,909
what garbage goes in that lane so we can

979
00:45:28,349 --> 00:45:31,799
actually do these flat loads we don't

980
00:45:29,909 --> 00:45:35,369
have to worry so you know basically we

981
00:45:31,800 --> 00:45:37,940
can do you know load ups is on these and

982
00:45:35,369 --> 00:45:41,309
load off the the pointers I don't know

983
00:45:37,940 --> 00:45:44,840
we probably have that right cuz yeah so

984
00:45:41,309 --> 00:45:47,519
we can just do load f/32 for X here and

985
00:45:44,840 --> 00:45:49,860
I think what we want to do is just load

986
00:45:47,519 --> 00:45:50,429
these tiles right so we just want to

987
00:45:49,860 --> 00:45:53,430
load them dry

988
00:45:50,429 --> 00:45:56,219
and so we're gonna have like a Texel

989
00:45:53,429 --> 00:45:58,409
pointer here and what we're gonna do is

990
00:45:56,219 --> 00:46:00,480
we're gonna have sort of like a series

991
00:45:58,409 --> 00:46:03,739
of things we want to load out the Texel

992
00:46:00,480 --> 00:46:07,139
pointer with like various offsets right

993
00:46:03,739 --> 00:46:09,899
so in each of these cases we've got like

994
00:46:07,139 --> 00:46:11,338
an X offset a Y offset and a Z offset

995
00:46:09,900 --> 00:46:13,769
you can sort of see what's going on

996
00:46:11,338 --> 00:46:18,199
there right so I think we just want to

997
00:46:13,769 --> 00:46:18,199
do something like this

998
00:46:22,369 --> 00:46:35,119
nope probably don't want to write it

999
00:46:32,400 --> 00:46:45,869
that laughs there we go

1000
00:46:35,119 --> 00:46:47,550
nope okay so what you can see here is

1001
00:46:45,869 --> 00:46:49,650
I'm just recreating this exact pattern

1002
00:46:47,550 --> 00:46:51,568
so you can see we have the Z offset here

1003
00:46:49,650 --> 00:46:52,740
and you know honestly if I was writing

1004
00:46:51,568 --> 00:46:54,989
this a little bit more sanely

1005
00:46:52,739 --> 00:46:56,179
let's actually not do that if I was

1006
00:46:54,989 --> 00:46:58,679
writing this a little bit more sanely

1007
00:46:56,179 --> 00:46:59,848
let's just do it in reverse order so we

1008
00:46:58,679 --> 00:47:04,139
know that we're doing it sort of this

1009
00:46:59,849 --> 00:47:05,940
way right and so if you look at that Z

1010
00:47:04,139 --> 00:47:14,400
offset probably the smartest thing to do

1011
00:47:05,940 --> 00:47:16,950
here is this right and then each of

1012
00:47:14,400 --> 00:47:20,730
these is just going to be is it the X

1013
00:47:16,949 --> 00:47:23,489
the Y or the X Y right so it's like the

1014
00:47:20,730 --> 00:47:28,530
first one is nothing the next one is X

1015
00:47:23,489 --> 00:47:39,229
the next one is Y and the next one is Y

1016
00:47:28,530 --> 00:47:39,230
X right and so that would in theory

1017
00:47:40,880 --> 00:47:52,190
allow me to load these in a fairly

1018
00:47:43,380 --> 00:47:54,660
straightforward fashion but yeah I mean

1019
00:47:52,190 --> 00:47:55,190
but nothing that's really all there is

1020
00:47:54,659 --> 00:47:58,259
to it

1021
00:47:55,190 --> 00:47:59,670
so we just need to produce one texel

1022
00:47:58,260 --> 00:48:01,290
pointer and then we can do these loads

1023
00:47:59,670 --> 00:48:03,420
very straightforward so you can see we

1024
00:48:01,289 --> 00:48:03,719
can get rid of like 99% of the work

1025
00:48:03,420 --> 00:48:04,829
that's

1026
00:48:03,719 --> 00:48:06,269
actually go out of here but there's a

1027
00:48:04,829 --> 00:48:07,679
couple of edge cases we need to be able

1028
00:48:06,269 --> 00:48:09,840
to take into account for example if

1029
00:48:07,679 --> 00:48:12,539
you're sampling off the voxel we want to

1030
00:48:09,840 --> 00:48:13,619
make sure we're sampling in the voxel so

1031
00:48:12,539 --> 00:48:15,809
there's a couple things that we want to

1032
00:48:13,619 --> 00:48:17,910
be able to do there so the first thing

1033
00:48:15,809 --> 00:48:21,179
we want to be able to do right is the

1034
00:48:17,909 --> 00:48:26,190
offsets here we want these offsets to by

1035
00:48:21,179 --> 00:48:28,649
default just not be things and then if

1036
00:48:26,190 --> 00:48:34,829
we're in bounds to the voxel then we'll

1037
00:48:28,650 --> 00:48:38,160
actually set them to stuff right but

1038
00:48:34,829 --> 00:48:41,098
otherwise we won't and so when we

1039
00:48:38,159 --> 00:48:43,529
actually produce this Texel pointer here

1040
00:48:41,099 --> 00:48:46,559
we're going to produce the Texel pointer

1041
00:48:43,530 --> 00:48:49,410
for the base voxel which we will clamp

1042
00:48:46,559 --> 00:48:52,799
in bounds and if we've determined that

1043
00:48:49,409 --> 00:48:55,170
it is in bounds then we will set these

1044
00:48:52,800 --> 00:48:56,190
offset values otherwise we will not

1045
00:48:55,170 --> 00:48:59,190
right

1046
00:48:56,190 --> 00:49:01,170
so that's that's sort of the way we're

1047
00:48:59,190 --> 00:49:05,400
gonna do this and this actually probably

1048
00:49:01,170 --> 00:49:06,420
will happen like here I would assume is

1049
00:49:05,400 --> 00:49:09,900
probably what's actually gonna happen

1050
00:49:06,420 --> 00:49:13,380
but kind of take a look at that later so

1051
00:49:09,900 --> 00:49:16,619
really this whole thing is is not super

1052
00:49:13,380 --> 00:49:19,200
important right the txt Y can already be

1053
00:49:16,619 --> 00:49:21,300
baked in so when we do this initial

1054
00:49:19,199 --> 00:49:24,960
thing we don't because we're sampling

1055
00:49:21,300 --> 00:49:27,330
from the same octahedral map slot we

1056
00:49:24,960 --> 00:49:29,699
don't ever have to permute that so that

1057
00:49:27,329 --> 00:49:30,838
extra work can just be done once it

1058
00:49:29,699 --> 00:49:32,759
doesn't have to be done eight times

1059
00:49:30,838 --> 00:49:34,440
right so again just massive savings we

1060
00:49:32,760 --> 00:49:36,060
can clean out I don't know how much of

1061
00:49:34,440 --> 00:49:37,619
this the compiler was doing but based on

1062
00:49:36,059 --> 00:49:39,119
that spot check of the code that I did

1063
00:49:37,619 --> 00:49:41,730
like I didn't even bother because it was

1064
00:49:39,119 --> 00:49:43,050
such a mess but I was just like we got a

1065
00:49:41,730 --> 00:49:44,369
we got to write this in a way the

1066
00:49:43,050 --> 00:49:46,619
compiler can do something clean with it

1067
00:49:44,369 --> 00:49:48,329
because it was already a disaster so how

1068
00:49:46,619 --> 00:49:51,210
many things compiler actually spotted I

1069
00:49:48,329 --> 00:49:53,130
don't know but not enough was the answer

1070
00:49:51,210 --> 00:49:54,679
and so I'm just trying to clean the

1071
00:49:53,130 --> 00:49:57,570
whole thing out and just write a

1072
00:49:54,679 --> 00:49:58,799
sensible routine that I think the

1073
00:49:57,570 --> 00:50:04,500
compiler will have an easy time with

1074
00:49:58,800 --> 00:50:06,300
right okay so again we're just trying to

1075
00:50:04,500 --> 00:50:08,699
produce base offsets here so that you

1076
00:50:06,300 --> 00:50:12,450
know we can basically do offset you know

1077
00:50:08,699 --> 00:50:14,659
register with with base register plus

1078
00:50:12,449 --> 00:50:16,829
offset register kind of addressing here

1079
00:50:14,659 --> 00:50:17,608
and so we just need to produce these

1080
00:50:16,829 --> 00:50:21,960
values

1081
00:50:17,608 --> 00:50:24,058
and the X offset Y offset X Y offset so

1082
00:50:21,960 --> 00:50:25,499
in here I'll just produce the X I'll

1083
00:50:24,059 --> 00:50:27,180
clear all these registers out and then

1084
00:50:25,498 --> 00:50:30,689
if this thing is in bounds

1085
00:50:27,179 --> 00:50:32,338
we'll just produce those offset values

1086
00:50:30,690 --> 00:50:37,200
and then we'll address off them after

1087
00:50:32,338 --> 00:50:38,818
that right so let's start by actually

1088
00:50:37,199 --> 00:50:40,980
trying to decrypt some of the stuff and

1089
00:50:38,818 --> 00:50:54,778
we're gonna have to do the actual

1090
00:50:40,980 --> 00:50:58,409
clamping here I don't actually know how

1091
00:50:54,778 --> 00:51:01,710
I would want to do this but I suspect

1092
00:50:58,409 --> 00:51:03,808
that I can just again rather than trying

1093
00:51:01,710 --> 00:51:07,349
to do an incredibly fancy version of

1094
00:51:03,809 --> 00:51:08,910
this routine if we just lose one lane we

1095
00:51:07,349 --> 00:51:13,289
probably can just do the straightforward

1096
00:51:08,909 --> 00:51:20,730
thing of taking the X Y Z's directly

1097
00:51:13,289 --> 00:51:23,309
loaded I would imagine so if we did

1098
00:51:20,730 --> 00:51:25,199
something like this I don't remember how

1099
00:51:23,309 --> 00:51:32,130
we do our u3 two loads here but we've

1100
00:51:25,199 --> 00:51:33,509
got yeah so we can do this right and the

1101
00:51:32,130 --> 00:51:36,358
problem that we'll have here is that

1102
00:51:33,509 --> 00:51:38,400
these are actually signed values so we

1103
00:51:36,358 --> 00:51:43,048
probably want to have a separate routine

1104
00:51:38,400 --> 00:51:46,579
for loading these up I don't really know

1105
00:51:43,048 --> 00:51:46,579
why we're doing it this way

1106
00:51:53,900 --> 00:51:59,010
III don't know that that makes a lot of

1107
00:51:56,730 --> 00:52:04,320
sense but it's okay doesn't really

1108
00:51:59,010 --> 00:52:05,640
matter but point being these are

1109
00:52:04,320 --> 00:52:07,500
probably signed value so I would imagine

1110
00:52:05,639 --> 00:52:17,940
when they come in here right am I wrong

1111
00:52:07,500 --> 00:52:19,230
about that yeah cuz we've already well

1112
00:52:17,940 --> 00:52:20,280
actually you know what I guess now I

1113
00:52:19,230 --> 00:52:21,300
think about it we don't even have to

1114
00:52:20,280 --> 00:52:23,250
load them I don't need that because

1115
00:52:21,300 --> 00:52:27,960
we're actually just well no you know

1116
00:52:23,250 --> 00:52:29,610
what we yeah no we don't so what we

1117
00:52:27,960 --> 00:52:33,090
fundamentally we need to do here is we

1118
00:52:29,610 --> 00:52:34,800
need to load the bounds the that we're

1119
00:52:33,090 --> 00:52:36,480
clamping against I guess is the way to

1120
00:52:34,800 --> 00:52:37,890
look at it so if we if we come back here

1121
00:52:36,480 --> 00:52:40,590
to get tuck clamped right you can see

1122
00:52:37,889 --> 00:52:45,659
that we're doing clamp where we have two

1123
00:52:40,590 --> 00:52:47,340
lewd voxel dim minus one right so we

1124
00:52:45,659 --> 00:52:50,339
want to do there is we want to be able

1125
00:52:47,340 --> 00:52:52,350
to load in these values and we need to

1126
00:52:50,340 --> 00:52:56,100
then clamp against them so if we wanted

1127
00:52:52,349 --> 00:52:57,779
to do that we could do that wide the

1128
00:52:56,099 --> 00:52:59,549
only problem is you know as I'm thinking

1129
00:52:57,780 --> 00:53:02,670
about it I'm like well but then we're

1130
00:52:59,550 --> 00:53:04,440
just gonna have to transit it out anyway

1131
00:53:02,670 --> 00:53:16,710
like is that really the smartest thing

1132
00:53:04,440 --> 00:53:18,420
to do I mean maybe I'm just I'm kind of

1133
00:53:16,710 --> 00:53:22,530
conflicted like I don't know what to

1134
00:53:18,420 --> 00:53:25,700
make of it I'm not sure how I want to do

1135
00:53:22,530 --> 00:53:25,700
that front part

1136
00:53:43,579 --> 00:53:57,809
so I think I'm just gonna do it wide

1137
00:53:45,960 --> 00:54:00,300
because because wide wide not so yeah if

1138
00:53:57,809 --> 00:54:03,329
I want to do this wide we can load the

1139
00:54:00,300 --> 00:54:07,410
voxel dim indirectly right so what I

1140
00:54:03,329 --> 00:54:11,610
would do here is just say let's load the

1141
00:54:07,409 --> 00:54:13,649
axis voxel dim so we're gonna have

1142
00:54:11,610 --> 00:54:17,579
something like this right where we've

1143
00:54:13,650 --> 00:54:20,070
got the x y&amp;z loaded into the voxel dim

1144
00:54:17,579 --> 00:54:24,360
and so whatever Atlas we're sampling

1145
00:54:20,070 --> 00:54:25,860
here which is diffuse setlists right and

1146
00:54:24,360 --> 00:54:27,630
I don't know why we said diffuse

1147
00:54:25,860 --> 00:54:29,640
setlists because it doesn't have to be

1148
00:54:27,630 --> 00:54:31,170
the diffuse Atlas but you know it's

1149
00:54:29,639 --> 00:54:33,150
whatever Atlas you wanted a sample from

1150
00:54:31,170 --> 00:54:38,130
we just don't ever sample from any other

1151
00:54:33,150 --> 00:54:39,960
Atlas at the moment but you know so in

1152
00:54:38,130 --> 00:54:44,070
here we would just say look we've got

1153
00:54:39,960 --> 00:54:48,289
the diffuse that lists dimension here

1154
00:54:44,070 --> 00:54:51,480
we've got some various constant values

1155
00:54:48,289 --> 00:54:53,880
like 1 and then we probably want 0 as

1156
00:54:51,480 --> 00:55:03,860
well so up here we would say well

1157
00:54:53,880 --> 00:55:08,220
there's 0 what is it like 0 for X yeah

1158
00:55:03,860 --> 00:55:10,800
so we start off with a couple of values

1159
00:55:08,219 --> 00:55:12,959
here and if we want to we can subtract 1

1160
00:55:10,800 --> 00:55:16,230
from this so we can say voxel dem minus

1161
00:55:12,960 --> 00:55:19,349
1 and we also have 0 so if you want to

1162
00:55:16,230 --> 00:55:23,909
do a clamp we just can write so we can

1163
00:55:19,349 --> 00:55:28,829
say like the clamp X Y Z equals clamp

1164
00:55:23,909 --> 00:55:34,769
you know and I should probably just do

1165
00:55:28,829 --> 00:55:36,659
like f/32 voxel max or something and

1166
00:55:34,769 --> 00:55:39,840
store this value because I'm gonna need

1167
00:55:36,659 --> 00:55:42,869
it twice at least I think I will

1168
00:55:39,840 --> 00:55:46,019
so if we do the voxel max and zero that

1169
00:55:42,869 --> 00:55:51,329
would clamp the incoming XYZ coordinates

1170
00:55:46,019 --> 00:55:54,179
right so we've got our X Y Z here and I

1171
00:55:51,329 --> 00:55:56,369
guess I I knew where that is because

1172
00:55:54,179 --> 00:55:58,589
that actually comes out of the first

1173
00:55:56,369 --> 00:56:01,769
computation that we do so like if we

1174
00:55:58,590 --> 00:56:04,140
look down here the UVW coordinates we

1175
00:56:01,769 --> 00:56:06,000
don't need to later but I might just

1176
00:56:04,139 --> 00:56:07,739
grab them all and put them at the top

1177
00:56:06,000 --> 00:56:10,500
just because they're kind of things we

1178
00:56:07,739 --> 00:56:13,679
actually care about so the B chord value

1179
00:56:10,500 --> 00:56:15,989
here that's our X Y Z so we already have

1180
00:56:13,679 --> 00:56:18,029
the B chord value and what I want to do

1181
00:56:15,989 --> 00:56:21,959
with the B chord value is I just want to

1182
00:56:18,030 --> 00:56:24,600
clamp it right now the nice thing about

1183
00:56:21,960 --> 00:56:25,860
this is so once I've done the floor on

1184
00:56:24,599 --> 00:56:28,139
the B chord value the really interesting

1185
00:56:25,860 --> 00:56:30,450
thing I can do here is I can also just

1186
00:56:28,139 --> 00:56:35,099
say well actually why don't I just

1187
00:56:30,449 --> 00:56:38,250
produce a simple location from this

1188
00:56:35,099 --> 00:56:42,119
where I can just say oh well when we're

1189
00:56:38,250 --> 00:56:46,199
actually doing this clamping I can clamp

1190
00:56:42,119 --> 00:56:50,159
two things I can clamp so I can say like

1191
00:56:46,199 --> 00:56:52,230
the min XYZ and the max XYZ right which

1192
00:56:50,159 --> 00:56:54,210
are just the two sides of the cube that

1193
00:56:52,230 --> 00:56:59,219
I want to sample on so what I can do

1194
00:56:54,210 --> 00:57:01,889
here is I can just literally do a plus 1

1195
00:56:59,219 --> 00:57:03,779
and a minus 1 to some priest abuse the

1196
00:57:01,889 --> 00:57:06,329
Max's way and a plus 1 on the B chord to

1197
00:57:03,780 --> 00:57:09,269
get the far one if I clamp both of these

1198
00:57:06,329 --> 00:57:12,059
now I don't have to do any testing so

1199
00:57:09,269 --> 00:57:15,239
this if statement doesn't have to occur

1200
00:57:12,059 --> 00:57:19,759
right so now what I can do is I can

1201
00:57:15,239 --> 00:57:22,199
produce these by just doing extracts

1202
00:57:19,760 --> 00:57:29,460
right it's pretty straightforward

1203
00:57:22,199 --> 00:57:32,789
so so actually I can just do this these

1204
00:57:29,460 --> 00:57:37,590
can just be extracts where I extract you

1205
00:57:32,789 --> 00:57:41,190
32s from these things right so I can get

1206
00:57:37,590 --> 00:57:43,920
the 0 the 1 and the 2 out of these and

1207
00:57:41,190 --> 00:57:47,760
all these are going to be is the the

1208
00:57:43,920 --> 00:57:51,960
Delta right so the Delta X Y Z is just

1209
00:57:47,760 --> 00:57:53,490
going to be the max XYZ minus the min

1210
00:57:51,960 --> 00:57:56,849
XYZ right

1211
00:57:53,489 --> 00:58:00,419
and so if both values were out of bounds

1212
00:57:56,849 --> 00:58:04,019
and they both clamped down in either

1213
00:58:00,420 --> 00:58:06,059
direction then I will just have an on

1214
00:58:04,019 --> 00:58:08,449
Delta and we'll just sample all from the

1215
00:58:06,059 --> 00:58:12,000
same tile right which will be fine

1216
00:58:08,449 --> 00:58:14,639
but if they weren't then I'll sample

1217
00:58:12,000 --> 00:58:19,199
from you know the eight corners as I

1218
00:58:14,639 --> 00:58:20,759
should so I think that just works and it

1219
00:58:19,199 --> 00:58:22,409
works for all the different kinds of

1220
00:58:20,760 --> 00:58:25,290
clamping so if only one thing is out of

1221
00:58:22,409 --> 00:58:26,848
bounds it'll still clamp properly so I

1222
00:58:25,289 --> 00:58:28,889
think that's kind of a nicer way to do

1223
00:58:26,849 --> 00:58:32,068
it so if we just like were to extract

1224
00:58:28,889 --> 00:58:34,608
you 32s from this thing and I don't know

1225
00:58:32,068 --> 00:58:38,039
exactly how we would want to do that

1226
00:58:34,608 --> 00:58:43,858
like this is really like a cast of this

1227
00:58:38,039 --> 00:58:45,058
thing you know the SSE code for this is

1228
00:58:43,858 --> 00:58:46,558
very straightforward but I just don't

1229
00:58:45,059 --> 00:58:49,650
know what we wrote in our library so I'm

1230
00:58:46,559 --> 00:58:51,359
gonna have to look that up and we'll you

1231
00:58:49,650 --> 00:58:55,889
know it's not really a cast it's a

1232
00:58:51,358 --> 00:58:57,630
convert you know again it's just one

1233
00:58:55,889 --> 00:58:59,190
simple instruction and then then the

1234
00:58:57,630 --> 00:59:02,818
extract but you know doesn't matter well

1235
00:58:59,190 --> 00:59:04,920
we'll get to that later so this is very

1236
00:59:02,818 --> 00:59:07,558
streamlined right we can do that with no

1237
00:59:04,920 --> 00:59:09,750
ifs and we can immediately produce this

1238
00:59:07,559 --> 00:59:11,670
XYZ coordinates really very trivially

1239
00:59:09,750 --> 00:59:13,889
and then we pretty much know exactly

1240
00:59:11,670 --> 00:59:18,210
what we need and so now we're just down

1241
00:59:13,889 --> 00:59:20,909
to the fact that these here need to get

1242
00:59:18,210 --> 00:59:24,298
multiplied by their appropriate values

1243
00:59:20,909 --> 00:59:26,868
right so we really want an X Y Z stride

1244
00:59:24,298 --> 00:59:33,960
because we can do that wide as well

1245
00:59:26,869 --> 00:59:36,599
right so in here we can just say like

1246
00:59:33,960 --> 00:59:41,400
well whatever the and in fact I guess

1247
00:59:36,599 --> 00:59:43,109
it's not stride X Y Z it's the leg it's

1248
00:59:41,400 --> 00:59:48,269
the actual computed Delta so we probably

1249
00:59:43,108 --> 00:59:54,000
want the stride X Y Z to be a thing that

1250
00:59:48,269 --> 00:59:56,940
we load but this is just going to be the

1251
00:59:54,000 --> 00:59:59,039
stride X Y Z times the Delta right so

1252
00:59:56,940 --> 01:00:00,119
we'll be able to produce this very

1253
00:59:59,039 --> 01:00:01,650
straightforward

1254
01:00:00,119 --> 01:00:05,430
these values will just come straight out

1255
01:00:01,650 --> 01:00:07,108
of it we will have a base Texel pointer

1256
01:00:05,429 --> 01:00:09,778
cure we'll have to do

1257
01:00:07,108 --> 01:00:12,509
movement on the pointer and we need to

1258
01:00:09,778 --> 01:00:16,380
go grab this light Atlas offset nonsense

1259
01:00:12,509 --> 01:00:18,420
which is a huge disaster and basically

1260
01:00:16,380 --> 01:00:21,420
we just need to reproduce this equation

1261
01:00:18,420 --> 01:00:23,489
now so for each one of the things

1262
01:00:21,420 --> 01:00:25,409
involved here there's obviously stride

1263
01:00:23,489 --> 01:00:26,730
values that we need to take into account

1264
01:00:25,409 --> 01:00:30,058
and you can actually see what they are

1265
01:00:26,730 --> 01:00:32,248
so you can see here what all of these

1266
01:00:30,059 --> 01:00:37,230
actually what well these values actually

1267
01:00:32,248 --> 01:00:39,179
are I don't know why it's done quite

1268
01:00:37,230 --> 01:00:42,389
exactly this way but it's all done in F

1269
01:00:39,179 --> 01:00:45,199
32 so it's all multiplied out by I'm

1270
01:00:42,389 --> 01:00:48,509
sorry V 3s so it's all multi-tap by that

1271
01:00:45,199 --> 01:00:51,838
sort of stride value which seems fine I

1272
01:00:48,509 --> 01:00:54,989
mean I don't really care I suppose at

1273
01:00:51,838 --> 01:00:57,298
the end of the day and so what that

1274
01:00:54,989 --> 01:00:59,970
means is like these values for each of

1275
01:00:57,298 --> 01:01:03,119
the strides this if we're going to make

1276
01:00:59,969 --> 01:01:06,149
this be a load thing that we do here the

1277
01:01:03,119 --> 01:01:07,858
load is going to in it's going to have

1278
01:01:06,150 --> 01:01:10,769
these particular values this one's that

1279
01:01:07,858 --> 01:01:21,328
we're looking at right here so the Z

1280
01:01:10,768 --> 01:01:25,008
value stride is this so that's the Z the

1281
01:01:21,329 --> 01:01:25,009
x value stride is this

1282
01:01:32,829 --> 01:01:44,440
and the y-value stride is this it looks

1283
01:01:36,219 --> 01:01:46,749
like right so for every x value it's

1284
01:01:44,440 --> 01:01:52,119
gonna go by one tile now for every Y

1285
01:01:46,748 --> 01:01:54,368
value it's gonna go by one voxel x Rho

1286
01:01:52,119 --> 01:01:56,858
times the tiles right because the Y's

1287
01:01:54,369 --> 01:02:00,369
are packed after the x's and then for

1288
01:01:56,858 --> 01:02:03,219
the Z's it's gonna go down by however

1289
01:02:00,369 --> 01:02:05,950
much it is so you can see it's pretty

1290
01:02:03,219 --> 01:02:08,528
straightforward there and so really all

1291
01:02:05,949 --> 01:02:11,379
we've got left after you look at those

1292
01:02:08,528 --> 01:02:15,608
is we've got this sort of residual

1293
01:02:11,380 --> 01:02:17,890
concept of inside the Texel there so

1294
01:02:15,608 --> 01:02:21,119
it's it's gonna have to have in addition

1295
01:02:17,889 --> 01:02:26,018
to the XYZ offset it's gonna need this

1296
01:02:21,119 --> 01:02:27,989
right that makes sense so this is

1297
01:02:26,018 --> 01:02:31,058
something that just has to be done

1298
01:02:27,989 --> 01:02:33,309
separately because you know we just have

1299
01:02:31,059 --> 01:02:34,630
this extra thing that's gonna get added

1300
01:02:33,309 --> 01:02:36,729
on there and there's no point in doing

1301
01:02:34,630 --> 01:02:40,959
that wide because it's only there isn't

1302
01:02:36,728 --> 01:02:42,639
any clamping or anything done to it it

1303
01:02:40,958 --> 01:02:44,228
would just waste time transiting in and

1304
01:02:42,639 --> 01:02:46,958
out of the wide registers it's just a

1305
01:02:44,228 --> 01:02:48,218
complete it's just complete waste so we

1306
01:02:46,958 --> 01:02:51,068
really should probably just do it in

1307
01:02:48,219 --> 01:02:52,659
scaler and so the base textile value

1308
01:02:51,068 --> 01:02:55,599
that we're actually going to be looking

1309
01:02:52,659 --> 01:03:00,699
at here is going to look like that right

1310
01:02:55,599 --> 01:03:03,789
and that's where we're actually starting

1311
01:03:00,699 --> 01:03:05,709
for our textile pointer and from there

1312
01:03:03,789 --> 01:03:13,440
we should be able to just load these

1313
01:03:05,708 --> 01:03:16,778
things directly right that makes sense

1314
01:03:13,440 --> 01:03:20,349
so we're almost done actually there's

1315
01:03:16,778 --> 01:03:21,699
not a lot left so if you take a look at

1316
01:03:20,349 --> 01:03:23,588
what's going on here we just need to

1317
01:03:21,699 --> 01:03:26,380
produce this initial pointer and we do

1318
01:03:23,588 --> 01:03:28,509
all the loads off of them we have the

1319
01:03:26,380 --> 01:03:30,548
the delta and so if you look here the

1320
01:03:28,509 --> 01:03:34,900
final thing we need is like the base

1321
01:03:30,548 --> 01:03:37,420
offset of this thing because this is the

1322
01:03:34,900 --> 01:03:40,660
deltas right but we haven't actually

1323
01:03:37,420 --> 01:03:44,739
produced the initial XYZ and so we're

1324
01:03:40,659 --> 01:03:47,129
going to need one more offset value here

1325
01:03:44,739 --> 01:03:53,249
or whatever you want to call it

1326
01:03:47,130 --> 01:03:55,739
and and that's just gonna come from this

1327
01:03:53,248 --> 01:03:58,649
stride we already have being multiplied

1328
01:03:55,739 --> 01:04:04,588
by the B chord right well then me an X Y

1329
01:03:58,650 --> 01:04:09,539
Z right so the base X Y Z value here

1330
01:04:04,588 --> 01:04:11,429
these are obviously all vectors so the

1331
01:04:09,539 --> 01:04:13,528
base X Y Z value is just whatever the

1332
01:04:11,429 --> 01:04:16,919
mineus times that stride that's how much

1333
01:04:13,528 --> 01:04:19,469
of an offset we actually need so then

1334
01:04:16,920 --> 01:04:20,940
those just get summed together because

1335
01:04:19,469 --> 01:04:22,499
now they've been correct they've been

1336
01:04:20,940 --> 01:04:26,429
correctly look multiplied by their

1337
01:04:22,498 --> 01:04:29,189
actual offset numbers so all we really

1338
01:04:26,429 --> 01:04:31,469
need to do now is for the like base

1339
01:04:29,190 --> 01:04:33,889
offset value we just need you know

1340
01:04:31,469 --> 01:04:36,889
whatever these are we need to do them

1341
01:04:33,889 --> 01:04:36,889
right

1342
01:04:42,650 --> 01:04:50,130
so that's it and now our primary thing

1343
01:04:47,389 --> 01:04:52,650
to think about is how we want to extract

1344
01:04:50,130 --> 01:04:57,660
integer values from this stuff all of

1345
01:04:52,650 --> 01:05:00,930
this I think would just work but the

1346
01:04:57,659 --> 01:05:02,670
problem so this is not actually correct

1347
01:05:00,929 --> 01:05:06,478
because we actually do want to do these

1348
01:05:02,670 --> 01:05:07,829
in F these are actually float we can

1349
01:05:06,478 --> 01:05:11,868
just do them in float we could do them

1350
01:05:07,829 --> 01:05:15,959
binary but 32 I mean we could do them

1351
01:05:11,869 --> 01:05:18,180
integer but multiplying integers 32-bit

1352
01:05:15,958 --> 01:05:20,808
on SSE is a bit dicey if I remember

1353
01:05:18,179 --> 01:05:20,808
correctly in fact

1354
01:05:40,780 --> 01:05:47,290
so no it's not I took it back so we

1355
01:05:43,820 --> 01:05:47,289
could just do multi cues on these

1356
01:06:06,219 --> 01:06:10,548
I'm a little bit torn so if I was just

1357
01:06:08,688 --> 01:06:14,719
writing this myself I might actually use

1358
01:06:10,548 --> 01:06:17,650
multi cue on it then because you know

1359
01:06:14,719 --> 01:06:32,119
you can see here it's really not

1360
01:06:17,650 --> 01:06:33,739
different I mean the latency is a little

1361
01:06:32,119 --> 01:06:37,969
bit better on the floating-point

1362
01:06:33,739 --> 01:06:39,228
multiply I don't know so here's I'm

1363
01:06:37,969 --> 01:06:40,849
going to do I'm gonna leave it in float

1364
01:06:39,228 --> 01:06:42,228
just because that's what we were using

1365
01:06:40,849 --> 01:06:46,088
is our little library that we're using

1366
01:06:42,228 --> 01:06:49,158
here and our library is kind of crap so

1367
01:06:46,088 --> 01:06:57,139
I'm just gonna say look we're gonna cast

1368
01:06:49,159 --> 01:07:00,588
these and that's just how it is so just

1369
01:06:57,139 --> 01:07:03,098
get used to it folks and you know don't

1370
01:07:00,588 --> 01:07:06,679
don't whine to me about it because

1371
01:07:03,099 --> 01:07:08,568
that's just what we're doing so then we

1372
01:07:06,679 --> 01:07:11,358
would be able to use everything exactly

1373
01:07:08,568 --> 01:07:15,798
the way that it was and all of this

1374
01:07:11,358 --> 01:07:17,688
stuff should in theory just work these

1375
01:07:15,798 --> 01:07:18,858
might have to have castes in front of

1376
01:07:17,688 --> 01:07:21,259
them in order for the compiler to not

1377
01:07:18,858 --> 01:07:21,679
complain but other than that it would be

1378
01:07:21,259 --> 01:07:23,389
fine

1379
01:07:21,679 --> 01:07:25,759
all of this stuff therefore is just

1380
01:07:23,389 --> 01:07:27,618
operating entirely in float and the only

1381
01:07:25,759 --> 01:07:29,659
thing we actually need to do here is we

1382
01:07:27,619 --> 01:07:36,979
need to figure out a way to get these

1383
01:07:29,659 --> 01:07:39,259
values out so if we produce 32s for all

1384
01:07:36,978 --> 01:07:42,018
of this we need a way to get you 32 s

1385
01:07:39,259 --> 01:07:44,739
out of all this so if we take a look at

1386
01:07:42,018 --> 01:07:47,538
how the Simbi code is structured here

1387
01:07:44,739 --> 01:07:51,318
you can see we have extracts for

1388
01:07:47,539 --> 01:08:00,679
extracting floating point values and we

1389
01:07:51,318 --> 01:08:02,978
don't really have anything else what is

1390
01:08:00,679 --> 01:08:02,979
this

1391
01:08:04,230 --> 01:08:11,670
is that really it produces an int for

1392
01:08:07,510 --> 01:08:11,670
mmx4 mmx2 act PS

1393
01:08:20,960 --> 01:08:34,789
why the heck does it do that we heard so

1394
01:08:31,310 --> 01:08:46,009
what do you suppose the point of that

1395
01:08:34,789 --> 01:08:46,838
was gosh that's odd huh well it is what

1396
01:08:46,009 --> 01:08:51,259
it is

1397
01:08:46,838 --> 01:08:53,719
so when Intel extracts those values they

1398
01:08:51,259 --> 01:08:56,988
already come out as integers anyway so I

1399
01:08:53,719 --> 01:08:59,239
guess if we do a cat convert on that and

1400
01:08:56,988 --> 01:09:01,009
then yeah I mean well you know yeah I

1401
01:08:59,238 --> 01:09:06,289
don't know what to tell you it is what

1402
01:09:01,009 --> 01:09:08,298
it is it's a little strange anyway so I

1403
01:09:06,289 --> 01:09:10,908
don't think we have anything for doing

1404
01:09:08,298 --> 01:09:14,719
that kind of extraction so we're gonna

1405
01:09:10,908 --> 01:09:17,000
want to actually produce that right we

1406
01:09:14,719 --> 01:09:21,408
want we want to have a thing here that

1407
01:09:17,000 --> 01:09:23,630
allows to get that out and I don't think

1408
01:09:21,408 --> 01:09:27,139
I have not seen anything here where we

1409
01:09:23,630 --> 01:09:29,239
where we do that right yeah I don't see

1410
01:09:27,140 --> 01:09:32,060
anything so I wanna I want something

1411
01:09:29,238 --> 01:09:35,928
there that will do that and so I want

1412
01:09:32,060 --> 01:09:38,810
something probably that does both of

1413
01:09:35,929 --> 01:09:40,399
these together I'm guessing so I

1414
01:09:38,810 --> 01:09:42,739
probably want something like this where

1415
01:09:40,399 --> 01:09:47,448
we just do like I'm gonna call it

1416
01:09:42,738 --> 01:09:49,428
convert s 32 for now because I know

1417
01:09:47,448 --> 01:09:51,379
that's I don't know that Intel actually

1418
01:09:49,429 --> 01:09:55,969
has a I don't know that they have a

1419
01:09:51,380 --> 01:10:00,170
convert you 32 and we don't need one so

1420
01:09:55,969 --> 01:10:02,840
I'm not gonna force the issue so the way

1421
01:10:00,170 --> 01:10:07,100
this would work is convert s 3 - it

1422
01:10:02,840 --> 01:10:09,920
probably has to be unfortunately a macro

1423
01:10:07,100 --> 01:10:15,190
I'm guessing because these probably have

1424
01:10:09,920 --> 01:10:17,719
to be immediate and C++ is too crappy

1425
01:10:15,189 --> 01:10:20,178
you have to make a template I guess if

1426
01:10:17,719 --> 01:10:25,640
you want to do that for no frickin

1427
01:10:20,179 --> 01:10:31,960
reason so if I want to do an extract

1428
01:10:25,640 --> 01:10:31,960
here probably just do an extract epi32

1429
01:10:37,960 --> 01:10:42,739
with whatever the immediate you asked

1430
01:10:40,250 --> 01:10:52,159
for is and then on the inside it would

1431
01:10:42,739 --> 01:10:59,380
be a convert of the input and the input

1432
01:10:52,159 --> 01:11:09,079
in this case we want an mm convert of a

1433
01:10:59,380 --> 01:11:11,420
nope none of this I always get the so

1434
01:11:09,079 --> 01:11:16,130
there's like which one it's on and which

1435
01:11:11,420 --> 01:11:18,920
one it's going to I never there is a

1436
01:11:16,130 --> 01:11:21,650
rhyme or reason to this naming scheme

1437
01:11:18,920 --> 01:11:23,989
however it's one that always confuses me

1438
01:11:21,649 --> 01:11:25,939
like my brain doesn't think of it the

1439
01:11:23,989 --> 01:11:31,250
way that they do

1440
01:11:25,939 --> 01:11:34,899
so like the PS that this interior part

1441
01:11:31,250 --> 01:11:38,479
is the thing that it operates on and

1442
01:11:34,899 --> 01:11:45,639
this underscore part is the thing it

1443
01:11:38,479 --> 01:11:49,609
produces so convert PS epi32 is take a

1444
01:11:45,640 --> 01:11:52,660
floating-point pacts scalar packed

1445
01:11:49,609 --> 01:11:58,309
single precision sorry and convert it to

1446
01:11:52,659 --> 01:12:02,029
a integer 32 return that right

1447
01:11:58,310 --> 01:12:09,890
whereas if convert if the epi32 or the

1448
01:12:02,029 --> 01:12:11,389
pi32 was on the inside right then and

1449
01:12:09,890 --> 01:12:13,280
the PS was on the outside it would do

1450
01:12:11,390 --> 01:12:16,550
the opposite conversion does that make

1451
01:12:13,279 --> 01:12:18,469
sense and I think the e is like extended

1452
01:12:16,550 --> 01:12:22,579
because it's like if you don't have the

1453
01:12:18,470 --> 01:12:25,400
e it's it's the S it's the old MMX

1454
01:12:22,579 --> 01:12:26,720
registers or something anyway there is a

1455
01:12:25,399 --> 01:12:28,909
rhyme or reason to the scheme I always

1456
01:12:26,720 --> 01:12:32,590
forget it and hey look it does have an

1457
01:12:28,909 --> 01:12:35,119
convert for unsigned so there you go um

1458
01:12:32,590 --> 01:12:39,050
so anyway this is what we actually want

1459
01:12:35,119 --> 01:12:43,529
convert PS epi32 you'll notice I wrote

1460
01:12:39,050 --> 01:12:45,579
it wrong instinctively like I said

1461
01:12:43,529 --> 01:12:49,199
and so now we can actually get those

1462
01:12:45,579 --> 01:12:54,369
values out so let's ignore this for now

1463
01:12:49,199 --> 01:12:56,019
we don't want any of these now and let's

1464
01:12:54,369 --> 01:13:07,510
take a look at actually yeah so these

1465
01:12:56,020 --> 01:13:20,770
need to be cast a cast and so did I

1466
01:13:07,510 --> 01:13:24,489
would assume these we don't have a clamp

1467
01:13:20,770 --> 01:13:32,230
and we probably want one right so the

1468
01:13:24,488 --> 01:13:35,549
clamp 0 1 that we made now what we

1469
01:13:32,229 --> 01:13:35,549
probably want here is this

1470
01:13:49,389 --> 01:13:55,099
so in here I just want to have what the

1471
01:13:52,729 --> 01:13:57,488
min V and the max V are so here I would

1472
01:13:55,099 --> 01:14:08,840
say look here is the max value and

1473
01:13:57,488 --> 01:14:13,759
here's the min value oops right and so

1474
01:14:08,840 --> 01:14:16,279
this can now just do a clamp kind of

1475
01:14:13,760 --> 01:14:20,949
equivalent to its other the other

1476
01:14:16,279 --> 01:14:23,630
routine so clamp between 0 and 1 right

1477
01:14:20,948 --> 01:14:25,609
and now anyone can use that clamp and it

1478
01:14:23,630 --> 01:14:30,050
makes just a little easier for this is

1479
01:14:25,609 --> 01:14:34,759
simpler for people to use okay

1480
01:14:30,050 --> 01:14:45,139
so I think we're mostly done now hmm

1481
01:14:34,760 --> 01:14:52,219
oh crap so yeah oops forgot about the

1482
01:14:45,139 --> 01:14:53,779
fact that we need these anyway so

1483
01:14:52,219 --> 01:14:56,029
nevermind my original thing wasn't as

1484
01:14:53,779 --> 01:14:59,768
stupid as I thought it was because hey

1485
01:14:56,029 --> 01:14:59,768
guess what we already had to do that

1486
01:15:05,920 --> 01:15:16,118
that's a bummer so because we need these

1487
01:15:09,979 --> 01:15:19,848
w's to still be around this shortcut is

1488
01:15:16,118 --> 01:15:22,518
not not really as feasible

1489
01:15:19,849 --> 01:15:28,989
I mean we can do it but because we have

1490
01:15:22,519 --> 01:15:31,840
to broadcast all these anyway yeah

1491
01:15:28,988 --> 01:15:35,169
alright so so much for being clever

1492
01:15:31,840 --> 01:15:38,170
there's really not much we can do there

1493
01:15:35,170 --> 01:15:38,170
right

1494
01:15:41,890 --> 01:15:48,010
least I don't see one which is a bummer

1495
01:15:55,810 --> 01:16:03,230
so I also wonder about this so because

1496
01:15:59,720 --> 01:16:17,930
these two I guess none of these really

1497
01:16:03,229 --> 01:16:19,639
matter what order you do them in but so

1498
01:16:17,930 --> 01:16:22,280
that's the zero one some two three some

1499
01:16:19,640 --> 01:16:28,869
so this is going to be zero two and four

1500
01:16:22,279 --> 01:16:35,899
six so I think that's all we need there

1501
01:16:28,869 --> 01:16:38,119
two four five six seven all right so so

1502
01:16:35,899 --> 01:16:49,819
much for being clever not gonna happen

1503
01:16:38,119 --> 01:16:51,559
unfortunately oops that's some so I

1504
01:16:49,819 --> 01:16:53,029
think we're down to just loading those

1505
01:16:51,560 --> 01:16:54,710
initial values so we're almost

1506
01:16:53,029 --> 01:16:56,630
completely done with the routine so

1507
01:16:54,710 --> 01:17:00,920
that's good and then we can take a look

1508
01:16:56,630 --> 01:17:02,569
at it so this load here again it depends

1509
01:17:00,920 --> 01:17:04,489
on how we want to do it we could just

1510
01:17:02,569 --> 01:17:05,119
flat load it directly I'm not going to

1511
01:17:04,489 --> 01:17:07,130
bother with that

1512
01:17:05,119 --> 01:17:09,890
because we don't really need to it this

1513
01:17:07,130 --> 01:17:12,230
particular moment we're not at that kind

1514
01:17:09,890 --> 01:17:14,090
of performance level where we're

1515
01:17:12,229 --> 01:17:15,559
worrying about you know did you do a

1516
01:17:14,090 --> 01:17:17,449
little bit of extra work to get the

1517
01:17:15,560 --> 01:17:19,700
stuff into the registers then maybe you

1518
01:17:17,449 --> 01:17:22,210
should have so we're going to ignore

1519
01:17:19,699 --> 01:17:22,210
that for now

1520
01:17:34,488 --> 01:17:39,299
and so those could be done much more

1521
01:17:37,498 --> 01:17:45,029
efficiently but we're just not going to

1522
01:17:39,300 --> 01:17:47,219
bother at the moment these pieces of

1523
01:17:45,029 --> 01:17:53,458
information have to come from the Atlas

1524
01:17:47,219 --> 01:17:55,260
grid so it would be this right and so I

1525
01:17:53,458 --> 01:18:02,938
might just make just so it's easier on

1526
01:17:55,260 --> 01:18:05,248
me I might just make I just might make a

1527
01:18:02,939 --> 01:18:08,609
alias for that so that I don't have to

1528
01:18:05,248 --> 01:18:17,938
keep typing it right so we'll just do

1529
01:18:08,609 --> 01:18:21,169
that up here and leave it at that okay

1530
01:18:17,939 --> 01:18:23,999
so in here we have the world P

1531
01:18:21,168 --> 01:18:24,958
apparently is not unknown thing but I

1532
01:18:23,998 --> 01:18:36,148
thought that came in

1533
01:18:24,958 --> 01:18:42,059
oh so it's actually it's sample P so

1534
01:18:36,149 --> 01:18:43,889
there's that okay so now we should be

1535
01:18:42,059 --> 01:18:45,418
able to run this code and in theory

1536
01:18:43,889 --> 01:18:48,118
unless we really screwed something up

1537
01:18:45,418 --> 01:18:50,639
which we probably did we should be able

1538
01:18:48,118 --> 01:18:54,808
to just it shouldn't do anything right

1539
01:18:50,639 --> 01:18:56,998
because we're not actually we're not

1540
01:18:54,809 --> 01:18:58,949
actually using it it's just running in a

1541
01:18:56,998 --> 01:19:02,849
pair it's like running in parallel right

1542
01:18:58,948 --> 01:19:09,658
with our with our existing code so what

1543
01:19:02,849 --> 01:19:12,300
that should allow me to do in theory is

1544
01:19:09,658 --> 01:19:13,228
take a look to see if the compiler well

1545
01:19:12,300 --> 01:19:15,449
you know the compiler probably

1546
01:19:13,229 --> 01:19:17,249
eliminated it it's probably the problem

1547
01:19:15,448 --> 01:19:19,018
I was gonna say we kind of want to look

1548
01:19:17,248 --> 01:19:20,519
to see if it generated any better code

1549
01:19:19,019 --> 01:19:22,739
but I don't know that we can't because

1550
01:19:20,519 --> 01:19:29,099
it probably doesn't actually exist Yeah

1551
01:19:22,738 --> 01:19:30,779
right it probably stops here so we'd

1552
01:19:29,099 --> 01:19:31,918
like to do is see what the compiler

1553
01:19:30,779 --> 01:19:33,238
generates for this code so I'm gonna

1554
01:19:31,918 --> 01:19:36,050
have to start using it which is not

1555
01:19:33,238 --> 01:19:38,829
really great because

1556
01:19:36,050 --> 01:19:51,500
we kind of know that it's wrong but

1557
01:19:38,829 --> 01:19:52,729
we'll try it anyway okay and so I'm

1558
01:19:51,500 --> 01:19:54,380
gonna do the exact same thing I just did

1559
01:19:52,729 --> 01:19:58,069
and I just want to look at the code

1560
01:19:54,380 --> 01:20:01,579
right so now we're actually are using

1561
01:19:58,069 --> 01:20:03,289
this code or we should be right and so I

1562
01:20:01,579 --> 01:20:04,850
just want to take a look and see what

1563
01:20:03,289 --> 01:20:11,920
this code actually looks like and so you

1564
01:20:04,850 --> 01:20:11,920
can see here the code for the routine

1565
01:20:12,220 --> 01:20:22,520
let's take a look at what happens when

1566
01:20:14,090 --> 01:20:27,560
we move in here first so a reason I

1567
01:20:22,520 --> 01:20:30,550
can't do we never get here show me

1568
01:20:27,560 --> 01:20:30,550
somewhere where you get

1569
01:20:40,960 --> 01:20:47,359
okay oh I forgot this probably cause of

1570
01:20:43,399 --> 01:20:49,250
threading right all right so with

1571
01:20:47,359 --> 01:20:53,059
compute Foxhall radiance that here's

1572
01:20:49,250 --> 01:20:55,600
where this routine starts right and so

1573
01:20:53,060 --> 01:20:58,070
just looking at what it's doing for code

1574
01:20:55,600 --> 01:20:59,600
my hope would be and of course the

1575
01:20:58,069 --> 01:21:00,739
problem is multiple threads are banging

1576
01:20:59,600 --> 01:21:02,420
on this at the same time so we really

1577
01:21:00,739 --> 01:21:05,809
kind of need this to be single threaded

1578
01:21:02,420 --> 01:21:07,880
if I actually want to look at it but

1579
01:21:05,810 --> 01:21:09,740
after it finishes with this SS stuff we

1580
01:21:07,880 --> 01:21:11,539
should go down to code that's more not

1581
01:21:09,739 --> 01:21:14,179
you know I can't even do this I got a I

1582
01:21:11,539 --> 01:21:16,310
got to do thread that first I can't deal

1583
01:21:14,180 --> 01:21:22,070
with that so let me just do thread this

1584
01:21:16,310 --> 01:21:30,800
first so where is internal lightning

1585
01:21:22,069 --> 01:21:38,989
core called so here's internal lighting

1586
01:21:30,800 --> 01:21:51,289
core I'm just gonna know if it real

1587
01:21:38,989 --> 01:21:53,389
quick and then I'm gonna run so now if

1588
01:21:51,289 --> 01:21:55,489
we take a look at the code you can see

1589
01:21:53,390 --> 01:21:58,850
it running through here real quick to

1590
01:21:55,489 --> 01:22:03,710
produce like the txt Y values and it's

1591
01:21:58,850 --> 01:22:05,060
doing that in just you know to get the

1592
01:22:03,710 --> 01:22:07,069
octahedral offset or whatever it's

1593
01:22:05,060 --> 01:22:11,060
there's the divide and all that crap

1594
01:22:07,069 --> 01:22:14,799
right and then hopefully does it is it

1595
01:22:11,060 --> 01:22:14,800
actually still doing all this crap I

1596
01:22:15,159 --> 01:22:43,078
think it is all right hold on a second

1597
01:22:21,389 --> 01:22:44,609
I should also just real quick so here's

1598
01:22:43,078 --> 01:22:50,340
the threading I just want to turn the

1599
01:22:44,609 --> 01:22:51,688
threading off like that basically um so

1600
01:22:50,340 --> 01:22:53,309
what I'm gonna do here is just get rid

1601
01:22:51,689 --> 01:22:55,619
of all this code because I don't know

1602
01:22:53,309 --> 01:22:56,909
even know it shouldn't be doing most of

1603
01:22:55,618 --> 01:22:58,679
this stuff but it looks like it actually

1604
01:22:56,908 --> 01:23:00,688
is it should only really compute that

1605
01:22:58,679 --> 01:23:05,069
txt Y value and then it shouldn't do any

1606
01:23:00,689 --> 01:23:06,599
of this like this is all not not good so

1607
01:23:05,069 --> 01:23:07,978
I'm just gonna try that and see what

1608
01:23:06,599 --> 01:23:09,119
happens because I just want to look at

1609
01:23:07,979 --> 01:23:10,619
the code I just want to see what it

1610
01:23:09,118 --> 01:23:27,799
should generate is it's pretty hard for

1611
01:23:10,618 --> 01:23:31,368
me to actually see alright so here we go

1612
01:23:27,800 --> 01:23:38,820
so you can see us starting to do some

1613
01:23:31,368 --> 01:23:41,788
loads in there what is going on I think

1614
01:23:38,819 --> 01:23:43,859
remedy might be busted here which

1615
01:23:41,788 --> 01:23:48,418
version are we on oh man

1616
01:23:43,859 --> 01:23:56,668
okay so we're on a hmm we're on a really

1617
01:23:48,418 --> 01:24:02,189
old version which is less good hold on

1618
01:23:56,668 --> 01:24:06,648
one second I kind of forgot to update

1619
01:24:02,189 --> 01:24:06,649
this machine that's like incredibly old

1620
01:24:06,769 --> 01:24:14,820
hold on one second it's just it's remedy

1621
01:24:12,748 --> 01:24:16,228
is you know it's good so a lot of times

1622
01:24:14,819 --> 01:24:17,728
I don't notice that I'm still using a

1623
01:24:16,229 --> 01:24:22,159
really old version but there are bugs

1624
01:24:17,729 --> 01:24:24,689
and it does the bugs do get fixed so

1625
01:24:22,158 --> 01:24:27,988
kind of gotta just make sure somebody

1626
01:24:24,689 --> 01:24:29,399
see ya it's 3:05 the latest version

1627
01:24:27,988 --> 01:24:30,808
what's the latest version let me just

1628
01:24:29,399 --> 01:24:32,990
make sure I even have the latest version

1629
01:24:30,809 --> 01:24:38,150
so

1630
01:24:32,989 --> 01:24:46,699
remedy BG that itch what's the latest

1631
01:24:38,149 --> 01:24:55,129
version anyone anyone we're just like

1632
01:24:46,699 --> 01:24:58,159
download now there's like a 307 looks

1633
01:24:55,130 --> 01:25:01,840
like all right so hold please

1634
01:24:58,159 --> 01:25:01,840
I'm just really quickly gonna actually

1635
01:25:01,899 --> 01:25:07,699
download the latest one because I didn't

1636
01:25:05,449 --> 01:25:12,050
realize that I was so far behind on

1637
01:25:07,699 --> 01:25:22,869
remedy for reasons I don't actually know

1638
01:25:12,050 --> 01:25:22,869
what they are so

1639
01:25:27,260 --> 01:25:32,750
let's take a look here remedy

1640
01:25:46,539 --> 01:25:54,590
and over I'm gonna close this sure save

1641
01:25:53,239 --> 01:25:57,859
it

1642
01:25:54,590 --> 01:26:02,329
watch the incredibly complicated install

1643
01:25:57,859 --> 01:26:04,729
process for remedy like let me launch

1644
01:26:02,329 --> 01:26:07,239
the Installer and download the updates

1645
01:26:04,729 --> 01:26:11,299
and the package manager it's just that

1646
01:26:07,239 --> 01:26:12,769
it's the executable in a zip file this

1647
01:26:11,300 --> 01:26:14,480
is how everything should be and

1648
01:26:12,770 --> 01:26:16,130
everything could be if people were

1649
01:26:14,479 --> 01:26:18,439
sensible when they made programs but

1650
01:26:16,130 --> 01:26:21,190
they're not so that was it that was

1651
01:26:18,439 --> 01:26:25,699
updating remedy and here's the update

1652
01:26:21,189 --> 01:26:29,169
right Microsoft did you see that did you

1653
01:26:25,699 --> 01:26:33,500
see how that works can you fathom it

1654
01:26:29,170 --> 01:26:34,760
alright so sorry about that I forgot

1655
01:26:33,500 --> 01:26:36,170
that I was using a very old version I

1656
01:26:34,760 --> 01:26:37,670
think there were some bugs in assembly

1657
01:26:36,170 --> 01:26:40,699
stepping I remember that being a thing

1658
01:26:37,670 --> 01:26:42,109
so let me try it yeah so you see how I'm

1659
01:26:40,699 --> 01:26:43,909
able to step through the assembly

1660
01:26:42,109 --> 01:26:45,829
correctly now so I forgot that in the

1661
01:26:43,909 --> 01:26:48,649
baseline 3 0 there was some sembly

1662
01:26:45,829 --> 01:26:49,880
stepping bugs I think and they got fixed

1663
01:26:48,649 --> 01:26:52,789
a long time ago but I just hadn't

1664
01:26:49,880 --> 01:26:54,440
updated the program all right so here we

1665
01:26:52,789 --> 01:26:56,210
are stepping through it unfortunately

1666
01:26:54,439 --> 01:27:00,619
the little overlay is kind of in the way

1667
01:26:56,210 --> 01:27:04,029
there but this is a bunch of singles

1668
01:27:00,619 --> 01:27:11,599
stuff so that's probably this code

1669
01:27:04,029 --> 01:27:13,819
happening here that's actually a lot of

1670
01:27:11,600 --> 01:27:15,260
code to do that we should probably try

1671
01:27:13,819 --> 01:27:19,609
and fix that code as well at some point

1672
01:27:15,260 --> 01:27:22,880
because that's not great um so at some

1673
01:27:19,609 --> 01:27:24,710
point here actually don't yeah it's just

1674
01:27:22,880 --> 01:27:26,810
a lot of code for no real reason I'm not

1675
01:27:24,710 --> 01:27:30,409
sure where that a lot of that's coming

1676
01:27:26,810 --> 01:27:33,710
from might be these weird like loads

1677
01:27:30,409 --> 01:27:35,420
that we're doing here so these are all

1678
01:27:33,710 --> 01:27:37,369
the converts you can see them loading up

1679
01:27:35,420 --> 01:27:40,579
so we could we could try to do that a

1680
01:27:37,369 --> 01:27:43,099
lot more efficiently so that's pretty

1681
01:27:40,579 --> 01:27:45,590
ugly here's the actual code we care

1682
01:27:43,100 --> 01:27:48,289
about starting to happen so now you can

1683
01:27:45,590 --> 01:27:51,170
see like this part's actually pretty

1684
01:27:48,289 --> 01:27:52,460
reasonable right it's a little ugly

1685
01:27:51,170 --> 01:27:55,159
because we have to do all these pee

1686
01:27:52,460 --> 01:27:57,890
extracts to actually start computing the

1687
01:27:55,159 --> 01:27:59,448
offsets and stuff right but otherwise

1688
01:27:57,890 --> 01:28:04,090
it's fine

1689
01:27:59,448 --> 01:28:08,988
once we're done with that this stuff

1690
01:28:04,090 --> 01:28:11,690
looks totally fine right just very

1691
01:28:08,988 --> 01:28:16,039
simple chefs moles ads right straight

1692
01:28:11,689 --> 01:28:17,599
line code no spilling there well you

1693
01:28:16,039 --> 01:28:20,539
know a little bit of loads in but no

1694
01:28:17,600 --> 01:28:21,829
spills look at that very nice remember

1695
01:28:20,539 --> 01:28:25,340
how much spilling there was before very

1696
01:28:21,829 --> 01:28:28,100
very clean here totally reasonable yeah

1697
01:28:25,340 --> 01:28:30,800
that looks fine okay so the top part

1698
01:28:28,100 --> 01:28:32,239
still sucks a little and maybe could

1699
01:28:30,800 --> 01:28:33,949
stand it but but now we don't have all

1700
01:28:32,238 --> 01:28:35,419
that there was just a lot of ridiculous

1701
01:28:33,948 --> 01:28:39,198
garbage going on this all looks pretty

1702
01:28:35,420 --> 01:28:41,140
reasonable okay so we're good there I'm

1703
01:28:39,198 --> 01:28:43,359
happy with that

1704
01:28:41,140 --> 01:28:47,210
honestly it looks like it just worked

1705
01:28:43,359 --> 01:28:48,529
this is single threaded by the way it

1706
01:28:47,210 --> 01:28:50,869
looks like it actually just worked it

1707
01:28:48,529 --> 01:28:52,789
could we should probably still do the

1708
01:28:50,869 --> 01:28:56,149
comparison but that's that's kind of

1709
01:28:52,789 --> 01:28:57,560
nuts what are the chances that we got

1710
01:28:56,149 --> 01:29:00,409
the whole thing right the first time or

1711
01:28:57,560 --> 01:29:02,690
that doesn't seem likely but but it

1712
01:29:00,409 --> 01:29:08,448
actually looks good so it's not too far

1713
01:29:02,689 --> 01:29:12,859
off right I mean it looks like it looked

1714
01:29:08,448 --> 01:29:14,899
before so we may still be kind of wrong

1715
01:29:12,859 --> 01:29:17,710
there I don't know but it looks pretty

1716
01:29:14,899 --> 01:29:17,710
good right

1717
01:29:18,010 --> 01:29:22,070
so let's lick end there for today we

1718
01:29:20,539 --> 01:29:24,380
probably want to do the testing of this

1719
01:29:22,069 --> 01:29:26,479
next weekend I would like now to just to

1720
01:29:24,380 --> 01:29:32,270
see what the actual performance ended up

1721
01:29:26,479 --> 01:29:36,889
being so if I go to handmade debug and I

1722
01:29:32,270 --> 01:29:38,630
run this build of HH light prof what are

1723
01:29:36,890 --> 01:29:45,320
we getting because remember we were

1724
01:29:38,630 --> 01:29:49,010
taking a look at these values here we

1725
01:29:45,319 --> 01:29:50,269
can try turning off the cast again we

1726
01:29:49,010 --> 01:29:51,920
can also compare against these values so

1727
01:29:50,270 --> 01:29:54,320
I'm just curious what we ended up with

1728
01:29:51,920 --> 01:29:56,480
if there was a speed difference from

1729
01:29:54,319 --> 01:29:58,819
that first pass over the routine which

1730
01:29:56,479 --> 01:30:00,559
there might have been I don't know if we

1731
01:29:58,819 --> 01:30:01,880
did enough because that top part still

1732
01:30:00,560 --> 01:30:05,300
looks really crappy so we're probably to

1733
01:30:01,880 --> 01:30:07,989
fix that but let's just see what we got

1734
01:30:05,300 --> 01:30:07,989
because I don't know

1735
01:30:12,250 --> 01:30:25,069
so actually if you look at that speed

1736
01:30:17,689 --> 01:30:33,939
difference its massive actually so grid

1737
01:30:25,069 --> 01:30:41,590
with optimized compute irradiance that's

1738
01:30:33,939 --> 01:30:41,589
2.3 seconds faster right just from that

1739
01:30:44,560 --> 01:30:52,010
so that's kind of nuts right if you look

1740
01:30:48,380 --> 01:30:54,109
at what kind of a speeding increase we

1741
01:30:52,010 --> 01:30:55,940
got from that that's kind of ridiculous

1742
01:30:54,109 --> 01:30:59,210
right that's a massive speed boost and

1743
01:30:55,939 --> 01:31:02,329
by the way that would happen here too

1744
01:30:59,210 --> 01:31:06,859
right so if we went back to the AABB

1745
01:31:02,329 --> 01:31:11,779
tester that's also calling this routine

1746
01:31:06,859 --> 01:31:15,219
so if we do this and do a test of a be

1747
01:31:11,779 --> 01:31:18,819
walk that one should have been

1748
01:31:15,220 --> 01:31:18,820
accelerated to

1749
01:31:30,270 --> 01:31:40,870
so yeah since this one so now we can out

1750
01:31:39,430 --> 01:31:43,450
so one of the really interesting things

1751
01:31:40,869 --> 01:31:46,659
that this uncovers too so there's some

1752
01:31:43,449 --> 01:31:48,519
interesting things here right so the

1753
01:31:46,659 --> 01:31:50,229
other thing you can see here is notice

1754
01:31:48,520 --> 01:31:52,060
that this one did get about a second

1755
01:31:50,229 --> 01:31:53,859
faster but this one got 2 seconds faster

1756
01:31:52,060 --> 01:31:55,840
what you can see here is that's because

1757
01:31:53,859 --> 01:31:58,239
I think our grid ray caster is like way

1758
01:31:55,840 --> 01:32:00,100
faster than the AABB ray caster but you

1759
01:31:58,239 --> 01:32:02,889
can't tell as much because the grid ray

1760
01:32:00,100 --> 01:32:05,530
caster does more sampling because it

1761
01:32:02,890 --> 01:32:09,700
does early-out pulls which the AABB

1762
01:32:05,529 --> 01:32:12,099
sampler never did right so this one's

1763
01:32:09,699 --> 01:32:14,529
calling computer radiance much more than

1764
01:32:12,100 --> 01:32:16,960
this one is and so it was making our

1765
01:32:14,529 --> 01:32:19,029
grid look worse than it was now mind you

1766
01:32:16,960 --> 01:32:20,619
I still think I can take quite a bit of

1767
01:32:19,029 --> 01:32:23,969
time off the grid ray caster by doing a

1768
01:32:20,619 --> 01:32:26,590
few things to it but anyway point being

1769
01:32:23,970 --> 01:32:29,230
really good work there I think we should

1770
01:32:26,590 --> 01:32:30,789
be really proud of that haven't verified

1771
01:32:29,229 --> 01:32:32,889
it yet so we should probably go in and

1772
01:32:30,789 --> 01:32:36,659
actually do some better testing on it

1773
01:32:32,890 --> 01:32:36,660
but that's looking really good right

1774
01:32:36,699 --> 01:32:43,420
so anyway oops let's get rid of that I

1775
01:32:40,659 --> 01:32:45,670
don't know why the ABS why did the a BB

1776
01:32:43,420 --> 01:32:48,520
test or not produce any light is it

1777
01:32:45,670 --> 01:32:51,489
calling the radians caster wrong or

1778
01:32:48,520 --> 01:32:52,540
something I was weird let's go look at

1779
01:32:51,489 --> 01:32:56,199
what's going on there because I don't

1780
01:32:52,539 --> 01:32:58,750
actually know so anyway that might still

1781
01:32:56,199 --> 01:33:01,420
be wrong but if you take a look at this

1782
01:32:58,750 --> 01:33:08,710
number keeps going down quite a bit

1783
01:33:01,420 --> 01:33:11,710
right and so I think we're making a lot

1784
01:33:08,710 --> 01:33:13,000
of progress here just on in terms of

1785
01:33:11,710 --> 01:33:16,119
like what's actually happening and if we

1786
01:33:13,000 --> 01:33:19,210
take a look at our threads view here you

1787
01:33:16,119 --> 01:33:21,399
can also see that like you know I think

1788
01:33:19,210 --> 01:33:23,140
we probably if we if we just turned the

1789
01:33:21,399 --> 01:33:24,460
debug system off we're already at 60

1790
01:33:23,140 --> 01:33:28,210
frames a second because we're really

1791
01:33:24,460 --> 01:33:29,980
close to it right 16 if that number 16

1792
01:33:28,210 --> 01:33:32,949
which that kind of looks like it would

1793
01:33:29,979 --> 01:33:35,500
be I think we'd kind of be there already

1794
01:33:32,949 --> 01:33:37,119
so I think we're pretty much zeroing in

1795
01:33:35,500 --> 01:33:40,810
on our on our goal here like

1796
01:33:37,119 --> 01:33:42,220
think we're getting there but I also

1797
01:33:40,810 --> 01:33:43,960
think that there may be some bugs in

1798
01:33:42,220 --> 01:33:46,350
that routine so we got to fix that first

1799
01:33:43,960 --> 01:33:51,930
right

1800
01:33:46,350 --> 01:33:54,940
so anyway point being looking good

1801
01:33:51,930 --> 01:33:56,500
quality is up next but the optimization

1802
01:33:54,939 --> 01:33:57,849
is looking really good and we have more

1803
01:33:56,500 --> 01:33:59,619
we can do so we'll do a little bit more

1804
01:33:57,850 --> 01:34:11,079
of that and then we'll switch over to

1805
01:33:59,619 --> 01:34:19,539
quality all right we can do a brief Q&amp;A

1806
01:34:11,079 --> 01:34:20,500
let me should I guess I don't need to

1807
01:34:19,539 --> 01:34:23,880
eject that just now

1808
01:34:20,500 --> 01:34:23,880
[Music]

1809
01:34:59,699 --> 01:35:06,389
do you plan on bringing your editor on

1810
01:35:01,739 --> 01:35:12,949
stream no can you run light prof without

1811
01:35:06,390 --> 01:35:18,840
any days can't you run light prof

1812
01:35:12,949 --> 01:35:22,639
without any days o light prof without

1813
01:35:18,840 --> 01:35:24,960
any rays yes you just want the bookend

1814
01:35:22,640 --> 01:35:26,640
value right is that what you're talking

1815
01:35:24,960 --> 01:35:28,649
about you want to know what grid book

1816
01:35:26,640 --> 01:35:38,850
ends only looks like now so basically

1817
01:35:28,649 --> 01:35:50,039
like this and yes we can

1818
01:35:38,850 --> 01:35:54,660
so all we needed to do for that was was

1819
01:35:50,039 --> 01:35:58,109
this so basically if we just force it to

1820
01:35:54,659 --> 01:35:59,880
early out every time it's basically

1821
01:35:58,109 --> 01:36:01,889
doing 100% of the work but it just

1822
01:35:59,880 --> 01:36:07,310
doesn't actually do this the grid walk

1823
01:36:01,890 --> 01:36:16,350
right so if you take a look at that mmm

1824
01:36:07,310 --> 01:36:18,360
there you go and unsurprisingly it's

1825
01:36:16,350 --> 01:36:21,450
it's sort of similar to this number

1826
01:36:18,359 --> 01:36:24,029
right so basically what's happening

1827
01:36:21,449 --> 01:36:27,389
there is you know we're down to two

1828
01:36:24,029 --> 01:36:36,289
point five four just doing the the read

1829
01:36:27,390 --> 01:36:36,289
right there right so

1830
01:36:47,010 --> 01:36:52,989
can we time the function with the debug

1831
01:36:50,890 --> 01:36:54,789
system so we see how the top part of

1832
01:36:52,989 --> 01:37:01,210
that function takes not really because

1833
01:36:54,789 --> 01:37:02,769
it gets called too many times why is

1834
01:37:01,210 --> 01:37:04,539
frame time stability such a rare

1835
01:37:02,770 --> 01:37:11,170
impossible thing without leaving

1836
01:37:04,539 --> 01:37:18,600
Headroom yeah I mean you know the answer

1837
01:37:11,170 --> 01:37:21,279
is because modern computer architectures

1838
01:37:18,600 --> 01:37:23,170
simply aren't structured around

1839
01:37:21,279 --> 01:37:26,829
repeatability that's not really what

1840
01:37:23,170 --> 01:37:28,960
they do CPUs are currently designed to

1841
01:37:26,829 --> 01:37:31,059
just extract the most amount of compute

1842
01:37:28,960 --> 01:37:33,640
that can out of their computation units

1843
01:37:31,060 --> 01:37:36,700
and that is just an inherently noisy

1844
01:37:33,640 --> 01:37:40,960
process it depends entirely on the cache

1845
01:37:36,699 --> 01:37:42,939
and on you know the order in which

1846
01:37:40,960 --> 01:37:48,250
things have happened so far and it's

1847
01:37:42,939 --> 01:37:51,279
just there they're not like the old in

1848
01:37:48,250 --> 01:37:54,789
order processors that were just very

1849
01:37:51,279 --> 01:37:58,479
lockstep and 100% predictable right so

1850
01:37:54,789 --> 01:38:01,630
the way you have to think of it is that

1851
01:37:58,479 --> 01:38:04,089
the underlying performance of a modern

1852
01:38:01,630 --> 01:38:06,909
algorithm on modern hardware is just

1853
01:38:04,090 --> 01:38:10,449
always inherently noisy because it's

1854
01:38:06,909 --> 01:38:18,880
never the same exact cash setup and the

1855
01:38:10,449 --> 01:38:23,409
exact port fills every time cache

1856
01:38:18,880 --> 01:38:28,680
occupancy port status like what's in the

1857
01:38:23,409 --> 01:38:32,409
pipeline branch predictor or state Trant

1858
01:38:28,680 --> 01:38:33,880
TLB so address mappings all of these

1859
01:38:32,409 --> 01:38:35,139
things even if you took the operating

1860
01:38:33,880 --> 01:38:37,859
system out of the equation and we're

1861
01:38:35,140 --> 01:38:42,760
just running raw all of that stuff

1862
01:38:37,859 --> 01:38:46,210
changes the performance right so it's

1863
01:38:42,760 --> 01:38:47,680
just you can't no you can't no you have

1864
01:38:46,210 --> 01:38:48,609
to treat it as noisy in what you're

1865
01:38:47,680 --> 01:38:53,460
trying to do is figure out what the

1866
01:38:48,609 --> 01:38:53,460
bounds on that noise are so

1867
01:38:54,020 --> 01:39:00,410
do we activate threading in for

1868
01:38:56,039 --> 01:39:02,909
benchmark yeah I'm pretty sure we did

1869
01:39:00,409 --> 01:39:05,809
first of all the threading is always on

1870
01:39:02,909 --> 01:39:05,809
in the benchmark

1871
01:39:17,020 --> 01:39:21,940
I sent you an email regarding this to

1872
01:39:20,680 --> 01:39:23,619
see stuff you did in today's stream you

1873
01:39:21,939 --> 01:39:24,219
might get a smile out of it okay I will

1874
01:39:23,619 --> 01:39:30,069
check it out

1875
01:39:24,220 --> 01:39:31,539
so as I'm off stream naysayer mentioned

1876
01:39:30,069 --> 01:39:32,559
you discussed with him my programming

1877
01:39:31,539 --> 01:39:36,159
languages shouldn't have unsigned

1878
01:39:32,560 --> 01:39:38,770
integers no I I said they shouldn't have

1879
01:39:36,159 --> 01:39:42,099
signed and unsigned integers they should

1880
01:39:38,770 --> 01:39:45,370
just have integers and the reason is

1881
01:39:42,100 --> 01:39:46,930
because those don't exist in the CPU so

1882
01:39:45,369 --> 01:39:48,220
there's just a few operations that

1883
01:39:46,930 --> 01:39:54,000
actually differentiate between them

1884
01:39:48,220 --> 01:39:54,000
comparison multiplication and division

1885
01:39:54,449 --> 01:40:03,329
right some have assigned shift does

1886
01:39:59,800 --> 01:40:07,300
theirs are called arithmetic shifts and

1887
01:40:03,329 --> 01:40:08,859
like that's what I kind of want to talk

1888
01:40:07,300 --> 01:40:10,539
about when I'm programming I don't

1889
01:40:08,859 --> 01:40:11,920
really want to talk about this thing as

1890
01:40:10,539 --> 01:40:13,560
signed or unsigned because it's really

1891
01:40:11,920 --> 01:40:18,399
just most of the time it doesn't matter

1892
01:40:13,560 --> 01:40:20,800
like if you add if you do an addition or

1893
01:40:18,399 --> 01:40:23,049
subtraction of numbers it doesn't matter

1894
01:40:20,800 --> 01:40:24,909
which one you're doing right like you

1895
01:40:23,050 --> 01:40:28,360
don't care about those things usually

1896
01:40:24,909 --> 01:40:30,819
because most operations that you're

1897
01:40:28,359 --> 01:40:32,920
going to do don't care that the thing is

1898
01:40:30,819 --> 01:40:34,420
signed or unsigned right and so I'd

1899
01:40:32,920 --> 01:40:37,500
rather just talk about it when I

1900
01:40:34,420 --> 01:40:40,770
actually want to know which one it is

1901
01:40:37,500 --> 01:40:43,979
you know what I mean

1902
01:40:40,770 --> 01:40:43,980
that's all

1903
01:40:49,149 --> 01:40:55,479
can you compile all files in all

1904
01:40:51,609 --> 01:40:59,170
subdirectories with CL recursively you

1905
01:40:55,479 --> 01:41:02,319
mean like using the just the command CL

1906
01:40:59,170 --> 01:41:07,119
no it doesn't have it doesn't have that

1907
01:41:02,319 --> 01:41:08,469
as far as I know can you use some of the

1908
01:41:07,119 --> 01:41:12,420
lighting work you do on Hamid here on

1909
01:41:08,470 --> 01:41:20,230
different projects I mean it's probably

1910
01:41:12,420 --> 01:41:24,340
applicable to low geometry complexity

1911
01:41:20,229 --> 01:41:34,289
scenarios so it depends if that's you

1912
01:41:24,340 --> 01:41:39,190
have or not when do we add special sauce

1913
01:41:34,289 --> 01:41:42,689
I would say that we are kind of always

1914
01:41:39,189 --> 01:41:42,689
adding a little bit of a special sauce

1915
01:41:46,890 --> 01:41:50,220
alright we good

1916
01:42:30,489 --> 01:42:35,599
couldn't the v3 XYZ be loaded with a

1917
01:42:32,689 --> 01:42:43,039
single load if we pad them some can some

1918
01:42:35,600 --> 01:42:44,750
can't I mean they both can but we so the

1919
01:42:43,039 --> 01:42:46,489
ones that are floats we can load

1920
01:42:44,750 --> 01:42:48,439
directly the ones that aren't floats we

1921
01:42:46,489 --> 01:42:50,750
would have to load and convert which

1922
01:42:48,439 --> 01:42:52,219
what we can that's why I said like I

1923
01:42:50,750 --> 01:42:53,329
wasn't remember I said I wasn't gonna do

1924
01:42:52,220 --> 01:42:56,140
anything with them at the moment I was

1925
01:42:53,329 --> 01:42:58,369
gonna leave them but we could write and

1926
01:42:56,140 --> 01:42:59,810
so it really depends on how much we

1927
01:42:58,369 --> 01:43:01,579
think that's costing us and we could

1928
01:42:59,810 --> 01:43:03,110
certainly try it what do we probably do

1929
01:43:01,579 --> 01:43:04,340
is not bother patting them first

1930
01:43:03,109 --> 01:43:05,869
just try loading them and see what

1931
01:43:04,340 --> 01:43:07,220
performance we get and if we got a

1932
01:43:05,869 --> 01:43:07,729
significant boost then maybe like oh

1933
01:43:07,220 --> 01:43:10,909
okay

1934
01:43:07,729 --> 01:43:12,500
we can go ahead and pad them cuz only

1935
01:43:10,909 --> 01:43:14,149
some of them have to be padded right

1936
01:43:12,500 --> 01:43:19,250
because like if you take a look at

1937
01:43:14,149 --> 01:43:25,009
what's actually going on there what you

1938
01:43:19,250 --> 01:43:27,229
can see is that in here where we're

1939
01:43:25,010 --> 01:43:30,199
doing these loads so if you take a look

1940
01:43:27,229 --> 01:43:33,139
at what is in one of those Atlas voxel

1941
01:43:30,199 --> 01:43:36,559
grid things right you can see here that

1942
01:43:33,140 --> 01:43:40,760
like there's like a cell count thing and

1943
01:43:36,560 --> 01:43:43,850
stuff or whatever and so we know that

1944
01:43:40,760 --> 01:43:45,710
actually these are just loadable right

1945
01:43:43,850 --> 01:43:48,140
we could just load them because they

1946
01:43:45,710 --> 01:43:49,579
already have the padding off the end we

1947
01:43:48,140 --> 01:43:51,380
don't need this to be zero

1948
01:43:49,579 --> 01:43:54,710
we never care what it is it could be

1949
01:43:51,380 --> 01:43:56,810
anything and we could always mask it off

1950
01:43:54,710 --> 01:44:00,079
even if we did right so we could just

1951
01:43:56,810 --> 01:44:03,350
load this could be a flat load and that

1952
01:44:00,079 --> 01:44:05,659
could be a flat load this is less of a

1953
01:44:03,350 --> 01:44:07,460
flat load because really what you'd want

1954
01:44:05,659 --> 01:44:11,680
to do is just pass it in that way which

1955
01:44:07,460 --> 01:44:11,680
is what I think we would do in fact this

1956
01:44:13,300 --> 01:44:16,960
applies here as well

1957
01:44:23,100 --> 01:44:27,910
because we could probably have the outer

1958
01:44:25,329 --> 01:44:30,519
code be smarter about how it produces

1959
01:44:27,909 --> 01:44:32,590
that sample value so that one could

1960
01:44:30,520 --> 01:44:35,800
probably says what can't really be done

1961
01:44:32,590 --> 01:44:37,449
that way exactly is these while while

1962
01:44:35,800 --> 01:44:38,980
they sort of could be done you can see

1963
01:44:37,449 --> 01:44:41,380
they're a little bit more complicated so

1964
01:44:38,979 --> 01:44:43,449
this one would have to be loaded and

1965
01:44:41,380 --> 01:44:47,829
converted but that's not a huge deal we

1966
01:44:43,449 --> 01:44:50,639
could do that and also it's that value

1967
01:44:47,829 --> 01:44:54,970
so we could choose to store this as a v3

1968
01:44:50,640 --> 01:44:57,940
instead because you know it's free for

1969
01:44:54,970 --> 01:45:00,460
us to do so so we could put a F because

1970
01:44:57,939 --> 01:45:03,099
it doesn't change right so we could put

1971
01:45:00,460 --> 01:45:06,340
that here and do a single load out of it

1972
01:45:03,100 --> 01:45:08,079
as well so there's a ton of stuff we

1973
01:45:06,340 --> 01:45:18,039
could do I can mark that for you if you

1974
01:45:08,079 --> 01:45:19,269
want um so it's really just this that's

1975
01:45:18,039 --> 01:45:21,850
a little more complicated you can see

1976
01:45:19,270 --> 01:45:24,600
this one is the thing but we could also

1977
01:45:21,850 --> 01:45:24,600
store this

1978
01:45:35,439 --> 01:45:43,819
right so in a lot of ways we could

1979
01:45:41,569 --> 01:45:46,189
choose to weld these values directly in

1980
01:45:43,819 --> 01:45:48,198
there and just have them be f/32 for X's

1981
01:45:46,189 --> 01:45:51,559
that we just load out because they're

1982
01:45:48,198 --> 01:45:53,809
constants right so you know that's

1983
01:45:51,560 --> 01:45:55,070
something we could totally do and maybe

1984
01:45:53,810 --> 01:45:59,530
next weekend we can look at it right

1985
01:45:55,069 --> 01:46:11,840
it's because doing you know mind as well

1986
01:45:59,529 --> 01:46:13,399
it's pretty much free to do it are there

1987
01:46:11,840 --> 01:46:15,679
any fundamental differences between game

1988
01:46:13,399 --> 01:46:23,769
engines that use low poly models versus

1989
01:46:15,679 --> 01:46:28,130
this one yeah

1990
01:46:23,770 --> 01:46:31,400
yeah I think there would be so the

1991
01:46:28,130 --> 01:46:35,690
primary difference that I would say that

1992
01:46:31,399 --> 01:46:37,819
you would need to do is our renderer

1993
01:46:35,689 --> 01:46:39,948
assumes you're just gonna be pushing

1994
01:46:37,819 --> 01:46:44,269
quads because most of the things on the

1995
01:46:39,948 --> 01:46:46,698
screen are quads if you were using low

1996
01:46:44,270 --> 01:46:49,280
poly models you would need so you know

1997
01:46:46,698 --> 01:46:50,869
how our texture system like pushes

1998
01:46:49,279 --> 01:46:54,859
things to the card and has like a cache

1999
01:46:50,869 --> 01:46:59,960
there for that and whatever you probably

2000
01:46:54,859 --> 01:47:02,929
need that for model data right because

2001
01:46:59,960 --> 01:47:05,119
you'd want even low poly models get

2002
01:47:02,929 --> 01:47:08,119
large quickly so you don't really want

2003
01:47:05,119 --> 01:47:11,050
to send those down as quads like that so

2004
01:47:08,119 --> 01:47:13,670
I would say you probably want a cache

2005
01:47:11,050 --> 01:47:16,429
that's the same as our texture system

2006
01:47:13,670 --> 01:47:23,079
but you know for models basically you'd

2007
01:47:16,429 --> 01:47:23,079
want something like that so

2008
01:47:34,198 --> 01:47:41,819
yeah I don't use emacs anymore used for

2009
01:47:36,810 --> 01:47:43,380
coder on stream which I need to update I

2010
01:47:41,819 --> 01:47:49,799
need to update to the latest for Carter

2011
01:47:43,380 --> 01:47:54,000
this is ancient actually so I was gonna

2012
01:47:49,800 --> 01:47:56,250
update to Ryan Flurry's public custom

2013
01:47:54,000 --> 01:47:58,890
layer and integrate anything that wasn't

2014
01:47:56,250 --> 01:48:00,920
already in there from mine into his so

2015
01:47:58,890 --> 01:48:05,070
that it's just in a github somewhere I

2016
01:48:00,920 --> 01:48:11,929
just haven't had time but that's what I

2017
01:48:05,069 --> 01:48:15,469
would like to do all right shut it down

2018
01:48:11,929 --> 01:48:15,469
loop oops

2019
01:48:23,738 --> 01:48:27,979
okay thank you everyone for joining me

2020
01:48:26,719 --> 01:48:29,689
for an episode of hand made here at Sona

2021
01:48:27,979 --> 01:48:30,678
pleasure coding with you as always if

2022
01:48:29,689 --> 01:48:31,789
you'd like to follow on series at home

2023
01:48:30,679 --> 01:48:33,289
you can always peer to the game at

2024
01:48:31,789 --> 01:48:35,149
handmade hero organic comes to the

2025
01:48:33,289 --> 01:48:38,090
source code so you can follow along with

2026
01:48:35,149 --> 01:48:40,488
it the optimization works going actually

2027
01:48:38,090 --> 01:48:43,460
really well so it looks like we're

2028
01:48:40,488 --> 01:48:45,019
totally gonna hit our goals we may have

2029
01:48:43,460 --> 01:48:46,460
actually already hit them but I have a

2030
01:48:45,020 --> 01:48:48,050
bunch of other stuff that I wanted to do

2031
01:48:46,460 --> 01:48:49,670
so I'm going to finish doing those

2032
01:48:48,050 --> 01:48:50,989
because I think our grid red caster can

2033
01:48:49,670 --> 01:48:53,420
get dramatically faster than it is

2034
01:48:50,988 --> 01:48:55,158
without a whole lot of extra work there

2035
01:48:53,420 --> 01:48:59,420
so I just want to try out some of those

2036
01:48:55,158 --> 01:49:00,710
things and and verify that and then of

2037
01:48:59,420 --> 01:49:02,090
course also that routine that we just

2038
01:49:00,710 --> 01:49:04,730
found was actually a pretty big deal for

2039
01:49:02,090 --> 01:49:07,039
us we can improve that a little bit too

2040
01:49:04,729 --> 01:49:08,059
without too much work by just finishing

2041
01:49:07,039 --> 01:49:11,029
off so in the opportunities we were

2042
01:49:08,060 --> 01:49:13,730
doing so actually there's just a lot of

2043
01:49:11,029 --> 01:49:15,679
stuff we can do and so since there's so

2044
01:49:13,729 --> 01:49:17,029
many low-hanging fruits here to pick now

2045
01:49:15,679 --> 01:49:20,270
that we've kind of got things structured

2046
01:49:17,029 --> 01:49:21,500
well we might as let's go picking and so

2047
01:49:20,270 --> 01:49:23,560
next weekend that's what we'll do we'll

2048
01:49:21,500 --> 01:49:26,719
do a bunch of those and see how it goes

2049
01:49:23,560 --> 01:49:28,610
that's it for today I'll probably be

2050
01:49:26,719 --> 01:49:30,679
back here next weekend for that I

2051
01:49:28,609 --> 01:49:32,299
haven't posted schedule yet but I'll try

2052
01:49:30,679 --> 01:49:34,039
to get scheduled up relatively soon

2053
01:49:32,300 --> 01:49:35,570
hopes you back for that till then have

2054
01:49:34,039 --> 01:49:38,710
from putting everyone I'll see on the

2055
01:49:35,569 --> 01:49:38,710
Internet piggies everybody

