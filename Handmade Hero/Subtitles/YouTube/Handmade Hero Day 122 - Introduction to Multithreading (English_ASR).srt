1
00:00:00,949 --> 00:00:05,309
okay hello everyone and welcome to

2
00:00:03,509 --> 00:00:10,439
handmade Hero the show recode complete

3
00:00:05,309 --> 00:00:12,649
games live on Twitch no engines no no

4
00:00:10,439 --> 00:00:15,750
libraries no nothing it's just us and

5
00:00:12,650 --> 00:00:18,449
today we're starting a topic that's

6
00:00:15,750 --> 00:00:21,750
actually unfortunately bad news for

7
00:00:18,449 --> 00:00:24,109
everyone out there unfortunately it's

8
00:00:21,750 --> 00:00:29,719
important yep

9
00:00:24,109 --> 00:00:32,368
and I don't say unfortunately because of

10
00:00:29,719 --> 00:00:33,899
anything like because it's bad to have

11
00:00:32,368 --> 00:00:35,159
important topics on hanbit here

12
00:00:33,899 --> 00:00:36,390
obviously it's great to have important

13
00:00:35,159 --> 00:00:40,229
topics on Hanneman here I say

14
00:00:36,390 --> 00:00:44,969
unfortunately because really there is

15
00:00:40,229 --> 00:00:47,599
nothing inherently inherently

16
00:00:44,969 --> 00:00:50,760
interesting in some sense you might say

17
00:00:47,600 --> 00:00:51,629
when you try to solve problems given

18
00:00:50,759 --> 00:00:54,329
this thing that we're going to talk

19
00:00:51,628 --> 00:00:56,909
about today it is literally just another

20
00:00:54,329 --> 00:00:59,910
layer you have to pile on to the

21
00:00:56,909 --> 00:01:02,968
problems that you already have so it's

22
00:00:59,909 --> 00:01:04,768
not like optimization where you're

23
00:01:02,969 --> 00:01:08,210
talking about taking a problem and

24
00:01:04,769 --> 00:01:11,368
solving it down to a more fine level

25
00:01:08,209 --> 00:01:13,769
this is not what this is what we're

26
00:01:11,368 --> 00:01:17,368
talking about today is is really it just

27
00:01:13,769 --> 00:01:19,500
adds to your to your troubles and in

28
00:01:17,368 --> 00:01:21,868
some sense unfortunately this is the

29
00:01:19,500 --> 00:01:24,180
thing that that really programming

30
00:01:21,868 --> 00:01:25,950
languages and high-level stuff hasn't

31
00:01:24,180 --> 00:01:29,220
really solved that well either it's it's

32
00:01:25,950 --> 00:01:30,930
just relatively nasty and so on handmade

33
00:01:29,219 --> 00:01:32,929
here we'll try to show some ways that

34
00:01:30,930 --> 00:01:37,770
you can make it a lot less nasty and

35
00:01:32,930 --> 00:01:40,049
think about it as a you know in in sort

36
00:01:37,769 --> 00:01:41,578
of a simple way as possible but I won't

37
00:01:40,049 --> 00:01:44,670
lie to you it is one of those things

38
00:01:41,578 --> 00:01:46,978
that has just been sort of creeping up

39
00:01:44,670 --> 00:01:48,960
on programming and it keeps being more

40
00:01:46,978 --> 00:01:51,328
and more important to do and it never

41
00:01:48,959 --> 00:01:52,679
really gets all that much easier I'm

42
00:01:51,328 --> 00:01:55,938
beating around the bush but of course

43
00:01:52,680 --> 00:01:55,939
the subject is multi-threading

44
00:01:56,269 --> 00:02:03,179
multi-threading is the process by which

45
00:02:00,299 --> 00:02:06,210
you have multiple simultaneously

46
00:02:03,180 --> 00:02:08,969
executing CPU cores or separate

47
00:02:06,209 --> 00:02:12,299
processors entirely working on problems

48
00:02:08,969 --> 00:02:13,590
together and if you're lucky you can

49
00:02:12,300 --> 00:02:14,939
separate them out so that

50
00:02:13,590 --> 00:02:17,400
degree to which they have to communicate

51
00:02:14,939 --> 00:02:20,939
with each other is very small if you are

52
00:02:17,400 --> 00:02:22,860
unlucky then you cannot and really that

53
00:02:20,939 --> 00:02:25,019
depends on the problem and sometimes

54
00:02:22,860 --> 00:02:26,519
your own ingenuity let's go to the

55
00:02:25,019 --> 00:02:29,099
blackboard first and I'll talk a little

56
00:02:26,519 --> 00:02:31,289
bit about how this sort of stuff goes

57
00:02:29,098 --> 00:02:32,699
down and then we'll sort of show how to

58
00:02:31,289 --> 00:02:34,378
create some threads and get them doing

59
00:02:32,699 --> 00:02:36,359
some things I don't know how far we'll

60
00:02:34,378 --> 00:02:38,370
get into it today because we'll have to

61
00:02:36,360 --> 00:02:41,940
cover the basics and win32 of how to

62
00:02:38,370 --> 00:02:43,890
actually make these things but will by

63
00:02:41,939 --> 00:02:45,000
tomorrow at least we'll be at the point

64
00:02:43,889 --> 00:02:48,208
where we're actually having things

65
00:02:45,000 --> 00:02:51,259
happen multi-threading it's not that

66
00:02:48,209 --> 00:02:55,709
hard to get there all right so

67
00:02:51,259 --> 00:02:57,598
multi-threading so first of all let's

68
00:02:55,709 --> 00:02:59,909
just say very briefly what this even

69
00:02:57,598 --> 00:03:01,679
means and why this phrase exists the way

70
00:02:59,909 --> 00:03:03,719
it does so you'll notice you have this

71
00:03:01,680 --> 00:03:05,400
thing called threading here which we've

72
00:03:03,719 --> 00:03:07,318
never really talked about that much and

73
00:03:05,400 --> 00:03:08,670
basically that's because there's these

74
00:03:07,318 --> 00:03:11,458
words that have been introduced in

75
00:03:08,669 --> 00:03:14,098
operating system parlance that have to

76
00:03:11,459 --> 00:03:17,280
do with with certain degrees of

77
00:03:14,098 --> 00:03:20,699
execution granularity and they tend to

78
00:03:17,280 --> 00:03:24,060
be processed thread and fiber what what

79
00:03:20,699 --> 00:03:27,479
generally these things refer to are the

80
00:03:24,060 --> 00:03:30,109
degree of sort of logical separation

81
00:03:27,479 --> 00:03:32,669
that an operating system does between

82
00:03:30,109 --> 00:03:34,950
you know lines of execution so let me

83
00:03:32,669 --> 00:03:37,259
just break them down for you very simply

84
00:03:34,949 --> 00:03:39,449
so as you know on handmade hero right

85
00:03:37,259 --> 00:03:40,979
we're writing a bunch of code and that

86
00:03:39,449 --> 00:03:42,509
code looks like assembly language

87
00:03:40,979 --> 00:03:44,578
instructions so there's like a NASM

88
00:03:42,509 --> 00:03:46,888
instruction right followed by another as

89
00:03:44,579 --> 00:03:50,040
of instruction followed by another as an

90
00:03:46,889 --> 00:03:51,629
instruction right and there's a notion

91
00:03:50,039 --> 00:03:53,009
of where in the code we are there's

92
00:03:51,629 --> 00:03:54,388
thing called the instruction pointer we

93
00:03:53,009 --> 00:03:56,009
talked about and it says you know I'm

94
00:03:54,389 --> 00:03:57,870
here and I'm going to do this

95
00:03:56,009 --> 00:03:59,098
instruction I do this instruction the

96
00:03:57,870 --> 00:04:01,379
instruction pointer moves down to the

97
00:03:59,098 --> 00:04:02,848
next one I do the next one right and we

98
00:04:01,379 --> 00:04:05,189
also know there's a bunch of things like

99
00:04:02,848 --> 00:04:06,449
registers that are here and we talked a

100
00:04:05,189 --> 00:04:08,340
little bit about things like translation

101
00:04:06,449 --> 00:04:09,598
lookaside buffer or the address table

102
00:04:08,340 --> 00:04:11,098
and there's all these are the things

103
00:04:09,598 --> 00:04:12,929
that the processor is doing that

104
00:04:11,098 --> 00:04:15,509
basically allow us to map memory and do

105
00:04:12,930 --> 00:04:17,009
all these sorts of things right so what

106
00:04:15,509 --> 00:04:20,250
I want you to think about here is just

107
00:04:17,009 --> 00:04:23,788
the fact that there's CPU state right

108
00:04:20,250 --> 00:04:25,750
there's all the CPU state that says a

109
00:04:23,788 --> 00:04:28,959
whole bunch of things that need

110
00:04:25,750 --> 00:04:30,310
CPU needs to know in order to execute an

111
00:04:28,959 --> 00:04:32,319
assemble damage instruction it needs to

112
00:04:30,310 --> 00:04:33,970
know which instruction is executing for

113
00:04:32,319 --> 00:04:35,980
starters it needs to know what the

114
00:04:33,970 --> 00:04:37,990
memory layout is for the thing that it's

115
00:04:35,980 --> 00:04:39,490
using right because we said everything's

116
00:04:37,990 --> 00:04:42,730
virtual memory right so it needs to know

117
00:04:39,490 --> 00:04:45,370
how addresses in the in the data map or

118
00:04:42,730 --> 00:04:47,439
in the code map to actual addresses on

119
00:04:45,370 --> 00:04:49,840
the physical chip of memory the chip

120
00:04:47,439 --> 00:04:51,219
memory chips it needs to know what the

121
00:04:49,839 --> 00:04:53,439
register states are like we have these

122
00:04:51,220 --> 00:04:54,700
registers right we had those like Cindy

123
00:04:53,439 --> 00:04:55,689
wide registers we were talking about

124
00:04:54,699 --> 00:04:57,129
moving things in and out of those

125
00:04:55,689 --> 00:05:00,639
registers well it's got to have the

126
00:04:57,129 --> 00:05:09,550
registers right it's got to have all

127
00:05:00,639 --> 00:05:13,509
these sorts of things right okay so it's

128
00:05:09,550 --> 00:05:16,870
got that the question is how is this

129
00:05:13,509 --> 00:05:19,659
broken up right how is the operating

130
00:05:16,870 --> 00:05:22,540
system conceptualizing of this because

131
00:05:19,660 --> 00:05:25,300
we know that multiple processes multiple

132
00:05:22,540 --> 00:05:28,120
like logical processes to us as users

133
00:05:25,300 --> 00:05:29,978
multiple applications I should say are

134
00:05:28,120 --> 00:05:31,600
running at any given time and as we

135
00:05:29,978 --> 00:05:33,639
talked about in hand may hero each one

136
00:05:31,600 --> 00:05:35,770
of those has their own virtual address

137
00:05:33,639 --> 00:05:37,389
space right so handmade hero has a

138
00:05:35,769 --> 00:05:40,060
virtual address space that's its memory

139
00:05:37,389 --> 00:05:41,829
layout but like mischeif has its own one

140
00:05:40,060 --> 00:05:43,660
and they're both running on the same

141
00:05:41,829 --> 00:05:47,800
machine okay

142
00:05:43,660 --> 00:05:49,390
and so that is is this is this

143
00:05:47,800 --> 00:05:52,090
granularity that is what we call a

144
00:05:49,389 --> 00:05:56,139
process okay and what a process is is a

145
00:05:52,089 --> 00:06:01,239
process is essentially the state of the

146
00:05:56,139 --> 00:06:03,639
memory layout right the memory layout is

147
00:06:01,240 --> 00:06:06,430
controlled on the process level and what

148
00:06:03,639 --> 00:06:08,800
that's basically saying is okay when you

149
00:06:06,430 --> 00:06:13,509
are running this particular application

150
00:06:08,800 --> 00:06:16,990
on the CPU its memory layout looks like

151
00:06:13,509 --> 00:06:20,228
this right but the rest of this stuff is

152
00:06:16,990 --> 00:06:23,769
not per process right what azzam

153
00:06:20,228 --> 00:06:25,029
instructions are running and and well so

154
00:06:23,769 --> 00:06:26,620
that this the translation lookaside

155
00:06:25,029 --> 00:06:28,239
buffer and the addresses are part of

156
00:06:26,620 --> 00:06:30,910
memory right so this is all process

157
00:06:28,240 --> 00:06:33,340
stuff right process process process the

158
00:06:30,910 --> 00:06:37,630
registers the assembly instructions that

159
00:06:33,339 --> 00:06:39,489
stuff is not per process it is actually

160
00:06:37,629 --> 00:06:43,478
done at a level but

161
00:06:39,490 --> 00:06:46,180
low process because each process may

162
00:06:43,478 --> 00:06:49,318
want to have multiple simultaneous or

163
00:06:46,180 --> 00:06:53,620
not even simultaneous possibly separate

164
00:06:49,319 --> 00:06:56,500
code execution states which is what we

165
00:06:53,620 --> 00:06:58,240
call threads so underneath a process

166
00:06:56,500 --> 00:07:01,660
inside a process you actually have

167
00:06:58,240 --> 00:07:03,970
multiple threads and threads are what

168
00:07:01,660 --> 00:07:06,310
store the rest of this stuff a thread

169
00:07:03,970 --> 00:07:08,740
knows where it is in in terms of what

170
00:07:06,310 --> 00:07:10,449
instructions its executing a thread has

171
00:07:08,740 --> 00:07:14,199
a state of the registers in the

172
00:07:10,449 --> 00:07:15,639
processor right and so what you have to

173
00:07:14,199 --> 00:07:17,710
start to think about is the fact that

174
00:07:15,639 --> 00:07:19,509
these are actually sort of like there's

175
00:07:17,709 --> 00:07:21,430
like two levels right so there's

176
00:07:19,509 --> 00:07:24,819
processes which are sort of memory Maps

177
00:07:21,430 --> 00:07:27,550
and a collection of threads and then

178
00:07:24,819 --> 00:07:29,979
each individual thread stores additional

179
00:07:27,550 --> 00:07:32,650
state that has to do with with the state

180
00:07:29,978 --> 00:07:39,250
of the processor beyond just what the

181
00:07:32,649 --> 00:07:42,279
memory map is okay so handmade hero is a

182
00:07:39,250 --> 00:07:46,629
process that runs right it's an

183
00:07:42,279 --> 00:07:50,168
executable and inside that process there

184
00:07:46,629 --> 00:07:52,629
are many threads that run right now we

185
00:07:50,168 --> 00:07:55,718
have written one of those threads the

186
00:07:52,629 --> 00:07:57,069
main execution thread there are other

187
00:07:55,718 --> 00:07:58,899
threads that are running that the

188
00:07:57,069 --> 00:08:00,728
operating system starts that we have no

189
00:07:58,899 --> 00:08:02,468
control over for example directsound

190
00:08:00,728 --> 00:08:04,569
starts some threads the fact that we're

191
00:08:02,468 --> 00:08:07,060
using direct sound at all starts some

192
00:08:04,569 --> 00:08:08,680
threads in our process space that we

193
00:08:07,060 --> 00:08:13,478
have no control over but that do things

194
00:08:08,680 --> 00:08:17,019
with the audio device well the audio

195
00:08:13,478 --> 00:08:18,668
output should say device so there are

196
00:08:17,019 --> 00:08:20,560
multiple threads already in hand-made

197
00:08:18,668 --> 00:08:25,029
here but only one of them have we have

198
00:08:20,560 --> 00:08:26,530
we actually written okay now in addition

199
00:08:25,029 --> 00:08:27,939
to processes and threads there's also

200
00:08:26,529 --> 00:08:29,379
things called fibers which we won't

201
00:08:27,939 --> 00:08:33,338
really talk about because they're not

202
00:08:29,379 --> 00:08:35,528
super necessary but what a fiber is is a

203
00:08:33,339 --> 00:08:39,159
thread and a fiber are very similar

204
00:08:35,528 --> 00:08:41,288
things the difference is a thread is

205
00:08:39,158 --> 00:08:43,769
something that is actually a first-class

206
00:08:41,288 --> 00:08:46,659
operating system citizen that actually

207
00:08:43,769 --> 00:08:49,088
exists on the hardware and the hardware

208
00:08:46,659 --> 00:08:52,669
actually can run multiple of them at the

209
00:08:49,089 --> 00:08:54,830
same time a fiber is sort of a main

210
00:08:52,669 --> 00:08:57,139
newel version of a thread it's a thing

211
00:08:54,830 --> 00:08:59,480
that lets you save the CPU state for

212
00:08:57,139 --> 00:09:01,879
something but they don't execute

213
00:08:59,480 --> 00:09:03,710
concurrently you basically say like I'm

214
00:09:01,879 --> 00:09:05,750
capturing the state of this thing and

215
00:09:03,710 --> 00:09:07,730
then I'm going to like restart it later

216
00:09:05,750 --> 00:09:09,200
or something like that so we're not

217
00:09:07,730 --> 00:09:10,730
really going to talk about those because

218
00:09:09,200 --> 00:09:13,370
the reason that we're doing

219
00:09:10,730 --> 00:09:16,180
multi-threading is to take advantage of

220
00:09:13,370 --> 00:09:18,110
multiple CPU cores and stuff like this

221
00:09:16,179 --> 00:09:20,089
we don't really need to worry about

222
00:09:18,110 --> 00:09:21,950
fibers they were more things for

223
00:09:20,090 --> 00:09:23,899
overlapping work in the old days when

224
00:09:21,950 --> 00:09:26,509
you wanted to make it easier on yourself

225
00:09:23,899 --> 00:09:27,350
and I read I really all I can say about

226
00:09:26,509 --> 00:09:29,269
this I don't really want to talk about

227
00:09:27,350 --> 00:09:32,149
they're not useful but know that they

228
00:09:29,269 --> 00:09:33,799
did exist and you know you couldn't go

229
00:09:32,149 --> 00:09:34,970
look up more information around if you

230
00:09:33,799 --> 00:09:39,079
care about but this is what we care

231
00:09:34,970 --> 00:09:41,090
about all right so why do we care about

232
00:09:39,080 --> 00:09:42,500
this at all right why can't we just

233
00:09:41,090 --> 00:09:44,860
write everything in one thread well the

234
00:09:42,500 --> 00:09:48,950
reason is because as we've shown before

235
00:09:44,860 --> 00:09:50,990
here in the windows task manager which I

236
00:09:48,950 --> 00:09:54,379
opened by hitting ctrl shift escape

237
00:09:50,990 --> 00:09:57,350
which you can do as well you can see the

238
00:09:54,379 --> 00:09:59,720
number of logical processing units that

239
00:09:57,350 --> 00:10:02,899
this CPU that I'm on has now this is a

240
00:09:59,720 --> 00:10:06,230
Xeon machine it was originally a very

241
00:10:02,899 --> 00:10:09,110
beefy machine so as you can see it has a

242
00:10:06,230 --> 00:10:10,700
ton of these your machine if it's a

243
00:10:09,110 --> 00:10:13,220
modern machine will probably only have

244
00:10:10,700 --> 00:10:15,710
eight of these I think - twelve one two

245
00:10:13,220 --> 00:10:17,540
three four five six seven eight nine ten

246
00:10:15,710 --> 00:10:19,519
twelve thirteen fourteen fifteen sixteen

247
00:10:17,539 --> 00:10:22,549
nevermind it's got sixteen so my

248
00:10:19,519 --> 00:10:26,090
processor setup has roughly twice the

249
00:10:22,549 --> 00:10:28,879
number of logical units as does the

250
00:10:26,090 --> 00:10:30,830
common modern desktop which has four

251
00:10:28,879 --> 00:10:34,159
cores each with two hyper threads or

252
00:10:30,830 --> 00:10:36,080
eight slots right the reason I'm

253
00:10:34,159 --> 00:10:39,169
pointing this out is because each one of

254
00:10:36,080 --> 00:10:42,350
these things is capable of executing a

255
00:10:39,169 --> 00:10:45,049
thread simultaneously effectively right

256
00:10:42,350 --> 00:10:47,629
so what that means is the fact that

257
00:10:45,049 --> 00:10:51,799
we've only written our code in handmade

258
00:10:47,629 --> 00:10:54,309
hero on a single thread means that no

259
00:10:51,799 --> 00:10:56,899
matter what we do effectively there is

260
00:10:54,309 --> 00:10:59,689
you know if there are if there are

261
00:10:56,899 --> 00:11:02,269
sixteen slots for executing things on

262
00:10:59,690 --> 00:11:05,240
the CPU we have filled one of those

263
00:11:02,269 --> 00:11:06,360
slots right so we are effectively

264
00:11:05,240 --> 00:11:09,778
leaving

265
00:11:06,360 --> 00:11:12,740
right fifteen sixteenths if you will of

266
00:11:09,778 --> 00:11:16,350
our performance potentially on the table

267
00:11:12,740 --> 00:11:18,329
because the CPU can only actually fill

268
00:11:16,350 --> 00:11:20,970
one slot of execution with handmade hero

269
00:11:18,328 --> 00:11:23,519
and the other 15 slots just sit around

270
00:11:20,970 --> 00:11:25,110
waiting and maybe live for lucky they do

271
00:11:23,519 --> 00:11:27,299
some work on behalf of the OS or

272
00:11:25,110 --> 00:11:30,500
something right like graphics driver or

273
00:11:27,299 --> 00:11:34,649
who knows what but for the most part

274
00:11:30,500 --> 00:11:39,028
because we only wrote one thread the CPU

275
00:11:34,649 --> 00:11:40,259
can only execute one out of the the

276
00:11:39,028 --> 00:11:47,278
sixteen possible

277
00:11:40,259 --> 00:11:49,519
units can it even fill right so our goal

278
00:11:47,278 --> 00:11:51,600
with multi-threading on handmade hero

279
00:11:49,519 --> 00:11:52,589
well it's actually twofold but the

280
00:11:51,600 --> 00:11:55,920
primary thing that we're talking about

281
00:11:52,589 --> 00:11:58,920
right now is we want to increase the

282
00:11:55,919 --> 00:12:02,759
number of threads that we have available

283
00:11:58,919 --> 00:12:06,120
to the processor to run so that it can

284
00:12:02,759 --> 00:12:08,278
fill up logical processing units with

285
00:12:06,120 --> 00:12:08,909
those threads and do more work on our

286
00:12:08,278 --> 00:12:14,519
behalf

287
00:12:08,909 --> 00:12:16,980
okay so there's two types of sort of

288
00:12:14,519 --> 00:12:21,019
ways of thinking about this there is a

289
00:12:16,980 --> 00:12:23,370
core and there is a hyper thread and

290
00:12:21,019 --> 00:12:24,810
let's talk about what those are we've

291
00:12:23,370 --> 00:12:30,720
mentioned them multiple times before but

292
00:12:24,809 --> 00:12:33,088
just to be concrete a core is a set of

293
00:12:30,720 --> 00:12:36,480
those units that we've talked about a

294
00:12:33,089 --> 00:12:41,190
bunch of times that can do work right so

295
00:12:36,480 --> 00:12:48,539
a core has instruction decoding right it

296
00:12:41,190 --> 00:12:52,019
has arithmetic logic units on it it has

297
00:12:48,539 --> 00:12:54,120
memory units on it right and basically

298
00:12:52,019 --> 00:12:57,120
what a core is is it's a set of units

299
00:12:54,120 --> 00:13:00,149
that can do work like our multiplies

300
00:12:57,120 --> 00:13:02,698
like looking up addresses all of that

301
00:13:00,149 --> 00:13:08,669
stuff is what a core actually has on it

302
00:13:02,698 --> 00:13:11,250
okay now a core as we know can issue

303
00:13:08,669 --> 00:13:13,500
several instructions per clock cycle if

304
00:13:11,250 --> 00:13:15,448
there are instructions available for it

305
00:13:13,500 --> 00:13:17,159
to issue we just got done with two weeks

306
00:13:15,448 --> 00:13:19,049
of talking about stuff like that right

307
00:13:17,159 --> 00:13:20,250
so hopefully that's all fairly

308
00:13:19,049 --> 00:13:21,629
comfortable to you you

309
00:13:20,250 --> 00:13:23,850
basically no in fact we were using that

310
00:13:21,629 --> 00:13:26,070
IACA thing to tell us about how many

311
00:13:23,850 --> 00:13:27,420
ports we could stuff with things and

312
00:13:26,070 --> 00:13:31,110
which instructions went in which ports

313
00:13:27,419 --> 00:13:33,959
all those sorts of stuff right so the

314
00:13:31,110 --> 00:13:35,399
concept of a core the core is that thing

315
00:13:33,960 --> 00:13:38,370
that we were looking at with the ports

316
00:13:35,399 --> 00:13:41,639
that could have stuff filled right but

317
00:13:38,370 --> 00:13:43,649
modern cores the x64 cores that we're

318
00:13:41,639 --> 00:13:44,970
looking at here like the one that's in

319
00:13:43,649 --> 00:13:47,970
this machine the ones that's on your

320
00:13:44,970 --> 00:13:51,420
machine at your that for those of you

321
00:13:47,970 --> 00:13:54,779
watching at home actually have the

322
00:13:51,419 --> 00:13:59,219
ability to issue instructions from more

323
00:13:54,779 --> 00:14:01,589
than one place at the same time so a

324
00:13:59,220 --> 00:14:03,149
core that might have a bunch of Units

325
00:14:01,590 --> 00:14:05,430
here like we saw it have you know like

326
00:14:03,149 --> 00:14:07,289
five ports or whatever right and each of

327
00:14:05,429 --> 00:14:10,169
those ports on any given cycle could

328
00:14:07,289 --> 00:14:11,879
accept something right so you could if

329
00:14:10,169 --> 00:14:13,409
you had a port free and an instruction

330
00:14:11,879 --> 00:14:14,939
that could go into that port you could

331
00:14:13,409 --> 00:14:18,539
issue it right and it could start doing

332
00:14:14,940 --> 00:14:21,480
work for you well a hyper thread right

333
00:14:18,539 --> 00:14:23,819
is basically the same thing as a thread

334
00:14:21,480 --> 00:14:26,820
in terms of what it means right it's got

335
00:14:23,820 --> 00:14:29,339
the CPU state it has a notion of where

336
00:14:26,820 --> 00:14:34,190
it is in an instruction stream it has a

337
00:14:29,339 --> 00:14:37,410
notion of what the register state is but

338
00:14:34,190 --> 00:14:39,630
unlike threads as they were defined

339
00:14:37,409 --> 00:14:41,939
before hyper threading came along what a

340
00:14:39,629 --> 00:14:44,338
hyper thread can do is actually run

341
00:14:41,940 --> 00:14:49,050
concurrently on the same core as another

342
00:14:44,339 --> 00:14:52,440
hyper thread at the same time so in the

343
00:14:49,049 --> 00:14:55,889
past used to have one thread per logical

344
00:14:52,440 --> 00:14:57,330
core right so if I had a processor right

345
00:14:55,889 --> 00:15:00,059
and it had two cores

346
00:14:57,330 --> 00:15:01,500
here's core a and here's core B then the

347
00:15:00,059 --> 00:15:03,869
what would happen is the operating

348
00:15:01,500 --> 00:15:06,240
system would assign one thread to each

349
00:15:03,870 --> 00:15:08,190
core so this core would be running this

350
00:15:06,240 --> 00:15:09,750
thread and this core would be running

351
00:15:08,190 --> 00:15:12,089
this thread and that's the end of it

352
00:15:09,750 --> 00:15:13,289
here's thread a here's thread B they go

353
00:15:12,089 --> 00:15:16,740
on the chorus they operate

354
00:15:13,289 --> 00:15:18,299
simultaneously but that's it if one of

355
00:15:16,740 --> 00:15:21,149
these cores is actually a hyper

356
00:15:18,299 --> 00:15:23,909
threading core then what happens is it

357
00:15:21,149 --> 00:15:26,549
actually assigns more than one thread to

358
00:15:23,909 --> 00:15:28,500
the core and it depends on the hyper

359
00:15:26,549 --> 00:15:31,199
threading counts some things to handle -

360
00:15:28,500 --> 00:15:33,200
hyper threads this processor is - our

361
00:15:31,200 --> 00:15:34,850
threads I believe some

362
00:15:33,200 --> 00:15:38,600
hyper-threading chorus can do like four

363
00:15:34,850 --> 00:15:42,200
hyper threads and basically it's just

364
00:15:38,600 --> 00:15:43,639
how many slots the processor has for

365
00:15:42,200 --> 00:15:44,870
storing things like the registers in the

366
00:15:43,639 --> 00:15:48,470
instruction state and all that stuff

367
00:15:44,870 --> 00:15:51,948
right and what happens here is on any

368
00:15:48,470 --> 00:15:53,959
given clock cycle right so when the

369
00:15:51,948 --> 00:15:56,569
clock cycle you know ticks over it's

370
00:15:53,958 --> 00:15:58,309
like it's time to execute like four

371
00:15:56,570 --> 00:15:59,600
instructions right I can execute like we

372
00:15:58,309 --> 00:16:02,299
were saying up to four instructions on a

373
00:15:59,600 --> 00:16:05,269
clock cycle what it does is it looks at

374
00:16:02,299 --> 00:16:07,639
both threads and sees do either of these

375
00:16:05,269 --> 00:16:09,409
two guys have instructions that can go

376
00:16:07,639 --> 00:16:12,409
into the ports that I have available

377
00:16:09,409 --> 00:16:14,240
right and so now instead of the

378
00:16:12,409 --> 00:16:15,889
situation before like you know like we

379
00:16:14,240 --> 00:16:16,759
were having where we're looking to go oh

380
00:16:15,889 --> 00:16:18,620
okay

381
00:16:16,759 --> 00:16:22,659
here's all the instructions you know

382
00:16:18,620 --> 00:16:25,789
here's these as instructions right

383
00:16:22,659 --> 00:16:27,649
here's thread thread see right and

384
00:16:25,789 --> 00:16:30,259
here's these atom instructions oh they

385
00:16:27,649 --> 00:16:31,370
all go on port one all the instructions

386
00:16:30,259 --> 00:16:33,230
in the instruction window that I'm

387
00:16:31,370 --> 00:16:35,899
looking at go in port one so you know

388
00:16:33,230 --> 00:16:38,959
what I can only execute one in spike and

389
00:16:35,899 --> 00:16:41,600
only issue one instruction this clock

390
00:16:38,958 --> 00:16:43,129
cycle I guess I'll have to waste the

391
00:16:41,600 --> 00:16:44,720
other three instructions that I could

392
00:16:43,129 --> 00:16:46,610
have issued if only they go on two

393
00:16:44,720 --> 00:16:49,160
different ports instead what it will do

394
00:16:46,610 --> 00:16:52,039
is it will go oh well you know what I've

395
00:16:49,159 --> 00:16:53,448
also got thread B right and here's some

396
00:16:52,039 --> 00:16:54,948
asthma instructions there and yeah the

397
00:16:53,448 --> 00:16:56,778
first one goes on port one but the

398
00:16:54,948 --> 00:16:58,338
second one goes on port zero and the

399
00:16:56,778 --> 00:16:59,809
third one goes on I'm sorry on port two

400
00:16:58,339 --> 00:17:02,660
and that's what goes in port zero I'm

401
00:16:59,809 --> 00:17:05,808
going to grab these other two as well

402
00:17:02,659 --> 00:17:08,088
and now I can issue three instructions

403
00:17:05,808 --> 00:17:12,230
on this clock cycle instead of only

404
00:17:08,088 --> 00:17:15,139
having to issue one and so effectively

405
00:17:12,230 --> 00:17:18,828
what you can think of this doing is it's

406
00:17:15,140 --> 00:17:21,350
as if it were sort of free for the core

407
00:17:18,828 --> 00:17:23,688
to switch which thread it was using at

408
00:17:21,349 --> 00:17:25,938
any time and it can just bounce back

409
00:17:23,689 --> 00:17:28,040
between them all the time even inside

410
00:17:25,939 --> 00:17:29,840
one clock cycle right because it can

411
00:17:28,039 --> 00:17:32,329
literally just grab from either of the

412
00:17:29,839 --> 00:17:34,279
threads so it's it's actually much more

413
00:17:32,329 --> 00:17:37,099
efficient than the old style where the

414
00:17:34,279 --> 00:17:40,220
operating system had to manually switch

415
00:17:37,099 --> 00:17:42,048
out these threads right because instead

416
00:17:40,220 --> 00:17:43,640
of having to wait for the operating

417
00:17:42,048 --> 00:17:46,400
system come in and switch out a thread

418
00:17:43,640 --> 00:17:49,100
it can literally feel very tiny

419
00:17:46,400 --> 00:17:52,280
latency bubbles you know on the order of

420
00:17:49,099 --> 00:17:54,289
a few cycles latency bubbles it can fill

421
00:17:52,279 --> 00:17:56,720
those in by picking instructions from

422
00:17:54,289 --> 00:17:59,539
multiple streams which if the two

423
00:17:56,720 --> 00:18:01,430
streams can sort of manage to like slot

424
00:17:59,539 --> 00:18:03,079
into each other nicely where they you

425
00:18:01,430 --> 00:18:04,370
know get into a phase where one guys

426
00:18:03,079 --> 00:18:05,899
doing is memory while the other ones

427
00:18:04,369 --> 00:18:08,719
doing is computations and vice versa

428
00:18:05,900 --> 00:18:12,200
it's this can be really symbiotic and

429
00:18:08,720 --> 00:18:16,819
you can fill in a lot of the bubbles

430
00:18:12,200 --> 00:18:18,470
that way right so okay so let's talk

431
00:18:16,819 --> 00:18:20,450
about the thing I just said which is I

432
00:18:18,470 --> 00:18:25,309
said something like the operating system

433
00:18:20,450 --> 00:18:26,480
comes in and switches right because

434
00:18:25,309 --> 00:18:30,349
that's the next part we have to think

435
00:18:26,480 --> 00:18:31,660
about so all right so on a given cord

436
00:18:30,349 --> 00:18:34,549
whether it's hyper threading or not

437
00:18:31,660 --> 00:18:37,850
there's typically more threads in the

438
00:18:34,549 --> 00:18:39,680
running at any given time then can fit

439
00:18:37,849 --> 00:18:40,909
on the course right so we just said

440
00:18:39,680 --> 00:18:42,140
there are sixteen slots on this

441
00:18:40,910 --> 00:18:43,400
processor but the number of threads

442
00:18:42,140 --> 00:18:45,980
running in this machine are probably

443
00:18:43,400 --> 00:18:50,000
probably like in the hundreds if not the

444
00:18:45,980 --> 00:18:52,759
thousands right and that's because you

445
00:18:50,000 --> 00:18:55,069
know here you go here I open up

446
00:18:52,759 --> 00:18:58,879
processes look at all these processes

447
00:18:55,069 --> 00:19:00,200
there are more processes running on this

448
00:18:58,880 --> 00:19:03,470
computer right now than there are

449
00:19:00,200 --> 00:19:09,110
execution slots right and each of these

450
00:19:03,470 --> 00:19:11,900
processes itself has threads okay so

451
00:19:09,109 --> 00:19:14,959
what that means is the operating system

452
00:19:11,900 --> 00:19:17,300
at any given time really has some giant

453
00:19:14,960 --> 00:19:20,059
set of threads right you know there's a

454
00:19:17,299 --> 00:19:24,649
thousand of these or whatever and it's

455
00:19:20,059 --> 00:19:26,470
only got 16 slots worth on this CPU or

456
00:19:24,650 --> 00:19:31,880
like on your CPU maybe eight or whatever

457
00:19:26,470 --> 00:19:33,890
worth of actual logical right CPUs these

458
00:19:31,880 --> 00:19:36,470
are often called logical CPUs I keep

459
00:19:33,890 --> 00:19:39,259
using that term because like like I said

460
00:19:36,470 --> 00:19:41,269
or or logical cores would be a better

461
00:19:39,259 --> 00:19:43,640
term for it they're usually called

462
00:19:41,269 --> 00:19:46,700
logical cores because again they're not

463
00:19:43,640 --> 00:19:49,370
actual cores a lot of times they're too

464
00:19:46,700 --> 00:19:53,269
high per threads right is are both

465
00:19:49,369 --> 00:19:54,409
executing on one actual physical pour so

466
00:19:53,269 --> 00:19:57,079
there's always this constant between

467
00:19:54,410 --> 00:19:59,750
logical and physical cores this machine

468
00:19:57,079 --> 00:20:02,539
probably has eight physical cores for

469
00:19:59,750 --> 00:20:04,609
sample but it has got 16 logical cores

470
00:20:02,539 --> 00:20:06,649
because each of the physical cores can

471
00:20:04,609 --> 00:20:09,169
have two threads on it so it's as if

472
00:20:06,650 --> 00:20:10,880
there were more now it's not as good as

473
00:20:09,170 --> 00:20:12,440
having a whole nother CPU core because

474
00:20:10,880 --> 00:20:15,770
it doesn't duplicate all those things

475
00:20:12,440 --> 00:20:22,309
like the ALU or the l1 cache or stuff

476
00:20:15,769 --> 00:20:25,609
like that those are shared but it does

477
00:20:22,309 --> 00:20:28,759
allow you to run as many threads as if

478
00:20:25,609 --> 00:20:30,949
you actually had 16 actual course you

479
00:20:28,759 --> 00:20:33,619
just may not run them as fast as you

480
00:20:30,950 --> 00:20:36,440
could if you have 16 actual cores with

481
00:20:33,619 --> 00:20:39,139
all the duplicated stuff but the hope is

482
00:20:36,440 --> 00:20:41,180
that you do run it somewhere near that

483
00:20:39,140 --> 00:20:44,480
fast right so if that was going to be

484
00:20:41,180 --> 00:20:46,519
twice as fast to run them on on 16

485
00:20:44,480 --> 00:20:49,579
physical cores you're hoping maybe you

486
00:20:46,519 --> 00:20:51,829
get 1.4 1.3 X you get something right

487
00:20:49,579 --> 00:20:52,939
you're not going to get it all but

488
00:20:51,829 --> 00:20:55,189
you'll get something and maybe if you're

489
00:20:52,940 --> 00:20:56,809
really lucky you get up close to it 1.8

490
00:20:55,190 --> 00:20:59,390
who knows it depends on the workload

491
00:20:56,809 --> 00:21:02,769
what's going to happen but that's the

492
00:20:59,390 --> 00:21:04,820
goal right because it's relatively cheap

493
00:21:02,769 --> 00:21:08,119
my understanding anyway is it's

494
00:21:04,819 --> 00:21:10,399
relatively cheap for Intel to add hyper

495
00:21:08,119 --> 00:21:12,109
threads to a core as opposed to adding a

496
00:21:10,400 --> 00:21:13,490
whole nother core because they don't

497
00:21:12,109 --> 00:21:15,289
have to duplicate things like the

498
00:21:13,490 --> 00:21:17,299
multiplier circuitry and the memory

499
00:21:15,289 --> 00:21:18,950
circuitry whenever that's the same they

500
00:21:17,299 --> 00:21:21,829
just have to add things that allow

501
00:21:18,950 --> 00:21:23,779
multiple slots in terms of like the

502
00:21:21,829 --> 00:21:25,429
register file and stuff like that now

503
00:21:23,779 --> 00:21:27,049
those things are still expensive they're

504
00:21:25,430 --> 00:21:28,820
not free so it's not like you can just

505
00:21:27,049 --> 00:21:29,509
have a hundred Piper threads it's free

506
00:21:28,819 --> 00:21:30,740
woohoo

507
00:21:29,509 --> 00:21:31,910
it doesn't work that way because the

508
00:21:30,740 --> 00:21:33,289
routing and all that stuff is still

509
00:21:31,910 --> 00:21:35,330
expensive I don't know very much about

510
00:21:33,289 --> 00:21:37,069
it but that's why we don't have like

511
00:21:35,329 --> 00:21:38,389
tons of hyper threads but in order to

512
00:21:37,069 --> 00:21:40,399
get like a certain number of hyper

513
00:21:38,390 --> 00:21:41,810
threads it turns out to usually be a

514
00:21:40,400 --> 00:21:43,519
performance win that's why they do it

515
00:21:41,809 --> 00:21:44,599
it's cheaper to add hyper threads than

516
00:21:43,519 --> 00:21:49,970
it would be to stamp out a whole new

517
00:21:44,599 --> 00:21:52,159
core alright so and just to put a cherry

518
00:21:49,970 --> 00:21:53,420
on top of that so you can imagine what

519
00:21:52,160 --> 00:21:58,820
they do at Intel is they basically look

520
00:21:53,420 --> 00:22:00,890
and go okay how underutilized is this

521
00:21:58,819 --> 00:22:03,109
are the set of things on a core

522
00:22:00,890 --> 00:22:05,960
typically right like the ALU or whatever

523
00:22:03,109 --> 00:22:07,789
how underutilized is that and then they

524
00:22:05,960 --> 00:22:09,110
would want to add as many hyper threads

525
00:22:07,789 --> 00:22:11,029
as would be necessary to utilize it so

526
00:22:09,109 --> 00:22:13,909
you know if it takes two hyper threads

527
00:22:11,029 --> 00:22:16,849
for typical workloads to fully utilize

528
00:22:13,910 --> 00:22:18,710
the actual work units of the core then

529
00:22:16,849 --> 00:22:21,349
that's a good number of hyper threads

530
00:22:18,710 --> 00:22:22,819
right if it takes four of them then they

531
00:22:21,349 --> 00:22:24,679
would do that takes two of them they

532
00:22:22,819 --> 00:22:27,349
would do that what you'll typically see

533
00:22:24,680 --> 00:22:29,150
I believe and this is again me sort of

534
00:22:27,349 --> 00:22:31,250
hand waving here because I'm not a

535
00:22:29,150 --> 00:22:33,800
hardware guy so you know hardware guys

536
00:22:31,250 --> 00:22:35,750
feel free to correct me if I'm wrong but

537
00:22:33,799 --> 00:22:38,869
well you'll typically see is out of

538
00:22:35,750 --> 00:22:43,250
order processors versus in order

539
00:22:38,869 --> 00:22:44,929
processors right the x64 is an out of

540
00:22:43,250 --> 00:22:46,789
order processor which means it has that

541
00:22:44,930 --> 00:22:49,130
big window where it can grab

542
00:22:46,789 --> 00:22:52,879
instructions from right we talked about

543
00:22:49,130 --> 00:22:55,010
that a lot what that means is that the

544
00:22:52,880 --> 00:22:57,020
degree to which it needs hyper threading

545
00:22:55,009 --> 00:23:00,079
is drastically reduced because it's able

546
00:22:57,019 --> 00:23:02,750
to use stuff in the same thread a lot

547
00:23:00,079 --> 00:23:04,460
more efficiently than an inorder

548
00:23:02,750 --> 00:23:06,559
processor which is a processor that has

549
00:23:04,460 --> 00:23:07,779
to execute the next instruction always

550
00:23:06,559 --> 00:23:11,899
right

551
00:23:07,779 --> 00:23:13,849
these stall a lot more on the same code

552
00:23:11,900 --> 00:23:15,980
because even if there were instructions

553
00:23:13,849 --> 00:23:17,899
just even if just the next instruction

554
00:23:15,980 --> 00:23:19,610
that you would have executed wouldn't

555
00:23:17,900 --> 00:23:22,009
have been blocked the fact that you're

556
00:23:19,609 --> 00:23:24,679
the one you're on right now is blocked

557
00:23:22,009 --> 00:23:26,539
means you can't continue and so these

558
00:23:24,680 --> 00:23:28,490
tend to benefit a lot more from more

559
00:23:26,539 --> 00:23:31,369
hyper threads so you might see you know

560
00:23:28,490 --> 00:23:33,589
four hyper threads right on an inorder

561
00:23:31,369 --> 00:23:35,779
processor being common whereas two hyper

562
00:23:33,589 --> 00:23:37,849
threads on an out-of-order processor

563
00:23:35,779 --> 00:23:40,220
might be common and that's because you

564
00:23:37,849 --> 00:23:41,839
don't need as many hyper threads to give

565
00:23:40,220 --> 00:23:43,339
you the options that you need on an out

566
00:23:41,839 --> 00:23:44,779
of order processor wares on an internal

567
00:23:43,339 --> 00:23:47,149
processor you might need quite a few for

568
00:23:44,779 --> 00:23:49,359
might not even be enough right so there

569
00:23:47,150 --> 00:23:49,360
you go

570
00:23:51,849 --> 00:23:58,399
okay so here we go want to wrap this up

571
00:23:56,930 --> 00:24:00,289
so we can go show how to create some

572
00:23:58,400 --> 00:24:01,880
threads and win32 hopefully this gave

573
00:24:00,289 --> 00:24:06,440
you some idea about that but what I want

574
00:24:01,880 --> 00:24:08,200
to talk about one more thing today we're

575
00:24:06,440 --> 00:24:12,200
going to save memory for tomorrow

576
00:24:08,200 --> 00:24:14,630
one more thing today is the OS so what's

577
00:24:12,200 --> 00:24:16,490
the OS doing well honestly these days I

578
00:24:14,630 --> 00:24:21,350
have no idea what the OS is doing I've

579
00:24:16,490 --> 00:24:24,529
never seen a modern OS kernel so I can't

580
00:24:21,349 --> 00:24:28,839
tell you but it works something like

581
00:24:24,529 --> 00:24:28,839
this there's a thing called an interrupt

582
00:24:28,930 --> 00:24:33,830
alright we haven't talked about these at

583
00:24:31,369 --> 00:24:36,529
all on handmade hero because you will

584
00:24:33,829 --> 00:24:38,359
never get to use them probably we the

585
00:24:36,529 --> 00:24:40,160
first time we'll probably ever get to

586
00:24:38,359 --> 00:24:43,279
use one of these for any real purpose is

587
00:24:40,160 --> 00:24:44,750
if we do Raspberry Pi programming or

588
00:24:43,279 --> 00:24:47,029
something like that where we're able to

589
00:24:44,750 --> 00:24:49,250
write sort of all the way down to the

590
00:24:47,029 --> 00:24:51,859
hardware and run as the kernel

591
00:24:49,250 --> 00:24:54,859
effectively but on Windows you probably

592
00:24:51,859 --> 00:24:57,919
will never deal with this so especially

593
00:24:54,859 --> 00:24:59,389
if you're just writing a game so what is

594
00:24:57,920 --> 00:25:01,240
an interrupt well an interrupt is

595
00:24:59,390 --> 00:25:03,320
something where the processor itself

596
00:25:01,240 --> 00:25:05,120
decides to replace the thing that's

597
00:25:03,319 --> 00:25:08,179
currently running with something else

598
00:25:05,119 --> 00:25:10,339
right so basically what happens is you

599
00:25:08,180 --> 00:25:11,930
have that azzam code right and you've

600
00:25:10,339 --> 00:25:14,329
got an instruction pointer and it's

601
00:25:11,930 --> 00:25:16,039
going right so we're on some core here's

602
00:25:14,329 --> 00:25:18,049
the core we're running this stuff and

603
00:25:16,039 --> 00:25:20,450
we're and that's all fine and dandy and

604
00:25:18,049 --> 00:25:23,539
then what happens is at some point you

605
00:25:20,450 --> 00:25:25,400
get an interrupt and that interrupt

606
00:25:23,539 --> 00:25:27,649
might be like the scheduling timer for

607
00:25:25,400 --> 00:25:29,380
example in this case so it might be an

608
00:25:27,650 --> 00:25:32,269
interrupt that just happens periodically

609
00:25:29,380 --> 00:25:34,340
right and what that interrupt does is it

610
00:25:32,269 --> 00:25:35,660
says all right hold on I know you were

611
00:25:34,339 --> 00:25:39,139
going to you were going to execute

612
00:25:35,660 --> 00:25:41,150
something don't execute that instead I

613
00:25:39,140 --> 00:25:44,920
want you to execute this other code over

614
00:25:41,150 --> 00:25:48,500
here right and that code happens to be

615
00:25:44,920 --> 00:25:50,420
some operating system code so when the

616
00:25:48,500 --> 00:25:52,309
operating system started up back when

617
00:25:50,420 --> 00:25:54,440
you like booted Windows right it

618
00:25:52,309 --> 00:25:56,029
installed this interrupt it installed

619
00:25:54,440 --> 00:25:59,120
the thing called an interrupt handler

620
00:25:56,029 --> 00:26:02,059
which is this code and it basically told

621
00:25:59,119 --> 00:26:05,158
the processor every so often every

622
00:26:02,059 --> 00:26:07,168
millisecond or whatever I

623
00:26:05,159 --> 00:26:12,899
want you to stop what you are doing I

624
00:26:07,169 --> 00:26:16,950
want you to run my code okay and my code

625
00:26:12,898 --> 00:26:21,558
is going to do some stuff now what this

626
00:26:16,950 --> 00:26:24,989
code will do is this code will see

627
00:26:21,558 --> 00:26:28,528
whether it wants to change which thread

628
00:26:24,989 --> 00:26:31,919
is running on this core so for example

629
00:26:28,528 --> 00:26:34,558
what this this code could do is it could

630
00:26:31,919 --> 00:26:37,139
issue a thing that says save the state

631
00:26:34,558 --> 00:26:40,528
of the processor right save those

632
00:26:37,138 --> 00:26:42,689
registers write that register state and

633
00:26:40,528 --> 00:26:44,190
the registers by the way includes this

634
00:26:42,690 --> 00:26:45,929
instruction pointer right because that's

635
00:26:44,190 --> 00:26:47,970
actually a register in the processor so

636
00:26:45,929 --> 00:26:52,859
save out all this stuff to a piece of

637
00:26:47,970 --> 00:26:55,769
memory somewhere okay save it out load

638
00:26:52,858 --> 00:26:57,960
in somebody else's right go grab some

639
00:26:55,769 --> 00:27:00,598
other state from some other thread and

640
00:26:57,960 --> 00:27:05,098
move it in here and then resume what you

641
00:27:00,598 --> 00:27:07,200
were doing jump back in there right so

642
00:27:05,098 --> 00:27:11,398
effectively what the OS does is it has a

643
00:27:07,200 --> 00:27:13,460
thing which every so often will

644
00:27:11,398 --> 00:27:15,928
interrupt what's running on a processor

645
00:27:13,460 --> 00:27:17,489
possibly decide you know doesn't have to

646
00:27:15,929 --> 00:27:18,419
do this but possibly decide that what

647
00:27:17,489 --> 00:27:20,788
should really be running on the

648
00:27:18,419 --> 00:27:22,499
processor is some other thread possibly

649
00:27:20,788 --> 00:27:25,138
from some other process in which case

650
00:27:22,499 --> 00:27:26,669
it'll also have the TLB like travel and

651
00:27:25,138 --> 00:27:29,278
not patil v but it'll have the the

652
00:27:26,669 --> 00:27:30,899
virtual addressing table it'll pull in

653
00:27:29,278 --> 00:27:34,019
that memory mapping table as well it

654
00:27:30,898 --> 00:27:35,488
will swap that out right so it'll

655
00:27:34,019 --> 00:27:37,499
possibly do a whole bunch of work to

656
00:27:35,489 --> 00:27:39,749
change over the state and then it will

657
00:27:37,499 --> 00:27:41,639
resume execution of some totally other

658
00:27:39,749 --> 00:27:45,808
thread possibly from some totally other

659
00:27:41,638 --> 00:27:47,788
process okay so the operating system is

660
00:27:45,808 --> 00:27:49,440
the guy who's actually doing this work

661
00:27:47,788 --> 00:27:51,450
it's doing it on an interrupt that

662
00:27:49,440 --> 00:27:54,330
interrupts is allowing the optical

663
00:27:51,450 --> 00:27:56,220
system to come in and interrupt what

664
00:27:54,329 --> 00:28:01,428
someone's doing to let someone else do

665
00:27:56,220 --> 00:28:03,538
it now this is called preemption and

666
00:28:01,429 --> 00:28:07,849
operating systems that work this way are

667
00:28:03,538 --> 00:28:11,009
called pre-emptive multitasking

668
00:28:07,848 --> 00:28:14,500
operating systems

669
00:28:11,009 --> 00:28:16,960
okay a pre-emptive multitasking

670
00:28:14,500 --> 00:28:20,230
operating system is one that preempts

671
00:28:16,960 --> 00:28:22,298
the the execution of a thread without

672
00:28:20,230 --> 00:28:24,009
that thread giving the operating system

673
00:28:22,298 --> 00:28:26,500
permission okay this is how modern

674
00:28:24,009 --> 00:28:29,589
operating multitasking operating systems

675
00:28:26,500 --> 00:28:34,900
work there are other styles called

676
00:28:29,589 --> 00:28:37,449
cooperative multitasking okay

677
00:28:34,900 --> 00:28:39,730
and what those are are ones where the

678
00:28:37,450 --> 00:28:42,929
operand system does not have this

679
00:28:39,730 --> 00:28:47,950
interrupts instead what they have is

680
00:28:42,929 --> 00:28:50,740
every uh every chain of execution every

681
00:28:47,950 --> 00:28:52,720
thread when it was written has to have a

682
00:28:50,740 --> 00:28:53,829
thing in there that basically looks like

683
00:28:52,720 --> 00:28:55,900
yield

684
00:28:53,829 --> 00:28:56,889
it basically says like okay I'm gonna do

685
00:28:55,900 --> 00:29:00,788
a bunch of work and then I'm going to

686
00:28:56,890 --> 00:29:04,538
call yield and yield actually physically

687
00:29:00,788 --> 00:29:07,690
calls out to the scheduler right so

688
00:29:04,538 --> 00:29:10,569
basically these are much more efficient

689
00:29:07,690 --> 00:29:12,669
actually because they never have these

690
00:29:10,569 --> 00:29:14,349
interrupts popping up ever so that's

691
00:29:12,669 --> 00:29:16,900
kind of Handy but they are much less

692
00:29:14,349 --> 00:29:18,849
reliable for the user because what it

693
00:29:16,900 --> 00:29:20,679
means is that if one of these pieces of

694
00:29:18,849 --> 00:29:22,779
code is behaving badly or has a bug in

695
00:29:20,679 --> 00:29:23,620
it or just doesn't care and it never

696
00:29:22,779 --> 00:29:25,839
calls yield

697
00:29:23,619 --> 00:29:27,879
you can never that's you can never

698
00:29:25,839 --> 00:29:30,250
switch what's running on that core right

699
00:29:27,880 --> 00:29:33,789
once that launches it's gone forever

700
00:29:30,250 --> 00:29:35,409
right so the reason that most monitoring

701
00:29:33,788 --> 00:29:38,288
system operating systems are preempted

702
00:29:35,409 --> 00:29:41,320
multitasking now is because it no longer

703
00:29:38,288 --> 00:29:43,779
requires the people who program these

704
00:29:41,319 --> 00:29:45,668
things to be good citizens and it gets

705
00:29:43,779 --> 00:29:47,710
much more even load balancing because it

706
00:29:45,669 --> 00:29:49,150
can guarantee that it doesn't matter how

707
00:29:47,710 --> 00:29:51,940
this code was written it can always

708
00:29:49,150 --> 00:29:53,650
preempt it at predefined intervals right

709
00:29:51,940 --> 00:29:55,840
whereas with the cooperative when it

710
00:29:53,650 --> 00:29:58,210
couldn't do that so whereas this one can

711
00:29:55,839 --> 00:29:59,949
be made more efficient because you're

712
00:29:58,210 --> 00:30:01,750
never having these things happen at

713
00:29:59,950 --> 00:30:04,720
inopportune times they can always be

714
00:30:01,750 --> 00:30:06,038
planned they are much more reliable if

715
00:30:04,720 --> 00:30:07,690
they're pre-emptive because they can

716
00:30:06,038 --> 00:30:09,788
spread the work evenly that's guaranteed

717
00:30:07,690 --> 00:30:13,590
and they can make sure that bad actors

718
00:30:09,788 --> 00:30:13,589
don't suck up all the cpu time

719
00:30:15,410 --> 00:30:20,279
okay so what do we have to do on

720
00:30:18,509 --> 00:30:22,379
handmade here oh right like I said but

721
00:30:20,279 --> 00:30:25,079
we want to do right now our goal for

722
00:30:22,380 --> 00:30:28,860
today or our goal for this week I should

723
00:30:25,079 --> 00:30:32,699
say is we want to fill all 16 slots

724
00:30:28,859 --> 00:30:35,569
worth of cores of logical cores on the

725
00:30:32,700 --> 00:30:38,788
processor we want to fill those all with

726
00:30:35,569 --> 00:30:41,788
threads that the CPUs could be executing

727
00:30:38,788 --> 00:30:46,140
and right now when we have one right so

728
00:30:41,788 --> 00:30:50,548
what we need to do is we need to give

729
00:30:46,140 --> 00:30:52,380
the operating system some threads it can

730
00:30:50,548 --> 00:30:54,599
start filling right it can start

731
00:30:52,380 --> 00:30:56,190
assigning to these processors right

732
00:30:54,599 --> 00:30:58,048
because the operating system is the

733
00:30:56,190 --> 00:30:59,940
thing that assigns these the operating

734
00:30:58,048 --> 00:31:02,700
is the thing that that schedules them

735
00:30:59,940 --> 00:31:05,880
right and so right now basically what's

736
00:31:02,700 --> 00:31:07,860
happening is on all 16 slots right you

737
00:31:05,880 --> 00:31:10,799
know we've got these 16 slots worth of

738
00:31:07,859 --> 00:31:12,359
processing that are happening right most

739
00:31:10,798 --> 00:31:14,009
of them are just sitting there right

740
00:31:12,359 --> 00:31:17,279
most of them are doing nothing they're

741
00:31:14,009 --> 00:31:19,048
just waiting right and so the operating

742
00:31:17,279 --> 00:31:20,759
system is like running all of handmade

743
00:31:19,048 --> 00:31:21,569
hero basically on like one thread and

744
00:31:20,759 --> 00:31:23,158
the rest of these guys are sitting

745
00:31:21,569 --> 00:31:25,079
around waiting what we want to do is

746
00:31:23,159 --> 00:31:26,940
have it so that there's things in all

747
00:31:25,079 --> 00:31:28,558
the slots so the processor can kick them

748
00:31:26,940 --> 00:31:30,470
all off and get them all doing things

749
00:31:28,558 --> 00:31:34,769
that's all we're trying to do here right

750
00:31:30,470 --> 00:31:38,390
and so when we look at this when we look

751
00:31:34,769 --> 00:31:41,190
at this graph what you can see here is

752
00:31:38,390 --> 00:31:45,630
you can see that this number hovers

753
00:31:41,190 --> 00:31:47,100
around 11 percent right and we can see

754
00:31:45,630 --> 00:31:49,590
if we look at processes you can see

755
00:31:47,099 --> 00:31:52,079
what's going on on there it's it's the

756
00:31:49,589 --> 00:31:57,449
its OBS that's that's taken that that

757
00:31:52,079 --> 00:31:59,699
time right but we could get we could

758
00:31:57,450 --> 00:32:01,288
probably get a little bit more explicit

759
00:31:59,700 --> 00:32:04,429
well you know we'll do first of all

760
00:32:01,288 --> 00:32:04,429
let's just run handmade hero

761
00:32:08,288 --> 00:32:19,429
right now so if I run handmade hero and

762
00:32:15,740 --> 00:32:21,888
we just have it running right um you

763
00:32:19,429 --> 00:32:23,870
know if you can see that there but you

764
00:32:21,888 --> 00:32:27,878
know this is going you know handmade

765
00:32:23,869 --> 00:32:30,888
heroes is going here here it goes and

766
00:32:27,878 --> 00:32:37,459
right now it's using like three percent

767
00:32:30,888 --> 00:32:39,888
of the CPU right and I guess we that may

768
00:32:37,460 --> 00:32:41,240
actually be less than even a full single

769
00:32:39,888 --> 00:32:43,189
thread performance because there's just

770
00:32:41,240 --> 00:32:46,038
enough not enough rendering to do so we

771
00:32:43,190 --> 00:32:49,929
may have to actually start making that

772
00:32:46,038 --> 00:32:53,628
we have to increase the render workload

773
00:32:49,929 --> 00:32:55,190
but what I wanted to point out is we're

774
00:32:53,628 --> 00:32:56,509
hovering around three percent when we're

775
00:32:55,190 --> 00:32:58,669
doing our rendering right now of

776
00:32:56,509 --> 00:33:00,440
processor usage and what we want to do

777
00:32:58,669 --> 00:33:01,600
is we want to be using like a tremendous

778
00:33:00,440 --> 00:33:03,679
amount right we want to be using

779
00:33:01,599 --> 00:33:05,658
basically 90 percent because that's

780
00:33:03,679 --> 00:33:07,879
what's left over from after OBS is

781
00:33:05,659 --> 00:33:10,639
running we want to make sure that we're

782
00:33:07,878 --> 00:33:13,368
actually using all that and so if we

783
00:33:10,638 --> 00:33:19,248
take a look at what that value actually

784
00:33:13,368 --> 00:33:24,349
means right one sixteenth of a processor

785
00:33:19,249 --> 00:33:26,569
right is six percent right so right now

786
00:33:24,349 --> 00:33:29,089
we're are we've optimized our render

787
00:33:26,569 --> 00:33:32,240
enough that with the current amount of

788
00:33:29,089 --> 00:33:36,499
work that we're asking it to do we're

789
00:33:32,240 --> 00:33:39,618
not even using all of one cores worth

790
00:33:36,499 --> 00:33:40,788
right so the first thing we may have to

791
00:33:39,618 --> 00:33:41,990
do once we start doing our

792
00:33:40,788 --> 00:33:43,220
multi-threading is we may have to

793
00:33:41,990 --> 00:33:44,829
increase the graphics work well because

794
00:33:43,220 --> 00:33:50,210
we did a little bit too good of a job

795
00:33:44,829 --> 00:33:54,648
optimizing it but that that amount that

796
00:33:50,210 --> 00:33:56,450
1/16 that point oh six there 6% if we

797
00:33:54,648 --> 00:33:57,678
did not increase the number of threads

798
00:33:56,450 --> 00:33:59,360
that handmade here are used for

799
00:33:57,679 --> 00:34:02,389
rendering that would be the maximum

800
00:33:59,359 --> 00:34:06,740
amount of the CPU we'd ever see used by

801
00:34:02,388 --> 00:34:08,809
us because even if we fully max it out

802
00:34:06,740 --> 00:34:10,280
so we add enough rendering work that

803
00:34:08,809 --> 00:34:12,500
it's just it's in the renderer the whole

804
00:34:10,280 --> 00:34:14,899
time right and you know it's it's

805
00:34:12,500 --> 00:34:16,190
working the entire time does the blitt

806
00:34:14,898 --> 00:34:18,529
two windows and then goes right back to

807
00:34:16,190 --> 00:34:21,139
rendering we would never see it get

808
00:34:18,530 --> 00:34:24,349
above 6% because without

809
00:34:21,139 --> 00:34:28,700
more cores going we can't ever use more

810
00:34:24,349 --> 00:34:31,460
than 6% of the processor right so when

811
00:34:28,699 --> 00:34:34,608
you see this in the task manager and you

812
00:34:31,460 --> 00:34:37,429
wonder my why isn't my application

813
00:34:34,608 --> 00:34:39,798
running faster it's only using 10% of

814
00:34:37,429 --> 00:34:42,079
the CPU and like it was dog slow or

815
00:34:39,798 --> 00:34:44,538
whatever right and I mean we can even do

816
00:34:42,079 --> 00:34:47,210
this in fact I can do this pretty easily

817
00:34:44,539 --> 00:34:50,000
and this would be a problem maybe even a

818
00:34:47,210 --> 00:34:52,730
good way to illustrate it first off if I

819
00:34:50,000 --> 00:34:55,668
go back and switch it to the super slow

820
00:34:52,730 --> 00:35:00,829
version right where we do draw rectangle

821
00:34:55,668 --> 00:35:02,298
quickly in our render group thing where

822
00:35:00,829 --> 00:35:03,859
we were actually calling that if I

823
00:35:02,298 --> 00:35:07,759
switched it back to calling draw

824
00:35:03,858 --> 00:35:11,239
rectangle slowly right then our game is

825
00:35:07,760 --> 00:35:13,400
super slow and crappy right you know

826
00:35:11,239 --> 00:35:15,048
here we go right and here's our here's

827
00:35:13,400 --> 00:35:19,670
our game it's like barely functioning

828
00:35:15,048 --> 00:35:22,940
right so that's super slow if we if we

829
00:35:19,670 --> 00:35:25,519
go look again at this this is super slow

830
00:35:22,940 --> 00:35:27,798
framerate we can see that we're just

831
00:35:25,518 --> 00:35:29,328
it's the CPU isn't pegged at all right

832
00:35:27,798 --> 00:35:31,278
and if we go back here and look at how

833
00:35:29,329 --> 00:35:32,568
much hand may is taking advantage of hey

834
00:35:31,278 --> 00:35:36,349
look it's the exact number that I

835
00:35:32,568 --> 00:35:38,568
calculated six percent right and so

836
00:35:36,349 --> 00:35:40,338
again the threading what we're trying to

837
00:35:38,568 --> 00:35:43,099
do now is we're trying to say okay you

838
00:35:40,338 --> 00:35:45,250
know modern processors they just they

839
00:35:43,099 --> 00:35:48,200
count on this multi-threading a lot and

840
00:35:45,250 --> 00:35:49,818
so we're never going to get all of the

841
00:35:48,199 --> 00:35:51,500
horsepower out of the processor if all

842
00:35:49,818 --> 00:35:54,588
we do is write the single tiptoe we've

843
00:35:51,500 --> 00:35:57,349
got to push it into multi-threading in

844
00:35:54,588 --> 00:35:58,670
order to get above that amount and if

845
00:35:57,349 --> 00:36:00,380
you think about how much processing is

846
00:35:58,670 --> 00:36:02,389
left on the table if it actually worked

847
00:36:00,380 --> 00:36:04,160
out perfectly and again it never does

848
00:36:02,389 --> 00:36:06,858
but if it actually worked out perfectly

849
00:36:04,159 --> 00:36:10,489
right using 60 percent of the processor

850
00:36:06,858 --> 00:36:11,929
would be 10 times faster right that's

851
00:36:10,489 --> 00:36:14,538
how much is left on the table there and

852
00:36:11,929 --> 00:36:15,828
60 percent 800 does even you know after

853
00:36:14,539 --> 00:36:16,880
sixty percent there's like another 2x or

854
00:36:15,829 --> 00:36:19,400
right so we're talking about something

855
00:36:16,880 --> 00:36:22,099
in the order of like 617 percent or

856
00:36:19,400 --> 00:36:24,048
something like this 1600 sorry 16x

857
00:36:22,099 --> 00:36:25,849
because we know we're only filling one

858
00:36:24,048 --> 00:36:27,469
slot and we've got 16 processors so

859
00:36:25,849 --> 00:36:29,900
we're talking about 16 times the

860
00:36:27,469 --> 00:36:31,818
performance we could get if we filled

861
00:36:29,900 --> 00:36:34,670
those out now you won't get actually all

862
00:36:31,818 --> 00:36:36,259
16 for like I said because you know

863
00:36:34,670 --> 00:36:37,670
some of those are logical cores not

864
00:36:36,260 --> 00:36:39,049
actual course and then there's memory

865
00:36:37,670 --> 00:36:40,579
issues and all these other sorts of

866
00:36:39,048 --> 00:36:44,288
things and handshaking blah blah blah

867
00:36:40,579 --> 00:36:48,380
blah blah so we probably won't get 16x

868
00:36:44,289 --> 00:36:52,069
but you know 10x totally plausible right

869
00:36:48,380 --> 00:36:54,680
and 10x is huge so that's again why it's

870
00:36:52,068 --> 00:36:57,288
so important and again the reason why

871
00:36:54,679 --> 00:37:00,139
this is the case you may wonder who's

872
00:36:57,289 --> 00:37:03,680
really bad idea it was to make these

873
00:37:00,139 --> 00:37:05,179
processors require this because why do

874
00:37:03,679 --> 00:37:06,588
we have to care why can't we just write

875
00:37:05,179 --> 00:37:07,940
the code single-threaded and widen just

876
00:37:06,588 --> 00:37:11,048
make a processor that excuse a single

877
00:37:07,940 --> 00:37:18,079
threaded code is very fast

878
00:37:11,048 --> 00:37:27,230
the answer is heat unfortunately

879
00:37:18,079 --> 00:37:30,230
so basically like heat is bad is is is

880
00:37:27,230 --> 00:37:32,150
basically the problem so what they found

881
00:37:30,230 --> 00:37:35,599
out there is an architecture it was

882
00:37:32,150 --> 00:37:37,190
called the Pentium 6 or the P 6 or

883
00:37:35,599 --> 00:37:40,548
whatever it was the thing after the

884
00:37:37,190 --> 00:37:43,700
Pentium right so there's the Pentium and

885
00:37:40,548 --> 00:37:45,380
then they made the P 6 and the P 6 was

886
00:37:43,699 --> 00:37:47,868
designed to scale to very high clock

887
00:37:45,380 --> 00:37:49,009
rates so they were like ah yeah you know

888
00:37:47,869 --> 00:37:51,950
like we're going to make this run eight

889
00:37:49,009 --> 00:37:53,659
gigahertz or something right what they

890
00:37:51,949 --> 00:37:58,489
found is when they got up to 4 gigahertz

891
00:37:53,659 --> 00:38:00,528
the chip melted basically right and they

892
00:37:58,489 --> 00:38:02,118
just did not anticipate how much heat

893
00:38:00,528 --> 00:38:05,690
these things would generate and how much

894
00:38:02,119 --> 00:38:09,259
the heat would be a problem and to my

895
00:38:05,690 --> 00:38:11,210
knowledge to this day they pretty much

896
00:38:09,259 --> 00:38:14,659
never solved this problem like the heat

897
00:38:11,210 --> 00:38:17,088
just is flat-out not solvable at the

898
00:38:14,659 --> 00:38:18,768
moment I don't know chip design so I

899
00:38:17,088 --> 00:38:21,619
can't speak to that again that may be

900
00:38:18,768 --> 00:38:23,389
not quite true but basically what

901
00:38:21,619 --> 00:38:25,789
happened is right around this period

902
00:38:23,389 --> 00:38:28,098
they hit a heat barrier and the heat

903
00:38:25,789 --> 00:38:30,380
barrier has never been breached it's

904
00:38:28,099 --> 00:38:32,568
basically just a hard limit so you will

905
00:38:30,380 --> 00:38:34,670
never see the 8 gigahertz CPU well

906
00:38:32,568 --> 00:38:36,548
someday you might but you didn't see an

907
00:38:34,670 --> 00:38:38,509
8 gigahertz CPU in the last decade

908
00:38:36,548 --> 00:38:40,400
specifically because of this otherwise

909
00:38:38,509 --> 00:38:43,490
you would have and so what they quickly

910
00:38:40,400 --> 00:38:46,639
found was that they cannot increase the

911
00:38:43,489 --> 00:38:47,358
clock rate any more than they already

912
00:38:46,639 --> 00:38:48,119
have

913
00:38:47,358 --> 00:38:51,750
and what that

914
00:38:48,119 --> 00:38:54,839
means is they've had to do other things

915
00:38:51,750 --> 00:39:00,510
and what were those other things well

916
00:38:54,840 --> 00:39:03,600
number one is wide execution right and

917
00:39:00,510 --> 00:39:06,630
we saw that that's like alright if we

918
00:39:03,599 --> 00:39:09,659
can't go any faster maybe we can go the

919
00:39:06,630 --> 00:39:11,490
same speed but do the operation on four

920
00:39:09,659 --> 00:39:13,920
times as many things and that was Cindy

921
00:39:11,489 --> 00:39:15,569
right that was four times many things

922
00:39:13,920 --> 00:39:17,610
eight times many things sixteen times

923
00:39:15,570 --> 00:39:19,380
many things in five to pay maybe X 512

924
00:39:17,610 --> 00:39:21,050
right and we already took advantage of

925
00:39:19,380 --> 00:39:23,010
that that was the first set of

926
00:39:21,050 --> 00:39:24,420
optimizations we did right we didn't

927
00:39:23,010 --> 00:39:26,010
really have to optimize much really all

928
00:39:24,420 --> 00:39:29,519
we did was just make the routine wide

929
00:39:26,010 --> 00:39:31,020
and hey it got done faster right so

930
00:39:29,519 --> 00:39:32,400
that's what that is and that's a way of

931
00:39:31,019 --> 00:39:34,259
getting for extra performance 8x

932
00:39:32,400 --> 00:39:37,019
performance 60 pips worth right through

933
00:39:34,260 --> 00:39:38,670
the the CPU just by saying okay

934
00:39:37,019 --> 00:39:40,009
instructions instead of operating on one

935
00:39:38,670 --> 00:39:43,650
thing now operate on way more things

936
00:39:40,010 --> 00:39:47,520
right so that's a way to make the speed

937
00:39:43,650 --> 00:39:49,139
not change but the work amount change so

938
00:39:47,519 --> 00:39:53,820
that's the first thing they did number

939
00:39:49,139 --> 00:39:55,949
two was more more execution right and

940
00:39:53,820 --> 00:39:57,930
that's what threads are they were just

941
00:39:55,949 --> 00:40:00,149
like alright if we can't go any faster

942
00:39:57,929 --> 00:40:02,699
let's just execute more different

943
00:40:00,150 --> 00:40:04,889
programs at once right and we'll just

944
00:40:02,699 --> 00:40:06,989
hope that the programmers can figure out

945
00:40:04,889 --> 00:40:10,170
ways of breaking their work up into

946
00:40:06,989 --> 00:40:11,819
multiple simultaneous programs and so

947
00:40:10,170 --> 00:40:14,519
that's where we're at today and that's

948
00:40:11,820 --> 00:40:16,019
why optimization today largely boils

949
00:40:14,519 --> 00:40:18,329
down to how well you can do these two

950
00:40:16,019 --> 00:40:20,190
things because at the end of the day

951
00:40:18,329 --> 00:40:22,409
this is where all of the processor

952
00:40:20,190 --> 00:40:25,889
horsepower now goes it's getting wider

953
00:40:22,409 --> 00:40:28,980
and getting more execution at the same

954
00:40:25,889 --> 00:40:30,329
time right and so we've already looked

955
00:40:28,980 --> 00:40:32,730
at how to do this and you kind of have

956
00:40:30,329 --> 00:40:35,250
an idea of how to write routines to do

957
00:40:32,730 --> 00:40:36,510
this now and so this is the second thing

958
00:40:35,250 --> 00:40:40,079
that we're trying to do now we've got

959
00:40:36,510 --> 00:40:42,120
about 1518 minutes left and so what I

960
00:40:40,079 --> 00:40:48,360
want to do is pop back to win32 and show

961
00:40:42,119 --> 00:40:49,469
you how to do the basics okay so

962
00:40:48,360 --> 00:40:51,660
hopefully everyone's kind of clear on

963
00:40:49,469 --> 00:40:53,969
that there's not a lot of mystery there

964
00:40:51,659 --> 00:40:56,399
it's at its core again it's a very

965
00:40:53,969 --> 00:40:58,649
simple concept it's just saying hey

966
00:40:56,400 --> 00:40:59,700
before you could execute one thing now

967
00:40:58,650 --> 00:41:00,900
you can have

968
00:40:59,699 --> 00:41:03,629
multiple things like shooting at the

969
00:41:00,900 --> 00:41:05,309
same time but other than that they're

970
00:41:03,630 --> 00:41:07,619
basically the same right and there's a

971
00:41:05,309 --> 00:41:09,420
bunch of nuance to it that will start

972
00:41:07,619 --> 00:41:13,140
going into over the next couple days but

973
00:41:09,420 --> 00:41:15,030
that's that's really about it and really

974
00:41:13,139 --> 00:41:16,828
gets down memory the way you deal with

975
00:41:15,030 --> 00:41:18,630
memory and synchronization issues tends

976
00:41:16,829 --> 00:41:21,240
to be the the part that's really hard

977
00:41:18,630 --> 00:41:22,588
about multi-threading you'll already see

978
00:41:21,239 --> 00:41:23,819
there's there's already one thing we'll

979
00:41:22,588 --> 00:41:25,739
have to change in the way that we're

980
00:41:23,820 --> 00:41:27,450
filling our rectangles because of the

981
00:41:25,739 --> 00:41:28,889
way cache line boundaries work and stuff

982
00:41:27,449 --> 00:41:30,419
like this so there's one thing left to

983
00:41:28,889 --> 00:41:31,739
do there and then there's another thing

984
00:41:30,420 --> 00:41:34,079
that we'll have to do in terms of

985
00:41:31,739 --> 00:41:35,848
letting people know what which threads

986
00:41:34,079 --> 00:41:38,220
are supposed to do what but that's

987
00:41:35,849 --> 00:41:40,079
basically like you know where the where

988
00:41:38,219 --> 00:41:44,368
the actual difficulty comes in so here

989
00:41:40,079 --> 00:41:46,769
we are in win32 handmade right and what

990
00:41:44,369 --> 00:41:48,480
you can see here is you know when we

991
00:41:46,769 --> 00:41:49,559
wrote this code we never really talked

992
00:41:48,480 --> 00:41:51,990
about threading at all and the reason

993
00:41:49,559 --> 00:41:54,269
for that is because by default things

994
00:41:51,989 --> 00:41:55,858
were set up the same way they were in

995
00:41:54,269 --> 00:41:57,449
the old days right like Windows still

996
00:41:55,858 --> 00:41:58,679
launches your app exactly the way they

997
00:41:57,449 --> 00:42:00,989
used to be in the old days which is to

998
00:41:58,679 --> 00:42:03,419
say that in the old days there was only

999
00:42:00,989 --> 00:42:05,098
one thread execution anyway so you

1000
00:42:03,420 --> 00:42:06,990
called in to win main and it was just a

1001
00:42:05,099 --> 00:42:08,849
given that that was the one thread and

1002
00:42:06,989 --> 00:42:10,588
this was the thread of execution so

1003
00:42:08,849 --> 00:42:12,329
everything pretty much happened on that

1004
00:42:10,588 --> 00:42:18,239
thread and here it is happening on that

1005
00:42:12,329 --> 00:42:19,829
thread so if we want more threads and we

1006
00:42:18,239 --> 00:42:21,299
want to start control more threads we

1007
00:42:19,829 --> 00:42:24,210
need a way of telling the operating

1008
00:42:21,300 --> 00:42:27,180
system hey I need to start making more

1009
00:42:24,210 --> 00:42:30,929
threads give me more execution context

1010
00:42:27,179 --> 00:42:33,899
please and so as you might expect the

1011
00:42:30,929 --> 00:42:35,699
way to do that is with a function called

1012
00:42:33,900 --> 00:42:37,769
create thread it's actually fairly

1013
00:42:35,699 --> 00:42:39,358
straightforward as some things in

1014
00:42:37,769 --> 00:42:40,650
Windows actually are oftentimes the

1015
00:42:39,358 --> 00:42:42,509
things in the Windows kernel are

1016
00:42:40,650 --> 00:42:43,980
actually pretty well thought out because

1017
00:42:42,510 --> 00:42:46,109
honestly the guys who originally wrote

1018
00:42:43,980 --> 00:42:48,240
the Windows kernel were pretty darn

1019
00:42:46,108 --> 00:42:49,889
smart and actually unlike people who

1020
00:42:48,239 --> 00:42:52,469
write a lot of the windows API they were

1021
00:42:49,889 --> 00:42:54,118
very experienced as well which makes a

1022
00:42:52,469 --> 00:42:57,629
huge difference and so some of the

1023
00:42:54,119 --> 00:43:00,809
things that they do are really actually

1024
00:42:57,630 --> 00:43:01,800
pretty well thought out and I'm not

1025
00:43:00,809 --> 00:43:03,059
going to say that create thread is

1026
00:43:01,800 --> 00:43:04,318
perfect or anything like that but I'll

1027
00:43:03,059 --> 00:43:08,068
just say that a lot of the Windows

1028
00:43:04,318 --> 00:43:12,869
kernel stuff is is done in a very nice

1029
00:43:08,068 --> 00:43:13,889
way I Oh completion ports for example IO

1030
00:43:12,869 --> 00:43:16,170
completion ports which will

1031
00:43:13,889 --> 00:43:17,819
use a little later on or probably one of

1032
00:43:16,170 --> 00:43:19,619
the best api's that exists in window

1033
00:43:17,820 --> 00:43:22,710
actually in windows actually it's it's

1034
00:43:19,619 --> 00:43:24,269
almost perfect and that's not something

1035
00:43:22,710 --> 00:43:26,099
that you pretty much ever say about a

1036
00:43:24,269 --> 00:43:28,590
windows API or anyone elses API for that

1037
00:43:26,099 --> 00:43:30,059
matter all right

1038
00:43:28,590 --> 00:43:31,200
so we have a function here that we're

1039
00:43:30,059 --> 00:43:32,429
going to call and I'll just call it

1040
00:43:31,199 --> 00:43:33,329
right at the top for now we'll worry

1041
00:43:32,429 --> 00:43:34,289
about where we're going to call it a

1042
00:43:33,329 --> 00:43:35,909
little bit later I just want to show you

1043
00:43:34,289 --> 00:43:38,340
how it works we have a function here

1044
00:43:35,909 --> 00:43:39,779
called create thread okay and what that

1045
00:43:38,340 --> 00:43:44,309
does is it returns us to handle to the

1046
00:43:39,780 --> 00:43:50,130
thread this is our thread oops our

1047
00:43:44,309 --> 00:43:52,019
thread handle okay and it takes a bunch

1048
00:43:50,130 --> 00:43:54,869
of things in first of all it takes these

1049
00:43:52,019 --> 00:43:56,550
LP security attributes and what those

1050
00:43:54,869 --> 00:43:58,829
are is we don't really care very much

1051
00:43:56,550 --> 00:44:00,240
about those we I think we bumped into

1052
00:43:58,829 --> 00:44:01,230
them once before we said we didn't care

1053
00:44:00,239 --> 00:44:02,969
about them there we also don't care

1054
00:44:01,230 --> 00:44:06,119
about them here what those are is these

1055
00:44:02,969 --> 00:44:08,129
things that you can do if you wanted a

1056
00:44:06,119 --> 00:44:10,440
thread that you were creating to not

1057
00:44:08,130 --> 00:44:13,920
have the same permissions that you have

1058
00:44:10,440 --> 00:44:15,179
right and so we don't really care about

1059
00:44:13,920 --> 00:44:16,650
that so we're just going to passion

1060
00:44:15,179 --> 00:44:19,619
though which basically says that you

1061
00:44:16,650 --> 00:44:21,480
know the thread that I'm creating should

1062
00:44:19,619 --> 00:44:23,099
be able to do anything that I can do but

1063
00:44:21,480 --> 00:44:25,679
you can imagine in other security

1064
00:44:23,099 --> 00:44:27,449
scenarios where you wanted a thread to

1065
00:44:25,679 --> 00:44:30,179
have restricted ability to call when

1066
00:44:27,449 --> 00:44:31,589
win32 calls like oh I'm going to I don't

1067
00:44:30,179 --> 00:44:32,909
know I'm trying to protect against some

1068
00:44:31,590 --> 00:44:34,350
kind of hack soaring so I just don't

1069
00:44:32,909 --> 00:44:36,119
want this thread to be able to call some

1070
00:44:34,349 --> 00:44:37,860
stuff I don't know whatever you can

1071
00:44:36,119 --> 00:44:40,440
imagine maybe some cases where you want

1072
00:44:37,860 --> 00:44:42,930
to do that in games you rarely have that

1073
00:44:40,440 --> 00:44:43,950
case but you know maybe a web browser or

1074
00:44:42,929 --> 00:44:46,399
somebody else wants to do stuff like

1075
00:44:43,949 --> 00:44:46,399
that okay

1076
00:44:46,650 --> 00:44:50,490
so then we've got the actual meat of the

1077
00:44:48,719 --> 00:44:53,609
thing here we've got the stack size

1078
00:44:50,489 --> 00:44:56,309
right you can see what this is what we

1079
00:44:53,610 --> 00:44:58,289
can do here is we can basically say we

1080
00:44:56,309 --> 00:45:00,570
want to use whatever one we were using

1081
00:44:58,289 --> 00:45:02,519
for all the other threads right which is

1082
00:45:00,570 --> 00:45:04,320
if we pass 0 so again we can just pass

1083
00:45:02,519 --> 00:45:06,659
essentially default values for these two

1084
00:45:04,320 --> 00:45:08,670
and nothing will change that stack size

1085
00:45:06,659 --> 00:45:11,279
is whatever we specified when we built

1086
00:45:08,670 --> 00:45:13,860
the executable so in the build bat file

1087
00:45:11,280 --> 00:45:15,840
right we didn't actually put one in here

1088
00:45:13,860 --> 00:45:17,340
but if later on we wanted to we can

1089
00:45:15,840 --> 00:45:18,809
control the stack size in here we played

1090
00:45:17,340 --> 00:45:20,610
around with that a little in early

1091
00:45:18,809 --> 00:45:22,079
handmade hero but so we're just going to

1092
00:45:20,610 --> 00:45:25,019
use the default again but we could we

1093
00:45:22,079 --> 00:45:26,699
could change it then we get down to the

1094
00:45:25,019 --> 00:45:27,329
meat of it which is the start address in

1095
00:45:26,699 --> 00:45:29,519
the LP

1096
00:45:27,329 --> 00:45:31,980
ammeter and basically what these are is

1097
00:45:29,519 --> 00:45:34,380
just saying okay what's the actual code

1098
00:45:31,980 --> 00:45:37,889
for this thread what's actually going to

1099
00:45:34,380 --> 00:45:39,960
happen right and so what you do is you

1100
00:45:37,889 --> 00:45:43,079
create one of these guys it's this this

1101
00:45:39,960 --> 00:45:45,449
is what it looks like right we create

1102
00:45:43,079 --> 00:45:48,840
one of these guys called a thread proc

1103
00:45:45,449 --> 00:45:50,669
and this is the actual parameter I'm so

1104
00:45:48,840 --> 00:45:52,200
going to leave it like that it doesn't

1105
00:45:50,670 --> 00:45:55,079
actually matter in 164 but that's

1106
00:45:52,199 --> 00:45:56,759
separate issue this is actually what the

1107
00:45:55,079 --> 00:45:58,559
code is going to be for this thread

1108
00:45:56,760 --> 00:46:00,420
right it's the entry point for the

1109
00:45:58,559 --> 00:46:01,619
thread so just like when main was where

1110
00:46:00,420 --> 00:46:03,329
we get started calling although

1111
00:46:01,619 --> 00:46:06,359
technically it was in the CRT that first

1112
00:46:03,329 --> 00:46:07,619
call but point being we basically have

1113
00:46:06,360 --> 00:46:09,120
an entry point where this thread is

1114
00:46:07,619 --> 00:46:10,319
going to start executing and then it's

1115
00:46:09,119 --> 00:46:11,549
going to do something in here and then

1116
00:46:10,320 --> 00:46:13,260
it's going to you know when it's done

1117
00:46:11,550 --> 00:46:15,840
it'll exit out and that'll be the end of

1118
00:46:13,260 --> 00:46:18,240
the thread right so we want to we can do

1119
00:46:15,840 --> 00:46:20,269
output debug string you know thread

1120
00:46:18,239 --> 00:46:23,039
started or something like this and

1121
00:46:20,269 --> 00:46:24,210
that's fine and this would be the code

1122
00:46:23,039 --> 00:46:26,489
for the thread that's all the thread

1123
00:46:24,210 --> 00:46:29,250
would do and what we do is we pass that

1124
00:46:26,489 --> 00:46:30,629
address to create thread and say that's

1125
00:46:29,250 --> 00:46:33,150
where I want you to start executing

1126
00:46:30,630 --> 00:46:34,950
right and then what we can do is we can

1127
00:46:33,150 --> 00:46:36,840
also pass a parameter to the thread and

1128
00:46:34,949 --> 00:46:39,359
that parameter is what comes in right

1129
00:46:36,840 --> 00:46:41,130
here right so whatever we pass is the

1130
00:46:39,360 --> 00:46:43,289
next thing is the thing that comes in

1131
00:46:41,130 --> 00:46:46,440
here so right now we don't actually have

1132
00:46:43,289 --> 00:46:48,480
anything but you know we have a pram

1133
00:46:46,440 --> 00:46:50,639
equals 0 we'll just put it there and

1134
00:46:48,480 --> 00:46:51,869
leave it there for right now that's what

1135
00:46:50,639 --> 00:46:53,429
and then later we'll actually worry

1136
00:46:51,869 --> 00:46:55,440
about what we're going to pass it and

1137
00:46:53,429 --> 00:46:56,789
that's what will come in here in fact we

1138
00:46:55,440 --> 00:47:00,659
could do something like this just to

1139
00:46:56,789 --> 00:47:02,369
show it thread started like so we could

1140
00:47:00,659 --> 00:47:06,059
do it this way where we just say a

1141
00:47:02,369 --> 00:47:08,730
string to print equals whatever this LP

1142
00:47:06,059 --> 00:47:12,929
parameter was casted oops and then we

1143
00:47:08,730 --> 00:47:15,360
print it right like so and this way

1144
00:47:12,929 --> 00:47:17,789
we're passing in that right so we call

1145
00:47:15,360 --> 00:47:19,829
that almost like that not really

1146
00:47:17,789 --> 00:47:22,170
anything particularly too weird there we

1147
00:47:19,829 --> 00:47:23,969
then have two more things which is the

1148
00:47:22,170 --> 00:47:26,880
creation flags and you can see those

1149
00:47:23,969 --> 00:47:30,089
again always using MSDN you can see

1150
00:47:26,880 --> 00:47:32,640
those here and basically what these are

1151
00:47:30,090 --> 00:47:35,670
is special ways that we won't want to do

1152
00:47:32,639 --> 00:47:36,960
stuff so normally if we just pass a 0

1153
00:47:35,670 --> 00:47:38,400
which is what we're going to do here the

1154
00:47:36,960 --> 00:47:41,159
thread just starts executing right away

1155
00:47:38,400 --> 00:47:43,650
right but if we'd want to

1156
00:47:41,159 --> 00:47:45,808
- we could create it so that the thread

1157
00:47:43,650 --> 00:47:48,298
gets created but doesn't actually start

1158
00:47:45,809 --> 00:47:50,039
executing until we call an additional

1159
00:47:48,298 --> 00:47:51,568
function so if we want to create a bunch

1160
00:47:50,039 --> 00:47:54,059
of threads that are just waiting like

1161
00:47:51,568 --> 00:47:56,369
courses at the start of a race until

1162
00:47:54,059 --> 00:47:58,740
like you know the the gates open in the

1163
00:47:56,369 --> 00:48:01,259
air loud and start running basically

1164
00:47:58,739 --> 00:48:02,788
like that resume thread would be the

1165
00:48:01,259 --> 00:48:05,099
thing that actually starts them going

1166
00:48:02,789 --> 00:48:06,509
right so if we wanted to we can create

1167
00:48:05,099 --> 00:48:08,160
the threads and not have them run yet

1168
00:48:06,509 --> 00:48:09,869
but we don't really care about that so

1169
00:48:08,159 --> 00:48:11,639
we don't wanna do that this guy I've

1170
00:48:09,869 --> 00:48:14,130
never even I don't even remember this

1171
00:48:11,639 --> 00:48:16,558
guy being in here but you can see here

1172
00:48:14,130 --> 00:48:18,568
this is basically a thing which says

1173
00:48:16,559 --> 00:48:21,000
whether you want to do reserves or

1174
00:48:18,568 --> 00:48:22,858
commits on the stack memory I mean I

1175
00:48:21,000 --> 00:48:23,969
don't know there must be that must have

1176
00:48:22,858 --> 00:48:25,170
been something that they needed to do at

1177
00:48:23,969 --> 00:48:26,189
some point so they had to flag for it

1178
00:48:25,170 --> 00:48:30,028
we're definitely not going to ever look

1179
00:48:26,190 --> 00:48:31,409
at that okay so then finally and this is

1180
00:48:30,028 --> 00:48:35,039
the part that's a little bit weird in

1181
00:48:31,409 --> 00:48:39,358
Windows threads are identified both by a

1182
00:48:35,039 --> 00:48:41,849
handle and by an identifier okay and I

1183
00:48:39,358 --> 00:48:43,199
feel like this was kind of a mistake but

1184
00:48:41,849 --> 00:48:44,789
I don't know maybe they had a really

1185
00:48:43,199 --> 00:48:46,288
good reason for it I've never really

1186
00:48:44,789 --> 00:48:48,809
grok tweye they thought this was a good

1187
00:48:46,289 --> 00:48:50,819
idea but so they basically have a thread

1188
00:48:48,809 --> 00:48:52,319
ID that identifies the thread and it

1189
00:48:50,818 --> 00:48:53,518
will give you that as a return value as

1190
00:48:52,318 --> 00:48:55,170
well so not only do you get back a

1191
00:48:53,518 --> 00:48:57,239
handle which you can use to operate on

1192
00:48:55,170 --> 00:48:58,829
the thread you also get back an ID which

1193
00:48:57,239 --> 00:49:01,108
you can also use to operate on thread in

1194
00:48:58,829 --> 00:49:03,630
different ways right so you basically

1195
00:49:01,108 --> 00:49:06,869
have the thread ID here and we pass the

1196
00:49:03,630 --> 00:49:08,730
address of that thread ID d-word and it

1197
00:49:06,869 --> 00:49:13,048
will fill it out it's a return value

1198
00:49:08,730 --> 00:49:15,420
essentially it will fill it out with the

1199
00:49:13,048 --> 00:49:16,679
value so if we actually do this so we

1200
00:49:15,420 --> 00:49:19,200
actually run this code that's actually

1201
00:49:16,679 --> 00:49:20,669
all we need to start multi-threaded for

1202
00:49:19,199 --> 00:49:23,639
the most part oops I got a rest return

1203
00:49:20,670 --> 00:49:24,450
something here right this actually

1204
00:49:23,639 --> 00:49:25,949
returns a d-word

1205
00:49:24,449 --> 00:49:27,538
that's actually all we need to actually

1206
00:49:25,949 --> 00:49:29,730
get multi-threading started and if we

1207
00:49:27,539 --> 00:49:32,519
actually run the code here and I just

1208
00:49:29,730 --> 00:49:37,318
run the code in then and then exit or

1209
00:49:32,518 --> 00:49:38,909
try to exit anyway stop in theory we

1210
00:49:37,318 --> 00:49:40,108
should be able to see that work now of

1211
00:49:38,909 --> 00:49:42,808
course I didn't actually see it here I'm

1212
00:49:40,108 --> 00:49:44,940
not sure why we didn't see it oh yes we

1213
00:49:42,809 --> 00:49:48,059
did there it is it's up here so you can

1214
00:49:44,940 --> 00:49:49,528
see it right here right so here's the

1215
00:49:48,059 --> 00:49:51,359
thread started call and you can see

1216
00:49:49,528 --> 00:49:54,298
immediately after it that thread exited

1217
00:49:51,358 --> 00:49:55,739
right and so

1218
00:49:54,298 --> 00:49:58,409
this is just something that happened

1219
00:49:55,739 --> 00:50:00,900
totally separate execution paths than

1220
00:49:58,409 --> 00:50:05,219
the rest of the code and it's just that

1221
00:50:00,900 --> 00:50:06,660
was it right and again we'll be able to

1222
00:50:05,219 --> 00:50:09,929
demonstrate this a little bit more

1223
00:50:06,659 --> 00:50:12,568
explicitly a little bit later on but you

1224
00:50:09,929 --> 00:50:14,579
know that is literally the the entirety

1225
00:50:12,568 --> 00:50:16,380
of how you get multi-threading started

1226
00:50:14,579 --> 00:50:17,160
and so you can create as many of these

1227
00:50:16,380 --> 00:50:19,528
as you want

1228
00:50:17,159 --> 00:50:20,759
right you can imagine us creating lots

1229
00:50:19,528 --> 00:50:24,809
of these threads if that's what we

1230
00:50:20,759 --> 00:50:26,429
wanted to do we could do that like so we

1231
00:50:24,809 --> 00:50:30,959
can just keep on creating threads all

1232
00:50:26,429 --> 00:50:32,999
day long and and no one's going to stop

1233
00:50:30,958 --> 00:50:34,498
us right and so if we want to do that we

1234
00:50:32,998 --> 00:50:36,088
can do that off we go

1235
00:50:34,498 --> 00:50:37,948
that just creates a bunch of threads all

1236
00:50:36,088 --> 00:50:40,099
of which call that initial thing and you

1237
00:50:37,949 --> 00:50:44,699
can see them all happening here right

1238
00:50:40,099 --> 00:50:46,949
and they happen in exit right so that's

1239
00:50:44,699 --> 00:50:48,688
really about it however there's some

1240
00:50:46,949 --> 00:50:51,719
additional work that we probably want to

1241
00:50:48,688 --> 00:50:53,248
do here just to sort of solidify things

1242
00:50:51,719 --> 00:50:54,838
a little bit which is that when we call

1243
00:50:53,248 --> 00:50:58,078
this create thread we get back this

1244
00:50:54,838 --> 00:50:59,429
thread handle ok and the thread handle

1245
00:50:58,079 --> 00:51:03,749
like I said is something that allows us

1246
00:50:59,429 --> 00:51:05,309
to do operations on that thread right so

1247
00:51:03,748 --> 00:51:08,248
once we have a thread handle like for

1248
00:51:05,309 --> 00:51:11,160
example we could destroy the thread or

1249
00:51:08,248 --> 00:51:13,228
we can like that resume thread call that

1250
00:51:11,159 --> 00:51:15,868
you saw if you were to create the thread

1251
00:51:13,228 --> 00:51:17,248
suspended the resume thread call you can

1252
00:51:15,869 --> 00:51:19,469
see that basically what they do is they

1253
00:51:17,248 --> 00:51:22,288
take that thread handle and that's a way

1254
00:51:19,469 --> 00:51:25,349
that you can refer to this particular

1255
00:51:22,289 --> 00:51:27,239
thread right now when we don't want it

1256
00:51:25,349 --> 00:51:30,479
anymore if we don't want that handle

1257
00:51:27,239 --> 00:51:31,798
anymore we can call closed handle which

1258
00:51:30,478 --> 00:51:33,239
basically says to Windows we're not

1259
00:51:31,798 --> 00:51:35,670
going to talk about this thread anymore

1260
00:51:33,239 --> 00:51:35,999
right we're just not it's not going to

1261
00:51:35,670 --> 00:51:40,559
happen

1262
00:51:35,998 --> 00:51:41,788
right and so we can actually do that we

1263
00:51:40,559 --> 00:51:44,459
can actually say we don't care about

1264
00:51:41,789 --> 00:51:48,479
this anymore and say closed handle right

1265
00:51:44,458 --> 00:51:50,208
thread handle but what's important to

1266
00:51:48,478 --> 00:51:53,038
remember is that doesn't kill the thread

1267
00:51:50,208 --> 00:51:54,838
the thread is still going it just says

1268
00:51:53,039 --> 00:51:55,829
closing the handle says you know what I

1269
00:51:54,838 --> 00:51:58,018
don't need to talk about this story

1270
00:51:55,829 --> 00:52:01,259
anymore it's off doing its thing I'm not

1271
00:51:58,018 --> 00:52:02,848
going to explicitly manhandle it and so

1272
00:52:01,259 --> 00:52:04,608
you can just release that handle back to

1273
00:52:02,849 --> 00:52:06,460
the operating system just by doing that

1274
00:52:04,608 --> 00:52:08,380
right

1275
00:52:06,460 --> 00:52:10,809
and what we can see here if I add in

1276
00:52:08,380 --> 00:52:12,088
something like to say I did something

1277
00:52:10,809 --> 00:52:13,930
like this oops

1278
00:52:12,088 --> 00:52:15,578
where I was just going to print the

1279
00:52:13,929 --> 00:52:20,169
string out over and over and over and

1280
00:52:15,579 --> 00:52:21,700
over again ad infinitum right and maybe

1281
00:52:20,170 --> 00:52:24,039
I introduced a sleep here so it doesn't

1282
00:52:21,699 --> 00:52:25,779
spam it too much so this thing is just

1283
00:52:24,039 --> 00:52:29,079
going to every second it's going to

1284
00:52:25,780 --> 00:52:31,359
print this out right what we can see

1285
00:52:29,079 --> 00:52:32,530
here if I do this is yeah I know it's

1286
00:52:31,358 --> 00:52:34,150
unreachable code what do you want me to

1287
00:52:32,530 --> 00:52:39,940
do I got a return a value oh is this one

1288
00:52:34,150 --> 00:52:43,210
of those kept 22s no okay so off we go I

1289
00:52:39,940 --> 00:52:45,970
run this code and what you can see here

1290
00:52:43,210 --> 00:52:48,880
is that even though I've you know closed

1291
00:52:45,969 --> 00:52:51,308
that handle the thread started message

1292
00:52:48,880 --> 00:52:52,720
is still getting printed right and

1293
00:52:51,309 --> 00:52:54,010
that's just going to keep on going that

1294
00:52:52,719 --> 00:52:55,929
threads just going to keep on doing that

1295
00:52:54,010 --> 00:52:57,460
thing because the closed handle is just

1296
00:52:55,929 --> 00:52:59,108
releasing the handle back to the

1297
00:52:57,460 --> 00:53:01,568
operation the sing act I don't need to

1298
00:52:59,108 --> 00:53:02,769
talk about this thread anymore right but

1299
00:53:01,568 --> 00:53:03,849
you should but it's still going to be

1300
00:53:02,769 --> 00:53:06,099
running is still going to be doing its

1301
00:53:03,849 --> 00:53:07,930
execution path right so whether we want

1302
00:53:06,099 --> 00:53:10,210
to or not I don't know whether we need

1303
00:53:07,929 --> 00:53:11,649
to talk about it later we'll see but for

1304
00:53:10,210 --> 00:53:13,568
now you can just seal okay we created it

1305
00:53:11,650 --> 00:53:16,329
it's off it's running we're done right

1306
00:53:13,568 --> 00:53:18,009
and that's about it

1307
00:53:16,329 --> 00:53:21,609
that's that's really the end of it so

1308
00:53:18,010 --> 00:53:24,130
what we would need to do here right is

1309
00:53:21,608 --> 00:53:26,739
we would need to have some way for this

1310
00:53:24,130 --> 00:53:28,720
thing to eventually exit right because

1311
00:53:26,739 --> 00:53:31,328
otherwise whatever it's doing is still

1312
00:53:28,719 --> 00:53:35,469
going to keep on going even after our

1313
00:53:31,329 --> 00:53:37,390
game is like you know our game is

1314
00:53:35,469 --> 00:53:39,788
supposed to exit and this thread is

1315
00:53:37,389 --> 00:53:41,108
still running right and so let's take a

1316
00:53:39,789 --> 00:53:43,690
look at what happens there actually I'll

1317
00:53:41,108 --> 00:53:46,568
show you what I mean by that so our game

1318
00:53:43,690 --> 00:53:48,099
I'm going to actually go stop that draw

1319
00:53:46,568 --> 00:53:49,179
rectangle slowly from eating up all of

1320
00:53:48,099 --> 00:53:51,068
our time I'm going to put it back to the

1321
00:53:49,179 --> 00:53:53,500
fast mode just so we're in a in a more

1322
00:53:51,068 --> 00:53:55,210
well-functioning system so here we go

1323
00:53:53,500 --> 00:53:57,699
here's the game and if I remember

1324
00:53:55,210 --> 00:54:02,409
quickly I believe F alt f4 closes our

1325
00:53:57,699 --> 00:54:04,538
application right so when we do alt f4

1326
00:54:02,409 --> 00:54:07,750
right and it closes the application I

1327
00:54:04,539 --> 00:54:10,809
believe what happens is we do an exit

1328
00:54:07,750 --> 00:54:12,159
process right if I well you know I don't

1329
00:54:10,809 --> 00:54:15,040
actually remember what we did so let's

1330
00:54:12,159 --> 00:54:18,009
actually go take a look at what we did

1331
00:54:15,039 --> 00:54:20,289
there we go 1:32 handmade so I don't

1332
00:54:18,010 --> 00:54:24,580
actually remember what happens here to

1333
00:54:20,289 --> 00:54:27,369
be honest with you I do not know so

1334
00:54:24,579 --> 00:54:29,289
let's take a look exit process do be

1335
00:54:27,369 --> 00:54:32,500
colleagues and pubs makes a process

1336
00:54:29,289 --> 00:54:36,130
anywhere we do not so what happens

1337
00:54:32,500 --> 00:54:39,849
within our WM close handle handler right

1338
00:54:36,130 --> 00:54:42,130
because like we're doing alt f4 global

1339
00:54:39,849 --> 00:54:53,039
running equals false all right let's

1340
00:54:42,130 --> 00:54:55,240
take a look yeah so that code gets

1341
00:54:53,039 --> 00:54:57,460
optimized out oh this is an optimized

1342
00:54:55,239 --> 00:55:01,179
build all right so never mind I will go

1343
00:54:57,460 --> 00:55:04,869
into the build and change back there we

1344
00:55:01,179 --> 00:55:06,369
go alright because I want to see what

1345
00:55:04,869 --> 00:55:08,199
happens when we do that so we hit alt f4

1346
00:55:06,369 --> 00:55:13,329
there we go global running equals false

1347
00:55:08,199 --> 00:55:16,480
and so now we should fall out of our of

1348
00:55:13,329 --> 00:55:20,789
our loop up here right because we've got

1349
00:55:16,480 --> 00:55:23,889
this wild global running situation here

1350
00:55:20,789 --> 00:55:26,789
oops that's not it that's the simple one

1351
00:55:23,889 --> 00:55:34,210
where is our actual wild global running

1352
00:55:26,789 --> 00:55:36,130
hello there it is that's the one so when

1353
00:55:34,210 --> 00:55:38,500
we get here right global running is now

1354
00:55:36,130 --> 00:55:40,660
going to be false so when we actually

1355
00:55:38,500 --> 00:55:43,809
come through here we're going to return

1356
00:55:40,659 --> 00:55:46,420
zero right and if we actually step

1357
00:55:43,809 --> 00:55:50,259
through what happens here we pop out

1358
00:55:46,420 --> 00:55:52,690
right and this is in the C runtime

1359
00:55:50,260 --> 00:55:53,860
library right and I imagine that's

1360
00:55:52,690 --> 00:55:55,389
probably what's going to happen is it's

1361
00:55:53,860 --> 00:55:59,070
going to call the exit process for us

1362
00:55:55,389 --> 00:56:07,239
I'm not actually sure we'll find out

1363
00:55:59,070 --> 00:56:09,610
let's take a look man oh man I assume

1364
00:56:07,239 --> 00:56:17,109
we're going through trying to call C++

1365
00:56:09,610 --> 00:56:25,150
destructors here yeah so much fun oh the

1366
00:56:17,110 --> 00:56:30,550
C++ of it all okay exit process zero to

1367
00:56:25,150 --> 00:56:33,900
exit process get module handle there it

1368
00:56:30,550 --> 00:56:36,550
is so what you can see here is

1369
00:56:33,900 --> 00:56:39,130
eventually the C runtime library calls

1370
00:56:36,550 --> 00:56:41,019
exit process for us right here in there

1371
00:56:39,130 --> 00:56:42,070
lovely C++ cleanup code that's going

1372
00:56:41,019 --> 00:56:43,300
through and trying to claw global

1373
00:56:42,070 --> 00:56:46,690
destructors and God knows what else is

1374
00:56:43,300 --> 00:56:49,450
doing here is the exit process call and

1375
00:56:46,690 --> 00:56:52,480
that exit process call is actually what

1376
00:56:49,449 --> 00:56:54,099
kills our other thread right because

1377
00:56:52,480 --> 00:56:55,929
that other thread is just right it's

1378
00:56:54,099 --> 00:56:57,579
just going right and it would just keep

1379
00:56:55,929 --> 00:56:59,289
on running and our process would never

1380
00:56:57,579 --> 00:57:02,049
exit because we have that thread running

1381
00:56:59,289 --> 00:57:04,659
but exit process basically terminates

1382
00:57:02,050 --> 00:57:06,609
all the threads right

1383
00:57:04,659 --> 00:57:08,739
so right here you can see the very first

1384
00:57:06,608 --> 00:57:12,969
thing that happens all of these threads

1385
00:57:08,739 --> 00:57:17,259
just get terminated basically without

1386
00:57:12,969 --> 00:57:19,088
any regard to where they were okay so

1387
00:57:17,260 --> 00:57:21,789
that is what actually allows our

1388
00:57:19,088 --> 00:57:23,710
application to exit if exit process were

1389
00:57:21,789 --> 00:57:26,440
not being called by the C runtime

1390
00:57:23,710 --> 00:57:28,480
library that thread would just keep on

1391
00:57:26,440 --> 00:57:30,670
running and so it's worth the reason I

1392
00:57:28,480 --> 00:57:32,858
bring that up is because for example one

1393
00:57:30,670 --> 00:57:34,480
thing we have not done yet in handmade

1394
00:57:32,858 --> 00:57:37,568
hero but what we might do in the future

1395
00:57:34,480 --> 00:57:39,789
is build without the C runtime library

1396
00:57:37,568 --> 00:57:41,019
at all in fact we probably will do that

1397
00:57:39,789 --> 00:57:43,480
sometime in the future when we're in the

1398
00:57:41,019 --> 00:57:44,588
mood to do so because again we like to

1399
00:57:43,480 --> 00:57:48,460
do things from scratch here so it'd be

1400
00:57:44,588 --> 00:57:50,469
nice to get that out of there it's worth

1401
00:57:48,460 --> 00:57:54,130
noting we would have to call exit

1402
00:57:50,469 --> 00:57:55,929
process in order to actually kill this

1403
00:57:54,130 --> 00:57:57,970
thread because once we get rid of the

1404
00:57:55,929 --> 00:57:59,259
handle and if we're not actually looking

1405
00:57:57,969 --> 00:58:01,239
up at a thread ID or anything like that

1406
00:57:59,260 --> 00:58:02,380
and trying to kill the thread we would

1407
00:58:01,239 --> 00:58:05,858
have to do that now there's another way

1408
00:58:02,380 --> 00:58:10,990
we could do that right we could say that

1409
00:58:05,858 --> 00:58:13,690
in there in win32 hand-made we could

1410
00:58:10,989 --> 00:58:15,548
actually make this guy also look at that

1411
00:58:13,690 --> 00:58:18,579
right we could say that this guy also

1412
00:58:15,548 --> 00:58:20,139
looks at well global running and he will

1413
00:58:18,579 --> 00:58:21,190
exit when global running a signal as

1414
00:58:20,139 --> 00:58:25,150
well right

1415
00:58:21,190 --> 00:58:27,548
because again threads share all the same

1416
00:58:25,150 --> 00:58:29,798
memory they're not separate processes

1417
00:58:27,548 --> 00:58:32,079
they're separate threads so what that

1418
00:58:29,798 --> 00:58:34,298
means is that any piece of information

1419
00:58:32,079 --> 00:58:37,869
that we want to look at we can actually

1420
00:58:34,298 --> 00:58:40,538
look at right now there's a catch and

1421
00:58:37,869 --> 00:58:42,519
this gets into what we start talking

1422
00:58:40,539 --> 00:58:44,890
about tomorrow probably although maybe

1423
00:58:42,519 --> 00:58:47,288
not we might get into this we might not

1424
00:58:44,889 --> 00:58:49,750
get into still Wednesday is that the

1425
00:58:47,289 --> 00:58:51,400
compiler doesn't unfortunately know

1426
00:58:49,750 --> 00:58:54,190
about these sorts of things it doesn't

1427
00:58:51,400 --> 00:58:56,798
know about threading so actually doing

1428
00:58:54,190 --> 00:58:59,650
this may or may not work right it

1429
00:58:56,798 --> 00:59:01,750
depends and what it depends on is

1430
00:58:59,650 --> 00:59:04,088
whether the compiler tries to reload

1431
00:59:01,750 --> 00:59:06,190
this value or not right because remember

1432
00:59:04,088 --> 00:59:09,099
the optimising compiler how the

1433
00:59:06,190 --> 00:59:12,278
optimizing compiler worked where it

1434
00:59:09,099 --> 00:59:14,680
would you know the optimizing compiler

1435
00:59:12,278 --> 00:59:16,269
would basically say oh well global

1436
00:59:14,679 --> 00:59:18,069
running maybe I know that that never

1437
00:59:16,269 --> 00:59:20,110
changes so I don't

1438
00:59:18,070 --> 00:59:21,880
have to actually reload it from memory

1439
00:59:20,110 --> 00:59:25,840
every time it might do something like

1440
00:59:21,880 --> 00:59:29,980
that not realizing that some other

1441
00:59:25,840 --> 00:59:31,660
thread right unbeknownst to us is what's

1442
00:59:29,980 --> 00:59:34,030
actually going to go change global

1443
00:59:31,659 --> 00:59:35,710
running so there's things like markup

1444
00:59:34,030 --> 00:59:37,480
like volatile and stuff that we might

1445
00:59:35,710 --> 00:59:40,179
need to use to make this sort of stuff

1446
00:59:37,480 --> 00:59:41,440
work right so for now we'll leave that I

1447
00:59:40,179 --> 00:59:43,089
just want to point that out and then

1448
00:59:41,440 --> 00:59:45,940
it's time to wrap up anyway so we'll go

1449
00:59:43,090 --> 00:59:48,280
ahead and go to the QA that is a very

1450
00:59:45,940 --> 00:59:49,990
brief introduction to threading tomorrow

1451
00:59:48,280 --> 00:59:51,340
what we'll do is we'll create a bunch of

1452
00:59:49,989 --> 00:59:53,319
these threads and figure out how to

1453
00:59:51,340 --> 00:59:55,329
start pointing them at the renderer if

1454
00:59:53,320 --> 00:59:57,180
that makes sense but hopefully that was

1455
00:59:55,329 --> 01:00:00,819
a reasonable introduction to threading

1456
00:59:57,179 --> 01:00:08,399
and and now I will take questions on

1457
01:00:00,820 --> 01:00:08,400
that it's type Q and a there we go

1458
01:00:26,789 --> 01:00:30,959
what does closing the handle of a thread

1459
01:00:29,458 --> 01:00:33,298
do for you when you release the handle

1460
01:00:30,958 --> 01:00:35,759
to the OS does it open up resources and

1461
01:00:33,298 --> 01:00:38,458
increase performance so in our case

1462
01:00:35,759 --> 01:00:39,838
nothing really I mean the way that we're

1463
01:00:38,458 --> 01:00:42,538
going to do stuff is we're going to

1464
01:00:39,838 --> 01:00:44,818
create 16 threads basically we're 15

1465
01:00:42,539 --> 01:00:46,439
threads include and then we'll have the

1466
01:00:44,818 --> 01:00:48,778
16th from the one we have here whatever

1467
01:00:46,438 --> 01:00:52,588
and we don't really have to close those

1468
01:00:48,778 --> 01:00:54,179
handles it doesn't matter but the reason

1469
01:00:52,588 --> 01:00:57,058
I pointed it out was because it is

1470
01:00:54,179 --> 01:00:58,349
creating a handle so what it means is

1471
01:00:57,059 --> 01:01:02,219
that there's only a certain number of

1472
01:00:58,349 --> 01:01:04,559
handles and so on so closing them might

1473
01:01:02,219 --> 01:01:08,818
free up some slots for the operation so

1474
01:01:04,559 --> 01:01:10,319
you get it doesn't matter honestly it

1475
01:01:08,818 --> 01:01:12,418
really doesn't matter I just wanted to

1476
01:01:10,318 --> 01:01:14,518
point it out it's sort of good

1477
01:01:12,418 --> 01:01:16,368
housekeeping to say ok if I'm not going

1478
01:01:14,518 --> 01:01:20,038
to use the handle anymore I'll free it

1479
01:01:16,369 --> 01:01:21,660
but really in the way we're using it now

1480
01:01:20,039 --> 01:01:23,249
you could just you could just go ahead

1481
01:01:21,659 --> 01:01:25,498
and let the handle leak and it wouldn't

1482
01:01:23,248 --> 01:01:33,358
matter at all so in practice nothing

1483
01:01:25,498 --> 01:01:35,038
there's no difference doesn't increasing

1484
01:01:33,358 --> 01:01:37,498
the number of threads to match the hyper

1485
01:01:35,039 --> 01:01:39,509
threads count increase cross core across

1486
01:01:37,498 --> 01:01:43,558
context switches thus making it less

1487
01:01:39,509 --> 01:01:46,798
efficient for small operations well it

1488
01:01:43,559 --> 01:01:55,289
depends so basically what you have to

1489
01:01:46,798 --> 01:01:57,478
keep in mind is how much overhead are

1490
01:01:55,289 --> 01:02:00,869
you introducing for your multiple

1491
01:01:57,478 --> 01:02:01,998
threads right and that's something that

1492
01:02:00,869 --> 01:02:03,809
we haven't really talked about yet

1493
01:02:01,998 --> 01:02:05,938
because we haven't started actually

1494
01:02:03,809 --> 01:02:08,039
doing work on these threads but there's

1495
01:02:05,938 --> 01:02:09,838
a question of how much overhead are you

1496
01:02:08,039 --> 01:02:12,839
introducing to have the secondary thread

1497
01:02:09,838 --> 01:02:14,818
if that overhead in terms of like how it

1498
01:02:12,838 --> 01:02:17,188
communicates and how the work has to be

1499
01:02:14,818 --> 01:02:19,168
done differently to partition it if that

1500
01:02:17,188 --> 01:02:21,748
overhead is very small then it's

1501
01:02:19,168 --> 01:02:23,068
unlikely that you will then that it's

1502
01:02:21,748 --> 01:02:25,798
unlikely that you'll ever going to lose

1503
01:02:23,068 --> 01:02:28,469
from using the same number of threads as

1504
01:02:25,798 --> 01:02:32,009
there are hyper thread slots available

1505
01:02:28,469 --> 01:02:34,349
in the machine but if you are actually

1506
01:02:32,009 --> 01:02:36,228
creating more work and more like if

1507
01:02:34,349 --> 01:02:38,950
you're creating a lot of extra stuff

1508
01:02:36,228 --> 01:02:40,389
that happens there in

1509
01:02:38,949 --> 01:02:42,879
terms of getting the hyper-threading

1510
01:02:40,389 --> 01:02:45,429
getting up to the number of threads that

1511
01:02:42,880 --> 01:02:47,500
you need then that can definitely be the

1512
01:02:45,429 --> 01:02:49,059
case it may be the case that you really

1513
01:02:47,500 --> 01:02:50,530
only want to increase it to the number

1514
01:02:49,059 --> 01:02:54,338
of actual cores not to the number of

1515
01:02:50,530 --> 01:02:56,470
hyper cores but again the only real way

1516
01:02:54,338 --> 01:02:58,900
you can know that is by testing it so

1517
01:02:56,469 --> 01:03:00,699
you probably want to if you really care

1518
01:02:58,900 --> 01:03:03,789
about the formants try it at least first

1519
01:03:00,699 --> 01:03:04,838
before deciding ahead of time that you

1520
01:03:03,789 --> 01:03:08,190
think it's one way or the other because

1521
01:03:04,838 --> 01:03:08,190
you probably aren't going to guess right

1522
01:03:20,889 --> 01:03:24,609
is there any advantage to creating a

1523
01:03:22,960 --> 01:03:26,250
separate process to render the graphics

1524
01:03:24,610 --> 01:03:29,230
in the context of game development

1525
01:03:26,250 --> 01:03:32,650
probably not the only reason you would

1526
01:03:29,230 --> 01:03:35,050
want to create a separate process is if

1527
01:03:32,650 --> 01:03:36,910
you were worried about security but

1528
01:03:35,050 --> 01:03:38,519
there isn't really much reason to create

1529
01:03:36,909 --> 01:03:45,969
a separate process to render graphics

1530
01:03:38,519 --> 01:03:48,489
otherwise because I mean okay so there's

1531
01:03:45,969 --> 01:03:51,099
one other reason it would be if you were

1532
01:03:48,489 --> 01:03:52,719
on 32-bit windows instead of 64-bit

1533
01:03:51,099 --> 01:03:55,239
windows which is becoming increasingly

1534
01:03:52,719 --> 01:03:55,809
rare so I doubt that anyone would do

1535
01:03:55,239 --> 01:03:59,259
this anymore

1536
01:03:55,809 --> 01:04:01,989
but if you were on 32-bit windows you

1537
01:03:59,260 --> 01:04:04,270
would get more memory because remember

1538
01:04:01,989 --> 01:04:06,699
each process has its own virtual memory

1539
01:04:04,269 --> 01:04:09,789
space which on 32 at Windows is 2

1540
01:04:06,699 --> 01:04:11,500
gigabytes of memory for the for the

1541
01:04:09,789 --> 01:04:13,539
process memory and 2 gigabytes of memory

1542
01:04:11,500 --> 01:04:16,869
for kernel mapped memory and other

1543
01:04:13,539 --> 01:04:20,619
things right so if you needed more than

1544
01:04:16,869 --> 01:04:22,480
a 2 gig to Gig split then you wanted

1545
01:04:20,619 --> 01:04:25,029
your game to say have a four gig 4 gig

1546
01:04:22,480 --> 01:04:27,130
split if you broke the game into two

1547
01:04:25,030 --> 01:04:32,290
processes each process gets its own two

1548
01:04:27,130 --> 01:04:36,369
gigabytes right so I mean in some real

1549
01:04:32,289 --> 01:04:38,619
crazy scenario maybe but on 64-bit

1550
01:04:36,369 --> 01:04:40,659
Windows I don't think there's really any

1551
01:04:38,619 --> 01:04:42,789
reason you would want to do it if you

1552
01:04:40,659 --> 01:04:45,639
weren't if it wasn't first for making a

1553
01:04:42,789 --> 01:04:47,349
security partition because in 64-bit

1554
01:04:45,639 --> 01:04:48,759
windows you have way more memory

1555
01:04:47,349 --> 01:04:51,610
addressing space than you could possibly

1556
01:04:48,760 --> 01:04:54,160
need and so there wouldn't be any reason

1557
01:04:51,610 --> 01:04:59,829
to go breaking it up into multiple oxys

1558
01:04:54,159 --> 01:05:01,449
like that is it still a while yet before

1559
01:04:59,829 --> 01:05:03,940
we look at other platform layers other

1560
01:05:01,449 --> 01:05:04,960
than win32 yeah so just to be clear on

1561
01:05:03,940 --> 01:05:07,240
that I've said it a couple times I'll

1562
01:05:04,960 --> 01:05:08,829
say it again we won't be doing multiple

1563
01:05:07,239 --> 01:05:10,750
platform layers until we're ready to

1564
01:05:08,829 --> 01:05:14,259
ship because otherwise we're just

1565
01:05:10,750 --> 01:05:16,119
wasting work because we want one

1566
01:05:14,260 --> 01:05:17,470
platform layer that has all the stuff in

1567
01:05:16,119 --> 01:05:19,269
it that we know we need so we want the

1568
01:05:17,469 --> 01:05:20,829
game to basically be done and having all

1569
01:05:19,269 --> 01:05:23,139
the platform support that we know that

1570
01:05:20,829 --> 01:05:25,179
we need and then we just port just that

1571
01:05:23,139 --> 01:05:26,710
instead of trying to maintain multiple

1572
01:05:25,179 --> 01:05:30,089
platform layers at a time which just

1573
01:05:26,710 --> 01:05:30,090
wastes a lot of work right

1574
01:05:31,199 --> 01:05:37,659
why just 15 threads why not future-proof

1575
01:05:34,320 --> 01:05:39,970
so when I say 16 threads I'm talking

1576
01:05:37,659 --> 01:05:42,909
about on this particular machine what we

1577
01:05:39,969 --> 01:05:44,649
will be doing is not creating 16 magical

1578
01:05:42,909 --> 01:05:46,629
threads and saying that's good because

1579
01:05:44,650 --> 01:05:49,510
that would actually be too many threads

1580
01:05:46,630 --> 01:05:52,150
for people who have only a fork or two

1581
01:05:49,510 --> 01:05:53,500
hyper thread processor right so what we

1582
01:05:52,150 --> 01:05:55,780
will actually be doing is we'll be

1583
01:05:53,500 --> 01:05:57,099
calling a function that asks the

1584
01:05:55,780 --> 01:05:58,780
operating system how many processors

1585
01:05:57,099 --> 01:06:01,469
there actually are and that's how many

1586
01:05:58,780 --> 01:06:01,470
threads we'll be creating

1587
01:06:10,969 --> 01:06:13,029
you

1588
01:06:18,929 --> 01:06:22,629
will we be creating the system for its

1589
01:06:21,190 --> 01:06:28,990
CPU count determine how many threads to

1590
01:06:22,630 --> 01:06:30,130
use yes and we will also try to out in

1591
01:06:28,989 --> 01:06:32,379
the fact this is the next question do

1592
01:06:30,130 --> 01:06:33,789
you have control over on which cord the

1593
01:06:32,380 --> 01:06:37,599
thread excuse from the program itself

1594
01:06:33,789 --> 01:06:38,980
and the answer is to some degree yes and

1595
01:06:37,599 --> 01:06:40,210
so what we will be doing is we'll be

1596
01:06:38,980 --> 01:06:42,219
using operating system calls to

1597
01:06:40,210 --> 01:06:47,079
basically say how many processors are

1598
01:06:42,219 --> 01:06:49,419
there to what extent can you tell me mr.

1599
01:06:47,079 --> 01:06:52,239
operating system which of these

1600
01:06:49,420 --> 01:06:55,720
processor logical processors share

1601
01:06:52,239 --> 01:06:57,250
resources like caches right and that's

1602
01:06:55,719 --> 01:07:00,639
the hyper thread thing right because two

1603
01:06:57,250 --> 01:07:03,489
hyper threads share resources on a core

1604
01:07:00,639 --> 01:07:05,529
and then we will be using that

1605
01:07:03,489 --> 01:07:09,519
information to as best as we can create

1606
01:07:05,530 --> 01:07:13,180
the right number of threads and hint to

1607
01:07:09,519 --> 01:07:16,389
the operating system which cores we want

1608
01:07:13,179 --> 01:07:18,730
those threads to run on so that we will

1609
01:07:16,389 --> 01:07:21,489
try to make it so that if the thing has

1610
01:07:18,730 --> 01:07:24,369
you know eight cores with two hyper

1611
01:07:21,489 --> 01:07:27,669
threads each we actually create two

1612
01:07:24,369 --> 01:07:29,440
threads per core to run and know which

1613
01:07:27,670 --> 01:07:31,570
two they are so that they can work on

1614
01:07:29,440 --> 01:07:36,220
the correct workloads to try to maximize

1615
01:07:31,570 --> 01:07:38,620
the caster's cache usage so we will try

1616
01:07:36,219 --> 01:07:40,719
to do that and Windows does give you

1617
01:07:38,619 --> 01:07:43,349
calls that get get that allow you to do

1618
01:07:40,719 --> 01:07:43,349
those sorts of things

1619
01:07:56,588 --> 01:08:04,489
do you plan to make pathfinding

1620
01:07:59,358 --> 01:08:07,420
multi-threaded so I don't think we will

1621
01:08:04,489 --> 01:08:10,129
probably multi-thread pathfinding

1622
01:08:07,420 --> 01:08:12,409
specifically itself what I suspect we

1623
01:08:10,130 --> 01:08:15,140
will do is multi thread simulation in

1624
01:08:12,409 --> 01:08:16,698
general and so that all of the

1625
01:08:15,139 --> 01:08:19,429
simulation stuff can happen while they

1626
01:08:16,698 --> 01:08:26,928
thread it if we want it to we'll see I'm

1627
01:08:19,429 --> 01:08:28,670
not sure but we'll see Jonathan Blow had

1628
01:08:26,929 --> 01:08:30,440
created 10,000 threads on his compiler

1629
01:08:28,670 --> 01:08:33,350
demo some people wondered how in the

1630
01:08:30,439 --> 01:08:36,710
world that could happen well a thread is

1631
01:08:33,350 --> 01:08:38,179
just a CPU State so you can create

1632
01:08:36,710 --> 01:08:39,350
hundreds of thousands of them you could

1633
01:08:38,179 --> 01:08:41,179
create a million of them if you wanted

1634
01:08:39,350 --> 01:08:42,890
to it's only limited by the amount of

1635
01:08:41,179 --> 01:08:44,239
storage space the operating system will

1636
01:08:42,890 --> 01:08:47,329
allow you to use for storing thread

1637
01:08:44,238 --> 01:08:48,979
State that's it because remember there's

1638
01:08:47,329 --> 01:08:50,689
only 16 of them like on this processor

1639
01:08:48,979 --> 01:08:52,519
that are happening on the processor so

1640
01:08:50,689 --> 01:08:54,019
the rest of it is just memory that the

1641
01:08:52,520 --> 01:08:55,370
operating system is reserving to store

1642
01:08:54,020 --> 01:08:58,850
the state of a thread that it might swap

1643
01:08:55,369 --> 01:09:01,390
in at some point right that's it so

1644
01:08:58,850 --> 01:09:05,660
creating a thread is not a big deal

1645
01:09:01,390 --> 01:09:07,130
right you you wouldn't ever want to

1646
01:09:05,659 --> 01:09:09,108
create 10,000 threads because you're

1647
01:09:07,130 --> 01:09:10,850
just wasting a bunch of resources and

1648
01:09:09,109 --> 01:09:12,739
slowing things down because the

1649
01:09:10,850 --> 01:09:14,449
operation has to swap them in so

1650
01:09:12,738 --> 01:09:16,309
typically you only want as many threads

1651
01:09:14,448 --> 01:09:22,698
as can actually execute on the processor

1652
01:09:16,310 --> 01:09:24,380
right but you can create as many as you

1653
01:09:22,698 --> 01:09:25,939
want up to the limit that the operating

1654
01:09:24,380 --> 01:09:29,829
system until the operating system just

1655
01:09:25,939 --> 01:09:29,829
says I'm out of space right

1656
01:09:37,050 --> 01:09:48,750
I think all the rest of the questions

1657
01:09:46,859 --> 01:09:51,779
were not on topic do we have any other

1658
01:09:48,750 --> 01:09:52,170
on topic questions first let me make

1659
01:09:51,779 --> 01:09:56,329
sure

1660
01:09:52,170 --> 01:09:59,250
and by the way Carl and Oh bloom is

1661
01:09:56,329 --> 01:10:01,289
totally right obviously no one will ever

1662
01:09:59,250 --> 01:10:06,930
need more than 16 threads or two

1663
01:10:01,289 --> 01:10:08,220
gigabytes of RAM clearly Andy Seven

1664
01:10:06,930 --> 01:10:10,500
Samurai it's also correct that no one

1665
01:10:08,220 --> 01:10:11,820
will ever need more than 20 56 colors we

1666
01:10:10,500 --> 01:10:13,649
just know these limits there of it

1667
01:10:11,819 --> 01:10:15,509
they're so high how could you ever use

1668
01:10:13,649 --> 01:10:17,519
more than 26 colors I don't even know

1669
01:10:15,510 --> 01:10:21,210
like how many colors can you name red

1670
01:10:17,520 --> 01:10:22,650
green blue cyan magenta I mean that's it

1671
01:10:21,210 --> 01:10:25,560
right I mean you probably only need like

1672
01:10:22,649 --> 01:10:27,149
16 colors really okay I dare you there

1673
01:10:25,560 --> 01:10:30,780
aren't even 200 colors in one of those

1674
01:10:27,149 --> 01:10:33,799
big boxes of Crayola so clearly these

1675
01:10:30,779 --> 01:10:33,800
limits are totally fine

1676
01:10:44,488 --> 01:10:47,579
all right so it doesn't look like

1677
01:10:45,960 --> 01:10:49,590
there's any more on topic questions so

1678
01:10:47,579 --> 01:10:54,689
I'll address a couple of the off-topic

1679
01:10:49,590 --> 01:10:57,569
ones why you see over C++

1680
01:10:54,689 --> 01:11:00,079
I would note we do use some C++ features

1681
01:10:57,569 --> 01:11:02,849
occasionally operator overloading

1682
01:11:00,079 --> 01:11:06,149
function overloading and declare

1683
01:11:02,850 --> 01:11:09,539
anywhere our C++ features that we use

1684
01:11:06,149 --> 01:11:10,549
now granted declare anywhere I think now

1685
01:11:09,539 --> 01:11:13,829
is in c99

1686
01:11:10,550 --> 01:11:16,079
so that's not really a C++ feature I

1687
01:11:13,829 --> 01:11:17,880
guess but just point being when I

1688
01:11:16,079 --> 01:11:21,779
started using it it was a C++ feature

1689
01:11:17,880 --> 01:11:24,060
back in the 90s but the reason that I

1690
01:11:21,779 --> 01:11:26,550
don't use C++ is because almost all the

1691
01:11:24,060 --> 01:11:28,020
features of C++ are bad they're they're

1692
01:11:26,550 --> 01:11:30,420
poorly implemented they don't work very

1693
01:11:28,020 --> 01:11:34,230
well they end up wasting a lot of code

1694
01:11:30,420 --> 01:11:37,560
and producing lousy output code they're

1695
01:11:34,229 --> 01:11:38,909
just they're just really bad C++ is a

1696
01:11:37,560 --> 01:11:43,830
lousy language and most of its features

1697
01:11:38,909 --> 01:11:45,210
are lousy so I don't use them C is a

1698
01:11:43,829 --> 01:11:47,640
pretty good language and most of its

1699
01:11:45,210 --> 01:11:49,020
features are good I wish it had other

1700
01:11:47,640 --> 01:11:51,090
features they're a bunch of features I

1701
01:11:49,020 --> 01:11:52,650
wish C had that it doesn't unfortunately

1702
01:11:51,090 --> 01:11:55,770
C++ doesn't add those features it adds

1703
01:11:52,649 --> 01:11:58,099
other lousy features and you know what

1704
01:11:55,770 --> 01:11:58,100
do you do

1705
01:12:10,899 --> 01:12:15,710
can we stay on stream after I end the

1706
01:12:13,850 --> 01:12:19,010
episode recording for another try on the

1707
01:12:15,710 --> 01:12:21,859
story yes I will stay on and we can try

1708
01:12:19,010 --> 01:12:24,250
that again two other questions which

1709
01:12:21,859 --> 01:12:27,949
programmers code you'd recommend reading

1710
01:12:24,250 --> 01:12:29,960
I don't know I don't spend a lot of time

1711
01:12:27,949 --> 01:12:31,909
reading other people's code and I'm not

1712
01:12:29,960 --> 01:12:36,380
sure what you mean by that

1713
01:12:31,909 --> 01:12:39,109
if you mean like to pick up good habits

1714
01:12:36,380 --> 01:12:40,550
in coding or to learn about how to

1715
01:12:39,109 --> 01:12:44,719
implement algorithms like it would

1716
01:12:40,550 --> 01:12:47,600
depend right and that stuff's pretty

1717
01:12:44,720 --> 01:12:50,659
preference oriented so I don't really

1718
01:12:47,600 --> 01:12:54,470
know into when are we covering patching

1719
01:12:50,659 --> 01:12:57,619
or a couple of words on brief basics of

1720
01:12:54,470 --> 01:13:00,440
patching so you're talking about you

1721
01:12:57,619 --> 01:13:02,569
want an asset list and you want to

1722
01:13:00,439 --> 01:13:05,119
update the asset list so I don't know

1723
01:13:02,569 --> 01:13:06,710
that we'll ever cover patching because I

1724
01:13:05,119 --> 01:13:09,409
don't know that we have a lot of options

1725
01:13:06,710 --> 01:13:11,989
in terms of doing patching right like my

1726
01:13:09,409 --> 01:13:13,220
understanding and again this is not

1727
01:13:11,989 --> 01:13:17,329
something that I normally deal with my

1728
01:13:13,220 --> 01:13:18,860
understanding is like Steam does the

1729
01:13:17,329 --> 01:13:21,199
patching the way it does the patching

1730
01:13:18,859 --> 01:13:22,639
right so like when we put our game up

1731
01:13:21,199 --> 01:13:25,479
there or whatever we're going to do in

1732
01:13:22,640 --> 01:13:32,329
terms of getting of releasing the game

1733
01:13:25,479 --> 01:13:33,919
we don't get to do patching right so you

1734
01:13:32,329 --> 01:13:35,449
know I don't I don't know that there's

1735
01:13:33,920 --> 01:13:36,890
really anything we're going to do with

1736
01:13:35,449 --> 01:13:38,899
patching because the patching is

1737
01:13:36,890 --> 01:13:41,000
determined to a large extent by the

1738
01:13:38,899 --> 01:13:42,920
distribution service you know if we put

1739
01:13:41,000 --> 01:13:44,949
it on GOG galaxy or something like they

1740
01:13:42,920 --> 01:13:47,390
have their own patching as far as I know

1741
01:13:44,949 --> 01:13:49,010
so I don't actually know to what extent

1742
01:13:47,390 --> 01:13:53,570
we are allowed to do anything with

1743
01:13:49,010 --> 01:13:55,640
patching so we may never cover that but

1744
01:13:53,569 --> 01:13:57,049
in terms of how to deal with it like you

1745
01:13:55,640 --> 01:13:59,090
know it's a pretty straightforward

1746
01:13:57,050 --> 01:14:01,940
problem you can go read about our sink

1747
01:13:59,090 --> 01:14:06,770
you can go read about standard you know

1748
01:14:01,939 --> 01:14:08,239
diffing systems and you know if you want

1749
01:14:06,770 --> 01:14:10,310
to go those routes you can go those

1750
01:14:08,239 --> 01:14:11,809
routes there isn't something special

1751
01:14:10,310 --> 01:14:13,070
about game assets that makes any

1752
01:14:11,810 --> 01:14:16,060
different from other people's

1753
01:14:13,069 --> 01:14:16,059
synchronization really

1754
01:14:16,128 --> 01:14:25,639
so what was the reason for dismissing

1755
01:14:22,279 --> 01:14:27,559
the use of fibers early on so the reason

1756
01:14:25,639 --> 01:14:29,269
is because fibers don't give us what we

1757
01:14:27,559 --> 01:14:31,099
actually wanted out of threading like

1758
01:14:29,269 --> 01:14:33,378
our problem right now is not that we

1759
01:14:31,099 --> 01:14:35,719
need to interleave work on the same cpu

1760
01:14:33,378 --> 01:14:37,639
core our problem is we need more work

1761
01:14:35,719 --> 01:14:40,248
available for the processor and fibers

1762
01:14:37,639 --> 01:14:42,559
don't do that right so we don't actually

1763
01:14:40,248 --> 01:14:44,779
have a use case for fibers at the moment

1764
01:14:42,559 --> 01:14:46,969
and I don't think we ever will I don't

1765
01:14:44,779 --> 01:14:50,139
anticipate us ever needing them we want

1766
01:14:46,969 --> 01:14:50,139
actual real threads

1767
01:14:58,479 --> 01:15:01,929
have you made any progress on the

1768
01:15:00,130 --> 01:15:02,859
license text reports for other program

1769
01:15:01,929 --> 01:15:04,748
to other programming languages

1770
01:15:02,859 --> 01:15:05,618
unfortunately not I tried multiple times

1771
01:15:04,748 --> 01:15:09,099
to do this

1772
01:15:05,618 --> 01:15:11,859
unfortunately the liability is a little

1773
01:15:09,099 --> 01:15:14,769
bit difficult so like what I was trying

1774
01:15:11,859 --> 01:15:18,038
to figure out is how I would get it so

1775
01:15:14,769 --> 01:15:20,619
that Mali rocket isn't liable if someone

1776
01:15:18,038 --> 01:15:22,988
like basically ships a virus as part of

1777
01:15:20,618 --> 01:15:25,538
their port to some other language and we

1778
01:15:22,988 --> 01:15:28,299
include that with our zip file I don't

1779
01:15:25,538 --> 01:15:29,590
know what happens there right and I

1780
01:15:28,300 --> 01:15:31,029
haven't been able to find anything

1781
01:15:29,590 --> 01:15:34,059
definitive that says how we deal with

1782
01:15:31,029 --> 01:15:35,738
that so I've been considering other

1783
01:15:34,059 --> 01:15:36,909
options for how to do the licensing

1784
01:15:35,738 --> 01:15:39,038
which is basically saying maybe

1785
01:15:36,908 --> 01:15:41,978
something like you have to stay a

1786
01:15:39,038 --> 01:15:43,300
hundred days behind the mainstream but

1787
01:15:41,979 --> 01:15:45,190
other than that you're allowed to post

1788
01:15:43,300 --> 01:15:47,199
it or something I was trying to figure

1789
01:15:45,189 --> 01:15:49,118
out things where we could basically just

1790
01:15:47,198 --> 01:15:51,609
allow people to post it and just have

1791
01:15:49,118 --> 01:15:54,248
some restriction on there so that we

1792
01:15:51,609 --> 01:15:58,569
still get some of the exclusivity out of

1793
01:15:54,248 --> 01:16:00,609
it in you know just short-term I I don't

1794
01:15:58,569 --> 01:16:03,149
know it's a very tough problem because

1795
01:16:00,609 --> 01:16:03,149
lawyers

1796
01:16:10,469 --> 01:16:13,829
would be possible for you to boost the

1797
01:16:12,149 --> 01:16:15,149
sound of your voice on stream I've

1798
01:16:13,829 --> 01:16:16,920
always found that it is barely high

1799
01:16:15,149 --> 01:16:19,019
enough even with all mixers at maximum

1800
01:16:16,920 --> 01:16:20,390
volume possible so I think you've got

1801
01:16:19,020 --> 01:16:23,810
something weird going on because

1802
01:16:20,390 --> 01:16:27,000
actually it's at the maximum volume

1803
01:16:23,810 --> 01:16:28,980
right like if you actually look at

1804
01:16:27,000 --> 01:16:31,050
what's happening here it is actually at

1805
01:16:28,979 --> 01:16:32,309
the maximum volume it doesn't really go

1806
01:16:31,050 --> 01:16:36,770
any higher than that without just

1807
01:16:32,310 --> 01:16:36,770
straight-up clipping if that makes sense

1808
01:16:38,719 --> 01:16:46,698
alright I think that's it for today so

1809
01:16:43,319 --> 01:16:48,569
I'm going to go ahead and wrap things up

1810
01:16:46,698 --> 01:16:52,609
close this down

1811
01:16:48,569 --> 01:17:00,359
exit make sure we've saved our

1812
01:16:52,609 --> 01:17:01,559
blackboard alright thank you everyone

1813
01:17:00,359 --> 01:17:02,969
for joining me for another episode of

1814
01:17:01,560 --> 01:17:05,190
hand made here oh it's been a pleasure

1815
01:17:02,969 --> 01:17:06,448
coding with you as always it was a good

1816
01:17:05,189 --> 01:17:09,299
blackboard session today we covered

1817
01:17:06,448 --> 01:17:10,619
threading and we created our threads but

1818
01:17:09,300 --> 01:17:12,029
we haven't actually done anything with

1819
01:17:10,619 --> 01:17:13,500
them that will be tomorrow's job to

1820
01:17:12,029 --> 01:17:14,909
actually start pointing our threads for

1821
01:17:13,500 --> 01:17:16,399
something useful and in order to do that

1822
01:17:14,909 --> 01:17:18,448
we will have start talking about

1823
01:17:16,399 --> 01:17:20,819
synchronization which is the next big

1824
01:17:18,448 --> 01:17:22,289
topic in multi-threading so we'll have

1825
01:17:20,819 --> 01:17:23,189
to do quite a bit of Blackboard work

1826
01:17:22,289 --> 01:17:24,600
this week because there's a whole bunch

1827
01:17:23,189 --> 01:17:26,519
of topics in need to be introduced but

1828
01:17:24,600 --> 01:17:28,320
slowly but surely we will get to the

1829
01:17:26,520 --> 01:17:30,239
point where we are running

1830
01:17:28,319 --> 01:17:33,420
multi-threaded in the renderer and that

1831
01:17:30,238 --> 01:17:36,029
will be a good thing so thank you

1832
01:17:33,420 --> 01:17:38,010
everyone for joining me if you would

1833
01:17:36,029 --> 01:17:39,809
like to follow along at home with a

1834
01:17:38,010 --> 01:17:41,820
source code you can do so by going to

1835
01:17:39,810 --> 01:17:43,110
handmade hero org and pre-ordering the

1836
01:17:41,819 --> 01:17:44,488
game it comes with all the source code

1837
01:17:43,109 --> 01:17:46,380
you can download it every night after

1838
01:17:44,488 --> 01:17:47,669
I'm done you'll get a link that you can

1839
01:17:46,380 --> 01:17:49,710
just keep using to reap download the

1840
01:17:47,670 --> 01:17:51,149
source code anytime you want

1841
01:17:49,710 --> 01:17:52,590
we also have a forum site you can go to

1842
01:17:51,149 --> 01:17:56,039
ask questions or to get coding resources

1843
01:17:52,590 --> 01:17:57,600
like ports to Mac or Linux or an

1844
01:17:56,039 --> 01:17:59,010
eight-episode guide that the community

1845
01:17:57,600 --> 01:18:01,289
maintains stuff like that it's really

1846
01:17:59,010 --> 01:18:03,090
handy we have a patreon page where you

1847
01:18:01,289 --> 01:18:05,430
can support the video series if you'd

1848
01:18:03,090 --> 01:18:06,510
like which is very appreciated and we

1849
01:18:05,430 --> 01:18:08,670
have a tweet bot that tweets the

1850
01:18:06,510 --> 01:18:11,789
schedule at you we also thanks to some

1851
01:18:08,670 --> 01:18:15,989
donations by folks who helped write the

1852
01:18:11,789 --> 01:18:17,969
JavaScript and in fact I do not know how

1853
01:18:15,988 --> 01:18:21,269
to pronounce either of their names so I

1854
01:18:17,969 --> 01:18:24,579
will simply point you at the thing that

1855
01:18:21,270 --> 01:18:28,480
says their names I'm going to say

1856
01:18:24,579 --> 01:18:32,019
like Remy rock kitsch let's see

1857
01:18:28,479 --> 01:18:34,000
and maybe Jakob Munk Anderson I don't

1858
01:18:32,020 --> 01:18:37,120
know how to pronounce these names they

1859
01:18:34,000 --> 01:18:39,640
are names whose pronunciations I

1860
01:18:37,119 --> 01:18:42,849
probably butchered but thanks to them we

1861
01:18:39,640 --> 01:18:46,300
also have the live button now actually

1862
01:18:42,850 --> 01:18:47,980
does a reasonable job at telling you

1863
01:18:46,300 --> 01:18:49,539
when it's actually going to be live so

1864
01:18:47,979 --> 01:18:51,369
you can also just check this guy and

1865
01:18:49,539 --> 01:18:52,869
I'll do it but the tweet bot tells you

1866
01:18:51,369 --> 01:18:54,099
the schedule in advance so if you want

1867
01:18:52,869 --> 01:18:56,109
to know kind of what the schedules will

1868
01:18:54,100 --> 01:18:57,370
be for the week and to get a reminder in

1869
01:18:56,109 --> 01:18:59,259
the morning or stuff like that that's

1870
01:18:57,369 --> 01:19:01,510
the place to go for that it's pretty

1871
01:18:59,260 --> 01:19:03,039
handy so thanks everyone I hope to see

1872
01:19:01,510 --> 01:19:04,750
you back here tomorrow tomorrow will be

1873
01:19:03,039 --> 01:19:06,909
regularly scheduled timeslot 5 p.m.

1874
01:19:04,750 --> 01:19:08,680
Pacific Daylight Time hope to see you

1875
01:19:06,909 --> 01:19:10,210
all here for that we will go over how to

1876
01:19:08,680 --> 01:19:12,940
get those threads actually doing some

1877
01:19:10,210 --> 01:19:15,039
work for us which i think will be good

1878
01:19:12,939 --> 01:19:18,129
so see you there for that until then

1879
01:19:15,039 --> 01:19:19,539
have fun coding and I will see you next

1880
01:19:18,130 --> 01:19:21,750
time I'm going to stay on the stream

1881
01:19:19,539 --> 01:19:23,560
just for a few seconds because

1882
01:19:21,750 --> 01:19:24,880
apparently there's some story I'm

1883
01:19:23,560 --> 01:19:28,320
supposed to check out so we'll take a

1884
01:19:24,880 --> 01:19:28,319
look at that ok thanks everyone

