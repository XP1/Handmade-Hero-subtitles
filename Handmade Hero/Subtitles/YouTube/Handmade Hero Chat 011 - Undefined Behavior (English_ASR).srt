1
00:00:00,000 --> 00:00:07,108
to start recording hello everyone and

2
00:00:04,980 --> 00:00:10,380
welcome to handmade Hero the show we

3
00:00:07,108 --> 00:00:11,759
could a complete game live on stream we

4
00:00:10,380 --> 00:00:13,320
were talking in the pre-chat and I was

5
00:00:11,759 --> 00:00:15,440
just not I wasn't feeling like it was a

6
00:00:13,320 --> 00:00:18,448
good night for it I was feeling chatty

7
00:00:15,439 --> 00:00:20,160
so I asked if people wanted to do a chat

8
00:00:18,449 --> 00:00:22,800
because sometimes we do a chat once in a

9
00:00:20,160 --> 00:00:27,629
while instead of programming and they

10
00:00:22,800 --> 00:00:29,880
said yes and so I feel like this is

11
00:00:27,629 --> 00:00:32,519
gonna be a chat stream and we'll file it

12
00:00:29,879 --> 00:00:34,738
under handmade chat and we'll just see

13
00:00:32,520 --> 00:00:35,790
what people want to chat about we'll

14
00:00:34,738 --> 00:00:42,949
just see what they want to chat about

15
00:00:35,789 --> 00:00:46,399
and we can open up our Milton as well

16
00:00:42,950 --> 00:00:46,399
let's see here

17
00:00:46,820 --> 00:00:52,500
uh-oh did I kill it we're using a by the

18
00:00:50,670 --> 00:00:56,609
way we're using an experimental version

19
00:00:52,500 --> 00:00:58,320
of Milton here it's got a brand new GPU

20
00:00:56,609 --> 00:01:01,079
renderer which technically is not

21
00:00:58,320 --> 00:01:03,869
supposed to work on AMD yet it's only on

22
00:01:01,079 --> 00:01:06,659
nvidia and we are running it on an AMD

23
00:01:03,869 --> 00:01:10,798
card because i want to scare sergio i

24
00:01:06,659 --> 00:01:13,170
guess so yeah expect expect built-in

25
00:01:10,799 --> 00:01:18,060
problems we're not really in a we're not

26
00:01:13,170 --> 00:01:19,590
in the correct we're not where we should

27
00:01:18,060 --> 00:01:23,070
be yeah it's looking like it's having

28
00:01:19,590 --> 00:01:26,880
some trouble let's put it that way but

29
00:01:23,069 --> 00:01:29,250
I'm not a quite sure why it's sort of

30
00:01:26,879 --> 00:01:30,899
working it's you know it's in there I

31
00:01:29,250 --> 00:01:32,578
don't know what I really should do at

32
00:01:30,900 --> 00:01:35,250
some point is switch this machine over

33
00:01:32,578 --> 00:01:38,129
to an Nvidia card probably or at least a

34
00:01:35,250 --> 00:01:40,739
more modern AMD card all right so maybe

35
00:01:38,129 --> 00:01:45,539
we won't do that maybe that's not what

36
00:01:40,739 --> 00:01:47,789
we'll do I take it all back I don't know

37
00:01:45,540 --> 00:01:50,850
if we can launch the old one I may have

38
00:01:47,790 --> 00:01:52,469
to download a copy of the old one we'll

39
00:01:50,849 --> 00:01:54,859
just see if we can load the old one up

40
00:01:52,469 --> 00:01:54,859
here oops

41
00:01:55,680 --> 00:02:04,010
there we go so yeah we'll have Milton up

42
00:02:00,629 --> 00:02:11,069
so I can draw off I want to on the chat

43
00:02:04,010 --> 00:02:23,670
let's see here I'll scroll through some

44
00:02:11,069 --> 00:02:25,379
of the cues let's see so I guess what I

45
00:02:23,669 --> 00:02:27,929
should say is Alan since you

46
00:02:25,379 --> 00:02:29,639
definitively voted YES on the chat did

47
00:02:27,930 --> 00:02:30,180
you have a topic you wanted me to chat

48
00:02:29,639 --> 00:02:33,089
about

49
00:02:30,180 --> 00:02:38,400
I will ask first and then if you don't I

50
00:02:33,090 --> 00:02:42,330
will go through the questions on the on

51
00:02:38,400 --> 00:02:49,640
the stream and select some that I think

52
00:02:42,330 --> 00:02:49,640
might be good and we'll go from there

53
00:03:29,069 --> 00:03:36,609
all right so let's see

54
00:03:33,550 --> 00:03:41,760
oh and Alan asked is Milton successfully

55
00:03:36,610 --> 00:03:41,760
maintaining your data between versions I

56
00:03:44,370 --> 00:03:53,680
guess I don't know but it looks like it

57
00:03:47,289 --> 00:03:56,079
is I mean I I definitely wrote that on

58
00:03:53,680 --> 00:03:59,920
the new on the new one and now I hold it

59
00:03:56,080 --> 00:04:01,420
it loaded it in the old one but I

60
00:03:59,919 --> 00:04:03,780
haven't really tested it thoroughly if

61
00:04:01,419 --> 00:04:03,780
that makes sense

62
00:04:05,729 --> 00:04:10,479
mr. fourth dimension oh shoot that first

63
00:04:08,650 --> 00:04:11,530
question wasn't my questions I think a

64
00:04:10,479 --> 00:04:14,109
lot of people are interested in this you

65
00:04:11,530 --> 00:04:16,230
be business and I am too so let's start

66
00:04:14,110 --> 00:04:26,020
there and see what comes up after ok

67
00:04:16,230 --> 00:04:28,150
well so so the ubii thing is I think I

68
00:04:26,019 --> 00:04:31,269
guess I I don't really know when this

69
00:04:28,149 --> 00:04:35,289
term got coined the you be part of it

70
00:04:31,269 --> 00:04:39,930
but obviously in C and C++ there's the

71
00:04:35,290 --> 00:04:39,930
concept of undefined behavior right

72
00:04:40,750 --> 00:04:44,168
and you V just stands for undefined

73
00:04:42,790 --> 00:04:45,939
behavior for those of you who don't know

74
00:04:44,168 --> 00:04:49,930
what that is

75
00:04:45,939 --> 00:04:52,660
but what undefined behavior means in the

76
00:04:49,930 --> 00:04:55,540
C and C both suspect is just that if you

77
00:04:52,660 --> 00:04:57,550
put in a line of code that does

78
00:04:55,540 --> 00:04:59,319
something that is classified to the

79
00:04:57,550 --> 00:05:01,740
specification as undefined behavior

80
00:04:59,319 --> 00:05:04,689
right

81
00:05:01,740 --> 00:05:08,079
like say dereference a null pointer or

82
00:05:04,689 --> 00:05:10,990
something like this then the idea is

83
00:05:08,079 --> 00:05:13,689
that the specification does not say what

84
00:05:10,990 --> 00:05:15,490
has to happen at that point it instead

85
00:05:13,689 --> 00:05:17,459
simply says that it's undefined behavior

86
00:05:15,490 --> 00:05:19,240
which means that if you write it

87
00:05:17,459 --> 00:05:23,680
anything could happen

88
00:05:19,240 --> 00:05:26,590
right and just to give you an example of

89
00:05:23,680 --> 00:05:30,100
this from the talk in fact even that

90
00:05:26,589 --> 00:05:32,500
touched on this if you dereference a

91
00:05:30,100 --> 00:05:34,570
null pointer on some machines it will

92
00:05:32,500 --> 00:05:35,889
fault because it has virtual memory and

93
00:05:34,569 --> 00:05:37,930
memory protection and dereference

94
00:05:35,889 --> 00:05:39,430
candela pointer will cause an exception

95
00:05:37,930 --> 00:05:40,990
like the kind that we see on handmade

96
00:05:39,430 --> 00:05:42,100
hero if we write to a null pointer

97
00:05:40,990 --> 00:05:44,620
accidentally

98
00:05:42,100 --> 00:05:46,890
that will happen that is not in the C or

99
00:05:44,620 --> 00:05:49,449
C++ specification right the C or C++

100
00:05:46,889 --> 00:05:51,939
specifications do not say that

101
00:05:49,449 --> 00:05:54,610
dereferencing a null pointer causes a

102
00:05:51,939 --> 00:05:55,689
memory exception or a seg fault the

103
00:05:54,610 --> 00:05:57,930
reason for that is there are other

104
00:05:55,689 --> 00:06:00,189
platforms that do support C and C++

105
00:05:57,930 --> 00:06:02,530
compilation which do not have memory

106
00:06:00,189 --> 00:06:05,350
protection and so on those platforms the

107
00:06:02,529 --> 00:06:07,569
reference genome pointer just works you

108
00:06:05,350 --> 00:06:09,610
can read and write from the zero address

109
00:06:07,569 --> 00:06:15,040
all day long it's a valid memory

110
00:06:09,610 --> 00:06:16,740
location right and so what undefined

111
00:06:15,040 --> 00:06:21,160
behavior essentially is in the C++

112
00:06:16,740 --> 00:06:23,560
specification is just a way for the spec

113
00:06:21,160 --> 00:06:26,110
to say we don't know what's gonna happen

114
00:06:23,560 --> 00:06:29,110
when you do this because the results can

115
00:06:26,110 --> 00:06:31,300
vary per platform and we don't find that

116
00:06:29,110 --> 00:06:34,210
it's a good idea to be overly

117
00:06:31,300 --> 00:06:36,939
prescriptive here because if we were we

118
00:06:34,209 --> 00:06:39,310
may rule out c's ability to run on

119
00:06:36,939 --> 00:06:41,199
certain platforms or we may make it so

120
00:06:39,310 --> 00:06:46,569
that the compiler the code the compiler

121
00:06:41,199 --> 00:06:48,879
has to generate in order to in order to

122
00:06:46,569 --> 00:06:51,459
fulfill the behavior definition

123
00:06:48,879 --> 00:06:53,589
specified in the spec is prohibitively

124
00:06:51,459 --> 00:06:55,689
expensive it's too slow right because

125
00:06:53,589 --> 00:06:57,399
you could imagine in that example I gave

126
00:06:55,689 --> 00:06:59,230
with the null pointer you could imagine

127
00:06:57,399 --> 00:07:01,859
if you did want that to always be the

128
00:06:59,230 --> 00:07:04,450
behavior that a fault would happen right

129
00:07:01,860 --> 00:07:06,460
you could still implement that on all

130
00:07:04,449 --> 00:07:09,579
platforms but what you would have to do

131
00:07:06,459 --> 00:07:11,859
is every where in C before the first

132
00:07:09,579 --> 00:07:14,409
time that any particular pointer state

133
00:07:11,860 --> 00:07:17,170
is written to or read from you would

134
00:07:14,410 --> 00:07:19,450
have to manually insert an if check to

135
00:07:17,170 --> 00:07:21,580
see if it was zero first and if it was

136
00:07:19,449 --> 00:07:25,349
you would then have to manually call an

137
00:07:21,579 --> 00:07:29,039
exception raising routine right

138
00:07:25,350 --> 00:07:29,040
hopefully that makes some sense

139
00:07:29,519 --> 00:07:33,339
so obviously the spec writers don't want

140
00:07:32,139 --> 00:07:35,310
to say that they don't want to say

141
00:07:33,339 --> 00:07:37,539
writing to a null pointer is a seg fault

142
00:07:35,310 --> 00:07:43,480
because now all of a sudden these other

143
00:07:37,540 --> 00:07:47,470
platforms it creates a prohibitive cost

144
00:07:43,480 --> 00:07:50,550
if you will for for C to run on those

145
00:07:47,470 --> 00:07:53,190
platforms okay

146
00:07:50,550 --> 00:07:55,918
so that's what undefined behavior sort

147
00:07:53,189 --> 00:07:57,478
of initially was in terms of like how I

148
00:07:55,918 --> 00:08:00,389
would have described it to you before

149
00:07:57,478 --> 00:08:03,870
sort of the nonsense of the past 10 20

150
00:08:00,389 --> 00:08:06,240
years right now what is started

151
00:08:03,870 --> 00:08:07,889
happening unfortunately is as compiler

152
00:08:06,240 --> 00:08:10,560
vendors have been starting to get more

153
00:08:07,889 --> 00:08:12,900
aggressive with optimizing compilers and

154
00:08:10,560 --> 00:08:14,098
that's not a bad thing right we want

155
00:08:12,899 --> 00:08:15,299
them to be aggressive with optimizing

156
00:08:14,098 --> 00:08:17,490
compilers because we want them to

157
00:08:15,300 --> 00:08:18,960
produce code that runs quickly so we

158
00:08:17,490 --> 00:08:20,250
want to we want to be spending time

159
00:08:18,959 --> 00:08:23,189
trying to think of new ways optimize

160
00:08:20,250 --> 00:08:24,990
code certainly what they have been doing

161
00:08:23,189 --> 00:08:28,469
is they've been introducing

162
00:08:24,990 --> 00:08:30,900
optimizations which use the fact that

163
00:08:28,470 --> 00:08:34,379
undefined behaviors are specified in the

164
00:08:30,899 --> 00:08:36,689
spec as being literally undefined to

165
00:08:34,379 --> 00:08:40,379
essentially optimize code to the point

166
00:08:36,690 --> 00:08:46,459
of being what I would call intuitively

167
00:08:40,379 --> 00:08:48,899
incorrect right but technically correct

168
00:08:46,458 --> 00:08:50,849
now I'll just write those two words down

169
00:08:48,899 --> 00:08:52,769
because I'm making them up right they

170
00:08:50,850 --> 00:08:55,560
don't have real words these things I'm

171
00:08:52,769 --> 00:08:57,600
just saying how I would view them so

172
00:08:55,559 --> 00:09:00,059
there's what I would say is there's a

173
00:08:57,600 --> 00:09:03,028
concept of what's intuitively correct in

174
00:09:00,059 --> 00:09:06,649
a piece of code right and then there's a

175
00:09:03,028 --> 00:09:06,649
concept of what's technically correct

176
00:09:08,450 --> 00:09:17,209
right and just to give you an example of

177
00:09:14,278 --> 00:09:21,958
what I mean there right I might expect

178
00:09:17,208 --> 00:09:27,028
in my code for example that if I define

179
00:09:21,958 --> 00:09:30,239
an int right let's say I have an int and

180
00:09:27,028 --> 00:09:32,250
I and the int is currently set to like

181
00:09:30,240 --> 00:09:33,959
two billion or whatever right so the int

182
00:09:32,250 --> 00:09:35,850
is at 2 billion very close to the

183
00:09:33,958 --> 00:09:37,819
wrapping range of an integer right

184
00:09:35,850 --> 00:09:40,709
because you know we've got four billion

185
00:09:37,820 --> 00:09:42,690
values that a 32-bit number can take on

186
00:09:40,708 --> 00:09:45,599
and let's say this is a 32-bit integer

187
00:09:42,690 --> 00:09:47,190
as it would be by default on say you

188
00:09:45,600 --> 00:09:50,879
know the platform's we are currently

189
00:09:47,190 --> 00:09:53,250
programming on if I were to start at 0

190
00:09:50,879 --> 00:09:55,049
and go up to 2 billion well when I get

191
00:09:53,250 --> 00:09:56,820
to like 2 billion in change I'm gonna

192
00:09:55,049 --> 00:10:01,708
wrap around to negative 2 billion and

193
00:09:56,820 --> 00:10:04,470
come back through right on the CPU okay

194
00:10:01,708 --> 00:10:08,639
so that's what's gonna happen on the CPU

195
00:10:04,470 --> 00:10:10,620
if I were to issue an ad however my

196
00:10:08,639 --> 00:10:14,309
understanding and I am NOT a spec person

197
00:10:10,620 --> 00:10:16,560
because I you know I hate the C++ and C

198
00:10:14,309 --> 00:10:18,839
specs with a passion because I never

199
00:10:16,559 --> 00:10:21,149
seem to agree with how they decide to do

200
00:10:18,840 --> 00:10:23,370
things so I don't spend a lot of time

201
00:10:21,149 --> 00:10:27,029
reading them but my understanding is

202
00:10:23,370 --> 00:10:30,419
that an integer when it overflows is not

203
00:10:27,029 --> 00:10:33,509
specified so basically it is undefined

204
00:10:30,419 --> 00:10:35,819
behavior what happens if you took 2

205
00:10:33,509 --> 00:10:38,759
billion as an integer and added another

206
00:10:35,820 --> 00:10:41,040
2 billion to it right now it's

207
00:10:38,759 --> 00:10:43,409
completely rigorously defined what will

208
00:10:41,039 --> 00:10:47,399
happen if you do this with at x64

209
00:10:43,409 --> 00:10:49,379
Edition right if you do a 32-bit ad and

210
00:10:47,399 --> 00:10:50,939
another if you do a 32-bit ad of a

211
00:10:49,379 --> 00:10:52,620
32-bit register and a third another

212
00:10:50,940 --> 00:10:54,840
32-bit register both containing 2

213
00:10:52,620 --> 00:10:56,340
billion it will wrap back around right

214
00:10:54,840 --> 00:11:00,810
we know what's going to happen there

215
00:10:56,340 --> 00:11:05,759
right but as far as the spec is

216
00:11:00,809 --> 00:11:10,139
concerned the compiler is under no is

217
00:11:05,759 --> 00:11:14,189
under no obligation to do that right it

218
00:11:10,139 --> 00:11:16,769
does not have to actually obey that rule

219
00:11:14,190 --> 00:11:19,350
because it is technically undefined what

220
00:11:16,769 --> 00:11:21,539
happens when an integer wraps around if

221
00:11:19,350 --> 00:11:23,940
you or I should say wrapped around if an

222
00:11:21,539 --> 00:11:26,579
integer overflows its value so if an

223
00:11:23,940 --> 00:11:27,930
integer can only hold between negative 2

224
00:11:26,580 --> 00:11:30,720
billion and positive 2 billion and you

225
00:11:27,929 --> 00:11:34,829
go over positive 2 billion the compiler

226
00:11:30,720 --> 00:11:38,509
does not have to make it wrap around all

227
00:11:34,830 --> 00:11:43,650
right now the technically correct thing

228
00:11:38,509 --> 00:11:45,059
here right is anything in that case the

229
00:11:43,649 --> 00:11:47,429
intuitively correct thing would be for

230
00:11:45,059 --> 00:11:49,619
it to wrap around right that's what I

231
00:11:47,429 --> 00:11:51,689
expect that's what the program expects

232
00:11:49,620 --> 00:11:53,669
to happen why because I understand the

233
00:11:51,690 --> 00:11:55,500
CPU I know what the CPU does if you add

234
00:11:53,669 --> 00:11:57,240
two numbers I suspect that if I have 2

235
00:11:55,500 --> 00:11:59,100
billion plus 2 billion that it will wrap

236
00:11:57,240 --> 00:12:00,509
around like the CPU would normally do

237
00:11:59,100 --> 00:12:01,740
because in my mind what's going to

238
00:12:00,509 --> 00:12:06,689
happen as compares going to turn that

239
00:12:01,740 --> 00:12:08,519
into an ADD however the technically

240
00:12:06,690 --> 00:12:10,890
correct thing to have happen as per the

241
00:12:08,519 --> 00:12:12,449
spec is anything the compiler wants to

242
00:12:10,889 --> 00:12:16,939
have happen right because it is

243
00:12:12,450 --> 00:12:16,940
undefined behavior now

244
00:12:17,549 --> 00:12:21,508
start to get into the reason why this

245
00:12:19,769 --> 00:12:23,759
was coming up in the Internet

246
00:12:21,509 --> 00:12:26,369
Chandler careth the guy at Google who

247
00:12:23,759 --> 00:12:28,409
does work on the optimizer for LLVM I

248
00:12:26,369 --> 00:12:29,639
don't know if he leads the optimization

249
00:12:28,409 --> 00:12:34,019
team there something like this I think

250
00:12:29,639 --> 00:12:37,230
is his position he's he's one of the

251
00:12:34,019 --> 00:12:39,028
main guys let's put it that way he gave

252
00:12:37,230 --> 00:12:40,709
a talk that touches on this and I'll

253
00:12:39,028 --> 00:12:42,509
explain why he was giving that talk in a

254
00:12:40,708 --> 00:12:47,698
second so to give you a more background

255
00:12:42,509 --> 00:12:49,470
on it but just to sort of talk about

256
00:12:47,698 --> 00:12:51,208
something that he said in that talk it's

257
00:12:49,470 --> 00:12:53,129
important to understand as well and I

258
00:12:51,208 --> 00:12:56,998
agree with him on this point certainly

259
00:12:53,129 --> 00:12:58,800
that anything here it's not like if you

260
00:12:56,999 --> 00:13:00,778
if you don't really understand this

261
00:12:58,799 --> 00:13:02,909
issue or haven't really seen it before a

262
00:13:00,778 --> 00:13:04,860
lot of times people may joke about it or

263
00:13:02,909 --> 00:13:06,088
whatever and say that the anything like

264
00:13:04,860 --> 00:13:07,619
literally means anything like you could

265
00:13:06,089 --> 00:13:10,199
format your hard drive or whatever and

266
00:13:07,619 --> 00:13:12,209
yes that is technically true because it

267
00:13:10,198 --> 00:13:13,948
is undefined behavior so technically the

268
00:13:12,208 --> 00:13:15,989
compiler could literally do anything if

269
00:13:13,948 --> 00:13:18,149
it wanted to but obviously that's never

270
00:13:15,990 --> 00:13:19,860
going to be true right there's never

271
00:13:18,149 --> 00:13:21,749
going to be unless the compiler vendors

272
00:13:19,860 --> 00:13:23,909
were particularly malicious they're

273
00:13:21,749 --> 00:13:26,159
never going to do anything where they

274
00:13:23,909 --> 00:13:28,528
intentionally introduced a bug into your

275
00:13:26,159 --> 00:13:30,208
program for no reason at all right

276
00:13:28,528 --> 00:13:31,528
they're not like out to get you or

277
00:13:30,208 --> 00:13:34,678
something like this although sometimes

278
00:13:31,528 --> 00:13:36,178
it may seem that way so what does it

279
00:13:34,678 --> 00:13:38,369
mean to say that anything could happen

280
00:13:36,178 --> 00:13:40,470
why would something else happen right

281
00:13:38,369 --> 00:13:42,569
like why would something other than the

282
00:13:40,470 --> 00:13:45,569
intuitively correct thing happen the

283
00:13:42,568 --> 00:13:47,428
reason is because once optimizations are

284
00:13:45,568 --> 00:13:49,678
considered there are plenty of

285
00:13:47,428 --> 00:13:51,568
opportunities for the compiler to do

286
00:13:49,678 --> 00:13:52,889
something more efficient than what it

287
00:13:51,568 --> 00:13:56,490
could have done if it did the

288
00:13:52,889 --> 00:13:58,980
intuitively correct thing for example in

289
00:13:56,490 --> 00:14:01,198
this case where I added 2 billion to two

290
00:13:58,980 --> 00:14:04,470
billion it assumes that I'm using a

291
00:14:01,198 --> 00:14:06,659
32-bit ad right because if I had two

292
00:14:04,470 --> 00:14:08,879
integers and I do a different kind of ad

293
00:14:06,659 --> 00:14:11,568
let's say for example I'm on a processor

294
00:14:08,879 --> 00:14:15,808
architecture where a 64-bit ad is

295
00:14:11,568 --> 00:14:18,178
inexpensive but a 32-bit ad is not I'm

296
00:14:15,808 --> 00:14:21,269
sorry a 64-bit ad is inexpensive and a

297
00:14:18,178 --> 00:14:23,039
32-bit ad is expensive so doing a 64-bit

298
00:14:21,269 --> 00:14:24,869
ad is much cheaper because it doesn't

299
00:14:23,039 --> 00:14:26,219
32-bit it's like an afterthought with

300
00:14:24,869 --> 00:14:30,899
this processor it's used to handling

301
00:14:26,220 --> 00:14:33,389
64-bit native right well in that case

302
00:14:30,899 --> 00:14:35,490
if I want to do computations with this

303
00:14:33,389 --> 00:14:37,470
thing I add two billion to two billion

304
00:14:35,490 --> 00:14:39,389
the compiler knows that if it calls the

305
00:14:37,470 --> 00:14:43,170
32-bit ad it's going to be particularly

306
00:14:39,389 --> 00:14:44,789
slow right so it wants to do the 64-bit

307
00:14:43,169 --> 00:14:47,250
ad because the 64 bit adder is much

308
00:14:44,789 --> 00:14:48,870
faster but when it calls a sixty

309
00:14:47,250 --> 00:14:51,269
four-bit adder it's going to get four

310
00:14:48,870 --> 00:14:54,299
billion right which is not the right

311
00:14:51,269 --> 00:14:56,730
answer in this case and it needs to wrap

312
00:14:54,299 --> 00:14:59,099
the value around right it needs to

313
00:14:56,730 --> 00:15:01,649
produce the wrap or something right

314
00:14:59,100 --> 00:15:04,259
now if it's gonna do a subsequent

315
00:15:01,649 --> 00:15:05,909
arithmetic operation on this thing where

316
00:15:04,259 --> 00:15:08,009
something else is going to happen to it

317
00:15:05,909 --> 00:15:10,799
where it matters whether it has wrapped

318
00:15:08,009 --> 00:15:12,419
around or not or whether that top piece

319
00:15:10,799 --> 00:15:15,000
exists at all right

320
00:15:12,419 --> 00:15:17,879
whether that additional greater than a

321
00:15:15,000 --> 00:15:20,370
signed integer could be part exists it's

322
00:15:17,879 --> 00:15:23,338
going to have to truncate the value here

323
00:15:20,370 --> 00:15:25,289
manually right it's gonna have to like

324
00:15:23,339 --> 00:15:26,900
and out the top part or do something you

325
00:15:25,289 --> 00:15:30,329
know it's gonna have to do some work

326
00:15:26,899 --> 00:15:32,759
additional work and so since this is

327
00:15:30,330 --> 00:15:34,830
undefined behavior in the spec the

328
00:15:32,759 --> 00:15:36,419
compiler is free to do the technically

329
00:15:34,830 --> 00:15:38,310
correct thing which may give a

330
00:15:36,419 --> 00:15:39,809
completely unintuitive result because

331
00:15:38,309 --> 00:15:41,429
the programmer was expecting it to wrap

332
00:15:39,809 --> 00:15:42,869
since he knows there's a 32-bit value

333
00:15:41,429 --> 00:15:47,429
and he thinks three to the values wrap

334
00:15:42,870 --> 00:15:49,620
right but lo and behold it does not wrap

335
00:15:47,429 --> 00:15:52,079
and it gives some very different result

336
00:15:49,620 --> 00:15:56,310
because the processor actually did it in

337
00:15:52,080 --> 00:15:59,430
64-bit right now this is not even

338
00:15:56,309 --> 00:16:01,799
hypothetical even back if we take a look

339
00:15:59,429 --> 00:16:03,299
at something that was before any of this

340
00:16:01,799 --> 00:16:07,278
sort of stuff started happening if you

341
00:16:03,299 --> 00:16:11,939
just take the example of the x87 FPU

342
00:16:07,278 --> 00:16:14,669
right before we had x64 architecture we

343
00:16:11,940 --> 00:16:16,470
had the x86 architecture and on the x86

344
00:16:14,669 --> 00:16:17,939
architecture there was a floating-point

345
00:16:16,470 --> 00:16:20,519
unit called the x87

346
00:16:17,940 --> 00:16:22,020
right and of course they were on one

347
00:16:20,519 --> 00:16:23,189
chip after a while but I think

348
00:16:22,019 --> 00:16:26,610
originally it might have been a

349
00:16:23,190 --> 00:16:28,140
coprocessor I'm not sure I was an amiga

350
00:16:26,610 --> 00:16:30,509
person at that point so I don't really

351
00:16:28,139 --> 00:16:34,169
know exactly what happened for them by

352
00:16:30,509 --> 00:16:35,519
the time I got to the PC they were on

353
00:16:34,169 --> 00:16:39,629
one chip I don't know if they're ever

354
00:16:35,519 --> 00:16:41,610
separate right but the x86 architecture

355
00:16:39,629 --> 00:16:43,139
has the notion of a floating-point unit

356
00:16:41,610 --> 00:16:44,600
in it and it had a floating-point unit

357
00:16:43,139 --> 00:16:48,769
which had

358
00:16:44,600 --> 00:16:52,159
high precision it had greater much

359
00:16:48,769 --> 00:16:55,490
greater than 32-bit I Triple E floating

360
00:16:52,159 --> 00:16:58,309
point okay 32-bit I Triple E floating

361
00:16:55,490 --> 00:17:01,789
point is real weak sauce compared to the

362
00:16:58,309 --> 00:17:03,349
x87 FPU the x87 FPU when you did

363
00:17:01,789 --> 00:17:05,209
operations on it unless you did some

364
00:17:03,350 --> 00:17:07,009
special mode things later on in time if

365
00:17:05,209 --> 00:17:09,230
I remember correctly it added the

366
00:17:07,009 --> 00:17:12,529
ability to you know make the precision

367
00:17:09,230 --> 00:17:14,390
less it would do things to 80 bits this

368
00:17:12,529 --> 00:17:15,949
is my recollection forgive me if I'm

369
00:17:14,390 --> 00:17:17,929
getting this wrong it's been a long time

370
00:17:15,949 --> 00:17:20,150
but my recollection is like it did it

371
00:17:17,929 --> 00:17:23,569
had 80 bit floating point numbers that's

372
00:17:20,150 --> 00:17:25,850
what it did and so you can imagine what

373
00:17:23,568 --> 00:17:28,220
would happen if somebody was expecting

374
00:17:25,849 --> 00:17:30,139
to use I Triple E 32-bit floats so in

375
00:17:28,220 --> 00:17:32,120
their seat code they wrote float X or

376
00:17:30,140 --> 00:17:33,409
whatever right and they did some

377
00:17:32,119 --> 00:17:35,689
operations that they thought would be

378
00:17:33,409 --> 00:17:38,059
32-bit and then they compared the

379
00:17:35,690 --> 00:17:41,750
results of those operations to doing it

380
00:17:38,058 --> 00:17:43,788
on an X at 87 CPU and then compared the

381
00:17:41,750 --> 00:17:45,819
results to doing it on some other CPU

382
00:17:43,788 --> 00:17:48,379
that only have 32-bit floating-point and

383
00:17:45,819 --> 00:17:50,058
what they would find is that their

384
00:17:48,380 --> 00:17:52,640
results would be totally different on

385
00:17:50,058 --> 00:17:54,918
the X 87 because there were so many more

386
00:17:52,640 --> 00:17:57,530
bits of precision you might get totally

387
00:17:54,919 --> 00:17:59,179
totally different results drastically

388
00:17:57,529 --> 00:18:01,460
different in the case of things like

389
00:17:59,179 --> 00:18:02,900
catastrophic cancellation or other sorts

390
00:18:01,460 --> 00:18:04,308
of floating-point operations where the

391
00:18:02,900 --> 00:18:07,940
extra bits of research and make a huge

392
00:18:04,308 --> 00:18:10,009
difference right and so again you can

393
00:18:07,940 --> 00:18:12,470
imagine here if you were a compiler

394
00:18:10,009 --> 00:18:14,869
vendor and someone had told you that the

395
00:18:12,470 --> 00:18:16,610
spec says you have to have 32-bit

396
00:18:14,869 --> 00:18:18,019
floating points instead of saying

397
00:18:16,609 --> 00:18:20,089
something like floating points are

398
00:18:18,019 --> 00:18:21,769
whatever they are right however many

399
00:18:20,089 --> 00:18:24,379
bits they are if as long as it's at

400
00:18:21,769 --> 00:18:27,139
least 32 or something you would have to

401
00:18:24,380 --> 00:18:29,990
insert all this extra code to constantly

402
00:18:27,140 --> 00:18:31,909
truncate these values to make sure that

403
00:18:29,990 --> 00:18:33,620
they weren't doing higher precision

404
00:18:31,909 --> 00:18:42,140
calculations than you were expecting

405
00:18:33,619 --> 00:18:43,729
right so that's what what you know how I

406
00:18:42,140 --> 00:18:45,650
would sort of start to frame this

407
00:18:43,730 --> 00:18:46,880
problem in terms of how to start

408
00:18:45,650 --> 00:18:48,860
thinking about the undefined behavior

409
00:18:46,880 --> 00:18:51,799
issue and now I'll start talking about

410
00:18:48,859 --> 00:18:53,928
what kind of came up recently and sort

411
00:18:51,798 --> 00:18:55,069
of has been brewing over time but that's

412
00:18:53,929 --> 00:18:57,019
kind of the way I think about it is

413
00:18:55,069 --> 00:18:58,678
there's an intuitively correct thing and

414
00:18:57,019 --> 00:19:01,529
a technically correct thing

415
00:18:58,679 --> 00:19:02,940
we might want to use the drop the

416
00:19:01,529 --> 00:19:05,609
correct here if you're uncomfortable but

417
00:19:02,940 --> 00:19:07,200
say there's an intuitive thing and then

418
00:19:05,609 --> 00:19:11,428
there's a technically correct thing

419
00:19:07,200 --> 00:19:13,710
right or spec correct let's say if

420
00:19:11,429 --> 00:19:15,659
you're uncomfortable with that just to

421
00:19:13,710 --> 00:19:16,890
use very generic terminology but point

422
00:19:15,659 --> 00:19:17,909
being there's your intuition of what

423
00:19:16,890 --> 00:19:18,960
should happen and then there's what's

424
00:19:17,909 --> 00:19:21,690
actually gonna happen

425
00:19:18,960 --> 00:19:24,058
according to the spec and sometimes the

426
00:19:21,690 --> 00:19:25,830
spec just doesn't guarantee anything so

427
00:19:24,058 --> 00:19:28,440
the compiler can do whatever is

428
00:19:25,829 --> 00:19:31,199
efficient and that may have unintended

429
00:19:28,440 --> 00:19:34,759
consequences because again it's

430
00:19:31,200 --> 00:19:37,710
undefined behavior you can't count on it

431
00:19:34,759 --> 00:19:39,450
alright so recently what's been

432
00:19:37,710 --> 00:19:42,360
happening is we've been getting a lot of

433
00:19:39,450 --> 00:19:45,509
pretty damaging versions of this thing

434
00:19:42,359 --> 00:19:47,099
right so compiler vendors or you know

435
00:19:45,509 --> 00:19:49,169
looking for the spec they're looking for

436
00:19:47,099 --> 00:19:50,908
optimization opportunities they see oh

437
00:19:49,169 --> 00:19:52,320
okay you know I've got this sort of

438
00:19:50,909 --> 00:19:53,610
wraparound thing that's happening here I

439
00:19:52,319 --> 00:19:55,500
don't have to guarantee that wraparound

440
00:19:53,609 --> 00:19:57,538
so hey guess what I can fold these

441
00:19:55,500 --> 00:20:00,269
operations in and make a much more

442
00:19:57,538 --> 00:20:02,158
efficient execution a much more

443
00:20:00,269 --> 00:20:04,379
efficient set of instructions to do this

444
00:20:02,159 --> 00:20:06,210
operation but hey if the programmer was

445
00:20:04,380 --> 00:20:09,480
actually counting on wraparound you

446
00:20:06,210 --> 00:20:12,000
introduced a bug in their code right now

447
00:20:09,480 --> 00:20:14,788
it's not technically a bug as per the

448
00:20:12,000 --> 00:20:16,079
spec because the spec did not guarantee

449
00:20:14,788 --> 00:20:18,569
the programmer they could wrap the

450
00:20:16,079 --> 00:20:21,119
integer right but it is definitely

451
00:20:18,569 --> 00:20:22,710
intuitively a bug because the programmer

452
00:20:21,119 --> 00:20:24,239
was thinking they were using 32-bit

453
00:20:22,710 --> 00:20:26,400
integers and it turns out that they

454
00:20:24,240 --> 00:20:27,929
really kind of aren't because the C

455
00:20:26,400 --> 00:20:36,750
compiler isn't guaranteeing them that

456
00:20:27,929 --> 00:20:38,820
right okay so that is what's been

457
00:20:36,750 --> 00:20:41,669
happening a lot lately and one of the

458
00:20:38,819 --> 00:20:42,960
big sort of the reasons why this is kind

459
00:20:41,669 --> 00:20:45,480
of getting aggravating to a lot of

460
00:20:42,960 --> 00:20:48,419
people is this can introduce a lot of

461
00:20:45,480 --> 00:20:52,140
fairly serious bugs this can introduce

462
00:20:48,419 --> 00:20:54,870
say very bad security bugs because

463
00:20:52,140 --> 00:20:56,970
somebody thinks they wrote code that if

464
00:20:54,869 --> 00:20:59,729
the wrapping works properly we'll never

465
00:20:56,970 --> 00:21:01,440
overflow a buffer but hey guess what the

466
00:20:59,730 --> 00:21:03,630
compiler compiled it so that it can

467
00:21:01,440 --> 00:21:05,850
actually far exceed the buffer when it

468
00:21:03,630 --> 00:21:08,820
does the offset because hey the spec

469
00:21:05,849 --> 00:21:11,908
didn't say that you had to guarantee the

470
00:21:08,819 --> 00:21:13,678
wrap would happen right

471
00:21:11,909 --> 00:21:14,909
so you're starting to see more and more

472
00:21:13,679 --> 00:21:16,859
of these things where the compiler

473
00:21:14,909 --> 00:21:18,659
vendors are technically within their

474
00:21:16,858 --> 00:21:21,958
rights to do a particular optimization

475
00:21:18,659 --> 00:21:25,079
they do it it introduces fairly severe

476
00:21:21,959 --> 00:21:27,479
bugs in some form or another into

477
00:21:25,078 --> 00:21:30,749
well-known software packages those

478
00:21:27,479 --> 00:21:33,179
people get upset obvious reasons and you

479
00:21:30,749 --> 00:21:36,899
get this like he said she said of you

480
00:21:33,179 --> 00:21:38,278
know okay well just why are you doing

481
00:21:36,898 --> 00:21:40,078
that you're breaking this code it's like

482
00:21:38,278 --> 00:21:41,878
well that's the spec that's our jobs

483
00:21:40,078 --> 00:21:43,108
implement the spec you should have

484
00:21:41,878 --> 00:21:44,968
written code that could form to the spec

485
00:21:43,108 --> 00:21:46,678
you know your code is buggy technically

486
00:21:44,969 --> 00:21:48,690
and then they're like my coche not buggy

487
00:21:46,679 --> 00:21:49,919
you guys just don't understand the knee

488
00:21:48,690 --> 00:21:51,298
what you're suppose to be doing here

489
00:21:49,919 --> 00:21:53,249
that why are you even doing this no one

490
00:21:51,298 --> 00:21:54,449
cared about this updated so you can see

491
00:21:53,249 --> 00:21:56,249
like there would be a lot of acrimony

492
00:21:54,449 --> 00:22:01,649
there right you could understand the

493
00:21:56,249 --> 00:22:04,199
acrimony there and to give a personal

494
00:22:01,648 --> 00:22:05,728
example of this from quite a bit further

495
00:22:04,199 --> 00:22:07,769
back in my programming career when I

496
00:22:05,729 --> 00:22:09,359
wasn't even aware of this stuff it's the

497
00:22:07,769 --> 00:22:12,858
first time I really became aware of this

498
00:22:09,358 --> 00:22:15,269
I actually had a bug exactly this way

499
00:22:12,858 --> 00:22:17,638
and I'll tell you what it was because I

500
00:22:15,269 --> 00:22:20,788
remember it in all the versions of

501
00:22:17,638 --> 00:22:22,738
Granny that I shipped there was a tree

502
00:22:20,788 --> 00:22:24,269
that would do some kind of tracking of

503
00:22:22,739 --> 00:22:26,219
pointers and I don't remember exactly

504
00:22:24,269 --> 00:22:27,959
what it did it for but it tracked

505
00:22:26,219 --> 00:22:29,459
basically some addresses of things and

506
00:22:27,959 --> 00:22:31,229
the reason it was doing that is because

507
00:22:29,459 --> 00:22:32,818
the address was just a convenient thing

508
00:22:31,229 --> 00:22:34,288
that I knew would be unique right

509
00:22:32,818 --> 00:22:35,519
because I knew that each of these data

510
00:22:34,288 --> 00:22:36,808
structures existed somewhere in memory

511
00:22:35,519 --> 00:22:38,278
and I know that no two of them could

512
00:22:36,808 --> 00:22:40,288
access the same place in memory because

513
00:22:38,278 --> 00:22:41,608
hey that's how allocation works you

514
00:22:40,288 --> 00:22:45,058
can't store the same stuff in the same

515
00:22:41,608 --> 00:22:47,968
place and so what I would do inside this

516
00:22:45,058 --> 00:22:51,509
tree is I would just say oh well I've

517
00:22:47,969 --> 00:22:54,869
got two pointers you know a pointer to

518
00:22:51,509 --> 00:22:56,818
foo a and a pointer to foo B right and I

519
00:22:54,868 --> 00:22:59,009
just was like out well I just need to

520
00:22:56,818 --> 00:23:01,528
return the sort criteria for these two

521
00:22:59,009 --> 00:23:04,078
things so it's fine just do like you

522
00:23:01,528 --> 00:23:06,419
know I've got an int or something that I

523
00:23:04,078 --> 00:23:12,418
need to return so I'll just do like a

524
00:23:06,419 --> 00:23:14,969
minus B or something right so if a

525
00:23:12,419 --> 00:23:17,549
subtracted for B if it turns out that a

526
00:23:14,969 --> 00:23:19,109
produces a negative result that's what

527
00:23:17,548 --> 00:23:20,699
will happen for my sort criteria if it

528
00:23:19,108 --> 00:23:22,378
turns a pause result that's what if it's

529
00:23:20,699 --> 00:23:24,179
zero then they're equal it's exactly

530
00:23:22,378 --> 00:23:25,679
what I want and I don't care about

531
00:23:24,179 --> 00:23:27,210
overflowing or wrapping or

532
00:23:25,680 --> 00:23:28,830
anything here because I just as long as

533
00:23:27,210 --> 00:23:30,750
it always produces the same comparison

534
00:23:28,829 --> 00:23:33,210
between these two things in terms of

535
00:23:30,750 --> 00:23:36,150
positive negative or zero I can use a

536
00:23:33,210 --> 00:23:37,559
standard binary tree algorithm which is

537
00:23:36,150 --> 00:23:41,660
what I was using and it will all just

538
00:23:37,559 --> 00:23:45,419
work right okay

539
00:23:41,660 --> 00:23:49,440
problem is that technically according to

540
00:23:45,420 --> 00:23:53,940
the C++ specification if you have two

541
00:23:49,440 --> 00:23:57,960
non care stars so if these are not 8-bit

542
00:23:53,940 --> 00:24:01,680
pointers to 8-bit values right so let's

543
00:23:57,960 --> 00:24:04,200
say struct foo has you know an int in it

544
00:24:01,680 --> 00:24:09,840
so it's it's for wide or something like

545
00:24:04,200 --> 00:24:12,779
this then pointer arithmetic is only

546
00:24:09,839 --> 00:24:18,149
guaranteed to work if the two things

547
00:24:12,779 --> 00:24:23,420
came from the same allocation right so

548
00:24:18,150 --> 00:24:30,660
in other words if I have foo star array

549
00:24:23,420 --> 00:24:38,039
equals you know Malik yeah I don't know

550
00:24:30,660 --> 00:24:39,870
twelve times size of foo right if I do

551
00:24:38,039 --> 00:24:42,059
an allocation and I say that you know

552
00:24:39,869 --> 00:24:43,859
these things have to these things all

553
00:24:42,059 --> 00:24:46,799
came from here and then I want to say

554
00:24:43,859 --> 00:24:50,069
okay I've got my a is you know array

555
00:24:46,799 --> 00:24:52,859
plus three and my B is array plus seven

556
00:24:50,069 --> 00:24:54,659
then technically this is required to

557
00:24:52,859 --> 00:24:57,719
work in the spec it is not undefined

558
00:24:54,660 --> 00:24:59,790
behavior if I remember correctly it is

559
00:24:57,720 --> 00:25:04,190
technically defined to be the distance

560
00:24:59,789 --> 00:25:08,930
between these two things in the array

561
00:25:04,190 --> 00:25:08,930
however if they came this way

562
00:25:10,670 --> 00:25:17,279
so allocated from two different pools

563
00:25:13,230 --> 00:25:19,039
now they no longer have to have any kind

564
00:25:17,279 --> 00:25:22,079
of this doesn't have to work at all so

565
00:25:19,039 --> 00:25:24,629
for example these could be two totally

566
00:25:22,079 --> 00:25:27,299
different pointers totally different

567
00:25:24,630 --> 00:25:33,380
this is still allowed to evaluate to

568
00:25:27,299 --> 00:25:36,349
zero right now you may say why on earth

569
00:25:33,380 --> 00:25:39,030
would anyone ever want that to be

570
00:25:36,349 --> 00:25:44,009
allowed in a specification

571
00:25:39,029 --> 00:25:46,259
right and I would like you to push that

572
00:25:44,009 --> 00:25:51,089
thought on the stack for a minute

573
00:25:46,259 --> 00:25:53,279
because this I guess this sort of

574
00:25:51,089 --> 00:25:55,859
example will be perfect for me to

575
00:25:53,279 --> 00:25:57,930
illustrate my opinion of this whole

576
00:25:55,859 --> 00:26:00,359
subject matter in a moment when we get

577
00:25:57,930 --> 00:26:03,390
to talking about how I feel about it

578
00:26:00,359 --> 00:26:05,399
right which I don't know you know since

579
00:26:03,390 --> 00:26:07,170
it is my stream presumably some button

580
00:26:05,400 --> 00:26:10,019
asks this question because they want to

581
00:26:07,170 --> 00:26:11,580
know what I think about it so I'll tell

582
00:26:10,019 --> 00:26:14,220
you my opinion not that anyone else

583
00:26:11,579 --> 00:26:17,849
cares what that is certainly not the C++

584
00:26:14,220 --> 00:26:19,620
committee but so hold that thought for a

585
00:26:17,849 --> 00:26:21,719
minute but hopefully that's pretty clear

586
00:26:19,619 --> 00:26:23,699
and then just save your bewilderment of

587
00:26:21,720 --> 00:26:25,079
why that would be for later because

588
00:26:23,700 --> 00:26:26,640
there's a perfectly good explanation of

589
00:26:25,079 --> 00:26:28,199
why it would be and also I think a

590
00:26:26,640 --> 00:26:30,509
perfectly good explanation of why it's

591
00:26:28,200 --> 00:26:33,330
ridiculous so I'll give those two to you

592
00:26:30,509 --> 00:26:37,230
and you can kind of chew on them anyway

593
00:26:33,329 --> 00:26:38,939
so mm-hmm now we get to the the latest

594
00:26:37,230 --> 00:26:41,130
sort of thing about this

595
00:26:38,940 --> 00:26:44,880
Chandler careth the aforementioned

596
00:26:41,130 --> 00:26:46,470
google optimization guy in LLVM gave a

597
00:26:44,880 --> 00:26:49,590
lecture where he was sort of talking

598
00:26:46,470 --> 00:26:51,569
about this because and this I don't know

599
00:26:49,589 --> 00:26:53,069
very much about so you know I don't know

600
00:26:51,569 --> 00:26:56,399
if James Whitman's on the stream I know

601
00:26:53,069 --> 00:26:57,450
he's a cpp aspect kind of person he

602
00:26:56,400 --> 00:26:59,490
might be able to tell you more about

603
00:26:57,450 --> 00:27:01,890
this aspect of it

604
00:26:59,490 --> 00:27:04,980
I don't follow CP PP stuff anymore

605
00:27:01,890 --> 00:27:07,040
obviously but I believe there is now

606
00:27:04,980 --> 00:27:11,299
push on the C++ standards committee

607
00:27:07,039 --> 00:27:13,950
called UB or unsigned behavior kind of

608
00:27:11,299 --> 00:27:16,470
they have introduced this is kind of the

609
00:27:13,950 --> 00:27:18,600
abbreviation for it there's kind of this

610
00:27:16,470 --> 00:27:20,400
push to start dealing with undefined

611
00:27:18,599 --> 00:27:24,719
behavior a little bit more to start like

612
00:27:20,400 --> 00:27:27,450
nailing down you know how you sanitize

613
00:27:24,720 --> 00:27:29,279
on a defined behavior from programs and

614
00:27:27,450 --> 00:27:30,960
I don't know I mean I'll be honest with

615
00:27:29,279 --> 00:27:32,789
you I don't really know I don't know why

616
00:27:30,960 --> 00:27:34,140
it became more of an issue maybe because

617
00:27:32,789 --> 00:27:35,519
people have been complaining about it

618
00:27:34,140 --> 00:27:37,770
and they want to see people take more

619
00:27:35,519 --> 00:27:38,700
action about this I don't really know so

620
00:27:37,769 --> 00:27:43,400
you'll have to ask somebody else about

621
00:27:38,700 --> 00:27:47,900
that but he gave a lecture at CB Picon

622
00:27:43,400 --> 00:27:51,179
about undefined behavior and he kind of

623
00:27:47,900 --> 00:27:52,880
gave you know examples of various

624
00:27:51,179 --> 00:27:55,140
undefined behaviors

625
00:27:52,880 --> 00:27:56,490
y-you know the compiler why they

626
00:27:55,140 --> 00:27:58,140
implement certain things compiler that

627
00:27:56,490 --> 00:28:00,059
you know why though some behind apply

628
00:27:58,140 --> 00:28:04,050
and behaviors are happening and that

629
00:28:00,059 --> 00:28:05,549
sort of thing and he also gave the you

630
00:28:04,049 --> 00:28:06,750
know that I think the part if you saw my

631
00:28:05,549 --> 00:28:08,339
tweet about the part I was very

632
00:28:06,750 --> 00:28:09,599
uncomfortable that was for some reason

633
00:28:08,339 --> 00:28:12,629
he called out a lot of game developers

634
00:28:09,599 --> 00:28:14,879
people I respect and kind of the tone

635
00:28:12,630 --> 00:28:16,950
was very odd it was like he was sort of

636
00:28:14,880 --> 00:28:18,150
suggesting they were stupid or didn't

637
00:28:16,950 --> 00:28:20,250
know what they were talking about or

638
00:28:18,150 --> 00:28:22,050
were you know arguing about stupid

639
00:28:20,250 --> 00:28:23,759
things I don't know it was just it felt

640
00:28:22,049 --> 00:28:25,200
very dismissive and I didn't understand

641
00:28:23,759 --> 00:28:27,960
why he was doing that cuz like it was

642
00:28:25,200 --> 00:28:29,340
like Fabien you know who's I mean one of

643
00:28:27,960 --> 00:28:33,590
the most meticulous programmers I know

644
00:28:29,339 --> 00:28:36,119
so to suggest that he would be you know

645
00:28:33,589 --> 00:28:38,579
unaware of the important aspects of this

646
00:28:36,119 --> 00:28:40,169
issue was odd you know or John Blow who

647
00:28:38,579 --> 00:28:41,429
like obviously you know I mean he's

648
00:28:40,170 --> 00:28:44,009
writing his own compiler that's like

649
00:28:41,430 --> 00:28:45,960
better than C++ so why you wouldn't you

650
00:28:44,009 --> 00:28:47,670
know take what he says research that I

651
00:28:45,960 --> 00:28:51,390
know so there was kind of like the it

652
00:28:47,670 --> 00:28:53,850
was a totally weird and made me kind of

653
00:28:51,390 --> 00:28:57,150
uncomfortable to call them out you know

654
00:28:53,849 --> 00:29:00,059
it just felt really odd and dismissive

655
00:28:57,150 --> 00:29:01,230
however Chandler later said on Twitter

656
00:29:00,059 --> 00:29:02,789
after I kind of post so hasn't come

657
00:29:01,230 --> 00:29:03,930
found it he said on Twitter that wasn't

658
00:29:02,789 --> 00:29:05,460
his attention so I think that may have

659
00:29:03,930 --> 00:29:09,269
you know that that may well have been a

660
00:29:05,460 --> 00:29:11,490
case of him you know trying to be more

661
00:29:09,269 --> 00:29:13,349
humorous about it then it came across or

662
00:29:11,490 --> 00:29:15,720
something for all I know you know so so

663
00:29:13,349 --> 00:29:17,879
I don't really know so maybe that part

664
00:29:15,720 --> 00:29:18,960
just was you can just forget about you

665
00:29:17,880 --> 00:29:20,550
know don't worry about that part of the

666
00:29:18,960 --> 00:29:23,190
talk maybe it didn't come across as he

667
00:29:20,549 --> 00:29:26,129
intended and it wasn't meant as sort of

668
00:29:23,190 --> 00:29:29,759
a dismissal of some of these other

669
00:29:26,130 --> 00:29:34,800
points of view I'm not sure but anyway

670
00:29:29,759 --> 00:29:37,230
so he gave is talk about that and you

671
00:29:34,799 --> 00:29:40,349
know I guess what I would say is the

672
00:29:37,230 --> 00:29:42,900
talk if anything I I think maybe the

673
00:29:40,349 --> 00:29:48,929
talk was meant to to persuade people

674
00:29:42,900 --> 00:29:51,120
like me who you know maybe were not

675
00:29:48,930 --> 00:29:53,900
zealots about this issue or hadn't been

676
00:29:51,119 --> 00:29:55,889
involved in the discussion you know very

677
00:29:53,900 --> 00:30:01,220
strongly or something in the past

678
00:29:55,890 --> 00:30:04,470
we're baby to persuade them to not be so

679
00:30:01,220 --> 00:30:05,700
much against the way that the C++ people

680
00:30:04,470 --> 00:30:08,308
do it or I

681
00:30:05,700 --> 00:30:10,110
really no but you know again because I

682
00:30:08,308 --> 00:30:12,990
already know that the tone of the

683
00:30:10,109 --> 00:30:15,089
lecture I misinterpreted I perhaps from

684
00:30:12,990 --> 00:30:16,710
what he had expected I couldn't really

685
00:30:15,089 --> 00:30:17,730
say what he was necessarily trying to

686
00:30:16,710 --> 00:30:19,558
accomplish the lecture because maybe I

687
00:30:17,730 --> 00:30:20,759
misheard him as to but it felt to me

688
00:30:19,558 --> 00:30:23,700
like something where he was kind of

689
00:30:20,759 --> 00:30:25,619
trying to put forward a model of

690
00:30:23,700 --> 00:30:27,630
undefined behavior or a way of looking

691
00:30:25,619 --> 00:30:29,609
at the problem that is in line with the

692
00:30:27,630 --> 00:30:31,919
way the C++ spec and compiler vendors

693
00:30:29,609 --> 00:30:33,689
want to look at it as being a productive

694
00:30:31,919 --> 00:30:37,139
or useful way of looking at the problem

695
00:30:33,690 --> 00:30:39,990
and to not be upset about it or

696
00:30:37,138 --> 00:30:45,240
something like this but I did not find

697
00:30:39,990 --> 00:30:48,750
it at all persuasive in that way and I

698
00:30:45,240 --> 00:30:51,720
guess now I can ping-pong back to my

699
00:30:48,750 --> 00:30:54,960
example and maybe give a clearer

700
00:30:51,720 --> 00:30:58,528
explanation of why I am not persuaded by

701
00:30:54,960 --> 00:31:00,210
that based on how I like to program and

702
00:30:58,528 --> 00:31:00,740
what I expect my compiler to do and so

703
00:31:00,210 --> 00:31:03,149
on

704
00:31:00,740 --> 00:31:04,380
so let's ping-pong back here and see if

705
00:31:03,148 --> 00:31:07,379
now I can sort of tie those things

706
00:31:04,380 --> 00:31:09,990
together so we have a case where we are

707
00:31:07,380 --> 00:31:12,120
trying to do a minus B and we would like

708
00:31:09,990 --> 00:31:14,460
the compiler to give us back a positive

709
00:31:12,119 --> 00:31:15,658
or a negative or a zero and we're

710
00:31:14,460 --> 00:31:18,028
expecting zero to mean that they're

711
00:31:15,659 --> 00:31:19,320
equivalent positive to mean sort one

712
00:31:18,028 --> 00:31:21,028
direction negative to mean sort other

713
00:31:19,319 --> 00:31:22,678
direction all we care about is it always

714
00:31:21,028 --> 00:31:24,210
the values to the same thing and it only

715
00:31:22,679 --> 00:31:28,380
evaluates to 0 if the pointers are the

716
00:31:24,210 --> 00:31:31,500
same right that's what we wanted now the

717
00:31:28,380 --> 00:31:33,570
reason why you do not get this behavior

718
00:31:31,500 --> 00:31:35,548
necessarily when you do point arithmetic

719
00:31:33,569 --> 00:31:37,319
and the reason why it's undefined in the

720
00:31:35,548 --> 00:31:39,509
seats back if they come from two

721
00:31:37,319 --> 00:31:42,918
different memory pools is because

722
00:31:39,509 --> 00:31:46,950
there's ways of doing more efficient

723
00:31:42,919 --> 00:31:51,350
determination of the arithmetic here in

724
00:31:46,950 --> 00:31:54,720
the case where you know that the

725
00:31:51,349 --> 00:31:59,579
pointers must be an even multiple of the

726
00:31:54,720 --> 00:32:02,220
struct size away from each other okay so

727
00:31:59,579 --> 00:32:06,329
if I know that this is four elements

728
00:32:02,220 --> 00:32:08,700
long and I know that a and B are of from

729
00:32:06,329 --> 00:32:12,359
the same pool I know that they must have

730
00:32:08,700 --> 00:32:15,929
the same alignment relative to each

731
00:32:12,359 --> 00:32:18,119
other so if this guy starts on a certain

732
00:32:15,929 --> 00:32:19,390
boundary I know that this guy will be on

733
00:32:18,119 --> 00:32:21,699
the same boundary

734
00:32:19,390 --> 00:32:24,790
four right you you you will never have

735
00:32:21,700 --> 00:32:27,819
them be separated by some other amount I

736
00:32:24,789 --> 00:32:29,500
can't say make a and B be seven bytes

737
00:32:27,819 --> 00:32:31,750
away from each other I could make them

738
00:32:29,500 --> 00:32:36,190
be eight or I can make them before but

739
00:32:31,750 --> 00:32:39,490
never seven right and what that means is

740
00:32:36,190 --> 00:32:42,269
that remember C++ is specification of

741
00:32:39,490 --> 00:32:45,880
the distance between two things is

742
00:32:42,269 --> 00:32:47,829
technically going to be the distance

743
00:32:45,880 --> 00:32:51,669
between the two pointers divided by the

744
00:32:47,829 --> 00:32:53,589
size of the structure right now an

745
00:32:51,669 --> 00:32:56,559
integer divided could be very expensive

746
00:32:53,589 --> 00:32:58,779
so if this was for example not a power

747
00:32:56,558 --> 00:33:01,569
of two let's say this was something like

748
00:32:58,779 --> 00:33:04,329
this all right so it's 12 bytes long

749
00:33:01,569 --> 00:33:06,789
well I don't want to issue an integer

750
00:33:04,329 --> 00:33:08,529
divided by 12 what I want to do instead

751
00:33:06,789 --> 00:33:11,769
is do some shorthand shifty

752
00:33:08,529 --> 00:33:13,869
multiplication weirdness or something to

753
00:33:11,769 --> 00:33:16,298
do a divided by 12 more efficiently than

754
00:33:13,869 --> 00:33:18,699
issuing the integer divide and so that's

755
00:33:16,298 --> 00:33:20,470
exactly what they'll do and they'll use

756
00:33:18,700 --> 00:33:24,490
the compiler will use the fact that

757
00:33:20,470 --> 00:33:26,620
these things are unknown alignment

758
00:33:24,490 --> 00:33:32,460
relative to each other to make it happen

759
00:33:26,619 --> 00:33:34,928
right it can do more efficient

760
00:33:32,460 --> 00:33:38,200
arithmetic that way and avoid the divide

761
00:33:34,929 --> 00:33:40,120
all together okay so you can see that

762
00:33:38,200 --> 00:33:42,340
sounds pretty reasonable right that's a

763
00:33:40,119 --> 00:33:44,500
very reasonable thing for a compiler to

764
00:33:42,339 --> 00:33:47,619
want to do and the reason that they are

765
00:33:44,500 --> 00:33:51,190
enabled to do that was specifically

766
00:33:47,619 --> 00:33:55,209
because this is not allowed in the spec

767
00:33:51,190 --> 00:33:57,340
it is undefined the compiler could omit

768
00:33:55,210 --> 00:34:00,009
working code for a subtraction between a

769
00:33:57,339 --> 00:34:02,168
and B or it can omit completely broken

770
00:34:00,009 --> 00:34:03,609
code for that and in this case what it

771
00:34:02,169 --> 00:34:06,130
decided to do was submit completely

772
00:34:03,609 --> 00:34:08,319
broken code for that because it made the

773
00:34:06,130 --> 00:34:12,220
code for the correct thing the correct

774
00:34:08,320 --> 00:34:16,659
by spec thing to be much more efficient

775
00:34:12,219 --> 00:34:18,579
right so hopefully you can see why that

776
00:34:16,659 --> 00:34:21,190
makes some sense and I certainly don't

777
00:34:18,579 --> 00:34:22,599
want a sir compiler writers under a bus

778
00:34:21,190 --> 00:34:24,250
for doing something like that because

779
00:34:22,599 --> 00:34:26,440
you can see why that would speed up a

780
00:34:24,250 --> 00:34:30,099
bunch of cases in your program which are

781
00:34:26,440 --> 00:34:32,260
based on doing exactly this right but

782
00:34:30,099 --> 00:34:33,250
now let me try to explain why I think

783
00:34:32,260 --> 00:34:35,139
this sort of thing

784
00:34:33,250 --> 00:34:37,360
is really ridiculous and why I don't

785
00:34:35,139 --> 00:34:39,128
like it and why I wish there was a

786
00:34:37,360 --> 00:34:40,659
different attitude taken and more

787
00:34:39,128 --> 00:34:43,719
specifically what that attitude actually

788
00:34:40,659 --> 00:34:45,789
it's so the reason that I think this is

789
00:34:43,719 --> 00:34:47,529
ridiculous is because I think it comes

790
00:34:45,789 --> 00:34:50,800
at the problem from a fundamentally

791
00:34:47,530 --> 00:34:52,480
misguided perspective not necessarily

792
00:34:50,800 --> 00:34:55,360
from the perspective of the compiler

793
00:34:52,480 --> 00:34:58,599
writer but from this perspective of the

794
00:34:55,360 --> 00:35:03,070
specification authors right and here's

795
00:34:58,599 --> 00:35:08,679
why if I am going to define subtraction

796
00:35:03,070 --> 00:35:12,789
between two pointers a and B I think if

797
00:35:08,679 --> 00:35:16,449
I am a diligent spec writer then I have

798
00:35:12,789 --> 00:35:21,400
to choose to do one of two things either

799
00:35:16,449 --> 00:35:27,039
I have to specify an inefficient but

800
00:35:21,400 --> 00:35:33,300
complete option for doing so or I have

801
00:35:27,039 --> 00:35:37,179
to specify multiple efficient options

802
00:35:33,300 --> 00:35:38,920
that are complete this is the way I tend

803
00:35:37,179 --> 00:35:42,549
to look at this sort of problem right

804
00:35:38,920 --> 00:35:47,010
and what I mean by this is if I'm only

805
00:35:42,550 --> 00:35:49,660
going to specify one a minus B operation

806
00:35:47,010 --> 00:35:51,520
right which is sort of what we're saying

807
00:35:49,659 --> 00:35:54,009
because this is the only way I can take

808
00:35:51,519 --> 00:35:56,079
the difference between a and B right

809
00:35:54,010 --> 00:35:58,210
there are not multiple subtraction

810
00:35:56,079 --> 00:36:00,670
operators if I have a pointer a and I

811
00:35:58,210 --> 00:36:03,820
have a pointer B and I say that a minus

812
00:36:00,670 --> 00:36:08,769
B is my grammar for subtracting these

813
00:36:03,820 --> 00:36:14,289
two pointers if I'm only specifying one

814
00:36:08,769 --> 00:36:18,730
it must be the one that always works if

815
00:36:14,289 --> 00:36:21,219
on the other hand I do not want to

816
00:36:18,730 --> 00:36:23,590
handcuff the compiler writers or the

817
00:36:21,219 --> 00:36:25,359
optimizers into a situation where they

818
00:36:23,590 --> 00:36:28,750
cannot write efficient code for things

819
00:36:25,360 --> 00:36:32,079
then that's fine but you then have to

820
00:36:28,750 --> 00:36:36,360
give me options for doing the correct

821
00:36:32,079 --> 00:36:39,400
thing right or you could say multiple

822
00:36:36,360 --> 00:36:40,840
you know options that are complete some

823
00:36:39,400 --> 00:36:44,289
are which are efficient some of which

824
00:36:40,840 --> 00:36:46,360
aren't right and that would look like

825
00:36:44,289 --> 00:36:49,809
this

826
00:36:46,360 --> 00:37:00,160
- be right yields you know is always

827
00:36:49,809 --> 00:37:10,570
correct a you know - /b right is correct

828
00:37:00,159 --> 00:37:13,059
only in the same pool right that makes

829
00:37:10,570 --> 00:37:14,260
very good logical sense to me because

830
00:37:13,059 --> 00:37:17,110
they're what you're doing is you're

831
00:37:14,260 --> 00:37:19,900
saying okay we know that this may be an

832
00:37:17,110 --> 00:37:22,000
operation where people need to write it

833
00:37:19,900 --> 00:37:24,760
in a way that could produce incorrect

834
00:37:22,000 --> 00:37:25,960
results in certain cases so what we're

835
00:37:24,760 --> 00:37:29,560
gonna do is provide two different

836
00:37:25,960 --> 00:37:32,349
operators with that awareness and this

837
00:37:29,559 --> 00:37:34,599
way when the programmer knows that they

838
00:37:32,349 --> 00:37:37,179
are well within the specified usage of

839
00:37:34,599 --> 00:37:40,000
this faster version of subtract they can

840
00:37:37,179 --> 00:37:41,769
use it and when they are not they can

841
00:37:40,000 --> 00:37:47,110
use the regular subtract and ensure that

842
00:37:41,769 --> 00:37:48,940
there will be no gotchas right in my

843
00:37:47,110 --> 00:37:50,740
mind there is no other sensible way of

844
00:37:48,940 --> 00:37:51,610
approaching this problem and the reason

845
00:37:50,739 --> 00:37:52,839
that I don't think there's any other

846
00:37:51,610 --> 00:37:55,349
sensible way of approaching this problem

847
00:37:52,840 --> 00:37:59,710
is because approaching it the other way

848
00:37:55,349 --> 00:38:03,369
requires every programmer that ever uses

849
00:37:59,710 --> 00:38:06,610
your language at any time to be

850
00:38:03,369 --> 00:38:09,489
completely and fully aware of every

851
00:38:06,610 --> 00:38:13,390
corner case in your entire specification

852
00:38:09,489 --> 00:38:15,309
and is that really realistic I would

853
00:38:13,389 --> 00:38:19,769
argue that there is no way that that

854
00:38:15,309 --> 00:38:22,960
will ever be realistic most C C

855
00:38:19,769 --> 00:38:25,119
programmers don't even know all of the

856
00:38:22,960 --> 00:38:29,409
things in the spec let alone their

857
00:38:25,119 --> 00:38:31,150
corner cases I would say 100% of all C++

858
00:38:29,409 --> 00:38:33,969
programmers don't know everything that's

859
00:38:31,150 --> 00:38:37,090
in the spec like there's probably one

860
00:38:33,969 --> 00:38:39,369
thing in the spec somewhere that you

861
00:38:37,090 --> 00:38:40,660
could pick for any C++ programmer and

862
00:38:39,369 --> 00:38:42,549
they wouldn't know it they would be

863
00:38:40,659 --> 00:38:45,039
wrong a little bit or they just didn't

864
00:38:42,550 --> 00:38:47,019
know it was there right that's just the

865
00:38:45,039 --> 00:38:48,969
nature of a 500 page document or

866
00:38:47,019 --> 00:38:50,769
whatever it is at this point nobody's

867
00:38:48,969 --> 00:38:52,149
gonna remember every last little bit and

868
00:38:50,769 --> 00:38:53,409
maybe there is someone somewhere who

869
00:38:52,150 --> 00:38:54,940
disproves that but they're like you know

870
00:38:53,409 --> 00:38:56,799
the autistic programmer a guy in the

871
00:38:54,940 --> 00:39:00,480
basement who just recites the spec while

872
00:38:56,800 --> 00:39:00,480
like you know going like this

873
00:39:00,659 --> 00:39:09,129
okay so from my perspective none of

874
00:39:07,510 --> 00:39:13,120
these things should have ever come up

875
00:39:09,130 --> 00:39:15,309
right there shouldn't be this idea that

876
00:39:13,119 --> 00:39:17,799
the specification can leave all these

877
00:39:15,309 --> 00:39:19,389
undefined things happening where the

878
00:39:17,800 --> 00:39:23,830
undefined thing can be very

879
00:39:19,389 --> 00:39:27,940
non-intuitive right you need to be able

880
00:39:23,829 --> 00:39:30,179
to say that here is a very reliable

881
00:39:27,940 --> 00:39:33,309
intuitive way that this thing works and

882
00:39:30,179 --> 00:39:36,369
when we are going to depart from that in

883
00:39:33,309 --> 00:39:38,440
some way we must make it very clear to

884
00:39:36,369 --> 00:39:40,509
the programmer kind of like a Buy in if

885
00:39:38,440 --> 00:39:42,820
you will that you are about to do

886
00:39:40,510 --> 00:39:45,640
something where you understand the cost

887
00:39:42,820 --> 00:39:48,490
of what you're doing in terms of these

888
00:39:45,639 --> 00:39:50,769
minutiae right because no one's ever

889
00:39:48,489 --> 00:39:52,689
gonna write this if they don't

890
00:39:50,769 --> 00:39:55,449
understand the difference between those

891
00:39:52,690 --> 00:39:58,409
two things and especially nowadays when

892
00:39:55,449 --> 00:40:01,119
computers are incredibly fast

893
00:39:58,409 --> 00:40:04,029
introducing a bug that could be very

894
00:40:01,119 --> 00:40:05,559
problematic that only happens on certain

895
00:40:04,030 --> 00:40:08,170
compilers with certain optimization

896
00:40:05,559 --> 00:40:09,759
settings because you take advantage of

897
00:40:08,170 --> 00:40:13,090
this automatically when someone just

898
00:40:09,760 --> 00:40:15,820
wrote this that's really really hurtful

899
00:40:13,090 --> 00:40:18,070
to programmer productivity confidence in

900
00:40:15,820 --> 00:40:19,390
your compiler ability for programmers to

901
00:40:18,070 --> 00:40:23,410
know that they've written things that

902
00:40:19,389 --> 00:40:31,210
are correct right and possibly the

903
00:40:23,409 --> 00:40:34,299
security of whole systems okay so in my

904
00:40:31,210 --> 00:40:36,639
mind 90% of the undefined behavior

905
00:40:34,300 --> 00:40:39,130
things in C and C++ that I've seen fall

906
00:40:36,639 --> 00:40:40,839
into this camp they are problems with

907
00:40:39,130 --> 00:40:41,950
the specification the specification

908
00:40:40,840 --> 00:40:44,650
should not say undefined behavior

909
00:40:41,949 --> 00:40:46,929
instead what it should do is specify a

910
00:40:44,650 --> 00:40:48,630
reasonable intuitive behavior that can

911
00:40:46,929 --> 00:40:51,730
be implemented on most machines

912
00:40:48,630 --> 00:40:54,400
relatively well but perhaps more costly

913
00:40:51,730 --> 00:40:55,539
and then they should say if we have all

914
00:40:54,400 --> 00:40:57,340
these optimizations in mind for this

915
00:40:55,539 --> 00:40:59,800
thing there will be a faster way of

916
00:40:57,340 --> 00:41:02,590
doing it that you can opt into right

917
00:40:59,800 --> 00:41:04,660
that you can opt into and you can opt

918
00:41:02,590 --> 00:41:06,460
into this in various ways maybe one way

919
00:41:04,659 --> 00:41:08,289
of doing it is changing the type of your

920
00:41:06,460 --> 00:41:10,000
variables maybe you have an int and then

921
00:41:08,289 --> 00:41:11,259
you have an int opt or something that

922
00:41:10,000 --> 00:41:13,000
ops into a few things

923
00:41:11,260 --> 00:41:13,540
maybe it's an operator based thing I

924
00:41:13,000 --> 00:41:15,519
don't know

925
00:41:13,539 --> 00:41:16,779
obviously for different circumstances we

926
00:41:15,519 --> 00:41:18,099
could imagine different things being

927
00:41:16,780 --> 00:41:22,510
more efficient but the point is simply

928
00:41:18,099 --> 00:41:24,730
you should have to buy into these kinds

929
00:41:22,510 --> 00:41:27,100
of optimizations that are extremely

930
00:41:24,730 --> 00:41:29,199
non-intuitive based on what you might

931
00:41:27,099 --> 00:41:30,699
expect to happen in it to a reasonable

932
00:41:29,199 --> 00:41:34,419
programmer that the principle of least

933
00:41:30,699 --> 00:41:37,569
surprise if you will okay here's thing

934
00:41:34,420 --> 00:41:41,230
number two so let's talk about the other

935
00:41:37,570 --> 00:41:43,720
case that I brought up over here so the

936
00:41:41,230 --> 00:41:47,920
thing that I brought up over here was

937
00:41:43,719 --> 00:41:51,689
the wraparound integer case right so let

938
00:41:47,920 --> 00:41:55,960
me talk about that okay

939
00:41:51,690 --> 00:41:57,909
so fundamentally all of there's a whole

940
00:41:55,960 --> 00:42:02,769
family of things in this whole like you

941
00:41:57,909 --> 00:42:07,569
know wrapping sort of family of things

942
00:42:02,769 --> 00:42:11,710
or like you know casting you know

943
00:42:07,570 --> 00:42:13,300
whatever implicit conversion I don't

944
00:42:11,710 --> 00:42:16,900
know whatever you want to talk about

945
00:42:13,300 --> 00:42:23,140
here but but for example in the C++ Beck

946
00:42:16,900 --> 00:42:32,099
you know int unsigned has well-defined

947
00:42:23,139 --> 00:42:37,150
wrapping Wow writing well-defined

948
00:42:32,099 --> 00:42:39,190
wrapping so you do know that if you have

949
00:42:37,150 --> 00:42:40,030
an unsigned integer it will wrap

950
00:42:39,190 --> 00:42:46,210
properly

951
00:42:40,030 --> 00:42:49,269
whereas int does not write so this may

952
00:42:46,210 --> 00:42:52,769
not wrap properly but this I think is

953
00:42:49,269 --> 00:42:56,440
guaranteed to that's my recollection

954
00:42:52,769 --> 00:43:00,880
okay so the interesting thing about

955
00:42:56,440 --> 00:43:03,309
these is this gets at another

956
00:43:00,880 --> 00:43:06,630
fundamental weakness in the C spec and C

957
00:43:03,309 --> 00:43:10,210
the suspect in my opinion which is that

958
00:43:06,630 --> 00:43:13,059
types that generally the way that we

959
00:43:10,210 --> 00:43:16,720
talk about types in C doesn't correspond

960
00:43:13,059 --> 00:43:18,940
to what the processor does in a way that

961
00:43:16,719 --> 00:43:22,589
is useful to the programmer right and

962
00:43:18,940 --> 00:43:27,539
this comes from a fundamentally I think

963
00:43:22,590 --> 00:43:27,539
misapplication or Mis a fundamentally

964
00:43:28,199 --> 00:43:32,769
how should I put this it comes from a

965
00:43:30,579 --> 00:43:34,809
fundamentally different worldview

966
00:43:32,769 --> 00:43:37,119
between the people who work on the

967
00:43:34,809 --> 00:43:40,000
specification from C++ and people like

968
00:43:37,119 --> 00:43:42,639
me now that doesn't mean that that I'm

969
00:43:40,000 --> 00:43:45,030
right and they're wrong but what it does

970
00:43:42,639 --> 00:43:47,799
mean is I don't want to use C and C++

971
00:43:45,030 --> 00:43:49,840
right what it means is it's not a good

972
00:43:47,800 --> 00:43:54,300
language for me and I can say that

973
00:43:49,840 --> 00:43:56,890
pretty definitively right and here's why

974
00:43:54,300 --> 00:43:59,289
when you talk about things in these

975
00:43:56,889 --> 00:44:01,029
sorts of terms and you say that int

976
00:43:59,289 --> 00:44:05,920
unsigned has well-defined wrapping

977
00:44:01,030 --> 00:44:10,830
behavior and int does not just the fact

978
00:44:05,920 --> 00:44:10,829
that you have stated things in this way

979
00:44:11,429 --> 00:44:18,009
completely ignores the fact that

980
00:44:14,610 --> 00:44:22,840
programmers such as myself are not

981
00:44:18,010 --> 00:44:25,390
trying to write an abstract program like

982
00:44:22,840 --> 00:44:28,780
I am NOT trying to write a mathematical

983
00:44:25,389 --> 00:44:31,480
proof in a book I am NOT trying to write

984
00:44:28,780 --> 00:44:33,519
an abstract mathematical program that

985
00:44:31,480 --> 00:44:35,829
can be preserved for generations on a

986
00:44:33,519 --> 00:44:39,239
single piece of paper for future people

987
00:44:35,829 --> 00:44:43,239
to look at and understand how it worked

988
00:44:39,239 --> 00:44:49,179
what I am trying to do is program a

989
00:44:43,239 --> 00:44:53,919
PlayStation 4 right or I'm trying to

990
00:44:49,179 --> 00:44:57,909
program a PC I'm trying to program an

991
00:44:53,920 --> 00:45:02,050
Xbox 360 right that's what I actually

992
00:44:57,909 --> 00:45:04,599
need to have happen and this is sort of

993
00:45:02,050 --> 00:45:06,670
the essence of Mike actin cpp con talk

994
00:45:04,599 --> 00:45:08,920
for example where he talked about this

995
00:45:06,670 --> 00:45:11,200
very civically to the C++ audience I

996
00:45:08,920 --> 00:45:15,760
don't know that anyone found it

997
00:45:11,199 --> 00:45:17,949
convincing but fundamentally speaking

998
00:45:15,760 --> 00:45:19,540
the kind of programming that I do during

999
00:45:17,949 --> 00:45:21,759
the day and that most people in the game

1000
00:45:19,539 --> 00:45:25,000
machine during the day is not about an

1001
00:45:21,760 --> 00:45:27,190
abstract programming to a language it's

1002
00:45:25,000 --> 00:45:30,309
about making something that runs on

1003
00:45:27,190 --> 00:45:33,250
actual hardware and in a way that is

1004
00:45:30,309 --> 00:45:40,489
specified very completely by that actual

1005
00:45:33,250 --> 00:45:45,469
hardware so when I type mmm you know

1006
00:45:40,489 --> 00:45:48,919
door PS I'm not trying to say some

1007
00:45:45,469 --> 00:45:50,659
abstract thing about how I might want to

1008
00:45:48,920 --> 00:45:54,230
write some values to memory at some

1009
00:45:50,659 --> 00:46:00,019
point what I'm trying to say is like put

1010
00:45:54,230 --> 00:46:02,780
a move ApS in there right I'm trying to

1011
00:46:00,019 --> 00:46:05,869
tell the processor what to do and that's

1012
00:46:02,780 --> 00:46:09,290
how I generally view what I do during

1013
00:46:05,869 --> 00:46:10,789
the day now you might say well why don't

1014
00:46:09,289 --> 00:46:15,619
you program in a semi language then

1015
00:46:10,789 --> 00:46:17,809
right and the answer is because well

1016
00:46:15,619 --> 00:46:19,070
it's vastly more complicated to program

1017
00:46:17,809 --> 00:46:21,440
in a semi language I would have to do

1018
00:46:19,070 --> 00:46:24,320
things like register allocation I'd have

1019
00:46:21,440 --> 00:46:26,300
to do things like think about how to

1020
00:46:24,320 --> 00:46:29,180
like put things on the stack and where

1021
00:46:26,300 --> 00:46:31,130
they should go right and I don't want to

1022
00:46:29,179 --> 00:46:33,349
do those things I appreciate the fact

1023
00:46:31,130 --> 00:46:36,099
that I have a higher level language to

1024
00:46:33,349 --> 00:46:39,679
do those things for me but what I don't

1025
00:46:36,099 --> 00:46:44,929
want my higher level language to do at

1026
00:46:39,679 --> 00:46:47,629
all is pretend that I'm on some kind of

1027
00:46:44,929 --> 00:46:50,419
an ill-defined system that doesn't

1028
00:46:47,630 --> 00:46:51,590
really know whether it uses

1029
00:46:50,420 --> 00:46:55,099
two's-complement

1030
00:46:51,590 --> 00:46:59,180
or not or whether or not the size of a

1031
00:46:55,099 --> 00:47:01,940
register is 64 bits I have no interest

1032
00:46:59,179 --> 00:47:04,250
in that because I know exactly what I'm

1033
00:47:01,940 --> 00:47:07,490
shipping on and what I want to be able

1034
00:47:04,250 --> 00:47:11,358
to do is write code confidently that

1035
00:47:07,489 --> 00:47:16,489
translates into well-defined behavior on

1036
00:47:11,358 --> 00:47:18,079
the processor I am targeting right so I

1037
00:47:16,489 --> 00:47:21,019
don't ever want you to say something

1038
00:47:18,079 --> 00:47:23,690
like well-defined rapping or non

1039
00:47:21,019 --> 00:47:27,829
well-defined rapping or honestly ever

1040
00:47:23,690 --> 00:47:29,929
int or unsigned int because as far as

1041
00:47:27,829 --> 00:47:33,349
I'm concerned these things are actually

1042
00:47:29,929 --> 00:47:36,469
the same thing they're a 64-bit register

1043
00:47:33,349 --> 00:47:37,909
that's going to get operated on and it

1044
00:47:36,469 --> 00:47:39,829
doesn't matter whether it's an inter and

1045
00:47:37,909 --> 00:47:43,699
unsigned int they get the exact same

1046
00:47:39,829 --> 00:47:45,319
instructions generated right for a huge

1047
00:47:43,699 --> 00:47:49,039
number of the operations you might do on

1048
00:47:45,320 --> 00:47:51,320
them there isn't like going to be two

1049
00:47:49,039 --> 00:47:53,329
different types of add for example

1050
00:47:51,320 --> 00:47:53,990
there's only going to be one and it

1051
00:47:53,329 --> 00:47:57,230
doesn't matter

1052
00:47:53,989 --> 00:47:59,959
it's an unsigned int or a signed it when

1053
00:47:57,230 --> 00:48:03,920
it starts to matter which one is which

1054
00:47:59,960 --> 00:48:05,449
is when I do something like you know a

1055
00:48:03,920 --> 00:48:07,119
comparison operator or something like

1056
00:48:05,449 --> 00:48:10,159
this when I do something that actually

1057
00:48:07,119 --> 00:48:11,750
takes the two's complement and has to do

1058
00:48:10,159 --> 00:48:13,190
a different thing for the two's

1059
00:48:11,750 --> 00:48:16,550
complement versions than the non two's

1060
00:48:13,190 --> 00:48:20,900
competition so it's actually operator

1061
00:48:16,550 --> 00:48:23,480
based signed and unsigned is actually

1062
00:48:20,900 --> 00:48:25,099
not about this value it's not storing

1063
00:48:23,480 --> 00:48:28,849
anything different it's storing the

1064
00:48:25,099 --> 00:48:31,519
exact same thing right the difference is

1065
00:48:28,849 --> 00:48:33,019
just how I'm operating on it and you can

1066
00:48:31,519 --> 00:48:35,690
see this brought in two very sharp

1067
00:48:33,019 --> 00:48:39,019
relief when we start switching to the

1068
00:48:35,690 --> 00:48:41,420
mmm sort of stuff where we just have

1069
00:48:39,019 --> 00:48:48,440
like you know mmm 128 or whatever it is

1070
00:48:41,420 --> 00:48:51,110
right or a sorry M 128 you know these M

1071
00:48:48,440 --> 00:48:53,030
128 times right well if you've ever

1072
00:48:51,110 --> 00:48:54,980
programmed anything with sim D even very

1073
00:48:53,030 --> 00:48:56,540
basic step acidity what you realize is

1074
00:48:54,980 --> 00:48:59,059
that if you start to do anything besides

1075
00:48:56,539 --> 00:49:03,460
floating-point if you do anything with

1076
00:48:59,059 --> 00:49:07,009
with non floating-point you are quickly

1077
00:49:03,460 --> 00:49:09,139
writing code that treats these registers

1078
00:49:07,010 --> 00:49:12,580
as a whole host of different things

1079
00:49:09,139 --> 00:49:15,529
right so the problem was kind of like

1080
00:49:12,579 --> 00:49:16,819
simple back here and you could sort of

1081
00:49:15,530 --> 00:49:18,200
say well there's just two-way street you

1082
00:49:16,820 --> 00:49:19,809
know it's an int or it's an unsigned int

1083
00:49:18,199 --> 00:49:22,730
so we'll just have those two things

1084
00:49:19,809 --> 00:49:25,059
right but when you start writing this

1085
00:49:22,730 --> 00:49:27,469
code you realize none and then uh no

1086
00:49:25,059 --> 00:49:28,969
registers and pressors nowadays there

1087
00:49:27,469 --> 00:49:31,099
can be like 50 different ways to think

1088
00:49:28,969 --> 00:49:33,589
about them like oh this thing was like 8

1089
00:49:31,099 --> 00:49:35,480
sliced signed values for this operation

1090
00:49:33,590 --> 00:49:37,880
and then the operation immediately after

1091
00:49:35,480 --> 00:49:40,429
it I was thinking of it as 4 sliced 16s

1092
00:49:37,880 --> 00:49:42,108
and blah blah blah right and so it

1093
00:49:40,429 --> 00:49:44,599
becomes very very clear very very

1094
00:49:42,108 --> 00:49:46,279
quickly is the view of the data in

1095
00:49:44,599 --> 00:49:47,868
memory is entirely based on the

1096
00:49:46,280 --> 00:49:51,470
operation that you're doing with it and

1097
00:49:47,869 --> 00:49:54,289
this in signed unsigned nonsense

1098
00:49:51,469 --> 00:49:56,750
is really just some convenience features

1099
00:49:54,289 --> 00:49:58,099
that people thought were cool back when

1100
00:49:56,750 --> 00:50:00,469
there were very simplistic ways of

1101
00:49:58,099 --> 00:50:03,199
looking at values and registers where

1102
00:50:00,469 --> 00:50:05,299
hey if I just specify that these two

1103
00:50:03,199 --> 00:50:07,639
types then the compiler can just always

1104
00:50:05,300 --> 00:50:09,680
infer

1105
00:50:07,639 --> 00:50:12,349
which of the operations I wanted to do

1106
00:50:09,679 --> 00:50:14,119
in the case where the CPU does have

1107
00:50:12,349 --> 00:50:20,299
differing operations for signed races

1108
00:50:14,119 --> 00:50:23,299
unsigned right and so I this is just a

1109
00:50:20,300 --> 00:50:25,160
complete waste of time like the fact

1110
00:50:23,300 --> 00:50:27,260
that anyone's even spending time looking

1111
00:50:25,159 --> 00:50:29,119
at that just kind of underscores to me

1112
00:50:27,260 --> 00:50:31,010
that I don't think about these that

1113
00:50:29,119 --> 00:50:34,159
where they do I would like a different

1114
00:50:31,010 --> 00:50:37,610
language I would like it to be based on

1115
00:50:34,159 --> 00:50:39,399
how processors work not on how language

1116
00:50:37,610 --> 00:50:42,349
designers think about things or types

1117
00:50:39,400 --> 00:50:46,579
what I'd rather have is a language that

1118
00:50:42,349 --> 00:50:48,349
just lets me say here are a bunch of

1119
00:50:46,579 --> 00:50:51,440
primitives they're based on what

1120
00:50:48,349 --> 00:50:54,829
processors can do right I can execute

1121
00:50:51,440 --> 00:50:56,630
any of them that I want if I try to use

1122
00:50:54,829 --> 00:50:58,460
one that doesn't isn't supported on a

1123
00:50:56,630 --> 00:51:00,980
particular platform that's just an error

1124
00:50:58,460 --> 00:51:03,289
so it's up to me to make different

1125
00:51:00,980 --> 00:51:05,389
compilation units or versions of

1126
00:51:03,289 --> 00:51:08,360
whatever to support the processors that

1127
00:51:05,389 --> 00:51:11,179
I want and then I never want you to talk

1128
00:51:08,360 --> 00:51:13,340
to me about spec behavior I don't want

1129
00:51:11,179 --> 00:51:15,049
you to specify anything the

1130
00:51:13,340 --> 00:51:17,329
specification for the behavior should be

1131
00:51:15,050 --> 00:51:21,470
whatever the processor does that's it

1132
00:51:17,329 --> 00:51:23,389
right and furthermore if I want some

1133
00:51:21,469 --> 00:51:26,000
extra behavior I'll tell you what it is

1134
00:51:23,389 --> 00:51:28,909
right if I don't want you to care about

1135
00:51:26,000 --> 00:51:32,389
values wrapping I'll tell you right I'll

1136
00:51:28,909 --> 00:51:35,029
make my own type and I'll mark it don't

1137
00:51:32,389 --> 00:51:36,739
care if it wraps and then the optimizer

1138
00:51:35,030 --> 00:51:38,210
knows it can do anything it wants and

1139
00:51:36,739 --> 00:51:41,229
doesn't have to worry about wrapping

1140
00:51:38,210 --> 00:51:43,670
right I'll tell you but don't

1141
00:51:41,230 --> 00:51:45,889
arbitrarily have a bunch of people in a

1142
00:51:43,670 --> 00:51:47,630
room decide that in sneed to be

1143
00:51:45,889 --> 00:51:48,859
specified is to complement and it

1144
00:51:47,630 --> 00:51:50,780
doesn't matter how they wrap someone

1145
00:51:48,860 --> 00:51:54,230
define don't do that that doesn't help

1146
00:51:50,780 --> 00:51:55,010
me at all that just hurts me right it

1147
00:51:54,230 --> 00:51:56,900
slows me down

1148
00:51:55,010 --> 00:51:59,120
it has bugs to my program and it doesn't

1149
00:51:56,900 --> 00:52:01,160
get me any closer to what I need which

1150
00:51:59,119 --> 00:52:02,630
is a more efficient version of assembly

1151
00:52:01,159 --> 00:52:03,259
language for programming actual

1152
00:52:02,630 --> 00:52:06,400
computers

1153
00:52:03,260 --> 00:52:10,250
that's what C is supposed to be right

1154
00:52:06,400 --> 00:52:12,440
and so I find this whole discussion to

1155
00:52:10,250 --> 00:52:14,059
be incredibly misguided I don't think it

1156
00:52:12,440 --> 00:52:15,980
addresses the actual problems it

1157
00:52:14,059 --> 00:52:18,110
certainly doesn't help me out and it's

1158
00:52:15,980 --> 00:52:21,079
going nowhere good as far as I can tell

1159
00:52:18,110 --> 00:52:23,420
right and so you

1160
00:52:21,079 --> 00:52:26,150
my preference as how things would go

1161
00:52:23,420 --> 00:52:29,680
forwards programming lies is to try and

1162
00:52:26,150 --> 00:52:32,360
go back to the original basic idea that

1163
00:52:29,679 --> 00:52:35,210
platforms specify their behaviors what

1164
00:52:32,360 --> 00:52:37,760
their CPU actually does the idea behind

1165
00:52:35,210 --> 00:52:41,329
the language is to allow the programmer

1166
00:52:37,760 --> 00:52:45,200
to write portable code when they don't

1167
00:52:41,329 --> 00:52:50,659
care by using things which are specified

1168
00:52:45,199 --> 00:52:52,099
very concisely and anytime there's any

1169
00:52:50,659 --> 00:52:55,279
question about what's going to happen

1170
00:52:52,099 --> 00:52:58,069
the programmer makes it explicit it is

1171
00:52:55,280 --> 00:53:00,730
not the optimizers job or the specs job

1172
00:52:58,070 --> 00:53:03,860
to leave things up in the air so that

1173
00:53:00,730 --> 00:53:06,440
random stuff can start happening to make

1174
00:53:03,860 --> 00:53:09,950
the code faster like that just doesn't

1175
00:53:06,440 --> 00:53:14,769
help me I don't like that I think that

1176
00:53:09,949 --> 00:53:14,769
hurts me a lot more than it helps right

1177
00:53:16,119 --> 00:53:23,769
so I feel like that is a fairly full

1178
00:53:19,429 --> 00:53:31,609
description of the problem I hope that I

1179
00:53:23,769 --> 00:53:36,139
hope that sort of clarify as my position

1180
00:53:31,610 --> 00:53:38,530
on that subject for anyone who actually

1181
00:53:36,139 --> 00:53:38,529
cares

1182
00:54:02,260 --> 00:54:17,920
so I think that took basically the

1183
00:54:04,389 --> 00:54:19,629
entire hour Allen says he's quite

1184
00:54:17,920 --> 00:54:22,510
satisfied and since you asked the

1185
00:54:19,630 --> 00:54:24,789
question originally that is good

1186
00:54:22,510 --> 00:54:34,230
can I definitely so think about uh yeah

1187
00:54:24,789 --> 00:54:34,230
I mean I feel like fundamentally I

1188
00:54:34,980 --> 00:54:43,630
really would just like to see some work

1189
00:54:39,789 --> 00:54:46,210
being done in the area of let's now that

1190
00:54:43,630 --> 00:54:48,400
we know what assembly language actually

1191
00:54:46,210 --> 00:54:50,260
looks like on modern CPUs in terms of

1192
00:54:48,400 --> 00:54:52,269
their instruction set can we make a

1193
00:54:50,260 --> 00:54:55,840
better version of like the original idea

1194
00:54:52,269 --> 00:54:58,358
behind C which was like make it easier

1195
00:54:55,840 --> 00:55:03,809
to write low-level code cuz right now

1196
00:54:58,358 --> 00:55:03,809
it's not really that way you know

1197
00:55:07,769 --> 00:55:16,650
so so yeah that's what I would say

1198
00:55:26,199 --> 00:55:32,529
that's what I would say and I don't know

1199
00:55:28,929 --> 00:55:37,539
like I don't know that would be that

1200
00:55:32,530 --> 00:55:42,640
difficult to do you know uh but it you

1201
00:55:37,539 --> 00:55:47,920
know it just seems like it just seems to

1202
00:55:42,639 --> 00:55:50,889
me like fundamentally not that hard of a

1203
00:55:47,920 --> 00:55:53,320
problem to do this part of it and I feel

1204
00:55:50,889 --> 00:55:56,920
like with all of the effort that's

1205
00:55:53,320 --> 00:56:00,730
expended on C++ spec and compilers and

1206
00:55:56,920 --> 00:56:03,369
they never improve the core programming

1207
00:56:00,730 --> 00:56:06,670
experience you know they never get they

1208
00:56:03,369 --> 00:56:09,369
never actually get down and fix the fact

1209
00:56:06,670 --> 00:56:11,769
that it's just I it's this huge

1210
00:56:09,369 --> 00:56:15,839
nightmare to program and do basic stuff

1211
00:56:11,769 --> 00:56:19,630
like work with you know vector registers

1212
00:56:15,840 --> 00:56:21,400
but that's you know that's why people

1213
00:56:19,630 --> 00:56:24,400
program in these languages still you

1214
00:56:21,400 --> 00:56:27,220
know people people writing web apps

1215
00:56:24,400 --> 00:56:30,039
aren't writing them in C and C++ you

1216
00:56:27,219 --> 00:56:32,049
know the people still using C and C++

1217
00:56:30,039 --> 00:56:33,820
are the people who care about these sort

1218
00:56:32,050 --> 00:56:36,430
of things to a certain degree right I

1219
00:56:33,820 --> 00:56:38,050
mean I feel like the people who care

1220
00:56:36,429 --> 00:56:39,309
simply about using high-level languages

1221
00:56:38,050 --> 00:56:42,250
I've got to think they would be leaving

1222
00:56:39,309 --> 00:56:44,019
C++ in droves right because C++ is not a

1223
00:56:42,250 --> 00:56:46,000
very good high-level language you know

1224
00:56:44,019 --> 00:56:47,889
it's not I feel like you could easily

1225
00:56:46,000 --> 00:56:50,559
find a better one somewhere else if

1226
00:56:47,889 --> 00:56:53,199
you're just if you don't care about the

1227
00:56:50,559 --> 00:56:55,420
the low-level aspects of it and pointers

1228
00:56:53,199 --> 00:56:57,849
and things like that why are you using

1229
00:56:55,420 --> 00:57:00,940
it you know why aren't you using a

1230
00:56:57,849 --> 00:57:02,529
Python or rust or go or I don't know

1231
00:57:00,940 --> 00:57:07,269
right there's all these other options

1232
00:57:02,530 --> 00:57:09,790
out there and the C++ spec is filled

1233
00:57:07,269 --> 00:57:11,710
with you know tons of these crazy things

1234
00:57:09,789 --> 00:57:16,900
and none of them are particularly you

1235
00:57:11,710 --> 00:57:19,769
know easy to use or complete or anything

1236
00:57:16,900 --> 00:57:19,769
else right so

1237
00:57:40,750 --> 00:57:44,199
let me see it maybe I'll take one more

1238
00:57:42,670 --> 00:57:46,650
if it's quick otherwise I think I'm

1239
00:57:44,199 --> 00:57:46,649
gonna go

1240
00:57:58,750 --> 00:58:02,900
Andrew JDR has one that I can answer I

1241
00:58:01,369 --> 00:58:04,400
think pretty quickly but not in a very

1242
00:58:02,900 --> 00:58:06,200
satisfying way curious if you've

1243
00:58:04,400 --> 00:58:09,559
experimented with different 3d polygons

1244
00:58:06,199 --> 00:58:11,089
triangulation approaches and settled on

1245
00:58:09,559 --> 00:58:13,690
something that you use under most

1246
00:58:11,090 --> 00:58:17,200
circumstances and the answer there is no

1247
00:58:13,690 --> 00:58:20,809
because I have not really had to do that

1248
00:58:17,199 --> 00:58:23,359
I probably will have to do that in

1249
00:58:20,809 --> 00:58:24,949
future incarnations of our engines at

1250
00:58:23,360 --> 00:58:26,750
Mali

1251
00:58:24,949 --> 00:58:28,909
so maybe I'll have more of opinion about

1252
00:58:26,750 --> 00:58:30,289
that five years from now not that it'll

1253
00:58:28,909 --> 00:58:34,730
be relevant to you at that point I'm

1254
00:58:30,289 --> 00:58:40,579
sure but I mostly I just have not had to

1255
00:58:34,730 --> 00:58:42,079
do con like con K you know eat a 3d

1256
00:58:40,579 --> 00:58:46,090
polygons is pretty trivial to

1257
00:58:42,079 --> 00:58:49,989
triangulate if it's if it's convex right

1258
00:58:46,090 --> 00:58:52,970
so there's really no need to get fancy

1259
00:58:49,989 --> 00:58:55,569
if it's convex but if it's concave which

1260
00:58:52,969 --> 00:58:59,989
is I assume what you're talking about

1261
00:58:55,570 --> 00:59:02,200
you know well well maybe you're not

1262
00:58:59,989 --> 00:59:04,819
maybe you just mean if you want it up

1263
00:59:02,199 --> 00:59:09,710
res it because you said constrained

1264
00:59:04,820 --> 00:59:11,150
along de Launay triangulation so I don't

1265
00:59:09,710 --> 00:59:12,289
know I guess I should clarify first

1266
00:59:11,150 --> 00:59:15,289
though you're just talking about adding

1267
00:59:12,289 --> 00:59:21,380
triangles to inside of a triangle that's

1268
00:59:15,289 --> 00:59:23,449
already that's already come concave and

1269
00:59:21,380 --> 00:59:25,820
convex or you talking about concave yeah

1270
00:59:23,449 --> 00:59:30,469
come on okay so yeah I've never really

1271
00:59:25,820 --> 00:59:31,880
had to deal with that and I think it

1272
00:59:30,469 --> 00:59:34,699
sounds like a fun problem you know I

1273
00:59:31,880 --> 00:59:36,740
would like to play with something like

1274
00:59:34,699 --> 00:59:39,289
that it sounds fun

1275
00:59:36,739 --> 00:59:47,809
but I have it I do know that Sean

1276
00:59:39,289 --> 00:59:52,099
Barrett did some work with this because

1277
00:59:47,809 --> 01:00:01,509
he wrote a flash emulator for Rad's

1278
00:59:52,099 --> 01:00:01,509
called Iggy I don't know if I can

1279
01:00:05,469 --> 01:00:14,029
why are you not working streams still

1280
01:00:10,880 --> 01:00:18,130
working DNS server doesn't look like

1281
01:00:14,030 --> 01:00:18,130
it's working that's not a good sign oh

1282
01:00:21,130 --> 01:00:27,380
alright

1283
01:00:22,869 --> 01:00:34,640
not great not great anyway there's a

1284
01:00:27,380 --> 01:00:37,608
thing called eggy I can't get to the

1285
01:00:34,639 --> 01:00:43,779
site to show you but there's thing

1286
01:00:37,608 --> 01:00:43,779
called eggy that is a flash emulator for

1287
01:00:44,440 --> 01:00:54,200
for games like if people want you know

1288
01:00:50,539 --> 01:00:58,480
to play back flash animations and he you

1289
01:00:54,199 --> 01:01:02,868
know cuz flash that you do arbitrarily

1290
01:00:58,480 --> 01:01:05,510
you know arbitrary triangle things or

1291
01:01:02,869 --> 01:01:09,349
whatever arbitrary polygons and animate

1292
01:01:05,510 --> 01:01:11,680
them around or whatever and so he wrote

1293
01:01:09,349 --> 01:01:16,130
a thing that will triangulate those and

1294
01:01:11,679 --> 01:01:22,639
I don't actually know what he settled on

1295
01:01:16,130 --> 01:01:24,260
using but you know you could ask him

1296
01:01:22,639 --> 01:01:25,909
some time when he's streaming to talk

1297
01:01:24,260 --> 01:01:27,440
about it because he probably has an

1298
01:01:25,909 --> 01:01:29,509
opinion I mean he probably looked at a

1299
01:01:27,440 --> 01:01:32,720
couple different things and picked an

1300
01:01:29,510 --> 01:01:40,790
algorithm for some particular reason so

1301
01:01:32,719 --> 01:01:46,669
I don't know yeah so I guess only the

1302
01:01:40,789 --> 01:01:48,318
DNS server got got whacked right because

1303
01:01:46,670 --> 01:01:50,568
it looks like it just can't resolve the

1304
01:01:48,318 --> 01:01:53,900
DNS server but it's not a problem

1305
01:01:50,568 --> 01:01:57,469
resolving traffic so traffic still going

1306
01:01:53,900 --> 01:02:00,970
through but the but the DNS server is

1307
01:01:57,469 --> 01:02:00,969
just out right

1308
01:02:05,880 --> 01:02:09,690
and let's see

1309
01:02:28,518 --> 01:02:31,518
yeah

1310
01:02:36,690 --> 01:02:42,230
I think that's it for short questions

1311
01:02:44,088 --> 01:02:50,659
think that is it it's probably going to

1312
01:02:48,300 --> 01:02:50,660
wind down

1313
01:03:31,219 --> 01:03:34,269
all right

1314
01:03:39,030 --> 01:03:45,250
alright I think we've got everything all

1315
01:03:43,809 --> 01:03:47,170
the rest of the questions look like kind

1316
01:03:45,250 --> 01:03:49,480
of involved ones so I'm gonna go and of

1317
01:03:47,170 --> 01:03:53,039
course I can't get to the internet so

1318
01:03:49,480 --> 01:03:53,039
that's always good

1319
01:03:53,159 --> 01:04:00,460
anyway thank you for joining me for a

1320
01:03:57,548 --> 01:04:03,130
special edition of handmade Hero for a

1321
01:04:00,460 --> 01:04:06,358
chat which we don't often do but we did

1322
01:04:03,130 --> 01:04:09,579
tonight I'll be back next week I think

1323
01:04:06,358 --> 01:04:11,440
it depends on whether I think I will

1324
01:04:09,579 --> 01:04:13,200
probably be moving the handmade hero

1325
01:04:11,440 --> 01:04:17,470
machine to the office at some point

1326
01:04:13,199 --> 01:04:19,358
because we had to get a static IP

1327
01:04:17,469 --> 01:04:23,019
address for the office for various

1328
01:04:19,358 --> 01:04:25,150
contractual reasons so although it won't

1329
01:04:23,019 --> 01:04:28,210
be plugged into anything I could just

1330
01:04:25,150 --> 01:04:30,670
sit the handmade hero thing there and

1331
01:04:28,210 --> 01:04:32,949
use that and stream from the office

1332
01:04:30,670 --> 01:04:35,079
which I might decide to do if I do do

1333
01:04:32,949 --> 01:04:39,189
that will probably take a week off at

1334
01:04:35,079 --> 01:04:41,559
the point where I move it and get it

1335
01:04:39,190 --> 01:04:43,750
back up and running there but I don't

1336
01:04:41,559 --> 01:04:48,450
know if and when that's gonna happen so

1337
01:04:43,750 --> 01:04:51,789
as always check out the schedule bot and

1338
01:04:48,449 --> 01:04:53,588
and figure out whether whether that

1339
01:04:51,789 --> 01:04:55,599
happens by that the handy a sketch with

1340
01:04:53,588 --> 01:04:57,130
that anyway thank you very for a free

1341
01:04:55,599 --> 01:04:58,720
hat chat I think it will be back next

1342
01:04:57,130 --> 01:05:01,750
week if not we'll be back the week after

1343
01:04:58,719 --> 01:05:03,368
that one way or the other and that is

1344
01:05:01,750 --> 01:05:06,269
about it for now

1345
01:05:03,369 --> 01:05:09,338
have fun programming this weekend and

1346
01:05:06,269 --> 01:05:12,250
yeah try not to hit any undefined

1347
01:05:09,338 --> 01:05:15,130
behavior in your compiler until next

1348
01:05:12,250 --> 01:05:17,789
time take it easy everyone and I'll see

1349
01:05:15,130 --> 01:05:17,789
you on the Internet

