1
00:00:02,419 --> 00:00:10,080
okay we are back with the Q&amp;A please

2
00:00:06,059 --> 00:00:13,018
remember to put at sameera tori or when

3
00:00:10,080 --> 00:00:14,309
you when you do a when you ask a

4
00:00:13,019 --> 00:00:16,019
question so I can quickly see that

5
00:00:14,308 --> 00:00:17,399
someone has asked a question and isn't

6
00:00:16,019 --> 00:00:20,719
talking to someone else on the screen

7
00:00:17,399 --> 00:00:25,349
and I will start taking questions now

8
00:00:20,719 --> 00:00:28,710
let's see a brain cruiser says do a

9
00:00:25,350 --> 00:00:30,660
segmentation error I am going to get to

10
00:00:28,710 --> 00:00:34,109
those I think in the mainstream I'd

11
00:00:30,660 --> 00:00:36,090
rather save memory out-of-bounds writes

12
00:00:34,109 --> 00:00:37,380
for the mainstream but we will

13
00:00:36,090 --> 00:00:40,739
definitely deal with that and memory

14
00:00:37,380 --> 00:00:42,090
protection chronolog in asks me oh you

15
00:00:40,738 --> 00:00:43,828
know what I should probably turn off the

16
00:00:42,090 --> 00:00:46,289
infinite KC's I know you love seeing the

17
00:00:43,829 --> 00:00:48,000
infinite cases but you know really do we

18
00:00:46,289 --> 00:00:49,309
need infinite cases infant cases sounds

19
00:00:48,000 --> 00:00:51,448
like a bad thing to have in the world

20
00:00:49,308 --> 00:00:54,359
will you explain how negative numbers

21
00:00:51,448 --> 00:00:55,649
are encoded yes well I will try to if we

22
00:00:54,359 --> 00:00:57,030
have time tomorrow I would try to

23
00:00:55,649 --> 00:00:59,660
two's-complement

24
00:00:57,030 --> 00:01:02,399
is how they're encoded I don't know that

25
00:00:59,659 --> 00:01:03,869
I don't know that I want spent too much

26
00:01:02,399 --> 00:01:05,460
time because it's not that important for

27
00:01:03,869 --> 00:01:06,450
people to know but I will kind of

28
00:01:05,459 --> 00:01:07,859
mention it in passing at least

29
00:01:06,450 --> 00:01:09,780
chronodragon what would be the

30
00:01:07,859 --> 00:01:13,289
difference if you C++ classes instead of

31
00:01:09,780 --> 00:01:14,489
structs well really nothing at first if

32
00:01:13,290 --> 00:01:15,780
you just declare something as a class

33
00:01:14,489 --> 00:01:18,089
instead of a struct it doesn't actually

34
00:01:15,780 --> 00:01:20,340
lay it out any different in memory but

35
00:01:18,090 --> 00:01:21,659
it can start to be different once you

36
00:01:20,340 --> 00:01:24,150
start to have things like virtual

37
00:01:21,659 --> 00:01:25,920
functions in there because once you have

38
00:01:24,150 --> 00:01:28,280
things like virtual functions then the

39
00:01:25,920 --> 00:01:30,750
class actually has to have a thing in it

40
00:01:28,280 --> 00:01:33,359
potentially that lets it know what kind

41
00:01:30,750 --> 00:01:35,188
of of which class you actually

42
00:01:33,359 --> 00:01:36,750
instantiated so there's a thing called a

43
00:01:35,188 --> 00:01:38,158
V table pointer that gets shoved in

44
00:01:36,750 --> 00:01:40,140
there so basically the only thing that

45
00:01:38,159 --> 00:01:41,460
happens with C++ classes that doesn't

46
00:01:40,140 --> 00:01:43,049
happen with structs is the compiler

47
00:01:41,459 --> 00:01:44,368
starts inserting crap that you can't

48
00:01:43,049 --> 00:01:48,118
control it's one of the reasons I hate

49
00:01:44,368 --> 00:01:51,328
C++ actually is because the things they

50
00:01:48,118 --> 00:01:53,519
added all do stuff in a way that you

51
00:01:51,328 --> 00:01:55,949
can't control like I actually don't mind

52
00:01:53,519 --> 00:01:57,359
the concept of virtual functions it's

53
00:01:55,950 --> 00:01:58,978
really the implementation of virtual

54
00:01:57,359 --> 00:02:01,670
functions that I think is crappy so if

55
00:01:58,978 --> 00:02:04,109
C++ had instead been about building

56
00:02:01,670 --> 00:02:05,549
features that allow me to control how I

57
00:02:04,109 --> 00:02:07,140
wanted to do virtual dispatch I'd

58
00:02:05,549 --> 00:02:08,819
probably love it and I think that's

59
00:02:07,140 --> 00:02:10,229
hopefully sort of what Jon blows doing a

60
00:02:08,818 --> 00:02:11,759
little bit with his languages is going

61
00:02:10,229 --> 00:02:13,830
more like giving you the control to do

62
00:02:11,759 --> 00:02:17,459
those things and that would be better so

63
00:02:13,830 --> 00:02:18,960
you know yeah does the order of variable

64
00:02:17,460 --> 00:02:22,560
equations affect their memory packing

65
00:02:18,960 --> 00:02:25,290
yes basically instructs it always does

66
00:02:22,560 --> 00:02:27,270
so in a struct if you declare things in

67
00:02:25,289 --> 00:02:27,689
a particular order they have to go in

68
00:02:27,270 --> 00:02:28,890
that order

69
00:02:27,689 --> 00:02:30,120
they could be spaced however the

70
00:02:28,889 --> 00:02:34,319
compiler wants what they have to go in

71
00:02:30,120 --> 00:02:36,689
that order on the stack you know I'm not

72
00:02:34,319 --> 00:02:39,359
sure how much leeway the compiler gets

73
00:02:36,689 --> 00:02:40,620
on the stack I think like local

74
00:02:39,360 --> 00:02:42,810
variables to a function like when you

75
00:02:40,620 --> 00:02:45,450
declare things on the stack I don't know

76
00:02:42,810 --> 00:02:48,000
the compiler may be allowed to or to

77
00:02:45,449 --> 00:02:49,799
rearrange those I don't I don't know if

78
00:02:48,000 --> 00:02:51,659
it's under any particular obligation to

79
00:02:49,800 --> 00:02:53,490
keep the ordering that you have it might

80
00:02:51,659 --> 00:02:57,000
be but I'd have to read the spec to know

81
00:02:53,490 --> 00:02:58,800
for sure so I'm not sure show a

82
00:02:57,000 --> 00:02:59,340
segmentation error I will in the

83
00:02:58,800 --> 00:03:01,140
mainstream

84
00:02:59,340 --> 00:03:02,550
we will I'll show one whether we like it

85
00:03:01,139 --> 00:03:03,899
or not I'll make a mistake in the

86
00:03:02,550 --> 00:03:06,570
mainstream that causes us to seg fault

87
00:03:03,900 --> 00:03:08,459
at some point I guarantee it why are

88
00:03:06,569 --> 00:03:09,959
there 18 columns in the memory window

89
00:03:08,459 --> 00:03:11,550
the reason that there are eighteen

90
00:03:09,959 --> 00:03:15,060
columns is because that's how big it

91
00:03:11,550 --> 00:03:18,150
happened to be I'm pretty sure that

92
00:03:15,060 --> 00:03:21,090
actually if I just ran this code if I

93
00:03:18,150 --> 00:03:22,620
were to resize this this thing that

94
00:03:21,090 --> 00:03:24,629
would just give me more yeah it just

95
00:03:22,620 --> 00:03:26,069
gives me more columns and you can do

96
00:03:24,629 --> 00:03:28,859
things in the memory window like you can

97
00:03:26,069 --> 00:03:31,349
change it so that it's it's spaced by by

98
00:03:28,860 --> 00:03:34,709
eight byte things instead like these are

99
00:03:31,349 --> 00:03:36,689
64 bits at a time right and so I just

100
00:03:34,709 --> 00:03:38,370
had it on the the lowest kind which was

101
00:03:36,689 --> 00:03:39,870
one byte per so that we could see each

102
00:03:38,370 --> 00:03:41,909
individual byte of memory but you can

103
00:03:39,870 --> 00:03:43,379
hoist it up and see bigger things at

104
00:03:41,909 --> 00:03:45,780
once if you want to and this over here

105
00:03:43,379 --> 00:03:48,269
also shows you what the ASCII values are

106
00:03:45,780 --> 00:03:51,300
of things and so on and you can change

107
00:03:48,269 --> 00:03:53,340
that here like ANSI text Unicode text so

108
00:03:51,300 --> 00:03:54,330
okay so it is ANSI I always say ASCII

109
00:03:53,340 --> 00:03:56,069
because that's the encoding I think of

110
00:03:54,330 --> 00:03:58,170
but it's actually the ANSI standard

111
00:03:56,069 --> 00:04:00,449
which is ASCII and then revised or

112
00:03:58,169 --> 00:04:01,679
whatever so yeah that's the text of the

113
00:04:00,449 --> 00:04:06,719
slide you can change it to Unicode if

114
00:04:01,680 --> 00:04:08,069
you want etcetera etc let's see this was

115
00:04:06,719 --> 00:04:09,449
asking engine chapter for the stream why

116
00:04:08,069 --> 00:04:13,199
you use chair and short if they get pad

117
00:04:09,449 --> 00:04:17,069
to 32 bits like in anyway so the reason

118
00:04:13,199 --> 00:04:20,519
for that the reason that they are 32 bit

119
00:04:17,069 --> 00:04:21,810
ins is I'm sorry the reason that you

120
00:04:20,519 --> 00:04:26,280
might declare smell has a short instead

121
00:04:21,810 --> 00:04:27,600
of an int is because it's kind of trying

122
00:04:26,279 --> 00:04:30,539
to think of how to explain this

123
00:04:27,600 --> 00:04:32,640
so you will pack things sometimes and

124
00:04:30,540 --> 00:04:34,770
you will not know the size of things

125
00:04:32,639 --> 00:04:36,899
other times so typically what you're

126
00:04:34,769 --> 00:04:41,039
doing when you use care short and int is

127
00:04:36,899 --> 00:04:43,589
you're programming the logic of what you

128
00:04:41,040 --> 00:04:46,439
wanted and you're living the compiler

129
00:04:43,589 --> 00:04:50,729
more flexibility to do fancier stuff so

130
00:04:46,439 --> 00:04:52,259
for example let's say I was going to use

131
00:04:50,730 --> 00:04:54,240
things and I knew that none of them are

132
00:04:52,259 --> 00:04:56,219
going to be bigger than 16 bits then

133
00:04:54,240 --> 00:04:58,230
what I will do is I'll define them as

134
00:04:56,220 --> 00:05:00,180
short so the compiler knows I don't care

135
00:04:58,230 --> 00:05:02,129
about anything else so that if on a

136
00:05:00,180 --> 00:05:04,019
particular target platform it could pack

137
00:05:02,129 --> 00:05:07,379
them efficiently or do something more

138
00:05:04,019 --> 00:05:08,370
efficiently it will now there's a lot of

139
00:05:07,379 --> 00:05:10,589
places that this could come in handy

140
00:05:08,370 --> 00:05:12,449
right like you could imagine doing like

141
00:05:10,589 --> 00:05:13,859
wide sim D operations or something like

142
00:05:12,449 --> 00:05:15,060
this that could do eight at a time

143
00:05:13,860 --> 00:05:17,129
instead of four of a time because it

144
00:05:15,060 --> 00:05:19,319
knows our 16-bit instead of 32-bit you

145
00:05:17,129 --> 00:05:22,100
could imagine if this structure had no

146
00:05:19,319 --> 00:05:24,269
like let's say this structure had no

147
00:05:22,100 --> 00:05:25,650
things that were 32 bit so it thought it

148
00:05:24,269 --> 00:05:28,979
was only ever going to be working with

149
00:05:25,649 --> 00:05:30,750
32 with with 16-bit values it might

150
00:05:28,980 --> 00:05:34,040
decide to pack it differently I don't

151
00:05:30,750 --> 00:05:34,040
know we'll find out in a second here

152
00:05:34,610 --> 00:05:43,050
size of project yeah so you can see if

153
00:05:40,259 --> 00:05:44,759
there aren't any things like I think the

154
00:05:43,050 --> 00:05:47,040
convention typically and see and I don't

155
00:05:44,759 --> 00:05:49,589
know if this is is definitely the case

156
00:05:47,040 --> 00:05:51,090
in the spec or only optionally the case

157
00:05:49,589 --> 00:05:52,469
in the spec but something that typically

158
00:05:51,089 --> 00:05:54,929
happens with most C compilers that I've

159
00:05:52,470 --> 00:05:58,500
seen is if everything in a structure

160
00:05:54,930 --> 00:06:00,240
happens to be a like a certain like a

161
00:05:58,500 --> 00:06:02,129
certain size or smaller then that

162
00:06:00,240 --> 00:06:04,410
becomes the size for the packing so

163
00:06:02,129 --> 00:06:06,209
basically if I have you know one care

164
00:06:04,410 --> 00:06:08,670
and and three shorts or something in

165
00:06:06,209 --> 00:06:11,819
there right then typically it will pack

166
00:06:08,670 --> 00:06:13,199
a it will pack it down to two that to

167
00:06:11,819 --> 00:06:15,269
the size of shorts where the things are

168
00:06:13,199 --> 00:06:19,680
aligned is shorts and furthermore I

169
00:06:15,269 --> 00:06:24,000
believe that it's ordered so that the

170
00:06:19,680 --> 00:06:26,579
packing actually only only happens when

171
00:06:24,000 --> 00:06:29,610
things come after smaller things so I

172
00:06:26,579 --> 00:06:30,719
believe we can do even that potentially

173
00:06:29,610 --> 00:06:33,330
I don't actually know if this is true

174
00:06:30,720 --> 00:06:35,520
but I'm going to say here if this is if

175
00:06:33,329 --> 00:06:41,089
this is possible so I believe we can do

176
00:06:35,519 --> 00:06:41,089
something sort of like this

177
00:06:44,329 --> 00:06:47,329
oops

178
00:06:47,779 --> 00:06:58,948
doo-doo-doo sorry this is the perils and

179
00:06:52,379 --> 00:07:01,168
live coding ladies and gentlemen so you

180
00:06:58,949 --> 00:07:04,139
can see this is actually six so it's a

181
00:07:01,168 --> 00:07:05,909
short that's two bytes plus two bytes is

182
00:07:04,139 --> 00:07:08,910
four now if each of these were aligned

183
00:07:05,910 --> 00:07:10,439
at two bytes it would be six eight so he

184
00:07:08,910 --> 00:07:12,270
respected to be to be eight

185
00:07:10,439 --> 00:07:14,550
but you'll notice it's not it actually

186
00:07:12,269 --> 00:07:16,439
did pack it as essentially three shorts

187
00:07:14,550 --> 00:07:18,478
it did damage part one segment and then

188
00:07:16,439 --> 00:07:20,668
one and two each only got eight bits and

189
00:07:18,478 --> 00:07:22,829
the reason for that is it basically it

190
00:07:20,668 --> 00:07:25,049
seems like it typically only bumps up

191
00:07:22,829 --> 00:07:27,300
the alignment when you have something

192
00:07:25,050 --> 00:07:29,668
that follows so that the thing that

193
00:07:27,300 --> 00:07:32,280
follows will not be unaligned to its

194
00:07:29,668 --> 00:07:34,379
natural alignment whatever it is right

195
00:07:32,279 --> 00:07:36,089
so like if I go ahead and do this it

196
00:07:34,379 --> 00:07:37,319
should you know it should I would think

197
00:07:36,089 --> 00:07:39,029
bump it back up I don't know if actually

198
00:07:37,319 --> 00:07:40,228
did oh you know what it wouldn't because

199
00:07:39,029 --> 00:07:41,848
they're aligned properly so what I've

200
00:07:40,228 --> 00:07:44,759
actually what I'd actually have to do is

201
00:07:41,848 --> 00:07:46,348
that if I wanted it to be to be back to

202
00:07:44,759 --> 00:07:47,819
eight right and you can see that there

203
00:07:46,348 --> 00:07:48,899
and the reason for that is basically

204
00:07:47,819 --> 00:07:51,300
what the compiler is doing it's going

205
00:07:48,899 --> 00:07:54,239
okay I'm at the beginning a thing short

206
00:07:51,300 --> 00:07:55,740
that wants to be on two byte boundaries

207
00:07:54,240 --> 00:07:58,019
basically I'm trying to do it so that's

208
00:07:55,740 --> 00:07:59,819
fine to buy boundaries a care ok that

209
00:07:58,019 --> 00:08:02,038
can be one byte I'll make one byte then

210
00:07:59,819 --> 00:08:03,389
it goes oh this needs this is a 2-byte

211
00:08:02,038 --> 00:08:05,728
thing so I want to line out two byte

212
00:08:03,389 --> 00:08:07,470
boundary again but I'm off because this

213
00:08:05,728 --> 00:08:10,019
was only one byte so I'll add an extra

214
00:08:07,470 --> 00:08:11,820
byte of padding and then do it right and

215
00:08:10,019 --> 00:08:13,379
then when it gets to this one again it's

216
00:08:11,819 --> 00:08:15,478
going to do the the thing where it's got

217
00:08:13,379 --> 00:08:17,310
the one byte pad and then you know it

218
00:08:15,478 --> 00:08:18,719
pads out the end of the structure so I

219
00:08:17,310 --> 00:08:20,158
could sneak another one in here if I

220
00:08:18,720 --> 00:08:24,720
wanted to without changing the size from

221
00:08:20,158 --> 00:08:26,579
eight I suspect yeah I don't think I

222
00:08:24,720 --> 00:08:29,130
mean again I wouldn't care too much

223
00:08:26,579 --> 00:08:31,228
about the vagaries of this typically you

224
00:08:29,129 --> 00:08:33,389
know it matters when it matters and it

225
00:08:31,228 --> 00:08:34,799
doesn't most of the time so it's good to

226
00:08:33,389 --> 00:08:36,809
kind of know what happens there but when

227
00:08:34,799 --> 00:08:38,879
you actually care about how something is

228
00:08:36,809 --> 00:08:40,528
packed you almost always use the thing I

229
00:08:38,879 --> 00:08:42,330
just talked about where you turn off the

230
00:08:40,528 --> 00:08:43,740
compilers options and then you pack it

231
00:08:42,330 --> 00:08:45,420
yourself so you actually go in and

232
00:08:43,740 --> 00:08:47,730
actually say exactly how you want it and

233
00:08:45,419 --> 00:08:49,379
you turn off the the optional packing so

234
00:08:47,730 --> 00:08:50,610
I think that's how C packs things it may

235
00:08:49,379 --> 00:08:52,078
be in the spec because most compilers

236
00:08:50,610 --> 00:08:52,830
I've seen does that so it may be

237
00:08:52,078 --> 00:08:54,389
required

238
00:08:52,830 --> 00:08:55,770
does it that way but I don't really know

239
00:08:54,389 --> 00:08:59,990
if you want to know you should

240
00:08:55,769 --> 00:09:04,590
definitely check the the spec for see

241
00:08:59,990 --> 00:09:05,909
okay let's see in case you weren't aware

242
00:09:04,590 --> 00:09:07,740
the twitch stream doesn't stop when you

243
00:09:05,909 --> 00:09:08,939
kill the webcam video yes that is fine

244
00:09:07,740 --> 00:09:11,399
it's I'm not actually stopping the

245
00:09:08,940 --> 00:09:12,600
stream I'm stopping the recording of the

246
00:09:11,399 --> 00:09:13,980
stream because I post them in two

247
00:09:12,600 --> 00:09:15,570
different chunks that's all it's

248
00:09:13,980 --> 00:09:17,340
happening I leave the stream on so the

249
00:09:15,570 --> 00:09:18,750
stream is still going there's no

250
00:09:17,340 --> 00:09:20,509
shouldn't name be any break in the

251
00:09:18,750 --> 00:09:22,919
stream

252
00:09:20,509 --> 00:09:24,509
what is the arrow operator explain it

253
00:09:22,919 --> 00:09:25,500
yes I explained the arrow operator if

254
00:09:24,509 --> 00:09:26,990
you want to go back and watch the

255
00:09:25,500 --> 00:09:32,700
archived video hopefully that'll happen

256
00:09:26,990 --> 00:09:34,950
uh let's see I understand it do I is

257
00:09:32,700 --> 00:09:36,450
there any particular reason that the

258
00:09:34,950 --> 00:09:38,460
memory watch window shows 18 bytes per

259
00:09:36,450 --> 00:09:39,870
row okay covered that actually tries to

260
00:09:38,460 --> 00:09:41,639
any arbitrary but nevertheless little

261
00:09:39,870 --> 00:09:43,350
any nough seems backwards or at the very

262
00:09:41,639 --> 00:09:46,529
least harder for humans to interpret the

263
00:09:43,350 --> 00:09:48,389
byte code why didn't big envyus win okay

264
00:09:46,529 --> 00:09:49,860
so idiocracy is asking why didn't big

265
00:09:48,389 --> 00:09:51,509
endianness become the thing instead of

266
00:09:49,860 --> 00:09:53,009
little m unis conversely a sony is in a

267
00:09:51,509 --> 00:09:54,809
world where little nes is dominant in

268
00:09:53,009 --> 00:09:56,069
xa6 why would they make things harder

269
00:09:54,809 --> 00:10:01,889
for everyone by choosing big engines for

270
00:09:56,070 --> 00:10:03,390
the ps3 lot of stuff in that question so

271
00:10:01,889 --> 00:10:05,939
the first thing I would say is I don't

272
00:10:03,389 --> 00:10:08,250
know why big nd in this lost and little

273
00:10:05,940 --> 00:10:09,780
endianness one I can only hope that one

274
00:10:08,250 --> 00:10:11,909
is even the right term we don't know

275
00:10:09,779 --> 00:10:13,439
there could be a ton of little endian I

276
00:10:11,909 --> 00:10:15,059
mean a ton of big endian machines that

277
00:10:13,440 --> 00:10:15,930
are about to come out who knows i really

278
00:10:15,059 --> 00:10:17,309
hope we're done with that and

279
00:10:15,929 --> 00:10:20,099
everything's little-endian from now on

280
00:10:17,309 --> 00:10:21,750
but what I'm going to do so the reason I

281
00:10:20,100 --> 00:10:23,519
think it one is probably just because

282
00:10:21,750 --> 00:10:24,720
hey that's what arm and Intel are that's

283
00:10:23,519 --> 00:10:26,250
what maybe that's what Intel happened to

284
00:10:24,720 --> 00:10:29,610
do which is very prevalent so when arm

285
00:10:26,250 --> 00:10:31,620
started being used for like phone os's

286
00:10:29,610 --> 00:10:35,430
they just picked that because both Apple

287
00:10:31,620 --> 00:10:37,500
and both both Apple and the PC market

288
00:10:35,429 --> 00:10:38,819
we're all on little endian and so they

289
00:10:37,500 --> 00:10:42,600
probably figured oh and just be easier

290
00:10:38,820 --> 00:10:44,879
to use the same nd in this on our phones

291
00:10:42,600 --> 00:10:46,230
operating systems as we do on the other

292
00:10:44,879 --> 00:10:47,580
thing because I think arm like I said I

293
00:10:46,230 --> 00:10:49,470
think arm is a switchable architecture I

294
00:10:47,580 --> 00:10:51,300
think you can choose what endianness you

295
00:10:49,470 --> 00:10:52,379
want to build it as when you actually

296
00:10:51,299 --> 00:10:54,120
design it when you license the

297
00:10:52,379 --> 00:10:55,500
architecture from them so I think it

298
00:10:54,120 --> 00:10:58,350
could have gone big I mean but it didn't

299
00:10:55,500 --> 00:11:00,720
and thank God for that so basically we

300
00:10:58,350 --> 00:11:02,040
have little endian now everywhere Wyatt

301
00:11:00,720 --> 00:11:03,930
won I think it probably was just because

302
00:11:02,039 --> 00:11:05,459
of x86 I expect this because what it's

303
00:11:03,929 --> 00:11:06,479
what was on all the desktop machines I

304
00:11:05,460 --> 00:11:08,879
don't know that there's any

305
00:11:06,480 --> 00:11:12,420
particular reason why it's better what I

306
00:11:08,879 --> 00:11:15,629
will say is that the reason why it's a

307
00:11:12,419 --> 00:11:16,679
little bit nicer even as a programmer

308
00:11:15,629 --> 00:11:18,720
and I know you said it's a little more

309
00:11:16,679 --> 00:11:21,299
confusing to read the reason it's nicer

310
00:11:18,720 --> 00:11:24,600
even as a programmer to me is that you

311
00:11:21,299 --> 00:11:27,659
can cast things properly and they would

312
00:11:24,600 --> 00:11:29,490
they they will work so for example let's

313
00:11:27,659 --> 00:11:32,009
say I've got something just to give a

314
00:11:29,490 --> 00:11:35,129
really simple quick example let's say I

315
00:11:32,009 --> 00:11:39,149
have something that is an int and I say

316
00:11:35,129 --> 00:11:41,309
int x equals 16 or something right now

317
00:11:39,149 --> 00:11:43,740
16 fits in a byte just fine

318
00:11:41,309 --> 00:11:47,669
so let's say I now have I want to do

319
00:11:43,740 --> 00:11:51,060
short y equals equals you know this ooh

320
00:11:47,669 --> 00:11:54,000
ah I have no idea what hotkey I just hit

321
00:11:51,059 --> 00:11:56,000
but holy crap that is crazy it's now

322
00:11:54,000 --> 00:11:57,870
showing me like non-printable characters

323
00:11:56,000 --> 00:11:58,980
how do I make it go away

324
00:11:57,870 --> 00:12:02,459
all right I don't know we'll deal with

325
00:11:58,980 --> 00:12:03,659
that later but yeah yeah I do not know

326
00:12:02,458 --> 00:12:06,659
this editor in case you couldn't tell

327
00:12:03,659 --> 00:12:09,179
so if I want to cast this value if I'm

328
00:12:06,659 --> 00:12:11,309
going to cast X to a short right and

329
00:12:09,179 --> 00:12:13,078
then I want to have a care and it's even

330
00:12:11,309 --> 00:12:15,388
smaller and so I want to cast you know

331
00:12:13,078 --> 00:12:18,328
to that I'm going to keep casting these

332
00:12:15,389 --> 00:12:19,829
things right like that now we all know

333
00:12:18,328 --> 00:12:21,750
we've covered very extensively that that

334
00:12:19,828 --> 00:12:23,429
I can I can easily fit eight bits of

335
00:12:21,750 --> 00:12:25,049
data into an int I can easily fit eight

336
00:12:23,429 --> 00:12:27,539
bits of data into a short I can easily

337
00:12:25,049 --> 00:12:29,969
fit bits of data into a care because it

338
00:12:27,539 --> 00:12:32,039
carries eight short is 16 and into 32

339
00:12:29,970 --> 00:12:34,019
but when I do these casting I'm

340
00:12:32,039 --> 00:12:36,208
essentially lopping off parts of the

341
00:12:34,019 --> 00:12:38,789
value technically even though I only

342
00:12:36,208 --> 00:12:41,068
used the bottom eight bits I technically

343
00:12:38,789 --> 00:12:42,929
had 24 extra bits in this integer right

344
00:12:41,068 --> 00:12:44,759
so what this does is this lops off the

345
00:12:42,929 --> 00:12:48,328
top 16 bits what this does it lops off

346
00:12:44,759 --> 00:12:49,948
the top 24 bits right so what we would

347
00:12:48,328 --> 00:12:53,909
expect to see is that all of these

348
00:12:49,948 --> 00:12:54,740
values are equal to 16 correct here we

349
00:12:53,909 --> 00:12:59,009
go

350
00:12:54,740 --> 00:13:01,049
X Y Z all equal to 16 all good right

351
00:12:59,009 --> 00:13:03,179
that'll work just fine on a big-endian

352
00:13:01,049 --> 00:13:06,419
or little-endian architecture right but

353
00:13:03,179 --> 00:13:08,789
what is a little trickier is if I were

354
00:13:06,419 --> 00:13:12,419
to have a pointer to memory so let's say

355
00:13:08,789 --> 00:13:15,448
I have int star X well in star X pointer

356
00:13:12,419 --> 00:13:19,049
let's say equals the address of X right

357
00:13:15,448 --> 00:13:19,859
if I now go and say I want a short

358
00:13:19,049 --> 00:13:22,229
pointer of

359
00:13:19,860 --> 00:13:26,490
Poynter to do that and I'm going to cast

360
00:13:22,230 --> 00:13:29,339
it like this right if I were on a big

361
00:13:26,490 --> 00:13:31,350
endian architecture right what has to

362
00:13:29,339 --> 00:13:33,079
happen here and think about it think

363
00:13:31,350 --> 00:13:35,459
about it carefully I don't want any

364
00:13:33,078 --> 00:13:37,078
shoddy thinking about it here when I say

365
00:13:35,458 --> 00:13:40,708
think about it I want the real full

366
00:13:37,078 --> 00:13:42,088
thinking about it right on this little

367
00:13:40,708 --> 00:13:43,649
endian architecture the pointers are the

368
00:13:42,089 --> 00:13:44,820
same and the reason the pointers are the

369
00:13:43,649 --> 00:13:47,039
same is because we're pointing to the

370
00:13:44,820 --> 00:13:48,600
smallest value so if I cast from a

371
00:13:47,039 --> 00:13:50,669
bigger value down to a smaller one

372
00:13:48,600 --> 00:13:53,190
there isn't any work to actually be done

373
00:13:50,669 --> 00:13:55,078
it's the same pointer I'm just reading

374
00:13:53,190 --> 00:13:56,490
less values instead of reading four

375
00:13:55,078 --> 00:13:58,859
values at that pointer address I'm

376
00:13:56,490 --> 00:14:01,680
reading two in a big endian architecture

377
00:13:58,860 --> 00:14:03,180
I couldn't have done that and the reason

378
00:14:01,679 --> 00:14:05,819
is because the pointer is pointing to

379
00:14:03,179 --> 00:14:07,439
the largest value I'm lopping off that

380
00:14:05,820 --> 00:14:09,690
value so I can't keep the pointer there

381
00:14:07,440 --> 00:14:11,850
so when I cast it down to a smaller

382
00:14:09,690 --> 00:14:13,709
pointer if I wanted to get the same

383
00:14:11,850 --> 00:14:15,269
value if I want to point to the right

384
00:14:13,708 --> 00:14:17,518
digits I'd have to move the pointer

385
00:14:15,269 --> 00:14:19,860
forward by two bytes in order to get it

386
00:14:17,519 --> 00:14:21,389
does that make sense so I don't love

387
00:14:19,860 --> 00:14:22,528
that I don't love the fact that you have

388
00:14:21,389 --> 00:14:23,819
to do that in bighetti and so I don't

389
00:14:22,528 --> 00:14:25,049
super like that I've heard other people

390
00:14:23,820 --> 00:14:26,910
say that that's actually better because

391
00:14:25,049 --> 00:14:28,679
it helps you eliminate bugs or some I

392
00:14:26,909 --> 00:14:30,028
don't know I don't have a strong opinion

393
00:14:28,679 --> 00:14:31,679
bottom either way but honestly I like

394
00:14:30,028 --> 00:14:34,528
the little endian and I don't have a

395
00:14:31,679 --> 00:14:36,569
trouble reading it so you know I'm a fan

396
00:14:34,528 --> 00:14:39,419
I'm her little Indian I'm glad that's

397
00:14:36,570 --> 00:14:41,100
the one but you know do I do I really

398
00:14:39,419 --> 00:14:43,439
care about it either way not that much

399
00:14:41,100 --> 00:14:45,449
I'm just happy to have I just prefer we

400
00:14:43,440 --> 00:14:46,649
always always have just one so that

401
00:14:45,448 --> 00:14:48,208
we're always on the land unit or

402
00:14:46,649 --> 00:14:50,129
big-endian whichever the prevalent one

403
00:14:48,208 --> 00:14:54,359
is now finally why did they pick it for

404
00:14:50,129 --> 00:14:56,549
the ps3 don't know honestly the reason

405
00:14:54,360 --> 00:15:01,940
that they chose the processors for the

406
00:14:56,549 --> 00:15:04,409
ps3 and the the ps3 processor and the

407
00:15:01,940 --> 00:15:07,079
xbox360 processor were chosen largely

408
00:15:04,409 --> 00:15:09,629
for economic reasons I believe I think

409
00:15:07,078 --> 00:15:12,958
it was mostly that Intel did not offer a

410
00:15:09,629 --> 00:15:18,208
processor option for as low a cost as

411
00:15:12,958 --> 00:15:20,549
IBM Motorola that sort of the consortium

412
00:15:18,208 --> 00:15:21,958
that was making the power pcs and so I

413
00:15:20,549 --> 00:15:23,969
think it was really just an economic

414
00:15:21,958 --> 00:15:25,889
decision and those happen to be little

415
00:15:23,970 --> 00:15:27,570
endian so I don't think I think it was

416
00:15:25,889 --> 00:15:30,028
basically like the economics trumped

417
00:15:27,570 --> 00:15:31,890
perhaps the ease of use of it and I also

418
00:15:30,028 --> 00:15:33,240
think at that time Sony was maybe a

419
00:15:31,889 --> 00:15:38,639
little less concerned

420
00:15:33,240 --> 00:15:40,709
about the the barrier to entry that is

421
00:15:38,639 --> 00:15:43,588
posed by them making odd decisions on

422
00:15:40,708 --> 00:15:45,359
their platforms and same perhaps with

423
00:15:43,589 --> 00:15:46,529
Microsoft to some extent and I think

424
00:15:45,360 --> 00:15:48,870
both of them are a lot more conscious

425
00:15:46,528 --> 00:15:50,338
now about how important it is that

426
00:15:48,870 --> 00:15:51,959
programmers be able to just use the same

427
00:15:50,339 --> 00:15:53,279
code that they were using and the least

428
00:15:51,958 --> 00:15:54,750
amount of hassle to get things onto a

429
00:15:53,278 --> 00:15:56,309
platform I think they're kind of aware

430
00:15:54,750 --> 00:15:58,019
that that's important now because in the

431
00:15:56,309 --> 00:16:01,559
old days console programming was a lot

432
00:15:58,019 --> 00:16:03,059
about programming everything 100% custom

433
00:16:01,559 --> 00:16:05,429
for a console and getting every last bit

434
00:16:03,059 --> 00:16:07,289
out of it but nowadays you know consoles

435
00:16:05,429 --> 00:16:10,439
are so powerful and PCs are so powerful

436
00:16:07,289 --> 00:16:13,620
that there's a lot of stuff that's about

437
00:16:10,440 --> 00:16:14,580
whether the game was good and if someone

438
00:16:13,620 --> 00:16:15,629
makes a great game but doesn't

439
00:16:14,580 --> 00:16:17,100
necessarily know how to program on a

440
00:16:15,629 --> 00:16:18,539
console very well and they can't get the

441
00:16:17,100 --> 00:16:19,950
thing to your console or it takes too

442
00:16:18,539 --> 00:16:22,289
long or it means that less games are

443
00:16:19,950 --> 00:16:24,720
ported to it that can be mean that you

444
00:16:22,289 --> 00:16:27,990
lose the war that console generation

445
00:16:24,720 --> 00:16:29,850
right so I think console vendors are a

446
00:16:27,990 --> 00:16:31,320
lot more aware now that like there's

447
00:16:29,850 --> 00:16:32,700
people making games who maybe don't know

448
00:16:31,320 --> 00:16:34,800
how to optimize something for a console

449
00:16:32,700 --> 00:16:36,209
and they just don't make games that have

450
00:16:34,799 --> 00:16:37,679
the kinds of things in them that you

451
00:16:36,208 --> 00:16:39,328
would need to know how to do that

452
00:16:37,679 --> 00:16:40,588
optimization for and that's fine and

453
00:16:39,328 --> 00:16:41,879
again even though I'm about to teach a

454
00:16:40,589 --> 00:16:43,320
thing that's about how to do all those

455
00:16:41,879 --> 00:16:47,370
kinds of crazy optimizations and stuff

456
00:16:43,320 --> 00:16:48,540
uh you know while I think programmers

457
00:16:47,370 --> 00:16:50,278
who are serious about programming should

458
00:16:48,539 --> 00:16:52,919
know how to do a lot of that stuff it

459
00:16:50,278 --> 00:16:54,689
doesn't necessarily mean that people all

460
00:16:52,919 --> 00:16:56,729
have to know it and game designers who

461
00:16:54,690 --> 00:16:58,110
can only just barely program they can

462
00:16:56,730 --> 00:17:00,720
make great games too and all that stuff

463
00:16:58,110 --> 00:17:01,980
is true so while I'm really into the

464
00:17:00,720 --> 00:17:03,000
low-level stuff and want to teach a

465
00:17:01,980 --> 00:17:05,429
bunch of that stuff as part of the

466
00:17:03,000 --> 00:17:08,220
course it's also true that that's not

467
00:17:05,429 --> 00:17:10,110
the only way that things can go and so I

468
00:17:08,220 --> 00:17:12,900
think that nowadays I think people who

469
00:17:10,109 --> 00:17:14,609
ship platforms appreciate that there's

470
00:17:12,900 --> 00:17:16,920
all sorts of programmers out there and

471
00:17:14,609 --> 00:17:19,049
the best course of action is usually to

472
00:17:16,920 --> 00:17:19,890
enable them all you want to have the

473
00:17:19,049 --> 00:17:22,139
people who are give you the crazy

474
00:17:19,890 --> 00:17:23,520
awesome tech stuff on your platform and

475
00:17:22,140 --> 00:17:25,079
you also want the people who like barely

476
00:17:23,519 --> 00:17:27,000
only know how to code but hey they had a

477
00:17:25,078 --> 00:17:28,678
good idea and did an interesting game or

478
00:17:27,000 --> 00:17:30,269
something or even they're just an artist

479
00:17:28,679 --> 00:17:31,860
and it's not about a game or game design

480
00:17:30,269 --> 00:17:33,660
it's about an interesting art project

481
00:17:31,859 --> 00:17:35,159
sort of that's pretty and cool

482
00:17:33,660 --> 00:17:36,779
those are good to have too and so I

483
00:17:35,160 --> 00:17:38,308
think maybe nowadays they appreciate it

484
00:17:36,779 --> 00:17:39,869
but in the ps3 days they were just

485
00:17:38,308 --> 00:17:41,730
coming off the ps2 where they totally

486
00:17:39,869 --> 00:17:43,439
reign supreme no questions so I don't

487
00:17:41,730 --> 00:17:45,299
think it was really on their radar of

488
00:17:43,440 --> 00:17:47,720
thinking to go what will be easy for

489
00:17:45,299 --> 00:17:47,720
people

490
00:17:47,920 --> 00:17:52,670
let's take a look here sorry if I missed

491
00:17:50,869 --> 00:17:54,199
it but aren't the sizes of short int and

492
00:17:52,670 --> 00:17:55,519
long determined by the CPU and memory

493
00:17:54,200 --> 00:17:58,519
architecture rather than always being

494
00:17:55,519 --> 00:18:00,799
16-bit story to bits etc yes technically

495
00:17:58,519 --> 00:18:03,289
they are just not on anything that we

496
00:18:00,799 --> 00:18:05,329
work on so it used to be the case that

497
00:18:03,289 --> 00:18:06,920
they would be quite variable nowadays on

498
00:18:05,329 --> 00:18:09,500
everything you program they are exactly

499
00:18:06,920 --> 00:18:12,620
what I said they were 8 bit 16 bits 32

500
00:18:09,500 --> 00:18:14,000
bits so yes it is true that they could

501
00:18:12,619 --> 00:18:16,099
be changed if you were on an

502
00:18:14,000 --> 00:18:19,009
architecture in the future some kind of

503
00:18:16,099 --> 00:18:20,659
future machine but on the architectures

504
00:18:19,009 --> 00:18:26,539
that we will be using they are always

505
00:18:20,660 --> 00:18:27,830
these sizes after the pragma on the

506
00:18:26,539 --> 00:18:30,859
struct you could rearrange the equation

507
00:18:27,829 --> 00:18:33,799
so it's 11 bytes but on three of the

508
00:18:30,859 --> 00:18:35,539
four 32-bit boundaries in sorry sorry

509
00:18:33,799 --> 00:18:36,129
Jimmy I don't totally understand that

510
00:18:35,539 --> 00:18:38,299
question

511
00:18:36,130 --> 00:18:39,680
after the pragma basically will do

512
00:18:38,299 --> 00:18:41,569
exactly what you tell it so it will

513
00:18:39,680 --> 00:18:43,279
basically reserve only exactly the space

514
00:18:41,569 --> 00:18:44,720
that you tell it so if you say int it

515
00:18:43,279 --> 00:18:46,879
will go 4 bytes forward if you say short

516
00:18:44,720 --> 00:18:50,180
logo 2 bytes forward regardless of what

517
00:18:46,880 --> 00:18:51,800
it would have done otherwise how do I

518
00:18:50,180 --> 00:18:55,460
feel about functional programming I

519
00:18:51,799 --> 00:18:57,500
don't feel much about it I don't do a

520
00:18:55,460 --> 00:18:58,549
lot of functional programming is there a

521
00:18:57,500 --> 00:18:59,960
difference between combining multiple

522
00:18:58,549 --> 00:19:01,399
statements into a single line the

523
00:18:59,960 --> 00:19:03,680
resulting code or is it just to save on

524
00:19:01,400 --> 00:19:06,110
typing mostly it's just to save on

525
00:19:03,680 --> 00:19:08,000
typing although C has requirements about

526
00:19:06,109 --> 00:19:09,439
what is and is not an expression and

527
00:19:08,000 --> 00:19:11,750
what isn't is not a statement so there's

528
00:19:09,440 --> 00:19:15,559
a limit to how much you can combine on a

529
00:19:11,750 --> 00:19:19,220
single line for example a for loop or an

530
00:19:15,559 --> 00:19:20,720
if statement can't really like there's

531
00:19:19,220 --> 00:19:22,039
things I'm having a really give an

532
00:19:20,720 --> 00:19:23,930
example because it's not a great example

533
00:19:22,039 --> 00:19:26,000
now think about it but it's it's a

534
00:19:23,930 --> 00:19:27,560
little wonky like expression oriented

535
00:19:26,000 --> 00:19:29,029
things like adding things and casting

536
00:19:27,559 --> 00:19:30,259
things you can glom rate as much as you

537
00:19:29,029 --> 00:19:31,819
want but there's other things that

538
00:19:30,259 --> 00:19:33,170
aren't quite that way and so there are

539
00:19:31,819 --> 00:19:34,970
places where you kind of have to break

540
00:19:33,170 --> 00:19:36,320
you have to break this it into multiple

541
00:19:34,970 --> 00:19:41,569
statements because of the way it's

542
00:19:36,319 --> 00:19:42,950
written is there a particular reason you

543
00:19:41,569 --> 00:19:44,779
cast a projectile pour into a Kara

544
00:19:42,950 --> 00:19:47,480
pointer instead of an int yes the reason

545
00:19:44,779 --> 00:19:49,190
is because I was trying to add bytes so

546
00:19:47,480 --> 00:19:51,860
the reason that I casted it to an int is

547
00:19:49,190 --> 00:19:54,890
because I did this expression I did size

548
00:19:51,859 --> 00:19:58,579
of projectile I was trying to add this

549
00:19:54,890 --> 00:19:59,509
amount so I said like the pointer it was

550
00:19:58,579 --> 00:20:03,379
a you know care

551
00:19:59,509 --> 00:20:04,730
to our pointer right I did something

552
00:20:03,380 --> 00:20:06,470
like this I had a projectile pointer I

553
00:20:04,730 --> 00:20:09,170
cast it to a Kara star and I added three

554
00:20:06,470 --> 00:20:12,559
times the size of projectile size of is

555
00:20:09,170 --> 00:20:14,810
always returned in bytes so if I am

556
00:20:12,559 --> 00:20:16,879
adding 30 times the size of that I have

557
00:20:14,809 --> 00:20:19,220
to cast to a pointer that's eight bits

558
00:20:16,880 --> 00:20:22,280
that's one byte long otherwise this math

559
00:20:19,220 --> 00:20:25,279
is wrong if I had instead cast it to a

560
00:20:22,279 --> 00:20:27,589
short then I would need to divide this

561
00:20:25,279 --> 00:20:29,420
value by two because I'm going this

562
00:20:27,589 --> 00:20:30,889
pointer when I add whatever the number I

563
00:20:29,420 --> 00:20:32,690
add is will be multiplied by two

564
00:20:30,890 --> 00:20:35,690
remember I said whatever the pointer

565
00:20:32,690 --> 00:20:37,850
type is see adds that multiplication in

566
00:20:35,690 --> 00:20:39,710
there for you it adds see adds this

567
00:20:37,849 --> 00:20:41,419
hidden times two if it's a short if it

568
00:20:39,710 --> 00:20:43,400
was an int it would add a hidden times

569
00:20:41,420 --> 00:20:44,960
four so I would have to divide by four

570
00:20:43,400 --> 00:20:46,940
so what I wanted to do is just do the

571
00:20:44,960 --> 00:20:48,620
simplest possible thing which is go okay

572
00:20:46,940 --> 00:20:50,360
one byte is what we're on so you will

573
00:20:48,619 --> 00:20:51,759
now just literally add the value I told

574
00:20:50,359 --> 00:20:58,479
you without doing a hidden multiple

575
00:20:51,759 --> 00:21:01,759
multiplier and that's what that was um

576
00:20:58,480 --> 00:21:04,549
doot-doot-doot is there a difference

577
00:21:01,759 --> 00:21:06,230
between cabaÃ±as I don't know about the

578
00:21:04,549 --> 00:21:07,879
packing I'm pretty sure it just puts the

579
00:21:06,230 --> 00:21:10,370
variable at an address in memory that is

580
00:21:07,880 --> 00:21:12,350
a multiple of that variable size yes

581
00:21:10,369 --> 00:21:15,139
that's sort of what I kind of went over

582
00:21:12,349 --> 00:21:19,279
or tried to say but maybe that's not how

583
00:21:15,140 --> 00:21:20,600
it came across to do maybe I'm

584
00:21:19,279 --> 00:21:27,379
misunderstanding it sounds like you guys

585
00:21:20,599 --> 00:21:30,619
kind of worked us out a little bit short

586
00:21:27,380 --> 00:21:33,500
care int care will be so I don't

587
00:21:30,619 --> 00:21:35,359
understand that one brain Cruiser will

588
00:21:33,500 --> 00:21:37,009
QA continue when you start the main

589
00:21:35,359 --> 00:21:39,379
series yes there will always be a QA

590
00:21:37,009 --> 00:21:40,879
after the main series I'm new here what

591
00:21:39,380 --> 00:21:42,890
is the goal of your stream and are you

592
00:21:40,880 --> 00:21:46,910
streaming stuff like this again yes go

593
00:21:42,890 --> 00:21:50,720
to if you want to see the full action go

594
00:21:46,910 --> 00:21:52,310
to handmade jirobo RG and you can see

595
00:21:50,720 --> 00:21:53,779
the whole faq and everything there and

596
00:21:52,309 --> 00:21:57,109
that'll tell you what the stream is and

597
00:21:53,779 --> 00:21:58,789
when the stream is if pointers are

598
00:21:57,109 --> 00:22:00,709
always pointing to one byte why are

599
00:21:58,789 --> 00:22:03,349
there why are there ever any types

600
00:22:00,710 --> 00:22:07,039
besides unsigned care so the answer is

601
00:22:03,349 --> 00:22:09,349
again just convenience an our kid the

602
00:22:07,039 --> 00:22:11,089
reason for that is that C was trying to

603
00:22:09,349 --> 00:22:12,559
help you out it's trying to basically do

604
00:22:11,089 --> 00:22:13,339
a little hidden multiplication for you

605
00:22:12,559 --> 00:22:15,079
there so that you know

606
00:22:13,339 --> 00:22:16,879
that you're always kind of moving by the

607
00:22:15,079 --> 00:22:18,470
right amount and we will use that to our

608
00:22:16,880 --> 00:22:20,990
advantage to kind of eliminate some

609
00:22:18,470 --> 00:22:22,279
typing in the mainstream so it's good

610
00:22:20,990 --> 00:22:24,200
that it allows you to point to other

611
00:22:22,279 --> 00:22:25,789
values so yeah even though they always

612
00:22:24,200 --> 00:22:27,529
point to the first byte anyway

613
00:22:25,789 --> 00:22:29,480
conceptually they may be pointing to a

614
00:22:27,529 --> 00:22:30,829
larger thing like a projectile and you

615
00:22:29,480 --> 00:22:32,599
want the convenience of being able to

616
00:22:30,829 --> 00:22:34,159
say like just add one go to the next

617
00:22:32,599 --> 00:22:36,230
projectile I don't want to constantly

618
00:22:34,160 --> 00:22:37,820
add to type plus size of projectile I

619
00:22:36,230 --> 00:22:42,860
want be able to just type plus one and

620
00:22:37,819 --> 00:22:45,349
go to the next one couldn't it also be

621
00:22:42,859 --> 00:22:47,000
to make emulation harder

622
00:22:45,349 --> 00:22:48,169
oh so you talked about the platform's it

623
00:22:47,000 --> 00:22:49,430
might have been I don't know I doubt

624
00:22:48,170 --> 00:22:54,430
that was really a concern but maybe

625
00:22:49,430 --> 00:22:57,740
yesterday you said why oh I plant to use

626
00:22:54,430 --> 00:22:59,120
Visual Studio for debugging only we what

627
00:22:57,740 --> 00:22:59,720
we'll use instead and since I am more

628
00:22:59,119 --> 00:23:00,949
used to it

629
00:22:59,720 --> 00:23:02,420
well the vigil so you can power make it

630
00:23:00,950 --> 00:23:04,160
harder to go with you oh I'm sure you're

631
00:23:02,420 --> 00:23:05,840
saying no I will I will still be using

632
00:23:04,160 --> 00:23:07,279
visual Studios compiler and debugger so

633
00:23:05,839 --> 00:23:08,419
what we've been doing will be basically

634
00:23:07,279 --> 00:23:09,649
the same in the mainstream the only

635
00:23:08,420 --> 00:23:10,430
difference is I'll be editing in good

636
00:23:09,650 --> 00:23:11,930
new Emacs

637
00:23:10,430 --> 00:23:15,860
the reason I added in that is I'm more

638
00:23:11,930 --> 00:23:17,570
comfortable that as the editor and I it

639
00:23:15,859 --> 00:23:19,279
works on all the platforms so when I'm

640
00:23:17,569 --> 00:23:20,569
programming when I show how to do the

641
00:23:19,279 --> 00:23:23,329
platform startup code on Mac and on

642
00:23:20,569 --> 00:23:24,679
Linux you'll still see the same Emacs so

643
00:23:23,329 --> 00:23:25,759
it'll be nice and consistent in that way

644
00:23:24,680 --> 00:23:27,890
I don't have to learn like each

645
00:23:25,759 --> 00:23:29,180
individual platforms thing like I don't

646
00:23:27,890 --> 00:23:31,160
when I go to program Mac I can still

647
00:23:29,180 --> 00:23:32,600
just use Emacs which I like since I've

648
00:23:31,160 --> 00:23:33,890
done a lot of cross-platform coding in

649
00:23:32,599 --> 00:23:36,079
the past I've done a lot of work on

650
00:23:33,890 --> 00:23:39,710
other platforms I program on Linux every

651
00:23:36,079 --> 00:23:41,269
day in fact even today so Linux I like

652
00:23:39,710 --> 00:23:42,470
having the same editor on Linux as I

653
00:23:41,269 --> 00:23:43,879
have on Windows so I don't have to

654
00:23:42,470 --> 00:23:46,430
relearn editor shortcuts and stuff like

655
00:23:43,880 --> 00:23:48,920
that for every platform similar to what

656
00:23:46,430 --> 00:23:50,660
are these D word word Q word things in

657
00:23:48,920 --> 00:23:53,000
the win32 api I know they're type test

658
00:23:50,660 --> 00:23:55,720
so I guess I'm asking why they exist so

659
00:23:53,000 --> 00:23:59,089
the reason they exist is because

660
00:23:55,720 --> 00:24:01,579
actually the the question that was asked

661
00:23:59,089 --> 00:24:02,720
earlier about intz being you know aren't

662
00:24:01,579 --> 00:24:05,000
they sort of platform dependent the

663
00:24:02,720 --> 00:24:06,920
answer is exactly that when windows

664
00:24:05,000 --> 00:24:08,660
started everything wasn't the same size

665
00:24:06,920 --> 00:24:11,360
so there are platforms where things were

666
00:24:08,660 --> 00:24:12,769
16 bits an integer would be 16 bits and

667
00:24:11,359 --> 00:24:14,119
platform at least I believe that's true

668
00:24:12,769 --> 00:24:15,589
don't quote me on that but I thought

669
00:24:14,119 --> 00:24:17,359
that was true that the standard size on

670
00:24:15,589 --> 00:24:20,299
16-bit windows might have been 16-bit

671
00:24:17,359 --> 00:24:21,979
and then the standard size of an int

672
00:24:20,299 --> 00:24:23,930
when they went to 32-bit windows became

673
00:24:21,980 --> 00:24:24,829
32-bit and so what they needed to do was

674
00:24:23,930 --> 00:24:26,750
make sure that those sizes were

675
00:24:24,829 --> 00:24:27,980
consistent depending on which

676
00:24:26,750 --> 00:24:31,819
kind of code was being compiled so they

677
00:24:27,980 --> 00:24:34,279
wanted to say Oh a word is 16 a D word

678
00:24:31,819 --> 00:24:36,559
is 32 always no matter what you're

679
00:24:34,279 --> 00:24:38,420
compiling on and so we'll see that in

680
00:24:36,559 --> 00:24:40,669
the mainstream I will actually define my

681
00:24:38,420 --> 00:24:42,800
own types to make sure we can always get

682
00:24:40,670 --> 00:24:44,090
the amount that we want so yeah you'll

683
00:24:42,799 --> 00:24:44,990
see a little bit more about that we'll

684
00:24:44,089 --> 00:24:50,569
cover that a little more detail but

685
00:24:44,990 --> 00:24:51,769
that's why they did it in Windows not

686
00:24:50,569 --> 00:24:54,200
really directed related to the cognitive

687
00:24:51,769 --> 00:24:55,460
stream but do you think C++ has beaten C

688
00:24:54,200 --> 00:24:57,799
as this android game programming and if

689
00:24:55,460 --> 00:25:01,130
so why given your preference for C and

690
00:24:57,799 --> 00:25:02,180
John's very builders like f C++ yeah C++

691
00:25:01,130 --> 00:25:03,470
is typically what's using game

692
00:25:02,180 --> 00:25:06,350
programming and people use it to varying

693
00:25:03,470 --> 00:25:08,839
degrees I even I don't really like C++

694
00:25:06,349 --> 00:25:11,539
very much but I still compiled in cpsc

695
00:25:08,839 --> 00:25:12,829
PPS in C++ because there are some

696
00:25:11,539 --> 00:25:14,180
features as us less that I do take

697
00:25:12,829 --> 00:25:16,369
advantage of from time to time and

698
00:25:14,180 --> 00:25:19,549
you'll see me do that in the mainstream

699
00:25:16,369 --> 00:25:20,779
and so so I definitely think C++ is what

700
00:25:19,549 --> 00:25:22,849
people use in game pregnant even people

701
00:25:20,779 --> 00:25:27,019
who like me who program mostly C like

702
00:25:22,849 --> 00:25:27,289
still usually use C++ if that makes

703
00:25:27,019 --> 00:25:29,150
sense

704
00:25:27,289 --> 00:25:30,889
so so there's really no reason not to

705
00:25:29,150 --> 00:25:32,480
use C++ and that may be the reason the

706
00:25:30,890 --> 00:25:33,920
main reason that it was beat that beat C

707
00:25:32,480 --> 00:25:35,299
is because it's only adding features and

708
00:25:33,920 --> 00:25:37,730
you can choose not to use ones that you

709
00:25:35,299 --> 00:25:39,169
don't like how do you psychologically

710
00:25:37,730 --> 00:25:40,190
deal with not having visceral results or

711
00:25:39,170 --> 00:25:43,490
something you've been programming for a

712
00:25:40,190 --> 00:25:45,799
long time uh well that's interesting

713
00:25:43,490 --> 00:25:47,539
question I usually try to make little

714
00:25:45,799 --> 00:25:48,889
things along the way and like the stuff

715
00:25:47,539 --> 00:25:50,180
that I was showing you in here where we

716
00:25:48,890 --> 00:25:51,920
looked at the memory window and stuff in

717
00:25:50,180 --> 00:25:53,289
some sense doing that sort of stuff with

718
00:25:51,920 --> 00:25:55,670
your code is actually a good idea

719
00:25:53,289 --> 00:25:57,500
psychologically because it helps you get

720
00:25:55,670 --> 00:25:59,570
into the habit of running things that

721
00:25:57,500 --> 00:26:01,220
don't have visual results and seeing

722
00:25:59,569 --> 00:26:03,049
that they're doing things and tuning

723
00:26:01,220 --> 00:26:04,970
certain things of them and so I would

724
00:26:03,049 --> 00:26:07,549
say yeah like use the debugger a lot

725
00:26:04,970 --> 00:26:09,860
look at what you're doing run it time it

726
00:26:07,549 --> 00:26:11,450
do things that sort of turn non visual

727
00:26:09,859 --> 00:26:15,649
things into stuff that kind of has a

728
00:26:11,450 --> 00:26:16,640
tangible result that can often help you

729
00:26:15,650 --> 00:26:17,840
should really put a link to the hand

730
00:26:16,640 --> 00:26:22,340
made to your website and at which pages

731
00:26:17,839 --> 00:26:23,839
description well I tried to in the bio I

732
00:26:22,339 --> 00:26:25,279
don't know what the description is I

733
00:26:23,839 --> 00:26:26,559
guess I'll try to look at what the

734
00:26:25,279 --> 00:26:29,899
description is because I don't even know

735
00:26:26,559 --> 00:26:32,089
I'll write that down but I don't I don't

736
00:26:29,900 --> 00:26:33,860
you know I'm not a I'm not a twitcher I

737
00:26:32,089 --> 00:26:36,319
don't know a lot of these things I am a

738
00:26:33,859 --> 00:26:37,909
programmer so I'm kind of learning this

739
00:26:36,319 --> 00:26:39,980
stuff I will I will try to put that in

740
00:26:37,910 --> 00:26:42,230
there I'll try to go find that

741
00:26:39,980 --> 00:26:43,460
let's see what do you think about rust

742
00:26:42,230 --> 00:26:48,079
or game development have you tried out

743
00:26:43,460 --> 00:26:49,700
yet no I have not tried out rust I don't

744
00:26:48,079 --> 00:26:51,109
really have that much interest in new

745
00:26:49,700 --> 00:26:53,750
languages to be completely honest with

746
00:26:51,109 --> 00:26:55,519
you because at this point I tend to do

747
00:26:53,750 --> 00:26:57,859
my own sort of C meta programming most

748
00:26:55,519 --> 00:27:00,500
of the time and so I kind of programming

749
00:26:57,859 --> 00:27:03,138
KC Lang a lot of the time anyway if that

750
00:27:00,500 --> 00:27:04,669
makes sense not sure you covered pointer

751
00:27:03,138 --> 00:27:06,319
dereference but that would solve some

752
00:27:04,669 --> 00:27:09,259
arrow operator questions people were

753
00:27:06,319 --> 00:27:11,720
asking yes so that's true probably cover

754
00:27:09,259 --> 00:27:13,849
point reference a little bit later but

755
00:27:11,720 --> 00:27:15,409
yeah what what the what that poster is

756
00:27:13,849 --> 00:27:17,778
referring to is the fact that if I have

757
00:27:15,409 --> 00:27:19,970
something like projectile star test and

758
00:27:17,778 --> 00:27:21,798
I want to treat it like it wasn't a

759
00:27:19,970 --> 00:27:24,440
pointer anymore I can dereference it

760
00:27:21,798 --> 00:27:25,369
this way which makes them which is more

761
00:27:24,440 --> 00:27:27,380
useful when you have things like

762
00:27:25,369 --> 00:27:30,379
pointers to pointers but I would rather

763
00:27:27,380 --> 00:27:33,260
cover that a little bit later later on

764
00:27:30,380 --> 00:27:35,600
if that makes sense but I'll make a note

765
00:27:33,259 --> 00:27:37,069
to cover pointers to pointers at some

766
00:27:35,599 --> 00:27:43,668
point so that we can kind of talk about

767
00:27:37,069 --> 00:27:44,960
that a little bit more when I said the

768
00:27:43,669 --> 00:27:46,100
twitch page gription I meant the bio I

769
00:27:44,960 --> 00:27:47,179
think I don't know much about search

770
00:27:46,099 --> 00:27:50,000
phase user but the link should probably

771
00:27:47,179 --> 00:27:51,919
be somewhere on this page so I did put

772
00:27:50,000 --> 00:27:53,778
it like like all I can say is I did put

773
00:27:51,919 --> 00:27:56,210
it there I just don't know how to get

774
00:27:53,778 --> 00:27:57,710
twitch to show it anywhere else I'm not

775
00:27:56,210 --> 00:28:00,380
that knowledgeable of that sort of thing

776
00:27:57,710 --> 00:28:02,808
so yeah

777
00:28:00,380 --> 00:28:03,860
quantum placeand says in the past videos

778
00:28:02,808 --> 00:28:06,019
you seem to dislike Microsoft

779
00:28:03,859 --> 00:28:07,278
substantially why do you think a what do

780
00:28:06,019 --> 00:28:08,480
you think of many of their new open

781
00:28:07,278 --> 00:28:11,538
source free initiatives announced

782
00:28:08,480 --> 00:28:12,829
recently um I guess what I would say is

783
00:28:11,538 --> 00:28:14,240
it's nice of them to release the

784
00:28:12,829 --> 00:28:16,189
compiler for free because it makes it

785
00:28:14,240 --> 00:28:17,569
easier to do this casts I don't have to

786
00:28:16,190 --> 00:28:20,840
tell people to buy something that's two

787
00:28:17,569 --> 00:28:23,869
hundred dollars so that's good I guess

788
00:28:20,839 --> 00:28:28,658
the reason that I dislike a lot of

789
00:28:23,869 --> 00:28:30,709
Microsoft things is not because they're

790
00:28:28,659 --> 00:28:32,419
expensive I don't

791
00:28:30,710 --> 00:28:33,829
I like programmers getting paid for

792
00:28:32,419 --> 00:28:35,870
their work like I don't think there's

793
00:28:33,829 --> 00:28:38,538
anything great about free software in

794
00:28:35,869 --> 00:28:39,949
the free beer sense I do like software

795
00:28:38,538 --> 00:28:41,898
freedom and I think there's some cool

796
00:28:39,950 --> 00:28:42,980
things about that but I don't I think

797
00:28:41,898 --> 00:28:44,479
programmers should be paid I mean it's

798
00:28:42,980 --> 00:28:46,009
how I make a living I want people to

799
00:28:44,480 --> 00:28:48,019
have to pay for software just like they

800
00:28:46,009 --> 00:28:49,730
pay for other things because it's the

801
00:28:48,019 --> 00:28:52,190
only way you can pay people to make it

802
00:28:49,730 --> 00:28:52,990
and to spend a lot of time on it and so

803
00:28:52,190 --> 00:28:54,370
real

804
00:28:52,990 --> 00:28:56,620
the thing that I don't like about about

805
00:28:54,369 --> 00:28:59,049
about the most of stuff that Microsoft

806
00:28:56,619 --> 00:29:01,239
does is it's low quality now I used to

807
00:28:59,049 --> 00:29:02,678
like Microsoft a lot more because their

808
00:29:01,240 --> 00:29:05,319
stuff they shipped was high quality

809
00:29:02,679 --> 00:29:07,450
I thought Windows NT three three five

810
00:29:05,319 --> 00:29:10,299
one was a great operating system for its

811
00:29:07,450 --> 00:29:12,009
day I really liked using it I thought

812
00:29:10,299 --> 00:29:14,799
using Windows was a lot better than

813
00:29:12,009 --> 00:29:17,500
using Linux you know around like you

814
00:29:14,799 --> 00:29:19,049
know even even up through Windows XP

815
00:29:17,500 --> 00:29:21,359
even I thought was a pretty good

816
00:29:19,049 --> 00:29:23,319
operating system and it did it was very

817
00:29:21,359 --> 00:29:24,959
handled a lot of hardware and it made

818
00:29:23,319 --> 00:29:31,000
programming on that Hardware work well

819
00:29:24,960 --> 00:29:32,740
but you know for the past I want to say

820
00:29:31,000 --> 00:29:34,390
decade or more they've been shipping

821
00:29:32,740 --> 00:29:35,920
really lousy stuff I mean their

822
00:29:34,390 --> 00:29:37,809
operating systems are lousy now don't

823
00:29:35,920 --> 00:29:39,820
like them they're buggy they they're

824
00:29:37,808 --> 00:29:41,500
very unreliable they introduce things

825
00:29:39,819 --> 00:29:43,419
like side by side assemblies that make

826
00:29:41,500 --> 00:29:46,058
it impossible to ship code reliably ever

827
00:29:43,420 --> 00:29:47,620
if not a day goes by that I don't try to

828
00:29:46,058 --> 00:29:49,480
like run a game that someone sends me

829
00:29:47,619 --> 00:29:51,849
and it doesn't run on a machine because

830
00:29:49,480 --> 00:29:53,470
like the VC VARs 32 wasn't installed

831
00:29:51,849 --> 00:29:54,849
properly for the version of the compiler

832
00:29:53,470 --> 00:29:57,160
that they use to build oh so it's like

833
00:29:54,849 --> 00:29:59,319
they've lost Microsoft has lost sight of

834
00:29:57,160 --> 00:30:03,009
what it means to ship a platform they're

835
00:29:59,319 --> 00:30:05,319
in this like shipping consumer products

836
00:30:03,009 --> 00:30:06,789
thing and they're just it's a disaster

837
00:30:05,319 --> 00:30:09,759
now they don't ship a stable platform

838
00:30:06,789 --> 00:30:11,109
for developers anymore and so that's why

839
00:30:09,759 --> 00:30:12,819
I'm disparaging of them a lot of times

840
00:30:11,109 --> 00:30:14,199
is because the product is lousy now and

841
00:30:12,819 --> 00:30:16,629
the product used to be much better and

842
00:30:14,200 --> 00:30:18,190
so it makes me sad because I liked

843
00:30:16,630 --> 00:30:19,690
Windows Windows with my home platform

844
00:30:18,190 --> 00:30:22,179
and now Linux is my home platform my

845
00:30:19,690 --> 00:30:25,509
most of my machines now run Linux and I

846
00:30:22,179 --> 00:30:27,009
my laptops run Linux and because you

847
00:30:25,509 --> 00:30:29,019
know I feel like if I'm going to have

848
00:30:27,009 --> 00:30:31,299
something that isn't reliable like that

849
00:30:29,019 --> 00:30:33,308
I might as well use an open-source

850
00:30:31,299 --> 00:30:36,039
alternative because that way I don't

851
00:30:33,308 --> 00:30:41,490
have to be entirely beholden to

852
00:30:36,039 --> 00:30:44,139
Microsoft when I when I do things that's

853
00:30:41,490 --> 00:30:45,849
about all the questions I think if

854
00:30:44,140 --> 00:30:46,360
someone has a question that they that I

855
00:30:45,849 --> 00:30:50,379
missed

856
00:30:46,359 --> 00:30:53,649
please re retweet it or whatever so I

857
00:30:50,380 --> 00:30:57,250
can see it but it looks like we have we

858
00:30:53,650 --> 00:31:01,300
have caught everything that was in the

859
00:30:57,250 --> 00:31:04,179
question so I will wrap up the the Q&amp;A

860
00:31:01,299 --> 00:31:05,529
if no one's got another question I'll

861
00:31:04,179 --> 00:31:06,450
wait another couple minutes just to make

862
00:31:05,529 --> 00:31:16,180
sure

863
00:31:06,450 --> 00:31:18,009
let's see doot-doot-doot no looks like

864
00:31:16,180 --> 00:31:18,519
everyone everyone is done for the

865
00:31:18,009 --> 00:31:21,039
evening

866
00:31:18,519 --> 00:31:23,740
all right everybody well thank you very

867
00:31:21,039 --> 00:31:26,379
much for coming it has been a pleasure

868
00:31:23,740 --> 00:31:29,380
chatting with you as always and I will

869
00:31:26,380 --> 00:31:32,320
see you tomorrow probably around the

870
00:31:29,380 --> 00:31:35,920
same time but I will tweet I will tweet

871
00:31:32,319 --> 00:31:37,990
the actual time on the handmade hero

872
00:31:35,920 --> 00:31:40,000
Twitter stream and on the senior Ettore

873
00:31:37,990 --> 00:31:41,620
Twitter stream if you would like to know

874
00:31:40,000 --> 00:31:43,450
you can follow those streams you can

875
00:31:41,619 --> 00:31:44,679
follow those Twitter streams Twitter

876
00:31:43,450 --> 00:31:45,700
accounts to find out when the next is

877
00:31:44,680 --> 00:31:48,310
going to be but tomorrow will be the

878
00:31:45,700 --> 00:31:51,009
last intro to see before we get to the

879
00:31:48,309 --> 00:31:53,589
main stream so please join me and we

880
00:31:51,009 --> 00:31:54,819
will talk about control flow tomorrow

881
00:31:53,589 --> 00:31:57,399
will basically talking about like if

882
00:31:54,819 --> 00:31:59,200
else while do four function pointers

883
00:31:57,400 --> 00:32:01,390
that sort of stuff and also a little bit

884
00:31:59,200 --> 00:32:03,819
about the preprocessor and then we will

885
00:32:01,390 --> 00:32:05,380
be starting on Monday with the actual

886
00:32:03,819 --> 00:32:07,599
game so things will be quite a bit more

887
00:32:05,380 --> 00:32:09,850
accelerated on the actual game but

888
00:32:07,599 --> 00:32:12,369
hopefully this primer if you didn't know

889
00:32:09,849 --> 00:32:13,539
any C but you know or may be familiar

890
00:32:12,369 --> 00:32:15,519
with some other language hopefully this

891
00:32:13,539 --> 00:32:16,750
primer has gotten you to the point where

892
00:32:15,519 --> 00:32:18,519
you will be pretty comfortable with that

893
00:32:16,750 --> 00:32:20,619
if not we'll do some catch-up streams

894
00:32:18,519 --> 00:32:23,309
maybe but we'll figure it out so thank

895
00:32:20,619 --> 00:32:27,000
you so much for joining me and we will

896
00:32:23,309 --> 00:32:27,000
be back tomorrow

897
00:32:31,548 --> 00:32:33,609
you

