1
00:00:01,159 --> 00:00:06,120
hello everyone and welcome to I guess

2
00:00:04,169 --> 00:00:08,789
what will be a fairly short episode of

3
00:00:06,120 --> 00:00:11,219
handmade hero because well since we've

4
00:00:08,789 --> 00:00:12,928
been on RSI break with the hand

5
00:00:11,218 --> 00:00:15,029
I've just been basically starting the

6
00:00:12,929 --> 00:00:17,368
stream and I take questions until we get

7
00:00:15,029 --> 00:00:18,419
up to a question that seems like it's

8
00:00:17,368 --> 00:00:20,460
one that should be recorded for

9
00:00:18,420 --> 00:00:22,080
posterity and then I start recording and

10
00:00:20,460 --> 00:00:23,609
now we have gotten one but I think we

11
00:00:22,079 --> 00:00:27,348
chatted for like 45 minutes on

12
00:00:23,609 --> 00:00:29,060
relatively off-topic stuff so anyway

13
00:00:27,349 --> 00:00:31,349
here we go

14
00:00:29,059 --> 00:00:33,629
first question of the day that's tech

15
00:00:31,349 --> 00:00:36,119
oriented let's go ahead and check it out

16
00:00:33,630 --> 00:00:42,300
so the question was can you explain

17
00:00:36,119 --> 00:00:47,878
cross compiling and the answer is yes I

18
00:00:42,299 --> 00:00:49,530
can and here I will all right so what is

19
00:00:47,878 --> 00:00:50,640
cross compiling first of all for those

20
00:00:49,530 --> 00:00:53,600
of you don't know what it is because

21
00:00:50,640 --> 00:00:55,859
some people maybe never encountered it

22
00:00:53,600 --> 00:00:58,020
hopefully everyone knows what compiling

23
00:00:55,859 --> 00:00:59,519
is because we've talked about in a bunch

24
00:00:58,020 --> 00:01:01,469
if you don't know what it is go all the

25
00:00:59,520 --> 00:01:03,539
way back to the very first stream and I

26
00:01:01,469 --> 00:01:06,450
explain what it is the intro to see

27
00:01:03,539 --> 00:01:10,170
stream for example will tell you exactly

28
00:01:06,450 --> 00:01:13,320
what it is but as you know compiling is

29
00:01:10,170 --> 00:01:15,570
the process by which we take source code

30
00:01:13,319 --> 00:01:18,478
and turn it into machine code something

31
00:01:15,569 --> 00:01:20,039
that takes the text files that we write

32
00:01:18,478 --> 00:01:22,140
that are the sort of human readable

33
00:01:20,040 --> 00:01:23,880
version of what we want the computer to

34
00:01:22,140 --> 00:01:26,579
do and turn it into actually something

35
00:01:23,879 --> 00:01:27,959
that CPU actually reads now the textbook

36
00:01:26,579 --> 00:01:29,879
definition of compiling is a little bit

37
00:01:27,959 --> 00:01:30,750
different I think technically and I

38
00:01:29,879 --> 00:01:32,158
could be wrong about this but

39
00:01:30,750 --> 00:01:34,140
technically the definition of compiling

40
00:01:32,159 --> 00:01:35,609
usually means something more like

41
00:01:34,140 --> 00:01:38,879
translating something from one language

42
00:01:35,609 --> 00:01:40,500
to another so I don't really know what

43
00:01:38,879 --> 00:01:41,908
the textbook definition compiling is and

44
00:01:40,500 --> 00:01:43,500
I'm not trying to say that this is what

45
00:01:41,909 --> 00:01:46,259
the tax profession is what I'm trying to

46
00:01:43,500 --> 00:01:47,790
say is what we think of it as when we do

47
00:01:46,259 --> 00:01:49,739
it here on handmade here and we run the

48
00:01:47,790 --> 00:01:51,810
compiler what we are trying to do is

49
00:01:49,739 --> 00:01:53,759
take these text files that we have

50
00:01:51,810 --> 00:01:54,899
created that our source code that we can

51
00:01:53,759 --> 00:01:58,618
read and turn them into something that

52
00:01:54,899 --> 00:02:02,040
CPU reads and we've looked several times

53
00:01:58,618 --> 00:02:05,849
on the stream at what X 64 code right

54
00:02:02,040 --> 00:02:08,250
that's the the sort of encoding that the

55
00:02:05,849 --> 00:02:10,679
processor uses that we're trying to run

56
00:02:08,250 --> 00:02:12,449
on right

57
00:02:10,679 --> 00:02:13,468
so what we're talking about very

58
00:02:12,449 --> 00:02:15,929
specifically when we talked about

59
00:02:13,468 --> 00:02:18,750
compiling handmade hero is we're talking

60
00:02:15,930 --> 00:02:19,950
about taking a source file a set of

61
00:02:18,750 --> 00:02:22,919
source files right you know like

62
00:02:19,949 --> 00:02:24,718
handmade dot cpp and everything else

63
00:02:22,919 --> 00:02:27,030
like all the source files whatever they

64
00:02:24,718 --> 00:02:30,829
are and turning them into some stream of

65
00:02:27,030 --> 00:02:33,539
binary right which the CPU can execute

66
00:02:30,829 --> 00:02:35,549
right the CPU can understand this so

67
00:02:33,539 --> 00:02:37,798
this is the human readable thing this is

68
00:02:35,549 --> 00:02:41,329
the CPU readable thing and the compiling

69
00:02:37,799 --> 00:02:43,650
step this is compilation right

70
00:02:41,329 --> 00:02:45,239
compilation turns the human readable

71
00:02:43,650 --> 00:02:47,760
stuff into the machine readable stuff

72
00:02:45,239 --> 00:02:49,169
for us and that's fundamentally all

73
00:02:47,759 --> 00:02:50,908
we're doing member programming right is

74
00:02:49,169 --> 00:02:53,489
we're trying to create we're trying to

75
00:02:50,908 --> 00:02:56,250
create this but typing out a bunch of

76
00:02:53,489 --> 00:02:59,459
ones and zeros would be murderously hard

77
00:02:56,250 --> 00:03:01,430
on us right so we create textual things

78
00:02:59,459 --> 00:03:03,780
that are easier for humans to manipulate

79
00:03:01,430 --> 00:03:06,269
because that's what way more efficient

80
00:03:03,780 --> 00:03:07,530
you know the very first programmers were

81
00:03:06,269 --> 00:03:08,938
actually in putting this stuff directly

82
00:03:07,530 --> 00:03:10,859
right the very first program has

83
00:03:08,938 --> 00:03:13,108
programmed machines by actually putting

84
00:03:10,859 --> 00:03:15,389
in the actual instruction encoding in

85
00:03:13,109 --> 00:03:18,859
binary you know using flip like levers

86
00:03:15,389 --> 00:03:22,109
and stuff right or punch cards later on

87
00:03:18,859 --> 00:03:24,750
but quickly you know we kind of said

88
00:03:22,109 --> 00:03:27,180
that we can make this better by making

89
00:03:24,750 --> 00:03:28,530
something that translates easier

90
00:03:27,180 --> 00:03:31,019
directives things that humans can

91
00:03:28,530 --> 00:03:32,609
manipulate more easily and that's where

92
00:03:31,019 --> 00:03:34,530
the concept of compilation kind of

93
00:03:32,609 --> 00:03:35,790
became central to the programming

94
00:03:34,530 --> 00:03:37,408
process where it's like Oh

95
00:03:35,789 --> 00:03:38,698
instead of inputting the stuff directly

96
00:03:37,408 --> 00:03:41,068
we should input it in some other

97
00:03:38,699 --> 00:03:43,979
language that's designed for easy human

98
00:03:41,068 --> 00:03:46,289
use that can still output what we wanted

99
00:03:43,979 --> 00:03:47,340
to output and and that's you know where

100
00:03:46,289 --> 00:03:49,500
where that comes from

101
00:03:47,340 --> 00:03:51,090
so that's what we're doing when we

102
00:03:49,500 --> 00:03:53,280
compile and the important thing to

103
00:03:51,090 --> 00:03:54,840
remember about compiling is really

104
00:03:53,280 --> 00:03:56,669
there's a couple different stations this

105
00:03:54,840 --> 00:03:58,859
process we kind of talked about it where

106
00:03:56,669 --> 00:04:00,780
technically you know when we say compile

107
00:03:58,859 --> 00:04:04,859
well really there's multiple steps to

108
00:04:00,780 --> 00:04:06,479
that we compile right but then you also

109
00:04:04,859 --> 00:04:09,599
if you remember we linked there's a

110
00:04:06,479 --> 00:04:11,639
linker right so really like the when we

111
00:04:09,598 --> 00:04:13,500
say a week recompile the program well

112
00:04:11,639 --> 00:04:15,150
usually when I say that really what

113
00:04:13,500 --> 00:04:17,759
we're talking about is wery compiled and

114
00:04:15,150 --> 00:04:19,500
we relinked the program because

115
00:04:17,759 --> 00:04:22,680
technically usually it's you compile

116
00:04:19,500 --> 00:04:23,399
then you link and then you have this

117
00:04:22,680 --> 00:04:27,329
thing

118
00:04:23,399 --> 00:04:28,829
right so it's it's really worth noting

119
00:04:27,329 --> 00:04:30,418
that there's two steps here now now what

120
00:04:28,829 --> 00:04:31,978
are those two steps you know if you

121
00:04:30,418 --> 00:04:33,899
don't quite recall from way back in the

122
00:04:31,978 --> 00:04:36,209
beginning well this first step where we

123
00:04:33,899 --> 00:04:39,000
do the compilation that's turning our

124
00:04:36,209 --> 00:04:41,879
source code into sort of a partially

125
00:04:39,000 --> 00:04:44,310
it's turning into partially this right

126
00:04:41,879 --> 00:04:45,689
and why is it partially this well it's

127
00:04:44,310 --> 00:04:48,360
partially this because there's still

128
00:04:45,689 --> 00:04:49,620
some unknowns in the process there's

129
00:04:48,360 --> 00:04:51,509
still some things that aren't quite

130
00:04:49,620 --> 00:04:53,430
known yet at the time when the compiler

131
00:04:51,509 --> 00:04:55,050
runs okay and there's a couple different

132
00:04:53,430 --> 00:05:00,360
reasons for that one is because

133
00:04:55,050 --> 00:05:02,788
oftentimes more than one file is is

134
00:05:00,360 --> 00:05:04,288
involved in building the project and

135
00:05:02,788 --> 00:05:07,800
especially if you don't use like we use

136
00:05:04,288 --> 00:05:09,538
a unity build when people call it on on

137
00:05:07,800 --> 00:05:11,430
the stream which has nothing to do with

138
00:05:09,538 --> 00:05:12,810
the game engine unity it's just saying

139
00:05:11,430 --> 00:05:14,490
that we build everything as one big

140
00:05:12,810 --> 00:05:16,439
giant source file it's kind of a nice

141
00:05:14,490 --> 00:05:18,629
way to do things when you do things that

142
00:05:16,439 --> 00:05:20,879
way it may be a little bit less clear

143
00:05:18,629 --> 00:05:22,439
this is happening but in a in most

144
00:05:20,879 --> 00:05:24,180
people's projects they don't actually do

145
00:05:22,439 --> 00:05:25,978
things that way most people products

146
00:05:24,180 --> 00:05:28,650
there's a the concept of an obj file

147
00:05:25,978 --> 00:05:30,240
that they actually overtly use and what

148
00:05:28,649 --> 00:05:33,569
that means is you know you've got you

149
00:05:30,240 --> 00:05:34,889
know a dot CPP and B dot CPP and C dot

150
00:05:33,569 --> 00:05:36,538
CPP you know I don't know make me up

151
00:05:34,889 --> 00:05:38,220
names here but you've got tons and tons

152
00:05:36,538 --> 00:05:40,110
of CPP files you know there may be like

153
00:05:38,220 --> 00:05:42,510
a thousand of these files right all

154
00:05:40,110 --> 00:05:44,550
involved in the project and the compiler

155
00:05:42,509 --> 00:05:46,469
you typically invoke on only just one of

156
00:05:44,550 --> 00:05:48,930
them and you say compile a dot c p--

157
00:05:46,470 --> 00:05:50,789
opinion too often times a dot obj or a

158
00:05:48,930 --> 00:05:53,280
dot o depending on the operating system

159
00:05:50,788 --> 00:05:55,620
this is the UNIX way right this is the

160
00:05:53,279 --> 00:05:57,418
the windows way right

161
00:05:55,620 --> 00:05:59,189
and so when you compile something you

162
00:05:57,418 --> 00:06:01,379
turn into this object file and then the

163
00:05:59,189 --> 00:06:04,228
object files they all go into the linker

164
00:06:01,379 --> 00:06:06,719
right and the linker produces a single

165
00:06:04,228 --> 00:06:10,139
executable file right so it typically

166
00:06:06,720 --> 00:06:11,220
looks something more like CPP s you know

167
00:06:10,139 --> 00:06:12,538
there's tons of them maybe there's a

168
00:06:11,220 --> 00:06:14,849
thousand of them who knows how many a

169
00:06:12,538 --> 00:06:18,180
hundred of them I'm not sure right they

170
00:06:14,848 --> 00:06:20,728
all come over to OBJ's one to one right

171
00:06:18,180 --> 00:06:24,959
so every individual CPP file becomes an

172
00:06:20,728 --> 00:06:30,509
obj file ok and then all of those files

173
00:06:24,959 --> 00:06:34,979
the linker this is linking this is

174
00:06:30,509 --> 00:06:37,560
piling soca' pile we linked and then we

175
00:06:34,980 --> 00:06:39,840
get an executable right or an 8 a doubt

176
00:06:37,560 --> 00:06:41,339
file or whatever elf binary whatever

177
00:06:39,839 --> 00:06:42,689
whatever you're trying to produce the

178
00:06:41,339 --> 00:06:46,199
thing that the operating system actually

179
00:06:42,689 --> 00:06:47,850
runs right so that's actually what's

180
00:06:46,199 --> 00:06:50,490
happening right when we talk about

181
00:06:47,850 --> 00:06:52,680
compiling when we talk about doing

182
00:06:50,490 --> 00:06:55,620
compilation that's really what we're

183
00:06:52,680 --> 00:06:56,519
talking about is that process and this

184
00:06:55,620 --> 00:06:58,410
we know what it is

185
00:06:56,519 --> 00:06:59,969
we look at this every day this we don't

186
00:06:58,410 --> 00:07:01,260
really know what it is in the sense that

187
00:06:59,970 --> 00:07:03,150
we haven't really talked about too much

188
00:07:01,259 --> 00:07:05,459
on handmade hero but what this is is

189
00:07:03,149 --> 00:07:09,060
it's a partially CPU readable thing

190
00:07:05,459 --> 00:07:11,419
meaning inside it is actually machine

191
00:07:09,060 --> 00:07:13,709
code right so it's got machine code

192
00:07:11,420 --> 00:07:15,390
that's like ready you could send it to

193
00:07:13,709 --> 00:07:16,109
an X 64 and the X is before would know

194
00:07:15,389 --> 00:07:19,649
what to do with it

195
00:07:16,110 --> 00:07:22,310
but it's not quite all there yet because

196
00:07:19,649 --> 00:07:25,199
since there's a lot of obj files

197
00:07:22,310 --> 00:07:27,629
remember those obj files call each other

198
00:07:25,199 --> 00:07:29,279
right every CPP file that we you make

199
00:07:27,629 --> 00:07:31,019
maybe call something that's in some

200
00:07:29,279 --> 00:07:33,149
other CPP file or whatever so if you

201
00:07:31,019 --> 00:07:35,579
have a function right let's say you have

202
00:07:33,149 --> 00:07:37,560
some function foo of X or whatever that

203
00:07:35,579 --> 00:07:39,000
you're trying to call and foo of X is

204
00:07:37,560 --> 00:07:40,290
defined in one second feed file let's

205
00:07:39,000 --> 00:07:43,079
say it's defined here here's the

206
00:07:40,290 --> 00:07:45,540
definition right and then somewhere else

207
00:07:43,079 --> 00:07:49,169
is a call to foo right and some other

208
00:07:45,540 --> 00:07:51,240
CPP well obviously when I build these

209
00:07:49,170 --> 00:07:53,610
things you know when I produce the obj

210
00:07:51,240 --> 00:07:55,829
files those obj files they don't

211
00:07:53,610 --> 00:07:57,660
actually have enough information neither

212
00:07:55,829 --> 00:08:00,539
of them has all the information they

213
00:07:57,660 --> 00:08:03,060
need to successfully have foo get called

214
00:08:00,540 --> 00:08:05,160
because the debt the actual code for foo

215
00:08:03,060 --> 00:08:06,839
is in one place and the actual call to

216
00:08:05,160 --> 00:08:08,580
foo is in another place and those two

217
00:08:06,839 --> 00:08:10,439
things aren't even seen by the compiler

218
00:08:08,579 --> 00:08:13,649
at any given time the compiler is

219
00:08:10,439 --> 00:08:15,300
working at one file at a time right and

220
00:08:13,649 --> 00:08:17,429
so that's where the linking phase comes

221
00:08:15,300 --> 00:08:19,259
in so the machine code that's in the obj

222
00:08:17,430 --> 00:08:20,970
files has what are called like

223
00:08:19,259 --> 00:08:22,829
unresolved symbols basically in them

224
00:08:20,970 --> 00:08:24,570
right it has things in them that it

225
00:08:22,829 --> 00:08:26,159
doesn't really know what it is yet so

226
00:08:24,569 --> 00:08:26,819
let's take that call - foo we're trying

227
00:08:26,160 --> 00:08:28,800
to call foo

228
00:08:26,819 --> 00:08:30,870
right so maybe there's something like a

229
00:08:28,800 --> 00:08:33,029
jump instruction or a call instruction

230
00:08:30,870 --> 00:08:35,009
right for the in the case of a function

231
00:08:33,029 --> 00:08:36,779
call would be a call instruction right

232
00:08:35,009 --> 00:08:38,189
so it's got the machine code the actual

233
00:08:36,779 --> 00:08:40,348
binary encoding for a call instruction

234
00:08:38,190 --> 00:08:42,120
and then it needs to know the address

235
00:08:40,349 --> 00:08:43,889
it's trying to call it needs to know

236
00:08:42,120 --> 00:08:46,438
what it's trying to call into but

237
00:08:43,889 --> 00:08:49,318
it doesn't know what this is it has no

238
00:08:46,438 --> 00:08:51,808
idea because it doesn't know where foo

239
00:08:49,318 --> 00:08:53,849
actually is it's never even seen foo it

240
00:08:51,808 --> 00:08:56,358
doesn't know anything about it other

241
00:08:53,850 --> 00:08:59,639
than maybe its function prototype right

242
00:08:56,359 --> 00:09:01,649
so that remains as sort of an ambiguous

243
00:08:59,639 --> 00:09:04,289
symbol and then it gets fed into the

244
00:09:01,649 --> 00:09:06,359
linker and the linker reads these obj

245
00:09:04,289 --> 00:09:07,948
files and has the obj files have

246
00:09:06,359 --> 00:09:09,410
information that tell the linker where

247
00:09:07,948 --> 00:09:11,789
all those symbols are and what they are

248
00:09:09,409 --> 00:09:13,409
so then what the linker does is the

249
00:09:11,789 --> 00:09:15,418
linker does a couple things it merges

250
00:09:13,409 --> 00:09:17,519
all of these things together right so

251
00:09:15,418 --> 00:09:21,048
it's basically something that allows it

252
00:09:17,519 --> 00:09:26,548
to create for lack of a better term a

253
00:09:21,048 --> 00:09:29,068
single homogeneous thing with all the

254
00:09:26,548 --> 00:09:32,548
code that correctly can jump into itself

255
00:09:29,068 --> 00:09:36,599
and knows where everything is right so

256
00:09:32,548 --> 00:09:38,759
it's that but it actually has a little

257
00:09:36,600 --> 00:09:40,290
more so it's it's gonna bind all these

258
00:09:38,759 --> 00:09:44,039
IP files together but it's gonna put in

259
00:09:40,289 --> 00:09:46,469
a few other things okay and so what's it

260
00:09:44,039 --> 00:09:50,548
gonna put in well what its gonna put in

261
00:09:46,470 --> 00:09:53,009
is on this executable right we have the

262
00:09:50,548 --> 00:09:56,548
result of all of the obj files so all

263
00:09:53,009 --> 00:10:00,409
the obj files are are sort of merged

264
00:09:56,548 --> 00:10:04,198
into some giant block of executable code

265
00:10:00,409 --> 00:10:09,659
let's let's actually call this machine

266
00:10:04,198 --> 00:10:11,519
code so all of this machine code all of

267
00:10:09,659 --> 00:10:13,558
these OBJ's are combined together if

268
00:10:11,519 --> 00:10:15,678
they're you know correctly aligned and

269
00:10:13,558 --> 00:10:18,088
all that stuff to produce machine code

270
00:10:15,678 --> 00:10:21,558
all that machine code is all ready to go

271
00:10:18,089 --> 00:10:23,910
it could start being run right but

272
00:10:21,558 --> 00:10:26,068
typically because this is running in the

273
00:10:23,909 --> 00:10:28,259
context of an operating system there's a

274
00:10:26,068 --> 00:10:31,288
bunch of like header data here as well

275
00:10:28,259 --> 00:10:33,178
right so the linker is not just

276
00:10:31,288 --> 00:10:35,428
producing a bunch of stuff for the CPU

277
00:10:33,178 --> 00:10:36,629
it's also producing a bunch of data that

278
00:10:35,428 --> 00:10:39,238
typically goes at the beginning but it

279
00:10:36,629 --> 00:10:42,119
could go anywhere it's producing a bunch

280
00:10:39,239 --> 00:10:44,429
of other information right that tells

281
00:10:42,119 --> 00:10:46,439
the operating system how to load and

282
00:10:44,428 --> 00:10:48,389
execute this code because remember

283
00:10:46,438 --> 00:10:52,438
remember we talked about dynamic link

284
00:10:48,389 --> 00:10:54,418
libraries right dynamic linking this

285
00:10:52,438 --> 00:10:56,899
concept that well you know I have to

286
00:10:54,418 --> 00:10:58,970
call Windows for stuff but Windows Azure

287
00:10:56,899 --> 00:11:01,189
running when I run we weren't compiled

288
00:10:58,970 --> 00:11:04,519
together I didn't compile my app into

289
00:11:01,190 --> 00:11:06,620
Windows right that didn't happen and so

290
00:11:04,519 --> 00:11:09,829
if you think about it what happens there

291
00:11:06,620 --> 00:11:12,049
is a actual runtime when this executable

292
00:11:09,830 --> 00:11:13,850
is loaded in and executed by Windows it

293
00:11:12,049 --> 00:11:15,620
needs to know how to like patch up some

294
00:11:13,850 --> 00:11:18,019
things in my excuse to that when I do

295
00:11:15,620 --> 00:11:21,049
jumps into Windows code it knows where

296
00:11:18,019 --> 00:11:22,490
the windows code is right so all of that

297
00:11:21,049 --> 00:11:24,469
information ends up having to be packed

298
00:11:22,490 --> 00:11:25,759
into this header as well as some things

299
00:11:24,470 --> 00:11:27,350
that usually they stick on there that's

300
00:11:25,759 --> 00:11:28,970
like for example in Windows there's some

301
00:11:27,350 --> 00:11:30,769
stuff that identifies it as a Windows

302
00:11:28,970 --> 00:11:32,420
executable so there's like a thing like

303
00:11:30,769 --> 00:11:35,120
a mattad value and stuff like that in

304
00:11:32,419 --> 00:11:36,588
there right and it's even more

305
00:11:35,120 --> 00:11:37,399
complicated there's lots more stuff in

306
00:11:36,589 --> 00:11:38,779
here right so it's it's a very

307
00:11:37,399 --> 00:11:41,569
structured file that's a lot of

308
00:11:38,778 --> 00:11:43,549
information so and the linker does more

309
00:11:41,570 --> 00:11:46,070
than just mush the objects together it

310
00:11:43,549 --> 00:11:47,959
also does a bunch of extra work to

311
00:11:46,070 --> 00:11:49,790
basically produce a file that's in the

312
00:11:47,960 --> 00:11:51,860
right format for the operating system to

313
00:11:49,789 --> 00:11:56,028
get the stuff out of do what it needs to

314
00:11:51,860 --> 00:12:00,289
do and start the program running okay so

315
00:11:56,028 --> 00:12:04,820
what is cross compiling well cross

316
00:12:00,289 --> 00:12:07,419
compiling is when you want to run this

317
00:12:04,820 --> 00:12:09,830
process exact when we talked about

318
00:12:07,419 --> 00:12:12,740
compilation linking producing an

319
00:12:09,830 --> 00:12:14,480
executable you want to run this process

320
00:12:12,740 --> 00:12:15,799
but you want to run it for an operating

321
00:12:14,480 --> 00:12:18,800
system other than the one you are

322
00:12:15,799 --> 00:12:24,019
running on so for example let's say I

323
00:12:18,799 --> 00:12:27,889
have a Linux machine oops and I want to

324
00:12:24,019 --> 00:12:30,230
run code on the Linux machine so my goal

325
00:12:27,889 --> 00:12:36,110
is to run an executable on a Linux

326
00:12:30,230 --> 00:12:37,220
machine but I am running on 1/32 this

327
00:12:36,110 --> 00:12:38,419
machine we're running on right now is

328
00:12:37,220 --> 00:12:43,490
win through two machine well it's a win

329
00:12:38,419 --> 00:12:47,019
64 machine right but it's Windows ok so

330
00:12:43,490 --> 00:12:51,259
if I was to set up a tool chain that

331
00:12:47,019 --> 00:12:53,419
built a Linux executable on Windows so

332
00:12:51,259 --> 00:12:55,549
I'm running the linker the compiler and

333
00:12:53,419 --> 00:12:57,409
the linker on Windows but I'm producing

334
00:12:55,549 --> 00:13:00,229
an executable that's in the format that

335
00:12:57,409 --> 00:13:02,028
a Linux machine would expect that is

336
00:13:00,230 --> 00:13:04,278
cross compiling that's what cross

337
00:13:02,028 --> 00:13:08,000
compiling is it's simply the act of

338
00:13:04,278 --> 00:13:10,639
taking one operating system and one tool

339
00:13:08,000 --> 00:13:12,799
chain on that operating system

340
00:13:10,639 --> 00:13:15,110
running it and getting output that you

341
00:13:12,799 --> 00:13:18,859
can then run on some other operating

342
00:13:15,110 --> 00:13:21,919
system okay very very simple so how does

343
00:13:18,860 --> 00:13:22,970
that work was the question and I had to

344
00:13:21,919 --> 00:13:24,620
go through the salaah explanation so

345
00:13:22,970 --> 00:13:27,950
that you could understand the answer was

346
00:13:24,620 --> 00:13:30,440
incredibly simple which is it's there's

347
00:13:27,950 --> 00:13:32,690
literally nothing to it all of this

348
00:13:30,440 --> 00:13:35,960
process none of it has anything to do

349
00:13:32,690 --> 00:13:38,420
with the operating system at all right

350
00:13:35,960 --> 00:13:39,950
nothing in this process has anything to

351
00:13:38,419 --> 00:13:44,599
do with the operating system it's all

352
00:13:39,950 --> 00:13:47,410
just reading and writing files right so

353
00:13:44,600 --> 00:13:51,470
if you want to build a cross compiler

354
00:13:47,409 --> 00:13:53,959
all you have to do is build a compiler

355
00:13:51,470 --> 00:13:57,610
in the linker exactly as you would if

356
00:13:53,960 --> 00:14:00,290
you weren't cross compiling right and

357
00:13:57,610 --> 00:14:03,200
then run it on some other operating

358
00:14:00,289 --> 00:14:06,589
system there's no magic to it right

359
00:14:03,200 --> 00:14:09,050
because all the compiler does is read in

360
00:14:06,590 --> 00:14:11,930
the CPP file do a bunch of work on it

361
00:14:09,049 --> 00:14:13,399
and then output the obj file at no time

362
00:14:11,929 --> 00:14:14,779
does it have to interface the operation

363
00:14:13,399 --> 00:14:17,419
for anything other than loading and

364
00:14:14,779 --> 00:14:19,699
saving files right which we all know how

365
00:14:17,419 --> 00:14:21,649
to do on any operating system really and

366
00:14:19,700 --> 00:14:24,980
you can even use a C runtime library for

367
00:14:21,649 --> 00:14:27,289
that right so all of that logic all of

368
00:14:24,980 --> 00:14:29,000
the code for the compilation does not

369
00:14:27,289 --> 00:14:31,159
depend on the apperance is amin anyway

370
00:14:29,000 --> 00:14:34,159
so if you wrote something that compiles

371
00:14:31,159 --> 00:14:36,740
for say x64 you could go run it on a

372
00:14:34,159 --> 00:14:39,409
PowerPC you could compile that code with

373
00:14:36,740 --> 00:14:41,840
a PowerPC compiler run it on a PowerPC

374
00:14:39,409 --> 00:14:44,480
and it would still output x64 code

375
00:14:41,840 --> 00:14:45,889
because the compiler is a thing that has

376
00:14:44,480 --> 00:14:48,230
nothing to do with the platform it's

377
00:14:45,889 --> 00:14:50,659
running on it's just code that generates

378
00:14:48,230 --> 00:14:53,000
file data right it's just generating

379
00:14:50,659 --> 00:14:55,250
data that it writes out to a file so it

380
00:14:53,000 --> 00:14:56,990
doesn't matter what platform it's

381
00:14:55,250 --> 00:14:59,809
running on just because you run

382
00:14:56,990 --> 00:15:02,180
something code that generates x64 code

383
00:14:59,809 --> 00:15:03,979
running it on a PowerPC doesn't make it

384
00:15:02,179 --> 00:15:05,809
suddenly output PowerPC code right

385
00:15:03,980 --> 00:15:07,850
because you know I'm talking about

386
00:15:05,809 --> 00:15:12,649
literally the process of doing it is

387
00:15:07,850 --> 00:15:15,830
like hey I want to XIII I want to output

388
00:15:12,649 --> 00:15:17,000
a call instruction here right that's

389
00:15:15,830 --> 00:15:18,440
what I want my can power to do my

390
00:15:17,000 --> 00:15:19,879
compiler did a bunch of work it wants to

391
00:15:18,440 --> 00:15:22,130
write out a call instruction into the

392
00:15:19,879 --> 00:15:24,110
obj file or whatever right it just knows

393
00:15:22,129 --> 00:15:26,149
that oh a call instruction I don't even

394
00:15:24,110 --> 00:15:28,459
what it is but I know it's like Oh x5b

395
00:15:26,149 --> 00:15:30,769
or something and then the address is

396
00:15:28,458 --> 00:15:32,958
encoded here or whatever right it just

397
00:15:30,769 --> 00:15:36,230
literally writes those bytes out to the

398
00:15:32,958 --> 00:15:38,599
file so it doesn't need to be running on

399
00:15:36,230 --> 00:15:41,720
an X 64 for any reason in order to write

400
00:15:38,600 --> 00:15:43,519
out X 64 code right because X is before

401
00:15:41,720 --> 00:15:45,379
code is just data it's just bytes on the

402
00:15:43,519 --> 00:15:47,990
disk so as long as the compiler knows

403
00:15:45,379 --> 00:15:49,610
what all of the opcodes are it could

404
00:15:47,990 --> 00:15:52,399
write them out no matter what the host

405
00:15:49,610 --> 00:15:54,500
machine is right so you write the

406
00:15:52,399 --> 00:15:56,419
compiler just as you would if it was

407
00:15:54,500 --> 00:15:57,620
native if it was on the same machine if

408
00:15:56,419 --> 00:16:00,049
it wasn't cross compiling you'd write

409
00:15:57,620 --> 00:16:01,519
the same code then you write the same

410
00:16:00,049 --> 00:16:05,059
exact linker you would you know you

411
00:16:01,519 --> 00:16:06,560
write the same code to link to X C and

412
00:16:05,059 --> 00:16:08,088
just because you're not running on

413
00:16:06,559 --> 00:16:10,879
Windows or not running on Linux doesn't

414
00:16:08,089 --> 00:16:13,610
matter it's the format that you output

415
00:16:10,879 --> 00:16:16,159
the format of the file you output is the

416
00:16:13,610 --> 00:16:17,600
thing that determines what platforms

417
00:16:16,159 --> 00:16:20,088
will be able to run it so if I write a

418
00:16:17,600 --> 00:16:22,190
linker that writes an exe it doesn't

419
00:16:20,089 --> 00:16:23,959
matter if I compile that linker on Linux

420
00:16:22,190 --> 00:16:26,269
it's still gonna write out an exe that

421
00:16:23,958 --> 00:16:30,139
Windows would read that's just how that

422
00:16:26,269 --> 00:16:32,028
works right so cross compiling there's

423
00:16:30,139 --> 00:16:34,578
no magic to it all it means is that the

424
00:16:32,028 --> 00:16:36,889
code for the compiler in the linker were

425
00:16:34,578 --> 00:16:39,528
programmed to output specific format

426
00:16:36,889 --> 00:16:43,370
things that were for a target other than

427
00:16:39,528 --> 00:16:45,078
the one that they are running on that's

428
00:16:43,370 --> 00:16:48,679
it

429
00:16:45,078 --> 00:16:52,870
and so if you write your code well like

430
00:16:48,679 --> 00:16:56,689
for example LLVM you know it's a nice

431
00:16:52,870 --> 00:16:58,940
compiler or whatever I you can just pick

432
00:16:56,690 --> 00:17:01,399
the target because it's got a bunch of

433
00:16:58,940 --> 00:17:04,429
back ends in it one that generates x64

434
00:17:01,399 --> 00:17:05,869
code one that generates arm code and it

435
00:17:04,429 --> 00:17:07,640
doesn't matter whether you're running it

436
00:17:05,869 --> 00:17:10,759
on an ARM processor or an x64 a

437
00:17:07,640 --> 00:17:13,280
processor whatever you compiled LLVM for

438
00:17:10,759 --> 00:17:15,470
has nothing to do with that code path

439
00:17:13,279 --> 00:17:17,828
both of those code paths will exist

440
00:17:15,470 --> 00:17:20,720
inside the actual compiled compiler

441
00:17:17,828 --> 00:17:21,769
right and so at that point if you just

442
00:17:20,720 --> 00:17:23,298
have a command-line switch that says

443
00:17:21,769 --> 00:17:24,769
please generate arm code that just means

444
00:17:23,298 --> 00:17:26,660
that the compiler will now call its arm

445
00:17:24,769 --> 00:17:28,910
code generator which is a piece of code

446
00:17:26,660 --> 00:17:32,090
that knows how to write out files with X

447
00:17:28,910 --> 00:17:34,730
with with arm assembly instructions in

448
00:17:32,089 --> 00:17:36,289
them right arm machine code whereas if

449
00:17:34,730 --> 00:17:38,000
you tell it to run the exit e for branch

450
00:17:36,289 --> 00:17:43,119
it's just going to call some

451
00:17:38,000 --> 00:17:44,680
that writes out x64 machine code okay

452
00:17:43,119 --> 00:17:47,539
and that's it

453
00:17:44,680 --> 00:17:49,759
so cross compilation is nothing special

454
00:17:47,539 --> 00:17:52,759
it's no different than compilation in

455
00:17:49,759 --> 00:17:53,930
fact compilation is just compilation the

456
00:17:52,759 --> 00:17:56,089
only thing that makes something cross

457
00:17:53,930 --> 00:17:58,549
compilation is if you happen to have

458
00:17:56,089 --> 00:18:01,759
compiled a compiler for some other

459
00:17:58,549 --> 00:18:03,500
operating systems format on you know a

460
00:18:01,759 --> 00:18:04,940
different operating system that's all

461
00:18:03,500 --> 00:18:06,769
that makes it cross compiling but the

462
00:18:04,940 --> 00:18:09,380
code for the compiler is identical it

463
00:18:06,769 --> 00:18:11,240
doesn't change at all right because when

464
00:18:09,380 --> 00:18:14,030
you write a compiler that outputs x64

465
00:18:11,240 --> 00:18:15,740
code it will always output x64 code and

466
00:18:14,029 --> 00:18:17,899
if you compile that compiler on PowerPC

467
00:18:15,740 --> 00:18:21,289
and then run it on PowerPC it will

468
00:18:17,900 --> 00:18:23,630
suddenly output x64 code on the PowerPC

469
00:18:21,289 --> 00:18:25,909
and so you've made a cross compiler at

470
00:18:23,630 --> 00:18:27,860
that point just by recompiling the

471
00:18:25,910 --> 00:18:30,320
compiler on a different platform write

472
00:18:27,859 --> 00:18:32,539
compile of ecstasy for compiler on x64

473
00:18:30,319 --> 00:18:34,700
and you will have a compiler compile and

474
00:18:32,539 --> 00:18:38,289
execute for our compiler on PowerPC and

475
00:18:34,700 --> 00:18:41,799
you have a cross compiler that's it

476
00:18:38,289 --> 00:18:41,799
hopefully that answered the question

477
00:18:51,298 --> 00:18:54,629
let's see

478
00:18:55,980 --> 00:18:59,220
let's see I think we're just about out

479
00:18:57,940 --> 00:19:01,269
of time

480
00:18:59,220 --> 00:19:03,460
s I was going to be very short one

481
00:19:01,269 --> 00:19:16,440
because we most the time was off topic

482
00:19:03,460 --> 00:19:16,440
questions today let's find out

483
00:19:41,808 --> 00:19:47,099
looks like there's no other super

484
00:19:44,730 --> 00:19:49,319
critical questions here alright so I'm

485
00:19:47,099 --> 00:19:50,219
gonna go ahead and wind down there is

486
00:19:49,319 --> 00:19:57,779
cross-compiling

487
00:19:50,220 --> 00:20:00,029
in a nutshell oh well ok here's one

488
00:19:57,779 --> 00:20:01,859
that's kind of on the topic just so we

489
00:20:00,029 --> 00:20:03,149
do it's a Qbert Caleb you didn't put a

490
00:20:01,859 --> 00:20:05,609
QQ on in front of it but I noticed it

491
00:20:03,150 --> 00:20:08,429
here he just want to know so why do I

492
00:20:05,609 --> 00:20:12,058
still need Linux to compile for Linux

493
00:20:08,429 --> 00:20:16,200
and the answer is you probably actually

494
00:20:12,058 --> 00:20:19,589
don't but here are the reasons in

495
00:20:16,200 --> 00:20:22,710
practice why you often times have to be

496
00:20:19,589 --> 00:20:26,609
on a particular platform to compile for

497
00:20:22,710 --> 00:20:28,919
that platform reason number one is some

498
00:20:26,609 --> 00:20:31,168
important tool in this some some piece

499
00:20:28,919 --> 00:20:32,730
of this chain is not available for the

500
00:20:31,169 --> 00:20:35,788
platform you're talking about so for

501
00:20:32,730 --> 00:20:38,419
example right I don't think I don't know

502
00:20:35,788 --> 00:20:41,460
if on Linux there is a Windows linker

503
00:20:38,419 --> 00:20:43,020
like LLVM doesn't have a Windows linker

504
00:20:41,460 --> 00:20:46,350
a thing that it doesn't have a thing

505
00:20:43,019 --> 00:20:49,079
that can link to an egg's II so LLVM on

506
00:20:46,349 --> 00:20:50,969
Linux can very easily output obj code

507
00:20:49,079 --> 00:20:53,308
that could be used for a Windows program

508
00:20:50,970 --> 00:20:55,950
but on Linux you may not have access to

509
00:20:53,308 --> 00:20:57,690
a Windows linker right now I assume by

510
00:20:55,950 --> 00:21:00,210
now someone probably has run it like

511
00:20:57,690 --> 00:21:01,590
Ming Ming GW Ming win or whatever has

512
00:21:00,210 --> 00:21:03,720
won so I assume you can do it on Linux

513
00:21:01,589 --> 00:21:05,158
right so I assume that that's actually

514
00:21:03,720 --> 00:21:07,529
the case I don't really know though so I

515
00:21:05,159 --> 00:21:09,450
have no idea but point being one reason

516
00:21:07,529 --> 00:21:12,058
that you might not be able to do

517
00:21:09,450 --> 00:21:14,400
something is because the linker has

518
00:21:12,058 --> 00:21:15,839
never been ported so you might have

519
00:21:14,400 --> 00:21:17,159
access to the compiler but not the

520
00:21:15,839 --> 00:21:19,019
linker or I guess the other way around

521
00:21:17,159 --> 00:21:21,210
you may be a linker not compile but so

522
00:21:19,019 --> 00:21:22,798
in practice you may not have all the

523
00:21:21,210 --> 00:21:24,269
tools that you actually need on any on

524
00:21:22,798 --> 00:21:26,538
one platform so that's one thing can

525
00:21:24,269 --> 00:21:29,639
happen the next thing that can happen is

526
00:21:26,538 --> 00:21:32,658
nobody may have done the work of setting

527
00:21:29,640 --> 00:21:35,360
up all the dependencies so for example

528
00:21:32,659 --> 00:21:38,250
you know in order to compile a program

529
00:21:35,359 --> 00:21:40,349
oftentimes you need all of these system

530
00:21:38,250 --> 00:21:43,019
header files all these dot H file system

531
00:21:40,349 --> 00:21:45,869
header files system library files right

532
00:21:43,019 --> 00:21:47,759
if you don't have all those you need all

533
00:21:45,869 --> 00:21:49,229
of those in order for the compiler in

534
00:21:47,759 --> 00:21:52,079
the linker to grab them when they're

535
00:21:49,230 --> 00:21:54,099
required and so in order to build for

536
00:21:52,079 --> 00:21:56,470
Linux say on Windows

537
00:21:54,099 --> 00:21:58,538
you need to grab all those files and you

538
00:21:56,470 --> 00:22:00,220
need to put them all on Windows and so

539
00:21:58,538 --> 00:22:02,019
that your windows toolchain can access

540
00:22:00,220 --> 00:22:04,870
them right

541
00:22:02,019 --> 00:22:07,058
and so again cross compiling

542
00:22:04,869 --> 00:22:09,159
conceptually is incredibly simple

543
00:22:07,058 --> 00:22:12,819
hopefully it's you know I convinced you

544
00:22:09,160 --> 00:22:15,220
of that but as you know and builds can

545
00:22:12,819 --> 00:22:17,980
get incredibly confusing right

546
00:22:15,220 --> 00:22:19,890
as with many unnecessarily complicated

547
00:22:17,980 --> 00:22:21,910
build processes building for an OS

548
00:22:19,890 --> 00:22:23,049
oftentimes is way more complicated that

549
00:22:21,910 --> 00:22:24,519
needs to be because there's all these

550
00:22:23,048 --> 00:22:26,529
libraries you have to link with there's

551
00:22:24,519 --> 00:22:28,480
all this special stuff that has to

552
00:22:26,529 --> 00:22:30,279
happen for producing executable or

553
00:22:28,480 --> 00:22:32,048
there's all these system header files

554
00:22:30,279 --> 00:22:35,798
like hundreds of system enter files blah

555
00:22:32,048 --> 00:22:37,599
blah blah and you have to reproduce that

556
00:22:35,798 --> 00:22:40,029
whole environment because otherwise you

557
00:22:37,599 --> 00:22:44,069
know the compiler it sees pound include

558
00:22:40,029 --> 00:22:46,178
you know some some Linux header file and

559
00:22:44,069 --> 00:22:48,908
windows you know that's not on your

560
00:22:46,179 --> 00:22:50,440
machine so you do have to do a bunch of

561
00:22:48,909 --> 00:22:53,140
work to set up a cross compiling

562
00:22:50,440 --> 00:22:55,298
environment oftentimes that has nothing

563
00:22:53,140 --> 00:22:57,100
to do with having an actual compiler

564
00:22:55,298 --> 00:22:59,349
that can produce the code sometimes

565
00:22:57,099 --> 00:23:00,969
that's the easy part and the hard part

566
00:22:59,349 --> 00:23:03,579
is all the accoutrement

567
00:23:00,970 --> 00:23:05,440
although like you know other files that

568
00:23:03,579 --> 00:23:07,210
have to get input into the process so

569
00:23:05,440 --> 00:23:09,100
the compiler when you say pound include

570
00:23:07,210 --> 00:23:12,669
this there actually is that that thing

571
00:23:09,099 --> 00:23:14,319
right but that said I would be surprised

572
00:23:12,669 --> 00:23:17,200
if you can't compile for Linux on

573
00:23:14,319 --> 00:23:18,819
Windows I suspect you can are you sure

574
00:23:17,200 --> 00:23:23,740
there's not a tool chain for that I feel

575
00:23:18,819 --> 00:23:25,689
like I feel like that would surprise me

576
00:23:23,740 --> 00:23:30,099
it's probably super janky but I feel

577
00:23:25,690 --> 00:23:35,230
like it's probably exists anyway all

578
00:23:30,099 --> 00:23:37,408
right so let's go ahead and close things

579
00:23:35,230 --> 00:23:37,409
down

580
00:23:40,710 --> 00:23:48,190
all right I don't want to sign into

581
00:23:44,019 --> 00:23:49,720
Google accounts but thank you all right

582
00:23:48,190 --> 00:23:50,860
thanks everyone for joining me for the

583
00:23:49,720 --> 00:23:52,960
lip soda handmade hero it's been a

584
00:23:50,859 --> 00:23:55,059
pleasure chatting with you

585
00:23:52,960 --> 00:23:57,279
like I said we're on RSI break right now

586
00:23:55,059 --> 00:23:58,839
I don't have a specific ETA for when

587
00:23:57,279 --> 00:24:03,039
we'll be actually doing game coding

588
00:23:58,839 --> 00:24:06,549
again but if you would like to join us

589
00:24:03,039 --> 00:24:09,819
for more Q&amp;A style chats obviously we're

590
00:24:06,549 --> 00:24:11,470
still here 5:30 p.m. tomorrow I think

591
00:24:09,819 --> 00:24:13,629
check the tweet but though I may have to

592
00:24:11,470 --> 00:24:15,519
move it up to 6:00 I can't quite

593
00:24:13,630 --> 00:24:16,630
remember what exactly the schedule will

594
00:24:15,519 --> 00:24:17,859
end up having to be for tomorrow there

595
00:24:16,630 --> 00:24:20,380
might be a reason why it has to be moved

596
00:24:17,859 --> 00:24:22,299
slightly but we'll be a Becker shouting

597
00:24:20,380 --> 00:24:24,400
and then next week I will also post the

598
00:24:22,299 --> 00:24:26,019
tweet bot scheduled for next week so if

599
00:24:24,400 --> 00:24:29,830
you've got questions tech questions that

600
00:24:26,019 --> 00:24:31,720
you want answered I can I can feel them

601
00:24:29,829 --> 00:24:34,839
or if you just want to chat like I said

602
00:24:31,720 --> 00:24:36,460
we we do a pre stream I basically take

603
00:24:34,839 --> 00:24:37,899
off-topic questions till the first on

604
00:24:36,460 --> 00:24:40,600
topic question and then I start the

605
00:24:37,900 --> 00:24:43,120
recorded stream so if you have off-topic

606
00:24:40,599 --> 00:24:44,919
questions we cover those too that's

607
00:24:43,119 --> 00:24:46,419
about it for now I'll hopefully see you

608
00:24:44,920 --> 00:24:49,630
all tomorrow

609
00:24:46,420 --> 00:24:50,740
back here on Twitch until then have fun

610
00:24:49,630 --> 00:24:52,830
programming I'll see you guys on the

611
00:24:50,740 --> 00:24:52,829
Internet

