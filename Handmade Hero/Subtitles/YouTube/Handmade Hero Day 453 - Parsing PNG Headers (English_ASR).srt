1
00:00:00,030 --> 00:00:04,169
hello everyone and welcome to handmade

2
00:00:02,158 --> 00:00:07,258
Hero show recode complete-game live on

3
00:00:04,169 --> 00:00:13,289
stream we are gonna have some unsavory

4
00:00:07,259 --> 00:00:15,030
tasks to do this weekend and so yeah

5
00:00:13,289 --> 00:00:17,399
it's just something we're gonna have to

6
00:00:15,029 --> 00:00:21,028
dive straight into so where we left off

7
00:00:17,399 --> 00:00:24,028
last weekend is we pretty much you know

8
00:00:21,028 --> 00:00:27,929
we kept everything that we were doing

9
00:00:24,028 --> 00:00:29,339
sort of well okay I could split this

10
00:00:27,929 --> 00:00:30,928
into two halves I suppose there is

11
00:00:29,339 --> 00:00:32,759
something we could do before diving into

12
00:00:30,928 --> 00:00:34,199
the unsavory Ness but we basically took

13
00:00:32,759 --> 00:00:35,960
a look at everything we were doing and

14
00:00:34,200 --> 00:00:39,390
we went ahead and made it so that our

15
00:00:35,960 --> 00:00:42,090
our camera behavior was reasonable now

16
00:00:39,390 --> 00:00:43,500
and our our lightning behavior was

17
00:00:42,090 --> 00:00:45,780
reasonable in terms of tracking where

18
00:00:43,500 --> 00:00:47,340
the player moves and stuff like this so

19
00:00:45,780 --> 00:00:49,170
now we can reasonably walk around the

20
00:00:47,340 --> 00:00:50,940
game and do what we're gonna do but we

21
00:00:49,170 --> 00:00:52,559
don't have any artist that's in here at

22
00:00:50,939 --> 00:00:55,128
the moment and that's a problem so that

23
00:00:52,558 --> 00:00:57,718
was the next big thing that we had to do

24
00:00:55,128 --> 00:01:01,409
was have a way of figuring out how we

25
00:00:57,719 --> 00:01:02,609
were going to specify that that piece of

26
00:01:01,409 --> 00:01:05,280
information like how we were gonna get

27
00:01:02,609 --> 00:01:06,659
the art assets in in the new that we

28
00:01:05,280 --> 00:01:10,049
want to so let me talk about the two

29
00:01:06,659 --> 00:01:11,909
things that we could do today and I

30
00:01:10,049 --> 00:01:13,470
think probably we should just get right

31
00:01:11,909 --> 00:01:15,719
into the art asset stuff because the

32
00:01:13,469 --> 00:01:17,819
other part of its not as important all

33
00:01:15,719 --> 00:01:19,200
right so one thing that we could do

34
00:01:17,819 --> 00:01:21,239
today that I think that we should just

35
00:01:19,200 --> 00:01:23,368
skip and we can leave to later is that

36
00:01:21,239 --> 00:01:26,429
for large rooms we wanted to have camera

37
00:01:23,368 --> 00:01:28,978
scrolling and right now that's very

38
00:01:26,430 --> 00:01:31,409
simple it's not a lot to do with

39
00:01:28,978 --> 00:01:32,728
anything it's just a very simple thing

40
00:01:31,409 --> 00:01:35,400
we would have to do that would allow us

41
00:01:32,728 --> 00:01:37,769
to to know that this room is too large

42
00:01:35,400 --> 00:01:39,780
for the zoom out because we said we only

43
00:01:37,769 --> 00:01:42,118
wanted to zoom out about this far well

44
00:01:39,780 --> 00:01:44,609
this room is too big so if you only zoom

45
00:01:42,118 --> 00:01:46,170
out to the maximum zoom out you end up

46
00:01:44,609 --> 00:01:48,478
in a situation where you can't actually

47
00:01:46,170 --> 00:01:50,670
see the whole room so we need the camera

48
00:01:48,478 --> 00:01:51,989
to follow the player around that's not

49
00:01:50,670 --> 00:01:54,210
particularly difficult we've already

50
00:01:51,989 --> 00:01:55,379
done it before on handmade hero we just

51
00:01:54,209 --> 00:01:59,188
need a thing that basically says that

52
00:01:55,379 --> 00:02:01,019
it's doing it now so that would just be

53
00:01:59,188 --> 00:02:03,449
coupled with pulling the camera code out

54
00:02:01,019 --> 00:02:05,340
and adding a better interpolator right

55
00:02:03,450 --> 00:02:07,200
now we just have a sort of makeshift

56
00:02:05,340 --> 00:02:08,368
interpolator in place and we can do a

57
00:02:07,200 --> 00:02:10,110
lot better than what's in there right

58
00:02:08,368 --> 00:02:12,419
now so that would also be something we'd

59
00:02:10,110 --> 00:02:13,500
discuss and then do the reason I don't

60
00:02:12,419 --> 00:02:13,959
think that's particularly useful right

61
00:02:13,500 --> 00:02:15,310
now is

62
00:02:13,960 --> 00:02:16,510
really not a blocking factor and

63
00:02:15,310 --> 00:02:18,550
basically anything I mean you could play

64
00:02:16,509 --> 00:02:19,959
the whole game like this honestly and we

65
00:02:18,550 --> 00:02:21,160
could just make the zoom out be a little

66
00:02:19,960 --> 00:02:23,290
bit further and then just play the whole

67
00:02:21,159 --> 00:02:24,909
game like this so it's really not

68
00:02:23,289 --> 00:02:26,620
stopping us from implementing the rest

69
00:02:24,909 --> 00:02:28,030
of the game the thing that isn't

70
00:02:26,620 --> 00:02:31,390
stopping us from the plantiffs the game

71
00:02:28,030 --> 00:02:32,949
right now is the lack of any art assets

72
00:02:31,389 --> 00:02:34,469
in the game other than just the

73
00:02:32,949 --> 00:02:36,699
Testaments that we brought in originally

74
00:02:34,469 --> 00:02:38,229
so that's the part that I wanted to

75
00:02:36,699 --> 00:02:41,289
start addressing now because I think

76
00:02:38,229 --> 00:02:43,899
that's the biggest obstacle to starting

77
00:02:41,289 --> 00:02:46,150
to tune anything in the game and so the

78
00:02:43,900 --> 00:02:49,120
problem there that we have is we made a

79
00:02:46,150 --> 00:02:50,800
thing that would allow us to pack our

80
00:02:49,120 --> 00:02:52,300
debts into a pack file and load on the

81
00:02:50,800 --> 00:02:54,490
pack files so that all stuff just works

82
00:02:52,300 --> 00:02:55,420
fine but that was created at a time

83
00:02:54,490 --> 00:02:57,790
where and we didn't really know that

84
00:02:55,419 --> 00:03:01,269
we'd have a artist potentially working

85
00:02:57,789 --> 00:03:02,109
on the project so we didn't know that

86
00:03:01,270 --> 00:03:03,969
we'd have someone who could actually

87
00:03:02,110 --> 00:03:07,240
like play the game and perhaps want to

88
00:03:03,969 --> 00:03:09,280
be able to tune art assets while playing

89
00:03:07,240 --> 00:03:12,460
the game and see them reload and stuff

90
00:03:09,280 --> 00:03:14,020
like that and so one of the things we

91
00:03:12,460 --> 00:03:15,700
didn't do was any kind of a hot

92
00:03:14,020 --> 00:03:17,830
reloading path and the reason for that

93
00:03:15,699 --> 00:03:19,149
is really pretty straight forward it's a

94
00:03:17,830 --> 00:03:21,190
real pain in the butt

95
00:03:19,150 --> 00:03:23,020
now oddly enough it's not a pain in the

96
00:03:21,189 --> 00:03:25,359
butt in terms of the actual

97
00:03:23,020 --> 00:03:26,980
architectural issues that we have

98
00:03:25,360 --> 00:03:28,480
we pretty much would already support it

99
00:03:26,979 --> 00:03:31,239
it'd be trivial to drop it in it'd be

100
00:03:28,479 --> 00:03:32,469
really really straightforward I think so

101
00:03:31,240 --> 00:03:34,810
that's really not that big of a deal

102
00:03:32,469 --> 00:03:36,669
because our asset system already does

103
00:03:34,810 --> 00:03:38,650
loading on-demand and streaming and that

104
00:03:36,669 --> 00:03:40,509
sort of stuff so when you have an asset

105
00:03:38,650 --> 00:03:42,280
system that does that you're pretty much

106
00:03:40,509 --> 00:03:44,229
good to go like you know hot loading is

107
00:03:42,280 --> 00:03:46,719
just you can just pretend the asset

108
00:03:44,229 --> 00:03:47,769
wasn't loaded you just say this asset

109
00:03:46,719 --> 00:03:49,539
wasn't loaded and then it'll try to

110
00:03:47,770 --> 00:03:50,890
reload it again right so hot loading is

111
00:03:49,539 --> 00:03:53,469
really really simple when you've already

112
00:03:50,889 --> 00:03:55,899
done the work of having a streaming

113
00:03:53,469 --> 00:03:57,580
asset system so that's the good news the

114
00:03:55,900 --> 00:03:59,920
bad news is if we actually want to load

115
00:03:57,580 --> 00:04:01,420
things in that way then what we need to

116
00:03:59,919 --> 00:04:03,699
do is we need to load a format that an

117
00:04:01,419 --> 00:04:04,899
artist actually might save and one of

118
00:04:03,699 --> 00:04:06,429
the things that's really annoying for

119
00:04:04,900 --> 00:04:08,590
example about Photoshop is Photoshop

120
00:04:06,430 --> 00:04:11,080
doesn't really have a quick export path

121
00:04:08,590 --> 00:04:13,569
for say a BMP or something simple to

122
00:04:11,080 --> 00:04:15,280
load all of its quick export paths like

123
00:04:13,569 --> 00:04:16,569
the simple buttons for an artist to hit

124
00:04:15,280 --> 00:04:21,759
inside Photoshop that will quickly

125
00:04:16,569 --> 00:04:24,009
export a bitmap to a drive for use in a

126
00:04:21,759 --> 00:04:26,259
game for example are all PNG based and

127
00:04:24,009 --> 00:04:27,639
so our problem that we have the thing

128
00:04:26,259 --> 00:04:30,579
that would stop us from being able to

129
00:04:27,639 --> 00:04:32,110
load art assets into the game in real

130
00:04:30,579 --> 00:04:35,378
time like that is that we don't have a

131
00:04:32,110 --> 00:04:37,960
PNG loader so that's really the problem

132
00:04:35,379 --> 00:04:39,278
that we have so what we need to do is we

133
00:04:37,959 --> 00:04:41,138
need to go through and figure out how

134
00:04:39,278 --> 00:04:42,639
we're gonna get that happening and

135
00:04:41,139 --> 00:04:44,019
that's why I say it's very unsavory

136
00:04:42,639 --> 00:04:46,778
tasks because there's nothing fun or

137
00:04:44,019 --> 00:04:48,788
interesting about loading a PNG it's not

138
00:04:46,778 --> 00:04:52,360
even a good data formats really pretty

139
00:04:48,788 --> 00:04:55,089
lousy but it's pretty much what you have

140
00:04:52,360 --> 00:04:57,759
to do and so what we need to do is we

141
00:04:55,089 --> 00:05:01,869
need to look so for example inside our

142
00:04:57,759 --> 00:05:05,020
code base here we can look for BMP and

143
00:05:01,870 --> 00:05:07,000
what you can see is that we've got a BMP

144
00:05:05,019 --> 00:05:09,609
loader that we wrote inside the asset

145
00:05:07,000 --> 00:05:10,930
builder here and you can see how simple

146
00:05:09,610 --> 00:05:14,590
this is right I mean this is basically

147
00:05:10,930 --> 00:05:17,468
one function long that has almost

148
00:05:14,589 --> 00:05:21,688
nothing in it it just reads it does one

149
00:05:17,468 --> 00:05:23,978
simple read of a file to read a header

150
00:05:21,689 --> 00:05:25,870
so basically you know you see you in

151
00:05:23,978 --> 00:05:28,209
here at capacity filename it just reads

152
00:05:25,870 --> 00:05:29,949
the file in it does one simple it's not

153
00:05:28,209 --> 00:05:31,899
really read just looks at the memory it

154
00:05:29,949 --> 00:05:34,060
looks at the first part of the memory it

155
00:05:31,899 --> 00:05:35,739
knows that's a header it pulls out of

156
00:05:34,060 --> 00:05:38,079
that header what the width and height is

157
00:05:35,740 --> 00:05:39,810
it looks at some masked values to figure

158
00:05:38,079 --> 00:05:43,658
out where the red green blue and alpha

159
00:05:39,810 --> 00:05:46,329
bits are in each pixel and then it loops

160
00:05:43,658 --> 00:05:50,050
through and extracts those and that's

161
00:05:46,329 --> 00:05:54,639
all it does right it doesn't really do

162
00:05:50,050 --> 00:05:57,069
anything else so you know that's the

163
00:05:54,639 --> 00:05:58,658
simplicity of a file format that really

164
00:05:57,069 --> 00:06:01,509
just doesn't have any complexity to it

165
00:05:58,658 --> 00:06:03,639
there's no compression to speak of here

166
00:06:01,509 --> 00:06:05,860
or transforms on the data

167
00:06:03,639 --> 00:06:07,240
there's no extensibility that we need to

168
00:06:05,860 --> 00:06:09,038
concern ourselves with so on

169
00:06:07,240 --> 00:06:10,838
to be honest BMP is actually a pretty

170
00:06:09,038 --> 00:06:12,250
good format in that sense it's pretty

171
00:06:10,838 --> 00:06:14,168
straightforward there's not a lot you

172
00:06:12,250 --> 00:06:15,610
have to do there are some things about

173
00:06:14,168 --> 00:06:18,128
it that are kind of dumb like the fact

174
00:06:15,610 --> 00:06:20,348
that it allows up up down and down up

175
00:06:18,129 --> 00:06:21,908
bitmaps and stuff and things that are

176
00:06:20,348 --> 00:06:24,788
just adding complexity for not really

177
00:06:21,908 --> 00:06:26,978
much value in my opinion but that's kind

178
00:06:24,788 --> 00:06:29,378
of a separate issue and it's still

179
00:06:26,978 --> 00:06:31,810
pretty straightforward to read PNG is

180
00:06:29,379 --> 00:06:35,020
not that way that it's not really the

181
00:06:31,810 --> 00:06:38,079
way PNG works PNG is a much more

182
00:06:35,019 --> 00:06:41,319
traditional crufty file format it's

183
00:06:38,079 --> 00:06:43,300
based on blocks those blocks just get

184
00:06:41,319 --> 00:06:46,209
slammed into a file they're not

185
00:06:43,300 --> 00:06:47,980
particularly well thought through and it

186
00:06:46,209 --> 00:06:51,310
doesn't really stake out a very good

187
00:06:47,980 --> 00:06:53,470
place in terms of complexity versus bang

188
00:06:51,310 --> 00:06:54,759
for the buck it mostly just adds a lot

189
00:06:53,470 --> 00:06:59,080
of complexity without really giving you

190
00:06:54,759 --> 00:07:00,759
much beyond an hourly bitmap you get a

191
00:06:59,079 --> 00:07:02,139
little bit better because it uses what's

192
00:07:00,759 --> 00:07:05,649
called LZ compression which we actually

193
00:07:02,139 --> 00:07:06,879
sort of covered really basic LZ

194
00:07:05,649 --> 00:07:08,229
compression in the stream on compression

195
00:07:06,879 --> 00:07:09,550
that we did one time is a one-off I

196
00:07:08,230 --> 00:07:11,110
think it was because Midler was talking

197
00:07:09,550 --> 00:07:13,420
about implementing I'll see stuff maybe

198
00:07:11,110 --> 00:07:17,550
I don't remember if we did philsie or

199
00:07:13,420 --> 00:07:20,500
not we may have only done basically I

200
00:07:17,550 --> 00:07:22,629
just can't remember but anyway point

201
00:07:20,500 --> 00:07:25,089
being you get very little extra stuff

202
00:07:22,629 --> 00:07:27,579
and you add a ton of complexity for

203
00:07:25,089 --> 00:07:29,799
having to handle it now fortunately for

204
00:07:27,579 --> 00:07:32,259
us one of the things that is nice about

205
00:07:29,800 --> 00:07:33,879
our situation is again we're only

206
00:07:32,259 --> 00:07:36,399
talking we're not talking about

207
00:07:33,879 --> 00:07:39,360
releasing this out into the wilds where

208
00:07:36,399 --> 00:07:42,609
the program itself is expected to read

209
00:07:39,360 --> 00:07:44,860
PNG files like you would if you were an

210
00:07:42,610 --> 00:07:47,319
art package right so we're not releasing

211
00:07:44,860 --> 00:07:51,100
this PNG code out in some way where

212
00:07:47,319 --> 00:07:54,040
we're gonna be making sort of some kind

213
00:07:51,100 --> 00:07:55,510
of a warrant to the general user that

214
00:07:54,040 --> 00:07:57,520
we're gonna load a PNG file because if

215
00:07:55,509 --> 00:08:00,939
you do that then you have to support

216
00:07:57,519 --> 00:08:03,159
like all PNG files right and PNG files

217
00:08:00,939 --> 00:08:05,379
because again they have a lot of crufty

218
00:08:03,160 --> 00:08:08,189
complexity to them there's actually a

219
00:08:05,379 --> 00:08:11,079
lot of different ways that a PNG file

220
00:08:08,189 --> 00:08:12,969
can be stored they have like palletized

221
00:08:11,079 --> 00:08:16,419
versions for example and other things

222
00:08:12,970 --> 00:08:18,940
like that which we won't have to support

223
00:08:16,420 --> 00:08:21,580
because we know that our art is always

224
00:08:18,939 --> 00:08:25,600
going to be saved in 32-bit color format

225
00:08:21,579 --> 00:08:27,669
24 bits RGB and 8 bits alpha right or 8

226
00:08:25,600 --> 00:08:31,629
bits each of our GBA might be another

227
00:08:27,670 --> 00:08:34,240
way set so we do buy ourselves a little

228
00:08:31,629 --> 00:08:36,460
bit of a better time there because we

229
00:08:34,240 --> 00:08:39,340
don't have to go through every aspect of

230
00:08:36,460 --> 00:08:41,769
the PNG spec and make sure that we get

231
00:08:39,340 --> 00:08:46,240
it right because we know that we'll only

232
00:08:41,769 --> 00:08:49,210
be looking at a few basic export sources

233
00:08:46,240 --> 00:08:51,009
for example we can support Photoshop

234
00:08:49,210 --> 00:08:53,860
which we know we need and maybe

235
00:08:51,009 --> 00:08:54,980
which is a freely alternative freely

236
00:08:53,860 --> 00:08:58,009
available alternative

237
00:08:54,980 --> 00:08:59,899
gram for example and so we can focus our

238
00:08:58,009 --> 00:09:02,480
attentions just on doing the bare

239
00:08:59,899 --> 00:09:04,578
minimum necessary to read pngs that come

240
00:09:02,480 --> 00:09:07,430
from those two sources and that is nice

241
00:09:04,578 --> 00:09:09,638
it's not still the best thing in the

242
00:09:07,429 --> 00:09:12,708
world but it's better than nothing so

243
00:09:09,639 --> 00:09:15,560
that's the situation as it stands and we

244
00:09:12,708 --> 00:09:16,939
need to to just attack it head-on

245
00:09:15,559 --> 00:09:18,828
there's nothing else we can really do

246
00:09:16,940 --> 00:09:20,480
other than what I just said if we want

247
00:09:18,828 --> 00:09:21,888
it to be inside the game then we have to

248
00:09:20,480 --> 00:09:25,070
write it ourselves that's the rules on

249
00:09:21,889 --> 00:09:26,659
handmade hero so here we go the first

250
00:09:25,070 --> 00:09:29,180
thing I'm going to do is I don't even

251
00:09:26,659 --> 00:09:32,750
know if we have installed here we

252
00:09:29,179 --> 00:09:34,849
probably don't do B yes we do no we

253
00:09:32,750 --> 00:09:38,120
don't this is the search thank you for

254
00:09:34,850 --> 00:09:41,379
loading up a browser that I don't use so

255
00:09:38,120 --> 00:09:43,730
if I go here and just search for

256
00:09:41,379 --> 00:09:45,708
I'm gonna download this and the first

257
00:09:43,730 --> 00:09:48,800
thing we're going to do is create a PNG

258
00:09:45,708 --> 00:09:53,359
that we'll start with and try to use for

259
00:09:48,799 --> 00:09:55,370
our hopefully this has a just have a

260
00:09:53,360 --> 00:10:00,528
Windows version let's see get for

261
00:09:55,370 --> 00:10:03,860
Windows there we go we're gonna load up

262
00:10:00,528 --> 00:10:05,929
will create a PNG and save it and

263
00:10:03,860 --> 00:10:08,318
then we will start to try and read it by

264
00:10:05,929 --> 00:10:11,179
working off of the specification for PNG

265
00:10:08,318 --> 00:10:13,610
which is freely available so we can just

266
00:10:11,179 --> 00:10:16,239
look at it and try to figure out what

267
00:10:13,610 --> 00:10:18,259
the most efficacious way would be to

268
00:10:16,240 --> 00:10:19,818
read something that comes out of

269
00:10:18,259 --> 00:10:21,500
and then we'll take a Photoshop file

270
00:10:19,818 --> 00:10:22,818
when we get that working and we'll see

271
00:10:21,500 --> 00:10:24,889
if there are any differences between the

272
00:10:22,818 --> 00:10:26,328
King for the Photoshop versions in terms

273
00:10:24,889 --> 00:10:28,490
of what they're likely to spit out and

274
00:10:26,328 --> 00:10:30,198
then we'll have a reader that reads from

275
00:10:28,490 --> 00:10:32,448
those two sources and we'll just say

276
00:10:30,198 --> 00:10:35,240
look anyone making art had better

277
00:10:32,448 --> 00:10:37,278
produce PM G's that are compliant with

278
00:10:35,240 --> 00:10:39,019
these two packages or and if the source

279
00:10:37,278 --> 00:10:43,278
code yourself if you want to use

280
00:10:39,019 --> 00:10:46,129
something else so that's the current

281
00:10:43,278 --> 00:10:49,039
situation this has downloaded here so

282
00:10:46,129 --> 00:10:52,129
that's good we'll go ahead and run that

283
00:10:49,039 --> 00:10:54,759
setup program and then we should be good

284
00:10:52,129 --> 00:10:54,759
to go

285
00:11:02,909 --> 00:11:20,309
I don't really care about that but

286
00:11:08,639 --> 00:11:23,519
whatever I don't really think I want any

287
00:11:20,309 --> 00:11:26,119
of that stuff just sounds a little bit a

288
00:11:23,519 --> 00:11:26,120
little bit much

289
00:11:26,809 --> 00:11:30,479
you don't think we you know I don't

290
00:11:29,039 --> 00:11:41,899
really want any of this any stuff at all

291
00:11:30,480 --> 00:11:41,899
just install the thing all right

292
00:11:43,190 --> 00:11:49,010
so while that's doing its thing I'm

293
00:11:46,169 --> 00:11:53,429
gonna go ahead and look up the PNG spec

294
00:11:49,009 --> 00:11:57,330
so here's the w3c version I'm going to

295
00:11:53,429 --> 00:11:59,159
look at a couple different pieces of

296
00:11:57,330 --> 00:12:01,110
information here just in terms of

297
00:11:59,159 --> 00:12:05,100
anything that I see that I you know I

298
00:12:01,110 --> 00:12:10,080
might be interested in so here's the w3

299
00:12:05,100 --> 00:12:13,909
C's version here's sort of looks like an

300
00:12:10,080 --> 00:12:13,910
old version from 96

301
00:12:20,480 --> 00:12:25,909
looks like that just kind of goes back

302
00:12:22,220 --> 00:12:33,590
up to there so maybe we'll leave that

303
00:12:25,909 --> 00:12:37,990
out for now I don't know what the

304
00:12:33,590 --> 00:12:37,990
difference is between these two here

305
00:12:41,409 --> 00:12:50,719
this must be an older version maybe but

306
00:12:49,279 --> 00:12:53,539
I'm gonna leave both those up I don't

307
00:12:50,720 --> 00:12:56,180
know which one will be more useful to us

308
00:12:53,539 --> 00:12:58,610
but I'm gonna leave those two up all

309
00:12:56,179 --> 00:12:59,629
right so we've installed and again

310
00:12:58,610 --> 00:13:03,320
that's something you can do at home

311
00:12:59,629 --> 00:13:05,480
because it's free software I've never

312
00:13:03,320 --> 00:13:08,150
used goop goo that's good

313
00:13:05,480 --> 00:13:10,960
2.10 I even know there was a

314
00:13:08,149 --> 00:13:14,419
2.10 ik the last version i used was 2.8

315
00:13:10,960 --> 00:13:15,800
I like to use single window mo but it

316
00:13:14,419 --> 00:13:17,360
looks like it's the default now that

317
00:13:15,799 --> 00:13:18,379
didn't used to be used to have windows

318
00:13:17,360 --> 00:13:20,750
floating all over the place and it was

319
00:13:18,379 --> 00:13:22,490
kind of nuts but it looks like this

320
00:13:20,750 --> 00:13:24,500
defaults to that now so that's kind of

321
00:13:22,490 --> 00:13:28,190
nice all right I'm gonna go ahead and

322
00:13:24,500 --> 00:13:31,700
make a new image here I don't really

323
00:13:28,190 --> 00:13:33,950
care at the moment what we do in terms

324
00:13:31,700 --> 00:13:35,540
of sizes so I'm just gonna make a square

325
00:13:33,950 --> 00:13:38,300
texture for the moment actually I

326
00:13:35,539 --> 00:13:40,159
suppose we're always gonna be loading

327
00:13:38,299 --> 00:13:42,109
square textures from the art so I'll

328
00:13:40,159 --> 00:13:43,399
just make one because that's the the

329
00:13:42,110 --> 00:13:45,470
common thing that we're gonna use and

330
00:13:43,399 --> 00:13:47,689
we'll be using a power of two sizing as

331
00:13:45,470 --> 00:13:49,399
well so we know that that's always going

332
00:13:47,690 --> 00:13:51,680
to be the case

333
00:13:49,399 --> 00:13:55,819
we do want RGB color we do on 8-bit

334
00:13:51,679 --> 00:13:58,969
integer space we do want srgb and I

335
00:13:55,820 --> 00:14:02,000
think that's really all we need for our

336
00:13:58,970 --> 00:14:05,230
thing now normally like I said if we

337
00:14:02,000 --> 00:14:07,580
were writing an arbitrary loader I

338
00:14:05,230 --> 00:14:08,720
wouldn't make a square texture because

339
00:14:07,580 --> 00:14:10,730
you want to make sure you handle the

340
00:14:08,720 --> 00:14:12,470
width and the height separately and I

341
00:14:10,730 --> 00:14:13,879
also wouldn't use a power of two with

342
00:14:12,470 --> 00:14:15,649
because you'd want to make sure that you

343
00:14:13,879 --> 00:14:18,049
didn't have to worry about some padding

344
00:14:15,649 --> 00:14:19,189
that was happening but like I said this

345
00:14:18,049 --> 00:14:23,839
is the only thing we're gonna support

346
00:14:19,190 --> 00:14:28,010
we're only going to support multiples of

347
00:14:23,840 --> 00:14:29,450
1024 and by 1024 in general and we're

348
00:14:28,009 --> 00:14:33,139
mostly only going to be allowing squares

349
00:14:29,450 --> 00:14:33,680
so I am fine with that because this is

350
00:14:33,139 --> 00:14:37,039
not

351
00:14:33,679 --> 00:14:38,989
to be a general PNG loader now what I

352
00:14:37,039 --> 00:14:43,610
want to do here is I want to make

353
00:14:38,990 --> 00:14:45,440
something that I can reasonably test and

354
00:14:43,610 --> 00:14:47,930
make sure that we're you know doing

355
00:14:45,440 --> 00:14:50,600
something right so what I want to do

356
00:14:47,929 --> 00:14:52,879
here is I would like to make a little

357
00:14:50,600 --> 00:14:56,149
bit of information just up in the top

358
00:14:52,879 --> 00:14:59,088
corner of the PNG and then in the bottom

359
00:14:56,149 --> 00:15:00,769
corner of the PMG because I want to be

360
00:14:59,089 --> 00:15:03,560
able to quickly know what I'm looking at

361
00:15:00,769 --> 00:15:06,949
so what I'm gonna do here is I'm gonna

362
00:15:03,559 --> 00:15:11,379
put in the top corner I'm just gonna put

363
00:15:06,950 --> 00:15:16,990
loops it's not what I wanted at all I

364
00:15:11,379 --> 00:15:19,009
want just a pencil I want a simple pixel

365
00:15:16,990 --> 00:15:26,750
but doesn't look like I'm gonna get that

366
00:15:19,009 --> 00:15:36,919
so I guess I got to go in here so it

367
00:15:26,750 --> 00:15:39,409
looks like it looks like there we go if

368
00:15:36,919 --> 00:15:42,289
I want to make just one red dot there it

369
00:15:39,409 --> 00:15:45,199
looks like now I have done so so I just

370
00:15:42,289 --> 00:15:47,059
wanted one red dot up in that corner and

371
00:15:45,200 --> 00:15:50,240
then I'm gonna go down to the bottom

372
00:15:47,059 --> 00:15:53,809
here and I'm gonna put one green dot in

373
00:15:50,240 --> 00:15:55,430
the bottom and this is just a way again

374
00:15:53,809 --> 00:15:58,099
we've talked about structured art a

375
00:15:55,429 --> 00:16:01,189
couple times let me go ahead and make

376
00:15:58,100 --> 00:16:04,399
that size one I'm basically just setting

377
00:16:01,190 --> 00:16:06,440
myself up so that I can look and see if

378
00:16:04,399 --> 00:16:08,958
we've got something I don't want a

379
00:16:06,440 --> 00:16:10,580
complicated image because a complicated

380
00:16:08,958 --> 00:16:12,889
image is hard for me to visually inspect

381
00:16:10,580 --> 00:16:15,020
so I definitely don't want that right I

382
00:16:12,889 --> 00:16:18,319
want something that I can easily look at

383
00:16:15,019 --> 00:16:20,149
very quickly now what I would like to do

384
00:16:18,320 --> 00:16:23,180
is make sure that we've got an alpha

385
00:16:20,149 --> 00:16:25,759
channel here so I also want to go ahead

386
00:16:23,179 --> 00:16:27,949
and erase part of the image just so I

387
00:16:25,759 --> 00:16:30,319
can see when we actually load something

388
00:16:27,950 --> 00:16:35,120
in here I want to be able to see that an

389
00:16:30,320 --> 00:16:36,410
alpha comes through as well I can't tell

390
00:16:35,120 --> 00:16:37,250
which those as a racer I suspect is

391
00:16:36,409 --> 00:16:39,620
probably that one that looks like

392
00:16:37,250 --> 00:16:41,299
they've changed all the icons so I'm

393
00:16:39,620 --> 00:16:43,909
gonna go ahead here and it's

394
00:16:41,299 --> 00:16:47,359
an opacity that's lower why is that not

395
00:16:43,909 --> 00:16:52,100
I don't know why that's not erasing 100%

396
00:16:47,360 --> 00:16:54,409
where I am don't ask me but there we go

397
00:16:52,100 --> 00:16:57,430
so now we've got some alpha happening

398
00:16:54,409 --> 00:17:00,350
and we can take a look at that as well

399
00:16:57,429 --> 00:17:03,919
so that's all I really wanted out of my

400
00:17:00,350 --> 00:17:08,058
PNG and then just so we can look and see

401
00:17:03,919 --> 00:17:11,088
if the thing looks correct I can go

402
00:17:08,058 --> 00:17:12,980
ahead also and make the middle of it be

403
00:17:11,088 --> 00:17:15,678
something we could visually inspect at

404
00:17:12,980 --> 00:17:18,500
some point if we wanted to so just an

405
00:17:15,679 --> 00:17:22,269
empty area there and then I'm gonna load

406
00:17:18,500 --> 00:17:25,689
up a brush here of some arbitrary color

407
00:17:22,269 --> 00:17:27,859
something like this and I'll just write

408
00:17:25,689 --> 00:17:37,820
oops I've got to get a little bit

409
00:17:27,859 --> 00:17:41,719
thicker there our name in there and then

410
00:17:37,819 --> 00:17:43,159
we're good alright so I think that's all

411
00:17:41,720 --> 00:17:47,240
we really need I'm gonna go ahead and

412
00:17:43,160 --> 00:17:53,750
export this and I'm gonna put this into

413
00:17:47,240 --> 00:17:57,079
W handmade and I feel like normally this

414
00:17:53,750 --> 00:17:58,849
would go here in the data directory the

415
00:17:57,079 --> 00:18:00,789
data directory doesn't get synced and we

416
00:17:58,849 --> 00:18:05,539
might want this to just be a test ping

417
00:18:00,789 --> 00:18:08,629
so inside here maybe in one of these

418
00:18:05,539 --> 00:18:10,759
directories like misc or something we

419
00:18:08,630 --> 00:18:13,010
could put or maybe I could make a little

420
00:18:10,759 --> 00:18:15,470
test directory that we start sinking or

421
00:18:13,009 --> 00:18:17,210
something like that I'm not sure but let

422
00:18:15,470 --> 00:18:20,960
me go ahead and try it let's just have a

423
00:18:17,210 --> 00:18:22,190
test directory here and I'm going to

424
00:18:20,960 --> 00:18:28,549
call this

425
00:18:22,190 --> 00:18:31,640
PNG I guess we can just call it Gib test

426
00:18:28,549 --> 00:18:35,269
PNG and all I'm gonna do here is just

427
00:18:31,640 --> 00:18:37,520
export this and let it do whatever it's

428
00:18:35,269 --> 00:18:40,069
gonna do now I don't want it to do an

429
00:18:37,519 --> 00:18:42,740
automatic pixel format I'm presupposing

430
00:18:40,069 --> 00:18:46,970
that I only want eight bits per pixel

431
00:18:42,740 --> 00:18:48,980
RGB a and so I'm gonna force it to do

432
00:18:46,970 --> 00:18:52,190
that I don't care about the rest of this

433
00:18:48,980 --> 00:18:53,599
stuff really these will presumably

434
00:18:52,190 --> 00:18:56,059
create things that we don't actually

435
00:18:53,599 --> 00:18:57,709
care about anyway

436
00:18:56,059 --> 00:19:00,589
so we're just gonna leave it as it is

437
00:18:57,710 --> 00:19:05,090
now and hit export so that creates a PNG

438
00:19:00,589 --> 00:19:08,779
file and hopefully if I now go in and

439
00:19:05,089 --> 00:19:11,869
try to reload that PNG file I would just

440
00:19:08,779 --> 00:19:13,369
get exactly what we just looked at and

441
00:19:11,869 --> 00:19:17,779
nothing weird would happen right so

442
00:19:13,369 --> 00:19:21,579
there's our PNG presumably there's an

443
00:19:17,779 --> 00:19:21,579
open with there it is

444
00:19:23,720 --> 00:19:30,759
and so there's our image so that's what

445
00:19:27,200 --> 00:19:34,640
we want to do now is just get that basic

446
00:19:30,759 --> 00:19:37,789
operation working so what I'm gonna do

447
00:19:34,640 --> 00:19:41,420
at the outset here is I'm gonna just go

448
00:19:37,789 --> 00:19:45,319
ahead and probably make this its own

449
00:19:41,420 --> 00:19:48,620
little file so we've got in our build

450
00:19:45,319 --> 00:19:50,659
process you know there's a sort of the

451
00:19:48,619 --> 00:19:52,789
test asset builder here with forgot the

452
00:19:50,660 --> 00:19:56,240
line commented out and the simple

453
00:19:52,789 --> 00:19:58,579
compressor line here these are not

454
00:19:56,240 --> 00:20:00,529
things that are being used they're just

455
00:19:58,579 --> 00:20:03,439
things that we had played around with

456
00:20:00,529 --> 00:20:05,660
I'm gonna make another one of those that

457
00:20:03,440 --> 00:20:11,600
we can go in here and say alright I want

458
00:20:05,660 --> 00:20:12,650
you know maybe let's let you know what

459
00:20:11,599 --> 00:20:14,500
we could just make it be code we're

460
00:20:12,650 --> 00:20:18,320
actually gonna again let's just call it

461
00:20:14,500 --> 00:20:23,420
handmade PNG dot CPP and what we'll do

462
00:20:18,319 --> 00:20:25,789
is we'll make the handmade PNG code that

463
00:20:23,420 --> 00:20:28,130
would normally operate inside handmade

464
00:20:25,789 --> 00:20:30,049
hero and then what we'll do is we'll

465
00:20:28,130 --> 00:20:34,220
just stop compiling it as its own thing

466
00:20:30,049 --> 00:20:36,529
later when we need to to put it into the

467
00:20:34,220 --> 00:20:40,490
game so I'm gonna create that handmade

468
00:20:36,529 --> 00:20:47,389
PNG dot CPP here oops that's not the

469
00:20:40,490 --> 00:20:49,460
load command and PNG CPP and then what I

470
00:20:47,390 --> 00:20:52,009
want to do is I'm just gonna go into

471
00:20:49,460 --> 00:20:57,049
like simple compressor for example I'm

472
00:20:52,009 --> 00:20:59,839
just gonna copy out basic startup stuff

473
00:20:57,049 --> 00:21:02,000
and one thing I would like to do is I

474
00:20:59,839 --> 00:21:07,639
will go ahead and see if I can just do

475
00:21:02,000 --> 00:21:09,819
this and we'll see how that goes ok yeah

476
00:21:07,640 --> 00:21:09,820
we're

477
00:21:10,269 --> 00:21:14,589
so this way I can create a main here and

478
00:21:12,670 --> 00:21:18,460
I can just make something that reads a

479
00:21:14,589 --> 00:21:20,259
PNG and parses it and we can just have

480
00:21:18,460 --> 00:21:22,420
it be its own program that I can step

481
00:21:20,259 --> 00:21:24,640
into and test separate from everything

482
00:21:22,420 --> 00:21:29,580
else and then once it's working we just

483
00:21:24,640 --> 00:21:29,580
weld it into the mainline code so

484
00:21:30,299 --> 00:21:34,558
assuming that we've got a main here

485
00:21:39,450 --> 00:21:46,690
here's us loading a PNG quote/unquote by

486
00:21:43,900 --> 00:21:50,259
just printing yay so what I want to do

487
00:21:46,690 --> 00:21:52,120
now is I want to go ahead and take a

488
00:21:50,259 --> 00:21:55,720
look at what that did you can see it

489
00:21:52,119 --> 00:21:59,709
should have in here made that handmade

490
00:21:55,720 --> 00:22:02,319
PNG you can see that it did right so I'm

491
00:21:59,710 --> 00:22:03,970
gonna go ahead and run that and it'll

492
00:22:02,319 --> 00:22:05,619
just print PNG literally a so that just

493
00:22:03,970 --> 00:22:08,170
means we now have a little test area

494
00:22:05,619 --> 00:22:10,239
that we can make this thing in and off

495
00:22:08,170 --> 00:22:12,400
we go so the first thing I want to do is

496
00:22:10,240 --> 00:22:14,230
just load the entire file and we

497
00:22:12,400 --> 00:22:17,590
actually already have that in our simple

498
00:22:14,230 --> 00:22:20,289
preprocessor I'm sorry our simple asset

499
00:22:17,589 --> 00:22:23,259
our test asset builder we have read

500
00:22:20,289 --> 00:22:25,299
entire file and I just want exactly that

501
00:22:23,259 --> 00:22:28,000
so I'm just gonna sort of pirate that

502
00:22:25,299 --> 00:22:29,259
over here and that'll just serve as a

503
00:22:28,000 --> 00:22:31,808
pretty simple way for us to get the

504
00:22:29,259 --> 00:22:35,319
entire file into memory so what I want

505
00:22:31,808 --> 00:22:41,490
to do here is just say okay if the Arg

506
00:22:35,319 --> 00:22:44,649
count is equal to two then we can load

507
00:22:41,490 --> 00:22:47,349
otherwise we can't and what I'll do is

508
00:22:44,650 --> 00:22:50,890
I'll just print out an error if you

509
00:22:47,349 --> 00:22:58,029
don't use the right number of arguments

510
00:22:50,890 --> 00:23:00,550
to the program so we know that's how you

511
00:22:58,029 --> 00:23:01,990
use this thing we know that the zeroth

512
00:23:00,549 --> 00:23:05,319
argument is always the name of the

513
00:23:01,990 --> 00:23:08,039
executable so that's fine and then we

514
00:23:05,319 --> 00:23:08,039
know here

515
00:23:18,069 --> 00:23:26,059
so again nothing really revolutionary

516
00:23:23,029 --> 00:23:28,819
there just one say like okay so if we

517
00:23:26,059 --> 00:23:31,399
say ham a P&amp;G it'll say okay give us the

518
00:23:28,819 --> 00:23:33,529
file load if we give it a file to load

519
00:23:31,400 --> 00:23:35,630
then it'll try to load that file right

520
00:23:33,529 --> 00:23:37,430
so once we know which file we want to

521
00:23:35,630 --> 00:23:44,150
load we just say okay let's go ahead and

522
00:23:37,430 --> 00:23:45,529
read that in and now we have the entire

523
00:23:44,150 --> 00:23:47,870
file so then we can do

524
00:23:45,529 --> 00:23:56,359
why don't you parse this file right go

525
00:23:47,869 --> 00:23:57,679
ahead and okay so I don't know what this

526
00:23:56,359 --> 00:24:00,729
wants to look like it's I'm just gonna

527
00:23:57,680 --> 00:24:05,390
literally do exactly what it looks like

528
00:24:00,730 --> 00:24:08,539
and presumably what we want to do here

529
00:24:05,390 --> 00:24:10,370
is pass the file in and we'll just have

530
00:24:08,539 --> 00:24:14,019
something that will start out with just

531
00:24:10,369 --> 00:24:16,279
the real basic stuff of trying to parse

532
00:24:14,019 --> 00:24:19,339
what's in the file that's all we're

533
00:24:16,279 --> 00:24:23,210
gonna do right so nothing fancy just see

534
00:24:19,339 --> 00:24:24,919
if we can get the basics of what's in

535
00:24:23,210 --> 00:24:27,200
the file working now another thing that

536
00:24:24,920 --> 00:24:29,060
I want to point out here is this is

537
00:24:27,200 --> 00:24:34,400
strictly this is not something that's

538
00:24:29,059 --> 00:24:37,190
meant for robust use so basically like

539
00:24:34,400 --> 00:24:40,550
we are not going to even remotely

540
00:24:37,190 --> 00:24:43,150
guarantee in fact I'll put that right in

541
00:24:40,549 --> 00:24:43,149
the top here

542
00:24:58,200 --> 00:25:02,160
basically we are not going to handle

543
00:25:00,059 --> 00:25:04,200
anything special we're not going to

544
00:25:02,160 --> 00:25:06,180
handle malformed pngs we're not gonna

545
00:25:04,200 --> 00:25:09,509
handle malicious pngs we're not going to

546
00:25:06,180 --> 00:25:11,430
anything like at all so this is going to

547
00:25:09,509 --> 00:25:14,460
be the most simple it's designed only

548
00:25:11,430 --> 00:25:16,440
for use with an artist that you trust it

549
00:25:14,460 --> 00:25:20,400
is not supposed to be robust to

550
00:25:16,440 --> 00:25:21,779
tampering or anything like that so we

551
00:25:20,400 --> 00:25:23,040
really just don't care any other things

552
00:25:21,779 --> 00:25:25,049
we're just gonna write the simplest

553
00:25:23,039 --> 00:25:29,849
possible PNG load that is not even

554
00:25:25,049 --> 00:25:34,980
remotely capable of handling any kind of

555
00:25:29,849 --> 00:25:37,500
malformed input and again that's because

556
00:25:34,980 --> 00:25:42,000
we really don't care about that at all

557
00:25:37,500 --> 00:25:44,579
that's someone else's problem okay so

558
00:25:42,000 --> 00:25:47,460
let's take a look at the spec here and

559
00:25:44,579 --> 00:25:49,049
also let me get myself set up with the

560
00:25:47,460 --> 00:25:52,680
debugging context so what I'm gonna do

561
00:25:49,049 --> 00:25:55,909
is I'm gonna do MS dev here I'm going to

562
00:25:52,680 --> 00:25:58,529
say that we want to debug it handmade

563
00:25:55,910 --> 00:26:00,330
PNG eggsy

564
00:25:58,529 --> 00:26:02,549
and then in here I'm going to go ahead

565
00:26:00,329 --> 00:26:06,259
and set the properties of the loading

566
00:26:02,549 --> 00:26:08,940
code the arguments to it I have that

567
00:26:06,259 --> 00:26:11,490
piece of test data that I made there I

568
00:26:08,940 --> 00:26:17,340
believe it was called oops test up

569
00:26:11,490 --> 00:26:21,779
PNG and so when we build this program

570
00:26:17,339 --> 00:26:23,609
here as part of this process if I now

571
00:26:21,779 --> 00:26:26,250
were to step into it I should be able to

572
00:26:23,609 --> 00:26:29,849
see this happening you can see the

573
00:26:26,250 --> 00:26:32,700
arguments come in here and like there's

574
00:26:29,849 --> 00:26:36,240
the maybe cue ball so on so we should

575
00:26:32,700 --> 00:26:39,950
see us load this file I don't need to

576
00:26:36,240 --> 00:26:39,950
step into F open thank you

577
00:26:47,829 --> 00:26:53,480
alright never mind forget it doesn't

578
00:26:50,450 --> 00:26:57,529
matter so what I should probably do to

579
00:26:53,480 --> 00:26:59,420
avoid that eventually in future is we

580
00:26:57,529 --> 00:27:00,649
want to be able to set this to OD cuz

581
00:26:59,420 --> 00:27:03,440
probably what happened is the optimizer

582
00:27:00,650 --> 00:27:04,880
welded that all together so what I want

583
00:27:03,440 --> 00:27:06,200
to do now is we step into it just this

584
00:27:04,880 --> 00:27:08,030
way well it's gonna show you so when we

585
00:27:06,200 --> 00:27:09,890
do an entire file we should see it open

586
00:27:08,029 --> 00:27:13,250
the file we should see it read the

587
00:27:09,890 --> 00:27:14,690
entire file in like so and then close it

588
00:27:13,250 --> 00:27:17,569
and then the thing that we're left with

589
00:27:14,690 --> 00:27:19,340
should be a result that has the size of

590
00:27:17,569 --> 00:27:21,019
the file and the Const of the file in it

591
00:27:19,339 --> 00:27:24,019
so we have the entire file loaded into

592
00:27:21,019 --> 00:27:25,970
memory now it says that files 30k let's

593
00:27:24,019 --> 00:27:27,619
make sure that is actually how big it

594
00:27:25,970 --> 00:27:31,700
should be just to make sure we're not

595
00:27:27,619 --> 00:27:33,500
doing anything obviously stupid that's

596
00:27:31,700 --> 00:27:36,680
the size it should be

597
00:27:33,500 --> 00:27:39,049
so as you can see here everything's fine

598
00:27:36,680 --> 00:27:40,940
so then we've got the file in memory and

599
00:27:39,049 --> 00:27:42,259
now we can press it and now we just need

600
00:27:40,940 --> 00:27:44,390
to write the code that actually starts

601
00:27:42,259 --> 00:27:46,460
so look at that and does something

602
00:27:44,390 --> 00:27:48,500
reasonable so I'm gonna make another

603
00:27:46,460 --> 00:27:50,360
file here I'm gonna make a header file

604
00:27:48,500 --> 00:27:51,950
that accompanies handmade PNG and the

605
00:27:50,359 --> 00:27:55,309
responsible for that header file is just

606
00:27:51,950 --> 00:27:58,039
a dumping ground for all of the sort of

607
00:27:55,309 --> 00:27:59,779
specific code specific structures that I

608
00:27:58,039 --> 00:28:02,750
might use to extract information out of

609
00:27:59,779 --> 00:28:04,639
the PNG to make it easier on myself now

610
00:28:02,750 --> 00:28:06,799
we may not be able to do much of that I

611
00:28:04,640 --> 00:28:10,670
don't actually know how structured PNG

612
00:28:06,799 --> 00:28:13,099
is as a format so we'll see it may be a

613
00:28:10,670 --> 00:28:14,480
very short header file I'm not sure but

614
00:28:13,099 --> 00:28:18,079
that's what we're I'm going to put that

615
00:28:14,480 --> 00:28:20,539
stuff to the eliminated any so here's

616
00:28:18,079 --> 00:28:26,149
handmade PNG again I'm just gonna copy

617
00:28:20,539 --> 00:28:29,619
this in there like so and then inside

618
00:28:26,150 --> 00:28:29,620
here I'm gonna go ahead and include

619
00:28:33,190 --> 00:28:40,149
so now we can start looking at this here

620
00:28:36,598 --> 00:28:41,979
there's a bunch of sort of concept stuff

621
00:28:40,148 --> 00:28:43,719
and whatever we don't really want to

622
00:28:41,979 --> 00:28:45,489
look at that stuff quite yet we're gonna

623
00:28:43,720 --> 00:28:45,788
kind of work our way backwards through

624
00:28:45,489 --> 00:28:48,009
there

625
00:28:45,788 --> 00:28:50,079
we want to start looking at first is the

626
00:28:48,009 --> 00:28:52,239
data stream structure which is just the

627
00:28:50,079 --> 00:28:54,388
thing that lets us know sort of how we

628
00:28:52,239 --> 00:28:56,470
should start to break apart this file

629
00:28:54,388 --> 00:28:58,258
and what you can see here is they give

630
00:28:56,470 --> 00:29:00,608
this is very common specifications

631
00:28:58,259 --> 00:29:04,479
there's basically this this notion of a

632
00:29:00,608 --> 00:29:06,478
RIF file format our iff we saw it with

633
00:29:04,479 --> 00:29:09,190
wave data when we were playing sounds

634
00:29:06,479 --> 00:29:12,220
this PNG is that kind of a file format

635
00:29:09,190 --> 00:29:14,200
it's based on chunks of data which tend

636
00:29:12,220 --> 00:29:15,848
to have two things in them they tend to

637
00:29:14,200 --> 00:29:17,979
have a length which says how long it's

638
00:29:15,848 --> 00:29:20,339
going to be and a type field which is

639
00:29:17,979 --> 00:29:24,159
often times but not always a

640
00:29:20,339 --> 00:29:28,898
four-character field that just says some

641
00:29:24,159 --> 00:29:30,309
identifiers like HD are two for a second

642
00:29:28,898 --> 00:29:33,518
version of the header or something like

643
00:29:30,308 --> 00:29:35,440
that that tells you what kind of chunk

644
00:29:33,519 --> 00:29:38,378
you're looking for are looking at and

645
00:29:35,440 --> 00:29:40,659
what you're expected to do as a parser

646
00:29:38,378 --> 00:29:42,418
of the file format for better or for

647
00:29:40,659 --> 00:29:44,859
worse is to scan through the file

648
00:29:42,419 --> 00:29:47,288
looking at these chunks and you can look

649
00:29:44,858 --> 00:29:49,210
and see okay here's the first chunk

650
00:29:47,288 --> 00:29:51,579
here's how long it is here's what type

651
00:29:49,210 --> 00:29:53,950
it is do I understand and/or care about

652
00:29:51,579 --> 00:29:55,298
that type if the answer is yes I look at

653
00:29:53,950 --> 00:29:58,619
the data inside there at the answer is

654
00:29:55,298 --> 00:30:03,038
no I used the length field to skip over

655
00:29:58,618 --> 00:30:05,470
that chunk right so that's typically how

656
00:30:03,038 --> 00:30:07,690
that works now I can't say I necessarily

657
00:30:05,470 --> 00:30:11,348
know because I've never written to PNG

658
00:30:07,690 --> 00:30:13,359
reader before I tend to read Photoshop

659
00:30:11,348 --> 00:30:16,960
files directly that's that's what I do

660
00:30:13,358 --> 00:30:23,769
in my engines speaking of things you

661
00:30:16,960 --> 00:30:26,019
really don't want to get yourself into I

662
00:30:23,769 --> 00:30:29,259
have no idea what this kind of chunk

663
00:30:26,019 --> 00:30:31,388
means because this is like I guess if

664
00:30:29,259 --> 00:30:33,098
you just want to put in a type that has

665
00:30:31,388 --> 00:30:36,189
literally no data like I'm just trying

666
00:30:33,098 --> 00:30:38,048
to tag the thing then I guess you have a

667
00:30:36,190 --> 00:30:41,919
length that equals zero and then it's

668
00:30:38,048 --> 00:30:46,779
just a CRC of nothing so that's kind of

669
00:30:41,919 --> 00:30:49,780
interesting but yeah I

670
00:30:46,779 --> 00:30:53,619
there's probably tag-based stuff you'd

671
00:30:49,779 --> 00:30:55,599
then do in a PNG that makes sense sir I

672
00:30:53,619 --> 00:30:57,599
don't know I'm sure we'll find out as we

673
00:30:55,599 --> 00:31:00,129
go along but point being you can see

674
00:30:57,599 --> 00:31:01,599
that this part of the reason I jumped

675
00:31:00,130 --> 00:31:03,040
right to the datastream structure part

676
00:31:01,599 --> 00:31:05,019
is because this is the part reaction to

677
00:31:03,039 --> 00:31:06,789
start with now as we work our way

678
00:31:05,019 --> 00:31:08,319
through here we will find things we

679
00:31:06,789 --> 00:31:10,240
don't understand and that's when we'll

680
00:31:08,319 --> 00:31:13,119
have to go back to the previous part the

681
00:31:10,240 --> 00:31:15,400
rest of this this is not useless we do

682
00:31:13,119 --> 00:31:17,199
need to read it all it's just not

683
00:31:15,400 --> 00:31:19,540
relevant to us just yet because we

684
00:31:17,200 --> 00:31:21,460
haven't really gotten to the part of

685
00:31:19,539 --> 00:31:22,599
parsing where we need to understand the

686
00:31:21,460 --> 00:31:23,890
concepts that are being talked about

687
00:31:22,599 --> 00:31:28,389
instead what we need to do is just

688
00:31:23,890 --> 00:31:30,430
extract the basic data that's there so

689
00:31:28,390 --> 00:31:32,740
the first thing we can expect to see it

690
00:31:30,430 --> 00:31:35,440
says right here is that the eight bytes

691
00:31:32,740 --> 00:31:37,990
that begin a PNG file have to contain

692
00:31:35,440 --> 00:31:40,180
these decimal values so the first thing

693
00:31:37,990 --> 00:31:43,960
we're going to look at is essentially a

694
00:31:40,180 --> 00:31:45,370
eight byte field and so this is gonna be

695
00:31:43,960 --> 00:31:49,090
something I can put in this header here

696
00:31:45,369 --> 00:31:50,589
I'm gonna go ahead and do a pragma and

697
00:31:49,089 --> 00:31:53,079
you've seen this pragma that we've we've

698
00:31:50,589 --> 00:31:56,230
used this pragma before it's called a

699
00:31:53,079 --> 00:31:58,269
pragma pack and what it does is it says

700
00:31:56,230 --> 00:32:00,849
we don't want the c compiler to

701
00:31:58,269 --> 00:32:02,170
introduce any padding and the reason

702
00:32:00,849 --> 00:32:04,629
that we don't want the cecum power to

703
00:32:02,170 --> 00:32:06,580
induce any padding here is just because

704
00:32:04,630 --> 00:32:09,100
if the C compiler introduces padding

705
00:32:06,579 --> 00:32:11,470
then it will align with what's in the

706
00:32:09,099 --> 00:32:12,939
file so the file has its own ideas about

707
00:32:11,470 --> 00:32:15,279
what should be padded and what shouldn't

708
00:32:12,940 --> 00:32:17,680
be so if we create structures here that

709
00:32:15,279 --> 00:32:20,619
are meant to overlay exactly with memory

710
00:32:17,680 --> 00:32:22,630
read from a file if we then go ahead and

711
00:32:20,619 --> 00:32:23,979
say okay the C compiler can introduce

712
00:32:22,630 --> 00:32:26,770
any kind of padding that it wants to

713
00:32:23,980 --> 00:32:28,089
hear we will end up with something that

714
00:32:26,769 --> 00:32:29,559
doesn't actually line up with the data

715
00:32:28,089 --> 00:32:31,509
in the file so this is a pretty

716
00:32:29,559 --> 00:32:33,309
important thing to do so the first thing

717
00:32:31,509 --> 00:32:35,710
we want to do is is talk about the PNG

718
00:32:33,309 --> 00:32:37,960
header we now know that the PNG header

719
00:32:35,710 --> 00:32:41,130
has to have exactly this and it's going

720
00:32:37,960 --> 00:32:45,100
to contain this this string if you will

721
00:32:41,130 --> 00:32:48,670
137 80s 78 or you know that that exact

722
00:32:45,099 --> 00:32:51,759
pattern is going to be there but these

723
00:32:48,670 --> 00:32:53,050
decimals and so what we want to do is

724
00:32:51,759 --> 00:32:56,920
say all right we know there's going to

725
00:32:53,049 --> 00:33:00,539
be 8 things in here this is for lack of

726
00:32:56,920 --> 00:33:04,480
a better term this is the

727
00:33:00,539 --> 00:33:07,990
signature it's eight bytes long

728
00:33:04,480 --> 00:33:11,140
we know that the PNG signature has to

729
00:33:07,990 --> 00:33:14,079
look like this because the spec told us

730
00:33:11,140 --> 00:33:17,230
so soon when we load the scene we can do

731
00:33:14,079 --> 00:33:22,919
a comparison on those two and we can

732
00:33:17,230 --> 00:33:26,110
verify that that is what is there right

733
00:33:22,920 --> 00:33:29,529
so that's all fine we then have the

734
00:33:26,109 --> 00:33:30,639
chunks and so you can see it says here

735
00:33:29,529 --> 00:33:32,678
the signature in the case is remaining

736
00:33:30,640 --> 00:33:34,870
main the remainder of the data stream

737
00:33:32,679 --> 00:33:36,519
contains a single PNG image to a series

738
00:33:34,869 --> 00:33:39,549
of chunks beginning with an IEEE header

739
00:33:36,519 --> 00:33:42,400
and ending with an int ankh now what

740
00:33:39,549 --> 00:33:45,159
that says to me is that it's not going

741
00:33:42,400 --> 00:33:47,170
to tell us the size of the file we know

742
00:33:45,160 --> 00:33:48,910
the size of the file that we read so we

743
00:33:47,170 --> 00:33:50,250
could do error checking on it if we want

744
00:33:48,910 --> 00:33:52,390
to like I said we don't care about that

745
00:33:50,250 --> 00:33:55,329
so really what we're gonna do there is

746
00:33:52,390 --> 00:33:57,250
start reading chunks one at a time and

747
00:33:55,329 --> 00:33:59,109
the chunk layout is very specific you

748
00:33:57,250 --> 00:34:00,910
can see it here it's got a length of a

749
00:33:59,109 --> 00:34:04,419
chunk type and then the chunk get a CRC

750
00:34:00,910 --> 00:34:05,950
stuff so right here inside the chunk

751
00:34:04,420 --> 00:34:08,250
parts they're gonna tell us how to read

752
00:34:05,950 --> 00:34:10,030
that it says that the length is 4 bytes

753
00:34:08,250 --> 00:34:12,579
giving the number of bytes the chimes

754
00:34:10,030 --> 00:34:15,580
data field it's only the data field not

755
00:34:12,579 --> 00:34:17,590
the chunk type of the CRT so when you

756
00:34:15,579 --> 00:34:19,210
say it's 0 it means that there's no

757
00:34:17,590 --> 00:34:20,350
chunk data it doesn't mean that there

758
00:34:19,210 --> 00:34:22,840
isn't one of these one of these there's

759
00:34:20,349 --> 00:34:26,710
always those two so effectively since

760
00:34:22,840 --> 00:34:29,769
this the trunk type is 4 bytes and the

761
00:34:26,710 --> 00:34:31,750
the CRC is 4 bytes for the cyclic

762
00:34:29,769 --> 00:34:35,559
redundancy check that basically means

763
00:34:31,750 --> 00:34:37,449
that there's 4 bytes and then 8 bytes at

764
00:34:35,559 --> 00:34:40,000
the I'm sorry there's 8 bytes to start

765
00:34:37,449 --> 00:34:44,710
and then 4 bytes at the end the length

766
00:34:40,000 --> 00:34:47,648
does not include those 4 bytes on either

767
00:34:44,710 --> 00:34:53,128
side here the chunk type or the CRT less

768
00:34:47,648 --> 00:34:57,429
CRC sir so we have a PNG chunk header

769
00:34:53,128 --> 00:35:01,000
and a PNG chunk footer and again do we

770
00:34:57,429 --> 00:35:05,049
really need these no these are here

771
00:35:01,000 --> 00:35:07,059
because I want to make a record of the

772
00:35:05,050 --> 00:35:08,650
structure of the PNG that's easy for me

773
00:35:07,059 --> 00:35:10,090
to see and easy for others to follow

774
00:35:08,650 --> 00:35:12,730
along with if they look at this code or

775
00:35:10,090 --> 00:35:13,650
have to debug it so we could just fly

776
00:35:12,730 --> 00:35:15,900
you know

777
00:35:13,650 --> 00:35:17,369
go ahead and not have these but I feel

778
00:35:15,900 --> 00:35:20,579
like this is a good way to document what

779
00:35:17,369 --> 00:35:23,160
I think the file format is and that's

780
00:35:20,579 --> 00:35:28,259
just helpful right that that's really

781
00:35:23,159 --> 00:35:30,239
all it is okay so that's really all we

782
00:35:28,259 --> 00:35:32,278
need to do to start printing out what

783
00:35:30,239 --> 00:35:35,278
chunks are in this file and what we can

784
00:35:32,278 --> 00:35:36,690
see here is we've got a list of all

785
00:35:35,278 --> 00:35:39,449
these sort of things that we might see

786
00:35:36,690 --> 00:35:41,278
in the file so what we what I think we

787
00:35:39,449 --> 00:35:43,980
should do here is just make a thing that

788
00:35:41,278 --> 00:35:45,568
now can dump this aspect of the file

789
00:35:43,980 --> 00:35:48,210
right because now we know enough to

790
00:35:45,568 --> 00:35:50,159
parse the entire PNG file we just should

791
00:35:48,210 --> 00:35:52,199
we won't be able to understand me of the

792
00:35:50,159 --> 00:35:55,409
data in it and that's fine but that's

793
00:35:52,199 --> 00:35:58,588
step two right so let's get started here

794
00:35:55,409 --> 00:36:01,399
so we want a header and the header it

795
00:35:58,588 --> 00:36:06,568
should be in in this file contents here

796
00:36:01,400 --> 00:36:09,210
now what we're gonna see is in fact one

797
00:36:06,568 --> 00:36:11,489
thing that we could do is and I think we

798
00:36:09,210 --> 00:36:13,108
should do is we're gonna have this

799
00:36:11,489 --> 00:36:14,909
entire file we got this contents here

800
00:36:13,108 --> 00:36:18,538
and what we'd see is we see the same

801
00:36:14,909 --> 00:36:21,328
pattern sort of appearing many many

802
00:36:18,539 --> 00:36:28,589
times right which is to say that we

803
00:36:21,329 --> 00:36:29,999
would do something like this where I'm

804
00:36:28,588 --> 00:36:32,278
saying look I'm gonna start with a

805
00:36:29,998 --> 00:36:36,538
pointer to the file contents I'm gonna

806
00:36:32,278 --> 00:36:37,829
get out one of these things right I'm

807
00:36:36,539 --> 00:36:39,630
gonna look at the first part as a header

808
00:36:37,829 --> 00:36:42,710
and then I want to move past whatever

809
00:36:39,630 --> 00:36:42,710
the header is so I'm gonna do this

810
00:36:45,619 --> 00:36:50,730
that's gonna be a really common pattern

811
00:36:47,998 --> 00:36:52,108
that we would do right and so what we

812
00:36:50,730 --> 00:36:53,940
could do instead is just make it

813
00:36:52,108 --> 00:36:56,548
something that's easier to extract from

814
00:36:53,940 --> 00:36:59,009
there and furthermore if we want to we

815
00:36:56,548 --> 00:37:01,949
can do something that's even fancier we

816
00:36:59,009 --> 00:37:05,400
can do some some pretty wily stuff if we

817
00:37:01,949 --> 00:37:08,298
really want to we could do something

818
00:37:05,400 --> 00:37:08,298
like this

819
00:37:14,768 --> 00:37:24,218
I don't really want an something like

820
00:37:20,079 --> 00:37:27,869
this let's say where we pass in the size

821
00:37:24,219 --> 00:37:34,208
of the thing that we want to consume and

822
00:37:27,869 --> 00:37:37,298
we pass in the the file pointer and it

823
00:37:34,208 --> 00:37:40,118
just gives us back the correct amount

824
00:37:37,298 --> 00:37:41,650
and advances the pointer right and then

825
00:37:40,119 --> 00:37:45,809
what we would do is we define a macro

826
00:37:41,650 --> 00:37:50,949
like so and we just say oh yeah like

827
00:37:45,809 --> 00:37:54,249
tell us what type you wanted and to

828
00:37:50,949 --> 00:37:59,499
extract out of here and we will extract

829
00:37:54,248 --> 00:38:02,588
that for you and make sure it's casted

830
00:37:59,498 --> 00:38:05,198
properly right furthermore this gives us

831
00:38:02,588 --> 00:38:08,068
the opportunity to assert because we can

832
00:38:05,199 --> 00:38:11,019
assert that the size left in the thing

833
00:38:08,068 --> 00:38:12,969
is enough to give you back what you

834
00:38:11,018 --> 00:38:14,379
asked for so that also gives us a little

835
00:38:12,969 --> 00:38:18,219
bit of insurance that we don't have a

836
00:38:14,380 --> 00:38:21,369
bug in the code right so here's my

837
00:38:18,219 --> 00:38:24,208
result pointer my result pointer is

838
00:38:21,369 --> 00:38:26,439
whatever the contents is right now and

839
00:38:24,208 --> 00:38:29,139
the other thing I'm going to do is I'm

840
00:38:26,438 --> 00:38:33,489
going to take the result contents and

841
00:38:29,139 --> 00:38:37,538
I'm gonna advance it by whatever the

842
00:38:33,489 --> 00:38:38,739
size is so you can see what I'm doing

843
00:38:37,539 --> 00:38:40,209
here right so I'm gonna have a macro I'm

844
00:38:38,739 --> 00:38:43,420
going to say consume from this file

845
00:38:40,208 --> 00:38:44,558
consume one of these whatever it is and

846
00:38:43,420 --> 00:38:45,938
then what that'll do is it'll pass

847
00:38:44,559 --> 00:38:48,249
whatever the size of that thing is that

848
00:38:45,938 --> 00:38:49,328
you asked for it will find out where we

849
00:38:48,248 --> 00:38:50,788
are in the file right now and return

850
00:38:49,329 --> 00:38:53,079
that to you

851
00:38:50,789 --> 00:38:56,019
casted to whatever the put type is that

852
00:38:53,079 --> 00:38:58,089
you asked for then it will go ahead and

853
00:38:56,018 --> 00:39:01,208
take whatever the file contents are and

854
00:38:58,088 --> 00:39:04,208
it will advance it by however far it was

855
00:39:01,208 --> 00:39:05,469
that if by however much we actually are

856
00:39:04,208 --> 00:39:09,129
going to look at it'll advance by that

857
00:39:05,469 --> 00:39:10,719
much right so what I can do there is now

858
00:39:09,130 --> 00:39:13,269
instead of writing code like this all

859
00:39:10,719 --> 00:39:17,679
the time about what I can do here is say

860
00:39:13,268 --> 00:39:19,858
I've got a thing that's like I don't

861
00:39:17,679 --> 00:39:19,858
know

862
00:39:20,000 --> 00:39:26,579
like that and now what I can do is just

863
00:39:24,179 --> 00:39:33,029
say this pointer right here is how I

864
00:39:26,579 --> 00:39:35,309
will get all of my stuff so looking at

865
00:39:33,030 --> 00:39:37,350
this I know I want to hit her

866
00:39:35,309 --> 00:39:39,809
and then I know that I want to basically

867
00:39:37,349 --> 00:39:52,429
lock into a four loop where I'm going to

868
00:39:39,809 --> 00:39:55,139
have a chunk header and I'm going to

869
00:39:52,429 --> 00:39:56,669
essentially keep going through here I

870
00:39:55,139 --> 00:40:00,230
could you know what this is probably be

871
00:39:56,670 --> 00:40:04,250
a while loop it just says while at

872
00:40:00,230 --> 00:40:04,250
what's working for a while at

873
00:40:06,900 --> 00:40:13,000
content size like no that's your summer

874
00:40:09,519 --> 00:40:16,570
yeah well that content size is greater

875
00:40:13,000 --> 00:40:18,519
than zero we'll keep going right and

876
00:40:16,570 --> 00:40:20,110
this assertion will tell us that we

877
00:40:18,519 --> 00:40:21,940
haven't at the end of the file what we

878
00:40:20,110 --> 00:40:24,400
could do too is we could make this just

879
00:40:21,940 --> 00:40:26,230
a regular error what we could do is say

880
00:40:24,400 --> 00:40:28,119
like if the file content size is greater

881
00:40:26,230 --> 00:40:29,619
than or equal to the size then we go

882
00:40:28,119 --> 00:40:35,250
ahead and do what what it is that we

883
00:40:29,619 --> 00:40:38,710
were going to do and that should be fine

884
00:40:35,250 --> 00:40:41,800
if we don't we'll set the content size

885
00:40:38,710 --> 00:40:48,820
to zero we could also do something here

886
00:40:41,800 --> 00:40:58,120
where we do this and that way this code

887
00:40:48,820 --> 00:40:58,600
could if on that write something like

888
00:40:58,119 --> 00:41:02,440
that

889
00:40:58,599 --> 00:41:03,909
here I'm saying so anyway while we're

890
00:41:02,440 --> 00:41:05,769
doing this we can just do these consumes

891
00:41:03,909 --> 00:41:08,649
and the consumes we'll just go go go go

892
00:41:05,769 --> 00:41:10,599
go and each time we go through here

893
00:41:08,650 --> 00:41:12,760
we'll get one of these right and off we

894
00:41:10,599 --> 00:41:14,139
will go and that should just be fine I

895
00:41:12,760 --> 00:41:17,140
think that's all we would really need to

896
00:41:14,139 --> 00:41:21,129
do and then what happens in here as we

897
00:41:17,139 --> 00:41:23,980
go through here and we get chunk headers

898
00:41:21,130 --> 00:41:27,300
out when we see a valid chunk header oh

899
00:41:23,980 --> 00:41:27,300
you know what I should also do here is

900
00:41:35,099 --> 00:41:43,859
I just put it under flow message in

901
00:41:41,190 --> 00:41:45,690
there alright so what I want to do now

902
00:41:43,858 --> 00:41:48,808
is when we get back one of these chunk

903
00:41:45,690 --> 00:41:50,099
headers it's not as simple as just you

904
00:41:48,809 --> 00:41:51,450
know we can't just loop over this we

905
00:41:50,099 --> 00:41:53,970
have to remember that the chunk header

906
00:41:51,449 --> 00:41:56,788
has a length in it and that length tells

907
00:41:53,969 --> 00:41:59,659
us how much further forward we actually

908
00:41:56,789 --> 00:42:02,190
have to go in order to read that part of

909
00:41:59,659 --> 00:42:04,379
that particular chunk right and then we

910
00:42:02,190 --> 00:42:13,588
also know we've got a footer that we

911
00:42:04,380 --> 00:42:15,869
have to read as well like that right so

912
00:42:13,588 --> 00:42:18,358
in between here this is the chunk data

913
00:42:15,869 --> 00:42:22,289
we know that the chunk data is always

914
00:42:18,358 --> 00:42:24,498
going to be exactly the size that it

915
00:42:22,289 --> 00:42:28,109
tells us right so in the chunk header

916
00:42:24,498 --> 00:42:29,969
that length field we always need to

917
00:42:28,108 --> 00:42:31,978
consume that data now it might be zero

918
00:42:29,969 --> 00:42:34,618
right and so this might do nothing and

919
00:42:31,978 --> 00:42:36,568
that's fine but we always have to

920
00:42:34,619 --> 00:42:39,690
consume whatever the length is so we

921
00:42:36,568 --> 00:42:41,489
read the header out we consume however

922
00:42:39,690 --> 00:42:43,200
much data it says in there and then we

923
00:42:41,489 --> 00:42:45,539
consume the footer and then we continue

924
00:42:43,199 --> 00:42:48,328
until we can't continue anymore so let's

925
00:42:45,539 --> 00:42:50,400
go ahead and make what's this what's

926
00:42:48,329 --> 00:42:51,180
what is it global variable is that the

927
00:42:50,400 --> 00:43:01,318
name of it yep

928
00:42:51,179 --> 00:43:03,419
oh whoops yeah umm cannot convert entire

929
00:43:01,318 --> 00:43:06,588
file oh right this is supposed to be at

930
00:43:03,420 --> 00:43:06,588
not file

931
00:43:14,619 --> 00:43:25,690
[Music]

932
00:43:17,269 --> 00:43:25,690
let's see here looks like we've got some

933
00:43:26,199 --> 00:43:38,019
kind of a complaint regarding the type

934
00:43:28,880 --> 00:43:40,970
oh right so probably I should have that

935
00:43:38,019 --> 00:43:44,420
because we actually want to consume size

936
00:43:40,969 --> 00:43:46,759
at various points as well right that's

937
00:43:44,420 --> 00:43:48,619
not a struct at that point so that's

938
00:43:46,760 --> 00:43:52,130
what we really need to do there now

939
00:43:48,619 --> 00:43:53,449
we've got sort of a we've got something

940
00:43:52,130 --> 00:43:55,400
now that will loop through it but we

941
00:43:53,449 --> 00:43:57,769
don't actually have anything that it

942
00:43:55,400 --> 00:44:00,200
will print out right so you know there

943
00:43:57,769 --> 00:44:01,400
the program ran right but we haven't

944
00:44:00,199 --> 00:44:03,439
actually put anything out so what we

945
00:44:01,400 --> 00:44:05,420
want to do and if I do it out here as

946
00:44:03,440 --> 00:44:09,860
well just so we can see what it looks

947
00:44:05,420 --> 00:44:12,289
like if I say handmade PNG do we

948
00:44:09,860 --> 00:44:17,510
actually have now if I say handmade P&amp;G

949
00:44:12,289 --> 00:44:18,769
W handmade test PM test at P&amp;G what you

950
00:44:17,510 --> 00:44:20,120
can see is we don't actually get

951
00:44:18,769 --> 00:44:22,849
anything own we get that under flow

952
00:44:20,119 --> 00:44:24,259
there so we were reading something a

953
00:44:22,849 --> 00:44:26,599
little bit incorrectly there it would

954
00:44:24,260 --> 00:44:27,920
seem so what we want to do now is start

955
00:44:26,599 --> 00:44:30,619
looking through this and getting this

956
00:44:27,920 --> 00:44:35,659
working correctly and that's about it

957
00:44:30,619 --> 00:44:38,900
right so let's go ahead in here let's

958
00:44:35,659 --> 00:44:47,449
start by looking at what this equals at

959
00:44:38,900 --> 00:44:49,250
the moment thirty five to two oh forgot

960
00:44:47,449 --> 00:44:55,159
something relatively obvious when we

961
00:44:49,250 --> 00:44:59,619
advance this file content size needs to

962
00:44:55,159 --> 00:44:59,619
go down by the size obviously

963
00:45:01,139 --> 00:45:08,079
okay so let's start in here we get back

964
00:45:05,889 --> 00:45:08,730
the file header and I'm gonna take a

965
00:45:08,079 --> 00:45:11,679
look at it

966
00:45:08,730 --> 00:45:14,920
oops I suppose I should also have double

967
00:45:11,679 --> 00:45:17,069
check since I had that type over there

968
00:45:14,920 --> 00:45:20,170
let me just make sure that it goes down

969
00:45:17,070 --> 00:45:22,660
right so should I go and put down by

970
00:45:20,170 --> 00:45:28,090
eight and it did so now if we take a

971
00:45:22,659 --> 00:45:30,069
look at the file header what you can see

972
00:45:28,090 --> 00:45:31,960
is that it has that series of things

973
00:45:30,070 --> 00:45:34,510
that we said it should have actually we

974
00:45:31,960 --> 00:45:38,220
haven't checked them in our code yet but

975
00:45:34,510 --> 00:45:40,900
it does seem to have that right 137 80

976
00:45:38,219 --> 00:45:42,489
78-71 bla bla bla right it's got that in

977
00:45:40,900 --> 00:45:45,190
there so we know that the file header if

978
00:45:42,489 --> 00:45:50,618
he is apparently correct right so now

979
00:45:45,190 --> 00:45:52,179
we're gonna read the chunk header and

980
00:45:50,619 --> 00:45:53,829
there's the chunk header now I probably

981
00:45:52,179 --> 00:45:55,629
should have said that the chunk header

982
00:45:53,829 --> 00:46:01,690
was a Kara star because it would be

983
00:45:55,630 --> 00:46:04,570
easier for us to debug if I do you can

984
00:46:01,690 --> 00:46:06,670
see this is an AI header right and

985
00:46:04,570 --> 00:46:09,910
there's the length that length looks

986
00:46:06,670 --> 00:46:12,039
totally bogus so I think I must have

987
00:46:09,909 --> 00:46:14,230
made some mistake here because the AI

988
00:46:12,039 --> 00:46:16,989
editor cannot possibly be that long

989
00:46:14,230 --> 00:46:18,309
right so I think I just I got to go back

990
00:46:16,989 --> 00:46:19,750
and double-check that I didn't do

991
00:46:18,309 --> 00:46:24,449
something stupid there I probably did

992
00:46:19,750 --> 00:46:24,449
and so we have to fix that let me just

993
00:46:31,429 --> 00:46:35,519
for byte unsigned if you give the number

994
00:46:33,510 --> 00:46:37,890
of bytes in the chunks data Felix's only

995
00:46:35,519 --> 00:46:39,420
two Phillips head or the Searcy's yours

996
00:46:37,889 --> 00:46:41,519
well although cords dicker should treat

997
00:46:39,420 --> 00:46:46,130
the length is unsigned its value should

998
00:46:41,519 --> 00:46:52,170
not exceed two or three first one fights

999
00:46:46,130 --> 00:46:56,039
although it does seem is it just me or

1000
00:46:52,170 --> 00:46:57,539
does that just seemed really large that

1001
00:46:56,039 --> 00:46:59,719
does I mean that's where it should have

1002
00:46:57,539 --> 00:46:59,719
been

1003
00:47:06,230 --> 00:47:12,980
I would make one small change we're

1004
00:47:08,539 --> 00:47:16,579
coming back in a second so what I was

1005
00:47:12,980 --> 00:47:19,670
gonna say here is if we treat this like

1006
00:47:16,579 --> 00:47:31,039
so and you know I could even do it this

1007
00:47:19,670 --> 00:47:33,619
way last something like that then that

1008
00:47:31,039 --> 00:47:35,029
would allow us to look at it a little

1009
00:47:33,619 --> 00:47:37,460
more easily so you could see here in the

1010
00:47:35,030 --> 00:47:40,760
debugger now it that's just basically

1011
00:47:37,460 --> 00:47:43,280
the hint to the debugger if I don't have

1012
00:47:40,760 --> 00:47:46,280
this that's just a hint of the debugger

1013
00:47:43,280 --> 00:47:50,930
to show it to us this way which lets us

1014
00:47:46,280 --> 00:47:53,119
see that much more easily right and so

1015
00:47:50,929 --> 00:47:56,029
that's it's just the same value as this

1016
00:47:53,119 --> 00:47:58,070
but it just allows us to see it so what

1017
00:47:56,030 --> 00:48:00,080
you can see here right is this chunk

1018
00:47:58,070 --> 00:48:02,570
header is supposed to have a length on

1019
00:48:00,079 --> 00:48:05,358
it but the length value doesn't seem to

1020
00:48:02,570 --> 00:48:07,130
be real because if that was the actual

1021
00:48:05,358 --> 00:48:09,650
length it'd be longer than the entire

1022
00:48:07,130 --> 00:48:11,510
file right so what I'm having trouble

1023
00:48:09,650 --> 00:48:13,519
squaring is the fact that it says here

1024
00:48:11,510 --> 00:48:15,410
the first eight plates the PNG a

1025
00:48:13,519 --> 00:48:17,989
streamer always contain the following

1026
00:48:15,409 --> 00:48:20,599
decimal values we saw that right and

1027
00:48:17,989 --> 00:48:22,129
then it says the rate of the icer gives

1028
00:48:20,599 --> 00:48:24,199
the single PNG was Christa have a series

1029
00:48:22,130 --> 00:48:28,309
of chunks begin with an I hit her chunk

1030
00:48:24,199 --> 00:48:31,759
any with an I end chunk right now the I

1031
00:48:28,309 --> 00:48:36,710
header chunk says it's going to include

1032
00:48:31,760 --> 00:48:38,630
that right and then it's got you know

1033
00:48:36,710 --> 00:48:41,358
just a little bit of stuff in it with

1034
00:48:38,630 --> 00:48:45,619
height bit depth color compression it's

1035
00:48:41,358 --> 00:48:47,750
so on right I that should be relatively

1036
00:48:45,619 --> 00:48:50,660
small so what I'm not sure I understand

1037
00:48:47,750 --> 00:48:56,389
is why the length field appears to be

1038
00:48:50,659 --> 00:48:59,269
some very large value because I it

1039
00:48:56,389 --> 00:49:03,650
shouldn't be right that doesn't really

1040
00:48:59,269 --> 00:49:05,449
make any sense so when we try I mean

1041
00:49:03,650 --> 00:49:07,250
that explains why we get the underflow

1042
00:49:05,449 --> 00:49:08,779
there right if we come in here what

1043
00:49:07,250 --> 00:49:10,130
we're gonna see is we get a file

1044
00:49:08,780 --> 00:49:13,220
underflow immediately because we're

1045
00:49:10,130 --> 00:49:16,760
asking to read this giant thing and it

1046
00:49:13,219 --> 00:49:19,329
can't do that right so these two will

1047
00:49:16,760 --> 00:49:23,110
both underflow and

1048
00:49:19,329 --> 00:49:25,480
then we'll exit out so that's a little

1049
00:49:23,110 --> 00:49:27,910
confusing because I'm not sure what else

1050
00:49:25,480 --> 00:49:30,190
we could really do about that if that's

1051
00:49:27,909 --> 00:49:34,539
the spec so is this spec a little bit

1052
00:49:30,190 --> 00:49:39,119
off you know what do we make of that or

1053
00:49:34,539 --> 00:49:41,559
did I miss something here that that I

1054
00:49:39,119 --> 00:49:46,710
didn't understand so let's take a look

1055
00:49:41,559 --> 00:49:49,269
at the chunk specifications let's see

1056
00:49:46,710 --> 00:49:51,070
PNG diffuse cigs your philosophies which

1057
00:49:49,269 --> 00:49:52,750
sense each chunk of chunks as a chunk

1058
00:49:51,070 --> 00:49:54,070
type so it's function the clause defines

1059
00:49:52,750 --> 00:49:56,320
meters not standardized in this no

1060
00:49:54,070 --> 00:49:58,210
section minus Phi's you structure this

1061
00:49:56,320 --> 00:50:02,340
also the order which chunks may appear

1062
00:49:58,210 --> 00:50:06,070
for details for the encoders chunking

1063
00:50:02,340 --> 00:50:06,070
[Music]

1064
00:50:20,130 --> 00:50:28,360
I'm gonna look just before I go any

1065
00:50:22,900 --> 00:50:33,849
further I want to look at the contents

1066
00:50:28,360 --> 00:50:37,960
of the file here right from when we read

1067
00:50:33,849 --> 00:50:41,079
it in at the beginning I won't look at

1068
00:50:37,960 --> 00:50:51,039
the contents of the file as just raw

1069
00:50:41,079 --> 00:50:51,849
memory just so I can kind of see there

1070
00:50:51,039 --> 00:50:55,059
we go

1071
00:50:51,849 --> 00:50:57,329
what's actually in here so if I go ahead

1072
00:50:55,059 --> 00:51:00,759
and switch this to four byte integers

1073
00:50:57,329 --> 00:51:04,389
you can see the PNG header part is here

1074
00:51:00,760 --> 00:51:06,760
in here you know what I mean

1075
00:51:04,389 --> 00:51:11,980
so that's the eight bytes and then in

1076
00:51:06,760 --> 00:51:16,930
here so it looks like to me that this is

1077
00:51:11,980 --> 00:51:19,869
an ND in this issue right because look

1078
00:51:16,929 --> 00:51:22,210
at this value it looks like that would

1079
00:51:19,869 --> 00:51:26,319
be the correct length but it's in the

1080
00:51:22,210 --> 00:51:33,159
high bit instead of the low bit so it

1081
00:51:26,320 --> 00:51:36,690
looks like PNG is big endian god I hope

1082
00:51:33,159 --> 00:51:36,690
that's not true is that really true

1083
00:51:43,340 --> 00:52:03,680
does it have a section on Indian Asst it

1084
00:51:46,489 --> 00:52:05,509
might be switchable I'm assuming it

1085
00:52:03,679 --> 00:52:07,039
might be switchable but I don't know I

1086
00:52:05,510 --> 00:52:14,870
would say I would have expected them to

1087
00:52:07,039 --> 00:52:19,340
talk about this the fact that the phrase

1088
00:52:14,869 --> 00:52:26,119
Indian appears nowhere in the spec white

1089
00:52:19,340 --> 00:52:27,410
border there we go well let's use the

1090
00:52:26,119 --> 00:52:29,900
chrome relevant bytes shall be in

1091
00:52:27,409 --> 00:52:31,909
network byte order the most significant

1092
00:52:29,900 --> 00:52:33,559
byte comes first then the less

1093
00:52:31,909 --> 00:52:43,069
significant bytes in descending order

1094
00:52:33,559 --> 00:52:44,989
yeah bad wrong incorrect false but there

1095
00:52:43,070 --> 00:52:46,430
you have it right and so what that means

1096
00:52:44,989 --> 00:52:48,349
is that when we read one of these we

1097
00:52:46,429 --> 00:52:50,000
have to reverse the byte to come in them

1098
00:52:48,349 --> 00:52:53,299
so this length is not actually the

1099
00:52:50,000 --> 00:52:57,079
length it's actually the endianness

1100
00:52:53,300 --> 00:53:00,730
swapped version of the length so when we

1101
00:52:57,079 --> 00:53:03,309
read it we've got to swap it in like so

1102
00:53:00,730 --> 00:53:06,110
we've got to swap it round I should say

1103
00:53:03,309 --> 00:53:15,489
and so what I want to do then is say

1104
00:53:06,110 --> 00:53:15,490
okay when we read one of these like this

1105
00:53:18,559 --> 00:53:34,699
I got to do this and there's really not

1106
00:53:33,710 --> 00:53:35,780
much we're gonna be able to to get

1107
00:53:34,699 --> 00:53:38,719
around that

1108
00:53:35,780 --> 00:53:41,980
that's just how that's gonna go so when

1109
00:53:38,719 --> 00:53:45,589
we read the thing in we have to consume

1110
00:53:41,980 --> 00:53:49,369
the data in that format I really hate

1111
00:53:45,590 --> 00:53:51,769
that stuff I can't stand the fact that

1112
00:53:49,369 --> 00:53:55,279
we still have big endian it's just a

1113
00:53:51,769 --> 00:53:56,750
waste of everyone's time to even have to

1114
00:53:55,280 --> 00:54:00,830
think about it at this point

1115
00:53:56,750 --> 00:54:06,139
it drives me up the wall but sadly

1116
00:54:00,829 --> 00:54:08,750
that's just where we're at anyway it's

1117
00:54:06,139 --> 00:54:09,799
pretty easy to end even swap a value I

1118
00:54:08,750 --> 00:54:12,170
don't remember if we talked about the

1119
00:54:09,800 --> 00:54:14,210
Sun handmade here or in the past but if

1120
00:54:12,170 --> 00:54:16,250
we get a 32-bit value where we've got

1121
00:54:14,210 --> 00:54:18,650
it's the wrong way round so that we've

1122
00:54:16,250 --> 00:54:20,090
got you know the least significant and

1123
00:54:18,650 --> 00:54:21,650
most significant buy it's swap so

1124
00:54:20,090 --> 00:54:26,329
basically if we want the order of bytes

1125
00:54:21,650 --> 00:54:29,420
to go least significant bop-bop most

1126
00:54:26,329 --> 00:54:30,590
significant and we've got the opposite

1127
00:54:29,420 --> 00:54:32,420
so we're getting most significant

1128
00:54:30,590 --> 00:54:35,630
bop-bop least significant or something

1129
00:54:32,420 --> 00:54:37,519
like this either one of those two if

1130
00:54:35,630 --> 00:54:39,349
it's just which whichever one of those

1131
00:54:37,519 --> 00:54:41,119
two it is if we want the other one

1132
00:54:39,349 --> 00:54:44,389
to swap them all we have to do is

1133
00:54:41,119 --> 00:54:47,329
exchange the places of the bytes so if

1134
00:54:44,389 --> 00:54:49,639
we've got four bytes zero and three need

1135
00:54:47,329 --> 00:54:53,029
to get swapped and one and two need to

1136
00:54:49,639 --> 00:54:55,279
get swapped of our bytes right so we we

1137
00:54:53,030 --> 00:54:57,830
know how to do that we know how to pick

1138
00:54:55,280 --> 00:55:03,140
those out of a data stream right and I

1139
00:54:57,829 --> 00:55:06,019
can show you pretty d constructively how

1140
00:55:03,139 --> 00:55:12,559
it would work here so let's suppose we

1141
00:55:06,019 --> 00:55:14,630
have our value let's do it like this

1142
00:55:12,559 --> 00:55:17,659
so let's suppose we have our value here

1143
00:55:14,630 --> 00:55:19,849
we know if we want the first byte the

1144
00:55:17,659 --> 00:55:23,029
let's say the least significant byte of

1145
00:55:19,849 --> 00:55:25,549
the stream right that gets us the least

1146
00:55:23,030 --> 00:55:27,830
significant byte another way to say that

1147
00:55:25,550 --> 00:55:30,289
would be you know don't shift it and

1148
00:55:27,829 --> 00:55:32,650
just end it with XF that gives us the

1149
00:55:30,289 --> 00:55:34,329
lowest bite right here I can shift

1150
00:55:32,650 --> 00:55:35,500
again here I can shift down again here I

1151
00:55:34,329 --> 00:55:39,818
can shift down again right that would

1152
00:55:35,500 --> 00:55:41,710
extract each of the bytes in order then

1153
00:55:39,818 --> 00:55:44,259
if I want to build up the new value

1154
00:55:41,710 --> 00:55:46,809
right I can just say okay I need to

1155
00:55:44,260 --> 00:55:48,250
order these together and what I want to

1156
00:55:46,809 --> 00:55:50,440
do is put them back in the opposite

1157
00:55:48,250 --> 00:55:53,559
order they came so what I can do here is

1158
00:55:50,440 --> 00:55:56,079
say okay b0 used to be at the 0th

1159
00:55:53,559 --> 00:55:58,990
position I want to put it up at the 24

1160
00:55:56,079 --> 00:56:03,670
position now right and then I can take

1161
00:55:58,989 --> 00:56:05,798
b1 and put it up at the 16 position and

1162
00:56:03,670 --> 00:56:10,180
then B to put that up at the 8th

1163
00:56:05,798 --> 00:56:13,690
position right and b3 at the zero

1164
00:56:10,179 --> 00:56:16,000
position right so that's wops the order

1165
00:56:13,690 --> 00:56:17,409
of those things around oops that's not

1166
00:56:16,000 --> 00:56:19,929
we're doing here we're signing it back

1167
00:56:17,409 --> 00:56:23,199
right so that swaps the order of those

1168
00:56:19,929 --> 00:56:25,088
values for us and it swaps them you know

1169
00:56:23,199 --> 00:56:28,358
it replaces the existing value with the

1170
00:56:25,088 --> 00:56:32,139
swapped value now the thing that you can

1171
00:56:28,358 --> 00:56:34,150
notice here is that the I the compiler

1172
00:56:32,139 --> 00:56:35,858
may be smart enough to just realize what

1173
00:56:34,150 --> 00:56:38,260
we're doing and do it correctly but what

1174
00:56:35,858 --> 00:56:41,288
you can see here is you don't really

1175
00:56:38,260 --> 00:56:45,720
need to quite do it that way because

1176
00:56:41,289 --> 00:56:48,880
what you can see here is b3 gets like

1177
00:56:45,719 --> 00:56:51,909
shifted down 24 ANDed and then shifted

1178
00:56:48,880 --> 00:56:54,369
up 8 or whatever b2 is shifted down 16

1179
00:56:51,909 --> 00:56:56,828
and then up 8 what we could do instead

1180
00:56:54,369 --> 00:56:58,269
is just do one shift that shifts it into

1181
00:56:56,829 --> 00:57:00,430
the right position and then one mass

1182
00:56:58,269 --> 00:57:08,588
that masks it out correctly right so you

1183
00:57:00,429 --> 00:57:14,159
can do a more condensed version of the

1184
00:57:08,588 --> 00:57:14,159
swap if you want to so for example

1185
00:57:20,929 --> 00:57:26,069
if you take a look at what's going on

1186
00:57:22,920 --> 00:57:41,059
here let's suppose we just inserted b0

1187
00:57:26,070 --> 00:57:44,490
as a term b1 as a term b2 as a term and

1188
00:57:41,059 --> 00:57:47,730
b3 of the term right so what we see

1189
00:57:44,489 --> 00:57:52,859
pretty early on is that like b3 for

1190
00:57:47,730 --> 00:57:55,050
example just works that is exactly where

1191
00:57:52,860 --> 00:57:57,480
that value needs to go right it just

1192
00:57:55,050 --> 00:57:59,789
gets shifted down 24 and masked off by

1193
00:57:57,480 --> 00:58:02,369
FF but do we really have to mask it off

1194
00:57:59,789 --> 00:58:04,440
by FF no because this shift will shift

1195
00:58:02,369 --> 00:58:06,659
in zeroes for us and there's nothing up

1196
00:58:04,440 --> 00:58:09,059
above it so really that's all that's

1197
00:58:06,659 --> 00:58:11,129
happening right all we're doing there is

1198
00:58:09,059 --> 00:58:13,079
just saying okay we just need to shift

1199
00:58:11,130 --> 00:58:14,809
it down 24 that'll just leave the eight

1200
00:58:13,079 --> 00:58:17,789
bytes exactly in the lane that we want

1201
00:58:14,809 --> 00:58:20,219
now this one that shifts down sixteen is

1202
00:58:17,789 --> 00:58:23,429
then getting shifted up by eight right

1203
00:58:20,219 --> 00:58:25,589
so it's going down 16 but then it's

1204
00:58:23,429 --> 00:58:28,230
going back eight the other direction

1205
00:58:25,590 --> 00:58:30,180
right so really all that has to happen

1206
00:58:28,230 --> 00:58:35,699
there is it just has to get shifted

1207
00:58:30,179 --> 00:58:38,489
eight that's it right but in order to

1208
00:58:35,699 --> 00:58:40,769
when we do shifted eight we need to

1209
00:58:38,489 --> 00:58:42,449
block out the part that we're talking

1210
00:58:40,769 --> 00:58:43,739
about there right we need to block out

1211
00:58:42,449 --> 00:58:47,519
the the part that we're actually

1212
00:58:43,739 --> 00:58:50,399
interested in because it still got cruft

1213
00:58:47,519 --> 00:58:52,380
on either side of it right so what we

1214
00:58:50,400 --> 00:58:56,039
want to do specifically there is make

1215
00:58:52,380 --> 00:58:58,050
sure that we're we're knocking out only

1216
00:58:56,039 --> 00:58:59,789
that one part of the value that we're

1217
00:58:58,050 --> 00:59:01,260
actually trying to put in right which is

1218
00:58:59,789 --> 00:59:03,179
this part right here because that's

1219
00:59:01,260 --> 00:59:04,770
trying to get that Lane right so we got

1220
00:59:03,179 --> 00:59:06,149
the least significant byte we've got the

1221
00:59:04,769 --> 00:59:08,159
next two least significant byte we've

1222
00:59:06,150 --> 00:59:10,470
put it in place and we just need to make

1223
00:59:08,159 --> 00:59:13,829
sure that this cruft isn't still there

1224
00:59:10,469 --> 00:59:15,569
right and that's all we need to do for

1225
00:59:13,829 --> 00:59:18,000
that now this one is the opposite of

1226
00:59:15,570 --> 00:59:20,580
that this one's going down eight to mask

1227
00:59:18,000 --> 00:59:22,170
it but then it was going back up 16 so

1228
00:59:20,579 --> 00:59:23,880
instead what we can do is just say look

1229
00:59:22,170 --> 00:59:26,700
that's just a shift upwards by eight and

1230
00:59:23,880 --> 00:59:29,190
now the same thing happens right we just

1231
00:59:26,699 --> 00:59:31,108
need to mask it with something that will

1232
00:59:29,190 --> 00:59:33,749
make sure it clears out the other

1233
00:59:31,108 --> 00:59:35,848
part of the craft so that we don't have

1234
00:59:33,748 --> 00:59:37,469
to deal with that right and furthermore

1235
00:59:35,849 --> 00:59:39,298
if you look at what's going to happen

1236
00:59:37,469 --> 00:59:41,368
here there's a number of things you can

1237
00:59:39,298 --> 00:59:43,440
sort of see going on one of the thing is

1238
00:59:41,369 --> 00:59:46,259
well it'd be nice if these two masks

1239
00:59:43,440 --> 00:59:48,568
were the same we actually can make those

1240
00:59:46,259 --> 00:59:49,769
two masks the same because if you think

1241
00:59:48,568 --> 00:59:52,288
about what's happening here we could

1242
00:59:49,768 --> 00:59:56,699
just choose two masks beforehand right

1243
00:59:52,289 --> 00:59:59,160
if we mask this guy beforehand here like

1244
00:59:56,699 --> 01:00:00,960
so then this would be the same mask so

1245
00:59:59,159 --> 01:00:02,699
we could use the same mask twice and not

1246
01:00:00,960 --> 01:00:05,009
have to neat use an additional mass

1247
01:00:02,699 --> 01:00:08,248
because we just an first and then shift

1248
01:00:05,009 --> 01:00:11,880
right and then finally this one is one

1249
01:00:08,248 --> 01:00:13,498
that's just up in in the that needs to

1250
01:00:11,880 --> 01:00:16,108
go up in the top it starts at the bottom

1251
01:00:13,498 --> 01:00:18,268
same things true here right we can mask

1252
01:00:16,108 --> 01:00:20,670
that off early and not have to load a

1253
01:00:18,268 --> 01:00:22,798
large mask in and then we can just shift

1254
01:00:20,670 --> 01:00:25,380
it up by 24 to put it into the correct

1255
01:00:22,798 --> 01:00:27,690
place now here's the thing why would we

1256
01:00:25,380 --> 01:00:29,880
mask it at all if we're gonna shift it

1257
01:00:27,690 --> 01:00:31,499
all the way up 24 places all the stuff

1258
01:00:29,880 --> 01:00:33,329
that would have been there he's just

1259
01:00:31,498 --> 01:00:35,730
gonna get obliterated anyway so we can

1260
01:00:33,329 --> 01:00:38,249
again just like we did in this case when

1261
01:00:35,730 --> 01:00:40,199
you shift one byte from the bottom or

1262
01:00:38,248 --> 01:00:42,538
the top all the way to the position all

1263
01:00:40,199 --> 01:00:43,980
the other values get shifted out so

1264
01:00:42,539 --> 01:00:46,049
we're left with a pretty straightforward

1265
01:00:43,980 --> 01:00:49,469
way of doing this once you work it all

1266
01:00:46,048 --> 01:00:55,969
through that you can kind of see here we

1267
01:00:49,469 --> 01:00:55,969
end up with this fairly nice-looking

1268
01:00:56,298 --> 01:01:04,469
little bit of code here right shift V up

1269
01:01:00,630 --> 01:01:07,499
24 we or that with V and F F shifted up

1270
01:01:04,469 --> 01:01:11,219
8 we shift it down 8 and and it with F F

1271
01:01:07,498 --> 01:01:13,919
again and then we shift it 24 right

1272
01:01:11,219 --> 01:01:17,929
and so that's the concise way of writing

1273
01:01:13,920 --> 01:01:17,930
it it's pretty nice right

1274
01:01:26,500 --> 01:01:31,659
and so that's nice and clean right it's

1275
01:01:29,289 --> 01:01:33,250
pretty good so what we want to do here

1276
01:01:31,659 --> 01:01:34,889
now is just verify this actually works

1277
01:01:33,250 --> 01:01:38,289
at all I mean that would be nice right

1278
01:01:34,889 --> 01:01:40,659
so if I go ahead and say let's make

1279
01:01:38,289 --> 01:01:45,429
value to start with something that we

1280
01:01:40,659 --> 01:01:48,009
understand right that's a really easy

1281
01:01:45,429 --> 01:01:56,769
bit pattern to see and so now we can do

1282
01:01:48,010 --> 01:01:59,920
is we can watch it swap and put it into

1283
01:01:56,769 --> 01:02:05,170
that position right so let's just do

1284
01:01:59,920 --> 01:02:08,550
that there we go

1285
01:02:05,170 --> 01:02:08,550
so I'm gonna go ahead and run to there

1286
01:02:12,929 --> 01:02:23,379
and if I go ahead and watch here's my V

1287
01:02:16,480 --> 01:02:25,809
value in hex and here's my actual stored

1288
01:02:23,380 --> 01:02:27,430
value and when we're done you can see

1289
01:02:25,809 --> 01:02:29,079
you see how that flipped it so it was

1290
01:02:27,429 --> 01:02:31,629
four or three to one and then it's up to

1291
01:02:29,079 --> 01:02:34,000
one two three four right and so that's

1292
01:02:31,630 --> 01:02:35,920
the nd in reverse that we need to do to

1293
01:02:34,000 --> 01:02:38,440
make sure that we get out the value that

1294
01:02:35,920 --> 01:02:41,050
we expect okay so now let's get out take

1295
01:02:38,440 --> 01:02:43,088
out the nerfing there like so so now

1296
01:02:41,050 --> 01:02:45,250
this will actually swap real values for

1297
01:02:43,088 --> 01:02:47,019
us so now we can jump in here and take a

1298
01:02:45,250 --> 01:02:49,239
look so when we come through here and we

1299
01:02:47,019 --> 01:02:51,039
look at the chunk header when we endian

1300
01:02:49,239 --> 01:02:52,449
swap that now we're gonna see that the

1301
01:02:51,039 --> 01:02:54,940
length is actually a much more

1302
01:02:52,449 --> 01:02:57,189
reasonable value there we go now we

1303
01:02:54,940 --> 01:02:58,539
don't know what the padding algorithm is

1304
01:02:57,190 --> 01:03:00,789
here so I don't know if these numbers

1305
01:02:58,539 --> 01:03:03,070
should be padded out that's something

1306
01:03:00,789 --> 01:03:05,380
we're gonna have to look at and see but

1307
01:03:03,070 --> 01:03:07,300
we should know right away if it is or

1308
01:03:05,380 --> 01:03:08,619
isn't because remember this is a chunk

1309
01:03:07,300 --> 01:03:11,019
data format so he's fixed each chunk

1310
01:03:08,619 --> 01:03:13,059
chunk chunk chunk chunk if we jump

1311
01:03:11,019 --> 01:03:14,500
forward by the amount as specified which

1312
01:03:13,059 --> 01:03:18,130
is 13 now that we've read it in

1313
01:03:14,500 --> 01:03:20,469
endianness format correct right what

1314
01:03:18,130 --> 01:03:23,320
we're gonna see here in this in this

1315
01:03:20,469 --> 01:03:25,689
next go through on the read is we should

1316
01:03:23,320 --> 01:03:27,970
now see another valid chunk header and

1317
01:03:25,690 --> 01:03:31,450
we do right so it looks like they're not

1318
01:03:27,969 --> 01:03:33,429
padded out so here's our bkgd that's a

1319
01:03:31,449 --> 01:03:34,929
background data trunk probably I'm

1320
01:03:33,429 --> 01:03:38,169
guessing just by the name

1321
01:03:34,929 --> 01:03:39,909
again a short one so there we go and we

1322
01:03:38,170 --> 01:03:42,849
just you know keep on reading here and

1323
01:03:39,909 --> 01:03:44,679
off we go so now let's go ahead and take

1324
01:03:42,849 --> 01:03:47,019
that because that's all well and good

1325
01:03:44,679 --> 01:03:48,159
and fine now that we're reading this a

1326
01:03:47,019 --> 01:03:49,750
little bit more correctly and we figured

1327
01:03:48,159 --> 01:03:51,250
out that a little endian problem what

1328
01:03:49,750 --> 01:03:52,719
I'd like to do now is just have this

1329
01:03:51,250 --> 01:03:55,150
print out what we're actually seeing the

1330
01:03:52,719 --> 01:03:56,379
files so we can look at it cleanly so

1331
01:03:55,150 --> 01:03:57,880
when we come through here after we do

1332
01:03:56,380 --> 01:03:59,890
our Indian swap I'm going to do is I'm

1333
01:03:57,880 --> 01:04:01,660
going to print out what the type is for

1334
01:03:59,889 --> 01:04:04,719
each of the chunks in the file so when

1335
01:04:01,659 --> 01:04:06,759
we get the chunk data out here what I

1336
01:04:04,719 --> 01:04:07,989
want to do is now I'm just going to

1337
01:04:06,760 --> 01:04:20,890
print the header in fact I could print

1338
01:04:07,989 --> 01:04:21,969
it right here there's a probably I could

1339
01:04:20,889 --> 01:04:25,469
have done that a little bit differently

1340
01:04:21,969 --> 01:04:25,469
I'm not gonna bother though who cares

1341
01:04:32,130 --> 01:04:36,190
there we go

1342
01:04:34,150 --> 01:04:37,930
so now we should be able to do is run it

1343
01:04:36,190 --> 01:04:40,150
like on a file like this and it should

1344
01:04:37,929 --> 01:04:41,469
tell us all the chunks and now we could

1345
01:04:40,150 --> 01:04:44,079
see that we're actually parsing the file

1346
01:04:41,469 --> 01:04:46,119
correctly at least for this kind of file

1347
01:04:44,079 --> 01:04:47,889
because you can see we didn't have any

1348
01:04:46,119 --> 01:04:49,539
underflow like we've read exactly the

1349
01:04:47,889 --> 01:04:50,710
amount of data we should have read and

1350
01:04:49,539 --> 01:04:52,509
you could also see that we got exactly

1351
01:04:50,710 --> 01:04:54,190
what the spec said we should get an AI

1352
01:04:52,510 --> 01:04:56,290
header at the beginning in an AI end at

1353
01:04:54,190 --> 01:04:59,619
the end and then all of this is just

1354
01:04:56,289 --> 01:05:00,820
data information that we can choose to

1355
01:04:59,619 --> 01:05:02,349
parse if it's something that we think

1356
01:05:00,820 --> 01:05:04,870
affects the image we actually care about

1357
01:05:02,349 --> 01:05:07,360
and not if it doesn't so for example T

1358
01:05:04,869 --> 01:05:09,039
ext chunks I'm guessing just based on

1359
01:05:07,360 --> 01:05:14,860
the name that that might be something we

1360
01:05:09,039 --> 01:05:17,019
don't really need to parse yeah and you

1361
01:05:14,860 --> 01:05:19,870
can see here it just contains a key word

1362
01:05:17,019 --> 01:05:22,809
and texturing in the following format so

1363
01:05:19,869 --> 01:05:25,839
there's a key word character string a

1364
01:05:22,809 --> 01:05:27,730
null separator and then some other text

1365
01:05:25,840 --> 01:05:31,300
string here so what I could do there for

1366
01:05:27,730 --> 01:05:34,780
example is just look and see if I if I

1367
01:05:31,300 --> 01:05:37,500
want to to check like that could do

1368
01:05:34,780 --> 01:05:37,500
something like this

1369
01:05:44,940 --> 01:05:48,059
[Music]

1370
01:05:49,670 --> 01:06:06,720
can you do so here's the question for

1371
01:05:55,500 --> 01:06:08,130
you this is macro land for CC is usually

1372
01:06:06,719 --> 01:06:13,250
the name of these kind of codes they

1373
01:06:08,130 --> 01:06:13,250
like four letters for a type code thing

1374
01:06:13,789 --> 01:06:20,909
for whatever reason um can you do that

1375
01:06:18,360 --> 01:06:22,230
by extracting the letter information

1376
01:06:20,909 --> 01:06:24,509
from this I'm just curious

1377
01:06:22,230 --> 01:06:34,590
so for example if I have to do the

1378
01:06:24,510 --> 01:06:36,660
following could you just say alright I

1379
01:06:34,590 --> 01:06:45,690
want to take the string that you give me

1380
01:06:36,659 --> 01:06:49,769
and I want to extract the 0 the 1 the 2

1381
01:06:45,690 --> 01:06:53,090
and the 3 from it like is that on the

1382
01:06:49,769 --> 01:06:53,090
table I don't really know

1383
01:07:11,539 --> 01:07:17,520
guessing the answer is now it's one of

1384
01:07:15,690 --> 01:07:30,389
those macro things I just don't really

1385
01:07:17,519 --> 01:07:48,210
remember and so what was this it was

1386
01:07:30,389 --> 01:07:55,199
like txt yeah oh let's see here so I

1387
01:07:48,210 --> 01:08:01,608
want this to be cast to AU 32 actually I

1388
01:07:55,199 --> 01:08:04,139
want that to be true prior to this so

1389
01:08:01,608 --> 01:08:09,528
I'm really surprised that that worked by

1390
01:08:04,139 --> 01:08:09,528
the way if it worked that's pretty cool

1391
01:08:27,109 --> 01:08:40,180
so does that actually work so where is

1392
01:08:37,369 --> 01:08:44,048
the Derrida's holy cow

1393
01:08:40,180 --> 01:08:46,670
well that's pretty great alright so

1394
01:08:44,048 --> 01:08:48,380
that's a pretty easy way to take a

1395
01:08:46,670 --> 01:08:51,560
string and turn it into a 32-bit

1396
01:08:48,380 --> 01:08:53,659
identifier just automatically I wasn't

1397
01:08:51,560 --> 01:08:55,640
sure if that was kind of work but that's

1398
01:08:53,659 --> 01:09:01,519
pretty cool you see I've seen a lot of

1399
01:08:55,640 --> 01:09:04,940
times let's see if I got I've seen a lot

1400
01:09:01,520 --> 01:09:09,560
of people do it like yeah like that

1401
01:09:04,939 --> 01:09:12,919
right I've seen a lot of that garbage uh

1402
01:09:09,560 --> 01:09:14,660
and it's just dumb like this stuff is

1403
01:09:12,920 --> 01:09:21,109
just like look at how stupid this is

1404
01:09:14,659 --> 01:09:22,699
right and like this is way better if you

1405
01:09:21,109 --> 01:09:24,880
can do it I don't know if you can do

1406
01:09:22,699 --> 01:09:24,880
that

1407
01:09:26,079 --> 01:09:35,449
maybe you can do that but this seems

1408
01:09:31,699 --> 01:09:36,649
really good if you can't write my that

1409
01:09:35,449 --> 01:09:40,479
was this was another thing I was going

1410
01:09:36,649 --> 01:09:40,479
to try I'm not sure if that does work

1411
01:09:45,548 --> 01:09:49,838
may see if that other way works too but

1412
01:09:50,048 --> 01:09:53,778
anyway the only reason I want to show

1413
01:09:52,159 --> 01:09:56,180
you that was I didn't know I've seen

1414
01:09:53,779 --> 01:09:58,400
I've seen a lot of people do it where

1415
01:09:56,180 --> 01:10:01,579
you have to put commas in between like

1416
01:09:58,399 --> 01:10:02,899
that and that's just annoying so anyway

1417
01:10:01,579 --> 01:10:05,930
let me see if you can do it that way I

1418
01:10:02,899 --> 01:10:06,829
didn't think you could do this then

1419
01:10:05,930 --> 01:10:09,280
again I didn't think you could do the

1420
01:10:06,829 --> 01:10:09,279
other way either

1421
01:10:22,710 --> 01:10:28,090
that's great so these are real easy then

1422
01:10:26,350 --> 01:10:30,760
those are so much better than the

1423
01:10:28,090 --> 01:10:32,699
comma-separated versions so that's cool

1424
01:10:30,760 --> 01:10:35,890
I'm happy about that

1425
01:10:32,698 --> 01:10:39,579
all right so that makes it really easy

1426
01:10:35,890 --> 01:10:42,070
for us to sort of switch on which type

1427
01:10:39,579 --> 01:10:43,659
of chunk we're getting um so what I want

1428
01:10:42,069 --> 01:10:48,069
to do here is like here's the thing that

1429
01:10:43,659 --> 01:10:51,698
consumes the chunk data right and what I

1430
01:10:48,069 --> 01:10:53,198
probably will do here is just say look

1431
01:10:51,698 --> 01:10:57,669
well consume the chunk data at the

1432
01:10:53,198 --> 01:11:03,428
outset and then I'll just do a switch on

1433
01:10:57,670 --> 01:11:06,159
the type and then we'll just put some

1434
01:11:03,429 --> 01:11:16,890
cases in here so here's the cases that

1435
01:11:06,159 --> 01:11:16,889
we saw can I do those as constants

1436
01:11:31,329 --> 01:11:38,079
so there we can now see the benefit of

1437
01:11:34,390 --> 01:11:40,240
this approach I guess so mine is better

1438
01:11:38,079 --> 01:11:42,039
than the Castillo pointer because this

1439
01:11:40,239 --> 01:11:43,389
weight properly evaluates to the

1440
01:11:42,039 --> 01:11:44,829
constant as well as the compiler is

1441
01:11:43,390 --> 01:11:47,350
concerned in the other way didn't

1442
01:11:44,829 --> 01:11:49,319
so that's relatively important so I

1443
01:11:47,350 --> 01:11:57,600
think that's where we're at

1444
01:11:49,319 --> 01:12:06,729
alright so we had an I had our chunk a

1445
01:11:57,600 --> 01:12:10,030
bkgd chunk the phys chunk at T IME chunk

1446
01:12:06,729 --> 01:12:25,089
a text chunk I'd at chunks and an end

1447
01:12:10,029 --> 01:12:28,239
chunk so that's what we saw all right so

1448
01:12:25,090 --> 01:12:29,890
a txt chunk supposedly it's like just

1449
01:12:28,239 --> 01:12:31,809
textual data you could print that there

1450
01:12:29,890 --> 01:12:44,200
so in theory we should be able to just

1451
01:12:31,810 --> 01:12:46,660
do this where we just say okay the chunk

1452
01:12:44,199 --> 01:12:48,519
data is just a string now there's I

1453
01:12:46,659 --> 01:12:50,880
think there's two strings packed into it

1454
01:12:48,520 --> 01:12:50,880
actually

1455
01:13:02,279 --> 01:13:06,039
so we actually would print out more than

1456
01:13:05,050 --> 01:13:10,570
that one

1457
01:13:06,039 --> 01:13:13,420
but in theory so there you can see so

1458
01:13:10,569 --> 01:13:16,448
let me just see what this says in the

1459
01:13:13,420 --> 01:13:20,679
spec for what's in there we can go ahead

1460
01:13:16,448 --> 01:13:22,629
to txt textual data oops that's the

1461
01:13:20,679 --> 01:13:24,940
wrong one

1462
01:13:22,630 --> 01:13:26,590
so for textual data it just says the for

1463
01:13:24,939 --> 01:13:28,419
my Trinity of just with values each text

1464
01:13:26,590 --> 01:13:31,630
chunk it takes a keyword and a text

1465
01:13:28,420 --> 01:13:37,060
string in the format keyword null

1466
01:13:31,630 --> 01:13:51,159
separator texturing it's so I guess we

1467
01:13:37,060 --> 01:13:57,480
just say keyword string care star key

1468
01:13:51,158 --> 01:14:03,908
word equals chunk data care star spring

1469
01:13:57,479 --> 01:14:19,149
goes keyword while star string plus plus

1470
01:14:03,908 --> 01:14:23,309
string right so we just basically say

1471
01:14:19,149 --> 01:14:23,309
look go till you hit the null terminator

1472
01:14:27,510 --> 01:14:35,409
and give me what's what's after it right

1473
01:14:32,250 --> 01:14:37,869
it looks like they don't know terminate

1474
01:14:35,408 --> 01:14:40,269
the other one right because you're

1475
01:14:37,869 --> 01:14:42,099
seeing garbage at the end there so it

1476
01:14:40,270 --> 01:14:46,510
looks like you're expected to null

1477
01:14:42,100 --> 01:14:49,469
terminate it yourself I'm guessing at

1478
01:14:46,510 --> 01:14:56,949
least that's what appears to be the case

1479
01:14:49,469 --> 01:14:59,198
so like wherever the chunk footer is at

1480
01:14:56,948 --> 01:15:05,139
that point is the part that would need

1481
01:14:59,198 --> 01:15:08,888
to be the the null terminator so what we

1482
01:15:05,140 --> 01:15:10,920
can do here is to say RA like you need

1483
01:15:08,889 --> 01:15:10,920
to

1484
01:15:11,010 --> 01:15:16,690
print out only a certain amount of this

1485
01:15:14,229 --> 01:15:21,000
string and the amount that you're going

1486
01:15:16,689 --> 01:15:21,000
to print out is going to be whatever the

1487
01:15:21,810 --> 01:15:33,640
null pointer that whatever the end of

1488
01:15:25,779 --> 01:15:35,800
the chunk was we'll just say that that's

1489
01:15:33,640 --> 01:15:37,210
that's as far as you can go because it

1490
01:15:35,800 --> 01:15:44,699
looks like that's not null terminated

1491
01:15:37,210 --> 01:15:47,170
only the first part is looks like yeah

1492
01:15:44,699 --> 01:15:49,090
so and also I guess the problem here is

1493
01:15:47,170 --> 01:15:50,560
that it's only gonna accept that on the

1494
01:15:49,090 --> 01:15:55,720
printout which is fine we know it's not

1495
01:15:50,560 --> 01:15:57,789
going to be more than that so that's a

1496
01:15:55,720 --> 01:15:59,730
text chunk that's gonna be the easiest

1497
01:15:57,789 --> 01:16:02,079
thing probably that we can interpret

1498
01:15:59,729 --> 01:16:04,119
let's see which other ones of these we

1499
01:16:02,079 --> 01:16:06,010
care about we that was just a little bit

1500
01:16:04,119 --> 01:16:08,019
of practice we probably don't care about

1501
01:16:06,010 --> 01:16:09,789
most of the other ones here but let's

1502
01:16:08,020 --> 01:16:11,950
just verify that's true I don't know if

1503
01:16:09,789 --> 01:16:13,029
it is or not so we want to just go ahead

1504
01:16:11,949 --> 01:16:14,889
and see what all the rest of these

1505
01:16:13,029 --> 01:16:17,519
chunks are before we decide what we need

1506
01:16:14,890 --> 01:16:20,890
and what we don't need because who knows

1507
01:16:17,520 --> 01:16:24,570
all right so let's take a look at the

1508
01:16:20,890 --> 01:16:27,940
first chunk we've got here which is the

1509
01:16:24,569 --> 01:16:31,630
bkgd chunk we know we have to read the

1510
01:16:27,939 --> 01:16:34,269
header what one it's the default

1511
01:16:31,630 --> 01:16:35,890
background to present against if there

1512
01:16:34,270 --> 01:16:39,730
is any other preferred background

1513
01:16:35,890 --> 01:16:41,710
user-supplied yes so we don't care about

1514
01:16:39,729 --> 01:16:44,019
this color because our background is

1515
01:16:41,710 --> 01:16:48,659
always transparent if nothing specified

1516
01:16:44,020 --> 01:16:54,730
there so we don't care about this right

1517
01:16:48,659 --> 01:16:57,449
this is ignored let's take a look at the

1518
01:16:54,729 --> 01:16:57,449
fizz tunc

1519
01:16:59,390 --> 01:17:08,990
took the picture size an aspect ratio

1520
01:17:01,409 --> 01:17:08,989
don't care about that the time chunk

1521
01:17:12,658 --> 01:17:18,988
don't care about that and technically we

1522
01:17:16,538 --> 01:17:21,698
don't care about the text chunk either

1523
01:17:18,988 --> 01:17:23,799
so at that point we're just down to this

1524
01:17:21,698 --> 01:17:26,408
it looks like these are the only things

1525
01:17:23,800 --> 01:17:27,760
we care about the header and Alice see

1526
01:17:26,408 --> 01:17:35,679
the end chunk I don't even know if we

1527
01:17:27,760 --> 01:17:38,139
care about is there anything in it no so

1528
01:17:35,679 --> 01:18:03,639
if we're looking at that we're basically

1529
01:17:38,139 --> 01:18:06,460
looking at I think all right seems like

1530
01:18:03,639 --> 01:18:09,690
that's all we really care about so at

1531
01:18:06,460 --> 01:18:09,689
that point we're just like all right

1532
01:18:16,738 --> 01:18:20,529
that's all we're looking for in this

1533
01:18:19,300 --> 01:18:22,510
file that's the only thing that's

1534
01:18:20,529 --> 01:18:24,939
actually gonna have information that's

1535
01:18:22,510 --> 01:18:26,498
you know relevant to us we're parsing

1536
01:18:24,939 --> 01:18:28,658
them out so now we've got the two things

1537
01:18:26,498 --> 01:18:29,979
we need let's start with the IEEE header

1538
01:18:28,658 --> 01:18:31,839
chunk because that's the one that's

1539
01:18:29,979 --> 01:18:33,459
probably easiest because it's not going

1540
01:18:31,840 --> 01:18:34,779
to have any compress data it's just

1541
01:18:33,460 --> 01:18:37,149
going to tell us like what we're

1542
01:18:34,779 --> 01:18:40,868
actually doing so you can see that we've

1543
01:18:37,149 --> 01:18:42,638
got this nonsense going on here it base

1544
01:18:40,868 --> 01:18:43,719
says width height bit depth color type

1545
01:18:42,639 --> 01:18:45,400
compression method filter method

1546
01:18:43,719 --> 01:18:52,059
interlaced mess it's just telling us how

1547
01:18:45,399 --> 01:18:55,388
to read the file right it looks like

1548
01:18:52,059 --> 01:18:56,949
that's it so it looks like really the

1549
01:18:55,389 --> 01:18:59,590
rest of this is just telling us what

1550
01:18:56,948 --> 01:19:03,009
these things could be so let's just go

1551
01:18:59,590 --> 01:19:04,989
ahead and get those values out let me

1552
01:19:03,010 --> 01:19:05,940
make a structure that leads out that

1553
01:19:04,988 --> 01:19:11,229
exact thing

1554
01:19:05,939 --> 01:19:11,678
PNG I header so that's going to be the

1555
01:19:11,229 --> 01:19:18,328
width

1556
01:19:11,679 --> 01:19:18,328
oops the height the bit depth

1557
01:19:21,929 --> 01:19:34,130
color typed oppression filter interlace

1558
01:19:35,270 --> 01:19:50,370
so you're fine go ahead and consume one

1559
01:19:37,590 --> 01:19:51,539
of these I actually don't have to

1560
01:19:50,369 --> 01:19:54,090
consume me because we already got it

1561
01:19:51,539 --> 01:19:56,460
it's right there so if I go ahead and

1562
01:19:54,090 --> 01:19:59,699
get one of those then when I look

1563
01:19:56,460 --> 01:20:01,560
through here I should be able to print

1564
01:19:59,698 --> 01:20:03,960
all these out so again the width and the

1565
01:20:01,560 --> 01:20:12,239
height are actual have to be any in a

1566
01:20:03,960 --> 01:20:14,460
swap right because they're gonna be

1567
01:20:12,238 --> 01:20:17,428
stored in net reporter much to our

1568
01:20:14,460 --> 01:20:22,439
chagrin but then everything else we

1569
01:20:17,429 --> 01:20:24,300
should be able to print out doesn't see

1570
01:20:22,439 --> 01:20:25,649
whether that's an unsigned integer or a

1571
01:20:24,300 --> 01:20:28,020
signed integer I'm gonna go ahead and

1572
01:20:25,649 --> 01:20:29,099
treat it as unsigned cuz I don't think

1573
01:20:28,020 --> 01:20:32,120
you're gonna have negative with the

1574
01:20:29,100 --> 01:20:35,489
height that may not be true it may be

1575
01:20:32,119 --> 01:20:37,619
that no it says right here for byte

1576
01:20:35,488 --> 01:20:40,979
unsigned integers so that's good there's

1577
01:20:37,619 --> 01:20:43,189
no negatives sometimes they like what we

1578
01:20:40,979 --> 01:20:45,629
saw when we parse bitmap oh so long ago

1579
01:20:43,189 --> 01:20:48,479
negative means that's flipped in that

1580
01:20:45,630 --> 01:20:49,859
along that axis it looks like we will

1581
01:20:48,479 --> 01:20:52,289
never have that here it'll always go in

1582
01:20:49,859 --> 01:20:54,509
the same direction so that's nice that

1583
01:20:52,289 --> 01:20:56,010
just makes things a little easier so

1584
01:20:54,510 --> 01:20:58,159
let's go ahead and print out the rest of

1585
01:20:56,010 --> 01:20:58,159
this

1586
01:21:07,979 --> 01:21:23,629
so what else we got clark's i freshen

1587
01:21:13,920 --> 01:21:23,630
method filter method into lace method

1588
01:21:27,920 --> 01:21:36,270
okay so now we should see data about our

1589
01:21:34,500 --> 01:21:37,500
image coming through hopefully it's all

1590
01:21:36,270 --> 01:21:38,969
correct

1591
01:21:37,500 --> 01:21:40,800
there's the width the height the bit

1592
01:21:38,969 --> 01:21:43,439
depth color depth compression filter

1593
01:21:40,800 --> 01:21:46,199
interlace what you can see here is these

1594
01:21:43,439 --> 01:21:48,809
are exactly respect the only thing I

1595
01:21:46,198 --> 01:21:50,039
don't see here is anything like how many

1596
01:21:48,810 --> 01:21:51,480
bits per pixel there are things like

1597
01:21:50,039 --> 01:21:53,158
that I think that's because color type

1598
01:21:51,479 --> 01:21:54,269
is probably just a value it's going to

1599
01:21:53,158 --> 01:21:55,979
tell us all that information and we just

1600
01:21:54,270 --> 01:21:57,960
haven't looked at it yet so color type

1601
01:21:55,979 --> 01:21:59,698
six probably means our GBA we'll see you

1602
01:21:57,960 --> 01:22:00,840
in a second compression filter new lace

1603
01:21:59,698 --> 01:22:02,399
method I have no idea what they're

1604
01:22:00,840 --> 01:22:04,079
actually telling us I assumed interlaced

1605
01:22:02,399 --> 01:22:05,609
method 0 means non-interlaced I assume

1606
01:22:04,079 --> 01:22:07,769
filter based filter method 0 means

1607
01:22:05,609 --> 01:22:10,079
non-filtered I assume compression method

1608
01:22:07,770 --> 01:22:11,610
0 actually does mean compressed because

1609
01:22:10,079 --> 01:22:13,170
this image is smaller than it would be

1610
01:22:11,609 --> 01:22:15,149
if it wasn't compressed I assume 0 is

1611
01:22:13,170 --> 01:22:16,619
actually defaults to LZ or something

1612
01:22:15,149 --> 01:22:18,960
like that we're gonna see in a second

1613
01:22:16,619 --> 01:22:21,029
what that is so let's go ahead and take

1614
01:22:18,960 --> 01:22:23,489
a look and see what those values

1615
01:22:21,029 --> 01:22:24,420
actually translate into it might be the

1616
01:22:23,488 --> 01:22:25,979
compression a zero actually means

1617
01:22:24,420 --> 01:22:28,560
uncompressed and it's actually talking

1618
01:22:25,979 --> 01:22:30,329
about some other thing that we're that

1619
01:22:28,560 --> 01:22:33,600
it's not the bit plane did or something

1620
01:22:30,329 --> 01:22:34,829
I don't know but let's see so bit depth

1621
01:22:33,600 --> 01:22:37,230
to the single byte integer number but

1622
01:22:34,829 --> 01:22:39,359
for sample that's that we respect we

1623
01:22:37,229 --> 01:22:41,939
want that to always be 8 so that's gonna

1624
01:22:39,359 --> 01:22:43,289
be a requirement probably if it's not 8

1625
01:22:41,939 --> 01:22:46,349
then that's an error I would say

1626
01:22:43,289 --> 01:22:48,840
probably color type is a single byte

1627
01:22:46,350 --> 01:22:53,699
enjoyed 5 PNG image type of values are 0

1628
01:22:48,840 --> 01:22:56,550
2 3 4 and 6 so here's 0 2 3 4 &amp; 6 we

1629
01:22:53,698 --> 01:23:00,178
only accept true color with alpha so we

1630
01:22:56,550 --> 01:23:02,940
are only accepting 6 so 8 6 is the only

1631
01:23:00,179 --> 01:23:05,579
thing that we will actually accept right

1632
01:23:02,939 --> 01:23:09,750
so this right here 8 6 that's the only

1633
01:23:05,579 --> 01:23:11,850
thing that we'll accept right so

1634
01:23:09,750 --> 01:23:15,050
basically we'd say if the I header bit

1635
01:23:11,850 --> 01:23:15,050
depth is not equal to 8

1636
01:23:15,329 --> 01:23:24,779
or the I header color type is not equal

1637
01:23:19,469 --> 01:23:26,698
to six unsupported it's gonna equal true

1638
01:23:24,779 --> 01:23:30,420
or something like that right so there's

1639
01:23:26,698 --> 01:23:32,609
gonna be basically a boolean here that

1640
01:23:30,420 --> 01:23:34,500
says that this thing's unsporting what I

1641
01:23:32,609 --> 01:23:37,170
might do instead is something like this

1642
01:23:34,500 --> 01:23:39,750
I might do it affirmative Lee just

1643
01:23:37,170 --> 01:23:42,179
assume it's not supported it here will

1644
01:23:39,750 --> 01:23:44,039
actually set it to supported when the

1645
01:23:42,179 --> 01:23:46,529
bit depth and color type and everything

1646
01:23:44,039 --> 01:23:48,179
else says exactly what we want so if

1647
01:23:46,529 --> 01:24:08,929
those two things are correct then we'll

1648
01:23:48,179 --> 01:24:08,929
say it's supported and off we go

1649
01:24:17,229 --> 01:24:30,969
all right what what what was the problem

1650
01:24:23,050 --> 01:24:32,320
syntax error yes I crave that all right

1651
01:24:30,970 --> 01:24:33,880
so what we want to do now is look at

1652
01:24:32,319 --> 01:24:36,579
these compression filter interlace

1653
01:24:33,880 --> 01:24:39,069
things cuz we don't know what those mean

1654
01:24:36,579 --> 01:24:40,180
so let's take a look at that compression

1655
01:24:39,069 --> 01:24:41,439
method is a single interesting just

1656
01:24:40,180 --> 01:24:43,720
immense to do suppress the image only

1657
01:24:41,439 --> 01:24:45,339
compression method zero is defined in

1658
01:24:43,720 --> 01:24:46,690
this international standard so that

1659
01:24:45,340 --> 01:24:50,350
basically means that we're going to be

1660
01:24:46,689 --> 01:24:57,009
using compression method 0 these are

1661
01:24:50,350 --> 01:24:58,300
Ann's now so compression methods gonna

1662
01:24:57,010 --> 01:24:59,380
have to equal to 0 that's one thing

1663
01:24:58,300 --> 01:25:02,260
we're gonna support so I think it's even

1664
01:24:59,380 --> 01:25:03,400
in the spec filter method single-byte

1665
01:25:02,260 --> 01:25:04,900
interested in kiss Priya has some other

1666
01:25:03,399 --> 01:25:09,819
deposit image data for question filtered

1667
01:25:04,899 --> 01:25:11,829
zeroes defined that means we're you know

1668
01:25:09,819 --> 01:25:13,899
another good spot there because we only

1669
01:25:11,829 --> 01:25:15,430
have to handle one case although that

1670
01:25:13,899 --> 01:25:17,229
probably there's a bunch of cases inside

1671
01:25:15,430 --> 01:25:18,789
that case but whatever you don't I set

1672
01:25:17,229 --> 01:25:20,199
this thing about if it's shorter the two

1673
01:25:18,789 --> 01:25:24,250
values can find these just there's 0 no

1674
01:25:20,199 --> 01:25:26,789
delays or one atom 7 we may just require

1675
01:25:24,250 --> 01:25:26,789
0

1676
01:25:36,909 --> 01:25:45,409
okay so that's gonna be what we require

1677
01:25:42,829 --> 01:25:48,140
in terms of what comes out of here so

1678
01:25:45,409 --> 01:25:50,420
we've got the I header just fine now we

1679
01:25:48,140 --> 01:25:52,550
just need the I bat and that's gonna be

1680
01:25:50,420 --> 01:25:54,260
where all of the grievances come in

1681
01:25:52,550 --> 01:25:56,600
because that's gonna be the actual place

1682
01:25:54,260 --> 01:25:59,719
where it's compressed and has all kinds

1683
01:25:56,600 --> 01:26:02,030
of crap in it and whatever else so let's

1684
01:25:59,719 --> 01:26:03,949
jump down there and see what we've got a

1685
01:26:02,029 --> 01:26:05,149
four byte chunk field edge to the actual

1686
01:26:03,949 --> 01:26:07,099
image data that mr. compression

1687
01:26:05,149 --> 01:26:08,719
algorithms see Clause nine filtering

1688
01:26:07,100 --> 01:26:10,070
close to and compression details there

1689
01:26:08,719 --> 01:26:11,300
may be multiple I'd add chunks they

1690
01:26:10,069 --> 01:26:13,340
should appear consecutively with no

1691
01:26:11,300 --> 01:26:15,050
intervening chunks which they did the

1692
01:26:13,340 --> 01:26:18,770
issue is the concatenation of cost at it

1693
01:26:15,050 --> 01:26:19,880
fields in all the Ida X so who knows

1694
01:26:18,770 --> 01:26:22,700
what that means but we'll see you in a

1695
01:26:19,880 --> 01:26:24,770
second so let's start by looking at

1696
01:26:22,699 --> 01:26:26,238
what's going on here filtering

1697
01:26:24,770 --> 01:26:29,150
transforms PNG and just the goal of

1698
01:26:26,238 --> 01:26:32,139
improving compression so check your

1699
01:26:29,149 --> 01:26:34,699
method zero we got a bunch of stuff here

1700
01:26:32,140 --> 01:26:37,780
averaging we'll talk about what these do

1701
01:26:34,699 --> 01:26:37,779
in a second here

1702
01:26:38,420 --> 01:26:43,340
let's deflate inflate oppression of a

1703
01:26:41,449 --> 01:26:46,340
sliding window with super valid supreme

1704
01:26:43,340 --> 01:26:48,560
blah blah deflate compression lz77

1705
01:26:46,340 --> 01:26:50,119
derivative deflate compress data streams

1706
01:26:48,560 --> 01:26:53,710
within PNG restored in the Zeeland

1707
01:26:50,119 --> 01:26:55,729
format which has the structure this crap

1708
01:26:53,710 --> 01:26:57,260
further details on the form are given as

1709
01:26:55,729 --> 01:26:58,729
you look specification for PNG

1710
01:26:57,260 --> 01:27:05,600
compression method 0 0 the compression

1711
01:26:58,729 --> 01:27:08,149
method flashcard specify method 8 assume

1712
01:27:05,600 --> 01:27:10,010
this is telling you how to set it up if

1713
01:27:08,149 --> 01:27:13,929
you were calling the other piece of code

1714
01:27:10,010 --> 01:27:16,030
I guess whatever

1715
01:27:13,930 --> 01:27:24,850
[Music]

1716
01:27:16,029 --> 01:27:27,439
tu-tu-tu-tu-tu-tu so this is really not

1717
01:27:24,850 --> 01:27:29,719
so I guess we're gonna have to look at

1718
01:27:27,439 --> 01:27:33,619
the Z Lib standard to figure out what

1719
01:27:29,719 --> 01:27:36,680
the actual data stream encoding is is

1720
01:27:33,619 --> 01:27:39,699
that really the case you didn't bother

1721
01:27:36,680 --> 01:27:43,930
to put it in the actual spec that's

1722
01:27:39,699 --> 01:27:43,929
really bad but okay

1723
01:28:09,288 --> 01:28:25,109
would have been nice so where is this

1724
01:28:19,469 --> 01:28:31,109
actually to find let's see data format

1725
01:28:25,109 --> 01:28:32,719
is probably what we want on page four as

1726
01:28:31,109 --> 01:28:41,399
either stream at the following structure

1727
01:28:32,719 --> 01:28:43,979
CMF FL g if FL g f2 said it could press

1728
01:28:41,399 --> 01:28:45,179
data adler 32 any data which may appear

1729
01:28:43,979 --> 01:28:46,708
after the others they're not fuzzy them

1730
01:28:45,179 --> 01:28:50,760
streams see him as compressed method of

1731
01:28:46,708 --> 01:28:53,938
flags pressure max is 0 to 3 the infos 4

1732
01:28:50,760 --> 01:28:55,320
to 7 compression method file CM 8 just

1733
01:28:53,939 --> 01:28:58,800
to deflate compression method for window

1734
01:28:55,319 --> 01:29:01,708
size up to 32 k so i'm guessing that

1735
01:28:58,800 --> 01:29:05,689
that is not stored in the actual PNG

1736
01:29:01,708 --> 01:29:05,688
file it's just assumed that that's there

1737
01:29:11,658 --> 01:29:22,498
seems like it for compression method a

1738
01:29:20,639 --> 01:29:24,090
Chris Jess or the deflate compressor for

1739
01:29:22,498 --> 01:29:25,738
it turn the document to flake for

1740
01:29:24,090 --> 01:29:29,809
service are you kidding me

1741
01:29:25,738 --> 01:29:32,218
so they referenced a file which itself

1742
01:29:29,809 --> 01:29:34,288
references a file that actually has the

1743
01:29:32,219 --> 01:29:36,510
format you could have at least

1744
01:29:34,288 --> 01:29:45,828
referenced the file that actually had

1745
01:29:36,510 --> 01:29:45,829
the format in it fantastic

1746
01:29:52,689 --> 01:30:06,599
see why I said this would be a pain in

1747
01:29:54,250 --> 01:30:06,600
the butt here we go

1748
01:30:06,719 --> 01:30:12,100
all right so overall clinch the diagrams

1749
01:30:10,238 --> 01:30:13,689
little box like this represents one

1750
01:30:12,100 --> 01:30:15,760
buying two box like this it's a variable

1751
01:30:13,689 --> 01:30:17,529
number by its original bit order

1752
01:30:15,760 --> 01:30:19,270
associated you never bite consider

1753
01:30:17,529 --> 01:30:24,250
intermediates or fire bla bla bla bla

1754
01:30:19,270 --> 01:30:27,100
bla bla bla when in the computer okay

1755
01:30:24,250 --> 01:30:28,359
yes that's all good packing the bytes

1756
01:30:27,100 --> 01:30:30,310
the time does not address the issue of

1757
01:30:28,359 --> 01:30:32,019
the order in which bits of a byte are

1758
01:30:30,310 --> 01:30:33,700
transmitted on a bit sequential medium

1759
01:30:32,020 --> 01:30:34,540
since the final data format described

1760
01:30:33,699 --> 01:30:36,760
here is byte

1761
01:30:34,539 --> 01:30:38,439
rather than bit oriented however we

1762
01:30:36,760 --> 01:30:40,270
described the compressed block format in

1763
01:30:38,439 --> 01:30:41,738
below as the sequence of data elements

1764
01:30:40,270 --> 01:30:43,180
of various bit lengths not a sequence of

1765
01:30:41,738 --> 01:30:45,549
bytes we must therefore specify how to

1766
01:30:43,180 --> 01:30:47,200
pack these data elements into bytes to

1767
01:30:45,550 --> 01:30:48,909
form the final compressed byte sequence

1768
01:30:47,199 --> 01:30:50,380
data elements are packed into bytes in

1769
01:30:48,909 --> 01:30:52,238
order of increasing bit number within

1770
01:30:50,380 --> 01:30:53,619
the byte sorry with least significant

1771
01:30:52,238 --> 01:30:55,029
bit of the byte that omits other than

1772
01:30:53,619 --> 01:30:56,649
Huffman codes are packed starting with

1773
01:30:55,029 --> 01:30:58,300
the least significant bit of the data

1774
01:30:56,649 --> 01:31:02,609
element often codes are packed starting

1775
01:30:58,300 --> 01:31:04,750
with the most significant bit okay

1776
01:31:02,609 --> 01:31:06,130
in other words if one were to print out

1777
01:31:04,750 --> 01:31:07,689
the compressed data as a sequence of

1778
01:31:06,130 --> 01:31:09,159
bytes starting with the first byte at

1779
01:31:07,689 --> 01:31:11,529
the right margin and proceeding to the

1780
01:31:09,159 --> 01:31:16,000
left with the most significant bit of

1781
01:31:11,529 --> 01:31:17,529
each byte on the left as usual one would

1782
01:31:16,000 --> 01:31:19,659
be able to parse the result from right

1783
01:31:17,529 --> 01:31:23,829
to left with fixed width elements in the

1784
01:31:19,659 --> 01:31:25,420
correct okay well.alright prefix coding

1785
01:31:23,829 --> 01:31:28,180
orifices symbols with from an a priori

1786
01:31:25,420 --> 01:31:29,920
known alphabet by bit sequences one code

1787
01:31:28,180 --> 01:31:31,600
for each symbol in a manner such that

1788
01:31:29,920 --> 01:31:33,039
different symbols may be represented by

1789
01:31:31,600 --> 01:31:34,600
bit sequences of different lengths but a

1790
01:31:33,039 --> 01:31:35,909
parser can always parse an encoded

1791
01:31:34,600 --> 01:31:38,289
string on a biggest Lee symbol by symbol

1792
01:31:35,909 --> 01:31:40,210
we define a prefix code in terms of

1793
01:31:38,289 --> 01:31:42,430
binary tree in which the two edges

1794
01:31:40,210 --> 01:31:44,560
descending from each non leaf node are

1795
01:31:42,430 --> 01:31:46,600
labeled zero and one in which the leaf

1796
01:31:44,560 --> 01:31:47,980
nodes correspond one for one with are

1797
01:31:46,600 --> 01:31:50,350
labeled with the symbols of the alphabet

1798
01:31:47,979 --> 01:31:52,119
then the code for symbol is the sequence

1799
01:31:50,350 --> 01:31:53,469
of zeros and ones on the edges leading

1800
01:31:52,119 --> 01:31:57,309
from the root to the leaf labeled with

1801
01:31:53,469 --> 01:31:59,260
that symbol for example and here we go

1802
01:31:57,310 --> 01:32:02,020
you can see how they've got the tree set

1803
01:31:59,260 --> 01:32:05,020
up now this is setting us up I guess for

1804
01:32:02,020 --> 01:32:07,270
just straightforward use of Huffman

1805
01:32:05,020 --> 01:32:08,440
coding Huffman encoding of course which

1806
01:32:07,270 --> 01:32:10,930
I don't think we've really talked about

1807
01:32:08,439 --> 01:32:12,939
the stream before but let me just give a

1808
01:32:10,930 --> 01:32:14,469
really quick overview of what this

1809
01:32:12,939 --> 01:32:15,729
actually means it's it's pretty

1810
01:32:14,469 --> 01:32:17,649
straightforward but the implementation

1811
01:32:15,729 --> 01:32:19,899
stuff can get kind of hairy so I don't

1812
01:32:17,649 --> 01:32:23,289
know how crazy it will be in paying

1813
01:32:19,899 --> 01:32:23,289
but here you go

1814
01:32:37,380 --> 01:32:42,269
so this idea is really pretty

1815
01:32:38,819 --> 01:32:45,748
straightforward let me explain how it

1816
01:32:42,269 --> 01:32:49,650
works so normally what we would do when

1817
01:32:45,748 --> 01:32:51,840
we go to encode say a just a simple

1818
01:32:49,649 --> 01:32:54,149
piece of text even right is we have

1819
01:32:51,840 --> 01:32:56,639
something like an ASCII code which is

1820
01:32:54,149 --> 01:32:58,229
just to say that look how many things do

1821
01:32:56,639 --> 01:33:02,069
we need to encode well we need to encode

1822
01:32:58,229 --> 01:33:03,509
like about 128 things right that's

1823
01:33:02,069 --> 01:33:05,368
roughly how many we have to encode for

1824
01:33:03,510 --> 01:33:07,710
ASCII so what we're gonna do is say well

1825
01:33:05,368 --> 01:33:10,018
128 things well that's 2 to the seventh

1826
01:33:07,710 --> 01:33:12,630
power right so what we're gonna do is

1827
01:33:10,019 --> 01:33:16,349
we're going to use 7 bits of information

1828
01:33:12,630 --> 01:33:18,420
and we're just going to give each thing

1829
01:33:16,349 --> 01:33:20,538
that we might want to say each symbol in

1830
01:33:18,420 --> 01:33:23,219
the alphabet if you will ABCD efg

1831
01:33:20,538 --> 01:33:25,800
semicolon return space whatever we're

1832
01:33:23,219 --> 01:33:28,469
gonna give that one combination of 7

1833
01:33:25,800 --> 01:33:29,940
bits that says which one it is so if we

1834
01:33:28,469 --> 01:33:34,609
then look up what the ASCII

1835
01:33:29,939 --> 01:33:34,609
specification says as I spell that wrong

1836
01:33:34,670 --> 01:33:38,639
if we look at what the ASCII

1837
01:33:36,599 --> 01:33:41,460
specification is you can then see here

1838
01:33:38,639 --> 01:33:45,118
is the table that unambiguously assigns

1839
01:33:41,460 --> 01:33:48,809
a 7 bit code to a specific thing so you

1840
01:33:45,118 --> 01:33:51,689
can see 0 2 128 you can see what all of

1841
01:33:48,809 --> 01:33:52,019
it corresponds to and you know off you

1842
01:33:51,689 --> 01:33:53,189
go

1843
01:33:52,019 --> 01:33:55,590
right very very simple and

1844
01:33:53,189 --> 01:33:59,969
straightforward it's great it's fine

1845
01:33:55,590 --> 01:34:02,340
it's wonderful whatever so the problem

1846
01:33:59,969 --> 01:34:05,130
you get into coding stuff like this is

1847
01:34:02,340 --> 01:34:06,420
this not very efficient because well let

1848
01:34:05,130 --> 01:34:11,010
me bring that tree back up again

1849
01:34:06,420 --> 01:34:12,389
actually the chance is if you're

1850
01:34:11,010 --> 01:34:14,429
concluding a piece of text that you

1851
01:34:12,389 --> 01:34:17,159
might want to code say the letter s are

1852
01:34:14,429 --> 01:34:20,940
actually quite high whereas the chances

1853
01:34:17,158 --> 01:34:23,460
that you're going to encode s 0 H start

1854
01:34:20,939 --> 01:34:25,288
or Soh start of heading a code which

1855
01:34:23,460 --> 01:34:27,748
literally no one encodes anymore for any

1856
01:34:25,288 --> 01:34:31,198
reason I can even think of is very very

1857
01:34:27,748 --> 01:34:33,269
low so even though you know that s will

1858
01:34:31,198 --> 01:34:35,638
happen all the time and start of heading

1859
01:34:33,269 --> 01:34:37,619
will happen like never you end up

1860
01:34:35,639 --> 01:34:40,019
spending the same amount of bits to

1861
01:34:37,618 --> 01:34:43,649
write both of them so from a compression

1862
01:34:40,019 --> 01:34:46,199
standpoint we're wasting 7 bits on an S

1863
01:34:43,649 --> 01:34:49,618
right which we'd like to store it much

1864
01:34:46,198 --> 01:34:50,159
more concisely and it's also 7 bits to

1865
01:34:49,618 --> 01:34:51,599
store our

1866
01:34:50,159 --> 01:34:53,279
of header which as far as we're

1867
01:34:51,600 --> 01:34:55,470
concerned could take like 50 bits

1868
01:34:53,279 --> 01:34:58,289
because we're never going to store it so

1869
01:34:55,470 --> 01:35:00,360
in terms of the size of our file storing

1870
01:34:58,289 --> 01:35:02,130
seven bits for both of these is not a

1871
01:35:00,359 --> 01:35:03,689
very good trade-off because this happens

1872
01:35:02,130 --> 01:35:08,810
almost not at all and this happens all

1873
01:35:03,689 --> 01:35:12,089
the time right that's the fundamental

1874
01:35:08,810 --> 01:35:14,850
starting point for compression is to say

1875
01:35:12,090 --> 01:35:17,430
look what am i storing most often and

1876
01:35:14,850 --> 01:35:20,280
let me try to use the fewest possible

1877
01:35:17,430 --> 01:35:22,619
bits to do that because I want to assign

1878
01:35:20,279 --> 01:35:24,659
the fewest possible bits to the things I

1879
01:35:22,619 --> 01:35:26,399
store a lot and then I'll use more bits

1880
01:35:24,659 --> 01:35:28,769
to encode things that I don't store very

1881
01:35:26,399 --> 01:35:30,750
often that's the trade-off right so

1882
01:35:28,770 --> 01:35:32,640
fixed in coatings are really bad at that

1883
01:35:30,750 --> 01:35:36,270
because they assign the same number of

1884
01:35:32,640 --> 01:35:38,490
bits to everything and that just wastes

1885
01:35:36,270 --> 01:35:41,280
space because not everything has an

1886
01:35:38,489 --> 01:35:44,789
equal probability of being specified at

1887
01:35:41,279 --> 01:35:46,439
all times right so a Huffman tree is a

1888
01:35:44,789 --> 01:35:49,019
simple way of starting to attack that

1889
01:35:46,439 --> 01:35:52,739
problem what it says is well look what

1890
01:35:49,020 --> 01:35:54,930
if I made a tree of bits such that you

1891
01:35:52,739 --> 01:35:57,599
didn't always have to use all the bits

1892
01:35:54,930 --> 01:36:01,340
so for example I'll just start with one

1893
01:35:57,600 --> 01:36:05,610
bit and if that bit is zero that's an S

1894
01:36:01,340 --> 01:36:08,069
just period if the bit is one then I

1895
01:36:05,609 --> 01:36:11,429
will actually look at the next bit and

1896
01:36:08,069 --> 01:36:13,829
let's if that's zero maybe it's an E and

1897
01:36:11,430 --> 01:36:16,650
then if it's one i encode other things

1898
01:36:13,829 --> 01:36:18,180
right and then maybe I've got a tree

1899
01:36:16,649 --> 01:36:20,329
that actually branches out a little bit

1900
01:36:18,180 --> 01:36:23,789
here to do the rest of them right and

1901
01:36:20,329 --> 01:36:25,949
what you can see from that is it ends up

1902
01:36:23,789 --> 01:36:28,710
allowing you to say if you just read a

1903
01:36:25,949 --> 01:36:33,210
bit at a time instead of multiple bits

1904
01:36:28,710 --> 01:36:36,149
at a time and start deciding whether or

1905
01:36:33,210 --> 01:36:39,989
not to output a particular symbol from

1906
01:36:36,149 --> 01:36:43,500
only reading a few bits that allows you

1907
01:36:39,989 --> 01:36:47,219
to use say two or three bits or even one

1908
01:36:43,500 --> 01:36:49,409
bit to represent some of the things in

1909
01:36:47,220 --> 01:36:52,949
your stream that happened a lot and then

1910
01:36:49,409 --> 01:36:56,430
you'll use a lot more bits to talk about

1911
01:36:52,949 --> 01:36:57,720
things that happen rarely right so

1912
01:36:56,430 --> 01:37:00,829
that's what we're starting to get into

1913
01:36:57,720 --> 01:37:05,070
here when you can see in

1914
01:37:00,829 --> 01:37:07,140
are we there here we go so in the

1915
01:37:05,069 --> 01:37:09,210
deflate you can see them making exactly

1916
01:37:07,140 --> 01:37:11,070
such a tree you can see that they've

1917
01:37:09,210 --> 01:37:12,750
said well okay if you see a zero let's

1918
01:37:11,069 --> 01:37:15,119
keep reading if you see a one that's

1919
01:37:12,750 --> 01:37:16,619
just going to be the symbol B right if

1920
01:37:15,119 --> 01:37:18,840
you see a zero then it'll be the symbol

1921
01:37:16,619 --> 01:37:20,279
a if you see a one after that we'll keep

1922
01:37:18,840 --> 01:37:22,739
going and then a zero and that's a D or

1923
01:37:20,279 --> 01:37:25,769
one it's a C right and so then you can

1924
01:37:22,739 --> 01:37:28,409
see here the code lengths for each of

1925
01:37:25,770 --> 01:37:31,140
these differ dramatically a B costs only

1926
01:37:28,409 --> 01:37:33,720
one bit to output and a cost to bits and

1927
01:37:31,140 --> 01:37:35,250
C's and DS both cost three dates three

1928
01:37:33,720 --> 01:37:37,140
bits so what you can see there is

1929
01:37:35,250 --> 01:37:39,630
they've taken something which used to

1930
01:37:37,140 --> 01:37:41,910
cost because it had four symbols it used

1931
01:37:39,630 --> 01:37:44,039
to cost two bits for every symbol and

1932
01:37:41,909 --> 01:37:46,260
what they've done is skewed it so that

1933
01:37:44,039 --> 01:37:46,649
now it takes three bits toutput c's and

1934
01:37:46,260 --> 01:37:49,289
d's

1935
01:37:46,649 --> 01:37:51,809
but only one bit output a b and only two

1936
01:37:49,289 --> 01:37:53,519
bits that put an egg right so it's again

1937
01:37:51,810 --> 01:38:04,410
it's just shifting how you allocate the

1938
01:37:53,520 --> 01:38:05,940
bits okay so what you can see here is

1939
01:38:04,409 --> 01:38:07,050
it's saying given an alphabet with known

1940
01:38:05,939 --> 01:38:08,339
similar frequencies the Huffman

1941
01:38:07,050 --> 01:38:10,289
algorithm allows the construction of an

1942
01:38:08,340 --> 01:38:12,569
optimal prefix code one which represents

1943
01:38:10,289 --> 01:38:13,920
strings with those symbol frequencies

1944
01:38:12,569 --> 01:38:15,389
using the fewest bits of any polish

1945
01:38:13,920 --> 01:38:17,159
previous codes for that alphabet such a

1946
01:38:15,390 --> 01:38:19,740
code is called a Huffman code and so on

1947
01:38:17,159 --> 01:38:21,349
now that's not actually true I think

1948
01:38:19,739 --> 01:38:24,420
that's actually stated a little bit

1949
01:38:21,350 --> 01:38:27,150
incorrectly there so Huffman coding

1950
01:38:24,420 --> 01:38:29,670
doesn't actually produce the optimal

1951
01:38:27,149 --> 01:38:31,849
prefix codes the reason for that is that

1952
01:38:29,670 --> 01:38:34,619
it requires an integral number of bits

1953
01:38:31,850 --> 01:38:36,329
it is optimal for integral numbers of

1954
01:38:34,619 --> 01:38:38,189
bits if I remember correctly but

1955
01:38:36,329 --> 01:38:39,569
arithmetic encoding or other coatings

1956
01:38:38,189 --> 01:38:41,759
that are similar to arithmetic encodings

1957
01:38:39,569 --> 01:38:44,460
allow you to use fractional number of

1958
01:38:41,760 --> 01:38:46,710
bits and that's important because what

1959
01:38:44,460 --> 01:38:48,840
you can sort of infer from what we

1960
01:38:46,710 --> 01:38:51,779
talked about before is based on the

1961
01:38:48,840 --> 01:38:53,940
frequencies that symbols occur you want

1962
01:38:51,779 --> 01:38:55,949
to assign the number of bits exactly

1963
01:38:53,939 --> 01:38:57,869
proportional to those frequencies well

1964
01:38:55,949 --> 01:38:59,939
the frequencies are probably not going

1965
01:38:57,869 --> 01:39:03,239
to be exactly integer it's not likely

1966
01:38:59,939 --> 01:39:06,059
that a occurs exactly twice as likely as

1967
01:39:03,239 --> 01:39:08,849
B right a probably occurs in the bit

1968
01:39:06,060 --> 01:39:11,940
stream maybe 1.7 times more likely than

1969
01:39:08,850 --> 01:39:12,660
B in which case we'd like to have a take

1970
01:39:11,939 --> 01:39:16,289
one

1971
01:39:12,659 --> 01:39:18,510
seven times more bits than B not twice

1972
01:39:16,289 --> 01:39:20,310
as many bits as B and that's where

1973
01:39:18,510 --> 01:39:22,650
Huffman falls apart because Huffman can

1974
01:39:20,310 --> 01:39:24,710
only do integer numbers of bits because

1975
01:39:22,649 --> 01:39:27,779
as you can see it's a tree shape

1976
01:39:24,710 --> 01:39:30,420
arithmetic and other coatings like RNAs

1977
01:39:27,779 --> 01:39:33,449
or things like that or just ans in

1978
01:39:30,420 --> 01:39:35,489
general those are about assigning

1979
01:39:33,449 --> 01:39:37,260
fractional numbers of bits and they're

1980
01:39:35,489 --> 01:39:39,989
more advanced codecs they're better

1981
01:39:37,260 --> 01:39:41,579
right but if you just want something

1982
01:39:39,989 --> 01:39:43,229
that's more straightforward and it's

1983
01:39:41,579 --> 01:39:46,829
you're okay working with integral

1984
01:39:43,229 --> 01:39:51,299
numbers of bits then Huffman's puffins

1985
01:39:46,829 --> 01:39:53,010
you're your jam right okay

1986
01:39:51,300 --> 01:39:54,390
so let's see how they use it here

1987
01:39:53,010 --> 01:39:55,980
because you know Huffman can be

1988
01:39:54,390 --> 01:39:57,720
implemented all sorts of different ways

1989
01:39:55,979 --> 01:39:59,069
usually the Huffman coding is a format

1990
01:39:57,720 --> 01:40:00,329
the Huffman codes used for each alphabet

1991
01:39:59,069 --> 01:40:03,239
the deflate form have two additional

1992
01:40:00,329 --> 01:40:04,829
rules all codes of a given bit length

1993
01:40:03,239 --> 01:40:07,409
have lexicographically consecutive

1994
01:40:04,829 --> 01:40:17,659
values in the same order as the symbols

1995
01:40:07,409 --> 01:40:17,659
they represent so I think that

1996
01:40:28,050 --> 01:40:33,539
I don't understand the use of

1997
01:40:30,559 --> 01:40:35,309
lexicographically in that sentence to be

1998
01:40:33,539 --> 01:40:36,719
honest with you so I'm gonna have to

1999
01:40:35,309 --> 01:40:38,809
keep reading I'm not a compression

2000
01:40:36,719 --> 01:40:42,328
person so it could be that that use of

2001
01:40:38,809 --> 01:40:44,190
lexicographically is very common but

2002
01:40:42,328 --> 01:40:46,828
it's just I don't really do much

2003
01:40:44,189 --> 01:40:49,259
compression stuff so I'm gonna have to

2004
01:40:46,828 --> 01:40:50,969
take a mulligan on that one and keep

2005
01:40:49,260 --> 01:40:53,190
going we can be cured the example above

2006
01:40:50,969 --> 01:40:55,230
to follow this rule as follows assuming

2007
01:40:53,189 --> 01:41:08,488
that the order of the alphabet is ABCD

2008
01:40:55,229 --> 01:41:13,529
we get ABCD so it looks like what they

2009
01:41:08,488 --> 01:41:16,500
mean is that the code as interpreted

2010
01:41:13,529 --> 01:41:28,889
from left to right will always the

2011
01:41:16,500 --> 01:41:32,599
higher code goes first I guess I mean

2012
01:41:28,889 --> 01:41:32,599
I'm not sure how else to interpret that

2013
01:41:37,869 --> 01:41:44,420
because you can see here that they were

2014
01:41:40,100 --> 01:41:47,560
just like oh yeah well you know C and D

2015
01:41:44,420 --> 01:42:00,859
I had 0 1 1 and 0 1 0 before

2016
01:41:47,560 --> 01:42:01,820
that's becomes 1 1 0 and I mean well ok

2017
01:42:00,859 --> 01:42:03,559
so they did two things

2018
01:42:01,819 --> 01:42:07,789
first of all they inverted the tree

2019
01:42:03,560 --> 01:42:14,750
right so they they're actually doing the

2020
01:42:07,789 --> 01:42:18,909
tree slightly differently they're 0

2021
01:42:14,750 --> 01:42:18,909
precedes 10 which precedes 11x

2022
01:42:30,409 --> 01:42:34,769
in our example the code is completely

2023
01:42:33,000 --> 01:42:39,029
defined by the sequence of bit lengths 2

2024
01:42:34,770 --> 01:42:40,410
1 3 3 the following algorithm generates

2025
01:42:39,029 --> 01:42:42,059
the codes it's introduced intend to be

2026
01:42:40,409 --> 01:42:43,380
read from most less food cooks are

2027
01:42:42,060 --> 01:42:50,480
initially in treat Outland the codes

2028
01:42:43,380 --> 01:42:50,480
produced in tree i dot code interesting

2029
01:43:07,390 --> 01:43:11,560
so I get what they're doing here I'm

2030
01:43:09,699 --> 01:43:14,649
still just not sure I totally into it

2031
01:43:11,560 --> 01:43:16,150
exactly what they meant by that so what

2032
01:43:14,649 --> 01:43:18,309
they're doing in a high level though is

2033
01:43:16,149 --> 01:43:21,219
quite clear they made that quite clear

2034
01:43:18,310 --> 01:43:23,950
what they want to do is make it easy for

2035
01:43:21,220 --> 01:43:26,850
them to announce the format of the

2036
01:43:23,949 --> 01:43:28,599
Huffman tree that's going to be used and

2037
01:43:26,850 --> 01:43:29,920
obviously one of the things that you

2038
01:43:28,600 --> 01:43:31,690
want to do if you're doing compressed

2039
01:43:29,920 --> 01:43:34,000
file format is you don't want to spend a

2040
01:43:31,689 --> 01:43:36,009
lot of extra space describing the thing

2041
01:43:34,000 --> 01:43:37,750
that you're using for a compression so

2042
01:43:36,010 --> 01:43:39,730
if they have to give us information

2043
01:43:37,750 --> 01:43:40,989
about this Huffman table which of course

2044
01:43:39,729 --> 01:43:43,929
they are sorry I should say trait

2045
01:43:40,989 --> 01:43:46,000
Huffman tree that we are going to be

2046
01:43:43,930 --> 01:43:48,190
using to decode the thing they need to

2047
01:43:46,000 --> 01:43:49,779
specify it in a way that doesn't take

2048
01:43:48,189 --> 01:43:51,519
more space than necessary otherwise

2049
01:43:49,779 --> 01:43:54,099
they're wasting space in what's supposed

2050
01:43:51,520 --> 01:43:55,690
to be compressed file announcing things

2051
01:43:54,100 --> 01:43:57,430
about how they're compressing it so what

2052
01:43:55,689 --> 01:43:59,589
they wanted to do was say look let's

2053
01:43:57,430 --> 01:44:01,900
take all of the ambiguity that doesn't

2054
01:43:59,590 --> 01:44:04,150
matter out of this table and just say

2055
01:44:01,899 --> 01:44:05,679
here are the rules for how we will

2056
01:44:04,149 --> 01:44:08,109
specify Huffman code so we can give you

2057
01:44:05,680 --> 01:44:11,170
the least possible amount of information

2058
01:44:08,109 --> 01:44:12,369
so what they want to do is transform you

2059
01:44:11,170 --> 01:44:14,409
know I mean you could imagine a really

2060
01:44:12,369 --> 01:44:16,479
piggy way of describing this table of

2061
01:44:14,409 --> 01:44:17,920
actually sending down the tree with like

2062
01:44:16,479 --> 01:44:19,899
nodes and which nodes point to other

2063
01:44:17,920 --> 01:44:22,060
nodes right we could actually send down

2064
01:44:19,899 --> 01:44:23,739
a whole tree descriptor obviously that

2065
01:44:22,060 --> 01:44:24,910
weights a ton of space so what they're

2066
01:44:23,739 --> 01:44:26,500
gonna do instead is they're gonna say

2067
01:44:24,909 --> 01:44:28,869
look I'm just gonna tell you what the

2068
01:44:26,500 --> 01:44:30,850
bit lengths are and then we'll just have

2069
01:44:28,869 --> 01:44:33,039
a rule that says when you're assigning

2070
01:44:30,850 --> 01:44:35,110
bit lengths you do it exactly like this

2071
01:44:33,039 --> 01:44:37,800
so if I say that you've got a 1 bit

2072
01:44:35,109 --> 01:44:40,389
field here here's what that means right

2073
01:44:37,800 --> 01:44:43,420
so they've sucked all of the ambiguity

2074
01:44:40,390 --> 01:44:45,310
out by saying look we don't care how

2075
01:44:43,420 --> 01:44:47,800
these bit streams are necessarily

2076
01:44:45,310 --> 01:44:49,810
allocated right we just know they have

2077
01:44:47,800 --> 01:44:52,090
to be these lengths so if we just come

2078
01:44:49,810 --> 01:44:54,160
up with rules that go directly from the

2079
01:44:52,090 --> 01:44:57,159
bit length to what the bit field should

2080
01:44:54,159 --> 01:44:59,619
be then all we need to do is transmit

2081
01:44:57,159 --> 01:45:01,659
the lengths not anything else about the

2082
01:44:59,619 --> 01:45:03,069
table and you can fill it in the rest of

2083
01:45:01,659 --> 01:45:05,409
it yourself right so that's just same

2084
01:45:03,069 --> 01:45:09,880
space and that's just what they're

2085
01:45:05,409 --> 01:45:11,019
trying to do there right so that all

2086
01:45:09,880 --> 01:45:12,909
makes sense that's we'll come back to

2087
01:45:11,020 --> 01:45:15,580
that in a second ok so that's a B C F

2088
01:45:12,909 --> 01:45:17,649
with bit links 3 3 3 3 3 2 3 2 4 4

2089
01:45:15,579 --> 01:45:19,149
this expands it out so we've got that

2090
01:45:17,649 --> 01:45:20,619
step which I don't quite totally

2091
01:45:19,149 --> 01:45:21,219
understand yet but we'll go back to

2092
01:45:20,619 --> 01:45:23,019
later

2093
01:45:21,220 --> 01:45:24,909
it's basically saying this piece of

2094
01:45:23,020 --> 01:45:26,380
information came in from the stream we

2095
01:45:24,909 --> 01:45:28,869
need to go from that piece of

2096
01:45:26,380 --> 01:45:30,520
information to this symbol table which

2097
01:45:28,869 --> 01:45:33,189
says what the code is for each of these

2098
01:45:30,520 --> 01:45:34,810
things right and then we go through here

2099
01:45:33,189 --> 01:45:36,460
and talk about how that's actually gonna

2100
01:45:34,810 --> 01:45:37,570
come about so let's move forward and

2101
01:45:36,460 --> 01:45:44,380
we'll go back to that later

2102
01:45:37,569 --> 01:45:47,139
okay so each block of compressed data

2103
01:45:44,380 --> 01:45:49,930
begins with three header bits the first

2104
01:45:47,140 --> 01:45:53,260
bit says be final the next two bits say

2105
01:45:49,930 --> 01:45:54,789
b-type be final is set if it's the last

2106
01:45:53,260 --> 01:45:57,699
block so that's how we know that we're

2107
01:45:54,789 --> 01:45:59,979
done I guess and b-type says either it's

2108
01:45:57,699 --> 01:46:02,109
uncompressed it's compressed with fixed

2109
01:45:59,979 --> 01:46:03,549
Huffman codes compressed with dynamic

2110
01:46:02,109 --> 01:46:07,779
Huffman codes dynamic Huffman codes

2111
01:46:03,550 --> 01:46:10,840
means they change as you go and 11 is

2112
01:46:07,779 --> 01:46:12,279
like we don't use it yet right so then

2113
01:46:10,840 --> 01:46:13,480
we go alright the only difference

2114
01:46:12,279 --> 01:46:16,899
between compressed cases is how the

2115
01:46:13,479 --> 01:46:19,209
Huffman codes are defined in all cases

2116
01:46:16,899 --> 01:46:21,819
that a coding looks like this read the

2117
01:46:19,210 --> 01:46:24,909
header if it's no compression we just

2118
01:46:21,819 --> 01:46:27,489
grab everything we need otherwise if

2119
01:46:24,909 --> 01:46:29,439
it's dynamic Huffman codes we read the

2120
01:46:27,489 --> 01:46:33,880
representation of the code trees and

2121
01:46:29,439 --> 01:46:36,039
then we loop until the end wheel to code

2122
01:46:33,880 --> 01:46:39,279
literal if the files which we copy the

2123
01:46:36,039 --> 01:46:43,300
value otherwise we get out of the loop

2124
01:46:39,279 --> 01:46:44,319
and we use a lookup this is an lz77 loop

2125
01:46:43,300 --> 01:46:47,289
here we'll talk about that doesn't a

2126
01:46:44,319 --> 01:46:49,149
second move backwards copy the length

2127
01:46:47,289 --> 01:46:50,590
from a blob the duplicate string

2128
01:46:49,149 --> 01:46:52,719
reference may refer to a string in a

2129
01:46:50,590 --> 01:46:54,190
previous block docker just may cross one

2130
01:46:52,720 --> 01:46:55,360
of our block boundaries every distance

2131
01:46:54,189 --> 01:46:59,229
cannot refer past the beginning of the

2132
01:46:55,359 --> 01:47:01,269
app extreme that's all fine we'll talk

2133
01:46:59,229 --> 01:47:02,559
about all of that in a second preset

2134
01:47:01,270 --> 01:47:04,210
dictionary might discard part of the

2135
01:47:02,560 --> 01:47:06,970
output stream a distance can refer to

2136
01:47:04,210 --> 01:47:11,079
that part of that machine anyway yeah

2137
01:47:06,970 --> 01:47:13,360
this this is all fine so now I'm

2138
01:47:11,079 --> 01:47:15,010
compressed blocks are just a chunk of

2139
01:47:13,359 --> 01:47:19,269
data that's gonna be trivial right

2140
01:47:15,010 --> 01:47:22,260
compressed blocks are basically an lz77

2141
01:47:19,270 --> 01:47:25,250
thing which we'll talk about in a second

2142
01:47:22,260 --> 01:47:27,280
let's see here

2143
01:47:25,250 --> 01:47:29,510
compression with fixed Huffman codes

2144
01:47:27,279 --> 01:47:30,859
chests are fixed and are not presenting

2145
01:47:29,510 --> 01:47:34,150
to us today therefore code thanks to

2146
01:47:30,859 --> 01:47:34,149
literal are Oh

2147
01:47:35,770 --> 01:47:41,210
the Hoffman codes to do us are fixed and

2148
01:47:38,899 --> 01:47:42,319
are not represented explicitly in the

2149
01:47:41,210 --> 01:47:46,480
data the Huffman code thank she's a

2150
01:47:42,319 --> 01:47:46,479
little length alphabet are

2151
01:48:02,198 --> 01:48:07,429
interesting are they saying that it's

2152
01:48:04,430 --> 01:48:09,260
actually a thing that you just use

2153
01:48:07,430 --> 01:48:11,060
that's not even stored in the stream I

2154
01:48:09,260 --> 01:48:12,680
assumed fixed meant it would put it in

2155
01:48:11,060 --> 01:48:22,100
the stream maybe that's not what they

2156
01:48:12,680 --> 01:48:24,440
mean we'll look at that in a second

2157
01:48:22,100 --> 01:48:25,670
with dynamic Huffman codes shows for in

2158
01:48:24,439 --> 01:48:27,589
the blood the huffing codes the two

2159
01:48:25,670 --> 01:48:29,300
alphabets appear in the block

2160
01:48:27,590 --> 01:48:31,940
immediately after the header bits and

2161
01:48:29,300 --> 01:48:40,820
before they okay so this is not these

2162
01:48:31,939 --> 01:48:44,859
are not what I thought they were very

2163
01:48:40,819 --> 01:48:48,229
interesting so what I assumed when I saw

2164
01:48:44,859 --> 01:48:50,539
fixed and dynamic Huffman codes what I

2165
01:48:48,229 --> 01:48:53,599
thought they were talking about was that

2166
01:48:50,539 --> 01:48:55,488
fixed Huffman codes would be ones where

2167
01:48:53,600 --> 01:48:56,810
it just put the Huffman codes directly

2168
01:48:55,488 --> 01:48:59,629
in the stream you read them and then

2169
01:48:56,810 --> 01:49:03,140
used them and that dynamic Huffman codes

2170
01:48:59,630 --> 01:49:08,029
were ones where as you saw symbols you

2171
01:49:03,140 --> 01:49:10,070
updated the Huffman tree yourself that's

2172
01:49:08,029 --> 01:49:13,159
like an adaptive it's called adaptive

2173
01:49:10,069 --> 01:49:14,448
Huffman usually I believe that's not

2174
01:49:13,159 --> 01:49:16,130
apparently what they're talking about

2175
01:49:14,448 --> 01:49:17,960
they're actually talking about a fixed

2176
01:49:16,130 --> 01:49:20,119
Huffman code is one that's just pre

2177
01:49:17,960 --> 01:49:21,920
stored like I guess it's just in the

2178
01:49:20,119 --> 01:49:25,609
compressor and it's just saying use this

2179
01:49:21,920 --> 01:49:27,380
known set and it maybe that's like just

2180
01:49:25,609 --> 01:49:30,019
because they find a lot of data has this

2181
01:49:27,380 --> 01:49:31,789
pattern so they just I guess so it

2182
01:49:30,020 --> 01:49:34,460
sounds like it's saying here don't quote

2183
01:49:31,789 --> 01:49:36,079
me on that yet and that dynamic Huffman

2184
01:49:34,460 --> 01:49:37,399
codes are actually what I was thinking

2185
01:49:36,079 --> 01:49:38,779
of as fixed up in codes meaning it

2186
01:49:37,399 --> 01:49:40,909
actually just stores the Huffman codes

2187
01:49:38,779 --> 01:49:42,289
in there it doesn't look like adaptive

2188
01:49:40,909 --> 01:49:45,079
Huffman makes an appearance

2189
01:49:42,289 --> 01:49:47,810
it looks like adaptive Huffman is not on

2190
01:49:45,079 --> 01:49:48,890
the table which is nice it makes it

2191
01:49:47,810 --> 01:49:50,780
easier for us if that's really true

2192
01:49:48,890 --> 01:49:55,550
maybe I'm mistaken about that we'll see

2193
01:49:50,779 --> 01:50:00,369
as we go a little little further on all

2194
01:49:55,550 --> 01:50:06,920
right so moving along here let's see I

2195
01:50:00,369 --> 01:50:08,180
think that's it so this is the this is

2196
01:50:06,920 --> 01:50:10,489
what we're gonna have to start parsing

2197
01:50:08,180 --> 01:50:11,929
out of the IDE at again this is where

2198
01:50:10,488 --> 01:50:14,750
all of our work is gonna be like I said

2199
01:50:11,929 --> 01:50:16,940
you can see it's pretty complicated as

2200
01:50:14,750 --> 01:50:18,710
formats go it's not that complicated so

2201
01:50:16,939 --> 01:50:20,119
at least that's good it's not a jpeg or

2202
01:50:18,710 --> 01:50:21,980
something like that where we're gonna be

2203
01:50:20,119 --> 01:50:23,359
into like IDC T's and a bunch of stuff

2204
01:50:21,979 --> 01:50:25,189
that we really don't want to be spending

2205
01:50:23,359 --> 01:50:27,439
time doing so it's not that bad but it

2206
01:50:25,189 --> 01:50:28,699
is finicky and so it's gonna take us a

2207
01:50:27,439 --> 01:50:30,409
while to get this going thankfully

2208
01:50:28,699 --> 01:50:32,420
they've given us the outline of how they

2209
01:50:30,409 --> 01:50:33,889
believe the compression code generally

2210
01:50:32,420 --> 01:50:37,250
works so we can work from this

2211
01:50:33,890 --> 01:50:39,110
pseudocode and sort of start to get into

2212
01:50:37,250 --> 01:50:43,430
something that we're that we'll be able

2213
01:50:39,109 --> 01:50:45,589
to use right so let's get just the very

2214
01:50:43,430 --> 01:50:47,030
basics out we've only got about ten

2215
01:50:45,590 --> 01:50:49,340
minutes left so I'm not going to try to

2216
01:50:47,029 --> 01:50:52,219
do anything fancy here tomorrow we'll

2217
01:50:49,340 --> 01:50:54,380
start on the eye that's in in more in

2218
01:50:52,220 --> 01:50:56,630
earnest and so what I want to do here is

2219
01:50:54,380 --> 01:51:00,920
just say all right we know that we need

2220
01:50:56,630 --> 01:51:04,460
to create some room for this data to be

2221
01:51:00,920 --> 01:51:07,789
sort of decompressed and so what I want

2222
01:51:04,460 --> 01:51:09,829
to do is create sort of a buffer here

2223
01:51:07,789 --> 01:51:13,189
that's the resulting image so this is

2224
01:51:09,829 --> 01:51:16,670
the decompressed pixels here that's

2225
01:51:13,189 --> 01:51:18,500
going to start out being 0 then what I

2226
01:51:16,670 --> 01:51:21,590
want to do is if this is a supported

2227
01:51:18,500 --> 01:51:26,449
bitmap here then I want to go ahead and

2228
01:51:21,590 --> 01:51:30,860
allocate the the data for it in here

2229
01:51:26,449 --> 01:51:35,179
right so what I want to do is I want to

2230
01:51:30,859 --> 01:51:36,829
allocate the pixels here I want to use

2231
01:51:35,180 --> 01:51:39,530
the width and height as we talked about

2232
01:51:36,829 --> 01:51:44,750
so I know that it's going to be the eye

2233
01:51:39,529 --> 01:51:48,800
header width by the eye header height

2234
01:51:44,750 --> 01:51:51,260
and I know that we've got 4 bytes per

2235
01:51:48,800 --> 01:51:53,989
pixel so I'm going to go ahead here and

2236
01:51:51,260 --> 01:51:55,100
just stub this in because again this

2237
01:51:53,989 --> 01:51:58,189
will be something that we only care

2238
01:51:55,100 --> 01:52:02,020
about a little bit later on when we go

2239
01:51:58,189 --> 01:52:02,019
to merge this code into handmade hero

2240
01:52:03,760 --> 01:52:07,550
we'll want to allocate this from like a

2241
01:52:06,319 --> 01:52:11,359
data store that we actually know about

2242
01:52:07,550 --> 01:52:14,840
right so here's the result we got our

2243
01:52:11,359 --> 01:52:17,359
width height and our bits per pixel so

2244
01:52:14,840 --> 01:52:22,010
what we want to do is malloc exactly

2245
01:52:17,359 --> 01:52:23,239
that amount and return that so here

2246
01:52:22,010 --> 01:52:24,829
we're going to get the width times the

2247
01:52:23,239 --> 01:52:26,479
height times the byte per pixels which

2248
01:52:24,829 --> 01:52:28,069
should give us enough room to decompress

2249
01:52:26,479 --> 01:52:29,869
the thing that we wanted

2250
01:52:28,069 --> 01:52:34,670
so we're gonna take the decompressed

2251
01:52:29,869 --> 01:52:37,519
pixels here allocate those and then when

2252
01:52:34,670 --> 01:52:40,659
we get into this I dot chunk what I want

2253
01:52:37,520 --> 01:52:43,790
to do here is I think the i dot chunks

2254
01:52:40,659 --> 01:52:45,409
it's the thing that's a little bit

2255
01:52:43,789 --> 01:52:48,590
confusing about them is I don't know how

2256
01:52:45,409 --> 01:52:49,789
ident chunks writing works so what they

2257
01:52:48,590 --> 01:52:51,980
said is there there can be multiple

2258
01:52:49,789 --> 01:52:53,539
idaite sumps in the file I don't know

2259
01:52:51,979 --> 01:52:55,639
why there's multiple itit jumps in the

2260
01:52:53,539 --> 01:52:56,750
file maybe there's a good reason for

2261
01:52:55,640 --> 01:52:58,520
that we'll see maybe you could specify

2262
01:52:56,750 --> 01:52:59,600
different compression information for

2263
01:52:58,520 --> 01:53:01,490
each one of them or something like that

2264
01:52:59,600 --> 01:53:02,600
so I don't know why there's never an eye

2265
01:53:01,489 --> 01:53:04,760
on the file so there's just one eye that

2266
01:53:02,600 --> 01:53:05,600
trunk that's all the data in it maybe

2267
01:53:04,760 --> 01:53:06,920
we'll find out later

2268
01:53:05,600 --> 01:53:09,110
maybe there's no good reason I don't

2269
01:53:06,920 --> 01:53:10,399
know but what it does mean is I don't

2270
01:53:09,109 --> 01:53:14,719
know if we're gonna encounter a

2271
01:53:10,399 --> 01:53:16,519
situation such as oh yeah I put a bunch

2272
01:53:14,720 --> 01:53:18,199
of deflate data in here and then the

2273
01:53:16,520 --> 01:53:21,500
deflate data would have needed to read

2274
01:53:18,199 --> 01:53:23,960
more information from the I dot but it

2275
01:53:21,500 --> 01:53:26,119
ends and then the information that the

2276
01:53:23,960 --> 01:53:29,750
deflator needed is in like the next item

2277
01:53:26,119 --> 01:53:31,130
right so if that ends up being the case

2278
01:53:29,750 --> 01:53:34,550
then what we may want to do eventually

2279
01:53:31,130 --> 01:53:36,500
is take these i dot chunks and make

2280
01:53:34,550 --> 01:53:38,060
something that virtualizes across them

2281
01:53:36,500 --> 01:53:40,939
so that when we go to get information

2282
01:53:38,060 --> 01:53:42,860
out it can pull from the idaite trunk

2283
01:53:40,939 --> 01:53:44,479
seamlessly I don't know which over those

2284
01:53:42,859 --> 01:53:45,979
gonna be true so I won't go ahead and do

2285
01:53:44,479 --> 01:53:47,569
that yet because it'd just be

2286
01:53:45,979 --> 01:53:49,250
unnecessary complexity if it turns out

2287
01:53:47,569 --> 01:53:50,509
not to the case but that's something you

2288
01:53:49,250 --> 01:53:51,829
have to be aware of because that could

2289
01:53:50,510 --> 01:53:54,650
be what they're setting us up for here

2290
01:53:51,829 --> 01:53:57,439
just for maximal annoyance I don't know

2291
01:53:54,649 --> 01:53:59,659
yet though so what I want to do first is

2292
01:53:57,439 --> 01:54:03,559
I just want to say like okay we need to

2293
01:53:59,659 --> 01:54:05,059
decompress pixels thing and it's

2294
01:54:03,560 --> 01:54:06,850
supported so I'm gonna say supported is

2295
01:54:05,060 --> 01:54:08,840
the trigger that lets us know that

2296
01:54:06,850 --> 01:54:10,730
decompressed pixels is dr. gonna have

2297
01:54:08,840 --> 01:54:12,860
something in it so let's start looking

2298
01:54:10,729 --> 01:54:15,019
at the Ida chunk to see if we can just

2299
01:54:12,859 --> 01:54:17,630
get the basic stuff out first and then

2300
01:54:15,020 --> 01:54:20,480
we'll come back to the deflation part a

2301
01:54:17,630 --> 01:54:22,970
little bit later on so looking backwards

2302
01:54:20,479 --> 01:54:25,579
here at the compression format stuff

2303
01:54:22,970 --> 01:54:26,810
what I want to do is start to look at

2304
01:54:25,579 --> 01:54:29,059
what's going to be in here

2305
01:54:26,810 --> 01:54:30,890
again we don't really know exactly

2306
01:54:29,060 --> 01:54:34,490
what's going to be in the IDA chunk

2307
01:54:30,890 --> 01:54:36,050
because it's it was kind of a a so we're

2308
01:54:34,489 --> 01:54:38,359
looking for it was it was a very poor

2309
01:54:36,050 --> 01:54:39,650
explanation right it just kind of waved

2310
01:54:38,359 --> 01:54:41,729
its hands around and said I don't know

2311
01:54:39,649 --> 01:54:42,988
there's some stuff in it right

2312
01:54:41,729 --> 01:54:45,029
so we look at an image chunk it just

2313
01:54:42,988 --> 01:54:46,409
says here's the decimal values for the

2314
01:54:45,029 --> 01:54:48,599
thing that's that's just the thing says

2315
01:54:46,409 --> 01:54:50,460
I'd app and then it contains the image

2316
01:54:48,600 --> 01:54:54,780
data and it says nothing else about it

2317
01:54:50,460 --> 01:54:56,520
right nothing else about it so what we

2318
01:54:54,779 --> 01:54:59,130
want to do is look at these two to see

2319
01:54:56,520 --> 01:55:00,060
what it actually says and that's what

2320
01:54:59,130 --> 01:55:02,310
we're gonna have to try

2321
01:55:00,060 --> 01:55:03,900
so filtering transforms the PNG image

2322
01:55:02,310 --> 01:55:05,340
with the goal of putting compression PNG

2323
01:55:03,899 --> 01:55:07,799
last number of filter methods and all

2324
01:55:05,340 --> 01:55:11,779
the bah-bah-bah right what these are

2325
01:55:07,800 --> 01:55:14,190
going to be I'm almost certain is

2326
01:55:11,779 --> 01:55:17,250
filtering is going to be something that

2327
01:55:14,189 --> 01:55:22,259
tells us how the pixels relate to each

2328
01:55:17,250 --> 01:55:24,840
other and so what you often times will

2329
01:55:22,260 --> 01:55:26,070
do if you have an image right you know

2330
01:55:24,840 --> 01:55:28,470
that you're gonna be feeding it through

2331
01:55:26,069 --> 01:55:30,599
a certain compression algorithm at the

2332
01:55:28,470 --> 01:55:32,310
end right and that compression algorithm

2333
01:55:30,600 --> 01:55:34,860
was gonna do things like take chunks of

2334
01:55:32,310 --> 01:55:36,810
repeating data and compress them down to

2335
01:55:34,859 --> 01:55:38,369
smaller amounts right so if you see the

2336
01:55:36,810 --> 01:55:40,350
same pattern over and over again whether

2337
01:55:38,369 --> 01:55:42,659
that's a big run of zeros or a bunch of

2338
01:55:40,350 --> 01:55:45,329
you know repeating little pieces that

2339
01:55:42,659 --> 01:55:46,800
all like happen again that's the sort of

2340
01:55:45,329 --> 01:55:48,090
stuff that will start to suck up in the

2341
01:55:46,800 --> 01:55:50,940
deflate algorithm which we'll talk about

2342
01:55:48,090 --> 01:55:52,470
a little bit later so typically what you

2343
01:55:50,939 --> 01:55:55,379
want to do with an image beforehand and

2344
01:55:52,470 --> 01:56:00,390
PNG does a spectacularly bad job of this

2345
01:55:55,380 --> 01:56:04,050
their filters are awful but better

2346
01:56:00,390 --> 01:56:07,320
filters are not awful what you do is you

2347
01:56:04,050 --> 01:56:08,789
say well look but instead of just taking

2348
01:56:07,319 --> 01:56:10,679
all these pixels and feeding them

2349
01:56:08,789 --> 01:56:13,590
directly to the thing what I should do

2350
01:56:10,680 --> 01:56:16,530
is have some transform on the pixels

2351
01:56:13,590 --> 01:56:18,779
that tries to put them into a space that

2352
01:56:16,529 --> 01:56:21,000
might make it easier to compress them in

2353
01:56:18,779 --> 01:56:22,649
that way for example maybe one thing I

2354
01:56:21,000 --> 01:56:24,720
could do is take the average value of

2355
01:56:22,649 --> 01:56:26,639
all the pixels and subtract that away so

2356
01:56:24,720 --> 01:56:28,590
I just get like pixel differences or

2357
01:56:26,640 --> 01:56:30,360
something right that would mean that

2358
01:56:28,590 --> 01:56:32,400
only subtle changes would have to be

2359
01:56:30,359 --> 01:56:34,199
recorded which would reduce the size of

2360
01:56:32,399 --> 01:56:36,359
the pixel information which would then

2361
01:56:34,199 --> 01:56:39,059
allow the compressors Huffman tree to

2362
01:56:36,359 --> 01:56:41,309
use less space to encode the small Delta

2363
01:56:39,060 --> 01:56:43,410
s blah blah blah blah blah right so the

2364
01:56:41,310 --> 01:56:45,150
filter part is just a pre pass on the

2365
01:56:43,409 --> 01:56:47,369
image that tries to get it into shape

2366
01:56:45,149 --> 01:56:50,759
what we're gonna have to do is reverse

2367
01:56:47,369 --> 01:56:52,920
up that that change right so in theory I

2368
01:56:50,760 --> 01:56:54,929
expect this to happen after compression

2369
01:56:52,920 --> 01:56:56,219
so I'm gonna assume that the compression

2370
01:56:54,929 --> 01:56:58,949
parts what happens first notice they

2371
01:56:56,219 --> 01:57:00,420
didn't bother say that right so the

2372
01:56:58,948 --> 01:57:02,879
specs a little annoying us what I was

2373
01:57:00,420 --> 01:57:04,828
talking about but what are you gonna do

2374
01:57:02,880 --> 01:57:06,118
um so if you're looking at here I'm just

2375
01:57:04,828 --> 01:57:07,018
gonna start with this and assume that's

2376
01:57:06,118 --> 01:57:08,399
what's in the data stream in the eye

2377
01:57:07,019 --> 01:57:09,989
that chunk even though nobody brought

2378
01:57:08,399 --> 01:57:12,658
him to say that why would you it's only

2379
01:57:09,988 --> 01:57:14,069
a speck and let's go ahead and see what

2380
01:57:12,658 --> 01:57:15,988
it says it says compress the method

2381
01:57:14,069 --> 01:57:16,920
zeros for me in our standard our values

2382
01:57:15,988 --> 01:57:18,779
are reserved

2383
01:57:16,920 --> 01:57:20,908
PNG gigabytes to 0 is deflate inflate

2384
01:57:18,779 --> 01:57:22,018
compressor a sliding window which we

2385
01:57:20,908 --> 01:57:24,179
have inspect for over there

2386
01:57:22,019 --> 01:57:26,340
it's an lz77 derivative which we know

2387
01:57:24,179 --> 01:57:29,788
and which we said and it has this

2388
01:57:26,340 --> 01:57:32,639
structure right so let's look and see if

2389
01:57:29,788 --> 01:57:36,149
this is what we see right let's just see

2390
01:57:32,639 --> 01:57:38,219
if that's what we see so we expect to

2391
01:57:36,149 --> 01:57:40,018
see two bytes one that's the z lib

2392
01:57:38,219 --> 01:57:41,849
compression method and flags code and

2393
01:57:40,019 --> 01:57:44,039
ones it's additional flag and checks

2394
01:57:41,849 --> 01:57:48,650
bits and let's see if that's what we

2395
01:57:44,038 --> 01:57:48,649
actually get when we look at the stream

2396
01:57:54,078 --> 01:58:07,429
so that says and

2397
01:58:09,010 --> 01:58:14,070
and then we've also got a check value I

2398
01:58:18,359 --> 01:58:21,519
don't know what that means

2399
01:58:20,140 --> 01:58:24,280
probably something to let us know if

2400
01:58:21,520 --> 01:58:27,060
we've done our thing correctly let's

2401
01:58:24,279 --> 01:58:29,259
find out the feeder gauge mesazero

2402
01:58:27,060 --> 01:58:31,900
the sealer compression method slack code

2403
01:58:29,260 --> 01:58:33,430
shall specify method code 8 and Elsie's

2404
01:58:31,899 --> 01:58:35,979
the window size of not more than 3 to

2405
01:58:33,430 --> 01:58:37,810
768 the sealant profession Method number

2406
01:58:35,979 --> 01:58:40,238
is not the same as the PNG compression

2407
01:58:37,810 --> 01:58:41,920
method number in the I adore chunk the

2408
01:58:40,238 --> 01:58:46,839
flag shall not specify a preset

2409
01:58:41,920 --> 01:58:47,739
dictionary oh well that's good because

2410
01:58:46,840 --> 01:58:50,470
that means we don't have to implement

2411
01:58:47,738 --> 01:58:52,389
that code path presumably if the data to

2412
01:58:50,470 --> 01:58:53,829
begin press 15 blah blah blah you go to

2413
01:58:52,390 --> 01:58:55,600
Mesa the window size we're running up to

2414
01:58:53,829 --> 01:58:56,619
a power of 2 excretes the memory

2415
01:58:55,600 --> 01:58:58,329
required for mythic oh dear without

2416
01:58:56,619 --> 01:58:59,920
aversive Heather kris radio the compress

2417
01:58:58,329 --> 01:59:01,899
today within a suitably extreme are

2418
01:58:59,920 --> 01:59:04,779
stored as a series of blocks each of us

2419
01:59:01,899 --> 01:59:06,670
can represent raw data that's so good

2420
01:59:04,779 --> 01:59:08,380
the check 5 sword is calculated on the

2421
01:59:06,670 --> 01:59:09,460
uncompressed data represent data stream

2422
01:59:08,380 --> 01:59:12,460
that the algorithm you screw strikes

2423
01:59:09,460 --> 01:59:14,170
it's not saying seriously used to PHP 0z

2424
01:59:12,460 --> 01:59:22,270
check files to be a cross-check deflate

2425
01:59:14,170 --> 01:59:25,180
inflate does it say does it bother to

2426
01:59:22,270 --> 01:59:27,730
specify what is it just me or do they

2427
01:59:25,180 --> 01:59:29,920
just totally skip how the CRC was good

2428
01:59:27,729 --> 01:59:34,689
it is not the same as a seriously

2429
01:59:29,920 --> 01:59:36,430
calculation for the PNG chunk oh so I

2430
01:59:34,689 --> 01:59:39,069
think they just it's just whatever

2431
01:59:36,430 --> 01:59:42,310
Zealand would have done so I think they

2432
01:59:39,069 --> 01:59:45,309
just kind of they're just leaving that

2433
01:59:42,310 --> 01:59:46,690
to the Z Lim spec so that's fine alright

2434
01:59:45,310 --> 01:59:49,690
so let's take a look at what does this

2435
01:59:46,689 --> 01:59:53,889
look like right so let's take a look at

2436
01:59:49,689 --> 01:59:54,879
the at the PNG i dot header and just

2437
01:59:53,890 --> 01:59:56,200
look it looks like and that's we're all

2438
01:59:54,880 --> 02:00:03,100
in the stream and the tomorrow we'll

2439
01:59:56,199 --> 02:00:05,279
tackle the that part we'll tackle the

2440
02:00:03,100 --> 02:00:09,520
sort of like starting to get the

2441
02:00:05,279 --> 02:00:12,609
deflate coder working right so here's

2442
02:00:09,520 --> 02:00:16,150
the i dot header and i'm gonna go ahead

2443
02:00:12,609 --> 02:00:18,789
and just say look let's let's take a

2444
02:00:16,149 --> 02:00:22,019
gander at that data that's going to be

2445
02:00:18,789 --> 02:00:27,439
this where is this

2446
02:00:22,020 --> 02:00:31,980
trunk data here and what I want to do is

2447
02:00:27,439 --> 02:00:35,460
just inspect those values I guess and I

2448
02:00:31,979 --> 02:00:38,519
can inspect those values based on what I

2449
02:00:35,460 --> 02:00:41,310
read in here there was information about

2450
02:00:38,520 --> 02:00:42,540
how that was going to be stored right in

2451
02:00:41,310 --> 02:00:46,260
the Zealand part of things

2452
02:00:42,539 --> 02:00:49,109
mm-hmm so this is what it told us we

2453
02:00:46,260 --> 02:00:52,020
would be seeing it told us we would see

2454
02:00:49,109 --> 02:00:54,630
a compression method and it's saying in

2455
02:00:52,020 --> 02:00:57,090
the P&amp;G spec that this has to be 8 so

2456
02:00:54,630 --> 02:01:02,480
what we can say here is if bits 0 2 3

2457
02:00:57,090 --> 02:01:04,560
have to be set to 8 then 4 to 7 is the

2458
02:01:02,479 --> 02:01:07,409
the information we need to figure out

2459
02:01:04,560 --> 02:01:08,910
what the window size is right so let's

2460
02:01:07,409 --> 02:01:12,510
just see if we can get those two values

2461
02:01:08,909 --> 02:01:13,920
out and then we'll call it a day oh and

2462
02:01:12,510 --> 02:01:15,750
then we can also look at the flags we

2463
02:01:13,920 --> 02:01:19,949
can get out the F check the F dict in

2464
02:01:15,750 --> 02:01:23,100
the F level right so let's try to get

2465
02:01:19,949 --> 02:01:33,029
all of those out so let's go ahead and

2466
02:01:23,100 --> 02:01:33,890
get the CM the C info of the F check the

2467
02:01:33,029 --> 02:01:43,139
F dict

2468
02:01:33,890 --> 02:01:44,910
and the F level so the compression

2469
02:01:43,140 --> 02:01:50,690
method is going to be in the Z Lib

2470
02:01:44,909 --> 02:01:50,689
method flags that's going to be in the

2471
02:01:51,720 --> 02:02:00,579
bit zero to three is the CM so bit zero

2472
02:01:56,649 --> 02:02:04,539
to three is just the first four in

2473
02:02:00,579 --> 02:02:06,609
theory so the Z lib method flags and oxf

2474
02:02:04,539 --> 02:02:11,409
should give that to us and then if we

2475
02:02:06,609 --> 02:02:13,299
shift down the remainder by four that

2476
02:02:11,409 --> 02:02:15,479
should give us four to seven assuming

2477
02:02:13,300 --> 02:02:18,100
that we're looking at that correctly

2478
02:02:15,479 --> 02:02:19,959
four or five six seven zero one two

2479
02:02:18,100 --> 02:02:21,280
three so that's both tabs of that so

2480
02:02:19,960 --> 02:02:23,859
it's just two nibbles right we're just

2481
02:02:21,279 --> 02:02:26,920
getting one nibble out in each case the

2482
02:02:23,859 --> 02:02:32,670
F checked value is zero to four that's

2483
02:02:26,920 --> 02:02:36,159
in the flags and check bits for cmf and

2484
02:02:32,670 --> 02:02:40,899
flz the answers that see when viewed as

2485
02:02:36,159 --> 02:02:42,789
the city of Baton Rouge so is that it's

2486
02:02:40,899 --> 02:02:45,879
just is that just the thing

2487
02:02:42,789 --> 02:02:48,460
it looks like F check is just a like a

2488
02:02:45,880 --> 02:02:50,619
basically it error redundancy thing I

2489
02:02:48,460 --> 02:02:54,520
guess I don't know why that's there but

2490
02:02:50,619 --> 02:02:57,849
it looks like just another way of

2491
02:02:54,520 --> 02:02:59,440
checking things so we'll look at that in

2492
02:02:57,850 --> 02:03:01,420
a second I guess that the preset

2493
02:02:59,439 --> 02:03:06,909
dictionary is just bit five it's just on

2494
02:03:01,420 --> 02:03:09,100
or off right so in theory we should be

2495
02:03:06,909 --> 02:03:12,090
able to take well I guess we shift it

2496
02:03:09,100 --> 02:03:20,190
down by four and we'd get bit five right

2497
02:03:12,090 --> 02:03:20,190
that's bit five and then we want the

2498
02:03:30,550 --> 02:03:37,940
okay no sorry I'm off a little bit there

2499
02:03:33,770 --> 02:03:41,150
so they want 0 1 2 3 &amp; 4 so they want

2500
02:03:37,939 --> 02:03:42,769
the first 5 bits here so they're

2501
02:03:41,149 --> 02:03:48,049
actually looking this is a bigger value

2502
02:03:42,770 --> 02:03:48,889
so it's actually that right where we're

2503
02:03:48,050 --> 02:03:53,150
saying okay

2504
02:03:48,889 --> 02:03:55,789
Oh what's the wrong one there it's

2505
02:03:53,149 --> 02:03:58,339
actually that is what we're talking

2506
02:03:55,789 --> 02:04:01,729
about here so this F check is the first

2507
02:03:58,340 --> 02:04:04,520
5 bits then we shift this down by 5 and

2508
02:04:01,729 --> 02:04:08,000
get just the 5th bit out then we look at

2509
02:04:04,520 --> 02:04:09,619
big 6 and 7 for the F level okay

2510
02:04:08,000 --> 02:04:17,988
so now let me go ahead and print these

2511
02:04:09,618 --> 02:04:19,578
out just so we can see what they are and

2512
02:04:17,988 --> 02:04:30,769
then like I said that'll that'll be it

2513
02:04:19,578 --> 02:04:32,689
for today there's see em there's info

2514
02:04:30,770 --> 02:04:37,130
there's effect there's the F dickin

2515
02:04:32,689 --> 02:04:40,519
there's the F level so if I go ahead and

2516
02:04:37,130 --> 02:04:44,840
run this now what we'll see is what we

2517
02:04:40,520 --> 02:04:47,030
think those values are right for the

2518
02:04:44,840 --> 02:04:50,949
iTap chunks and I thought I should make

2519
02:04:47,029 --> 02:04:50,948
this a little bit easier to read here I

2520
02:04:51,819 --> 02:05:00,078
just can I get again these so they're

2521
02:04:56,210 --> 02:05:05,149
more like a tabbed text file sort of

2522
02:05:00,078 --> 02:05:09,189
thing so here's our various ah dat

2523
02:05:05,149 --> 02:05:11,359
chunks and you can see here we've got

2524
02:05:09,189 --> 02:05:15,558
you know different values for each of

2525
02:05:11,359 --> 02:05:17,960
them what I would say just looking at

2526
02:05:15,559 --> 02:05:22,190
this here what you can see is the first

2527
02:05:17,960 --> 02:05:27,770
I'd a chunk has a values that look like

2528
02:05:22,189 --> 02:05:30,789
what we do expect let me double check

2529
02:05:27,770 --> 02:05:33,800
that so F dick predicts that dictionary

2530
02:05:30,789 --> 02:05:36,229
if after to set the dictators present

2531
02:05:33,800 --> 02:05:38,000
immediately after the flak if after you

2532
02:05:36,229 --> 02:05:40,339
said the dictation err identifier is

2533
02:05:38,000 --> 02:05:41,658
present immediately after the flg bite

2534
02:05:40,340 --> 02:05:42,650
the dictionary is a sequence of bytes

2535
02:05:41,658 --> 02:05:43,670
which are initially fed to the

2536
02:05:42,649 --> 02:05:46,939
compressor with that producing

2537
02:05:43,670 --> 02:05:50,510
compressed output dicta Sadler okay so I

2538
02:05:46,939 --> 02:05:53,019
think we do expect that to be zero so

2539
02:05:50,510 --> 02:05:56,480
looking at this here I would say that

2540
02:05:53,020 --> 02:05:59,239
and what's seven again it's the window

2541
02:05:56,479 --> 02:06:00,829
size that looks correct these don't look

2542
02:05:59,238 --> 02:06:05,238
at all correct so what I'm going to

2543
02:06:00,829 --> 02:06:10,399
assume is true is that these Ida chunks

2544
02:06:05,238 --> 02:06:14,089
that follow are just raw concatenations

2545
02:06:10,399 --> 02:06:17,899
that themselves do not actually mean

2546
02:06:14,090 --> 02:06:20,360
anything meanings so like they don't

2547
02:06:17,899 --> 02:06:22,099
each have a header it's what I expected

2548
02:06:20,359 --> 02:06:24,559
there are actually just things that will

2549
02:06:22,100 --> 02:06:29,480
get consumed as part of the main IDOT

2550
02:06:24,560 --> 02:06:32,330
chunk right so what we need to do here

2551
02:06:29,479 --> 02:06:34,819
is we need to sort of like aggregate

2552
02:06:32,329 --> 02:06:39,019
those forward and that's not a huge deal

2553
02:06:34,819 --> 02:06:40,488
like we can do that just fine but that's

2554
02:06:39,020 --> 02:06:42,170
what that tells me so we'll think about

2555
02:06:40,488 --> 02:06:44,269
how we're going to do that later but it

2556
02:06:42,170 --> 02:06:46,579
looks like we're okay there so let's go

2557
02:06:44,270 --> 02:06:47,989
ahead and go to the QA and tomorrow

2558
02:06:46,579 --> 02:06:53,319
we'll take a look at how to start

2559
02:06:47,988 --> 02:06:53,319
compressing this I - honks and off we go

2560
02:07:28,949 --> 02:07:33,220
instead of using the 4c Macker why not

2561
02:07:31,510 --> 02:07:35,020
just use a single coated literal for

2562
02:07:33,220 --> 02:07:37,690
example if chunk header type three

2563
02:07:35,020 --> 02:07:41,470
vehicles I header are you allowed to do

2564
02:07:37,689 --> 02:07:47,009
that everywhere is that only allowed in

2565
02:07:41,470 --> 02:07:47,010
Lexi xx you know 11 or 17 or something

2566
02:07:54,390 --> 02:07:58,060
what is wrong about using imagemagick

2567
02:07:56,470 --> 02:08:00,310
from the build system to convert all the

2568
02:07:58,060 --> 02:08:01,900
images because we want the artist to be

2569
02:08:00,310 --> 02:08:05,170
able to save out of Photoshop and load

2570
02:08:01,899 --> 02:08:08,529
and this will load directly in from the

2571
02:08:05,170 --> 02:08:11,199
game the game is supposed to load the

2572
02:08:08,529 --> 02:08:15,000
output that the artist six in the

2573
02:08:11,199 --> 02:08:15,000
directory just immediately

2574
02:08:21,710 --> 02:08:26,250
you see this don't think so

2575
02:08:23,729 --> 02:08:28,169
you used it 20 years ago really so you

2576
02:08:26,250 --> 02:08:40,170
mean this entire time when people have

2577
02:08:28,170 --> 02:08:41,460
been doing because I've seen so many

2578
02:08:40,170 --> 02:08:47,368
macro set you're saying you could have

2579
02:08:41,460 --> 02:08:51,779
done that that's pretty awesome and I

2580
02:08:47,368 --> 02:08:53,609
did not think that worked well so okay

2581
02:08:51,779 --> 02:08:56,219
but it's the wrong order is the only

2582
02:08:53,609 --> 02:09:05,849
thing right so you'd have to actually do

2583
02:08:56,219 --> 02:09:15,960
this right which is which kind of

2584
02:09:05,850 --> 02:09:18,210
annoying so that's probably why NPC 743

2585
02:09:15,960 --> 02:09:21,569
what mass which I need to know to follow

2586
02:09:18,210 --> 02:09:23,670
along should I learn linear algebra well

2587
02:09:21,569 --> 02:09:25,019
it depends you do need to know some

2588
02:09:23,670 --> 02:09:27,149
linear algebra to follow along but we

2589
02:09:25,020 --> 02:09:31,830
don't do much work with matrices it's

2590
02:09:27,149 --> 02:09:34,259
pretty basic so I would say that you

2591
02:09:31,829 --> 02:09:36,000
don't need to know much about like

2592
02:09:34,260 --> 02:09:40,409
matrix factoring and those sorts of

2593
02:09:36,000 --> 02:09:43,198
things so I would say probably just

2594
02:09:40,408 --> 02:09:45,599
basic vector like working with vectors

2595
02:09:43,198 --> 02:09:49,399
is probably all you would need a little

2596
02:09:45,600 --> 02:09:49,400
practice in falling along

2597
02:09:55,368 --> 02:10:01,979
just little bit brainstorming can

2598
02:09:57,389 --> 02:10:05,880
somehow zip F's law be used for benefit

2599
02:10:01,979 --> 02:10:10,158
on presumably meant huffman zip F's law

2600
02:10:05,880 --> 02:10:10,159
I don't think I know what zip f slaw is

2601
02:10:10,819 --> 02:10:17,960
it work if you beat about the type yeah

2602
02:10:13,198 --> 02:10:17,960
I mean like I said you kind of have to I

2603
02:10:19,130 --> 02:10:25,159
mean yeah we could do this right

2604
02:10:27,118 --> 02:10:46,649
I suppose that would work which is kind

2605
02:10:44,639 --> 02:10:51,420
of cool I I definitely admit I did not

2606
02:10:46,649 --> 02:10:52,710
know that that would actually work so

2607
02:10:51,420 --> 02:10:54,270
I'm totally down with that because hey

2608
02:10:52,710 --> 02:10:58,469
it gets rid of a macro that the way

2609
02:10:54,270 --> 02:11:00,500
doesn't do anything so I'm flying with

2610
02:10:58,469 --> 02:11:00,500
that

2611
02:11:07,319 --> 02:11:20,109
so somebody is posting zip f slaw okay I

2612
02:11:10,390 --> 02:11:21,579
will look at it many types of data

2613
02:11:20,109 --> 02:11:22,899
studying the physical inertia has to be

2614
02:11:21,579 --> 02:11:24,309
approximated with a zip fee and

2615
02:11:22,899 --> 02:11:29,500
distribution to one of a family related

2616
02:11:24,310 --> 02:11:31,180
to power law property issue oh so I

2617
02:11:29,500 --> 02:11:41,829
think I see what you're saying you're

2618
02:11:31,180 --> 02:11:46,590
basically saying are you just saying use

2619
02:11:41,829 --> 02:11:46,590
a preformed distribution

2620
02:11:53,479 --> 02:11:56,659
[Music]

2621
02:12:05,390 --> 02:12:10,619
so I guess I'm not sure exactly what

2622
02:12:07,800 --> 02:12:13,140
you're asking about the zip s law but

2623
02:12:10,619 --> 02:12:17,130
here's what I can say so compression

2624
02:12:13,140 --> 02:12:19,200
generally speaking when you get more

2625
02:12:17,130 --> 02:12:22,579
advanced compression they don't

2626
02:12:19,199 --> 02:12:25,199
generally ever want to use a

2627
02:12:22,579 --> 02:12:27,090
pre-designed distribution I don't think

2628
02:12:25,199 --> 02:12:29,819
because you want to be able to adapt to

2629
02:12:27,090 --> 02:12:31,350
your data better than that so I don't

2630
02:12:29,819 --> 02:12:32,969
think anything as simple as just

2631
02:12:31,350 --> 02:12:34,710
assuming that the distribution is a

2632
02:12:32,970 --> 02:12:36,900
particular type of distribution is

2633
02:12:34,710 --> 02:12:38,340
something that they do I'm not a

2634
02:12:36,899 --> 02:12:40,559
compression person so you really want to

2635
02:12:38,340 --> 02:12:42,539
ask someone like Charles bloom but if I

2636
02:12:40,560 --> 02:12:45,510
had to guess what Charles would say I

2637
02:12:42,539 --> 02:12:47,819
think he would say something like what

2638
02:12:45,510 --> 02:12:50,340
you want to do is create systems that

2639
02:12:47,819 --> 02:12:53,880
can articulate their distributions

2640
02:12:50,340 --> 02:12:56,430
cleanly in a very concise way so that

2641
02:12:53,880 --> 02:12:58,890
depending on what kind of data you see

2642
02:12:56,430 --> 02:13:01,289
on the compression side you can quickly

2643
02:12:58,890 --> 02:13:03,990
articulate the distribution as easy as

2644
02:13:01,289 --> 02:13:07,340
possible to the decompression side so a

2645
02:13:03,989 --> 02:13:07,340
lot of times they'll use adaptive

2646
02:13:07,369 --> 02:13:14,489
alphabets right so as you see symbols

2647
02:13:11,430 --> 02:13:16,800
you adjust the tree so the decoder never

2648
02:13:14,489 --> 02:13:18,119
has to be sent a dictionary it just

2649
02:13:16,800 --> 02:13:20,070
figures out what the dictionary should

2650
02:13:18,119 --> 02:13:23,430
be as the compressor is doing it and so

2651
02:13:20,069 --> 02:13:25,170
on things like that but again that's a

2652
02:13:23,430 --> 02:13:29,010
question more for compression person not

2653
02:13:25,170 --> 02:13:31,350
for me I don't do compression how could

2654
02:13:29,010 --> 02:13:36,360
someone abuse the PNG loader you brought

2655
02:13:31,350 --> 02:13:39,840
up malformed code yes so the all I meant

2656
02:13:36,359 --> 02:13:44,250
was if you want your program to handle

2657
02:13:39,840 --> 02:13:46,529
like possibly garbage input you need to

2658
02:13:44,250 --> 02:13:48,390
put checks in and guard for that we

2659
02:13:46,529 --> 02:13:50,460
won't be doing that so someone could

2660
02:13:48,390 --> 02:13:52,500
construct a PNG file that would cause us

2661
02:13:50,460 --> 02:13:55,230
to crash or produce an exploit in our

2662
02:13:52,500 --> 02:13:58,819
code for example by setting the bits of

2663
02:13:55,229 --> 02:14:02,009
the i dot chunk for example to make our

2664
02:13:58,819 --> 02:14:03,750
lzd coding loop crash by looking into

2665
02:14:02,010 --> 02:14:04,470
memory that doesn't exist or something

2666
02:14:03,750 --> 02:14:06,390
like this right

2667
02:14:04,470 --> 02:14:08,670
and so if you want to ship something

2668
02:14:06,390 --> 02:14:10,740
robust that you expect other people to

2669
02:14:08,670 --> 02:14:11,819
be using this not during development

2670
02:14:10,739 --> 02:14:13,769
like we're here doing here but actually

2671
02:14:11,819 --> 02:14:17,380
like as part of like Photoshop or

2672
02:14:13,770 --> 02:14:19,330
something you probably want to put in so

2673
02:14:17,380 --> 02:14:21,420
resiliency there so that if there's a

2674
02:14:19,329 --> 02:14:23,979
malformed data stream you detect it and

2675
02:14:21,420 --> 02:14:29,380
just produce an error message rather

2676
02:14:23,979 --> 02:14:31,899
than crashing or who knows what else the

2677
02:14:29,380 --> 02:14:35,940
PNG i dot footer should be 4 bytes oh

2678
02:14:31,899 --> 02:14:35,939
yes you're right it should be thank you

2679
02:14:39,729 --> 02:14:46,658
why are there several itit chunks and

2680
02:14:41,529 --> 02:14:48,908
not one single one I don't know you know

2681
02:14:46,658 --> 02:14:57,158
that was something I said before I did

2682
02:14:48,908 --> 02:15:00,399
not understand why that's the case I I

2683
02:14:57,158 --> 02:15:02,829
couldn't tell you I could not tell you

2684
02:15:00,399 --> 02:15:05,079
they obviously thought it was important

2685
02:15:02,829 --> 02:15:07,510
for you to be able to put multiple itit

2686
02:15:05,079 --> 02:15:11,380
chunks in but I do not know why it seems

2687
02:15:07,510 --> 02:15:16,119
like a strictly a waste of bits maybe

2688
02:15:11,380 --> 02:15:23,260
they wanted it to be CR seed in parts or

2689
02:15:16,119 --> 02:15:26,590
something or I don't know I didn't see a

2690
02:15:23,260 --> 02:15:27,940
rationale in the spec there in the part

2691
02:15:26,590 --> 02:15:29,500
we were reading so I don't know what

2692
02:15:27,939 --> 02:15:32,519
they're thinking exactly but they might

2693
02:15:29,500 --> 02:15:36,340
have one I just don't know what it is

2694
02:15:32,520 --> 02:15:39,940
not using be swap intrinsic instead no

2695
02:15:36,340 --> 02:15:42,960
is there a particularly is there a

2696
02:15:39,939 --> 02:15:42,960
reason why we would

2697
02:15:52,210 --> 02:16:02,579
because what actually what does that

2698
02:15:59,079 --> 02:16:02,579
actually supported on anyway

2699
02:16:23,010 --> 02:16:35,130
so are these just always available in LX

2700
02:16:27,539 --> 02:16:42,409
64 because if so yeah we could totally

2701
02:16:35,129 --> 02:16:42,409
use one I wish this stated explicitly

2702
02:16:54,260 --> 02:17:01,620
so it should be it should be in any x64

2703
02:16:58,409 --> 02:17:27,479
chip right so yeah we could do if we

2704
02:17:01,620 --> 02:17:28,910
wanted to we could do this let's see if

2705
02:17:27,479 --> 02:17:33,949
that works

2706
02:17:28,909 --> 02:17:33,950
wait a minute what was the intrinsic

2707
02:17:41,329 --> 02:17:49,319
says it's an IMM inte R in which I

2708
02:17:45,659 --> 02:17:57,979
included and it says its underscore be

2709
02:17:49,319 --> 02:18:03,619
swap why are you complaining about that

2710
02:17:57,979 --> 02:18:03,619
I'm not sure why it doesn't like that

2711
02:18:05,809 --> 02:18:12,059
let's let's take a quick gander cuz yeah

2712
02:18:09,000 --> 02:18:22,739
I don't know why I guess I have not used

2713
02:18:12,059 --> 02:18:25,409
that instruction but I agree it should

2714
02:18:22,739 --> 02:18:27,780
it seems reasonable hold on a second let

2715
02:18:25,409 --> 02:18:30,110
me just find out why it's not happy

2716
02:18:27,780 --> 02:18:30,110
about that

2717
02:18:32,940 --> 02:18:39,179
so in here if I include X amendment R in

2718
02:18:36,899 --> 02:18:41,750
let me just see what happens if I touch

2719
02:18:39,179 --> 02:18:41,750
B swap

2720
02:19:12,059 --> 02:19:22,049
so X mm and Trin is in this directory

2721
02:19:15,780 --> 02:19:24,750
right yeah so what I could do is say all

2722
02:19:22,049 --> 02:19:27,629
right look tell me where that is and

2723
02:19:24,750 --> 02:19:29,370
let's look at what what why doesn't want

2724
02:19:27,629 --> 02:19:32,279
to be you know what would I have to

2725
02:19:29,370 --> 02:19:34,860
define for you to give me that macro so

2726
02:19:32,280 --> 02:19:40,770
if I just say look in here tell me where

2727
02:19:34,860 --> 02:20:00,931
be swap is it doesn't seem to want to

2728
02:19:40,770 --> 02:20:03,690
give it to me oh so it looks like it

2729
02:20:00,931 --> 02:20:10,649
just they have their own built-in macro

2730
02:20:03,690 --> 02:20:15,239
for it is what happened right so they

2731
02:20:10,649 --> 02:20:20,879
they called it byte swap you long is

2732
02:20:15,239 --> 02:20:27,199
what actually happened that's look like

2733
02:20:20,879 --> 02:20:27,199
what actually happened so probably

2734
02:20:39,260 --> 02:20:45,139
that's it even though Intel defined it

2735
02:20:42,978 --> 02:20:49,459
as a be swap probably what happened is

2736
02:20:45,139 --> 02:20:51,939
they were like oh yeah Visual Studio

2737
02:20:49,459 --> 02:20:54,738
already had its own idea of what that

2738
02:20:51,939 --> 02:20:57,199
act 64 intrinsic was going to be and so

2739
02:20:54,738 --> 02:21:01,850
that's what it used right that's

2740
02:20:57,199 --> 02:21:03,829
probably what happened so what we can do

2741
02:21:01,850 --> 02:21:06,290
though here is to now take a look and we

2742
02:21:03,829 --> 02:21:13,939
should get that instruction getting

2743
02:21:06,290 --> 02:21:18,380
issued so here let me jump in there so

2744
02:21:13,939 --> 02:21:19,790
if I'd go to the disassembly here you

2745
02:21:18,379 --> 02:21:26,379
can see the beef swap is now getting

2746
02:21:19,790 --> 02:21:29,720
executed right so off we go

2747
02:21:26,379 --> 02:21:31,759
so yeah that's totally cool by me

2748
02:21:29,719 --> 02:21:34,639
I don't think that's the part of the

2749
02:21:31,760 --> 02:21:36,889
code that really matters much at all you

2750
02:21:34,639 --> 02:21:42,379
know what I image to know how smart is

2751
02:21:36,889 --> 02:21:45,408
the compiler there so if we do that if I

2752
02:21:42,379 --> 02:21:47,059
switch the build to optimize is it smart

2753
02:21:45,408 --> 02:21:49,279
enough to figure out it's a beef swap

2754
02:21:47,059 --> 02:21:50,930
and to insert the B swap instruction

2755
02:21:49,279 --> 02:21:52,550
assuming the VCR instruction is the

2756
02:21:50,930 --> 02:22:02,449
fastest way to do it which presumably it

2757
02:21:52,549 --> 02:22:04,299
is let's find out so here's this hey

2758
02:22:02,449 --> 02:22:06,710
check it out

2759
02:22:04,299 --> 02:22:09,559
it's pretty cool right the compiler

2760
02:22:06,709 --> 02:22:12,139
actually figured out that this sequence

2761
02:22:09,559 --> 02:22:14,238
of instructions is a byte swap it

2762
02:22:12,139 --> 02:22:22,608
pattern match that and just output it a

2763
02:22:14,238 --> 02:22:28,579
B swap anyway so hey you don't even have

2764
02:22:22,609 --> 02:22:30,170
to find the intrinsic it'll just do the

2765
02:22:28,579 --> 02:22:32,180
right thing so I may leave it like that

2766
02:22:30,170 --> 02:22:35,930
because this works everywhere and this

2767
02:22:32,180 --> 02:22:37,790
doesn't right so I may leave it like

2768
02:22:35,930 --> 02:22:39,229
that for now because it's it in an

2769
02:22:37,790 --> 02:22:41,920
optimized bill that actually generates a

2770
02:22:39,228 --> 02:22:41,920
piece off anyway

2771
02:22:45,469 --> 02:22:52,349
is the PNG loader to support allow live

2772
02:22:48,898 --> 02:22:57,049
art iteration on stream not on stream

2773
02:22:52,350 --> 02:22:57,050
just when Anna's working on the art

2774
02:23:01,369 --> 02:23:04,409
sorry if I missed it was there any

2775
02:23:03,299 --> 02:23:08,849
reason that rim types have the weird

2776
02:23:04,408 --> 02:23:12,809
mixed case like te XT and phys I don't

2777
02:23:08,850 --> 02:23:14,309
know here's what I would say about it I

2778
02:23:12,809 --> 02:23:16,049
don't know what the again I don't know

2779
02:23:14,309 --> 02:23:18,059
the rationale by most things in the PNG

2780
02:23:16,049 --> 02:23:19,978
spec and this is my first time ever

2781
02:23:18,059 --> 02:23:24,090
looking at it right is on this stream

2782
02:23:19,978 --> 02:23:26,248
I've never looked at it before what I

2783
02:23:24,090 --> 02:23:28,949
will say about it is if you look at the

2784
02:23:26,248 --> 02:23:30,840
actual chunk where is that list of

2785
02:23:28,949 --> 02:23:34,949
chunks error we had a second ago here it

2786
02:23:30,840 --> 02:23:37,738
is what I think what what it appeared to

2787
02:23:34,949 --> 02:23:42,119
be to me is that chunks that are not

2788
02:23:37,738 --> 02:23:44,670
super necessary had lower case first

2789
02:23:42,119 --> 02:23:51,300
characters right and chunks that are

2790
02:23:44,670 --> 02:23:53,639
super necessary had the capitalized so I

2791
02:23:51,299 --> 02:23:56,129
think that that was sort of their way of

2792
02:23:53,639 --> 02:23:58,709
saying look anything with a caps is

2793
02:23:56,129 --> 02:24:00,839
trying to tell you this is important

2794
02:23:58,709 --> 02:24:03,709
anything with a lower case is like other

2795
02:24:00,840 --> 02:24:07,010
sorts of information that maybe isn't so

2796
02:24:03,709 --> 02:24:07,009
important right

2797
02:24:11,959 --> 02:24:17,000
what's the 32-bit CRC for it's just for

2798
02:24:14,719 --> 02:24:18,409
validating the stream right in case

2799
02:24:17,000 --> 02:24:21,680
there was errors introduced in the

2800
02:24:18,409 --> 02:24:23,299
stream you just you'd know file formats

2801
02:24:21,680 --> 02:24:25,340
often have CRC's in them so you can tell

2802
02:24:23,299 --> 02:24:28,719
if they've been corrupted just in

2803
02:24:25,340 --> 02:24:28,719
transport or whatever else

2804
02:24:39,860 --> 02:24:42,860
it's

2805
02:25:02,290 --> 02:25:07,960
alright looks like we're all done

2806
02:25:07,989 --> 02:25:12,219
alright so I'm gonna leave that stuff up

2807
02:25:12,370 --> 02:25:23,810
oops I probably want to didn't really

2808
02:25:16,729 --> 02:25:27,409
want us to okay I'm gonna leave that

2809
02:25:23,809 --> 02:25:31,250
stuff up because I want to have access

2810
02:25:27,409 --> 02:25:34,280
to all those specs tomorrow when we get

2811
02:25:31,250 --> 02:25:35,649
back to it let me go ahead and clean

2812
02:25:34,280 --> 02:25:37,730
that up there we don't need that anymore

2813
02:25:35,649 --> 02:25:38,930
all right thanks everyone for joining me

2814
02:25:37,729 --> 02:25:40,579
for this set of handmade hereit's and a

2815
02:25:38,930 --> 02:25:42,229
pleasure coding with you as always if

2816
02:25:40,579 --> 02:25:43,489
you want to follow along with the series

2817
02:25:42,229 --> 02:25:45,619
at home you can always preorder the game

2818
02:25:43,489 --> 02:25:48,229
hand me a hero or gonna comes with a

2819
02:25:45,620 --> 02:25:51,050
source code so you can play around with

2820
02:25:48,229 --> 02:25:53,029
it I you can actually try implementing

2821
02:25:51,049 --> 02:25:54,529
the IDE at chunks tonight if you want to

2822
02:25:53,030 --> 02:25:56,750
that's what we'll be starting on

2823
02:25:54,530 --> 02:25:58,250
tomorrow I don't know how long it will

2824
02:25:56,750 --> 02:26:00,409
take I don't think it'll take that long

2825
02:25:58,250 --> 02:26:02,510
to just sketch out the decompression of

2826
02:26:00,409 --> 02:26:04,129
the eye that chunks the problem I'm

2827
02:26:02,510 --> 02:26:05,510
suspecting is when we get down the nitty

2828
02:26:04,129 --> 02:26:06,829
gritty there'll be a lot of little bit

2829
02:26:05,510 --> 02:26:08,540
twiddling things that maybe we

2830
02:26:06,829 --> 02:26:10,069
accidentally get wrong or whatever and

2831
02:26:08,540 --> 02:26:13,640
they'll take a while for us to suss them

2832
02:26:10,069 --> 02:26:15,110
out as it is we've at least gotten it to

2833
02:26:13,639 --> 02:26:16,459
the point where we know how big the

2834
02:26:15,110 --> 02:26:18,739
thing is going to be we can allocate

2835
02:26:16,459 --> 02:26:20,539
space for it and now we have a chunk

2836
02:26:18,739 --> 02:26:22,699
data and we know the format that it's in

2837
02:26:20,540 --> 02:26:24,170
so we're in relatively good shape to

2838
02:26:22,700 --> 02:26:26,329
compress them so hopefully it won't take

2839
02:26:24,170 --> 02:26:27,710
too long to get it to the point where

2840
02:26:26,329 --> 02:26:29,959
it's usable but that's what we're gonna

2841
02:26:27,709 --> 02:26:31,039
have to start on tomorrow so hopefully

2842
02:26:29,959 --> 02:26:31,969
we'll make some sniffing you're headed

2843
02:26:31,040 --> 02:26:34,310
by here hope to see you back here for

2844
02:26:31,969 --> 02:26:35,239
that until then have fun programming

2845
02:26:34,309 --> 02:26:38,199
I'll see you everyone in the Internet

2846
02:26:35,239 --> 02:26:38,199
take a desert buddy

