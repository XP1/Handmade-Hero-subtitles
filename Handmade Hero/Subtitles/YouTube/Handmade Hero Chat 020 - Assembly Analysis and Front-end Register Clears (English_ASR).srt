1
00:00:02,879 --> 00:00:06,480
hello everyone and

2
00:00:04,318 --> 00:00:07,439
welcome back to handmade hero it's been

3
00:00:06,480 --> 00:00:09,679
a while

4
00:00:07,440 --> 00:00:11,040
and rather than jumping right back into

5
00:00:09,679 --> 00:00:12,798
programming i felt like that would

6
00:00:11,039 --> 00:00:14,558
probably be ill-advised since

7
00:00:12,798 --> 00:00:17,278
uh it's been a long time since we've

8
00:00:14,558 --> 00:00:19,198
done a stream we actually moved

9
00:00:17,278 --> 00:00:20,640
and so the streaming location is is

10
00:00:19,199 --> 00:00:22,880
completely different now i think

11
00:00:20,640 --> 00:00:26,000
everything's fine we did one test stream

12
00:00:22,879 --> 00:00:27,599
and the internet held up reasonably and

13
00:00:26,000 --> 00:00:28,399
the recording setup held up recently so

14
00:00:27,599 --> 00:00:30,800
we're

15
00:00:28,399 --> 00:00:32,479
hoping uh that that will be the case but

16
00:00:30,800 --> 00:00:34,558
we don't actually know

17
00:00:32,479 --> 00:00:36,799
so what we're gonna do today is a little

18
00:00:34,558 --> 00:00:38,479
bit lighter than full programming we're

19
00:00:36,799 --> 00:00:41,839
just going to take a look at some stuff

20
00:00:38,479 --> 00:00:41,839
that came up on twitter recently

21
00:00:41,920 --> 00:00:45,760
uh regarding how the front end of a cpu

22
00:00:45,119 --> 00:00:49,199
handles

23
00:00:45,759 --> 00:00:52,558
clears and i just wanted to kind of

24
00:00:49,200 --> 00:00:53,600
go through uh the basics of this sort of

25
00:00:52,558 --> 00:00:57,119
thing because

26
00:00:53,600 --> 00:00:58,239
it's a good less so than just

27
00:00:57,119 --> 00:01:01,358
understanding how

28
00:00:58,238 --> 00:01:03,358
an xor clear works on a cpu um

29
00:01:01,359 --> 00:01:04,400
because it is worth knowing that as a

30
00:01:03,359 --> 00:01:06,640
specific thing

31
00:01:04,400 --> 00:01:08,640
but also just understanding how to sort

32
00:01:06,640 --> 00:01:10,640
of like read the assembly

33
00:01:08,640 --> 00:01:11,680
at like a basic level that comes out of

34
00:01:10,640 --> 00:01:14,159
the compiler and

35
00:01:11,680 --> 00:01:15,280
understand whether or not it's producing

36
00:01:14,159 --> 00:01:17,118
something reasonable

37
00:01:15,280 --> 00:01:19,200
if you're trying to do like testing of

38
00:01:17,118 --> 00:01:22,400
what it's doing

39
00:01:19,200 --> 00:01:24,079
uh that can be kind of difficult and

40
00:01:22,400 --> 00:01:25,759
so i kind of wanted to walk through one

41
00:01:24,079 --> 00:01:29,039
of these just so you could

42
00:01:25,759 --> 00:01:32,719
see what's going on and

43
00:01:29,040 --> 00:01:36,159
get some experience with that process

44
00:01:32,719 --> 00:01:37,759
so if you uh i guess the easiest way to

45
00:01:36,159 --> 00:01:40,560
do it would be to like walk through

46
00:01:37,759 --> 00:01:41,599
what actually happened so there was some

47
00:01:40,560 --> 00:01:44,719
talk about

48
00:01:41,599 --> 00:01:46,078
uh clearing values to zero uh this was a

49
00:01:44,719 --> 00:01:48,319
separate thing

50
00:01:46,078 --> 00:01:49,919
uh regarding like language design stuff

51
00:01:48,319 --> 00:01:51,679
that i actually don't care about but the

52
00:01:49,920 --> 00:01:54,879
part about clearing to zero

53
00:01:51,680 --> 00:01:57,118
i do advocate i think zero clearing is

54
00:01:54,879 --> 00:01:58,959
probably one of the most

55
00:01:57,118 --> 00:02:00,159
under-appreciated things in computer

56
00:01:58,959 --> 00:02:03,359
programming um

57
00:02:00,159 --> 00:02:06,079
and in fact i highly advocate

58
00:02:03,359 --> 00:02:07,359
like what i would call z-i-i is the term

59
00:02:06,078 --> 00:02:09,280
that came up with a long time ago

60
00:02:07,359 --> 00:02:11,280
zero is initialization it's to kind of

61
00:02:09,280 --> 00:02:13,520
combat the raii

62
00:02:11,280 --> 00:02:15,039
phrase um which i don't think is

63
00:02:13,520 --> 00:02:16,400
valuable so resource acquisition is

64
00:02:15,039 --> 00:02:18,000
initialization i think is

65
00:02:16,400 --> 00:02:19,840
is a bad programming practice i don't

66
00:02:18,000 --> 00:02:20,479
think it's good i don't think it leads

67
00:02:19,840 --> 00:02:23,360
to good

68
00:02:20,479 --> 00:02:25,439
uh program structure but zii which is

69
00:02:23,360 --> 00:02:27,040
zero is initialization i think does lead

70
00:02:25,439 --> 00:02:29,439
to good program structure and it's

71
00:02:27,039 --> 00:02:30,239
it's actually not just about clearing to

72
00:02:29,439 --> 00:02:32,318
zero

73
00:02:30,239 --> 00:02:33,759
um clearing to zero is sort of a

74
00:02:32,318 --> 00:02:35,280
separate thing

75
00:02:33,759 --> 00:02:36,719
because you can imagine programs that

76
00:02:35,280 --> 00:02:38,560
are just written exactly the same way as

77
00:02:36,719 --> 00:02:40,719
they normally would be

78
00:02:38,560 --> 00:02:42,479
but you insert a zero clear before every

79
00:02:40,719 --> 00:02:44,239
use of a variable right so

80
00:02:42,479 --> 00:02:45,759
you just assume that if a variable is

81
00:02:44,239 --> 00:02:47,680
uninitialized it actually gets cleared

82
00:02:45,759 --> 00:02:49,199
to zero or something like that

83
00:02:47,680 --> 00:02:51,280
there have been languages that do that

84
00:02:49,199 --> 00:02:54,318
there are also like extensions

85
00:02:51,280 --> 00:02:55,598
to c plus do that i want to say i feel

86
00:02:54,318 --> 00:02:58,878
like microsoft

87
00:02:55,598 --> 00:03:01,518
actually introduced something like this

88
00:02:58,878 --> 00:03:04,158
in some research structured programming

89
00:03:01,519 --> 00:03:05,920
projects that they did

90
00:03:04,158 --> 00:03:08,158
they have divisions at microsoft that do

91
00:03:05,919 --> 00:03:12,158
things uh involving

92
00:03:08,158 --> 00:03:14,479
compiler and error uh research and such

93
00:03:12,158 --> 00:03:15,199
and they periodically do things like

94
00:03:14,479 --> 00:03:17,039
introduce

95
00:03:15,199 --> 00:03:18,479
static code analyzer things and they

96
00:03:17,039 --> 00:03:19,919
actually try to deploy them like at

97
00:03:18,479 --> 00:03:21,840
microsoft

98
00:03:19,919 --> 00:03:23,839
uh to try and find bugs and things that

99
00:03:21,840 --> 00:03:25,439
are like huge and unwieldy like you know

100
00:03:23,840 --> 00:03:27,598
microsoft word or something like you're

101
00:03:25,439 --> 00:03:31,199
talking about like legacy code base

102
00:03:27,598 --> 00:03:33,759
um hundreds of thousands

103
00:03:31,199 --> 00:03:36,238
thousands of developers millions of

104
00:03:33,759 --> 00:03:37,919
lines of code probably right

105
00:03:36,239 --> 00:03:39,840
and they try to deploy things and i

106
00:03:37,919 --> 00:03:41,598
think they had some things they deployed

107
00:03:39,840 --> 00:03:43,200
that in addition to stack last like

108
00:03:41,598 --> 00:03:46,798
clear to zero stuff

109
00:03:43,199 --> 00:03:49,839
i don't know so there's this is not like

110
00:03:46,799 --> 00:03:52,719
new like clearing to zero is old and

111
00:03:49,840 --> 00:03:55,438
not like anything that you haven't seen

112
00:03:52,719 --> 00:03:57,438
before if you've been around a while

113
00:03:55,438 --> 00:03:59,199
zii on the other hand is like actually

114
00:03:57,438 --> 00:04:01,199
pretty different

115
00:03:59,199 --> 00:04:02,639
i haven't seen it discussed much i don't

116
00:04:01,199 --> 00:04:04,079
know if it has a history or not it's

117
00:04:02,639 --> 00:04:06,479
just something i kind of came to on my

118
00:04:04,080 --> 00:04:09,760
own but i know that other people

119
00:04:06,479 --> 00:04:12,079
also kind of came to it on their own um

120
00:04:09,759 --> 00:04:13,039
at least something like it and the idea

121
00:04:12,080 --> 00:04:15,519
behind the iii

122
00:04:13,039 --> 00:04:16,478
is just that you try to structure your

123
00:04:15,519 --> 00:04:19,680
program

124
00:04:16,478 --> 00:04:21,758
so that zero is valid right and that's

125
00:04:19,680 --> 00:04:25,199
different than just clearing to zero so

126
00:04:21,759 --> 00:04:28,080
an example of how that would work is

127
00:04:25,199 --> 00:04:30,080
if you have only two valid states of

128
00:04:28,079 --> 00:04:31,758
your program let's say one where

129
00:04:30,079 --> 00:04:33,439
the value of a variable's supposed to be

130
00:04:31,759 --> 00:04:34,800
three and another where the value of the

131
00:04:33,439 --> 00:04:36,800
variable's supposed to be four

132
00:04:34,800 --> 00:04:38,560
you would actually change that program

133
00:04:36,800 --> 00:04:38,960
so that the correct values are zero and

134
00:04:38,560 --> 00:04:40,959
one

135
00:04:38,959 --> 00:04:42,319
instead of three and four and then you'd

136
00:04:40,959 --> 00:04:44,560
offset the three

137
00:04:42,319 --> 00:04:45,680
by two right so you'd add two to the

138
00:04:44,560 --> 00:04:46,800
variable so you get three or four

139
00:04:45,680 --> 00:04:50,240
depending on zero one

140
00:04:46,800 --> 00:04:53,280
that way no actual ish initialization

141
00:04:50,240 --> 00:04:55,759
is necessary for the default case

142
00:04:53,279 --> 00:04:56,399
so basically zii means transforming a

143
00:04:55,759 --> 00:04:58,960
program

144
00:04:56,399 --> 00:05:00,399
as much as possible into the state where

145
00:04:58,959 --> 00:05:03,279
all zeros

146
00:05:00,399 --> 00:05:04,879
is actually the like starting run

147
00:05:03,279 --> 00:05:08,719
condition

148
00:05:04,879 --> 00:05:10,000
rather than thinking of some random set

149
00:05:08,720 --> 00:05:12,080
of values that you want

150
00:05:10,000 --> 00:05:13,680
as the starting condition and trying to

151
00:05:12,079 --> 00:05:17,038
enforce that those actually get set

152
00:05:13,680 --> 00:05:20,079
right and so um

153
00:05:17,038 --> 00:05:23,439
again big proponent of this model it

154
00:05:20,079 --> 00:05:25,359
it has a lot of advantages

155
00:05:23,439 --> 00:05:27,918
number one it makes it much harder to

156
00:05:25,360 --> 00:05:29,680
introduce bugs uh but number two

157
00:05:27,918 --> 00:05:32,399
is that it's actually way more efficient

158
00:05:29,680 --> 00:05:34,400
because rather than having to

159
00:05:32,399 --> 00:05:35,758
keep all of this data on hand that you

160
00:05:34,399 --> 00:05:37,038
use for initialization that you're

161
00:05:35,759 --> 00:05:38,720
constantly like

162
00:05:37,038 --> 00:05:41,360
pulling into the cache to copy into

163
00:05:38,720 --> 00:05:43,039
things and having to like actually have

164
00:05:41,360 --> 00:05:44,800
structured pieces of code that go

165
00:05:43,038 --> 00:05:47,360
through and switch around

166
00:05:44,800 --> 00:05:48,079
to know how to initialize things you can

167
00:05:47,360 --> 00:05:50,240
literally just

168
00:05:48,079 --> 00:05:51,439
initialize like giant sections of your

169
00:05:50,240 --> 00:05:53,519
program

170
00:05:51,439 --> 00:05:54,639
simply by allocating and zeroing a block

171
00:05:53,519 --> 00:05:56,240
of memory

172
00:05:54,639 --> 00:05:57,840
which which is way more efficient

173
00:05:56,240 --> 00:05:58,319
especially because the first time you do

174
00:05:57,839 --> 00:05:59,519
it you

175
00:05:58,319 --> 00:06:01,039
actually don't pay for it because the

176
00:05:59,519 --> 00:06:02,879
operating system usually has to hand you

177
00:06:01,038 --> 00:06:05,519
a zeroed page to begin with

178
00:06:02,879 --> 00:06:06,959
since security concerns on modern os is

179
00:06:05,519 --> 00:06:08,000
means that they will zero the pages

180
00:06:06,959 --> 00:06:12,159
whether you want to

181
00:06:08,000 --> 00:06:14,879
them to or not for example on

182
00:06:12,160 --> 00:06:17,280
a pc there is really no way to allocate

183
00:06:14,879 --> 00:06:19,120
anything other than a xero page

184
00:06:17,279 --> 00:06:21,279
the operating system will never give you

185
00:06:19,120 --> 00:06:23,680
back anything other than a zero page

186
00:06:21,279 --> 00:06:25,758
so you can't actually get a performance

187
00:06:23,680 --> 00:06:28,720
win by not clearing memory

188
00:06:25,759 --> 00:06:30,400
the memory will be cleared and it will

189
00:06:28,720 --> 00:06:31,919
be cleared by the os and again the

190
00:06:30,399 --> 00:06:34,799
reason for that is because there are

191
00:06:31,918 --> 00:06:37,038
really significant security concerns

192
00:06:34,800 --> 00:06:38,079
to the operating system recycling memory

193
00:06:37,038 --> 00:06:40,000
because that memory

194
00:06:38,079 --> 00:06:42,240
wouldn't necessarily have come from your

195
00:06:40,000 --> 00:06:42,800
process or even if it did come from your

196
00:06:42,240 --> 00:06:44,879
process

197
00:06:42,800 --> 00:06:47,360
it doesn't really necessarily know

198
00:06:44,879 --> 00:06:49,279
whether it came from your process

199
00:06:47,360 --> 00:06:52,240
in a way that's safe to allow you to

200
00:06:49,279 --> 00:06:54,478
reuse it so when you call virtual alloc

201
00:06:52,240 --> 00:06:56,960
you always get memory that's zeroed

202
00:06:54,478 --> 00:06:58,159
that's just a specification of the os

203
00:06:56,959 --> 00:07:00,000
and the best of my knowledge there's no

204
00:06:58,160 --> 00:07:01,919
way to turn it off um

205
00:07:00,000 --> 00:07:04,639
you would have to be doing some kind of

206
00:07:01,918 --> 00:07:06,719
kernel bypass thing or something

207
00:07:04,639 --> 00:07:08,240
uh the average program that just runs on

208
00:07:06,720 --> 00:07:10,240
an end user's machine

209
00:07:08,240 --> 00:07:11,759
again to the best of my knowledge has no

210
00:07:10,240 --> 00:07:13,280
way without like

211
00:07:11,759 --> 00:07:15,759
special administrator privileges or

212
00:07:13,279 --> 00:07:19,918
something of actually getting

213
00:07:15,759 --> 00:07:19,919
a non-zeroed page so

214
00:07:23,360 --> 00:07:26,560
so what i wanted to talk about now with

215
00:07:24,959 --> 00:07:27,038
something sort of tangentially related

216
00:07:26,560 --> 00:07:28,879
to this

217
00:07:27,038 --> 00:07:30,159
that is just a programming model that i

218
00:07:28,879 --> 00:07:31,839
think is good you've seen me do it on

219
00:07:30,160 --> 00:07:33,919
handmade hero before

220
00:07:31,839 --> 00:07:35,119
um i actually do it even more now like

221
00:07:33,918 --> 00:07:37,279
in my

222
00:07:35,120 --> 00:07:38,800
in the past five years or so overhead

223
00:07:37,279 --> 00:07:40,559
course of handmade hero

224
00:07:38,800 --> 00:07:42,000
definitely some things have happened to

225
00:07:40,560 --> 00:07:43,918
my programming that

226
00:07:42,000 --> 00:07:45,038
uh i think make it better i mean you

227
00:07:43,918 --> 00:07:47,038
never really know whether you're getting

228
00:07:45,038 --> 00:07:49,759
better getting worse right but

229
00:07:47,038 --> 00:07:51,519
um and i actually apply zii a a lot more

230
00:07:49,759 --> 00:07:52,800
now than i did so like if anything i

231
00:07:51,519 --> 00:07:54,639
feel like it's on the rise

232
00:07:52,800 --> 00:07:56,240
in terms of the number of places where i

233
00:07:54,639 --> 00:07:57,598
find it useful

234
00:07:56,240 --> 00:07:59,280
um the other big one would be

235
00:07:57,598 --> 00:08:00,719
multi-threaded like i feel like i'm 10

236
00:07:59,279 --> 00:08:02,000
times better at multi-threaded now than

237
00:08:00,720 --> 00:08:03,360
i was starting handmade heroes so the

238
00:08:02,000 --> 00:08:04,720
multi-threading stuff in hammond hero is

239
00:08:03,360 --> 00:08:05,840
kind of crap but you know

240
00:08:04,720 --> 00:08:06,879
you're always learning there's nothing

241
00:08:05,839 --> 00:08:08,159
you can really do about that you're

242
00:08:06,879 --> 00:08:09,680
always going to look back at programs

243
00:08:08,160 --> 00:08:12,240
that you wrote and go wow this is

244
00:08:09,680 --> 00:08:13,519
garbage if you don't it's usually a bad

245
00:08:12,240 --> 00:08:15,280
sign because it means you've kind of

246
00:08:13,519 --> 00:08:16,799
stagnated right so i never really beat

247
00:08:15,279 --> 00:08:18,719
myself up over that sort of thing i just

248
00:08:16,800 --> 00:08:20,319
go look

249
00:08:18,720 --> 00:08:22,240
if i can't look back at a previous

250
00:08:20,319 --> 00:08:23,759
project and find something i did stupid

251
00:08:22,240 --> 00:08:26,000
then it must mean i stopped learning

252
00:08:23,759 --> 00:08:28,560
because no one's a perfect programmer

253
00:08:26,000 --> 00:08:30,160
and so if you look back and you say wow

254
00:08:28,560 --> 00:08:32,958
this is all great

255
00:08:30,160 --> 00:08:34,158
uh it's probably not a good sign right

256
00:08:32,958 --> 00:08:35,038
it probably means you haven't been

257
00:08:34,158 --> 00:08:38,240
pushing yourself

258
00:08:35,038 --> 00:08:40,000
very hard and that's usually not good so

259
00:08:38,240 --> 00:08:42,000
anyway um what i want to talk about

260
00:08:40,000 --> 00:08:44,080
today is tangential to this

261
00:08:42,000 --> 00:08:45,200
uh again uh i talked about this a little

262
00:08:44,080 --> 00:08:46,000
bit on the pre-stream but i'll talk

263
00:08:45,200 --> 00:08:49,600
about it again

264
00:08:46,000 --> 00:08:50,159
um on twitter a fellow named jesse meyer

265
00:08:49,600 --> 00:08:53,120
from

266
00:08:50,159 --> 00:08:53,838
nasa uh was responding to some of the

267
00:08:53,120 --> 00:08:56,080
stuff

268
00:08:53,839 --> 00:08:57,680
regarding zii with some stuff that

269
00:08:56,080 --> 00:09:00,399
doesn't really have anything to do

270
00:08:57,679 --> 00:09:01,838
with zii structurally it's just about

271
00:09:00,399 --> 00:09:04,159
looking at the performance

272
00:09:01,839 --> 00:09:06,720
something i said about clearing to xero

273
00:09:04,159 --> 00:09:08,958
being free in a lot of cases

274
00:09:06,720 --> 00:09:10,080
and i don't actually know why he was

275
00:09:08,958 --> 00:09:11,439
interested in this but he maybe just

276
00:09:10,080 --> 00:09:14,959
wanted to look into it a little bit

277
00:09:11,440 --> 00:09:16,000
and so he posted some test code he was

278
00:09:14,958 --> 00:09:18,239
trying to

279
00:09:16,000 --> 00:09:20,000
run and you can see it here it's

280
00:09:18,240 --> 00:09:23,039
basically a piece of code

281
00:09:20,000 --> 00:09:25,360
that creates a little fictitious

282
00:09:23,039 --> 00:09:26,879
matrix type here so four by four matrix

283
00:09:25,360 --> 00:09:29,200
uh homogeneous

284
00:09:26,879 --> 00:09:31,439
uh 3d matrix like the kind you would

285
00:09:29,200 --> 00:09:34,879
normally see in graphics programming

286
00:09:31,440 --> 00:09:35,440
and he then allocates a large number of

287
00:09:34,879 --> 00:09:38,958
these

288
00:09:35,440 --> 00:09:42,320
so you can see here that he's got um

289
00:09:38,958 --> 00:09:44,559
a what 10 million matrix alloc he just

290
00:09:42,320 --> 00:09:47,839
allocates a flat block of memory

291
00:09:44,559 --> 00:09:49,439
he does a clock and he then runs through

292
00:09:47,839 --> 00:09:52,240
the memory

293
00:09:49,440 --> 00:09:53,839
and he does some setting of it and he

294
00:09:52,240 --> 00:09:57,039
did it in two versions one

295
00:09:53,839 --> 00:09:57,440
has this zeroing commented out and one

296
00:09:57,039 --> 00:09:59,360
has

297
00:09:57,440 --> 00:10:00,560
it commented in you can actually see

298
00:09:59,360 --> 00:10:02,720
here uh it

299
00:10:00,559 --> 00:10:04,000
with the zero removed so he was trying

300
00:10:02,720 --> 00:10:07,200
both of these

301
00:10:04,000 --> 00:10:10,240
now um there's some things i want to say

302
00:10:07,200 --> 00:10:12,480
ahead of time about this because

303
00:10:10,240 --> 00:10:13,600
so if you look you can see on the

304
00:10:12,480 --> 00:10:17,039
command line here

305
00:10:13,600 --> 00:10:18,560
that jesse was using dos which means

306
00:10:17,039 --> 00:10:20,000
there's certain things that are not

307
00:10:18,559 --> 00:10:21,679
necessarily

308
00:10:20,000 --> 00:10:23,200
at play that would have been at play if

309
00:10:21,679 --> 00:10:24,958
he was using

310
00:10:23,200 --> 00:10:26,160
linux and i want to mention that real

311
00:10:24,958 --> 00:10:26,879
quickly because a lot of people don't

312
00:10:26,159 --> 00:10:29,439
know this

313
00:10:26,879 --> 00:10:30,879
um i've actually been bitten by this

314
00:10:29,440 --> 00:10:31,360
multiple times so i want to just point

315
00:10:30,879 --> 00:10:33,838
it out

316
00:10:31,360 --> 00:10:34,480
because we're coming from das it can be

317
00:10:33,839 --> 00:10:37,839
uh

318
00:10:34,480 --> 00:10:40,399
a little uh disquieting

319
00:10:37,839 --> 00:10:42,079
so the first thing i want to say is when

320
00:10:40,399 --> 00:10:45,519
you're doing a benchmark

321
00:10:42,078 --> 00:10:48,799
and it looks like this and you do

322
00:10:45,519 --> 00:10:52,799
a malloc of a large block of memory

323
00:10:48,799 --> 00:10:55,120
and then you do a timing run

324
00:10:52,799 --> 00:10:56,719
one of the problems that you will get is

325
00:10:55,120 --> 00:10:58,320
that if you actually structure your

326
00:10:56,720 --> 00:10:58,959
timing loop like this where you do a

327
00:10:58,320 --> 00:11:00,800
beginning

328
00:10:58,958 --> 00:11:02,958
end and then you do the whole thing

329
00:11:00,799 --> 00:11:05,759
inside the beginning and the end

330
00:11:02,958 --> 00:11:07,278
you can run into really significant

331
00:11:05,759 --> 00:11:09,360
performance penalties

332
00:11:07,278 --> 00:11:11,519
that are not accurate that don't reflect

333
00:11:09,360 --> 00:11:14,560
the actual performance

334
00:11:11,519 --> 00:11:15,039
of the routine inside because of the

335
00:11:14,559 --> 00:11:17,759
fact

336
00:11:15,039 --> 00:11:19,360
that the operating system is under no

337
00:11:17,759 --> 00:11:20,559
obligation to actually have mapped this

338
00:11:19,360 --> 00:11:22,560
memory yet

339
00:11:20,559 --> 00:11:23,679
so on windows usually what happens if

340
00:11:22,559 --> 00:11:25,039
you call malloc

341
00:11:23,679 --> 00:11:27,039
it's going to thunk through to virtual

342
00:11:25,039 --> 00:11:28,879
alloc for something this large

343
00:11:27,039 --> 00:11:31,519
and it's going to give you back a very

344
00:11:28,879 --> 00:11:35,519
large piece of actually committed memory

345
00:11:31,519 --> 00:11:35,759
usually um and then when you run through

346
00:11:35,519 --> 00:11:37,600
it

347
00:11:35,759 --> 00:11:39,439
you're not really page faulting

348
00:11:37,600 --> 00:11:41,278
necessarily right

349
00:11:39,440 --> 00:11:43,920
you're writing through that memory and

350
00:11:41,278 --> 00:11:46,958
it probably already got

351
00:11:43,919 --> 00:11:50,319
set up in the memory

352
00:11:46,958 --> 00:11:52,000
mapping tables so that's all fine

353
00:11:50,320 --> 00:11:53,519
and this was on windows so it was

354
00:11:52,000 --> 00:11:56,240
probably fine

355
00:11:53,519 --> 00:11:58,000
but again to avoid any kind of secret

356
00:11:56,240 --> 00:11:58,639
surprises while we're talking about this

357
00:11:58,000 --> 00:12:01,360
kind of

358
00:11:58,639 --> 00:12:02,799
profiling and this kind of looking at

359
00:12:01,360 --> 00:12:03,600
detailed information how the processor

360
00:12:02,799 --> 00:12:05,519
works

361
00:12:03,600 --> 00:12:07,040
it's important to remember that on linux

362
00:12:05,519 --> 00:12:09,039
that is not true

363
00:12:07,039 --> 00:12:10,879
so on linux if you allocate a very large

364
00:12:09,039 --> 00:12:14,159
block of memory

365
00:12:10,879 --> 00:12:14,720
um well i'm not exactly 100 sure all the

366
00:12:14,159 --> 00:12:16,958
things that

367
00:12:14,720 --> 00:12:19,040
malloc might do because malloc is

368
00:12:16,958 --> 00:12:21,599
actually a runtime library component

369
00:12:19,039 --> 00:12:22,480
but the equivalent to virtual alloc on

370
00:12:21,600 --> 00:12:25,600
linux is

371
00:12:22,480 --> 00:12:28,800
memp so it's mm map

372
00:12:25,600 --> 00:12:31,519
you can look it up in like the in the

373
00:12:28,799 --> 00:12:31,519
man pages

374
00:12:31,839 --> 00:12:36,959
mmap is exactly like virtual alloc in

375
00:12:35,200 --> 00:12:38,160
terms of what it does it sets up memory

376
00:12:36,958 --> 00:12:41,278
mapping tables

377
00:12:38,159 --> 00:12:43,919
for your process so that you can create

378
00:12:41,278 --> 00:12:46,240
pages of memory that you're going to use

379
00:12:43,919 --> 00:12:47,919
but it operates in a very different way

380
00:12:46,240 --> 00:12:50,639
than virtual alloc

381
00:12:47,919 --> 00:12:51,360
uh when you call it by default what it

382
00:12:50,639 --> 00:12:52,879
will do

383
00:12:51,360 --> 00:12:55,839
even with the kinds of settings that you

384
00:12:52,879 --> 00:12:57,838
would normally pass to virtual alloc

385
00:12:55,839 --> 00:12:59,839
is rather than ever actually allocating

386
00:12:57,839 --> 00:13:01,839
any memory for you

387
00:12:59,839 --> 00:13:03,120
when you ask it for something like this

388
00:13:01,839 --> 00:13:07,320
like 10 million

389
00:13:03,120 --> 00:13:10,639
matrices it will actually only allocate

390
00:13:07,320 --> 00:13:12,399
4096 uh bytes

391
00:13:10,639 --> 00:13:14,240
it actually won't even really allocate

392
00:13:12,399 --> 00:13:17,278
4000 isix bytes what i should say

393
00:13:14,240 --> 00:13:21,360
is we'll map a phantom page

394
00:13:17,278 --> 00:13:24,480
a zero page um of 4096 bytes

395
00:13:21,360 --> 00:13:28,000
it will point the complete range

396
00:13:24,480 --> 00:13:31,920
that you asked for at that one

397
00:13:28,000 --> 00:13:33,278
at that zero page and it will set it to

398
00:13:31,919 --> 00:13:36,479
copy on right

399
00:13:33,278 --> 00:13:39,360
so what it will do is when you actually

400
00:13:36,480 --> 00:13:40,320
touch a particular page of memory it

401
00:13:39,360 --> 00:13:43,759
will go

402
00:13:40,320 --> 00:13:46,879
and map an a real page

403
00:13:43,759 --> 00:13:49,439
at that time that you first touch it

404
00:13:46,879 --> 00:13:50,159
and when i say touch it i mean write to

405
00:13:49,440 --> 00:13:52,720
it

406
00:13:50,159 --> 00:13:54,958
so if all you ever did was read from it

407
00:13:52,720 --> 00:13:56,560
you would literally never map any memory

408
00:13:54,958 --> 00:14:01,278
so for example

409
00:13:56,559 --> 00:14:04,159
on windows if you virtual alloc

410
00:14:01,278 --> 00:14:05,360
16 gigabytes of memory with a commit

411
00:14:04,159 --> 00:14:07,919
like so if you actually

412
00:14:05,360 --> 00:14:08,879
you know use mem commit um not mem

413
00:14:07,919 --> 00:14:11,919
reserve you're actually

414
00:14:08,879 --> 00:14:14,559
saying hey i want to actually map this

415
00:14:11,919 --> 00:14:16,559
um it will actually allocate 16

416
00:14:14,559 --> 00:14:19,599
gigabytes of memory and if the machine

417
00:14:16,559 --> 00:14:20,159
doesn't have 16 gigabytes of virtual

418
00:14:19,600 --> 00:14:22,639
memory

419
00:14:20,159 --> 00:14:23,600
to spare because the page file isn't big

420
00:14:22,639 --> 00:14:26,879
enough or something

421
00:14:23,600 --> 00:14:29,519
that will just fail right

422
00:14:26,879 --> 00:14:30,480
on linux as far as i know and again i

423
00:14:29,519 --> 00:14:33,600
don't program links

424
00:14:30,480 --> 00:14:35,759
that often so you'll have to forgive me

425
00:14:33,600 --> 00:14:37,759
there may be certain configurations that

426
00:14:35,759 --> 00:14:39,039
interfere with this or certain behaviors

427
00:14:37,759 --> 00:14:42,159
that will change

428
00:14:39,039 --> 00:14:42,559
but generally speaking if you try to mem

429
00:14:42,159 --> 00:14:44,958
map

430
00:14:42,559 --> 00:14:46,719
16 gigabytes of memory on linux as far

431
00:14:44,958 --> 00:14:48,399
as i know it just works

432
00:14:46,720 --> 00:14:49,759
because it never actually allocates any

433
00:14:48,399 --> 00:14:51,919
memory so

434
00:14:49,759 --> 00:14:53,198
the only time that i would think that

435
00:14:51,919 --> 00:14:55,039
there could be any real

436
00:14:53,198 --> 00:14:57,759
way that that could fail meaning it

437
00:14:55,039 --> 00:14:59,439
would actually return like a zero

438
00:14:57,759 --> 00:15:01,120
is if you tried to allocate so much

439
00:14:59,440 --> 00:15:02,880
memory that it was outside like the

440
00:15:01,120 --> 00:15:05,120
bounds of mappable memory

441
00:15:02,879 --> 00:15:07,198
completely like it like if it if it blew

442
00:15:05,120 --> 00:15:08,560
past the 48-bit barrier or something

443
00:15:07,198 --> 00:15:11,359
like this

444
00:15:08,559 --> 00:15:12,399
where you were into a range where it was

445
00:15:11,360 --> 00:15:15,440
impossible to even

446
00:15:12,399 --> 00:15:17,679
map the memory but at no

447
00:15:15,440 --> 00:15:19,600
time as far as i know does linux

448
00:15:17,679 --> 00:15:22,879
actually look to see whether it

449
00:15:19,600 --> 00:15:24,639
actually has enough virtual memory left

450
00:15:22,879 --> 00:15:26,879
available to give you

451
00:15:24,639 --> 00:15:29,198
that memory it's only going to do that

452
00:15:26,879 --> 00:15:31,039
later when you actually write to it

453
00:15:29,198 --> 00:15:32,639
and whether or not this is a good idea i

454
00:15:31,039 --> 00:15:34,639
suppose is debatable i think it's

455
00:15:32,639 --> 00:15:36,000
horrible because i care a lot more about

456
00:15:34,639 --> 00:15:38,320
reliability

457
00:15:36,000 --> 00:15:39,759
than i care about like weird performance

458
00:15:38,320 --> 00:15:41,600
tricks like that where you're like

459
00:15:39,759 --> 00:15:41,919
getting a little bit extra in the case

460
00:15:41,600 --> 00:15:43,360
where

461
00:15:41,919 --> 00:15:45,519
an app doesn't really need the memory or

462
00:15:43,360 --> 00:15:50,159
something so

463
00:15:45,519 --> 00:15:52,799
i really don't like that but you know um

464
00:15:50,159 --> 00:15:54,480
linus and dave can fight that out

465
00:15:52,799 --> 00:15:56,240
because i'm not really experienced

466
00:15:54,480 --> 00:15:57,920
enough with os's to come down

467
00:15:56,240 --> 00:15:58,159
definitively on one side or the other as

468
00:15:57,919 --> 00:16:00,879
an

469
00:15:58,159 --> 00:16:02,559
as a system programmer or anything like

470
00:16:00,879 --> 00:16:03,198
that but as an app programmer i really

471
00:16:02,559 --> 00:16:05,599
don't like it

472
00:16:03,198 --> 00:16:06,799
suffice to say it happens so you need to

473
00:16:05,600 --> 00:16:10,240
be aware

474
00:16:06,799 --> 00:16:11,838
that that is occurring and even though

475
00:16:10,240 --> 00:16:13,919
in this particular case

476
00:16:11,839 --> 00:16:15,440
we don't care about the failure state

477
00:16:13,919 --> 00:16:17,519
for example

478
00:16:15,440 --> 00:16:18,480
the case where we're asking for more

479
00:16:17,519 --> 00:16:20,799
memory

480
00:16:18,480 --> 00:16:22,000
than the machine can actually provide in

481
00:16:20,799 --> 00:16:24,479
the mapping

482
00:16:22,000 --> 00:16:25,679
and uh if we were to actually touch them

483
00:16:24,480 --> 00:16:26,879
all we don't care about that because

484
00:16:25,679 --> 00:16:28,078
this is a test program we're not

485
00:16:26,879 --> 00:16:29,679
shipping it to an end user or anything

486
00:16:28,078 --> 00:16:31,198
like that so if it fails it fails we can

487
00:16:29,679 --> 00:16:33,519
work around it

488
00:16:31,198 --> 00:16:34,319
but what we do care about is the very

489
00:16:33,519 --> 00:16:37,360
odd

490
00:16:34,320 --> 00:16:38,720
access pattern and performance pattern

491
00:16:37,360 --> 00:16:41,278
that will occur

492
00:16:38,720 --> 00:16:43,440
the first time you attempt to write to

493
00:16:41,278 --> 00:16:44,958
the memory that you've allocated and so

494
00:16:43,440 --> 00:16:47,360
like i said

495
00:16:44,958 --> 00:16:49,278
in jesse's case he's using windows so

496
00:16:47,360 --> 00:16:51,360
probably this wasn't a problem

497
00:16:49,278 --> 00:16:53,519
for him and his timings probably weren't

498
00:16:51,360 --> 00:16:55,600
affected by this

499
00:16:53,519 --> 00:16:56,639
but if he had chosen to run this on

500
00:16:55,600 --> 00:16:58,399
linux

501
00:16:56,639 --> 00:16:59,680
he would have been and the reason for

502
00:16:58,399 --> 00:17:03,519
that is because

503
00:16:59,679 --> 00:17:06,558
rather than the time taken to

504
00:17:03,519 --> 00:17:09,838
pull these pages in and give them actual

505
00:17:06,558 --> 00:17:11,359
virtual memory addresses for real where

506
00:17:09,838 --> 00:17:15,198
where they're really mapped to real

507
00:17:11,359 --> 00:17:17,359
pages not to the xero page

508
00:17:15,199 --> 00:17:19,679
normally in windows this will probably

509
00:17:17,359 --> 00:17:21,359
happen on this line which is before we

510
00:17:19,679 --> 00:17:23,679
take the start clock

511
00:17:21,359 --> 00:17:25,678
but on linux it will happen inside this

512
00:17:23,679 --> 00:17:29,600
loop and it will specifically happen

513
00:17:25,679 --> 00:17:30,720
every time we cross one of those 4k page

514
00:17:29,599 --> 00:17:32,879
boundaries unless

515
00:17:30,720 --> 00:17:34,960
linux is set to a larger page size i

516
00:17:32,880 --> 00:17:36,559
assume linux can be set to 64k pages or

517
00:17:34,960 --> 00:17:37,919
two meg pages or something but i don't

518
00:17:36,558 --> 00:17:39,678
actually know again i'm not really a

519
00:17:37,919 --> 00:17:42,880
linux programmer so i don't

520
00:17:39,679 --> 00:17:44,400
no but point being usually 4k pages is a

521
00:17:42,880 --> 00:17:45,440
safe assumption on a lot of machines but

522
00:17:44,400 --> 00:17:48,559
it could be more

523
00:17:45,440 --> 00:17:51,200
every time you cross that page boundary

524
00:17:48,558 --> 00:17:52,079
you will actually page fault and this

525
00:17:51,200 --> 00:17:54,558
clocking

526
00:17:52,079 --> 00:17:55,359
here will actually measure the page

527
00:17:54,558 --> 00:17:58,480
faults

528
00:17:55,359 --> 00:18:01,759
so runs 1 through 25

529
00:17:58,480 --> 00:18:04,798
or run one through 24 i should say

530
00:18:01,759 --> 00:18:05,440
will be reasonable runs runs zero will

531
00:18:04,798 --> 00:18:08,480
actually be

532
00:18:05,440 --> 00:18:09,360
totally wrong and since this clocking

533
00:18:08,480 --> 00:18:12,720
here

534
00:18:09,359 --> 00:18:14,000
is actually taking that into account

535
00:18:12,720 --> 00:18:15,600
it's worth noting that when you're

536
00:18:14,000 --> 00:18:16,558
trying to do things like examine

537
00:18:15,599 --> 00:18:18,480
performance

538
00:18:16,558 --> 00:18:20,639
you really don't want to have that

539
00:18:18,480 --> 00:18:21,599
happen because page faults are so

540
00:18:20,640 --> 00:18:23,840
expensive

541
00:18:21,599 --> 00:18:25,759
that they may easily dominate the

542
00:18:23,839 --> 00:18:28,159
measurement time that you're actually

543
00:18:25,759 --> 00:18:29,839
seeing and the actual cost of the thing

544
00:18:28,160 --> 00:18:31,120
you were trying to measure may be a very

545
00:18:29,839 --> 00:18:33,759
small fraction of that

546
00:18:31,119 --> 00:18:34,879
leading you to believe that there's less

547
00:18:33,759 --> 00:18:37,038
effect

548
00:18:34,880 --> 00:18:38,320
on the time of the program than there

549
00:18:37,038 --> 00:18:40,480
really is

550
00:18:38,319 --> 00:18:43,038
so usually when you're doing this kind

551
00:18:40,480 --> 00:18:45,519
of timing what i would recommend

552
00:18:43,038 --> 00:18:48,798
depending on what you're actually doing

553
00:18:45,519 --> 00:18:52,400
there's two approaches you can take

554
00:18:48,798 --> 00:18:55,519
the wild west ride into town

555
00:18:52,400 --> 00:18:58,559
with guns blazing cowboy time

556
00:18:55,519 --> 00:18:59,839
fun fast way of doing it is you actually

557
00:18:58,558 --> 00:19:01,759
put the clocking

558
00:18:59,839 --> 00:19:03,599
and usually you use more accurate

559
00:19:01,759 --> 00:19:06,240
clocking than clock usually you would

560
00:19:03,599 --> 00:19:10,240
use query performance counter on windows

561
00:19:06,240 --> 00:19:12,798
um but you put that inside

562
00:19:10,240 --> 00:19:14,798
so inside the for loop you put the

563
00:19:12,798 --> 00:19:19,038
beginning end in here

564
00:19:14,798 --> 00:19:23,359
and what you do is you take the smallest

565
00:19:19,038 --> 00:19:26,720
time so you initialize outside the loop

566
00:19:23,359 --> 00:19:29,839
to like the lowest time is

567
00:19:26,720 --> 00:19:31,919
infinity right the highest value

568
00:19:29,839 --> 00:19:33,519
for the thing you're tracking then

569
00:19:31,919 --> 00:19:36,080
inside the loop here

570
00:19:33,519 --> 00:19:38,240
each time you do a begin then you do the

571
00:19:36,079 --> 00:19:41,038
4i over the entire end then an

572
00:19:38,240 --> 00:19:42,319
end you take the difference between the

573
00:19:41,038 --> 00:19:45,759
two of them

574
00:19:42,319 --> 00:19:46,480
and you if it's less than the previous

575
00:19:45,759 --> 00:19:49,839
minimum

576
00:19:46,480 --> 00:19:53,200
you use that one furthermore

577
00:19:49,839 --> 00:19:55,839
what some people do is they even put

578
00:19:53,200 --> 00:19:56,480
they they keep the it looking like this

579
00:19:55,839 --> 00:19:58,399
basically

580
00:19:56,480 --> 00:19:59,599
and they put the foreign loop around the

581
00:19:58,400 --> 00:20:01,440
outside but rather than

582
00:19:59,599 --> 00:20:03,439
being a four-eye loop they use a while

583
00:20:01,440 --> 00:20:07,279
loop and what they do

584
00:20:03,440 --> 00:20:09,600
is they do a four-eye of 25 runs or

585
00:20:07,279 --> 00:20:12,960
something like this

586
00:20:09,599 --> 00:20:15,199
and if it goes down from the if

587
00:20:12,960 --> 00:20:17,120
if inside here so i'm not explaining

588
00:20:15,200 --> 00:20:18,558
this well you put the clocks on the

589
00:20:17,119 --> 00:20:21,119
inside of this thing

590
00:20:18,558 --> 00:20:22,079
so you run it 25 times and you do the

591
00:20:21,119 --> 00:20:24,479
thing at the end

592
00:20:22,079 --> 00:20:26,079
inside here you do clock begin clock and

593
00:20:24,480 --> 00:20:28,159
you check the time if it's if it's

594
00:20:26,079 --> 00:20:30,240
lower you keep it but then you've got a

595
00:20:28,159 --> 00:20:33,520
while loop on the outside

596
00:20:30,240 --> 00:20:35,038
that says if during any of those 25 runs

597
00:20:33,519 --> 00:20:38,079
i found a new minimum

598
00:20:35,038 --> 00:20:40,798
run it again so basically that's just

599
00:20:38,079 --> 00:20:43,279
keeps running as long as it can get a

600
00:20:40,798 --> 00:20:45,359
lower time value it just keeps running

601
00:20:43,279 --> 00:20:46,480
and that's basically like a hunt for the

602
00:20:45,359 --> 00:20:50,639
minimum

603
00:20:46,480 --> 00:20:52,079
kind of routine a lot of times you want

604
00:20:50,640 --> 00:20:53,919
to use that's why i call it the wild

605
00:20:52,079 --> 00:20:55,119
west way because it's not a good

606
00:20:53,919 --> 00:20:57,280
measurement

607
00:20:55,119 --> 00:20:58,239
of what the routine will actually cost

608
00:20:57,279 --> 00:21:00,399
in practice

609
00:20:58,240 --> 00:21:02,000
because it's kind of the best case

610
00:21:00,400 --> 00:21:05,360
scenario it's finding the best case

611
00:21:02,000 --> 00:21:07,759
scenario of whatever this thing is but

612
00:21:05,359 --> 00:21:09,759
it's a good way to find out what's going

613
00:21:07,759 --> 00:21:11,038
on in the processor right because if

614
00:21:09,759 --> 00:21:12,720
you're trying to figure out what the

615
00:21:11,038 --> 00:21:14,798
minimum possible execution time is for

616
00:21:12,720 --> 00:21:16,400
something when all the stars align and

617
00:21:14,798 --> 00:21:17,519
the casters in the best possible state

618
00:21:16,400 --> 00:21:18,400
and the branch pictures are the best

619
00:21:17,519 --> 00:21:21,679
possible state

620
00:21:18,400 --> 00:21:24,080
and everyone is just happy and wonderful

621
00:21:21,679 --> 00:21:27,759
what is that time hunting for the

622
00:21:24,079 --> 00:21:27,759
minimum is the way that you get that

623
00:21:28,839 --> 00:21:31,839
right

624
00:21:33,919 --> 00:21:40,240
so in this particular case again this

625
00:21:37,359 --> 00:21:41,678
this uh this particular way of running

626
00:21:40,240 --> 00:21:46,000
it

627
00:21:41,679 --> 00:21:49,200
is particularly except susceptible

628
00:21:46,000 --> 00:21:51,759
to the page mapping problem and like i

629
00:21:49,200 --> 00:21:54,159
said the reason for that is just because

630
00:21:51,759 --> 00:21:56,879
since it's timing the entire set of runs

631
00:21:54,159 --> 00:21:59,360
rather than say hunting for a minimum

632
00:21:56,880 --> 00:22:00,720
i if you ran this on linux you would get

633
00:21:59,359 --> 00:22:02,798
totally screwed

634
00:22:00,720 --> 00:22:04,798
uh on windows you probably won't get

635
00:22:02,798 --> 00:22:08,720
that screwed right

636
00:22:04,798 --> 00:22:10,480
okay so uh as i said there's a second

637
00:22:08,720 --> 00:22:10,880
way that people often try to time these

638
00:22:10,480 --> 00:22:12,720
things

639
00:22:10,880 --> 00:22:14,159
and that is that you do basically the

640
00:22:12,720 --> 00:22:15,519
same thing i just said which is you put

641
00:22:14,159 --> 00:22:17,360
the clocks on the inside and then do a

642
00:22:15,519 --> 00:22:18,798
bunch of runs on the outside

643
00:22:17,359 --> 00:22:21,759
but uh and again you usually use a

644
00:22:18,798 --> 00:22:23,440
higher uh higher perf clock than clock

645
00:22:21,759 --> 00:22:25,200
uh if you're actually trying to time

646
00:22:23,440 --> 00:22:26,000
stuff precisely but point being whatever

647
00:22:25,200 --> 00:22:28,960
your timing function

648
00:22:26,000 --> 00:22:30,000
is and then what you do is you take a

649
00:22:28,960 --> 00:22:33,038
statistical

650
00:22:30,000 --> 00:22:34,640
look so you like histogram and make

651
00:22:33,038 --> 00:22:37,599
buckets for

652
00:22:34,640 --> 00:22:38,240
how like where did i see the times

653
00:22:37,599 --> 00:22:40,798
landing

654
00:22:38,240 --> 00:22:42,960
right and you maybe ignore some outliers

655
00:22:40,798 --> 00:22:45,200
like if the

656
00:22:42,960 --> 00:22:46,319
operating system decided to swap you out

657
00:22:45,200 --> 00:22:47,919
at that time so you're

658
00:22:46,319 --> 00:22:50,399
you know you you would count like a huge

659
00:22:47,919 --> 00:22:52,400
kernel transition in there for example

660
00:22:50,400 --> 00:22:54,240
uh that's an example of a place where

661
00:22:52,400 --> 00:22:56,880
you really don't want that

662
00:22:54,240 --> 00:22:57,679
to count that time against your average

663
00:22:56,880 --> 00:22:59,760
let's say

664
00:22:57,679 --> 00:23:01,120
um or if you find you get an extremely

665
00:22:59,759 --> 00:23:02,480
fast run and you've never seen

666
00:23:01,119 --> 00:23:04,079
it and you never see a run that fast

667
00:23:02,480 --> 00:23:05,759
again maybe again that was the case

668
00:23:04,079 --> 00:23:07,199
where all the stars aligned and that's

669
00:23:05,759 --> 00:23:10,079
really not a realistic

670
00:23:07,200 --> 00:23:11,360
expectation of what will happen so a lot

671
00:23:10,079 --> 00:23:13,199
of times what people will do is they'll

672
00:23:11,359 --> 00:23:15,599
look at a statistical breakdown

673
00:23:13,200 --> 00:23:17,360
right of what actually was happening in

674
00:23:15,599 --> 00:23:22,959
in in the routine

675
00:23:17,359 --> 00:23:25,439
and so that's one way you can um

676
00:23:22,960 --> 00:23:27,600
that's one way that you can go in and

677
00:23:25,440 --> 00:23:28,960
get another picture that's not just hunt

678
00:23:27,599 --> 00:23:31,359
for the fastest possible

679
00:23:28,960 --> 00:23:32,880
it's like try to get a picture for how

680
00:23:31,359 --> 00:23:35,759
this scatters around

681
00:23:32,880 --> 00:23:36,000
now in either case again it's never when

682
00:23:35,759 --> 00:23:38,240
you're

683
00:23:36,000 --> 00:23:39,759
creating a test case like this one we're

684
00:23:38,240 --> 00:23:41,759
usually investigating

685
00:23:39,759 --> 00:23:43,679
something specific about the processor

686
00:23:41,759 --> 00:23:45,359
so i would probably recommend the hunt

687
00:23:43,679 --> 00:23:46,240
for the minimum if we were going because

688
00:23:45,359 --> 00:23:47,759
because again

689
00:23:46,240 --> 00:23:49,120
what jesse was trying to do here was

690
00:23:47,759 --> 00:23:51,038
investigate something the processor was

691
00:23:49,119 --> 00:23:52,719
doing he's not really trying to figure

692
00:23:51,038 --> 00:23:53,839
out like what this routine does in the

693
00:23:52,720 --> 00:23:56,079
real world right

694
00:23:53,839 --> 00:23:57,839
so taking a statistical breakdown of it

695
00:23:56,079 --> 00:24:00,000
doesn't make a lot of sense

696
00:23:57,839 --> 00:24:01,839
because it's already a synthetic test

697
00:24:00,000 --> 00:24:02,880
case and we're not really trying to

698
00:24:01,839 --> 00:24:04,798
figure out

699
00:24:02,880 --> 00:24:06,559
anything about how it actually would

700
00:24:04,798 --> 00:24:07,440
behave in the real world what we're

701
00:24:06,558 --> 00:24:08,960
trying to do

702
00:24:07,440 --> 00:24:10,880
is investigate something about the

703
00:24:08,960 --> 00:24:12,400
processor so hunt for the minimum makes

704
00:24:10,880 --> 00:24:14,000
a lot more sense in this case and that's

705
00:24:12,400 --> 00:24:16,159
probably what you would do

706
00:24:14,000 --> 00:24:18,079
if you were going to upgrade this to a

707
00:24:16,159 --> 00:24:20,880
little bit of a stronger

708
00:24:18,079 --> 00:24:22,558
uh analysis right for um looking at what

709
00:24:20,880 --> 00:24:24,799
the processor does

710
00:24:22,558 --> 00:24:26,079
probably not statistical breakdown uh

711
00:24:24,798 --> 00:24:26,639
unless you were trying to capture

712
00:24:26,079 --> 00:24:27,599
something else

713
00:24:26,640 --> 00:24:28,880
if you're trying to capture sister

714
00:24:27,599 --> 00:24:30,079
breakdown you probably need a more

715
00:24:28,880 --> 00:24:32,480
complex test case

716
00:24:30,079 --> 00:24:33,678
because this is so compact and so

717
00:24:32,480 --> 00:24:35,360
straightforward

718
00:24:33,679 --> 00:24:36,880
that it's unlikely that you're going to

719
00:24:35,359 --> 00:24:37,918
capture a lot of weird things about

720
00:24:36,880 --> 00:24:41,520
cache behavior

721
00:24:37,919 --> 00:24:43,360
or branch prediction uh

722
00:24:41,519 --> 00:24:44,960
or hyper threading or whatever like

723
00:24:43,359 --> 00:24:47,038
we're just not going to get that

724
00:24:44,960 --> 00:24:48,400
here so statistical breakdown doesn't

725
00:24:47,038 --> 00:24:49,759
make a whole lot of sense to me but you

726
00:24:48,400 --> 00:24:52,960
know

727
00:24:49,759 --> 00:24:54,798
everyone has their preference okay

728
00:24:52,960 --> 00:24:56,240
so with all of that preamble out of the

729
00:24:54,798 --> 00:24:57,759
way which again

730
00:24:56,240 --> 00:24:59,120
all of these digressions are intentional

731
00:24:57,759 --> 00:25:00,640
because i'm just trying to give you a

732
00:24:59,119 --> 00:25:01,839
full uh

733
00:25:00,640 --> 00:25:03,759
the whole only reason i'm doing this

734
00:25:01,839 --> 00:25:05,918
today is just to give people

735
00:25:03,759 --> 00:25:07,119
a firm understanding to the extent that

736
00:25:05,919 --> 00:25:09,038
they can get one

737
00:25:07,119 --> 00:25:10,959
about how this kind of process works and

738
00:25:09,038 --> 00:25:13,038
what to be aware of so

739
00:25:10,960 --> 00:25:14,400
again like maybe this is sufficient

740
00:25:13,038 --> 00:25:15,919
what's already written here

741
00:25:14,400 --> 00:25:17,440
maybe it's not especially if you're

742
00:25:15,919 --> 00:25:18,799
running on linux it would be bad on

743
00:25:17,440 --> 00:25:20,640
windows maybe it's fine

744
00:25:18,798 --> 00:25:22,000
if it's not fine you may want to move

745
00:25:20,640 --> 00:25:23,120
these on the inside

746
00:25:22,000 --> 00:25:24,720
you probably want to switch to higher

747
00:25:23,119 --> 00:25:26,158
resolution timers a lot of these things

748
00:25:24,720 --> 00:25:27,600
are important for investigating cpu

749
00:25:26,159 --> 00:25:28,400
performance because cp performance is

750
00:25:27,599 --> 00:25:31,278
subtle

751
00:25:28,400 --> 00:25:32,720
right so you you need to be careful

752
00:25:31,278 --> 00:25:33,919
about how you do it because even if

753
00:25:32,720 --> 00:25:35,038
you're just trying to get

754
00:25:33,919 --> 00:25:36,799
a vague understanding of what's

755
00:25:35,038 --> 00:25:38,240
happening there's so many things at play

756
00:25:36,798 --> 00:25:39,038
that sometimes you have to get a little

757
00:25:38,240 --> 00:25:42,400
bit more

758
00:25:39,038 --> 00:25:44,158
precise so it's hard to say but

759
00:25:42,400 --> 00:25:46,559
this is sufficient for our purposes for

760
00:25:44,159 --> 00:25:49,520
now what i wanted to go through

761
00:25:46,558 --> 00:25:51,440
i tried to recreate this routine in god

762
00:25:49,519 --> 00:25:54,079
bolt so you can see it

763
00:25:51,440 --> 00:25:55,919
here i've not compiled it so i don't

764
00:25:54,079 --> 00:25:57,918
know if i have a typo or something so

765
00:25:55,919 --> 00:26:00,480
what i'd like to do

766
00:25:57,919 --> 00:26:01,200
is i'd like to just compile this really

767
00:26:00,480 --> 00:26:03,440
quick

768
00:26:01,200 --> 00:26:04,960
on the actual machine to make sure that

769
00:26:03,440 --> 00:26:06,320
i didn't screw it up right because i

770
00:26:04,960 --> 00:26:08,960
just kind of typed it in

771
00:26:06,319 --> 00:26:09,759
and i wasn't particularly careful or

772
00:26:08,960 --> 00:26:12,079
anything

773
00:26:09,759 --> 00:26:14,480
so i want to make sure that i don't have

774
00:26:12,079 --> 00:26:15,759
any kind of like stupid error in there

775
00:26:14,480 --> 00:26:19,599
that's going to make it

776
00:26:15,759 --> 00:26:21,839
um so that i don't uh let's just uh call

777
00:26:19,599 --> 00:26:21,839
this

778
00:26:22,480 --> 00:26:27,599
xor clear or something um i don't want

779
00:26:26,319 --> 00:26:29,278
to have anything in there that's really

780
00:26:27,599 --> 00:26:31,038
stupid that's going to make it so that

781
00:26:29,278 --> 00:26:32,640
we're looking at assembly code that's

782
00:26:31,038 --> 00:26:33,359
actually totally wrong and doesn't

783
00:26:32,640 --> 00:26:36,320
matter

784
00:26:33,359 --> 00:26:38,000
right um because if i screwed up the

785
00:26:36,319 --> 00:26:39,599
code and it doesn't actually work then

786
00:26:38,000 --> 00:26:41,519
the assembly that we're looking at isn't

787
00:26:39,599 --> 00:26:42,639
a reflection of anything at all it's

788
00:26:41,519 --> 00:26:44,480
just fictitious

789
00:26:42,640 --> 00:26:46,080
and wouldn't matter so i just want to

790
00:26:44,480 --> 00:26:48,960
run it and make sure you know

791
00:26:46,079 --> 00:26:50,639
get rid of any crash bugs get rid of any

792
00:26:48,960 --> 00:26:51,679
if it prints out completely wrong values

793
00:26:50,640 --> 00:26:53,200
or something right

794
00:26:51,679 --> 00:26:55,278
so i just want to go ahead and compile

795
00:26:53,200 --> 00:26:56,640
this here and run it and see what

796
00:26:55,278 --> 00:27:00,000
happens

797
00:26:56,640 --> 00:27:01,600
just so again i can get a feel for

798
00:27:00,000 --> 00:27:03,679
what's actually going on and make sure

799
00:27:01,599 --> 00:27:05,278
there's no obvious bugs

800
00:27:03,679 --> 00:27:07,038
value check is one which is what it

801
00:27:05,278 --> 00:27:10,000
should be so that's good and if i

802
00:27:07,038 --> 00:27:14,400
actually go in here and do an o2 on this

803
00:27:10,000 --> 00:27:17,759
um it should get faster and it does

804
00:27:14,400 --> 00:27:19,759
uh so i think we're good like i think

805
00:27:17,759 --> 00:27:20,960
i probably didn't screw it up too bad

806
00:27:19,759 --> 00:27:22,798
and

807
00:27:20,960 --> 00:27:24,079
that's really what would matter in this

808
00:27:22,798 --> 00:27:26,240
case

809
00:27:24,079 --> 00:27:27,519
so let's pop back over here because what

810
00:27:26,240 --> 00:27:30,079
i wanted to go over was

811
00:27:27,519 --> 00:27:31,119
nothing in particular about actually

812
00:27:30,079 --> 00:27:34,000
running this code

813
00:27:31,119 --> 00:27:35,199
i want to go over the assembly language

814
00:27:34,000 --> 00:27:37,519
and so what i'm going to do

815
00:27:35,200 --> 00:27:39,519
is i've opened up godbolt here and i've

816
00:27:37,519 --> 00:27:42,639
got

817
00:27:39,519 --> 00:27:43,200
that code basically exactly as jesse

818
00:27:42,640 --> 00:27:45,360
wrote it

819
00:27:43,200 --> 00:27:46,880
uh it's more or less the same i i maybe

820
00:27:45,359 --> 00:27:48,240
changed some names and wrote it in the

821
00:27:46,880 --> 00:27:49,840
style you're used to seeing on handmade

822
00:27:48,240 --> 00:27:51,440
hero but other than that

823
00:27:49,839 --> 00:27:53,918
it's basically the exact same code i

824
00:27:51,440 --> 00:27:55,120
also included xmm and trin here because

825
00:27:53,919 --> 00:27:57,679
i'm going to want to play with intrinsic

826
00:27:55,119 --> 00:27:59,278
a little bit later on so i just put in

827
00:27:57,679 --> 00:28:00,798
um the ability for us to access the

828
00:27:59,278 --> 00:28:02,480
intrinsics as well but otherwise it's

829
00:28:00,798 --> 00:28:04,398
basically the same code

830
00:28:02,480 --> 00:28:06,880
and what i'm going to do is just make

831
00:28:04,398 --> 00:28:08,959
sure that i have both compilers here

832
00:28:06,880 --> 00:28:10,799
um i don't really remember how to do

833
00:28:08,960 --> 00:28:12,798
this exactly yeah there we go

834
00:28:10,798 --> 00:28:14,240
i always have a little trouble the

835
00:28:12,798 --> 00:28:17,440
interface of godbolt sometimes

836
00:28:14,240 --> 00:28:21,038
once i get it set up it's it's nice

837
00:28:17,440 --> 00:28:24,320
um so i'm just going to pick an msvc

838
00:28:21,038 --> 00:28:25,919
with an o2 here um and

839
00:28:24,319 --> 00:28:27,678
so that we can look at both pieces of

840
00:28:25,919 --> 00:28:30,240
code and

841
00:28:27,679 --> 00:28:30,798
this way we have uh yeah you can kind of

842
00:28:30,240 --> 00:28:33,200
see here

843
00:28:30,798 --> 00:28:34,960
this way we've got an example of what

844
00:28:33,200 --> 00:28:36,080
clang will output when we tell it to

845
00:28:34,960 --> 00:28:39,679
optimize

846
00:28:36,079 --> 00:28:42,960
and we have an example of what msvc

847
00:28:39,679 --> 00:28:46,399
will output when we tell it to optimize

848
00:28:42,960 --> 00:28:46,399
as well and

849
00:28:55,759 --> 00:29:01,440
just looking at this i mean

850
00:28:59,359 --> 00:29:04,639
this this tends to be what i see and

851
00:29:01,440 --> 00:29:08,000
it's you know it's weird

852
00:29:04,640 --> 00:29:11,200
um i i don't know like maybe

853
00:29:08,000 --> 00:29:12,000
i just always happen to drop in and

854
00:29:11,200 --> 00:29:14,159
inspect assembly

855
00:29:12,000 --> 00:29:15,519
at times this happens but just whenever

856
00:29:14,159 --> 00:29:18,960
i look at assembly

857
00:29:15,519 --> 00:29:20,960
of scalar code or like code that the

858
00:29:18,960 --> 00:29:22,798
compiler was supposed to make for a

859
00:29:20,960 --> 00:29:26,079
simple routine

860
00:29:22,798 --> 00:29:29,278
um msvc always seems

861
00:29:26,079 --> 00:29:32,000
to totally beat uh

862
00:29:29,278 --> 00:29:33,679
clang from what it looks like like it

863
00:29:32,000 --> 00:29:36,319
just always look

864
00:29:33,679 --> 00:29:37,679
msvc's optimizing characters always

865
00:29:36,319 --> 00:29:41,038
outputs like better stuff

866
00:29:37,679 --> 00:29:42,880
for my code and then the opposite is

867
00:29:41,038 --> 00:29:45,119
true anytime they're intrinsic so

868
00:29:42,880 --> 00:29:46,000
anytime i write like heavy intrinsic

869
00:29:45,119 --> 00:29:47,519
code

870
00:29:46,000 --> 00:29:49,679
not any time i guess that's not true but

871
00:29:47,519 --> 00:29:51,679
a lot of times when i write heavy

872
00:29:49,679 --> 00:29:53,759
intrinsic code it seems like clang

873
00:29:51,679 --> 00:29:54,960
actually does better i don't know these

874
00:29:53,759 --> 00:29:58,798
may be

875
00:29:54,960 --> 00:29:58,798
a little bit um

876
00:29:59,519 --> 00:30:04,158
again just like selection randomness

877
00:30:02,398 --> 00:30:06,879
bias like i happen to see

878
00:30:04,159 --> 00:30:08,399
certain times and not um but it's just

879
00:30:06,880 --> 00:30:10,880
weird and when i look at this

880
00:30:08,398 --> 00:30:12,558
you know you can kind of see um even

881
00:30:10,880 --> 00:30:15,840
just from the start

882
00:30:12,558 --> 00:30:19,278
what you can see here is that um

883
00:30:15,839 --> 00:30:22,879
when when it's actually generating this

884
00:30:19,278 --> 00:30:25,919
code like it looks like

885
00:30:22,880 --> 00:30:28,880
it looks like msvc just

886
00:30:25,919 --> 00:30:30,240
totally crushed it like it looks like

887
00:30:28,880 --> 00:30:33,520
it's just using a rep

888
00:30:30,240 --> 00:30:36,159
to move these guys and i mean i feel

889
00:30:33,519 --> 00:30:39,519
like that's exactly what you would want

890
00:30:36,159 --> 00:30:41,200
most of the time you know maybe i'm

891
00:30:39,519 --> 00:30:42,639
wrong about that but i feel like that

892
00:30:41,200 --> 00:30:45,600
would absolutely destroy

893
00:30:42,640 --> 00:30:47,919
this nonsense which doesn't even look

894
00:30:45,599 --> 00:30:50,959
like this doesn't even look right

895
00:30:47,919 --> 00:30:53,600
just even if you were going to do

896
00:30:50,960 --> 00:30:55,600
like i'm going to walk through both the

897
00:30:53,599 --> 00:30:57,839
assemblies but

898
00:30:55,599 --> 00:30:58,959
this just looks nuts i have no idea why

899
00:30:57,839 --> 00:31:01,918
you would ever do this

900
00:30:58,960 --> 00:31:04,558
and again i'm not really an optimization

901
00:31:01,919 --> 00:31:06,159
guy so like

902
00:31:04,558 --> 00:31:07,918
my opinion of whether this looks nuts or

903
00:31:06,159 --> 00:31:09,278
not is maybe not the most informative

904
00:31:07,919 --> 00:31:13,919
but i mean just like

905
00:31:09,278 --> 00:31:17,200
at first blush i can't see why

906
00:31:13,919 --> 00:31:19,120
you would ever want anything like this

907
00:31:17,200 --> 00:31:22,720
code for this loop

908
00:31:19,119 --> 00:31:24,719
it's just plain nuts whereas this

909
00:31:22,720 --> 00:31:26,240
looks exactly like something i might

910
00:31:24,720 --> 00:31:30,319
want for this loop

911
00:31:26,240 --> 00:31:31,919
um so i i don't know like

912
00:31:30,319 --> 00:31:34,558
i i don't know what to make of that

913
00:31:31,919 --> 00:31:36,559
other than to say that it kind of

914
00:31:34,558 --> 00:31:37,678
reinforces my opinion that clang has a

915
00:31:36,558 --> 00:31:40,398
lot of weird

916
00:31:37,679 --> 00:31:42,320
bad cases hanging around in it that that

917
00:31:40,398 --> 00:31:45,359
just don't seem to happen

918
00:31:42,319 --> 00:31:46,639
um for msvc and sometimes like i said

919
00:31:45,359 --> 00:31:48,079
in certain circumstances it seems like

920
00:31:46,640 --> 00:31:49,919
clang has a much more aggressive

921
00:31:48,079 --> 00:31:51,839
optimizer that will do some really cool

922
00:31:49,919 --> 00:31:54,240
stuff in certain circumstances

923
00:31:51,839 --> 00:31:55,439
but on the average it seems to have

924
00:31:54,240 --> 00:31:58,240
really dumb

925
00:31:55,440 --> 00:31:59,038
problems uh that it that it always

926
00:31:58,240 --> 00:32:01,919
screws up

927
00:31:59,038 --> 00:32:03,359
right and this is an example of that so

928
00:32:01,919 --> 00:32:04,720
let's walk through what this code is

929
00:32:03,359 --> 00:32:06,798
actually doing

930
00:32:04,720 --> 00:32:08,240
um before i start talking about xor

931
00:32:06,798 --> 00:32:09,679
clears or any of those

932
00:32:08,240 --> 00:32:11,759
sorts of things you can see we don't do

933
00:32:09,679 --> 00:32:15,440
any clearing here all we're doing is

934
00:32:11,759 --> 00:32:18,879
basically a glorified memsat

935
00:32:15,440 --> 00:32:19,519
um so inside the loop and what you can

936
00:32:18,880 --> 00:32:21,600
see here

937
00:32:19,519 --> 00:32:22,880
is in if you're not very familiar with

938
00:32:21,599 --> 00:32:26,839
assembly language

939
00:32:22,880 --> 00:32:28,320
then the way to think about it is just

940
00:32:26,839 --> 00:32:31,199
uh

941
00:32:28,319 --> 00:32:33,119
the innermost loop of your code is

942
00:32:31,200 --> 00:32:35,120
usually pretty easy to identify in god

943
00:32:33,119 --> 00:32:36,719
bolt it's especially easy because you

944
00:32:35,119 --> 00:32:37,359
can actually move over it and it will

945
00:32:36,720 --> 00:32:39,440
show you

946
00:32:37,359 --> 00:32:40,879
and it also has them kind of color coded

947
00:32:39,440 --> 00:32:42,399
right so you can see when i move my

948
00:32:40,880 --> 00:32:43,440
cursor over here it like highlights this

949
00:32:42,398 --> 00:32:44,639
and when i move my cursor over here it

950
00:32:43,440 --> 00:32:47,278
highlights that

951
00:32:44,640 --> 00:32:47,840
so you can actually see the body of the

952
00:32:47,278 --> 00:32:50,319
loop

953
00:32:47,839 --> 00:32:51,839
in question um and you can even see

954
00:32:50,319 --> 00:32:53,839
where the criteria for the loop are so

955
00:32:51,839 --> 00:32:56,240
you see as i move over that you can see

956
00:32:53,839 --> 00:32:58,639
that it's highlighting this uh piece of

957
00:32:56,240 --> 00:33:00,720
code here right

958
00:32:58,640 --> 00:33:02,240
and so one of the nice things about

959
00:33:00,720 --> 00:33:03,120
godbolt and the reason i often tell

960
00:33:02,240 --> 00:33:04,240
people when they're learning assembly

961
00:33:03,119 --> 00:33:07,359
language to please and

962
00:33:04,240 --> 00:33:08,399
um take a look at it it's a very nice

963
00:33:07,359 --> 00:33:09,278
tool for this

964
00:33:08,398 --> 00:33:11,599
and it's the kind of thing that you

965
00:33:09,278 --> 00:33:13,759
would want built into your editor uh and

966
00:33:11,599 --> 00:33:16,240
so they've you know it's too bad it's

967
00:33:13,759 --> 00:33:18,398
not built into most editors but it's not

968
00:33:16,240 --> 00:33:20,319
um and so when you're actually looking

969
00:33:18,398 --> 00:33:21,599
at the code here it just helps because

970
00:33:20,319 --> 00:33:23,519
if you don't know how to read a semi

971
00:33:21,599 --> 00:33:25,678
language and you just had

972
00:33:23,519 --> 00:33:26,960
um like especially on this side where

973
00:33:25,679 --> 00:33:29,038
there's not labels

974
00:33:26,960 --> 00:33:30,240
in this one um because of the way that

975
00:33:29,038 --> 00:33:32,319
it turns into a rep

976
00:33:30,240 --> 00:33:33,919
uh but you look at it as just a giant

977
00:33:32,319 --> 00:33:35,359
wall of assembly and if you're not very

978
00:33:33,919 --> 00:33:36,559
familiar with how to read assembly that

979
00:33:35,359 --> 00:33:38,558
can be very

980
00:33:36,558 --> 00:33:40,480
daunting and it can be hard for you to

981
00:33:38,558 --> 00:33:43,119
figure out where you're looking at and

982
00:33:40,480 --> 00:33:44,079
get any kind of foothold on it but when

983
00:33:43,119 --> 00:33:45,918
you have

984
00:33:44,079 --> 00:33:47,839
godbolt you can just move over it and

985
00:33:45,919 --> 00:33:51,278
see where it's coming from

986
00:33:47,839 --> 00:33:53,918
which makes it a lot easier for you so

987
00:33:51,278 --> 00:33:54,480
um when we actually look at this code we

988
00:33:53,919 --> 00:33:57,200
could see

989
00:33:54,480 --> 00:33:57,839
what it's doing and let's go ahead and

990
00:33:57,200 --> 00:34:00,399
walk through

991
00:33:57,839 --> 00:34:01,038
what's actually happening so as you can

992
00:34:00,398 --> 00:34:03,759
see

993
00:34:01,038 --> 00:34:05,038
this particular for loop here has

994
00:34:03,759 --> 00:34:08,480
evaluated to

995
00:34:05,038 --> 00:34:12,320
effectively this piece of code so

996
00:34:08,480 --> 00:34:15,440
this lbb02 label

997
00:34:12,320 --> 00:34:16,559
is matched with this jump and what

998
00:34:15,440 --> 00:34:18,240
that's doing is

999
00:34:16,559 --> 00:34:19,759
that is what is creating the loop so

1000
00:34:18,239 --> 00:34:22,000
remember for those of you who are really

1001
00:34:19,760 --> 00:34:24,639
new to assembly language

1002
00:34:22,000 --> 00:34:25,119
for loops while loops do loops all of

1003
00:34:24,639 --> 00:34:27,519
that

1004
00:34:25,119 --> 00:34:28,240
stuff doesn't actually exist in the

1005
00:34:27,519 --> 00:34:31,358
processor at

1006
00:34:28,239 --> 00:34:32,239
all those are just shorthand notations

1007
00:34:31,358 --> 00:34:35,759
for

1008
00:34:32,239 --> 00:34:38,878
tests and go go-to's so basically like

1009
00:34:35,760 --> 00:34:41,760
um you can think of all

1010
00:34:38,878 --> 00:34:42,000
loops in c as getting rewritten first as

1011
00:34:41,760 --> 00:34:44,079
an

1012
00:34:42,000 --> 00:34:45,918
if and a go-to and then they get

1013
00:34:44,079 --> 00:34:47,119
translated into assembly language

1014
00:34:45,918 --> 00:34:48,799
is a good way to think about it because

1015
00:34:47,119 --> 00:34:49,838
that's what's actually going to happen

1016
00:34:48,800 --> 00:34:51,519
on the processor

1017
00:34:49,838 --> 00:34:53,119
so what you can see here is that's

1018
00:34:51,519 --> 00:34:55,759
exactly what occurs

1019
00:34:53,119 --> 00:34:56,559
this cmp instruction is doing a

1020
00:34:55,760 --> 00:34:58,160
comparison

1021
00:34:56,559 --> 00:34:59,679
it's doing a comparison between a

1022
00:34:58,159 --> 00:35:01,838
register rax

1023
00:34:59,679 --> 00:35:03,358
which happens to be where we are in our

1024
00:35:01,838 --> 00:35:06,000
copy

1025
00:35:03,358 --> 00:35:06,639
and this value which is how many things

1026
00:35:06,000 --> 00:35:08,320
in total

1027
00:35:06,639 --> 00:35:10,078
it was going to try and copy i mean it's

1028
00:35:08,320 --> 00:35:14,079
not how many things it's like how many

1029
00:35:10,079 --> 00:35:15,920
bytes basically um it was going to copy

1030
00:35:14,079 --> 00:35:17,839
and after it does that comparison it

1031
00:35:15,920 --> 00:35:20,240
does a jump and the jump

1032
00:35:17,838 --> 00:35:22,480
is basically saying look if this

1033
00:35:20,239 --> 00:35:23,679
comparison it's a jne which means jump

1034
00:35:22,480 --> 00:35:26,079
not equal to

1035
00:35:23,679 --> 00:35:27,199
it's basically saying look the previous

1036
00:35:26,079 --> 00:35:29,680
comparison you did

1037
00:35:27,199 --> 00:35:31,039
is going to set a bit in the processor

1038
00:35:29,679 --> 00:35:32,000
that says whether or not these things

1039
00:35:31,039 --> 00:35:33,358
were equal

1040
00:35:32,000 --> 00:35:35,039
and then we're going to jump if they're

1041
00:35:33,358 --> 00:35:38,000
not equal and so

1042
00:35:35,039 --> 00:35:39,119
what this does is it says here is a you

1043
00:35:38,000 --> 00:35:41,280
know what the compiler did is it

1044
00:35:39,119 --> 00:35:43,519
precomputed this value

1045
00:35:41,280 --> 00:35:44,880
which is if we go and actually do the

1046
00:35:43,519 --> 00:35:46,239
computation ourselves we should be able

1047
00:35:44,880 --> 00:35:49,358
to figure it out

1048
00:35:46,239 --> 00:35:51,838
we know we have a four by four matrix

1049
00:35:49,358 --> 00:35:53,519
um and each floating point value in this

1050
00:35:51,838 --> 00:35:54,880
case it's a float so it's going to be

1051
00:35:53,519 --> 00:35:58,079
four bytes long

1052
00:35:54,880 --> 00:36:01,280
you can see that that is 64 bytes

1053
00:35:58,079 --> 00:36:02,960
per identity matrix and we know that we

1054
00:36:01,280 --> 00:36:06,240
said we wanted a matrix count

1055
00:36:02,960 --> 00:36:07,519
of 10 million right so if we do 10

1056
00:36:06,239 --> 00:36:10,719
million

1057
00:36:07,519 --> 00:36:13,519
64 byte matrices there is our value

1058
00:36:10,719 --> 00:36:14,559
right and lo and behold that is exactly

1059
00:36:13,519 --> 00:36:16,800
the value

1060
00:36:14,559 --> 00:36:19,279
that we're looking at here right zero

1061
00:36:16,800 --> 00:36:20,960
zero zero zero zero zero zero six four

1062
00:36:19,280 --> 00:36:22,640
four six right so it's this value right

1063
00:36:20,960 --> 00:36:24,960
here right

1064
00:36:22,639 --> 00:36:27,279
so what clang did in this case is it

1065
00:36:24,960 --> 00:36:29,119
multiplied out how many bytes total it

1066
00:36:27,280 --> 00:36:32,400
was going to be writing

1067
00:36:29,119 --> 00:36:33,680
and it just makes rax be the pointer to

1068
00:36:32,400 --> 00:36:35,838
the matrix

1069
00:36:33,679 --> 00:36:36,879
and you can see here that each time

1070
00:36:35,838 --> 00:36:39,519
through the loop

1071
00:36:36,880 --> 00:36:41,200
it adds 64 bytes which is the size of

1072
00:36:39,519 --> 00:36:44,079
exactly one matrix

1073
00:36:41,199 --> 00:36:46,639
and so you can infer that this copies

1074
00:36:44,079 --> 00:36:49,359
one identity matrix

1075
00:36:46,639 --> 00:36:50,639
to the memory it advances the pointer by

1076
00:36:49,358 --> 00:36:52,719
one matrix

1077
00:36:50,639 --> 00:36:54,400
test to see whether it has gotten to the

1078
00:36:52,719 --> 00:36:57,039
end of the byte range

1079
00:36:54,400 --> 00:36:58,960
by looking at the total number of bytes

1080
00:36:57,039 --> 00:37:01,440
it was expecting to write

1081
00:36:58,960 --> 00:37:03,358
and if it has reached zero it will not

1082
00:37:01,440 --> 00:37:03,838
take this jump this is jump if not equal

1083
00:37:03,358 --> 00:37:05,519
to

1084
00:37:03,838 --> 00:37:07,358
so i'm sorry if it is reach zero if

1085
00:37:05,519 --> 00:37:09,920
there's no difference between them

1086
00:37:07,358 --> 00:37:11,440
right then it will just fall through and

1087
00:37:09,920 --> 00:37:14,320
finish

1088
00:37:11,440 --> 00:37:15,838
by executing the next loop check which

1089
00:37:14,320 --> 00:37:18,320
is this one out here

1090
00:37:15,838 --> 00:37:19,199
otherwise it will jump back and copy

1091
00:37:18,320 --> 00:37:21,599
another matrix

1092
00:37:19,199 --> 00:37:23,199
right so again not very difficult to

1093
00:37:21,599 --> 00:37:24,079
understand when you actually parse it

1094
00:37:23,199 --> 00:37:26,159
out it's just

1095
00:37:24,079 --> 00:37:28,000
advance the pointer check to see if it's

1096
00:37:26,159 --> 00:37:29,920
hit the end of the byte range

1097
00:37:28,000 --> 00:37:31,679
and jump back to the beginning now

1098
00:37:29,920 --> 00:37:34,000
you'll notice that it does take a little

1099
00:37:31,679 --> 00:37:36,239
bit of work to read this because

1100
00:37:34,000 --> 00:37:37,599
it's not doing the loop the way we wrote

1101
00:37:36,239 --> 00:37:41,439
it we wrote it as

1102
00:37:37,599 --> 00:37:44,640
going indices of index um

1103
00:37:41,440 --> 00:37:45,838
to matrix count not indexed to 64 times

1104
00:37:44,639 --> 00:37:48,559
matrix count so we

1105
00:37:45,838 --> 00:37:50,559
wrote this to copy a matrix at a time so

1106
00:37:48,559 --> 00:37:53,679
we use the index of

1107
00:37:50,559 --> 00:37:57,039
the matrix but in this case they

1108
00:37:53,679 --> 00:37:59,440
the compiler clang expanded it out so

1109
00:37:57,039 --> 00:38:02,239
that actually rax is a byte pointer

1110
00:37:59,440 --> 00:38:03,760
now you may ask why did it do that and

1111
00:38:02,239 --> 00:38:05,598
the reason that it did that is just

1112
00:38:03,760 --> 00:38:06,320
because it's a free transformation for

1113
00:38:05,599 --> 00:38:07,920
it to do

1114
00:38:06,320 --> 00:38:09,680
these are both constants so it doesn't

1115
00:38:07,920 --> 00:38:12,960
matter whether this was one

1116
00:38:09,679 --> 00:38:14,319
and this was uh 10 million or if it's 64

1117
00:38:12,960 --> 00:38:17,679
and 640 million

1118
00:38:14,320 --> 00:38:18,079
right those are both free uh more or

1119
00:38:17,679 --> 00:38:20,559
less

1120
00:38:18,079 --> 00:38:21,440
with with the exception of maybe no i

1121
00:38:20,559 --> 00:38:22,078
don't think there's really an exception

1122
00:38:21,440 --> 00:38:24,800
there that's just

1123
00:38:22,079 --> 00:38:26,400
basically just both gonna be free um so

1124
00:38:24,800 --> 00:38:29,039
it's a free transformation to do

1125
00:38:26,400 --> 00:38:30,000
and it gets rid of extra addressing that

1126
00:38:29,039 --> 00:38:32,960
might have to happen

1127
00:38:30,000 --> 00:38:34,079
in here or you would have to do rax

1128
00:38:32,960 --> 00:38:36,480
times 64.

1129
00:38:34,079 --> 00:38:37,519
so it's trying to reduce the complexity

1130
00:38:36,480 --> 00:38:39,119
of the addressing

1131
00:38:37,519 --> 00:38:40,639
used when it's actually trying to figure

1132
00:38:39,119 --> 00:38:42,400
out where to write this stuff

1133
00:38:40,639 --> 00:38:43,679
um so that's a transformation that it

1134
00:38:42,400 --> 00:38:47,838
probably will

1135
00:38:43,679 --> 00:38:47,838
usually apply because why not right

1136
00:38:57,599 --> 00:39:02,320
we need to have like an auto ban of rust

1137
00:39:00,400 --> 00:39:05,519
from the chat

1138
00:39:02,320 --> 00:39:08,559
uh anyway so if you take a look

1139
00:39:05,519 --> 00:39:12,400
at this um what you basically find

1140
00:39:08,559 --> 00:39:14,078
is that this is the part that we

1141
00:39:12,400 --> 00:39:16,160
probably actually care the most about

1142
00:39:14,079 --> 00:39:17,440
i'll speak briefly about what was going

1143
00:39:16,159 --> 00:39:20,000
on the assembly language here

1144
00:39:17,440 --> 00:39:21,679
just so that everyone's clear on it um

1145
00:39:20,000 --> 00:39:24,559
when you look at what's going on

1146
00:39:21,679 --> 00:39:25,358
these two instructions are usually what

1147
00:39:24,559 --> 00:39:28,480
are called

1148
00:39:25,358 --> 00:39:31,119
fused macro apps um or usually our

1149
00:39:28,480 --> 00:39:33,679
macro ops subject to fusion might be the

1150
00:39:31,119 --> 00:39:35,358
way that you would say it

1151
00:39:33,679 --> 00:39:37,039
so one of the things that you'll notice

1152
00:39:35,358 --> 00:39:39,199
and you see this actually

1153
00:39:37,039 --> 00:39:40,719
twice already just in this really simple

1154
00:39:39,199 --> 00:39:42,480
piece of code that we have here

1155
00:39:40,719 --> 00:39:44,078
is that usually what's going to happen

1156
00:39:42,480 --> 00:39:45,760
in assembly language

1157
00:39:44,079 --> 00:39:47,920
is that most of the time you don't just

1158
00:39:45,760 --> 00:39:49,359
jump around the code for no reason most

1159
00:39:47,920 --> 00:39:51,280
of the time you jump around the code

1160
00:39:49,358 --> 00:39:53,358
because you've done a comparison

1161
00:39:51,280 --> 00:39:54,880
and you're trying to skip over an if

1162
00:39:53,358 --> 00:39:55,759
body or you're trying to go back to the

1163
00:39:54,880 --> 00:39:59,280
beginning of a loop

1164
00:39:55,760 --> 00:40:00,079
as is the case here and so almost always

1165
00:39:59,280 --> 00:40:02,720
you will see

1166
00:40:00,079 --> 00:40:04,160
a comparison instruction paired with a

1167
00:40:02,719 --> 00:40:07,039
jump instruction

1168
00:40:04,159 --> 00:40:08,960
so what the processor actually does

1169
00:40:07,039 --> 00:40:12,000
because this pattern is so

1170
00:40:08,960 --> 00:40:15,280
common is that actually comp

1171
00:40:12,000 --> 00:40:18,159
jump even though it's not an instruction

1172
00:40:15,280 --> 00:40:18,880
is actually what the processor treats it

1173
00:40:18,159 --> 00:40:22,799
as

1174
00:40:18,880 --> 00:40:25,440
so this on modern x64 processors

1175
00:40:22,800 --> 00:40:26,560
will often be interpreted not as two

1176
00:40:25,440 --> 00:40:29,519
instructions

1177
00:40:26,559 --> 00:40:30,400
comp and then jump but actually as one

1178
00:40:29,519 --> 00:40:33,519
instruction

1179
00:40:30,400 --> 00:40:34,079
which is comp jump so the reason that's

1180
00:40:33,519 --> 00:40:36,838
actually

1181
00:40:34,079 --> 00:40:38,079
important is because when it actually

1182
00:40:36,838 --> 00:40:41,519
goes

1183
00:40:38,079 --> 00:40:44,720
uh to process this that will often

1184
00:40:41,519 --> 00:40:47,519
not count against you in your four

1185
00:40:44,719 --> 00:40:49,279
ops per cycle so on like a skylake park

1186
00:40:47,519 --> 00:40:50,400
for example which is kind of the most

1187
00:40:49,280 --> 00:40:52,640
prevalent part right now

1188
00:40:50,400 --> 00:40:54,400
although that's going to change because

1189
00:40:52,639 --> 00:40:56,000
amd is going to take over the world next

1190
00:40:54,400 --> 00:40:57,760
year and no one will be using intel

1191
00:40:56,000 --> 00:41:00,079
processors anymore because they

1192
00:40:57,760 --> 00:41:00,880
no longer are able to actually make them

1193
00:41:00,079 --> 00:41:02,640
um

1194
00:41:00,880 --> 00:41:04,838
at the moment when we talk about the

1195
00:41:02,639 --> 00:41:06,239
most common processor it's a skylake

1196
00:41:04,838 --> 00:41:08,880
processor

1197
00:41:06,239 --> 00:41:10,959
and it's going to fuse these into a

1198
00:41:08,880 --> 00:41:11,838
single operation which means it won't

1199
00:41:10,960 --> 00:41:13,920
count

1200
00:41:11,838 --> 00:41:15,039
against your four instructions that you

1201
00:41:13,920 --> 00:41:18,240
get through the front end

1202
00:41:15,039 --> 00:41:19,920
i believe it gets fused and can be put

1203
00:41:18,239 --> 00:41:21,439
through as a single instruction and

1204
00:41:19,920 --> 00:41:22,960
again when you're trying to

1205
00:41:21,440 --> 00:41:24,079
look at the throughput of a processor

1206
00:41:22,960 --> 00:41:25,280
one of the main things you look at

1207
00:41:24,079 --> 00:41:27,519
nowadays

1208
00:41:25,280 --> 00:41:28,560
is what's called ipc or instructions per

1209
00:41:27,519 --> 00:41:30,719
clock

1210
00:41:28,559 --> 00:41:32,159
and when you talk about the number of

1211
00:41:30,719 --> 00:41:34,318
instructions per clock that you can

1212
00:41:32,159 --> 00:41:36,239
actually do in a processor it's around

1213
00:41:34,318 --> 00:41:39,440
four micro ops

1214
00:41:36,239 --> 00:41:42,399
um on the skylight cores

1215
00:41:39,440 --> 00:41:43,920
and this is an interesting case where

1216
00:41:42,400 --> 00:41:45,440
you actually diffuse those

1217
00:41:43,920 --> 00:41:47,119
through the entire pipeline i believe

1218
00:41:45,440 --> 00:41:48,559
it's actually macro opt fusion not micro

1219
00:41:47,119 --> 00:41:50,640
objects i believe

1220
00:41:48,559 --> 00:41:52,480
comp jump actually goes through the

1221
00:41:50,639 --> 00:41:54,078
entire pipeline as one

1222
00:41:52,480 --> 00:41:56,159
meaning it's only counts as one in the

1223
00:41:54,079 --> 00:41:58,160
front end and only counts as one

1224
00:41:56,159 --> 00:41:59,598
uh in the back end as well don't quote

1225
00:41:58,159 --> 00:42:01,279
me on that because again i'm not

1226
00:41:59,599 --> 00:42:02,720
offspring it might be that it's only

1227
00:42:01,280 --> 00:42:04,319
micro up fusion which means it actually

1228
00:42:02,719 --> 00:42:06,480
counts as two in the front end

1229
00:42:04,318 --> 00:42:08,000
uh for certain parts and then it counts

1230
00:42:06,480 --> 00:42:10,719
as one um

1231
00:42:08,000 --> 00:42:12,639
on the back end but either way point

1232
00:42:10,719 --> 00:42:16,559
being these get fused together and don't

1233
00:42:12,639 --> 00:42:16,559
count against your execution time at all

1234
00:42:16,880 --> 00:42:20,079
as 2 they count as 1.

1235
00:42:23,760 --> 00:42:29,839
and i think part of the reason for that

1236
00:42:26,800 --> 00:42:33,119
is also that if you think about it jump

1237
00:42:29,838 --> 00:42:36,000
isn't really an operation

1238
00:42:33,119 --> 00:42:36,800
so comp is something that actually needs

1239
00:42:36,000 --> 00:42:39,280
to go through

1240
00:42:36,800 --> 00:42:40,880
an execution port it actually needs to

1241
00:42:39,280 --> 00:42:44,160
do work to figure out if these two

1242
00:42:40,880 --> 00:42:46,079
bit patterns are the same so it's taking

1243
00:42:44,159 --> 00:42:48,078
actual values feeding them into an

1244
00:42:46,079 --> 00:42:48,880
execution port and actually testing to

1245
00:42:48,079 --> 00:42:51,760
see

1246
00:42:48,880 --> 00:42:52,240
if they're the same jump doesn't

1247
00:42:51,760 --> 00:42:54,400
actually

1248
00:42:52,239 --> 00:42:56,559
do anything it doesn't have any

1249
00:42:54,400 --> 00:42:58,000
execution ports it's just a thing in the

1250
00:42:56,559 --> 00:43:01,519
front end that says

1251
00:42:58,000 --> 00:43:03,119
i need to fetch a different execution

1252
00:43:01,519 --> 00:43:04,800
set i'm going to fetch these

1253
00:43:03,119 --> 00:43:05,760
instructions rather than these

1254
00:43:04,800 --> 00:43:08,400
instructions

1255
00:43:05,760 --> 00:43:10,640
as the next things to pull into the out

1256
00:43:08,400 --> 00:43:13,680
of order window

1257
00:43:10,639 --> 00:43:16,159
and so what usually happens

1258
00:43:13,679 --> 00:43:18,318
on jumps is they're either completely

1259
00:43:16,159 --> 00:43:19,598
free as i was saying meaning the comp is

1260
00:43:18,318 --> 00:43:21,759
the only thing we actually care about so

1261
00:43:19,599 --> 00:43:24,160
the jump is either completely free

1262
00:43:21,760 --> 00:43:25,520
or it actually has a branch

1263
00:43:24,159 --> 00:43:27,598
misprediction penalty

1264
00:43:25,519 --> 00:43:28,960
if the branch predictor failed to guess

1265
00:43:27,599 --> 00:43:30,880
which way it would go

1266
00:43:28,960 --> 00:43:32,400
and we'd end up spending 20 cycles

1267
00:43:30,880 --> 00:43:33,680
pulling in the correct instructions

1268
00:43:32,400 --> 00:43:34,720
because we actually pulled in the wrong

1269
00:43:33,679 --> 00:43:36,078
set of instructions or something like

1270
00:43:34,719 --> 00:43:38,719
that right

1271
00:43:36,079 --> 00:43:39,280
so jumps get into branch predictors not

1272
00:43:38,719 --> 00:43:41,358
very

1273
00:43:39,280 --> 00:43:42,880
uh relevant to this particular thing but

1274
00:43:41,358 --> 00:43:44,318
it's because this loop is running so

1275
00:43:42,880 --> 00:43:45,760
many times that it's always going to

1276
00:43:44,318 --> 00:43:47,440
predict basically correctly because it's

1277
00:43:45,760 --> 00:43:49,040
always going to take this jump

1278
00:43:47,440 --> 00:43:50,880
uh except for the very last time that it

1279
00:43:49,039 --> 00:43:52,079
runs and so

1280
00:43:50,880 --> 00:43:53,200
it really doesn't matter that much to us

1281
00:43:52,079 --> 00:43:54,079
here but it's worth understanding what's

1282
00:43:53,199 --> 00:43:56,000
going on

1283
00:43:54,079 --> 00:43:58,000
so what will actually happen at the end

1284
00:43:56,000 --> 00:43:58,960
of this is we'll have an ad on the

1285
00:43:58,000 --> 00:44:00,639
scalar pipe

1286
00:43:58,960 --> 00:44:03,039
because this is a scalar ad we'll have a

1287
00:44:00,639 --> 00:44:06,159
comp on the same so this is actually

1288
00:44:03,039 --> 00:44:08,639
an ad and a dependent compare and then

1289
00:44:06,159 --> 00:44:11,039
it will do the jump these can all be

1290
00:44:08,639 --> 00:44:11,920
uh sorry these two will issue like i

1291
00:44:11,039 --> 00:44:14,400
said together

1292
00:44:11,920 --> 00:44:15,760
uh for free we'll get the jump it's only

1293
00:44:14,400 --> 00:44:19,039
the comp that we're worried about

1294
00:44:15,760 --> 00:44:20,960
and the ad is actually

1295
00:44:19,039 --> 00:44:22,159
again dependent so it's gonna wait this

1296
00:44:20,960 --> 00:44:24,000
comp is going to stall

1297
00:44:22,159 --> 00:44:25,920
waiting for this ad to finish it so

1298
00:44:24,000 --> 00:44:28,239
it'll be like one cycle on the ad

1299
00:44:25,920 --> 00:44:30,079
and then one cycle on the comp right and

1300
00:44:28,239 --> 00:44:33,279
the jump is free

1301
00:44:30,079 --> 00:44:34,800
so really what we care about um is what

1302
00:44:33,280 --> 00:44:35,359
we're going to start looking at up here

1303
00:44:34,800 --> 00:44:37,839
because

1304
00:44:35,358 --> 00:44:39,440
also typically when you're talking about

1305
00:44:37,838 --> 00:44:41,119
doing large moves and you can actually

1306
00:44:39,440 --> 00:44:43,599
see this happening here

1307
00:44:41,119 --> 00:44:45,519
xmm registers are the cmd registers they

1308
00:44:43,599 --> 00:44:48,559
are the wide registers

1309
00:44:45,519 --> 00:44:50,000
typically the pipes are separate um so

1310
00:44:48,559 --> 00:44:53,119
on skylake they're completely

1311
00:44:50,000 --> 00:44:56,318
separate in the sense that scalar

1312
00:44:53,119 --> 00:44:59,119
ads and um like

1313
00:44:56,318 --> 00:45:00,400
mob aps are not on the same execution

1314
00:44:59,119 --> 00:45:02,318
units at all

1315
00:45:00,400 --> 00:45:03,920
uh this is gonna be something that's on

1316
00:45:02,318 --> 00:45:05,119
a memory execution unit this is going to

1317
00:45:03,920 --> 00:45:06,960
be something

1318
00:45:05,119 --> 00:45:08,480
that's on one of the scalar arithmetic

1319
00:45:06,960 --> 00:45:12,318
units

1320
00:45:08,480 --> 00:45:15,920
uh and i believe there's

1321
00:45:12,318 --> 00:45:19,838
slightly different so it's

1322
00:45:15,920 --> 00:45:19,838
let's just go full pull on this

1323
00:45:21,599 --> 00:45:25,119
i mean it's a handmade chat after all

1324
00:45:30,559 --> 00:45:34,159
so uh here's our instruction no it's

1325
00:45:33,599 --> 00:45:37,838
just add

1326
00:45:34,159 --> 00:45:47,838
sorry i'm thinking

1327
00:45:37,838 --> 00:45:51,039
sse i was one step ahead of myself there

1328
00:45:47,838 --> 00:45:53,920
come back maybe i'll make there we go

1329
00:45:51,039 --> 00:45:55,358
that's what i need okay yes

1330
00:45:53,920 --> 00:45:57,760
all right so in this case we've got an

1331
00:45:55,358 --> 00:45:58,719
ad with a 64-bit register and an

1332
00:45:57,760 --> 00:46:00,400
immediate

1333
00:45:58,719 --> 00:46:02,399
um so if you take a look at what's going

1334
00:46:00,400 --> 00:46:04,800
on here we can actually pick out

1335
00:46:02,400 --> 00:46:05,760
exactly that one so you can see here

1336
00:46:04,800 --> 00:46:09,039
like here's an

1337
00:46:05,760 --> 00:46:11,920
an ad with an rs64 and it's probably an

1338
00:46:09,039 --> 00:46:13,440
i8 because it's only adding 64 so it

1339
00:46:11,920 --> 00:46:15,838
doesn't need

1340
00:46:13,440 --> 00:46:17,519
very many bits to encode that now i

1341
00:46:15,838 --> 00:46:19,170
don't know if i can get code bytes on

1342
00:46:17,519 --> 00:46:22,360
here

1343
00:46:19,170 --> 00:46:22,360
[Music]

1344
00:46:26,838 --> 00:46:30,960
um

1345
00:46:29,119 --> 00:46:32,400
it doesn't really matter because they're

1346
00:46:30,960 --> 00:46:35,039
going to be this pretty much same anyway

1347
00:46:32,400 --> 00:46:37,519
but point being

1348
00:46:35,039 --> 00:46:40,318
let me open it up um so here's the

1349
00:46:37,519 --> 00:46:42,318
performance breakdown for skylake x core

1350
00:46:40,318 --> 00:46:44,400
for the ad instruction where you're

1351
00:46:42,318 --> 00:46:45,679
adding an immediate to a register

1352
00:46:44,400 --> 00:46:47,760
and it doesn't really matter if we got

1353
00:46:45,679 --> 00:46:48,879
the right one or not because as long as

1354
00:46:47,760 --> 00:46:50,480
we're in the ballpark it should be

1355
00:46:48,880 --> 00:46:52,960
basically the same

1356
00:46:50,480 --> 00:46:53,599
and what you can see here is the port

1357
00:46:52,960 --> 00:46:56,559
usage

1358
00:46:53,599 --> 00:46:57,680
here tells us which of the actual

1359
00:46:56,559 --> 00:46:59,920
execution ports

1360
00:46:57,679 --> 00:47:00,960
on the skylake processor uh are going to

1361
00:46:59,920 --> 00:47:03,280
be able to use it and

1362
00:47:00,960 --> 00:47:04,639
see ice like canon lake skylake we don't

1363
00:47:03,280 --> 00:47:06,640
have isolator canon lake

1364
00:47:04,639 --> 00:47:08,159
nobody does because intel can't figure

1365
00:47:06,639 --> 00:47:09,519
out how to fab them

1366
00:47:08,159 --> 00:47:11,199
so you might have this if you're using

1367
00:47:09,519 --> 00:47:14,880
like a recent

1368
00:47:11,199 --> 00:47:16,559
uh laptop this i think got deep six

1369
00:47:14,880 --> 00:47:18,318
they printed a very small number of

1370
00:47:16,559 --> 00:47:20,400
these and then they just gave up

1371
00:47:18,318 --> 00:47:22,079
so this is the only thing you might have

1372
00:47:20,400 --> 00:47:22,800
if you have a modern laptop there are no

1373
00:47:22,079 --> 00:47:25,599
desktop

1374
00:47:22,800 --> 00:47:26,800
ice lakes i don't think i don't know if

1375
00:47:25,599 --> 00:47:30,318
they ever got that working

1376
00:47:26,800 --> 00:47:30,880
they may never have um so we ignore

1377
00:47:30,318 --> 00:47:32,239
these two

1378
00:47:30,880 --> 00:47:34,800
because these are not particularly

1379
00:47:32,239 --> 00:47:36,159
relevant right now for anything honestly

1380
00:47:34,800 --> 00:47:39,119
so we're really looking at this right

1381
00:47:36,159 --> 00:47:40,799
here and here's the port usage now the

1382
00:47:39,119 --> 00:47:42,800
port usage happens to be the same

1383
00:47:40,800 --> 00:47:44,160
so we really don't care but it's worth

1384
00:47:42,800 --> 00:47:45,519
noting that this is the core that you

1385
00:47:44,159 --> 00:47:48,399
probably actually have

1386
00:47:45,519 --> 00:47:49,920
right similarly this might be the core

1387
00:47:48,400 --> 00:47:51,680
that you have this one's a little harder

1388
00:47:49,920 --> 00:47:52,960
course it depends which one you have

1389
00:47:51,679 --> 00:47:54,480
this is the one i think is in this

1390
00:47:52,960 --> 00:47:56,480
machine i don't use the skylake x

1391
00:47:54,480 --> 00:47:58,240
because sky x has avx 512 i'm not

1392
00:47:56,480 --> 00:47:59,519
mistaken and this machine doesn't

1393
00:47:58,239 --> 00:48:01,679
so i believe this is just a regular

1394
00:47:59,519 --> 00:48:02,880
skylight core again same port usage so

1395
00:48:01,679 --> 00:48:06,078
it's okay

1396
00:48:02,880 --> 00:48:08,160
um and what this p0156 means

1397
00:48:06,079 --> 00:48:09,200
that's the list of execution ports there

1398
00:48:08,159 --> 00:48:12,399
are like seven

1399
00:48:09,199 --> 00:48:13,759
i think in a skylight core zero one five

1400
00:48:12,400 --> 00:48:17,039
and six can all

1401
00:48:13,760 --> 00:48:20,160
do an add right um and so it takes

1402
00:48:17,039 --> 00:48:24,239
one cycle not one cycle

1403
00:48:20,159 --> 00:48:27,358
it takes one of these execution ports

1404
00:48:24,239 --> 00:48:28,159
and it will do it on any of them that it

1405
00:48:27,358 --> 00:48:31,199
has

1406
00:48:28,159 --> 00:48:32,239
what this means is that if you have four

1407
00:48:31,199 --> 00:48:34,239
ad instructions

1408
00:48:32,239 --> 00:48:36,558
that are all independent you could

1409
00:48:34,239 --> 00:48:37,199
actually get them all going on separate

1410
00:48:36,559 --> 00:48:40,079
ports

1411
00:48:37,199 --> 00:48:41,759
and not have to wait right um so in

1412
00:48:40,079 --> 00:48:42,160
other words you could issue on port zero

1413
00:48:41,760 --> 00:48:44,240
an ad

1414
00:48:42,159 --> 00:48:46,000
on port one nad a port five an ad and

1415
00:48:44,239 --> 00:48:49,519
port six an ad you could issue

1416
00:48:46,000 --> 00:48:50,960
ads on all four ports at once that's why

1417
00:48:49,519 --> 00:48:54,079
they end up with a thing that's like

1418
00:48:50,960 --> 00:48:57,599
the reciprocal throughput here is 0.25

1419
00:48:54,079 --> 00:49:00,559
that's basically saying four per clock

1420
00:48:57,599 --> 00:49:01,200
right meaning it only takes a quarter of

1421
00:49:00,559 --> 00:49:03,440
a clock

1422
00:49:01,199 --> 00:49:05,519
quote-unquote to do an ad because you

1423
00:49:03,440 --> 00:49:06,800
can do four of them at once now any

1424
00:49:05,519 --> 00:49:09,039
given one

1425
00:49:06,800 --> 00:49:10,079
actually will take one cycle that's what

1426
00:49:09,039 --> 00:49:11,920
this latency

1427
00:49:10,079 --> 00:49:13,119
tells you but this thing is just saying

1428
00:49:11,920 --> 00:49:14,838
hey there's four ports so it's

1429
00:49:13,119 --> 00:49:18,318
effectively 0.25

1430
00:49:14,838 --> 00:49:19,920
right so again just trying to give you

1431
00:49:18,318 --> 00:49:21,440
a little bit of a flavor for what's

1432
00:49:19,920 --> 00:49:24,159
going on here right

1433
00:49:21,440 --> 00:49:25,358
um and so basically the cpu resources

1434
00:49:24,159 --> 00:49:26,318
that are going to get assigned to be

1435
00:49:25,358 --> 00:49:30,000
doing this

1436
00:49:26,318 --> 00:49:31,838
the ad can go to any of four ports

1437
00:49:30,000 --> 00:49:34,400
so what i was trying to get across there

1438
00:49:31,838 --> 00:49:35,759
is that pretty much no matter what

1439
00:49:34,400 --> 00:49:39,200
happens in this loop

1440
00:49:35,760 --> 00:49:40,720
unless it is absolutely psychotically

1441
00:49:39,199 --> 00:49:44,000
tightly optimized

1442
00:49:40,719 --> 00:49:47,358
and can only work with zero one five six

1443
00:49:44,000 --> 00:49:47,920
as its ports this ad will probably just

1444
00:49:47,358 --> 00:49:51,039
sneak

1445
00:49:47,920 --> 00:49:53,680
in there for free right the

1446
00:49:51,039 --> 00:49:54,558
ad comp is probably gonna end up being

1447
00:49:53,679 --> 00:49:56,399
pretty free

1448
00:49:54,559 --> 00:49:59,839
let's look up the comp as well while

1449
00:49:56,400 --> 00:49:59,838
we're at it

1450
00:50:02,559 --> 00:50:11,280
uh so this is an r64 versus an immediate

1451
00:50:06,679 --> 00:50:11,279
64. or that's a 32 right

1452
00:50:11,358 --> 00:50:16,000
i think it's a 32-bit immediate right it

1453
00:50:13,039 --> 00:50:18,719
was it was 640 million so that's

1454
00:50:16,000 --> 00:50:20,318
that's well within 32-bit range um so

1455
00:50:18,719 --> 00:50:23,919
let's take a look at this comp

1456
00:50:20,318 --> 00:50:26,000
um of the r64 register and here it is

1457
00:50:23,920 --> 00:50:27,440
the comp can happen on all four as well

1458
00:50:26,000 --> 00:50:30,480
right

1459
00:50:27,440 --> 00:50:33,200
so chances are this

1460
00:50:30,480 --> 00:50:34,079
is literally irrelevant to the root loop

1461
00:50:33,199 --> 00:50:37,358
runtime

1462
00:50:34,079 --> 00:50:38,800
it will just find a hole one of those

1463
00:50:37,358 --> 00:50:41,199
ports will be open

1464
00:50:38,800 --> 00:50:41,839
and it will just find a hole and fill it

1465
00:50:41,199 --> 00:50:44,159
so we can

1466
00:50:41,838 --> 00:50:45,599
almost say i mean once we look at this

1467
00:50:44,159 --> 00:50:46,799
we'll have a better idea of it i mean i

1468
00:50:45,599 --> 00:50:48,318
can already tell just looking at it that

1469
00:50:46,800 --> 00:50:50,559
it's true but i mean

1470
00:50:48,318 --> 00:50:51,759
imagine we were gonna imagine that we

1471
00:50:50,559 --> 00:50:53,519
had to focus on this a little bit more

1472
00:50:51,760 --> 00:50:57,200
closely

1473
00:50:53,519 --> 00:51:00,159
um this will almost certainly

1474
00:50:57,199 --> 00:51:01,118
just fill up execution port bubbles in

1475
00:51:00,159 --> 00:51:03,440
our routine

1476
00:51:01,119 --> 00:51:04,400
and we just don't have to worry about it

1477
00:51:03,440 --> 00:51:07,280
right

1478
00:51:04,400 --> 00:51:08,240
so this is basically free and we'll just

1479
00:51:07,280 --> 00:51:11,519
find

1480
00:51:08,239 --> 00:51:12,719
of those ports 0 1 5 6 it will just find

1481
00:51:11,519 --> 00:51:15,199
one to execute on

1482
00:51:12,719 --> 00:51:16,318
and execute on it in the shadow of all

1483
00:51:15,199 --> 00:51:17,358
the other crap

1484
00:51:16,318 --> 00:51:20,159
that we're going to be feeding the

1485
00:51:17,358 --> 00:51:23,440
processor right

1486
00:51:20,159 --> 00:51:25,039
okay so that's what's going on

1487
00:51:23,440 --> 00:51:27,200
at the end of the loop and we can more

1488
00:51:25,039 --> 00:51:29,199
or less ignore it completely

1489
00:51:27,199 --> 00:51:30,480
so now what we're looking at is just

1490
00:51:29,199 --> 00:51:33,679
this

1491
00:51:30,480 --> 00:51:36,240
what does this code actually do and to

1492
00:51:33,679 --> 00:51:37,838
be completely honest with you while i

1493
00:51:36,239 --> 00:51:41,358
think i know what it does

1494
00:51:37,838 --> 00:51:45,199
i have literally no idea

1495
00:51:41,358 --> 00:51:48,400
like i literally have absolutely no idea

1496
00:51:45,199 --> 00:51:50,480
why the compiler is doing it this way

1497
00:51:48,400 --> 00:51:51,920
there's probably an explanation and if

1498
00:51:50,480 --> 00:51:53,199
there's someone out there who works on

1499
00:51:51,920 --> 00:51:55,200
the clang back end

1500
00:51:53,199 --> 00:51:56,719
who's watching this maybe you can tell

1501
00:51:55,199 --> 00:51:59,519
me what the heck happened here

1502
00:51:56,719 --> 00:52:05,838
i don't know maybe there is a smart

1503
00:51:59,519 --> 00:52:05,838
reason why you would do this but i just

1504
00:52:08,239 --> 00:52:11,549
i don't know what happened here let me

1505
00:52:09,920 --> 00:52:14,608
walk you through it

1506
00:52:11,550 --> 00:52:14,609
[Music]

1507
00:52:16,838 --> 00:52:24,960
um

1508
00:52:19,760 --> 00:52:24,960
i i'm i'm struggling to figure out

1509
00:52:29,199 --> 00:52:32,078
i i mean the only thing i can say

1510
00:52:30,880 --> 00:52:34,000
because i've never looked at the back

1511
00:52:32,079 --> 00:52:35,680
end of clang before so i don't have an

1512
00:52:34,000 --> 00:52:39,199
idea of like how it could get

1513
00:52:35,679 --> 00:52:42,318
into get itself into this situation

1514
00:52:39,199 --> 00:52:45,838
um i

1515
00:52:42,318 --> 00:52:48,239
guess maybe the reason it it ended up

1516
00:52:45,838 --> 00:52:53,279
doing this is because it

1517
00:52:48,239 --> 00:52:53,279
was penalizing

1518
00:52:55,039 --> 00:53:01,838
uh yeah i'm sorry i just i don't know i

1519
00:52:57,440 --> 00:53:01,838
have no idea why it's doing this

1520
00:53:01,920 --> 00:53:05,760
i i wish i knew

1521
00:53:12,838 --> 00:53:15,838
um

1522
00:53:24,000 --> 00:53:27,199
i'm sorry yeah i think our only real

1523
00:53:26,639 --> 00:53:28,799
hope

1524
00:53:27,199 --> 00:53:30,239
is that somebody who works with the

1525
00:53:28,800 --> 00:53:32,318
clang back end

1526
00:53:30,239 --> 00:53:33,519
uh is watching the stream and can post

1527
00:53:32,318 --> 00:53:34,800
later to tell us why

1528
00:53:33,519 --> 00:53:35,920
you know how it got itself in the stairs

1529
00:53:34,800 --> 00:53:36,880
so let me walk you through what it's

1530
00:53:35,920 --> 00:53:39,838
doing

1531
00:53:36,880 --> 00:53:41,519
um and i i'm i'm sorry i just i can't

1532
00:53:39,838 --> 00:53:42,558
because that's not my expertise i don't

1533
00:53:41,519 --> 00:53:44,000
spend a lot of time looking at the clan

1534
00:53:42,559 --> 00:53:44,800
compiler back end in fact i don't think

1535
00:53:44,000 --> 00:53:46,800
i've ever looked

1536
00:53:44,800 --> 00:53:49,039
clanky power back in so i just i don't

1537
00:53:46,800 --> 00:53:50,640
know what set of heuristics went

1538
00:53:49,039 --> 00:53:52,960
wrong to get it into the state or if

1539
00:53:50,639 --> 00:53:54,719
this is somehow really brilliant but

1540
00:53:52,960 --> 00:53:56,960
my knowledge of skylake suggested this

1541
00:53:54,719 --> 00:53:59,919
is not even remotely good

1542
00:53:56,960 --> 00:54:01,358
um maybe it was trying to optimize for

1543
00:53:59,920 --> 00:54:02,559
another

1544
00:54:01,358 --> 00:54:05,119
i don't know if there's a way to

1545
00:54:02,559 --> 00:54:06,400
basically say like hey

1546
00:54:05,119 --> 00:54:08,079
what would you do if you knew you had a

1547
00:54:06,400 --> 00:54:09,519
monitor no so it just it seems to want

1548
00:54:08,079 --> 00:54:11,200
to do that even if i tell it it's a very

1549
00:54:09,519 --> 00:54:14,318
modern processor

1550
00:54:11,199 --> 00:54:16,000
um so i'm sorry

1551
00:54:14,318 --> 00:54:17,759
i've got nothing i don't know why clang

1552
00:54:16,000 --> 00:54:18,800
did that it's just seems just kind of

1553
00:54:17,760 --> 00:54:20,160
nuts to me so

1554
00:54:18,800 --> 00:54:21,839
maybe someone else can clarify that

1555
00:54:20,159 --> 00:54:22,318
later what the heck it was doing here or

1556
00:54:21,838 --> 00:54:23,838
why

1557
00:54:22,318 --> 00:54:26,400
i don't know but let me tell you what

1558
00:54:23,838 --> 00:54:28,960
it's doing and then we can go from there

1559
00:54:26,400 --> 00:54:29,440
so if you take a look uh what you've got

1560
00:54:28,960 --> 00:54:33,039
is

1561
00:54:29,440 --> 00:54:36,079
you have essentially a set of

1562
00:54:33,039 --> 00:54:38,558
instructions that are sort of uh paired

1563
00:54:36,079 --> 00:54:41,599
a little bit so you can see that you

1564
00:54:38,559 --> 00:54:44,640
know it's it's doing this loop

1565
00:54:41,599 --> 00:54:48,079
uh where it's going to do uh

1566
00:54:44,639 --> 00:54:50,000
four separate mobs right

1567
00:54:48,079 --> 00:54:52,079
and those moths are going to be moving a

1568
00:54:50,000 --> 00:54:54,559
particular constant value

1569
00:54:52,079 --> 00:54:56,079
into particular locations and what you

1570
00:54:54,559 --> 00:54:59,200
could see

1571
00:54:56,079 --> 00:55:02,480
is this value is a very specific

1572
00:54:59,199 --> 00:55:05,519
structured value it's hard to determine

1573
00:55:02,480 --> 00:55:08,880
what this actually is for a human

1574
00:55:05,519 --> 00:55:11,199
um because it happens to be a floating

1575
00:55:08,880 --> 00:55:14,318
point number now remember we're actually

1576
00:55:11,199 --> 00:55:17,679
moving um this pattern here

1577
00:55:14,318 --> 00:55:22,000
around but what we can do uh

1578
00:55:17,679 --> 00:55:24,078
in this case potentially is just um

1579
00:55:22,000 --> 00:55:25,519
if you happen to know what 1.0 looks

1580
00:55:24,079 --> 00:55:27,359
like in floating point numbers then you

1581
00:55:25,519 --> 00:55:28,719
know what it is but if you don't know it

1582
00:55:27,358 --> 00:55:30,159
can be tricky so i want to show you a

1583
00:55:28,719 --> 00:55:31,519
little trick

1584
00:55:30,159 --> 00:55:34,480
so you can figure out what the heck is

1585
00:55:31,519 --> 00:55:37,759
going on there if i was to do

1586
00:55:34,480 --> 00:55:40,400
this um

1587
00:55:37,760 --> 00:55:41,200
what you can see is that this value now

1588
00:55:40,400 --> 00:55:44,480
changed

1589
00:55:41,199 --> 00:55:46,960
right so that's a way of me

1590
00:55:44,480 --> 00:55:49,199
verifying that that number is just the

1591
00:55:46,960 --> 00:55:51,119
floating point in coding of 1.0 without

1592
00:55:49,199 --> 00:55:52,000
me having to actually go figure out what

1593
00:55:51,119 --> 00:55:54,960
the floating point

1594
00:55:52,000 --> 00:55:56,639
value of 1.0 actually is in binary right

1595
00:55:54,960 --> 00:55:57,599
is i can just twiddle some of these and

1596
00:55:56,639 --> 00:56:01,118
see if i'm right

1597
00:55:57,599 --> 00:56:04,720
and it turns out you know that i am so

1598
00:56:01,119 --> 00:56:07,838
this ox3f8 with the zeros at the end

1599
00:56:04,719 --> 00:56:10,480
is just floating point one

1600
00:56:07,838 --> 00:56:11,358
and what you can see is that it's doing

1601
00:56:10,480 --> 00:56:14,480
a move

1602
00:56:11,358 --> 00:56:15,440
so it's copying memory it's saying i

1603
00:56:14,480 --> 00:56:18,159
want to

1604
00:56:15,440 --> 00:56:19,519
write a constant so an immediate value

1605
00:56:18,159 --> 00:56:22,879
this value

1606
00:56:19,519 --> 00:56:27,199
and i want to write it to rbx

1607
00:56:22,880 --> 00:56:29,760
plus rax right these are two registers

1608
00:56:27,199 --> 00:56:30,719
we can infer i haven't even looked but i

1609
00:56:29,760 --> 00:56:33,520
can just infer

1610
00:56:30,719 --> 00:56:35,439
that rbx is what the base pointer of

1611
00:56:33,519 --> 00:56:36,719
matrix so this is what we got from malek

1612
00:56:35,440 --> 00:56:38,240
and in fact you can see it happening

1613
00:56:36,719 --> 00:56:40,480
right here there's the return value of

1614
00:56:38,239 --> 00:56:42,719
malik getting copied into rbx

1615
00:56:40,480 --> 00:56:45,358
so that's just the base pointer and then

1616
00:56:42,719 --> 00:56:46,239
rax as we already determined is just the

1617
00:56:45,358 --> 00:56:48,480
byte offset

1618
00:56:46,239 --> 00:56:50,399
of the current matrix we're writing so

1619
00:56:48,480 --> 00:56:53,199
you can see we'll do an rbx plus

1620
00:56:50,400 --> 00:56:54,720
rax and we're going to do that we're

1621
00:56:53,199 --> 00:56:55,199
going to do these writes throughout so

1622
00:56:54,719 --> 00:56:58,399
you can see

1623
00:56:55,199 --> 00:57:00,239
everything here is like rbx plus rax rb

1624
00:56:58,400 --> 00:57:03,519
express so all of our rights

1625
00:57:00,239 --> 00:57:06,479
are all just writing to offsets

1626
00:57:03,519 --> 00:57:08,079
of the actual matrix we're trying to

1627
00:57:06,480 --> 00:57:10,240
write

1628
00:57:08,079 --> 00:57:13,839
makes sense like that's what you know

1629
00:57:10,239 --> 00:57:13,838
that's what we're doing

1630
00:57:17,519 --> 00:57:23,679
um and what you can see here is that the

1631
00:57:20,719 --> 00:57:25,039
actual way that this thing works is

1632
00:57:23,679 --> 00:57:28,159
completely nuts

1633
00:57:25,039 --> 00:57:30,558
it's absolutely bonkers i

1634
00:57:28,159 --> 00:57:32,239
never would have thought to try this or

1635
00:57:30,559 --> 00:57:33,519
and now that i've seen it tried i have

1636
00:57:32,239 --> 00:57:36,719
no idea

1637
00:57:33,519 --> 00:57:37,199
why it was tried um and i can't imagine

1638
00:57:36,719 --> 00:57:38,798
it's

1639
00:57:37,199 --> 00:57:40,558
ever a good way to write this loop but

1640
00:57:38,798 --> 00:57:43,679
what's happening is

1641
00:57:40,559 --> 00:57:46,960
it's literally moving the one value

1642
00:57:43,679 --> 00:57:48,960
so this value one right

1643
00:57:46,960 --> 00:57:50,639
it's literally writing the one value

1644
00:57:48,960 --> 00:57:54,559
into the first

1645
00:57:50,639 --> 00:57:57,519
slot so the first floating point slot of

1646
00:57:54,559 --> 00:57:58,000
32 bits four bytes it's writing that

1647
00:57:57,519 --> 00:58:01,440
there

1648
00:57:58,000 --> 00:58:04,400
with a single 32-bit move so it's just

1649
00:58:01,440 --> 00:58:05,440
writing 32 bits or four bytes it's

1650
00:58:04,400 --> 00:58:08,880
writing it

1651
00:58:05,440 --> 00:58:11,280
here then it is

1652
00:58:08,880 --> 00:58:12,720
doing this load so it's doing an xmm

1653
00:58:11,280 --> 00:58:15,359
word pointer rsp

1654
00:58:12,719 --> 00:58:17,118
plus 32. now what is rsp plus 32 in this

1655
00:58:15,358 --> 00:58:19,440
case

1656
00:58:17,119 --> 00:58:20,240
well rsp is usually the stack pointer so

1657
00:58:19,440 --> 00:58:21,920
that's usually

1658
00:58:20,239 --> 00:58:23,679
something that's on the stack and what

1659
00:58:21,920 --> 00:58:25,519
is on the stack in this case

1660
00:58:23,679 --> 00:58:27,279
well you can see right here that what we

1661
00:58:25,519 --> 00:58:30,639
did is we did an xrps

1662
00:58:27,280 --> 00:58:36,720
on xmm0 and xrps is

1663
00:58:30,639 --> 00:58:38,558
packed single xor it's

1664
00:58:36,719 --> 00:58:42,078
i have a whole hour left so i think i'm

1665
00:58:38,559 --> 00:58:44,000
okay to just be this explicit

1666
00:58:42,079 --> 00:58:46,400
xoring your register with itself clears

1667
00:58:44,000 --> 00:58:47,679
it that's because xoring any two values

1668
00:58:46,400 --> 00:58:50,798
together that are the same

1669
00:58:47,679 --> 00:58:54,399
right so if i have two uh if if my two

1670
00:58:50,798 --> 00:58:58,559
operands to xor are equal i get zero

1671
00:58:54,400 --> 00:59:00,798
that's because if you do a uh

1672
00:58:58,559 --> 00:59:02,160
exclusive or it's baked into the name

1673
00:59:00,798 --> 00:59:03,519
exclusive or means it has to be

1674
00:59:02,159 --> 00:59:05,759
exclusively

1675
00:59:03,519 --> 00:59:07,440
or like it has to be one or the other

1676
00:59:05,760 --> 00:59:09,920
and never both the same

1677
00:59:07,440 --> 00:59:10,960
so zero one produces one one zero

1678
00:59:09,920 --> 00:59:13,358
produces one

1679
00:59:10,960 --> 00:59:14,079
but zero zero and one one both produce

1680
00:59:13,358 --> 00:59:17,119
zero

1681
00:59:14,079 --> 00:59:18,559
that means x or p s of x m m zero with

1682
00:59:17,119 --> 00:59:21,838
x100 will produce

1683
00:59:18,559 --> 00:59:23,519
zero everywhere even no matter what this

1684
00:59:21,838 --> 00:59:25,039
value is can be anything

1685
00:59:23,519 --> 00:59:26,559
and this is actually the topic i was

1686
00:59:25,039 --> 00:59:27,920
starting out with today which is xor

1687
00:59:26,559 --> 00:59:29,040
clears

1688
00:59:27,920 --> 00:59:30,639
and we're going to talk about what that

1689
00:59:29,039 --> 00:59:32,318
does the problem is the compiler never

1690
00:59:30,639 --> 00:59:35,039
used them in the loop anyway

1691
00:59:32,318 --> 00:59:36,719
but uh we'll talk about them at the end

1692
00:59:35,039 --> 00:59:38,480
because i wanted to

1693
00:59:36,719 --> 00:59:39,759
talk about what they were so we'll get

1694
00:59:38,480 --> 00:59:42,240
there eventually

1695
00:59:39,760 --> 00:59:43,440
so this actually clears xmm0 so xm0 is

1696
00:59:42,239 --> 00:59:45,679
just zero

1697
00:59:43,440 --> 00:59:47,838
and then what the compiler does is it

1698
00:59:45,679 --> 00:59:51,919
moves to the stack rsp

1699
00:59:47,838 --> 00:59:55,440
plus 32 plus 16 and plus zero

1700
00:59:51,920 --> 00:59:58,480
three copies of zero right

1701
00:59:55,440 --> 01:00:02,159
so it's saying all right i want to

1702
00:59:58,480 --> 01:00:05,838
store zero to the stack three times

1703
01:00:02,159 --> 01:00:09,039
right um and again this is why

1704
01:00:05,838 --> 01:00:11,679
i don't really understand like i'm

1705
01:00:09,039 --> 01:00:14,318
passing o2 here and i've passed o3

1706
01:00:11,679 --> 01:00:14,798
as well as an attempt those are supposed

1707
01:00:14,318 --> 01:00:16,880
to be

1708
01:00:14,798 --> 01:00:18,480
optimization flags as far as i know

1709
01:00:16,880 --> 01:00:20,079
maybe i'm just naive with clang and you

1710
01:00:18,480 --> 01:00:23,119
have to say it's something else

1711
01:00:20,079 --> 01:00:26,480
um but i don't

1712
01:00:23,119 --> 01:00:26,480
really know

1713
01:00:26,838 --> 01:00:32,239
i does anyone know

1714
01:00:29,838 --> 01:00:33,039
like is there anything i can ask this

1715
01:00:32,239 --> 01:00:34,959
thing to do

1716
01:00:33,039 --> 01:00:36,719
better than o3 i'll just stop real

1717
01:00:34,960 --> 01:00:37,838
briefly and ask chat does anyone know if

1718
01:00:36,719 --> 01:00:43,439
clang

1719
01:00:37,838 --> 01:00:45,920
does anything more than o3

1720
01:00:43,440 --> 01:00:45,920
anybody

1721
01:00:46,639 --> 01:00:51,440
because as far as i know that's as

1722
01:00:49,440 --> 01:00:52,240
optimal as clang is likely to get i mean

1723
01:00:51,440 --> 01:00:54,000
i can give it

1724
01:00:52,239 --> 01:00:55,598
like i said i can give it the benefit of

1725
01:00:54,000 --> 01:00:58,798
knowing the architecture

1726
01:00:55,599 --> 01:01:00,640
is better than the base sse2 but it

1727
01:00:58,798 --> 01:01:04,639
doesn't seem to change the code

1728
01:01:00,639 --> 01:01:10,318
so as far as i can tell minus o2 is

1729
01:01:04,639 --> 01:01:12,078
all it gets right um

1730
01:01:10,318 --> 01:01:13,679
like it's this is the code no matter

1731
01:01:12,079 --> 01:01:15,920
what i pass

1732
01:01:13,679 --> 01:01:15,919
right

1733
01:01:16,880 --> 01:01:19,599
so i don't know

1734
01:01:21,519 --> 01:01:24,159
so let me finish explaining what it's

1735
01:01:22,719 --> 01:01:25,838
doing and i'll go through all the ways

1736
01:01:24,159 --> 01:01:27,199
it's absolutely ridiculous and makes no

1737
01:01:25,838 --> 01:01:28,558
sense

1738
01:01:27,199 --> 01:01:30,078
so what it's doing is clearing this to

1739
01:01:28,559 --> 01:01:32,319
zero and storing it three times to the

1740
01:01:30,079 --> 01:01:33,839
stack so it's basically creating

1741
01:01:32,318 --> 01:01:35,599
three places on the stack where it

1742
01:01:33,838 --> 01:01:39,920
stores xmm0

1743
01:01:35,599 --> 01:01:42,880
and that xmm0 is basically just clearing

1744
01:01:39,920 --> 01:01:45,280
48 bytes right so there's 48 bytes of

1745
01:01:42,880 --> 01:01:48,960
zero on the stack starting at rsp

1746
01:01:45,280 --> 01:01:51,119
and ending at rs rsp plus 48

1747
01:01:48,960 --> 01:01:53,280
right so because each one of these is

1748
01:01:51,119 --> 01:01:57,680
storing 16 bytes move aps

1749
01:01:53,280 --> 01:02:00,960
is move aligned um for a

1750
01:01:57,679 --> 01:02:04,399
16 byte register right

1751
01:02:00,960 --> 01:02:06,318
which is xmm so clear a 16 byte register

1752
01:02:04,400 --> 01:02:08,480
write it to the stack at three locations

1753
01:02:06,318 --> 01:02:11,759
sequentially so we now have

1754
01:02:08,480 --> 01:02:12,480
three times 16 or 48 contiguous zero

1755
01:02:11,760 --> 01:02:14,480
bytes

1756
01:02:12,480 --> 01:02:17,440
set that up and so in here what it's

1757
01:02:14,480 --> 01:02:21,679
doing is moving the one value

1758
01:02:17,440 --> 01:02:24,240
then it is loading into xmm0

1759
01:02:21,679 --> 01:02:24,798
what it stored to the stack which was

1760
01:02:24,239 --> 01:02:29,118
zero

1761
01:02:24,798 --> 01:02:32,400
and coincidentally it is what xm0 is

1762
01:02:29,119 --> 01:02:35,760
so it's loading xmm0 here

1763
01:02:32,400 --> 01:02:38,318
in this line even though xmm0 already

1764
01:02:35,760 --> 01:02:38,799
is zero so this line does literally

1765
01:02:38,318 --> 01:02:40,960
nothing

1766
01:02:38,798 --> 01:02:42,400
it's a complete waste of time but it

1767
01:02:40,960 --> 01:02:45,760
doesn't anyway

1768
01:02:42,400 --> 01:02:47,920
then it stores the zero uh

1769
01:02:45,760 --> 01:02:49,280
to the next location so remember it

1770
01:02:47,920 --> 01:02:52,720
wrote 4 bytes

1771
01:02:49,280 --> 01:02:55,519
now it's going to write 16 zeros here

1772
01:02:52,719 --> 01:02:56,078
makes sense then it does the same thing

1773
01:02:55,519 --> 01:02:59,838
again

1774
01:02:56,079 --> 01:03:01,599
write the one load 0 again

1775
01:02:59,838 --> 01:03:04,558
and load it from a different location

1776
01:03:01,599 --> 01:03:07,280
even though these are all the same value

1777
01:03:04,559 --> 01:03:08,880
it still decided to load it again right

1778
01:03:07,280 --> 01:03:12,319
from a different location

1779
01:03:08,880 --> 01:03:12,318
as if this were different memory

1780
01:03:12,480 --> 01:03:16,400
then it writes it then it writes the one

1781
01:03:15,440 --> 01:03:20,000
again

1782
01:03:16,400 --> 01:03:22,079
then it does uh another load to load the

1783
01:03:20,000 --> 01:03:24,719
final zero value even though the whole

1784
01:03:22,079 --> 01:03:27,760
time xmm0 was zero

1785
01:03:24,719 --> 01:03:31,519
uh and then it goes ahead and writes

1786
01:03:27,760 --> 01:03:34,640
uh the final zeros and the final ones

1787
01:03:31,519 --> 01:03:44,559
right does this make sense you see what

1788
01:03:34,639 --> 01:03:48,000
i'm saying

1789
01:03:44,559 --> 01:03:48,720
i have absolutely no idea why it decided

1790
01:03:48,000 --> 01:03:52,719
to do that

1791
01:03:48,719 --> 01:03:55,199
someone was saying make it const

1792
01:03:52,719 --> 01:03:56,239
it's the compiler already knows that

1793
01:03:55,199 --> 01:03:59,358
it's const

1794
01:03:56,239 --> 01:04:02,078
right um

1795
01:03:59,358 --> 01:04:03,358
nobody else got visibility to this value

1796
01:04:02,079 --> 01:04:05,200
so there's no way

1797
01:04:03,358 --> 01:04:07,119
like i don't know so if adding const

1798
01:04:05,199 --> 01:04:08,639
helps that's just a compiler bug

1799
01:04:07,119 --> 01:04:10,640
but i'm pretty sure it won't matter

1800
01:04:08,639 --> 01:04:12,078
because again the compiler already knows

1801
01:04:10,639 --> 01:04:15,598
that it's const

1802
01:04:12,079 --> 01:04:18,960
right um so it just doesn't matter

1803
01:04:15,599 --> 01:04:20,880
right i mean that's not relevant um

1804
01:04:18,960 --> 01:04:22,639
people always thinks const helps and it

1805
01:04:20,880 --> 01:04:23,920
doesn't because the compiler either

1806
01:04:22,639 --> 01:04:26,000
knows it's const already

1807
01:04:23,920 --> 01:04:27,280
or can't can't count on it anyway

1808
01:04:26,000 --> 01:04:29,119
because of constcat so there's

1809
01:04:27,280 --> 01:04:31,280
almost never a case where cost affects

1810
01:04:29,119 --> 01:04:33,920
optimization it's pretty important

1811
01:04:31,280 --> 01:04:35,839
right um so you kind of have to

1812
01:04:33,920 --> 01:04:37,760
understand that like

1813
01:04:35,838 --> 01:04:38,880
const doesn't usually help optimization

1814
01:04:37,760 --> 01:04:42,640
almost ever

1815
01:04:38,880 --> 01:04:44,798
right um so you can see that this is

1816
01:04:42,639 --> 01:04:46,719
just really bad code and if you really

1817
01:04:44,798 --> 01:04:49,038
wanted clang to generate this you would

1818
01:04:46,719 --> 01:04:50,239
probably try to do stuff to fool it into

1819
01:04:49,039 --> 01:04:52,079
writing better code

1820
01:04:50,239 --> 01:04:54,558
because this code is horrible how is

1821
01:04:52,079 --> 01:04:56,240
this code horrible well first of all

1822
01:04:54,559 --> 01:04:57,680
it doesn't need even if you're going to

1823
01:04:56,239 --> 01:04:59,118
do it this way where you write a one

1824
01:04:57,679 --> 01:05:01,118
then write four zeros then write a one

1825
01:04:59,119 --> 01:05:04,880
then write four zeros and write a one

1826
01:05:01,119 --> 01:05:07,920
right none of this code

1827
01:05:04,880 --> 01:05:08,160
none of these lines are necessary xmm0

1828
01:05:07,920 --> 01:05:10,400
is

1829
01:05:08,159 --> 01:05:11,440
already zero it doesn't need to store it

1830
01:05:10,400 --> 01:05:13,280
to the stack at all

1831
01:05:11,440 --> 01:05:15,200
and it doesn't need to load it from the

1832
01:05:13,280 --> 01:05:16,640
stack at all so literally you can just

1833
01:05:15,199 --> 01:05:19,838
delete these instructions

1834
01:05:16,639 --> 01:05:22,400
they don't do anything right so that's

1835
01:05:19,838 --> 01:05:24,000
incredibly bad code and and this is just

1836
01:05:22,400 --> 01:05:25,920
a bug in the back end as far as i'm

1837
01:05:24,000 --> 01:05:29,039
concerned like that that should never

1838
01:05:25,920 --> 01:05:30,798
have happened right um

1839
01:05:29,039 --> 01:05:32,079
let's see what would happen if we move

1840
01:05:30,798 --> 01:05:37,838
these outside

1841
01:05:32,079 --> 01:05:37,839
of the function does it change it at all

1842
01:05:40,239 --> 01:05:44,159
so it actually produces better code if

1843
01:05:42,719 --> 01:05:46,480
you move it outside

1844
01:05:44,159 --> 01:05:47,519
so actually if it if it doesn't know

1845
01:05:46,480 --> 01:05:50,880
that it's constant

1846
01:05:47,519 --> 01:05:52,880
it produces better code actually

1847
01:05:50,880 --> 01:05:55,680
it's still not necessarily fantastic

1848
01:05:52,880 --> 01:05:58,240
code but it's a lot better code

1849
01:05:55,679 --> 01:06:00,000
right like this is way way better code

1850
01:05:58,239 --> 01:06:01,199
in fact this may actually be more or

1851
01:06:00,000 --> 01:06:03,920
less optimal

1852
01:06:01,199 --> 01:06:04,719
um it's probably as good as the rep mav

1853
01:06:03,920 --> 01:06:07,760
sq

1854
01:06:04,719 --> 01:06:11,598
that msvc was doing

1855
01:06:07,760 --> 01:06:15,119
um so like yeah

1856
01:06:11,599 --> 01:06:16,880
moving those outside helps a ton um

1857
01:06:15,119 --> 01:06:18,559
but i'm not done talking about this so

1858
01:06:16,880 --> 01:06:21,200
i'm going to leave them

1859
01:06:18,559 --> 01:06:22,640
on the inside for now um because i want

1860
01:06:21,199 --> 01:06:25,279
to finish talking about this so

1861
01:06:22,639 --> 01:06:27,440
obviously hopefully everyone understands

1862
01:06:25,280 --> 01:06:29,440
why these instructions are ridiculous

1863
01:06:27,440 --> 01:06:31,039
they're because it's loading zero off of

1864
01:06:29,440 --> 01:06:32,000
three locations of stack even though it

1865
01:06:31,039 --> 01:06:34,160
was already zero

1866
01:06:32,000 --> 01:06:35,440
and doesn't need to be loaded at all so

1867
01:06:34,159 --> 01:06:37,118
even if

1868
01:06:35,440 --> 01:06:39,039
you wouldn't even have to replace these

1869
01:06:37,119 --> 01:06:40,960
lines with uh sorry replace these lines

1870
01:06:39,039 --> 01:06:43,760
with xor ps

1871
01:06:40,960 --> 01:06:45,599
because you already cleared it it's

1872
01:06:43,760 --> 01:06:47,920
already clear so you don't even need an

1873
01:06:45,599 --> 01:06:50,240
xrps here you can literally just delete

1874
01:06:47,920 --> 01:06:51,920
these lines completely they don't do

1875
01:06:50,239 --> 01:06:55,199
anything

1876
01:06:51,920 --> 01:06:57,358
but even if you deleted those lines

1877
01:06:55,199 --> 01:06:59,038
this code is still not very good and the

1878
01:06:57,358 --> 01:07:00,480
reason it's not very good is because if

1879
01:06:59,039 --> 01:07:01,599
we look at what's happening with that

1880
01:07:00,480 --> 01:07:03,920
code

1881
01:07:01,599 --> 01:07:04,640
what we can see is that it's executing

1882
01:07:03,920 --> 01:07:06,720
so skip

1883
01:07:04,639 --> 01:07:08,400
skip the mav aps let's assume that we

1884
01:07:06,719 --> 01:07:09,279
got rid of those and the compiler wasn't

1885
01:07:08,400 --> 01:07:12,798
quite as dumb

1886
01:07:09,280 --> 01:07:16,000
as it is so suppose it just did the mav

1887
01:07:12,798 --> 01:07:19,119
and the mafia ups is so that's one two

1888
01:07:16,000 --> 01:07:22,400
three four five six seven

1889
01:07:19,119 --> 01:07:24,079
right so it's requiring seven

1890
01:07:22,400 --> 01:07:29,838
instructions

1891
01:07:24,079 --> 01:07:29,839
to move 64 bytes right

1892
01:07:33,358 --> 01:07:40,000
seven instructions to move 64 bytes

1893
01:07:36,880 --> 01:07:42,318
how many instructions should it take

1894
01:07:40,000 --> 01:07:44,400
right how many instructions should it

1895
01:07:42,318 --> 01:07:46,798
take to move 64 bytes

1896
01:07:44,400 --> 01:07:48,720
well if we assume that we're only on an

1897
01:07:46,798 --> 01:07:51,280
sse capable computer so we don't have

1898
01:07:48,719 --> 01:07:55,199
avx

1899
01:07:51,280 --> 01:07:57,440
then if we wanted to use move ups for

1900
01:07:55,199 --> 01:08:01,439
example which is the largest move

1901
01:07:57,440 --> 01:08:04,480
available on an sse target machine

1902
01:08:01,440 --> 01:08:06,639
move ups moves 16 bytes so to

1903
01:08:04,480 --> 01:08:07,679
write 64 bytes to memory we should

1904
01:08:06,639 --> 01:08:11,118
require four

1905
01:08:07,679 --> 01:08:11,440
instructions four move ups if we just

1906
01:08:11,119 --> 01:08:13,599
did

1907
01:08:11,440 --> 01:08:14,480
four move ups we would write the entire

1908
01:08:13,599 --> 01:08:18,159
thing

1909
01:08:14,480 --> 01:08:22,238
but because it chose to write the one

1910
01:08:18,158 --> 01:08:24,639
as an actual separate scalar move

1911
01:08:22,238 --> 01:08:27,198
we're creating seven instructions where

1912
01:08:24,640 --> 01:08:30,798
four would have been sufficient

1913
01:08:27,198 --> 01:08:33,838
scalar moves and wide moves

1914
01:08:30,798 --> 01:08:37,119
happen on the same ports

1915
01:08:33,838 --> 01:08:39,039
ports for memory ops are

1916
01:08:37,119 --> 01:08:40,399
not dependent on whether they're scalar

1917
01:08:39,039 --> 01:08:43,759
or not

1918
01:08:40,399 --> 01:08:45,599
in skylake so if we pop back to our uaps

1919
01:08:43,759 --> 01:08:49,359
table

1920
01:08:45,600 --> 01:08:51,120
we can see just how bad this is

1921
01:08:49,359 --> 01:08:53,440
so let's go ahead and take a look at

1922
01:08:51,119 --> 01:08:56,960
imav and what you can see

1923
01:08:53,439 --> 01:08:58,158
is that if you look at everything that's

1924
01:08:56,960 --> 01:09:02,719
written here

1925
01:08:58,158 --> 01:09:06,079
all of the mob stuff that we care about

1926
01:09:02,719 --> 01:09:08,319
is where is the mob that we care

1927
01:09:06,079 --> 01:09:08,318
about

1928
01:09:10,319 --> 01:09:14,480
oh right it never mind uh so one of the

1929
01:09:13,600 --> 01:09:16,159
interesting i was

1930
01:09:14,479 --> 01:09:18,158
looking for the r64 this is actually a

1931
01:09:16,158 --> 01:09:19,759
32-bit mob right the art the

1932
01:09:18,158 --> 01:09:21,358
uh it's gonna be a move quad word if

1933
01:09:19,759 --> 01:09:22,399
it's not so i've got that there's a

1934
01:09:21,359 --> 01:09:23,600
little brain front my part

1935
01:09:22,399 --> 01:09:27,599
so this is the part we're talking about

1936
01:09:23,600 --> 01:09:27,600
here right oops

1937
01:09:30,719 --> 01:09:39,279
i take that back

1938
01:09:34,640 --> 01:09:41,119
where is it where's the immediate move

1939
01:09:39,279 --> 01:09:43,920
so this is a move immediate to a memory

1940
01:09:41,119 --> 01:09:43,920
location right

1941
01:09:46,838 --> 01:09:49,838
it's

1942
01:09:54,640 --> 01:09:57,840
so i don't know where it is it may be

1943
01:09:56,880 --> 01:10:03,840
that it's

1944
01:09:57,840 --> 01:10:03,840
named differently in here

1945
01:10:04,960 --> 01:10:10,719
it may be because these are only

1946
01:10:06,640 --> 01:10:10,719
micro-ops so it's actually gonna do

1947
01:10:12,960 --> 01:10:17,840
a different one of these

1948
01:10:18,880 --> 01:10:22,239
but i don't see any immediates in here

1949
01:10:20,479 --> 01:10:23,359
so why can't i get the immediates in

1950
01:10:22,238 --> 01:10:25,839
here

1951
01:10:23,359 --> 01:10:31,839
what am i missing do i need to tell it

1952
01:10:25,840 --> 01:10:31,840
something else

1953
01:10:36,719 --> 01:10:39,198
because it should be in the base

1954
01:10:37,760 --> 01:10:40,640
instruction set and there should be a

1955
01:10:39,198 --> 01:10:45,839
mod for an immediate

1956
01:10:40,640 --> 01:10:45,840
but it doesn't look like there is

1957
01:10:49,920 --> 01:10:55,760
so this may be above my pay grade of why

1958
01:10:52,158 --> 01:10:59,359
the ups info table doesn't have

1959
01:10:55,760 --> 01:11:03,280
mauve on there

1960
01:10:59,359 --> 01:11:05,279
as moth these will be um

1961
01:11:03,279 --> 01:11:06,559
these are all on here where's my ssa

1962
01:11:05,279 --> 01:11:08,880
there it is

1963
01:11:06,560 --> 01:11:11,440
so these are easy to understand you can

1964
01:11:08,880 --> 01:11:14,560
see and the scalar move is the same so

1965
01:11:11,439 --> 01:11:18,158
port tooth to ports two

1966
01:11:14,560 --> 01:11:21,520
and three um are the ports on which

1967
01:11:18,158 --> 01:11:22,399
this can happen so when you are doing a

1968
01:11:21,520 --> 01:11:25,280
right

1969
01:11:22,399 --> 01:11:26,079
uh you can see that like if you're

1970
01:11:25,279 --> 01:11:29,519
trying to do

1971
01:11:26,079 --> 01:11:32,880
a move from a register to memory

1972
01:11:29,520 --> 01:11:36,480
or uh from reddit for from a register to

1973
01:11:32,880 --> 01:11:39,600
memory or from memory to a register

1974
01:11:36,479 --> 01:11:43,198
you can actually see uh what's required

1975
01:11:39,600 --> 01:11:45,440
by looking at the uh by looking at the

1976
01:11:43,198 --> 01:11:45,439
um

1977
01:11:46,319 --> 01:11:57,119
port usage here what these are i can't

1978
01:11:54,319 --> 01:11:57,119
say that i know

1979
01:12:00,880 --> 01:12:05,440
oh i know what these are so this must be

1980
01:12:04,000 --> 01:12:06,960
the nomenclature they give to

1981
01:12:05,439 --> 01:12:09,039
so okay you can see a register to

1982
01:12:06,960 --> 01:12:10,000
register move is free because it happens

1983
01:12:09,039 --> 01:12:11,840
in the rename

1984
01:12:10,000 --> 01:12:13,840
so these are probably just what the

1985
01:12:11,840 --> 01:12:14,880
names they gave to those front-end

1986
01:12:13,840 --> 01:12:16,319
micro-ops

1987
01:12:14,880 --> 01:12:18,719
i've never seen that before so i didn't

1988
01:12:16,319 --> 01:12:19,279
know these had a name but it looks like

1989
01:12:18,719 --> 01:12:22,158
these

1990
01:12:19,279 --> 01:12:23,039
are synthetic things at the upset info

1991
01:12:22,158 --> 01:12:24,158
people i don't know if these are

1992
01:12:23,039 --> 01:12:25,840
standardized

1993
01:12:24,158 --> 01:12:27,599
but these must be synthetic things they

1994
01:12:25,840 --> 01:12:30,960
gave to

1995
01:12:27,600 --> 01:12:37,760
um to basically say look

1996
01:12:30,960 --> 01:12:41,119
this is what the um

1997
01:12:37,760 --> 01:12:41,920
this is what we're calling the micro up

1998
01:12:41,119 --> 01:12:44,399
that

1999
01:12:41,920 --> 01:12:45,199
renames and it's weird to call it a

2000
01:12:44,399 --> 01:12:47,119
micro up but

2001
01:12:45,198 --> 01:12:48,839
it basically says if i have two

2002
01:12:47,119 --> 01:12:50,079
registers and i want to copy one to

2003
01:12:48,840 --> 01:12:52,079
another

2004
01:12:50,079 --> 01:12:53,679
that's never actually doing an operation

2005
01:12:52,079 --> 01:12:56,158
it's just renaming

2006
01:12:53,679 --> 01:12:58,158
that value by giving it a new name so so

2007
01:12:56,158 --> 01:13:00,079
then now that value has two names

2008
01:12:58,158 --> 01:13:02,238
in the front end rather than one right

2009
01:13:00,079 --> 01:13:05,039
in the register allocation table

2010
01:13:02,238 --> 01:13:06,559
um so that's probably what these

2011
01:13:05,039 --> 01:13:08,158
nomenclatures are we haven't really

2012
01:13:06,560 --> 01:13:11,600
gotten to the rat yet but

2013
01:13:08,158 --> 01:13:14,479
we'll get there eventually um so these

2014
01:13:11,600 --> 01:13:16,320
here are the two move ups this one is

2015
01:13:14,479 --> 01:13:16,639
moving a register into memory this one

2016
01:13:16,319 --> 01:13:20,479
is

2017
01:13:16,640 --> 01:13:24,000
is moving um a

2018
01:13:20,479 --> 01:13:25,198
uh memory into a register so this is

2019
01:13:24,000 --> 01:13:27,279
like a load

2020
01:13:25,198 --> 01:13:28,479
right and this is like a store if that

2021
01:13:27,279 --> 01:13:30,880
makes sense

2022
01:13:28,479 --> 01:13:32,079
um as you can see here the breakdown of

2023
01:13:30,880 --> 01:13:34,640
ports uh

2024
01:13:32,079 --> 01:13:35,198
you can see that port four is necessary

2025
01:13:34,640 --> 01:13:38,480
for

2026
01:13:35,198 --> 01:13:42,960
storing um and then ports two three or

2027
01:13:38,479 --> 01:13:44,559
seven can all be used for uh

2028
01:13:42,960 --> 01:13:45,760
for address generation so the thing that

2029
01:13:44,560 --> 01:13:46,960
actually determines like where this

2030
01:13:45,760 --> 01:13:48,239
thing's gonna get stored

2031
01:13:46,960 --> 01:13:50,719
that looks like what it's trying to say

2032
01:13:48,238 --> 01:13:52,879
here um and unfortunately i can't seem

2033
01:13:50,719 --> 01:13:56,239
to load that out of this one and i

2034
01:13:52,880 --> 01:13:56,239
don't know why um

2035
01:13:57,439 --> 01:14:01,439
i i don't really know why that is i

2036
01:13:59,520 --> 01:14:04,719
should be able to find

2037
01:14:01,439 --> 01:14:09,039
uh this here i mean this is sort of like

2038
01:14:04,719 --> 01:14:09,039
what it looks like right i mean this is

2039
01:14:09,359 --> 01:14:13,759
uh a move from a register to memory so

2040
01:14:12,000 --> 01:14:17,279
you can see it's the same exact

2041
01:14:13,760 --> 01:14:18,159
breakdown as as the mav here so it's

2042
01:14:17,279 --> 01:14:19,439
like

2043
01:14:18,158 --> 01:14:21,279
writing to memory looks basically

2044
01:14:19,439 --> 01:14:23,279
exactly the same but i'm not sure i've

2045
01:14:21,279 --> 01:14:24,800
never really looked up the mobs in this

2046
01:14:23,279 --> 01:14:26,559
upset info table and

2047
01:14:24,800 --> 01:14:28,239
i have to admit it throws me for a

2048
01:14:26,560 --> 01:14:29,760
little bit of loop these look like

2049
01:14:28,238 --> 01:14:31,119
exactly what i would expect except that

2050
01:14:29,760 --> 01:14:32,719
i didn't know that they gave names to

2051
01:14:31,119 --> 01:14:35,679
these

2052
01:14:32,719 --> 01:14:36,158
this doesn't and i'm not so i'm not sure

2053
01:14:35,679 --> 01:14:40,079
why

2054
01:14:36,158 --> 01:14:41,279
it seems so limited there and and

2055
01:14:40,079 --> 01:14:42,880
you know i would have expected to see

2056
01:14:41,279 --> 01:14:44,559
other permutations of moths and and

2057
01:14:42,880 --> 01:14:46,159
there might be a reason for that

2058
01:14:44,560 --> 01:14:48,320
it might be that there's like some kind

2059
01:14:46,158 --> 01:14:50,479
of a different name that they give those

2060
01:14:48,319 --> 01:14:52,719
and so you don't look them up by the

2061
01:14:50,479 --> 01:14:56,158
actual assembly language mnemonic

2062
01:14:52,719 --> 01:14:57,840
you look it up by uh something else um

2063
01:14:56,158 --> 01:14:59,759
and we can look in the intel and turns

2064
01:14:57,840 --> 01:15:00,800
this guide i'm not the intelligent chat

2065
01:14:59,760 --> 01:15:03,760
the um

2066
01:15:00,800 --> 01:15:04,719
intel programmers manual to see um what

2067
01:15:03,760 --> 01:15:08,480
it actually says

2068
01:15:04,719 --> 01:15:10,239
because it might uh guide us

2069
01:15:08,479 --> 01:15:11,519
a little bit better there so if i go

2070
01:15:10,238 --> 01:15:14,000
ahead and pull this up

2071
01:15:11,520 --> 01:15:15,040
and we look at mauve and here we can see

2072
01:15:14,000 --> 01:15:17,760
um

2073
01:15:15,039 --> 01:15:18,640
if there's yeah but i mean even just

2074
01:15:17,760 --> 01:15:20,719
looking at

2075
01:15:18,640 --> 01:15:21,920
at this right like i was expecting to

2076
01:15:20,719 --> 01:15:23,760
see mav q

2077
01:15:21,920 --> 01:15:25,199
in there as well right and you know i

2078
01:15:23,760 --> 01:15:28,960
typed in

2079
01:15:25,198 --> 01:15:29,519
um mav and and it doesn't even have mob

2080
01:15:28,960 --> 01:15:31,198
q

2081
01:15:29,520 --> 01:15:33,440
in there which which doesn't make a

2082
01:15:31,198 --> 01:15:35,119
whole lot of sense um to me i guess i

2083
01:15:33,439 --> 01:15:36,839
guess because it's only in ssc so that's

2084
01:15:35,119 --> 01:15:39,519
fine

2085
01:15:36,840 --> 01:15:43,039
um so maybe that's

2086
01:15:39,520 --> 01:15:43,040
uh part of it let's see here

2087
01:15:44,319 --> 01:15:48,880
no it's just not there well at least mob

2088
01:15:47,600 --> 01:15:51,360
q is there

2089
01:15:48,880 --> 01:15:52,480
i don't know um so let's say we look at

2090
01:15:51,359 --> 01:15:55,359
mob q

2091
01:15:52,479 --> 01:15:57,039
right um if we look at mavq that's a

2092
01:15:55,359 --> 01:16:00,000
64-bit write

2093
01:15:57,039 --> 01:16:00,640
um sorry 64-bit load from register to

2094
01:16:00,000 --> 01:16:02,479
register

2095
01:16:00,640 --> 01:16:04,800
right and so here's one that's like

2096
01:16:02,479 --> 01:16:06,319
writing 64-bits to memory

2097
01:16:04,800 --> 01:16:08,400
uh and you can see that's the exact same

2098
01:16:06,319 --> 01:16:10,719
thing same port usage

2099
01:16:08,399 --> 01:16:12,559
so i don't know why ups is weird there

2100
01:16:10,719 --> 01:16:15,039
if somebody else knows why

2101
01:16:12,560 --> 01:16:16,560
uh it doesn't have like here's here's

2102
01:16:15,039 --> 01:16:18,238
mob for example

2103
01:16:16,560 --> 01:16:19,600
here's all the permutations of mauve

2104
01:16:18,238 --> 01:16:21,519
there's like a ton of them

2105
01:16:19,600 --> 01:16:24,719
right you can see how many mobs there

2106
01:16:21,520 --> 01:16:27,120
are there's like infinite mobs

2107
01:16:24,719 --> 01:16:28,640
uh and i don't know why like here's a

2108
01:16:27,119 --> 01:16:31,198
mob for example

2109
01:16:28,640 --> 01:16:32,800
uh that didn't show up in the uops table

2110
01:16:31,198 --> 01:16:35,519
there right i mean

2111
01:16:32,800 --> 01:16:37,119
so i just don't know i i couldn't say uh

2112
01:16:35,520 --> 01:16:37,760
it might be just because they figure

2113
01:16:37,119 --> 01:16:39,840
well

2114
01:16:37,760 --> 01:16:41,280
we didn't want to list them all and and

2115
01:16:39,840 --> 01:16:42,800
we know that it's it's basically just

2116
01:16:41,279 --> 01:16:44,880
gonna be the same

2117
01:16:42,800 --> 01:16:46,719
uh port breakdown as this one is so just

2118
01:16:44,880 --> 01:16:48,400
use that one i don't know uh somebody

2119
01:16:46,719 --> 01:16:50,480
who works on upside info maybe can clue

2120
01:16:48,399 --> 01:16:52,479
us in on what's going on there

2121
01:16:50,479 --> 01:16:54,000
all of that i apologize for wasting so

2122
01:16:52,479 --> 01:16:55,519
much time on that but all of that was

2123
01:16:54,000 --> 01:16:59,198
just to say

2124
01:16:55,520 --> 01:17:01,440
mob and mob aps and mob ups

2125
01:16:59,198 --> 01:17:03,599
they're all banging on the same ports

2126
01:17:01,439 --> 01:17:07,839
right so it doesn't

2127
01:17:03,600 --> 01:17:10,159
benefit you at all to insert

2128
01:17:07,840 --> 01:17:11,360
32-bit moves in the middle of your

2129
01:17:10,158 --> 01:17:17,839
64-bit moves

2130
01:17:11,359 --> 01:17:17,839
there's no reason to do so

2131
01:17:20,000 --> 01:17:25,439
what's the problem oh the orange look at

2132
01:17:21,760 --> 01:17:25,440
chat okay re-say what the chat is

2133
01:17:25,679 --> 01:17:31,840
oh was the whole time there was another

2134
01:17:27,439 --> 01:17:31,839
page are you kidding me right now

2135
01:17:32,560 --> 01:17:37,840
where's the where's the oh it's behind

2136
01:17:35,439 --> 01:17:39,519
my head

2137
01:17:37,840 --> 01:17:42,840
i don't feel like that's the owl of

2138
01:17:39,520 --> 01:17:44,400
shame i couldn't see it it was behind my

2139
01:17:42,840 --> 01:17:48,480
head

2140
01:17:44,399 --> 01:17:50,799
no all right

2141
01:17:48,479 --> 01:17:54,238
thank god i thought i was losing my mind

2142
01:17:50,800 --> 01:17:54,239
i'm like what is going on

2143
01:17:55,600 --> 01:18:01,920
all right thank you chat

2144
01:17:59,039 --> 01:18:03,119
thank god all right so this is what i

2145
01:18:01,920 --> 01:18:05,760
was expecting to see

2146
01:18:03,119 --> 01:18:07,198
i'm like god i even thought in my head

2147
01:18:05,760 --> 01:18:08,560
i'm like haven't i ever looked at this

2148
01:18:07,198 --> 01:18:09,839
in your feeling like maybe i haven't

2149
01:18:08,560 --> 01:18:10,640
because it's just kind of obvious so i

2150
01:18:09,840 --> 01:18:14,319
wouldn't bother

2151
01:18:10,640 --> 01:18:17,440
i mean i don't know okay thank god so

2152
01:18:14,319 --> 01:18:20,000
finally here's this is what i wanted

2153
01:18:17,439 --> 01:18:20,960
this these are what i wanted so this is

2154
01:18:20,000 --> 01:18:24,000
moving amer

2155
01:18:20,960 --> 01:18:27,039
um uh immediate 32-bit immediate

2156
01:18:24,000 --> 01:18:30,158
to a memory location right

2157
01:18:27,039 --> 01:18:33,039
so we can find that one on here

2158
01:18:30,158 --> 01:18:34,960
uh and and this this is it right this is

2159
01:18:33,039 --> 01:18:38,399
oh no sorry uh this is

2160
01:18:34,960 --> 01:18:40,399
it right here right

2161
01:18:38,399 --> 01:18:41,839
32-bit immediate moves to a 30-bit

2162
01:18:40,399 --> 01:18:44,319
memory location

2163
01:18:41,840 --> 01:18:45,520
and you can see that the ports are 237

2164
01:18:44,319 --> 01:18:46,880
plus 1p4

2165
01:18:45,520 --> 01:18:50,080
right so it's going to take two

2166
01:18:46,880 --> 01:18:52,319
micro-apps one is p37 i believe that

2167
01:18:50,079 --> 01:18:53,600
first micro up is the address generation

2168
01:18:52,319 --> 01:18:58,158
so basically what that is

2169
01:18:53,600 --> 01:18:59,440
is this thing it's taking this rbx plus

2170
01:18:58,158 --> 01:19:00,960
rax and turning it into an

2171
01:18:59,439 --> 01:19:02,719
actual like location that it's going to

2172
01:19:00,960 --> 01:19:06,079
write to right

2173
01:19:02,719 --> 01:19:07,840
uh and then the one times p4 p4 is the

2174
01:19:06,079 --> 01:19:08,640
right port so that's the execution port

2175
01:19:07,840 --> 01:19:10,560
that actually

2176
01:19:08,640 --> 01:19:12,159
like once you have an address and you

2177
01:19:10,560 --> 01:19:12,719
have a value it's going to put it out

2178
01:19:12,158 --> 01:19:16,559
there

2179
01:19:12,719 --> 01:19:19,760
right makes sense um

2180
01:19:16,560 --> 01:19:20,560
so just so you know that's that's what's

2181
01:19:19,760 --> 01:19:24,239
actually

2182
01:19:20,560 --> 01:19:26,560
going on there right okay whoo

2183
01:19:24,238 --> 01:19:28,158
i'm glad i wasn't crazy because i'm like

2184
01:19:26,560 --> 01:19:30,159
what the heck i'm like where's all the

2185
01:19:28,158 --> 01:19:33,920
mobs there's so many of them

2186
01:19:30,158 --> 01:19:35,198
um all right so as you can see

2187
01:19:33,920 --> 01:19:37,279
this is all gonna hammer on the exact

2188
01:19:35,198 --> 01:19:40,960
same port so this is just a disaster

2189
01:19:37,279 --> 01:19:44,238
this loop is crazy slow for no reason um

2190
01:19:40,960 --> 01:19:46,480
it should just be four move ups's

2191
01:19:44,238 --> 01:19:47,839
because all it really needs to do is

2192
01:19:46,479 --> 01:19:51,439
have xmm0

2193
01:19:47,840 --> 01:19:54,000
one two and three have one zero zero

2194
01:19:51,439 --> 01:19:55,119
zero one zero zero zero zero one zero

2195
01:19:54,000 --> 01:19:58,000
and zero zero zero

2196
01:19:55,119 --> 01:19:59,198
one and just right right right right

2197
01:19:58,000 --> 01:20:01,760
right right right right

2198
01:19:59,198 --> 01:20:02,719
right right right right right so if we

2199
01:20:01,760 --> 01:20:05,920
want to help

2200
01:20:02,719 --> 01:20:09,279
out clang and say hey clang i know

2201
01:20:05,920 --> 01:20:10,960
it's been a bad day right

2202
01:20:09,279 --> 01:20:12,960
uh in fact i guess i'll just do it this

2203
01:20:10,960 --> 01:20:17,279
way to avoid confusion

2204
01:20:12,960 --> 01:20:20,560
um i'm just gonna say look

2205
01:20:17,279 --> 01:20:22,880
let's help you out here let's tell you

2206
01:20:20,560 --> 01:20:25,120
what is going on because you obviously

2207
01:20:22,880 --> 01:20:28,400
don't know and are very confused

2208
01:20:25,119 --> 01:20:31,279
about the world um let's create

2209
01:20:28,399 --> 01:20:33,519
three explicit register values that you

2210
01:20:31,279 --> 01:20:37,439
can use

2211
01:20:33,520 --> 01:20:41,120
like so um and then let's tell you

2212
01:20:37,439 --> 01:20:42,879
how to actually do your job so let's do

2213
01:20:41,119 --> 01:20:46,960
a well you know what i'll just put a

2214
01:20:42,880 --> 01:20:50,400
little if zero in here

2215
01:20:46,960 --> 01:20:50,399
so we'll get rid of this right

2216
01:20:54,800 --> 01:21:03,840
like so

2217
01:21:00,158 --> 01:21:07,759
and i'm just gonna try to store

2218
01:21:03,840 --> 01:21:07,760
the rows myself

2219
01:21:10,960 --> 01:21:14,000
right so you can see me trying to store

2220
01:21:13,279 --> 01:21:16,158
one row there

2221
01:21:14,000 --> 01:21:19,119
and i just want to store all four rows

2222
01:21:16,158 --> 01:21:19,119
like so

2223
01:21:19,359 --> 01:21:24,000
um and here is the new code that base

2224
01:21:22,158 --> 01:21:27,759
says all right i'm gonna generate

2225
01:21:24,000 --> 01:21:29,359
hopefully four registers xm0123 or

2226
01:21:27,760 --> 01:21:31,520
something right

2227
01:21:29,359 --> 01:21:32,880
each register will be set to one row of

2228
01:21:31,520 --> 01:21:35,520
the matrix and i believe

2229
01:21:32,880 --> 01:21:37,039
set rps is the way that you say that you

2230
01:21:35,520 --> 01:21:43,840
want to go in memory order

2231
01:21:37,039 --> 01:21:43,840
um let me just make sure that's true

2232
01:21:44,800 --> 01:21:51,119
before i lead everyone down a bum path

2233
01:21:48,880 --> 01:21:51,119
there

2234
01:21:54,158 --> 01:21:57,439
oh no it's not okay so it is normally

2235
01:21:56,158 --> 01:21:58,879
memory order is that right

2236
01:21:57,439 --> 01:22:00,479
i almost never use these functions

2237
01:21:58,880 --> 01:22:03,600
directly i always

2238
01:22:00,479 --> 01:22:10,158
have them like written in my own version

2239
01:22:03,600 --> 01:22:12,719
so no that's not it so set ps

2240
01:22:10,158 --> 01:22:13,839
oh no it is it is because they're in

2241
01:22:12,719 --> 01:22:16,560
opposite order

2242
01:22:13,840 --> 01:22:18,000
in the parameters so yeah it's set rps

2243
01:22:16,560 --> 01:22:19,679
if we want them in memory order which

2244
01:22:18,000 --> 01:22:22,399
which is what i wanted

2245
01:22:19,679 --> 01:22:23,600
um so here's them set uh to the various

2246
01:22:22,399 --> 01:22:24,799
rows of the matrix so we're not going to

2247
01:22:23,600 --> 01:22:26,880
use this we're just going to set these

2248
01:22:24,800 --> 01:22:29,760
up directly so the compiler understands

2249
01:22:26,880 --> 01:22:30,239
what they are uh and then we've got uh

2250
01:22:29,760 --> 01:22:32,400
this

2251
01:22:30,238 --> 01:22:33,599
storing here we're going to store each

2252
01:22:32,399 --> 01:22:36,638
row of the matrix

2253
01:22:33,600 --> 01:22:37,440
as as written right and then i'm going

2254
01:22:36,639 --> 01:22:39,520
to see

2255
01:22:37,439 --> 01:22:41,279
if that helps this thing out at all i

2256
01:22:39,520 --> 01:22:42,400
don't know if it will or if it won't but

2257
01:22:41,279 --> 01:22:45,759
we'll see

2258
01:22:42,399 --> 01:22:47,839
um and lo and behold yes it does uh so

2259
01:22:45,760 --> 01:22:50,159
if you look at what actually happens

2260
01:22:47,840 --> 01:22:51,279
with this piece of code it actually has

2261
01:22:50,158 --> 01:22:53,839
produced

2262
01:22:51,279 --> 01:22:54,880
exactly the right code now and if you're

2263
01:22:53,840 --> 01:22:56,880
wondering why

2264
01:22:54,880 --> 01:22:58,719
there's eight stores instead of four

2265
01:22:56,880 --> 01:22:59,600
it's because it chose to unroll this

2266
01:22:58,719 --> 01:23:02,800
loop

2267
01:22:59,600 --> 01:23:07,039
one time why it chose to enroll this

2268
01:23:02,800 --> 01:23:21,840
loop one time

2269
01:23:07,039 --> 01:23:21,840
um hmm

2270
01:23:22,479 --> 01:23:27,198
i don't know why it chose to enroll the

2271
01:23:24,719 --> 01:23:31,920
loop that may be because it's thinking

2272
01:23:27,198 --> 01:23:31,919
of a broad set of architectures so

2273
01:23:32,000 --> 01:23:37,920
when you issue

2274
01:23:35,439 --> 01:23:40,079
because this is free so the sub comp

2275
01:23:37,920 --> 01:23:41,920
jump is gonna snuggle up in here

2276
01:23:40,079 --> 01:23:44,158
and just be executed in parallel with

2277
01:23:41,920 --> 01:23:44,158
this

2278
01:23:45,840 --> 01:23:50,480
there's no way to issue four stores per

2279
01:23:48,560 --> 01:23:53,600
cycle you can only issue

2280
01:23:50,479 --> 01:23:55,919
two stores per cycle at most so

2281
01:23:53,600 --> 01:23:57,120
the fact that this is dependent the sub

2282
01:23:55,920 --> 01:23:59,279
comp jump

2283
01:23:57,119 --> 01:24:00,639
it should just nestle correctly where it

2284
01:23:59,279 --> 01:24:03,039
will do

2285
01:24:00,639 --> 01:24:04,319
if you had just had four it would do the

2286
01:24:03,039 --> 01:24:06,079
sub with the first one

2287
01:24:04,319 --> 01:24:08,158
and the comp with the next one and then

2288
01:24:06,079 --> 01:24:11,600
it would go to the next part of the loop

2289
01:24:08,158 --> 01:24:13,839
i don't actually know if there would be

2290
01:24:11,600 --> 01:24:15,039
any value at all to unrolling this loop

2291
01:24:13,840 --> 01:24:17,760
i can't

2292
01:24:15,039 --> 01:24:18,880
say that i would expect her to be so why

2293
01:24:17,760 --> 01:24:21,119
the heuristics

2294
01:24:18,880 --> 01:24:22,400
told it to do that it may be because

2295
01:24:21,119 --> 01:24:22,800
it's thinking about more architectures

2296
01:24:22,399 --> 01:24:25,279
than i

2297
01:24:22,800 --> 01:24:25,840
am so it's like broader it certainly

2298
01:24:25,279 --> 01:24:28,639
can't

2299
01:24:25,840 --> 01:24:29,199
hurt it's not really like gonna ruin

2300
01:24:28,639 --> 01:24:33,119
anything

2301
01:24:29,198 --> 01:24:33,119
that it chose to do that um

2302
01:24:35,760 --> 01:24:38,480
so like

2303
01:24:41,840 --> 01:24:45,840
i yeah i mean i wish i had an

2304
01:24:44,639 --> 01:24:50,400
explanation here

2305
01:24:45,840 --> 01:24:50,400
for that but but i but i i don't um

2306
01:24:52,560 --> 01:24:56,800
i i really don't know and you can see

2307
01:24:54,880 --> 01:24:58,000
that there's issues that it's created so

2308
01:24:56,800 --> 01:24:59,760
the fact that it chose to do

2309
01:24:58,000 --> 01:25:01,520
this means it had to do a little bit

2310
01:24:59,760 --> 01:25:02,560
more fancy footwork here than if it had

2311
01:25:01,520 --> 01:25:04,480
just done

2312
01:25:02,560 --> 01:25:06,239
what i told it to do and i think what i

2313
01:25:04,479 --> 01:25:09,198
told to do is honestly still better so i

2314
01:25:06,238 --> 01:25:11,439
still think clang is kind of

2315
01:25:09,198 --> 01:25:13,039
um wearing a slight dance cap here but i

2316
01:25:11,439 --> 01:25:14,399
don't know like me there may be some

2317
01:25:13,039 --> 01:25:15,840
reason to unroll this so i'm not going

2318
01:25:14,399 --> 01:25:17,679
to say i'm not going to criticize it

2319
01:25:15,840 --> 01:25:19,039
because maybe that's actually smart on

2320
01:25:17,679 --> 01:25:19,760
some architectures and so on like maybe

2321
01:25:19,039 --> 01:25:22,158
that's a good thing

2322
01:25:19,760 --> 01:25:23,920
so but point being now you can see we've

2323
01:25:22,158 --> 01:25:25,679
got it much cleaner this is

2324
01:25:23,920 --> 01:25:27,840
probably twice as fast as the other loop

2325
01:25:25,679 --> 01:25:28,639
was because rather than doing seven

2326
01:25:27,840 --> 01:25:31,199
instructions

2327
01:25:28,639 --> 01:25:32,719
it's doing four instructions per matrix

2328
01:25:31,198 --> 01:25:34,079
four instructions per matrix is almost

2329
01:25:32,719 --> 01:25:37,679
twice as fast as seven instructions for

2330
01:25:34,079 --> 01:25:37,679
matrix that's just kind of how that goes

2331
01:25:38,479 --> 01:25:41,839
so there you go

2332
01:25:42,560 --> 01:25:46,400
yeah and anyone who thinks that like the

2333
01:25:44,000 --> 01:25:48,479
o3 help it didn't we can put o3 on now

2334
01:25:46,399 --> 01:25:50,479
to see if it changes but it it didn't

2335
01:25:48,479 --> 01:25:51,759
seem to change at all what we were doing

2336
01:25:50,479 --> 01:25:53,599
uh we can leave it on though there's no

2337
01:25:51,760 --> 01:25:56,639
reason to have it not on there but it

2338
01:25:53,600 --> 01:25:56,639
basically does the same thing

2339
01:25:56,800 --> 01:26:03,119
so that's at least sane and

2340
01:26:00,079 --> 01:26:05,279
this is also why um

2341
01:26:03,119 --> 01:26:06,559
i tend to write things out explicitly as

2342
01:26:05,279 --> 01:26:08,719
often as i can

2343
01:26:06,560 --> 01:26:10,239
because compilers just aren't very good

2344
01:26:08,719 --> 01:26:11,198
a lot of people think compilers are

2345
01:26:10,238 --> 01:26:13,359
smarter than they are

2346
01:26:11,198 --> 01:26:14,559
they're not um that argument's been had

2347
01:26:13,359 --> 01:26:16,000
on twitter before

2348
01:26:14,560 --> 01:26:17,760
and the people who say the compiler

2349
01:26:16,000 --> 01:26:19,439
smarter than a programmer

2350
01:26:17,760 --> 01:26:22,320
must be talking about other programmers

2351
01:26:19,439 --> 01:26:25,279
because i come across this sort of thing

2352
01:26:22,319 --> 01:26:27,279
all the time and that previous loop i

2353
01:26:25,279 --> 01:26:29,198
will absolutely stake my reputation on

2354
01:26:27,279 --> 01:26:32,238
using seven cycles

2355
01:26:29,198 --> 01:26:36,158
to set 64 bytes is just plain dumb

2356
01:26:32,238 --> 01:26:37,599
um again i am no optimization god

2357
01:26:36,158 --> 01:26:39,279
and you shouldn't take my word for

2358
01:26:37,600 --> 01:26:41,840
anything optimization related but

2359
01:26:39,279 --> 01:26:43,679
that one is pretty blatant and i will be

2360
01:26:41,840 --> 01:26:45,840
shocked if someone

2361
01:26:43,679 --> 01:26:47,119
can point to me to something that

2362
01:26:45,840 --> 01:26:49,279
suggests that doing

2363
01:26:47,119 --> 01:26:50,238
that seven cycle sequence was better

2364
01:26:49,279 --> 01:26:55,119
than doing four mod

2365
01:26:50,238 --> 01:26:58,479
ups's i will be very shocked

2366
01:26:55,119 --> 01:27:00,158
anyway um getting back to

2367
01:26:58,479 --> 01:27:02,718
what was happening here if we switch

2368
01:27:00,158 --> 01:27:05,679
back to the other version really quickly

2369
01:27:02,719 --> 01:27:07,840
um i wanted to point out briefly what

2370
01:27:05,679 --> 01:27:09,119
msvc was doing here and why i thought

2371
01:27:07,840 --> 01:27:12,639
this was

2372
01:27:09,119 --> 01:27:14,079
particularly cool um so basically

2373
01:27:12,639 --> 01:27:16,639
there's a thing built into intel

2374
01:27:14,079 --> 01:27:18,319
processors called the rep instruction

2375
01:27:16,639 --> 01:27:20,560
and it's kind of a really neat

2376
01:27:18,319 --> 01:27:23,119
instruction it basically says

2377
01:27:20,560 --> 01:27:24,239
hey i'm going to be doing a dumb simple

2378
01:27:23,119 --> 01:27:25,920
loop

2379
01:27:24,238 --> 01:27:27,678
either i'm going to write the same thing

2380
01:27:25,920 --> 01:27:29,440
a lot or i'm going to copy the same

2381
01:27:27,679 --> 01:27:32,000
thing a lot

2382
01:27:29,439 --> 01:27:33,519
why don't you just do that for me and

2383
01:27:32,000 --> 01:27:35,520
one of the nice things that's happened

2384
01:27:33,520 --> 01:27:37,440
is as the intel processors have gotten

2385
01:27:35,520 --> 01:27:40,800
more advanced their ability to do

2386
01:27:37,439 --> 01:27:43,839
high performance reps has gone up

2387
01:27:40,800 --> 01:27:44,400
so nowadays calling a rep instruction is

2388
01:27:43,840 --> 01:27:47,039
actually

2389
01:27:44,399 --> 01:27:47,920
really really fast and you know that

2390
01:27:47,039 --> 01:27:49,840
you're going to get

2391
01:27:47,920 --> 01:27:51,279
really good throughput on it because it

2392
01:27:49,840 --> 01:27:54,560
will be smart and use

2393
01:27:51,279 --> 01:27:56,479
large block moves where it can so

2394
01:27:54,560 --> 01:27:58,080
actually even though this kind of looks

2395
01:27:56,479 --> 01:28:00,319
like stupider code it's just calling

2396
01:27:58,079 --> 01:28:02,880
some processor instruction rep and

2397
01:28:00,319 --> 01:28:04,960
sometimes rep gets a bad name on modern

2398
01:28:02,880 --> 01:28:09,679
like skylight cores actually rep

2399
01:28:04,960 --> 01:28:12,960
is a pretty darn good instruction and so

2400
01:28:09,679 --> 01:28:15,840
if we look at the ups dot info for

2401
01:28:12,960 --> 01:28:15,840
rap for example

2402
01:28:16,079 --> 01:28:20,639
um here is

2403
01:28:21,520 --> 01:28:26,639
this is an uh sq right

2404
01:28:26,840 --> 01:28:29,840
so

2405
01:28:30,079 --> 01:28:35,840
i don't know i don't know how to ask i

2406
01:28:33,119 --> 01:28:38,079
i've never looked up this on

2407
01:28:35,840 --> 01:28:38,079
uh

2408
01:28:38,960 --> 01:28:43,840
i've never looked up a rep move

2409
01:28:50,880 --> 01:28:55,679
so i'm not sure which one this would be

2410
01:28:53,600 --> 01:28:58,000
closest

2411
01:28:55,679 --> 01:28:58,000
um

2412
01:29:00,158 --> 01:29:05,920
because i'm not sure which of these

2413
01:29:03,600 --> 01:29:08,840
would map to a rep mavs cue this is just

2414
01:29:05,920 --> 01:29:11,679
my naivete with rep mods

2415
01:29:08,840 --> 01:29:13,760
um let's pick one

2416
01:29:11,679 --> 01:29:15,199
uh let's this would just be the bite one

2417
01:29:13,760 --> 01:29:18,480
probably right

2418
01:29:15,198 --> 01:29:22,479
um so if you take a look here uh

2419
01:29:18,479 --> 01:29:25,759
at doing this on skylake

2420
01:29:22,479 --> 01:29:26,559
here you can see um so you can see like

2421
01:29:25,760 --> 01:29:28,880
the cost

2422
01:29:26,560 --> 01:29:29,840
of the ports and it's pretty confusing

2423
01:29:28,880 --> 01:29:33,600
confusing

2424
01:29:29,840 --> 01:29:34,159
right um because the problem is it's a

2425
01:29:33,600 --> 01:29:36,079
loop

2426
01:29:34,158 --> 01:29:37,599
so it's pretty hard to determine like

2427
01:29:36,079 --> 01:29:39,439
what the heck is going on

2428
01:29:37,600 --> 01:29:41,600
in here when you look at the actual port

2429
01:29:39,439 --> 01:29:43,678
usage of it it's just like well it's

2430
01:29:41,600 --> 01:29:45,760
going to use one on this gonna use 16 on

2431
01:29:43,679 --> 01:29:49,119
this gonna use two on this 22 like

2432
01:29:45,760 --> 01:29:52,400
this is just you know i don't know right

2433
01:29:49,119 --> 01:29:53,599
um but in terms of the actual cost of

2434
01:29:52,399 --> 01:29:56,719
the uops

2435
01:29:53,600 --> 01:29:59,360
um for a given size

2436
01:29:56,719 --> 01:30:01,039
where the size gets put the way that you

2437
01:29:59,359 --> 01:30:01,920
use this instruction is you put the size

2438
01:30:01,039 --> 01:30:03,119
in one register

2439
01:30:01,920 --> 01:30:04,639
and like the value you want to move

2440
01:30:03,119 --> 01:30:05,599
another register or you set up pointers

2441
01:30:04,639 --> 01:30:08,639
and so on

2442
01:30:05,600 --> 01:30:10,159
when you actually do this rep

2443
01:30:08,639 --> 01:30:12,800
instruction here

2444
01:30:10,158 --> 01:30:14,960
it actually is very fast per loop it

2445
01:30:12,800 --> 01:30:17,600
basically will do the equivalent

2446
01:30:14,960 --> 01:30:18,719
most of the time on a modern core at

2447
01:30:17,600 --> 01:30:21,920
least as far as i know

2448
01:30:18,719 --> 01:30:22,960
of what i did so this rep mob sq will

2449
01:30:21,920 --> 01:30:25,760
actually use

2450
01:30:22,960 --> 01:30:26,960
the two ports to actually do two stores

2451
01:30:25,760 --> 01:30:30,320
per cycle

2452
01:30:26,960 --> 01:30:32,960
um as far as i know right

2453
01:30:30,319 --> 01:30:35,279
um and so this is actually probably way

2454
01:30:32,960 --> 01:30:37,520
better code than clang generated

2455
01:30:35,279 --> 01:30:38,960
when we didn't help it once we help

2456
01:30:37,520 --> 01:30:40,480
clang and we get here

2457
01:30:38,960 --> 01:30:42,079
i think these two would be about

2458
01:30:40,479 --> 01:30:44,479
equivalent but again

2459
01:30:42,079 --> 01:30:46,079
hard to say you'd have to time them and

2460
01:30:44,479 --> 01:30:49,359
find out

2461
01:30:46,079 --> 01:30:52,880
all right so finally let's get back to

2462
01:30:49,359 --> 01:30:52,880
the thing we actually wanted to know

2463
01:30:55,760 --> 01:30:59,600
so after all that i hope you understand

2464
01:30:57,520 --> 01:31:02,639
this assembly at least a little bit

2465
01:30:59,600 --> 01:31:03,600
what i want to do now is i want to try

2466
01:31:02,639 --> 01:31:07,039
to actually

2467
01:31:03,600 --> 01:31:10,560
determine what will happen

2468
01:31:07,039 --> 01:31:13,119
if we now do some kind of say dependent

2469
01:31:10,560 --> 01:31:15,039
clear so let's say we stop doing things

2470
01:31:13,119 --> 01:31:17,039
the way that it was done before because

2471
01:31:15,039 --> 01:31:18,800
none of this stuff is good and this is

2472
01:31:17,039 --> 01:31:19,920
by the way why i was trying to on

2473
01:31:18,800 --> 01:31:21,520
twitter tell

2474
01:31:19,920 --> 01:31:22,719
jesse to not do things the way he was

2475
01:31:21,520 --> 01:31:24,239
doing it is because when i saw the

2476
01:31:22,719 --> 01:31:25,119
assembly language code that he posted i

2477
01:31:24,238 --> 01:31:27,279
was like clang

2478
01:31:25,119 --> 01:31:29,840
is doing garbage here so i was trying to

2479
01:31:27,279 --> 01:31:30,639
say and i thought it was just because he

2480
01:31:29,840 --> 01:31:33,840
was complying with

2481
01:31:30,639 --> 01:31:35,520
with minus og but actually now that

2482
01:31:33,840 --> 01:31:37,440
we've looked at it compiled with o

2483
01:31:35,520 --> 01:31:39,520
three it's just clang is just bad at

2484
01:31:37,439 --> 01:31:40,319
this it's just it's just producing bum

2485
01:31:39,520 --> 01:31:42,960
code

2486
01:31:40,319 --> 01:31:44,399
so you don't want to do timings with bum

2487
01:31:42,960 --> 01:31:46,079
code you got to look and see if the

2488
01:31:44,399 --> 01:31:47,519
compiler generated something usable to

2489
01:31:46,079 --> 01:31:48,479
begin with before you actually time it

2490
01:31:47,520 --> 01:31:51,120
because

2491
01:31:48,479 --> 01:31:51,759
that code that clang generated was so

2492
01:31:51,119 --> 01:31:53,519
bad

2493
01:31:51,760 --> 01:31:54,880
that it's not a fair comparison of what

2494
01:31:53,520 --> 01:31:56,159
would happen if you clear registers of

2495
01:31:54,880 --> 01:31:57,119
course clearing the registers will

2496
01:31:56,158 --> 01:31:58,638
probably be free

2497
01:31:57,119 --> 01:32:01,039
because clan created a loop that's so

2498
01:31:58,639 --> 01:32:04,239
slow that you won't notice

2499
01:32:01,039 --> 01:32:06,238
right so yes clearing registers

2500
01:32:04,238 --> 01:32:07,439
happens to be free but that was not a

2501
01:32:06,238 --> 01:32:09,678
fair test of it right

2502
01:32:07,439 --> 01:32:11,198
um so anyway that's what i was trying to

2503
01:32:09,679 --> 01:32:15,199
say hopefully

2504
01:32:11,198 --> 01:32:17,039
um that's what you get right

2505
01:32:15,198 --> 01:32:18,559
um so anyway oh someone wants me to try

2506
01:32:17,039 --> 01:32:19,920
one more set of composers so before i

2507
01:32:18,560 --> 01:32:21,280
get rid of it we'll just try one more to

2508
01:32:19,920 --> 01:32:24,399
see if it

2509
01:32:21,279 --> 01:32:26,399
creates anything you wanted march

2510
01:32:24,399 --> 01:32:28,079
skylake so it knows it's using a skylake

2511
01:32:26,399 --> 01:32:31,599
architecture

2512
01:32:28,079 --> 01:32:34,319
and fast math yeah

2513
01:32:31,600 --> 01:32:35,920
i mean trust me this doesn't look like

2514
01:32:34,319 --> 01:32:38,000
any kind of thing that has to do with

2515
01:32:35,920 --> 01:32:38,800
any of that it's just super confused

2516
01:32:38,000 --> 01:32:41,119
right

2517
01:32:38,800 --> 01:32:42,079
and so really the thing that's confusing

2518
01:32:41,119 --> 01:32:44,158
it is that

2519
01:32:42,079 --> 01:32:46,000
for some reason the fact that this is on

2520
01:32:44,158 --> 01:32:48,960
the stack i guess

2521
01:32:46,000 --> 01:32:49,760
confuses it because moving these to

2522
01:32:48,960 --> 01:32:53,840
actually

2523
01:32:49,760 --> 01:32:56,560
to actual stored data it suddenly knows

2524
01:32:53,840 --> 01:32:59,840
more what to do oops

2525
01:32:56,560 --> 01:33:01,920
what just happened okay there we go

2526
01:32:59,840 --> 01:33:02,880
moving it outside it suddenly knows what

2527
01:33:01,920 --> 01:33:06,840
to do

2528
01:33:02,880 --> 01:33:08,560
right um this is again just an unrolled

2529
01:33:06,840 --> 01:33:11,279
version

2530
01:33:08,560 --> 01:33:11,760
of this loop that's not horrible right

2531
01:33:11,279 --> 01:33:15,679
um

2532
01:33:11,760 --> 01:33:18,960
it's not good uh but it's not horrible

2533
01:33:15,679 --> 01:33:20,239
right um

2534
01:33:18,960 --> 01:33:22,319
actually it's kind of horrible never

2535
01:33:20,238 --> 01:33:23,198
mind it just doesn't know clanks clang

2536
01:33:22,319 --> 01:33:24,960
sucks at this

2537
01:33:23,198 --> 01:33:27,119
let's just let's just stop talking about

2538
01:33:24,960 --> 01:33:28,639
switches clang sucks at this you

2539
01:33:27,119 --> 01:33:30,399
shouldn't have to set any switches

2540
01:33:28,639 --> 01:33:32,560
other than optimize to get this to work

2541
01:33:30,399 --> 01:33:34,399
properly the compiler has

2542
01:33:32,560 --> 01:33:36,080
all the information it needs it does not

2543
01:33:34,399 --> 01:33:37,439
need const here and even if we said it

2544
01:33:36,079 --> 01:33:39,279
didn't help anyway

2545
01:33:37,439 --> 01:33:40,879
it does not need to be static this is

2546
01:33:39,279 --> 01:33:42,319
obvious the compiler should be able to

2547
01:33:40,880 --> 01:33:43,199
figure it out and it doesn't that's

2548
01:33:42,319 --> 01:33:46,639
pretty much period

2549
01:33:43,198 --> 01:33:46,638
we're done playing with switches

2550
01:33:48,840 --> 01:33:53,520
okay

2551
01:33:50,800 --> 01:33:55,520
no you can you cannot leave it inside

2552
01:33:53,520 --> 01:33:57,360
and set it to static

2553
01:33:55,520 --> 01:33:59,600
if you leave it inside and set it to

2554
01:33:57,359 --> 01:34:02,719
stab set it to static

2555
01:33:59,600 --> 01:34:05,039
right you're gonna get uh

2556
01:34:02,719 --> 01:34:05,760
initialization garbage in there right i

2557
01:34:05,039 --> 01:34:08,158
mean maybe

2558
01:34:05,760 --> 01:34:08,159
you can

2559
01:34:13,198 --> 01:34:17,678
uh but i would i would worry right in

2560
01:34:15,840 --> 01:34:20,480
this particular case it

2561
01:34:17,679 --> 01:34:20,480
oh my god

2562
01:34:23,600 --> 01:34:27,039
what the heck did it do

2563
01:34:27,119 --> 01:34:34,238
that's even nuts

2564
01:34:30,158 --> 01:34:37,039
yeah don't do that holy cow

2565
01:34:34,238 --> 01:34:37,039
that's horrible

2566
01:34:37,359 --> 01:34:43,759
all right clang is nuts okay

2567
01:34:40,560 --> 01:34:45,520
just just it's nuts you got to write the

2568
01:34:43,760 --> 01:34:47,840
code yourself

2569
01:34:45,520 --> 01:34:48,880
that's what we did just stop telling me

2570
01:34:47,840 --> 01:34:51,279
switches

2571
01:34:48,880 --> 01:34:52,560
switches if if the compiler was any good

2572
01:34:51,279 --> 01:34:54,559
you wouldn't have to know what switches

2573
01:34:52,560 --> 01:34:57,840
to get it to output an obvious

2574
01:34:54,560 --> 01:35:00,560
copy from register right so it's got a

2575
01:34:57,840 --> 01:35:02,719
lot of issues

2576
01:35:00,560 --> 01:35:03,840
like i said this is what i find a lot of

2577
01:35:02,719 --> 01:35:06,399
times like a pile of clang

2578
01:35:03,840 --> 01:35:07,360
msvc output something sane clang output

2579
01:35:06,399 --> 01:35:08,960
something ridiculous

2580
01:35:07,359 --> 01:35:10,719
and i have to handhold it like this

2581
01:35:08,960 --> 01:35:12,560
that's just what i see a lot of the time

2582
01:35:10,719 --> 01:35:15,920
and that's what we saw here

2583
01:35:12,560 --> 01:35:17,440
your mileage may vary moving on

2584
01:35:15,920 --> 01:35:19,199
so let's suppose that we actually want

2585
01:35:17,439 --> 01:35:21,039
to do what we were talking about at the

2586
01:35:19,198 --> 01:35:22,000
beginning which is we want to have some

2587
01:35:21,039 --> 01:35:26,158
way

2588
01:35:22,000 --> 01:35:28,399
of doing a uh potential clear

2589
01:35:26,158 --> 01:35:31,118
so we want to see what happens if it

2590
01:35:28,399 --> 01:35:33,679
costs us anything in the kind of case

2591
01:35:31,118 --> 01:35:35,839
that involves clearing registers so in

2592
01:35:33,679 --> 01:35:38,000
here let's suppose we move these

2593
01:35:35,840 --> 01:35:39,039
uh into place and so we've got a thing

2594
01:35:38,000 --> 01:35:42,000
where we set them up

2595
01:35:39,039 --> 01:35:43,840
and then we write them out right and so

2596
01:35:42,000 --> 01:35:45,760
in here we've got the same loop right

2597
01:35:43,840 --> 01:35:48,000
this is fine it's unrolled for no

2598
01:35:45,760 --> 01:35:50,239
reason whatsoever but it's you know it's

2599
01:35:48,000 --> 01:35:52,399
fine it's not ridiculous

2600
01:35:50,238 --> 01:35:53,678
but now what i want to do is i want to

2601
01:35:52,399 --> 01:35:56,799
say look

2602
01:35:53,679 --> 01:36:00,960
uh if every so often

2603
01:35:56,800 --> 01:36:00,960
like maybe if

2604
01:36:04,399 --> 01:36:12,439
let's see um maybe we introduce

2605
01:36:09,679 --> 01:36:15,960
and um

2606
01:36:12,439 --> 01:36:15,960
[Music]

2607
01:36:16,319 --> 01:36:20,479
maybe i try to do something like this so

2608
01:36:18,800 --> 01:36:25,840
i say look if index

2609
01:36:20,479 --> 01:36:25,839
equals run

2610
01:36:26,719 --> 01:36:33,359
um then it's this and if it's not it's

2611
01:36:30,639 --> 01:36:33,359
going to be zero

2612
01:36:35,679 --> 01:36:39,118
and all i'm trying to do here is

2613
01:36:37,198 --> 01:36:40,799
simulate the case where we have

2614
01:36:39,118 --> 01:36:44,000
something to test

2615
01:36:40,800 --> 01:36:46,880
where we set the

2616
01:36:44,000 --> 01:36:47,920
matrix to the identity sometimes but we

2617
01:36:46,880 --> 01:36:53,279
set it to zero

2618
01:36:47,920 --> 01:36:55,679
other times right

2619
01:36:53,279 --> 01:36:57,679
so in this case sorry i'm not very good

2620
01:36:55,679 --> 01:36:59,279
with this web editor so i'm kind of like

2621
01:36:57,679 --> 01:36:59,920
ham-fisted when i'm editing things

2622
01:36:59,279 --> 01:37:01,679
because it's not

2623
01:36:59,920 --> 01:37:03,920
you know my normal editor config or

2624
01:37:01,679 --> 01:37:07,840
whatever but i'm working on it

2625
01:37:03,920 --> 01:37:09,920
i'm getting there right

2626
01:37:07,840 --> 01:37:11,840
um so let's say we have something like

2627
01:37:09,920 --> 01:37:14,719
this and we take a look

2628
01:37:11,840 --> 01:37:15,440
at what we end up with in here uh when

2629
01:37:14,719 --> 01:37:18,639
we ask

2630
01:37:15,439 --> 01:37:19,919
clang to do optimizations on this thing

2631
01:37:18,639 --> 01:37:22,880
so here we're saying is look we're going

2632
01:37:19,920 --> 01:37:26,079
to set these to zero and then sometimes

2633
01:37:22,880 --> 01:37:28,639
right we're going to

2634
01:37:26,079 --> 01:37:30,238
set it to the identity and either way

2635
01:37:28,639 --> 01:37:32,000
we're writing a matrix but sometimes

2636
01:37:30,238 --> 01:37:34,559
we're going to write the zero matrix

2637
01:37:32,000 --> 01:37:35,920
in fact most of the time and other times

2638
01:37:34,560 --> 01:37:39,119
we're going to write

2639
01:37:35,920 --> 01:37:41,440
uh you know

2640
01:37:39,118 --> 01:37:44,719
i didn't mean to do that i guess i just

2641
01:37:41,439 --> 01:37:44,719
saved a copy of that somewhere

2642
01:37:44,800 --> 01:37:48,960
so anyway um taking a look at what goes

2643
01:37:47,679 --> 01:37:49,600
on in this particular piece of code you

2644
01:37:48,960 --> 01:37:53,118
can see

2645
01:37:49,600 --> 01:37:57,600
in here if we want to look at uh the

2646
01:37:53,118 --> 01:38:00,719
the stuff that it did here um

2647
01:37:57,600 --> 01:38:01,760
it looks like it went again ahead and

2648
01:38:00,719 --> 01:38:05,920
kind of went

2649
01:38:01,760 --> 01:38:07,760
into uh a rather absurd way of

2650
01:38:05,920 --> 01:38:09,359
of breaking this down i'm wondering if

2651
01:38:07,760 --> 01:38:09,920
we try to do is outsmart us because you

2652
01:38:09,359 --> 01:38:12,079
can see these

2653
01:38:09,920 --> 01:38:13,199
let me see if i can make it even harder

2654
01:38:12,079 --> 01:38:17,840
for it

2655
01:38:13,198 --> 01:38:17,839
um in this case so

2656
01:38:28,880 --> 01:38:31,840
i'm trying to think of a way to make

2657
01:38:30,238 --> 01:38:32,959
this something the compiler doesn't

2658
01:38:31,840 --> 01:38:45,840
understand

2659
01:38:32,960 --> 01:38:45,840
uh you know what's a good way to do that

2660
01:38:47,760 --> 01:38:53,440
here so now we just have a function foo

2661
01:38:51,198 --> 01:38:53,439
right

2662
01:38:54,479 --> 01:38:58,238
and i'm going to make it read out of

2663
01:38:56,719 --> 01:39:00,480
this control structure so that the

2664
01:38:58,238 --> 01:39:04,879
compiler doesn't know

2665
01:39:00,479 --> 01:39:08,158
at all uh what it has to do

2666
01:39:04,880 --> 01:39:10,239
right so it has no idea

2667
01:39:08,158 --> 01:39:11,679
whether it's going to do one or the

2668
01:39:10,238 --> 01:39:14,718
other and we'll see

2669
01:39:11,679 --> 01:39:16,319
what it actually outputs here right

2670
01:39:14,719 --> 01:39:17,920
so if you take a look at what it

2671
01:39:16,319 --> 01:39:21,039
generated for the loop

2672
01:39:17,920 --> 01:39:24,079
um here's us doing the right

2673
01:39:21,039 --> 01:39:26,479
here's us doing the um

2674
01:39:24,079 --> 01:39:27,760
add so we're moving forwards right

2675
01:39:26,479 --> 01:39:30,638
here's us doing the comp

2676
01:39:27,760 --> 01:39:32,000
and the jump and we jump back to 11

2677
01:39:30,639 --> 01:39:33,679
which is here

2678
01:39:32,000 --> 01:39:35,920
and then what we do is we kind of do

2679
01:39:33,679 --> 01:39:39,279
like jumps around

2680
01:39:35,920 --> 01:39:41,930
uh kind of nonsense wise so here's us

2681
01:39:39,279 --> 01:39:44,158
oh wait no that's jumping out so

2682
01:39:41,930 --> 01:39:45,840
[Music]

2683
01:39:44,158 --> 01:39:47,679
this is the part so we fall through here

2684
01:39:45,840 --> 01:39:51,279
we jump to two

2685
01:39:47,679 --> 01:39:54,399
we do a test of

2686
01:39:51,279 --> 01:39:57,679
this we do the xors

2687
01:39:54,399 --> 01:40:00,158
if necessary otherwise we jump

2688
01:39:57,679 --> 01:40:01,039
to and then we jump to three no we just

2689
01:40:00,158 --> 01:40:04,158
jump

2690
01:40:01,039 --> 01:40:08,238
based on the comp so we xor our sum

2691
01:40:04,158 --> 01:40:09,439
we jump based on the com what what is

2692
01:40:08,238 --> 01:40:11,118
the point of this

2693
01:40:09,439 --> 01:40:13,198
look at how many jumps this thing

2694
01:40:11,118 --> 01:40:17,519
inserted in here

2695
01:40:13,198 --> 01:40:17,519
what did what did msvc do

2696
01:40:20,719 --> 01:40:25,520
hold on a second if i see if msvc is at

2697
01:40:22,800 --> 01:40:28,560
all sane so here's the comp

2698
01:40:25,520 --> 01:40:32,639
here's the uh

2699
01:40:28,560 --> 01:40:37,840
zero clear right here is the jump

2700
01:40:32,639 --> 01:40:37,840
over the yeah so like once again

2701
01:40:39,920 --> 01:40:44,639
like once again visual studio does like

2702
01:40:43,198 --> 01:40:47,759
exactly the right code

2703
01:40:44,639 --> 01:40:50,800
and clang is a friggin nightmare

2704
01:40:47,760 --> 01:40:52,880
i don't know why i can't imagine having

2705
01:40:50,800 --> 01:40:53,360
this many jumps in here could ever be

2706
01:40:52,880 --> 01:40:57,118
good

2707
01:40:53,359 --> 01:40:58,719
for anything they're conditional jumps

2708
01:40:57,118 --> 01:41:01,039
so these go through the branch predictor

2709
01:40:58,719 --> 01:41:01,039
even

2710
01:41:02,840 --> 01:41:05,840
um

2711
01:41:07,679 --> 01:41:10,399
yeah i mean

2712
01:41:10,960 --> 01:41:17,198
i mean that's that's the loop

2713
01:41:14,399 --> 01:41:19,039
right it's perfect it's exactly what you

2714
01:41:17,198 --> 01:41:21,359
want you comp

2715
01:41:19,039 --> 01:41:22,960
clear jump if you're not going to

2716
01:41:21,359 --> 01:41:26,158
overwrite

2717
01:41:22,960 --> 01:41:29,359
copy um

2718
01:41:26,158 --> 01:41:31,679
it's exactly right so msvc

2719
01:41:29,359 --> 01:41:33,519
output the exact right loop clang output

2720
01:41:31,679 --> 01:41:35,679
an absolute monstrosity i

2721
01:41:33,520 --> 01:41:37,199
can't imagine that's ever faster let's

2722
01:41:35,679 --> 01:41:41,440
see if o2

2723
01:41:37,198 --> 01:41:41,439
was more sane it's not

2724
01:41:41,760 --> 01:41:47,840
what is going on um

2725
01:41:46,238 --> 01:41:49,359
i just don't know why you'd ever want

2726
01:41:47,840 --> 01:41:51,119
any of this

2727
01:41:49,359 --> 01:41:52,639
this just looks like massive branch

2728
01:41:51,118 --> 01:41:54,880
prediction nightmare

2729
01:41:52,639 --> 01:41:54,880
right

2730
01:41:58,840 --> 01:42:01,840
so

2731
01:42:04,960 --> 01:42:08,880
i want to say and i could be wrong about

2732
01:42:07,920 --> 01:42:10,960
this

2733
01:42:08,880 --> 01:42:13,679
i want to say that there's some really

2734
01:42:10,960 --> 01:42:14,079
really really bad aspects to this code

2735
01:42:13,679 --> 01:42:17,359
so

2736
01:42:14,079 --> 01:42:18,158
looking at this code i could be wrong

2737
01:42:17,359 --> 01:42:20,238
about this

2738
01:42:18,158 --> 01:42:22,158
but this looks like code that is

2739
01:42:20,238 --> 01:42:24,399
absolutely abhorrently bad

2740
01:42:22,158 --> 01:42:25,839
and maybe this is again just my naivete

2741
01:42:24,399 --> 01:42:28,719
with optimization but when i look at

2742
01:42:25,840 --> 01:42:32,319
this code the first thing

2743
01:42:28,719 --> 01:42:35,439
pun intended that jumps out at me

2744
01:42:32,319 --> 01:42:38,479
is that if i'm not mistaken at least

2745
01:42:35,439 --> 01:42:40,479
on zen 2 which is like one of the

2746
01:42:38,479 --> 01:42:44,238
highest performance cpus

2747
01:42:40,479 --> 01:42:49,839
currently in existence if you have

2748
01:42:44,238 --> 01:42:53,759
multiple jumps per 64 byte block of code

2749
01:42:49,840 --> 01:42:57,679
every jump past the second jump becomes

2750
01:42:53,760 --> 01:43:01,119
worse so like if this is probably

2751
01:42:57,679 --> 01:43:04,158
like 164 byte block of code

2752
01:43:01,118 --> 01:43:07,759
and there's like one two three four five

2753
01:43:04,158 --> 01:43:10,559
six jumps in it right

2754
01:43:07,760 --> 01:43:12,079
um one of them is a straight up jump but

2755
01:43:10,560 --> 01:43:14,000
so maybe that doesn't matter but these

2756
01:43:12,079 --> 01:43:16,880
are all conditional jumps

2757
01:43:14,000 --> 01:43:18,800
so that many conditional jumps in 164

2758
01:43:16,880 --> 01:43:21,039
byte block is an absolute nightmare for

2759
01:43:18,800 --> 01:43:23,440
the branch predictor i think

2760
01:43:21,039 --> 01:43:25,158
i mean i could be wrong about that but

2761
01:43:23,439 --> 01:43:29,359
that just seems

2762
01:43:25,158 --> 01:43:29,759
really bad really really really not good

2763
01:43:29,359 --> 01:43:32,319
now

2764
01:43:29,760 --> 01:43:34,079
again some optimization like if agner

2765
01:43:32,319 --> 01:43:36,000
fogs up

2766
01:43:34,079 --> 01:43:37,279
on here and wants to tell me that that's

2767
01:43:36,000 --> 01:43:40,238
not true

2768
01:43:37,279 --> 01:43:41,679
that would be cool but this just looks

2769
01:43:40,238 --> 01:43:43,279
like garbage

2770
01:43:41,679 --> 01:43:45,920
this looks like exactly the right code

2771
01:43:43,279 --> 01:43:48,800
to me um

2772
01:43:45,920 --> 01:43:50,639
and so what you can see here is what i

2773
01:43:48,800 --> 01:43:53,679
finally wanted to

2774
01:43:50,639 --> 01:43:55,520
get to um and

2775
01:43:53,679 --> 01:43:57,840
it's not quite exactly what i wanted

2776
01:43:55,520 --> 01:44:00,159
because i wanted xor ps

2777
01:43:57,840 --> 01:44:01,600
for an xor clear but these are actually

2778
01:44:00,158 --> 01:44:03,279
functionally the same thing

2779
01:44:01,600 --> 01:44:05,440
so we can talk about that and this is

2780
01:44:03,279 --> 01:44:07,039
what i actually wanted to get to

2781
01:44:05,439 --> 01:44:08,638
by the end of the show and hey

2782
01:44:07,039 --> 01:44:09,600
thankfully we did get to it by the end

2783
01:44:08,639 --> 01:44:12,880
of the show

2784
01:44:09,600 --> 01:44:13,920
so let's finally talk about exo or

2785
01:44:12,880 --> 01:44:15,840
clears

2786
01:44:13,920 --> 01:44:17,118
um oh and someone mentioned there's a

2787
01:44:15,840 --> 01:44:23,119
there's a tuning parameter for

2788
01:44:17,118 --> 01:44:23,118
zen so let's see if it knows about that

2789
01:44:24,000 --> 01:44:30,399
nope i mean it looks a little better

2790
01:44:28,479 --> 01:44:32,959
but it's still outputting a heck of a

2791
01:44:30,399 --> 01:44:34,399
lot of jumps

2792
01:44:32,960 --> 01:44:36,960
i think it may have improved slightly

2793
01:44:34,399 --> 01:44:36,960
but i don't know

2794
01:44:38,560 --> 01:44:43,280
yeah i don't know real bad code

2795
01:44:44,238 --> 01:44:51,439
um so yeah

2796
01:44:48,319 --> 01:44:53,039
not great and uh and like i said i do

2797
01:44:51,439 --> 01:44:54,638
feel like

2798
01:44:53,039 --> 01:44:56,560
my experience with clang is it outputs

2799
01:44:54,639 --> 01:44:59,279
really stupid code a lot of the time

2800
01:44:56,560 --> 01:45:01,199
but like i said before i also find that

2801
01:44:59,279 --> 01:45:03,759
in certain places where it really counts

2802
01:45:01,198 --> 01:45:04,960
like in really intrinsic heavy like

2803
01:45:03,760 --> 01:45:06,800
crazy math code

2804
01:45:04,960 --> 01:45:08,079
i feel like when i've done clan compiles

2805
01:45:06,800 --> 01:45:11,119
it actually

2806
01:45:08,079 --> 01:45:11,760
produces the faster code and so i do

2807
01:45:11,118 --> 01:45:13,839
think they're

2808
01:45:11,760 --> 01:45:15,440
important things clang does that often

2809
01:45:13,840 --> 01:45:16,319
times you run it on your whole code base

2810
01:45:15,439 --> 01:45:19,439
you actually get a win

2811
01:45:16,319 --> 01:45:20,719
from clang but it's like i don't know

2812
01:45:19,439 --> 01:45:24,000
why

2813
01:45:20,719 --> 01:45:26,719
um i don't know why it's doing these

2814
01:45:24,000 --> 01:45:26,719
stupid things

2815
01:45:29,760 --> 01:45:35,679
it don't seem right um anyway

2816
01:45:33,920 --> 01:45:36,800
so let's talk about this because this is

2817
01:45:35,679 --> 01:45:38,719
the code i actually want to talk about

2818
01:45:36,800 --> 01:45:40,639
and this looks about right to me

2819
01:45:38,719 --> 01:45:42,840
so what's happening in this loop is it's

2820
01:45:40,639 --> 01:45:45,840
doing a comp on the control

2821
01:45:42,840 --> 01:45:48,639
right that's just seeing whether or not

2822
01:45:45,840 --> 01:45:52,079
it needs to write an identity or a zero

2823
01:45:48,639 --> 01:45:52,400
it has mob aps's to move xmm0 into one

2824
01:45:52,079 --> 01:45:54,559
two

2825
01:45:52,399 --> 01:45:56,319
three and four xm0 is just the zero

2826
01:45:54,560 --> 01:45:57,600
value you can see that it was cleared up

2827
01:45:56,319 --> 01:46:00,799
here

2828
01:45:57,600 --> 01:46:04,239
so that's just setting these all to zero

2829
01:46:00,800 --> 01:46:06,719
then it's going to just jump over the

2830
01:46:04,238 --> 01:46:08,479
actual load of the identity matrix so

2831
01:46:06,719 --> 01:46:11,920
this will load the identity matrix

2832
01:46:08,479 --> 01:46:14,959
in then it does the same set of mobs

2833
01:46:11,920 --> 01:46:18,560
one two three and four out to the matrix

2834
01:46:14,960 --> 01:46:21,600
right and advances again

2835
01:46:18,560 --> 01:46:24,159
exactly what we want this looks great

2836
01:46:21,600 --> 01:46:25,840
right and so now let's get to the part

2837
01:46:24,158 --> 01:46:27,359
that i was trying to explain before

2838
01:46:25,840 --> 01:46:28,400
which is why i was saying usually

2839
01:46:27,359 --> 01:46:31,519
clearing to xero

2840
01:46:28,399 --> 01:46:32,638
is free and in this case you can see why

2841
01:46:31,520 --> 01:46:37,440
it's free

2842
01:46:32,639 --> 01:46:40,480
because this piece of code right

2843
01:46:37,439 --> 01:46:44,479
doesn't do anything

2844
01:46:40,479 --> 01:46:47,759
mob aps xmm1 xmm0 here

2845
01:46:44,479 --> 01:46:49,039
is actually not going to ever go to an

2846
01:46:47,760 --> 01:46:52,400
execution port at all

2847
01:46:49,039 --> 01:46:52,960
it's just going to rename the value that

2848
01:46:52,399 --> 01:46:56,719
was in

2849
01:46:52,960 --> 01:46:59,760
xmm0 to also be the value that's in xmm1

2850
01:46:56,719 --> 01:47:01,118
modern processors don't have registers

2851
01:46:59,760 --> 01:47:04,320
the way that

2852
01:47:01,118 --> 01:47:08,000
that old school processors did when we

2853
01:47:04,319 --> 01:47:13,118
say that there's xmm0 through xmm7

2854
01:47:08,000 --> 01:47:13,118
or something there aren't actually

2855
01:47:13,600 --> 01:47:18,560
eight physical registers in the cpu

2856
01:47:16,719 --> 01:47:20,800
each holding 16 bytes that's not what

2857
01:47:18,560 --> 01:47:24,400
happens there actually is

2858
01:47:20,800 --> 01:47:27,600
is a much larger register table

2859
01:47:24,399 --> 01:47:30,799
with lots of 16 byte spaces

2860
01:47:27,600 --> 01:47:34,159
in it for values and then

2861
01:47:30,800 --> 01:47:37,520
there are eight tags

2862
01:47:34,158 --> 01:47:40,960
xmm0 through xmm7 that can tag

2863
01:47:37,520 --> 01:47:43,360
those values so all that's happening

2864
01:47:40,960 --> 01:47:44,158
whenever you see a register to register

2865
01:47:43,359 --> 01:47:48,559
move

2866
01:47:44,158 --> 01:47:51,439
is it's just taking the tag for xmm1

2867
01:47:48,560 --> 01:47:53,920
and attaching it to the value that is

2868
01:47:51,439 --> 01:47:57,118
xmm0 so that now that value

2869
01:47:53,920 --> 01:48:00,399
is tagged as both xm0 and xmm1

2870
01:47:57,118 --> 01:48:02,238
so anyone who reads from xmm0 or xm1 in

2871
01:48:00,399 --> 01:48:03,599
the future will get the same value out

2872
01:48:02,238 --> 01:48:06,638
of that table

2873
01:48:03,600 --> 01:48:08,560
right it doesn't ever actually copy it

2874
01:48:06,639 --> 01:48:10,880
to the best of my knowledge

2875
01:48:08,560 --> 01:48:10,880
right

2876
01:48:11,600 --> 01:48:18,639
so what happens is all of these the

2877
01:48:14,800 --> 01:48:21,920
only cost that you pay for them at all

2878
01:48:18,639 --> 01:48:25,760
is just the decode code space

2879
01:48:21,920 --> 01:48:28,000
cost right so those instructions still

2880
01:48:25,760 --> 01:48:31,119
have to move through the front end

2881
01:48:28,000 --> 01:48:33,760
like they do take up some time to decode

2882
01:48:31,118 --> 01:48:35,439
in the first place but for a loop it's

2883
01:48:33,760 --> 01:48:37,360
all in the hot cache anyway it's

2884
01:48:35,439 --> 01:48:41,759
probably actually in the loop cache

2885
01:48:37,359 --> 01:48:42,319
anyway so these are effectively free

2886
01:48:41,760 --> 01:48:45,600
they take

2887
01:48:42,319 --> 01:48:47,359
no execution ports whatsoever they only

2888
01:48:45,600 --> 01:48:50,639
take front end time

2889
01:48:47,359 --> 01:48:53,759
so the only time you could ever

2890
01:48:50,639 --> 01:48:57,359
ever pay for a mob

2891
01:48:53,760 --> 01:48:57,760
aps or equivalently in xrps is the same

2892
01:48:57,359 --> 01:49:01,198
thing

2893
01:48:57,760 --> 01:49:03,199
it's just re-tagging a location as zero

2894
01:49:01,198 --> 01:49:06,799
basically

2895
01:49:03,198 --> 01:49:09,439
it's processed in the front end um

2896
01:49:06,800 --> 01:49:09,920
any the only time you can ever pay for

2897
01:49:09,439 --> 01:49:14,399
those

2898
01:49:09,920 --> 01:49:17,679
in an actual uh execution cost

2899
01:49:14,399 --> 01:49:20,238
is two cases that i know of

2900
01:49:17,679 --> 01:49:22,158
one is when you are actually decode

2901
01:49:20,238 --> 01:49:25,279
bound so like the front end

2902
01:49:22,158 --> 01:49:28,638
is actually the thing that is stalling

2903
01:49:25,279 --> 01:49:29,519
your routine in our case we know that's

2904
01:49:28,639 --> 01:49:32,159
not possible

2905
01:49:29,520 --> 01:49:32,719
how do we know because we know we only

2906
01:49:32,158 --> 01:49:36,559
have

2907
01:49:32,719 --> 01:49:39,198
two possible stores we can do per cycle

2908
01:49:36,560 --> 01:49:41,039
there's no way on anything on skylake

2909
01:49:39,198 --> 01:49:42,000
that i've ever heard of that can ever

2910
01:49:41,039 --> 01:49:45,840
store more than

2911
01:49:42,000 --> 01:49:47,520
two uh stores per cycle

2912
01:49:45,840 --> 01:49:49,920
so if you can only do two stores per

2913
01:49:47,520 --> 01:49:52,560
cycle at an absolute maximum

2914
01:49:49,920 --> 01:49:53,599
um i wanna say i think you can i don't

2915
01:49:52,560 --> 01:49:56,480
even know if you can do

2916
01:49:53,599 --> 01:49:59,360
two you may only be able to do one um

2917
01:49:56,479 --> 01:50:01,759
store per cycle on skylake

2918
01:49:59,359 --> 01:50:03,439
we should look that up but point being i

2919
01:50:01,760 --> 01:50:04,239
i think you maybe do two reads and one

2920
01:50:03,439 --> 01:50:06,879
right

2921
01:50:04,238 --> 01:50:08,718
i don't know if you can do two writes

2922
01:50:06,880 --> 01:50:11,840
you can definitely do two reads

2923
01:50:08,719 --> 01:50:11,840
per cycle but

2924
01:50:12,079 --> 01:50:17,519
but rights i think is only one

2925
01:50:15,920 --> 01:50:18,960
don't quote me on that but but that's my

2926
01:50:17,520 --> 01:50:20,400
feeling is that you can only actually do

2927
01:50:18,960 --> 01:50:24,480
one right per cycle maybe

2928
01:50:20,399 --> 01:50:25,519
either way it's either one or two

2929
01:50:24,479 --> 01:50:26,799
depending whether it's reads or writes

2930
01:50:25,520 --> 01:50:28,159
and depending on whether my memory is

2931
01:50:26,800 --> 01:50:31,199
bad or good

2932
01:50:28,158 --> 01:50:32,158
um but the front end can process four

2933
01:50:31,198 --> 01:50:35,519
cycles at a time

2934
01:50:32,158 --> 01:50:37,279
uh four instructions at a time right and

2935
01:50:35,520 --> 01:50:38,719
since mob aps is not a complex

2936
01:50:37,279 --> 01:50:41,439
instruction it doesn't generate like

2937
01:50:38,719 --> 01:50:43,920
lots and lots of u-ops or anything

2938
01:50:41,439 --> 01:50:45,759
there's no chance that we're going to be

2939
01:50:43,920 --> 01:50:47,599
stalled on decoding

2940
01:50:45,760 --> 01:50:49,920
anything there's going to be lots of

2941
01:50:47,599 --> 01:50:52,239
spare decoder bandwidth here

2942
01:50:49,920 --> 01:50:54,000
because we're simply going to be mostly

2943
01:50:52,238 --> 01:50:54,959
waiting around for the store port to

2944
01:50:54,000 --> 01:50:56,560
become available

2945
01:50:54,960 --> 01:50:58,719
because chances are we're only going to

2946
01:50:56,560 --> 01:51:01,280
be issuing like one store

2947
01:50:58,719 --> 01:51:03,439
or two stores per cycle and if we're

2948
01:51:01,279 --> 01:51:05,679
doing two stores per cycle

2949
01:51:03,439 --> 01:51:06,960
then we actually have two spare

2950
01:51:05,679 --> 01:51:09,760
instructions

2951
01:51:06,960 --> 01:51:10,480
that we can issue every cycle in that

2952
01:51:09,760 --> 01:51:13,199
shadow

2953
01:51:10,479 --> 01:51:14,399
that we you know it doesn't matter so

2954
01:51:13,198 --> 01:51:16,158
the front end

2955
01:51:14,399 --> 01:51:17,519
we're not counting on the front end

2956
01:51:16,158 --> 01:51:20,960
pushing five

2957
01:51:17,520 --> 01:51:23,760
or six if they're fused i'm sorry

2958
01:51:20,960 --> 01:51:24,719
four or five if they're fused ops

2959
01:51:23,760 --> 01:51:26,800
through

2960
01:51:24,719 --> 01:51:27,920
uh to the execution ports because the

2961
01:51:26,800 --> 01:51:29,119
execution ports are what we're going to

2962
01:51:27,920 --> 01:51:32,480
be bound on

2963
01:51:29,118 --> 01:51:33,598
right um and you'll forgive me for not

2964
01:51:32,479 --> 01:51:36,079
remembering whether one or two but we

2965
01:51:33,599 --> 01:51:36,079
can look it up

2966
01:51:45,439 --> 01:51:48,399
chad is saying maybe someone looked up

2967
01:51:46,800 --> 01:51:49,840
skylake and it's only one so i'm not

2968
01:51:48,399 --> 01:51:50,879
wrong in remembering that it's two reads

2969
01:51:49,840 --> 01:51:53,679
and one right i guess

2970
01:51:50,880 --> 01:51:55,359
i guess but i might wrong either way

2971
01:51:53,679 --> 01:51:58,079
it's definitely not more than two

2972
01:51:55,359 --> 01:51:59,759
as far as memory ops it's either two

2973
01:51:58,079 --> 01:52:01,279
reads and one right or two reads and two

2974
01:51:59,760 --> 01:52:03,119
writes but i'm pretty sure it's like two

2975
01:52:01,279 --> 01:52:04,880
reads and one right

2976
01:52:03,118 --> 01:52:06,639
and that would the fact that when we

2977
01:52:04,880 --> 01:52:07,359
looked it up on us.info it said port

2978
01:52:06,639 --> 01:52:08,719
four

2979
01:52:07,359 --> 01:52:10,559
it didn't say like port four and

2980
01:52:08,719 --> 01:52:11,920
something else so if you could do two

2981
01:52:10,560 --> 01:52:15,280
per cycle it should have said

2982
01:52:11,920 --> 01:52:17,118
port like three and four right um so i'm

2983
01:52:15,279 --> 01:52:17,599
pretty sure that it basically is like

2984
01:52:17,118 --> 01:52:19,198
you know

2985
01:52:17,599 --> 01:52:20,800
reads on ports two and three and writes

2986
01:52:19,198 --> 01:52:21,598
on port four or something right so you

2987
01:52:20,800 --> 01:52:24,719
can only

2988
01:52:21,599 --> 01:52:26,239
you only have one port for rights you

2989
01:52:24,719 --> 01:52:28,560
know what i'm saying

2990
01:52:26,238 --> 01:52:28,559
anyway

2991
01:52:29,359 --> 01:52:33,519
so these are effectively free in almost

2992
01:52:32,560 --> 01:52:35,280
everything you do

2993
01:52:33,520 --> 01:52:36,800
and the reason for that is because it's

2994
01:52:35,279 --> 01:52:38,559
so cheap to rename

2995
01:52:36,800 --> 01:52:40,320
things compared to everything else

2996
01:52:38,560 --> 01:52:42,480
you're doing that you have to have

2997
01:52:40,319 --> 01:52:45,118
gotten down to like an incredibly

2998
01:52:42,479 --> 01:52:46,399
highly optimized really well working

2999
01:52:45,118 --> 01:52:48,079
system before they actually pay for them

3000
01:52:46,399 --> 01:52:49,279
now there is one other case where they

3001
01:52:48,079 --> 01:52:52,399
could have an effect

3002
01:52:49,279 --> 01:52:54,238
and that's code size or

3003
01:52:52,399 --> 01:52:56,079
like if the alignment is slightly

3004
01:52:54,238 --> 01:52:57,359
different there's all these weird like

3005
01:52:56,079 --> 01:52:59,439
edge cases you can hit

3006
01:52:57,359 --> 01:53:01,759
so i don't want to say that like

3007
01:52:59,439 --> 01:53:02,960
inserting mob aps is into something that

3008
01:53:01,760 --> 01:53:04,960
moved from registered register

3009
01:53:02,960 --> 01:53:06,880
never affects the performance because

3010
01:53:04,960 --> 01:53:08,719
sometimes it actually can in a weird way

3011
01:53:06,880 --> 01:53:10,000
but that's true of every instruction

3012
01:53:08,719 --> 01:53:12,079
that you could do

3013
01:53:10,000 --> 01:53:13,118
so that's kind of not something you

3014
01:53:12,079 --> 01:53:14,639
actually are talking about when you're

3015
01:53:13,118 --> 01:53:16,158
talking about how much does it generally

3016
01:53:14,639 --> 01:53:18,319
cost to do a thing because that's like

3017
01:53:16,158 --> 01:53:19,039
finicky stuff that may have nothing to

3018
01:53:18,319 --> 01:53:22,479
do with

3019
01:53:19,039 --> 01:53:25,198
like what the actual cost of doing thing

3020
01:53:22,479 --> 01:53:26,158
so mob aps and export rps in these ways

3021
01:53:25,198 --> 01:53:28,238
where you just use

3022
01:53:26,158 --> 01:53:29,759
an xrps to clear a register or use mob

3023
01:53:28,238 --> 01:53:30,479
aps to move one register to another

3024
01:53:29,760 --> 01:53:32,880
register

3025
01:53:30,479 --> 01:53:33,678
you're not paying for that it's not

3026
01:53:32,880 --> 01:53:36,000
actually

3027
01:53:33,679 --> 01:53:37,920
bit work being done by the processor in

3028
01:53:36,000 --> 01:53:40,158
the back end on an execution port it's

3029
01:53:37,920 --> 01:53:42,319
actually just happening in the register

3030
01:53:40,158 --> 01:53:46,158
allocation table and all you're doing is

3031
01:53:42,319 --> 01:53:48,158
renaming something you're either

3032
01:53:46,158 --> 01:53:49,839
uh or clearing like you're either saying

3033
01:53:48,158 --> 01:53:50,879
oh there's no value in here anymore it's

3034
01:53:49,840 --> 01:53:53,039
zero

3035
01:53:50,880 --> 01:53:54,079
or you're saying this value that

3036
01:53:53,039 --> 01:53:56,880
previously existed

3037
01:53:54,079 --> 01:53:58,399
is now also called some other register

3038
01:53:56,880 --> 01:54:01,599
name right

3039
01:53:58,399 --> 01:54:04,238
and so that's why i say for zii patterns

3040
01:54:01,599 --> 01:54:09,840
clearing to zero is almost always free

3041
01:54:04,238 --> 01:54:09,839
you really don't have to do this

3042
01:54:15,599 --> 01:54:18,719
this is what you do when you don't zii

3043
01:54:18,158 --> 01:54:22,079
right

3044
01:54:18,719 --> 01:54:23,198
when you say oh i'm i'm i'm optimizing

3045
01:54:22,079 --> 01:54:26,319
my code

3046
01:54:23,198 --> 01:54:28,960
right by doing this

3047
01:54:26,319 --> 01:54:28,960
so that

3048
01:54:30,880 --> 01:54:36,719
actually that that's not what i meant to

3049
01:54:34,840 --> 01:54:38,239
do

3050
01:54:36,719 --> 01:54:40,239
you know people will often be like oh

3051
01:54:38,238 --> 01:54:42,799
i'm optimizing my code

3052
01:54:40,238 --> 01:54:44,000
by doing this but you're not optimizing

3053
01:54:42,800 --> 01:54:47,279
your code by doing this

3054
01:54:44,000 --> 01:54:50,719
right um this doesn't actually

3055
01:54:47,279 --> 01:54:54,079
do anything other than introduce

3056
01:54:50,719 --> 01:54:56,239
a potentially unnecessary uh

3057
01:54:54,079 --> 01:54:58,000
operation into the code depending on how

3058
01:54:56,238 --> 01:54:59,759
complicated the code gets

3059
01:54:58,000 --> 01:55:01,920
in this particular case the code's so

3060
01:54:59,760 --> 01:55:02,480
simple that basically these two things

3061
01:55:01,920 --> 01:55:04,880
will

3062
01:55:02,479 --> 01:55:06,000
will evaluate to effectively the same

3063
01:55:04,880 --> 01:55:10,480
thing right

3064
01:55:06,000 --> 01:55:12,399
um oh no you know it's worse

3065
01:55:10,479 --> 01:55:13,759
there's an extra jump so i'm right even

3066
01:55:12,399 --> 01:55:15,039
in this case it's it's true

3067
01:55:13,760 --> 01:55:16,880
i was assuming they could probably smart

3068
01:55:15,039 --> 01:55:18,238
enough not to do that uh but it looks

3069
01:55:16,880 --> 01:55:20,560
like it's not

3070
01:55:18,238 --> 01:55:22,559
so what you can see here is actually

3071
01:55:20,560 --> 01:55:23,920
this just introduced an extra jump now

3072
01:55:22,560 --> 01:55:25,360
it's not definitely worse code

3073
01:55:23,920 --> 01:55:26,639
necessarily because this jump is

3074
01:55:25,359 --> 01:55:27,679
probably free because it's not

3075
01:55:26,639 --> 01:55:30,000
conditional

3076
01:55:27,679 --> 01:55:31,359
so the front end's just going to eat it

3077
01:55:30,000 --> 01:55:34,000
and it's probably fine

3078
01:55:31,359 --> 01:55:34,960
right so this is probably not necessary

3079
01:55:34,000 --> 01:55:37,520
um

3080
01:55:34,960 --> 01:55:38,960
necessary to worry about but what you

3081
01:55:37,520 --> 01:55:40,560
can see is you basically just ended up

3082
01:55:38,960 --> 01:55:42,560
with exactly the same code anyway

3083
01:55:40,560 --> 01:55:43,760
these are just clears so they don't cost

3084
01:55:42,560 --> 01:55:45,119
you anything

3085
01:55:43,760 --> 01:55:47,199
these are the things that you are now

3086
01:55:45,118 --> 01:55:48,799
doing a jump around right so it

3087
01:55:47,198 --> 01:55:50,238
reorganize the code slightly but it's

3088
01:55:48,800 --> 01:55:52,000
basically the exact same thing

3089
01:55:50,238 --> 01:55:53,279
so you haven't ended up with more

3090
01:55:52,000 --> 01:55:55,760
optimal code at all

3091
01:55:53,279 --> 01:55:57,519
it's either the same code or if

3092
01:55:55,760 --> 01:55:59,199
something was going on here that was

3093
01:55:57,520 --> 01:56:00,000
more complicated the compiler may not

3094
01:55:59,198 --> 01:56:02,000
have been able to figure

3095
01:56:00,000 --> 01:56:04,000
out exactly what it should have done and

3096
01:56:02,000 --> 01:56:07,359
it actually would have just gotten worse

3097
01:56:04,000 --> 01:56:09,198
right so this

3098
01:56:07,359 --> 01:56:11,039
is like an old way of thinking about

3099
01:56:09,198 --> 01:56:12,960
things when you think about

3100
01:56:11,039 --> 01:56:14,079
having to do this you're kind of

3101
01:56:12,960 --> 01:56:17,279
thinking about stuff

3102
01:56:14,079 --> 01:56:20,559
that's like a decade old or more right

3103
01:56:17,279 --> 01:56:21,679
this didn't change this is a better way

3104
01:56:20,560 --> 01:56:24,159
to write this code

3105
01:56:21,679 --> 01:56:26,480
is to just not do that right is to get

3106
01:56:24,158 --> 01:56:28,559
rid of this

3107
01:56:26,479 --> 01:56:30,000
and just always clear to zero because

3108
01:56:28,560 --> 01:56:32,880
there's a no reason

3109
01:56:30,000 --> 01:56:33,359
to actually make the compiler think

3110
01:56:32,880 --> 01:56:35,118
about

3111
01:56:33,359 --> 01:56:37,118
going down two different branches

3112
01:56:35,118 --> 01:56:39,039
because you really only ever have

3113
01:56:37,118 --> 01:56:41,359
one thing you might need to do if you

3114
01:56:39,039 --> 01:56:43,679
can start with zero that's just a way

3115
01:56:41,359 --> 01:56:44,559
to have the front end eat the clear for

3116
01:56:43,679 --> 01:56:46,239
free

3117
01:56:44,560 --> 01:56:48,239
so you don't pay for it and then you

3118
01:56:46,238 --> 01:56:50,479
have one branch to avoid

3119
01:56:48,238 --> 01:56:52,479
overwriting your cleared values but

3120
01:56:50,479 --> 01:56:56,000
that's all you actually

3121
01:56:52,479 --> 01:56:58,399
need to do right now this actually gets

3122
01:56:56,000 --> 01:56:59,760
a little more complicated because you

3123
01:56:58,399 --> 01:57:02,638
can actually make this

3124
01:56:59,760 --> 01:57:03,440
even more free than that so you can

3125
01:57:02,639 --> 01:57:05,840
write this

3126
01:57:03,439 --> 01:57:07,118
in a way that's actually branchless if

3127
01:57:05,840 --> 01:57:12,880
you want to

3128
01:57:07,118 --> 01:57:12,880
um and you can see like for example

3129
01:57:13,599 --> 01:57:18,159
just to finish off this is actually just

3130
01:57:16,479 --> 01:57:20,879
a value we could just use

3131
01:57:18,158 --> 01:57:22,719
right um so if we wanted to we could

3132
01:57:20,880 --> 01:57:25,359
actually just have a blend here

3133
01:57:22,719 --> 01:57:26,639
where we actually never do an if so if

3134
01:57:25,359 --> 01:57:28,559
we can

3135
01:57:26,639 --> 01:57:29,679
if we're concerned about the branch

3136
01:57:28,560 --> 01:57:31,360
predictor getting

3137
01:57:29,679 --> 01:57:34,239
confused about this we can actually just

3138
01:57:31,359 --> 01:57:36,799
eliminate it entirely and so this is yet

3139
01:57:34,238 --> 01:57:37,678
another reason why clear to zero is

3140
01:57:36,800 --> 01:57:39,679
often

3141
01:57:37,679 --> 01:57:40,960
pretty reasonable to do because

3142
01:57:39,679 --> 01:57:41,520
oftentimes what you're actually going to

3143
01:57:40,960 --> 01:57:43,760
do

3144
01:57:41,520 --> 01:57:45,599
in here is you're actually going to do

3145
01:57:43,760 --> 01:57:53,840
something

3146
01:57:45,599 --> 01:57:53,840
more like this so like

3147
01:57:55,118 --> 01:58:00,319
this is a totally common pattern that

3148
01:57:57,118 --> 01:58:00,319
you might see right

3149
01:58:01,198 --> 01:58:04,960
where i'm i'm now going to do

3150
01:58:02,880 --> 01:58:06,960
effectively exactly the same code

3151
01:58:04,960 --> 01:58:08,719
i think i have to tell it now that we

3152
01:58:06,960 --> 01:58:12,239
have uh sse4

3153
01:58:08,719 --> 01:58:16,079
does this is it sse4 sss e4

3154
01:58:12,238 --> 01:58:16,079
there's weird what's the name of that

3155
01:58:18,840 --> 01:58:21,840
thing

3156
01:58:24,238 --> 01:58:35,839
how do i get is it is it just sorry is

3157
01:58:28,000 --> 01:58:35,840
it just blend

3158
01:58:37,439 --> 01:58:43,519
i may need to tell it sometimes there's

3159
01:58:40,079 --> 01:58:43,519
it's this kind of nonsense

3160
01:58:46,079 --> 01:58:50,238
what is the what is the actual thing

3161
01:58:47,920 --> 01:58:53,279
that needs to be on here

3162
01:58:50,238 --> 01:58:56,238
you know what forget it

3163
01:58:53,279 --> 01:58:56,238
i'll just do it old school

3164
01:58:59,520 --> 01:59:03,920
so suppose i want to write this thing

3165
01:59:01,118 --> 01:59:06,238
out and i want to just make it dependent

3166
01:59:03,920 --> 01:59:08,560
what i can do is just do it

3167
01:59:06,238 --> 01:59:09,759
by like doing an and not right so

3168
01:59:08,560 --> 01:59:11,920
suppose i just make

3169
01:59:09,760 --> 01:59:13,840
a macro here that's for blending so i

3170
01:59:11,920 --> 01:59:16,560
don't have to type it four times

3171
01:59:13,840 --> 01:59:18,400
and i just want to blend this based on a

3172
01:59:16,560 --> 01:59:19,760
value that i load out of the control so

3173
01:59:18,399 --> 01:59:20,719
what i want to do is i'm doing the same

3174
01:59:19,760 --> 01:59:24,000
exact loop

3175
01:59:20,719 --> 01:59:26,880
loop i want to take this control um

3176
01:59:24,000 --> 01:59:28,479
value here and what i want to do is just

3177
01:59:26,880 --> 01:59:32,239
use that control value

3178
01:59:28,479 --> 01:59:35,759
as a mask right so let's suppose

3179
01:59:32,238 --> 01:59:36,319
that i just have uh a set of masks in

3180
01:59:35,760 --> 01:59:39,599
here

3181
01:59:36,319 --> 01:59:41,279
maybe these uh i want them to actually

3182
01:59:39,599 --> 01:59:42,480
be like set up properly i mean i don't

3183
01:59:41,279 --> 01:59:44,639
know you probably want to would do an

3184
01:59:42,479 --> 01:59:47,279
expansion here but just to make keep the

3185
01:59:44,639 --> 01:59:49,039
code as simple as possible

3186
01:59:47,279 --> 01:59:50,479
let's say we're loading the mask out of

3187
01:59:49,039 --> 01:59:52,319
here um

3188
01:59:50,479 --> 01:59:54,238
rather than lofting it up although we

3189
01:59:52,319 --> 01:59:55,279
can we can show how to do the control

3190
01:59:54,238 --> 01:59:56,158
i'm trying to keep it simple because

3191
01:59:55,279 --> 01:59:58,319
we're at the end of the

3192
01:59:56,158 --> 01:59:59,439
time period here but um so let's say we

3193
01:59:58,319 --> 02:00:02,319
do a blend here

3194
01:59:59,439 --> 02:00:04,319
and so we're going to do a blend of zero

3195
02:00:02,319 --> 02:00:07,198
and if the mask is true we're gonna use

3196
02:00:04,319 --> 02:00:12,238
uh this secondary value here right so

3197
02:00:07,198 --> 02:00:13,919
then what i do is just say okay let's

3198
02:00:12,238 --> 02:00:18,238
take blend and maybe i can

3199
02:00:13,920 --> 02:00:18,239
uh help fix this here

3200
02:00:23,760 --> 02:00:27,840
so here's my various

3201
02:00:29,359 --> 02:00:32,238
options that i have

3202
02:00:33,279 --> 02:00:38,479
and what you can see here is i'm going

3203
02:00:34,399 --> 02:00:40,000
to load out a control word here

3204
02:00:38,479 --> 02:00:41,519
and that control word is going to i'm

3205
02:00:40,000 --> 02:00:43,039
going to say is pre-expanded so i don't

3206
02:00:41,520 --> 02:00:45,280
have to do it but we'll

3207
02:00:43,039 --> 02:00:46,238
actually do the expansion if we have

3208
02:00:45,279 --> 02:00:48,719
time in a second

3209
02:00:46,238 --> 02:00:49,598
um so that it can still come from a care

3210
02:00:48,719 --> 02:00:51,279
and then what i'm going to do

3211
02:00:49,599 --> 02:00:52,639
is i'm just going to find a blend macro

3212
02:00:51,279 --> 02:00:54,399
here um

3213
02:00:52,639 --> 02:00:56,719
where we basically say look i've got an

3214
02:00:54,399 --> 02:00:58,238
a and a b and a mask value

3215
02:00:56,719 --> 02:01:00,158
and what i want to do is i want to

3216
02:00:58,238 --> 02:01:00,559
combine the two so what i want to do

3217
02:01:00,158 --> 02:01:03,598
here

3218
02:01:00,560 --> 02:01:04,719
is i want to basically uh or these two

3219
02:01:03,599 --> 02:01:07,199
together

3220
02:01:04,719 --> 02:01:08,158
um there is an actual blend command but

3221
02:01:07,198 --> 02:01:11,198
it only got introduced

3222
02:01:08,158 --> 02:01:13,839
in like sse4 um so

3223
02:01:11,198 --> 02:01:14,719
i'm not calling the the blend directly

3224
02:01:13,840 --> 02:01:18,079
because of that

3225
02:01:14,719 --> 02:01:20,560
uh that's the only reason so

3226
02:01:18,079 --> 02:01:21,439
uh if i want to bore these two together

3227
02:01:20,560 --> 02:01:24,880
i'm going to or

3228
02:01:21,439 --> 02:01:28,479
together an and and an and

3229
02:01:24,880 --> 02:01:30,719
not and it doesn't actually matter

3230
02:01:28,479 --> 02:01:32,158
which one's which in this case uh let's

3231
02:01:30,719 --> 02:01:36,079
just say we're gonna and with

3232
02:01:32,158 --> 02:01:38,000
m and and not with uh

3233
02:01:36,079 --> 02:01:40,158
with the other one i always have to look

3234
02:01:38,000 --> 02:01:42,960
up and not because i always forget

3235
02:01:40,158 --> 02:01:44,319
which uh one gets knotted in the intel

3236
02:01:42,960 --> 02:01:46,399
syntax

3237
02:01:44,319 --> 02:01:48,238
so i always look it up and see which one

3238
02:01:46,399 --> 02:01:52,079
it is so compute the bitwise not

3239
02:01:48,238 --> 02:01:54,158
of practice a so the first parameter

3240
02:01:52,079 --> 02:01:55,279
is the one that actually gets knotted

3241
02:01:54,158 --> 02:01:57,279
right so the m

3242
02:01:55,279 --> 02:01:59,359
comes first which is what i did so i

3243
02:01:57,279 --> 02:02:00,960
happened to guess right that time but i

3244
02:01:59,359 --> 02:02:03,598
usually have to look

3245
02:02:00,960 --> 02:02:04,319
so uh in this case i think i'm gonna say

3246
02:02:03,599 --> 02:02:06,400
i think i said

3247
02:02:04,319 --> 02:02:08,000
a is the one that happens if the knot is

3248
02:02:06,399 --> 02:02:10,079
false so i'm gonna i'm gonna switch it

3249
02:02:08,000 --> 02:02:12,639
that way so we not the mask for a

3250
02:02:10,079 --> 02:02:13,118
and then we use the mask for b there's

3251
02:02:12,639 --> 02:02:15,359
our

3252
02:02:13,118 --> 02:02:17,519
uh blend instruction so what that does

3253
02:02:15,359 --> 02:02:19,679
is just takes the mask and picks a or b

3254
02:02:17,520 --> 02:02:22,080
based on whether the mask is pop is ones

3255
02:02:19,679 --> 02:02:23,520
or zeros right

3256
02:02:22,079 --> 02:02:24,800
so now what we can do is we can take a

3257
02:02:23,520 --> 02:02:25,840
look at the code that's generated and

3258
02:02:24,800 --> 02:02:29,279
i'm going to just look

3259
02:02:25,840 --> 02:02:30,400
at the code on the msvc side because it

3260
02:02:29,279 --> 02:02:33,519
tends to be the one that's

3261
02:02:30,399 --> 02:02:34,719
less ridiculous um and so let's take a

3262
02:02:33,520 --> 02:02:37,360
look at where

3263
02:02:34,719 --> 02:02:38,719
this code ended up right so here's us

3264
02:02:37,359 --> 02:02:42,079
moving the control

3265
02:02:38,719 --> 02:02:44,639
word in um

3266
02:02:42,079 --> 02:02:46,399
i'll be honest i don't really know why

3267
02:02:44,639 --> 02:02:50,319
it's bothering to do

3268
02:02:46,399 --> 02:02:50,670
these rx rcx loads

3269
02:02:50,319 --> 02:02:53,769
from

3270
02:02:50,670 --> 02:02:53,770
[Music]

3271
02:02:56,800 --> 02:03:00,000
i'm not i have to stop and decrypt that

3272
02:02:58,719 --> 02:03:01,599
my assembly language reading skills are

3273
02:03:00,000 --> 02:03:03,439
not fast enough to know exactly why

3274
02:03:01,599 --> 02:03:05,679
those lease are there

3275
02:03:03,439 --> 02:03:05,678
um

3276
02:03:06,800 --> 02:03:14,400
because it looks like so it looks like

3277
02:03:09,118 --> 02:03:15,920
it's just using

3278
02:03:14,399 --> 02:03:18,319
it looks like it's just using those as a

3279
02:03:15,920 --> 02:03:20,399
way to advance the pointers

3280
02:03:18,319 --> 02:03:22,238
which i guess anyway let's not care

3281
02:03:20,399 --> 02:03:23,279
about that let's just ignore that right

3282
02:03:22,238 --> 02:03:26,079
now

3283
02:03:23,279 --> 02:03:28,639
um so what this is doing here right

3284
02:03:26,079 --> 02:03:31,039
because that's load effective address

3285
02:03:28,639 --> 02:03:31,679
so yeah just ignore those two for now

3286
02:03:31,039 --> 02:03:33,359
because those are

3287
02:03:31,679 --> 02:03:34,560
those are you like working with the

3288
02:03:33,359 --> 02:03:36,238
pointers so let's just look at what we

3289
02:03:34,560 --> 02:03:39,199
did with the ups so

3290
02:03:36,238 --> 02:03:40,079
first what we do here right is we load

3291
02:03:39,198 --> 02:03:43,439
in

3292
02:03:40,079 --> 02:03:46,559
excuse me we load in the control word

3293
02:03:43,439 --> 02:03:49,118
that's coming from rcx right uh we then

3294
02:03:46,560 --> 02:03:49,920
basically take xmm3 which presumably is

3295
02:03:49,118 --> 02:03:53,759
prepped

3296
02:03:49,920 --> 02:03:56,880
uh somewhere here yeah so we take xmm3

3297
02:03:53,760 --> 02:04:00,880
which is prepped with one

3298
02:03:56,880 --> 02:04:04,800
right um and we we load that into zero

3299
02:04:00,880 --> 02:04:07,279
we then and uh

3300
02:04:04,800 --> 02:04:08,560
we then and that which is exactly what

3301
02:04:07,279 --> 02:04:11,519
we would expect to do

3302
02:04:08,560 --> 02:04:13,280
we then move this as i assume is zero we

3303
02:04:11,520 --> 02:04:14,320
move that into here so again these two

3304
02:04:13,279 --> 02:04:17,359
are both free

3305
02:04:14,319 --> 02:04:17,359
now we then and it

3306
02:04:17,520 --> 02:04:21,920
uh with two we do all of the ands with

3307
02:04:21,439 --> 02:04:25,039
two

3308
02:04:21,920 --> 02:04:28,239
actually uh and then we do

3309
02:04:25,039 --> 02:04:30,479
oh so wow

3310
02:04:28,238 --> 02:04:32,479
actually if you look at what this

3311
02:04:30,479 --> 02:04:34,479
generated it was smart enough to know

3312
02:04:32,479 --> 02:04:36,319
that it didn't have to do the blend with

3313
02:04:34,479 --> 02:04:39,359
zero

3314
02:04:36,319 --> 02:04:40,639
right so it's not ever even doing the or

3315
02:04:39,359 --> 02:04:41,359
because it's just smart enough to know

3316
02:04:40,639 --> 02:04:43,760
that

3317
02:04:41,359 --> 02:04:45,759
so let's since we were just doing this

3318
02:04:43,760 --> 02:04:47,199
as a test let's just

3319
02:04:45,760 --> 02:04:52,239
make sure that you can see the whole

3320
02:04:47,198 --> 02:04:55,919
code path

3321
02:04:52,238 --> 02:04:57,839
this way it has to actually do something

3322
02:04:55,920 --> 02:04:59,039
that was pretty cool though right good

3323
02:04:57,840 --> 02:05:01,360
job msvc

3324
02:04:59,039 --> 02:05:02,639
noticed that as an or was zero but there

3325
02:05:01,359 --> 02:05:05,118
now you can see the ors

3326
02:05:02,639 --> 02:05:07,039
so it's just going to load those in and

3327
02:05:05,118 --> 02:05:08,960
by load it's actually just renaming the

3328
02:05:07,039 --> 02:05:10,960
registers which is great

3329
02:05:08,960 --> 02:05:12,399
so it's it's really costing us nothing

3330
02:05:10,960 --> 02:05:15,599
it's just doing an

3331
02:05:12,399 --> 02:05:19,118
and an or and or and or and or

3332
02:05:15,599 --> 02:05:22,078
right it's just doing ands and ors

3333
02:05:19,118 --> 02:05:22,960
and there's those and knots as well

3334
02:05:22,078 --> 02:05:26,399
right

3335
02:05:22,960 --> 02:05:29,840
um there should be

3336
02:05:26,399 --> 02:05:31,679
more of them than that shouldn't there

3337
02:05:29,840 --> 02:05:32,960
no there shouldn't because these are all

3338
02:05:31,679 --> 02:05:36,239
the same value

3339
02:05:32,960 --> 02:05:38,078
the compiler is so quick isn't it

3340
02:05:36,238 --> 02:05:39,598
it's it's really doing a good job with

3341
02:05:38,078 --> 02:05:40,719
the sub expression elimination there

3342
02:05:39,599 --> 02:05:43,840
right

3343
02:05:40,719 --> 02:05:43,840
so the oh you know what i'll do

3344
02:05:44,719 --> 02:05:49,840
here we go

3345
02:05:50,479 --> 02:05:58,078
there you go so here you can see um

3346
02:05:55,118 --> 02:05:58,399
the full case where it has to do it and

3347
02:05:58,078 --> 02:06:02,479
and

3348
02:05:58,399 --> 02:06:03,039
and not and an or for each one now again

3349
02:06:02,479 --> 02:06:06,959
this may

3350
02:06:03,039 --> 02:06:08,639
look like a lot of code right because

3351
02:06:06,960 --> 02:06:10,158
it looks like a lot more code than the

3352
02:06:08,639 --> 02:06:12,239
other one which just had one you know

3353
02:06:10,158 --> 02:06:14,399
four and then a branch and four

3354
02:06:12,238 --> 02:06:15,598
but what you have to remember is that

3355
02:06:14,399 --> 02:06:18,960
this now has

3356
02:06:15,599 --> 02:06:22,078
no branches at all this entire loop

3357
02:06:18,960 --> 02:06:22,480
executes branch free and all of these

3358
02:06:22,078 --> 02:06:25,679
things

3359
02:06:22,479 --> 02:06:27,919
execute together or an and

3360
02:06:25,679 --> 02:06:30,800
are simple one cycle instructions for

3361
02:06:27,920 --> 02:06:34,560
which there are many ports three

3362
02:06:30,800 --> 02:06:38,800
ports at least most of the time

3363
02:06:34,560 --> 02:06:41,520
um and so all of this stuff will overlap

3364
02:06:38,800 --> 02:06:43,119
so actually when you actually profile

3365
02:06:41,520 --> 02:06:45,119
this this routine may be

3366
02:06:43,118 --> 02:06:46,799
way faster than the other one depending

3367
02:06:45,118 --> 02:06:48,238
on the circumstances

3368
02:06:46,800 --> 02:06:50,480
because now there can never be a

3369
02:06:48,238 --> 02:06:52,479
mispredicted branch so whether this

3370
02:06:50,479 --> 02:06:53,598
routine or the other one was faster

3371
02:06:52,479 --> 02:06:56,638
would depend on

3372
02:06:53,599 --> 02:07:00,078
how random the control word was

3373
02:06:56,639 --> 02:07:01,599
basically right now again we can also

3374
02:07:00,078 --> 02:07:02,000
amplify the control word if we only want

3375
02:07:01,599 --> 02:07:04,560
to

3376
02:07:02,000 --> 02:07:05,840
load one byte out we can always do a

3377
02:07:04,560 --> 02:07:08,719
load and a shuff

3378
02:07:05,840 --> 02:07:09,599
to like blow that out um but there you

3379
02:07:08,719 --> 02:07:11,039
go

3380
02:07:09,599 --> 02:07:12,800
okay so i think i covered everything i

3381
02:07:11,039 --> 02:07:14,880
wanted to cover

3382
02:07:12,800 --> 02:07:26,800
let's go to a quick q a if anyone has

3383
02:07:14,880 --> 02:07:29,679
any questions

3384
02:07:26,800 --> 02:07:31,360
and this is jesse whose uh original post

3385
02:07:29,679 --> 02:07:32,719
on twitter motivated this

3386
02:07:31,359 --> 02:07:33,920
he says thank you so much for taking the

3387
02:07:32,719 --> 02:07:35,599
time to explain and demonstrate this on

3388
02:07:33,920 --> 02:07:38,840
handmade hero deep appreciated

3389
02:07:35,599 --> 02:07:40,000
my pleasure thank you for taking um it

3390
02:07:38,840 --> 02:07:42,560
seriously

3391
02:07:40,000 --> 02:07:44,319
like of everything i saw on that twitter

3392
02:07:42,560 --> 02:07:46,079
thread which is mostly just people

3393
02:07:44,319 --> 02:07:48,479
making stuff up that they didn't know

3394
02:07:46,078 --> 02:07:50,799
about you actually took the time to

3395
02:07:48,479 --> 02:07:53,039
write some actual code and learn from it

3396
02:07:50,800 --> 02:07:55,840
and that is like so important

3397
02:07:53,039 --> 02:07:58,238
so that that was why i did this because

3398
02:07:55,840 --> 02:08:01,039
i was like somebody actually cares

3399
02:07:58,238 --> 02:08:02,399
rather than just saying stuff on twitter

3400
02:08:01,039 --> 02:08:06,479
and when somebody actually

3401
02:08:02,399 --> 02:08:11,198
cares that is the person

3402
02:08:06,479 --> 02:08:15,759
that deserves to have their concerns

3403
02:08:11,198 --> 02:08:17,519
like legitimated and explored so

3404
02:08:15,760 --> 02:08:19,199
thank you for taking it seriously and

3405
02:08:17,520 --> 02:08:22,159
posting on twitter and i'm

3406
02:08:19,198 --> 02:08:23,439
glad that you found this useful if you

3407
02:08:22,158 --> 02:08:37,439
found it useful

3408
02:08:23,439 --> 02:08:39,759
uh so yeah

3409
02:08:37,439 --> 02:08:42,078
and yeah the lea so load effective

3410
02:08:39,760 --> 02:08:43,760
address there's just

3411
02:08:42,078 --> 02:08:45,840
so because i don't really do much

3412
02:08:43,760 --> 02:08:49,199
assembly language programming except

3413
02:08:45,840 --> 02:08:52,400
with um simdi

3414
02:08:49,198 --> 02:08:54,319
a lot of the vagaries of x64 or x86 for

3415
02:08:52,399 --> 02:08:56,158
that matter assembly language like using

3416
02:08:54,319 --> 02:08:58,960
load effective address to do

3417
02:08:56,158 --> 02:09:01,279
arithmetic and stuff are lost on me

3418
02:08:58,960 --> 02:09:03,439
because i never write that code really

3419
02:09:01,279 --> 02:09:05,118
right i'm usually just trying to look at

3420
02:09:03,439 --> 02:09:06,319
how to make sure this sort of stuff

3421
02:09:05,118 --> 02:09:09,519
works out okay

3422
02:09:06,319 --> 02:09:10,559
so i have a pretty good understanding of

3423
02:09:09,520 --> 02:09:14,000
how to make sure

3424
02:09:10,560 --> 02:09:14,719
all of the um cmd unit stuff lines up

3425
02:09:14,000 --> 02:09:18,000
properly

3426
02:09:14,719 --> 02:09:19,920
but like the cool tricks and stuff

3427
02:09:18,000 --> 02:09:22,319
that's like using load effective address

3428
02:09:19,920 --> 02:09:23,599
to do point arithmetic

3429
02:09:22,319 --> 02:09:25,679
faster than maybe you could do it with

3430
02:09:23,599 --> 02:09:28,319
something else i just

3431
02:09:25,679 --> 02:09:29,440
don't understand that stuff i'm sure

3432
02:09:28,319 --> 02:09:30,880
it's not that complicated if you went

3433
02:09:29,439 --> 02:09:31,439
and looked it's probably not that hard

3434
02:09:30,880 --> 02:09:33,840
to learn

3435
02:09:31,439 --> 02:09:35,439
but i've never done it and so i don't

3436
02:09:33,840 --> 02:09:38,239
feel comfortable

3437
02:09:35,439 --> 02:09:39,839
explaining anything that may actually be

3438
02:09:38,238 --> 02:09:41,279
slower than doing the equivalent now and

3439
02:09:39,840 --> 02:09:41,920
it may be kind of antiquated that it's

3440
02:09:41,279 --> 02:09:43,679
doing that

3441
02:09:41,920 --> 02:09:45,359
or maybe that's still the best way to do

3442
02:09:43,679 --> 02:09:46,800
it i have no idea so i

3443
02:09:45,359 --> 02:09:49,279
you know someone else will have to talk

3444
02:09:46,800 --> 02:09:49,279
about that

3445
02:09:56,800 --> 02:10:00,000
i compiled the code with icc the intel

3446
02:09:58,719 --> 02:10:03,359
compiler with o2 and it takes

3447
02:10:00,000 --> 02:10:05,118
3.5 seconds to run it is it really bad

3448
02:10:03,359 --> 02:10:06,479
um well it depends on what the platform

3449
02:10:05,118 --> 02:10:09,598
is i don't know and

3450
02:10:06,479 --> 02:10:10,879
again like i don't uh i don't really

3451
02:10:09,599 --> 02:10:12,800
have

3452
02:10:10,880 --> 02:10:15,039
a feel for how fast this thing should go

3453
02:10:12,800 --> 02:10:16,639
yet because we haven't tried test

3454
02:10:15,039 --> 02:10:18,399
running it or anything

3455
02:10:16,639 --> 02:10:20,639
i will say that the memory bandwidth on

3456
02:10:18,399 --> 02:10:23,598
your machine will make a big difference

3457
02:10:20,639 --> 02:10:24,719
because this is going to be out of the

3458
02:10:23,599 --> 02:10:27,440
cache so

3459
02:10:24,719 --> 02:10:28,239
if you look at how many bytes that is

3460
02:10:27,439 --> 02:10:30,559
this is the

3461
02:10:28,238 --> 02:10:33,118
total number of bytes right so it's six

3462
02:10:30,560 --> 02:10:35,199
four zero zero zero zero zero zero

3463
02:10:33,118 --> 02:10:36,799
is the number of bytes that it's going

3464
02:10:35,198 --> 02:10:37,678
to have to write if we did that

3465
02:10:36,800 --> 02:10:40,000
correctly

3466
02:10:37,679 --> 02:10:41,199
so if you take a look at the cache size

3467
02:10:40,000 --> 02:10:42,880
or typical cache size that you might

3468
02:10:41,198 --> 02:10:45,439
find in one of these processors

3469
02:10:42,880 --> 02:10:47,279
um you're going to find that like 256k

3470
02:10:45,439 --> 02:10:49,279
is like a typical l2 cache size for

3471
02:10:47,279 --> 02:10:52,800
example

3472
02:10:49,279 --> 02:10:54,719
um and so this is like way more

3473
02:10:52,800 --> 02:10:56,079
times than the cache is covered so

3474
02:10:54,719 --> 02:10:57,679
you're looking at l3

3475
02:10:56,078 --> 02:10:59,679
or main memory bandwidth most of the

3476
02:10:57,679 --> 02:11:02,639
time that's actually going to be

3477
02:10:59,679 --> 02:11:03,279
a big bottleneck so one of the reasons

3478
02:11:02,639 --> 02:11:04,800
that

3479
02:11:03,279 --> 02:11:06,238
if we were actually going to move into

3480
02:11:04,800 --> 02:11:07,039
like actually talking about this and

3481
02:11:06,238 --> 02:11:09,678
testing this

3482
02:11:07,039 --> 02:11:10,399
in a real scenario rather than just

3483
02:11:09,679 --> 02:11:11,760
talking about

3484
02:11:10,399 --> 02:11:13,598
what's happening in the registers as a

3485
02:11:11,760 --> 02:11:15,199
for educational purposes we would have

3486
02:11:13,599 --> 02:11:16,639
to acknowledge the fact that the amount

3487
02:11:15,198 --> 02:11:17,839
of memory that this thing is working

3488
02:11:16,639 --> 02:11:20,880
with at a time

3489
02:11:17,840 --> 02:11:23,039
will make it very difficult to assess

3490
02:11:20,880 --> 02:11:25,359
differences in the routine in the first

3491
02:11:23,039 --> 02:11:28,158
place because there's so much

3492
02:11:25,359 --> 02:11:30,399
memory getting moo touched here that the

3493
02:11:28,158 --> 02:11:32,078
cpu's memory bandwidth will really be

3494
02:11:30,399 --> 02:11:33,359
the bottleneck because

3495
02:11:32,078 --> 02:11:35,840
remember when i said it can do two

3496
02:11:33,359 --> 02:11:37,198
stores per cycle that's two stores to

3497
02:11:35,840 --> 02:11:40,639
the l1

3498
02:11:37,198 --> 02:11:42,399
or the l2 uh there's no way it's going

3499
02:11:40,639 --> 02:11:43,039
to get two stores per cycle to main

3500
02:11:42,399 --> 02:11:44,479
memory

3501
02:11:43,039 --> 02:11:46,158
because main memory isn't fast enough

3502
02:11:44,479 --> 02:11:50,799
for that right

3503
02:11:46,158 --> 02:11:54,158
um so you have to keep in mind the

3504
02:11:50,800 --> 02:11:56,880
the performance overhead of stores is

3505
02:11:54,158 --> 02:11:58,158
one cycle to l1 and 14 cycles to l2

3506
02:11:56,880 --> 02:11:59,920
typically

3507
02:11:58,158 --> 02:12:02,638
so depending on exactly what you're

3508
02:11:59,920 --> 02:12:06,000
doing you may be able to get

3509
02:12:02,639 --> 02:12:08,078
l1 or l2 bandwidth which may end up

3510
02:12:06,000 --> 02:12:09,840
equating to

3511
02:12:08,078 --> 02:12:12,078
something like two stores per i'm sorry

3512
02:12:09,840 --> 02:12:14,000
one store per cycle

3513
02:12:12,078 --> 02:12:16,078
uh sorry if i said two store circle one

3514
02:12:14,000 --> 02:12:18,319
store per cycle to l1

3515
02:12:16,078 --> 02:12:19,599
um you're not going to get you're gonna

3516
02:12:18,319 --> 02:12:22,799
get one store every 14

3517
02:12:19,599 --> 02:12:25,920
cycles uh to l2 and

3518
02:12:22,800 --> 02:12:27,520
you're going to get one store very

3519
02:12:25,920 --> 02:12:29,599
much less frequently than that if you

3520
02:12:27,520 --> 02:12:33,360
have to go l3 to

3521
02:12:29,599 --> 02:12:35,039
mem or main memory right so

3522
02:12:33,359 --> 02:12:37,039
the fact that we're doing such a huge

3523
02:12:35,039 --> 02:12:38,800
chunk of this thing

3524
02:12:37,039 --> 02:12:40,560
this is not indicative of how you're

3525
02:12:38,800 --> 02:12:41,679
usually using clear to zero

3526
02:12:40,560 --> 02:12:43,679
normally you're talking about something

3527
02:12:41,679 --> 02:12:45,840
local that you're about to use like i'm

3528
02:12:43,679 --> 02:12:48,000
initializing like an entity or something

3529
02:12:45,840 --> 02:12:50,239
and those are the cases where clear to

3530
02:12:48,000 --> 02:12:51,439
zero is completely free usually because

3531
02:12:50,238 --> 02:12:55,039
you're about to use it anyway

3532
02:12:51,439 --> 02:12:57,039
and you can go as fast as

3533
02:12:55,039 --> 02:12:58,479
l1 goes because you're all in the l1

3534
02:12:57,039 --> 02:13:00,560
doing stuff in the l1

3535
02:12:58,479 --> 02:13:02,000
when you're talking about giant clears

3536
02:13:00,560 --> 02:13:03,760
or giant writes

3537
02:13:02,000 --> 02:13:05,520
usually it doesn't matter what you do

3538
02:13:03,760 --> 02:13:07,599
because memory bandwidth is so slow you

3539
02:13:05,520 --> 02:13:10,159
can do several instructions that are

3540
02:13:07,599 --> 02:13:11,679
irrelevant and don't matter even the

3541
02:13:10,158 --> 02:13:13,679
branch misprediction penalty

3542
02:13:11,679 --> 02:13:15,599
probably doesn't matter because it's on

3543
02:13:13,679 --> 02:13:16,960
the order of 20 cycles

3544
02:13:15,599 --> 02:13:19,360
and main memory bandwidth is on the

3545
02:13:16,960 --> 02:13:23,599
order of like 100 cycles or something

3546
02:13:19,359 --> 02:13:31,839
so it's just worth noting that

3547
02:13:23,599 --> 02:13:31,840
these are the limitations right

3548
02:13:35,279 --> 02:13:38,319
uh someone has mentioned that older

3549
02:13:37,039 --> 02:13:38,800
versions of claiming generate better

3550
02:13:38,319 --> 02:13:40,960
code

3551
02:13:38,800 --> 02:13:42,719
uh it could be right performance

3552
02:13:40,960 --> 02:13:44,719
regressions are real

3553
02:13:42,719 --> 02:13:46,480
um and their test suite probably can't

3554
02:13:44,719 --> 02:13:48,480
capture everything so

3555
02:13:46,479 --> 02:13:49,759
you know if we go back to doing this

3556
02:13:48,479 --> 02:13:50,879
thing

3557
02:13:49,760 --> 02:13:53,280
which was where it was kind of

3558
02:13:50,880 --> 02:13:54,639
generating uh really bad code if i

3559
02:13:53,279 --> 02:13:57,840
remember correctly

3560
02:13:54,639 --> 02:13:59,920
yeah we can certainly roll back so let's

3561
02:13:57,840 --> 02:14:02,560
suppose we roll back to like an earlier

3562
02:13:59,920 --> 02:14:05,118
version of clang let's say clang seven

3563
02:14:02,560 --> 02:14:07,360
um looks the same we can roll back to

3564
02:14:05,118 --> 02:14:07,359
four

3565
02:14:07,520 --> 02:14:11,599
looks the same so for whatever reason

3566
02:14:09,679 --> 02:14:13,520
like clang's memory analysis here is

3567
02:14:11,599 --> 02:14:15,440
just it just rolls over and dies

3568
02:14:13,520 --> 02:14:18,239
who knows why just hit a bad case i

3569
02:14:15,439 --> 02:14:18,238
guess i don't know

3570
02:14:24,158 --> 02:14:27,839
i read that mixing sc2 and avx-2 will

3571
02:14:26,158 --> 02:14:29,598
incur performance penalty how would you

3572
02:14:27,840 --> 02:14:31,360
handle optimizing code if you want to

3573
02:14:29,599 --> 02:14:32,960
support avx-2 but also sse

3574
02:14:31,359 --> 02:14:36,000
for older systems would you just have

3575
02:14:32,960 --> 02:14:36,000
separate builds for each

3576
02:14:38,840 --> 02:14:41,840
um

3577
02:14:42,399 --> 02:14:47,039
so let me first take a moment to cast a

3578
02:14:45,279 --> 02:14:50,238
slight shadow of doubt on that

3579
02:14:47,039 --> 02:14:52,158
statement i don't actually know that

3580
02:14:50,238 --> 02:14:56,319
it's fair to say that mixing

3581
02:14:52,158 --> 02:15:00,638
sse and avx ii code

3582
02:14:56,319 --> 02:15:04,880
incurs a performance penalty because

3583
02:15:00,639 --> 02:15:10,159
it it does i mean that's not wrong

3584
02:15:04,880 --> 02:15:10,159
but it's more precise to say that

3585
02:15:12,880 --> 02:15:18,159
mixing v prefix and

3586
02:15:15,920 --> 02:15:20,399
non-v prefix instructions can have a

3587
02:15:18,158 --> 02:15:26,078
performance penalty

3588
02:15:20,399 --> 02:15:29,279
so avx instructions are prefixed with v

3589
02:15:26,078 --> 02:15:33,359
but so are sse instructions written

3590
02:15:29,279 --> 02:15:34,319
in avx so the sse instructions

3591
02:15:33,359 --> 02:15:36,880
themselves

3592
02:15:34,319 --> 02:15:37,359
have v prefix versions that you can use

3593
02:15:36,880 --> 02:15:39,359
and you

3594
02:15:37,359 --> 02:15:41,759
see them show up so here's the exact

3595
02:15:39,359 --> 02:15:43,920
same code when i say mavx

3596
02:15:41,760 --> 02:15:44,960
it'll all have v prefixes inserted in

3597
02:15:43,920 --> 02:15:47,279
front of it

3598
02:15:44,960 --> 02:15:49,118
so the code is actually completely the

3599
02:15:47,279 --> 02:15:49,359
same the only difference is now it has a

3600
02:15:49,118 --> 02:15:53,279
v

3601
02:15:49,359 --> 02:15:56,880
prefix and that's to avoid calling

3602
02:15:53,279 --> 02:15:57,920
v and non-v instructions in the same

3603
02:15:56,880 --> 02:15:59,760
path

3604
02:15:57,920 --> 02:16:01,760
whether that has a performance so

3605
02:15:59,760 --> 02:16:05,199
calling a v in a non-v

3606
02:16:01,760 --> 02:16:06,800
uh in the same path whether that has a

3607
02:16:05,198 --> 02:16:08,559
performance implication

3608
02:16:06,800 --> 02:16:10,560
i think depends entirely on the

3609
02:16:08,560 --> 02:16:12,159
architecture i don't think it's true for

3610
02:16:10,560 --> 02:16:19,840
all architectures but i could be wrong

3611
02:16:12,158 --> 02:16:19,839
about that right

3612
02:16:21,279 --> 02:16:27,359
um and

3613
02:16:24,479 --> 02:16:29,198
to the extent that you care about this

3614
02:16:27,359 --> 02:16:31,920
what i would say is

3615
02:16:29,198 --> 02:16:32,718
typically what i do is i isolate all of

3616
02:16:31,920 --> 02:16:34,799
the code

3617
02:16:32,718 --> 02:16:35,919
that is architecture dependent into like

3618
02:16:34,799 --> 02:16:39,438
one file

3619
02:16:35,920 --> 02:16:42,558
i usually call that like x64

3620
02:16:39,439 --> 02:16:44,398
underscore you know math or something

3621
02:16:42,558 --> 02:16:47,358
right

3622
02:16:44,398 --> 02:16:47,840
and then i will have variants of it so

3623
02:16:47,359 --> 02:16:51,359
uh

3624
02:16:47,840 --> 02:16:52,960
in that file i will have

3625
02:16:51,359 --> 02:16:55,599
if blocks determining which one i'm

3626
02:16:52,959 --> 02:17:00,398
using or i will just have

3627
02:16:55,599 --> 02:17:03,120
like avx underscore avx2 underscore

3628
02:17:00,398 --> 02:17:03,920
sse underscore as my files and then

3629
02:17:03,120 --> 02:17:06,160
pound

3630
02:17:03,920 --> 02:17:08,478
include f0 around which ones i'm going

3631
02:17:06,159 --> 02:17:11,519
to include right

3632
02:17:08,478 --> 02:17:15,599
and i will just create the code

3633
02:17:11,519 --> 02:17:18,000
for each path i will

3634
02:17:15,599 --> 02:17:18,799
write the entire path that way so i'll

3635
02:17:18,000 --> 02:17:22,000
compile

3636
02:17:18,799 --> 02:17:26,398
all of my sse routines

3637
02:17:22,000 --> 02:17:28,558
as avx routines and so forth

3638
02:17:26,398 --> 02:17:30,879
switching between so if you just have

3639
02:17:28,558 --> 02:17:32,879
the compiler outputting sse instructions

3640
02:17:30,879 --> 02:17:34,638
in your normal code and then you call

3641
02:17:32,879 --> 02:17:36,159
into an avx

3642
02:17:34,638 --> 02:17:38,000
routine that's going to have vp

3643
02:17:36,159 --> 02:17:39,599
instructions i don't think that

3644
02:17:38,000 --> 02:17:41,120
performance penalty is going to hurt you

3645
02:17:39,599 --> 02:17:42,719
because it's only the first time you do

3646
02:17:41,120 --> 02:17:44,160
it that you pay a transition penalty and

3647
02:17:42,718 --> 02:17:45,598
it's not that expensive

3648
02:17:44,159 --> 02:17:48,239
so the only thing you're really trying

3649
02:17:45,599 --> 02:17:49,599
to avoid there is like inside a loop you

3650
02:17:48,239 --> 02:17:51,359
don't want them both

3651
02:17:49,599 --> 02:17:52,639
but like if you occasionally switch

3652
02:17:51,359 --> 02:17:53,840
between the two i don't think it's going

3653
02:17:52,638 --> 02:17:56,398
to matter

3654
02:17:53,840 --> 02:17:59,200
that said allowing the compiler the

3655
02:17:56,398 --> 02:18:02,079
ability to generate avx code

3656
02:17:59,200 --> 02:18:04,159
is usually kind of good so what you

3657
02:18:02,079 --> 02:18:05,200
might want to do is just have two builds

3658
02:18:04,159 --> 02:18:07,039
of your game

3659
02:18:05,200 --> 02:18:08,840
and just have a little shim that starts

3660
02:18:07,040 --> 02:18:11,599
up and loads the right one

3661
02:18:08,840 --> 02:18:14,799
right so like build two dlls

3662
02:18:11,599 --> 02:18:18,239
avx avx2 or

3663
02:18:14,799 --> 02:18:19,920
three dlls sse2 avx and avx2 or

3664
02:18:18,239 --> 02:18:23,280
something like that

3665
02:18:19,920 --> 02:18:25,439
um or avx 512 if you're really gung-ho

3666
02:18:23,280 --> 02:18:26,960
uh and then just load the right one or

3667
02:18:25,439 --> 02:18:28,398
load them in series and wait for them to

3668
02:18:26,959 --> 02:18:29,759
fault and then switch to another one you

3669
02:18:28,398 --> 02:18:32,000
know whatever you want to do

3670
02:18:29,760 --> 02:18:32,000
right

3671
02:18:34,638 --> 02:18:38,318
someone asked if we could show what gcc

3672
02:18:36,318 --> 02:18:42,879
does yes we can

3673
02:18:38,318 --> 02:18:45,359
um where is it though

3674
02:18:42,879 --> 02:18:45,358
here it is

3675
02:18:47,280 --> 02:18:55,840
um so wow

3676
02:18:51,200 --> 02:18:55,840
all right um is that really what it does

3677
02:18:56,159 --> 02:19:04,159
so gcc's code is is terrible

3678
02:19:00,318 --> 02:19:04,159
um it did the entire thing with scalar

3679
02:19:04,840 --> 02:19:07,840
moves

3680
02:19:18,398 --> 02:19:21,840
try clang six

3681
02:19:27,280 --> 02:19:31,439
still looks bad um

3682
02:19:33,519 --> 02:19:39,519
playing six looks wrong doesn't it still

3683
02:19:37,280 --> 02:19:39,519
ah

3684
02:19:41,840 --> 02:19:49,840
still looks bad

3685
02:19:58,079 --> 02:20:05,039
ah okay so 03 made a big difference

3686
02:20:01,760 --> 02:20:07,439
for gcc though right that is the correct

3687
02:20:05,040 --> 02:20:09,680
code

3688
02:20:07,439 --> 02:20:09,680
so

3689
02:20:12,559 --> 02:20:19,519
so that's so gcc absolutely trounces

3690
02:20:16,239 --> 02:20:22,318
clang here at 03

3691
02:20:19,520 --> 02:20:22,319
for what it's worth

3692
02:20:26,239 --> 02:20:28,000
could you provide the twitter

3693
02:20:27,040 --> 02:20:29,600
conversation link that you are

3694
02:20:28,000 --> 02:20:30,159
responding to for the youtube video i

3695
02:20:29,600 --> 02:20:34,399
thought i

3696
02:20:30,159 --> 02:20:37,520
did actually at the beginning of it um

3697
02:20:34,398 --> 02:20:40,318
but it was jesse meyer posting

3698
02:20:37,520 --> 02:20:41,359
some tests he was trying to do right

3699
02:20:40,318 --> 02:20:45,039
here

3700
02:20:41,359 --> 02:20:48,239
um so uh this is what i

3701
02:20:45,040 --> 02:20:49,439
uh said you know because like i said i

3702
02:20:48,239 --> 02:20:50,398
appreciated the fact that he took the

3703
02:20:49,439 --> 02:20:53,600
time to do this so

3704
02:20:50,398 --> 02:20:54,639
i uh wanted to take the time to expound

3705
02:20:53,600 --> 02:20:57,439
on it

3706
02:20:54,639 --> 02:20:58,239
um and just say my thoughts on this

3707
02:20:57,439 --> 02:21:01,920
particular

3708
02:20:58,239 --> 02:21:01,920
uh topic

3709
02:21:03,680 --> 02:21:08,318
uh latest clang with well i thought i

3710
02:21:06,159 --> 02:21:11,280
did i think we did try the latest clang

3711
02:21:08,318 --> 02:21:12,478
with o3 um and yeah that's latest clang

3712
02:21:11,280 --> 02:21:14,640
with o3

3713
02:21:12,478 --> 02:21:15,760
so let me let me pause for a second and

3714
02:21:14,639 --> 02:21:18,000
also say one more thing before we

3715
02:21:15,760 --> 02:21:21,920
conclude

3716
02:21:18,000 --> 02:21:25,120
this isn't a tractable situation right

3717
02:21:21,920 --> 02:21:27,040
this is like really bad the fact that

3718
02:21:25,120 --> 02:21:29,600
everyone's like try clang six with o3

3719
02:21:27,040 --> 02:21:33,399
and arch this

3720
02:21:29,600 --> 02:21:35,040
it should produce reliable code for

3721
02:21:33,398 --> 02:21:37,599
reliablely written

3722
02:21:35,040 --> 02:21:39,520
simple pieces of code without having to

3723
02:21:37,600 --> 02:21:41,439
be some kind of a switch jockey

3724
02:21:39,520 --> 02:21:43,439
now in this case it never produces good

3725
02:21:41,439 --> 02:21:45,120
code so clang as far as i can tell will

3726
02:21:43,439 --> 02:21:48,880
never produce good code for this

3727
02:21:45,120 --> 02:21:49,600
period but this is one of the reasons

3728
02:21:48,879 --> 02:21:52,639
why i

3729
02:21:49,600 --> 02:21:55,760
think that fundamentally the model for

3730
02:21:52,639 --> 02:21:58,639
c and compilers is broken

3731
02:21:55,760 --> 02:22:00,639
it should not be a gigantic mystery what

3732
02:21:58,639 --> 02:22:01,840
kind of x64 code is going to get

3733
02:22:00,639 --> 02:22:03,279
generated when you do something as

3734
02:22:01,840 --> 02:22:06,318
simple as copy

3735
02:22:03,280 --> 02:22:08,960
from a known value to memory

3736
02:22:06,318 --> 02:22:10,239
right it should be like really

3737
02:22:08,959 --> 02:22:12,799
straightforward

3738
02:22:10,239 --> 02:22:13,280
and the problem is we keep introducing

3739
02:22:12,799 --> 02:22:16,478
all these

3740
02:22:13,280 --> 02:22:17,359
layers switches and optimization paths

3741
02:22:16,478 --> 02:22:20,799
and all stuff

3742
02:22:17,359 --> 02:22:23,520
just let's stop all that

3743
02:22:20,799 --> 02:22:25,358
if there's not straightforward ways to

3744
02:22:23,520 --> 02:22:28,479
optimize code from the c

3745
02:22:25,359 --> 02:22:30,479
code let's modify the c spec so that i

3746
02:22:28,478 --> 02:22:33,679
can tell you what i was trying to do

3747
02:22:30,478 --> 02:22:36,719
right and that's just better

3748
02:22:33,680 --> 02:22:37,840
right i don't want this to be happening

3749
02:22:36,719 --> 02:22:40,799
this is bad

3750
02:22:37,840 --> 02:22:42,478
right it makes the um person's job a lot

3751
02:22:40,799 --> 02:22:45,199
harder when they can't

3752
02:22:42,478 --> 02:22:46,478
reliably know that copying from one

3753
02:22:45,200 --> 02:22:50,079
place to another

3754
02:22:46,478 --> 02:22:53,199
if it's 64 bytes should just be

3755
02:22:50,079 --> 02:22:55,760
four mod ups's

3756
02:22:53,200 --> 02:22:57,280
that should just be like obvious and if

3757
02:22:55,760 --> 02:22:58,960
something other than that's gonna happen

3758
02:22:57,280 --> 02:23:00,479
you should have to be specifying all

3759
02:22:58,959 --> 02:23:02,239
kinds of like in code pragmas or

3760
02:23:00,478 --> 02:23:03,920
something to get it to happen

3761
02:23:02,239 --> 02:23:05,600
doing the obvious thing is way more

3762
02:23:03,920 --> 02:23:06,799
valuable than occasionally doing some

3763
02:23:05,600 --> 02:23:10,000
heroic thing

3764
02:23:06,799 --> 02:23:13,840
you know so

3765
02:23:10,000 --> 02:23:13,840
this is not tractable it's not great

3766
02:23:16,840 --> 02:23:19,840
right

3767
02:23:23,200 --> 02:23:27,359
is it possible the extra jumps clang

3768
02:23:24,799 --> 02:23:31,199
generates are a specter mitigation

3769
02:23:27,359 --> 02:23:31,200
why is it doing specter mitigation

3770
02:23:31,520 --> 02:23:35,680
nobody asked it to do spectre mitigation

3771
02:23:35,840 --> 02:23:40,239
in what universe would i care about

3772
02:23:37,439 --> 02:23:44,720
spectre mitigation in a game

3773
02:23:40,239 --> 02:23:46,639
right it's absurd

3774
02:23:44,719 --> 02:23:50,398
it's absurd if you want specter

3775
02:23:46,639 --> 02:23:50,398
mitigation you should have to ask for it

3776
02:23:52,079 --> 02:23:54,799
now i don't know if that had anything to

3777
02:23:53,280 --> 02:23:56,239
do with spectrum indication but if let's

3778
02:23:54,799 --> 02:23:59,119
say that you're right and it did it's

3779
02:23:56,239 --> 02:24:00,398
absurd that it was doing that by default

3780
02:23:59,120 --> 02:24:03,040
i'm trying to test this code and it's

3781
02:24:00,398 --> 02:24:14,478
doing spectre mitigation well that's

3782
02:24:03,040 --> 02:24:17,520
something i should have asked for right

3783
02:24:14,478 --> 02:24:20,719
all right um so if you want

3784
02:24:17,520 --> 02:24:23,920
to uh share this

3785
02:24:20,719 --> 02:24:26,079
god bolt as well uh here is a link to it

3786
02:24:23,920 --> 02:24:29,840
um it'll probably save it uh and then

3787
02:24:26,079 --> 02:24:31,359
we'll close down for the day um

3788
02:24:29,840 --> 02:24:33,680
oh someone says spectre mitigation is on

3789
02:24:31,359 --> 02:24:34,720
a hardware level um spectre mitigation

3790
02:24:33,680 --> 02:24:37,439
at the hardware level

3791
02:24:34,719 --> 02:24:38,559
is only in some processors right and

3792
02:24:37,439 --> 02:24:42,079
they had to do like

3793
02:24:38,559 --> 02:24:44,000
patches for it but again i don't think

3794
02:24:42,079 --> 02:24:47,280
that was spectre mitigation or anything

3795
02:24:44,000 --> 02:24:50,079
anyway uh but i'm just

3796
02:24:47,280 --> 02:24:51,520
saying let's suppose it was i don't see

3797
02:24:50,079 --> 02:24:52,159
how it would be but let's just suppose

3798
02:24:51,520 --> 02:24:54,960
it was

3799
02:24:52,159 --> 02:24:56,799
that's dumb anyway right it shouldn't

3800
02:24:54,959 --> 02:24:57,839
just be throwing spectre mitigation in

3801
02:24:56,799 --> 02:24:58,318
the middle of something that i didn't

3802
02:24:57,840 --> 02:25:01,600
ask for

3803
02:24:58,318 --> 02:25:05,279
so either way it's dumb right

3804
02:25:01,600 --> 02:25:06,960
um so anyway

3805
02:25:05,280 --> 02:25:08,720
so here's the godbolt link if you want

3806
02:25:06,959 --> 02:25:09,919
to jump to it yourself uh and play

3807
02:25:08,719 --> 02:25:11,760
around which if you're trying to learn

3808
02:25:09,920 --> 02:25:12,799
assembly language i highly recommend you

3809
02:25:11,760 --> 02:25:15,920
do

3810
02:25:12,799 --> 02:25:19,358
um and uh yeah

3811
02:25:15,920 --> 02:25:22,239
uh i guess all i can say is it surprised

3812
02:25:19,359 --> 02:25:23,840
even me how bad this clan code was

3813
02:25:22,239 --> 02:25:25,680
i really don't like that i guess i'll be

3814
02:25:23,840 --> 02:25:26,960
more aware nowadays to double check

3815
02:25:25,680 --> 02:25:28,720
anytime i comply with claim that it's

3816
02:25:26,959 --> 02:25:31,839
not doing something really heinous

3817
02:25:28,719 --> 02:25:38,000
uh to mems set loops basically uh so

3818
02:25:31,840 --> 02:25:39,760
now i know all right let's close it down

3819
02:25:38,000 --> 02:25:42,000
thank you everyone for joining me for

3820
02:25:39,760 --> 02:25:43,120
the first episode back of handmade hero

3821
02:25:42,000 --> 02:25:46,478
it's been a while

3822
02:25:43,120 --> 02:25:47,920
thanks for coming back and joining us uh

3823
02:25:46,478 --> 02:25:49,920
if you want to follow along this series

3824
02:25:47,920 --> 02:25:51,520
at home you can always pre-order the

3825
02:25:49,920 --> 02:25:52,719
game at handmadehero.org

3826
02:25:51,520 --> 02:25:55,120
we're going to start working on that

3827
02:25:52,719 --> 02:25:56,559
soon maybe next week but i want to start

3828
02:25:55,120 --> 02:25:57,280
off so with the chat and i did want to

3829
02:25:56,559 --> 02:25:59,760
address that

3830
02:25:57,280 --> 02:26:01,760
twitter uh thread because i appreciated

3831
02:25:59,760 --> 02:26:03,359
jesse taking the time

3832
02:26:01,760 --> 02:26:04,840
to actually do some testing and some

3833
02:26:03,359 --> 02:26:08,159
timing

3834
02:26:04,840 --> 02:26:08,960
so uh that's it for this week i'm gonna

3835
02:26:08,159 --> 02:26:10,719
do limited

3836
02:26:08,959 --> 02:26:12,159
uh since i'm working on star code galaxy

3837
02:26:10,719 --> 02:26:14,879
right now um

3838
02:26:12,159 --> 02:26:16,079
which is the upcoming code class i'm i'm

3839
02:26:14,879 --> 02:26:17,599
actually working pretty hard to try and

3840
02:26:16,079 --> 02:26:20,239
get it finalized

3841
02:26:17,600 --> 02:26:21,680
um since i'm working on this right now

3842
02:26:20,239 --> 02:26:23,280
uh there's gonna be limited handmade

3843
02:26:21,680 --> 02:26:25,680
heroes only once a weekend

3844
02:26:23,280 --> 02:26:26,880
just just to save my voice so i can have

3845
02:26:25,680 --> 02:26:30,079
a day off

3846
02:26:26,879 --> 02:26:32,559
um and not get too much laryngitis

3847
02:26:30,079 --> 02:26:34,159
um so it's limited schedule but i will

3848
02:26:32,559 --> 02:26:34,799
be here once a week just to say hi to

3849
02:26:34,159 --> 02:26:37,840
y'all

3850
02:26:34,799 --> 02:26:39,438
and to also um make a little bit of

3851
02:26:37,840 --> 02:26:42,398
progress on the game while we wait

3852
02:26:39,439 --> 02:26:43,760
and then after our starco galaxy is out

3853
02:26:42,398 --> 02:26:47,680
we'll start resuming

3854
02:26:43,760 --> 02:26:49,520
regularly scheduled programming uh so

3855
02:26:47,680 --> 02:26:51,040
thanks for joining i'll see you back

3856
02:26:49,520 --> 02:26:52,239
here next week until then have fun

3857
02:26:51,040 --> 02:26:54,560
program everyone

3858
02:26:52,239 --> 02:27:03,199
and i'll see you on the internet take it

3859
02:26:54,559 --> 02:27:03,199
easy everybody

