1
00:00:00,530 --> 00:00:04,799
hello everyone and welcome to handmade

2
00:00:02,879 --> 00:00:07,919
here sure we code a complete game live

3
00:00:04,799 --> 00:00:09,690
on stream we stopped yesterday just at

4
00:00:07,918 --> 00:00:14,308
the point where we need to do debugging

5
00:00:09,689 --> 00:00:16,289
of our import code and we also need one

6
00:00:14,308 --> 00:00:21,299
other thing which is we wanted to have a

7
00:00:16,289 --> 00:00:23,490
way of taking checksums of our input

8
00:00:21,300 --> 00:00:25,080
files so we would know we could have a

9
00:00:23,489 --> 00:00:28,709
little bit more than just the date to go

10
00:00:25,079 --> 00:00:29,669
on now here's a problem I don't have a

11
00:00:28,710 --> 00:00:33,149
strong opinion on what we should

12
00:00:29,670 --> 00:00:35,489
implement for a checksum anything will

13
00:00:33,149 --> 00:00:39,620
do but some things are significantly

14
00:00:35,488 --> 00:00:39,619
better than others right like you know

15
00:00:42,049 --> 00:00:45,779
the better of the hash we use the more

16
00:00:44,429 --> 00:00:47,659
resilient it is to collisions the less

17
00:00:45,780 --> 00:00:50,579
likely it is to do something spurious

18
00:00:47,659 --> 00:00:52,939
and who knows what that would actually

19
00:00:50,579 --> 00:00:55,500
end up looking like in practice

20
00:00:52,939 --> 00:00:56,968
certainly it's not that hard if

21
00:00:55,500 --> 00:00:58,890
something is refusing to import because

22
00:00:56,969 --> 00:01:00,090
it thinks she's already changed we can

23
00:00:58,890 --> 00:01:02,189
always just have a button that's like

24
00:01:00,090 --> 00:01:06,478
force it to him for it this file and

25
00:01:02,189 --> 00:01:09,599
it'll reemployed the file so the the

26
00:01:06,478 --> 00:01:13,219
cost of a hash collision in our world is

27
00:01:09,599 --> 00:01:16,349
pretty low and so it's not really very

28
00:01:13,219 --> 00:01:18,329
important for us to get this right there

29
00:01:16,349 --> 00:01:21,030
are cases where it's way more important

30
00:01:18,329 --> 00:01:24,450
to get it right and it costs a lot if

31
00:01:21,030 --> 00:01:27,030
you get it wrong code signing and those

32
00:01:24,450 --> 00:01:28,469
sorts of things would be places where

33
00:01:27,030 --> 00:01:30,450
you really don't want to have collisions

34
00:01:28,469 --> 00:01:31,798
be easy to generate because attackers

35
00:01:30,450 --> 00:01:34,228
could smooth things we don't have

36
00:01:31,799 --> 00:01:37,290
attackers in this case anyone can import

37
00:01:34,228 --> 00:01:39,719
a file if they want to and this is not

38
00:01:37,290 --> 00:01:41,700
true this hash is not being used to

39
00:01:39,719 --> 00:01:44,280
prevent anything it's actually just

40
00:01:41,700 --> 00:01:45,990
being used as a minor speed-up to

41
00:01:44,280 --> 00:01:47,939
prevent files from being reloaded if

42
00:01:45,989 --> 00:01:53,368
they don't have to so it's a very low

43
00:01:47,938 --> 00:01:55,679
weight a very low risk endeavor for us

44
00:01:53,368 --> 00:01:58,228
in any hash will really do the question

45
00:01:55,680 --> 00:01:59,790
is which hash should we do and I don't

46
00:01:58,228 --> 00:02:05,118
know so let's take a spin around the

47
00:01:59,790 --> 00:02:12,259
internet and see if I say let's get a

48
00:02:05,118 --> 00:02:12,258
fast good file hash what will it say

49
00:02:13,360 --> 00:02:21,430
when a good analysis extremely fashion

50
00:02:18,460 --> 00:02:24,640
non credere non cryptographic hash well

51
00:02:21,430 --> 00:02:28,689
that sounds pretty good but how is it in

52
00:02:24,639 --> 00:02:37,199
terms of resiliency you know I don't

53
00:02:28,689 --> 00:02:37,199
know let's see let's see here

54
00:02:38,699 --> 00:02:43,919
well it's got a quality metric right

55
00:02:45,539 --> 00:02:52,000
who knows

56
00:02:48,490 --> 00:02:53,560
that seems nice it's fast all right

57
00:02:52,000 --> 00:02:58,349
let's take a look at what the code looks

58
00:02:53,560 --> 00:02:58,349
like here's a C++ version

59
00:03:06,030 --> 00:03:15,188
it's really just a document that says

60
00:03:08,378 --> 00:03:18,128
what the algorithm is by the way so it

61
00:03:15,188 --> 00:03:20,139
looks like it's one that uses the some

62
00:03:18,128 --> 00:03:20,560
tables which isn't necessarily a bad

63
00:03:20,139 --> 00:03:22,449
thing

64
00:03:20,560 --> 00:03:26,949
a lot of CRC's use tables like for

65
00:03:22,449 --> 00:03:32,709
example the original crc32 stuff they

66
00:03:26,949 --> 00:03:33,759
use those tables not sure if they have

67
00:03:32,709 --> 00:03:37,689
them in here somewhere

68
00:03:33,759 --> 00:03:40,469
a lot of the original CRC stuff CRC

69
00:03:37,689 --> 00:03:40,469
stuff used tables

70
00:03:47,818 --> 00:03:51,468
and it looks like they do a lot of

71
00:03:55,908 --> 00:04:03,449
rotations and rounding your what wit

72
00:04:00,259 --> 00:04:06,949
this must be round like a cryptographic

73
00:04:03,449 --> 00:04:10,768
round not actually rounding right

74
00:04:06,949 --> 00:04:15,750
what is this round like they're not in

75
00:04:10,769 --> 00:04:18,798
float right so round and must be there

76
00:04:15,750 --> 00:04:20,699
around like their cryptographic round I

77
00:04:18,798 --> 00:04:27,049
don't know where that actually is

78
00:04:20,699 --> 00:04:27,050
defined here it is

79
00:04:27,418 --> 00:04:33,839
yeah so it's basically just a rotation

80
00:04:31,189 --> 00:04:35,519
and then it picks the prime so it is a

81
00:04:33,839 --> 00:04:42,418
cryptographic round it does a particular

82
00:04:35,519 --> 00:04:45,319
rotation and then does pick that one of

83
00:04:42,418 --> 00:04:45,319
the primes that it wants

84
00:04:49,290 --> 00:04:54,010
is there so is there a is there just a

85
00:04:52,449 --> 00:04:55,539
description of the algorithm somewhere

86
00:04:54,009 --> 00:04:58,529
do we get that or is that not on the

87
00:04:55,540 --> 00:04:58,530
table for some reason

88
00:05:07,180 --> 00:05:14,728
I don't know why there isn't just a

89
00:05:10,209 --> 00:05:18,538
thing that's out here we go well no

90
00:05:14,728 --> 00:05:18,538
thought I was gonna find an article

91
00:05:20,850 --> 00:05:25,300
let's take out murmur as well because

92
00:05:23,589 --> 00:05:29,079
murmur I've used before and I like

93
00:05:25,300 --> 00:05:31,509
better it's pretty simple it's a pretty

94
00:05:29,079 --> 00:05:36,209
basic hash right

95
00:05:31,509 --> 00:05:38,949
very very simple doesn't use a table and

96
00:05:36,209 --> 00:05:40,719
looks like the quality at least by

97
00:05:38,949 --> 00:05:42,960
whatever these benchmarks however it's

98
00:05:40,720 --> 00:05:45,550
measuring it which I don't really know

99
00:05:42,959 --> 00:05:47,439
how they're actually measuring these in

100
00:05:45,550 --> 00:05:49,060
terms of hash qualities

101
00:05:47,439 --> 00:05:51,129
it looks like the quality would be

102
00:05:49,060 --> 00:05:53,769
similar we don't care too much about the

103
00:05:51,129 --> 00:05:56,560
peak speed there and this the simplicity

104
00:05:53,769 --> 00:05:58,839
would be nice now like I said xx hash

105
00:05:56,560 --> 00:06:01,478
might have a simpler version it would be

106
00:05:58,839 --> 00:06:03,399
I wish they had a simple thing here that

107
00:06:01,478 --> 00:06:05,379
explained the algorithm right cuz here's

108
00:06:03,399 --> 00:06:07,779
like that's here's the example it's like

109
00:06:05,379 --> 00:06:10,750
here's a very simple explanation of the

110
00:06:07,779 --> 00:06:14,049
algorithm so you know I don't

111
00:06:10,750 --> 00:06:15,310
necessarily want something when I'm just

112
00:06:14,050 --> 00:06:16,930
initially looking and trying to

113
00:06:15,310 --> 00:06:20,288
understand what something's doing I

114
00:06:16,930 --> 00:06:22,598
don't want to look at highly optimized

115
00:06:20,288 --> 00:06:23,829
code that who knows what it's got in

116
00:06:22,598 --> 00:06:25,060
there and that's you know what I mean

117
00:06:23,829 --> 00:06:26,158
like I don't want to look at all that

118
00:06:25,060 --> 00:06:28,839
stuff I just want a simple explanation

119
00:06:26,158 --> 00:06:33,459
what's it doing so I can see you know

120
00:06:28,839 --> 00:06:35,560
basically what's going on you can see

121
00:06:33,459 --> 00:06:40,269
here that this is it's basically got

122
00:06:35,560 --> 00:06:43,750
like a while loop that does 32 bits at a

123
00:06:40,269 --> 00:06:45,758
time and you know we could just make it

124
00:06:43,750 --> 00:06:48,639
so that it's always 32 bits at a time if

125
00:06:45,759 --> 00:06:50,770
we wanted to we could just enforce that

126
00:06:48,639 --> 00:06:53,139
so we could literally make the murmur

127
00:06:50,769 --> 00:07:00,008
hash be like that big and then it just

128
00:06:53,139 --> 00:07:02,560
does that final bit there right so this

129
00:07:00,009 --> 00:07:03,819
is a really straightforward hash which I

130
00:07:02,560 --> 00:07:04,899
think makes it may be a better choice

131
00:07:03,819 --> 00:07:06,158
because I don't want something

132
00:07:04,899 --> 00:07:09,638
complicated I just want something

133
00:07:06,158 --> 00:07:12,490
reasonable it would be nice if we had a

134
00:07:09,639 --> 00:07:15,189
64 bit murmur hash because we can store

135
00:07:12,490 --> 00:07:18,579
64 bits and work with 64 bits on a 64

136
00:07:15,189 --> 00:07:22,930
bit machine really easily and so

137
00:07:18,579 --> 00:07:34,620
I kind of would have preferred that let

138
00:07:22,930 --> 00:07:38,468
me see if there's a 64-bit murmur - yeah

139
00:07:34,620 --> 00:07:45,098
so this one wasn't 64 right yeah so this

140
00:07:38,468 --> 00:07:50,860
was a 32 only so basically this hash

141
00:07:45,098 --> 00:07:52,779
here is a is a 64-bit version of murmur

142
00:07:50,860 --> 00:07:58,319
that seems maybe like a little bit

143
00:07:52,779 --> 00:07:58,318
better going here

144
00:08:06,560 --> 00:08:15,839
so here you can see again very very

145
00:08:12,990 --> 00:08:19,379
simple right

146
00:08:15,839 --> 00:08:24,209
I like the looks of this one a lot

147
00:08:19,379 --> 00:08:27,000
better they've got a lot of stuff in

148
00:08:24,209 --> 00:08:29,189
here right you can see them again much

149
00:08:27,000 --> 00:08:30,540
like the XX hash stuff what are the

150
00:08:29,189 --> 00:08:31,620
problems with these is they always like

151
00:08:30,540 --> 00:08:34,680
expand them out because they're trying

152
00:08:31,620 --> 00:08:37,019
to be performant you know and so if I

153
00:08:34,679 --> 00:08:38,519
just want to look at something simple

154
00:08:37,019 --> 00:08:40,259
sometimes you end up in a bad situation

155
00:08:38,519 --> 00:08:41,929
where you've got to wade through a bunch

156
00:08:40,259 --> 00:08:46,889
of that code I don't really care about

157
00:08:41,929 --> 00:08:49,589
but it's you know it's to be expected

158
00:08:46,889 --> 00:08:55,110
either way that seems pretty good to me

159
00:08:49,590 --> 00:08:58,410
let me go forward there I didn't know it

160
00:08:55,110 --> 00:08:59,840
was no space in between those two so I

161
00:08:58,409 --> 00:09:02,669
feel like that's pretty reasonable

162
00:08:59,840 --> 00:09:07,230
murmur hash three might be what we want

163
00:09:02,669 --> 00:09:08,819
to do and here's the like you know the

164
00:09:07,230 --> 00:09:12,330
thing that I wanted which was the

165
00:09:08,820 --> 00:09:15,780
description so basically it says here's

166
00:09:12,330 --> 00:09:19,259
a thing like a mixer it's pretty basic

167
00:09:15,779 --> 00:09:23,279
right I multiply by a constant I rotate

168
00:09:19,259 --> 00:09:25,799
I multiply by another constant I take

169
00:09:23,279 --> 00:09:28,860
the XOR right so this this thing that

170
00:09:25,799 --> 00:09:32,609
I've this thing that I've prepared here

171
00:09:28,860 --> 00:09:36,180
which is K this is not the same as H so

172
00:09:32,610 --> 00:09:38,639
I've got two values I'm tracking so I

173
00:09:36,179 --> 00:09:42,659
update my K with a multiplier rotation

174
00:09:38,639 --> 00:09:44,370
to multiply I XOR my hash value I

175
00:09:42,659 --> 00:09:49,399
assumed H as a hash value I don't really

176
00:09:44,370 --> 00:09:51,600
know yet i XOR my H value with my K

177
00:09:49,399 --> 00:09:55,259
which is the thing that is updating I

178
00:09:51,600 --> 00:10:01,580
rotate that and then I do a multiply and

179
00:09:55,259 --> 00:10:05,039
an ADD here with constants right and so

180
00:10:01,580 --> 00:10:11,310
it looks like K is what I'm reading in H

181
00:10:05,039 --> 00:10:13,289
is the hash value right pretty if that's

182
00:10:11,309 --> 00:10:15,759
really how simple it is right I like I

183
00:10:13,289 --> 00:10:18,458
just like how basic that is

184
00:10:15,759 --> 00:10:20,110
and then the finalizar this is if I want

185
00:10:18,458 --> 00:10:25,359
a 32-bit value this is if I want a

186
00:10:20,110 --> 00:10:27,730
64-bit value right I don't know what

187
00:10:25,360 --> 00:10:29,050
these values are supposed to be I don't

188
00:10:27,730 --> 00:10:32,379
know if these are supposed to be 64-bit

189
00:10:29,049 --> 00:10:35,189
or not let me see here yeah so those are

190
00:10:32,379 --> 00:10:37,838
six so this is assuming these are 64-bit

191
00:10:35,190 --> 00:10:38,889
so here's the 64-bit finalizar because

192
00:10:37,839 --> 00:10:42,220
you couldn't shift something down

193
00:10:38,889 --> 00:10:44,649
thirty-three bits if it wasn't right it

194
00:10:42,220 --> 00:10:47,860
would just be zero so these are 64-bit

195
00:10:44,649 --> 00:10:51,000
values or at least H is I don't know if

196
00:10:47,860 --> 00:10:54,730
K is expected to also be 64 bits or not

197
00:10:51,000 --> 00:11:00,958
so I think that's pretty easy for us to

198
00:10:54,730 --> 00:11:04,449
do and I'm just gonna go ahead and do it

199
00:11:00,958 --> 00:11:05,409
yeah that seems good and we could if we

200
00:11:04,448 --> 00:11:09,039
want to make it easier on ourselves

201
00:11:05,409 --> 00:11:10,448
again just like Pat it out but I guess

202
00:11:09,039 --> 00:11:12,399
even that's something we'd probably be

203
00:11:10,448 --> 00:11:13,528
pretty privileged to handle this the end

204
00:11:12,399 --> 00:11:16,570
of it

205
00:11:13,528 --> 00:11:17,919
pretty pretty straightforward to handle

206
00:11:16,570 --> 00:11:21,430
the end of it special as well so let's

207
00:11:17,919 --> 00:11:23,379
just take a look and again the reason

208
00:11:21,429 --> 00:11:25,299
that I'm just going by stuff on the web

209
00:11:23,379 --> 00:11:28,049
for this is that I just don't have any

210
00:11:25,299 --> 00:11:30,609
cryptographic skills whatsoever so I

211
00:11:28,049 --> 00:11:33,338
don't really have the ability to

212
00:11:30,610 --> 00:11:37,360
evaluate cryptographic things I can't

213
00:11:33,339 --> 00:11:38,470
like look at two hash functions and tell

214
00:11:37,360 --> 00:11:40,810
you which one I think will be more

215
00:11:38,470 --> 00:11:42,730
collision resistant I just can't so I

216
00:11:40,809 --> 00:11:45,369
have to go buy other people's public

217
00:11:42,730 --> 00:11:47,889
testing and attestation that's the best

218
00:11:45,370 --> 00:11:49,539
I can do if I was doing something that

219
00:11:47,889 --> 00:11:51,490
was really cryptographically important

220
00:11:49,539 --> 00:11:52,870
which is not something I ever do I would

221
00:11:51,490 --> 00:11:55,209
probably have to take the time to learn

222
00:11:52,870 --> 00:11:56,379
a lot more in numerical analysis so that

223
00:11:55,208 --> 00:11:58,689
I could start to have an opinion about

224
00:11:56,379 --> 00:12:00,789
things like that I just don't have that

225
00:11:58,690 --> 00:12:03,040
knowledge at all so I have to trust

226
00:12:00,789 --> 00:12:06,189
other experts who say that things are

227
00:12:03,039 --> 00:12:08,230
stronger or weaker and off you go

228
00:12:06,190 --> 00:12:11,800
murmur hash is supposed to be a fast

229
00:12:08,230 --> 00:12:14,350
hash that's just reasonable for files it

230
00:12:11,799 --> 00:12:18,458
is not a particularly strong hash by

231
00:12:14,350 --> 00:12:21,159
comparison to like a cryptogram a real

232
00:12:18,458 --> 00:12:23,739
cryptographic hash like or one this

233
00:12:21,159 --> 00:12:28,269
'never cryptographic views like catch

234
00:12:23,740 --> 00:12:29,139
expunged or the or even like a sha not

235
00:12:28,269 --> 00:12:30,730
the SI

236
00:12:29,139 --> 00:12:32,499
jae-won before I destitute - or whatever

237
00:12:30,730 --> 00:12:33,730
I don't think the murmur hash is meant

238
00:12:32,499 --> 00:12:35,949
to compete with those it's supposed to

239
00:12:33,730 --> 00:12:37,480
be more of a high-speed hash for doing

240
00:12:35,948 --> 00:12:38,889
things like this just checking files

241
00:12:37,480 --> 00:12:41,350
where you assume that there's no

242
00:12:38,889 --> 00:12:42,850
attacker who's trying to thwart you so

243
00:12:41,350 --> 00:12:44,019
I'm pretty sure murmur hash is not

244
00:12:42,850 --> 00:12:47,918
something you would ever use in a

245
00:12:44,019 --> 00:12:49,688
cryptographic setting a cryptography

246
00:12:47,918 --> 00:12:51,308
person is welcome to correct me if there

247
00:12:49,688 --> 00:12:53,618
any watching but I'm pretty sure that

248
00:12:51,308 --> 00:12:55,958
that's it's not that kind of hash but

249
00:12:53,619 --> 00:12:57,160
it's a fine hash for file things to the

250
00:12:55,958 --> 00:13:00,039
best of my knowledge and we don't want

251
00:12:57,159 --> 00:13:02,048
to waste a lot of time doing hashing so

252
00:13:00,039 --> 00:13:05,488
that's why I want to go with this so if

253
00:13:02,048 --> 00:13:05,489
I go into the shared code here

254
00:13:19,678 --> 00:13:26,828
so this is murmur hash three in

255
00:13:22,600 --> 00:13:29,079
particular that we're doing or and I say

256
00:13:26,828 --> 00:13:31,418
based on here because you know I'm not

257
00:13:29,078 --> 00:13:33,938
really gonna test it thoroughly or make

258
00:13:31,418 --> 00:13:36,639
sure that I even comply with what they

259
00:13:33,938 --> 00:13:38,948
were doing and so I don't want to say

260
00:13:36,639 --> 00:13:41,110
this is a murmur hash because it might

261
00:13:38,948 --> 00:13:44,019
not quite be a murmur hash it might be

262
00:13:41,110 --> 00:13:48,039
our own secret nan thing that isn't

263
00:13:44,019 --> 00:13:50,499
really a murmur hash all right so what I

264
00:13:48,039 --> 00:13:56,409
want to do here is I want to make a hash

265
00:13:50,499 --> 00:13:59,168
update like we had before and that's

266
00:13:56,409 --> 00:14:03,789
just a little function that's gonna do

267
00:13:59,168 --> 00:14:08,139
this right so it's going to be a K and

268
00:14:03,789 --> 00:14:11,438
an H right and it's gonna it's gonna

269
00:14:08,139 --> 00:14:15,579
return the H value to us because K

270
00:14:11,438 --> 00:14:18,269
doesn't get stored K is read in so what

271
00:14:15,578 --> 00:14:22,238
I want to do here is I want to say okay

272
00:14:18,269 --> 00:14:24,028
Kate x equals c1 we got to know what ooh

273
00:14:22,239 --> 00:14:25,629
that's not good

274
00:14:24,028 --> 00:14:27,999
we're gonna have to find out what that

275
00:14:25,629 --> 00:14:31,808
constant is oh but that's fine then we

276
00:14:27,999 --> 00:14:33,788
want to do rotate left and we have if I

277
00:14:31,808 --> 00:14:37,238
remember correct correct Leah rotate

278
00:14:33,788 --> 00:14:41,889
left here right the problem is we don't

279
00:14:37,239 --> 00:14:42,879
have a rotate left for 64-bit and so

280
00:14:41,889 --> 00:14:45,818
we're gonna have to look

281
00:14:42,879 --> 00:14:57,909
I don't actually know if there is one I

282
00:14:45,818 --> 00:15:01,028
assume Intel put one in but even if they

283
00:14:57,909 --> 00:15:07,769
didn't you can see here how we

284
00:15:01,028 --> 00:15:10,600
implemented the rotate left in terms of

285
00:15:07,769 --> 00:15:15,190
regular operations right ones that

286
00:15:10,600 --> 00:15:19,209
didn't require a Rowell so I can do one

287
00:15:15,190 --> 00:15:25,329
of these rotate left's with 64-bit if I

288
00:15:19,208 --> 00:15:29,500
wanted to by just doing that right so

289
00:15:25,328 --> 00:15:32,258
here where we do the the knock out of

290
00:15:29,500 --> 00:15:36,309
the value we would just have to do like

291
00:15:32,259 --> 00:15:38,980
okay I you know it's it's not an 31

292
00:15:36,309 --> 00:15:41,619
anymore because this is 31 was there

293
00:15:38,980 --> 00:15:44,230
because it's 32 minus 1 right so we

294
00:15:41,620 --> 00:15:47,649
would want to do and 63 here right to

295
00:15:44,230 --> 00:15:51,810
make sure that we are clipping off

296
00:15:47,649 --> 00:15:56,068
whatever the sign is if there is a sign

297
00:15:51,809 --> 00:15:59,528
so what we want to do here is make sure

298
00:15:56,068 --> 00:16:01,958
we what we want to do here is make sure

299
00:15:59,528 --> 00:16:04,299
that we can do a 64-bit one I don't

300
00:16:01,958 --> 00:16:08,559
actually know if we can there may be a

301
00:16:04,299 --> 00:16:10,929
rot el 64 of some kind I'm not sure so

302
00:16:08,559 --> 00:16:13,929
we'll have to check that out if there

303
00:16:10,929 --> 00:16:16,659
isn't then what we can do is again just

304
00:16:13,929 --> 00:16:19,028
do probably the same thing here and it

305
00:16:16,659 --> 00:16:21,159
should just work right because we're all

306
00:16:19,028 --> 00:16:22,568
we're doing is doing two shifts to put

307
00:16:21,159 --> 00:16:24,250
the things in the right position then or

308
00:16:22,568 --> 00:16:26,799
them together that's all that the

309
00:16:24,250 --> 00:16:28,078
rotation would be doing anyway so it

310
00:16:26,799 --> 00:16:32,919
should be fine

311
00:16:28,078 --> 00:16:36,179
now I think we should be able to use our

312
00:16:32,919 --> 00:16:36,179
search oops

313
00:16:36,899 --> 00:16:43,360
hopefully to find some of these things

314
00:16:40,600 --> 00:16:45,850
if they exist so that we can just call

315
00:16:43,360 --> 00:16:48,339
the compiler intrinsic if there is one

316
00:16:45,850 --> 00:16:50,819
let's find out yeah remember if there

317
00:16:48,339 --> 00:16:50,819
isn't

318
00:16:52,250 --> 00:16:58,940
so we know oops no we know it's there

319
00:16:56,809 --> 00:17:02,689
should be an underscore rod L so let's

320
00:16:58,940 --> 00:17:06,078
go ahead and try to get that yes you can

321
00:17:02,690 --> 00:17:12,558
see it here so let's try and find like

322
00:17:06,078 --> 00:17:14,688
is there rod L 64 yep so you can see

323
00:17:12,558 --> 00:17:18,558
here there's a rod L 64 so that means

324
00:17:14,689 --> 00:17:21,048
that I think in theory anyway we should

325
00:17:18,558 --> 00:17:23,869
be able to just stick a 64 on here and

326
00:17:21,048 --> 00:17:26,808
have it I don't actually know if that's

327
00:17:23,869 --> 00:17:31,099
true but hopefully it is so it looks

328
00:17:26,808 --> 00:17:32,808
like it's s 64 is what it's actually I'm

329
00:17:31,099 --> 00:17:34,369
sorry int is what it's actually wanting

330
00:17:32,808 --> 00:17:39,859
for the amount and now I think about it

331
00:17:34,369 --> 00:17:42,709
that's you know what that's actually we

332
00:17:39,859 --> 00:17:46,039
don't need a 64 bit shift value right

333
00:17:42,710 --> 00:17:48,230
you can only shift by up to 64 bits

334
00:17:46,039 --> 00:17:50,899
anyway so this could be an 8-bit integer

335
00:17:48,230 --> 00:17:52,490
for all we care about right it's just

336
00:17:50,900 --> 00:17:54,009
not relevant so I don't know why I did

337
00:17:52,490 --> 00:17:57,980
that I was just kind of not thinking

338
00:17:54,009 --> 00:18:00,019
particularly hard about it okay so if we

339
00:17:57,980 --> 00:18:01,789
want to do a rotate left as we were

340
00:18:00,019 --> 00:18:04,730
instructed to do we can do that in 64

341
00:18:01,789 --> 00:18:08,450
bits it's no big deal so we want to

342
00:18:04,730 --> 00:18:10,039
rotate by the r1 constant which again

343
00:18:08,450 --> 00:18:11,269
we're gonna have to find out what they

344
00:18:10,039 --> 00:18:15,589
actually want because these constants

345
00:18:11,269 --> 00:18:18,319
are important so we've got a c1 an r1 in

346
00:18:15,589 --> 00:18:23,928
a c2 that's gonna affect our K then we

347
00:18:18,319 --> 00:18:27,139
want to do the XOR here with whatever we

348
00:18:23,929 --> 00:18:29,870
mixed up we are now going to do the XOR

349
00:18:27,140 --> 00:18:32,659
that's the end of our use of K now we're

350
00:18:29,869 --> 00:18:34,219
going to do further operations on the

351
00:18:32,659 --> 00:18:36,740
hash value itself so this is like the

352
00:18:34,220 --> 00:18:40,940
hash update step again we're rotating

353
00:18:36,740 --> 00:18:44,509
left we're rotating the hash left and

354
00:18:40,940 --> 00:18:47,840
we're using the same constant for the

355
00:18:44,509 --> 00:18:50,900
rotation as we did with our K we then do

356
00:18:47,839 --> 00:18:54,230
a multiply step so there's an m1 plus an

357
00:18:50,900 --> 00:18:58,400
n1 there and then finally we return the

358
00:18:54,230 --> 00:19:02,140
new H value and so this is sort of an in

359
00:18:58,400 --> 00:19:04,710
fact I can probably should put this here

360
00:19:02,140 --> 00:19:06,720
because it's

361
00:19:04,710 --> 00:19:09,029
really this is the part that we're using

362
00:19:06,720 --> 00:19:10,230
this part is just gonna read this this

363
00:19:09,029 --> 00:19:13,369
part has nothing to do with the murder

364
00:19:10,230 --> 00:19:15,900
hash this is just the part that's gonna

365
00:19:13,369 --> 00:19:19,409
iterate over the buffer calling hash

366
00:19:15,900 --> 00:19:22,170
update right so then we have the the

367
00:19:19,410 --> 00:19:24,509
finalization step and the finalization

368
00:19:22,170 --> 00:19:27,060
step is going to be the 64-bit one here

369
00:19:24,509 --> 00:19:30,750
now I don't know why they chose to

370
00:19:27,059 --> 00:19:33,539
include the constants here and not here

371
00:19:30,750 --> 00:19:35,400
I'm not quite sure about that and so

372
00:19:33,539 --> 00:19:42,960
we'll have to read a little bit further

373
00:19:35,400 --> 00:19:52,140
on and find out what I don't really know

374
00:19:42,960 --> 00:19:54,329
what that yeah I don't know why they

375
00:19:52,140 --> 00:19:59,310
chose to have some of the constants and

376
00:19:54,329 --> 00:20:01,439
not others so you know it's probably

377
00:19:59,309 --> 00:20:02,909
because they just wanted to write this

378
00:20:01,440 --> 00:20:05,610
once and they didn't want to write it

379
00:20:02,910 --> 00:20:07,170
each time for 32-bit 64-bit whatever bit

380
00:20:05,609 --> 00:20:08,369
right

381
00:20:07,170 --> 00:20:09,539
that's probably why because they're

382
00:20:08,369 --> 00:20:10,889
gonna use different constants for the

383
00:20:09,539 --> 00:20:14,549
two so that's probably just wanted to

384
00:20:10,890 --> 00:20:15,840
condense I'm guessing but either way

385
00:20:14,549 --> 00:20:18,299
this is what we wanted to hear it's

386
00:20:15,839 --> 00:20:22,939
basically just like two constants and a

387
00:20:18,299 --> 00:20:27,109
bunch of XOR shifts which is fine

388
00:20:22,940 --> 00:20:30,990
so murmur hash oops

389
00:20:27,109 --> 00:20:33,240
murmur hash finalized so this is just

390
00:20:30,990 --> 00:20:37,680
gonna take the hash value it doesn't use

391
00:20:33,240 --> 00:20:39,779
any new information in fact I might put

392
00:20:37,680 --> 00:20:41,789
the H at the front so it's base like you

393
00:20:39,779 --> 00:20:43,980
always pass the hash value and the K is

394
00:20:41,789 --> 00:20:47,700
like the new thing that you're feeding

395
00:20:43,980 --> 00:20:51,410
in right so now if I want to generate

396
00:20:47,700 --> 00:20:54,360
the finalization I just have to do my

397
00:20:51,410 --> 00:21:00,060
this is an XOR shift and I'm doing the

398
00:20:54,359 --> 00:21:01,559
same exercise right so we shift down

399
00:21:00,059 --> 00:21:03,690
through three I don't remember if this

400
00:21:01,559 --> 00:21:06,000
has to be you 64 but I'm gonna make sure

401
00:21:03,690 --> 00:21:10,950
it is just to make sure there's no

402
00:21:06,000 --> 00:21:13,259
weirdness there and then in between each

403
00:21:10,950 --> 00:21:14,970
of these we need to multiply by the

404
00:21:13,259 --> 00:21:18,509
constants so I'm gonna put those in here

405
00:21:14,970 --> 00:21:20,669
and again those also I think have to

406
00:21:18,509 --> 00:21:22,349
potentially I don't know how smart the

407
00:21:20,669 --> 00:21:25,440
compiler is in terms of understanding

408
00:21:22,349 --> 00:21:30,949
that these are supposed to be 64 bits

409
00:21:25,440 --> 00:21:38,960
you could also do that I believe I think

410
00:21:30,950 --> 00:21:42,058
not for sure but I believe that that

411
00:21:38,960 --> 00:21:44,700
tells it hey look make it a 64 bit on

412
00:21:42,058 --> 00:21:45,839
sign please and you can just stick that

413
00:21:44,700 --> 00:21:48,058
I mean to anything when you actually

414
00:21:45,839 --> 00:21:50,399
care there so I just wanted to make sure

415
00:21:48,058 --> 00:21:52,379
that was operating in 64-bit and then we

416
00:21:50,400 --> 00:21:55,350
will turn it so that gives us what we

417
00:21:52,380 --> 00:21:57,390
need to do our murmur hash what I don't

418
00:21:55,349 --> 00:22:00,298
know is where to get these classes from

419
00:21:57,390 --> 00:22:03,030
because now we have to know what they

420
00:22:00,298 --> 00:22:06,480
are specific to the to the particular

421
00:22:03,029 --> 00:22:08,129
routine and so to find that I'm gonna

422
00:22:06,480 --> 00:22:09,690
just go look at the actual code because

423
00:22:08,130 --> 00:22:12,270
obviously if they improves that's the

424
00:22:09,690 --> 00:22:14,100
issues if they implemented it then

425
00:22:12,269 --> 00:22:17,308
they're gonna have to put the costs in

426
00:22:14,099 --> 00:22:19,259
somewhere so let's take a look so here's

427
00:22:17,308 --> 00:22:21,710
the murmur hash stuff I assume I can

428
00:22:19,259 --> 00:22:23,548
just go in here to murmur hash 3 dot H

429
00:22:21,710 --> 00:22:27,900
look and see what we've got

430
00:22:23,548 --> 00:22:31,500
so we are trying to do a 64-bit one I

431
00:22:27,900 --> 00:22:41,720
don't see the 64-bit one though which

432
00:22:31,500 --> 00:22:41,720
isn't great hmm okay

433
00:22:44,829 --> 00:22:50,529
so it looks like they have their rod el

434
00:22:48,339 --> 00:22:52,799
64 right doing the same thing we were

435
00:22:50,529 --> 00:22:52,799
doing

436
00:23:05,669 --> 00:23:13,389
so this looks like the part that we just

437
00:23:11,259 --> 00:23:15,700
implemented so there's their finalizar

438
00:23:13,388 --> 00:23:17,109
for 64-bit we did not do the 32-bit

439
00:23:15,700 --> 00:23:23,409
finalizar because you don't care about

440
00:23:17,109 --> 00:23:25,028
it here's their 32-bit operation and you

441
00:23:23,409 --> 00:23:31,629
can see they've defined the constants

442
00:23:25,028 --> 00:23:32,919
for the 32-bit version so the thing that

443
00:23:31,628 --> 00:23:37,928
makes you nervous tears it looks like

444
00:23:32,919 --> 00:23:42,220
they don't really have a 64-bit only

445
00:23:37,929 --> 00:23:48,940
version it looks like they only do 128

446
00:23:42,220 --> 00:23:51,038
here right I don't know what to make of

447
00:23:48,940 --> 00:23:53,129
that I'm not sure why they did that

448
00:23:51,038 --> 00:23:57,158
because if you look they actually do to

449
00:23:53,128 --> 00:23:58,418
64-bit mixing steps at the end so

450
00:23:57,159 --> 00:24:00,940
they're they're actually mixing these

451
00:23:58,419 --> 00:24:08,649
together here I'm not sure what the deal

452
00:24:00,940 --> 00:24:09,340
is with that why they do to 128 that's

453
00:24:08,648 --> 00:24:11,739
really strange

454
00:24:09,339 --> 00:24:14,378
so you can see the way they're doing it

455
00:24:11,740 --> 00:24:16,298
you've got what they're doing is they're

456
00:24:14,378 --> 00:24:20,740
doing 128 bits at a time by maintaining

457
00:24:16,298 --> 00:24:22,960
to 64-bit hash values right now I'm

458
00:24:20,740 --> 00:24:25,509
assuming because these are 64-bit if we

459
00:24:22,960 --> 00:24:28,090
want to we can't just use the constants

460
00:24:25,509 --> 00:24:30,659
that for the 64-bit version it because

461
00:24:28,089 --> 00:24:33,158
they're telling us what they are right

462
00:24:30,659 --> 00:24:37,330
so rather than doing 2 and mixing them

463
00:24:33,159 --> 00:24:39,369
together I think we can just extract the

464
00:24:37,329 --> 00:24:41,408
costs we want out into it the way we're

465
00:24:39,368 --> 00:24:49,720
doing it I don't see a lot of reason not

466
00:24:41,409 --> 00:24:54,119
to here's the c1 value right so that's

467
00:24:49,720 --> 00:24:54,118
the one here's the c2 value

468
00:24:56,548 --> 00:25:02,239
so those are the two pieces we need here

469
00:25:19,319 --> 00:25:23,359
try to correct this comment a little bit

470
00:25:23,539 --> 00:25:30,180
so we're not gonna do to it once and mix

471
00:25:27,809 --> 00:25:31,559
them because we just I just I don't even

472
00:25:30,180 --> 00:25:33,150
know why that's the only other thing

473
00:25:31,559 --> 00:25:34,589
they did they must have a good reason I

474
00:25:33,150 --> 00:25:35,550
mean they wrote the hash in the first

475
00:25:34,589 --> 00:25:43,019
place they asked you know what they're

476
00:25:35,549 --> 00:25:46,349
doing but they just don't want to do

477
00:25:43,019 --> 00:25:52,950
that so we can see what we want to see

478
00:25:46,349 --> 00:25:56,459
here here's our here's the make this the

479
00:25:52,950 --> 00:26:00,480
step right and what's particularly odd

480
00:25:56,460 --> 00:26:03,630
about this step and I do not know why

481
00:26:00,480 --> 00:26:06,210
they're doing this is that they're

482
00:26:03,630 --> 00:26:09,240
different right so they've hashed

483
00:26:06,210 --> 00:26:10,980
they're generating a hash value for K -

484
00:26:09,240 --> 00:26:13,140
that's different than the way they're

485
00:26:10,980 --> 00:26:17,910
for H 2 then for it that's different

486
00:26:13,140 --> 00:26:20,340
from H 1 right it uses 27 or 31 uses two

487
00:26:17,910 --> 00:26:21,900
different constants here and so I don't

488
00:26:20,339 --> 00:26:25,049
know why they're doing that

489
00:26:21,900 --> 00:26:26,430
for for subsequent blocks it must have

490
00:26:25,049 --> 00:26:29,389
to do with the fact that they're going

491
00:26:26,430 --> 00:26:34,620
to mix the blocks values together later

492
00:26:29,390 --> 00:26:43,740
using this I guess no that's just for

493
00:26:34,619 --> 00:26:48,449
the tail I don't know why so this right

494
00:26:43,740 --> 00:26:52,650
the h1 plus h2 they must be doing this

495
00:26:48,450 --> 00:26:56,210
because they're doing this part they're

496
00:26:52,650 --> 00:26:59,670
like cross mixing the hash values right

497
00:26:56,210 --> 00:27:01,620
so I don't I really just don't quite get

498
00:26:59,670 --> 00:27:06,240
that which makes me a little nervous I

499
00:27:01,619 --> 00:27:08,159
wish I knew why they were doing that if

500
00:27:06,240 --> 00:27:11,750
we take a look at the original member

501
00:27:08,160 --> 00:27:17,220
hash so here's the the basic one right

502
00:27:11,750 --> 00:27:22,549
it's 15 13 and 5 for those and then it's

503
00:27:17,220 --> 00:27:22,549
you know e 6 5 4 B 6 4 or whatever right

504
00:27:23,210 --> 00:27:31,600
so these are completely different except

505
00:27:27,180 --> 00:27:32,798
for the five five remains so these

506
00:27:31,599 --> 00:27:35,259
shifts are up more which would make

507
00:27:32,798 --> 00:27:37,359
sense because they're 64-bit these are

508
00:27:35,259 --> 00:27:39,669
presumably picked because they're being

509
00:27:37,359 --> 00:27:42,459
mixed together what I don't know is if

510
00:27:39,669 --> 00:27:44,890
we just want to maintain one hash value

511
00:27:42,460 --> 00:27:48,960
which of these would be better or should

512
00:27:44,890 --> 00:27:53,470
there be some third as-yet-unnamed

513
00:27:48,960 --> 00:28:01,269
constants that we should be using here's

514
00:27:53,470 --> 00:28:11,350
okay so in murmur hash - they do have a

515
00:28:01,269 --> 00:28:19,288
64-bit version so what goes on here so

516
00:28:11,349 --> 00:28:19,288
this is a simpler hash actually

517
00:28:24,410 --> 00:28:30,279
and I guess they decided to change it

518
00:28:33,220 --> 00:28:37,640
cuz this is totally different I mean not

519
00:28:35,960 --> 00:28:40,090
totally different but it's quite a bit

520
00:28:37,640 --> 00:28:40,090
different

521
00:28:57,720 --> 00:29:02,339
so I'm not sure what to make of that I

522
00:29:03,148 --> 00:29:08,018
don't quite understand why they wouldn't

523
00:29:05,859 --> 00:29:09,548
have provided a 64-bit version and I

524
00:29:08,019 --> 00:29:12,099
wish there was some explanation in here

525
00:29:09,548 --> 00:29:24,940
but I see nothing that even mentions

526
00:29:12,099 --> 00:29:37,778
that fact and that's a little troubling

527
00:29:24,940 --> 00:29:38,980
I like super fast hash dot CPP um so I

528
00:29:37,778 --> 00:29:46,950
don't know what do you think we should

529
00:29:38,980 --> 00:29:49,358
do maybe we should just ask dear Sirs

530
00:29:46,950 --> 00:29:51,220
which constants would you use if you

531
00:29:49,358 --> 00:29:56,220
were only going to produce a single

532
00:29:51,220 --> 00:29:56,220
64-bit hash value and not try to hash

533
00:29:56,730 --> 00:30:05,919
128 bits at once you know and and and I

534
00:30:03,970 --> 00:30:08,769
don't know so I'm gonna just go with

535
00:30:05,919 --> 00:30:10,299
this mixing step like I said we don't

536
00:30:08,769 --> 00:30:14,739
have a lot of risk here so I'm gonna go

537
00:30:10,298 --> 00:30:16,778
with this mixing step we have our c1 you

538
00:30:14,739 --> 00:30:19,358
have our c2 we just need to know what I

539
00:30:16,778 --> 00:30:25,089
rotate left gonna be so we'll just say

540
00:30:19,358 --> 00:30:27,878
it's 31 okay and then here we've got our

541
00:30:25,089 --> 00:30:35,428
other rotate is 27 so then we just need

542
00:30:27,878 --> 00:30:37,839
our m1 which we know is 5 and our n1

543
00:30:35,429 --> 00:30:40,590
which again this is the part that we

544
00:30:37,839 --> 00:30:40,589
really just don't know

545
00:30:43,210 --> 00:30:49,240
but our n1 is going to be the first

546
00:30:46,480 --> 00:30:51,990
constant because I'm just purely

547
00:30:49,240 --> 00:31:03,539
ignorant Li picking the first mix

548
00:30:51,990 --> 00:31:08,109
because I can right that's it

549
00:31:03,539 --> 00:31:09,879
now as with any of these things and this

550
00:31:08,109 --> 00:31:13,000
is the downside of not knowing any

551
00:31:09,880 --> 00:31:15,340
numerical analysis I have no idea how

552
00:31:13,000 --> 00:31:17,890
good this is right like I have a

553
00:31:15,339 --> 00:31:21,809
literally no idea I know what it's doing

554
00:31:17,890 --> 00:31:24,370
right I can see how it works it's pretty

555
00:31:21,809 --> 00:31:27,269
straightforward the the math that's

556
00:31:24,369 --> 00:31:29,469
going on but what that math actually

557
00:31:27,269 --> 00:31:30,099
accomplishes is totally opaque to me

558
00:31:29,470 --> 00:31:33,069
right

559
00:31:30,099 --> 00:31:36,399
like I wouldn't know if you were to

560
00:31:33,069 --> 00:31:38,919
change this 2 to a 3 what would be like

561
00:31:36,400 --> 00:31:41,290
does it matter right I have no idea

562
00:31:38,920 --> 00:31:43,480
these constants were chosen probably

563
00:31:41,289 --> 00:31:45,639
very specifically to do certain

564
00:31:43,480 --> 00:31:47,289
operations to the bits and put them in

565
00:31:45,640 --> 00:31:48,759
special positions and make them be

566
00:31:47,289 --> 00:31:52,500
dependent on each other in a special way

567
00:31:48,759 --> 00:31:55,869
I have no idea how it's working right

568
00:31:52,500 --> 00:31:57,220
it's a little bit frustrating again the

569
00:31:55,869 --> 00:31:58,989
reason I don't know these things is

570
00:31:57,220 --> 00:32:00,430
because it never actually matters to

571
00:31:58,990 --> 00:32:03,430
code that I write it's usually

572
00:32:00,430 --> 00:32:06,519
sufficient to take someone who has made

573
00:32:03,430 --> 00:32:08,470
a good hash that's relatively well

574
00:32:06,519 --> 00:32:10,359
respected to just take their word for it

575
00:32:08,470 --> 00:32:12,039
it's usually good enough because again

576
00:32:10,359 --> 00:32:13,929
if you just pick something relatively

577
00:32:12,039 --> 00:32:16,089
simple like this you know you can

578
00:32:13,930 --> 00:32:17,140
usually put it in a relatively small

579
00:32:16,089 --> 00:32:19,689
amount of space you don't think about

580
00:32:17,140 --> 00:32:24,070
too much and if the cost of it being bad

581
00:32:19,690 --> 00:32:25,809
isn't that high well it's okay right but

582
00:32:24,069 --> 00:32:27,669
again it's a little bit nerve-racking

583
00:32:25,809 --> 00:32:29,710
because you can see how if let's suppose

584
00:32:27,670 --> 00:32:32,080
we actually really cared how good this

585
00:32:29,710 --> 00:32:33,700
was we would have to go spend a ton of

586
00:32:32,079 --> 00:32:35,230
time trying to figure out exactly how

587
00:32:33,700 --> 00:32:36,580
this thing was working before we could

588
00:32:35,230 --> 00:32:39,329
have any confidence that it works well

589
00:32:36,579 --> 00:32:41,259
at all and of course the supremely

590
00:32:39,329 --> 00:32:43,629
unsatisfying part about all of it as

591
00:32:41,259 --> 00:32:45,609
with anything in cryptography we don't

592
00:32:43,630 --> 00:32:47,440
really know like even the best

593
00:32:45,609 --> 00:32:49,750
cryptographers really don't know how

594
00:32:47,440 --> 00:32:51,190
hard something is to crack right all we

595
00:32:49,750 --> 00:32:55,029
really know is that no one's cracked it

596
00:32:51,190 --> 00:32:55,900
yet right or things like that and so we

597
00:32:55,029 --> 00:32:58,089
don't have

598
00:32:55,900 --> 00:33:00,550
ways of proving things are unbreakable

599
00:32:58,089 --> 00:33:03,220
we don't have ways of proving things our

600
00:33:00,549 --> 00:33:04,720
can't have collisions generated for them

601
00:33:03,220 --> 00:33:07,059
we haven't gotten there yet

602
00:33:04,720 --> 00:33:10,299
I mean that's like cutting-edge stuff

603
00:33:07,059 --> 00:33:12,549
right and so you know it's it's kind of

604
00:33:10,299 --> 00:33:14,799
a supremely unsatisfying thing in its

605
00:33:12,549 --> 00:33:16,990
entirety because a lot of times even the

606
00:33:14,799 --> 00:33:18,250
best people can't really tell you they

607
00:33:16,990 --> 00:33:19,930
might be able to tell you well this

608
00:33:18,250 --> 00:33:22,210
one's weaker than this one because we've

609
00:33:19,930 --> 00:33:24,190
found this many exploits to it or we can

610
00:33:22,210 --> 00:33:26,559
go through these parts of it more easily

611
00:33:24,190 --> 00:33:28,299
and stuff like that but that's it's

612
00:33:26,559 --> 00:33:30,099
right we don't really know much more

613
00:33:28,299 --> 00:33:31,720
than that and we can also evaluate

614
00:33:30,099 --> 00:33:33,009
through in practice if we just take a

615
00:33:31,720 --> 00:33:34,630
bunch of random stuff and feed it

616
00:33:33,009 --> 00:33:37,180
through it how often is it colliding

617
00:33:34,630 --> 00:33:38,710
with small permutations and the data or

618
00:33:37,180 --> 00:33:40,810
stuff like that right we can do some

619
00:33:38,710 --> 00:33:43,930
testing and and that's you know maybe

620
00:33:40,809 --> 00:33:46,569
that's as good as it gets right so again

621
00:33:43,930 --> 00:33:48,670
it's not a very satisfying thing but

622
00:33:46,569 --> 00:33:50,740
luckily for us like I say we don't have

623
00:33:48,670 --> 00:33:53,740
to care we're in the envy about position

624
00:33:50,740 --> 00:33:55,569
of really it doesn't matter and that's

625
00:33:53,740 --> 00:33:59,019
really nice for us because it means we

626
00:33:55,569 --> 00:34:00,429
can't fail too hard and that's really

627
00:33:59,019 --> 00:34:02,019
what you want when you're going into

628
00:34:00,430 --> 00:34:03,820
something cryptographic because if

629
00:34:02,019 --> 00:34:06,730
failure is on the table oh it's it's

630
00:34:03,819 --> 00:34:09,789
it's rough it's nerve-racking okay so

631
00:34:06,730 --> 00:34:13,269
let's start here by creating our results

632
00:34:09,789 --> 00:34:19,000
I want to note here that the seed values

633
00:34:13,269 --> 00:34:22,509
are often passed in that's if we wanted

634
00:34:19,000 --> 00:34:26,559
to get some additional information in

635
00:34:22,510 --> 00:34:28,960
here from outside we still can do that I

636
00:34:26,559 --> 00:34:31,389
don't know that we really care but if we

637
00:34:28,960 --> 00:34:34,148
wanted to we could do that just by

638
00:34:31,389 --> 00:34:36,519
saying something like this right where

639
00:34:34,148 --> 00:34:38,589
we say look if you want to pass in a

640
00:34:36,519 --> 00:34:41,530
seed value go right ahead that will be

641
00:34:38,590 --> 00:34:43,179
the initial state of the hash and then

642
00:34:41,530 --> 00:34:45,580
when we go through and do the hashing

643
00:34:43,179 --> 00:34:48,550
we'll start from there and update as we

644
00:34:45,579 --> 00:34:52,960
go now we know we're gonna have a hash

645
00:34:48,550 --> 00:34:54,159
value that is that result I guess I

646
00:34:52,960 --> 00:34:56,139
don't even do it that way

647
00:34:54,159 --> 00:34:58,809
so what we're pretty much gonna look at

648
00:34:56,139 --> 00:35:02,759
is something that does the hash

649
00:34:58,809 --> 00:35:06,190
finalized at the end by taking what we

650
00:35:02,760 --> 00:35:08,050
get as our last hash value and passing

651
00:35:06,190 --> 00:35:09,679
it through the finalization step that

652
00:35:08,050 --> 00:35:13,880
finalization step again

653
00:35:09,679 --> 00:35:15,980
shifting out the low bits here you know

654
00:35:13,880 --> 00:35:18,380
in a sense so shifting it over and then

655
00:35:15,980 --> 00:35:22,699
xor ring so it's kind of mixing it's

656
00:35:18,380 --> 00:35:23,300
it's mixing in itself through two rounds

657
00:35:22,699 --> 00:35:25,639
of multiplies

658
00:35:23,300 --> 00:35:27,109
I don't know why right I don't know

659
00:35:25,639 --> 00:35:29,598
what's magic about those constants

660
00:35:27,108 --> 00:35:31,279
that's again the thing that we maybe if

661
00:35:29,599 --> 00:35:32,900
if there's a paper on rumor hash we

662
00:35:31,280 --> 00:35:35,750
could go read and find out why but

663
00:35:32,900 --> 00:35:38,170
basically that step it right it's we're

664
00:35:35,750 --> 00:35:41,059
taking the value we're shifting it over

665
00:35:38,170 --> 00:35:42,289
X soaring it in on the bottom shifting

666
00:35:41,059 --> 00:35:43,700
it over X soaring and on the bottom

667
00:35:42,289 --> 00:35:45,619
shifting it over X soaring it in on the

668
00:35:43,699 --> 00:35:48,679
bottom so we're really mixing up those

669
00:35:45,619 --> 00:35:57,079
bottom bits that way and I'm not quite

670
00:35:48,679 --> 00:35:59,419
sure why I don't know if that has

671
00:35:57,079 --> 00:36:01,280
something to do with the fact that we're

672
00:35:59,420 --> 00:36:11,838
less sure about our bottom bits or

673
00:36:01,280 --> 00:36:14,990
something you got me that's what the

674
00:36:11,838 --> 00:36:16,730
numerical analysts to worry about so

675
00:36:14,989 --> 00:36:18,229
anyway when we go to do our checksum

676
00:36:16,730 --> 00:36:21,588
here what we want to do is we want to

677
00:36:18,230 --> 00:36:23,449
read out 64-bit values so what I want to

678
00:36:21,588 --> 00:36:24,108
do first is I just want to find out the

679
00:36:23,449 --> 00:36:27,588
count here

680
00:36:24,108 --> 00:36:29,659
so I want to say look how many 64-bit

681
00:36:27,588 --> 00:36:31,909
values could I do so we know the buffer

682
00:36:29,659 --> 00:36:33,739
has a count and we know that if we

683
00:36:31,909 --> 00:36:35,779
divided that by eight or maybe if I'm

684
00:36:33,739 --> 00:36:39,279
feeling saucy or I could just say sigh

685
00:36:35,780 --> 00:36:42,260
the new 64 so however many of these

686
00:36:39,280 --> 00:36:44,809
we're actually gonna do that's our count

687
00:36:42,260 --> 00:36:48,290
64 and then we've got like a count

688
00:36:44,809 --> 00:36:50,390
that's going to be a byte count so how

689
00:36:48,289 --> 00:36:52,099
many eighths do we have right and that's

690
00:36:50,389 --> 00:36:58,029
gonna be however many there are in the

691
00:36:52,099 --> 00:37:02,240
buffer - the count 64 times the size of

692
00:36:58,030 --> 00:37:04,880
a you 64 so what I'm doing there is

693
00:37:02,239 --> 00:37:07,489
saying look how many packets of 64 bits

694
00:37:04,880 --> 00:37:11,690
can I process right and then how many

695
00:37:07,489 --> 00:37:13,939
eights are left over once I'm done so

696
00:37:11,690 --> 00:37:18,849
that means I can go fast right I can

697
00:37:13,940 --> 00:37:21,110
just say alright let's loop through all

698
00:37:18,849 --> 00:37:23,269
of those

699
00:37:21,110 --> 00:37:27,230
I'm just gonna loop through all of the

700
00:37:23,269 --> 00:37:28,250
64-bit ones that I that I have here and

701
00:37:27,230 --> 00:37:55,579
what I'm going to do is I'm going to

702
00:37:28,250 --> 00:37:57,949
snap a 64-bit pointer to the data and

703
00:37:55,579 --> 00:38:00,139
it's just worth noting here and I maybe

704
00:37:57,949 --> 00:38:02,329
I should make this up to do so on Intel

705
00:38:00,139 --> 00:38:03,500
machines they don't care very much about

706
00:38:02,329 --> 00:38:10,309
alignment anymore

707
00:38:03,500 --> 00:38:13,369
they really just don't I guess they

708
00:38:10,309 --> 00:38:15,590
found that having the lanes move around

709
00:38:13,369 --> 00:38:17,929
was not as big of a deal as it could be

710
00:38:15,590 --> 00:38:19,039
I I really don't know why it used to be

711
00:38:17,929 --> 00:38:22,789
a problem for them and now it doesn't

712
00:38:19,039 --> 00:38:26,210
seem to be but operating on 64's that

713
00:38:22,789 --> 00:38:28,610
are offset it doesn't tend to be a huge

714
00:38:26,210 --> 00:38:31,070
problem anymore it used to be a much

715
00:38:28,610 --> 00:38:32,809
bigger problem so at the moment I'm not

716
00:38:31,070 --> 00:38:35,690
going to care about that but if in the

717
00:38:32,809 --> 00:38:37,699
future we do care about that what we

718
00:38:35,690 --> 00:38:40,789
would want to do there is step two the

719
00:38:37,699 --> 00:38:44,659
first aligned 64-bit boundary and then

720
00:38:40,789 --> 00:38:45,980
just go 64 bits along right so you can

721
00:38:44,659 --> 00:38:47,899
see why that might be important

722
00:38:45,980 --> 00:38:51,019
depending on the platform so we'd have

723
00:38:47,900 --> 00:38:54,050
to see since this is only used in

724
00:38:51,019 --> 00:38:56,150
imports we probably will never care

725
00:38:54,050 --> 00:38:57,890
about it but again it's just worth

726
00:38:56,150 --> 00:39:00,139
putting it to do there because we know

727
00:38:57,889 --> 00:39:01,549
it could be problem mines well put it to

728
00:39:00,139 --> 00:39:04,400
do so that when people are searching the

729
00:39:01,550 --> 00:39:06,830
codebase they can see and maybe it heads

730
00:39:04,400 --> 00:39:12,170
off some problems for them who knows

731
00:39:06,829 --> 00:39:13,639
right I guess I can do this every time I

732
00:39:12,170 --> 00:39:15,409
read one of these things I want to

733
00:39:13,639 --> 00:39:17,659
update the murmur hash right so my

734
00:39:15,409 --> 00:39:21,170
result is going to be a murmur hash

735
00:39:17,659 --> 00:39:25,009
update step where I read in I pass in

736
00:39:21,170 --> 00:39:27,980
the current result and I read in the

737
00:39:25,010 --> 00:39:30,560
next 64-bit value from the data that

738
00:39:27,980 --> 00:39:35,019
gives me a new update when I'm a poveri

739
00:39:30,559 --> 00:39:38,659
end here I need to low

740
00:39:35,019 --> 00:39:42,280
one final 64-bit value to suck up any of

741
00:39:38,659 --> 00:39:44,869
the additional eight parts that I've got

742
00:39:42,280 --> 00:39:49,880
so what I'm gonna do here is make it

743
00:39:44,869 --> 00:39:51,500
residual I'm going to snap a pointer to

744
00:39:49,880 --> 00:39:55,579
the residual I'm just gonna fill it

745
00:39:51,500 --> 00:39:59,090
right with whatever is left so here's

746
00:39:55,579 --> 00:40:01,909
the count eight that's how many bytes

747
00:39:59,090 --> 00:40:05,510
are left over and I'm just gonna say

748
00:40:01,909 --> 00:40:07,549
look copy from at wherever we ended copy

749
00:40:05,510 --> 00:40:11,650
the residual remaining bytes put them

750
00:40:07,550 --> 00:40:16,630
into my 64-bit value that I've got here

751
00:40:11,650 --> 00:40:20,750
and it'll just fill them in now

752
00:40:16,630 --> 00:40:22,579
technically right you might have to

753
00:40:20,750 --> 00:40:24,619
think about which direction you wanted

754
00:40:22,579 --> 00:40:26,809
to go do you want to fill the top bits

755
00:40:24,619 --> 00:40:29,409
in or do you want to fill the bottom

756
00:40:26,809 --> 00:40:32,420
bits in because since it's little endian

757
00:40:29,409 --> 00:40:35,989
you know if you if you look at what

758
00:40:32,420 --> 00:40:39,820
happens to grab a 64-bit value the first

759
00:40:35,989 --> 00:40:43,069
thing goes into the bottom that goes up

760
00:40:39,820 --> 00:40:45,260
it just so happens that doing this copy

761
00:40:43,070 --> 00:40:48,370
would fill in the same order that that

762
00:40:45,260 --> 00:40:52,610
grab would fill so the missing parts are

763
00:40:48,369 --> 00:40:54,440
coming in in the in the right place

764
00:40:52,610 --> 00:40:56,690
right the zeros will be in the right

765
00:40:54,440 --> 00:40:58,690
place on a big endian machine this would

766
00:40:56,690 --> 00:41:01,250
be wrong it would be the wrong round

767
00:40:58,690 --> 00:41:03,800
since we don't actually care however

768
00:41:01,250 --> 00:41:05,239
meaning we're just it's just however we

769
00:41:03,800 --> 00:41:07,100
want to do the residual is how we do it

770
00:41:05,239 --> 00:41:09,769
as long as we do the hash consistently

771
00:41:07,099 --> 00:41:12,199
both times it's okay it should be fine

772
00:41:09,769 --> 00:41:13,849
but it's worth noting that if we were to

773
00:41:12,199 --> 00:41:16,009
run that checksum on a little any

774
00:41:13,849 --> 00:41:18,079
machine and a big endian machine this

775
00:41:16,010 --> 00:41:21,460
would produce potentially different

776
00:41:18,079 --> 00:41:21,460
results right

777
00:41:43,489 --> 00:41:49,549
so basically we don't want to support

778
00:41:46,400 --> 00:41:51,079
big endian machines because I hate the

779
00:41:49,550 --> 00:41:52,910
fact that endianness is still a thing

780
00:41:51,079 --> 00:41:54,319
and we have all little endian machines

781
00:41:52,909 --> 00:41:57,500
in consumer space right now we should

782
00:41:54,320 --> 00:41:59,269
stay that way so I'm just gonna leave it

783
00:41:57,500 --> 00:42:03,139
like this and everyone has a big endian

784
00:41:59,269 --> 00:42:05,659
machine can eat on it so what we want to

785
00:42:03,139 --> 00:42:10,250
do here is finish off that residual by

786
00:42:05,659 --> 00:42:14,659
doing one final murmur half step where

787
00:42:10,250 --> 00:42:15,800
we can pass in again the same format

788
00:42:14,659 --> 00:42:17,869
that we have before but now we're just

789
00:42:15,800 --> 00:42:19,970
going to do that residual this step

790
00:42:17,869 --> 00:42:23,150
obviously only needs to be done if there

791
00:42:19,969 --> 00:42:25,069
was a residual so we can just check the

792
00:42:23,150 --> 00:42:27,650
count eight first and just skip all this

793
00:42:25,070 --> 00:42:30,440
nonsense in the case where there wasn't

794
00:42:27,650 --> 00:42:32,059
any residual this will automatically

795
00:42:30,440 --> 00:42:33,980
skip itself because this first check

796
00:42:32,059 --> 00:42:36,380
will fail so we don't really need to do

797
00:42:33,980 --> 00:42:38,960
anything about that that should be the

798
00:42:36,380 --> 00:42:42,650
entirety of the hash that should give us

799
00:42:38,960 --> 00:42:44,329
back the hash code that we wanted so now

800
00:42:42,650 --> 00:42:48,079
when we import things we should get that

801
00:42:44,329 --> 00:42:51,259
checksum this also means that in the HHA

802
00:42:48,079 --> 00:42:53,719
edit in theory when we produce that

803
00:42:51,260 --> 00:42:56,510
checksum value the source file check

804
00:42:53,719 --> 00:42:59,539
some stuff here we could actually

805
00:42:56,510 --> 00:43:01,430
produce the synthetic checksum for the

806
00:42:59,539 --> 00:43:03,980
file if we really wanted to I don't know

807
00:43:01,429 --> 00:43:06,259
that we really do want to but when we do

808
00:43:03,980 --> 00:43:08,780
the read hav zero and we produce that

809
00:43:06,260 --> 00:43:11,720
synthetic annotation at this part here

810
00:43:08,780 --> 00:43:15,530
we could actually produce the file date

811
00:43:11,719 --> 00:43:17,750
and check some of the v-0 that we read I

812
00:43:15,530 --> 00:43:20,390
don't think it's worth it because I

813
00:43:17,750 --> 00:43:25,429
don't think we we don't really support

814
00:43:20,389 --> 00:43:28,579
updating from a V 0 to V 1 file in a on

815
00:43:25,429 --> 00:43:31,669
demand way so it just doesn't seem like

816
00:43:28,579 --> 00:43:33,920
it would make any difference so I think

817
00:43:31,670 --> 00:43:38,480
we just can leave it the way it is now

818
00:43:33,920 --> 00:43:41,690
but it's nice to have that in here you

819
00:43:38,480 --> 00:43:44,000
way so I think that's it I think that's

820
00:43:41,690 --> 00:43:45,650
everything that we needed there and so

821
00:43:44,000 --> 00:43:49,039
now we should be able to store that

822
00:43:45,650 --> 00:43:50,930
annotation data into the file it should

823
00:43:49,039 --> 00:43:54,829
have the check sums for the files

824
00:43:50,929 --> 00:43:58,659
properly and that should be you know I

825
00:43:54,829 --> 00:44:02,929
think what we want so if we go in and

826
00:43:58,659 --> 00:44:08,690
and start the debugging process now we

827
00:44:02,929 --> 00:44:15,019
should be able to sort of go down the

828
00:44:08,690 --> 00:44:17,809
homestretch here of the art importing

829
00:44:15,019 --> 00:44:20,719
process so here's the game running as it

830
00:44:17,809 --> 00:44:25,039
normally would write with the with the

831
00:44:20,719 --> 00:44:30,949
hero and loading the sprites in and what

832
00:44:25,039 --> 00:44:33,469
I remember us doing is when we we made

833
00:44:30,949 --> 00:44:37,279
his fist be something that is only comes

834
00:44:33,469 --> 00:44:39,799
from imported out our tassets right and

835
00:44:37,280 --> 00:44:43,670
so the question is can we now go ahead

836
00:44:39,800 --> 00:44:45,800
and make the imported art assets work

837
00:44:43,670 --> 00:44:48,320
again and see if we can start testing

838
00:44:45,800 --> 00:44:50,900
that system so if you remember correctly

839
00:44:48,320 --> 00:44:53,840
the way we did that is we said we we

840
00:44:50,900 --> 00:44:55,910
don't import by default you have to

841
00:44:53,840 --> 00:44:58,010
create an HHA that's suitable for

842
00:44:55,909 --> 00:44:59,509
importing and if it sees that there it

843
00:44:58,010 --> 00:45:02,720
will start to use it to import art

844
00:44:59,510 --> 00:45:05,600
assets from the art directory so from

845
00:45:02,719 --> 00:45:08,119
this directory so if I want to do that

846
00:45:05,599 --> 00:45:10,159
what I can do is I can run our HHA edit

847
00:45:08,119 --> 00:45:12,650
routine as you can see there's a -

848
00:45:10,159 --> 00:45:15,409
create on that that - create is the

849
00:45:12,650 --> 00:45:18,260
thing that tells us okay let's make a

850
00:45:15,409 --> 00:45:21,199
new file here that we can use and so we

851
00:45:18,260 --> 00:45:28,010
can make that local HHA and that local

852
00:45:21,199 --> 00:45:30,379
HHA is what's gonna trigger all of the

853
00:45:28,010 --> 00:45:32,000
dynamic loading stuff so if we create

854
00:45:30,380 --> 00:45:35,690
one of those we can also take a look at

855
00:45:32,000 --> 00:45:39,019
it right here's the dump it starts out

856
00:45:35,690 --> 00:45:43,309
with no assets no tags no annotations

857
00:45:39,019 --> 00:45:45,170
nothing right it's a version 1 file and

858
00:45:43,309 --> 00:45:49,699
that's all that's in there is is

859
00:45:45,170 --> 00:45:51,380
literally nothing so if I if I now run

860
00:45:49,699 --> 00:45:52,159
the game we should be able to step

861
00:45:51,380 --> 00:45:54,380
through

862
00:45:52,159 --> 00:45:56,838
our new code and it should actually run

863
00:45:54,380 --> 00:45:59,210
and do stuff and that's what we want to

864
00:45:56,838 --> 00:46:01,489
see here I don't want this nonsense so

865
00:45:59,210 --> 00:46:03,829
I'm gonna get rid of it so what I want

866
00:46:01,489 --> 00:46:08,598
to do is I want to step into here I want

867
00:46:03,829 --> 00:46:13,700
to see us get this path I want to see

868
00:46:08,599 --> 00:46:17,030
this path get hit right and so the file

869
00:46:13,699 --> 00:46:20,118
high watermark is 128 the idea is that

870
00:46:17,030 --> 00:46:23,030
should be the header right and you can

871
00:46:20,119 --> 00:46:25,190
see that it is because there's nothing

872
00:46:23,030 --> 00:46:26,510
in the file so the first place we would

873
00:46:25,190 --> 00:46:29,750
write is right after the header because

874
00:46:26,510 --> 00:46:34,250
nothing in here right allow editing

875
00:46:29,750 --> 00:46:38,989
becomes true which is good and it's our

876
00:46:34,250 --> 00:46:41,480
new default append so HHA 5 is what

877
00:46:38,989 --> 00:46:43,548
we're going to append through to when we

878
00:46:41,480 --> 00:46:47,449
see an asset we don't know where it goes

879
00:46:43,548 --> 00:46:49,670
it's going to go in here ok so then we

880
00:46:47,449 --> 00:46:52,038
come through and we allocate our arrays

881
00:46:49,670 --> 00:46:54,318
we're using our large arrays so we've

882
00:46:52,039 --> 00:46:56,049
got tons of extra space in there to put

883
00:46:54,318 --> 00:46:59,869
new assets in if we want to load them

884
00:46:56,048 --> 00:47:03,199
that's exactly what we want I should

885
00:46:59,869 --> 00:47:05,028
probably put an if here on whether

886
00:47:03,199 --> 00:47:07,149
there's anything to append to because I

887
00:47:05,028 --> 00:47:09,469
mean we don't need to do it but you know

888
00:47:07,150 --> 00:47:11,210
technically even if it's an internal we

889
00:47:09,469 --> 00:47:14,868
don't need space if we're not running an

890
00:47:11,210 --> 00:47:16,670
append mode but you know whatever so if

891
00:47:14,869 --> 00:47:20,180
we come through here now what I'm most

892
00:47:16,670 --> 00:47:22,548
interested in is just this path here

893
00:47:20,179 --> 00:47:25,159
this is the pet that has not been run

894
00:47:22,548 --> 00:47:27,829
yet it's not going to do anything at the

895
00:47:25,159 --> 00:47:30,078
moment unfortunately for uh you know I

896
00:47:27,829 --> 00:47:32,150
forgots another breakpoint that was bad

897
00:47:30,079 --> 00:47:35,210
well we hit an assertion anyway so

898
00:47:32,150 --> 00:47:36,980
that's fine what I was gonna say is I

899
00:47:35,210 --> 00:47:38,720
want to step to that code but then I

900
00:47:36,980 --> 00:47:40,400
realized as soon as I had a 5 as like

901
00:47:38,719 --> 00:47:43,028
wait a minute it's not going to run

902
00:47:40,400 --> 00:47:46,490
because that would that part of the code

903
00:47:43,028 --> 00:47:48,349
here would only run if there were any

904
00:47:46,489 --> 00:47:50,649
assets in the file this is the thing

905
00:47:48,349 --> 00:47:53,450
that like brings in asset information

906
00:47:50,650 --> 00:47:55,460
from the existing file for importing

907
00:47:53,449 --> 00:47:58,848
purposes obviously that's not going to

908
00:47:55,460 --> 00:48:00,079
fly because well I mean for obvious

909
00:47:58,849 --> 00:48:03,068
reasons

910
00:48:00,079 --> 00:48:03,068
there is no

911
00:48:04,739 --> 00:48:09,029
there there are no assets in this local

912
00:48:06,809 --> 00:48:13,409
file so there's no information to pull

913
00:48:09,030 --> 00:48:15,330
in in this case so all right so I can't

914
00:48:13,409 --> 00:48:17,549
debug that path yet I've got to wait

915
00:48:15,329 --> 00:48:19,949
till the next time we load but I can

916
00:48:17,550 --> 00:48:21,420
debug the rest of the path so let's go

917
00:48:19,949 --> 00:48:23,250
ahead and do that now we've got an

918
00:48:21,420 --> 00:48:24,659
assertion here so we can start with this

919
00:48:23,250 --> 00:48:27,869
although I would have liked to have step

920
00:48:24,659 --> 00:48:30,719
through this stuff first but that's okay

921
00:48:27,869 --> 00:48:35,280
we look here and we see we're supposed

922
00:48:30,719 --> 00:48:46,230
to have 13 tags we wrote 208 tags is

923
00:48:35,280 --> 00:48:48,420
that right so that seems bad to say the

924
00:48:46,230 --> 00:48:51,570
least so I'm not sure exactly how that

925
00:48:48,420 --> 00:48:54,150
ended up happening we were supposed to

926
00:48:51,570 --> 00:48:56,640
write 13 tags and we wrote like an

927
00:48:54,150 --> 00:48:58,970
infinity of tags so is that really what

928
00:48:56,639 --> 00:49:02,429
happened there what did what did we do

929
00:48:58,969 --> 00:49:05,698
so when we went to write

930
00:49:02,429 --> 00:49:05,698
[Music]

931
00:49:23,489 --> 00:49:27,929
so I would like to step through that a

932
00:49:25,889 --> 00:49:30,329
little bit more carefully and I think I

933
00:49:27,929 --> 00:49:33,719
can pretty easily so if we look at

934
00:49:30,329 --> 00:49:40,039
what's going on here if I just delete

935
00:49:33,719 --> 00:49:42,419
that local uhha and make a new one I

936
00:49:40,039 --> 00:49:43,829
should just be able to step through that

937
00:49:42,420 --> 00:49:46,559
directly which is what I want to do I

938
00:49:43,829 --> 00:49:51,329
just want to watch this thing go let's

939
00:49:46,559 --> 00:49:52,949
just start there all right so first

940
00:49:51,329 --> 00:49:56,429
thing one knows how many assets do we

941
00:49:52,949 --> 00:49:59,129
have and we want to count our tags so

942
00:49:56,429 --> 00:50:01,079
let's take a look if here's our asset

943
00:49:59,130 --> 00:50:03,119
that we're looping over I'm gonna set a

944
00:50:01,079 --> 00:50:04,889
breakpoint here as well if this is our

945
00:50:03,119 --> 00:50:08,429
asset that we're looping over you can

946
00:50:04,889 --> 00:50:14,099
see inside hsj data it's got the tag

947
00:50:08,429 --> 00:50:17,779
information here it is one tag per in

948
00:50:14,099 --> 00:50:20,670
fact all of these are one tag per right

949
00:50:17,780 --> 00:50:26,900
so the tag count is looking pretty

950
00:50:20,670 --> 00:50:26,900
accurate there so we get 13 tags and 13

951
00:50:27,619 --> 00:50:36,000
assets this could actually be set to a 1

952
00:50:30,929 --> 00:50:37,500
here I won't actually do that well I'll

953
00:50:36,000 --> 00:50:40,590
do that later because I don't want to

954
00:50:37,500 --> 00:50:44,579
stop it bugging so through here I'm

955
00:50:40,590 --> 00:50:47,820
gonna make 13 of everything 13 tags 14

956
00:50:44,579 --> 00:50:51,090
assets 13 annotations not a lot going on

957
00:50:47,820 --> 00:50:53,190
there pretty basic right so then we

958
00:50:51,090 --> 00:50:55,230
create arrays for each of these things

959
00:50:53,190 --> 00:51:02,670
we're gonna start by writing to the

960
00:50:55,230 --> 00:51:03,929
first one here is the source asset if it

961
00:51:02,670 --> 00:51:06,539
doesn't match the file index we don't

962
00:51:03,929 --> 00:51:09,409
write it so we're going to want to stop

963
00:51:06,539 --> 00:51:12,599
when we get to you know this is the same

964
00:51:09,409 --> 00:51:14,789
loop here we're gonna want to stop when

965
00:51:12,599 --> 00:51:18,329
we get to one that actually is is in the

966
00:51:14,789 --> 00:51:24,059
file so if I now look in and check out

967
00:51:18,329 --> 00:51:28,769
the source asset it's got one tag right

968
00:51:24,059 --> 00:51:34,949
so when I come through here oh that's a

969
00:51:28,769 --> 00:51:36,460
problem this is not the right loop it

970
00:51:34,949 --> 00:51:45,789
should be source

971
00:51:36,460 --> 00:51:59,470
right that's just wrong so again I want

972
00:51:45,789 --> 00:52:02,500
to fix this here these nulls are skipped

973
00:51:59,469 --> 00:52:05,199
sorry Mel asset

974
00:52:02,500 --> 00:52:08,019
these are skipped this is otherwise

975
00:52:05,199 --> 00:52:14,379
correct this is the problem this really

976
00:52:08,019 --> 00:52:17,369
wants to use this loop those are the

977
00:52:14,380 --> 00:52:20,440
tags we're trying to copy out so we do

978
00:52:17,369 --> 00:52:21,190
and then you know when when we're done

979
00:52:20,440 --> 00:52:24,849
here

980
00:52:21,190 --> 00:52:34,260
we we should now be able to wrap that up

981
00:52:24,849 --> 00:52:34,259
properly so let's go ahead and run that

982
00:52:34,650 --> 00:52:41,740
should jump down there now after

983
00:52:38,230 --> 00:52:46,780
importing all the pngs let's take a look

984
00:52:41,739 --> 00:52:49,509
13 13 13 13 much better now we can write

985
00:52:46,780 --> 00:52:53,530
out those pieces of information and then

986
00:52:49,510 --> 00:52:55,840
we end so that's all good and you can

987
00:52:53,530 --> 00:52:58,900
see we actually do have the art asset

988
00:52:55,840 --> 00:53:03,280
there that we were interested in so now

989
00:52:58,900 --> 00:53:07,180
I'm gonna close that and I mean I'm

990
00:53:03,280 --> 00:53:09,250
going to bring up tab view again so I'm

991
00:53:07,179 --> 00:53:12,969
gonna go into the bonus pack here I'm

992
00:53:09,250 --> 00:53:13,809
gonna use tab view and I'm gonna say all

993
00:53:12,969 --> 00:53:21,209
right

994
00:53:13,809 --> 00:53:24,699
let's dump local HHA to local top dump

995
00:53:21,210 --> 00:53:27,480
oh right and I'll never you know what we

996
00:53:24,699 --> 00:53:34,989
should just go fix that I type it every

997
00:53:27,480 --> 00:53:38,110
single time you know you'd think so

998
00:53:34,989 --> 00:53:41,319
here's our imported file what you can

999
00:53:38,110 --> 00:53:43,180
see here hopefully just want to

1000
00:53:41,320 --> 00:53:45,580
underscore this so this is why I spent

1001
00:53:43,179 --> 00:53:49,210
the time on that HHA edit utility this

1002
00:53:45,579 --> 00:53:50,920
is just a really nice way for us to see

1003
00:53:49,210 --> 00:53:55,539
what's going on

1004
00:53:50,920 --> 00:53:57,880
right you know it gives us this nice

1005
00:53:55,539 --> 00:53:59,799
debugging visualization right off the

1006
00:53:57,880 --> 00:54:02,920
bat I can see that this is set to

1007
00:53:59,798 --> 00:54:05,199
unknown should it be I don't think so so

1008
00:54:02,920 --> 00:54:08,230
we want to go fix that you know that's

1009
00:54:05,199 --> 00:54:10,058
something to do I can sort of see that

1010
00:54:08,230 --> 00:54:13,869
at least the checksums and the dates are

1011
00:54:10,059 --> 00:54:15,430
set to something right I can look at the

1012
00:54:13,869 --> 00:54:19,829
size of the data and see if it makes

1013
00:54:15,429 --> 00:54:24,278
sense it's just it gives me a way of

1014
00:54:19,829 --> 00:54:26,349
really testing things a little more

1015
00:54:24,278 --> 00:54:27,670
deeply than I ever could stepping

1016
00:54:26,349 --> 00:54:31,000
through and looking because it's just

1017
00:54:27,670 --> 00:54:33,608
hey now we now we kind of have our a

1018
00:54:31,000 --> 00:54:37,539
little bit more of a handle on it now

1019
00:54:33,608 --> 00:54:39,818
this type unknown is bad news we need to

1020
00:54:37,539 --> 00:54:43,690
set that to bitmap so we're still we're

1021
00:54:39,818 --> 00:54:46,960
not done yet we want to do a little

1022
00:54:43,690 --> 00:54:50,409
better here with that so let's try one

1023
00:54:46,960 --> 00:54:52,809
more time at initializing our system

1024
00:54:50,409 --> 00:54:55,929
here I'm gonna do a nature to edit

1025
00:54:52,809 --> 00:55:01,289
create local data HHA and then what I'd

1026
00:54:55,929 --> 00:55:01,288
like to do is I'd like to just go into

1027
00:55:03,119 --> 00:55:07,269
the code and find out where we were

1028
00:55:05,588 --> 00:55:11,349
supposed to be setting that so that

1029
00:55:07,268 --> 00:55:14,588
information if we go to the HHA file

1030
00:55:11,349 --> 00:55:19,210
format that information was supposed to

1031
00:55:14,588 --> 00:55:21,159
tell us this bitmap sound or font right

1032
00:55:19,210 --> 00:55:23,650
it's supposed to give us a clearer

1033
00:55:21,159 --> 00:55:27,190
understanding of what this thing was

1034
00:55:23,650 --> 00:55:30,309
it's this thing here right and so no

1035
00:55:27,190 --> 00:55:35,559
one's setting that right now that's not

1036
00:55:30,309 --> 00:55:39,069
getting labeled so what I need to do is

1037
00:55:35,559 --> 00:55:42,819
I need to make sure that it is so when

1038
00:55:39,068 --> 00:55:44,650
we find that we don't have an HHA or I

1039
00:55:42,818 --> 00:55:47,259
guess even when we do we have to make

1040
00:55:44,650 --> 00:55:50,079
sure we overwrite it if it was if it in

1041
00:55:47,259 --> 00:55:52,719
all cases I think so when we come

1042
00:55:50,079 --> 00:55:56,710
through here we need to set that value

1043
00:55:52,719 --> 00:55:59,980
so when we when we're creating this part

1044
00:55:56,710 --> 00:56:03,420
in addition the tag value so we need the

1045
00:55:59,980 --> 00:56:03,420
size the offset

1046
00:56:03,570 --> 00:56:08,588
[Music]

1047
00:56:05,559 --> 00:56:13,690
you know this this could use the size

1048
00:56:08,588 --> 00:56:17,078
too even if it was less so I think we

1049
00:56:13,690 --> 00:56:19,929
want to do this here we want to set that

1050
00:56:17,079 --> 00:56:22,089
data size down to the asset data size in

1051
00:56:19,929 --> 00:56:24,789
all cases we want to just say look if

1052
00:56:22,088 --> 00:56:26,679
the data size is greater than the asset

1053
00:56:24,789 --> 00:56:28,929
data size or sorry if it's less than the

1054
00:56:26,679 --> 00:56:30,909
asset data size then we need to reserve

1055
00:56:28,929 --> 00:56:35,049
a new one but then we always truncate to

1056
00:56:30,909 --> 00:56:37,449
that size right so I think that's

1057
00:56:35,050 --> 00:56:39,818
actually more we want there this one we

1058
00:56:37,449 --> 00:56:41,500
need to always set the type and again

1059
00:56:39,818 --> 00:56:42,849
that type is just it's all it's saying

1060
00:56:41,500 --> 00:56:44,050
is that it was a bitmap because we

1061
00:56:42,849 --> 00:56:46,930
wanted to make that a little bit more

1062
00:56:44,050 --> 00:56:47,680
explicit it's like it's a bitmap keep

1063
00:56:46,929 --> 00:56:51,190
that in mind

1064
00:56:47,679 --> 00:56:53,108
right so let's try one more time with

1065
00:56:51,190 --> 00:56:56,588
that fixed and let's see if we can get

1066
00:56:53,108 --> 00:57:00,400
this thing to look appropriate I'm gonna

1067
00:56:56,588 --> 00:57:04,469
go ahead and run here this is doing the

1068
00:57:00,400 --> 00:57:08,108
import and remember it's an optimistic

1069
00:57:04,469 --> 00:57:12,039
I'll so that should have done the import

1070
00:57:08,108 --> 00:57:16,259
and now I should be able to dump that

1071
00:57:12,039 --> 00:57:19,750
out and see what it what it shows up as

1072
00:57:16,260 --> 00:57:22,559
so if I now open one of these up we can

1073
00:57:19,750 --> 00:57:24,880
now see that the bitmap is is actually

1074
00:57:22,559 --> 00:57:30,200
correctly reported it's got the correct

1075
00:57:24,880 --> 00:57:31,500
size that is how big the tiles were and

1076
00:57:30,199 --> 00:57:40,298
[Music]

1077
00:57:31,500 --> 00:57:45,010
so this looks pretty good I mean that's

1078
00:57:40,298 --> 00:57:49,088
that's good stuff right so I'm pretty

1079
00:57:45,010 --> 00:57:51,220
pleased with that so now we can check

1080
00:57:49,088 --> 00:57:52,838
the next part of the process the next

1081
00:57:51,219 --> 00:57:56,139
part of the process is can we rerun the

1082
00:57:52,838 --> 00:58:00,369
game and furthermore if if we make it

1083
00:57:56,139 --> 00:58:02,949
through the reload stage will our check

1084
00:58:00,369 --> 00:58:06,460
for changes correctly identify that we

1085
00:58:02,949 --> 00:58:08,558
do not need to import these files oh and

1086
00:58:06,460 --> 00:58:11,019
this part again - this is good we wanted

1087
00:58:08,559 --> 00:58:14,099
to know this part so let's see if we get

1088
00:58:11,019 --> 00:58:14,099
the right source file name

1089
00:58:15,650 --> 00:58:19,769
hande skeleton that is the correct

1090
00:58:18,030 --> 00:58:22,019
source file name

1091
00:58:19,769 --> 00:58:24,869
we got the sprite sheets going on there

1092
00:58:22,019 --> 00:58:27,239
we're gonna get a create the asset index

1093
00:58:24,869 --> 00:58:29,069
we're gonna write in this index say

1094
00:58:27,239 --> 00:58:40,849
that's what's currently sitting in that

1095
00:58:29,070 --> 00:58:40,850
slot oh I meant to look at that my bad

1096
00:58:43,730 --> 00:58:56,789
okay

1097
00:58:45,119 --> 00:58:59,119
so yeah I think we have now correctly we

1098
00:58:56,789 --> 00:58:59,119
do not

1099
00:59:10,579 --> 00:59:13,579
well

1100
00:59:17,269 --> 00:59:26,809
title screen oh yeah well okay right so

1101
00:59:21,530 --> 00:59:31,460
I guess I just check that yeah so we do

1102
00:59:26,809 --> 00:59:34,190
not reach and everything seems pretty

1103
00:59:31,460 --> 00:59:37,280
good the only problems we have now are I

1104
00:59:34,190 --> 00:59:39,110
I'm not seeing the actual asset so I'm

1105
00:59:37,280 --> 00:59:41,150
not sure we're actually labeling it

1106
00:59:39,110 --> 00:59:42,530
properly so we'll see about that in a

1107
00:59:41,150 --> 00:59:45,019
second here

1108
00:59:42,530 --> 00:59:47,320
and in fact we kind of note we're

1109
00:59:45,019 --> 00:59:51,849
definitely not because there's no tag

1110
00:59:47,320 --> 00:59:56,630
these are not tagged as a hand yet right

1111
00:59:51,849 --> 01:00:00,289
so we've got to do that as well all

1112
00:59:56,630 --> 01:00:04,369
right so we're getting there let's go

1113
01:00:00,289 --> 01:00:07,369
ahead and and finish up if I remember

1114
01:00:04,369 --> 01:00:09,589
correctly we had sort of this thing

1115
01:00:07,369 --> 01:00:12,199
where we searched for the the basic

1116
01:00:09,590 --> 01:00:14,870
category right and so we need to set

1117
01:00:12,199 --> 01:00:22,009
that basic category where's those tags

1118
01:00:14,869 --> 01:00:25,130
that's kind of did sort of a hacked

1119
01:00:22,010 --> 01:00:26,660
thing here for temporary testing and we

1120
01:00:25,130 --> 01:00:30,860
might as well do that so here's yeah you

1121
01:00:26,659 --> 01:00:32,989
can see the tag the tag stuff here so if

1122
01:00:30,860 --> 01:00:35,570
we wanted to make the basic category for

1123
01:00:32,989 --> 01:00:40,359
these things be hand we would just put

1124
01:00:35,570 --> 01:00:45,559
two of them on there so we would do like

1125
01:00:40,360 --> 01:00:47,829
reserved tags too and we would do like

1126
01:00:45,559 --> 01:00:47,829
this

1127
01:00:51,679 --> 01:01:07,339
I don't remember what this was exactly

1128
01:00:59,030 --> 01:01:09,410
but it's like that I think so if we

1129
01:01:07,340 --> 01:01:12,079
wanted to say as a hand we could do that

1130
01:01:09,409 --> 01:01:19,819
we look like this when we actually go to

1131
01:01:12,079 --> 01:01:21,769
make the tag the tag buffers here the

1132
01:01:19,820 --> 01:01:24,710
difference would be that this is a plus

1133
01:01:21,769 --> 01:01:28,309
two so each one gets two tags now and

1134
01:01:24,710 --> 01:01:40,130
now if we reran that import that's what

1135
01:01:28,309 --> 01:01:44,809
we would get right so let's do it and I

1136
01:01:40,130 --> 01:01:50,480
should be able to now go look at well

1137
01:01:44,809 --> 01:01:53,809
and there's the there's the whatever it

1138
01:01:50,480 --> 01:01:55,099
the little test bitmap there and now

1139
01:01:53,809 --> 01:01:58,219
let's see what happens if I run a second

1140
01:01:55,099 --> 01:01:59,809
time it's still there so I think we're

1141
01:01:58,219 --> 01:02:05,119
in good shape right I mean I think

1142
01:01:59,809 --> 01:02:09,799
that's starting to be respectable and if

1143
01:02:05,119 --> 01:02:12,319
we now go look up blue angels again

1144
01:02:09,800 --> 01:02:16,400
today if we now go look at what's in the

1145
01:02:12,320 --> 01:02:17,660
file we should see yeah the basic

1146
01:02:16,400 --> 01:02:19,639
categories there as well as face

1147
01:02:17,659 --> 01:02:21,859
Direction each one of these should also

1148
01:02:19,639 --> 01:02:25,940
now have the information about where it

1149
01:02:21,860 --> 01:02:32,090
came for a minute what's a little weird

1150
01:02:25,940 --> 01:02:32,240
as I'm not seeing any of that oh yes I

1151
01:02:32,090 --> 01:02:34,010
am

1152
01:02:32,239 --> 01:02:36,739
there it is it's the from field I'm like

1153
01:02:34,010 --> 01:02:39,050
where is that go hand glove Oh - right

1154
01:02:36,739 --> 01:02:44,329
oh three and those are correct first

1155
01:02:39,050 --> 01:02:51,650
column third row uh so I think that's

1156
01:02:44,329 --> 01:02:56,119
all good now yeah and I think for mostly

1157
01:02:51,650 --> 01:03:00,380
there the next thing I want to do we've

1158
01:02:56,119 --> 01:03:04,159
got that weird it's we're not our ours

1159
01:03:00,380 --> 01:03:05,570
and our bees are flipped around we right

1160
01:03:04,159 --> 01:03:07,969
so we kind of need

1161
01:03:05,570 --> 01:03:12,470
do a Swizzle on the R&amp;B channel when we

1162
01:03:07,969 --> 01:03:15,199
import from the PNG so that's a little

1163
01:03:12,469 --> 01:03:18,529
bit annoying but we got to do that and

1164
01:03:15,199 --> 01:03:20,149
the other thing that we need to do is we

1165
01:03:18,530 --> 01:03:29,900
need to think about if we want a down

1166
01:03:20,150 --> 01:03:33,769
sample this is a bit annoying and let me

1167
01:03:29,900 --> 01:03:40,430
just let me just give you the background

1168
01:03:33,769 --> 01:03:42,019
of what the problem is and this is a

1169
01:03:40,429 --> 01:03:44,629
place where we kind of want to just say

1170
01:03:42,019 --> 01:03:46,009
look we'll we'll do what something

1171
01:03:44,630 --> 01:03:49,180
reasonable we don't want to go overboard

1172
01:03:46,010 --> 01:03:49,180
on it

1173
01:03:56,679 --> 01:04:02,190
mm-hmm so this is

1174
01:04:13,309 --> 01:04:19,110
okay so we now have a problem that we

1175
01:04:16,860 --> 01:04:21,230
have not had to confront before but we

1176
01:04:19,110 --> 01:04:24,450
will have to confront it soon the

1177
01:04:21,230 --> 01:04:30,269
problem is that the art assets are made

1178
01:04:24,449 --> 01:04:36,389
at 1024 by 1024 by 4 right this is the

1179
01:04:30,269 --> 01:04:42,989
width this is the height this is the

1180
01:04:36,389 --> 01:04:49,670
bits per pixel it doesn't take a math

1181
01:04:42,989 --> 01:04:49,669
savant to know that this is one megabyte

1182
01:04:49,760 --> 01:04:56,370
right 1024 x 1024 so if you take one

1183
01:04:54,119 --> 01:05:03,389
megabyte and you multiply it by 4 you

1184
01:04:56,369 --> 01:05:06,539
get 4 megabytes that means that every

1185
01:05:03,389 --> 01:05:12,079
sprite in our game is 4 megabytes of

1186
01:05:06,539 --> 01:05:14,820
data right at its source resolution the

1187
01:05:12,079 --> 01:05:21,299
resolution of our screen at the moment

1188
01:05:14,820 --> 01:05:23,250
is 1920 by 1080 that means that every

1189
01:05:21,300 --> 01:05:26,789
sprite in our game is made at a

1190
01:05:23,250 --> 01:05:36,050
resolution that would occupy roughly

1191
01:05:26,789 --> 01:05:36,050
this much of the screen okay way too big

1192
01:05:40,119 --> 01:05:45,699
does this matter for us in terms of

1193
01:05:42,789 --> 01:05:47,650
rendering no why doesn't it matter in

1194
01:05:45,699 --> 01:05:49,599
terms of rendering it doesn't matter in

1195
01:05:47,650 --> 01:05:51,519
terms of rendering because it would be

1196
01:05:49,599 --> 01:05:54,400
very simple for us to turn mipmapping

1197
01:05:51,519 --> 01:05:57,639
on we could down sample our sprites at

1198
01:05:54,400 --> 01:06:00,190
runtime very easily graphics cards can

1199
01:05:57,639 --> 01:06:02,230
do this on transfer almost they just do

1200
01:06:00,190 --> 01:06:06,460
a quick series of renderers and generate

1201
01:06:02,230 --> 01:06:06,730
it there's it's very easy to do all

1202
01:06:06,460 --> 01:06:09,250
right

1203
01:06:06,730 --> 01:06:13,240
and so we could down sample just in time

1204
01:06:09,250 --> 01:06:14,559
and then you know it would first cut it

1205
01:06:13,239 --> 01:06:17,099
in half and then cut it in half again

1206
01:06:14,559 --> 01:06:22,119
and now that's probably the right size

1207
01:06:17,099 --> 01:06:24,039
right so and just to be clear what I'm

1208
01:06:22,119 --> 01:06:26,139
talking about there is we don't want to

1209
01:06:24,039 --> 01:06:28,269
feed this texture and then render at

1210
01:06:26,139 --> 01:06:30,969
this size because the sampling will be

1211
01:06:28,269 --> 01:06:33,909
lousy it'll be all crackly and weird and

1212
01:06:30,969 --> 01:06:36,459
not properly anti-alias at all right so

1213
01:06:33,909 --> 01:06:40,259
we need to do filtering down to sizes

1214
01:06:36,460 --> 01:06:43,300
probably down to probably a 256 by 256

1215
01:06:40,260 --> 01:06:46,810
right is probably more in the ballpark

1216
01:06:43,300 --> 01:06:50,100
of what we want to start with some are

1217
01:06:46,809 --> 01:06:54,369
between 128 128 286 somewhere in there

1218
01:06:50,099 --> 01:07:02,980
so we could do that the problem we have

1219
01:06:54,369 --> 01:07:04,900
is the streaming streaming in four

1220
01:07:02,980 --> 01:07:11,800
megabytes for sprite isn't gonna fly

1221
01:07:04,900 --> 01:07:16,650
right let's suppose that there are 200

1222
01:07:11,800 --> 01:07:16,650
sprites or 300 sprites on the screen

1223
01:07:16,829 --> 01:07:30,730
that we need to load well 300 sprites

1224
01:07:22,500 --> 01:07:35,949
times 4 megabytes right equals 1.2

1225
01:07:30,730 --> 01:07:41,590
gigabytes am i doing that math right

1226
01:07:35,949 --> 01:07:43,989
right 1.2 gigabytes is way beyond the

1227
01:07:41,590 --> 01:07:49,120
streaming limit in any reasonable amount

1228
01:07:43,989 --> 01:07:52,119
of time of older series drives right now

1229
01:07:49,119 --> 01:07:53,739
if you're an m2 if you're an nvme like

1230
01:07:52,119 --> 01:07:59,019
m2 drive or MVM

1231
01:07:53,739 --> 01:08:02,139
PCI like a PCIe Drive no problem that

1232
01:07:59,019 --> 01:08:06,639
takes like one second right this is like

1233
01:08:02,139 --> 01:08:10,900
a second or less so no big deal

1234
01:08:06,639 --> 01:08:13,299
nvme X point whatever like any of these

1235
01:08:10,900 --> 01:08:17,798
advanced drive technologies SSD drive

1236
01:08:13,300 --> 01:08:19,810
technologies on the fast buses 1.2

1237
01:08:17,798 --> 01:08:22,778
gigabytes is not they don't even care

1238
01:08:19,810 --> 01:08:24,220
right it's no big deal it would only

1239
01:08:22,779 --> 01:08:28,120
take a second to stream that in and

1240
01:08:24,220 --> 01:08:30,430
you're off and running right so we'd be

1241
01:08:28,119 --> 01:08:32,640
able to startup go and it would just be

1242
01:08:30,430 --> 01:08:32,640
fine

1243
01:08:32,909 --> 01:08:43,568
but for older drives this is probably

1244
01:08:39,159 --> 01:08:46,568
gonna be too much right so if you take a

1245
01:08:43,569 --> 01:08:48,880
look I'm just trying to think of like

1246
01:08:46,569 --> 01:08:53,920
what an example would be in terms of a

1247
01:08:48,880 --> 01:09:06,190
minimum platform what is like HDD read

1248
01:08:53,920 --> 01:09:08,670
speed right now for example pop it up on

1249
01:09:06,189 --> 01:09:08,669
here

1250
01:09:09,949 --> 01:09:13,148
[Music]

1251
01:09:14,009 --> 01:09:19,838
so here we go

1252
01:09:17,048 --> 01:09:21,960
so we're talking about something like

1253
01:09:19,838 --> 01:09:25,539
let's say worst case is like 50

1254
01:09:21,960 --> 01:09:28,149
megabytes per second or even a hundred

1255
01:09:25,539 --> 01:09:30,250
megabytes per second so at a hundred

1256
01:09:28,149 --> 01:09:34,000
megabytes per second we're looking at

1257
01:09:30,250 --> 01:09:42,789
twelve seconds right to load in this

1258
01:09:34,000 --> 01:09:45,548
thing it's a little scary it's just it's

1259
01:09:42,789 --> 01:09:48,488
a little scary and we know we don't ever

1260
01:09:45,548 --> 01:09:52,448
need it to be that big we're not gonna

1261
01:09:48,488 --> 01:09:54,698
draw sprites at that size pretty much

1262
01:09:52,448 --> 01:09:56,198
ever right

1263
01:09:54,698 --> 01:09:58,178
the only things we'd be drawing if those

1264
01:09:56,198 --> 01:10:00,210
sides are not our sprites they're like

1265
01:09:58,179 --> 01:10:04,359
special case stuff like the title screen

1266
01:10:00,210 --> 01:10:07,810
you know I'm saying so I think

1267
01:10:04,359 --> 01:10:10,929
fundamentally speaking we want to

1268
01:10:07,810 --> 01:10:13,929
perhaps downsample our artwork right off

1269
01:10:10,929 --> 01:10:17,590
the bat like we may want to have the

1270
01:10:13,929 --> 01:10:21,130
size of our artwork because let's

1271
01:10:17,590 --> 01:10:26,590
suppose that instead of this we did

1272
01:10:21,130 --> 01:10:29,349
everything at 512 by 512 by 4 right

1273
01:10:26,590 --> 01:10:39,010
so we reduce each of these dimensions by

1274
01:10:29,349 --> 01:10:42,190
two well then it's one megabyte per and

1275
01:10:39,010 --> 01:10:46,360
if it's one megabyte per suddenly this

1276
01:10:42,189 --> 01:10:49,899
looks a lot better right this now looks

1277
01:10:46,359 --> 01:10:53,289
like three hundred Meg's which is

1278
01:10:49,899 --> 01:10:56,259
something like you know three seconds at

1279
01:10:53,289 --> 01:11:06,840
a hundred megabytes a second or six

1280
01:10:56,260 --> 01:11:06,840
seconds right at at fifty

1281
01:11:07,560 --> 01:11:11,370
so this is starting to look a lot better

1282
01:11:09,210 --> 01:11:13,289
especially because we're streaming so we

1283
01:11:11,369 --> 01:11:16,619
can bring those things in more gradually

1284
01:11:13,289 --> 01:11:20,130
it's not as bad furthermore if we reduce

1285
01:11:16,619 --> 01:11:23,579
it down again same thing right if 256 by

1286
01:11:20,130 --> 01:11:30,659
256 by 4 that is even better

1287
01:11:23,579 --> 01:11:34,920
that's 286 k right that's that's a 1/4

1288
01:11:30,659 --> 01:11:36,960
megabyte and it further reduces this

1289
01:11:34,920 --> 01:11:38,760
into a fraction of a second right at a

1290
01:11:36,960 --> 01:11:43,199
reasonable harddrive rate we're looking

1291
01:11:38,760 --> 01:11:45,440
at less than a second to stream in 300

1292
01:11:43,199 --> 01:11:45,439
of them

1293
01:11:47,449 --> 01:11:59,159
these aren't perfect measurements hard

1294
01:11:52,229 --> 01:12:00,719
drives have trouble with seeking so it's

1295
01:11:59,159 --> 01:12:03,149
worth noting that this is not really

1296
01:12:00,720 --> 01:12:05,130
necessarily fair the seek times can be

1297
01:12:03,149 --> 01:12:08,909
pretty bad depending on the the

1298
01:12:05,130 --> 01:12:11,850
situations SSD drives the situation gets

1299
01:12:08,909 --> 01:12:15,359
a lot better 550 megabytes a second and

1300
01:12:11,850 --> 01:12:19,110
up write 5 to 50 megabytes second is for

1301
01:12:15,359 --> 01:12:23,729
SSDs not on a good bus they're they're

1302
01:12:19,109 --> 01:12:30,210
not on like a PCIe lanes this is for

1303
01:12:23,729 --> 01:12:32,309
like SATA right so if we assume that it

1304
01:12:30,210 --> 01:12:33,510
only gets better from there and that a

1305
01:12:32,310 --> 01:12:35,370
lot of times people wouldn't be running

1306
01:12:33,510 --> 01:12:37,440
them on these then you know you can see

1307
01:12:35,369 --> 01:12:39,479
that to justify 26 is a really easy

1308
01:12:37,439 --> 01:12:44,399
sweet spot to be in we probably won't

1309
01:12:39,479 --> 01:12:49,199
hit any trouble I would imagine 512 by

1310
01:12:44,399 --> 01:12:54,509
512 is probably okay 1024 by 1024 by 4 I

1311
01:12:49,199 --> 01:12:56,819
just don't think it's feasible what we

1312
01:12:54,510 --> 01:12:59,730
would have to do is try to compress that

1313
01:12:56,819 --> 01:13:01,319
down run it through like a PNG style

1314
01:12:59,729 --> 01:13:05,189
compressor or something if we wanted

1315
01:13:01,319 --> 01:13:08,969
lossless or DX T texture compression if

1316
01:13:05,189 --> 01:13:10,979
we wanted lossy and just reduce the size

1317
01:13:08,970 --> 01:13:14,010
that way but what we would have to do

1318
01:13:10,979 --> 01:13:14,759
something right look we have to do

1319
01:13:14,010 --> 01:13:17,400
something

1320
01:13:14,760 --> 01:13:19,969
either we compress the textures someway

1321
01:13:17,399 --> 01:13:24,799
lossy or lossless to get it down for

1322
01:13:19,969 --> 01:13:27,289
from what it is or or more or we down

1323
01:13:24,800 --> 01:13:28,969
sample and down sampling just seems like

1324
01:13:27,289 --> 01:13:31,219
a good thing to start with at least a

1325
01:13:28,969 --> 01:13:32,000
512 by $5 for because it just doesn't

1326
01:13:31,219 --> 01:13:34,698
make any sense

1327
01:13:32,000 --> 01:13:37,609
to store things at 10 20 right 1024 now

1328
01:13:34,698 --> 01:13:40,729
why did I have the art done at 1024 high

1329
01:13:37,609 --> 01:13:45,319
temperature sorry that it never hurts to

1330
01:13:40,729 --> 01:13:48,529
over sample on the artwork who knows in

1331
01:13:45,319 --> 01:13:52,099
four years we might want to do the 8k

1332
01:13:48,529 --> 01:13:54,139
remaster of handmade hero and all the

1333
01:13:52,100 --> 01:13:56,840
drives are nvme were drives and they

1334
01:13:54,140 --> 01:13:59,440
read at 5 gigabytes a second and we want

1335
01:13:56,840 --> 01:14:01,940
all our sprites to be 1024 by 1024 by 4

1336
01:13:59,439 --> 01:14:04,869
because it just looks crispy er and

1337
01:14:01,939 --> 01:14:07,669
nicer with those beautiful pixels right

1338
01:14:04,869 --> 01:14:11,689
so you never want to have your artists

1339
01:14:07,670 --> 01:14:14,359
do the sprites at exactly the resolution

1340
01:14:11,689 --> 01:14:16,039
that you're gonna use you wanted to have

1341
01:14:14,359 --> 01:14:19,210
them do the sprites at a resolution

1342
01:14:16,039 --> 01:14:22,100
higher than that and downsample unless

1343
01:14:19,210 --> 01:14:24,140
you need them to be finicky about every

1344
01:14:22,100 --> 01:14:26,180
individual pixel right like if you're

1345
01:14:24,140 --> 01:14:28,010
doing pixel art they've got to know what

1346
01:14:26,180 --> 01:14:31,329
the resolution is but if you're doing

1347
01:14:28,010 --> 01:14:34,909
can drawn like full painted bitmap stuff

1348
01:14:31,329 --> 01:14:36,680
you wanna up res because you're gonna

1349
01:14:34,909 --> 01:14:38,569
want higher quality art assets in the

1350
01:14:36,680 --> 01:14:41,449
future almost certainly if you ever do a

1351
01:14:38,569 --> 01:14:44,299
remaster it's pretty free for the artist

1352
01:14:41,448 --> 01:14:46,698
to just set the bitmap size in Photoshop

1353
01:14:44,300 --> 01:14:52,219
to be twice as large as they were gonna

1354
01:14:46,698 --> 01:14:53,569
use or four times as large and with the

1355
01:14:52,219 --> 01:14:56,029
exception of the fact that Photoshop

1356
01:14:53,569 --> 01:15:00,139
tends to be way too slow because it's

1357
01:14:56,029 --> 01:15:04,250
extremely unoptimized other than that it

1358
01:15:00,140 --> 01:15:06,469
tends to be fine so that's all I want to

1359
01:15:04,250 --> 01:15:08,359
say so I kind of feel like we should

1360
01:15:06,469 --> 01:15:11,480
take our art assets here and maybe

1361
01:15:08,359 --> 01:15:13,579
downsample them because of that loading

1362
01:15:11,479 --> 01:15:15,529
pressure and like I said the only other

1363
01:15:13,579 --> 01:15:18,319
option would be to use some kind of some

1364
01:15:15,529 --> 01:15:19,550
other kind of compression I'm just not

1365
01:15:18,319 --> 01:15:21,529
sure I want to go that route because

1366
01:15:19,550 --> 01:15:23,989
again it over complicates the path at

1367
01:15:21,529 --> 01:15:26,238
this point we can certainly do more with

1368
01:15:23,988 --> 01:15:28,909
compression later on if we want to I

1369
01:15:26,238 --> 01:15:32,428
just don't know that now is the time for

1370
01:15:28,909 --> 01:15:37,349
that so I'm kind of thinking that

1371
01:15:32,429 --> 01:15:41,550
I just really I don't know that I wanna

1372
01:15:37,350 --> 01:15:45,239
I don't know that I want to dive into

1373
01:15:41,550 --> 01:15:47,640
compression at this point right uh so

1374
01:15:45,238 --> 01:15:51,389
taking a look at this what we need to do

1375
01:15:47,640 --> 01:15:56,130
if we wanted to make that happen is once

1376
01:15:51,390 --> 01:15:59,940
we identify one of these one of these

1377
01:15:56,130 --> 01:16:04,760
cells as having something in it when we

1378
01:15:59,939 --> 01:16:10,349
get to this part right and we're and

1379
01:16:04,760 --> 01:16:13,800
we're going to when we're going to

1380
01:16:10,350 --> 01:16:16,230
actually use the image what we can do is

1381
01:16:13,800 --> 01:16:19,949
produce a down sampled version right at

1382
01:16:16,229 --> 01:16:23,069
that time and there's a lot of different

1383
01:16:19,948 --> 01:16:25,229
ways that we can down sample I will

1384
01:16:23,069 --> 01:16:27,719
probably pick a box filter for now but

1385
01:16:25,229 --> 01:16:29,129
there are other ways of sampling and it

1386
01:16:27,719 --> 01:16:32,939
really depends on what you're trying to

1387
01:16:29,130 --> 01:16:36,380
do there's a lot of different filters I

1388
01:16:32,939 --> 01:16:42,059
even have my own filter that I've made

1389
01:16:36,380 --> 01:16:44,400
that I use for certain purposes and you

1390
01:16:42,060 --> 01:16:47,190
can play around with this stuff a lot

1391
01:16:44,399 --> 01:16:48,929
it's not worth going into too much

1392
01:16:47,189 --> 01:16:51,599
detail right now but I just want to

1393
01:16:48,929 --> 01:16:56,310
bring that up so let's go ahead and take

1394
01:16:51,600 --> 01:16:59,310
a look at how that would work if there's

1395
01:16:56,310 --> 01:17:01,710
something in the tile I want basically a

1396
01:16:59,310 --> 01:17:05,489
down sample and flip I know I need to

1397
01:17:01,710 --> 01:17:08,698
reverse the R&amp;B channels on a pinch on a

1398
01:17:05,488 --> 01:17:13,019
ping so what I want to do here is I want

1399
01:17:08,698 --> 01:17:16,229
to load in the RG and B and a I want to

1400
01:17:13,020 --> 01:17:18,480
down sample them and then I want to

1401
01:17:16,229 --> 01:17:20,939
write them out and the other thing that

1402
01:17:18,479 --> 01:17:24,448
I want to do and I don't really know

1403
01:17:20,939 --> 01:17:27,059
which way this it's a little frustrating

1404
01:17:24,448 --> 01:17:33,539
I don't necessarily know what the format

1405
01:17:27,060 --> 01:17:36,449
in ping implies I'm not quite sure

1406
01:17:33,539 --> 01:17:38,760
whether I should pre multiply the alpha

1407
01:17:36,448 --> 01:17:41,629
again or whether the Alpha whether the

1408
01:17:38,760 --> 01:17:44,730
PNG has the alpha pre multiplet or not

1409
01:17:41,630 --> 01:17:45,480
fortunately for me when we step through

1410
01:17:44,729 --> 01:17:48,059
in the debugger

1411
01:17:45,479 --> 01:17:50,909
should be obvious whether it's primo

1412
01:17:48,060 --> 01:17:53,010
flight or not because if we ever see a

1413
01:17:50,909 --> 01:17:57,420
color value higher than the Alpha value

1414
01:17:53,010 --> 01:18:00,810
88 premultiplied right because if it's

1415
01:17:57,420 --> 01:18:05,069
premultiplied it should line up directly

1416
01:18:00,810 --> 01:18:10,080
with the Alpha right the brightest you

1417
01:18:05,069 --> 01:18:11,880
can be is the Alpha Channel is that time

1418
01:18:10,079 --> 01:18:13,079
we always a case not necessarily it may

1419
01:18:11,880 --> 01:18:15,420
be that they were using some kind of

1420
01:18:13,079 --> 01:18:17,750
mechanic or that we didn't understand

1421
01:18:15,420 --> 01:18:19,760
and so the gamma curve is putting the

1422
01:18:17,750 --> 01:18:23,340
[Music]

1423
01:18:19,760 --> 01:18:25,739
the RGB above the Alpha because it's

1424
01:18:23,340 --> 01:18:27,900
gamma corrected after the pre-multiply I

1425
01:18:25,738 --> 01:18:29,189
mean I know this I could make up a

1426
01:18:27,899 --> 01:18:31,259
situation in which that wouldn't be true

1427
01:18:29,189 --> 01:18:33,419
but for the most part we should not be

1428
01:18:31,260 --> 01:18:35,940
seeing very high color values and very

1429
01:18:33,420 --> 01:18:38,159
low alpha values that's a clear telltale

1430
01:18:35,939 --> 01:18:40,139
sign that they are not pre multiplied if

1431
01:18:38,159 --> 01:18:41,699
we never see a color value higher than

1432
01:18:40,140 --> 01:18:45,020
an alpha value that's a pretty good

1433
01:18:41,699 --> 01:18:47,159
indication that they are P multiplied I

1434
01:18:45,020 --> 01:18:50,430
think that's the best I can give you at

1435
01:18:47,159 --> 01:18:55,109
the moment all right so let's take a

1436
01:18:50,430 --> 01:18:57,030
look we now would need we would need

1437
01:18:55,109 --> 01:19:01,319
when we come in here we've got a temper

1438
01:18:57,029 --> 01:19:03,738
Reena what I would like to do is you

1439
01:19:01,319 --> 01:19:08,819
know if we've got this pixel buffer here

1440
01:19:03,738 --> 01:19:12,389
we already do copy out into the pixel

1441
01:19:08,819 --> 01:19:21,539
buffer right that's what this thing's

1442
01:19:12,390 --> 01:19:23,100
doing and so I guess I guess we could

1443
01:19:21,539 --> 01:19:24,810
just push a second one of those on

1444
01:19:23,100 --> 01:19:28,860
that's our that's our downscale buffer

1445
01:19:24,810 --> 01:19:33,989
we could down sample in place if we

1446
01:19:28,859 --> 01:19:35,210
wanted to though and maybe we just

1447
01:19:33,988 --> 01:19:39,169
should

1448
01:19:35,210 --> 01:19:39,170
there's really no harm in it

1449
01:19:41,859 --> 01:19:45,130
yeah so we could just downsample in

1450
01:19:43,750 --> 01:19:50,619
place as well so maybe we'll just do

1451
01:19:45,130 --> 01:19:54,039
that so anyway when we look here and we

1452
01:19:50,619 --> 01:19:55,359
we take a look what's going on I'm just

1453
01:19:54,039 --> 01:19:57,670
gonna write a down sample in place

1454
01:19:55,359 --> 01:19:59,349
because why not so what if down sample

1455
01:19:57,670 --> 01:20:01,300
in place looks like is once we've copied

1456
01:19:59,350 --> 01:20:03,579
these things out into this pixel buffer

1457
01:20:01,300 --> 01:20:05,680
what I can do is I can just loop over

1458
01:20:03,579 --> 01:20:09,550
the size of the downsampled pixel buffer

1459
01:20:05,680 --> 01:20:12,490
right so what I would do here is say

1460
01:20:09,550 --> 01:20:18,670
okay my X is 0 my X is less than the

1461
01:20:12,489 --> 01:20:28,119
half tiled in plus plus X loop over the

1462
01:20:18,670 --> 01:20:30,279
rows and what you can see here is for

1463
01:20:28,119 --> 01:20:33,099
every tile I'm just gonna go through and

1464
01:20:30,279 --> 01:20:35,800
I'm gonna make a quarter sized version

1465
01:20:33,100 --> 01:20:37,450
of it so I'm gonna go through half of

1466
01:20:35,800 --> 01:20:49,180
everything I would have gone through in

1467
01:20:37,449 --> 01:20:51,849
the normal case okay so in the when I go

1468
01:20:49,180 --> 01:20:55,980
to actually produce a pixel what I want

1469
01:20:51,850 --> 01:21:01,960
to do here is I want to read four pixels

1470
01:20:55,979 --> 01:21:08,709
right and I want to filter them together

1471
01:21:01,960 --> 01:21:11,439
and then write them out so what I want

1472
01:21:08,710 --> 01:21:14,920
to do is say okay let's get my source

1473
01:21:11,439 --> 01:21:18,849
pixels out of here I can if I want to

1474
01:21:14,920 --> 01:21:22,960
actually do sort of the the row based

1475
01:21:18,850 --> 01:21:27,570
version here and help what that would

1476
01:21:22,960 --> 01:21:27,569
look like I say okay let's take

1477
01:21:34,698 --> 01:21:43,678
probably do it like this as well and now

1478
01:21:42,208 --> 01:21:45,929
I think about two if we want this thing

1479
01:21:43,679 --> 01:21:48,868
to be a block I would actually need it

1480
01:21:45,929 --> 01:21:53,880
to be compacted so now I think about it

1481
01:21:48,868 --> 01:21:56,478
I actually do need it to be smaller

1482
01:21:53,880 --> 01:22:03,479
right I need it to be like one smaller

1483
01:21:56,479 --> 01:22:06,749
then well no I can still write it in

1484
01:22:03,479 --> 01:22:08,400
place though so never mind

1485
01:22:06,748 --> 01:22:10,649
no I can still write it in place it

1486
01:22:08,399 --> 01:22:14,609
doesn't matter all right

1487
01:22:10,649 --> 01:22:16,558
um sue if I take the pixel buffer that's

1488
01:22:14,609 --> 01:22:18,719
the destination this is where the image

1489
01:22:16,559 --> 01:22:20,550
currently exists if I take the pixel

1490
01:22:18,719 --> 01:22:24,239
buffer and then I use the pixel buffer

1491
01:22:20,550 --> 01:22:28,139
and the pixel buffer plus one row like

1492
01:22:24,238 --> 01:22:35,658
right one entire X stride so this is

1493
01:22:28,139 --> 01:22:40,519
basically like the the tile dimension I

1494
01:22:35,658 --> 01:22:40,518
guess could actually do it this way so

1495
01:22:43,849 --> 01:22:49,288
here's the first row of the tile here's

1496
01:22:47,760 --> 01:22:51,030
the second row of the tile and here's

1497
01:22:49,288 --> 01:22:55,109
again the first row that I'm writing out

1498
01:22:51,029 --> 01:22:58,759
I'm writing it out so what I can do is I

1499
01:22:55,109 --> 01:23:02,219
can now say like you know read pixel and

1500
01:22:58,760 --> 01:23:07,519
I think we've got I believe actually

1501
01:23:02,219 --> 01:23:14,429
have a thing that's like linear like

1502
01:23:07,519 --> 01:23:15,570
upconvert kind of thing don't actually

1503
01:23:14,429 --> 01:23:17,550
know where it is

1504
01:23:15,569 --> 01:23:19,558
I thought we have I mean we we've got

1505
01:23:17,550 --> 01:23:22,050
those linear eyes but I don't know if we

1506
01:23:19,559 --> 01:23:29,189
have actually ones that unpack there it

1507
01:23:22,050 --> 01:23:35,668
is so here if I want to unpack the value

1508
01:23:29,189 --> 01:23:39,959
I can call rgba unpack right and that

1509
01:23:35,668 --> 01:23:43,519
will get me back a v4 so I can load all

1510
01:23:39,958 --> 01:23:43,519
my pixels in like so

1511
01:23:48,199 --> 01:23:57,750
so let's load in two pixels from the

1512
01:23:52,319 --> 01:24:07,229
first row and two pixels from the second

1513
01:23:57,750 --> 01:24:09,180
row so this gives me four pixels

1514
01:24:07,229 --> 01:24:12,029
it gives me two from the first row two

1515
01:24:09,180 --> 01:24:14,400
from the second row and then I can

1516
01:24:12,029 --> 01:24:18,409
choose to do with those what I wish so

1517
01:24:14,399 --> 01:24:22,859
if we assume these were stored in srgb

1518
01:24:18,409 --> 01:24:26,250
what I can do here is I can actually do

1519
01:24:22,859 --> 01:24:28,799
sort of an sRGB convert I can move them

1520
01:24:26,250 --> 01:24:30,449
to linear and then move them back so if

1521
01:24:28,800 --> 01:24:33,119
I want to do the blend in the proper

1522
01:24:30,449 --> 01:24:35,970
space I can choose to do that which

1523
01:24:33,119 --> 01:24:38,430
seems like a good idea to me looking at

1524
01:24:35,970 --> 01:24:42,960
what happens when I do the unpack so if

1525
01:24:38,430 --> 01:24:45,390
I come down here you can see the unpack

1526
01:24:42,960 --> 01:24:49,829
leaves them in the 255 space so let me

1527
01:24:45,390 --> 01:24:51,600
go to a linearize here so if I do if I

1528
01:24:49,829 --> 01:24:57,960
do these two operations that's my

1529
01:24:51,600 --> 01:25:02,250
compliment that would allow me to that

1530
01:24:57,960 --> 01:25:05,039
would allow me to basically do the

1531
01:25:02,250 --> 01:25:06,539
blending in a somewhat sRGB corrected

1532
01:25:05,039 --> 01:25:07,859
space remember this is approximate

1533
01:25:06,539 --> 01:25:11,909
because we just use square so none

1534
01:25:07,859 --> 01:25:13,619
squares it's not real srgb so if I want

1535
01:25:11,909 --> 01:25:16,319
to do these unpacks here that would

1536
01:25:13,619 --> 01:25:22,460
unpack my pixels I could then go ahead

1537
01:25:16,319 --> 01:25:26,509
and change my pixels to be linearized

1538
01:25:22,460 --> 01:25:26,510
just by passing them all through

1539
01:25:31,979 --> 01:25:41,988
and so when I do this srgb to linear one

1540
01:25:34,560 --> 01:25:53,850
the other thing could do is swap them I

1541
01:25:41,988 --> 01:25:56,849
don't know where that function is so

1542
01:25:53,850 --> 01:26:02,750
that's just this we could make that a

1543
01:25:56,850 --> 01:26:06,409
shared function let's just grab that out

1544
01:26:02,750 --> 01:26:06,408
and put that share

1545
01:26:15,719 --> 01:26:28,719
let's put it down to pack Oh and

1546
01:26:24,819 --> 01:26:30,309
actually but we wouldn't really need to

1547
01:26:28,719 --> 01:26:38,130
call it would be because we could also

1548
01:26:30,310 --> 01:26:38,130
use the inverse unpacking interesting

1549
01:26:38,460 --> 01:26:46,000
interesting so really what we could do

1550
01:26:41,439 --> 01:26:49,988
here is say well alright when we do RGB

1551
01:26:46,000 --> 01:26:53,189
a unpack right that's gonna unpack the

1552
01:26:49,988 --> 01:26:58,479
are the the bottom channel into our

1553
01:26:53,189 --> 01:27:00,428
right which is actually what we want so

1554
01:26:58,479 --> 01:27:06,309
we don't need to swap them because the

1555
01:27:00,429 --> 01:27:11,349
unpack we'll swap them for us right then

1556
01:27:06,310 --> 01:27:13,360
when we do the packing we just have to

1557
01:27:11,349 --> 01:27:15,730
make sure that we pack them back into

1558
01:27:13,359 --> 01:27:18,719
the correct place because right now it's

1559
01:27:15,729 --> 01:27:22,328
ours in the bottom channel its RGB a

1560
01:27:18,719 --> 01:27:24,429
right and then when we pack it back out

1561
01:27:22,328 --> 01:27:28,000
we just want to make sure we pack it

1562
01:27:24,429 --> 01:27:30,520
back out in BGR a pack so really this

1563
01:27:28,000 --> 01:27:35,679
probably will just work hopefully he

1564
01:27:30,520 --> 01:27:37,989
says not really knowing but once we

1565
01:27:35,679 --> 01:27:43,929
produce the color value hopefully that

1566
01:27:37,988 --> 01:27:46,809
works it might who knows so we unpack

1567
01:27:43,929 --> 01:27:49,420
linearise blend which we haven't done

1568
01:27:46,810 --> 01:27:51,699
yet and then pack that should give us a

1569
01:27:49,420 --> 01:27:54,969
downsampled and color corrected version

1570
01:27:51,698 --> 01:28:01,598
I'm sorry and color swapped our R&amp;B

1571
01:27:54,969 --> 01:28:03,578
version of what we want right so to do

1572
01:28:01,599 --> 01:28:05,800
that we just need a way to blend these

1573
01:28:03,578 --> 01:28:10,569
let's just start with the obvious the

1574
01:28:05,800 --> 01:28:16,300
blended color can just be all these

1575
01:28:10,569 --> 01:28:17,319
things added together right so all we're

1576
01:28:16,300 --> 01:28:18,820
doing here is saying switch them all

1577
01:28:17,319 --> 01:28:20,799
together divide by four is take the

1578
01:28:18,819 --> 01:28:22,359
average it's a simple box filter it's

1579
01:28:20,800 --> 01:28:25,800
the bit most basic filter you can

1580
01:28:22,359 --> 01:28:27,909
possibly apply it has really no

1581
01:28:25,800 --> 01:28:30,400
characteristics that are gonna create

1582
01:28:27,909 --> 01:28:31,840
spurious artifacts but it tends to blur

1583
01:28:30,399 --> 01:28:33,869
things maybe a little more than you

1584
01:28:31,840 --> 01:28:37,630
would like right

1585
01:28:33,869 --> 01:28:40,420
that's its property because it doesn't

1586
01:28:37,630 --> 01:28:42,909
look at any wider area of the image to

1587
01:28:40,420 --> 01:28:44,079
see whether this was a like a hard edge

1588
01:28:42,909 --> 01:28:46,359
or something that it should try to

1589
01:28:44,079 --> 01:28:48,519
preserve it just smooches down probably

1590
01:28:46,359 --> 01:28:57,969
will be fine for our proces we will see

1591
01:28:48,520 --> 01:29:01,510
here's the down sample though down

1592
01:28:57,970 --> 01:29:05,610
something by 2x once we do that I guess

1593
01:29:01,510 --> 01:29:05,610
we can do this part first actually

1594
01:29:19,079 --> 01:29:23,699
once we down stapled by 2x when we come

1595
01:29:21,779 --> 01:29:26,819
through here if the tile dim stuff is

1596
01:29:23,699 --> 01:29:29,239
going to be incorrect right and so

1597
01:29:26,819 --> 01:29:34,109
everything that was using tile dim

1598
01:29:29,239 --> 01:29:36,029
should be like sprite dim so I'm just

1599
01:29:34,109 --> 01:29:38,939
gonna say sprite dims bright dim sprite

1600
01:29:36,029 --> 01:29:41,250
dim so all that stuff is gonna be based

1601
01:29:38,939 --> 01:29:42,750
on the sprite dim so here I'm just gonna

1602
01:29:41,250 --> 01:29:44,340
say all right after we do that the

1603
01:29:42,750 --> 01:29:47,010
sprite dimension is the half tile

1604
01:29:44,340 --> 01:29:52,860
dimension right so now it's down

1605
01:29:47,010 --> 01:29:55,020
sampling what are you complaining about

1606
01:29:52,859 --> 01:30:05,969
that I hide the declaration of best

1607
01:29:55,020 --> 01:30:11,940
pixel okay I don't disagree does this

1608
01:30:05,970 --> 01:30:14,400
make you happy so now if I come through

1609
01:30:11,939 --> 01:30:16,679
and look at what's gonna happen in that

1610
01:30:14,399 --> 01:30:20,009
code I'm expecting to reduce the size of

1611
01:30:16,680 --> 01:30:22,289
these down to 512 by 512 what's more is

1612
01:30:20,010 --> 01:30:24,659
actually I could run this more than once

1613
01:30:22,289 --> 01:30:28,560
right I couldn't run this in a 4 I loop

1614
01:30:24,659 --> 01:30:33,090
the only downside is it welds in the

1615
01:30:28,560 --> 01:30:37,140
reversal of the R&amp;B and so what we could

1616
01:30:33,090 --> 01:30:38,430
do is move the R&amp;B up here swap which is

1617
01:30:37,140 --> 01:30:39,900
a little slower because it's actually

1618
01:30:38,430 --> 01:30:41,909
well actually it's not a little slower

1619
01:30:39,899 --> 01:30:48,479
and in fact maybe that's better right if

1620
01:30:41,909 --> 01:30:55,109
we do mmm Jimmy if we did hear a B GRA

1621
01:30:48,479 --> 01:31:01,649
unpack and instead did a swap did the

1622
01:30:55,109 --> 01:31:04,049
swap are our own beat be here right that

1623
01:31:01,649 --> 01:31:09,119
might be smarter because now if we want

1624
01:31:04,050 --> 01:31:13,400
to we can actually do this as many times

1625
01:31:09,119 --> 01:31:13,399
as we want right

1626
01:31:16,510 --> 01:31:21,820
and so this could be a four I loop that

1627
01:31:19,810 --> 01:31:23,500
allows us to down sample in any way that

1628
01:31:21,819 --> 01:31:25,449
we wish so what I could do is say

1629
01:31:23,500 --> 01:31:31,119
alright the sprite dim equals the tile

1630
01:31:25,449 --> 01:31:34,529
dim and then this right here is just a

1631
01:31:31,119 --> 01:31:39,539
Down sampler so we just say alright

1632
01:31:34,529 --> 01:31:39,539
sprite dim equals sprite come over to

1633
01:31:45,840 --> 01:31:51,880
something like this right so we just do

1634
01:31:49,930 --> 01:31:53,829
however many down samples we want if

1635
01:31:51,880 --> 01:31:56,529
this is one down sample it runs once if

1636
01:31:53,829 --> 01:32:02,350
it's two down samples it runs twice this

1637
01:31:56,529 --> 01:32:09,009
just continues to shrink the thing over

1638
01:32:02,350 --> 01:32:12,130
and over and over again right I think

1639
01:32:09,010 --> 01:32:13,449
that's right we got it we're I'm waving

1640
01:32:12,130 --> 01:32:14,890
my hands around the earth up through

1641
01:32:13,449 --> 01:32:16,649
entirely but I believe that would just

1642
01:32:14,890 --> 01:32:20,050
allow us to kind of sit there in a loop

1643
01:32:16,649 --> 01:32:27,839
shrink shrink shrink just keep shrinking

1644
01:32:20,050 --> 01:32:30,880
it down and yeah so I don't actually

1645
01:32:27,840 --> 01:32:32,560
know that we want to run it twice but

1646
01:32:30,880 --> 01:32:34,440
maybe we want to go down to 2 to 6 by 2

1647
01:32:32,560 --> 01:32:37,739
to 6 and if we do that would be the way

1648
01:32:34,439 --> 01:32:40,539
to do it so let's go ahead and try this

1649
01:32:37,738 --> 01:32:42,399
first things first let's make it simple

1650
01:32:40,539 --> 01:32:46,060
on ourselves I'm not going to run the

1651
01:32:42,399 --> 01:32:48,279
down sampler at all so I'm just gonna

1652
01:32:46,060 --> 01:32:51,280
say look let's just see if we reverse

1653
01:32:48,279 --> 01:32:54,639
our channels correctly right so let's

1654
01:32:51,279 --> 01:32:57,789
create a blank import file let's run it

1655
01:32:54,640 --> 01:33:04,150
and let's see if we get the correct

1656
01:32:57,789 --> 01:33:05,738
color channels for our our weird will

1657
01:33:04,149 --> 01:33:07,449
sprite there and so now I think those

1658
01:33:05,738 --> 01:33:15,039
are actually more correct than they were

1659
01:33:07,449 --> 01:33:16,599
right I think those are more proper we

1660
01:33:15,039 --> 01:33:18,189
don't know about the premultiplied alpha

1661
01:33:16,600 --> 01:33:20,289
though now I think about it that

1662
01:33:18,189 --> 01:33:21,488
actually still needs to be corrected so

1663
01:33:20,289 --> 01:33:25,630
we're gonna have to look at that in a

1664
01:33:21,488 --> 01:33:28,329
second I'm gonna try now down sample by

1665
01:33:25,630 --> 01:33:29,750
2 just to see if we can produce 56 by

1666
01:33:28,329 --> 01:33:38,979
256

1667
01:33:29,750 --> 01:33:38,979
let's see go local create local and run

1668
01:33:46,210 --> 01:33:53,359
not looking good if we're honest about

1669
01:33:49,880 --> 01:33:55,279
it so let's take a look first of all do

1670
01:33:53,359 --> 01:33:58,939
we get anything obvious wrong like is

1671
01:33:55,279 --> 01:34:02,869
the file even correct and what not gonna

1672
01:33:58,939 --> 01:34:05,960
move to the local dump there and take a

1673
01:34:02,869 --> 01:34:08,180
look at it alright so at least it

1674
01:34:05,960 --> 01:34:10,819
produced it produced the correct thing

1675
01:34:08,180 --> 01:34:13,010
right it's the right size it's the right

1676
01:34:10,819 --> 01:34:15,889
we didn't do anything obviously stupid

1677
01:34:13,010 --> 01:34:17,510
right so that's good but what we did do

1678
01:34:15,890 --> 01:34:19,789
is not actually write out the data

1679
01:34:17,510 --> 01:34:22,940
properly so it's still not particularly

1680
01:34:19,789 --> 01:34:24,469
encouraging so let's take a look at what

1681
01:34:22,939 --> 01:34:28,488
we did wrong here we could step through

1682
01:34:24,469 --> 01:34:30,680
this and see what's going on we're

1683
01:34:28,488 --> 01:34:32,389
assuming that we're in this pixel buffer

1684
01:34:30,680 --> 01:34:34,640
thing we're gonna right out here right

1685
01:34:32,390 --> 01:34:36,829
this best pixel buffer and that's what

1686
01:34:34,640 --> 01:34:38,750
we write out if I'm not mistaken right

1687
01:34:36,829 --> 01:34:40,760
meaning when we reserve the asset data

1688
01:34:38,750 --> 01:34:42,948
the thing that we actually write to the

1689
01:34:40,760 --> 01:34:45,440
file is the pixel buffer and we write a

1690
01:34:42,948 --> 01:34:47,389
set data size which is computed by just

1691
01:34:45,439 --> 01:34:48,738
taking the sprite dim squared times 4

1692
01:34:47,390 --> 01:34:52,489
which is what we want to do is by do

1693
01:34:48,738 --> 01:34:55,909
this by 4 right so in here when we do

1694
01:34:52,488 --> 01:34:58,309
our loops we're setting it up so that

1695
01:34:55,909 --> 01:35:00,139
we're looking at the front of the pixel

1696
01:34:58,310 --> 01:35:04,390
buffer when we start and writing there

1697
01:35:00,140 --> 01:35:04,390
oh that's our problem right there

1698
01:35:08,779 --> 01:35:12,229
so that actually I mean it's not our

1699
01:35:10,698 --> 01:35:13,549
only problem we probably have other

1700
01:35:12,229 --> 01:35:15,500
problems in that but that was one of our

1701
01:35:13,550 --> 01:35:17,270
problems so we actually want to do is

1702
01:35:15,500 --> 01:35:19,039
set it up to the next row and then

1703
01:35:17,270 --> 01:35:21,560
divide by 2 so that we're still using

1704
01:35:19,039 --> 01:35:26,479
the correct thing to reset our tyldum

1705
01:35:21,560 --> 01:35:28,130
and it gets smaller each time to me then

1706
01:35:26,479 --> 01:35:30,379
when we come through here we do our B

1707
01:35:28,130 --> 01:35:33,400
GRA unpacks and let's make sure that's

1708
01:35:30,380 --> 01:35:33,400
going to the right space

1709
01:35:37,219 --> 01:35:43,230
so that's going yeah that's correctly

1710
01:35:39,810 --> 01:35:44,640
going to 255 0 to 2 3 to 5 right then

1711
01:35:43,229 --> 01:35:46,019
we're taking esterday B 2 to 5 which is

1712
01:35:44,640 --> 01:35:49,079
what we're loading and we're bringing

1713
01:35:46,020 --> 01:35:54,449
that to linear which is what we want and

1714
01:35:49,079 --> 01:36:03,329
then the PAC function be Jerry pack so

1715
01:35:54,448 --> 01:36:05,039
not correct we want that right and off

1716
01:36:03,329 --> 01:36:15,149
we go

1717
01:36:05,039 --> 01:36:17,670
so let's try that oh you know what and

1718
01:36:15,149 --> 01:36:20,339
we need to we need to do the other yeah

1719
01:36:17,670 --> 01:36:22,260
that we're missing our d linearized 2

1720
01:36:20,340 --> 01:36:25,800
that would be just yeah that's

1721
01:36:22,260 --> 01:36:35,369
I just forgot to call the upconvert as

1722
01:36:25,800 --> 01:36:37,289
well we need to call this that's the

1723
01:36:35,369 --> 01:36:38,670
problem I shouldn't just multiply 2 to 5

1724
01:36:37,289 --> 01:36:42,769
I should actually do the you know we

1725
01:36:38,670 --> 01:36:42,770
want the square root stuff so all right

1726
01:36:42,829 --> 01:36:49,050
all right so we also need to look and

1727
01:36:45,869 --> 01:36:50,939
see whether we actually have

1728
01:36:49,050 --> 01:36:52,260
premultiplied alpha so that's one thing

1729
01:36:50,939 --> 01:36:55,529
I want to do before the end of the

1730
01:36:52,260 --> 01:36:59,340
stream as well let's create a locally

1731
01:36:55,529 --> 01:37:00,750
today and let's run but I because I

1732
01:36:59,340 --> 01:37:04,650
don't know if that's actually working

1733
01:37:00,750 --> 01:37:08,250
properly I'm concerned that it might not

1734
01:37:04,649 --> 01:37:10,619
be it probably isn't so I saw so we

1735
01:37:08,250 --> 01:37:13,680
we've got a little bit it looks like

1736
01:37:10,619 --> 01:37:15,329
we've got some stride issues there with

1737
01:37:13,680 --> 01:37:17,900
the down sampling so let's just take a

1738
01:37:15,329 --> 01:37:17,899
look at that

1739
01:37:18,590 --> 01:37:26,550
[Music]

1740
01:37:21,300 --> 01:37:28,829
oh yeah yeah yeah yeah so the problem

1741
01:37:26,550 --> 01:37:30,329
here is that source pixel is pointed to

1742
01:37:28,829 --> 01:37:40,579
the right place so we're gonna kind of

1743
01:37:30,329 --> 01:37:44,970
have to keep we're gonna have to do this

1744
01:37:40,579 --> 01:37:49,260
when we do the down sample and we set up

1745
01:37:44,970 --> 01:37:52,829
these two once we're done with a pass

1746
01:37:49,260 --> 01:37:57,960
we need source pixel zero and source

1747
01:37:52,829 --> 01:38:01,079
pixel one to move extra row down right

1748
01:37:57,960 --> 01:38:02,789
because source pixel one will be pointed

1749
01:38:01,079 --> 01:38:07,319
where source pixel zero wants to be but

1750
01:38:02,789 --> 01:38:10,710
source pixel one needs to be one row

1751
01:38:07,319 --> 01:38:12,750
below that right so we actually need at

1752
01:38:10,710 --> 01:38:15,510
this point to do source pixel zero plus

1753
01:38:12,750 --> 01:38:19,949
equals freedom source pixel one plus

1754
01:38:15,510 --> 01:38:23,760
equals freedom right every row they need

1755
01:38:19,949 --> 01:38:27,470
to advance again so that that was a mess

1756
01:38:23,760 --> 01:38:27,470
up there let's try that one more time

1757
01:38:31,069 --> 01:38:35,159
but we're almost there and like I said

1758
01:38:33,569 --> 01:38:37,889
they're the premultiplied alpha we got a

1759
01:38:35,159 --> 01:38:39,960
go look maybe I'll put in some checks

1760
01:38:37,890 --> 01:38:42,720
that just kind of built get some values

1761
01:38:39,960 --> 01:38:45,869
we can actually look at there so there's

1762
01:38:42,720 --> 01:38:49,230
our down sample - it looks good looking

1763
01:38:45,869 --> 01:38:52,859
at the edges I want to say like look at

1764
01:38:49,229 --> 01:38:55,500
those edges those edges look a lot to me

1765
01:38:52,859 --> 01:38:59,759
like it's not premultiplied you know

1766
01:38:55,500 --> 01:39:01,920
what I'm saying to you so I kind of feel

1767
01:38:59,760 --> 01:39:04,980
like that may be a pretty good

1768
01:39:01,920 --> 01:39:10,010
indication that it is not premultiplied

1769
01:39:04,979 --> 01:39:13,709
alpha I want to know though for sure and

1770
01:39:10,010 --> 01:39:17,550
so I want to do a little bit of us of a

1771
01:39:13,710 --> 01:39:21,329
scour here and just see what the values

1772
01:39:17,550 --> 01:39:22,680
are that we're actually getting out so

1773
01:39:21,329 --> 01:39:26,699
that I can have some idea of what's

1774
01:39:22,680 --> 01:39:31,590
going on so what I want to do is I want

1775
01:39:26,699 --> 01:39:32,670
to keep I'm just gonna use the blue

1776
01:39:31,590 --> 01:39:34,889
channel because that looked like a

1777
01:39:32,670 --> 01:39:37,109
fairly blue sprite

1778
01:39:34,889 --> 01:39:42,719
I'm just gonna use the blue channel and

1779
01:39:37,109 --> 01:39:48,589
I'm gonna find out okay for the max blue

1780
01:39:42,719 --> 01:39:51,960
alpha diff I'm gonna say it's zero

1781
01:39:48,590 --> 01:39:54,510
what I want to do here is say all right

1782
01:39:51,960 --> 01:39:58,859
when I come through here and I've got

1783
01:39:54,510 --> 01:40:01,980
these values when when I first import

1784
01:39:58,859 --> 01:40:07,380
them I'm gonna say like all right if P

1785
01:40:01,979 --> 01:40:09,569
zero zeros alpha value is less than Peas

1786
01:40:07,380 --> 01:40:13,739
or maybe both the blue value is greater

1787
01:40:09,569 --> 01:40:18,420
than P zero zeros alpha value right then

1788
01:40:13,738 --> 01:40:22,439
max blue alpha diff equals maximum max

1789
01:40:18,420 --> 01:40:33,149
blue alpha diff and peas or b minus p 0

1790
01:40:22,439 --> 01:40:35,759
0 a and so all I'm doing there is I'm

1791
01:40:33,149 --> 01:40:37,829
we're gonna record that maximum value so

1792
01:40:35,760 --> 01:40:39,690
whatever the highest difference is

1793
01:40:37,829 --> 01:40:42,719
between the B and the a I'm gonna record

1794
01:40:39,689 --> 01:40:44,729
it and the other thing I want to do is I

1795
01:40:42,719 --> 01:40:49,819
want to in fact you know what let me put

1796
01:40:44,729 --> 01:40:49,819
it like this

1797
01:40:54,238 --> 01:41:20,639
let's just do it like this and this will

1798
01:41:14,789 --> 01:41:25,130
let me store the actual pixel that it

1799
01:41:20,640 --> 01:41:27,600
found that that was the highest.if right

1800
01:41:25,130 --> 01:41:30,900
so what I want to do here is I want to

1801
01:41:27,600 --> 01:41:33,570
set a breakpoint on the import and I

1802
01:41:30,899 --> 01:41:35,699
want to see what it gets for that value

1803
01:41:33,569 --> 01:41:38,579
so it's gonna run through here one time

1804
01:41:35,699 --> 01:41:40,289
and before it hits the second time I

1805
01:41:38,579 --> 01:41:41,039
want to look I'm gonna look at what that

1806
01:41:40,289 --> 01:41:47,310
value is

1807
01:41:41,039 --> 01:41:52,529
okay I so let's force that to do a

1808
01:41:47,310 --> 01:41:56,370
refresh a reinforce and then I'm gonna

1809
01:41:52,529 --> 01:42:01,849
take a look at it so let's bring those

1810
01:41:56,369 --> 01:42:08,609
two values up max blue alpha gypsy and

1811
01:42:01,850 --> 01:42:13,850
max blue Jeff and run it and let's see

1812
01:42:08,609 --> 01:42:18,389
what the values were so I mean yeah

1813
01:42:13,850 --> 01:42:25,650
that's a white pixel with no alpha it is

1814
01:42:18,390 --> 01:42:27,539
obviously not premultiplied right so we

1815
01:42:25,649 --> 01:42:29,099
know that these are non premultiplied

1816
01:42:27,539 --> 01:42:30,659
alpha I think we sort of knew that

1817
01:42:29,100 --> 01:42:32,670
before because remember when we were

1818
01:42:30,659 --> 01:42:35,969
doing the PNG compressor and looking at

1819
01:42:32,670 --> 01:42:39,210
the RG and B channels there had they had

1820
01:42:35,969 --> 01:42:42,390
stuff in them right where there was no

1821
01:42:39,210 --> 01:42:46,800
sprite so we know that's not right so we

1822
01:42:42,390 --> 01:42:48,690
need to do the pre multiply at the end

1823
01:42:46,800 --> 01:42:51,029
or at the beginning I guess at the

1824
01:42:48,689 --> 01:42:54,179
beginning is more correct so when we

1825
01:42:51,029 --> 01:42:57,079
come in here what we want to do is say

1826
01:42:54,180 --> 01:42:59,730
look we've got a pre multiply this thing

1827
01:42:57,079 --> 01:43:02,159
so when we do the down sample we can do

1828
01:42:59,729 --> 01:43:05,939
that the problem is if we just did it

1829
01:43:02,159 --> 01:43:07,710
only on the down sample it's it's kind

1830
01:43:05,939 --> 01:43:10,559
of a problem because if

1831
01:43:07,710 --> 01:43:12,899
we only needed on the downsample then if

1832
01:43:10,560 --> 01:43:18,350
we don't downsample it doesn't it's not

1833
01:43:12,899 --> 01:43:18,349
gonna happen so we kind of want to do it

1834
01:43:18,500 --> 01:43:22,920
we kind of want to do it up in the act

1835
01:43:21,810 --> 01:43:27,780
and this routine

1836
01:43:22,920 --> 01:43:32,940
honestly unfortunately right and so I

1837
01:43:27,779 --> 01:43:35,219
think what we want to say here is for

1838
01:43:32,939 --> 01:43:36,839
each one of these pixels before we write

1839
01:43:35,219 --> 01:43:39,420
it out I think we're gonna actually have

1840
01:43:36,840 --> 01:43:40,890
to follow this and this is gonna be

1841
01:43:39,420 --> 01:43:43,289
slower right but I think we're just

1842
01:43:40,890 --> 01:43:45,239
gonna have to do it so what we want to

1843
01:43:43,289 --> 01:43:48,479
do is say alright we're checking to see

1844
01:43:45,238 --> 01:43:51,089
if there's any alpha channel if there is

1845
01:43:48,479 --> 01:43:52,619
an alpha channel then we're gonna use it

1846
01:43:51,090 --> 01:43:55,260
for boundary purposes but what we also

1847
01:43:52,619 --> 01:44:13,170
want to do at the same time is make sure

1848
01:43:55,260 --> 01:44:15,409
that we do an unpack and a repack like

1849
01:44:13,170 --> 01:44:15,409
so

1850
01:44:23,170 --> 01:44:29,319
so what we want to do here is unpack the

1851
01:44:25,180 --> 01:44:31,570
value do the linearization of it so it's

1852
01:44:29,319 --> 01:44:33,729
in the right space real in your eyes

1853
01:44:31,569 --> 01:44:35,920
pack right this should be a completely

1854
01:44:33,729 --> 01:44:37,469
neutral opera's the operation within

1855
01:44:35,920 --> 01:44:39,579
rounding error right should just work

1856
01:44:37,470 --> 01:44:43,990
shouldn't change anything other than the

1857
01:44:39,579 --> 01:44:48,220
swap RGB and what we do is right here we

1858
01:44:43,989 --> 01:44:51,819
do a multiplication of the RGB channel

1859
01:44:48,220 --> 01:44:54,550
by the a channel so we force the pre

1860
01:44:51,819 --> 01:44:59,789
multiply in the right space we did apply

1861
01:44:54,550 --> 01:45:04,739
we unlink your eyes it back and go right

1862
01:44:59,789 --> 01:45:07,989
I think that's the right place to do it

1863
01:45:04,739 --> 01:45:12,219
because when you unli gnear eyes you

1864
01:45:07,989 --> 01:45:18,969
want to be right I'm pretty sure but

1865
01:45:12,220 --> 01:45:22,480
with cameras always a huge mind mind

1866
01:45:18,970 --> 01:45:30,010
game what's wait what's happening here

1867
01:45:22,479 --> 01:45:31,389
why is this running anything we must

1868
01:45:30,010 --> 01:45:34,619
have done something wrong cuz this

1869
01:45:31,390 --> 01:45:34,619
should not be running anything

1870
01:45:37,550 --> 01:45:49,640
what was what's going on there why am I

1871
01:45:47,069 --> 01:45:49,639
not seeing anything

1872
01:45:55,670 --> 01:45:59,510
something we were just happening but I

1873
01:45:58,609 --> 01:46:01,279
don't know what it is

1874
01:45:59,510 --> 01:46:02,960
hold on one second because I wanted to

1875
01:46:01,279 --> 01:46:04,009
finish what I was doing first but then I

1876
01:46:02,960 --> 01:46:07,539
want to see what's going on there

1877
01:46:04,010 --> 01:46:07,539
there's my local

1878
01:46:18,100 --> 01:46:25,210
what did I break how could I broken

1879
01:46:22,989 --> 01:46:32,369
something by touching that part of the

1880
01:46:25,210 --> 01:46:38,710
code I'm not sure what I broke anyway

1881
01:46:32,369 --> 01:46:40,059
let's zoom in on that there we go so now

1882
01:46:38,710 --> 01:46:42,939
you can see we get those nice clean

1883
01:46:40,060 --> 01:46:44,140
edges and that's because you know

1884
01:46:42,939 --> 01:46:46,689
everything's supposed to be doing

1885
01:46:44,140 --> 01:46:47,829
using premultiplied alpha here and since

1886
01:46:46,689 --> 01:46:49,389
this was coming in with non

1887
01:46:47,829 --> 01:46:51,039
premultiplied alpha it was totally

1888
01:46:49,390 --> 01:46:53,200
breaking the renderer right it was it

1889
01:46:51,039 --> 01:46:58,180
was not gonna compute the right map at

1890
01:46:53,199 --> 01:47:01,809
all in that case and so that's importing

1891
01:46:58,180 --> 01:47:03,340
correctly now that that's right what's

1892
01:47:01,810 --> 01:47:05,020
happening if I run a second timer we

1893
01:47:03,340 --> 01:47:06,489
broke I don't know what broke there I

1894
01:47:05,020 --> 01:47:07,720
must have done something weird that I

1895
01:47:06,489 --> 01:47:08,920
shouldn't have done maybe I hit a key I

1896
01:47:07,720 --> 01:47:11,590
was not supposed to hit I don't know

1897
01:47:08,920 --> 01:47:14,260
what happened there let's go ahead and

1898
01:47:11,590 --> 01:47:20,529
and test the builds in an optimized

1899
01:47:14,260 --> 01:47:22,470
setting so if I if I go ahead and run

1900
01:47:20,529 --> 01:47:27,569
this here

1901
01:47:22,470 --> 01:47:32,470
so nice and zippy still so that's good

1902
01:47:27,569 --> 01:47:35,529
and if I if I take a look at how fast

1903
01:47:32,470 --> 01:47:39,480
the import works for those files on an

1904
01:47:35,529 --> 01:47:39,479
optimized build again just wanted to

1905
01:47:41,340 --> 01:47:47,739
figure out how slow the import would be

1906
01:47:44,920 --> 01:47:49,750
so here it is running so that's really

1907
01:47:47,739 --> 01:47:53,439
fast actually and that was for three

1908
01:47:49,750 --> 01:47:54,909
files so I feel like that's totally

1909
01:47:53,439 --> 01:47:57,750
acceptable because most of the time an

1910
01:47:54,909 --> 01:48:00,189
artist only updates one file at a time

1911
01:47:57,750 --> 01:48:03,130
you know cuz take some Photoshop a while

1912
01:48:00,189 --> 01:48:07,179
to even export it so that should be a

1913
01:48:03,130 --> 01:48:12,670
totally acceptable turnaround time so I

1914
01:48:07,180 --> 01:48:14,770
think that's everything we've got the

1915
01:48:12,670 --> 01:48:17,289
premultiplied alpha in there

1916
01:48:14,770 --> 01:48:20,440
we're on startup we're not doing

1917
01:48:17,289 --> 01:48:23,409
anything when we detect no changes it

1918
01:48:20,439 --> 01:48:28,349
looks like we can survive across runs

1919
01:48:23,409 --> 01:48:28,349
properly the dumps look right

1920
01:48:29,368 --> 01:48:33,399
also let me just here to make sure the

1921
01:48:31,359 --> 01:48:35,710
size is right you can see this is now

1922
01:48:33,399 --> 01:48:39,069
much smaller right it was previously 50

1923
01:48:35,710 --> 01:48:43,750
Meg's it's three now so that all looks

1924
01:48:39,069 --> 01:48:45,819
good and I think we're done I think

1925
01:48:43,750 --> 01:48:49,090
that's that's literally everything so

1926
01:48:45,819 --> 01:48:52,569
next week we will be clear to import at

1927
01:48:49,090 --> 01:48:54,730
art assets as we like which is basically

1928
01:48:52,569 --> 01:48:57,038
going to involve us deciding how to tag

1929
01:48:54,729 --> 01:49:00,698
everything and how to specify what we

1930
01:48:57,038 --> 01:49:03,639
want to load which is going to be a toll

1931
01:49:00,698 --> 01:49:04,988
a toll on thing but hey we want to get

1932
01:49:03,639 --> 01:49:06,520
our assets in the game we did all the

1933
01:49:04,988 --> 01:49:08,078
work to do it so now we actually have to

1934
01:49:06,520 --> 01:49:11,440
figure out how we want to specify which

1935
01:49:08,078 --> 01:49:14,679
ones to use not a bad problem to have

1936
01:49:11,439 --> 01:49:15,698
right it's like hey at some point you

1937
01:49:14,679 --> 01:49:18,969
got to figure out how you want to tag

1938
01:49:15,698 --> 01:49:21,928
things alright so I think that's it

1939
01:49:18,969 --> 01:49:21,929
we'll go ahead and go to the QA

1940
01:49:50,929 --> 01:49:56,219
at the end of the Y loop of the

1941
01:49:53,609 --> 01:49:58,920
downsample shouldn't it be source before

1942
01:49:56,219 --> 01:50:04,670
zero equal source buffer oneplus proved

1943
01:49:58,920 --> 01:50:07,739
in yeah you might be right huh second

1944
01:50:04,670 --> 01:50:09,658
let me see actually no I don't think you

1945
01:50:07,738 --> 01:50:14,638
are sorry I didn't mean to say you were

1946
01:50:09,658 --> 01:50:16,879
right in and theorem no that looks right

1947
01:50:14,639 --> 01:50:19,980
to me so hmm

1948
01:50:16,880 --> 01:50:22,679
source pixel zero and source pixel one

1949
01:50:19,979 --> 01:50:25,198
are both pointing at Rose they're gonna

1950
01:50:22,679 --> 01:50:27,149
advance all the way across to the end of

1951
01:50:25,198 --> 01:50:30,658
their row and now they're at the next

1952
01:50:27,149 --> 01:50:31,469
row that would be correct if it wasn't

1953
01:50:30,658 --> 01:50:33,238
for the fact that we're trying to

1954
01:50:31,469 --> 01:50:35,578
advance two rows at a time so they've

1955
01:50:33,238 --> 01:50:40,488
advanced one so this just advances them

1956
01:50:35,578 --> 01:50:40,488
one more row does that make sense

1957
01:51:01,639 --> 01:51:05,150
Martin said you add a comment for a

1958
01:51:03,560 --> 01:51:06,710
handling Big Ed ninis for residual value

1959
01:51:05,149 --> 01:51:07,969
of Calculon the hash but I feel that

1960
01:51:06,710 --> 01:51:10,368
it's important to mention the same

1961
01:51:07,969 --> 01:51:13,880
comment should apply also for dot d

1962
01:51:10,368 --> 01:51:14,429
resting in the loop yeah you're probably

1963
01:51:13,880 --> 01:51:17,319
right

1964
01:51:14,430 --> 01:51:21,670
[Music]

1965
01:51:17,319 --> 01:51:21,670
hold on I can't remember where this is

1966
01:51:23,770 --> 01:51:43,520
yes oh yeah so you're right because this

1967
01:51:38,658 --> 01:51:45,439
is gonna be it's going to use these same

1968
01:51:43,520 --> 01:51:48,969
shifts and constants which are going to

1969
01:51:45,439 --> 01:51:48,969
they're going to be the wrong way round

1970
01:52:07,600 --> 01:52:14,900
let's just say that because yeah the

1971
01:52:12,050 --> 01:52:20,810
start at will load it in in big-endian

1972
01:52:14,899 --> 01:52:25,029
or little-endian and at that point these

1973
01:52:20,810 --> 01:52:25,030
operations will go the wrong way round

1974
01:52:25,750 --> 01:52:32,600
everything is backwards at that point so

1975
01:52:29,300 --> 01:52:35,739
that's a good point Martin's I didn't

1976
01:52:32,600 --> 01:52:35,739
think of that when I was typing it in

1977
01:52:38,710 --> 01:52:44,350
and by the founder of Molly rocky yes

1978
01:52:41,029 --> 01:52:44,349
Molly rocket is my company

1979
01:53:01,880 --> 01:53:05,279
does Anna draw vector graphics initially

1980
01:53:04,289 --> 01:53:06,840
and would you consider raster and vector

1981
01:53:05,279 --> 01:53:12,630
guys in the asset system or it startup

1982
01:53:06,840 --> 01:53:14,670
for a game like this so actually I can

1983
01:53:12,630 --> 01:53:17,010
answer that in a little bit more complex

1984
01:53:14,670 --> 01:53:21,720
way because this is something that I

1985
01:53:17,010 --> 01:53:24,480
actually kind of annoys me so no Anna

1986
01:53:21,720 --> 01:53:26,490
uses Photoshop actually so they are not

1987
01:53:24,479 --> 01:53:30,059
vector graphics initially so we cannot

1988
01:53:26,489 --> 01:53:32,429
consider a rasterization path I would

1989
01:53:30,060 --> 01:53:36,690
like that because her style is very

1990
01:53:32,430 --> 01:53:38,579
cartoony and it could be nicely made

1991
01:53:36,689 --> 01:53:40,349
sort of resolution dependent the problem

1992
01:53:38,579 --> 01:53:45,059
is Photoshop just doesn't record

1993
01:53:40,350 --> 01:53:47,280
brushstrokes right so we have no ability

1994
01:53:45,060 --> 01:53:49,289
to make a resolution independent version

1995
01:53:47,279 --> 01:53:51,179
of Anna's art even though it would be

1996
01:53:49,289 --> 01:53:54,630
pretty straightforward if Photoshop just

1997
01:53:51,180 --> 01:53:55,920
recorded brushstrokes but don't not in a

1998
01:53:54,630 --> 01:54:02,340
way that it exports any way that I can

1999
01:53:55,920 --> 01:54:04,680
find and so it's it's just not really an

2000
01:54:02,340 --> 01:54:06,239
option your artists have to work in a

2001
01:54:04,680 --> 01:54:08,460
vector graphics program in order to

2002
01:54:06,239 --> 01:54:10,170
really have that work in the present day

2003
01:54:08,460 --> 01:54:16,279
and age I hope that changes in the

2004
01:54:10,170 --> 01:54:16,279
future but right now not so not so much

2005
01:54:23,159 --> 01:54:28,989
what sort of precision would we be

2006
01:54:25,569 --> 01:54:31,750
losing by doing the down samples and

2007
01:54:28,989 --> 01:54:33,429
doing s were to be linear sRGB rather

2008
01:54:31,750 --> 01:54:35,739
than doing the linear conversion at the

2009
01:54:33,430 --> 01:54:37,119
start and keeping it in linear and doing

2010
01:54:35,739 --> 01:54:43,059
the linear sr to be only been running

2011
01:54:37,119 --> 01:54:48,460
out each file um so if you mean what if

2012
01:54:43,060 --> 01:54:49,570
we just stored a float well okay so

2013
01:54:48,460 --> 01:54:51,760
there's a couple things you can't do

2014
01:54:49,569 --> 01:54:53,679
first of all we could just iterate over

2015
01:54:51,760 --> 01:54:54,869
the whole block and do the thing in

2016
01:54:53,680 --> 01:54:58,420
floating point right there

2017
01:54:54,869 --> 01:55:04,090
the answer is I you to only lose one bit

2018
01:54:58,420 --> 01:55:12,100
per downsample I think I can't really

2019
01:55:04,090 --> 01:55:14,260
think of how you would lose more because

2020
01:55:12,100 --> 01:55:16,480
basically like whatever you're storing

2021
01:55:14,260 --> 01:55:19,810
is just gonna have to round it to the

2022
01:55:16,479 --> 01:55:22,839
255 and but then you're gonna

2023
01:55:19,810 --> 01:55:25,030
immediately be blending it again so even

2024
01:55:22,840 --> 01:55:29,680
if you rounded wrong you'd have to round

2025
01:55:25,029 --> 01:55:32,649
wrong the same way on three of the four

2026
01:55:29,680 --> 01:55:36,670
you rounded the wrong way it would just

2027
01:55:32,649 --> 01:55:40,809
cancel out in the next blend so I don't

2028
01:55:36,670 --> 01:55:41,980
know I I don't know Neil I'd have to

2029
01:55:40,810 --> 01:55:43,990
think about that a little more but I

2030
01:55:41,979 --> 01:55:48,750
suspect the difference would be pretty

2031
01:55:43,989 --> 01:55:52,349
minimal for this kind of filter for more

2032
01:55:48,750 --> 01:55:57,329
wider filters that have uneven weighting

2033
01:55:52,350 --> 01:56:04,720
then you probably lose a bit every time

2034
01:55:57,329 --> 01:56:07,050
would be my guess a bottom bit of

2035
01:56:04,720 --> 01:56:07,050
precision

2036
01:56:13,380 --> 01:56:18,150
I don't know that you really you only

2037
01:56:16,738 --> 01:56:21,089
lose a bottom every surgeon every time

2038
01:56:18,149 --> 01:56:23,250
on this one and really it's probably

2039
01:56:21,090 --> 01:56:28,350
actually unlikely but I don't know I'd

2040
01:56:23,250 --> 01:56:30,689
have to think about that some more off

2041
01:56:28,350 --> 01:56:32,280
topic any suggestion or resource about

2042
01:56:30,689 --> 01:56:35,839
how to implement a network layer from

2043
01:56:32,279 --> 01:56:40,679
scratch for a massive multiplayer game

2044
01:56:35,840 --> 01:56:46,230
not really you're talking about like

2045
01:56:40,679 --> 01:56:47,460
like World of Warcraft or something you

2046
01:56:46,229 --> 01:56:50,509
know I guess there's one thing for you

2047
01:56:47,460 --> 01:56:50,510
to test out yeah

2048
01:56:51,710 --> 01:57:07,050
filtering is kind of a really weird sort

2049
01:56:57,300 --> 01:57:09,420
of topic and there's a lot of so here's

2050
01:57:07,050 --> 01:57:15,270
the thing we don't really know how to

2051
01:57:09,420 --> 01:57:17,609
analyze filtering very well audio

2052
01:57:15,270 --> 01:57:20,850
filtering is one thing because your ears

2053
01:57:17,609 --> 01:57:24,029
kind of do look at frequency domain

2054
01:57:20,850 --> 01:57:25,980
stuff and so analyzing them in terms of

2055
01:57:24,029 --> 01:57:29,849
digital filters and Fourier transforms

2056
01:57:25,979 --> 01:57:33,138
is not really a bad idea to a certain

2057
01:57:29,850 --> 01:57:37,400
extent because it actually is more

2058
01:57:33,139 --> 01:57:37,400
closely related to how you hear

2059
01:57:37,729 --> 01:57:42,599
analyzing digital filters is still kind

2060
01:57:40,439 --> 01:57:44,309
of something that I don't really find

2061
01:57:42,600 --> 01:57:48,060
super compelling a lot of the ways they

2062
01:57:44,310 --> 01:57:49,889
do it because it doesn't really feel

2063
01:57:48,060 --> 01:57:52,230
like it matches that well with how the

2064
01:57:49,889 --> 01:57:56,579
brain really does its own visual

2065
01:57:52,229 --> 01:57:59,698
filtering and so some of the stuff that

2066
01:57:56,579 --> 01:58:02,219
they do to analyze filters is kind of

2067
01:57:59,698 --> 01:58:03,869
hand-wavy to me it's like here's a

2068
01:58:02,219 --> 01:58:05,939
mathematical model that we're applying

2069
01:58:03,869 --> 01:58:09,300
analyzes filter but we've never really

2070
01:58:05,939 --> 01:58:11,158
justified that model as being something

2071
01:58:09,300 --> 01:58:12,989
you care about you know because

2072
01:58:11,158 --> 01:58:14,698
filtering fundamentally is about making

2073
01:58:12,988 --> 01:58:16,559
things that look good and if you haven't

2074
01:58:14,698 --> 01:58:18,448
first proven that your mathematical

2075
01:58:16,560 --> 01:58:21,449
model correlates well with what looks

2076
01:58:18,448 --> 01:58:23,759
good then it's kind of dumb to use you

2077
01:58:21,448 --> 01:58:25,949
know you're just using math for math

2078
01:58:23,760 --> 01:58:29,340
sake

2079
01:58:25,949 --> 01:58:31,139
and so the digital image filtering is

2080
01:58:29,340 --> 01:58:32,819
kind of a nasty topic and it's nasty

2081
01:58:31,140 --> 01:58:35,369
because I don't really feel like we've

2082
01:58:32,819 --> 01:58:37,769
gotten as good of a hold on it as we

2083
01:58:35,369 --> 01:58:39,659
really should and so some of the ways

2084
01:58:37,770 --> 01:58:42,750
that people analyze these filters in

2085
01:58:39,659 --> 01:58:49,970
terms of frequency domain stuff I think

2086
01:58:42,750 --> 01:58:52,789
is a little misguided so I would I would

2087
01:58:49,970 --> 01:58:56,610
it's an interesting thing to look into

2088
01:58:52,789 --> 01:58:59,130
be advised that the writing on it out

2089
01:58:56,609 --> 01:59:07,679
there is a little hand wavy in my

2090
01:58:59,130 --> 01:59:09,270
opinion just curious are there any games

2091
01:59:07,680 --> 01:59:11,070
that require more accurate or complex

2092
01:59:09,270 --> 01:59:12,960
digital filters in the image than those

2093
01:59:11,069 --> 01:59:15,199
of bilinear other approximations like

2094
01:59:12,960 --> 01:59:18,989
any sort of sharp low pass filter etc

2095
01:59:15,199 --> 01:59:21,149
yeah so basically you can do a lot of

2096
01:59:18,989 --> 01:59:24,090
different kinds of filters and they're

2097
01:59:21,149 --> 01:59:27,059
different and you do it real-time you do

2098
01:59:24,090 --> 01:59:29,640
use different ones so if you are

2099
01:59:27,060 --> 01:59:32,820
filtering image stuff I think a lot of

2100
01:59:29,640 --> 01:59:35,700
times people still do bilinear because

2101
01:59:32,819 --> 01:59:39,029
it's fast and it has no objection Allart

2102
01:59:35,699 --> 01:59:41,550
effects so I don't know to what extent

2103
01:59:39,029 --> 01:59:44,819
people use more complex filters in at

2104
01:59:41,550 --> 01:59:47,159
runtime for image to straight-up image

2105
01:59:44,819 --> 01:59:49,199
data but there's a lot of other kinds of

2106
01:59:47,159 --> 01:59:50,510
data that gets used in games now normal

2107
01:59:49,199 --> 01:59:53,970
Maps

2108
01:59:50,510 --> 01:59:57,140
light buffers like buffers that store

2109
01:59:53,970 --> 02:00:00,930
like lens effects and stuff like this so

2110
01:59:57,140 --> 02:00:02,640
depth of depth of field effects and

2111
02:00:00,930 --> 02:00:06,869
blurring and that sort of stuff those

2112
02:00:02,640 --> 02:00:08,220
often don't use bilinear filters and

2113
02:00:06,869 --> 02:00:10,349
they don't use but linear filters

2114
02:00:08,220 --> 02:00:14,909
because the kinds of things they're

2115
02:00:10,350 --> 02:00:17,310
trying to preserve in the filter are

2116
02:00:14,909 --> 02:00:21,689
better preserved with other methods

2117
02:00:17,310 --> 02:00:24,240
right so max filters or min filters

2118
02:00:21,689 --> 02:00:27,989
things like this other simple filters

2119
02:00:24,239 --> 02:00:29,699
are sometimes used at runtime that are

2120
02:00:27,989 --> 02:00:33,739
not bilinear depending on what it is

2121
02:00:29,699 --> 02:00:33,739
that you're trying to capture right

2122
02:00:48,539 --> 02:00:54,960
could you explain again the rotation to

2123
02:00:50,909 --> 02:00:56,519
the left in the bit pattern used well no

2124
02:00:54,960 --> 02:00:57,630
not really if you're not if you're

2125
02:00:56,520 --> 02:00:59,580
talking about the murmur hatch one

2126
02:00:57,630 --> 02:01:02,220
because again I don't know why they

2127
02:00:59,579 --> 02:01:08,159
picked these I don't know why they

2128
02:01:02,220 --> 02:01:11,369
decided to rotate left you know when

2129
02:01:08,159 --> 02:01:15,180
you're bringing these bits in they want

2130
02:01:11,369 --> 02:01:16,500
to mix bits so that low bits mixed with

2131
02:01:15,180 --> 02:01:19,260
high bits and stuff right

2132
02:01:16,500 --> 02:01:22,229
so it's typical to see things rotating a

2133
02:01:19,260 --> 02:01:24,329
lot and if you look at rotating it by 31

2134
02:01:22,229 --> 02:01:26,339
it's like well I want to rotate it by

2135
02:01:24,329 --> 02:01:28,170
like something that moves the bits in

2136
02:01:26,340 --> 02:01:31,289
like a marching pattern all around my

2137
02:01:28,170 --> 02:01:33,090
value right so 31 makes some sense 27

2138
02:01:31,289 --> 02:01:35,760
minute they make sense in a sort of

2139
02:01:33,090 --> 02:01:38,369
vague hand wavy way but no I you know I

2140
02:01:35,760 --> 02:01:40,980
don't know why they decided to use these

2141
02:01:38,369 --> 02:01:45,500
bit patterns they decided those would

2142
02:01:40,979 --> 02:01:48,059
mix the bits together in a resilient way

2143
02:01:45,500 --> 02:01:50,399
how they decided I don't know we'd have

2144
02:01:48,060 --> 02:01:52,050
to go read the paper and hope that it

2145
02:01:50,399 --> 02:01:53,429
was written in a way that explains to

2146
02:01:52,050 --> 02:01:58,820
people who aren't familiar with

2147
02:01:53,430 --> 02:01:58,820
numerical analysis why it's good right I

2148
02:02:00,500 --> 02:02:04,680
was thinking about a shooter but let's

2149
02:02:02,489 --> 02:02:07,289
think we want support multiplayer for

2150
02:02:04,680 --> 02:02:11,610
handmade here well I mean you know the

2151
02:02:07,289 --> 02:02:14,729
basics is not super complicated it's

2152
02:02:11,609 --> 02:02:17,299
like look you've got the in hand made

2153
02:02:14,729 --> 02:02:20,309
here you've already got the renderer

2154
02:02:17,300 --> 02:02:22,170
separated from the world sim right so

2155
02:02:20,310 --> 02:02:23,730
you can pull the world sim out and

2156
02:02:22,170 --> 02:02:26,369
you're gonna run the world sim on the

2157
02:02:23,729 --> 02:02:28,919
server-side and then you're gonna run

2158
02:02:26,369 --> 02:02:30,840
the world sim on the client-side and the

2159
02:02:28,920 --> 02:02:32,789
problem is that you have to now have a

2160
02:02:30,840 --> 02:02:34,619
way of reconciling those two things so

2161
02:02:32,789 --> 02:02:36,899
what's gonna happen is the server has to

2162
02:02:34,619 --> 02:02:39,539
send to the client what it actually

2163
02:02:36,899 --> 02:02:41,969
updated in the world and the clients

2164
02:02:39,539 --> 02:02:46,979
gonna have to fix its representation of

2165
02:02:41,970 --> 02:02:49,470
the world to match that right and it's

2166
02:02:46,979 --> 02:02:52,500
kind of nasty coding but you can make it

2167
02:02:49,470 --> 02:02:54,590
relatively clean if you work at it you

2168
02:02:52,500 --> 02:02:54,590
know

2169
02:03:00,479 --> 02:03:04,329
off-topic about can you give a quick

2170
02:03:02,859 --> 02:03:07,750
description the filter you designed I'm

2171
02:03:04,329 --> 02:03:10,869
fine with heavy DSP target actually no

2172
02:03:07,750 --> 02:03:12,189
DSP jargon necessary I will be posting

2173
02:03:10,869 --> 02:03:15,849
an article about it I just haven't quite

2174
02:03:12,189 --> 02:03:17,889
finished it it's a it's a very special

2175
02:03:15,850 --> 02:03:19,510
filter that's designed for a very

2176
02:03:17,890 --> 02:03:23,130
specific thing and it had a property

2177
02:03:19,510 --> 02:03:27,340
that no other filter I've I've seen has

2178
02:03:23,130 --> 02:03:28,600
and so I I have an article it's gonna

2179
02:03:27,340 --> 02:03:31,929
write about I designed it way back in

2180
02:03:28,600 --> 02:03:34,719
2011 it's an old filter but it just has

2181
02:03:31,929 --> 02:03:37,239
never been published so I have a blog

2182
02:03:34,719 --> 02:03:41,198
post I just have to finish it up but

2183
02:03:37,238 --> 02:03:43,029
you'll be able to read about it there

2184
02:03:41,198 --> 02:03:45,129
are no rotate left right as to see AVX

2185
02:03:43,029 --> 02:03:45,488
intrinsics correct not that I know of

2186
02:03:45,130 --> 02:03:52,029
anyway

2187
02:03:45,488 --> 02:03:53,859
I guess what I would say is I don't

2188
02:03:52,029 --> 02:04:00,519
remember if there are a BX I have 12

2189
02:03:53,859 --> 02:04:05,198
rotations I don't know if rotates tucked

2190
02:04:00,520 --> 02:04:07,860
snuck back in there it probably didn't

2191
02:04:05,198 --> 02:04:07,859
but I don't know

2192
02:04:27,170 --> 02:04:36,020
looks like it's there so I think it did

2193
02:04:34,489 --> 02:04:40,250
come back in in 512

2194
02:04:36,020 --> 02:04:45,260
I think they added rotate so so there

2195
02:04:40,250 --> 02:04:47,239
are if we ever end up being able to

2196
02:04:45,260 --> 02:04:51,140
program avx-512 which seems at this

2197
02:04:47,239 --> 02:04:52,519
point like a distant dream 512 got it

2198
02:04:51,140 --> 02:04:55,180
those look those look like rotate

2199
02:04:52,520 --> 02:04:55,180
intrinsic to me

2200
02:04:59,770 --> 02:05:04,790
my girlfriend appreciates how much you

2201
02:05:02,119 --> 02:05:06,470
hate on Microsoft in Windows so do i but

2202
02:05:04,789 --> 02:05:08,989
she said your keyboard sounds like

2203
02:05:06,470 --> 02:05:11,920
someone peeing in the next room and it

2204
02:05:08,989 --> 02:05:11,920
has ruined my life

2205
02:05:21,880 --> 02:05:25,170
I just need a flush now

2206
02:05:38,099 --> 02:05:42,719
when client updates using server and

2207
02:05:40,590 --> 02:05:44,849
command plates assume client simulates

2208
02:05:42,719 --> 02:05:47,099
locally it can create discontinuities if

2209
02:05:44,849 --> 02:05:49,440
simulation diverged may be an HMH it

2210
02:05:47,099 --> 02:05:54,179
cannot diverge that much though yeah but

2211
02:05:49,439 --> 02:05:55,469
that's how would this works right so the

2212
02:05:54,179 --> 02:05:56,578
simnet architecture which is

2213
02:05:55,469 --> 02:05:59,239
fundamentally the same thing that

2214
02:05:56,578 --> 02:06:01,590
everyone pretty much uses today right is

2215
02:05:59,238 --> 02:06:04,348
you have a client in a server and they

2216
02:06:01,590 --> 02:06:07,560
both run the simulation the client

2217
02:06:04,349 --> 02:06:10,139
simulation is not right because it

2218
02:06:07,560 --> 02:06:13,349
doesn't know what everyone else has done

2219
02:06:10,139 --> 02:06:15,539
it only knows what it did so it keeps

2220
02:06:13,349 --> 02:06:17,369
trying to run along and the server is

2221
02:06:15,539 --> 02:06:21,988
running the real version that has what

2222
02:06:17,368 --> 02:06:24,328
everyone did in it the server is sending

2223
02:06:21,988 --> 02:06:27,238
packets to the client to force their

2224
02:06:24,328 --> 02:06:29,519
simulate simulations to converge so it's

2225
02:06:27,238 --> 02:06:31,709
constantly sending the updates to the

2226
02:06:29,520 --> 02:06:34,739
client it's like hey you probably got

2227
02:06:31,710 --> 02:06:37,319
this wrong change it to this right so

2228
02:06:34,738 --> 02:06:39,779
that's exactly what the packets are

2229
02:06:37,319 --> 02:06:41,759
designed to do the server sends the

2230
02:06:39,779 --> 02:06:44,539
packets to the client that correct its

2231
02:06:41,760 --> 02:06:48,960
mistakes that's what it's supposed to do

2232
02:06:44,539 --> 02:06:52,469
right in the full simnet architecture a

2233
02:06:48,960 --> 02:06:56,420
server simulates every client the same

2234
02:06:52,469 --> 02:06:59,219
way the client would have updated it and

2235
02:06:56,420 --> 02:07:01,469
then it does its authenticated version

2236
02:06:59,219 --> 02:07:04,590
and it only sends the diffs because now

2237
02:07:01,469 --> 02:07:07,889
it knows exactly what the client would

2238
02:07:04,590 --> 02:07:10,619
have would be thinking most servers

2239
02:07:07,889 --> 02:07:12,989
today don't do that because it's too

2240
02:07:10,618 --> 02:07:15,738
much work but that was the original sim

2241
02:07:12,988 --> 02:07:15,738
that architecture

2242
02:07:38,719 --> 02:07:46,010
and that F arrow I don't know how to

2243
02:07:43,189 --> 02:07:48,559
press that you are correct like what

2244
02:07:46,010 --> 02:07:50,300
most games do is they try to smoothly

2245
02:07:48,560 --> 02:07:54,770
blend as much as they can

2246
02:07:50,300 --> 02:07:56,060
between the update of where the client

2247
02:07:54,770 --> 02:07:58,250
thinks something should be and where the

2248
02:07:56,060 --> 02:08:01,400
server tells it and you tend to kind of

2249
02:07:58,250 --> 02:08:04,340
try to blend between those as much as

2250
02:08:01,399 --> 02:08:05,839
you can sometimes it's just hugely wrong

2251
02:08:04,340 --> 02:08:07,369
and you can't you just got to snap it

2252
02:08:05,840 --> 02:08:08,960
over but you know assuming that it's a

2253
02:08:07,368 --> 02:08:12,618
slight correction you just try to blend

2254
02:08:08,960 --> 02:08:14,359
it we do need the brush strokes or with

2255
02:08:12,618 --> 02:08:24,279
vector graphics from a conversion tool

2256
02:08:14,359 --> 02:08:26,719
work well I I don't tend to like those

2257
02:08:24,279 --> 02:08:29,118
conversion tools they seem to produce

2258
02:08:26,719 --> 02:08:31,130
pretty bad results in my experience that

2259
02:08:29,118 --> 02:08:32,750
aren't really that useful for multi res

2260
02:08:31,130 --> 02:08:34,699
cuz they don't really capture what the

2261
02:08:32,750 --> 02:08:38,060
artist was actually doing they just sort

2262
02:08:34,698 --> 02:08:43,238
of capture the pixel result and I don't

2263
02:08:38,060 --> 02:08:43,239
know how useful that really is right

2264
02:08:52,039 --> 02:09:08,729
alright I'm gonna shut it on down yeah

2265
02:09:06,679 --> 02:09:10,260
alright thank you everyone for joining

2266
02:09:08,729 --> 02:09:11,488
me for the upset of handmade hero it's

2267
02:09:10,260 --> 02:09:13,409
been a pleasure coding with you as

2268
02:09:11,488 --> 02:09:14,579
always if you wanted to follow along

2269
02:09:13,408 --> 02:09:17,009
with the series at home you can always

2270
02:09:14,579 --> 02:09:19,019
peer to the game on handmade hero arc it

2271
02:09:17,010 --> 02:09:22,860
comes with a source code so you can play

2272
02:09:19,020 --> 02:09:25,440
around with it I we got a bunch of other

2273
02:09:22,859 --> 02:09:27,420
stuff on the website check it out you

2274
02:09:25,439 --> 02:09:29,729
can use our watch page to watch a series

2275
02:09:27,420 --> 02:09:31,408
whenever we're live on Twitch it'll show

2276
02:09:29,729 --> 02:09:33,928
up there you can watch the stream it

2277
02:09:31,408 --> 02:09:35,099
also has the schedule posted at all time

2278
02:09:33,929 --> 02:09:37,050
so you know when the next time are going

2279
02:09:35,100 --> 02:09:38,719
to be live is and it's got an episode

2280
02:09:37,050 --> 02:09:41,130
guide that's pretty awesome

2281
02:09:38,719 --> 02:09:43,020
you can type stuff in there and it'll

2282
02:09:41,130 --> 02:09:44,909
search for episodes that have that

2283
02:09:43,020 --> 02:09:46,620
content for you it's it's great so check

2284
02:09:44,908 --> 02:09:48,029
out that page also check out the

2285
02:09:46,619 --> 02:09:50,189
handmade hero fun if you're interested

2286
02:09:48,029 --> 02:09:51,869
in supporting community projects like

2287
02:09:50,189 --> 02:09:54,269
have a network or that episode guide

2288
02:09:51,869 --> 02:09:56,099
that I just talked about it's a great

2289
02:09:54,270 --> 02:09:57,270
way to do it and finally you want to see

2290
02:09:56,100 --> 02:09:58,889
what else we're up to it Molly Rocket

2291
02:09:57,270 --> 02:10:00,150
just click on the handmade hero head got

2292
02:09:58,889 --> 02:10:01,859
all our projects here you can explore

2293
02:10:00,149 --> 02:10:04,170
them as well as my blog people were

2294
02:10:01,859 --> 02:10:09,658
asking today about that filter that'll

2295
02:10:04,170 --> 02:10:12,199
be posted on on here on the the blog

2296
02:10:09,658 --> 02:10:14,399
section as soon as I'm done with that

2297
02:10:12,198 --> 02:10:17,129
that's it for today hope to see you back

2298
02:10:14,399 --> 02:10:18,960
here next week when we will I'm out of

2299
02:10:17,130 --> 02:10:21,869
I'm out of delays I can't delay anymore

2300
02:10:18,960 --> 02:10:23,520
I'm out of things to do I've got to

2301
02:10:21,869 --> 02:10:26,099
start tagging things we'll figure out

2302
02:10:23,520 --> 02:10:27,929
how to do it well so we'll we'll roll up

2303
02:10:26,100 --> 02:10:31,920
our sleeves wearing short sleeves right

2304
02:10:27,929 --> 02:10:34,260
now but wear long sleeves next week and

2305
02:10:31,920 --> 02:10:35,699
we'll roll them up and we will figure

2306
02:10:34,260 --> 02:10:38,730
out how we want to tag these art assets

2307
02:10:35,698 --> 02:10:39,329
and then and then we're done we're done

2308
02:10:38,729 --> 02:10:43,079
with this

2309
02:10:39,329 --> 02:10:45,300
this whole loading for a we can bind

2310
02:10:43,079 --> 02:10:46,439
loading to a key or we can watch a

2311
02:10:45,300 --> 02:10:48,060
directory I don't know what we want to

2312
02:10:46,439 --> 02:10:49,979
do to trigger the reload but it looks

2313
02:10:48,060 --> 02:10:52,830
like it's all working so we're in we're

2314
02:10:49,979 --> 02:10:54,718
in good shape so we can we can have a

2315
02:10:52,829 --> 02:10:56,519
little party hope see you back here for

2316
02:10:54,719 --> 02:10:58,020
that till then have fun programming I'll

2317
02:10:56,520 --> 02:11:00,500
see everyone on the Internet take it

2318
02:10:58,020 --> 02:11:00,500
easy everybody

