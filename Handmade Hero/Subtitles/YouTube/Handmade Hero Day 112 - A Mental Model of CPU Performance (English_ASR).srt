1
00:00:00,000 --> 00:00:05,160
ten minutes over today because we're

2
00:00:02,040 --> 00:00:06,660
gonna need the time all right hello

3
00:00:05,160 --> 00:00:08,309
everyone and welcome to hand made here

4
00:00:06,660 --> 00:00:11,099
on the show we code we code a complete

5
00:00:08,308 --> 00:00:13,529
game from scratch live on Twitch no

6
00:00:11,099 --> 00:00:16,048
library's no no engines this is a

7
00:00:13,529 --> 00:00:18,719
essentially a serious about how to

8
00:00:16,048 --> 00:00:20,039
program everything in games so we cover

9
00:00:18,719 --> 00:00:21,390
everything including how you would

10
00:00:20,039 --> 00:00:24,330
program an engine if you're making your

11
00:00:21,390 --> 00:00:26,099
own and today we're doing a topic that

12
00:00:24,329 --> 00:00:28,799
is one of those topics that is straight

13
00:00:26,099 --> 00:00:31,109
to that point because it's not something

14
00:00:28,800 --> 00:00:33,299
that you might do that much of if you

15
00:00:31,109 --> 00:00:36,200
are just doing very sort of fluffy high

16
00:00:33,299 --> 00:00:38,250
level game code and that is optimization

17
00:00:36,200 --> 00:00:39,690
basically we've gotten to a point where

18
00:00:38,250 --> 00:00:41,909
we finally have some code in hand made

19
00:00:39,689 --> 00:00:44,218
hero that we're calling that does enough

20
00:00:41,909 --> 00:00:47,189
work where it's actually causing us a

21
00:00:44,219 --> 00:00:48,960
framerate problem and so what we want to

22
00:00:47,189 --> 00:00:50,939
do is learn some optimization techniques

23
00:00:48,960 --> 00:00:53,070
to go ahead and speed that up so that it

24
00:00:50,939 --> 00:00:55,170
will not cause us a problem during

25
00:00:53,070 --> 00:00:57,119
development right and so our goal right

26
00:00:55,170 --> 00:00:59,250
now is not necessarily to optimize it

27
00:00:57,119 --> 00:01:01,558
down to like get as fast as possible for

28
00:00:59,250 --> 00:01:03,960
anything but we do need to know enough

29
00:01:01,558 --> 00:01:06,239
optimization right now to be able to

30
00:01:03,960 --> 00:01:08,250
optimize that piece and basically the

31
00:01:06,239 --> 00:01:11,039
principles of optimization are more or

32
00:01:08,250 --> 00:01:12,868
less always the same whether or not you

33
00:01:11,040 --> 00:01:14,549
are trying to do the most optimal

34
00:01:12,868 --> 00:01:16,290
version of something or just an optimal

35
00:01:14,549 --> 00:01:17,430
enough version of something because

36
00:01:16,290 --> 00:01:18,750
really they're the same process it's

37
00:01:17,430 --> 00:01:23,189
just a question of when you stop

38
00:01:18,750 --> 00:01:24,659
iterating on that process and so really

39
00:01:23,188 --> 00:01:26,699
it's a good time to introduce

40
00:01:24,659 --> 00:01:28,170
optimization and talk about how we do it

41
00:01:26,700 --> 00:01:29,519
because we're going to do it at multiple

42
00:01:28,170 --> 00:01:32,070
points on the stream and this is

43
00:01:29,519 --> 00:01:33,509
definitely one of those points so I'm

44
00:01:32,069 --> 00:01:35,239
going to go over to the blackboard and

45
00:01:33,509 --> 00:01:38,009
give a really quick introduction to

46
00:01:35,239 --> 00:01:40,438
optimization how to think about it and

47
00:01:38,009 --> 00:01:43,649
how we are going to be thinking about it

48
00:01:40,438 --> 00:01:45,419
and then we are going to sort of build a

49
00:01:43,649 --> 00:01:47,340
few start building a few primitives that

50
00:01:45,420 --> 00:01:49,290
we're gonna need to do our optimization

51
00:01:47,340 --> 00:01:51,570
work we will probably not do any actual

52
00:01:49,290 --> 00:01:53,939
optimization today because as I'm about

53
00:01:51,569 --> 00:01:56,298
to talk about on the blackboard you you

54
00:01:53,938 --> 00:01:58,618
never the first step to optimization

55
00:01:56,299 --> 00:02:00,090
never has anything to do with actually

56
00:01:58,618 --> 00:02:03,810
optimizing code it has to do with

57
00:02:00,090 --> 00:02:06,540
measuring and determining a bunch of

58
00:02:03,810 --> 00:02:08,489
things about your code before you start

59
00:02:06,540 --> 00:02:10,319
and if you don't do that you're you're

60
00:02:08,489 --> 00:02:12,409
kind of missing out on a big part of

61
00:02:10,318 --> 00:02:15,889
optimizations so let's talk about that

62
00:02:12,409 --> 00:02:22,120
really quickly here on day 112

63
00:02:15,889 --> 00:02:24,819
alright so let's talk about optimization

64
00:02:22,120 --> 00:02:28,310
what it is how you do it

65
00:02:24,819 --> 00:02:29,599
everything about optimization first of

66
00:02:28,310 --> 00:02:32,060
all I'd like to start with a caveat

67
00:02:29,599 --> 00:02:38,419
which is I am NOT one of the world's

68
00:02:32,060 --> 00:02:41,120
best optimizers you are not going to be

69
00:02:38,419 --> 00:02:44,509
getting any incredible gems of wisdom

70
00:02:41,120 --> 00:02:46,819
forming here I am a good-enough

71
00:02:44,509 --> 00:02:48,799
optimizer I optimized code enough to get

72
00:02:46,819 --> 00:02:51,019
it to the place where it needs to be for

73
00:02:48,800 --> 00:02:53,600
for shipping purposes but I am NOT one

74
00:02:51,020 --> 00:02:55,730
of those people who you go to when it's

75
00:02:53,599 --> 00:02:57,349
like oh my god we have this thing and it

76
00:02:55,729 --> 00:03:00,259
needs to be optimized within an inch of

77
00:02:57,349 --> 00:03:02,180
its life that is the other guys that rad

78
00:03:00,259 --> 00:03:06,139
you're talking about Jeff and Fabien

79
00:03:02,180 --> 00:03:07,849
there or you know people who spend all

80
00:03:06,139 --> 00:03:11,119
their time working on optimization stuff

81
00:03:07,849 --> 00:03:12,949
I'm not one of those guys so I'm giving

82
00:03:11,120 --> 00:03:15,080
us basically the generalist view of

83
00:03:12,949 --> 00:03:17,569
optimization which is how do you make

84
00:03:15,080 --> 00:03:20,060
code so that it's fairly good and fairly

85
00:03:17,569 --> 00:03:22,519
performant and typically a lot of the

86
00:03:20,060 --> 00:03:24,560
techniques apply but there's a certain

87
00:03:22,520 --> 00:03:26,840
level beyond which I won't be able to

88
00:03:24,560 --> 00:03:29,209
guide you which gets into things like

89
00:03:26,840 --> 00:03:31,219
crazy stuff like cache line aliasing

90
00:03:29,209 --> 00:03:33,500
issues and all these sorts of things we

91
00:03:31,219 --> 00:03:35,090
won't really be getting into those other

92
00:03:33,500 --> 00:03:38,060
than to mention the fact that they exist

93
00:03:35,090 --> 00:03:39,920
and if you want to be one of those guys

94
00:03:38,060 --> 00:03:41,420
who just spent all your time on

95
00:03:39,919 --> 00:03:42,829
optimization things because there are

96
00:03:41,419 --> 00:03:45,369
people who really like that that's like

97
00:03:42,830 --> 00:03:47,450
what they like to do I'll sort of

98
00:03:45,370 --> 00:03:49,489
mention them as we go so that you're

99
00:03:47,449 --> 00:03:52,639
aware of what you need to go and learn

100
00:03:49,489 --> 00:03:55,280
in order to really push optimization

101
00:03:52,639 --> 00:03:57,279
like past sort of that the crazy point

102
00:03:55,280 --> 00:04:02,110
if you will all right

103
00:03:57,280 --> 00:04:06,500
so essentially what optimization is is

104
00:04:02,110 --> 00:04:10,570
understanding ok there is the CPU right

105
00:04:06,500 --> 00:04:13,879
and a GPU in your computer ok and

106
00:04:10,569 --> 00:04:16,159
everything that happens every frame of

107
00:04:13,879 --> 00:04:19,159
your game is going through one of these

108
00:04:16,160 --> 00:04:21,380
two things and often times both ok

109
00:04:19,160 --> 00:04:24,050
they are both things which look

110
00:04:21,379 --> 00:04:25,949
incredibly similar both of these things

111
00:04:24,050 --> 00:04:27,478
are chips that

112
00:04:25,949 --> 00:04:29,430
you know either soldered on to your

113
00:04:27,478 --> 00:04:33,029
motherboard or on the motherboard and on

114
00:04:29,430 --> 00:04:35,220
a card and so on they are chips and what

115
00:04:33,029 --> 00:04:37,439
those chips do is they decode an

116
00:04:35,220 --> 00:04:39,240
instruction stream right so there's a

117
00:04:37,439 --> 00:04:41,100
bunch of instructions and we've gone

118
00:04:39,240 --> 00:04:42,660
over this before right there you know

119
00:04:41,100 --> 00:04:44,310
we've we looked at this in the very

120
00:04:42,660 --> 00:04:46,680
first streams basically there's an

121
00:04:44,310 --> 00:04:48,449
encoding for that basically tells them

122
00:04:46,680 --> 00:04:49,918
what to do so they go over some

123
00:04:48,449 --> 00:04:52,288
instructions that are basically bytes

124
00:04:49,918 --> 00:04:54,389
that are in their native format and for

125
00:04:52,288 --> 00:04:56,399
each one of those things they do some

126
00:04:54,389 --> 00:04:58,650
computation right they do something and

127
00:04:56,399 --> 00:05:02,429
typically for the instructions that we

128
00:04:58,649 --> 00:05:04,379
tend to care about the most are kind of

129
00:05:02,430 --> 00:05:06,840
followed to two broad categories right

130
00:05:04,379 --> 00:05:08,759
there are things that are like loads and

131
00:05:06,839 --> 00:05:10,948
stores which are basically things that

132
00:05:08,759 --> 00:05:12,689
modify memory right so there's some

133
00:05:10,949 --> 00:05:13,860
memory somewhere and they're gonna do

134
00:05:12,689 --> 00:05:15,538
these loads and stores which are

135
00:05:13,860 --> 00:05:18,150
basically grabbing stuff from memory and

136
00:05:15,538 --> 00:05:21,569
pulling it into the local registers or

137
00:05:18,149 --> 00:05:23,129
the cache of these things operating on

138
00:05:21,569 --> 00:05:24,659
them or their stores which are saying

139
00:05:23,129 --> 00:05:26,639
we've got computer stuff and we push it

140
00:05:24,660 --> 00:05:27,689
out right so there's those types of

141
00:05:26,639 --> 00:05:30,000
instructions which time to think about

142
00:05:27,689 --> 00:05:32,519
and then there's ALU style instructions

143
00:05:30,000 --> 00:05:33,899
right and I guess we won't call it ALU

144
00:05:32,519 --> 00:05:35,969
it's a little ambiguous we'll just say

145
00:05:33,899 --> 00:05:38,939
there's basically than half operations

146
00:05:35,970 --> 00:05:41,340
right there's stuff we want to do right

147
00:05:38,939 --> 00:05:42,990
and typically the way that those work

148
00:05:41,339 --> 00:05:45,418
nowadays and this is a very very

149
00:05:42,990 --> 00:05:46,439
important thing to understand regardless

150
00:05:45,418 --> 00:05:48,000
of which of these we're talking about

151
00:05:46,439 --> 00:05:51,680
because I'm saying both of these things

152
00:05:48,000 --> 00:05:52,860
work this way now math tends to be wide

153
00:05:51,680 --> 00:05:54,900
okay

154
00:05:52,860 --> 00:05:56,098
it tends to be in something called sim D

155
00:05:54,899 --> 00:05:58,469
which is single instruction multiple

156
00:05:56,098 --> 00:05:58,829
data and it means exactly what it sounds

157
00:05:58,470 --> 00:06:01,020
like

158
00:05:58,829 --> 00:06:03,180
there is one instruction but it operates

159
00:06:01,019 --> 00:06:05,819
on multiple pieces of data at once and

160
00:06:03,180 --> 00:06:09,598
typically in the minimal case this is

161
00:06:05,819 --> 00:06:11,459
for things right this is 0 1 2 3 things

162
00:06:09,598 --> 00:06:13,079
and they're all gonna have the same

163
00:06:11,459 --> 00:06:14,250
thing happened to them so you know the

164
00:06:13,079 --> 00:06:18,719
way that we've been looking at code

165
00:06:14,250 --> 00:06:20,939
where we have stuff like float x equals

166
00:06:18,720 --> 00:06:23,370
you know y plus 3 you know we have

167
00:06:20,939 --> 00:06:25,709
something like this this is not at all

168
00:06:23,370 --> 00:06:28,168
how modern processors ever work when

169
00:06:25,709 --> 00:06:30,750
pretty much at all right this does not

170
00:06:28,168 --> 00:06:33,029
happen in a CPU or a GP you ever write

171
00:06:30,750 --> 00:06:34,740
we write that only because we are not

172
00:06:33,029 --> 00:06:38,098
caring about whether the code is optimal

173
00:06:34,740 --> 00:06:38,699
or not what will actually happen 99% of

174
00:06:38,098 --> 00:06:41,009
the time the

175
00:06:38,699 --> 00:06:43,920
if you write this piece of code is that

176
00:06:41,009 --> 00:06:46,529
the processor will actually do this

177
00:06:43,920 --> 00:06:50,069
operation on for floating-point values

178
00:06:46,529 --> 00:06:52,379
right so it'll actually do four X's plus

179
00:06:50,069 --> 00:06:54,689
four wise plus three replicated four

180
00:06:52,379 --> 00:06:56,339
times and it will simply throw away

181
00:06:54,689 --> 00:06:58,469
three of the results and keep only one

182
00:06:56,339 --> 00:07:02,609
of them I'm not joking this is really

183
00:06:58,470 --> 00:07:04,500
true that's what happens and the reason

184
00:07:02,610 --> 00:07:05,759
for that is that most processors are

185
00:07:04,500 --> 00:07:08,670
designed in this way single instruction

186
00:07:05,759 --> 00:07:10,560
multiple data and four is the minimum

187
00:07:08,670 --> 00:07:14,250
number that you would be throwing away

188
00:07:10,560 --> 00:07:17,220
actually there's typically as many often

189
00:07:14,250 --> 00:07:19,290
as many as eight in an Intel CPU soon to

190
00:07:17,220 --> 00:07:28,140
go to sixteen and in the GPU it could be

191
00:07:19,290 --> 00:07:31,140
as many as 64 okay again I wish I was

192
00:07:28,139 --> 00:07:32,879
making this up I'm not making this up so

193
00:07:31,139 --> 00:07:34,349
what that means is when you encounter a

194
00:07:32,879 --> 00:07:36,620
particular instruction like I want to

195
00:07:34,350 --> 00:07:38,760
add two numbers together or I want to

196
00:07:36,620 --> 00:07:40,829
multiply two numbers together any math

197
00:07:38,759 --> 00:07:43,319
operation you are typically talking

198
00:07:40,829 --> 00:07:45,359
about something that is either slightly

199
00:07:43,319 --> 00:07:47,670
wide is least four things wide or

200
00:07:45,360 --> 00:07:50,900
absurdly wide like sixty-four wide

201
00:07:47,670 --> 00:07:53,610
thirty-two wide that sort of thing okay

202
00:07:50,899 --> 00:07:55,709
why do they do that what's the point of

203
00:07:53,610 --> 00:07:58,500
that right I mean it sounds kind of

204
00:07:55,709 --> 00:08:00,930
crazy right the reason is because and

205
00:07:58,500 --> 00:08:03,300
again I'm not a hardware guy so you know

206
00:08:00,930 --> 00:08:04,889
this is sort of the hand-wavy reason and

207
00:08:03,300 --> 00:08:06,240
if you want you know a more detailed

208
00:08:04,889 --> 00:08:08,370
reason you've got to ask a serious

209
00:08:06,240 --> 00:08:10,470
hardware person someone who works on

210
00:08:08,370 --> 00:08:13,170
chip design for a living but basically

211
00:08:10,470 --> 00:08:16,860
the hand-wavy reason is because it's not

212
00:08:13,170 --> 00:08:19,160
free for CPUs and GPUs to decode and

213
00:08:16,860 --> 00:08:21,720
process these instruction streams right

214
00:08:19,160 --> 00:08:22,980
there's a lot of work that goes on in

215
00:08:21,720 --> 00:08:23,880
these instruction streams and let's

216
00:08:22,980 --> 00:08:26,490
think about what one of these

217
00:08:23,879 --> 00:08:28,980
instructions actually is write an

218
00:08:26,490 --> 00:08:31,650
instruction might be something like say

219
00:08:28,980 --> 00:08:32,729
add right and again there's registers we

220
00:08:31,649 --> 00:08:34,679
talked about these before they're the

221
00:08:32,729 --> 00:08:36,840
things that processors operate on and so

222
00:08:34,679 --> 00:08:38,939
you might say like add a you know the

223
00:08:36,840 --> 00:08:40,349
contents of our zero

224
00:08:38,940 --> 00:08:42,090
well actually guess we'll say we'll put

225
00:08:40,349 --> 00:08:45,150
something in our zero so add the

226
00:08:42,090 --> 00:08:47,820
contents of r1 and r2 and put it in our

227
00:08:45,149 --> 00:08:49,829
zero right so we want to do like r1 plus

228
00:08:47,820 --> 00:08:52,500
r2 and we want to put that in our zero

229
00:08:49,830 --> 00:08:55,410
right so that computes r0 equal

230
00:08:52,500 --> 00:08:56,820
r1 plus r2 right this might be what's

231
00:08:55,409 --> 00:08:58,919
encoded in the actual processor some

232
00:08:56,820 --> 00:09:00,600
some bytes that encode the fact that we

233
00:08:58,919 --> 00:09:03,019
want to you know add these things and

234
00:09:00,600 --> 00:09:05,610
these registers right are just you know

235
00:09:03,019 --> 00:09:07,679
some some set the working set the

236
00:09:05,610 --> 00:09:09,000
smallest working set of things that the

237
00:09:07,679 --> 00:09:11,129
processor works on right

238
00:09:09,000 --> 00:09:12,570
maybe there's 16 of them who knows how

239
00:09:11,129 --> 00:09:14,759
many there are different processor to

240
00:09:12,570 --> 00:09:15,900
processor but basically everything looks

241
00:09:14,759 --> 00:09:17,039
like this and if you remember back to

242
00:09:15,899 --> 00:09:19,079
the beginning of handmade hero you

243
00:09:17,039 --> 00:09:21,120
remember how it looked our instruction

244
00:09:19,080 --> 00:09:23,040
streams typically looked like grabbed

245
00:09:21,120 --> 00:09:24,690
something from memory put it into one of

246
00:09:23,039 --> 00:09:25,889
these registers grab another thing from

247
00:09:24,690 --> 00:09:27,810
memory put it into when these registers

248
00:09:25,889 --> 00:09:29,879
operate on them and then write the

249
00:09:27,809 --> 00:09:32,369
result back out from the destination

250
00:09:29,879 --> 00:09:33,689
register to memory right so to give a

251
00:09:32,370 --> 00:09:34,830
complete instruction stream just for

252
00:09:33,690 --> 00:09:37,230
people who don't remember that stuff

253
00:09:34,830 --> 00:09:39,360
very well maybe we'd say like we want to

254
00:09:37,230 --> 00:09:41,759
load something into r1 so we load some

255
00:09:39,360 --> 00:09:43,529
memory into some register into r1 we

256
00:09:41,759 --> 00:09:46,080
load something into r2 we execute the ad

257
00:09:43,529 --> 00:09:49,350
which loads r1 and r2 together right and

258
00:09:46,080 --> 00:09:51,660
then we might store right that that r0

259
00:09:49,350 --> 00:09:53,100
out somewhere right so we load in two

260
00:09:51,659 --> 00:09:54,750
values into the registers of this

261
00:09:53,100 --> 00:09:55,590
processor we add them together and then

262
00:09:54,750 --> 00:09:58,500
we write them out

263
00:09:55,590 --> 00:10:00,540
okay so again a really simple stupid

264
00:09:58,500 --> 00:10:01,710
instruction stream but I'm just getting

265
00:10:00,539 --> 00:10:02,969
you back in that feeling we haven't

266
00:10:01,710 --> 00:10:04,470
talked about this in a while so I'm just

267
00:10:02,970 --> 00:10:05,700
recalling back to the beginning of

268
00:10:04,470 --> 00:10:07,050
things right I want you to think back

269
00:10:05,700 --> 00:10:09,120
about that that's what's actually

270
00:10:07,049 --> 00:10:10,439
happening inside the processor and stuff

271
00:10:09,120 --> 00:10:13,589
like this okay

272
00:10:10,440 --> 00:10:14,970
now what I'm trying to get into I'm

273
00:10:13,589 --> 00:10:16,589
trying to point out here for the

274
00:10:14,970 --> 00:10:18,899
purposes of the cindy discussion is that

275
00:10:16,589 --> 00:10:20,940
this is not free this is a bunch of

276
00:10:18,899 --> 00:10:23,429
circuits that actually have to do all

277
00:10:20,940 --> 00:10:25,860
this work they have to select registers

278
00:10:23,429 --> 00:10:27,479
for add operations they have to know

279
00:10:25,860 --> 00:10:29,070
that we're you know taking this and

280
00:10:27,480 --> 00:10:31,409
adding it to this and brighting it into

281
00:10:29,070 --> 00:10:33,660
this that has to look to see whether or

282
00:10:31,409 --> 00:10:36,149
not this gets used somewhere can it be

283
00:10:33,659 --> 00:10:38,250
multi pipeline can we issue another ad

284
00:10:36,149 --> 00:10:42,659
if there was another ad after this that

285
00:10:38,250 --> 00:10:45,000
looked like this right could I assure

286
00:10:42,659 --> 00:10:47,189
these two in parallel or not well the

287
00:10:45,000 --> 00:10:49,139
answer is no because this one needs the

288
00:10:47,190 --> 00:10:50,760
result of that one right but if this was

289
00:10:49,139 --> 00:10:53,250
our four it could in blah blah blah

290
00:10:50,759 --> 00:10:55,500
right so it's actually incredibly

291
00:10:53,250 --> 00:10:57,000
expensive the work that it has to do to

292
00:10:55,500 --> 00:11:00,179
decode the instruction stream that's

293
00:10:57,000 --> 00:11:02,429
coming in decide how to issue it go find

294
00:11:00,179 --> 00:11:04,229
free units because typically processors

295
00:11:02,429 --> 00:11:06,088
have multiple adding circuits in them

296
00:11:04,230 --> 00:11:07,949
right figure out which adding

297
00:11:06,089 --> 00:11:09,749
rockets are free at any given time to do

298
00:11:07,948 --> 00:11:11,008
this ad maybe this one goes to one and

299
00:11:09,749 --> 00:11:13,139
this one goes to a different one blah

300
00:11:11,009 --> 00:11:14,818
blah blah right so you can see that

301
00:11:13,139 --> 00:11:16,919
there's just a ton of stuff that goes in

302
00:11:14,818 --> 00:11:18,838
here we won't go into hardly any of how

303
00:11:16,919 --> 00:11:20,909
that works because it's not super

304
00:11:18,839 --> 00:11:22,559
relevant unless you want to again go

305
00:11:20,909 --> 00:11:23,759
down the super crazy path of

306
00:11:22,558 --> 00:11:25,558
optimization where you need to start

307
00:11:23,759 --> 00:11:27,839
knowing about like arithmetic unit

308
00:11:25,558 --> 00:11:29,068
pairing and which reservation slots of

309
00:11:27,839 --> 00:11:30,600
whether this thing can issue on this

310
00:11:29,068 --> 00:11:31,588
cycle or the next cycle there's all

311
00:11:30,600 --> 00:11:32,699
these sorts of things that you might

312
00:11:31,589 --> 00:11:35,490
want to get into you might want to know

313
00:11:32,698 --> 00:11:36,838
the full details here that's true if you

314
00:11:35,490 --> 00:11:38,370
want to be a super hardcore optimizer

315
00:11:36,839 --> 00:11:40,290
you do need to know that we might be

316
00:11:38,370 --> 00:11:41,308
won't ever really get into that on this

317
00:11:40,289 --> 00:11:43,828
thing because you probably won't need to

318
00:11:41,308 --> 00:11:44,969
but the point is it's incredibly

319
00:11:43,828 --> 00:11:48,149
incredibly complicated and that

320
00:11:44,970 --> 00:11:51,259
complexity means that if you can

321
00:11:48,149 --> 00:11:53,370
leverage if you're going to typically do

322
00:11:51,259 --> 00:11:56,639
operations on a bunch of data at once

323
00:11:53,370 --> 00:11:58,649
right then if it can leverage all of

324
00:11:56,639 --> 00:12:01,829
that thought thinking that it does here

325
00:11:58,649 --> 00:12:03,389
right to go ahead and make sure that

326
00:12:01,828 --> 00:12:05,120
when it figures out what it needs to do

327
00:12:03,389 --> 00:12:08,009
it can do it on a lot of things at once

328
00:12:05,120 --> 00:12:10,948
that's a total win in terms of circuitry

329
00:12:08,009 --> 00:12:12,959
there and it means that the amount of

330
00:12:10,948 --> 00:12:15,088
actual memory that has to be spun

331
00:12:12,958 --> 00:12:16,979
through in order to decode the

332
00:12:15,089 --> 00:12:19,439
instructions is much less - because if I

333
00:12:16,980 --> 00:12:21,089
have to say if I'm gonna load here and I

334
00:12:19,438 --> 00:12:23,998
can load four pieces of data at once

335
00:12:21,089 --> 00:12:26,129
that's four less instructions of well

336
00:12:23,999 --> 00:12:28,558
three less instructions a quarter of the

337
00:12:26,129 --> 00:12:30,659
instructions to load the data as if I

338
00:12:28,558 --> 00:12:32,578
had to do four instructions to load four

339
00:12:30,659 --> 00:12:34,678
things right same with the ads it's

340
00:12:32,578 --> 00:12:37,498
three less ads I do one add and add four

341
00:12:34,678 --> 00:12:40,528
things instead of having to do four ads

342
00:12:37,499 --> 00:12:43,230
right so if you know that your heavy

343
00:12:40,528 --> 00:12:45,838
workloads can typically be written in

344
00:12:43,230 --> 00:12:47,749
this style it saves a lot of complexity

345
00:12:45,839 --> 00:12:50,429
in the processor and it saves a lot of

346
00:12:47,749 --> 00:12:53,550
instruction space just the footprint

347
00:12:50,428 --> 00:12:55,169
write a lot less memory band but that's

348
00:12:53,549 --> 00:12:57,958
just going into the processor in terms

349
00:12:55,169 --> 00:12:59,849
of like they call this an AI cache

350
00:12:57,958 --> 00:13:01,558
typically it's an instruction cache it's

351
00:12:59,850 --> 00:13:02,879
the place where when you read out

352
00:13:01,558 --> 00:13:03,838
instruction streams and figure out what

353
00:13:02,879 --> 00:13:05,490
to do with them

354
00:13:03,839 --> 00:13:08,009
in terms of like what they actually mean

355
00:13:05,490 --> 00:13:10,499
for the microprocessor basically that a

356
00:13:08,009 --> 00:13:11,639
lot more fits in there at that point

357
00:13:10,499 --> 00:13:14,909
right because you just have less

358
00:13:11,639 --> 00:13:16,798
instructions so basically all processors

359
00:13:14,909 --> 00:13:18,808
work this way now Cindy is everywhere

360
00:13:16,798 --> 00:13:19,769
there isn't a processor you're likely to

361
00:13:18,808 --> 00:13:22,198
program on at all

362
00:13:19,769 --> 00:13:24,808
whether it's a CPU or a GPU that ever

363
00:13:22,198 --> 00:13:26,278
doesn't look like this and so what you

364
00:13:24,808 --> 00:13:34,139
need to think about obviously when

365
00:13:26,278 --> 00:13:37,409
you're in here is when we are talking

366
00:13:34,139 --> 00:13:40,579
about optimization the model that we're

367
00:13:37,409 --> 00:13:44,219
thinking about is this model and we

368
00:13:40,578 --> 00:13:46,078
essentially have three parts to it we

369
00:13:44,220 --> 00:13:47,489
might say which I'll kind of codify now

370
00:13:46,078 --> 00:13:49,109
that I've I've got the Cindy out of the

371
00:13:47,489 --> 00:13:50,249
way hopefully you all understand what

372
00:13:49,110 --> 00:13:52,438
that means when I say that the

373
00:13:50,249 --> 00:13:54,749
instructions are wide means that they're

374
00:13:52,438 --> 00:13:57,360
operating on many things at once right

375
00:13:54,749 --> 00:14:00,239
so we have a few things to think about

376
00:13:57,360 --> 00:14:03,028
right we essentially have the

377
00:14:00,239 --> 00:14:07,230
instructions themselves this is what the

378
00:14:03,028 --> 00:14:15,528
CPU or GPU has to actually do okay we've

379
00:14:07,230 --> 00:14:18,959
got the cache we've got memory right and

380
00:14:15,528 --> 00:14:21,629
what we need to think about is we need

381
00:14:18,958 --> 00:14:23,359
to think about all right whenever we're

382
00:14:21,629 --> 00:14:25,199
talking about optimizing something

383
00:14:23,360 --> 00:14:27,629
essentially everything that we're gonna

384
00:14:25,198 --> 00:14:29,159
do whether it's a CPU or GPU again

385
00:14:27,629 --> 00:14:31,110
always fits this model because this is

386
00:14:29,159 --> 00:14:33,178
all computers can do it's always a

387
00:14:31,110 --> 00:14:36,269
question of moving things from memory

388
00:14:33,178 --> 00:14:37,678
into a cache from a cache into some

389
00:14:36,269 --> 00:14:39,149
instruction set basically I mean you're

390
00:14:37,678 --> 00:14:41,338
not really moving them I guess you could

391
00:14:39,149 --> 00:14:42,720
say there's the registers right I'm

392
00:14:41,339 --> 00:14:46,019
trying to think of how to draw that but

393
00:14:42,720 --> 00:14:48,778
you know if I have that say that add

394
00:14:46,019 --> 00:14:51,568
here or I guess I'll do a load load are

395
00:14:48,778 --> 00:14:52,919
zero something we have to move things

396
00:14:51,568 --> 00:14:54,808
from memory which is where the computer

397
00:14:52,919 --> 00:14:56,308
store ISM GPU our CPU they both have

398
00:14:54,808 --> 00:14:58,409
memory they're gonna go into some kind

399
00:14:56,308 --> 00:15:00,990
of a local cache they're going to get

400
00:14:58,409 --> 00:15:02,818
loaded into registers inside the

401
00:15:00,990 --> 00:15:06,720
processor right they're going to be

402
00:15:02,818 --> 00:15:09,149
manipulated like those those you know

403
00:15:06,720 --> 00:15:10,470
ads we were talking about before and

404
00:15:09,149 --> 00:15:13,889
then they're going to be written back

405
00:15:10,470 --> 00:15:16,259
right they're gonna be written back to

406
00:15:13,889 --> 00:15:18,539
the cache maybe in a different place and

407
00:15:16,259 --> 00:15:21,418
then eventually back out to memory okay

408
00:15:18,539 --> 00:15:23,969
and whenever this is happening these

409
00:15:21,418 --> 00:15:25,619
instructions are going to be wide so

410
00:15:23,970 --> 00:15:27,298
basically almost everything that we do

411
00:15:25,619 --> 00:15:28,649
is going to be one of those single

412
00:15:27,298 --> 00:15:30,869
instruction multiple data things so it's

413
00:15:28,649 --> 00:15:33,330
going to be at least four things wide

414
00:15:30,869 --> 00:15:35,519
possibly more right

415
00:15:33,330 --> 00:15:37,200
so the model for everything we do is we

416
00:15:35,519 --> 00:15:39,269
know we have an instruction stream that

417
00:15:37,200 --> 00:15:40,890
instruction stream grabs things from

418
00:15:39,269 --> 00:15:42,000
memory and pulls them into the cache it

419
00:15:40,889 --> 00:15:43,470
pulls them from the cache into the

420
00:15:42,000 --> 00:15:45,750
registers it operates on the registers

421
00:15:43,470 --> 00:15:47,550
figuring out something computing some

422
00:15:45,750 --> 00:15:49,289
values and then pushing stuff back out

423
00:15:47,549 --> 00:15:58,859
into the cache which then goes back out

424
00:15:49,289 --> 00:16:00,838
to the memory right okay so we talked

425
00:15:58,860 --> 00:16:03,480
about this a little before I'll just

426
00:16:00,839 --> 00:16:04,890
mention it briefly again a cache is

427
00:16:03,480 --> 00:16:07,528
basically something that is on the

428
00:16:04,889 --> 00:16:10,139
processor usually sometimes it's not but

429
00:16:07,528 --> 00:16:14,189
usually on the cache and they have names

430
00:16:10,139 --> 00:16:18,990
like l1 l2 l3 and the number indicates

431
00:16:14,190 --> 00:16:22,079
how essentially how removed they are

432
00:16:18,990 --> 00:16:23,970
from the the CPU in a sense you could

433
00:16:22,078 --> 00:16:25,500
think of the registers themselves the

434
00:16:23,970 --> 00:16:28,200
thing that the CPU actually operates on

435
00:16:25,500 --> 00:16:29,879
as an l0 in some sense right it's the

436
00:16:28,200 --> 00:16:32,670
things that the CPU actually directly

437
00:16:29,879 --> 00:16:34,259
addresses and it is instantaneous for

438
00:16:32,669 --> 00:16:36,000
them to get them essentially right it's

439
00:16:34,259 --> 00:16:37,500
not entirely true but it's like the

440
00:16:36,000 --> 00:16:41,309
fastest thing for the processor to work

441
00:16:37,500 --> 00:16:43,649
on is its registers then it has series

442
00:16:41,309 --> 00:16:45,149
of diminishing lis small memory I'm

443
00:16:43,649 --> 00:16:48,208
sorry it has series of increasingly

444
00:16:45,149 --> 00:16:49,950
large memories it can access the l1

445
00:16:48,208 --> 00:16:52,109
cache the l2 cache the l3 cache

446
00:16:49,950 --> 00:16:54,959
sometimes might not have one and then

447
00:16:52,110 --> 00:16:57,269
main memory right and the cost of

448
00:16:54,958 --> 00:16:59,909
getting things from each of these gets

449
00:16:57,269 --> 00:17:01,949
increasingly expensive as you go off so

450
00:16:59,909 --> 00:17:04,588
whereas an l1 cache may be something

451
00:17:01,950 --> 00:17:06,720
like you know 16 cycles to grab from and

452
00:17:04,588 --> 00:17:08,759
an l2 cache might be more than that and

453
00:17:06,720 --> 00:17:11,308
l3 cache more than that up to main

454
00:17:08,759 --> 00:17:15,509
memory which may be something like 300

455
00:17:11,308 --> 00:17:17,160
cycles right and one of these

456
00:17:15,509 --> 00:17:21,480
instructions like an ad might be two

457
00:17:17,160 --> 00:17:24,329
cycles right so if you figure like okay

458
00:17:21,480 --> 00:17:26,429
looking at how this works if I want to

459
00:17:24,328 --> 00:17:29,069
talk about how expensive something is I

460
00:17:26,429 --> 00:17:31,019
could think about the fact that as I

461
00:17:29,069 --> 00:17:33,269
sort of get further away from the

462
00:17:31,019 --> 00:17:35,519
instruction stream those registers that

463
00:17:33,269 --> 00:17:37,918
I'm actually a proper ating on as I get

464
00:17:35,519 --> 00:17:40,349
further away from those I get more and

465
00:17:37,919 --> 00:17:42,740
more expensive to - basically how long

466
00:17:40,349 --> 00:17:45,799
it takes me to pull something in right

467
00:17:42,740 --> 00:17:47,870
okay so let's talk about this model

468
00:17:45,799 --> 00:17:50,869
over here because there's a lot of stuff

469
00:17:47,869 --> 00:17:52,669
to cover but just keep this in your mind

470
00:17:50,869 --> 00:17:55,189
basically this this diagram here we're

471
00:17:52,670 --> 00:17:56,480
gonna refer to it a lot all right so

472
00:17:55,190 --> 00:17:59,299
first let's talk about these things I

473
00:17:56,480 --> 00:18:01,460
just said which are cycles right cycles

474
00:17:59,299 --> 00:18:05,389
are basically the smallest thing that

475
00:18:01,460 --> 00:18:08,090
the CPU enumerates work in okay so

476
00:18:05,390 --> 00:18:10,400
basically when you ask the CPU to do

477
00:18:08,089 --> 00:18:13,579
something typically it's going to take

478
00:18:10,400 --> 00:18:16,940
some of these right it takes some of

479
00:18:13,579 --> 00:18:19,839
these to do something right and what

480
00:18:16,940 --> 00:18:22,460
they more or less coincide with is

481
00:18:19,839 --> 00:18:24,709
processors themselves run at a certain

482
00:18:22,460 --> 00:18:26,779
rate and they have internal clocking

483
00:18:24,710 --> 00:18:28,819
it's far beyond my knowledge of how that

484
00:18:26,779 --> 00:18:30,500
clocking works I'm sure it works very

485
00:18:28,819 --> 00:18:33,849
differently now from the old days when I

486
00:18:30,500 --> 00:18:33,849
sort of learned basically what it was

487
00:18:34,059 --> 00:18:39,679
but this is sort of what the processor

488
00:18:37,009 --> 00:18:42,349
is doing every step every cycle it can

489
00:18:39,680 --> 00:18:45,860
do something right each individual cycle

490
00:18:42,349 --> 00:18:47,179
it can do something so when we talk

491
00:18:45,859 --> 00:18:48,559
about a processor and we talk about how

492
00:18:47,180 --> 00:18:54,950
fast it is like for example this

493
00:18:48,559 --> 00:18:56,450
processor in this machine right here we

494
00:18:54,950 --> 00:18:57,920
can actually look at the details or I

495
00:18:56,450 --> 00:19:00,170
thought we could look at the details

496
00:18:57,920 --> 00:19:04,039
that's not what I want

497
00:19:00,170 --> 00:19:06,410
where's the just the how do I get just

498
00:19:04,039 --> 00:19:07,059
the details of this computer you know

499
00:19:06,410 --> 00:19:14,000
what I'm saying

500
00:19:07,059 --> 00:19:15,950
just computer there it is so you can see

501
00:19:14,000 --> 00:19:18,109
this is a three point one nine gigahertz

502
00:19:15,950 --> 00:19:22,460
processor it's actually got two of them

503
00:19:18,109 --> 00:19:24,139
in their 3.2 gigahertz is the rated

504
00:19:22,460 --> 00:19:28,400
speed so we'll use that for now all

505
00:19:24,140 --> 00:19:30,440
right so a 3.2 gigahertz processor which

506
00:19:28,400 --> 00:19:33,050
is what it's in this machine okay

507
00:19:30,440 --> 00:19:35,720
gigahertz is an SI unit so it's actually

508
00:19:33,049 --> 00:19:38,089
a thousand it's not 1024 like gigabytes

509
00:19:35,720 --> 00:19:39,589
right so the gigahertz is actually a

510
00:19:38,089 --> 00:19:41,089
thousand times a thousand times a

511
00:19:39,589 --> 00:19:42,889
thousand right

512
00:19:41,089 --> 00:19:44,240
a thousand this would be kilohertz this

513
00:19:42,890 --> 00:19:46,370
would be megahertz this would be

514
00:19:44,240 --> 00:19:50,210
gigahertz right so we're talking about

515
00:19:46,369 --> 00:19:52,929
3.2 times 1,000 times a thousand times

516
00:19:50,210 --> 00:19:56,590
thousand right that is how many cycles

517
00:19:52,930 --> 00:19:56,590
per second

518
00:19:57,349 --> 00:20:04,129
okay that is how many cycles per second

519
00:20:00,278 --> 00:20:05,960
we expect this processor to run it right

520
00:20:04,130 --> 00:20:07,789
now it could change that can change

521
00:20:05,960 --> 00:20:09,440
sometimes because processors have lower

522
00:20:07,788 --> 00:20:10,970
power states they have power saving

523
00:20:09,440 --> 00:20:12,470
cycles in stuff like that they might

524
00:20:10,970 --> 00:20:14,058
underclock themselves there's all kinds

525
00:20:12,470 --> 00:20:16,480
of reasons that it might fluctuate but

526
00:20:14,058 --> 00:20:22,819
at maximum when it is running full-bore

527
00:20:16,480 --> 00:20:26,569
that is what it will do right so that

528
00:20:22,819 --> 00:20:29,210
means we have three to zero Jimmy zero

529
00:20:26,569 --> 00:20:33,918
zero zero zero zero zero zero zero right

530
00:20:29,210 --> 00:20:37,879
basically 3.2 billion cycles per second

531
00:20:33,919 --> 00:20:40,159
right so that is how many the processor

532
00:20:37,878 --> 00:20:41,990
is actually going to issue how many

533
00:20:40,159 --> 00:20:43,789
cycles it's going to go through in one

534
00:20:41,990 --> 00:20:46,250
second now what's interesting about that

535
00:20:43,788 --> 00:20:48,528
right I'm gonna go ahead and even though

536
00:20:46,250 --> 00:20:50,089
we don't need it at the very moment I

537
00:20:48,528 --> 00:20:51,740
want to open up Emacs so I can use the

538
00:20:50,089 --> 00:20:54,949
little quick calc feature we were using

539
00:20:51,740 --> 00:20:57,319
right right so if I do 3.2 times a

540
00:20:54,950 --> 00:21:00,919
thousand times thousand times a thousand

541
00:20:57,319 --> 00:21:03,378
right there is my cycles oh you know

542
00:21:00,919 --> 00:21:05,600
what I don't know how to use the laughs

543
00:21:03,378 --> 00:21:08,058
there it is I love B max when it does

544
00:21:05,599 --> 00:21:09,138
that for you okay so there's that now we

545
00:21:08,058 --> 00:21:11,269
know that that's how many cycles per

546
00:21:09,138 --> 00:21:13,128
second but we know we do 30 frames per

547
00:21:11,269 --> 00:21:15,138
second right our game runs 30 frames a

548
00:21:13,128 --> 00:21:18,888
second which means every frame we have

549
00:21:15,138 --> 00:21:20,750
that many right that's how many of poops

550
00:21:18,888 --> 00:21:24,138
didn't mean for that to go away come

551
00:21:20,750 --> 00:21:26,148
back that's how many we actually have

552
00:21:24,138 --> 00:21:29,388
right so you can see here we've got like

553
00:21:26,148 --> 00:21:33,678
a hundred and six million or like 107

554
00:21:29,388 --> 00:21:39,939
million cycles per frame right so let's

555
00:21:33,679 --> 00:21:46,340
just write that down 107 million cycles

556
00:21:39,940 --> 00:21:48,679
per frame okay this is on the CPU so

557
00:21:46,339 --> 00:21:51,558
what that means is we have a hundred and

558
00:21:48,679 --> 00:21:53,210
seven million cycles to get everything

559
00:21:51,558 --> 00:21:56,599
that we need to get done in a frame done

560
00:21:53,210 --> 00:21:58,278
right and if we don't get everything

561
00:21:56,599 --> 00:21:59,990
that we need to have done in a frame

562
00:21:58,278 --> 00:22:02,148
done in that hundred and seven million

563
00:21:59,990 --> 00:22:06,169
cycles our gain will not hit 30 frames a

564
00:22:02,148 --> 00:22:08,959
second right it's that simple and so the

565
00:22:06,169 --> 00:22:11,000
first essentially thing that I want you

566
00:22:08,960 --> 00:22:12,680
to think about in terms of optimization

567
00:22:11,000 --> 00:22:14,839
is you should always know what this

568
00:22:12,680 --> 00:22:18,019
number is right you should always start

569
00:22:14,839 --> 00:22:23,779
out by going okay given whatever it is I

570
00:22:18,019 --> 00:22:25,730
have to work with right what is actually

571
00:22:23,779 --> 00:22:27,619
the base amount of performance I even

572
00:22:25,730 --> 00:22:30,829
have to work with what am i working with

573
00:22:27,619 --> 00:22:32,419
what are those numbers right and this is

574
00:22:30,829 --> 00:22:34,519
the first primary number we need to

575
00:22:32,420 --> 00:22:37,250
think about 107 million cycles per frame

576
00:22:34,519 --> 00:22:41,269
that's how many cycles we have on one of

577
00:22:37,250 --> 00:22:45,109
the CPUs to do our work right now this

578
00:22:41,269 --> 00:22:46,879
is of course not entirely that's not the

579
00:22:45,109 --> 00:22:50,559
entirety of the picture because this is

580
00:22:46,880 --> 00:22:53,360
essentially one core on one CPU right

581
00:22:50,559 --> 00:22:55,369
now in a machine there may be multiple

582
00:22:53,359 --> 00:22:57,079
processors and maybe multiple CPU cores

583
00:22:55,369 --> 00:23:00,649
that sort of thing and technically each

584
00:22:57,079 --> 00:23:02,210
core actually gets this many right so

585
00:23:00,650 --> 00:23:03,710
really depending on the machine we're

586
00:23:02,210 --> 00:23:05,870
targeting let's say we have a four core

587
00:23:03,710 --> 00:23:07,430
machine or something like that then we

588
00:23:05,869 --> 00:23:09,379
know we actually have more than this if

589
00:23:07,430 --> 00:23:10,580
we can divide up the work among multiple

590
00:23:09,380 --> 00:23:12,170
processors but we're gonna get to that

591
00:23:10,579 --> 00:23:15,139
in a second for now I just want you to

592
00:23:12,170 --> 00:23:17,480
focus on on one core on one CPU we have

593
00:23:15,140 --> 00:23:19,490
this many cycles per frame all of our

594
00:23:17,480 --> 00:23:25,250
work that has to be done on the CPU must

595
00:23:19,490 --> 00:23:27,880
fit into that number okay now it's

596
00:23:25,250 --> 00:23:30,259
already pretty low number 107 million

597
00:23:27,880 --> 00:23:31,640
right it's not that high and why do I

598
00:23:30,259 --> 00:23:33,440
say that well think about how many

599
00:23:31,640 --> 00:23:37,580
pixels on the screen there would be at

600
00:23:33,440 --> 00:23:42,049
1920 by 1080 right there's let's see

601
00:23:37,579 --> 00:23:45,039
there is 2 million right so there's 2

602
00:23:42,049 --> 00:23:48,289
million pixels on the screen at 1980 by

603
00:23:45,039 --> 00:23:50,480
1980 by by 10 20 right an HD display

604
00:23:48,289 --> 00:23:52,099
right 2 million so if you think about

605
00:23:50,480 --> 00:23:55,549
how many cycles per pixel

606
00:23:52,099 --> 00:23:56,809
there actually are to process if we were

607
00:23:55,549 --> 00:23:59,750
doing you know like software rendering

608
00:23:56,809 --> 00:24:01,759
like we're doing right now they're not

609
00:23:59,750 --> 00:24:04,099
that many right there's like you know

610
00:24:01,759 --> 00:24:06,019
something like 50 cycles of pixel right

611
00:24:04,099 --> 00:24:07,429
that's it 50 cycles of pixel

612
00:24:06,019 --> 00:24:09,799
not a very large number right what's

613
00:24:07,430 --> 00:24:12,470
this number divided by 2 right 107

614
00:24:09,799 --> 00:24:15,559
divided by 2 like 50 very very small

615
00:24:12,470 --> 00:24:16,880
right it's not a very big number so just

616
00:24:15,559 --> 00:24:18,589
want to sort of put that in your head

617
00:24:16,880 --> 00:24:21,250
that 107 million cycles per frame is

618
00:24:18,589 --> 00:24:21,250
actually not that many

619
00:24:23,160 --> 00:24:26,950
this is why you know you see a lot of

620
00:24:25,630 --> 00:24:28,990
stuff that doesn't run at 30 frames a

621
00:24:26,950 --> 00:24:30,580
second right you open up the you know

622
00:24:28,990 --> 00:24:32,230
some kind of app and it's super laggy

623
00:24:30,579 --> 00:24:34,750
and weird and janky it's like it's

624
00:24:32,230 --> 00:24:36,160
actually important that this number not

625
00:24:34,750 --> 00:24:38,859
be exceeded and often times things will

626
00:24:36,160 --> 00:24:40,150
right so anyway that's the first thing

627
00:24:38,859 --> 00:24:42,459
you want to think about that Mesa cycles

628
00:24:40,150 --> 00:24:44,200
per frame next thing you won't ever

629
00:24:42,460 --> 00:24:46,900
actually get a hundred and seven cycles

630
00:24:44,200 --> 00:24:49,120
for frame probably right because well

631
00:24:46,900 --> 00:24:50,290
maybe sometimes you will but other times

632
00:24:49,119 --> 00:24:53,139
there's stuff that needs to happen

633
00:24:50,289 --> 00:24:55,000
that's not your cycles right so for

634
00:24:53,140 --> 00:24:57,190
example there's stuff that when we call

635
00:24:55,000 --> 00:24:58,960
Windows to display the frame right we

636
00:24:57,190 --> 00:25:00,460
just we have stuff we have to do we call

637
00:24:58,960 --> 00:25:02,559
windows to get the state of the joystick

638
00:25:00,460 --> 00:25:04,269
and whatever right there's a bunch of

639
00:25:02,559 --> 00:25:06,399
stuff that we don't actually control

640
00:25:04,269 --> 00:25:08,529
that is using some of those cycles so

641
00:25:06,400 --> 00:25:10,180
depending on which core and which CPU

642
00:25:08,529 --> 00:25:13,059
were talking about we may not even be

643
00:25:10,180 --> 00:25:15,460
talking about all 107 million cycles for

644
00:25:13,059 --> 00:25:17,619
up being for our use right but in

645
00:25:15,460 --> 00:25:19,509
today's world where there's multi-core

646
00:25:17,619 --> 00:25:21,219
if you have a user whose machine has

647
00:25:19,509 --> 00:25:22,900
been set up to not have tons of like

648
00:25:21,220 --> 00:25:26,079
Adobe Acrobat running in the background

649
00:25:22,900 --> 00:25:28,000
and like I'm sorry Acrobat Reader like

650
00:25:26,079 --> 00:25:29,500
sitting there checking for updates Adobe

651
00:25:28,000 --> 00:25:30,849
Creative Cloud looking to see if it's

652
00:25:29,500 --> 00:25:32,589
license is valid and everything else

653
00:25:30,849 --> 00:25:34,059
happening assuming that you have a user

654
00:25:32,589 --> 00:25:38,799
who's got a machine set up for gaming

655
00:25:34,059 --> 00:25:40,329
and it's relatively clean maybe on a

656
00:25:38,799 --> 00:25:42,519
bunch of those cores you actually are

657
00:25:40,329 --> 00:25:44,649
getting 100 site seven cycles per frame

658
00:25:42,519 --> 00:25:46,509
but on at least one of them which is the

659
00:25:44,650 --> 00:25:50,950
one where you interface with Windows you

660
00:25:46,509 --> 00:25:54,430
don't so that's the next thing to be

661
00:25:50,950 --> 00:25:56,019
aware of all right so let's keep that in

662
00:25:54,430 --> 00:26:03,009
mind just think about that keep it in

663
00:25:56,019 --> 00:26:04,809
mind the next thing what is a cycle what

664
00:26:03,009 --> 00:26:06,879
actually is it right because we know

665
00:26:04,809 --> 00:26:07,779
that it's running at this rate but we

666
00:26:06,880 --> 00:26:11,290
don't really know what that actually

667
00:26:07,779 --> 00:26:12,819
means right so it helps to have some

668
00:26:11,289 --> 00:26:15,490
wonder standing what actually happens in

669
00:26:12,819 --> 00:26:17,619
the CPU on something called a cycle

670
00:26:15,490 --> 00:26:19,509
right and so basically what will happen

671
00:26:17,619 --> 00:26:22,179
in the cycle and again this is a very

672
00:26:19,509 --> 00:26:23,559
very high-level overview of what happens

673
00:26:22,180 --> 00:26:25,180
in a cycle and a processor this is not a

674
00:26:23,559 --> 00:26:27,009
hard-r exhalation it's just a mental

675
00:26:25,180 --> 00:26:29,440
model for you to understand roughly what

676
00:26:27,009 --> 00:26:32,890
is going on so please take it with with

677
00:26:29,440 --> 00:26:34,720
that large grain of salt so what's

678
00:26:32,890 --> 00:26:35,960
happening in the cycle first of all

679
00:26:34,720 --> 00:26:39,410
right

680
00:26:35,960 --> 00:26:41,150
is there is an assumption presumably

681
00:26:39,410 --> 00:26:44,210
remember I told you there's that thing

682
00:26:41,150 --> 00:26:45,980
called an eye cache right so basically a

683
00:26:44,210 --> 00:26:47,569
processor usually has a thing that's

684
00:26:45,980 --> 00:26:49,339
some kind of a cache that has the

685
00:26:47,569 --> 00:26:51,079
instructions in it and these things are

686
00:26:49,339 --> 00:26:53,599
actually decoded they're usually in

687
00:26:51,079 --> 00:26:56,419
something called micro code okay and

688
00:26:53,599 --> 00:26:58,699
what micro code is is they're not

689
00:26:56,420 --> 00:27:03,890
exactly necessarily the instructions

690
00:26:58,700 --> 00:27:05,180
that we see when we look at when we

691
00:27:03,890 --> 00:27:06,470
start talking about optimizing things

692
00:27:05,180 --> 00:27:08,570
and look at the instructions they're not

693
00:27:06,470 --> 00:27:11,180
actually the ones that we see they might

694
00:27:08,569 --> 00:27:13,250
be so it might be that like an ad like

695
00:27:11,180 --> 00:27:15,259
something like this ad actually is just

696
00:27:13,250 --> 00:27:16,849
an ad like it's just one instruction in

697
00:27:15,259 --> 00:27:17,930
the micro code but there's other

698
00:27:16,849 --> 00:27:20,089
instructions that might be multiple

699
00:27:17,930 --> 00:27:25,130
micro code instructions so really

700
00:27:20,089 --> 00:27:27,289
there's essentially two if you will this

701
00:27:25,130 --> 00:27:30,560
is like the memory where our code lives

702
00:27:27,289 --> 00:27:32,869
right there's two things there's

703
00:27:30,559 --> 00:27:34,759
instructions here and there's

704
00:27:32,869 --> 00:27:36,889
instructions here and when they get

705
00:27:34,759 --> 00:27:41,869
loaded when they load here it's actually

706
00:27:36,890 --> 00:27:44,870
load and decode right if that makes

707
00:27:41,869 --> 00:27:46,699
sense so basically code that we write

708
00:27:44,869 --> 00:27:48,199
that was compiled into instructions by

709
00:27:46,700 --> 00:27:50,420
the compiler is actually getting loaded

710
00:27:48,200 --> 00:27:52,610
into this I cache and decoded into a

711
00:27:50,420 --> 00:27:54,470
series of micro code instructions which

712
00:27:52,609 --> 00:27:58,159
are not necessarily a one-to-one

713
00:27:54,470 --> 00:28:00,620
correspondence with our instructions we

714
00:27:58,160 --> 00:28:03,410
see so what I'm about to say next is

715
00:28:00,619 --> 00:28:06,589
true for micro code instructions not

716
00:28:03,410 --> 00:28:08,090
instructions we see and sometimes you

717
00:28:06,589 --> 00:28:09,589
will have the benefit of knowing what

718
00:28:08,089 --> 00:28:11,419
that micro code is sometimes you won't

719
00:28:09,589 --> 00:28:12,470
it depends on how documented the

720
00:28:11,420 --> 00:28:14,210
processor is that you're working with

721
00:28:12,470 --> 00:28:21,110
and how much the manufacturer wants to

722
00:28:14,210 --> 00:28:22,490
share with you and so on okay so we pull

723
00:28:21,109 --> 00:28:25,039
these things into this I cache what the

724
00:28:22,490 --> 00:28:26,299
I cache is is this just like a cache for

725
00:28:25,039 --> 00:28:28,430
data like we were talking about before

726
00:28:26,299 --> 00:28:31,220
but all it does is cache decoded

727
00:28:28,430 --> 00:28:33,740
instructions usually and then the

728
00:28:31,220 --> 00:28:36,799
processor is reading out of this right

729
00:28:33,740 --> 00:28:41,029
it's fetching some instruction out of

730
00:28:36,799 --> 00:28:43,099
this okay so on one cycle what is

731
00:28:41,029 --> 00:28:46,339
happening is it is going to go and fetch

732
00:28:43,099 --> 00:28:47,839
some number of instructions right so

733
00:28:46,339 --> 00:28:49,429
it's going to fetch and maybe that

734
00:28:47,839 --> 00:28:53,119
number might be as many as

735
00:28:49,430 --> 00:28:55,370
pay for instructions right why did I

736
00:28:53,119 --> 00:28:58,639
just I don't know what just tap in there

737
00:28:55,369 --> 00:28:59,989
stop drawing it could be like for

738
00:28:58,640 --> 00:29:02,000
instructions it could be who knows how

739
00:28:59,990 --> 00:29:04,130
many depends on the processor it's going

740
00:29:02,000 --> 00:29:06,920
to fetch some instructions okay

741
00:29:04,130 --> 00:29:10,070
Amos going to fetch them potentially out

742
00:29:06,920 --> 00:29:11,660
of order right so depending on the

743
00:29:10,069 --> 00:29:13,059
processor in the old days this was very

744
00:29:11,660 --> 00:29:14,660
simple it always fetch them in order

745
00:29:13,059 --> 00:29:16,579
nowadays it doesn't even necessarily

746
00:29:14,660 --> 00:29:18,560
fetch them in order right so the

747
00:29:16,579 --> 00:29:20,299
processor is going to have a thing it's

748
00:29:18,559 --> 00:29:22,490
going to look at some window of

749
00:29:20,299 --> 00:29:24,740
instructions in the microcode it's going

750
00:29:22,490 --> 00:29:27,380
to fetch some instructions if things

751
00:29:24,740 --> 00:29:29,000
that can do and it will issue I think up

752
00:29:27,380 --> 00:29:30,050
to four is how many it typically issues

753
00:29:29,000 --> 00:29:31,609
on a minor press but I'm going to say

754
00:29:30,049 --> 00:29:34,159
it's gonna issue some number of them

755
00:29:31,609 --> 00:29:36,019
right so it fetches some number of them

756
00:29:34,160 --> 00:29:37,610
that it thinks it can issue right and

757
00:29:36,019 --> 00:29:39,650
they go in here right so maybe I have

758
00:29:37,609 --> 00:29:42,049
instruction 1 this is instruction 1 0

759
00:29:39,650 --> 00:29:44,720
instruction 2 1 instruction 2

760
00:29:42,049 --> 00:29:46,669
instruction 3 all right so I fetched

761
00:29:44,720 --> 00:29:48,769
these instructions and then I'm going to

762
00:29:46,670 --> 00:29:51,050
issue these instructions so on this

763
00:29:48,769 --> 00:29:52,910
cycle it will look at these instructions

764
00:29:51,049 --> 00:29:54,680
right and issue them so they go off to

765
00:29:52,910 --> 00:29:57,380
parts of the chip they're going off to

766
00:29:54,680 --> 00:29:59,570
parts of the CPU to be operated on right

767
00:29:57,380 --> 00:30:01,010
so these go out to some units we don't

768
00:29:59,569 --> 00:30:03,079
know what kind of units they are inside

769
00:30:01,009 --> 00:30:04,609
the processor you know maybe ones an

770
00:30:03,079 --> 00:30:06,500
arithmetic logic unit so it's going off

771
00:30:04,609 --> 00:30:07,849
to an ALU one's a memory units going up

772
00:30:06,500 --> 00:30:09,769
to some fetch some data I don't know

773
00:30:07,849 --> 00:30:11,240
what but point being we're going into

774
00:30:09,769 --> 00:30:12,680
this instruction Katrine inside the eye

775
00:30:11,240 --> 00:30:14,390
cache we're getting back some things

776
00:30:12,680 --> 00:30:16,850
we're gonna issue them now what happens

777
00:30:14,390 --> 00:30:18,440
in here I said order question mark what

778
00:30:16,849 --> 00:30:20,329
basically happens in here is modern

779
00:30:18,440 --> 00:30:23,029
processors in order to speed things up

780
00:30:20,329 --> 00:30:24,649
now issue things out of order what that

781
00:30:23,029 --> 00:30:29,089
means is that if the instruction stream

782
00:30:24,650 --> 00:30:31,730
said ABCDEF you know gee these are some

783
00:30:29,089 --> 00:30:33,439
instructions that i want to do the the

784
00:30:31,730 --> 00:30:36,019
there's actually a part of the processor

785
00:30:33,440 --> 00:30:38,539
that will look at these and go okay i

786
00:30:36,019 --> 00:30:41,089
can execute any now i can execute b now

787
00:30:38,539 --> 00:30:42,980
see i couldn't execute because c

788
00:30:41,089 --> 00:30:45,649
actually depends on a and b to have

789
00:30:42,980 --> 00:30:48,380
completed right c uses like a result

790
00:30:45,650 --> 00:30:50,269
from b or something with this right and

791
00:30:48,380 --> 00:30:52,370
a result from a it's like adding the

792
00:30:50,269 --> 00:30:54,319
result of a and b or something so i

793
00:30:52,369 --> 00:30:55,849
can't issue that right now but I could

794
00:30:54,319 --> 00:30:57,230
still issue another instruction because

795
00:30:55,849 --> 00:31:00,199
I could issue like four instructions

796
00:30:57,230 --> 00:31:02,029
this frame so I'm gonna grab D and E as

797
00:31:00,200 --> 00:31:02,860
well even though C isn't there because

798
00:31:02,029 --> 00:31:05,019
they don't have any

799
00:31:02,859 --> 00:31:07,269
seize on see let's say and it will bring

800
00:31:05,019 --> 00:31:09,879
all of those up and remember that it

801
00:31:07,269 --> 00:31:12,039
hasn't executed see so that later once

802
00:31:09,880 --> 00:31:15,160
when a and B complete it can grab C an

803
00:31:12,039 --> 00:31:16,928
issue it right and so modern-day Intel

804
00:31:15,160 --> 00:31:18,130
processors for example are heavily

805
00:31:16,929 --> 00:31:21,460
heavily out of order

806
00:31:18,130 --> 00:31:23,170
they work around the latency that you

807
00:31:21,460 --> 00:31:24,548
can imagine here where if you have to

808
00:31:23,170 --> 00:31:25,808
you know if I have to wait for these two

809
00:31:24,548 --> 00:31:27,250
things to be done

810
00:31:25,808 --> 00:31:29,710
I can't issue this right they work

811
00:31:27,250 --> 00:31:31,660
around that by having a very large

812
00:31:29,710 --> 00:31:33,670
window of instructions they look at and

813
00:31:31,660 --> 00:31:37,290
grabbing maximally from that window

814
00:31:33,670 --> 00:31:40,750
right so hopefully that makes some sense

815
00:31:37,289 --> 00:31:43,119
okay so once it gets those and it issues

816
00:31:40,750 --> 00:31:46,329
them they go out into what's generally

817
00:31:43,119 --> 00:31:47,500
called a pipeline right and this is

818
00:31:46,329 --> 00:31:50,409
actually the first step of that pipeline

819
00:31:47,500 --> 00:31:53,079
okay and the pipeline is actually

820
00:31:50,410 --> 00:31:55,390
enumerated in cycles so on a cycle

821
00:31:53,079 --> 00:31:57,909
what's actually happening is this this

822
00:31:55,390 --> 00:32:00,509
instruction issue is happening but also

823
00:31:57,910 --> 00:32:03,519
simultaneously on that these units are

824
00:32:00,509 --> 00:32:05,859
working on whatever the last instruction

825
00:32:03,519 --> 00:32:08,019
was that they were given and each of

826
00:32:05,859 --> 00:32:10,798
those instructions may take a certain

827
00:32:08,019 --> 00:32:14,798
number of what's called pipeline stages

828
00:32:10,798 --> 00:32:17,740
to complete so if I do an ADD here and

829
00:32:14,798 --> 00:32:20,259
add for example might take two stages so

830
00:32:17,740 --> 00:32:21,640
let's say this was an ADD here's the ALU

831
00:32:20,259 --> 00:32:25,419
unit gets the assignment on the add

832
00:32:21,640 --> 00:32:28,480
maybe that takes one cycle maybe on the

833
00:32:25,419 --> 00:32:30,130
issuing cycle like it could be most of

834
00:32:28,480 --> 00:32:31,960
the time I'd actually like to say that

835
00:32:30,130 --> 00:32:33,040
this is not really a line here in fact I

836
00:32:31,960 --> 00:32:37,269
probably shouldn't have drawn that line

837
00:32:33,039 --> 00:32:39,639
let me remove that typically I believe

838
00:32:37,269 --> 00:32:40,900
and again I'm not a hardware guy so

839
00:32:39,640 --> 00:32:43,720
don't you know take this with a grain of

840
00:32:40,900 --> 00:32:46,870
salt but typically on the on the cycle

841
00:32:43,720 --> 00:32:48,880
that's issued it does the first the

842
00:32:46,869 --> 00:32:50,649
first part of the work in the unit right

843
00:32:48,880 --> 00:32:52,510
so typically this one cycle here right

844
00:32:50,650 --> 00:32:55,059
and so here's another cycle that's

845
00:32:52,509 --> 00:32:59,798
happening and here's that pipeline okay

846
00:32:55,058 --> 00:33:03,910
I needs the stages so this is save zero

847
00:32:59,798 --> 00:33:05,470
this is stage one etc so let's say this

848
00:33:03,910 --> 00:33:06,910
is an add this is going into what's

849
00:33:05,470 --> 00:33:08,589
called an air Matt arithmetic logic unit

850
00:33:06,910 --> 00:33:11,080
an ALU which is things that do things

851
00:33:08,589 --> 00:33:13,329
like adds and ORS mask bit operations

852
00:33:11,079 --> 00:33:15,409
basically right it's going to go into a

853
00:33:13,329 --> 00:33:17,089
unit that's free right

854
00:33:15,410 --> 00:33:20,300
gonna do stage one of the ads so this is

855
00:33:17,089 --> 00:33:23,029
gonna do ad Stage one okay and then on

856
00:33:20,299 --> 00:33:25,789
the next processor cycle it's going to

857
00:33:23,029 --> 00:33:30,289
move into the next stage of the ad which

858
00:33:25,789 --> 00:33:33,230
is going to do ad Stage two okay

859
00:33:30,289 --> 00:33:36,079
and then only on stage three let's say

860
00:33:33,230 --> 00:33:39,049
does that actually complete and it gets

861
00:33:36,079 --> 00:33:41,389
written out right and so you typically

862
00:33:39,049 --> 00:33:42,559
have this concept and I don't know again

863
00:33:41,390 --> 00:33:44,000
we you have to look up in the

864
00:33:42,559 --> 00:33:47,539
documentation for any given processor

865
00:33:44,000 --> 00:33:49,069
for any given operation what this

866
00:33:47,539 --> 00:33:51,259
actually looks like for any given number

867
00:33:49,069 --> 00:33:54,379
of instructions but that's what a cycle

868
00:33:51,259 --> 00:34:00,650
actually means it's one tick of these

869
00:33:54,380 --> 00:34:03,950
stages right so if I say to you you know

870
00:34:00,650 --> 00:34:05,900
how many cycles does an ad take and you

871
00:34:03,950 --> 00:34:07,730
tell me that it takes two cycles to

872
00:34:05,900 --> 00:34:09,260
complete then what that means is it's

873
00:34:07,730 --> 00:34:12,440
going to use this stage and this stage

874
00:34:09,260 --> 00:34:15,770
and only after that will the results

875
00:34:12,440 --> 00:34:18,519
actually be available right okay so

876
00:34:15,769 --> 00:34:18,519
hopefully that makes some sense

877
00:34:21,460 --> 00:34:29,389
everybody clear on that everybody clear

878
00:34:25,250 --> 00:34:33,320
on that I don't even know are we clear

879
00:34:29,389 --> 00:34:34,460
on that who knows I'm going to assume

880
00:34:33,320 --> 00:34:38,030
you're clear on that you can ask

881
00:34:34,460 --> 00:34:40,010
questions in the Q&amp;A all right why do

882
00:34:38,030 --> 00:34:42,530
they do this what's the point of this

883
00:34:40,010 --> 00:34:48,590
pipelining well the reason is because

884
00:34:42,530 --> 00:34:51,980
this way it's a way of reusing parts of

885
00:34:48,590 --> 00:34:54,079
units at a faster rate right it's kind

886
00:34:51,980 --> 00:34:58,670
of the same reason that you have a

887
00:34:54,079 --> 00:35:05,719
washer and dryer separated when you're

888
00:34:58,670 --> 00:35:08,750
doing laundry right if it makes if you

889
00:35:05,719 --> 00:35:13,909
think about it right let's say that I

890
00:35:08,750 --> 00:35:15,829
have I'm literally I'm just gonna do it

891
00:35:13,909 --> 00:35:18,769
let's say you have a washer and a dryer

892
00:35:15,829 --> 00:35:21,440
in your house right let's say you have a

893
00:35:18,769 --> 00:35:24,769
washer and a dryer for your clothes okay

894
00:35:21,440 --> 00:35:27,769
most houses in America have this it's a

895
00:35:24,769 --> 00:35:29,210
common thing for people to have not so

896
00:35:27,769 --> 00:35:31,009
much in other places like in Japan

897
00:35:29,210 --> 00:35:32,690
a lot of people lime dry things which is

898
00:35:31,010 --> 00:35:34,760
in fact better for the environment in

899
00:35:32,690 --> 00:35:36,409
America yeah people are like an

900
00:35:34,760 --> 00:35:39,589
environment be damned we're gonna have a

901
00:35:36,409 --> 00:35:40,789
robot wash and dry our clothes so anyway

902
00:35:39,588 --> 00:35:43,639
let's say you have a washer and a dryer

903
00:35:40,789 --> 00:35:46,880
right well if you think about how that

904
00:35:43,639 --> 00:35:49,670
works right you typically have here's my

905
00:35:46,880 --> 00:35:52,070
washer here's my dryer right I put some

906
00:35:49,670 --> 00:35:55,400
clothes in right so clothes load zero

907
00:35:52,070 --> 00:35:56,809
goes into the washer right and then on

908
00:35:55,400 --> 00:35:58,880
the next you could actually think of

909
00:35:56,809 --> 00:36:01,130
these as the stages so stage zero is I

910
00:35:58,880 --> 00:36:03,410
load in the clothes to the washer right

911
00:36:01,130 --> 00:36:06,710
when the washer is done we go to the

912
00:36:03,409 --> 00:36:08,509
next stage right where zero clothes load

913
00:36:06,710 --> 00:36:12,289
zero goes from the washer to the dryer

914
00:36:08,510 --> 00:36:14,450
and if I want to I can now use the

915
00:36:12,289 --> 00:36:17,029
washer again so I can load the washer

916
00:36:14,449 --> 00:36:19,009
with clothes load what right well zeros

917
00:36:17,030 --> 00:36:22,160
in here and then the next time around

918
00:36:19,010 --> 00:36:26,210
one moves out zero goes to the laundry

919
00:36:22,159 --> 00:36:27,829
basket right and it's ready you can go

920
00:36:26,210 --> 00:36:30,139
somewhere can be used me war in whatever

921
00:36:27,829 --> 00:36:33,289
one moves in here and to with load in

922
00:36:30,139 --> 00:36:36,559
right and what you can see hopefully by

923
00:36:33,289 --> 00:36:39,409
doing this right is if I was to do it

924
00:36:36,559 --> 00:36:41,900
this way how many loads of laundry right

925
00:36:39,409 --> 00:36:46,489
can I actually do in a fixed amount of

926
00:36:41,900 --> 00:36:50,030
time let's take a look right so two

927
00:36:46,489 --> 00:36:51,409
would move here nothing would go in one

928
00:36:50,030 --> 00:36:54,260
comes out to the laundry basket and

929
00:36:51,409 --> 00:36:56,029
finally here the last time I'm going to

930
00:36:54,260 --> 00:36:58,220
take two out of the dryer and into the

931
00:36:56,030 --> 00:37:04,130
laundry basket right so how many do I

932
00:36:58,219 --> 00:37:12,519
need here I've got stage 1 stage 2 stage

933
00:37:04,130 --> 00:37:16,670
3 stage 4 stage 5 right so you can see

934
00:37:12,519 --> 00:37:19,070
essentially when I did it this way to do

935
00:37:16,670 --> 00:37:22,780
two loads of sorry to do three loads of

936
00:37:19,070 --> 00:37:24,650
laundry right I only needed five

937
00:37:22,780 --> 00:37:27,410
operations through my washer and dryer

938
00:37:24,650 --> 00:37:29,088
right now let's suppose I had some other

939
00:37:27,409 --> 00:37:30,649
mystical mythical device although they

940
00:37:29,088 --> 00:37:33,920
do have these which is the washer plus

941
00:37:30,650 --> 00:37:35,599
dryer which takes as long as a wash plus

942
00:37:33,920 --> 00:37:39,680
dry cycle so it would take two stages

943
00:37:35,599 --> 00:37:42,550
right so if I do my wash plus dry a load

944
00:37:39,679 --> 00:37:44,679
in zero right and it's still in

945
00:37:42,550 --> 00:37:47,590
they're the next phase right and then

946
00:37:44,679 --> 00:37:48,219
finally here I would get it out right if

947
00:37:47,590 --> 00:37:49,329
that makes sense

948
00:37:48,219 --> 00:37:51,069
in fact I guess you'd look at it like

949
00:37:49,329 --> 00:37:53,230
this here I would get it out right so it

950
00:37:51,070 --> 00:38:01,230
goes in here and it comes out next one

951
00:37:53,230 --> 00:38:01,230
goes in comes out final one goes in

952
00:38:01,619 --> 00:38:08,380
comes out right no pipelining and what

953
00:38:06,639 --> 00:38:10,000
you can see is if I have this see if I

954
00:38:08,380 --> 00:38:11,650
take the same amount of time right if

955
00:38:10,000 --> 00:38:15,550
this takes the combined time of both of

956
00:38:11,650 --> 00:38:17,769
these then I actually blow a whole stage

957
00:38:15,550 --> 00:38:19,480
to do my two loads of laundry

958
00:38:17,769 --> 00:38:21,489
I've wasted one whole stage because this

959
00:38:19,480 --> 00:38:24,789
is six stages and this was only five

960
00:38:21,489 --> 00:38:27,159
here right because I can use that first

961
00:38:24,789 --> 00:38:30,610
stage I can get that extra stage in

962
00:38:27,159 --> 00:38:31,659
there right and you know if I keep going

963
00:38:30,610 --> 00:38:33,760
right

964
00:38:31,659 --> 00:38:36,639
that gets it gets worse and worse for

965
00:38:33,760 --> 00:38:39,010
this mode right so if I'm in Stage five

966
00:38:36,639 --> 00:38:43,329
here let's say I go to stage six right

967
00:38:39,010 --> 00:38:49,030
where's my washer washer dryer right

968
00:38:43,329 --> 00:38:51,730
outcomes three if I wanted to do it here

969
00:38:49,030 --> 00:38:54,400
I would have to go to eight right to get

970
00:38:51,730 --> 00:38:56,500
three out and so now we're a whole two

971
00:38:54,400 --> 00:38:59,710
faster and what you'll basically see is

972
00:38:56,500 --> 00:39:02,619
as I crank the number up it keeps taking

973
00:38:59,710 --> 00:39:04,000
one more to do this one than this one so

974
00:39:02,619 --> 00:39:06,099
it just gets worse and worse and worse

975
00:39:04,000 --> 00:39:08,920
and worse and worse until basically at

976
00:39:06,099 --> 00:39:11,049
asymptotically it's always twice as long

977
00:39:08,920 --> 00:39:13,180
to do anything through this kind of a

978
00:39:11,050 --> 00:39:13,630
pipeline than it is to do it through

979
00:39:13,179 --> 00:39:16,359
this one

980
00:39:13,630 --> 00:39:18,220
so basically processors in order to

981
00:39:16,360 --> 00:39:20,289
maximize the value of all of the

982
00:39:18,219 --> 00:39:22,269
circuitry that they have they now are

983
00:39:20,289 --> 00:39:24,969
all based on a pipelining model like

984
00:39:22,269 --> 00:39:27,280
this right they're all based on a

985
00:39:24,969 --> 00:39:28,839
pipelining model because by being based

986
00:39:27,280 --> 00:39:31,870
on a pipelining model they can use the

987
00:39:28,840 --> 00:39:33,640
first part of something when the second

988
00:39:31,869 --> 00:39:35,559
part is completing and it gives it a way

989
00:39:33,639 --> 00:39:37,179
to sort of reuse circuitry when there

990
00:39:35,559 --> 00:39:39,880
are dependencies right

991
00:39:37,179 --> 00:39:42,639
zoom out a little bit here hopefully

992
00:39:39,880 --> 00:39:47,559
that makes some sense okay so that gets

993
00:39:42,639 --> 00:39:50,199
us another part of our puzzle here right

994
00:39:47,559 --> 00:39:53,289
which is in this thing actually I guess

995
00:39:50,199 --> 00:39:54,579
I want to be in here right now so we've

996
00:39:53,289 --> 00:39:55,929
got our code memory we've got our eye

997
00:39:54,579 --> 00:39:57,519
cash reserves our micro codes in

998
00:39:55,929 --> 00:40:00,399
we're grabbing things we're issuing them

999
00:39:57,519 --> 00:40:02,679
right and what we have then is we have

1000
00:40:00,400 --> 00:40:05,920
two pieces of information that we need

1001
00:40:02,679 --> 00:40:11,379
to care about right we have a number

1002
00:40:05,920 --> 00:40:15,309
called throughput and we have a number

1003
00:40:11,380 --> 00:40:17,289
called latency and for every one of

1004
00:40:15,309 --> 00:40:19,028
these instructions we would like to know

1005
00:40:17,289 --> 00:40:22,450
if possible what both of these things

1006
00:40:19,028 --> 00:40:24,099
are going to be latency means how long

1007
00:40:22,449 --> 00:40:26,379
does it take for an instruction to go

1008
00:40:24,099 --> 00:40:29,890
from being instantiated for it for being

1009
00:40:26,380 --> 00:40:32,890
issued sorry to being complete right so

1010
00:40:29,889 --> 00:40:35,528
that's end to end and throughput is a

1011
00:40:32,889 --> 00:40:38,920
number that tells me how many of them I

1012
00:40:35,528 --> 00:40:40,630
can do if their pipeline fully right so

1013
00:40:38,920 --> 00:40:44,048
this is assuming issuing back-to-back

1014
00:40:40,630 --> 00:40:47,250
right so translating that into our

1015
00:40:44,048 --> 00:40:50,920
washer diet washer/dryer diagram right

1016
00:40:47,250 --> 00:40:53,260
the latency does not change based on the

1017
00:40:50,920 --> 00:40:56,200
pipelining right the latency the amount

1018
00:40:53,260 --> 00:40:58,539
of stages it takes for these to go or

1019
00:40:56,199 --> 00:41:01,019
cycles right the number of cycles it

1020
00:40:58,539 --> 00:41:03,400
takes to do my wash and dry right is

1021
00:41:01,019 --> 00:41:06,909
going to be two no matter which of these

1022
00:41:03,400 --> 00:41:09,579
I do it takes two cycles for me to wash

1023
00:41:06,909 --> 00:41:12,909
and dry something and it so that is the

1024
00:41:09,579 --> 00:41:15,130
latency number if I have something that

1025
00:41:12,909 --> 00:41:16,568
I need wash and dry right now I have to

1026
00:41:15,130 --> 00:41:18,818
wear it I'm going to a meeting it's the

1027
00:41:16,568 --> 00:41:23,380
only thing I can wear it's gonna take me

1028
00:41:18,818 --> 00:41:25,719
two cycles so that's latency okay on the

1029
00:41:23,380 --> 00:41:27,970
other hand if all I care about is I have

1030
00:41:25,719 --> 00:41:30,669
a ton of laundry to do it's laundry day

1031
00:41:27,969 --> 00:41:32,588
I want to know roughly how long it's

1032
00:41:30,670 --> 00:41:35,559
going to take me to do these hundred

1033
00:41:32,588 --> 00:41:37,719
loads of laundry throughput is your

1034
00:41:35,559 --> 00:41:40,569
number for that that tells you how long

1035
00:41:37,719 --> 00:41:42,639
it takes if you cut out the startup and

1036
00:41:40,568 --> 00:41:46,630
shutdown time right this is typically

1037
00:41:42,639 --> 00:41:48,788
called drain out which is basically to

1038
00:41:46,630 --> 00:41:51,579
flush the pipeline right I don't know if

1039
00:41:48,789 --> 00:41:53,528
there's a term I don't remember if

1040
00:41:51,579 --> 00:41:56,230
there's a term for startup it might just

1041
00:41:53,528 --> 00:41:58,329
be startup which is basically getting

1042
00:41:56,230 --> 00:42:00,068
the pipeline going so basically what

1043
00:41:58,329 --> 00:42:01,390
throughput tells you is how long does it

1044
00:42:00,068 --> 00:42:04,659
take for things to push through the

1045
00:42:01,389 --> 00:42:08,230
pipeline once we've locked off the drain

1046
00:42:04,659 --> 00:42:09,879
out and the the startup

1047
00:42:08,230 --> 00:42:11,949
and it's basically saying if I put one

1048
00:42:09,880 --> 00:42:14,769
in how long does it take to get one out

1049
00:42:11,949 --> 00:42:17,049
I don't care which one right and in this

1050
00:42:14,769 --> 00:42:19,210
case that's one for here and it's still

1051
00:42:17,050 --> 00:42:21,010
two for here so this is a this is a

1052
00:42:19,210 --> 00:42:23,320
latency two throughput to system

1053
00:42:21,010 --> 00:42:25,030
basically and this is a latency to

1054
00:42:23,320 --> 00:42:27,070
throughput one system which means this

1055
00:42:25,030 --> 00:42:29,080
is twice as fast as this guy for

1056
00:42:27,070 --> 00:42:30,309
operating on large sets of data but if

1057
00:42:29,079 --> 00:42:34,840
you're just operating on one thing

1058
00:42:30,309 --> 00:42:36,369
they're the same okay so basically what

1059
00:42:34,840 --> 00:42:38,500
that tells you is if you only ever do

1060
00:42:36,369 --> 00:42:40,358
one load of laundry at a time you'd be

1061
00:42:38,500 --> 00:42:41,710
way better off with a washer/dryer combo

1062
00:42:40,358 --> 00:42:45,039
because you would have to do less work

1063
00:42:41,710 --> 00:42:46,960
yourself but if you wash lots of loads

1064
00:42:45,039 --> 00:42:54,329
of laundry you want a pipelined one

1065
00:42:46,960 --> 00:42:56,740
that's a washer and dryer right okay

1066
00:42:54,329 --> 00:42:59,319
so typically when we're talking about

1067
00:42:56,739 --> 00:43:01,000
performance we're only ever going to

1068
00:42:59,320 --> 00:43:04,059
talk about this throughput number

1069
00:43:01,000 --> 00:43:06,489
because latency and I shouldn't say that

1070
00:43:04,059 --> 00:43:09,009
with respect to instructions we will use

1071
00:43:06,489 --> 00:43:10,629
the term latency for other things with

1072
00:43:09,010 --> 00:43:13,119
respect to instructions this we

1073
00:43:10,630 --> 00:43:16,000
typically don't care about a whole heck

1074
00:43:13,119 --> 00:43:17,440
of a lot because typically our goal is

1075
00:43:16,000 --> 00:43:19,389
to structure the code so that we're

1076
00:43:17,440 --> 00:43:21,849
always working on things in a pipelined

1077
00:43:19,389 --> 00:43:23,710
fashion so that we're not waiting around

1078
00:43:21,849 --> 00:43:25,750
for the latency so when we look up

1079
00:43:23,710 --> 00:43:28,179
things like how long it takes to do an

1080
00:43:25,750 --> 00:43:30,369
ad what we're going to be looking at is

1081
00:43:28,179 --> 00:43:32,019
what the throughput is for an ad not

1082
00:43:30,369 --> 00:43:33,130
what the latency is for an ad because

1083
00:43:32,019 --> 00:43:34,780
we're going to assume that we're always

1084
00:43:33,130 --> 00:43:36,039
operating a lot of things at once now

1085
00:43:34,780 --> 00:43:39,760
sometimes that won't be true but that's

1086
00:43:36,039 --> 00:43:41,519
our goal anyway okay so if we understand

1087
00:43:39,760 --> 00:43:44,050
that that's pretty straightforward

1088
00:43:41,519 --> 00:43:46,809
and so let's talk about where latency

1089
00:43:44,050 --> 00:43:48,280
does actually come into play and this is

1090
00:43:46,809 --> 00:43:51,039
again measuring essentially the same

1091
00:43:48,280 --> 00:43:54,640
thing but in different context let's go

1092
00:43:51,039 --> 00:43:56,949
up to our caches right so the place

1093
00:43:54,639 --> 00:43:59,500
where latency really does cause us a

1094
00:43:56,949 --> 00:44:01,239
huge problem and it means latency and

1095
00:43:59,500 --> 00:44:03,849
throughput translate exactly basically

1096
00:44:01,239 --> 00:44:05,739
over here unfortunately we care about

1097
00:44:03,849 --> 00:44:07,989
them usually in the opposite way but

1098
00:44:05,739 --> 00:44:09,549
sometimes not so we'll talk about this

1099
00:44:07,989 --> 00:44:11,649
in a little more detail what am I at

1100
00:44:09,550 --> 00:44:12,850
here oh man we have gone through almost

1101
00:44:11,650 --> 00:44:14,200
all the time all right so basically this

1102
00:44:12,849 --> 00:44:18,639
is gonna be entirely a blackboard

1103
00:44:14,199 --> 00:44:21,419
session basically that's all right this

1104
00:44:18,639 --> 00:44:21,420
stuff has to be covered

1105
00:44:23,230 --> 00:44:32,000
okay so throughput and latency actually

1106
00:44:26,690 --> 00:44:33,980
typically throughput for whatever reason

1107
00:44:32,000 --> 00:44:36,619
typically bandwidth is what's actually

1108
00:44:33,980 --> 00:44:39,139
used to talk about memory even though

1109
00:44:36,619 --> 00:44:40,818
they kind of mean the same thing they're

1110
00:44:39,139 --> 00:44:41,659
not exactly the same but you'll see in a

1111
00:44:40,818 --> 00:44:43,489
second when I tell you what they are

1112
00:44:41,659 --> 00:44:45,078
whereas latency is exactly the same

1113
00:44:43,489 --> 00:44:46,489
thing latency just means exactly the

1114
00:44:45,079 --> 00:44:50,510
same thing it was used in both context

1115
00:44:46,489 --> 00:44:51,858
alright so what happens with our memory

1116
00:44:50,510 --> 00:44:55,160
our cache and that sort of stuff well

1117
00:44:51,858 --> 00:44:56,929
again this diagram where we've got a

1118
00:44:55,159 --> 00:44:58,190
stages of a pipeline that are issuing so

1119
00:44:56,929 --> 00:45:00,889
we got instructions that issue they

1120
00:44:58,190 --> 00:45:02,960
retire etc etc right this this whole

1121
00:45:00,889 --> 00:45:04,519
this whole diagram is how we think about

1122
00:45:02,960 --> 00:45:06,679
what the processor does with stuff that

1123
00:45:04,519 --> 00:45:09,019
it has right that it has in its

1124
00:45:06,679 --> 00:45:10,429
registers that it can operate on now but

1125
00:45:09,019 --> 00:45:12,349
the question is what about stuff that

1126
00:45:10,429 --> 00:45:15,049
the processor does not have that it has

1127
00:45:12,349 --> 00:45:18,019
to go and get right and typically we've

1128
00:45:15,050 --> 00:45:20,119
got two things to worry about there one

1129
00:45:18,019 --> 00:45:21,679
is the total amount of memory that we

1130
00:45:20,119 --> 00:45:24,170
can move through the processor at a

1131
00:45:21,679 --> 00:45:25,669
maximum speed and that again is like

1132
00:45:24,170 --> 00:45:28,039
sort of the throughput it's called

1133
00:45:25,670 --> 00:45:29,240
bandwidth typically but that's like our

1134
00:45:28,039 --> 00:45:31,099
throughput number that means if

1135
00:45:29,239 --> 00:45:32,989
everything's flowing smoothly in a

1136
00:45:31,099 --> 00:45:34,970
perfectly pipeline fashion how much

1137
00:45:32,989 --> 00:45:36,679
memory could we just move in right

1138
00:45:34,969 --> 00:45:39,439
there's like a bus there's a thing

1139
00:45:36,679 --> 00:45:40,940
called a bus that takes memory off from

1140
00:45:39,440 --> 00:45:42,500
the motherboard it takes the kind of sub

1141
00:45:40,940 --> 00:45:45,679
memory from the motherboard and drives

1142
00:45:42,500 --> 00:45:48,469
it into the caches right that thing and

1143
00:45:45,679 --> 00:45:50,029
similarly there's there's it's not

1144
00:45:48,469 --> 00:45:52,759
really a bus but there's lines that

1145
00:45:50,030 --> 00:45:54,619
allow the cache to travel from the cache

1146
00:45:52,760 --> 00:45:56,710
memory on the chip into the register

1147
00:45:54,619 --> 00:45:59,809
store on the chip the register file

1148
00:45:56,710 --> 00:46:02,088
right and that also has a speed a

1149
00:45:59,809 --> 00:46:04,400
maximum thing so there's a bandwidth on

1150
00:46:02,088 --> 00:46:06,920
both of these right and the bandwidth is

1151
00:46:04,400 --> 00:46:08,780
the total maximum amount of memory that

1152
00:46:06,920 --> 00:46:10,579
you could move typically you don't care

1153
00:46:08,780 --> 00:46:12,349
that much about that for cache bandwidth

1154
00:46:10,579 --> 00:46:14,359
but sometimes you do and you almost

1155
00:46:12,349 --> 00:46:16,579
always care about that bandwidth for

1156
00:46:14,358 --> 00:46:19,009
your memory right because the maximum

1157
00:46:16,579 --> 00:46:20,780
bandwidth to and from memory just

1158
00:46:19,010 --> 00:46:22,460
determines the total number of stuff you

1159
00:46:20,780 --> 00:46:24,260
could possibly ever operate on right

1160
00:46:22,460 --> 00:46:26,750
it's the speed with which things can

1161
00:46:24,260 --> 00:46:28,369
cycle through the processor and whatever

1162
00:46:26,750 --> 00:46:29,900
that speed is that's the maximum you

1163
00:46:28,369 --> 00:46:32,150
will ever be able to operate on stuff

1164
00:46:29,900 --> 00:46:33,369
right because at a bare minimum even if

1165
00:46:32,150 --> 00:46:35,110
you did nothing but move it

1166
00:46:33,369 --> 00:46:36,789
one place to another it has to come into

1167
00:46:35,110 --> 00:46:39,490
the processor and back out again right

1168
00:46:36,789 --> 00:46:41,590
so the bandwidth to the memory typically

1169
00:46:39,489 --> 00:46:44,169
given in like gigabytes per second for

1170
00:46:41,590 --> 00:46:46,660
example right the bit that memory

1171
00:46:44,170 --> 00:46:48,220
bandwidth is what determines how much

1172
00:46:46,659 --> 00:46:51,089
memory we'll be able to move through the

1173
00:46:48,219 --> 00:46:54,069
processor at peak okay

1174
00:46:51,090 --> 00:46:55,570
the latency on the memory again exactly

1175
00:46:54,070 --> 00:46:57,760
analogous to what it was in the

1176
00:46:55,570 --> 00:47:00,519
instruction case the latency on the

1177
00:46:57,760 --> 00:47:02,860
memory talks about how long it takes

1178
00:47:00,519 --> 00:47:05,710
from the time we ask for a piece of

1179
00:47:02,860 --> 00:47:07,480
memory to when we will get that piece of

1180
00:47:05,710 --> 00:47:10,659
memory back and it works exactly like

1181
00:47:07,480 --> 00:47:12,730
instructions if we issue a load and it

1182
00:47:10,659 --> 00:47:15,399
let's say it takes 300 cycles to get

1183
00:47:12,730 --> 00:47:17,349
memory we will have to issue that load

1184
00:47:15,400 --> 00:47:19,570
and then 300 cycles will transpire

1185
00:47:17,349 --> 00:47:22,509
before we get that particular piece of

1186
00:47:19,570 --> 00:47:25,030
memory back right what that means is

1187
00:47:22,510 --> 00:47:26,920
that if we were actually going to do

1188
00:47:25,030 --> 00:47:30,250
that load and the load could issue at

1189
00:47:26,920 --> 00:47:34,210
speed right if we literally just issued

1190
00:47:30,250 --> 00:47:35,769
a load had to wait for it and all of our

1191
00:47:34,210 --> 00:47:37,510
instructions were operating on whatever

1192
00:47:35,769 --> 00:47:39,610
that thing that was loaded was like

1193
00:47:37,510 --> 00:47:41,110
where all that whatever it was getting

1194
00:47:39,610 --> 00:47:44,050
loaded we were gonna operate on it right

1195
00:47:41,110 --> 00:47:46,650
away if that's how we were working we

1196
00:47:44,050 --> 00:47:49,600
would literally suffer a 300 cycle delay

1197
00:47:46,650 --> 00:47:51,900
while all of these instructions wait for

1198
00:47:49,599 --> 00:47:55,900
the result of this load to come back

1199
00:47:51,900 --> 00:47:58,300
right pretty horrible because 300 is a

1200
00:47:55,900 --> 00:48:00,610
ton of cycles add like I said is like to

1201
00:47:58,300 --> 00:48:02,890
cycle through put right so it's just a

1202
00:48:00,610 --> 00:48:04,750
massive hit and that is not a made-up

1203
00:48:02,889 --> 00:48:07,029
number like memory often will be 200

1204
00:48:04,750 --> 00:48:07,809
cycles 300 cycles to access that's not

1205
00:48:07,030 --> 00:48:10,269
unusual

1206
00:48:07,809 --> 00:48:12,190
right it's certainly probably in the

1207
00:48:10,269 --> 00:48:16,119
hundreds even on very fast memory

1208
00:48:12,190 --> 00:48:17,380
systems so or I guess it could be better

1209
00:48:16,119 --> 00:48:18,670
if you have a very slow processor in the

1210
00:48:17,380 --> 00:48:21,010
old days when processors were extremely

1211
00:48:18,670 --> 00:48:22,840
slow memory was instantaneous it was

1212
00:48:21,010 --> 00:48:25,060
basically it came right to you right but

1213
00:48:22,840 --> 00:48:27,970
as processors get faster and faster the

1214
00:48:25,059 --> 00:48:31,059
memory can't so that's what happens this

1215
00:48:27,969 --> 00:48:32,429
cycle count keeps going up all right so

1216
00:48:31,059 --> 00:48:35,259
hopefully that makes some sense and

1217
00:48:32,429 --> 00:48:37,989
basically what that means is we that is

1218
00:48:35,260 --> 00:48:40,030
where this whole Cantus concept you've

1219
00:48:37,989 --> 00:48:41,859
probably heard write of a cache miss a

1220
00:48:40,030 --> 00:48:45,160
cache miss is very expensive you hear

1221
00:48:41,860 --> 00:48:45,970
right what a cache miss is right is it

1222
00:48:45,159 --> 00:48:47,739
that the

1223
00:48:45,969 --> 00:48:49,779
structure of this thing here where we

1224
00:48:47,739 --> 00:48:51,699
have these caches on the processor and

1225
00:48:49,780 --> 00:48:53,730
then memory that fills the caches the

1226
00:48:51,699 --> 00:48:56,949
cache is what we load from so on

1227
00:48:53,730 --> 00:48:59,800
basically these caches like I said like

1228
00:48:56,949 --> 00:49:01,480
16 cycles or something like that might

1229
00:48:59,800 --> 00:49:03,190
be I know that's that's like an l2 speed

1230
00:49:01,480 --> 00:49:05,740
I think right I don't know when an l1 is

1231
00:49:03,190 --> 00:49:08,108
maybe two cycles I'm not sure but point

1232
00:49:05,739 --> 00:49:10,449
being these caches are way way faster to

1233
00:49:08,108 --> 00:49:11,889
fetch from the memory so if you can

1234
00:49:10,449 --> 00:49:13,449
write algorithms that tend to work

1235
00:49:11,889 --> 00:49:15,909
entirely out of things that are in the

1236
00:49:13,449 --> 00:49:18,429
cache and do not have to go to main

1237
00:49:15,909 --> 00:49:19,690
memory you will not suffer a cache miss

1238
00:49:18,429 --> 00:49:21,309
a cache misses when you ask for

1239
00:49:19,690 --> 00:49:22,599
something and it's not in the cache so

1240
00:49:21,309 --> 00:49:25,480
it has to go to main memory to get it

1241
00:49:22,599 --> 00:49:27,130
right your code will run much much much

1242
00:49:25,480 --> 00:49:29,980
much faster because it will never have

1243
00:49:27,130 --> 00:49:31,480
any of these latency hits right and

1244
00:49:29,980 --> 00:49:34,090
what's important to understand here is

1245
00:49:31,480 --> 00:49:36,190
the management of how this cache is

1246
00:49:34,090 --> 00:49:38,530
filled is a huge part of modern

1247
00:49:36,190 --> 00:49:40,599
optimization basically there are

1248
00:49:38,530 --> 00:49:46,119
instructions we can issue will see them

1249
00:49:40,599 --> 00:49:48,160
as we go called prefetches and what a

1250
00:49:46,119 --> 00:49:51,280
prefetch is is a way of telling the

1251
00:49:48,159 --> 00:49:53,829
processor hey look I need to tell you

1252
00:49:51,280 --> 00:49:56,530
some stuff to put into the cache because

1253
00:49:53,829 --> 00:49:59,019
I'm gonna need it later like 300 cycles

1254
00:49:56,530 --> 00:50:00,880
later and I want you to get going now so

1255
00:49:59,019 --> 00:50:02,619
that when I can I can do a bunch of

1256
00:50:00,880 --> 00:50:05,500
other operations and when I come back

1257
00:50:02,619 --> 00:50:07,510
the thing will be in the cache right so

1258
00:50:05,500 --> 00:50:10,059
there's a tremendous amount of this sort

1259
00:50:07,510 --> 00:50:12,010
of thinking about the cache thinking

1260
00:50:10,059 --> 00:50:13,599
about when to fill it and how to do as

1261
00:50:12,010 --> 00:50:15,520
much work with the stuff that's in the

1262
00:50:13,599 --> 00:50:17,559
cache as you can before flushing it out

1263
00:50:15,519 --> 00:50:20,500
again right before it gets replaced by

1264
00:50:17,559 --> 00:50:23,858
something else in order to avoid these

1265
00:50:20,500 --> 00:50:27,550
very very expensive latency hits and to

1266
00:50:23,858 --> 00:50:28,838
that effect this window here this thing

1267
00:50:27,550 --> 00:50:32,380
I was talking about with the out of

1268
00:50:28,838 --> 00:50:34,088
order window that is yet another way

1269
00:50:32,380 --> 00:50:36,880
that the processor tries to overcome

1270
00:50:34,088 --> 00:50:38,889
that latency you can imagine some code

1271
00:50:36,880 --> 00:50:40,390
that's not particularly good that does

1272
00:50:38,889 --> 00:50:42,819
some loads like this and then starts

1273
00:50:40,389 --> 00:50:44,440
doing ads on the loads right and that

1274
00:50:42,820 --> 00:50:45,670
stuff's not it's never been seen by the

1275
00:50:44,440 --> 00:50:46,960
processor before it's not in the cache

1276
00:50:45,670 --> 00:50:49,480
it has to go out to main memory so it's

1277
00:50:46,960 --> 00:50:51,490
got 300 cycles to work with if this

1278
00:50:49,480 --> 00:50:54,789
window is pretty large if this window is

1279
00:50:51,489 --> 00:50:56,889
like 50 or 100 cycles worth of stuff it

1280
00:50:54,789 --> 00:50:58,409
could do it can start grabbing things

1281
00:50:56,889 --> 00:51:00,719
while it waits for that low

1282
00:50:58,409 --> 00:51:03,389
and not waste all of the 300 cycles

1283
00:51:00,719 --> 00:51:06,899
right another thing you may heard of is

1284
00:51:03,389 --> 00:51:08,670
hyper threading right you've probably

1285
00:51:06,900 --> 00:51:10,710
heard of that right

1286
00:51:08,670 --> 00:51:13,200
well what hyper threading is is just a

1287
00:51:10,710 --> 00:51:15,720
processor keeping two states internally

1288
00:51:13,199 --> 00:51:19,469
right so maybe I have state 0 and state

1289
00:51:15,719 --> 00:51:21,298
1 and it's exactly like a totally it's

1290
00:51:19,469 --> 00:51:22,439
like having two total processors so all

1291
00:51:21,298 --> 00:51:23,699
of the state of the processor is

1292
00:51:22,440 --> 00:51:27,630
represented in both of these states

1293
00:51:23,699 --> 00:51:29,639
right and all it does is pretty lousy to

1294
00:51:27,630 --> 00:51:31,079
give it two sets of code to run as if

1295
00:51:29,639 --> 00:51:33,568
you had two separate threads two

1296
00:51:31,079 --> 00:51:36,660
separate processors right but what it

1297
00:51:33,568 --> 00:51:39,329
will do is whenever it sees that one of

1298
00:51:36,659 --> 00:51:42,298
these would stall on a memory hit right

1299
00:51:39,329 --> 00:51:44,099
if it's like oh I'm ran out of things in

1300
00:51:42,298 --> 00:51:46,048
this window to execute there's no more

1301
00:51:44,099 --> 00:51:47,099
things for me to grab I'm waiting all of

1302
00:51:46,048 --> 00:51:49,079
them are waiting on memory

1303
00:51:47,099 --> 00:51:51,660
it'll flop over to the other state and

1304
00:51:49,079 --> 00:51:53,160
see if it can grab anything that thing

1305
00:51:51,659 --> 00:51:54,899
will then do some work and it'll

1306
00:51:53,159 --> 00:51:56,730
probably end up stalling on some memory

1307
00:51:54,900 --> 00:51:58,920
and it'll switch back to state zero

1308
00:51:56,730 --> 00:52:00,809
right so hyper threading is yet another

1309
00:51:58,920 --> 00:52:03,900
way that Intel has tried to introduce

1310
00:52:00,809 --> 00:52:05,460
technology basically to get around the

1311
00:52:03,900 --> 00:52:07,650
fact that the memory is very very slow

1312
00:52:05,460 --> 00:52:10,048
right so there's basically lots of

1313
00:52:07,650 --> 00:52:11,579
things in here that are designed to sort

1314
00:52:10,048 --> 00:52:15,150
of hide that thing these are called

1315
00:52:11,579 --> 00:52:17,099
latency bubbles right which are

1316
00:52:15,150 --> 00:52:19,650
basically times when the processor is

1317
00:52:17,099 --> 00:52:21,298
waiting on memory and Lily can't do

1318
00:52:19,650 --> 00:52:23,460
anything because everything it might

1319
00:52:21,298 --> 00:52:26,909
want to do is waiting for a very long

1320
00:52:23,460 --> 00:52:29,010
fetch to memory right hyper threading is

1321
00:52:26,909 --> 00:52:30,389
one way gets around that right and this

1322
00:52:29,010 --> 00:52:32,309
memory window is the other one and the

1323
00:52:30,389 --> 00:52:35,159
rest of them it relies on us to issue

1324
00:52:32,309 --> 00:52:37,099
prefetches to write cache good thing

1325
00:52:35,159 --> 00:52:39,000
that has cache coherent it's called

1326
00:52:37,099 --> 00:52:42,410
basically stuff that uses the cache

1327
00:52:39,000 --> 00:52:45,719
efficiently it's all up to us right

1328
00:52:42,409 --> 00:52:47,278
alright so now we come to finally and I

1329
00:52:45,719 --> 00:52:48,269
guess this is perfect we're right up at

1330
00:52:47,278 --> 00:52:51,389
the end here we got about eight minutes

1331
00:52:48,269 --> 00:52:53,099
left so now we come to the end of sort

1332
00:52:51,389 --> 00:52:54,929
of the introduction to thinking about

1333
00:52:53,099 --> 00:52:55,920
what's actually going on and the next I

1334
00:52:54,929 --> 00:52:57,210
guess so this will be good because

1335
00:52:55,920 --> 00:53:00,119
tomorrow we can literally just talk

1336
00:52:57,210 --> 00:53:02,789
about optimization the process so this

1337
00:53:00,119 --> 00:53:04,890
is optimization essentially the platform

1338
00:53:02,789 --> 00:53:06,660
so now you get like this is what we're

1339
00:53:04,889 --> 00:53:08,608
trying to think about right what we're

1340
00:53:06,659 --> 00:53:10,199
trying to think about is you have a CPU

1341
00:53:08,608 --> 00:53:11,920
and a GPU right now we're only

1342
00:53:10,199 --> 00:53:13,239
concentrating on the CPU but almost

1343
00:53:11,920 --> 00:53:15,700
all of this stuff also applies to the

1344
00:53:13,239 --> 00:53:17,500
GPU oddly enough but we're only think

1345
00:53:15,699 --> 00:53:19,779
about the CPU right now so we're

1346
00:53:17,500 --> 00:53:21,969
thinking about the CPU our goal is to

1347
00:53:19,780 --> 00:53:25,120
figure out a good set of instructions

1348
00:53:21,969 --> 00:53:26,379
that does not have too big of a

1349
00:53:25,119 --> 00:53:27,730
footprint right so it doesn't blow out

1350
00:53:26,380 --> 00:53:29,140
this eye cache right because where

1351
00:53:27,730 --> 00:53:30,909
there's a cache where the instructions

1352
00:53:29,139 --> 00:53:33,009
come from so we're even thinking about

1353
00:53:30,909 --> 00:53:34,839
not making our code too large if that

1354
00:53:33,010 --> 00:53:37,720
makes sense right wanna stream of

1355
00:53:34,840 --> 00:53:40,690
instructions that's not too large that

1356
00:53:37,719 --> 00:53:42,639
does the right set of operations to

1357
00:53:40,690 --> 00:53:45,360
maximize the amount of time it is

1358
00:53:42,639 --> 00:53:47,829
operating on things in this cache right

1359
00:53:45,360 --> 00:53:49,030
that knows what memory it's going to use

1360
00:53:47,829 --> 00:53:50,769
ahead of time if possible and will

1361
00:53:49,030 --> 00:53:54,190
pre-fill the cache with it where

1362
00:53:50,769 --> 00:53:56,710
possible right that can be split up

1363
00:53:54,190 --> 00:53:58,599
potentially along among multiple hyper

1364
00:53:56,710 --> 00:54:01,119
threads and perhaps even multiple

1365
00:53:58,599 --> 00:54:02,650
processors let's say to maximize the

1366
00:54:01,119 --> 00:54:05,099
number of things that can be considered

1367
00:54:02,650 --> 00:54:08,800
by the processor at any given time and

1368
00:54:05,099 --> 00:54:11,650
finally whose instruction stream as well

1369
00:54:08,800 --> 00:54:13,810
as possible issues the maximum number of

1370
00:54:11,650 --> 00:54:15,220
cycles issues the maximum number of

1371
00:54:13,809 --> 00:54:19,650
instructions that could on every cycle

1372
00:54:15,219 --> 00:54:22,119
and in so doing is keeping this pipeline

1373
00:54:19,650 --> 00:54:26,769
maximally filled with the things that we

1374
00:54:22,119 --> 00:54:29,500
want it to do right if we can do that we

1375
00:54:26,769 --> 00:54:31,750
can get the most out of this 107 cycles

1376
00:54:29,500 --> 00:54:34,840
107 million cycles per frame that we

1377
00:54:31,750 --> 00:54:38,230
have and turn that into a very fast high

1378
00:54:34,840 --> 00:54:40,720
performance piece of code right and all

1379
00:54:38,230 --> 00:54:43,090
of these things can come into play

1380
00:54:40,719 --> 00:54:45,250
depending on the type of code some type

1381
00:54:43,090 --> 00:54:46,660
of code it's all about the memory it's

1382
00:54:45,250 --> 00:54:48,670
all about managing how the memory comes

1383
00:54:46,659 --> 00:54:50,079
through in other types of code it can be

1384
00:54:48,670 --> 00:54:52,180
all about the instructions it's all

1385
00:54:50,079 --> 00:54:54,009
about figuring out a good way to

1386
00:54:52,179 --> 00:54:55,839
structure how we're doing things but in

1387
00:54:54,010 --> 00:54:57,490
most pieces of code it's both it's

1388
00:54:55,840 --> 00:54:59,620
figuring out how to make sure the memory

1389
00:54:57,489 --> 00:55:01,449
doesn't stall you out and then once you

1390
00:54:59,619 --> 00:55:03,009
have it so the memory doesn't stall you

1391
00:55:01,449 --> 00:55:05,319
out it's about making sure that you do

1392
00:55:03,010 --> 00:55:08,950
the least amount of work on it as

1393
00:55:05,320 --> 00:55:12,550
possible right so that is optimization

1394
00:55:08,949 --> 00:55:15,929
okay now I'm going to mention an adjunct

1395
00:55:12,550 --> 00:55:18,310
here and this is not something really

1396
00:55:15,929 --> 00:55:19,659
that we'll talk about too much in this

1397
00:55:18,309 --> 00:55:21,309
particular pass because we're going to

1398
00:55:19,659 --> 00:55:23,079
start at the base level of optimization

1399
00:55:21,309 --> 00:55:24,980
which is about how to just write the

1400
00:55:23,079 --> 00:55:27,079
code so that it runs quickly

1401
00:55:24,980 --> 00:55:29,300
but there's another kind of concept here

1402
00:55:27,079 --> 00:55:32,150
and we might say that this is

1403
00:55:29,300 --> 00:55:34,250
performance and performance is the

1404
00:55:32,150 --> 00:55:35,809
hardest one to think through because

1405
00:55:34,250 --> 00:55:37,460
there's so much domain knowledge like

1406
00:55:35,809 --> 00:55:39,679
you see all this stuff I had to draw out

1407
00:55:37,460 --> 00:55:40,880
here right all this domain logic I

1408
00:55:39,679 --> 00:55:43,219
didn't even talk about everything I

1409
00:55:40,880 --> 00:55:44,570
didn't talk about aliasing and the cache

1410
00:55:43,219 --> 00:55:49,009
I didn't talk about any of that stuff

1411
00:55:44,570 --> 00:55:50,269
right so basically like performance is

1412
00:55:49,010 --> 00:55:54,590
the one that has the most domain

1413
00:55:50,269 --> 00:55:58,969
knowledge of the processor its adjunct

1414
00:55:54,590 --> 00:56:00,619
is efficiency an efficiency is the

1415
00:55:58,969 --> 00:56:03,469
easiest to understand it will literally

1416
00:56:00,619 --> 00:56:04,760
take me less than the last couple of

1417
00:56:03,469 --> 00:56:09,169
minutes we have here to tell you what it

1418
00:56:04,760 --> 00:56:12,320
is efficiency means just not doing work

1419
00:56:09,170 --> 00:56:14,659
you don't have to do right the

1420
00:56:12,320 --> 00:56:17,390
efficiency is all about the algorithm

1421
00:56:14,659 --> 00:56:19,879
okay so when we're talking about

1422
00:56:17,389 --> 00:56:22,129
performance we're usually talking about

1423
00:56:19,880 --> 00:56:23,809
how to make a particular algorithm run

1424
00:56:22,130 --> 00:56:25,550
as fast as possible using all of this

1425
00:56:23,809 --> 00:56:27,590
nastiness and thinking through all of

1426
00:56:25,550 --> 00:56:29,240
this complexity right which you have to

1427
00:56:27,590 --> 00:56:30,559
do if you want stuff to run quickly if

1428
00:56:29,239 --> 00:56:32,569
you want to be really good you got to do

1429
00:56:30,559 --> 00:56:34,489
it right but there's a whole other side

1430
00:56:32,570 --> 00:56:36,590
of the coin which happens before you

1431
00:56:34,489 --> 00:56:38,929
even really talk about this part which

1432
00:56:36,590 --> 00:56:40,789
is what are you actually doing and did

1433
00:56:38,929 --> 00:56:43,399
you have to do it all because a very

1434
00:56:40,789 --> 00:56:44,779
inefficient algorithm makes it so this

1435
00:56:43,400 --> 00:56:46,700
performance optimization really isn't

1436
00:56:44,780 --> 00:56:48,650
that that interesting because a more

1437
00:56:46,699 --> 00:56:50,358
efficient algorithm that isn't

1438
00:56:48,650 --> 00:56:52,280
performance optimized might actually

1439
00:56:50,358 --> 00:56:53,779
beat it because let's say that I have

1440
00:56:52,280 --> 00:56:55,280
some algorithm whatever we want to do

1441
00:56:53,780 --> 00:56:57,590
right in fact we already saw this once

1442
00:56:55,280 --> 00:56:59,420
right do you remember when I first

1443
00:56:57,590 --> 00:57:01,820
showed you how to fill the triangle

1444
00:56:59,420 --> 00:57:03,349
right we had a triangle and we just

1445
00:57:01,820 --> 00:57:05,269
iterated over every pixel on the screen

1446
00:57:03,349 --> 00:57:06,230
and said is it inside the triangle right

1447
00:57:05,269 --> 00:57:07,429
because I was just trying to prove a

1448
00:57:06,230 --> 00:57:10,490
point right as trying to say here it's

1449
00:57:07,429 --> 00:57:12,649
how the algorithm works right that ran

1450
00:57:10,489 --> 00:57:14,539
incredibly slowly so slowly that just

1451
00:57:12,650 --> 00:57:16,730
that one triangle right that was a

1452
00:57:14,539 --> 00:57:18,889
little tiny triangle would totally tank

1453
00:57:16,730 --> 00:57:20,719
the frames per second we then switched

1454
00:57:18,889 --> 00:57:22,969
to only iterating over the things that

1455
00:57:20,719 --> 00:57:24,589
were inside the rectangle bounding box

1456
00:57:22,969 --> 00:57:27,439
of the triangle and it got much faster

1457
00:57:24,590 --> 00:57:29,510
right I started wasn't a triangle I

1458
00:57:27,440 --> 00:57:31,130
think it was actually a it's actually a

1459
00:57:29,510 --> 00:57:32,110
maybe a rectangle I don't know but you

1460
00:57:31,130 --> 00:57:34,610
get my point

1461
00:57:32,110 --> 00:57:36,559
that is an example of efficiency we

1462
00:57:34,610 --> 00:57:39,200
didn't do any performance optimization

1463
00:57:36,559 --> 00:57:41,779
the cost to compute any given pixel was

1464
00:57:39,199 --> 00:57:45,109
exactly the same right but what we did

1465
00:57:41,780 --> 00:57:47,180
is we checked less pixels right and so

1466
00:57:45,110 --> 00:57:49,190
no amount of this kind of optimization

1467
00:57:47,179 --> 00:57:50,989
is ever going to make up for efficiency

1468
00:57:49,190 --> 00:57:52,579
and so you always do want to make sure

1469
00:57:50,989 --> 00:57:54,079
that you've done some work to make sure

1470
00:57:52,579 --> 00:57:56,960
you're reasonably efficient before you

1471
00:57:54,079 --> 00:57:58,159
start doing this but in this case we

1472
00:57:56,960 --> 00:57:59,449
kind of know roughly what we're doing

1473
00:57:58,159 --> 00:58:01,429
we'll talk about a little bit of this

1474
00:57:59,449 --> 00:58:03,139
because we do have a little bit of it to

1475
00:58:01,429 --> 00:58:04,699
do in the software renderer but most of

1476
00:58:03,139 --> 00:58:07,039
our work on the software renderer will

1477
00:58:04,699 --> 00:58:08,750
be this kind because we kind of know at

1478
00:58:07,039 --> 00:58:11,420
the end of the day that we gotta do

1479
00:58:08,750 --> 00:58:13,369
pixel filling right okay

1480
00:58:11,420 --> 00:58:14,990
so that's everything really about

1481
00:58:13,369 --> 00:58:17,150
optimization in terms of the high-level

1482
00:58:14,989 --> 00:58:20,089
overview we have efficiency we have

1483
00:58:17,150 --> 00:58:22,099
performance efficiency means doing the

1484
00:58:20,090 --> 00:58:23,590
least amount of work that you can do to

1485
00:58:22,099 --> 00:58:27,079
get the result that you need and

1486
00:58:23,590 --> 00:58:29,480
performance is structuring the data and

1487
00:58:27,079 --> 00:58:32,000
the ins and the actual operations on

1488
00:58:29,480 --> 00:58:34,519
that data in such a way that they move

1489
00:58:32,000 --> 00:58:36,530
through the processor in the least

1490
00:58:34,519 --> 00:58:40,190
amount of cycles that they possibly can

1491
00:58:36,530 --> 00:58:42,140
right and like I said we probably won't

1492
00:58:40,190 --> 00:58:43,550
hit the idealized performance for

1493
00:58:42,139 --> 00:58:45,769
anything we do we won't spend enough

1494
00:58:43,550 --> 00:58:47,480
time on performance to get the absolute

1495
00:58:45,769 --> 00:58:49,039
best what we'll be shooting for is like

1496
00:58:47,480 --> 00:58:51,019
the 80 percent case or whatever like you

1497
00:58:49,039 --> 00:58:52,849
know a pretty well optimized algorithm

1498
00:58:51,019 --> 00:58:54,349
but it could easily be beaten by

1499
00:58:52,849 --> 00:58:56,750
somebody who wants to spend a month just

1500
00:58:54,349 --> 00:58:58,610
working on this algorithm right I'm not

1501
00:58:56,750 --> 00:59:00,079
algorithm I shouldn't say but but

1502
00:58:58,610 --> 00:59:02,360
basically the way of writing the

1503
00:59:00,079 --> 00:59:04,880
algorithm that makes sense so that's

1504
00:59:02,360 --> 00:59:07,250
that's basically how to think about what

1505
00:59:04,880 --> 00:59:09,650
we're trying to do and so tomorrow what

1506
00:59:07,250 --> 00:59:11,900
we'll do is we'll talk about what are

1507
00:59:09,650 --> 00:59:13,940
the steps that we want to do that like

1508
00:59:11,900 --> 00:59:15,680
how do we actually do that we we this is

1509
00:59:13,940 --> 00:59:17,630
how much we have how do we think through

1510
00:59:15,679 --> 00:59:19,489
how we're going to work with those

1511
00:59:17,630 --> 00:59:21,740
cycles and that sort of thing how do we

1512
00:59:19,489 --> 00:59:23,239
come up with an estimate for how many

1513
00:59:21,739 --> 00:59:25,519
cycles we think we should be taking how

1514
00:59:23,239 --> 00:59:27,589
do we check against that how do we

1515
00:59:25,519 --> 00:59:28,699
measure how much we are taking all that

1516
00:59:27,590 --> 00:59:31,309
stuff that's what we'll talk about

1517
00:59:28,699 --> 00:59:33,349
tomorrow for now we will go to the QA

1518
00:59:31,309 --> 00:59:35,119
since I introduced a lot of stuff on the

1519
00:59:33,349 --> 00:59:37,429
stream just in case anyone has any

1520
00:59:35,119 --> 00:59:40,250
questions I'd like to just kind of have

1521
00:59:37,429 --> 00:59:41,779
a brief Q&amp;A where people can ask about

1522
00:59:40,250 --> 00:59:44,780
them so if you do have a question please

1523
00:59:41,780 --> 00:59:45,680
go ahead and ask it now put Q colon in

1524
00:59:44,780 --> 00:59:48,920
front of it

1525
00:59:45,679 --> 00:59:51,399
and I will see if I can clarify things

1526
00:59:48,920 --> 00:59:51,400
for you

1527
01:00:13,320 --> 01:00:17,650
otama click would you be willing to make

1528
01:00:15,730 --> 01:00:18,699
more blackboard episodes this is very

1529
01:00:17,650 --> 01:00:20,769
informative

1530
01:00:18,699 --> 01:00:22,809
I always make blackboard episodes when

1531
01:00:20,769 --> 01:00:24,009
they come up if you have something in

1532
01:00:22,809 --> 01:00:25,719
particular that you think we didn't

1533
01:00:24,010 --> 01:00:27,490
cover in enough detail on a previous

1534
01:00:25,719 --> 01:00:28,809
episode please let me know and we could

1535
01:00:27,489 --> 01:00:31,509
do a blackboard session of it eventually

1536
01:00:28,809 --> 01:00:32,889
but anytime I come to a point in

1537
01:00:31,510 --> 01:00:34,450
handmade hero where I need to explain

1538
01:00:32,889 --> 01:00:36,190
something we do do a blackboard episode

1539
01:00:34,449 --> 01:00:37,659
and we have had multiple blackboard

1540
01:00:36,190 --> 01:00:40,210
episodes in the past when we have gotten

1541
01:00:37,659 --> 01:00:42,250
to those things so I always I never

1542
01:00:40,210 --> 01:00:43,179
skimp out on the blackboard when it's

1543
01:00:42,250 --> 01:00:48,159
time to blackboard

1544
01:00:43,179 --> 01:00:49,599
we blackboard grumpy giant 256 are you

1545
01:00:48,159 --> 01:00:52,359
going to be using anything like vtune

1546
01:00:49,599 --> 01:00:54,250
for measuring performance I don't know

1547
01:00:52,360 --> 01:00:59,519
probably not I think we'll just probably

1548
01:00:54,250 --> 01:01:03,340
our DTSC it but I don't know I'll ask

1549
01:00:59,519 --> 01:01:05,320
cuz just correct me if I'm wrong v2

1550
01:01:03,340 --> 01:01:07,180
still costs a lot of money if I'm not

1551
01:01:05,320 --> 01:01:08,620
mistaken and I'd like to keep it the

1552
01:01:07,179 --> 01:01:11,469
stream to things that people can

1553
01:01:08,619 --> 01:01:13,239
actually use themselves so we'll try to

1554
01:01:11,469 --> 01:01:16,329
just write our own enough of our own

1555
01:01:13,239 --> 01:01:18,309
stuff that we can do it and leave vtune

1556
01:01:16,329 --> 01:01:19,420
is an exercise for the reader with $500

1557
01:01:18,309 --> 01:01:23,309
unless they're giving it away for free

1558
01:01:19,420 --> 01:01:23,309
now I'm not sure

1559
01:01:25,858 --> 01:01:33,699
how our instructions written in cache

1560
01:01:28,420 --> 01:01:35,650
memory I have absolutely no idea to be

1561
01:01:33,699 --> 01:01:38,799
honest I really don't I have no idea

1562
01:01:35,650 --> 01:01:40,210
that would be a great question for

1563
01:01:38,800 --> 01:01:43,240
someone at Intel I don't know if they

1564
01:01:40,210 --> 01:01:46,210
document it they might but they might

1565
01:01:43,239 --> 01:01:50,229
not that may just be a trade secret I

1566
01:01:46,210 --> 01:01:52,329
have no idea so you know I programmed

1567
01:01:50,230 --> 01:01:57,429
for 30 years now and I have and I've

1568
01:01:52,329 --> 01:01:59,799
never once seen somebody talk about the

1569
01:01:57,429 --> 01:02:03,190
actual format of the microcode like

1570
01:01:59,800 --> 01:02:05,890
literally the format so I don't know but

1571
01:02:03,190 --> 01:02:07,630
yeah in you could I've never trot like

1572
01:02:05,889 --> 01:02:09,129
I've never had a case it wasn't like I

1573
01:02:07,630 --> 01:02:11,230
tried to go find it and couldn't find it

1574
01:02:09,130 --> 01:02:12,849
I just never seen it come up it might be

1575
01:02:11,230 --> 01:02:15,010
that if you do a search for like Intel

1576
01:02:12,849 --> 01:02:16,539
micro code format or something or x86

1577
01:02:15,010 --> 01:02:18,070
and microcurrent egg 64 micro format

1578
01:02:16,539 --> 01:02:19,599
maybe there's a page somewhere it talks

1579
01:02:18,070 --> 01:02:20,769
about it maybe Intel's got a doc on it

1580
01:02:19,599 --> 01:02:24,759
it could be in the system architecture

1581
01:02:20,769 --> 01:02:25,780
manual I don't know but yeah so I don't

1582
01:02:24,760 --> 01:02:27,640
know that'd be a great question for

1583
01:02:25,780 --> 01:02:34,869
somebody didn't tell is it public and if

1584
01:02:27,639 --> 01:02:36,219
so where is it do we manually issue

1585
01:02:34,869 --> 01:02:38,200
prefetching or is that something

1586
01:02:36,219 --> 01:02:40,679
inferred by the CPU by looking at how we

1587
01:02:38,199 --> 01:02:42,939
access memory it can actually be both

1588
01:02:40,679 --> 01:02:45,608
but in our case what I was talking about

1589
01:02:42,940 --> 01:02:48,570
on this diagram is is manual actually

1590
01:02:45,608 --> 01:02:51,460
when they introduced Cindy instructions

1591
01:02:48,570 --> 01:02:54,970
into the processor way back in the

1592
01:02:51,460 --> 01:02:56,260
pentium days I think was the p6 maybe

1593
01:02:54,969 --> 01:02:59,319
introduced them I don't know it might

1594
01:02:56,260 --> 01:03:01,480
have been the p5 with MMX I don't it's

1595
01:02:59,320 --> 01:03:05,260
too long I don't remember but way way

1596
01:03:01,480 --> 01:03:07,449
back when for forever ago they

1597
01:03:05,260 --> 01:03:10,570
introduced manual prefetching to the

1598
01:03:07,449 --> 01:03:13,118
processor so basically if you if you

1599
01:03:10,570 --> 01:03:15,070
write some code and you find that you're

1600
01:03:13,119 --> 01:03:17,769
getting a lot of cache misses but you

1601
01:03:15,070 --> 01:03:19,720
know which memory you did need and the

1602
01:03:17,769 --> 01:03:23,380
processor is not predicting it properly

1603
01:03:19,719 --> 01:03:24,579
you just put in prefetches if that's the

1604
01:03:23,380 --> 01:03:27,250
only problem you can just put in

1605
01:03:24,579 --> 01:03:30,340
prefetches that say like okay when I'm

1606
01:03:27,250 --> 01:03:32,349
doing this part of the loop go prefetch

1607
01:03:30,340 --> 01:03:34,539
the one that's like four iterations past

1608
01:03:32,349 --> 01:03:36,009
here or something and it goes each time

1609
01:03:34,539 --> 01:03:36,619
you know so that it kind of always kind

1610
01:03:36,010 --> 01:03:38,780
of lead

1611
01:03:36,619 --> 01:03:40,759
you know like a like a snipers on that

1612
01:03:38,780 --> 01:03:42,800
kind of leads it and the processor will

1613
01:03:40,760 --> 01:03:45,170
then always know oh okay I gotta bring

1614
01:03:42,800 --> 01:03:46,640
that in right they also have

1615
01:03:45,170 --> 01:03:48,289
non-temporal stores that's update

1616
01:03:46,639 --> 01:03:49,670
there's there's actually quite a few

1617
01:03:48,289 --> 01:03:50,989
probably not as much if you're a

1618
01:03:49,670 --> 01:03:52,400
hardcore optimizer I'm sure there's

1619
01:03:50,989 --> 01:03:53,689
quite a few things that it doesn't do

1620
01:03:52,400 --> 01:03:55,579
that you would like to be able to do

1621
01:03:53,690 --> 01:03:57,769
with programming the cache but they're

1622
01:03:55,579 --> 01:04:00,259
you know for for a lightweight optimizer

1623
01:03:57,769 --> 01:04:01,849
like a such as myself there's actually

1624
01:04:00,260 --> 01:04:04,280
plenty of instructions in there for

1625
01:04:01,849 --> 01:04:06,230
stuff like prefetching and non-temporal

1626
01:04:04,280 --> 01:04:08,150
stores like this that allow you to kind

1627
01:04:06,230 --> 01:04:10,159
of you know if you're just having a

1628
01:04:08,150 --> 01:04:11,210
basic problem with the cache you could

1629
01:04:10,159 --> 01:04:13,069
fix it

1630
01:04:11,210 --> 01:04:14,360
stuff like cache aliasing and these sort

1631
01:04:13,070 --> 01:04:16,210
of things which are things that I like

1632
01:04:14,360 --> 01:04:21,500
only vaguely understand and have never

1633
01:04:16,210 --> 01:04:23,030
optimized around you know they you know

1634
01:04:21,500 --> 01:04:24,679
a hard crafter might be like I wish they

1635
01:04:23,030 --> 01:04:25,880
gave me more micro control I could I

1636
01:04:24,679 --> 01:04:27,949
could do more with it you know whatever

1637
01:04:25,880 --> 01:04:31,150
and that's to give you some perspective

1638
01:04:27,949 --> 01:04:33,409
that's why some people really loved

1639
01:04:31,150 --> 01:04:35,869
optimizing further these things will be

1640
01:04:33,409 --> 01:04:37,759
SP use on the on the PlayStation 3 on

1641
01:04:35,869 --> 01:04:39,769
the Cell processor there is a single DSP

1642
01:04:37,760 --> 01:04:42,100
used which were basically things whose

1643
01:04:39,769 --> 01:04:46,099
cache was essentially fixed it was like

1644
01:04:42,099 --> 01:04:47,839
256 K of cache that you micro program

1645
01:04:46,099 --> 01:04:50,420
like you said what to move in and when

1646
01:04:47,840 --> 01:04:52,100
and when to move out and when and what

1647
01:04:50,420 --> 01:04:53,869
to move out and when and you just had

1648
01:04:52,099 --> 01:04:56,000
complete control and so the programmer

1649
01:04:53,869 --> 01:04:57,650
could do whatever they wanted and they

1650
01:04:56,000 --> 01:04:59,300
were able you know people who really

1651
01:04:57,650 --> 01:05:02,389
like that find great optimization that's

1652
01:04:59,300 --> 01:05:08,930
just a lot of power they don't have with

1653
01:05:02,389 --> 01:05:10,519
an Intel processor right I know this is

1654
01:05:08,929 --> 01:05:12,079
a long way off but after handmade heroes

1655
01:05:10,519 --> 01:05:14,809
done do you plan to continue educational

1656
01:05:12,079 --> 01:05:16,130
streams I can try to yeah but I probably

1657
01:05:14,809 --> 01:05:18,739
at some point will want to stop doing

1658
01:05:16,130 --> 01:05:20,720
them five days a week so maybe we'll do

1659
01:05:18,739 --> 01:05:21,889
like one educational stream a week after

1660
01:05:20,719 --> 01:05:23,209
handmade heroes done or something like

1661
01:05:21,889 --> 01:05:25,449
that just to make it a little easier on

1662
01:05:23,210 --> 01:05:25,449
me

1663
01:05:34,739 --> 01:05:38,729
how often do you estimate the actual

1664
01:05:36,929 --> 01:05:39,329
amount of work prior to implementing a

1665
01:05:38,730 --> 01:05:40,860
feature

1666
01:05:39,329 --> 01:05:43,710
versus just implementing it and

1667
01:05:40,860 --> 01:05:45,690
measuring it so it depends on the thing

1668
01:05:43,710 --> 01:05:47,130
if I'm actually going to go if I

1669
01:05:45,690 --> 01:05:50,460
actually have some code that I want to

1670
01:05:47,130 --> 01:05:55,440
be optimized I always do at least two

1671
01:05:50,460 --> 01:06:00,139
things one is I try to figure out how at

1672
01:05:55,440 --> 01:06:06,269
peak speed how fast it should go right

1673
01:06:00,139 --> 01:06:10,949
and two I try to I try to sort of figure

1674
01:06:06,269 --> 01:06:13,320
out what my target speed would be for

1675
01:06:10,949 --> 01:06:14,639
that right like I try to get those in

1676
01:06:13,320 --> 01:06:16,740
mind

1677
01:06:14,639 --> 01:06:18,960
so I basically say all right let's say

1678
01:06:16,739 --> 01:06:20,759
that everything issued exactly right and

1679
01:06:18,960 --> 01:06:22,710
I did the minimum number of opps for

1680
01:06:20,760 --> 01:06:24,000
this math that I need to and here's a

1681
01:06:22,710 --> 01:06:26,159
processor I'm on and I have this many

1682
01:06:24,000 --> 01:06:29,130
cycles per frame what you know speed

1683
01:06:26,159 --> 01:06:30,809
should this thing run at right I almost

1684
01:06:29,130 --> 01:06:36,000
always do that if I'm active trying to

1685
01:06:30,809 --> 01:06:38,039
optimize that said I am NOT a great

1686
01:06:36,000 --> 01:06:40,260
optimizer like I'm not the guy that you

1687
01:06:38,039 --> 01:06:42,420
want to take advice from necessarily so

1688
01:06:40,260 --> 01:06:45,830
that may not be such a great idea but I

1689
01:06:42,420 --> 01:06:47,849
always like back-of-the-envelope

1690
01:06:45,829 --> 01:06:49,440
computations in that way a

1691
01:06:47,849 --> 01:06:50,639
back-of-the-envelope computations

1692
01:06:49,440 --> 01:06:52,500
basically which is what I'm going to

1693
01:06:50,639 --> 01:06:55,469
talk about on next stream basically is

1694
01:06:52,500 --> 01:06:57,630
going okay just a rough estimate how

1695
01:06:55,469 --> 01:06:59,459
fast should this thing run and the

1696
01:06:57,630 --> 01:07:01,740
reason that I like that is because it

1697
01:06:59,460 --> 01:07:03,510
gives me something to measure against so

1698
01:07:01,739 --> 01:07:05,549
I can go what if it doesn't turn out to

1699
01:07:03,510 --> 01:07:08,160
be something within a reasonable

1700
01:07:05,550 --> 01:07:10,590
percentage of that I can say why what's

1701
01:07:08,159 --> 01:07:12,539
the thing what what was I not thinking

1702
01:07:10,590 --> 01:07:15,930
about that's causing me to not get what

1703
01:07:12,539 --> 01:07:17,460
I want right and so like for example if

1704
01:07:15,929 --> 01:07:19,289
you get into a situation where you're

1705
01:07:17,460 --> 01:07:21,720
like I should be able to do this many

1706
01:07:19,289 --> 01:07:23,849
loads and this many multiplies and this

1707
01:07:21,719 --> 01:07:25,339
many stores all pipeline properly this

1708
01:07:23,849 --> 01:07:28,289
should work out to this and it's not

1709
01:07:25,340 --> 01:07:30,570
that's a great time to go call up Intel

1710
01:07:28,289 --> 01:07:32,579
call up whoever and be like ask your

1711
01:07:30,570 --> 01:07:34,200
optimization friends what's going on

1712
01:07:32,579 --> 01:07:36,710
here can you give me some information

1713
01:07:34,199 --> 01:07:38,849
and I've seen great results from that

1714
01:07:36,710 --> 01:07:40,679
some optimizers who are much more

1715
01:07:38,849 --> 01:07:44,039
serious than I am like Mike Sartain for

1716
01:07:40,679 --> 01:07:45,358
example I've seen them do stuff where

1717
01:07:44,039 --> 01:07:47,519
they encounter they end up at places

1718
01:07:45,358 --> 01:07:48,538
where they're like this is running too

1719
01:07:47,519 --> 01:07:49,829
slowly

1720
01:07:48,539 --> 01:07:53,309
and I've computed everything out and I

1721
01:07:49,829 --> 01:07:56,339
know it is and they've gone and talked

1722
01:07:53,309 --> 01:07:59,640
to Intel and they've gotten Intel to run

1723
01:07:56,338 --> 01:08:02,458
like top secret traces of the code that

1724
01:07:59,639 --> 01:08:03,418
they can't even see necessarily how they

1725
01:08:02,458 --> 01:08:05,938
were doing them because it's like on

1726
01:08:03,418 --> 01:08:06,509
internal only stuff and Intel will send

1727
01:08:05,938 --> 01:08:10,168
them back

1728
01:08:06,509 --> 01:08:11,849
Oh the problem is that there's a thing

1729
01:08:10,168 --> 01:08:13,708
in the processor that works like this

1730
01:08:11,849 --> 01:08:15,660
and you're hitting it because you're

1731
01:08:13,708 --> 01:08:18,778
alternating these two things and it was

1732
01:08:15,659 --> 01:08:20,880
like okay right and so a really really

1733
01:08:18,779 --> 01:08:24,210
hard core optimization guy knows the

1734
01:08:20,880 --> 01:08:25,500
boundary that's stated in the Box sees

1735
01:08:24,210 --> 01:08:28,198
if they can hit it and when they don't

1736
01:08:25,500 --> 01:08:29,789
hit it and don't know why they ask the

1737
01:08:28,198 --> 01:08:32,278
processor manufacturer and find out and

1738
01:08:29,789 --> 01:08:33,658
that's like the hard core thing right so

1739
01:08:32,279 --> 01:08:35,609
I always at least try to the first part

1740
01:08:33,658 --> 01:08:36,358
of that process which is to let me know

1741
01:08:35,609 --> 01:08:37,710
where I'm at

1742
01:08:36,359 --> 01:08:39,179
relative to what I should be doing

1743
01:08:37,710 --> 01:08:40,170
because I think that's a pretty

1744
01:08:39,179 --> 01:08:41,849
important thing to have because

1745
01:08:40,170 --> 01:08:43,380
otherwise you don't really know where

1746
01:08:41,849 --> 01:08:45,659
you're at you're like I don't know like

1747
01:08:43,380 --> 01:08:47,338
is this code optimizer isn't it who

1748
01:08:45,658 --> 01:08:48,539
knows because I don't know how fast it

1749
01:08:47,338 --> 01:08:49,948
should go and if I don't know how fast

1750
01:08:48,539 --> 01:08:51,658
it should go I don't know whether how

1751
01:08:49,948 --> 01:09:00,419
fast it's running right now is pretty

1752
01:08:51,658 --> 01:09:02,039
fast or pretty slow you know so so if

1753
01:09:00,420 --> 01:09:03,210
memory takes a few hundred cycles if the

1754
01:09:02,039 --> 01:09:04,618
instructions have to reach out to the

1755
01:09:03,210 --> 01:09:08,039
hard drive what impact would that have

1756
01:09:04,618 --> 01:09:14,698
the answer is a lot less now because of

1757
01:09:08,039 --> 01:09:15,838
SSDs so it's getting better but the way

1758
01:09:14,698 --> 01:09:19,769
to think about the hard drive is just

1759
01:09:15,838 --> 01:09:21,689
adds yet another piece right so I think

1760
01:09:19,770 --> 01:09:23,069
we drew this diagram a long time ago and

1761
01:09:21,689 --> 01:09:24,328
handmade here actually but since it's a

1762
01:09:23,069 --> 01:09:27,420
little more relevant now imma draw it

1763
01:09:24,328 --> 01:09:33,789
again you could think of it this way

1764
01:09:27,420 --> 01:09:40,239
right register

1765
01:09:33,789 --> 01:09:44,930
l1 l2 l3 memory just add another box

1766
01:09:40,239 --> 01:09:51,039
drive right and you can even do two of

1767
01:09:44,930 --> 01:09:54,590
them drive and network right so cheapest

1768
01:09:51,039 --> 01:09:58,840
right this is like almost free this is

1769
01:09:54,590 --> 01:10:03,260
very expensive and everything in between

1770
01:09:58,840 --> 01:10:05,180
and that's why you end up with this sort

1771
01:10:03,260 --> 01:10:07,699
of concept that latency you know

1772
01:10:05,180 --> 01:10:09,260
somewhere around here latency starts

1773
01:10:07,699 --> 01:10:11,689
being this kind of dominating thing that

1774
01:10:09,260 --> 01:10:14,539
you're thinking about because it starts

1775
01:10:11,689 --> 01:10:16,489
getting so big you know 300 cycles up to

1776
01:10:14,539 --> 01:10:18,019
you know thousands of cycles or tens and

1777
01:10:16,489 --> 01:10:20,059
thousands of cycles or way worse

1778
01:10:18,020 --> 01:10:23,810
depending on what we're talking about

1779
01:10:20,060 --> 01:10:26,990
fetching from here what you end up doing

1780
01:10:23,810 --> 01:10:28,460
is somewhere you know as latency starts

1781
01:10:26,989 --> 01:10:29,210
to dominate as you move in this

1782
01:10:28,460 --> 01:10:31,159
direction

1783
01:10:29,210 --> 01:10:33,439
that's why everything tends to be

1784
01:10:31,159 --> 01:10:37,340
overlapped when you get out here in a

1785
01:10:33,439 --> 01:10:38,750
huge way like drive stuff you issue you

1786
01:10:37,340 --> 01:10:41,569
know like on the thing that I'm doing it

1787
01:10:38,750 --> 01:10:44,090
at work right now I issue Drive reads

1788
01:10:41,569 --> 01:10:48,049
two seconds in advance of where they

1789
01:10:44,090 --> 01:10:50,600
would be used or more right so we're

1790
01:10:48,050 --> 01:10:54,520
talking six billion instructions in

1791
01:10:50,600 --> 01:10:58,370
advance I'm issuing them at least right

1792
01:10:54,520 --> 01:11:01,880
and and sometimes more depending on the

1793
01:10:58,369 --> 01:11:05,050
circumstance right so that's just that's

1794
01:11:01,880 --> 01:11:05,050
just how that that is

1795
01:11:13,948 --> 01:11:18,129
start your pancakes two questions are

1796
01:11:16,300 --> 01:11:19,659
there ever any cases where we have to

1797
01:11:18,130 --> 01:11:20,889
worry about one of our instructions

1798
01:11:19,658 --> 01:11:23,529
being decoded into multiple micro

1799
01:11:20,889 --> 01:11:25,329
instructions without our knowledge - in

1800
01:11:23,529 --> 01:11:27,158
optimizing have you set up the code in

1801
01:11:25,329 --> 01:11:28,569
such a way that you can optimize things

1802
01:11:27,158 --> 01:11:30,969
function by function with this

1803
01:11:28,569 --> 01:11:32,170
eventualities in mind or will we have to

1804
01:11:30,969 --> 01:11:36,760
restructure some of the functions to

1805
01:11:32,170 --> 01:11:42,730
allow them to be optimized so question

1806
01:11:36,760 --> 01:11:44,579
one the answer is typically I never

1807
01:11:42,729 --> 01:11:46,689
think about micro code all that much

1808
01:11:44,579 --> 01:11:49,000
because the throughput and latency

1809
01:11:46,689 --> 01:11:52,149
numbers tend to be all you really need

1810
01:11:49,000 --> 01:11:55,448
to know for baseline optimization like

1811
01:11:52,149 --> 01:11:58,179
we're doing if you're trying to do super

1812
01:11:55,448 --> 01:11:59,500
hard core optimization then yes actually

1813
01:11:58,179 --> 01:12:03,760
that is something you need to worry

1814
01:11:59,500 --> 01:12:07,539
about because of this part that I was

1815
01:12:03,760 --> 01:12:09,730
talking about back a little earlier you

1816
01:12:07,539 --> 01:12:12,850
can sort of see exactly why this comes

1817
01:12:09,729 --> 01:12:14,738
into play this thing with the issuing

1818
01:12:12,850 --> 01:12:16,780
it's the it's the issuing that kills you

1819
01:12:14,738 --> 01:12:19,029
right so when things get too coated into

1820
01:12:16,779 --> 01:12:21,729
micro multiple micro code instructions

1821
01:12:19,029 --> 01:12:24,130
what that means is it puts more pressure

1822
01:12:21,729 --> 01:12:26,198
on the on your issuing count right if

1823
01:12:24,130 --> 01:12:28,239
something gets blown out into seven

1824
01:12:26,198 --> 01:12:29,859
micro instructions that means that that

1825
01:12:28,238 --> 01:12:31,809
thing you thought was one instruction

1826
01:12:29,859 --> 01:12:33,908
actually gonna take two cycles even just

1827
01:12:31,810 --> 01:12:36,100
to issue everything of if they're not

1828
01:12:33,908 --> 01:12:38,589
independent possibly more it could take

1829
01:12:36,100 --> 01:12:41,500
up to the seven instructions if they're

1830
01:12:38,590 --> 01:12:42,969
all serially dependent right and so it's

1831
01:12:41,500 --> 01:12:44,948
having something broken out into micro

1832
01:12:42,969 --> 01:12:46,420
code if they're serially dependent and

1833
01:12:44,948 --> 01:12:48,849
there isn't code around it that can be

1834
01:12:46,420 --> 01:12:51,010
executed to hide that bubble could

1835
01:12:48,850 --> 01:12:53,320
absolutely be a problem but again is

1836
01:12:51,010 --> 01:12:55,300
that common note that's not the common

1837
01:12:53,319 --> 01:12:58,238
case the common case is you don't have

1838
01:12:55,300 --> 01:13:00,429
to think about micro code will it happen

1839
01:12:58,238 --> 01:13:01,750
if you're a super harka code optimizer I

1840
01:13:00,429 --> 01:13:03,880
suspect the answer is absolutely yes

1841
01:13:01,750 --> 01:13:06,639
will it happen if you're just a you know

1842
01:13:03,880 --> 01:13:09,190
reasonable optimizer such as myself no

1843
01:13:06,639 --> 01:13:12,190
you don't tend to be going you don't

1844
01:13:09,189 --> 01:13:13,329
tend to push things to the limit of peak

1845
01:13:12,189 --> 01:13:14,198
performance where you're gonna have to

1846
01:13:13,329 --> 01:13:17,948
start thinking about things like that

1847
01:13:14,198 --> 01:13:18,819
question to whether I've set up the code

1848
01:13:17,948 --> 01:13:20,888
in such a way that we can optimize

1849
01:13:18,819 --> 01:13:22,899
things function by function the answer

1850
01:13:20,889 --> 01:13:24,429
is generally yes and generally that's a

1851
01:13:22,899 --> 01:13:26,259
good thing to be doing just in general

1852
01:13:24,429 --> 01:13:28,720
like when I try to write code I try

1853
01:13:26,260 --> 01:13:31,659
to write code knowing what things are

1854
01:13:28,720 --> 01:13:36,010
expensive and really what that boils

1855
01:13:31,659 --> 01:13:37,840
down to is order stuff right remember

1856
01:13:36,010 --> 01:13:41,350
order notation that's the thing that's

1857
01:13:37,840 --> 01:13:44,619
like Oh N Oh and squared right that sort

1858
01:13:41,350 --> 01:13:49,590
of thing basically what you want to

1859
01:13:44,619 --> 01:13:51,819
think about is how many iterations right

1860
01:13:49,590 --> 01:13:53,770
that's really like what you want to

1861
01:13:51,819 --> 01:13:55,989
think about so you've got four loops

1862
01:13:53,770 --> 01:13:58,870
sometimes you get four loops inside four

1863
01:13:55,989 --> 01:14:00,369
loops and so on that little piece of

1864
01:13:58,869 --> 01:14:03,460
code in the middle how many iterations

1865
01:14:00,369 --> 01:14:04,689
does it have to do right and if you

1866
01:14:03,460 --> 01:14:06,159
think about that in the back of your

1867
01:14:04,689 --> 01:14:07,509
head you're always going to kind of know

1868
01:14:06,159 --> 01:14:09,309
what your slow parts of the game are

1869
01:14:07,510 --> 01:14:11,440
going to be a lot of times right because

1870
01:14:09,310 --> 01:14:14,170
the things that that executes the most

1871
01:14:11,439 --> 01:14:15,879
frequently are the things that have that

1872
01:14:14,170 --> 01:14:18,970
happen and so in the case of the

1873
01:14:15,880 --> 01:14:23,920
software renderer pixels right is a loop

1874
01:14:18,970 --> 01:14:25,300
over x and y right so it's om squared in

1875
01:14:23,920 --> 01:14:28,180
the size of the thing on the screen

1876
01:14:25,300 --> 01:14:29,739
right it's it's filling in an area so I

1877
01:14:28,180 --> 01:14:32,409
just tend to know when I'm writing a

1878
01:14:29,739 --> 01:14:33,789
software renderer okay what are the

1879
01:14:32,409 --> 01:14:35,619
things that are gonna happen to software

1880
01:14:33,789 --> 01:14:38,380
renderer I know that I've got relatively

1881
01:14:35,619 --> 01:14:40,329
big sprites on the screen that fill up a

1882
01:14:38,380 --> 01:14:42,190
fair number of pixels I know that I have

1883
01:14:40,329 --> 01:14:44,619
a fairly low number of them by

1884
01:14:42,189 --> 01:14:46,629
comparison right so like I've got the

1885
01:14:44,619 --> 01:14:50,229
number of sprites you know maybe that's

1886
01:14:46,630 --> 01:14:52,119
ten thousand or something total I know

1887
01:14:50,229 --> 01:14:55,239
I've got the number of pixels you know I

1888
01:14:52,119 --> 01:14:57,699
know that's like you know millions right

1889
01:14:55,239 --> 01:14:58,929
and I can just tell like this is the

1890
01:14:57,699 --> 01:15:01,300
thing that I need to be the most

1891
01:14:58,930 --> 01:15:04,300
concerned about and this is less so

1892
01:15:01,300 --> 01:15:06,940
right and so you're already when you're

1893
01:15:04,300 --> 01:15:08,289
thinking about writing the code it

1894
01:15:06,939 --> 01:15:10,210
should be obvious to you just that

1895
01:15:08,289 --> 01:15:11,109
you're typing it in oh what are the

1896
01:15:10,210 --> 01:15:13,510
places here they're gonna have to be

1897
01:15:11,109 --> 01:15:14,979
optimized it's that rectangle fill right

1898
01:15:13,510 --> 01:15:16,360
that's the gonna be the very most

1899
01:15:14,979 --> 01:15:18,039
important thing optimize so everything

1900
01:15:16,359 --> 01:15:19,899
else is gonna be secondary to that so

1901
01:15:18,039 --> 01:15:21,699
you gotta make sure the code is all

1902
01:15:19,899 --> 01:15:25,269
about allowing me to optimize that

1903
01:15:21,699 --> 01:15:27,039
rectangle fill right that's at etc but

1904
01:15:25,270 --> 01:15:29,020
at the end of the day as long as you're

1905
01:15:27,039 --> 01:15:30,310
not doing totally crazy stuff for their

1906
01:15:29,020 --> 01:15:32,170
code and this is one of the reasons why

1907
01:15:30,310 --> 01:15:34,900
again I also hate object-oriented

1908
01:15:32,170 --> 01:15:36,100
programming is because typically I find

1909
01:15:34,899 --> 01:15:39,460
that if you write stuff in a

1910
01:15:36,100 --> 01:15:39,850
straightforward C programming style just

1911
01:15:39,460 --> 01:15:41,500
the

1912
01:15:39,850 --> 01:15:44,260
way you would normally write the code

1913
01:15:41,500 --> 01:15:48,039
tends to end up looking like how it will

1914
01:15:44,260 --> 01:15:50,500
end up being when it's optimized and the

1915
01:15:48,039 --> 01:15:52,560
only time that that doesn't happen is

1916
01:15:50,500 --> 01:15:54,939
because of the fact that C's structs

1917
01:15:52,560 --> 01:15:57,340
weren't designed when Cindy was the

1918
01:15:54,939 --> 01:15:59,199
thing and so typically you have to do a

1919
01:15:57,340 --> 01:16:01,750
little bit of reorganization for this

1920
01:15:59,199 --> 01:16:05,050
for the cindy aspect of things so that

1921
01:16:01,750 --> 01:16:06,880
changes things a little but I find that

1922
01:16:05,050 --> 01:16:09,190
typically the way people normally write

1923
01:16:06,880 --> 01:16:10,720
things in an OOP style it's very

1924
01:16:09,189 --> 01:16:11,969
different from how you would write them

1925
01:16:10,720 --> 01:16:14,440
if you were trying to optimize things

1926
01:16:11,970 --> 01:16:16,240
and so that's yet another reason I don't

1927
01:16:14,439 --> 01:16:18,099
like that paradigm it doesn't mean you

1928
01:16:16,239 --> 01:16:20,380
can't write it doesn't mean you can't

1929
01:16:18,100 --> 01:16:21,940
learn to program your oop in a style

1930
01:16:20,380 --> 01:16:23,319
that makes it okay for a play it just

1931
01:16:21,939 --> 01:16:25,839
means your natural instincts will often

1932
01:16:23,319 --> 01:16:27,250
be wrong in that domain and so that's

1933
01:16:25,840 --> 01:16:28,989
another reason I like the C style

1934
01:16:27,250 --> 01:16:30,789
because I feel like people's natural way

1935
01:16:28,989 --> 01:16:32,260
they might write something and C tends

1936
01:16:30,789 --> 01:16:33,550
to be pretty close to how it should be

1937
01:16:32,260 --> 01:16:39,460
laid out when you actually need to

1938
01:16:33,550 --> 01:16:43,150
optimize it would it be inefficient to

1939
01:16:39,460 --> 01:16:47,890
offload the cache to an SSD over SSD

1940
01:16:43,149 --> 01:16:51,489
over or with minimal RAM usage or with a

1941
01:16:47,890 --> 01:16:52,960
late I'm sorry I'm not sure I totally

1942
01:16:51,489 --> 01:16:55,300
understand the question would it be

1943
01:16:52,960 --> 01:16:59,560
inefficient to offload the cache to an

1944
01:16:55,300 --> 01:17:02,170
SSD over or with minimal RAM usage or

1945
01:16:59,560 --> 01:17:04,030
would the latency be too much I'm not

1946
01:17:02,170 --> 01:17:08,079
sure I understand the question and SSD

1947
01:17:04,029 --> 01:17:10,659
is basically just very slow Ram right so

1948
01:17:08,079 --> 01:17:13,479
it sits at again the place that I drew

1949
01:17:10,659 --> 01:17:16,269
it sits over here in the hierarchy right

1950
01:17:13,479 --> 01:17:18,549
and so you would never offload things to

1951
01:17:16,270 --> 01:17:22,110
an SSD you would offload them to memory

1952
01:17:18,550 --> 01:17:24,880
first and then to the SSD usually

1953
01:17:22,109 --> 01:17:27,909
because you want to overlap that right

1954
01:17:24,880 --> 01:17:29,079
you want to overlap that that flush but

1955
01:17:27,909 --> 01:17:32,519
yeah I'm not sure I totally understand

1956
01:17:29,079 --> 01:17:34,869
the question so sorry about that

1957
01:17:32,520 --> 01:17:36,930
premature optimization is the root of

1958
01:17:34,869 --> 01:17:39,640
all evil what's your take on that quote

1959
01:17:36,930 --> 01:17:44,520
my take on that quote is it's largely a

1960
01:17:39,640 --> 01:17:48,820
meaningless quote unfortunately because

1961
01:17:44,520 --> 01:17:51,460
premature is the problem right it's

1962
01:17:48,819 --> 01:17:53,289
obviously true just at the face of it I

1963
01:17:51,460 --> 01:17:55,239
mean well I don't know if the truth

1964
01:17:53,289 --> 01:17:58,720
face it because I don't know the root of

1965
01:17:55,239 --> 01:18:02,289
all evil might be a bit much right it

1966
01:17:58,720 --> 01:18:03,460
might be that it's a statement that

1967
01:18:02,289 --> 01:18:07,899
would be unequivocally true would be

1968
01:18:03,460 --> 01:18:11,319
premature optimization is evil or is bad

1969
01:18:07,899 --> 01:18:12,939
right but the problem with that

1970
01:18:11,319 --> 01:18:14,880
statement is saying premature

1971
01:18:12,939 --> 01:18:17,500
optimization doesn't really help anyone

1972
01:18:14,880 --> 01:18:22,029
because how do you know what's premature

1973
01:18:17,500 --> 01:18:23,949
right on the one hand optimizing a bunch

1974
01:18:22,029 --> 01:18:25,929
of things at an instruction level when

1975
01:18:23,949 --> 01:18:27,189
you are when your game is already

1976
01:18:25,930 --> 01:18:29,230
running at 30 frames a second or

1977
01:18:27,189 --> 01:18:31,329
something like that might obviously be

1978
01:18:29,229 --> 01:18:32,859
stupid and premature and yeah that was a

1979
01:18:31,329 --> 01:18:35,050
huge waste of everyone's time and makes

1980
01:18:32,859 --> 01:18:36,519
the code less harder more brittle and

1981
01:18:35,050 --> 01:18:39,550
because you can't change it as easily in

1982
01:18:36,520 --> 01:18:41,710
whatever right so obviously that's true

1983
01:18:39,550 --> 01:18:44,409
but that's not normally what what the

1984
01:18:41,710 --> 01:18:45,579
the thing that might make a mistake the

1985
01:18:44,409 --> 01:18:48,099
thing where you tend to make the mistake

1986
01:18:45,579 --> 01:18:49,930
is okay do I need to store these things

1987
01:18:48,100 --> 01:18:51,700
in a spatial hierarchy or not right or

1988
01:18:49,930 --> 01:18:54,400
do I need to do this or not right and

1989
01:18:51,699 --> 01:18:56,529
the problem is doing those things or not

1990
01:18:54,399 --> 01:18:58,299
doing those things tends to have

1991
01:18:56,529 --> 01:19:00,250
architectural implications for the rest

1992
01:18:58,300 --> 01:19:02,199
of the code and it's not as simple as

1993
01:19:00,250 --> 01:19:04,930
just not doing it until you absolutely

1994
01:19:02,199 --> 01:19:06,699
have to because doing it later might

1995
01:19:04,930 --> 01:19:08,920
have to change how a bunch of stuff was

1996
01:19:06,699 --> 01:19:11,619
architected and then that optimization

1997
01:19:08,920 --> 01:19:13,750
was too late so post mature optimization

1998
01:19:11,619 --> 01:19:15,579
that becomes a problem and so I find the

1999
01:19:13,750 --> 01:19:16,569
problem with that quote is is not than

2000
01:19:15,579 --> 01:19:18,399
anything wrong with the court itself

2001
01:19:16,569 --> 01:19:20,319
it's just that knowing whether

2002
01:19:18,399 --> 01:19:23,889
something's premature or not is actually

2003
01:19:20,319 --> 01:19:29,289
very difficult and is not as easy as the

2004
01:19:23,890 --> 01:19:30,880
quote might make it sound is there any

2005
01:19:29,289 --> 01:19:31,659
way to use or avoid hyper setting to

2006
01:19:30,880 --> 01:19:33,460
your advantage

2007
01:19:31,659 --> 01:19:35,439
yes and we will be doing that on the

2008
01:19:33,460 --> 01:19:38,020
stream we will be using both hyper

2009
01:19:35,439 --> 01:19:39,849
threading and regular threading in the

2010
01:19:38,020 --> 01:19:43,920
in the renderer and we'll talk about how

2011
01:19:39,850 --> 01:19:43,920
to use those on the next stream probably

2012
01:19:44,399 --> 01:19:50,049
what you tell someone who doesn't like

2013
01:19:46,600 --> 01:19:52,030
Emacs I tell them not to use Emacs I

2014
01:19:50,050 --> 01:19:53,320
just use Emacs because that's the editor

2015
01:19:52,029 --> 01:19:55,630
that I'm most comfortable with but I

2016
01:19:53,319 --> 01:19:57,609
think everyone should use provided they

2017
01:19:55,630 --> 01:20:01,029
can be provided they can be like roughly

2018
01:19:57,609 --> 01:20:03,429
as fast as they see me code on stream if

2019
01:20:01,029 --> 01:20:05,229
you can code that fast in whatever

2020
01:20:03,430 --> 01:20:06,520
editor you want I think you're good

2021
01:20:05,229 --> 01:20:08,349
if you can't

2022
01:20:06,520 --> 01:20:09,700
then you might want to consider either

2023
01:20:08,350 --> 01:20:11,410
learning how to use your editor better

2024
01:20:09,699 --> 01:20:13,239
or switching to another editor not so

2025
01:20:11,409 --> 01:20:15,489
the Emacs but just another editor that's

2026
01:20:13,239 --> 01:20:17,710
better so that you can be at least

2027
01:20:15,489 --> 01:20:18,969
roughly as fast as I am because that's

2028
01:20:17,710 --> 01:20:20,170
the speed that I think you want to

2029
01:20:18,970 --> 01:20:21,550
roughly go at if you're going

2030
01:20:20,170 --> 01:20:23,409
significantly slower than I'm going

2031
01:20:21,550 --> 01:20:24,909
that's probably a bad sign

2032
01:20:23,409 --> 01:20:26,920
especially because I'm coding slower on

2033
01:20:24,909 --> 01:20:28,449
stream than I tend to code in real life

2034
01:20:26,920 --> 01:20:30,609
because I'm talking and stuff so if you

2035
01:20:28,449 --> 01:20:32,519
can't at least hit that speed I think

2036
01:20:30,609 --> 01:20:34,420
you want to think about whether you're

2037
01:20:32,520 --> 01:20:36,790
facile enough with the editor that

2038
01:20:34,420 --> 01:20:41,170
you're using but it doesn't have to be

2039
01:20:36,789 --> 01:20:42,609
Emacs does hyper threading reduce

2040
01:20:41,170 --> 01:20:44,230
maximum bandwidth because it has to

2041
01:20:42,609 --> 01:20:47,049
switch between states or can both states

2042
01:20:44,229 --> 01:20:48,819
operate at the same time typically yet

2043
01:20:47,050 --> 01:20:50,470
if the bandwidth is is typically shared

2044
01:20:48,819 --> 01:20:52,090
between hyper threads so yeah the

2045
01:20:50,470 --> 01:20:53,530
bandwidth doesn't get any higher just

2046
01:20:52,090 --> 01:20:57,340
because there's thread it hyper

2047
01:20:53,529 --> 01:20:59,920
threading so with a reduced bandwidth is

2048
01:20:57,340 --> 01:21:01,569
a little bit hard to say because

2049
01:20:59,920 --> 01:21:03,430
bandwidth is a measure of how much stuff

2050
01:21:01,569 --> 01:21:05,199
is moving into the processor so that

2051
01:21:03,430 --> 01:21:07,450
obviously is always the same but if you

2052
01:21:05,199 --> 01:21:09,250
have too hyper threads they are sharing

2053
01:21:07,449 --> 01:21:10,510
that bandwidth obviously so you don't

2054
01:21:09,250 --> 01:21:19,560
get double the bandwidth just cuz

2055
01:21:10,510 --> 01:21:23,230
they're the two hyper threads let's see

2056
01:21:19,560 --> 01:21:24,580
is your in your active me in your

2057
01:21:23,229 --> 01:21:27,209
experience what drives the good enough

2058
01:21:24,579 --> 01:21:29,619
optimization and how does the notice and

2059
01:21:27,210 --> 01:21:32,560
how did the novice guys get a handle on

2060
01:21:29,619 --> 01:21:34,119
that actually it's very simple the good

2061
01:21:32,560 --> 01:21:38,050
enough part is actually pretty pretty

2062
01:21:34,119 --> 01:21:40,090
straightforward you have a game it needs

2063
01:21:38,050 --> 01:21:41,230
to run at 30 frames a second you have

2064
01:21:40,090 --> 01:21:43,989
some expensive stuff you're doing in

2065
01:21:41,229 --> 01:21:45,489
that game it is good enough when it runs

2066
01:21:43,989 --> 01:21:48,519
at 30 frames a second on your target

2067
01:21:45,489 --> 01:21:50,859
platform that is the end of it right and

2068
01:21:48,520 --> 01:21:53,500
so it's usually actually pretty easy to

2069
01:21:50,859 --> 01:21:55,689
know when you've hit that now hitting it

2070
01:21:53,500 --> 01:21:59,680
can be hard if you're trying to do too

2071
01:21:55,689 --> 01:22:01,149
much but you know knowing when you've

2072
01:21:59,680 --> 01:22:05,140
hit it is easy the game runs at 30

2073
01:22:01,149 --> 01:22:07,899
frames a second done all right and so

2074
01:22:05,140 --> 01:22:09,880
for any given piece how you know how

2075
01:22:07,899 --> 01:22:10,899
close that piece is to being optimal is

2076
01:22:09,880 --> 01:22:12,190
by doing that back-of-the-envelope

2077
01:22:10,899 --> 01:22:15,659
calculation that I was talking about

2078
01:22:12,189 --> 01:22:18,219
before it was it's basically about

2079
01:22:15,659 --> 01:22:19,769
having some idea of how fast the

2080
01:22:18,220 --> 01:22:21,390
processor could ideal

2081
01:22:19,770 --> 01:22:22,890
do this workload and then seeing how

2082
01:22:21,390 --> 01:22:26,070
fast you are doing that workload and

2083
01:22:22,890 --> 01:22:30,240
that's a good measure of how optimized

2084
01:22:26,069 --> 01:22:31,829
your performance is efficiency there's

2085
01:22:30,239 --> 01:22:33,859
not a lot you can do about efficiency

2086
01:22:31,829 --> 01:22:37,140
I'll be honest with you efficiency is is

2087
01:22:33,859 --> 01:22:38,460
very hard to know because how do you

2088
01:22:37,140 --> 01:22:40,230
know if the algorithm you're using is

2089
01:22:38,460 --> 01:22:42,569
very efficient sometimes you can figure

2090
01:22:40,229 --> 01:22:45,089
it out by going oh well I know that

2091
01:22:42,569 --> 01:22:47,009
somebody has proven this algorithm takes

2092
01:22:45,090 --> 01:22:49,440
at least this many iterations right it's

2093
01:22:47,010 --> 01:22:50,489
Oh n provably and I'm only doing o n so

2094
01:22:49,439 --> 01:22:52,379
I know I'm relatively efficient

2095
01:22:50,489 --> 01:22:53,909
sometimes that's true but sometimes the

2096
01:22:52,380 --> 01:22:57,930
thing that you're doing it's very hard

2097
01:22:53,909 --> 01:22:59,760
to know because it's like okay well yeah

2098
01:22:57,930 --> 01:23:00,930
it's proven to be O n but I'm

2099
01:22:59,760 --> 01:23:02,310
accelerating it with this lookup

2100
01:23:00,930 --> 01:23:03,810
structure that makes it a little closer

2101
01:23:02,310 --> 01:23:05,190
to o n most of the time if it's

2102
01:23:03,810 --> 01:23:06,720
distributed well but what it's not sure

2103
01:23:05,189 --> 01:23:08,519
well maybe I could use a different

2104
01:23:06,720 --> 01:23:10,289
spatial partition and then it would be

2105
01:23:08,520 --> 01:23:11,970
distributed better so I you know bla bla

2106
01:23:10,289 --> 01:23:13,800
bla bla bla and like there's all these

2107
01:23:11,970 --> 01:23:15,539
things where it's like really kind of

2108
01:23:13,800 --> 01:23:17,970
nuanced and so that part is actually

2109
01:23:15,539 --> 01:23:20,189
very hard to know and sometimes the

2110
01:23:17,970 --> 01:23:21,930
answer is just you iterate on both the

2111
01:23:20,189 --> 01:23:23,969
algorithm and the performance because

2112
01:23:21,930 --> 01:23:25,320
you just don't know until you can get

2113
01:23:23,970 --> 01:23:26,970
yourself down to 30 frames a second

2114
01:23:25,319 --> 01:23:28,529
that's just any it's any it's a grind

2115
01:23:26,970 --> 01:23:30,930
and there's nothing else we can do right

2116
01:23:28,529 --> 01:23:33,949
and that's just sometimes that's the

2117
01:23:30,930 --> 01:23:33,950
case right

2118
01:23:39,770 --> 01:23:42,440
so it looks like that's about it we're

2119
01:23:41,119 --> 01:23:45,189
out of time and I don't see any more

2120
01:23:42,439 --> 01:23:49,759
questions on optimization really

2121
01:23:45,189 --> 01:23:52,519
sudonym 73 you were posting a gift hub

2122
01:23:49,760 --> 01:23:53,539
link there for latency numbers do you

2123
01:23:52,520 --> 01:23:55,070
want to go ahead and post that to the

2124
01:23:53,539 --> 01:23:56,899
forum so we can like have it up there I

2125
01:23:55,069 --> 01:23:59,000
could I could tag it as a as i cap

2126
01:23:56,899 --> 01:24:01,519
ermine opposed or something that might

2127
01:23:59,000 --> 01:24:04,340
be cool but for now let's go ahead and

2128
01:24:01,520 --> 01:24:05,180
wrap things up tomorrow hopefully now

2129
01:24:04,340 --> 01:24:06,260
that we've kind of gotten all the

2130
01:24:05,180 --> 01:24:07,579
preliminaries out of the way I can just

2131
01:24:06,260 --> 01:24:09,320
talk briefly about some of the stuff

2132
01:24:07,579 --> 01:24:10,880
that we need to do so we can actually

2133
01:24:09,319 --> 01:24:13,369
get to some code because I'd like to do

2134
01:24:10,880 --> 01:24:16,010
a couple code things relatively soon for

2135
01:24:13,369 --> 01:24:18,439
us to start working with but anyway yeah

2136
01:24:16,010 --> 01:24:20,600
there we go that was basically a giant

2137
01:24:18,439 --> 01:24:22,339
blackboard session on optimization

2138
01:24:20,600 --> 01:24:23,960
topics hopefully that set the stage so

2139
01:24:22,340 --> 01:24:25,010
that when I referenced when I go through

2140
01:24:23,960 --> 01:24:27,920
talking about subjects and their

2141
01:24:25,010 --> 01:24:30,650
reference things I'm hopefully hopefully

2142
01:24:27,920 --> 01:24:32,390
that will be nice and easy for everyone

2143
01:24:30,649 --> 01:24:34,129
to understand so when I reference

2144
01:24:32,390 --> 01:24:35,300
something like in l3 cache or the

2145
01:24:34,130 --> 01:24:37,010
latency of this instruction or the

2146
01:24:35,300 --> 01:24:39,650
throughput or whatever will kind of all

2147
01:24:37,010 --> 01:24:40,940
be on that same page so if some of this

2148
01:24:39,649 --> 01:24:42,289
was confusing please go back and read

2149
01:24:40,939 --> 01:24:44,629
watch this or ask questions on the

2150
01:24:42,289 --> 01:24:46,069
forums so that we can kind of all be on

2151
01:24:44,630 --> 01:24:47,329
that page because as I go through this

2152
01:24:46,069 --> 01:24:49,340
I'm going to just refer to those things

2153
01:24:47,329 --> 01:24:51,500
like instruction throughput in that sort

2154
01:24:49,340 --> 01:24:53,329
so I'm gonna refer to those and and

2155
01:24:51,500 --> 01:24:55,369
assume that we now are clear on what

2156
01:24:53,329 --> 01:24:57,500
those mean all right thank you everyone

2157
01:24:55,369 --> 01:24:58,579
for joining me for another episode of

2158
01:24:57,500 --> 01:25:00,829
hand made here it's been a pleasure

2159
01:24:58,579 --> 01:25:03,619
talking about optimization with you know

2160
01:25:00,829 --> 01:25:04,819
coding today hopefully tomorrow so I was

2161
01:25:03,619 --> 01:25:07,159
talking about I did I hope that cleared

2162
01:25:04,819 --> 01:25:08,539
some things up and got us on a good sort

2163
01:25:07,159 --> 01:25:10,189
of on the same page for what we're about

2164
01:25:08,539 --> 01:25:12,319
to do for this week next week and so on

2165
01:25:10,189 --> 01:25:14,659
if you would like to follow along with

2166
01:25:12,319 --> 01:25:16,969
the code we're gonna do this week and

2167
01:25:14,659 --> 01:25:18,198
you want to pre-order the game that gets

2168
01:25:16,969 --> 01:25:19,698
you the source code so if you go to

2169
01:25:18,198 --> 01:25:21,979
hammer here or get Pierrot to the game

2170
01:25:19,698 --> 01:25:23,089
here and it comes with a source code so

2171
01:25:21,979 --> 01:25:23,839
you can download it every night after

2172
01:25:23,090 --> 01:25:26,300
we're done here

2173
01:25:23,840 --> 01:25:27,529
the forums are a great place to go if

2174
01:25:26,300 --> 01:25:30,529
you have questions that you want to ask

2175
01:25:27,529 --> 01:25:31,909
or you want to look up some stuff that

2176
01:25:30,529 --> 01:25:34,539
we've got up there like that ports to

2177
01:25:31,909 --> 01:25:37,309
Mac or Linux and also we've got some

2178
01:25:34,539 --> 01:25:39,590
coding resources anti episode guide just

2179
01:25:37,310 --> 01:25:40,789
stuff good stuff up there check that

2180
01:25:39,590 --> 01:25:42,050
site out if you're Fowler for the stream

2181
01:25:40,789 --> 01:25:44,029
we also have a patreon if you want to

2182
01:25:42,050 --> 01:25:46,489
support the video series and what we're

2183
01:25:44,029 --> 01:25:47,809
doing here we would love that you can

2184
01:25:46,488 --> 01:25:50,119
always subscribe they're very much

2185
01:25:47,810 --> 01:25:51,260
appreciated and we've have a tweet

2186
01:25:50,119 --> 01:25:52,250
but which treats the schedule so if

2187
01:25:51,260 --> 01:25:54,590
you're just trying to catch the stream

2188
01:25:52,250 --> 01:25:55,909
live on any particular day if that's the

2189
01:25:54,590 --> 01:25:57,920
place to go it'll always tell you the

2190
01:25:55,909 --> 01:25:59,359
schedule today we're 5 p.m. Pacific

2191
01:25:57,920 --> 01:26:01,810
Standard Time every day except Friday

2192
01:25:59,359 --> 01:26:04,849
when we're doing a morning stream 9 a.m.

2193
01:26:01,810 --> 01:26:06,800
so please check that out just so you can

2194
01:26:04,850 --> 01:26:07,850
check that schedule out so you can

2195
01:26:06,800 --> 01:26:09,860
remind yourself what the schedule is

2196
01:26:07,850 --> 01:26:11,690
it's a great way to do that so thanks

2197
01:26:09,859 --> 01:26:12,739
everyone for joining me and I will see

2198
01:26:11,689 --> 01:26:15,639
you guys tomorrow

2199
01:26:12,739 --> 01:26:15,639
take it easy everyone

