1
00:00:01,639 --> 00:00:07,680
okay hello everyone and welcome to

2
00:00:04,889 --> 00:00:11,308
handmade hero the show recode a complete

3
00:00:07,679 --> 00:00:13,678
game live on stream and occasionally so

4
00:00:11,308 --> 00:00:17,608
very occasionally mention actual

5
00:00:13,679 --> 00:00:19,050
computer science topics like order

6
00:00:17,609 --> 00:00:23,400
notation which we talked about for the

7
00:00:19,050 --> 00:00:24,449
past two days and the reason that we

8
00:00:23,399 --> 00:00:26,909
don't talk about that much is because I

9
00:00:24,449 --> 00:00:28,769
don't study them so I really don't have

10
00:00:26,910 --> 00:00:30,149
very much to say about them but

11
00:00:28,768 --> 00:00:33,299
hopefully if in the past few days

12
00:00:30,149 --> 00:00:37,229
everyone got like sort of the idea of

13
00:00:33,299 --> 00:00:38,729
what goes on out there in CS land so if

14
00:00:37,229 --> 00:00:43,049
they are urgent about it they can go

15
00:00:38,729 --> 00:00:45,898
check it out and equally importantly I

16
00:00:43,049 --> 00:00:48,899
hope they kind of got what the practical

17
00:00:45,899 --> 00:00:50,879
part of order notation is so they can

18
00:00:48,899 --> 00:00:52,558
understand when I say something like

19
00:00:50,878 --> 00:00:54,780
that would be N squared or that would be

20
00:00:52,558 --> 00:00:56,339
n log n I hope they just have an idea of

21
00:00:54,780 --> 00:01:01,109
what that actually means for code and

22
00:00:56,340 --> 00:01:04,170
why we might care about that aspect but

23
00:01:01,109 --> 00:01:06,030
that's about the end of the CES I am a

24
00:01:04,170 --> 00:01:10,109
very practical programmer not a lot of

25
00:01:06,030 --> 00:01:12,450
computer science in my brain so that's

26
00:01:10,109 --> 00:01:15,569
probably the last you'll hear of it that

27
00:01:12,450 --> 00:01:17,250
said we still have some actual practical

28
00:01:15,569 --> 00:01:20,639
programming to do based on some of that

29
00:01:17,250 --> 00:01:23,969
CS which is to say that this is an o n

30
00:01:20,640 --> 00:01:26,368
squared sort you know this is laughs

31
00:01:23,969 --> 00:01:35,310
we'll just split it Casey this is the 0

32
00:01:26,368 --> 00:01:37,739
N squared bubble sort right and we had

33
00:01:35,310 --> 00:01:39,450
just a to do in here already which was

34
00:01:37,739 --> 00:01:40,679
saying we could early out now we discuss

35
00:01:39,450 --> 00:01:42,990
that when we're talking about sorts

36
00:01:40,680 --> 00:01:45,630
which is that we don't actually have to

37
00:01:42,989 --> 00:01:48,359
bubble sort forever and keep actually

38
00:01:45,629 --> 00:01:50,728
doing the N squared the N passes over n

39
00:01:48,359 --> 00:01:53,549
items if we can see that the list has

40
00:01:50,728 --> 00:01:55,560
already sorted itself earlier we can

41
00:01:53,549 --> 00:01:57,118
just stop and so what we could do here

42
00:01:55,560 --> 00:02:03,599
is just introduce something which is

43
00:01:57,118 --> 00:02:05,849
like list is is sorted we could just say

44
00:02:03,599 --> 00:02:08,128
that that was true and then as we go

45
00:02:05,849 --> 00:02:09,868
through here if we ever had to swap an

46
00:02:08,128 --> 00:02:13,229
item we'll just say that the list is

47
00:02:09,868 --> 00:02:13,860
sorted equals false so that we know that

48
00:02:13,229 --> 00:02:15,599
we made a

49
00:02:13,860 --> 00:02:16,890
swap which means the list may not be

50
00:02:15,599 --> 00:02:18,840
sorted we found something that was out

51
00:02:16,889 --> 00:02:21,569
of order and then at the end we could

52
00:02:18,840 --> 00:02:23,789
just say okay well you know that if the

53
00:02:21,569 --> 00:02:25,709
list is sorted in fact I could make this

54
00:02:23,789 --> 00:02:27,479
even a loop condition here but why

55
00:02:25,710 --> 00:02:31,800
bother I'll just say if the list is

56
00:02:27,479 --> 00:02:33,179
sorted right we can get out early so we

57
00:02:31,800 --> 00:02:35,280
don't have to do the entire account and

58
00:02:33,180 --> 00:02:36,990
so this is a more traditional bubble

59
00:02:35,280 --> 00:02:40,919
sort most people will include that

60
00:02:36,990 --> 00:02:44,520
because it's relatively cheap obviously

61
00:02:40,919 --> 00:02:46,379
to do we could do something even

62
00:02:44,520 --> 00:02:47,760
slightly more ridiculous which is we

63
00:02:46,379 --> 00:02:50,069
could instead of setting list is sorted

64
00:02:47,759 --> 00:02:52,019
equal to false we could set out or equal

65
00:02:50,069 --> 00:02:53,549
to the count value or some eat I mean

66
00:02:52,020 --> 00:02:58,469
there's weird things that we could do

67
00:02:53,550 --> 00:03:00,390
that like yeah but point being that is

68
00:02:58,469 --> 00:03:01,709
the more traditional way that someone

69
00:03:00,389 --> 00:03:03,449
might write a bubble sort which is to

70
00:03:01,709 --> 00:03:05,459
say that once you can see that the list

71
00:03:03,449 --> 00:03:09,030
is clearly sorted you don't keep going

72
00:03:05,459 --> 00:03:10,620
that now if you remember order notation

73
00:03:09,030 --> 00:03:13,739
wise what does that do does that change

74
00:03:10,620 --> 00:03:16,469
it from 0 n squared no it does not it is

75
00:03:13,739 --> 00:03:20,340
still worst case 0 N squared what does

76
00:03:16,469 --> 00:03:23,250
that do it changes the expected running

77
00:03:20,340 --> 00:03:25,530
time from 0 N squared to something less

78
00:03:23,250 --> 00:03:27,930
right and we don't know how much less

79
00:03:25,530 --> 00:03:29,939
because it would depend entirely on how

80
00:03:27,930 --> 00:03:31,200
sorted the items are at the beginning if

81
00:03:29,939 --> 00:03:33,509
we're handed lists that are already

82
00:03:31,199 --> 00:03:36,359
sorted most of the time it would change

83
00:03:33,509 --> 00:03:38,789
our running time 20 n if we typically

84
00:03:36,360 --> 00:03:40,950
are handed things which happen to be out

85
00:03:38,789 --> 00:03:42,239
of order to the extent where items that

86
00:03:40,949 --> 00:03:45,149
should appear at the top are appearing

87
00:03:42,239 --> 00:03:51,959
near the bottom we will remain N squared

88
00:03:45,150 --> 00:03:57,900
and so we don't know in the general case

89
00:03:51,959 --> 00:04:02,000
but that is what that does right okay so

90
00:03:57,900 --> 00:04:02,000
now let's talk about some other sort

91
00:04:02,959 --> 00:04:09,959
let's do for example we talked about

92
00:04:06,539 --> 00:04:11,519
merge sort right and I explained how a

93
00:04:09,959 --> 00:04:14,039
merge sort would work I basically said

94
00:04:11,519 --> 00:04:17,879
okay you just break this thing up into

95
00:04:14,039 --> 00:04:19,560
pieces and each individual piece gets

96
00:04:17,879 --> 00:04:21,180
sorted and then merged with another

97
00:04:19,560 --> 00:04:23,220
piece so it's like you break it in half

98
00:04:21,180 --> 00:04:26,250
and half and half and half until you're

99
00:04:23,220 --> 00:04:27,280
down to only things that have one or two

100
00:04:26,250 --> 00:04:29,139
items in them

101
00:04:27,279 --> 00:04:32,679
and then each one of those kind of gets

102
00:04:29,139 --> 00:04:34,569
merged as you go so again let's go ahead

103
00:04:32,680 --> 00:04:36,370
and see what we need to do here so we

104
00:04:34,569 --> 00:04:41,079
start out and we have this array we've

105
00:04:36,370 --> 00:04:44,530
got you know a certain what's the right

106
00:04:41,079 --> 00:04:47,409
looking for we basically have a count

107
00:04:44,529 --> 00:04:49,239
sized array and so what we want to do is

108
00:04:47,410 --> 00:04:52,090
we're going to want to make this so we

109
00:04:49,240 --> 00:04:53,379
can split it in half so what I'm going

110
00:04:52,089 --> 00:04:55,060
to do there is I'm going to start by

111
00:04:53,379 --> 00:04:57,129
saying let's implement this recursively

112
00:04:55,060 --> 00:04:58,509
because it's probably the easiest way to

113
00:04:57,129 --> 00:05:00,040
implement it so we don't write our own

114
00:04:58,509 --> 00:05:02,409
stack we're just going to use the

115
00:05:00,040 --> 00:05:03,970
program stack and we'll go ahead and do

116
00:05:02,410 --> 00:05:05,800
that here but later we may want to

117
00:05:03,970 --> 00:05:07,330
change that depending on which sort we

118
00:05:05,800 --> 00:05:08,650
end up to trying to use it sounded like

119
00:05:07,329 --> 00:05:10,659
people were most excited about radix

120
00:05:08,649 --> 00:05:11,979
sort so we probably won't actually use

121
00:05:10,660 --> 00:05:14,400
this merge sort but just so we can see

122
00:05:11,980 --> 00:05:16,660
how it works so here on the merge sort

123
00:05:14,399 --> 00:05:19,209
what we need to do is we need to say

124
00:05:16,660 --> 00:05:23,229
okay there's a starting point so here's

125
00:05:19,209 --> 00:05:25,539
like the first entry and then we've got

126
00:05:23,228 --> 00:05:26,978
a count and so the first thing we'd do

127
00:05:25,540 --> 00:05:29,470
is we'd call merge sort and just say

128
00:05:26,978 --> 00:05:31,089
please merge sort like my entire list

129
00:05:29,470 --> 00:05:32,260
right maybe I'll put the count first

130
00:05:31,089 --> 00:05:34,959
because I tend to like having counts

131
00:05:32,259 --> 00:05:36,969
come first so I'm going to do that okay

132
00:05:34,959 --> 00:05:39,219
so we're going to say hey you gotta do

133
00:05:36,970 --> 00:05:40,450
this and I'll maybe make an if 0 here

134
00:05:39,220 --> 00:05:44,560
because otherwise the list will already

135
00:05:40,449 --> 00:05:48,009
be sorted so here's our merge sort so we

136
00:05:44,560 --> 00:05:51,069
do our merge sort and say okay here is

137
00:05:48,009 --> 00:05:52,839
the count here are the entries and in

138
00:05:51,069 --> 00:05:58,089
the merge sort we need to go alright if

139
00:05:52,839 --> 00:06:00,788
the count is 1 then we are obviously

140
00:05:58,089 --> 00:06:04,829
already sorted right so if the count is

141
00:06:00,788 --> 00:06:04,829
1 we don't need to do any work right

142
00:06:05,069 --> 00:06:15,399
right because what would be the point if

143
00:06:09,160 --> 00:06:17,860
the count is 2 then we just have to look

144
00:06:15,399 --> 00:06:19,509
at the two items and can swap them right

145
00:06:17,860 --> 00:06:22,389
so we really just have to do exactly

146
00:06:19,509 --> 00:06:23,829
this thing that we had here right

147
00:06:22,389 --> 00:06:25,629
because if we're looking at two two

148
00:06:23,829 --> 00:06:28,139
entries and we know that that's all we

149
00:06:25,629 --> 00:06:30,430
had to sort well then if the sort keys

150
00:06:28,139 --> 00:06:31,810
happen and in fact I can just I can

151
00:06:30,430 --> 00:06:34,449
actually construct this to look exactly

152
00:06:31,810 --> 00:06:36,819
like the other one we basically have

153
00:06:34,449 --> 00:06:40,300
whatever the first one is and whatever

154
00:06:36,819 --> 00:06:40,959
the second one is right if they are in

155
00:06:40,300 --> 00:06:44,910
the wrong order

156
00:06:40,959 --> 00:06:49,359
it then we swap them all right that's it

157
00:06:44,910 --> 00:06:52,650
and so that gives us both of our sort of

158
00:06:49,360 --> 00:06:57,129
termination cases like our stub cases

159
00:06:52,649 --> 00:06:59,709
where we know what to do in any other

160
00:06:57,129 --> 00:07:01,598
case then the way our merge sort has to

161
00:06:59,709 --> 00:07:04,329
work is it has to split it into two

162
00:07:01,598 --> 00:07:05,978
smaller problems right so what we then

163
00:07:04,329 --> 00:07:08,859
need to do is figure out what the half

164
00:07:05,978 --> 00:07:10,930
count is so what's our half count right

165
00:07:08,860 --> 00:07:12,098
because we need to partition this into

166
00:07:10,930 --> 00:07:14,759
two pieces that we're going to sort

167
00:07:12,098 --> 00:07:17,589
separately so we've got our half count

168
00:07:14,759 --> 00:07:20,020
and we'll call that may be the first

169
00:07:17,589 --> 00:07:22,418
half like the the half that were the you

170
00:07:20,019 --> 00:07:25,750
know half one maybe well you know it was

171
00:07:22,418 --> 00:07:27,879
called half 0 and then to produce half

172
00:07:25,750 --> 00:07:29,529
the other half we would just say well

173
00:07:27,879 --> 00:07:31,300
whatever the other count was whatever

174
00:07:29,529 --> 00:07:32,709
the count originally was however many

175
00:07:31,300 --> 00:07:34,810
were in the first half well we know that

176
00:07:32,709 --> 00:07:37,839
this is going to be the remainder will

177
00:07:34,810 --> 00:07:39,639
be in the second half okay and we know

178
00:07:37,839 --> 00:07:41,408
that this is not always the same number

179
00:07:39,639 --> 00:07:43,180
because we might have had an odd number

180
00:07:41,408 --> 00:07:44,829
of items so we can't split it into two

181
00:07:43,180 --> 00:07:46,180
even has one house going to have more

182
00:07:44,829 --> 00:07:48,069
than the other potentially right and

183
00:07:46,180 --> 00:07:51,550
that's totally fine we sought to handle

184
00:07:48,069 --> 00:07:53,379
that so there we go we got half 0 and

185
00:07:51,550 --> 00:07:56,770
half 1 and then what we have to do is

186
00:07:53,379 --> 00:07:58,810
sort what we've got left right so we

187
00:07:56,769 --> 00:08:02,288
have to say all right we need to sort

188
00:07:58,810 --> 00:08:04,689
both of those pieces so we need to merge

189
00:08:02,288 --> 00:08:06,339
sort the first part right which we know

190
00:08:04,689 --> 00:08:08,348
has this many in it and we know that

191
00:08:06,339 --> 00:08:10,689
that's still at the same location as

192
00:08:08,348 --> 00:08:13,240
ours the first empty was the same and

193
00:08:10,689 --> 00:08:15,550
then we've got another half that's like

194
00:08:13,240 --> 00:08:18,310
the part that comes after that that hath

195
00:08:15,550 --> 00:08:22,240
we merge sort it as well right so that

196
00:08:18,310 --> 00:08:25,360
would merge sort our items for us but

197
00:08:22,240 --> 00:08:29,348
now we have to put those in order right

198
00:08:25,360 --> 00:08:32,310
because we've we've we've sorted the two

199
00:08:29,348 --> 00:08:35,078
halves but the halves themselves are not

200
00:08:32,309 --> 00:08:36,759
together sorted right they have to be

201
00:08:35,078 --> 00:08:38,978
interleaved you remember how I said

202
00:08:36,759 --> 00:08:40,509
after we have two sorted things we then

203
00:08:38,979 --> 00:08:43,538
have to go through step through each one

204
00:08:40,509 --> 00:08:46,379
and interleave them properly right so

205
00:08:43,538 --> 00:08:48,789
that's what we have to do right here and

206
00:08:46,379 --> 00:08:52,179
so in order to do that I have to sweep

207
00:08:48,789 --> 00:08:55,948
through both halves effectively until I

208
00:08:52,179 --> 00:08:55,948
get to the end of each 10

209
00:08:56,340 --> 00:09:07,570
so uh I don't actually know I feel like

210
00:09:03,879 --> 00:09:14,409
we should be able to if we were clever

211
00:09:07,570 --> 00:09:16,629
right it seems like there might be some

212
00:09:14,409 --> 00:09:19,029
way let's let's think about this for a

213
00:09:16,629 --> 00:09:21,519
second this is one of those things where

214
00:09:19,029 --> 00:09:22,959
we could cheat and Gus go read about

215
00:09:21,519 --> 00:09:24,639
whether or not you could do a merge sort

216
00:09:22,960 --> 00:09:26,470
in place but again for the sake of

217
00:09:24,639 --> 00:09:28,299
Education I feel like we should

218
00:09:26,470 --> 00:09:30,790
challenge ourselves and try to figure

219
00:09:28,299 --> 00:09:32,339
out can we do this in place or do we you

220
00:09:30,789 --> 00:09:34,449
know should we have extra storage

221
00:09:32,340 --> 00:09:35,830
chances are we should have extra storage

222
00:09:34,450 --> 00:09:37,570
either way it's probably going to be

223
00:09:35,830 --> 00:09:39,639
much faster if we do have extra storage

224
00:09:37,570 --> 00:09:41,500
because we or always know exactly how

225
00:09:39,639 --> 00:09:42,819
much extra storage we would need and we

226
00:09:41,500 --> 00:09:44,259
could just pass that as a side band

227
00:09:42,820 --> 00:09:45,370
because we never would need more extra

228
00:09:44,259 --> 00:09:50,939
storage than the size of the original

229
00:09:45,370 --> 00:09:54,159
list right but I just kind of want to

230
00:09:50,940 --> 00:09:55,720
see if we could do it right just see if

231
00:09:54,159 --> 00:09:57,610
it's possible because we should be able

232
00:09:55,720 --> 00:10:00,279
to determine that and so what we have

233
00:09:57,610 --> 00:10:06,279
here we've got two halves right here's

234
00:10:00,279 --> 00:10:08,289
half 0 and here is half one right if we

235
00:10:06,279 --> 00:10:10,319
had more halves we could even have half

236
00:10:08,289 --> 00:10:17,379
three and half three would be confirmed

237
00:10:10,320 --> 00:10:19,810
right half three confirmed anyway so if

238
00:10:17,379 --> 00:10:22,899
we have two halves and we've got the

239
00:10:19,809 --> 00:10:25,329
entries in them all i need to do is just

240
00:10:22,899 --> 00:10:26,709
produce the composite buffer by starting

241
00:10:25,330 --> 00:10:28,509
here remember how this works i'm

242
00:10:26,710 --> 00:10:29,680
starting here I know these are sorted so

243
00:10:28,509 --> 00:10:31,090
I know these go in order and I know

244
00:10:29,679 --> 00:10:34,509
these go in order and I just need to

245
00:10:31,090 --> 00:10:36,850
pick at each moment from like to you

246
00:10:34,509 --> 00:10:38,879
know read locations right one here one

247
00:10:36,850 --> 00:10:42,190
here I usually to go which one of these

248
00:10:38,879 --> 00:10:43,629
should come first and when I know which

249
00:10:42,190 --> 00:10:47,230
one of these should come first I put

250
00:10:43,629 --> 00:10:50,830
that into the entry okay and then I

251
00:10:47,230 --> 00:10:53,440
advance it to the next one and that's

252
00:10:50,830 --> 00:10:55,540
all I need to do the problem is right

253
00:10:53,440 --> 00:10:57,460
what would happen if I wanted to do this

254
00:10:55,539 --> 00:11:00,039
in place well if I wanted to do this in

255
00:10:57,460 --> 00:11:03,400
place I've effectively got a pointer to

256
00:11:00,039 --> 00:11:06,339
this guy here this is where I would want

257
00:11:03,399 --> 00:11:07,480
to store the original guy so if half 0

258
00:11:06,340 --> 00:11:09,250
contains

259
00:11:07,480 --> 00:11:12,519
the correct the person who should go

260
00:11:09,250 --> 00:11:14,309
first then we got in a problem if this

261
00:11:12,519 --> 00:11:17,589
contains the person who should go first

262
00:11:14,309 --> 00:11:20,919
right then I would need to swap these

263
00:11:17,589 --> 00:11:23,620
two elements the problem is if I swap

264
00:11:20,919 --> 00:11:27,028
these two elements how would I remember

265
00:11:23,620 --> 00:11:39,940
that this guy is actually from this list

266
00:11:27,028 --> 00:11:45,370
right it's a little tricky but I think

267
00:11:39,940 --> 00:11:50,440
we can do it all we would need is the

268
00:11:45,370 --> 00:11:53,049
knowledge that we had swapped so that

269
00:11:50,440 --> 00:11:55,540
when we actually take from this guy

270
00:11:53,049 --> 00:11:57,969
again instead of advancing his pointer

271
00:11:55,539 --> 00:12:02,110
this way we restore his pointer to what

272
00:11:57,970 --> 00:12:04,209
it should have been before right I mean

273
00:12:02,110 --> 00:12:06,519
it seems like that should be pretty

274
00:12:04,208 --> 00:12:11,588
straightforward correct me if I'm wrong

275
00:12:06,519 --> 00:12:15,278
I'm on this guy I have to pick an entry

276
00:12:11,589 --> 00:12:17,589
I look and see that the entry that's in

277
00:12:15,278 --> 00:12:19,269
the slot where I would actually put it

278
00:12:17,589 --> 00:12:21,370
is not the one that goes there

279
00:12:19,269 --> 00:12:22,778
unfortunately if it was I just advance

280
00:12:21,370 --> 00:12:25,328
its pointer and I don't need to move

281
00:12:22,778 --> 00:12:28,568
anything so I'm trying to take from half

282
00:12:25,328 --> 00:12:33,519
one so what do I do well when I take

283
00:12:28,568 --> 00:12:36,429
from half one I put that into here I

284
00:12:33,519 --> 00:12:39,220
swap this guy out to here I change the

285
00:12:36,429 --> 00:12:41,888
read pointer for the this half to here

286
00:12:39,220 --> 00:12:44,800
and set a flag that says the next time

287
00:12:41,889 --> 00:12:50,470
you take from half 0 it's actually out

288
00:12:44,799 --> 00:12:52,958
in the swap place right so when you do

289
00:12:50,470 --> 00:12:55,420
that restore the pointer to point to

290
00:12:52,958 --> 00:12:58,629
where it should have pointed as if we

291
00:12:55,419 --> 00:13:02,799
had advanced it right and since we can

292
00:12:58,629 --> 00:13:04,629
only at most be holding one element

293
00:13:02,799 --> 00:13:07,359
right or no we'd have to be we'd keep

294
00:13:04,629 --> 00:13:09,730
adding elements so we just increment

295
00:13:07,360 --> 00:13:11,019
that whatever that counter was that said

296
00:13:09,730 --> 00:13:13,240
how many we could advance before

297
00:13:11,019 --> 00:13:16,709
ping-ponging back we just increment that

298
00:13:13,240 --> 00:13:16,709
for every swap we did

299
00:13:18,688 --> 00:13:24,549
does that work it's rather complicated

300
00:13:22,419 --> 00:13:26,049
which is why i say i don't know that

301
00:13:24,549 --> 00:13:27,308
you'd want to do this because it seems

302
00:13:26,049 --> 00:13:30,308
like you may just want to use extra

303
00:13:27,308 --> 00:13:32,528
space but it feels like it should work

304
00:13:30,308 --> 00:13:40,899
because i can't think of any particular

305
00:13:32,528 --> 00:13:43,708
reason why it wouldn't work right i mean

306
00:13:40,899 --> 00:13:46,600
it seems pretty pretty reasonable I

307
00:13:43,708 --> 00:13:49,178
don't know so there we go we got these

308
00:13:46,600 --> 00:13:51,850
two to have sir let's do it here is our

309
00:13:49,178 --> 00:13:55,708
interleave so we're going to go through

310
00:13:51,850 --> 00:13:58,449
here and we effectively have you know a

311
00:13:55,708 --> 00:14:00,969
right pointer right so we've got our

312
00:13:58,448 --> 00:14:03,399
tile sort entry you know this is our

313
00:14:00,970 --> 00:14:06,069
this is our out pointer and our out

314
00:14:03,399 --> 00:14:07,958
pointer obviously starts at first and

315
00:14:06,068 --> 00:14:10,360
when we get to the end we should

316
00:14:07,958 --> 00:14:13,388
probably assert that our out pointer

317
00:14:10,360 --> 00:14:15,369
equals first plus count because you know

318
00:14:13,389 --> 00:14:18,100
we've got to write all the entries in

319
00:14:15,369 --> 00:14:25,089
this thing you know what I'm saying so

320
00:14:18,100 --> 00:14:27,009
that's good furthermore i suppose what

321
00:14:25,089 --> 00:14:29,019
we should also do here you know what we

322
00:14:27,009 --> 00:14:32,169
should do before we do anything else

323
00:14:29,019 --> 00:14:35,019
actually let's let's go ahead and

324
00:14:32,169 --> 00:14:36,909
comment this out we should just put in a

325
00:14:35,019 --> 00:14:38,230
test because we're writing a relatively

326
00:14:36,909 --> 00:14:39,639
complicated sort the chances that we

327
00:14:38,230 --> 00:14:41,230
messed up the bubble sort fairly low

328
00:14:39,639 --> 00:14:43,419
chances that we messed up the MER sort

329
00:14:41,230 --> 00:14:46,028
could be relatively high let's go ahead

330
00:14:43,419 --> 00:14:48,068
and put in a validator right here right

331
00:14:46,028 --> 00:14:52,119
let's just say you know if we're in

332
00:14:48,068 --> 00:14:55,868
validation mode let's just go through

333
00:14:52,119 --> 00:14:58,720
here and actually make sure that all of

334
00:14:55,869 --> 00:15:00,579
the items are actually in order instead

335
00:14:58,720 --> 00:15:02,528
of just assuming that they are let's

336
00:15:00,578 --> 00:15:04,568
actually just test it right because that

337
00:15:02,528 --> 00:15:07,178
way when we run this thing will know

338
00:15:04,568 --> 00:15:12,188
whether we messed it up so here's our

339
00:15:07,178 --> 00:15:14,318
index like so here is our test and so

340
00:15:12,188 --> 00:15:19,988
we'll just say okay for each pair of

341
00:15:14,318 --> 00:15:22,208
items as we move through this list we

342
00:15:19,989 --> 00:15:24,249
want to ensure that the first one is

343
00:15:22,208 --> 00:15:27,909
always less than or equal to the second

344
00:15:24,249 --> 00:15:31,440
one so that's just our assertion and

345
00:15:27,909 --> 00:15:33,769
that would validate right so now if we

346
00:15:31,440 --> 00:15:36,630
and this we should be able to validate

347
00:15:33,769 --> 00:15:41,399
this this code and see if it's actually

348
00:15:36,629 --> 00:15:46,980
correct and we're already wrong what's

349
00:15:41,399 --> 00:15:48,990
the deal with that oh whoops sorry count

350
00:15:46,980 --> 00:15:52,710
minus one we can't very well read off

351
00:15:48,990 --> 00:15:54,570
the end of our array so there we go and

352
00:15:52,710 --> 00:15:57,240
at least now we can sort of verify that

353
00:15:54,570 --> 00:15:59,460
we're not getting any bugs in there and

354
00:15:57,240 --> 00:16:02,340
let's just make to make sure let's go

355
00:15:59,460 --> 00:16:04,080
ahead and turn off the sort entirely so

356
00:16:02,340 --> 00:16:07,889
that we can verify that it actually does

357
00:16:04,080 --> 00:16:10,230
catch unsorted if we were to pass it's

358
00:16:07,889 --> 00:16:12,569
something unsorted that we would would

359
00:16:10,230 --> 00:16:14,580
effectively trigger the assert we do so

360
00:16:12,570 --> 00:16:15,960
that's good and now we know we've got a

361
00:16:14,580 --> 00:16:18,420
little safety net in there that could

362
00:16:15,960 --> 00:16:20,790
tell us when we messed up okay so let's

363
00:16:18,419 --> 00:16:23,459
switch to merge sort now we'll turn the

364
00:16:20,789 --> 00:16:25,529
merge sort back on and for example if I

365
00:16:23,460 --> 00:16:28,259
didn't do this interleave right if I

366
00:16:25,529 --> 00:16:29,519
didn't do the interleave then we should

367
00:16:28,259 --> 00:16:31,649
get an immediate firing of that

368
00:16:29,519 --> 00:16:33,600
assertion because it won't sort the

369
00:16:31,649 --> 00:16:34,980
array right and there we go and that's

370
00:16:33,600 --> 00:16:36,690
it so now what we're trying to do is

371
00:16:34,980 --> 00:16:39,720
basically get ourselves out of this

372
00:16:36,690 --> 00:16:41,550
morass where we've accidentally made our

373
00:16:39,720 --> 00:16:43,500
sort break because we switch to a new

374
00:16:41,549 --> 00:16:45,719
algorithm that's not done yet so here we

375
00:16:43,500 --> 00:16:55,289
go we've got to actually interleave this

376
00:16:45,720 --> 00:16:56,490
guy okay so we do our merge sort here we

377
00:16:55,289 --> 00:16:59,969
know that these two halves are in order

378
00:16:56,490 --> 00:17:04,019
for each one of these we would say okay

379
00:16:59,970 --> 00:17:09,588
I guess we could just go through counts

380
00:17:04,019 --> 00:17:11,459
so here's our index here or out index

381
00:17:09,588 --> 00:17:14,429
that's going to go through the count

382
00:17:11,459 --> 00:17:16,828
we're going to do it so at each point I

383
00:17:14,430 --> 00:17:21,539
just need to know what I should do to

384
00:17:16,828 --> 00:17:23,669
that out pointer yeah so I need to say

385
00:17:21,539 --> 00:17:29,970
and in fact you could imagine let's just

386
00:17:23,670 --> 00:17:31,950
write this just for a in half 0 just for

387
00:17:29,970 --> 00:17:34,700
so we can kind of see let's write it as

388
00:17:31,950 --> 00:17:40,230
if we have the temporary memory first

389
00:17:34,700 --> 00:17:42,740
right so we've got this in fact i can

390
00:17:40,230 --> 00:17:42,740
write it like this

391
00:17:43,659 --> 00:17:48,020
so we can see the pointers to the two

392
00:17:46,009 --> 00:17:51,679
halves so there's the pointers to the

393
00:17:48,019 --> 00:17:54,589
two halves right so as we go through

394
00:17:51,679 --> 00:18:00,519
each out index here what we want to do

395
00:17:54,589 --> 00:18:03,168
is say okay let's go ahead and read in

396
00:18:00,519 --> 00:18:09,079
the two you know compare the two entries

397
00:18:03,169 --> 00:18:12,679
like so and we want to select whichever

398
00:18:09,079 --> 00:18:16,668
one we should be reading from so in if

399
00:18:12,679 --> 00:18:19,580
in half 0 if it's sort key is less than

400
00:18:16,669 --> 00:18:23,809
in half one sort key then I want to pick

401
00:18:19,579 --> 00:18:32,058
in half in half 0 right so I'd want to

402
00:18:23,808 --> 00:18:33,710
write in half 0 if on the other hand in

403
00:18:32,058 --> 00:18:35,898
half one should come first then I want

404
00:18:33,710 --> 00:18:38,179
to write in half one and in either case

405
00:18:35,898 --> 00:18:42,459
i want to advance the pointers now

406
00:18:38,179 --> 00:18:46,640
obviously we do have a problem here

407
00:18:42,460 --> 00:18:49,610
which is that we might consume all of in

408
00:18:46,640 --> 00:18:52,130
half 0 before we're finished in which

409
00:18:49,609 --> 00:18:54,500
case we would start reading into items

410
00:18:52,130 --> 00:18:56,720
that were actually in in half one or

411
00:18:54,500 --> 00:18:58,220
something or worse yet if we consumed

412
00:18:56,720 --> 00:18:59,569
all of in half one we'd start reading

413
00:18:58,220 --> 00:19:01,429
into items that were just passed the end

414
00:18:59,569 --> 00:19:03,710
of the array so neither of those two

415
00:19:01,429 --> 00:19:05,509
situations is good so we need to have

416
00:19:03,710 --> 00:19:07,130
some way of knowing that we've gotten to

417
00:19:05,509 --> 00:19:13,669
the end of one of these and no longer

418
00:19:07,130 --> 00:19:15,200
consider those for retirement right so

419
00:19:13,669 --> 00:19:17,509
what we could do here there's a number

420
00:19:15,200 --> 00:19:21,350
of ways we could do that we could say

421
00:19:17,509 --> 00:19:22,759
for example and you know I don't know if

422
00:19:21,349 --> 00:19:24,528
I actually want to do it this way I

423
00:19:22,759 --> 00:19:26,000
might want to do this just for fun just

424
00:19:24,528 --> 00:19:28,609
to make it a little more explicit and so

425
00:19:26,000 --> 00:19:33,250
we can debug it easier we could call

426
00:19:28,609 --> 00:19:33,250
these read half like this

427
00:19:36,900 --> 00:19:42,780
right and if we did that then we could

428
00:19:40,859 --> 00:19:46,109
also do something like you know just

429
00:19:42,779 --> 00:19:50,579
write out the cases explicitly if in

430
00:19:46,109 --> 00:19:53,459
half 0 or sorry if read half 0 equals in

431
00:19:50,579 --> 00:19:56,699
half one then we know we've gotten to

432
00:19:53,460 --> 00:19:58,680
the end right and so basically if we've

433
00:19:56,700 --> 00:20:01,620
gotten to the end of read half 0 we know

434
00:19:58,680 --> 00:20:04,830
we would always take this this one we

435
00:20:01,619 --> 00:20:06,839
always take from in half one right and

436
00:20:04,829 --> 00:20:11,159
furthermore we'd want to assert that

437
00:20:06,839 --> 00:20:15,230
read half one was not equal to end right

438
00:20:11,160 --> 00:20:18,150
and the end would just be read half 1

439
00:20:15,230 --> 00:20:21,650
plus half one that's like the end of the

440
00:20:18,150 --> 00:20:21,650
of the things we're reading from right

441
00:20:22,490 --> 00:20:28,890
okay and in fact I guess that's just we

442
00:20:25,619 --> 00:20:31,469
could even say first plus count here and

443
00:20:28,890 --> 00:20:37,530
then I could say assert that out equals

444
00:20:31,470 --> 00:20:45,720
and there we go so similarly if read

445
00:20:37,529 --> 00:20:49,920
half 1 equal in half right end then we

446
00:20:45,720 --> 00:20:51,329
would know well we don't know sir that

447
00:20:49,920 --> 00:20:52,740
cuz we rechecked it so then we would

448
00:20:51,329 --> 00:20:57,299
know that we have to take from read half

449
00:20:52,740 --> 00:20:59,480
0 right and then otherwise we could do

450
00:20:57,299 --> 00:20:59,480
this

451
00:21:03,440 --> 00:21:11,340
okay right now we can simplify this a

452
00:21:08,640 --> 00:21:12,809
little bit already if we want to but I'm

453
00:21:11,339 --> 00:21:14,308
not really going to because like I said

454
00:21:12,808 --> 00:21:18,079
we want to try to make this in place and

455
00:21:14,308 --> 00:21:20,129
this is not in place at the moment mmm

456
00:21:18,079 --> 00:21:23,490
or i could just spill water all over

457
00:21:20,130 --> 00:21:26,278
myself that's also great that's a good

458
00:21:23,490 --> 00:21:28,200
thing to do basically that's a really

459
00:21:26,278 --> 00:21:29,909
great way if you're doing if you're

460
00:21:28,200 --> 00:21:31,830
implementing sort if you're trying to

461
00:21:29,909 --> 00:21:33,000
sort things that's a really great ways

462
00:21:31,829 --> 00:21:34,259
to just spill water all over yourself

463
00:21:33,000 --> 00:21:36,240
first because if you spill water all

464
00:21:34,259 --> 00:21:38,460
over yourself then the sort it basically

465
00:21:36,240 --> 00:21:39,839
like makes the it makes it much more

466
00:21:38,460 --> 00:21:41,490
easy for the sorting to happen because

467
00:21:39,839 --> 00:21:44,788
you've got that like extra water to

468
00:21:41,490 --> 00:21:46,409
lubricate all right so here we go this

469
00:21:44,788 --> 00:21:51,058
is what we would do presumably if we

470
00:21:46,409 --> 00:21:53,460
wanted to to make it sort into a

471
00:21:51,058 --> 00:21:55,470
separate buffer this would presumably

472
00:21:53,460 --> 00:21:56,460
work again we'll just maybe run through

473
00:21:55,470 --> 00:21:59,308
it we're trying to make sure that the

474
00:21:56,460 --> 00:22:00,870
logic is proper but that's all we would

475
00:21:59,308 --> 00:22:04,079
really need to do right and we could

476
00:22:00,869 --> 00:22:05,849
simplify this down more than we have you

477
00:22:04,079 --> 00:22:09,240
know obviously we could make these ifs

478
00:22:05,849 --> 00:22:14,639
be a little bit more intelligent but you

479
00:22:09,240 --> 00:22:17,579
get the idea so given that we want to do

480
00:22:14,640 --> 00:22:20,970
it in place we now have this problem

481
00:22:17,579 --> 00:22:24,960
where if we were going to do anything

482
00:22:20,970 --> 00:22:26,819
where we read off of half 0 we wouldn't

483
00:22:24,960 --> 00:22:29,970
have to change anything that would work

484
00:22:26,819 --> 00:22:32,038
right in fact all that would happen here

485
00:22:29,970 --> 00:22:33,390
is we wouldn't actually do anything at

486
00:22:32,038 --> 00:22:38,339
all like we wouldn't actually have to

487
00:22:33,390 --> 00:22:40,350
have to do anything but the problem is

488
00:22:38,339 --> 00:22:43,500
when we read half one we're going to

489
00:22:40,349 --> 00:22:47,099
overwrite whatever was in there for read

490
00:22:43,500 --> 00:22:50,130
half 0 so I think what we would have to

491
00:22:47,099 --> 00:22:53,629
do is first insert some sort of an

492
00:22:50,130 --> 00:22:56,190
additional thing here which is like uh

493
00:22:53,630 --> 00:23:04,470
you know it's it's gonna be something

494
00:22:56,190 --> 00:23:08,940
like read half stack end or something

495
00:23:04,470 --> 00:23:11,788
like that right in read a stack and

496
00:23:08,940 --> 00:23:14,970
would have to tell us whether or not we

497
00:23:11,788 --> 00:23:16,859
had gotten to the end of the in-place

498
00:23:14,970 --> 00:23:19,190
version that we were doing

499
00:23:16,859 --> 00:23:23,729
right I'm just trying to think through

500
00:23:19,190 --> 00:23:26,519
what we would do in this case when when

501
00:23:23,730 --> 00:23:28,289
half three is confirmed basically you

502
00:23:26,519 --> 00:23:30,420
know imagine we just take the very

503
00:23:28,289 --> 00:23:35,039
simple scenario where I've got my two

504
00:23:30,420 --> 00:23:40,048
pieces imagine I've got this scenario

505
00:23:35,039 --> 00:23:43,048
and I keep pulling from this this guy so

506
00:23:40,048 --> 00:23:44,548
I gotta write this guy to hear I got to

507
00:23:43,048 --> 00:23:46,289
write this guy to hear I got to write

508
00:23:44,548 --> 00:23:48,720
this guy to hear that means that these

509
00:23:46,289 --> 00:23:53,099
guys all get swapped down into this

510
00:23:48,720 --> 00:23:55,798
these locations right so each one of

511
00:23:53,099 --> 00:23:58,319
those is sort of getting pushed on there

512
00:23:55,798 --> 00:24:00,269
there's King swap swap swap and so when

513
00:23:58,319 --> 00:24:03,599
I go to read I need to know that I'm

514
00:24:00,269 --> 00:24:05,819
actually reading from here not from here

515
00:24:03,599 --> 00:24:12,209
so let's do the simplest version of this

516
00:24:05,819 --> 00:24:17,990
first which is like you know half 0

517
00:24:12,210 --> 00:24:20,548
stack count equals 0 and half 0 stack

518
00:24:17,990 --> 00:24:22,980
well I guess the appt 0 stacks always in

519
00:24:20,548 --> 00:24:25,319
the same place right it's always here

520
00:24:22,980 --> 00:24:27,539
it's always at in half one so we really

521
00:24:25,319 --> 00:24:33,569
only need to know how many things we

522
00:24:27,539 --> 00:24:39,678
pushed on right okay so the first thing

523
00:24:33,569 --> 00:24:39,678
I guess we would do is say you know if

524
00:24:40,700 --> 00:24:45,870
you get this guy first I'm going to do

525
00:24:44,069 --> 00:24:48,089
all these cases and then we'll probably

526
00:24:45,869 --> 00:24:49,109
be able I think to simplify it down but

527
00:24:48,089 --> 00:24:51,509
i'm going to write all the cases

528
00:24:49,109 --> 00:24:55,979
explicitly first before we try to get

529
00:24:51,509 --> 00:24:59,879
clever so if the read half one is at its

530
00:24:55,980 --> 00:25:04,140
end meaning read app one cannot go any

531
00:24:59,880 --> 00:25:08,880
further then we would know that if the

532
00:25:04,140 --> 00:25:13,140
half 0 stack count right if that equals

533
00:25:08,880 --> 00:25:16,140
0 then we would just read out of where

534
00:25:13,140 --> 00:25:18,320
we actually are in read half does that

535
00:25:16,140 --> 00:25:18,320
make sense

536
00:25:22,138 --> 00:25:30,278
because that's like that means there's

537
00:25:26,319 --> 00:25:31,960
there's nothing left in half one so we

538
00:25:30,278 --> 00:25:34,690
just have to see if there's nothing in

539
00:25:31,960 --> 00:25:37,329
the stack we would read normally if

540
00:25:34,690 --> 00:25:44,700
there is something in the stack we would

541
00:25:37,329 --> 00:25:49,178
decrement the stack right and oh wait

542
00:25:44,700 --> 00:25:52,929
but we wouldn't have to do anything at

543
00:25:49,179 --> 00:25:55,538
that point right because if that was the

544
00:25:52,929 --> 00:25:58,778
case that means that the entire rest of

545
00:25:55,538 --> 00:26:02,470
the buffer just contains the items that

546
00:25:58,778 --> 00:26:05,138
we swapped into it which means they're

547
00:26:02,470 --> 00:26:07,720
all correct they're all the right ones

548
00:26:05,138 --> 00:26:09,819
in order right because as we swapped

549
00:26:07,720 --> 00:26:11,710
them out they were still in sorted order

550
00:26:09,819 --> 00:26:13,628
so if we fill this whole thing up and

551
00:26:11,710 --> 00:26:15,909
got to the end then all of these must be

552
00:26:13,628 --> 00:26:18,339
correct so actually we wouldn't have to

553
00:26:15,909 --> 00:26:19,960
do anything so if the half stack count

554
00:26:18,339 --> 00:26:22,569
is 0 then we do need to do something

555
00:26:19,960 --> 00:26:25,149
otherwise we can just end everything is

556
00:26:22,569 --> 00:26:27,308
in order and we're done right because

557
00:26:25,148 --> 00:26:31,528
the number of swaps can only be as many

558
00:26:27,308 --> 00:26:31,528
as there were in that buffer I think

559
00:26:43,058 --> 00:26:52,759
no I take it back so we have two things

560
00:26:48,859 --> 00:26:55,459
to worry about here we go this is going

561
00:26:52,759 --> 00:26:57,140
to be tricky I like this this is good

562
00:26:55,460 --> 00:26:59,269
for friday because I feel like I'm

563
00:26:57,140 --> 00:27:01,490
Friday's people tend to get get it lazy

564
00:26:59,269 --> 00:27:05,829
but we've got 30 minutes left we can do

565
00:27:01,490 --> 00:27:09,289
this so the problem is if i come here

566
00:27:05,829 --> 00:27:11,210
and here as I swap these things out

567
00:27:09,289 --> 00:27:13,670
let's say that this buffer was much

568
00:27:11,210 --> 00:27:15,200
shorter so there's just like two things

569
00:27:13,670 --> 00:27:17,289
in here there's a and B in here or

570
00:27:15,200 --> 00:27:20,870
whatever right hey this is what was here

571
00:27:17,289 --> 00:27:23,000
and here is like one two three four I'll

572
00:27:20,869 --> 00:27:25,639
number of these and letter these you can

573
00:27:23,000 --> 00:27:27,890
see so let's say a and B have to come

574
00:27:25,640 --> 00:27:30,950
first so the first things we do is one

575
00:27:27,890 --> 00:27:34,040
comes into here right and a goes here

576
00:27:30,950 --> 00:27:35,929
too comes into here and B goes here

577
00:27:34,039 --> 00:27:38,740
right now we're at the case I was

578
00:27:35,929 --> 00:27:44,090
talking about and the problem is this

579
00:27:38,740 --> 00:27:45,740
right is now supposed to come after like

580
00:27:44,089 --> 00:27:48,980
this is supposed to come down here and

581
00:27:45,740 --> 00:27:52,039
this is supposed to come up in there so

582
00:27:48,980 --> 00:27:54,769
it's as if we now have another version

583
00:27:52,039 --> 00:27:56,990
of this of this interleave which almost

584
00:27:54,769 --> 00:27:59,750
kind of makes me wonder if you could

585
00:27:56,990 --> 00:28:01,849
sort of phrase this as just as always

586
00:27:59,750 --> 00:28:03,558
being between two buffers and we just

587
00:28:01,849 --> 00:28:06,069
changed which two buffers we were

588
00:28:03,558 --> 00:28:06,069
talking about

589
00:28:10,000 --> 00:28:17,740
I almost feel like we can I almost feel

590
00:28:14,380 --> 00:28:19,930
like we can let's let's do this I'm

591
00:28:17,740 --> 00:28:22,269
gonna I'm gonna I'm gonna go I'm gonna

592
00:28:19,930 --> 00:28:29,279
go crazy here I'm just going to go nuts

593
00:28:22,269 --> 00:28:33,400
here so yeah imagine imagine if you will

594
00:28:29,279 --> 00:28:37,029
but what do we have so we've got this

595
00:28:33,400 --> 00:28:40,240
guy originally so when we start out

596
00:28:37,029 --> 00:28:42,039
right we would say here's the to sort

597
00:28:40,240 --> 00:28:43,990
keys we're going to read from one of

598
00:28:42,039 --> 00:28:52,210
these but what we basically said is this

599
00:28:43,990 --> 00:28:57,940
guy this is now a swap right this is now

600
00:28:52,210 --> 00:29:04,900
a swap so instead a read half 0 you'd

601
00:28:57,940 --> 00:29:11,860
have 0 oops you know what I'm going to

602
00:29:04,900 --> 00:29:17,280
make this a little easier on myself feel

603
00:29:11,859 --> 00:29:17,279
like I just want to be able to swap

604
00:29:20,670 --> 00:29:29,769
seems like a good thing I want to do

605
00:29:22,599 --> 00:29:34,740
right so let's do this here's my be be a

606
00:29:29,769 --> 00:29:34,740
a there we go

607
00:29:38,349 --> 00:29:47,659
alright so now we can just do swap entry

608
00:29:43,430 --> 00:29:50,180
a entry be makes it easier to read and

609
00:29:47,660 --> 00:29:55,300
makes it less error-prone and here i

610
00:29:50,180 --> 00:30:07,990
would say swap read half 0 read half one

611
00:29:55,299 --> 00:30:15,139
and i could also put that in here okay

612
00:30:07,990 --> 00:30:18,049
so what I was about to say was here we

613
00:30:15,140 --> 00:30:20,000
go I got this DS to store keys if I

614
00:30:18,049 --> 00:30:21,919
going to retire the one that's in the

615
00:30:20,000 --> 00:30:23,720
thing that I want it's already in the

616
00:30:21,920 --> 00:30:26,180
correct place then I don't need to do

617
00:30:23,720 --> 00:30:28,039
anything right all I would do is skip

618
00:30:26,180 --> 00:30:33,860
over the location that I'm actually

619
00:30:28,039 --> 00:30:37,460
trying to write to right and and in that

620
00:30:33,859 --> 00:30:40,339
case i'm also going to update read half

621
00:30:37,460 --> 00:30:42,500
0 so in some sense read half 0 just is

622
00:30:40,339 --> 00:30:47,480
the out pointer i don't really need to

623
00:30:42,500 --> 00:30:49,400
do anything while I'm advancing right so

624
00:30:47,480 --> 00:30:54,440
that just like gets me pass any of the

625
00:30:49,400 --> 00:30:55,580
entries that don't that that I'm just

626
00:30:54,440 --> 00:30:57,799
getting past any entries that are

627
00:30:55,579 --> 00:31:01,309
already in the right position that's all

628
00:30:57,799 --> 00:31:02,809
I'm doing so as I do that I advance

629
00:31:01,309 --> 00:31:04,579
forward in fact I don't really need that

630
00:31:02,809 --> 00:31:06,079
right I just kind of advanced this guy

631
00:31:04,579 --> 00:31:11,359
forwards till he gets to the right

632
00:31:06,079 --> 00:31:14,329
position otherwise I gotta swap right so

633
00:31:11,359 --> 00:31:17,990
if I have to swap then I'm going to swap

634
00:31:14,329 --> 00:31:20,629
read half 0 and read half 1 and what I

635
00:31:17,990 --> 00:31:24,589
want to do here is I want to actually

636
00:31:20,630 --> 00:31:28,160
just keep going with as for as many

637
00:31:24,589 --> 00:31:31,569
swaps as I might need right so i swapped

638
00:31:28,160 --> 00:31:31,570
the two that are there

639
00:31:35,038 --> 00:31:40,028
and I just want to do as many swaps as I

640
00:31:38,470 --> 00:31:44,140
might need so basically this algorithm

641
00:31:40,028 --> 00:31:47,288
has you know two phases so far right I I

642
00:31:44,140 --> 00:31:50,409
basically say I find the place first

643
00:31:47,288 --> 00:31:53,079
that's the like actual start of where we

644
00:31:50,409 --> 00:31:55,179
need to sort because as long as these

645
00:31:53,079 --> 00:31:57,158
are before this guy I don't have to do

646
00:31:55,179 --> 00:32:01,298
anything right and in fact maybe I'll

647
00:31:57,159 --> 00:32:05,019
just label these steps you know so here

648
00:32:01,298 --> 00:32:11,319
we go get rid of this here's step one

649
00:32:05,019 --> 00:32:15,519
step one find the first out of order

650
00:32:11,319 --> 00:32:21,548
pair right and so all we do there is we

651
00:32:15,519 --> 00:32:25,058
just read through a read half 0 so I

652
00:32:21,548 --> 00:32:29,589
basically say you know while read half 0

653
00:32:25,058 --> 00:32:36,658
is not equal to read half one right well

654
00:32:29,589 --> 00:32:36,658
it's well there and they're sort keys

655
00:32:38,069 --> 00:32:44,319
the sort key is less than the sort key

656
00:32:41,169 --> 00:32:46,360
there I can advance so that's just a

657
00:32:44,319 --> 00:32:50,230
simple while loop that goes find which

658
00:32:46,359 --> 00:32:52,839
one is out of order right because you

659
00:32:50,230 --> 00:32:54,069
know at the front of the array there

660
00:32:52,839 --> 00:32:57,609
might just be a bunch that are just in

661
00:32:54,069 --> 00:32:59,200
order we skip those okay so after we've

662
00:32:57,609 --> 00:33:02,048
skipped all those we know we've come

663
00:32:59,200 --> 00:33:04,690
either to the end so at this point if

664
00:33:02,048 --> 00:33:06,579
read have 0 equals read half 1 we're

665
00:33:04,690 --> 00:33:09,960
done because it means that the two abs

666
00:33:06,579 --> 00:33:13,750
were completely in order right already

667
00:33:09,960 --> 00:33:16,179
but if they're not equal to each other

668
00:33:13,750 --> 00:33:19,359
then we know we would have to do some

669
00:33:16,179 --> 00:33:21,460
number of swaps right to put them into

670
00:33:19,359 --> 00:33:29,129
the correct positions i get rid of all

671
00:33:21,460 --> 00:33:31,960
this nonsense goodbye thank you okay

672
00:33:29,130 --> 00:33:35,110
right so that's that's a pretty basic

673
00:33:31,960 --> 00:33:38,139
right and we could we know as well that

674
00:33:35,109 --> 00:33:40,119
half one I believe we could say right

675
00:33:38,138 --> 00:33:42,069
that since we know that the count was at

676
00:33:40,119 --> 00:33:43,808
least three we know that each of these

677
00:33:42,069 --> 00:33:45,849
is greater than one so there's no

678
00:33:43,808 --> 00:33:48,339
condition we need to handle there where

679
00:33:45,849 --> 00:33:52,449
there isn't a read half one read half 10

680
00:33:48,339 --> 00:33:54,639
always exists right so we just kind of

681
00:33:52,450 --> 00:33:57,850
read move retasked 0 till it gets to the

682
00:33:54,640 --> 00:34:04,500
end and then if it's not right so then

683
00:33:57,849 --> 00:34:10,659
we say step to swap as many half ones as

684
00:34:04,500 --> 00:34:11,889
occur at the beginning although I

685
00:34:10,659 --> 00:34:13,300
shouldn't actually say that let's not

686
00:34:11,889 --> 00:34:15,820
say that yet because I gotta go works

687
00:34:13,300 --> 00:34:18,789
out in the whiteboard alright so now

688
00:34:15,820 --> 00:34:21,338
what we know is we're at a position

689
00:34:18,789 --> 00:34:23,199
we've we've taken care of anything that

690
00:34:21,338 --> 00:34:26,289
was at the beginning so now we're at a

691
00:34:23,199 --> 00:34:28,178
position where the item that's here has

692
00:34:26,289 --> 00:34:31,570
to move here and they're going to swap

693
00:34:28,179 --> 00:34:34,179
out right and some number of these will

694
00:34:31,570 --> 00:34:36,970
do that so some number will move in here

695
00:34:34,179 --> 00:34:39,849
and and now we will be left with right

696
00:34:36,969 --> 00:34:42,039
all of this is correct so we know that

697
00:34:39,849 --> 00:34:45,580
all of the swapped values are correct we

698
00:34:42,039 --> 00:34:46,750
have some number that might remain right

699
00:34:45,579 --> 00:34:52,799
we don't know how many but we have some

700
00:34:46,750 --> 00:34:52,800
number that might remain and we have

701
00:34:57,239 --> 00:35:07,000
excuse me we now have a part of the

702
00:35:01,239 --> 00:35:08,289
buffer here that's actually that that we

703
00:35:07,000 --> 00:35:12,579
have basically two buffers we have this

704
00:35:08,289 --> 00:35:14,529
buffer and this buffer that now i should

705
00:35:12,579 --> 00:35:17,469
say three buffers we've got this buffer

706
00:35:14,530 --> 00:35:21,250
this buffer and this buffer and we do

707
00:35:17,469 --> 00:35:24,309
know right how these things relate to

708
00:35:21,250 --> 00:35:29,139
each other right this buffer comes

709
00:35:24,309 --> 00:35:32,799
before this one and this buffer is is

710
00:35:29,139 --> 00:35:35,409
just the remainder of half one so my

711
00:35:32,800 --> 00:35:37,060
feeling is we maybe we need we might

712
00:35:35,409 --> 00:35:39,279
need a stack we'll have to see in a

713
00:35:37,059 --> 00:35:42,489
second here but my feeling is once we're

714
00:35:39,280 --> 00:35:44,200
at that point we should be able to then

715
00:35:42,489 --> 00:35:47,169
just adjust which buffers we're pulling

716
00:35:44,199 --> 00:35:50,679
from and repeat the same process right

717
00:35:47,170 --> 00:35:52,269
we should just be able I mean seems like

718
00:35:50,679 --> 00:35:56,019
that would make perfect sense because at

719
00:35:52,269 --> 00:35:58,650
this point when we get to step two we

720
00:35:56,019 --> 00:36:02,070
have three potential buffers we have

721
00:35:58,650 --> 00:36:06,059
well I guess sorry it's tough to swap as

722
00:36:02,070 --> 00:36:09,120
many items as necessary so here we just

723
00:36:06,059 --> 00:36:19,380
go okay while read half 1 is not equal

724
00:36:09,119 --> 00:36:23,880
to end and read half 0 tubing read half

725
00:36:19,380 --> 00:36:26,460
0 is still a valid entry write and read

726
00:36:23,880 --> 00:36:30,570
half one is actually the guy who should

727
00:36:26,460 --> 00:36:33,800
be in this position so i want to say the

728
00:36:30,570 --> 00:36:38,640
guy who moves right should we swap in

729
00:36:33,800 --> 00:36:40,350
like so so if i want to do that sort if

730
00:36:38,639 --> 00:36:44,449
i want to do this this thing I've got to

731
00:36:40,349 --> 00:36:47,279
swap now read half 0 and read half one

732
00:36:44,449 --> 00:36:49,259
right so that puts them in into the

733
00:36:47,280 --> 00:36:56,760
correct position and both of these

734
00:36:49,260 --> 00:37:00,450
pointers advance right is that actually

735
00:36:56,760 --> 00:37:05,100
true no that's not true when I do the

736
00:37:00,449 --> 00:37:10,589
swap I as I'm doing those swaps I need

737
00:37:05,099 --> 00:37:13,409
to now make read half 0 I need to make

738
00:37:10,590 --> 00:37:19,130
read half 0 be what read half one

739
00:37:13,409 --> 00:37:21,929
previously was right so read half 0 is I

740
00:37:19,130 --> 00:37:24,869
need like a second pointer for writing

741
00:37:21,929 --> 00:37:27,269
so that I can keep a you know track of

742
00:37:24,869 --> 00:37:30,349
who i am who i am comparing against

743
00:37:27,269 --> 00:37:34,440
right so i basically say like here's my

744
00:37:30,349 --> 00:37:38,250
comparator or whatever compared with say

745
00:37:34,440 --> 00:37:41,960
i'm comparing with this guy so here's my

746
00:37:38,250 --> 00:37:46,829
compared with as i move read half one up

747
00:37:41,960 --> 00:37:52,590
if i need to do that swap the compared

748
00:37:46,829 --> 00:37:56,880
with needs to move right trying to think

749
00:37:52,590 --> 00:37:58,380
if this actually needs to happen I guess

750
00:37:56,880 --> 00:38:00,539
the first one we actually know

751
00:37:58,380 --> 00:38:02,880
automatically happens so actually this

752
00:38:00,539 --> 00:38:05,670
happens immediately now I think about it

753
00:38:02,880 --> 00:38:08,940
right we know that this would have kept

754
00:38:05,670 --> 00:38:10,829
going if necessary right so we would

755
00:38:08,940 --> 00:38:13,340
swap these two guys although i should

756
00:38:10,829 --> 00:38:13,340
say

757
00:38:14,030 --> 00:38:20,990
what about equals do we care about being

758
00:38:17,780 --> 00:38:23,240
stable I don't think we do but we'll

759
00:38:20,989 --> 00:38:27,349
just say all right so we swap these two

760
00:38:23,239 --> 00:38:30,049
guys so they're now in separate

761
00:38:27,349 --> 00:38:31,789
positions and I now need to say like the

762
00:38:30,050 --> 00:38:35,060
person that we're actually comparing

763
00:38:31,789 --> 00:38:37,400
with is in is actually in the read half

764
00:38:35,059 --> 00:38:40,549
one slot right that's where that guy

765
00:38:37,400 --> 00:38:42,079
actually exists at the moment so we're

766
00:38:40,550 --> 00:38:47,990
going to keep comparing with that guy

767
00:38:42,079 --> 00:38:50,659
while we read out what's there right so

768
00:38:47,989 --> 00:38:53,750
then we advance both pointers read have

769
00:38:50,659 --> 00:38:58,399
zero and read half one they're both past

770
00:38:53,750 --> 00:39:01,460
where they were and while we can still

771
00:38:58,400 --> 00:39:05,800
do that right well read half one is is

772
00:39:01,460 --> 00:39:08,800
not equal to the end we should be able

773
00:39:05,800 --> 00:39:08,800
to

774
00:39:17,050 --> 00:39:24,760
you know kind of think of why I just did

775
00:39:19,300 --> 00:39:26,560
that I can just do this right this is

776
00:39:24,760 --> 00:39:28,300
this is going to be strictly better I

777
00:39:26,559 --> 00:39:30,309
think than what is about to say so

778
00:39:28,300 --> 00:39:32,050
instead I guess what I would say is just

779
00:39:30,309 --> 00:39:34,769
store the person we're comparing with

780
00:39:32,050 --> 00:39:37,150
and now we don't even have to swap right

781
00:39:34,769 --> 00:39:39,940
we've got the person we're comparing

782
00:39:37,150 --> 00:39:46,420
with and so we just keep going so we

783
00:39:39,940 --> 00:39:49,690
just say like all right while read half

784
00:39:46,420 --> 00:40:06,010
is not equal to the end then we would

785
00:39:49,690 --> 00:40:12,000
come in here and say we have zero plus

786
00:40:06,010 --> 00:40:12,000
plus equals read half 1 plus plus

787
00:40:15,199 --> 00:40:17,889
right

788
00:40:25,748 --> 00:40:33,558
so that I think does the thing that I

789
00:40:30,440 --> 00:40:36,048
was trying to do before this is kind of

790
00:40:33,559 --> 00:40:37,339
fun I have never written numbered sort

791
00:40:36,048 --> 00:40:39,650
in place before in case you're wondering

792
00:40:37,338 --> 00:40:41,630
so I have absolutely no idea how to do

793
00:40:39,650 --> 00:40:44,809
it I'm just figuring it out as I go and

794
00:40:41,630 --> 00:40:49,700
that sort of thing is quite fun all

795
00:40:44,809 --> 00:40:51,979
right so here's what we know we've

796
00:40:49,699 --> 00:40:54,858
gotten to this point where we anything

797
00:40:51,978 --> 00:40:56,478
that was in order we finished right we

798
00:40:54,858 --> 00:40:59,778
then say well now we know that we've got

799
00:40:56,478 --> 00:41:03,199
an element that's out of order and these

800
00:40:59,778 --> 00:41:06,588
guys have to come into place so what we

801
00:41:03,199 --> 00:41:10,098
then do is we say okay we store the sky

802
00:41:06,588 --> 00:41:14,358
out to a temporary location and then we

803
00:41:10,099 --> 00:41:16,999
start swapping people right so we we

804
00:41:14,358 --> 00:41:19,489
swap these two right so we put this guy

805
00:41:16,998 --> 00:41:21,588
here and that guy there we swap these

806
00:41:19,489 --> 00:41:26,599
two so we put this guy and put this guy

807
00:41:21,588 --> 00:41:31,099
there and then at some point we get to

808
00:41:26,599 --> 00:41:33,410
either the end meaning we have no more

809
00:41:31,099 --> 00:41:35,989
of these guys to do or we get to a point

810
00:41:33,409 --> 00:41:37,248
where they compared unfavorably so we'd

811
00:41:35,989 --> 00:41:40,429
have to stop let's say there was a guy

812
00:41:37,248 --> 00:41:42,379
here who would cause us to stop right so

813
00:41:40,429 --> 00:41:46,278
we know these two are in order but we

814
00:41:42,380 --> 00:41:48,440
know we hit a guy who actually I'm sorry

815
00:41:46,278 --> 00:41:50,568
we know we hit like say this guy who is

816
00:41:48,440 --> 00:41:53,690
actually not less than the first item

817
00:41:50,568 --> 00:41:55,639
right so we know that this guy it needs

818
00:41:53,690 --> 00:42:00,679
we need to wait and we need to put these

819
00:41:55,639 --> 00:42:04,159
guys in first right so now what we would

820
00:42:00,679 --> 00:42:06,889
need to do is we would need to look at

821
00:42:04,159 --> 00:42:10,808
this as having a certain number of extra

822
00:42:06,889 --> 00:42:10,808
buffers here right we have

823
00:42:16,400 --> 00:42:25,710
some number of remainder on half 0 right

824
00:42:21,090 --> 00:42:29,039
so this is like the half 0 bit we have

825
00:42:25,710 --> 00:42:32,010
some number of swapped so here's the

826
00:42:29,039 --> 00:42:34,199
like we've got the first part right this

827
00:42:32,010 --> 00:42:41,190
is like the second part of half 0 we've

828
00:42:34,199 --> 00:42:44,969
got the first part of half 0 right and

829
00:42:41,190 --> 00:42:50,880
then we also have the remainder the

830
00:42:44,969 --> 00:42:56,339
second part of half 1 all of these are

831
00:42:50,880 --> 00:43:00,358
in order right so I believe now we just

832
00:42:56,340 --> 00:43:04,550
have to figure out a way to take the

833
00:43:00,358 --> 00:43:10,619
second half 0 part and we have to like

834
00:43:04,550 --> 00:43:13,320
overwrite these values we have to

835
00:43:10,619 --> 00:43:15,900
overwrite these values with this and

836
00:43:13,320 --> 00:43:18,570
this right we have to put them in here

837
00:43:15,900 --> 00:43:26,930
and pushing out the remainder again

838
00:43:18,570 --> 00:43:29,039
right sounds a little mind bendy right

839
00:43:26,929 --> 00:43:31,409
again mind you we don't actually know

840
00:43:29,039 --> 00:43:32,608
that merge sort in place is possible so

841
00:43:31,409 --> 00:43:35,489
there's also the possibility that we

842
00:43:32,608 --> 00:43:36,630
simply can't do it but rather I said

843
00:43:35,489 --> 00:43:39,059
then looking it up I feel like we should

844
00:43:36,630 --> 00:43:40,619
at least give it a shot first so I'm

845
00:43:39,059 --> 00:43:42,029
still going to spend probably another 15

846
00:43:40,619 --> 00:43:44,730
minutes looking at this before we cheat

847
00:43:42,030 --> 00:43:46,230
and see whether you can do it or maybe I

848
00:43:44,730 --> 00:43:48,570
won't even do that maybe I'll wait and

849
00:43:46,230 --> 00:43:54,059
see do the whole time and then we'll see

850
00:43:48,570 --> 00:43:55,619
on monday who knows so we can get rid of

851
00:43:54,059 --> 00:43:57,449
that part we can swap as many as

852
00:43:55,619 --> 00:43:59,190
necessary and then we're and we end up

853
00:43:57,449 --> 00:44:01,669
with essentially three buffers as I

854
00:43:59,190 --> 00:44:08,099
guess what I'm saying right we've got a

855
00:44:01,670 --> 00:44:12,800
weave why's that what's what's going on

856
00:44:08,099 --> 00:44:12,800
there we go kind of in dead wrong

857
00:44:14,199 --> 00:44:24,259
so here we've got step 3 3 buffers so

858
00:44:21,349 --> 00:44:26,029
this is the tricky part so we now it's

859
00:44:24,260 --> 00:44:28,100
essentially at this point after this

860
00:44:26,030 --> 00:44:31,190
first step we now know that we have

861
00:44:28,099 --> 00:44:32,989
essentially just a sorted piece that we

862
00:44:31,190 --> 00:44:34,909
don't even care about anymore right it's

863
00:44:32,989 --> 00:44:36,829
the first part of it so really now at

864
00:44:34,909 --> 00:44:39,920
this point we're just sorting read half

865
00:44:36,829 --> 00:44:41,929
0 read half one we're sorting we're

866
00:44:39,920 --> 00:44:43,280
sorting kind of the remaining part so

867
00:44:41,929 --> 00:44:46,039
this just skips the part we don't need

868
00:44:43,280 --> 00:44:49,130
to care about then we do as many swaps

869
00:44:46,039 --> 00:44:51,289
as we can and so now we've got a fully

870
00:44:49,130 --> 00:44:53,480
and order part that that comes up to

871
00:44:51,289 --> 00:45:00,670
where we'd have 0 actually is at this

872
00:44:53,480 --> 00:45:03,500
point and so at that at that point we

873
00:45:00,670 --> 00:45:05,930
would also know that the original read

874
00:45:03,500 --> 00:45:09,739
half pointer so this part right here so

875
00:45:05,929 --> 00:45:14,859
in half one we essentially have in half

876
00:45:09,739 --> 00:45:20,839
one is the swapped part of half 0 right

877
00:45:14,860 --> 00:45:24,250
we have lead have 0 the unswept part of

878
00:45:20,840 --> 00:45:30,410
half 0 and destination for next item

879
00:45:24,250 --> 00:45:37,579
right and then we have read half 1 which

880
00:45:30,409 --> 00:45:43,049
is the remainder or I should say I'm

881
00:45:37,579 --> 00:45:46,440
swap part of half 1 right

882
00:45:43,050 --> 00:45:51,579
and we know that this part and this part

883
00:45:46,440 --> 00:45:55,990
have to be you know processed and it has

884
00:45:51,579 --> 00:45:57,670
to swap into here which is that's the

885
00:45:55,989 --> 00:45:59,979
tricky part which is the part that makes

886
00:45:57,670 --> 00:46:03,809
me worried that maybe we can't do this

887
00:45:59,980 --> 00:46:07,599
but I'm not sure so we'll find out so

888
00:46:03,809 --> 00:46:10,449
how would we do that so if we were to do

889
00:46:07,599 --> 00:46:13,300
that right I mean one way to do it is

890
00:46:10,449 --> 00:46:22,389
you can look at it just directly where

891
00:46:13,300 --> 00:46:31,450
we would say okay um in half one in half

892
00:46:22,389 --> 00:46:34,420
one I if it's going to have to swap

893
00:46:31,449 --> 00:46:36,460
basically with with its self right it's

894
00:46:34,420 --> 00:46:40,389
going to have to if it's not the correct

895
00:46:36,460 --> 00:46:45,519
thing it's going to have to be swapped

896
00:46:40,389 --> 00:46:50,049
in with itself yeah I'm in the other

897
00:46:45,519 --> 00:46:51,670
part of half 0 because if in half one

898
00:46:50,050 --> 00:46:56,460
was coming next it would have to go

899
00:46:51,670 --> 00:46:59,409
there right and actually I guess we know

900
00:46:56,460 --> 00:47:02,050
we know that it will write because we

901
00:46:59,409 --> 00:47:04,210
got to the part what we know is we would

902
00:47:02,050 --> 00:47:07,060
have kept going here this would have

903
00:47:04,210 --> 00:47:11,108
kept going if it wasn't the case that we

904
00:47:07,059 --> 00:47:13,420
now needed to swap in that part right so

905
00:47:11,108 --> 00:47:15,789
we now know that actually what we need

906
00:47:13,420 --> 00:47:18,608
to do is we need to put back in this

907
00:47:15,789 --> 00:47:22,690
part right this part has to come back in

908
00:47:18,608 --> 00:47:26,348
so this would be going as far as we

909
00:47:22,690 --> 00:47:29,079
would have to go swapping half 0 in for

910
00:47:26,349 --> 00:47:30,910
where read half 0 actually was so that

911
00:47:29,079 --> 00:47:35,579
basically pushes that back out again

912
00:47:30,909 --> 00:47:41,639
right um yeah I mean I think that just

913
00:47:35,579 --> 00:47:47,079
works so let's see so let's just say

914
00:47:41,639 --> 00:47:52,449
this is swap as many half 0 half 1 items

915
00:47:47,079 --> 00:47:54,970
in as necessary and you know what else I

916
00:47:52,449 --> 00:47:58,179
might want to do I feel like it would be

917
00:47:54,969 --> 00:48:03,139
kind of good to hear

918
00:47:58,179 --> 00:48:04,969
we can construct a false case like we

919
00:48:03,139 --> 00:48:06,469
can construct a test case here so

920
00:48:04,969 --> 00:48:08,179
instead of using the actual push buffer

921
00:48:06,469 --> 00:48:09,619
things we can call this with a thing

922
00:48:08,179 --> 00:48:11,629
where we've set it up so we can see them

923
00:48:09,619 --> 00:48:13,400
they're just like 1 2 3 4 5 6 7 8 right

924
00:48:11,630 --> 00:48:16,039
so we can when we can watch it in the

925
00:48:13,400 --> 00:48:18,410
debugger and see really clearly how our

926
00:48:16,039 --> 00:48:20,960
sort is behaving or you know we can step

927
00:48:18,409 --> 00:48:26,119
through it all right so swabs me half

928
00:48:20,960 --> 00:48:33,170
items is necessary step 3 now what we

929
00:48:26,119 --> 00:48:37,489
want to do is a swap in as many swapped

930
00:48:33,170 --> 00:48:40,909
half 04 swap back as many swapped have 0

931
00:48:37,489 --> 00:48:43,579
items as necessary right so we're going

932
00:48:40,909 --> 00:48:44,690
to push those guys on there and it feels

933
00:48:43,579 --> 00:48:45,949
like that's going to be recursive

934
00:48:44,690 --> 00:48:47,150
because then we're going to happy aware

935
00:48:45,949 --> 00:48:51,619
I think we're going to have to move this

936
00:48:47,150 --> 00:48:52,970
into a function because then we're going

937
00:48:51,619 --> 00:48:54,559
to have to go like as soon as we stop

938
00:48:52,969 --> 00:48:57,019
that you know we're gonna have to

939
00:48:54,559 --> 00:48:59,809
remember how far down we went but let's

940
00:48:57,019 --> 00:49:09,289
just keep writing it and see so okay so

941
00:48:59,809 --> 00:49:14,029
assuming this actually goes here

942
00:49:09,289 --> 00:49:19,190
otherwise we were done there we go so we

943
00:49:14,030 --> 00:49:24,400
go all right while read half or I guess

944
00:49:19,190 --> 00:49:24,400
we can even say if read half

945
00:49:36,739 --> 00:49:42,509
this is in half saree okay so it's

946
00:49:39,809 --> 00:49:44,910
actually if in half one that's where are

947
00:49:42,510 --> 00:49:50,910
things are so now we want to say okay if

948
00:49:44,909 --> 00:49:56,909
in half one or rather a while in half 1

949
00:49:50,909 --> 00:50:01,739
is not equal to read half 1 so that's

950
00:49:56,909 --> 00:50:04,588
that's the that's the bounds right of

951
00:50:01,739 --> 00:50:07,889
the problem we're going between those

952
00:50:04,588 --> 00:50:09,659
two and in fact maybe we want to say

953
00:50:07,889 --> 00:50:15,690
what that was so we'll say tell sword

954
00:50:09,659 --> 00:50:19,588
entry and a swap and this is the part

955
00:50:15,690 --> 00:50:22,380
that we ended at is right there so we

956
00:50:19,588 --> 00:50:26,039
came through and we have read half one

957
00:50:22,380 --> 00:50:29,809
that marks the end of the parts that we

958
00:50:26,039 --> 00:50:33,210
swapped out from read half 0 right and

959
00:50:29,809 --> 00:50:36,480
so what we want to do is say okay let's

960
00:50:33,210 --> 00:50:41,010
go ahead and read from there I guess so

961
00:50:36,480 --> 00:50:43,949
let's do this swap read equals in half

962
00:50:41,010 --> 00:50:47,809
one that's where that was so while the

963
00:50:43,949 --> 00:50:51,949
swap read is not equal to the swap and

964
00:50:47,809 --> 00:50:56,460
we need to basically swap these guys

965
00:50:51,949 --> 00:51:01,169
back in right so as long as these that

966
00:50:56,460 --> 00:51:05,190
are compared with guy is now going to be

967
00:51:01,170 --> 00:51:10,710
read half one and again we only need to

968
00:51:05,190 --> 00:51:13,650
do this I assume we only need to do that

969
00:51:10,710 --> 00:51:17,900
compass this particular step if read

970
00:51:13,650 --> 00:51:17,900
half one this this part probably remains

971
00:51:19,429 --> 00:51:26,279
if read half 1 is not equal to the end

972
00:51:23,309 --> 00:51:28,200
right because the free half 1 equals the

973
00:51:26,280 --> 00:51:34,650
end then the only thing that we would

974
00:51:28,199 --> 00:51:39,419
need to do is is is reverse our swaps so

975
00:51:34,650 --> 00:51:41,730
like if there's no more of that guy

976
00:51:39,420 --> 00:51:44,280
right so we've got this and I got this

977
00:51:41,730 --> 00:51:47,670
we basically went through here and we

978
00:51:44,280 --> 00:51:49,730
took this whole thing right and we stuck

979
00:51:47,670 --> 00:51:53,400
it somewhere in here

980
00:51:49,730 --> 00:51:55,949
so this doesn't exist anymore right but

981
00:51:53,400 --> 00:51:59,460
in its place in this whole thing's place

982
00:51:55,949 --> 00:52:01,608
is whatever was up here right so now

983
00:51:59,460 --> 00:52:05,010
what we need to do is we need to put

984
00:52:01,608 --> 00:52:10,409
right that back here and this needs to

985
00:52:05,010 --> 00:52:13,349
go down here right so you know it's

986
00:52:10,409 --> 00:52:14,759
essentially like a nasty move operation

987
00:52:13,349 --> 00:52:16,140
where I've got to take this piece and

988
00:52:14,760 --> 00:52:18,420
I've got to put it here while putting

989
00:52:16,139 --> 00:52:20,339
this piece there and it's got a bubble

990
00:52:18,420 --> 00:52:29,550
down to the bottom this is going to be

991
00:52:20,340 --> 00:52:32,640
awful man yeah in play smart but you

992
00:52:29,550 --> 00:52:34,970
never know like some usually or

993
00:52:32,639 --> 00:52:38,089
sometimes occasionally maybe not

994
00:52:34,969 --> 00:52:41,730
assuming that it is again possible to do

995
00:52:38,090 --> 00:52:43,349
it starts out really nasty and Harry but

996
00:52:41,730 --> 00:52:46,050
as you actually see what it ends up

997
00:52:43,349 --> 00:52:48,390
being oftentimes you can like make it

998
00:52:46,050 --> 00:52:50,490
simply simpler so you know we're we're

999
00:52:48,389 --> 00:52:51,750
at the worst stage of it when we're

1000
00:52:50,489 --> 00:52:53,669
working through and figuring out how to

1001
00:52:51,750 --> 00:52:55,409
go once you actually have the whole

1002
00:52:53,670 --> 00:52:57,480
thing working you can usually go oh like

1003
00:52:55,409 --> 00:53:00,480
these cases kind of collapse here and

1004
00:52:57,480 --> 00:53:03,869
you know it can get simpler as you can

1005
00:53:00,480 --> 00:53:05,849
analyze it so I wouldn't despair I I

1006
00:53:03,869 --> 00:53:07,140
don't want to the reason I'm not just

1007
00:53:05,849 --> 00:53:08,940
like oh let's give up now is because you

1008
00:53:07,139 --> 00:53:10,618
never know you want to kind of look you

1009
00:53:08,940 --> 00:53:13,019
want to get a little bit past that

1010
00:53:10,619 --> 00:53:15,358
breaking point to just make sure there

1011
00:53:13,019 --> 00:53:18,900
isn't like a maybe it would be clean you

1012
00:53:15,358 --> 00:53:23,489
know or just over the horizon right so

1013
00:53:18,900 --> 00:53:26,309
anyway okay so if we assume that read

1014
00:53:23,489 --> 00:53:31,579
half n read half 1 was equal to end the

1015
00:53:26,309 --> 00:53:35,190
note this is just reassembly of half 0

1016
00:53:31,579 --> 00:53:36,900
here right but otherwise if we weren't

1017
00:53:35,190 --> 00:53:38,579
going to do if that wasn't going to be

1018
00:53:36,900 --> 00:53:41,309
the case so there is still a read half

1019
00:53:38,579 --> 00:53:47,299
one left then we would need to swap as

1020
00:53:41,309 --> 00:53:47,299
many as the v's right in there

1021
00:53:50,400 --> 00:54:03,700
and i guess i would say at this point

1022
00:53:52,630 --> 00:54:06,789
that's what these are right so yeah

1023
00:54:03,699 --> 00:54:09,219
pretty tricky definitely pretty tricky

1024
00:54:06,789 --> 00:54:13,840
but this is this is the reassembly of

1025
00:54:09,219 --> 00:54:19,089
half 0 the original half 0 it does make

1026
00:54:13,840 --> 00:54:24,760
me wonder too uh I wonder if we swapped

1027
00:54:19,090 --> 00:54:37,390
our items smarter if there's something

1028
00:54:24,760 --> 00:54:38,710
we could do with that right I don't

1029
00:54:37,389 --> 00:54:41,529
think of anything but so we'll just

1030
00:54:38,710 --> 00:54:44,710
leave that for now all right so we got

1031
00:54:41,530 --> 00:54:46,540
those two pieces we we've swapped some

1032
00:54:44,710 --> 00:54:48,490
number and then we just have to figure

1033
00:54:46,539 --> 00:54:50,800
out like okay we've got these three

1034
00:54:48,489 --> 00:54:53,679
buffers how do we actually merge them

1035
00:54:50,800 --> 00:54:55,810
right how do we merge these three

1036
00:54:53,679 --> 00:54:59,199
buffers so we've got the swore off the

1037
00:54:55,809 --> 00:55:03,940
swapped part of half 0 the unlocked part

1038
00:54:59,199 --> 00:55:08,439
of half 0 and the you know but I guess

1039
00:55:03,940 --> 00:55:10,059
this is just the remainder we don't have

1040
00:55:08,440 --> 00:55:14,980
to think of that as being swapped or not

1041
00:55:10,059 --> 00:55:17,670
swap okay so let's take the case where

1042
00:55:14,980 --> 00:55:22,090
we know that we're just reassembling

1043
00:55:17,670 --> 00:55:27,400
half 0 so like I said that looks like

1044
00:55:22,090 --> 00:55:30,190
this if we were to take our buffer here

1045
00:55:27,400 --> 00:55:32,860
is the half marker now what we've

1046
00:55:30,190 --> 00:55:34,869
effectively got is we know that we

1047
00:55:32,860 --> 00:55:36,849
swapped out like basically everything

1048
00:55:34,869 --> 00:55:39,819
there was right so we know that the

1049
00:55:36,849 --> 00:55:45,130
entirety this was completely consumed we

1050
00:55:39,820 --> 00:55:47,320
know that all of this is all the first

1051
00:55:45,130 --> 00:55:50,890
part of half 0 right so this is the

1052
00:55:47,320 --> 00:55:53,170
first part and we know that you know

1053
00:55:50,889 --> 00:55:55,299
we're at some place here that there's

1054
00:55:53,170 --> 00:55:57,130
some other part and so what we need to

1055
00:55:55,300 --> 00:55:59,560
do is reverse the order of these two

1056
00:55:57,130 --> 00:56:03,250
things we need this chunk to come before

1057
00:55:59,559 --> 00:56:12,849
this chunk right and so

1058
00:56:03,250 --> 00:56:18,010
uh I sis I don't know that may is that

1059
00:56:12,849 --> 00:56:19,989
even is there any way to do that I mean

1060
00:56:18,010 --> 00:56:22,300
without doing it really without ending

1061
00:56:19,989 --> 00:56:26,259
up this costing a huge number of extra

1062
00:56:22,300 --> 00:56:28,660
things right because in order to do that

1063
00:56:26,260 --> 00:56:31,570
right I need this element to end up here

1064
00:56:28,659 --> 00:56:33,309
right then that would you know so that

1065
00:56:31,570 --> 00:56:34,420
would put it in its correct place but

1066
00:56:33,309 --> 00:56:37,900
then this thing would be in the wrong

1067
00:56:34,420 --> 00:56:39,369
place right and then like you're

1068
00:56:37,900 --> 00:56:55,019
constantly going to have these things

1069
00:56:39,369 --> 00:56:55,019
being being in their wrong places yeah

1070
00:56:55,599 --> 00:57:04,360
that's looking ugly I mean because I

1071
00:57:03,039 --> 00:57:06,400
think basically what this would end up

1072
00:57:04,360 --> 00:57:10,030
doing is this will end up making it so

1073
00:57:06,400 --> 00:57:12,639
that there's no way for us to ever do

1074
00:57:10,030 --> 00:57:15,360
this efficiently because if we have to

1075
00:57:12,639 --> 00:57:19,960
swap the order of two blocks of

1076
00:57:15,360 --> 00:57:21,789
different sizes right whatever those two

1077
00:57:19,960 --> 00:57:26,199
sizes are here's all ras here's all our

1078
00:57:21,789 --> 00:57:28,480
bees then in order to do that right I

1079
00:57:26,199 --> 00:57:31,419
could I mean I could just swap a into

1080
00:57:28,480 --> 00:57:33,969
the correct place right so there's

1081
00:57:31,420 --> 00:57:37,480
there's my a is now in the correct place

1082
00:57:33,969 --> 00:57:39,250
and now i have b but then i'm right back

1083
00:57:37,480 --> 00:57:42,130
to the exact same problem i had before

1084
00:57:39,250 --> 00:57:44,619
so now you know that be has to be at the

1085
00:57:42,130 --> 00:57:48,789
end so now i have to swap that part out

1086
00:57:44,619 --> 00:57:53,049
right I end up doing Oh n swaps on this

1087
00:57:48,789 --> 00:57:54,460
thing to put it in that order I don't

1088
00:57:53,050 --> 00:57:57,370
think there's anything else I could do

1089
00:57:54,460 --> 00:57:59,349
other than doing Oh n swaps and if I had

1090
00:57:57,369 --> 00:58:09,159
to do if I have to do those oh n swaps

1091
00:57:59,349 --> 00:58:15,969
and a little worried well yeah well

1092
00:58:09,159 --> 00:58:18,849
let's just do it what the hey uh so yeah

1093
00:58:15,969 --> 00:58:23,169
so if I need to rearrange the two halves

1094
00:58:18,849 --> 00:58:27,489
of this thing right so I guess what I

1095
00:58:23,170 --> 00:58:31,110
would do their say like okay as long as

1096
00:58:27,489 --> 00:58:34,599
I still have some left I've got to keep

1097
00:58:31,110 --> 00:58:37,150
swapping this thing in so what are my

1098
00:58:34,599 --> 00:58:39,750
two halves I've got in f1 that's the

1099
00:58:37,150 --> 00:58:43,690
swapped part I've got read half one

1100
00:58:39,750 --> 00:58:46,900
that's the unswept part and I need to

1101
00:58:43,690 --> 00:58:51,190
move in half one up to where read half

1102
00:58:46,900 --> 00:58:55,059
one actually is right so if I were to do

1103
00:58:51,190 --> 00:59:01,780
that that would just be like okay

1104
00:58:55,059 --> 00:59:07,500
however much in half one it's right here

1105
00:59:01,780 --> 00:59:18,250
while swap read not equal to swap end

1106
00:59:07,500 --> 00:59:20,559
star slop slop read trying to think if

1107
00:59:18,250 --> 00:59:23,469
I'm swapping it in what happens when I

1108
00:59:20,559 --> 00:59:25,539
get to the end of it yeah this is super

1109
00:59:23,469 --> 00:59:28,809
nasty this is super nasty because

1110
00:59:25,539 --> 00:59:34,300
there's two cases here to write if it

1111
00:59:28,809 --> 00:59:38,860
looks like this right then the thing

1112
00:59:34,300 --> 00:59:41,950
that I'm swapping will because I'm

1113
00:59:38,860 --> 00:59:44,079
putting this into this location one of

1114
00:59:41,949 --> 00:59:46,089
these is bigger than the other right so

1115
00:59:44,079 --> 00:59:47,949
you'd presumably want to do it so that

1116
00:59:46,090 --> 00:59:50,680
you did the bigger one first so if I

1117
00:59:47,949 --> 00:59:53,649
want to put this one you know if the

1118
00:59:50,679 --> 00:59:57,519
goal is to swap the order these two if I

1119
00:59:53,650 --> 01:00:00,840
want to put this one this one has to

1120
00:59:57,519 --> 01:00:05,769
come first then after I swap this many

1121
01:00:00,840 --> 01:00:07,660
right then I'm at a position where I'm

1122
01:00:05,769 --> 01:00:10,960
ending up with three buffers again

1123
01:00:07,659 --> 01:00:14,199
because now I have the right stuff comes

1124
01:00:10,960 --> 01:00:16,150
at the head end and so then I've got to

1125
01:00:14,199 --> 01:00:18,849
go these two buffers now need to be

1126
01:00:16,150 --> 01:00:21,610
swapped so it's kind of like a recursive

1127
01:00:18,849 --> 01:00:23,799
swapping thing right it's like okay swap

1128
01:00:21,610 --> 01:00:29,380
as much as you could and then you got to

1129
01:00:23,800 --> 01:00:33,250
recursively swap these two guys it just

1130
01:00:29,380 --> 01:00:35,200
doesn't seem worth it does it we're just

1131
01:00:33,250 --> 01:00:39,670
going to spend all our time swap like we

1132
01:00:35,199 --> 01:00:42,359
just spent all our time swapping well

1133
01:00:39,670 --> 01:00:44,920
I'm just I should probably go to the QA

1134
01:00:42,360 --> 01:00:47,680
the problem is if somebody cheated and

1135
01:00:44,920 --> 01:00:49,240
looked it up because i'm going to say do

1136
01:00:47,679 --> 01:00:50,529
you guys have any ideas but if somebody

1137
01:00:49,239 --> 01:00:51,819
would probably already went and looked

1138
01:00:50,530 --> 01:00:56,830
it up then they're going to cheat and

1139
01:00:51,820 --> 01:00:58,690
cheating is not fair because the

1140
01:00:56,829 --> 01:01:01,000
question is is there some crucial thing

1141
01:00:58,690 --> 01:01:04,590
that I'm missing that it's like if we

1142
01:01:01,000 --> 01:01:07,239
just were smarter about where we swapped

1143
01:01:04,590 --> 01:01:10,090
could we have done it without having to

1144
01:01:07,239 --> 01:01:13,989
do so many right is there a way we could

1145
01:01:10,090 --> 01:01:16,079
eliminate like like is there some way I

1146
01:01:13,989 --> 01:01:19,029
could have

1147
01:01:16,079 --> 01:01:20,710
not put myself into this position when

1148
01:01:19,030 --> 01:01:23,170
we got down here so I wouldn't have to

1149
01:01:20,710 --> 01:01:36,869
worry about having to do so many of

1150
01:01:23,170 --> 01:01:36,869
those hmmm

1151
01:01:44,809 --> 01:01:52,110
well let me think this through one more

1152
01:01:47,489 --> 01:01:54,479
time maybe i am missing something let's

1153
01:01:52,110 --> 01:01:58,349
see what actually just happens so here

1154
01:01:54,480 --> 01:02:06,329
are my two halves right and here are my

1155
01:01:58,349 --> 01:02:08,069
entries alright so i start off and i

1156
01:02:06,329 --> 01:02:09,690
skip some number of entries so let's say

1157
01:02:08,070 --> 01:02:11,340
I get to hear because the first one

1158
01:02:09,690 --> 01:02:17,429
already contains the letter A so it's

1159
01:02:11,340 --> 01:02:23,519
correct but the next one has lexi or

1160
01:02:17,429 --> 01:02:28,169
maybe d and b and c are here so we need

1161
01:02:23,519 --> 01:02:31,920
d and maybe d e f come next so those are

1162
01:02:28,170 --> 01:02:34,320
in order so then what happens right i'm

1163
01:02:31,920 --> 01:02:37,829
at a i swap these guys out so i get b

1164
01:02:34,320 --> 01:02:47,070
and I get see in here and D and E come

1165
01:02:37,829 --> 01:02:49,170
in here right but then I get to F G is

1166
01:02:47,070 --> 01:02:52,500
here then I get to F and G and I'm like

1167
01:02:49,170 --> 01:02:56,490
f is actually the thing that comes first

1168
01:02:52,500 --> 01:02:59,309
right so what I should really be doing

1169
01:02:56,489 --> 01:03:10,949
is saying oh why don't you just compare

1170
01:02:59,309 --> 01:03:13,190
a why don't you just compare F with this

1171
01:03:10,949 --> 01:03:13,189
guy

1172
01:03:18,259 --> 01:03:22,369
that's what should be happening right

1173
01:03:28,518 --> 01:03:35,758
yeah because we got to hear we said all

1174
01:03:31,469 --> 01:03:37,409
right we've got d we've got see right we

1175
01:03:35,759 --> 01:03:41,188
swapped in the scene because that was

1176
01:03:37,409 --> 01:03:42,420
still ahead of the of the of the person

1177
01:03:41,188 --> 01:03:43,978
we were spinning on which was the D

1178
01:03:42,420 --> 01:03:46,739
right that was the guy we were checking

1179
01:03:43,978 --> 01:03:50,639
on we got to the point where it was no

1180
01:03:46,739 --> 01:03:54,329
longer the case right so the guy who was

1181
01:03:50,639 --> 01:03:58,978
here is not less than D so at that point

1182
01:03:54,329 --> 01:04:00,599
is it sufficient to simply say oh then

1183
01:03:58,978 --> 01:04:04,198
the person you should be comparing with

1184
01:04:00,599 --> 01:04:10,170
just resets to hear can't we just back

1185
01:04:04,199 --> 01:04:11,969
up to here so then we compare F&amp;D we

1186
01:04:10,170 --> 01:04:19,769
find the DEA's first we swap the f in

1187
01:04:11,969 --> 01:04:26,688
their right and move it forwards and the

1188
01:04:19,768 --> 01:04:30,798
d comes out then we come down to the e

1189
01:04:26,688 --> 01:04:35,728
right we compared against whatever was

1190
01:04:30,798 --> 01:04:38,400
was in there as well which would be what

1191
01:04:35,728 --> 01:04:44,818
at this point I don't know like I J or

1192
01:04:38,400 --> 01:04:47,789
something like that we compare the I

1193
01:04:44,818 --> 01:04:50,489
against the e because we know ah that's

1194
01:04:47,789 --> 01:04:55,559
the key we know all the things that were

1195
01:04:50,489 --> 01:05:00,499
in here right we know that these things

1196
01:04:55,559 --> 01:05:00,499
came before the thing that we stopped on

1197
01:05:04,329 --> 01:05:11,840
so does that just work does it just work

1198
01:05:08,030 --> 01:05:16,640
to just reset the pointer you see what

1199
01:05:11,840 --> 01:05:20,090
I'm saying meaning if we do this where

1200
01:05:16,639 --> 01:05:22,309
we say this obviously is fine right we

1201
01:05:20,090 --> 01:05:25,100
just skip just skip things as far as we

1202
01:05:22,309 --> 01:05:27,920
want to skip we swap things as far as we

1203
01:05:25,099 --> 01:05:32,480
need to swap at that point can we just

1204
01:05:27,920 --> 01:05:35,630
say like as as long as we still have

1205
01:05:32,480 --> 01:05:38,900
stuff to go can we just run this thing

1206
01:05:35,630 --> 01:05:41,119
and at the end after we do all of our

1207
01:05:38,900 --> 01:05:43,900
swaps just reset the pointer to where we

1208
01:05:41,119 --> 01:05:43,900
had swapped from

1209
01:05:55,159 --> 01:06:03,199
I feel like that could work let's let's

1210
01:05:59,269 --> 01:06:08,570
let's see let's just let's just see what

1211
01:06:03,199 --> 01:06:12,769
happens so if we just said here okay

1212
01:06:08,570 --> 01:06:14,420
read half the pointer that we're reading

1213
01:06:12,769 --> 01:06:19,159
from from read half one is just going to

1214
01:06:14,420 --> 01:06:26,380
equal in half one again that's it right

1215
01:06:19,159 --> 01:06:31,960
I see here 795 what is the problem

1216
01:06:26,380 --> 01:06:35,360
syntax error what is the syntax error

1217
01:06:31,960 --> 01:06:37,820
syntax error oh I wrote that correctly

1218
01:06:35,360 --> 01:06:45,680
and emacs got confused didn't it think

1219
01:06:37,820 --> 01:06:49,220
it did let's see ya alright so let's see

1220
01:06:45,679 --> 01:06:52,219
here could this putt can this possibly

1221
01:06:49,219 --> 01:06:55,009
be correct let's find out I want to look

1222
01:06:52,219 --> 01:06:57,289
at this one more time that's so cool if

1223
01:06:55,010 --> 01:06:59,560
this works this is going to be so crazy

1224
01:06:57,289 --> 01:07:03,469
or something very close to it works

1225
01:06:59,559 --> 01:07:06,650
alright I'm going to construct a case

1226
01:07:03,469 --> 01:07:13,909
here just to see what happens ok so

1227
01:07:06,650 --> 01:07:23,360
we've got a and then we got bc then we

1228
01:07:13,909 --> 01:07:26,839
got like d e f g h i j k l all right

1229
01:07:23,360 --> 01:07:29,030
let's do this so we skip a we're

1230
01:07:26,840 --> 01:07:32,300
comparing a and B we take we keep a

1231
01:07:29,030 --> 01:07:34,580
right so we just advance the pointer

1232
01:07:32,300 --> 01:07:37,580
comes down one right so now we're

1233
01:07:34,579 --> 01:07:39,079
looking at d we compare D&amp;B and we find

1234
01:07:37,579 --> 01:07:40,639
that b is actually the things that

1235
01:07:39,079 --> 01:07:46,699
should be in this place so we get rid of

1236
01:07:40,639 --> 01:07:49,210
that and we do this swap right we keep

1237
01:07:46,699 --> 01:07:51,829
going so we say like okay what about

1238
01:07:49,210 --> 01:07:55,190
we're still comparing against d so what

1239
01:07:51,829 --> 01:07:57,440
about D and C well c is still better so

1240
01:07:55,190 --> 01:08:00,619
we get rid of this we put this here and

1241
01:07:57,440 --> 01:08:02,869
we put the sea there right then we're

1242
01:08:00,619 --> 01:08:04,969
still comparing against d source a D&amp;G

1243
01:08:02,869 --> 01:08:07,819
which one's better well clearly d is

1244
01:08:04,969 --> 01:08:08,809
better so now we halt and we set the

1245
01:08:07,820 --> 01:08:11,630
pointer back

1246
01:08:08,809 --> 01:08:14,239
up to here right and so we're still

1247
01:08:11,630 --> 01:08:17,810
looking we're still our right position

1248
01:08:14,239 --> 01:08:22,130
is still here right it's at F and so now

1249
01:08:17,810 --> 01:08:24,890
we're back to looking at F and D now

1250
01:08:22,130 --> 01:08:30,440
since we know that all of these must

1251
01:08:24,890 --> 01:08:33,410
have come before this one here right is

1252
01:08:30,439 --> 01:08:37,939
that correct no that is that's not true

1253
01:08:33,409 --> 01:08:40,309
we don't actually know that do we we got

1254
01:08:37,939 --> 01:08:42,619
to G we said that G was we know that

1255
01:08:40,310 --> 01:08:45,710
this guy came before him but we don't

1256
01:08:42,619 --> 01:08:48,800
know anything about these I guess that's

1257
01:08:45,710 --> 01:08:51,439
the actual problem right so this guy

1258
01:08:48,800 --> 01:08:54,020
will work properly but we don't actually

1259
01:08:51,439 --> 01:08:56,719
know if the next guy could have could

1260
01:08:54,020 --> 01:09:04,640
have been worse right the next guy could

1261
01:08:56,720 --> 01:09:07,280
have been worse than somebody here so i

1262
01:09:04,640 --> 01:09:12,170
think that that is why that doesn't

1263
01:09:07,279 --> 01:09:14,899
quite work yeah because we don't really

1264
01:09:12,170 --> 01:09:17,420
know we know that all of these guys will

1265
01:09:14,899 --> 01:09:19,818
be below this dude so we definitely know

1266
01:09:17,420 --> 01:09:23,119
that that swapping back guy back in now

1267
01:09:19,819 --> 01:09:27,280
is the correct operation but we don't

1268
01:09:23,119 --> 01:09:27,279
really know anything about any of these

1269
01:09:29,079 --> 01:09:33,680
so yeah so I don't know that there's

1270
01:09:31,130 --> 01:09:36,520
anything else we could do so in so when

1271
01:09:33,680 --> 01:09:39,829
we look at this position we need to look

1272
01:09:36,520 --> 01:09:42,250
we need to look at at this guy and that

1273
01:09:39,829 --> 01:09:42,250
this guy

1274
01:09:49,720 --> 01:09:51,780
you

1275
01:09:53,760 --> 01:09:57,789
now you gotta I feel like you gotta be

1276
01:09:56,229 --> 01:10:01,029
able to do this because we just need to

1277
01:09:57,789 --> 01:10:03,880
know which one to swap in and then we

1278
01:10:01,029 --> 01:10:06,908
can proceed right because let's say

1279
01:10:03,880 --> 01:10:10,960
whoever we end up swapping in here right

1280
01:10:06,908 --> 01:10:14,439
they go into whichever location they go

1281
01:10:10,960 --> 01:10:17,260
into their pulling out so if I swap in

1282
01:10:14,439 --> 01:10:22,869
this this D right and the F comes here

1283
01:10:17,260 --> 01:10:27,460
and then I move down here I'm still in a

1284
01:10:22,869 --> 01:10:29,769
position to know that I wouldn't revisit

1285
01:10:27,460 --> 01:10:32,380
these guys until I revisited every until

1286
01:10:29,770 --> 01:10:35,770
I visited everyone down here so it feels

1287
01:10:32,380 --> 01:10:38,679
like all I should need is just a stack

1288
01:10:35,770 --> 01:10:42,420
of these swap pointers a stack of the

1289
01:10:38,679 --> 01:10:45,600
swap base pointer I feel like that's it

1290
01:10:42,420 --> 01:10:47,529
all right i think what i'm going to do i

1291
01:10:45,600 --> 01:10:50,020
think what i'm going to do is I'm going

1292
01:10:47,529 --> 01:10:53,679
to say I'm not going to look at the chat

1293
01:10:50,020 --> 01:10:55,710
I'm not going to look at it because I

1294
01:10:53,679 --> 01:10:58,149
want to actually try this on monday i

1295
01:10:55,710 --> 01:11:00,279
want to see if we can do this because i

1296
01:10:58,149 --> 01:11:03,339
think that's all I really need I think

1297
01:11:00,279 --> 01:11:06,639
all i need to do is remember this this

1298
01:11:03,340 --> 01:11:09,489
stack pointer here right and I just need

1299
01:11:06,639 --> 01:11:13,389
I so i would need some space but i only

1300
01:11:09,488 --> 01:11:19,029
need space to store that that that

1301
01:11:13,389 --> 01:11:21,760
recurs of course you know what I I

1302
01:11:19,029 --> 01:11:24,960
suppose you could argue well that space

1303
01:11:21,760 --> 01:11:29,980
to store that back pointer though that's

1304
01:11:24,960 --> 01:11:34,719
that's cheating right I mean that is the

1305
01:11:29,979 --> 01:11:36,250
storage so at that point so it's only if

1306
01:11:34,719 --> 01:11:37,899
I could figure out something clever that

1307
01:11:36,250 --> 01:11:42,488
allows me to not ever store it

1308
01:11:37,899 --> 01:11:44,559
explicitly and I'm not seeing how to do

1309
01:11:42,488 --> 01:11:47,069
that because you don't know how many you

1310
01:11:44,560 --> 01:11:47,070
put in there

1311
01:11:58,880 --> 01:12:06,210
so I think that that may be enough to

1312
01:12:04,618 --> 01:12:09,359
convince me that you can't do it in

1313
01:12:06,210 --> 01:12:12,029
place because it seems like no matter

1314
01:12:09,359 --> 01:12:16,460
what you do I will have to solve I would

1315
01:12:12,029 --> 01:12:19,800
have to store that back pointer and

1316
01:12:16,460 --> 01:12:21,569
every time I switch between the two I

1317
01:12:19,800 --> 01:12:23,760
would need to remember where that was

1318
01:12:21,569 --> 01:12:30,960
which means that if you constructed

1319
01:12:23,760 --> 01:12:33,800
exactly the right ping pong I I can't I

1320
01:12:30,960 --> 01:12:33,800
can't do it right

1321
01:12:41,279 --> 01:12:47,710
that's a bummer so that means I would

1322
01:12:45,489 --> 01:12:49,449
predict based on having a sword that I

1323
01:12:47,710 --> 01:12:52,109
would predict that somebody has shown

1324
01:12:49,449 --> 01:12:54,670
that bird short can't be done in place

1325
01:12:52,109 --> 01:12:56,500
but it's a pretty weak prediction right

1326
01:12:54,670 --> 01:12:58,779
we didn't try that hard we didn't really

1327
01:12:56,500 --> 01:13:01,029
look at it that that closely we

1328
01:12:58,779 --> 01:13:02,769
certainly didn't prove anything so it's

1329
01:13:01,029 --> 01:13:05,139
possible that we're just missing one

1330
01:13:02,770 --> 01:13:13,090
clever insight that would allow us to do

1331
01:13:05,140 --> 01:13:16,630
something more clever yeah but I can't

1332
01:13:13,090 --> 01:13:21,579
think of what it would be so yeah so if

1333
01:13:16,630 --> 01:13:31,539
that was the case right we would need

1334
01:13:21,579 --> 01:13:33,369
some storage so when we do this merge

1335
01:13:31,539 --> 01:13:36,189
sort we would need some temporary

1336
01:13:33,369 --> 01:13:42,369
storage now in order to do that right we

1337
01:13:36,189 --> 01:13:44,739
can we can do kind of the the crappy way

1338
01:13:42,369 --> 01:13:46,000
I suppose which is to say that the first

1339
01:13:44,739 --> 01:13:48,309
you know just just for the sake of

1340
01:13:46,000 --> 01:13:51,750
finishing it up we can just do like a

1341
01:13:48,310 --> 01:13:54,310
temp pointer here that we always keep

1342
01:13:51,750 --> 01:13:55,449
and we'll do like the worst possible

1343
01:13:54,310 --> 01:13:58,510
version of this because we're basically

1344
01:13:55,449 --> 01:14:00,550
out of time the worst possible version

1345
01:13:58,510 --> 01:14:02,260
of this is we literally just do what I

1346
01:14:00,550 --> 01:14:09,489
wrote before where we say okay Kyle

1347
01:14:02,260 --> 01:14:12,850
sword entry out equals temp zero index

1348
01:14:09,489 --> 01:14:20,199
less than count + + index and then here

1349
01:14:12,850 --> 01:14:22,110
we just do exactly this thing so we have

1350
01:14:20,199 --> 01:14:25,349
our two loops we have our two entries

1351
01:14:22,109 --> 01:14:25,349
which is

1352
01:14:29,939 --> 01:14:42,759
and a half 10 we have our two reads we

1353
01:14:37,420 --> 01:14:47,140
say if we have 0 is less than three half

1354
01:14:42,760 --> 01:14:51,730
one then we just say the out location

1355
01:14:47,140 --> 01:14:55,119
equals read half 0 plus plus otherwise

1356
01:14:51,729 --> 01:15:01,689
we say at the location equals read half

1357
01:14:55,119 --> 01:15:03,340
one like so and then of course we have

1358
01:15:01,689 --> 01:15:10,149
to do the thing here to where if we have

1359
01:15:03,340 --> 01:15:11,350
1 or 0 equals in half one we always read

1360
01:15:10,149 --> 01:15:14,469
for the other one because that means

1361
01:15:11,350 --> 01:15:16,890
we're out of data on that one and same

1362
01:15:14,469 --> 01:15:16,890
thing here

1363
01:15:29,340 --> 01:15:34,510
so that actually just flat-out does what

1364
01:15:32,889 --> 01:15:36,159
we wanted to do that puts them all into

1365
01:15:34,510 --> 01:15:38,739
the temp thing and then we could

1366
01:15:36,158 --> 01:15:40,598
literally just copy it back now if we

1367
01:15:38,738 --> 01:15:41,768
are smarter about the way we ping pong

1368
01:15:40,599 --> 01:15:45,969
or buffers we wouldn't need to do the

1369
01:15:41,769 --> 01:15:51,820
copy back so to do not really necessary

1370
01:15:45,969 --> 01:15:55,328
if we think pong but again we'll just do

1371
01:15:51,819 --> 01:15:59,920
the easiest version first so here all we

1372
01:15:55,328 --> 01:16:04,078
need to do is say okay we have our our

1373
01:15:59,920 --> 01:16:07,689
first there we just do first index

1374
01:16:04,078 --> 01:16:11,078
equals temp index that's just the copy

1375
01:16:07,689 --> 01:16:13,630
back and that's really it so in here we

1376
01:16:11,078 --> 01:16:17,590
now need again we need that we need

1377
01:16:13,630 --> 01:16:20,969
space for the sorting and I believe we

1378
01:16:17,590 --> 01:16:23,439
actually have space for the sorting I

1379
01:16:20,969 --> 01:16:25,300
don't know if we actually do or not so

1380
01:16:23,439 --> 01:16:31,709
when we call merge sort we need like

1381
01:16:25,300 --> 01:16:34,599
temp space and I don't really remember

1382
01:16:31,708 --> 01:16:39,219
whether we had temp space or not so when

1383
01:16:34,599 --> 01:16:42,420
we do sword entries oops when we call

1384
01:16:39,219 --> 01:16:44,739
sword entries I don't quite remember

1385
01:16:42,420 --> 01:16:47,380
push before element count push before

1386
01:16:44,738 --> 01:16:49,598
base sort entry yet I don't remember if

1387
01:16:47,380 --> 01:16:52,300
we ever yeah so when we do sword entries

1388
01:16:49,599 --> 01:16:54,219
we did this sort space thing here where

1389
01:16:52,300 --> 01:16:56,650
we had the temporary nuh we don't need

1390
01:16:54,219 --> 01:17:00,189
that anymore right sort space is not a

1391
01:16:56,649 --> 01:17:01,929
thing anymore for these guys and we're

1392
01:17:00,189 --> 01:17:04,179
still doing that everywhere aren't we so

1393
01:17:01,929 --> 01:17:08,760
we don't really need that all we really

1394
01:17:04,179 --> 01:17:11,559
need to do is do it here right 41 41

1395
01:17:08,760 --> 01:17:13,409
just just before we do anything we do

1396
01:17:11,559 --> 01:17:16,029
that that sort entries that makes sense

1397
01:17:13,408 --> 01:17:21,129
so that would just take the temporary

1398
01:17:16,029 --> 01:17:26,429
nuh here let me call sword entries there

1399
01:17:21,130 --> 01:17:26,429
we go and

1400
01:17:30,729 --> 01:17:39,429
now we can get any memory that we want

1401
01:17:33,670 --> 01:17:41,539
and yeah begin temporary the temper Rena

1402
01:17:39,430 --> 01:17:45,890
we don't actually need to do that

1403
01:17:41,539 --> 01:17:52,699
anymore here right that stuff is just

1404
01:17:45,890 --> 01:17:54,710
not necessary okay and I want that to go

1405
01:17:52,699 --> 01:17:56,569
away entirely because we don't need to

1406
01:17:54,710 --> 01:18:01,180
do it anymore because it just happens in

1407
01:17:56,569 --> 01:18:04,670
here I'm pretty sure that's all fine

1408
01:18:01,180 --> 01:18:05,900
right is that not true because sword

1409
01:18:04,670 --> 01:18:10,010
entries doesn't happen for thread

1410
01:18:05,899 --> 01:18:12,920
anymore that's or never really did so

1411
01:18:10,010 --> 01:18:16,280
that's it and so all I need to do is

1412
01:18:12,920 --> 01:18:19,640
actually get that that temp space so

1413
01:18:16,279 --> 01:18:22,009
yeah when we call sort entries the temp

1414
01:18:19,640 --> 01:18:24,619
space is just tile sword entry temp

1415
01:18:22,010 --> 01:18:32,690
space I'm just going to grab however

1416
01:18:24,619 --> 01:18:37,670
many the count is and that should do it

1417
01:18:32,689 --> 01:18:42,769
right so yeah got to put some stars in

1418
01:18:37,670 --> 01:18:44,270
there and the assertion where'd my

1419
01:18:42,770 --> 01:18:51,610
assertion go I want to put my assertion

1420
01:18:44,270 --> 01:18:59,900
back in as well I want to do an assert

1421
01:18:51,609 --> 01:19:01,670
that out epolls temp plus well I guess I

1422
01:18:59,899 --> 01:19:03,170
know that that's definitely true but we

1423
01:19:01,670 --> 01:19:06,890
might as well do it anyway and then I'll

1424
01:19:03,170 --> 01:19:11,329
cert that read have 0 equals skin half 1

1425
01:19:06,890 --> 01:19:17,200
and read half 1 equals end let's just

1426
01:19:11,329 --> 01:19:20,350
make that happen there and then think

1427
01:19:17,199 --> 01:19:20,349
we're good

1428
01:19:21,289 --> 01:19:25,409
don't know why that guy's confused

1429
01:19:23,520 --> 01:19:27,000
they're probably because emacs gets

1430
01:19:25,409 --> 01:19:29,149
confused sometimes it thinks something's

1431
01:19:27,000 --> 01:19:33,199
a template that it's not there yeah yeah

1432
01:19:29,149 --> 01:19:37,589
all right so let's see what that does

1433
01:19:33,199 --> 01:19:41,000
again we should have an assertion if we

1434
01:19:37,590 --> 01:19:44,220
don't sort properly why am I getting oh

1435
01:19:41,000 --> 01:19:46,140
that's great yeah obviously it doesn't

1436
01:19:44,220 --> 01:19:49,110
have to be greater than 1 it just has to

1437
01:19:46,140 --> 01:19:52,440
be greater than or equal to 1 there we

1438
01:19:49,109 --> 01:19:56,909
go so we should get some assertions here

1439
01:19:52,439 --> 01:20:14,039
if we do something wrong looks like we

1440
01:19:56,909 --> 01:20:16,769
didn't do anything wrong I guess yeah so

1441
01:20:14,039 --> 01:20:19,260
yeah I disappointed that we couldn't

1442
01:20:16,770 --> 01:20:21,270
figure out how to do that in place but I

1443
01:20:19,260 --> 01:20:24,090
guess what we'll do now since since it

1444
01:20:21,270 --> 01:20:26,340
seems like i don't know i don't i feel

1445
01:20:24,090 --> 01:20:29,010
like i don't have any great ideas for

1446
01:20:26,340 --> 01:20:30,840
that i don't know if i want spoilers

1447
01:20:29,010 --> 01:20:33,930
wording or not I don't know if I want to

1448
01:20:30,840 --> 01:20:35,250
look and find out if it is or if if we

1449
01:20:33,930 --> 01:20:38,220
want to try to think about it over the

1450
01:20:35,250 --> 01:20:39,539
weekend I'm afraid to look at the chat

1451
01:20:38,220 --> 01:20:42,680
because I know someone has almost

1452
01:20:39,539 --> 01:20:42,680
certainly already looked it up

1453
01:20:42,840 --> 01:20:51,480
yeah i'm going to guess that you can't

1454
01:20:50,368 --> 01:20:53,250
do it in place i'm just going to guess

1455
01:20:51,479 --> 01:20:54,569
and then i'm going to feel bad if it

1456
01:20:53,250 --> 01:20:55,679
turns out you can and we just should

1457
01:20:54,569 --> 01:21:22,408
have thought about it longer we could

1458
01:20:55,679 --> 01:21:30,090
have figured it out let's see ya so it

1459
01:21:22,408 --> 01:21:33,779
looks like I'm roughly correct it looks

1460
01:21:30,090 --> 01:21:36,960
like you would need a lot more work if

1461
01:21:33,779 --> 01:21:38,579
you didn't at least they seem to say on

1462
01:21:36,960 --> 01:21:42,050
wikipedia that you need a lot more work

1463
01:21:38,579 --> 01:21:42,050
if you wanted to actually do it in place

1464
01:21:43,069 --> 01:21:47,149
let's see is there any

1465
01:22:00,859 --> 01:22:04,250
let's see

1466
01:22:12,569 --> 01:22:24,599
well this oh no there it is yeah yep

1467
01:22:20,119 --> 01:22:27,809
that's it right there so I don't know I

1468
01:22:24,600 --> 01:22:30,090
mean who's to say that penguin ed EWU

1469
01:22:27,810 --> 01:22:32,370
edu has the most clever in place merge

1470
01:22:30,090 --> 01:22:35,690
sort but you can see they do a whole

1471
01:22:32,369 --> 01:22:40,319
block copy to move everything up by one

1472
01:22:35,689 --> 01:22:41,729
which is not you know that's exactly the

1473
01:22:40,319 --> 01:22:46,579
kind of thing that I was saying I don't

1474
01:22:41,729 --> 01:22:49,079
think you can do it without so all right

1475
01:22:46,579 --> 01:22:50,069
well I don't feel bad about the fact

1476
01:22:49,079 --> 01:22:51,149
that we couldn't figure out a clever i

1477
01:22:50,069 --> 01:22:55,739
do it because it doesn't look like there

1478
01:22:51,149 --> 01:22:57,869
is one but it is a bummer because it

1479
01:22:55,739 --> 01:23:02,460
would be cool if there was a way to do

1480
01:22:57,869 --> 01:23:09,649
it in place I guess I can go I guess I

1481
01:23:02,460 --> 01:23:09,649
can go check the chat now

1482
01:23:19,920 --> 01:23:24,760
so yeah and given that it means that

1483
01:23:22,899 --> 01:23:26,379
almost certainly you want the 10th

1484
01:23:24,760 --> 01:23:28,000
memory the 10th memory is always going

1485
01:23:26,380 --> 01:23:29,859
to be faster if you can't do it more

1486
01:23:28,000 --> 01:23:32,590
clearly than that because basically all

1487
01:23:29,859 --> 01:23:38,710
we have to do is just actually swap use

1488
01:23:32,590 --> 01:23:40,390
like a basically ping-pong to to do it

1489
01:23:38,710 --> 01:23:43,060
and we will be able to eliminate this

1490
01:23:40,390 --> 01:23:48,840
entirely so this is going to be way

1491
01:23:43,060 --> 01:23:51,400
better than doing it in place so sad but

1492
01:23:48,840 --> 01:23:52,900
that's just how it is I'm not actually

1493
01:23:51,399 --> 01:23:54,399
going to do a Q&amp;A because that took you

1494
01:23:52,899 --> 01:23:56,349
long and hopefully there's not much to

1495
01:23:54,399 --> 01:24:00,929
QA about I mean you saw what I was doing

1496
01:23:56,350 --> 01:24:00,930
I just tried to figure it out but

1497
01:24:09,090 --> 01:24:12,850
ince of iris I didn't look this up so it

1498
01:24:11,380 --> 01:24:14,170
might not work but came up with whenever

1499
01:24:12,850 --> 01:24:17,940
an element from the upper half has

1500
01:24:14,170 --> 01:24:17,940
chosen put it in place in the lower half

1501
01:24:18,090 --> 01:24:22,930
shift the upper half down to fill the

1502
01:24:21,069 --> 01:24:24,849
space that the chosen element from the

1503
01:24:22,930 --> 01:24:26,320
upper from the lower half news face at

1504
01:24:24,850 --> 01:24:30,490
the end of the upper half Taylor are you

1505
01:24:26,319 --> 01:24:32,109
pointed that n bit thoughts yeah my

1506
01:24:30,489 --> 01:24:33,729
feeling on that is just that's that's

1507
01:24:32,109 --> 01:24:36,069
too much work right that that block

1508
01:24:33,729 --> 01:24:38,259
copies as soon as you have to do a block

1509
01:24:36,069 --> 01:24:45,340
copy you might as well just two views

1510
01:24:38,260 --> 01:24:47,110
the temp space right because at that

1511
01:24:45,340 --> 01:24:52,409
point I know I'm doing so much more

1512
01:24:47,109 --> 01:24:56,579
extra work that I just I can't see I

1513
01:24:52,409 --> 01:24:56,579
can't see doing it that makes sense

1514
01:25:08,920 --> 01:25:14,149
elephant off topic but I made a post

1515
01:25:11,869 --> 01:25:15,500
about the 2 to the 2 to the N arguments

1516
01:25:14,149 --> 01:25:16,969
for the TSP on the forums if you're

1517
01:25:15,500 --> 01:25:19,029
interested I am insured i'll probably

1518
01:25:16,970 --> 01:25:22,550
take a look at that this weekend then

1519
01:25:19,029 --> 01:25:24,529
Roberto crush Gracia could you post the

1520
01:25:22,550 --> 01:25:26,180
bit of rotation math in the pre stream

1521
01:25:24,529 --> 01:25:28,699
in the YouTube channel I generally don't

1522
01:25:26,180 --> 01:25:35,390
post the pre streams but you are welcome

1523
01:25:28,699 --> 01:25:38,989
to watch it on on twitch it'll be

1524
01:25:35,390 --> 01:25:40,579
archived on Twitch for two weeks one of

1525
01:25:38,989 --> 01:25:44,300
the variance in the wikipedia article

1526
01:25:40,579 --> 01:25:48,229
claimed only one slot Plus Row one extra

1527
01:25:44,300 --> 01:25:50,360
pointers well if you use the block copy

1528
01:25:48,229 --> 01:25:56,449
like I said if you block copy everything

1529
01:25:50,359 --> 01:25:59,269
down you could just do it if you didn't

1530
01:25:56,449 --> 01:26:01,010
care how many more comparisons if you

1531
01:25:59,270 --> 01:26:05,300
were willing to do Oh n more comparisons

1532
01:26:01,010 --> 01:26:07,369
and 0 n more move operations it seems

1533
01:26:05,300 --> 01:26:12,739
like you could do it in the fairly naive

1534
01:26:07,369 --> 01:26:16,550
way like you just go okay I find you

1535
01:26:12,739 --> 01:26:20,210
know I moved down I do this part I do

1536
01:26:16,550 --> 01:26:22,880
this this part and instead of swapping I

1537
01:26:20,210 --> 01:26:25,340
just find where this thing actually goes

1538
01:26:22,880 --> 01:26:27,859
and push everything down to put it in

1539
01:26:25,340 --> 01:26:31,779
place right so it's an insertion sort at

1540
01:26:27,859 --> 01:26:31,779
that point right

1541
01:26:34,020 --> 01:26:43,790
that makes sense like you insertion sort

1542
01:26:39,659 --> 01:26:47,430
this into half one if that makes sense

1543
01:26:43,789 --> 01:26:52,619
which is just really bad like that's

1544
01:26:47,430 --> 01:26:55,170
just super duplicant I I mean we can

1545
01:26:52,619 --> 01:26:58,619
certainly do it in place but it would be

1546
01:26:55,170 --> 01:27:01,319
so expensive that it you wouldn't want

1547
01:26:58,619 --> 01:27:03,029
to write I was hoping we would find some

1548
01:27:01,319 --> 01:27:05,429
way of just cleverly doing it so you

1549
01:27:03,029 --> 01:27:08,059
didn't ever move more than the number of

1550
01:27:05,430 --> 01:27:11,150
items you know just going through but I

1551
01:27:08,060 --> 01:27:11,150
don't know

1552
01:27:21,630 --> 01:27:25,659
but yeah who knows maybe there's still

1553
01:27:24,158 --> 01:27:27,219
something clever out there I don't know

1554
01:27:25,658 --> 01:27:28,599
it depends if anyone's proved anything

1555
01:27:27,219 --> 01:27:29,859
about it it could be that maybe we could

1556
01:27:28,600 --> 01:27:30,969
come up with something very clever that

1557
01:27:29,859 --> 01:27:33,899
people haven't thought of yet and it

1558
01:27:30,969 --> 01:27:33,899
would just work I don't know

1559
01:27:48,130 --> 01:27:52,670
but yeah I mean if I ever think of

1560
01:27:50,988 --> 01:27:54,829
something and I'm like oh here's a way

1561
01:27:52,670 --> 01:28:02,630
we could cleverly do that then I'll you

1562
01:27:54,829 --> 01:28:06,430
know we'll do it on a future strain all

1563
01:28:02,630 --> 01:28:10,039
right I'm going to wrap it up here as

1564
01:28:06,430 --> 01:28:11,780
you can see very very easy to write it

1565
01:28:10,039 --> 01:28:13,819
as I sort of show to the very beginning

1566
01:28:11,779 --> 01:28:18,469
very very easy to write it if you have

1567
01:28:13,819 --> 01:28:21,079
if you don't care about temp memory very

1568
01:28:18,470 --> 01:28:23,480
very hard to write it if you do want to

1569
01:28:21,079 --> 01:28:25,609
be efficient I couldn't figure out an

1570
01:28:23,479 --> 01:28:29,809
efficient way to write it without with

1571
01:28:25,609 --> 01:28:36,139
that temp so but then we haven't spent

1572
01:28:29,810 --> 01:28:44,660
that much time so I don't know all right

1573
01:28:36,140 --> 01:28:45,739
let's wind down thank you everyone for

1574
01:28:44,659 --> 01:28:47,539
joining me for an episode of handmade

1575
01:28:45,738 --> 01:28:48,979
here so I'm pleasure coding with URL you

1576
01:28:47,539 --> 01:28:51,170
as always unfortunately we couldn't

1577
01:28:48,979 --> 01:28:54,500
figure out any efficient in place merge

1578
01:28:51,170 --> 01:28:57,890
sort maybe one doesn't exist but maybe

1579
01:28:54,500 --> 01:28:59,988
one does and we just didn't think of the

1580
01:28:57,890 --> 01:29:01,430
right way to do it so you know we've got

1581
01:28:59,988 --> 01:29:02,809
the weekend to think about it if anyone

1582
01:29:01,430 --> 01:29:04,760
comes up with a particularly clever way

1583
01:29:02,810 --> 01:29:09,560
of doing it but does not involve a block

1584
01:29:04,760 --> 01:29:13,220
move every time we get to an item that's

1585
01:29:09,560 --> 01:29:14,840
out of place uh maybe posts on the

1586
01:29:13,220 --> 01:29:16,730
forums and maybe we'll figure out

1587
01:29:14,840 --> 01:29:18,140
something interesting or maybe we just

1588
01:29:16,729 --> 01:29:19,759
need to search the web a little bit and

1589
01:29:18,140 --> 01:29:21,619
it turns out that you know it's just not

1590
01:29:19,760 --> 01:29:24,130
a top hit but someone has to get out a

1591
01:29:21,619 --> 01:29:27,289
really clever merge sort who knows

1592
01:29:24,130 --> 01:29:28,579
anyway that's it for today and that's it

1593
01:29:27,289 --> 01:29:30,050
for this week we'll be back next week

1594
01:29:28,579 --> 01:29:32,329
with with more handmade here obviously

1595
01:29:30,050 --> 01:29:34,460
if you want to follow along at home you

1596
01:29:32,329 --> 01:29:35,960
can always pre-order the game comes with

1597
01:29:34,460 --> 01:29:37,880
a source code so you can follow along at

1598
01:29:35,960 --> 01:29:39,739
home and you can do that on handmade

1599
01:29:37,880 --> 01:29:41,449
hero or you can also find links to our

1600
01:29:39,738 --> 01:29:43,699
forums we can ask questions or discuss

1601
01:29:41,449 --> 01:29:45,260
the series for example if you think you

1602
01:29:43,699 --> 01:29:46,909
figure it out a particularly clever way

1603
01:29:45,260 --> 01:29:49,010
to do merge sort that doesn't involve a

1604
01:29:46,909 --> 01:29:52,279
bunch of la copies that'd be the place

1605
01:29:49,010 --> 01:29:54,020
to do it and let us all know also a

1606
01:29:52,279 --> 01:29:56,149
patreon page you can a sports video

1607
01:29:54,020 --> 01:29:57,800
series if you like supporting the video

1608
01:29:56,149 --> 01:29:59,179
series soy is very much appreciated we

1609
01:29:57,800 --> 01:30:00,619
have a tweet papa tweet the schedule so

1610
01:29:59,180 --> 01:30:03,770
if you want to catch us live you know

1611
01:30:00,619 --> 01:30:05,090
in and we'll be back next week so check

1612
01:30:03,770 --> 01:30:07,790
the tweet but over the weekend for a

1613
01:30:05,090 --> 01:30:10,279
schedule probably will be 5 p.m. pacific

1614
01:30:07,789 --> 01:30:12,079
standard time again on monday until then

1615
01:30:10,279 --> 01:30:14,000
have a great weekend coding and i will

1616
01:30:12,079 --> 01:30:16,340
see you guys on the internet don't

1617
01:30:14,000 --> 01:30:17,750
forget to think about merge sort and and

1618
01:30:16,340 --> 01:30:19,930
we'll see you next week take it easy

1619
01:30:17,750 --> 01:30:19,930
everyone

