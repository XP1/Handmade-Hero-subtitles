1
00:00:06,500 --> 00:00:11,070
okay hello everyone and welcome handmade

2
00:00:09,179 --> 00:00:13,798
hero show recode a complete game live on

3
00:00:11,070 --> 00:00:16,618
stream we are just debugging the stuff

4
00:00:13,798 --> 00:00:18,809
we wrote yesterday which is Huffman

5
00:00:16,618 --> 00:00:21,868
decoder well it's two things actually

6
00:00:18,809 --> 00:00:24,419
it's a Huffman it's the thing that

7
00:00:21,868 --> 00:00:26,640
builds Huffman tables based on the PNG

8
00:00:24,420 --> 00:00:28,769
specs statement of how Huffman table

9
00:00:26,640 --> 00:00:33,509
should be built and then it's a Huffman

10
00:00:28,768 --> 00:00:35,488
decoder for those Huffman tables I of

11
00:00:33,509 --> 00:00:38,099
course don't know anything about the PNG

12
00:00:35,488 --> 00:00:40,859
spec so I am literally flying blind here

13
00:00:38,100 --> 00:00:43,379
just reading the spec but I did want to

14
00:00:40,859 --> 00:00:45,058
try to do it that way once first just so

15
00:00:43,378 --> 00:00:46,799
we could have one on stream where we go

16
00:00:45,058 --> 00:00:49,530
from the spec the only other time I

17
00:00:46,799 --> 00:00:53,218
think we ever did any file reading it

18
00:00:49,530 --> 00:00:55,558
was a BMP and I had read BMP files

19
00:00:53,219 --> 00:00:58,739
before also they're very simple they

20
00:00:55,558 --> 00:01:00,718
don't have that much of a spec so we

21
00:00:58,738 --> 00:01:02,878
never did a whole lot in terms of trying

22
00:01:00,719 --> 00:01:04,530
to get a spec working so I thought I'd

23
00:01:02,878 --> 00:01:06,989
at least try for a little while before

24
00:01:04,530 --> 00:01:09,540
looking at someone else's PNG reading

25
00:01:06,989 --> 00:01:11,969
code to see how far I could get just

26
00:01:09,540 --> 00:01:14,670
from the spec the spec is not great I

27
00:01:11,969 --> 00:01:16,408
will say it doesn't really talk about

28
00:01:14,670 --> 00:01:18,810
things I would like it to talk about in

29
00:01:16,409 --> 00:01:21,030
a number of places and again that's

30
00:01:18,810 --> 00:01:23,159
really mostly because P&amp;G just refers to

31
00:01:21,030 --> 00:01:25,170
the deflate spec and the deflate spec

32
00:01:23,159 --> 00:01:26,820
kind of doesn't really say everything

33
00:01:25,170 --> 00:01:30,950
that I would want it to say about like

34
00:01:26,819 --> 00:01:33,809
Indian this and stuff like that but

35
00:01:30,950 --> 00:01:36,329
they're not awful I've read some pretty

36
00:01:33,810 --> 00:01:38,009
bad specs in the past ones where I think

37
00:01:36,328 --> 00:01:39,539
you might say you have no hope of

38
00:01:38,009 --> 00:01:41,189
actually using the spec to decode the

39
00:01:39,540 --> 00:01:43,680
thing and I've had to really just kind

40
00:01:41,188 --> 00:01:46,019
of black box it and do a lot of like

41
00:01:43,680 --> 00:01:48,360
poking and prodding so this is not that

42
00:01:46,019 --> 00:01:51,539
kind of spec this is still a decent spec

43
00:01:48,359 --> 00:01:53,280
it's just not you know a great one we're

44
00:01:51,540 --> 00:01:54,899
you know where anybody can just show up

45
00:01:53,280 --> 00:01:56,759
and write it you kind of need a little

46
00:01:54,899 --> 00:01:58,170
bit of finesse on this one so I'm not

47
00:01:56,759 --> 00:01:59,430
really looking forward to this debugging

48
00:01:58,170 --> 00:02:02,040
process cause I do think it'll be a

49
00:01:59,430 --> 00:02:04,229
little bit laborious but it's certainly

50
00:02:02,040 --> 00:02:05,759
better than a lot of specs out there so

51
00:02:04,228 --> 00:02:07,530
you know consider this a

52
00:02:05,759 --> 00:02:09,659
middle-of-the-road kind of an experience

53
00:02:07,530 --> 00:02:12,870
this is definitely you can get a lot

54
00:02:09,659 --> 00:02:13,659
worse than what we're about to do all

55
00:02:12,870 --> 00:02:15,909
right so

56
00:02:13,659 --> 00:02:18,129
if you remember where we left off we

57
00:02:15,909 --> 00:02:20,109
just left off trying to figure out how

58
00:02:18,129 --> 00:02:22,659
we would sort of go about knowing

59
00:02:20,110 --> 00:02:25,180
whether we have this right at all and so

60
00:02:22,659 --> 00:02:27,639
if we come back to sort of the beginning

61
00:02:25,180 --> 00:02:30,760
here and just walk a little bit through

62
00:02:27,639 --> 00:02:32,889
the code I kind of want to explain how

63
00:02:30,759 --> 00:02:36,719
we're sort of approaching this here now

64
00:02:32,889 --> 00:02:40,899
we read an AI bat header out of the PNG

65
00:02:36,719 --> 00:02:43,270
that well actually I should say we read

66
00:02:40,900 --> 00:02:45,129
all the AI datte headers out of the PNG

67
00:02:43,270 --> 00:02:48,010
and we don't really do anything with

68
00:02:45,129 --> 00:02:50,259
them we just chain them together into

69
00:02:48,009 --> 00:02:52,509
sort of a linked list that we can then

70
00:02:50,259 --> 00:02:54,219
traverse when we wish to read them later

71
00:02:52,509 --> 00:02:56,459
now the reason that I did that is

72
00:02:54,219 --> 00:02:58,900
because I wasn't super sure that all

73
00:02:56,460 --> 00:03:01,090
writers would follow the thing that was

74
00:02:58,900 --> 00:03:03,610
in the spec the thing that's in the spec

75
00:03:01,090 --> 00:03:05,409
specifically states that I that chunks

76
00:03:03,610 --> 00:03:07,840
have to come one right after another

77
00:03:05,409 --> 00:03:10,060
that's exactly the kind of thing that I

78
00:03:07,840 --> 00:03:12,640
don't expect all writers to follow

79
00:03:10,060 --> 00:03:15,009
because writers do all kinds of crazy

80
00:03:12,639 --> 00:03:17,079
stuff so I just figured it's easy enough

81
00:03:15,009 --> 00:03:19,689
for us to just remember where these are

82
00:03:17,080 --> 00:03:22,000
and then traverse through them later

83
00:03:19,689 --> 00:03:24,039
that way if someone does hand as a PNG

84
00:03:22,000 --> 00:03:26,740
where the IDA chunks aren't contiguous

85
00:03:24,039 --> 00:03:28,780
we can handle it plus since we already

86
00:03:26,740 --> 00:03:30,520
know that there's this gunk in between

87
00:03:28,780 --> 00:03:32,709
them we know we would have had to do

88
00:03:30,520 --> 00:03:34,330
work to chain them together anyway so

89
00:03:32,709 --> 00:03:36,219
it's pretty straightforward to just go

90
00:03:34,330 --> 00:03:38,200
ahead and build the linked list then

91
00:03:36,219 --> 00:03:39,609
walk back through them since we read the

92
00:03:38,199 --> 00:03:41,889
whole file as a chunk anyway it's not

93
00:03:39,610 --> 00:03:43,720
like we're issuing extra reads Plus this

94
00:03:41,889 --> 00:03:45,789
isn't going to be a fast PNG reader

95
00:03:43,719 --> 00:03:47,979
either way because we're doing bit at a

96
00:03:45,789 --> 00:03:49,989
time reading here which is not

97
00:03:47,979 --> 00:03:52,899
particularly efficient so just in

98
00:03:49,989 --> 00:03:54,789
general this is I think fine it's a more

99
00:03:52,900 --> 00:03:57,370
flexible way to do it and we're not

100
00:03:54,789 --> 00:04:01,449
going for a world record here or even a

101
00:03:57,370 --> 00:04:03,849
medium record so anyway when we get here

102
00:04:01,449 --> 00:04:06,159
to look at the INA chunks what we are

103
00:04:03,849 --> 00:04:08,409
looking at is some basic startup

104
00:04:06,159 --> 00:04:10,689
information and the way that we're

105
00:04:08,409 --> 00:04:12,669
consuming bits outside of the Huffman I

106
00:04:10,689 --> 00:04:15,159
think is correct the reason I say that

107
00:04:12,669 --> 00:04:17,620
is because this part looks sensible to

108
00:04:15,159 --> 00:04:20,290
us we are getting a reasonable B final

109
00:04:17,620 --> 00:04:22,990
in a reasonable B type when we read in

110
00:04:20,290 --> 00:04:25,330
the first and then second third bits to

111
00:04:22,990 --> 00:04:27,540
build those two values so I think our

112
00:04:25,329 --> 00:04:31,050
assumption and also the spec said they

113
00:04:27,540 --> 00:04:33,240
that we are looking at LS be like least

114
00:04:31,050 --> 00:04:36,360
significant bit at a time bit

115
00:04:33,240 --> 00:04:39,180
consumption is correct for everything

116
00:04:36,360 --> 00:04:42,000
outside the Huffman codes and so when we

117
00:04:39,180 --> 00:04:45,750
look through this part I feel like that

118
00:04:42,000 --> 00:04:47,899
probably worked okay I do say probably

119
00:04:45,750 --> 00:04:51,449
worked okay because I don't really know

120
00:04:47,899 --> 00:04:53,399
but I think there's a chance that this

121
00:04:51,449 --> 00:04:55,259
part is working correctly and then we

122
00:04:53,399 --> 00:04:56,250
don't need to look at it too much after

123
00:04:55,259 --> 00:04:58,500
that

124
00:04:56,250 --> 00:05:01,769
so what we can see here when we get down

125
00:04:58,500 --> 00:05:02,189
to the B type 2 which is what I expected

126
00:05:01,769 --> 00:05:05,599
to see

127
00:05:02,189 --> 00:05:09,540
turns out we will need to do this one

128
00:05:05,600 --> 00:05:11,850
probably because as as Martins pointed

129
00:05:09,540 --> 00:05:14,520
out yesterday although I misread the

130
00:05:11,850 --> 00:05:16,230
spec on PNG when it when I thought they

131
00:05:14,519 --> 00:05:18,750
were saying that deflate would only ever

132
00:05:16,230 --> 00:05:21,930
use B type 2 I think they are actually

133
00:05:18,750 --> 00:05:25,199
saying that they can use B type 2 or B

134
00:05:21,930 --> 00:05:26,519
type 1 I think I think Martin's was

135
00:05:25,199 --> 00:05:28,170
absolutely right about that when we went

136
00:05:26,519 --> 00:05:31,529
back and looked at the section 10 one of

137
00:05:28,170 --> 00:05:33,120
the spec it did seem to say that so for

138
00:05:31,529 --> 00:05:35,279
right now though we're only looking at B

139
00:05:33,120 --> 00:05:37,199
type twos we don't have any data it's in

140
00:05:35,279 --> 00:05:39,809
B type one so we just want to get B type

141
00:05:37,199 --> 00:05:43,500
two working B type one should in theory

142
00:05:39,810 --> 00:05:45,449
be basically the same it's just instead

143
00:05:43,500 --> 00:05:47,819
of doing these reads we would proceed

144
00:05:45,449 --> 00:05:50,490
our Huffman tables with stuff that we

145
00:05:47,819 --> 00:05:52,769
already know like basically hard-coded

146
00:05:50,490 --> 00:05:54,930
data from the spec that we just put in

147
00:05:52,769 --> 00:05:58,319
right so that's not going to be a huge

148
00:05:54,930 --> 00:05:59,970
deal to support B type one after we get

149
00:05:58,319 --> 00:06:01,920
B type two working it should be

150
00:05:59,970 --> 00:06:04,440
relatively straightforward but getting B

151
00:06:01,920 --> 00:06:08,879
type two working is going to be it's

152
00:06:04,439 --> 00:06:10,949
gonna be a grind so in here what I'm so

153
00:06:08,879 --> 00:06:13,379
what I'm trying to get at on the bit

154
00:06:10,949 --> 00:06:15,360
consumption thing is I believe these

155
00:06:13,379 --> 00:06:20,329
values are sensible then like I think

156
00:06:15,360 --> 00:06:23,490
this you know 29 29 14 is not a

157
00:06:20,329 --> 00:06:25,889
unreasonable set of values to get these

158
00:06:23,490 --> 00:06:28,280
are basically the huffman table set up

159
00:06:25,889 --> 00:06:31,199
values that were like they're just

160
00:06:28,279 --> 00:06:33,329
counts of stuff that we're supposed to

161
00:06:31,199 --> 00:06:37,918
get I think those are reasonable which

162
00:06:33,329 --> 00:06:39,839
again is just I think we're seeing the

163
00:06:37,918 --> 00:06:40,769
bit reading happening okay here but I

164
00:06:39,839 --> 00:06:43,439
don't know one of

165
00:06:40,769 --> 00:06:45,568
that one of the really bad parts about

166
00:06:43,439 --> 00:06:48,149
compressed data so this is sort of just

167
00:06:45,569 --> 00:06:50,098
a philosophical point is that compressed

168
00:06:48,149 --> 00:06:52,348
data the better the compression scheme

169
00:06:50,098 --> 00:06:54,598
the less possibility there is for

170
00:06:52,348 --> 00:06:56,310
clearly erroneous output if you imagine

171
00:06:54,598 --> 00:06:58,978
something that's an image compressor

172
00:06:56,310 --> 00:07:01,228
right it's producing an output stream

173
00:06:58,978 --> 00:07:03,418
and that output stream when you process

174
00:07:01,228 --> 00:07:07,128
it is supposed to produce images right

175
00:07:03,418 --> 00:07:09,359
well any possible way you can have

176
00:07:07,129 --> 00:07:11,539
nonsensical data in that output stream

177
00:07:09,360 --> 00:07:15,270
that does not lead to a correct image is

178
00:07:11,538 --> 00:07:18,269
effectively wasted information inside

179
00:07:15,269 --> 00:07:21,089
that bit stream right so the better and

180
00:07:18,269 --> 00:07:23,788
better a compressor gets the more likely

181
00:07:21,089 --> 00:07:26,989
you are to always see something that

182
00:07:23,788 --> 00:07:30,120
could be reasonable in the bit stream

183
00:07:26,990 --> 00:07:31,800
because all things that could show up in

184
00:07:30,120 --> 00:07:34,769
the bit stream will be reasonable right

185
00:07:31,800 --> 00:07:37,259
so you usually end up in this situation

186
00:07:34,769 --> 00:07:39,000
where once you get into things like when

187
00:07:37,259 --> 00:07:41,158
I'm only reading five bits at a time

188
00:07:39,000 --> 00:07:44,610
it's pretty hard to get a ridiculous

189
00:07:41,158 --> 00:07:47,339
value I can't get four billion coming

190
00:07:44,610 --> 00:07:49,620
out of a five bit read/write because if

191
00:07:47,339 --> 00:07:51,750
I got five billion four billion coming

192
00:07:49,620 --> 00:07:54,120
out of a five bit read something really

193
00:07:51,750 --> 00:07:56,819
bad has happened but if we'd actually

194
00:07:54,120 --> 00:07:59,370
read an entire u-32 from the data stream

195
00:07:56,819 --> 00:08:01,710
in a fattie non compressed format and we

196
00:07:59,370 --> 00:08:04,288
saw four billion that's a real good

197
00:08:01,709 --> 00:08:06,870
clear indicator that we screwed up the

198
00:08:04,288 --> 00:08:08,759
parsing further upstream and we know

199
00:08:06,870 --> 00:08:12,300
where to start looking for our error

200
00:08:08,759 --> 00:08:13,979
right so one of the big problems with

201
00:08:12,300 --> 00:08:15,750
compressed data and it's not a problem

202
00:08:13,978 --> 00:08:18,028
in the sense that somehow they're bad

203
00:08:15,750 --> 00:08:19,889
it's just for development purposes when

204
00:08:18,028 --> 00:08:22,560
you're writing the decoder for a

205
00:08:19,889 --> 00:08:25,228
compressed stream knowing when you

206
00:08:22,560 --> 00:08:27,870
screwed up gets much harder because you

207
00:08:25,228 --> 00:08:29,879
don't actually know whether a value is

208
00:08:27,870 --> 00:08:32,250
reasonable or not because most of them

209
00:08:29,879 --> 00:08:34,078
will look reasonable even if they aren't

210
00:08:32,250 --> 00:08:36,778
that's just what happens when you can

211
00:08:34,078 --> 00:08:39,718
only read values from 0 to 32 they're

212
00:08:36,778 --> 00:08:43,679
all probably reasonable right so that's

213
00:08:39,719 --> 00:08:48,480
sort of what goes on there right ok

214
00:08:43,679 --> 00:08:52,169
so if we keep going forwards down down

215
00:08:48,480 --> 00:08:54,930
through this process again no real way

216
00:08:52,169 --> 00:08:57,959
to know whether our h.glenn team

217
00:08:54,929 --> 00:09:00,929
got set up correctly but it looks again

218
00:08:57,960 --> 00:09:05,850
like something that could plausibly have

219
00:09:00,929 --> 00:09:07,589
happened right you know is it is it

220
00:09:05,850 --> 00:09:09,779
ironclad proof that this got read

221
00:09:07,590 --> 00:09:14,040
correctly absolutely not

222
00:09:09,779 --> 00:09:18,679
is it obviously wrong no right so I feel

223
00:09:14,039 --> 00:09:20,730
like this h.glenn table could be okay

224
00:09:18,679 --> 00:09:25,169
all right

225
00:09:20,730 --> 00:09:27,480
so we know that these H this part of the

226
00:09:25,169 --> 00:09:30,539
the huffman table built here where we

227
00:09:27,480 --> 00:09:32,370
have eight bits worth of possible

228
00:09:30,539 --> 00:09:35,519
Huffman code right that we know because

229
00:09:32,370 --> 00:09:38,129
basically every symbol that we read

230
00:09:35,519 --> 00:09:41,220
could be encoded in up to eight bits

231
00:09:38,129 --> 00:09:43,889
that was just the determination from

232
00:09:41,220 --> 00:09:47,269
looking at what these values could come

233
00:09:43,889 --> 00:09:53,009
out to be if that makes sense

234
00:09:47,269 --> 00:09:56,750
basically the the HDL end table here

235
00:09:53,009 --> 00:10:00,090
that we build our codes for seven here

236
00:09:56,750 --> 00:10:03,330
is sort of on the high end you can't

237
00:10:00,090 --> 00:10:05,399
have like a nine or ten bit value in

238
00:10:03,330 --> 00:10:07,680
these code lengths and the way that we

239
00:10:05,399 --> 00:10:10,740
know that is because when we actually

240
00:10:07,679 --> 00:10:13,919
read these bits in we're only reading in

241
00:10:10,740 --> 00:10:17,100
three bits for the length so even if the

242
00:10:13,919 --> 00:10:20,429
all the bits are set we can never really

243
00:10:17,100 --> 00:10:22,500
get to eight bits of code length now why

244
00:10:20,429 --> 00:10:24,209
didn't they just add one to it so we can

245
00:10:22,500 --> 00:10:26,779
get to eight bits of code length the

246
00:10:24,210 --> 00:10:29,460
reason is because they do need zero

247
00:10:26,779 --> 00:10:31,559
because they specifically said in the

248
00:10:29,460 --> 00:10:34,230
spec that the h.glenn table will contain

249
00:10:31,559 --> 00:10:37,769
zeros in the places where things aren't

250
00:10:34,230 --> 00:10:39,960
used so we know that we're zero to seven

251
00:10:37,769 --> 00:10:42,899
number of bits so that means that in

252
00:10:39,960 --> 00:10:43,980
here eight bits of Huffman is more than

253
00:10:42,899 --> 00:10:46,829
enough to do it

254
00:10:43,980 --> 00:10:49,500
in fact now I think about it seven bits

255
00:10:46,830 --> 00:10:53,690
of Huffman is really more than enough to

256
00:10:49,500 --> 00:10:53,690
do it we don't actually need the eight

257
00:10:53,809 --> 00:11:02,669
so that's actually not necessary this is

258
00:10:58,500 --> 00:11:04,919
this doesn't affect our behavior in the

259
00:11:02,669 --> 00:11:06,360
code at all because let me go ahead and

260
00:11:04,919 --> 00:11:08,689
switch over to one that's not have my

261
00:11:06,360 --> 00:11:08,690
head in the way

262
00:11:08,840 --> 00:11:13,290
we can set this number to really

263
00:11:11,159 --> 00:11:16,079
anything and it just makes our table

264
00:11:13,289 --> 00:11:18,659
bigger but we don't actually need 8 bits

265
00:11:16,080 --> 00:11:21,870
because if the longest code sequence we

266
00:11:18,659 --> 00:11:25,169
could see is 7 bits long then I think we

267
00:11:21,870 --> 00:11:27,120
don't ever really need the 8 there so I

268
00:11:25,169 --> 00:11:28,469
think technically and let me just double

269
00:11:27,120 --> 00:11:30,389
check that that's true I think

270
00:11:28,470 --> 00:11:33,090
technically we'd be fine through the

271
00:11:30,389 --> 00:11:36,179
compute half Minh there we would never

272
00:11:33,090 --> 00:11:38,030
hit an assertion at 7 because these only

273
00:11:36,179 --> 00:11:43,919
reading 3 bits and we can never have a

274
00:11:38,029 --> 00:11:46,139
code length of of 8 so anyway we then

275
00:11:43,919 --> 00:11:47,579
have the the compute - stuff which I'm

276
00:11:46,139 --> 00:11:49,110
gonna go ahead and step into here I

277
00:11:47,580 --> 00:11:50,610
don't know why I can't set a break on

278
00:11:49,110 --> 00:11:53,669
that line we're not compiling in release

279
00:11:50,610 --> 00:11:59,759
mode are we we're into we're in debug

280
00:11:53,669 --> 00:12:01,079
mode I do not know why I cannot why

281
00:11:59,759 --> 00:12:02,069
didn't it let me set a breakpoint

282
00:12:01,080 --> 00:12:03,860
I don't know why I wouldn't let me set a

283
00:12:02,070 --> 00:12:07,140
break down that line just Visual Studio

284
00:12:03,860 --> 00:12:10,169
fantasticness I guess anyway if we step

285
00:12:07,139 --> 00:12:13,019
into the compute huffman this is the

286
00:12:10,169 --> 00:12:16,500
part that we wrote yesterday again just

287
00:12:13,019 --> 00:12:18,179
flying blind from the spec I just trying

288
00:12:16,500 --> 00:12:20,159
to suss out what it was telling us in

289
00:12:18,179 --> 00:12:22,859
sear we've got this code length

290
00:12:20,159 --> 00:12:25,769
histogram and all our first loop does is

291
00:12:22,860 --> 00:12:28,740
count the values that we're gonna

292
00:12:25,769 --> 00:12:30,929
actually count how many times we see

293
00:12:28,740 --> 00:12:33,659
each individual code length so when we

294
00:12:30,929 --> 00:12:35,549
get through here as you can see we now

295
00:12:33,659 --> 00:12:38,610
have a histogram that tells us

296
00:12:35,549 --> 00:12:42,599
everything that we saw so you know we've

297
00:12:38,610 --> 00:12:45,600
got three zeros three five threes three

298
00:12:42,600 --> 00:12:48,269
fives four sevens and obviously nothing

299
00:12:45,600 --> 00:12:49,920
up here because the it can't ever hit

300
00:12:48,269 --> 00:12:52,799
eight or above in this particular

301
00:12:49,919 --> 00:12:58,279
Huffman again because it's only a three

302
00:12:52,799 --> 00:13:00,990
bit read so here we initialize that the

303
00:12:58,279 --> 00:13:02,429
zero away to zero and the reason for

304
00:13:00,990 --> 00:13:04,049
that is that we're specifically saying

305
00:13:02,429 --> 00:13:06,419
we're never allocating any codes to

306
00:13:04,049 --> 00:13:07,799
encode things that don't show up so we

307
00:13:06,419 --> 00:13:11,370
clear that one out and we set our next

308
00:13:07,799 --> 00:13:14,819
unused code we then go through here and

309
00:13:11,370 --> 00:13:19,519
what we do here is we each step of the

310
00:13:14,820 --> 00:13:25,280
way sort of assign the Huffman bits to

311
00:13:19,519 --> 00:13:28,669
let me show that there it is a sign the

312
00:13:25,279 --> 00:13:30,620
starting value to each of the huffman

313
00:13:28,669 --> 00:13:32,179
counts so for example four code lengths

314
00:13:30,620 --> 00:13:35,570
count three those are gonna start at

315
00:13:32,179 --> 00:13:38,659
zero and then fours are gonna start at

316
00:13:35,570 --> 00:13:40,220
10 5s gonna start at 28 and what that's

317
00:13:38,659 --> 00:13:43,639
doing is it's just leaving space for

318
00:13:40,220 --> 00:13:47,509
however many of the Huffman's we we saw

319
00:13:43,639 --> 00:13:49,460
right when we say we've seen X number of

320
00:13:47,509 --> 00:13:52,580
threes we need to leave that many

321
00:13:49,460 --> 00:13:55,129
Huffman codes available that many bit

322
00:13:52,580 --> 00:13:57,500
patterns basically available before we

323
00:13:55,129 --> 00:13:59,419
start assigning ones to fours 5 6 and so

324
00:13:57,500 --> 00:14:01,220
on right and again this is us just

325
00:13:59,419 --> 00:14:03,589
following the spec this is basically

326
00:14:01,220 --> 00:14:05,870
what the spec told us to do now we don't

327
00:14:03,590 --> 00:14:09,230
know if we did it right but you know

328
00:14:05,870 --> 00:14:11,600
this wasn't my doing that's just how

329
00:14:09,230 --> 00:14:14,960
they wanted to assign Huffman code so

330
00:14:11,600 --> 00:14:18,259
that's how we're doing it right somebody

331
00:14:14,960 --> 00:14:22,100
was saying we had a less than bug in

332
00:14:18,259 --> 00:14:26,710
here I'm sorry I don't remember ink

333
00:14:22,100 --> 00:14:31,009
valve is saying it may be your I

334
00:14:26,710 --> 00:14:33,680
promised I would look at it but I can't

335
00:14:31,009 --> 00:14:36,110
remember who said it so let me just look

336
00:14:33,679 --> 00:14:39,139
back here it is yeah it was available I

337
00:14:36,110 --> 00:14:40,490
think there is a type typo in the code

338
00:14:39,139 --> 00:14:42,199
you copied from the standard you have a

339
00:14:40,490 --> 00:14:44,899
less than instead of a less than or

340
00:14:42,200 --> 00:14:47,060
equal to we didn't really copy any code

341
00:14:44,899 --> 00:14:48,889
from the standard but we translated code

342
00:14:47,059 --> 00:14:50,329
from the standard in a sense so I'm

343
00:14:48,889 --> 00:14:52,000
assuming this is the part we're talking

344
00:14:50,330 --> 00:14:54,620
about cuz I'm not sure what other part

345
00:14:52,000 --> 00:14:58,279
we copied maybe it's the part later

346
00:14:54,620 --> 00:14:59,269
further down he's talking about cuz I

347
00:14:58,279 --> 00:15:01,850
don't know that there is a less than

348
00:14:59,269 --> 00:15:07,340
here we have some less dense that are

349
00:15:01,850 --> 00:15:07,850
search related but that's probably not

350
00:15:07,340 --> 00:15:09,410
what he meant

351
00:15:07,850 --> 00:15:12,290
so maybe he means the code a little

352
00:15:09,409 --> 00:15:15,679
further out I'm not sure that's that's

353
00:15:12,289 --> 00:15:16,849
yeah I don't know anyway let me finish

354
00:15:15,679 --> 00:15:18,289
going through this code server is on the

355
00:15:16,850 --> 00:15:20,420
same page and then we'll go to the next

356
00:15:18,289 --> 00:15:22,309
one so this part is the part we really

357
00:15:20,419 --> 00:15:24,439
just don't know this is the part where I

358
00:15:22,309 --> 00:15:26,119
kind of just was like I'm not sure what

359
00:15:24,440 --> 00:15:29,540
they mean here so we're kind of just in

360
00:15:26,120 --> 00:15:33,409
like trial and error mode so what they

361
00:15:29,539 --> 00:15:36,379
said was that when you take a code

362
00:15:33,409 --> 00:15:41,719
from the huffman table what you need to

363
00:15:36,379 --> 00:15:44,509
do is the huffman bits unlike all the

364
00:15:41,720 --> 00:15:48,290
rest of the bits are going to come in

365
00:15:44,509 --> 00:15:52,129
with their most significant byte at the

366
00:15:48,289 --> 00:15:55,490
bottom right now I don't know what they

367
00:15:52,129 --> 00:15:58,250
meant by that because there's two ways

368
00:15:55,490 --> 00:15:58,909
that I could believe you to mean that

369
00:15:58,250 --> 00:16:02,240
right

370
00:15:58,909 --> 00:16:04,939
one thing you could have meant was that

371
00:16:02,240 --> 00:16:07,060
you just are writing Huffman codes this

372
00:16:04,940 --> 00:16:10,100
way which means that this routine

373
00:16:07,059 --> 00:16:12,919
already takes that into account and is

374
00:16:10,100 --> 00:16:14,500
assigning codes the way you wanted them

375
00:16:12,919 --> 00:16:18,019
assigned for the way they were read in

376
00:16:14,500 --> 00:16:20,629
right because nothing here says I mean a

377
00:16:18,019 --> 00:16:24,559
Huffman code doesn't have a notion of

378
00:16:20,629 --> 00:16:27,139
most significant that I can like I don't

379
00:16:24,559 --> 00:16:29,869
I'm not a compression guy I don't know

380
00:16:27,139 --> 00:16:33,409
that a Huffman code has anything other

381
00:16:29,870 --> 00:16:37,610
than just first bit right like there's

382
00:16:33,409 --> 00:16:39,649
the bit that comes in first and that bit

383
00:16:37,610 --> 00:16:41,509
tells you whether you keep going on the

384
00:16:39,649 --> 00:16:43,399
Huffman or not sometimes not sometimes

385
00:16:41,509 --> 00:16:45,830
you read two bits in right it depends

386
00:16:43,399 --> 00:16:47,480
how many but those first n bits tell you

387
00:16:45,830 --> 00:16:49,430
whether to like output a symbol or keep

388
00:16:47,480 --> 00:16:52,300
going then the next n bits tell you to

389
00:16:49,429 --> 00:16:54,649
output a symbol or keep going right most

390
00:16:52,299 --> 00:16:56,649
significant I don't know what they meant

391
00:16:54,649 --> 00:17:00,860
by that because there's not a

392
00:16:56,649 --> 00:17:02,090
significant to its part maybe you think

393
00:17:00,860 --> 00:17:04,039
the most significant one is the one that

394
00:17:02,090 --> 00:17:07,160
gets decided on first that would that's

395
00:17:04,039 --> 00:17:10,399
my guess right but I don't know because

396
00:17:07,160 --> 00:17:14,029
that's not really explained so I don't

397
00:17:10,400 --> 00:17:15,769
know so looking through here let's see

398
00:17:14,029 --> 00:17:17,329
if they say it explicitly because it's

399
00:17:15,769 --> 00:17:18,619
been a while since we read this and

400
00:17:17,329 --> 00:17:21,949
let's read it with that in mind because

401
00:17:18,619 --> 00:17:23,479
this was where we've gotten to so given

402
00:17:21,950 --> 00:17:25,220
this rule we can define the Huffman code

403
00:17:23,480 --> 00:17:26,569
for an alphabet just by giving the bit

404
00:17:25,220 --> 00:17:30,319
lengths of the codes for each symbol of

405
00:17:26,569 --> 00:17:32,089
the alphabet in order so that's what

406
00:17:30,319 --> 00:17:33,799
we're processing this is sufficient to

407
00:17:32,089 --> 00:17:35,779
determine the actual codes in our

408
00:17:33,799 --> 00:17:38,119
example the code is completely defined

409
00:17:35,779 --> 00:17:40,099
by the sequence of bit lengths to 133

410
00:17:38,119 --> 00:17:42,349
the following algorithm generates the

411
00:17:40,099 --> 00:17:46,699
codes as integers intended to be read

412
00:17:42,349 --> 00:17:49,939
from most to least significant bit so

413
00:17:46,700 --> 00:17:54,850
oh so I'm assuming that that means is

414
00:17:49,940 --> 00:17:57,980
this is producing the integers the most

415
00:17:54,849 --> 00:18:01,819
significant bit is that comes out of

416
00:17:57,980 --> 00:18:02,420
this is the one that will come first in

417
00:18:01,819 --> 00:18:05,119
the bitstream

418
00:18:02,420 --> 00:18:06,920
that's how I'm interpreting that the

419
00:18:05,119 --> 00:18:08,419
code links are initially in tree land

420
00:18:06,920 --> 00:18:11,330
the codes are produced in tree code

421
00:18:08,420 --> 00:18:14,210
right yes

422
00:18:11,329 --> 00:18:17,240
consider the alphabet abcdefg with bit

423
00:18:14,210 --> 00:18:18,650
length 3 3 3 3 3 to 4 4 your step 1 we

424
00:18:17,240 --> 00:18:23,000
have this I'm just a barman effort right

425
00:18:18,650 --> 00:18:24,470
ok this code okay so I'm assuming that

426
00:18:23,000 --> 00:18:26,359
they're writing this with the most

427
00:18:24,470 --> 00:18:28,009
significant bit here and the Leeson it

428
00:18:26,359 --> 00:18:30,409
again fit here and what they're saying

429
00:18:28,009 --> 00:18:33,470
is this will come first in the bitstream

430
00:18:30,410 --> 00:18:39,890
and then this and then this and then

431
00:18:33,470 --> 00:18:44,390
this right that's what I'm assuming okay

432
00:18:39,890 --> 00:18:46,730
and then on top of that where I'm coming

433
00:18:44,390 --> 00:18:48,620
from with the bit most significantly

434
00:18:46,730 --> 00:18:53,410
significant was the other part in the

435
00:18:48,619 --> 00:18:53,409
deflate spec which was up here somewhere

436
00:18:53,920 --> 00:19:00,200
trust me it was here here we go

437
00:18:55,970 --> 00:19:01,610
that said everything's LSB right up to

438
00:19:00,200 --> 00:19:06,259
the Huffman codes which are sir

439
00:19:01,609 --> 00:19:08,809
suddenly MSB right so the Huffman codes

440
00:19:06,259 --> 00:19:11,829
get read differently from everybody else

441
00:19:08,809 --> 00:19:21,230
that's how I took that to be to be

442
00:19:11,829 --> 00:19:29,210
specifying right okay so I given that

443
00:19:21,230 --> 00:19:32,329
fact our task now the first thing I want

444
00:19:29,210 --> 00:19:34,400
to do you cigaratte whether I actually

445
00:19:32,329 --> 00:19:36,289
constructed the table properly when we

446
00:19:34,400 --> 00:19:38,570
read that part and decided we had to

447
00:19:36,289 --> 00:19:40,399
invert this thing here because this was

448
00:19:38,569 --> 00:19:43,279
sort of as we were working through that

449
00:19:40,400 --> 00:19:44,720
I you know I just said okay let's do a

450
00:19:43,279 --> 00:19:48,529
simple thing in here to reverse the bits

451
00:19:44,720 --> 00:19:52,100
as a test right so as we go through our

452
00:19:48,529 --> 00:19:55,730
entries this will this base index here

453
00:19:52,099 --> 00:19:58,519
that we'll construct I believe the entry

454
00:19:55,730 --> 00:20:01,039
into the Huffman table as if the bits

455
00:19:58,519 --> 00:20:03,259
were read LSB first now why they didn't

456
00:20:01,039 --> 00:20:04,730
write them LSB first I don't know right

457
00:20:03,259 --> 00:20:06,619
it seems to me like if everything else

458
00:20:04,730 --> 00:20:09,890
was LSB why wouldn't you leave the

459
00:20:06,619 --> 00:20:12,919
Huffman says LSB there's must be a

460
00:20:09,890 --> 00:20:15,830
reason for that somewhere I don't know

461
00:20:12,920 --> 00:20:18,320
what it is maybe that's because of my

462
00:20:15,829 --> 00:20:20,240
naivete with compression right I'm not a

463
00:20:18,319 --> 00:20:21,529
compression person so it might just be

464
00:20:20,240 --> 00:20:24,680
that there's like a really good reason

465
00:20:21,529 --> 00:20:26,480
for it and I just don't know what that

466
00:20:24,680 --> 00:20:30,789
reason is maybe it's because if you're

467
00:20:26,480 --> 00:20:30,789
consuming it literally a bit at a time

468
00:20:32,920 --> 00:20:37,039
no I don't know why cuz it seems to me

469
00:20:35,720 --> 00:20:39,380
like the right way to do it is just

470
00:20:37,039 --> 00:20:41,389
right your Huffman generator so that the

471
00:20:39,380 --> 00:20:43,760
least significant bit is the one you

472
00:20:41,390 --> 00:20:45,530
start with it just seems to me like

473
00:20:43,759 --> 00:20:46,819
they've done it backwards like just have

474
00:20:45,529 --> 00:20:49,339
everything LSB and just make your

475
00:20:46,819 --> 00:20:51,169
Huffman's LSB but I yeah I don't know I

476
00:20:49,339 --> 00:20:53,889
maybe I'm just missing the special sauce

477
00:20:51,170 --> 00:20:57,680
there so anyway when I come through here

478
00:20:53,890 --> 00:20:59,390
I've got the base index and I'm gonna

479
00:20:57,680 --> 00:21:00,650
generate the index off of the base index

480
00:20:59,390 --> 00:21:02,000
by flipping the bits around it's not

481
00:21:00,650 --> 00:21:03,230
gonna do anything for zero because

482
00:21:02,000 --> 00:21:04,490
there's a bits are the same at zero

483
00:21:03,230 --> 00:21:06,170
either way there's no such thing as a

484
00:21:04,490 --> 00:21:07,788
most significant at least leave me a bit

485
00:21:06,170 --> 00:21:09,200
when none of the bits are set

486
00:21:07,788 --> 00:21:12,528
so it don't matter but we flip it around

487
00:21:09,200 --> 00:21:14,058
completely and we tested that code and

488
00:21:12,528 --> 00:21:15,409
actually made sure it worked and then

489
00:21:14,058 --> 00:21:18,319
we're just gonna enter our thing into

490
00:21:15,409 --> 00:21:20,239
the huffman table reversed that way when

491
00:21:18,319 --> 00:21:23,118
we see the bits come in we don't

492
00:21:20,239 --> 00:21:25,608
actually have to figure out how to msb

493
00:21:23,118 --> 00:21:28,668
them our table just already flipped

494
00:21:25,608 --> 00:21:31,548
right so again that might be a stupid

495
00:21:28,669 --> 00:21:32,869
way to do this that's just what I did so

496
00:21:31,548 --> 00:21:35,210
that's how this code works and we can

497
00:21:32,868 --> 00:21:42,558
sort of see it working as well if we

498
00:21:35,210 --> 00:21:45,858
just look here the hex though in fact

499
00:21:42,558 --> 00:21:47,839
we've already got it right here so if

500
00:21:45,858 --> 00:21:51,470
you look at the the flipping of these

501
00:21:47,839 --> 00:21:53,478
right you can see that this one because

502
00:21:51,470 --> 00:21:56,058
there's only seven bits per Huffman code

503
00:21:53,479 --> 00:21:58,879
you can see here that the flip doesn't

504
00:21:56,058 --> 00:22:01,999
do anything for those right whereas the

505
00:21:58,878 --> 00:22:04,248
flip four here does it reverses around

506
00:22:01,999 --> 00:22:06,979
that center line right so there's the

507
00:22:04,249 --> 00:22:08,659
flip and yesterday it was flipping the

508
00:22:06,979 --> 00:22:10,069
whole thing that's because I had set the

509
00:22:08,659 --> 00:22:12,739
bit count to eight for some reason now

510
00:22:10,069 --> 00:22:14,239
it's only seven that again shouldn't

511
00:22:12,739 --> 00:22:17,119
affect our reading of the bit stream at

512
00:22:14,239 --> 00:22:18,829
all because the seven or the 8 is just

513
00:22:17,118 --> 00:22:20,778
how many bits we start with so we just

514
00:22:18,829 --> 00:22:22,788
need to flip relative to that when we

515
00:22:20,778 --> 00:22:24,019
look at it because remember we're going

516
00:22:22,788 --> 00:22:25,729
to be seeing the bits coming in the

517
00:22:24,019 --> 00:22:27,319
wrong order so we need to flip them

518
00:22:25,729 --> 00:22:31,509
around so that when we actually look at

519
00:22:27,319 --> 00:22:34,939
them we get the right answers there now

520
00:22:31,509 --> 00:22:37,970
my assumption and I could be very wrong

521
00:22:34,940 --> 00:22:41,960
about this but my assumption is that we

522
00:22:37,970 --> 00:22:45,528
can't actually do just this so what I

523
00:22:41,960 --> 00:22:47,960
because since we don't know how long the

524
00:22:45,528 --> 00:22:49,638
Huffman code is to begin with I'm not

525
00:22:47,960 --> 00:22:52,129
sure we can just flip it like that

526
00:22:49,638 --> 00:22:55,459
without changing the way our bits

527
00:22:52,128 --> 00:22:57,798
streamer actually streams in the bits so

528
00:22:55,460 --> 00:23:00,288
I'm concerned that what we actually have

529
00:22:57,798 --> 00:23:02,239
to do is flip our bit stream around and

530
00:23:00,288 --> 00:23:04,249
read them in that order or have some

531
00:23:02,239 --> 00:23:06,528
other fancy trick there so that's where

532
00:23:04,249 --> 00:23:09,440
we left off yesterday and what I want to

533
00:23:06,528 --> 00:23:13,128
do today now is actually work out on the

534
00:23:09,440 --> 00:23:15,349
blackboard how this has to work whether

535
00:23:13,128 --> 00:23:17,480
I can just flip and put it in the table

536
00:23:15,348 --> 00:23:19,278
or whether I need something fancier than

537
00:23:17,480 --> 00:23:21,589
that so what I want to do is work

538
00:23:19,278 --> 00:23:24,890
through an example basically

539
00:23:21,589 --> 00:23:27,769
to see whether or not the this actually

540
00:23:24,890 --> 00:23:30,460
can be done without changing without

541
00:23:27,769 --> 00:23:38,829
changing the reader into an MSB reader

542
00:23:30,460 --> 00:23:38,829
if that makes sense right okay so

543
00:23:56,039 --> 00:24:03,549
so what we want to look at now is let's

544
00:24:00,430 --> 00:24:05,320
suppose that we have something like the

545
00:24:03,549 --> 00:24:08,279
Huffman codes that we're looking at now

546
00:24:05,319 --> 00:24:11,980
what I want to know is is this table

547
00:24:08,279 --> 00:24:13,839
reverse if I reverse the table entries

548
00:24:11,980 --> 00:24:15,670
is that sufficient or does that produce

549
00:24:13,839 --> 00:24:17,709
wrong results after the first Huffman

550
00:24:15,670 --> 00:24:18,880
code because I confident will produce

551
00:24:17,710 --> 00:24:19,870
the correct results for the first

552
00:24:18,880 --> 00:24:21,580
Huffman code

553
00:24:19,869 --> 00:24:22,929
I don't know that'll produce correct

554
00:24:21,579 --> 00:24:24,699
results for every code thereafter

555
00:24:22,930 --> 00:24:26,320
because the shift be shifting in

556
00:24:24,700 --> 00:24:29,440
behavior may be wrong so that's what I'm

557
00:24:26,319 --> 00:24:31,689
trying to validate here so what we

558
00:24:29,440 --> 00:24:34,600
fundamentally have is we have a buffer

559
00:24:31,690 --> 00:24:36,430
that seven bits long right and that

560
00:24:34,599 --> 00:24:40,599
buffer of seven bits long has been read

561
00:24:36,430 --> 00:24:43,299
in LSB form right so as we read in bits

562
00:24:40,599 --> 00:24:45,939
we read them in and stack them up so we

563
00:24:43,299 --> 00:24:50,200
read in bits that go like this sort of a

564
00:24:45,940 --> 00:24:51,910
thing right and we're looking at the

565
00:24:50,200 --> 00:24:55,120
bottom seven bits of it so we know that

566
00:24:51,910 --> 00:24:59,140
the bit stream was 1 0 1 1 0 1 0 ba ba

567
00:24:55,119 --> 00:25:01,929
blah right we're looking at 1 2 3 4 5 6

568
00:24:59,140 --> 00:25:05,320
7 bits so we're basically just gonna

569
00:25:01,930 --> 00:25:07,000
look at this piece of it and we're gonna

570
00:25:05,319 --> 00:25:11,289
look that up into our Huffman table

571
00:25:07,000 --> 00:25:12,779
right now what we know for example is

572
00:25:11,289 --> 00:25:15,339
let's say that we had two different

573
00:25:12,779 --> 00:25:17,410
Huffman codes that we cared about and

574
00:25:15,339 --> 00:25:18,789
I'm just these are not listen we don't

575
00:25:17,410 --> 00:25:19,720
care that they're Huffman codes right

576
00:25:18,789 --> 00:25:21,970
that doesn't even matter

577
00:25:19,720 --> 00:25:25,450
forget Huffman we just want to look at

578
00:25:21,970 --> 00:25:27,850
bit patterns right so we know that we

579
00:25:25,450 --> 00:25:31,210
had one bit pattern that we cared about

580
00:25:27,849 --> 00:25:33,699
right and it was 1 0 and that coded for

581
00:25:31,210 --> 00:25:36,100
something a right and then we had

582
00:25:33,700 --> 00:25:39,819
another bit pattern let's say that was 1

583
00:25:36,099 --> 00:25:41,980
1 0 and that coded for B so if we were

584
00:25:39,819 --> 00:25:45,519
reading these in most significant byte

585
00:25:41,980 --> 00:25:47,829
format when we look at this and this and

586
00:25:45,519 --> 00:25:51,670
I'll I'll just throw the last one into

587
00:25:47,829 --> 00:25:56,379
that's another 1 0 right what we should

588
00:25:51,670 --> 00:26:00,970
see is this is 1 0 right 1 0 so that's

589
00:25:56,380 --> 00:26:03,700
an a we see 1 1 0 1 1 0 so that's a B

590
00:26:00,970 --> 00:26:04,710
and there's another 1 0 so that's an A

591
00:26:03,700 --> 00:26:07,480
right

592
00:26:04,710 --> 00:26:09,740
just forget enough min that's just what

593
00:26:07,480 --> 00:26:12,259
we thought we should see and

594
00:26:09,740 --> 00:26:15,470
we see it right so now the question is

595
00:26:12,259 --> 00:26:18,589
does the table generation produce the

596
00:26:15,470 --> 00:26:21,049
same result if we just reverse the table

597
00:26:18,589 --> 00:26:22,549
lookup right because what we want is the

598
00:26:21,049 --> 00:26:27,950
thing that literally read it that way

599
00:26:22,549 --> 00:26:29,629
from LSB to MSB and read it in the

600
00:26:27,950 --> 00:26:32,900
opposite order over here

601
00:26:29,630 --> 00:26:34,429
right so it basically said okay pretend

602
00:26:32,900 --> 00:26:36,290
this whole thing was flipped around and

603
00:26:34,429 --> 00:26:40,730
start reading from the most significant

604
00:26:36,289 --> 00:26:43,099
byte down right again I think that's

605
00:26:40,730 --> 00:26:45,380
what the spec was saying to do do not

606
00:26:43,099 --> 00:26:48,558
take this as me saying this is what the

607
00:26:45,380 --> 00:26:51,830
PMG does I have no idea I think that's

608
00:26:48,558 --> 00:26:53,299
what the spec told us to do right so

609
00:26:51,829 --> 00:26:55,250
what's gonna happen I look through the

610
00:26:53,299 --> 00:26:58,819
table I'm gonna look up this seven bit

611
00:26:55,250 --> 00:27:00,740
value right here first of all right and

612
00:26:58,819 --> 00:27:05,990
what I'm gonna find because we reverse

613
00:27:00,740 --> 00:27:09,349
the whole thing right is that our our

614
00:27:05,990 --> 00:27:12,289
table in everywhere where the top bits

615
00:27:09,349 --> 00:27:23,119
are ones up sorry where the bottom bits

616
00:27:12,289 --> 00:27:24,829
are 0 1 because we produced this 0 1

617
00:27:23,119 --> 00:27:26,928
Huffman code right when we were coding

618
00:27:24,829 --> 00:27:29,689
the a well actually that's not true

619
00:27:26,929 --> 00:27:31,160
let me rephrase that let me follow this

620
00:27:29,690 --> 00:27:34,519
through exactly because this may be part

621
00:27:31,160 --> 00:27:43,640
of the problem right so when we pack in

622
00:27:34,519 --> 00:27:44,960
this code ah ah I think I see the

623
00:27:43,640 --> 00:27:45,950
problem I think I already see the

624
00:27:44,960 --> 00:27:47,929
problem glad we did this

625
00:27:45,950 --> 00:27:49,789
when I pack in this code it's said most

626
00:27:47,929 --> 00:27:51,769
significant byte first that means if

627
00:27:49,789 --> 00:27:53,960
it's 1 0 that's the most significant

628
00:27:51,769 --> 00:27:56,480
byte then it comes this then everything

629
00:27:53,960 --> 00:27:59,600
else should have come after that right

630
00:27:56,480 --> 00:28:02,890
meaning it's 1 0 and then anything else

631
00:27:59,599 --> 00:28:05,990
those are least significant bits right

632
00:28:02,890 --> 00:28:09,500
after here after this MSB which is at

633
00:28:05,990 --> 00:28:11,750
the top of this then we flip it around

634
00:28:09,500 --> 00:28:17,450
and put it into the table I didn't

635
00:28:11,750 --> 00:28:20,529
remember to do that what I did when I

636
00:28:17,450 --> 00:28:20,529
put in the bit reverse

637
00:28:21,190 --> 00:28:28,269
right where is that here it is when I

638
00:28:25,628 --> 00:28:32,878
put in the bit reverse I'm still

639
00:28:28,269 --> 00:28:35,858
quitting the arbitrary part at the top

640
00:28:32,878 --> 00:28:38,319
but remember it's supposed to be the

641
00:28:35,858 --> 00:28:43,148
other way round right

642
00:28:38,319 --> 00:28:45,668
so actually the the LSB part is supposed

643
00:28:43,148 --> 00:28:49,148
to be this part here but I put that in

644
00:28:45,669 --> 00:28:51,899
the MSB before flipping so that I think

645
00:28:49,148 --> 00:28:56,998
is wrong that's that is incorrect so

646
00:28:51,898 --> 00:28:59,738
that that is I think that is our problem

647
00:28:56,999 --> 00:29:01,358
well it's a problem anyway so let's fix

648
00:28:59,739 --> 00:29:04,200
that immediately because that is

649
00:29:01,358 --> 00:29:06,128
definitely wrong again unless I'm

650
00:29:04,200 --> 00:29:07,298
completely misunderstanding what's

651
00:29:06,128 --> 00:29:08,978
supposed to happen which is entirely

652
00:29:07,298 --> 00:29:11,019
like okay

653
00:29:08,979 --> 00:29:14,109
so we know how many arbitrary bits there

654
00:29:11,019 --> 00:29:15,970
are so we're gonna or in this entry

655
00:29:14,108 --> 00:29:17,618
index which is the arbitrary bits part

656
00:29:15,970 --> 00:29:20,169
and what we're gonna do is we're gonna

657
00:29:17,618 --> 00:29:24,368
shift up the code part the arbitrary

658
00:29:20,169 --> 00:29:27,340
bits amount right so we're gonna stack

659
00:29:24,368 --> 00:29:34,199
that oops running so we're gonna snack

660
00:29:27,339 --> 00:29:36,579
that part at the top right before we do

661
00:29:34,200 --> 00:29:37,960
we're gonna put the like actual code at

662
00:29:36,579 --> 00:29:40,628
the top so the most employed goes first

663
00:29:37,960 --> 00:29:42,669
then the entry index is the part that's

664
00:29:40,628 --> 00:29:44,589
in the least significant parts then then

665
00:29:42,669 --> 00:29:45,580
we're gonna flip it around so they're

666
00:29:44,589 --> 00:29:48,878
all backwards

667
00:29:45,579 --> 00:29:49,269
right and then off we go does that make

668
00:29:48,878 --> 00:29:51,579
sense

669
00:29:49,269 --> 00:29:53,288
so that's what we're doing there now

670
00:29:51,579 --> 00:29:54,788
since the entry index is arbitrary

671
00:29:53,288 --> 00:29:56,769
really the only thing we'd have to flip

672
00:29:54,788 --> 00:29:58,298
it is really the code and then we could

673
00:29:56,769 --> 00:29:59,589
have packed it that way if but we're

674
00:29:58,298 --> 00:30:03,158
just gonna do it this way so it's all

675
00:29:59,589 --> 00:30:05,168
consistent right so now if we look at

676
00:30:03,159 --> 00:30:07,269
what happens here when we start packing

677
00:30:05,169 --> 00:30:09,519
a particular value which we'll do here

678
00:30:07,269 --> 00:30:11,108
let's just look at it when we start

679
00:30:09,519 --> 00:30:14,348
packing a particular value like this has

680
00:30:11,108 --> 00:30:17,319
16 entries right what we should see is

681
00:30:14,348 --> 00:30:19,509
the high bits should remain the same

682
00:30:17,319 --> 00:30:21,220
right the entire time and only the low

683
00:30:19,509 --> 00:30:23,200
bits vary and that's exactly what's

684
00:30:21,220 --> 00:30:26,259
happening that's the opposite of what we

685
00:30:23,200 --> 00:30:28,359
did last time so again I I think I

686
00:30:26,259 --> 00:30:31,509
messed that up when we threw that in

687
00:30:28,358 --> 00:30:33,368
there that was wrong so alright so

688
00:30:31,509 --> 00:30:34,250
that's it well actually you know what's

689
00:30:33,368 --> 00:30:37,789
interesting

690
00:30:34,250 --> 00:30:39,529
so you notice it worked this time we

691
00:30:37,789 --> 00:30:41,180
never we did not get past this before

692
00:30:39,529 --> 00:30:43,369
right we got an assertion that we hit a

693
00:30:41,180 --> 00:30:45,620
symbol we shouldn't have seen not one of

694
00:30:43,369 --> 00:30:48,289
these one of the huffman decodes so

695
00:30:45,619 --> 00:30:51,619
actually that was a huge bug that we

696
00:30:48,289 --> 00:30:52,940
just fixed so that's great so hey yay

697
00:30:51,619 --> 00:30:55,250
for working that on the blackboard that

698
00:30:52,940 --> 00:30:57,740
told us exactly where we went wrong and

699
00:30:55,250 --> 00:30:59,630
look we actually decompressed the exact

700
00:30:57,740 --> 00:31:01,819
right number of things that's a great

701
00:30:59,630 --> 00:31:06,500
sign that means it looks like we fixed

702
00:31:01,819 --> 00:31:10,189
part of our Huffman decode there okay so

703
00:31:06,500 --> 00:31:11,720
what I don't know now is is this we

704
00:31:10,190 --> 00:31:13,970
don't really know if the rest of our

705
00:31:11,720 --> 00:31:20,509
stuff here has made any sense and this

706
00:31:13,970 --> 00:31:23,180
stuff I think this is all I don't think

707
00:31:20,509 --> 00:31:27,890
we finished this so this all needs to

708
00:31:23,180 --> 00:31:29,900
get I think this all needs to get yeah I

709
00:31:27,890 --> 00:31:37,100
don't think any of this stuff is right

710
00:31:29,900 --> 00:31:41,060
yet that exits after the first block

711
00:31:37,099 --> 00:31:43,069
there right yeah so I don't really think

712
00:31:41,059 --> 00:31:45,529
all of this I don't I don't really know

713
00:31:43,069 --> 00:31:48,740
that any of this was correct i we sort

714
00:31:45,529 --> 00:31:50,539
of put this in here and we need we need

715
00:31:48,740 --> 00:31:53,329
to go back and look at that so so we'll

716
00:31:50,539 --> 00:31:55,309
deal with that a second so at the moment

717
00:31:53,329 --> 00:31:57,259
we do have some reason to believe that

718
00:31:55,309 --> 00:31:59,960
we may be decompressing this properly at

719
00:31:57,259 --> 00:32:02,569
least in a limited sense because now we

720
00:31:59,960 --> 00:32:04,100
are able to complete and we get the

721
00:32:02,569 --> 00:32:09,259
exact number of entries we think we

722
00:32:04,099 --> 00:32:11,659
should get which is a good sign which

723
00:32:09,259 --> 00:32:16,039
allows us to produce our Huffman tables

724
00:32:11,660 --> 00:32:17,420
for the literal distances which we can

725
00:32:16,039 --> 00:32:21,079
then use to decompress the rest of the

726
00:32:17,420 --> 00:32:23,840
stream I just don't know yeah I don't

727
00:32:21,079 --> 00:32:25,990
even remember what the rest of stuff is

728
00:32:23,839 --> 00:32:33,709
I don't even know why we're why are we

729
00:32:25,990 --> 00:32:35,750
exiting here I I guess that was just cuz

730
00:32:33,710 --> 00:32:37,850
we didn't want to keep going I guess I

731
00:32:35,750 --> 00:32:40,880
don't know so let me take that away

732
00:32:37,849 --> 00:32:43,309
because we should be able to now work on

733
00:32:40,880 --> 00:32:44,960
this back part of the routine to see how

734
00:32:43,309 --> 00:32:46,369
we're doing there and that should be

735
00:32:44,960 --> 00:32:47,799
able to allow us to once we get it

736
00:32:46,369 --> 00:32:49,449
working run till the end of the

737
00:32:47,799 --> 00:32:51,639
consuming the right number of bits so

738
00:32:49,450 --> 00:32:53,410
let's get rid of that and see where we

739
00:32:51,640 --> 00:32:55,840
blow up just I'm just curious now

740
00:32:53,410 --> 00:32:57,519
because we should be able to start

741
00:32:55,839 --> 00:33:05,409
working on that okay so you can see here

742
00:32:57,519 --> 00:33:09,700
we've got a there we go you can see here

743
00:33:05,410 --> 00:33:14,080
we've got a bug notice here encoded Len

744
00:33:09,700 --> 00:33:23,980
of of 12,000 there so if we go back up

745
00:33:14,079 --> 00:33:27,669
to there we go if we go back up to here

746
00:33:23,980 --> 00:33:30,579
it looks like this is not quite right so

747
00:33:27,670 --> 00:33:33,070
somehow we did oh well you know what

748
00:33:30,579 --> 00:33:34,949
that might be though the second time

749
00:33:33,069 --> 00:33:38,819
through the loop so let's actually

750
00:33:34,950 --> 00:33:41,319
verify that that's true you see first

751
00:33:38,819 --> 00:33:44,169
yeah so you can see the first time

752
00:33:41,319 --> 00:33:46,750
through the loop we're good the second

753
00:33:44,170 --> 00:33:53,019
time so this code is probably wrong it's

754
00:33:46,750 --> 00:33:54,579
probably not consuming yeah I mean I

755
00:33:53,019 --> 00:33:56,170
don't this just this just doesn't look

756
00:33:54,579 --> 00:33:57,699
done to me so let's just go finish this

757
00:33:56,170 --> 00:33:58,900
part first before we go any further

758
00:33:57,700 --> 00:34:01,120
because I think this is just missing

759
00:33:58,900 --> 00:34:03,820
stuff all right so our goal now is to

760
00:34:01,119 --> 00:34:05,199
get this part to work properly if we

761
00:34:03,819 --> 00:34:07,149
assume this part works properly which we

762
00:34:05,200 --> 00:34:09,550
don't know yet see if we can get this

763
00:34:07,150 --> 00:34:12,760
working properly because if we can't get

764
00:34:09,550 --> 00:34:14,590
this to work properly then that means we

765
00:34:12,760 --> 00:34:16,330
can go through all of the blocks and

766
00:34:14,590 --> 00:34:17,950
actually decompress potentially the

767
00:34:16,329 --> 00:34:20,139
right amount of data which would be a

768
00:34:17,949 --> 00:34:22,710
nice first step towards getting the PNG

769
00:34:20,139 --> 00:34:25,719
working so I'm going to go ahead and

770
00:34:22,710 --> 00:34:28,780
pong back over to the spec here and read

771
00:34:25,719 --> 00:34:31,539
that section so I believe that section

772
00:34:28,780 --> 00:34:33,250
comes from here you can see what this

773
00:34:31,539 --> 00:34:35,679
says here it says read the block header

774
00:34:33,250 --> 00:34:37,599
from the input stream that's what we did

775
00:34:35,679 --> 00:34:40,000
up above if it's store with no

776
00:34:37,599 --> 00:34:48,690
compression we do the basic copy that

777
00:34:40,000 --> 00:34:48,690
was this right I believe and this

778
00:34:49,360 --> 00:34:55,660
this we didn't doesn't look like we

779
00:34:52,929 --> 00:35:00,639
actually did the copy though right

780
00:34:55,659 --> 00:35:08,259
so that copy Len bytes of data to the

781
00:35:00,639 --> 00:35:11,589
output yeah so this right here wants to

782
00:35:08,260 --> 00:35:14,410
actually you know retire this much data

783
00:35:11,590 --> 00:35:16,420
so what we want to do is we want to

784
00:35:14,409 --> 00:35:17,980
start outputting now we didn't write

785
00:35:16,420 --> 00:35:20,619
anything for outputting but we want to

786
00:35:17,980 --> 00:35:23,050
here at the very least we just want to

787
00:35:20,619 --> 00:35:25,299
consume that size so this flush is a

788
00:35:23,050 --> 00:35:29,410
byte this is the thing that basically

789
00:35:25,300 --> 00:35:30,640
says hey let's get rid of any data

790
00:35:29,409 --> 00:35:32,519
that's still in the bit stream from the

791
00:35:30,639 --> 00:35:34,869
Huffman we're gonna read aligned now

792
00:35:32,519 --> 00:35:36,670
this doesn't really need to be consumed

793
00:35:34,869 --> 00:35:44,579
bits this should probably be consumed

794
00:35:36,670 --> 00:35:44,579
size right and it should consume a u16

795
00:35:44,969 --> 00:35:51,069
in fact we've got a consume for this

796
00:35:47,889 --> 00:36:03,099
exactly exactly this right we've got a

797
00:35:51,070 --> 00:36:08,039
thing it can just do consume that so

798
00:36:03,099 --> 00:36:10,389
this will get us our 2u sixteens

799
00:36:08,039 --> 00:36:12,039
that are the Loney and then now what I

800
00:36:10,389 --> 00:36:15,909
don't know is I don't know whether these

801
00:36:12,039 --> 00:36:20,529
lens need to be byte swapped it seems

802
00:36:15,909 --> 00:36:23,109
like that's the Botes operandi here that

803
00:36:20,530 --> 00:36:26,080
the they coming in the wrong order for a

804
00:36:23,110 --> 00:36:28,000
little onion don't quote me on that

805
00:36:26,079 --> 00:36:31,150
but if you look at what has to happen

806
00:36:28,000 --> 00:36:33,030
here whenever we were reading values

807
00:36:31,150 --> 00:36:36,700
that could take on a larger than a byte

808
00:36:33,030 --> 00:36:39,310
value we had to do an Indian swap so I

809
00:36:36,699 --> 00:36:41,529
assume that those values will be Indian

810
00:36:39,309 --> 00:36:43,420
swapped I don't know I'm gonna put an

811
00:36:41,530 --> 00:36:45,519
Indian swap in there for now

812
00:36:43,420 --> 00:36:46,960
I can try to determine that from the

813
00:36:45,519 --> 00:36:52,360
spec but I'm not sure if it's set in the

814
00:36:46,960 --> 00:36:56,250
spec or not if we do do an Indian swap

815
00:36:52,360 --> 00:36:56,250
here it just looks like this

816
00:37:04,389 --> 00:37:17,358
right so if we load a a it's kind can I

817
00:37:12,530 --> 00:37:22,970
do this yeah um I don't actually know if

818
00:37:17,358 --> 00:37:26,679
that works it does uh so we can use the

819
00:37:22,969 --> 00:37:29,209
intrinsics there or we can use the the

820
00:37:26,679 --> 00:37:31,608
non intrinsic version usually this gets

821
00:37:29,210 --> 00:37:34,550
compiled to one of those anyway let me

822
00:37:31,608 --> 00:37:36,500
just double check that it will that way

823
00:37:34,550 --> 00:37:39,140
we can do it in a platformer nonspecific

824
00:37:36,500 --> 00:37:48,769
way and still get the get the thing to

825
00:37:39,139 --> 00:37:50,690
produce the correct value there we go so

826
00:37:48,769 --> 00:37:52,550
I'm gonna go ahead and just take a look

827
00:37:50,690 --> 00:37:54,980
at that code just real quick

828
00:37:52,550 --> 00:37:58,280
so if we run to here I'm just gonna go

829
00:37:54,980 --> 00:38:08,389
to the disassembly I just want to see if

830
00:37:58,280 --> 00:38:19,040
Oh got to actually do it actually right

831
00:38:08,389 --> 00:38:22,159
this does it in place so if I look at

832
00:38:19,039 --> 00:38:24,519
the code for Indian swap Len here I'm

833
00:38:22,159 --> 00:38:24,519
gonna

834
00:38:28,469 --> 00:38:37,199
I'm gonna look to see whether or not I

835
00:38:31,349 --> 00:38:40,680
actually got a an Indian swap so you can

836
00:38:37,199 --> 00:38:44,629
see here when I call in to that code and

837
00:38:40,679 --> 00:38:44,629
I guess I should be more specific here

838
00:38:47,809 --> 00:38:51,000
so yeah

839
00:38:49,199 --> 00:38:52,409
so in here they call up to Indian swap

840
00:38:51,000 --> 00:38:54,510
now this is not the optimizing compiler

841
00:38:52,409 --> 00:38:56,159
so I'm guessing actually and of course

842
00:38:54,510 --> 00:38:59,460
we don't actually hit this case so why

843
00:38:56,159 --> 00:39:00,779
should probably do is set us - OH - so

844
00:38:59,460 --> 00:39:02,400
it'll compile it in there and I can see

845
00:39:00,780 --> 00:39:32,310
I just want to see if it produces the

846
00:39:02,400 --> 00:39:35,639
bite swap I don't know so it's optimize

847
00:39:32,309 --> 00:39:39,358
that out completely so I'm gonna have to

848
00:39:35,639 --> 00:39:41,639
do something here to copy it so what I

849
00:39:39,358 --> 00:39:45,088
could do is I could just say well when -

850
00:39:41,639 --> 00:39:51,569
- and I could actually do the copy the

851
00:39:45,088 --> 00:39:57,059
copy out right so there's the decompress

852
00:39:51,570 --> 00:40:05,849
pixels I'll just copy the the input that

853
00:39:57,059 --> 00:40:07,739
we get here maybe I'll call this test so

854
00:40:05,849 --> 00:40:12,359
I'll actually do the copy the source

855
00:40:07,739 --> 00:40:17,069
that we need is gonna be however big

856
00:40:12,358 --> 00:40:19,199
this Len told us to be I don't have any

857
00:40:17,070 --> 00:40:20,460
idea what that will look like because we

858
00:40:19,199 --> 00:40:23,730
don't actually hit this part of the code

859
00:40:20,460 --> 00:40:25,980
but if I actually grab lens worth of

860
00:40:23,730 --> 00:40:29,539
data then I should be able to you know

861
00:40:25,980 --> 00:40:29,539
just copy it out like that

862
00:40:32,840 --> 00:40:38,160
okay again that code is never hit so we

863
00:40:36,300 --> 00:40:40,500
can't actually see it but we can look at

864
00:40:38,159 --> 00:40:41,879
what if this assembly is and just see

865
00:40:40,500 --> 00:40:45,599
whether it actually did the byte swap

866
00:40:41,880 --> 00:40:48,750
the way I wanted to right so look in

867
00:40:45,599 --> 00:40:50,460
here looks like no so let me make sure I

868
00:40:48,750 --> 00:40:51,929
- I let me make sure I get that code

869
00:40:50,460 --> 00:40:55,460
right so that it does you can see it

870
00:40:51,929 --> 00:40:55,460
actually doing that anime or there

871
00:41:01,489 --> 00:41:13,229
alright so if I shift it up eight I mean

872
00:41:10,349 --> 00:41:15,960
I feel like that should have done it in

873
00:41:13,230 --> 00:41:19,409
a you 16 if I shift it up eight it will

874
00:41:15,960 --> 00:41:25,559
leave the bottoms a zero zero right and

875
00:41:19,409 --> 00:41:27,420
oh I thought I wrote it wrong I forgot

876
00:41:25,559 --> 00:41:29,610
to shift the other one down so if I

877
00:41:27,420 --> 00:41:31,559
shift that one up eight it should leave

878
00:41:29,610 --> 00:41:33,269
zeros in the bottom if I shift the other

879
00:41:31,559 --> 00:41:35,279
one down eight it'll leave zeros in the

880
00:41:33,269 --> 00:41:37,530
top or them together that should be the

881
00:41:35,280 --> 00:41:39,450
swap the compiler should be smart enough

882
00:41:37,530 --> 00:41:42,860
to see that and I just want to know if

883
00:41:39,449 --> 00:41:42,859
it is that's all I'm doing

884
00:41:43,400 --> 00:41:54,119
let's see so actually it did a it did

885
00:41:47,880 --> 00:41:57,809
our rotate which that's also correct so

886
00:41:54,119 --> 00:41:59,219
that's that's fine I don't think we have

887
00:41:57,809 --> 00:42:01,440
to care which one it does as long as it

888
00:41:59,219 --> 00:42:07,679
does it and it did so I think that's

889
00:42:01,440 --> 00:42:08,700
fine all right so anyway yeah don't

890
00:42:07,679 --> 00:42:10,529
really know what's supposed to happen

891
00:42:08,699 --> 00:42:13,469
here don't know if these are supposed to

892
00:42:10,530 --> 00:42:15,030
be Indian soft or not but we're gonna

893
00:42:13,469 --> 00:42:16,529
assume that they are I'm gonna put two

894
00:42:15,030 --> 00:42:18,360
do in there just so we know that it's

895
00:42:16,530 --> 00:42:21,290
not code that I thought was right it's

896
00:42:18,360 --> 00:42:21,289
just something that I tried

897
00:42:26,320 --> 00:42:33,440
so I don't know but that's what we think

898
00:42:30,050 --> 00:42:35,900
so I'll go back to our debug build now

899
00:42:33,440 --> 00:42:41,900
and take a look at the next part of the

900
00:42:35,900 --> 00:42:44,599
code right okay so we did that now and

901
00:42:41,900 --> 00:42:47,090
now we've got this section we don't

902
00:42:44,599 --> 00:42:49,099
handle the non dynamic Huffman code case

903
00:42:47,090 --> 00:42:51,710
so we're gonna have to do that later by

904
00:42:49,099 --> 00:42:54,170
just putting in the tables manually so

905
00:42:51,710 --> 00:42:57,559
we're down to here now okay so let's

906
00:42:54,170 --> 00:42:59,110
take a look at that okay so when we get

907
00:42:57,559 --> 00:43:01,579
to the part where actually decoding

908
00:42:59,110 --> 00:43:03,470
let's actually follow the spec here and

909
00:43:01,579 --> 00:43:04,819
see what they say to do they stated to

910
00:43:03,469 --> 00:43:06,649
code a literal length value from the

911
00:43:04,820 --> 00:43:08,720
input stream that's exactly what we did

912
00:43:06,650 --> 00:43:10,670
here we're using the literal the lit Len

913
00:43:08,719 --> 00:43:14,719
Huffman I mean to code one of those

914
00:43:10,670 --> 00:43:16,610
right if the value is less than 256 then

915
00:43:14,719 --> 00:43:20,509
we copy it to the output stream

916
00:43:16,610 --> 00:43:22,970
so whatever the thing was we just it

917
00:43:20,510 --> 00:43:26,500
gets outputted what the actual byte

918
00:43:22,969 --> 00:43:31,759
right so basically lit Len as a you ate

919
00:43:26,500 --> 00:43:37,909
just truncated directly down right just

920
00:43:31,760 --> 00:43:42,160
so you know this right we're literally

921
00:43:37,909 --> 00:43:45,259
just writing that to the output stream I

922
00:43:42,159 --> 00:43:48,529
guess right that's what it seems to say

923
00:43:45,260 --> 00:43:53,990
so that's just anything that comes in as

924
00:43:48,530 --> 00:43:57,620
a byte goes out as a byte right anything

925
00:43:53,989 --> 00:44:00,609
that's greater than a byte that we

926
00:43:57,619 --> 00:44:03,920
actually start to use here right so

927
00:44:00,610 --> 00:44:05,690
otherwise if the value equals the end of

928
00:44:03,920 --> 00:44:08,269
the block which is 256

929
00:44:05,690 --> 00:44:11,869
then break from the loop right so that's

930
00:44:08,269 --> 00:44:15,019
this here because that's if it's exactly

931
00:44:11,869 --> 00:44:18,859
equal to 56 otherwise if it's greater

932
00:44:15,019 --> 00:44:20,389
than 256 we do some stuff right we

933
00:44:18,860 --> 00:44:23,720
decode the distance from the input

934
00:44:20,389 --> 00:44:25,159
stream that's this here then we move

935
00:44:23,719 --> 00:44:28,219
backwards distance bytes in the output

936
00:44:25,159 --> 00:44:30,619
stream now this is wrong even though it

937
00:44:28,219 --> 00:44:34,009
doesn't say it here this step is more

938
00:44:30,619 --> 00:44:36,139
complicated I think is the key right so

939
00:44:34,010 --> 00:44:39,170
we just literally translate this code

940
00:44:36,139 --> 00:44:42,368
that it's not right

941
00:44:39,170 --> 00:44:46,430
so let's just get rid of this here this

942
00:44:42,369 --> 00:45:02,869
requires us to do some work so if I come

943
00:44:46,429 --> 00:45:06,679
over here to here here here so this part

944
00:45:02,869 --> 00:45:09,559
here I think indicates that there's a

945
00:45:06,679 --> 00:45:12,529
lot more that goes on in the length part

946
00:45:09,559 --> 00:45:14,809
that we haven't written yet so this was

947
00:45:12,530 --> 00:45:17,180
the pseudocode the pseudocode omitted

948
00:45:14,809 --> 00:45:20,240
like all this stuff I think I think

949
00:45:17,179 --> 00:45:23,509
that's what happened so if we look in

950
00:45:20,239 --> 00:45:27,679
here what you can see is that like if we

951
00:45:23,510 --> 00:45:30,790
have a number between 257 and 264 uh

952
00:45:27,679 --> 00:45:35,318
then you're gonna do that length

953
00:45:30,789 --> 00:45:38,900
directly right it's it's gonna be like

954
00:45:35,318 --> 00:45:43,699
254 it's gonna be this the number minus

955
00:45:38,900 --> 00:45:47,599
254 to get the length but if the number

956
00:45:43,699 --> 00:45:49,969
has more right you can see it keep going

957
00:45:47,599 --> 00:45:53,088
here if the number is higher than that

958
00:45:49,969 --> 00:45:54,919
then you get into things where you need

959
00:45:53,088 --> 00:45:56,900
to read more bits from the code stream

960
00:45:54,920 --> 00:46:00,588
to determine how far you should should

961
00:45:56,900 --> 00:46:03,430
jump right so yeah so anyway that is

962
00:46:00,588 --> 00:46:03,429
what is this

963
00:46:09,429 --> 00:46:16,909
length backward distance Paris where the

964
00:46:12,559 --> 00:46:20,239
length is drawn from 353 to 258 and the

965
00:46:16,909 --> 00:46:21,588
distance is drawn from 1 to 32 768 the

966
00:46:20,239 --> 00:46:24,079
literal in length outfits are merged

967
00:46:21,588 --> 00:46:27,199
into a single alphabet where values 0 to

968
00:46:24,079 --> 00:46:29,089
5 represent literal bytes the value 262

969
00:46:27,199 --> 00:46:30,978
takes on a block and to 0 represents

970
00:46:29,088 --> 00:46:33,978
length codes postures of the false right

971
00:46:30,978 --> 00:46:36,828
so I believe the next thing we need to

972
00:46:33,978 --> 00:46:40,219
do is in addition to the Huffman des

973
00:46:36,829 --> 00:46:43,579
code here we need two Huffman to code

974
00:46:40,219 --> 00:46:46,038
the distance like we did and then we

975
00:46:43,579 --> 00:46:48,380
need to do the extra bit stuff now what

976
00:46:46,039 --> 00:46:51,380
I don't know is where those bit reeds

977
00:46:48,380 --> 00:46:53,390
come so there's two ways we could

978
00:46:51,380 --> 00:46:55,608
interpret this one is you do both

979
00:46:53,389 --> 00:46:57,650
Huffman's first then read extra bits the

980
00:46:55,608 --> 00:46:59,568
other one is Huffman extra bits Huffman

981
00:46:57,650 --> 00:47:05,119
extra bits and I don't know which one it

982
00:46:59,568 --> 00:47:08,509
is I don't know if the spec even

983
00:47:05,119 --> 00:47:12,460
mentioned it but we'll look so we'll see

984
00:47:08,509 --> 00:47:14,509
if the spec says so reading this closely

985
00:47:12,460 --> 00:47:16,460
the litter Lonavala blah blah blah blah

986
00:47:14,509 --> 00:47:19,369
blah the value to d6 indicates and a

987
00:47:16,460 --> 00:47:20,749
block and values to d7 to 85 represent

988
00:47:19,369 --> 00:47:22,009
length codes possibly drugs actually

989
00:47:20,748 --> 00:47:24,259
bits following the symbol code as

990
00:47:22,009 --> 00:47:25,548
follows so the fact that says positive

991
00:47:24,259 --> 00:47:27,588
conjunction to bits

992
00:47:25,548 --> 00:47:29,809
makes me think it comes right after I'm

993
00:47:27,588 --> 00:47:31,429
not sure there should be a trivial

994
00:47:29,809 --> 00:47:32,059
machine is restore with the most living

995
00:47:31,429 --> 00:47:34,009
a bit first

996
00:47:32,059 --> 00:47:38,028
of course cuz why wouldn't we switch it

997
00:47:34,009 --> 00:47:39,440
again right fantastic as the machine is

998
00:47:38,028 --> 00:47:44,768
just or at the most immune but first

999
00:47:39,440 --> 00:47:44,769
eg bits 1 1 1 0 represents a value 14

1000
00:47:45,699 --> 00:47:51,489
not sure how that example clarifies

1001
00:47:48,920 --> 00:47:51,489
anything

1002
00:47:55,028 --> 00:48:03,139
you wrote it in display form of course

1003
00:47:59,989 --> 00:48:05,420
that represents 14 what else could it

1004
00:48:03,139 --> 00:48:09,940
possibly represent you neglected to say

1005
00:48:05,420 --> 00:48:14,180
which order those bits came in all right

1006
00:48:09,940 --> 00:48:15,588
whatever anyway so yeah reading through

1007
00:48:14,179 --> 00:48:16,039
this we know we need to grab an extra

1008
00:48:15,588 --> 00:48:24,170
bit

1009
00:48:16,039 --> 00:48:25,610
two or three four or five right who

1010
00:48:24,170 --> 00:48:27,559
knows how they came up with this I guess

1011
00:48:25,610 --> 00:48:28,970
it was just weakened right I guess there

1012
00:48:27,559 --> 00:48:30,889
was just weak and compression people

1013
00:48:28,969 --> 00:48:32,480
loved weakened so I'm assuming they just

1014
00:48:30,889 --> 00:48:34,599
tweaked it and this is what ended up

1015
00:48:32,480 --> 00:48:40,539
being the best thing I don't know

1016
00:48:34,599 --> 00:48:43,369
so anyway when we actually look here

1017
00:48:40,539 --> 00:48:45,739
this looks like the same table just for

1018
00:48:43,369 --> 00:48:47,089
distance codes so I think we just do

1019
00:48:45,739 --> 00:48:49,129
those two and off we go

1020
00:48:47,090 --> 00:48:51,620
I like that I think that's all we're

1021
00:48:49,130 --> 00:48:54,260
doing here so the main thing that I

1022
00:48:51,619 --> 00:48:56,569
don't understand is just looking here

1023
00:48:54,260 --> 00:49:06,760
it's like okay so we've got to invert

1024
00:48:56,570 --> 00:49:06,760
the bits so that's great

1025
00:49:16,969 --> 00:49:30,750
so I also I'm trying to think through is

1026
00:49:21,360 --> 00:49:34,019
there a fast way to invert the bits it

1027
00:49:30,750 --> 00:49:38,969
probably is it's probably like you know

1028
00:49:34,019 --> 00:49:40,920
oh if I if I subtract and then and and

1029
00:49:38,969 --> 00:49:43,769
then add or something

1030
00:49:40,920 --> 00:49:46,530
I get the inverted value like there's

1031
00:49:43,769 --> 00:49:49,110
probably a good binary trick to invert

1032
00:49:46,530 --> 00:49:51,090
the bits of a value and we're gonna want

1033
00:49:49,110 --> 00:49:54,000
to know that here because if we have to

1034
00:49:51,090 --> 00:49:57,030
like read in MSB based bits all of a

1035
00:49:54,000 --> 00:49:58,949
sudden I don't really and and this is

1036
00:49:57,030 --> 00:50:01,410
not during table generation this is

1037
00:49:58,949 --> 00:50:03,149
actually during decompression I don't

1038
00:50:01,409 --> 00:50:06,230
want to be sitting there doing actual

1039
00:50:03,150 --> 00:50:08,340
bit inversion that's just totally stupid

1040
00:50:06,230 --> 00:50:10,260
so we're gonna have to go think about

1041
00:50:08,340 --> 00:50:14,210
whether we can do a quick binary trick

1042
00:50:10,260 --> 00:50:14,210
to flip the order of our bits

1043
00:50:17,929 --> 00:50:22,799
I'm sure there's like Oh X or then

1044
00:50:20,699 --> 00:50:24,509
subtract then like there's gonna be

1045
00:50:22,800 --> 00:50:26,390
something my bet that will do that I

1046
00:50:24,510 --> 00:50:29,400
just have to think through what it is

1047
00:50:26,389 --> 00:50:33,029
more like do with search for a quick

1048
00:50:29,400 --> 00:50:35,190
binary bit inversion and find something

1049
00:50:33,030 --> 00:50:42,720
from 1962 that's like we found this

1050
00:50:35,190 --> 00:50:46,769
thing alright so let's try to make this

1051
00:50:42,719 --> 00:50:50,309
stuff work so I'm not sure what the best

1052
00:50:46,769 --> 00:50:52,679
way to do this would be but I think the

1053
00:50:50,309 --> 00:50:56,279
best way to do it is to just use a table

1054
00:50:52,679 --> 00:51:00,589
because we know that there's only 257 to

1055
00:50:56,280 --> 00:51:09,030
285 are their values so I'm just gonna

1056
00:51:00,590 --> 00:51:12,360
like I'm just gonna use like the table

1057
00:51:09,030 --> 00:51:13,380
entry thing we have here I think that's

1058
00:51:12,360 --> 00:51:16,110
the easiest thing to do

1059
00:51:13,380 --> 00:51:21,230
so actually we can use the PNG Huffman

1060
00:51:16,110 --> 00:51:21,230
entry if we want to

1061
00:51:26,579 --> 00:51:31,029
so think we can look up into the table

1062
00:51:29,019 --> 00:51:34,329
and it could tell us the value to

1063
00:51:31,030 --> 00:51:38,019
subtract from the base to get the

1064
00:51:34,329 --> 00:51:40,529
starting length number and then the

1065
00:51:38,019 --> 00:51:44,500
number of extra bits to read in to add

1066
00:51:40,530 --> 00:51:48,519
to that value and then we can just go

1067
00:51:44,500 --> 00:51:51,550
from there now again I the bit flipping

1068
00:51:48,519 --> 00:51:54,789
thing is going to be annoying but that's

1069
00:51:51,550 --> 00:52:00,210
just the way it goes sometimes my dude

1070
00:51:54,789 --> 00:52:02,889
so anyway inside parse P&amp;G we can have

1071
00:52:00,210 --> 00:52:10,960
some entries here so this is going to be

1072
00:52:02,889 --> 00:52:19,329
a distance value as is a length value so

1073
00:52:10,960 --> 00:52:25,720
this is the length extra so this is

1074
00:52:19,329 --> 00:52:29,699
going to be 2 57 58 59 60 61 62 63 64

1075
00:52:25,719 --> 00:52:35,129
right and it's going to be 0 bits extra

1076
00:52:29,699 --> 00:52:35,129
so I'm just going to do these like this

1077
00:52:50,130 --> 00:53:00,099
and you know I you know this can be

1078
00:52:52,869 --> 00:53:04,480
pulled out we'll just put it out here so

1079
00:53:00,099 --> 00:53:12,779
here's a global and we'll just make a

1080
00:53:04,480 --> 00:53:28,840
table it's not pretty but it'll work

1081
00:53:12,780 --> 00:53:31,090
alright so actually since we have one

1082
00:53:28,840 --> 00:53:40,870
that goes from zero to nine I could save

1083
00:53:31,090 --> 00:53:45,579
myself some typing by doing that so I

1084
00:53:40,869 --> 00:53:49,900
believe 285 is just 258

1085
00:53:45,579 --> 00:53:53,469
so essentially yeah what we would want

1086
00:53:49,900 --> 00:53:56,050
to do here is yeah just Inc encode the

1087
00:53:53,469 --> 00:54:00,569
subtraction value and then the the bits

1088
00:53:56,050 --> 00:54:04,150
used so the subtraction value for 257 is

1089
00:54:00,570 --> 00:54:06,010
we want it to start at 3 so it's 254

1090
00:54:04,150 --> 00:54:09,130
like you'd say key value and we'd

1091
00:54:06,010 --> 00:54:14,820
subtract 254 from it and we read zero

1092
00:54:09,130 --> 00:54:21,210
more bits in right and that goes up to

1093
00:54:14,820 --> 00:54:24,039
265 is the next time we change so at 265

1094
00:54:21,210 --> 00:54:26,139
we're assuming it's 11 so it looks like

1095
00:54:24,039 --> 00:54:30,150
we still always oh so do we always

1096
00:54:26,139 --> 00:54:30,150
subtract 254 from the value

1097
00:54:39,650 --> 00:54:44,410
that doesn't make a lot of sense does it

1098
00:54:49,800 --> 00:54:59,670
ah so it goes up one each time okay so

1099
00:54:53,039 --> 00:55:01,920
265 we would still do right this is

1100
00:54:59,670 --> 00:55:07,200
gonna be nuts to get right okay so at

1101
00:55:01,920 --> 00:55:09,210
265 - 254 is 11 which is what we want

1102
00:55:07,199 --> 00:55:14,909
but now we get one bit of extra data

1103
00:55:09,210 --> 00:55:18,329
right so now 266 we would not be

1104
00:55:14,909 --> 00:55:21,899
subtracting 254 any more from the value

1105
00:55:18,329 --> 00:55:23,549
right instead what we're subtracting

1106
00:55:21,900 --> 00:55:27,539
from the value is something that gives

1107
00:55:23,550 --> 00:55:38,070
us 13 right so what we actually want

1108
00:55:27,539 --> 00:55:41,159
there is 266 we want to know what value

1109
00:55:38,070 --> 00:55:41,730
we would subtract from 2006 to get 13

1110
00:55:41,159 --> 00:55:46,309
right

1111
00:55:41,730 --> 00:55:50,519
so we want to 6 6-2 53 which produces

1112
00:55:46,309 --> 00:55:52,170
the 13 value so that goes down by one in

1113
00:55:50,519 --> 00:55:55,110
order to account for the fact that you

1114
00:55:52,170 --> 00:55:58,260
read one more bit right so it doesn't

1115
00:55:55,110 --> 00:56:01,289
need to do that so the next one will go

1116
00:55:58,260 --> 00:56:04,110
down again right because since we've got

1117
00:56:01,289 --> 00:56:06,630
one extra bit there we now know that 266

1118
00:56:04,110 --> 00:56:08,880
should produce I'm sorry that's the one

1119
00:56:06,630 --> 00:56:16,440
we're on so we know 267 should produce

1120
00:56:08,880 --> 00:56:19,260
15 right so if we assume that 267 should

1121
00:56:16,440 --> 00:56:22,409
produce 15 then we want to go down 1

1122
00:56:19,260 --> 00:56:25,050
again right so every time we read that

1123
00:56:22,409 --> 00:56:28,289
one we're doing that one bit read we

1124
00:56:25,050 --> 00:56:30,539
know we kind of go down one more value

1125
00:56:28,289 --> 00:56:34,349
to account for the extra bit that was

1126
00:56:30,539 --> 00:56:37,170
specified right this is super weird

1127
00:56:34,349 --> 00:56:42,779
alright so now at 269 we start reading

1128
00:56:37,170 --> 00:56:45,240
two extra bits right oops she sees 9 we

1129
00:56:42,780 --> 00:56:52,580
read two extra bits we do that four

1130
00:56:45,239 --> 00:56:52,579
times 273 is 3

1131
00:56:58,710 --> 00:57:21,970
whoops so 277 is 421 is 5 and 285 just

1132
00:57:19,298 --> 00:57:26,199
produces 258 apparently that's just the

1133
00:57:21,969 --> 00:57:28,659
maximum value why that doesn't include

1134
00:57:26,199 --> 00:57:35,078
extra bits I don't know it just doesn't

1135
00:57:28,659 --> 00:57:40,028
so again TWiki compressors are TWiki

1136
00:57:35,079 --> 00:57:46,150
so 285 is supposed to produced 258 so -

1137
00:57:40,028 --> 00:57:49,150
85 - 258 is 27 so I guess we just take

1138
00:57:46,150 --> 00:57:51,160
the value right and subtract 27 and that

1139
00:57:49,150 --> 00:57:52,960
produces it and we read no extra bits

1140
00:57:51,159 --> 00:57:57,639
right so that one's kind of a little bit

1141
00:57:52,960 --> 00:58:04,019
of an anomaly there so I believe 269 -

1142
00:57:57,639 --> 00:58:06,400
249 is what we want to produce 20 right

1143
00:58:04,018 --> 00:58:11,608
so to produce and that's what we should

1144
00:58:06,400 --> 00:58:11,608
start at right oh no it starts at 19

1145
00:58:15,500 --> 00:58:21,559
oh right because it still does one bit

1146
00:58:17,960 --> 00:58:22,070
now we start subtracting more bit more

1147
00:58:21,559 --> 00:58:25,489
numbers

1148
00:58:22,070 --> 00:58:26,349
okay so 250 minus 269 is 19 that's what

1149
00:58:25,489 --> 00:58:37,219
we want

1150
00:58:26,349 --> 00:58:46,910
270 is supposed to produce 23 so that's

1151
00:58:37,219 --> 00:58:51,519
247 right so that's all good

1152
00:58:46,909 --> 00:58:56,598
and then we've got 271 has to produce 27

1153
00:58:51,519 --> 00:58:58,039
its 244 so yet that just goes down by 3

1154
00:58:56,599 --> 00:59:02,180
each time because hey we're reading 2

1155
00:58:58,039 --> 00:59:05,059
bits so that makes sense so keep reading

1156
00:59:02,179 --> 00:59:06,858
2 bits so that should be 241 and this

1157
00:59:05,059 --> 00:59:09,230
one again even though this is a 3 it's

1158
00:59:06,858 --> 00:59:12,529
the 2 bits here that count so we

1159
00:59:09,230 --> 00:59:14,329
subtract by we go down by 3 again on

1160
00:59:12,530 --> 00:59:20,530
this one alone right now let's just make

1161
00:59:14,329 --> 00:59:23,750
sure that lines up to 273 238 it's 35

1162
00:59:20,530 --> 00:59:28,609
that's what we expect right so now we're

1163
00:59:23,750 --> 00:59:30,769
up to 274 so this is going to be going

1164
00:59:28,608 --> 00:59:32,989
down by 7 probably so I'm assuming it

1165
00:59:30,769 --> 00:59:40,759
would be 231 not let's just see if

1166
00:59:32,989 --> 00:59:42,739
that's right so that produces 43 so

1167
00:59:40,760 --> 00:59:47,119
that's the right value yep so we just

1168
00:59:42,739 --> 00:59:51,649
keep going down by sevens each time so

1169
00:59:47,119 --> 00:59:57,160
that's going to be what 224 leave down

1170
00:59:51,650 --> 01:00:04,639
by 7 again so that's going to be 2 1 7

1171
00:59:57,159 --> 01:00:12,039
down by 7 again and I get to 10 so 277

1172
01:00:04,639 --> 01:00:12,039
minus 210 and that's 67

1173
01:00:12,838 --> 01:00:17,278
and that's right so now we're gonna

1174
01:00:15,179 --> 01:00:22,228
start going down by 15s because we're

1175
01:00:17,278 --> 01:00:25,469
reading for a bit at a time right so

1176
01:00:22,228 --> 01:00:29,669
going down by 15s this should be 195 if

1177
01:00:25,469 --> 01:00:34,739
I'm not mistaken this would be 180 this

1178
01:00:29,670 --> 01:00:42,479
would be 165 and the last one here be

1179
01:00:34,739 --> 01:00:44,429
150 so 281 minus 150 is 131 and that's

1180
01:00:42,478 --> 01:00:50,338
exactly right now we're going by thirty

1181
01:00:44,429 --> 01:00:54,868
ones right the last set and the thirty

1182
01:00:50,338 --> 01:00:58,679
ones are gonna be uh let's see so

1183
01:00:54,869 --> 01:01:02,489
starting here so it would be what 120

1184
01:00:58,679 --> 01:01:06,288
minus one is 119 right going down by

1185
01:01:02,489 --> 01:01:11,130
thirty again is gonna be what

1186
01:01:06,289 --> 01:01:14,910
eighty-nine so minus one is 88 going

1187
01:01:11,130 --> 01:01:21,900
down by thirty again is gonna be 58

1188
01:01:14,909 --> 01:01:28,588
minus 57 and then we're at the end of

1189
01:01:21,900 --> 01:01:29,509
those so let's see 24 minus 57 227 and

1190
01:01:28,588 --> 01:01:32,818
that's right

1191
01:01:29,509 --> 01:01:36,539
alright so we've built our magical

1192
01:01:32,818 --> 01:01:38,759
length table here which means we can now

1193
01:01:36,539 --> 01:01:41,519
use it to do our decode and then I don't

1194
01:01:38,759 --> 01:01:43,858
know how we're supposed to produce the

1195
01:01:41,518 --> 01:01:47,728
right value out of that for the bit

1196
01:01:43,858 --> 01:01:52,228
reversal we know how many extra bits to

1197
01:01:47,728 --> 01:01:54,058
consume and we know that we need to do

1198
01:01:52,228 --> 01:01:57,538
the reversal so let's think about what

1199
01:01:54,059 --> 01:02:00,329
that reversal actually means so when we

1200
01:01:57,539 --> 01:02:01,950
read this in let's just let's just see

1201
01:02:00,329 --> 01:02:04,170
if we can work it out at a small bit

1202
01:02:01,949 --> 01:02:07,710
level and see what we can get the bit

1203
01:02:04,170 --> 01:02:09,150
pattern figure it out I probably knew

1204
01:02:07,710 --> 01:02:10,829
how to do this at one point and I've

1205
01:02:09,150 --> 01:02:11,940
just forgotten because it seems like the

1206
01:02:10,829 --> 01:02:17,548
kind of thing you would do back in the

1207
01:02:11,940 --> 01:02:19,769
bit to Italy error alright so I if we

1208
01:02:17,548 --> 01:02:22,228
have a 0 or a 1 we know that that just

1209
01:02:19,768 --> 01:02:24,389
works right because you don't need to

1210
01:02:22,228 --> 01:02:24,868
flip the order of the bits in something

1211
01:02:24,389 --> 01:02:27,838
that only had

1212
01:02:24,869 --> 01:02:29,700
one bit on the other hand if we instead

1213
01:02:27,838 --> 01:02:34,558
have the bits in the opposite order so

1214
01:02:29,699 --> 01:02:38,578
we've got 0 1 I'm sorry 0 0 0 1 1 0 1 1

1215
01:02:34,559 --> 01:02:50,430
right and what we want to produce here

1216
01:02:38,579 --> 01:02:53,999
from these is 0 0 1 0 0 1 1 1 right how

1217
01:02:50,429 --> 01:02:56,129
are we gonna do it right how would I get

1218
01:02:53,998 --> 01:02:57,659
that so if you look at what happens

1219
01:02:56,130 --> 01:03:01,259
numerically to these just to see if that

1220
01:02:57,659 --> 01:03:03,298
helps us at all it's 0 1 2 3 and what we

1221
01:03:01,259 --> 01:03:07,829
want to produce on the other side of

1222
01:03:03,298 --> 01:03:08,248
that when we read it in instead is 0 2 1

1223
01:03:07,829 --> 01:03:11,460
3

1224
01:03:08,248 --> 01:03:13,949
right which is a pretty weird thing to

1225
01:03:11,460 --> 01:03:16,380
look at so who knows so this is the

1226
01:03:13,949 --> 01:03:20,759
transfer bit for information for 2

1227
01:03:16,380 --> 01:03:21,480
values not sure how we do it for 3

1228
01:03:20,759 --> 01:03:26,548
values

1229
01:03:21,480 --> 01:03:38,759
here's how it would look so that's 0 0 0

1230
01:03:26,548 --> 01:03:42,778
0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1

1231
01:03:38,759 --> 01:03:52,949
1 right and we want all of these to go

1232
01:03:42,778 --> 01:03:58,739
to 0 0 0 1 0 0 0 1 0 1 1 0 0 0 1 1 0 1 0

1233
01:03:52,949 --> 01:04:08,518
1 1 1 1 1 right looking at the numbers

1234
01:03:58,739 --> 01:04:10,249
that's 0 1 2 3 4 5 6 7 here it is 0 for

1235
01:04:08,518 --> 01:04:15,149
2

1236
01:04:10,248 --> 01:04:24,929
that's so weird so 0 for 2

1237
01:04:15,150 --> 01:04:30,150
what's that 6 4 5 that becomes 3 &amp; 7

1238
01:04:24,929 --> 01:04:33,778
right so 0 for 2 6 4 5 3 oh wait no

1239
01:04:30,150 --> 01:04:35,989
that's not a 4th that's a 1 and why said

1240
01:04:33,778 --> 01:04:35,989
4

1241
01:04:36,190 --> 01:04:50,980
it's going too fast zero four two six

1242
01:04:42,369 --> 01:04:54,990
one five three seven of course right all

1243
01:04:50,980 --> 01:04:54,990
right so

1244
01:05:05,989 --> 01:05:08,989
hmm

1245
01:05:23,039 --> 01:05:29,909
so what is for - the value in this case

1246
01:05:30,630 --> 01:05:39,579
or three - device so 3 - the value in

1247
01:05:34,599 --> 01:05:41,650
this case works for the inner - right

1248
01:05:39,579 --> 01:05:46,059
because 3 minus 2 is 1 and 3 minus 1 is

1249
01:05:41,650 --> 01:05:49,509
2 but for the 0 &amp; 3 it doesn't work

1250
01:05:46,059 --> 01:05:52,028
because the 0 becomes the 3 and the 3

1251
01:05:49,509 --> 01:05:54,838
becomes the 0 and we didn't want that

1252
01:05:52,028 --> 01:05:54,838
right

1253
01:05:56,289 --> 01:05:59,400
[Music]

1254
01:06:09,119 --> 01:06:16,899
if we did something like nodding the

1255
01:06:12,458 --> 01:06:21,958
value then it works for the zero and the

1256
01:06:16,898 --> 01:06:24,338
three because they get restored properly

1257
01:06:21,958 --> 01:06:26,678
but it doesn't work for the interior

1258
01:06:24,338 --> 01:06:32,878
because now they've inverted themselves

1259
01:06:26,679 --> 01:06:32,878
I believe right so for example if I take

1260
01:06:33,659 --> 01:06:38,729
knotted this will become a zero so 3

1261
01:06:36,219 --> 01:06:42,579
minus 0 equals 3 is correct for that

1262
01:06:38,728 --> 01:06:44,498
knotted this becomes 1 3 minus 1 equals

1263
01:06:42,579 --> 01:07:08,709
2 but it was supposed to become a 1

1264
01:06:44,498 --> 01:07:13,388
right I mean obviously I could put this

1265
01:07:08,708 --> 01:07:18,158
in a table that would get me out of a

1266
01:07:13,389 --> 01:07:20,399
jam but there's got to be something

1267
01:07:18,159 --> 01:07:20,398
right

1268
01:07:33,090 --> 01:07:36,090
yeah

1269
01:07:47,539 --> 01:07:54,269
so I don't know I'll search to see if

1270
01:07:51,300 --> 01:07:56,010
there's a good thing I can't think of

1271
01:07:54,269 --> 01:08:07,079
anything but those that some I'd have to

1272
01:07:56,010 --> 01:08:12,710
stay out for a while all right let's see

1273
01:08:07,079 --> 01:08:12,710
here Stanford computer graphics lab huh

1274
01:08:19,939 --> 01:08:24,979
there's a lot of a lot of this here

1275
01:08:34,229 --> 01:08:42,119
so it is pretty it's a pretty

1276
01:08:36,460 --> 01:08:46,930
complicated one so here's the one that's

1277
01:08:42,119 --> 01:08:49,269
the sort of not good way the lookup

1278
01:08:46,930 --> 01:08:50,610
table we don't care about because we

1279
01:08:49,270 --> 01:08:53,500
don't really want to do that

1280
01:08:50,609 --> 01:08:57,429
sixty-four multiply and modulus division

1281
01:08:53,500 --> 01:08:58,810
so reverse the bite so they use okay so

1282
01:08:57,430 --> 01:09:02,470
yeah these are one of those like

1283
01:08:58,810 --> 01:09:03,490
carefully constructed numbers ones we

1284
01:09:02,470 --> 01:09:04,890
would not have come up with that on

1285
01:09:03,489 --> 01:09:08,028
stream

1286
01:09:04,890 --> 01:09:08,029
[Music]

1287
01:09:34,100 --> 01:09:43,560
the last two steps cancer pursue the

1288
01:09:36,359 --> 01:09:45,630
rescue mrs. bytes so that's pretty nice

1289
01:09:43,560 --> 01:09:55,130
a non divided version you just multiply

1290
01:09:45,630 --> 01:09:55,130
and and you can even do it without 64

1291
01:09:57,619 --> 01:10:09,599
Wow 2001 that's pretty late so it looks

1292
01:10:07,170 --> 01:10:13,220
like there's nothing you can do other

1293
01:10:09,600 --> 01:10:15,090
than the constructed well-constructed

1294
01:10:13,220 --> 01:10:17,310
mathematical ops there's no actual

1295
01:10:15,090 --> 01:10:23,119
straight bit twiddle you can do you've

1296
01:10:17,310 --> 01:10:26,260
got to use and multiply which is cool

1297
01:10:23,119 --> 01:10:26,260
[Music]

1298
01:10:29,899 --> 01:10:34,289
but I guess that also does beg the

1299
01:10:32,250 --> 01:10:42,300
question so how big is the biggest one

1300
01:10:34,289 --> 01:10:49,550
I'm gonna have to read big so table wise

1301
01:10:42,300 --> 01:10:49,550
I might have to read up to 13 bits right

1302
01:10:49,579 --> 01:11:08,279
so I don't know a 13 bit table so it's

1303
01:11:05,789 --> 01:11:10,319
really 2 to the 14 right because it's 2

1304
01:11:08,279 --> 01:11:14,759
to the 13 for the size of table times

1305
01:11:10,319 --> 01:11:18,539
two bytes which is the size it's a good

1306
01:11:14,760 --> 01:11:20,400
so you sixteen right if it's reversed so

1307
01:11:18,539 --> 01:11:21,989
I don't know a 16 K table I'm gonna have

1308
01:11:20,399 --> 01:11:25,409
to go ahead and say I think we probably

1309
01:11:21,989 --> 01:11:31,369
can just I think we probably just do the

1310
01:11:25,409 --> 01:11:34,889
table to be honest so let's let's take

1311
01:11:31,369 --> 01:11:37,369
this guy here and actually make this be

1312
01:11:34,890 --> 01:11:37,369
a a thing

1313
01:11:47,460 --> 01:11:55,000
why did they do this I do not understand

1314
01:11:52,329 --> 01:11:59,319
the rationale for having the bits come

1315
01:11:55,000 --> 01:12:01,420
in in the wrong order if the entire spec

1316
01:11:59,319 --> 01:12:03,429
that been written that way I would

1317
01:12:01,420 --> 01:12:06,930
understand but it specifically brings in

1318
01:12:03,430 --> 01:12:13,900
LS B's normally for all the other values

1319
01:12:06,930 --> 01:12:15,820
it's real weird I don't get it I hope

1320
01:12:13,899 --> 01:12:28,779
they had a reason I just don't know what

1321
01:12:15,819 --> 01:12:33,670
the reason is so here we are you pass in

1322
01:12:28,779 --> 01:12:45,969
the bit count and it'll do the reverse

1323
01:12:33,670 --> 01:12:50,050
of that drop down here so we'll do a

1324
01:12:45,970 --> 01:12:52,810
reverse bits you pass in the thing you

1325
01:12:50,050 --> 01:12:56,550
want to reverse and how many bits there

1326
01:12:52,810 --> 01:12:56,550
are and it'll do its thing

1327
01:13:04,420 --> 01:13:10,710
I that's just the same value right yeah

1328
01:13:20,369 --> 01:13:49,779
okay so I think that does it

1329
01:13:38,739 --> 01:14:01,229
I hope so what happens if the value is

1330
01:13:49,779 --> 01:14:01,229
odd so I think you're still okay

1331
01:14:10,750 --> 01:14:17,539
are you still okay so if the values odd

1332
01:14:13,670 --> 01:14:19,760
does it hit the middle bit properly so

1333
01:14:17,539 --> 01:14:25,039
let's suppose your slip flippin seven

1334
01:14:19,760 --> 01:14:27,230
bits then 7/2 yeah because you go up you

1335
01:14:25,039 --> 01:14:29,569
do the middle one and it just it just

1336
01:14:27,229 --> 01:14:38,599
writes it onto itself so both of these

1337
01:14:29,569 --> 01:14:40,819
things produce the same result all right

1338
01:14:38,600 --> 01:14:43,179
so if we have our little reverse bits

1339
01:14:40,819 --> 01:14:46,099
here then we have to do our table build

1340
01:14:43,179 --> 01:14:51,469
and we know that the table goes up to

1341
01:14:46,100 --> 01:14:54,230
thirteen so well we can we know that we

1342
01:14:51,469 --> 01:14:56,118
have to do everything from 0 to 13 so

1343
01:14:54,229 --> 01:15:01,118
it's a 14 entry table might be a better

1344
01:14:56,118 --> 01:15:01,118
way to say it so

1345
01:15:11,359 --> 01:15:25,309
I shouldn't have said 14th retable I

1346
01:15:22,248 --> 01:15:29,628
should say it's one shift up 13 is how

1347
01:15:25,309 --> 01:15:31,699
many entries are on the table so when we

1348
01:15:29,628 --> 01:15:35,599
come in here we have to initialize so we

1349
01:15:31,698 --> 01:15:38,779
can go our index equals zero our index

1350
01:15:35,599 --> 01:15:42,588
is less than or a count first bits plus

1351
01:15:38,779 --> 01:15:44,328
plus our index now if we wanted to here

1352
01:15:42,588 --> 01:15:46,038
we could even make this table even

1353
01:15:44,328 --> 01:15:47,569
bigger and just do it when we build our

1354
01:15:46,038 --> 01:15:50,088
other table as well I don't think we

1355
01:15:47,569 --> 01:15:54,648
need to do that so I'm just gonna do

1356
01:15:50,088 --> 01:15:56,510
just reverse fits our index here what I

1357
01:15:54,649 --> 01:15:59,838
want to do here is just say like okay

1358
01:15:56,510 --> 01:16:04,119
the are whatever the reverse version is

1359
01:15:59,838 --> 01:16:04,118
here I'm just going to reverse the value

1360
01:16:04,208 --> 01:16:15,108
and wait no this is way worse because I

1361
01:16:11,599 --> 01:16:19,849
have to do it for each of these sizes

1362
01:16:15,109 --> 01:16:23,088
too cuz can you can you do can you still

1363
01:16:19,849 --> 01:16:25,849
you can't use the table of bit reversion

1364
01:16:23,088 --> 01:16:30,800
unless you know which size of these

1365
01:16:25,849 --> 01:16:32,479
you're using - oh that's awful alright

1366
01:16:30,800 --> 01:16:34,809
I'm gonna I'm gonna do the procedural

1367
01:16:32,479 --> 01:16:34,809
way then

1368
01:16:43,520 --> 01:16:49,350
because I think that would that would

1369
01:16:45,779 --> 01:16:54,119
just be oh no you know okay no no

1370
01:16:49,350 --> 01:16:55,949
so we can't still do it the problem is

1371
01:16:54,119 --> 01:17:00,979
we have to do a shift afterwards right

1372
01:16:55,948 --> 01:17:05,009
so if we have a thirteen bit table and

1373
01:17:00,979 --> 01:17:07,439
we want to look up the reversed value we

1374
01:17:05,010 --> 01:17:09,150
can still look up the reverse value but

1375
01:17:07,439 --> 01:17:10,738
we have to shift down the result by the

1376
01:17:09,149 --> 01:17:13,679
difference in the number of bits that

1377
01:17:10,738 --> 01:17:16,709
we're talking about right so if we're

1378
01:17:13,679 --> 01:17:18,149
only want three bits reversed we can

1379
01:17:16,710 --> 01:17:20,640
still look up those three bits in the

1380
01:17:18,149 --> 01:17:22,409
thirteen bit table but then they're

1381
01:17:20,640 --> 01:17:25,800
gonna flip to the high side and so we

1382
01:17:22,409 --> 01:17:27,719
need to shift them down by thirty minus

1383
01:17:25,800 --> 01:17:29,760
three right to get rid of the ten bits

1384
01:17:27,719 --> 01:17:31,439
that we don't actually care about to see

1385
01:17:29,760 --> 01:17:33,150
which ones we do care about so that's

1386
01:17:31,439 --> 01:17:36,619
actually not as bad as I thought it was

1387
01:17:33,149 --> 01:17:41,670
when I just said it it's still okay I

1388
01:17:36,619 --> 01:17:47,880
guess that's how I would put it right so

1389
01:17:41,670 --> 01:17:52,250
I think that's all right okay so we

1390
01:17:47,880 --> 01:17:52,250
still need to get one more table here

1391
01:17:53,000 --> 01:17:59,969
this is for dis extra this is the same

1392
01:17:57,390 --> 01:18:03,119
exact thing as the other one but now

1393
01:17:59,969 --> 01:18:08,100
we've got this nonsense here right so

1394
01:18:03,119 --> 01:18:10,769
it's exact same thing it's just it's

1395
01:18:08,100 --> 01:18:12,900
kind of got its own little yeah it's

1396
01:18:10,770 --> 01:18:15,300
it's got a very small number of values

1397
01:18:12,899 --> 01:18:17,309
and a very large number of extra bits is

1398
01:18:15,300 --> 01:18:20,250
basically what it what it boils down to

1399
01:18:17,310 --> 01:18:22,980
and what I think we want to do here is

1400
01:18:20,250 --> 01:18:25,738
rather than do the number that you would

1401
01:18:22,979 --> 01:18:28,609
subtract I think what we want to do here

1402
01:18:25,738 --> 01:18:28,609
it looks like

1403
01:18:37,788 --> 01:18:47,819
it looks like here we'd want to do the

1404
01:18:40,260 --> 01:18:53,489
number you add so it's like the starting

1405
01:18:47,819 --> 01:18:56,130
number right okay so here if we get code

1406
01:18:53,488 --> 01:19:05,419
0 the distance is 1 and there are no

1407
01:18:56,130 --> 01:19:05,420
extra bits and that is code 0

1408
01:19:24,880 --> 01:19:33,400
actually that was a mistake like that

1409
01:19:36,310 --> 01:19:51,620
butterfingers so you can only have 29

1410
01:19:40,970 --> 01:19:53,060
values it looks like so I guess they

1411
01:19:51,619 --> 01:19:54,710
just don't allow the huffman table to

1412
01:19:53,060 --> 01:19:57,170
have any more than 29 symbols in it

1413
01:19:54,710 --> 01:19:58,699
that's just how they did it

1414
01:19:57,170 --> 01:20:02,899
so there's only 29 symbols in the

1415
01:19:58,699 --> 01:20:05,179
huffman table which is fine if that's

1416
01:20:02,899 --> 01:20:08,689
what we're dealing with here so we know

1417
01:20:05,180 --> 01:20:11,800
we've got zero zero zero bytes I guess

1418
01:20:08,689 --> 01:20:14,389
I'll just do these one at a time so the

1419
01:20:11,800 --> 01:20:18,289
distance is two for the code length of

1420
01:20:14,390 --> 01:20:19,850
one the distance is three and four so

1421
01:20:18,289 --> 01:20:21,260
this is just the starting distance and

1422
01:20:19,850 --> 01:20:24,710
then you read this many bits and you add

1423
01:20:21,260 --> 01:20:26,150
it in right and of course there are no

1424
01:20:24,710 --> 01:20:29,239
bits to read this time so then we have

1425
01:20:26,149 --> 01:20:31,429
two ones the distances are five and

1426
01:20:29,239 --> 01:20:33,649
seven looks like so you start with the

1427
01:20:31,430 --> 01:20:38,180
five or the seven you add the one in

1428
01:20:33,649 --> 01:20:44,269
there two twos mm-hmm so that's nine and

1429
01:20:38,180 --> 01:20:48,430
thirteen starting points two threes 17

1430
01:20:44,270 --> 01:20:48,430
and five oops

1431
01:20:55,130 --> 01:20:59,769
two fours thirty three and forty nine

1432
01:21:01,510 --> 01:21:29,539
sixty five and ninety seven two sixes

1433
01:21:19,510 --> 01:21:36,369
and that's 129 and 103 two sevens well

1434
01:21:29,538 --> 01:21:36,368
it's two rates two nines - tends to 11s

1435
01:21:38,109 --> 01:22:03,130
to 12 to 13 so yeah then from there we

1436
01:21:47,719 --> 01:22:27,139
just go so 193 we have 257 385 513 769

1437
01:22:03,130 --> 01:22:34,118
1025 1537 2049 3073 4097 6145 81 90 312

1438
01:22:27,139 --> 01:22:34,118
289 16 385

1439
01:22:34,380 --> 01:22:57,510
and twenty four or five seven seven okay

1440
01:22:44,579 --> 01:23:02,039
so we now have our two tables that will

1441
01:22:57,510 --> 01:23:04,770
sort of decrypt for us what we need to

1442
01:23:02,039 --> 01:23:09,600
know to read the extra bits and we have

1443
01:23:04,770 --> 01:23:12,450
a way to reverse the bits as well I will

1444
01:23:09,600 --> 01:23:14,550
not use this table yet

1445
01:23:12,449 --> 01:23:16,439
I'll just call River it's manual but

1446
01:23:14,550 --> 01:23:18,060
reverse manual because we know that

1447
01:23:16,439 --> 01:23:20,659
works or at least we think that works uh

1448
01:23:18,060 --> 01:23:22,800
and then we'll get the table working

1449
01:23:20,659 --> 01:23:24,119
because I think we don't want to sit

1450
01:23:22,800 --> 01:23:26,789
there reversing the bits manual like

1451
01:23:24,119 --> 01:23:30,289
that that sounds nuts

1452
01:23:26,789 --> 01:23:33,720
okay so looking through here we've got

1453
01:23:30,289 --> 01:23:34,409
all that read stuff happening it's all

1454
01:23:33,720 --> 01:23:42,480
fine

1455
01:23:34,409 --> 01:23:43,949
let me put us over here so let's go

1456
01:23:42,479 --> 01:23:46,649
ahead and read from those two tables and

1457
01:23:43,949 --> 01:23:49,050
do what they say because that's the next

1458
01:23:46,649 --> 01:23:51,079
step so in the case where we're not

1459
01:23:49,050 --> 01:23:55,190
outputting a literal so this is the

1460
01:23:51,079 --> 01:23:59,119
literal I don't know why I put out there

1461
01:23:55,189 --> 01:23:59,119
probably should have done this I guess

1462
01:24:01,670 --> 01:24:05,850
so

1463
01:24:03,090 --> 01:24:09,029
when we get the little n that's over 256

1464
01:24:05,850 --> 01:24:13,410
then we need to do is actually decode

1465
01:24:09,029 --> 01:24:18,319
the value using the table so the little

1466
01:24:13,409 --> 01:24:24,389
N minus 256 is actually a table index

1467
01:24:18,319 --> 01:24:27,029
so this is our lenta index here and

1468
01:24:24,390 --> 01:24:28,829
that's gonna tell us the rest of the

1469
01:24:27,029 --> 01:24:31,500
information after we actually look it up

1470
01:24:28,829 --> 01:24:35,550
right so we have a Huffman entry here

1471
01:24:31,500 --> 01:24:37,500
which is the line' tab entry that's

1472
01:24:35,550 --> 01:24:40,619
going to be the PNG length extra table

1473
01:24:37,500 --> 01:24:42,420
looked up by that value that will give

1474
01:24:40,619 --> 01:24:43,619
us two things one it will give us the

1475
01:24:42,420 --> 01:24:46,310
extra bits that we need to actually

1476
01:24:43,619 --> 01:24:46,309
consume

1477
01:24:48,180 --> 01:24:58,000
so if the lent Abbe wouldn't I call that

1478
01:24:52,510 --> 01:24:59,920
value it's used so if there's a bit used

1479
01:24:58,000 --> 01:25:02,289
we actually do some stuff otherwise we

1480
01:24:59,920 --> 01:25:05,590
don't so we'll look at that in a second

1481
01:25:02,289 --> 01:25:07,960
here so we start off with the length the

1482
01:25:05,590 --> 01:25:13,810
length is assumed to be whatever the Len

1483
01:25:07,960 --> 01:25:17,140
tab index was actually it's whatever the

1484
01:25:13,810 --> 01:25:20,530
literal length was - whatever the symbol

1485
01:25:17,140 --> 01:25:22,869
value here was right now that I think

1486
01:25:20,529 --> 01:25:25,269
about it since I already had the line'

1487
01:25:22,869 --> 01:25:29,590
tab - 36 here I probably could simplify

1488
01:25:25,270 --> 01:25:31,150
that table to just be the AB value if we

1489
01:25:29,590 --> 01:25:33,819
had wanted to do it that way which

1490
01:25:31,149 --> 01:25:37,599
probably would have been smarter but

1491
01:25:33,819 --> 01:25:41,619
well it doesn't matter anyway so anyway

1492
01:25:37,600 --> 01:25:46,060
we come in here we get the the ya I

1493
01:25:41,619 --> 01:25:47,710
don't know why I didn't do that it seems

1494
01:25:46,060 --> 01:25:51,070
weird for that I didn't do that I'm not

1495
01:25:47,710 --> 01:25:53,250
sure why I didn't do that let me let me

1496
01:25:51,069 --> 01:25:53,250
read

1497
01:25:57,670 --> 01:26:02,480
because when we look this up here I

1498
01:26:00,109 --> 01:26:05,569
don't know why I didn't just set this to

1499
01:26:02,479 --> 01:26:07,329
be the value that you start with I made

1500
01:26:05,569 --> 01:26:11,420
like my life harder for no reason right

1501
01:26:07,329 --> 01:26:13,579
because here it's just 257 the length is

1502
01:26:11,420 --> 01:26:15,679
three right so this should have just

1503
01:26:13,579 --> 01:26:32,300
been that I don't know why it wasn't so

1504
01:26:15,679 --> 01:26:42,550
it's just 3 4 5 6 7 8 9 10 11 13 15 17

1505
01:26:32,300 --> 01:26:53,000
19 okay three twenty seven thirty one

1506
01:26:42,550 --> 01:27:08,710
thirty five forty three one nine six

1507
01:26:53,000 --> 01:27:17,000
seven eight three nine one 1530 163 195

1508
01:27:08,710 --> 01:27:18,710
227 258 alright so let's try it again

1509
01:27:17,000 --> 01:27:21,260
so when we go ahead and create the

1510
01:27:18,710 --> 01:27:24,619
length now all we need to do is just

1511
01:27:21,260 --> 01:27:27,159
start with the length table symbol and

1512
01:27:24,619 --> 01:27:31,630
then if there's more bits we just add

1513
01:27:27,159 --> 01:27:31,630
whatever the consumed its value is

1514
01:27:36,340 --> 01:27:40,210
however many told us

1515
01:27:41,719 --> 01:27:52,159
what was it bits used yeah

1516
01:27:47,119 --> 01:27:54,619
however Romania told us to do there and

1517
01:27:52,159 --> 01:28:07,430
whatever comes back we need to reverse

1518
01:27:54,619 --> 01:28:18,948
right so that's how many bits that's the

1519
01:28:07,430 --> 01:28:25,640
one to reverse it's like this so reverse

1520
01:28:18,948 --> 01:28:33,679
bits takes what's the value in the bit

1521
01:28:25,640 --> 01:28:37,369
count I think that's all good and then

1522
01:28:33,680 --> 01:28:40,000
we add that so that's how we decode that

1523
01:28:37,369 --> 01:28:40,000
symbol

1524
01:28:51,710 --> 01:28:55,020
yeah

1525
01:28:52,979 --> 01:28:58,769
so then when we get the distance value

1526
01:28:55,020 --> 01:29:01,830
back the distance value is actually the

1527
01:28:58,770 --> 01:29:03,600
distance table index right because it

1528
01:29:01,829 --> 01:29:07,829
doesn't actually tell us anything other

1529
01:29:03,600 --> 01:29:09,210
than what to look up because we're about

1530
01:29:07,829 --> 01:29:12,300
to grab a bunch more bits from the

1531
01:29:09,210 --> 01:29:14,510
stream so then what we want to do is

1532
01:29:12,300 --> 01:29:17,730
look up the PNG Huffman entry for that

1533
01:29:14,510 --> 01:29:21,630
the PNG Huffman entry for that is gonna

1534
01:29:17,729 --> 01:29:24,029
be whatever the distaff index is here's

1535
01:29:21,630 --> 01:29:27,180
the disk table then what we're gonna say

1536
01:29:24,029 --> 01:29:28,829
is all right the distance itself which

1537
01:29:27,180 --> 01:29:30,780
again is backwards so it's actually

1538
01:29:28,829 --> 01:29:34,319
negative but we don't care because we're

1539
01:29:30,779 --> 01:29:37,170
real subtract later so the disk table

1540
01:29:34,319 --> 01:29:38,340
symbol is what we start with and then

1541
01:29:37,170 --> 01:29:39,600
this is exactly the same we could

1542
01:29:38,340 --> 01:29:40,890
actually make our utility function first

1543
01:29:39,600 --> 01:29:42,630
if you wanted to because this is gonna

1544
01:29:40,890 --> 01:29:44,640
do exactly the same thing so it's gonna

1545
01:29:42,630 --> 01:29:50,250
take a look and see do we need any extra

1546
01:29:44,640 --> 01:29:52,230
bits if we do need extra bits then we're

1547
01:29:50,250 --> 01:29:55,710
gonna consume those bits and we're going

1548
01:29:52,229 --> 01:29:57,839
to reverse them then we're going to add

1549
01:29:55,710 --> 01:30:01,380
them into the distance to produce our

1550
01:29:57,840 --> 01:30:04,890
final distance value then when we're all

1551
01:30:01,380 --> 01:30:08,369
done with that now we actually go

1552
01:30:04,890 --> 01:30:12,060
through and copy out so we need a source

1553
01:30:08,369 --> 01:30:14,039
value here our source value is going to

1554
01:30:12,060 --> 01:30:18,210
be wherever we're at in our destination

1555
01:30:14,039 --> 01:30:22,019
stream minus the distance that we're

1556
01:30:18,210 --> 01:30:24,449
traveling backwards right and then we

1557
01:30:22,020 --> 01:30:31,760
want to do a count down so we take our

1558
01:30:24,449 --> 01:30:36,989
length and we just copy the values in

1559
01:30:31,760 --> 01:30:38,970
and I should note here that I don't

1560
01:30:36,989 --> 01:30:41,369
really know if it's subtract distance or

1561
01:30:38,970 --> 01:30:43,470
if its distance plus one I assume that

1562
01:30:41,369 --> 01:30:46,199
it's just the distance here because the

1563
01:30:43,470 --> 01:30:50,610
distance starts at one so I assume that

1564
01:30:46,199 --> 01:30:54,960
it's just a negative distance so I start

1565
01:30:50,609 --> 01:30:58,019
where I'm at I go back and then I copy

1566
01:30:54,960 --> 01:30:59,579
right now what I can do here just a try

1567
01:30:58,020 --> 01:31:01,620
and again put in more assertions to

1568
01:30:59,579 --> 01:31:02,789
catch like when we're interpreting the

1569
01:31:01,619 --> 01:31:04,739
code stream wrong

1570
01:31:02,789 --> 01:31:07,289
what I can do is I can say if the

1571
01:31:04,739 --> 01:31:10,889
distance would have moved me back like

1572
01:31:07,289 --> 01:31:14,729
if the source is now less than where I

1573
01:31:10,890 --> 01:31:17,940
started right so you know the the

1574
01:31:14,729 --> 01:31:18,869
decompressed pixels here then I I

1575
01:31:17,939 --> 01:31:21,569
screwed up

1576
01:31:18,869 --> 01:31:28,319
right I've obviously got the thing wrong

1577
01:31:21,569 --> 01:31:30,630
so if we got if I can just assert that

1578
01:31:28,319 --> 01:31:33,329
source is greater than equal to you can

1579
01:31:30,630 --> 01:31:35,250
press pixels right because the distance

1580
01:31:33,329 --> 01:31:37,109
value if it moves us back before the end

1581
01:31:35,250 --> 01:31:39,359
of the pixel the start of the pixels

1582
01:31:37,109 --> 01:31:44,639
unless it was a malformed stream which

1583
01:31:39,359 --> 01:31:46,649
again we know it's not we like we know

1584
01:31:44,640 --> 01:31:48,450
we did something wrong in our decoding

1585
01:31:46,649 --> 01:31:52,849
so that's just a another way to help

1586
01:31:48,449 --> 01:31:52,849
catch the error right

1587
01:32:06,340 --> 01:32:19,489
max reverse bits count is 13 so that's

1588
01:32:16,130 --> 01:32:28,429
the way all of these soups are gonna be

1589
01:32:19,488 --> 01:32:32,498
reversed okay um so I have no idea what

1590
01:32:28,429 --> 01:32:34,940
that's gonna do but hey we did our best

1591
01:32:32,498 --> 01:32:37,448
so let's see where we're at and we can

1592
01:32:34,939 --> 01:32:40,609
debug the rest of it next weekend

1593
01:32:37,448 --> 01:32:43,848
because we're out of time so the literal

1594
01:32:40,609 --> 01:32:48,170
length that we got the first thing here

1595
01:32:43,849 --> 01:32:50,479
was 1 which is a literal of 1 that

1596
01:32:48,170 --> 01:32:55,340
sounds wrong so I'm assuming we did

1597
01:32:50,479 --> 01:32:58,099
something wrong I don't know why you

1598
01:32:55,340 --> 01:33:04,940
would output a bite of one as the first

1599
01:32:58,099 --> 01:33:10,599
thing doesn't really make any sense then

1600
01:33:04,939 --> 01:33:13,779
we get a little n of 255 which is

1601
01:33:10,599 --> 01:33:16,159
actually what we would have expected

1602
01:33:13,779 --> 01:33:23,359
because that's what we put in the data

1603
01:33:16,158 --> 01:33:26,658
stream so I don't know where that one

1604
01:33:23,359 --> 01:33:34,518
that one seems wrong the other values

1605
01:33:26,658 --> 01:33:37,069
seemed right then we got a 263 so a 263

1606
01:33:34,519 --> 01:33:40,940
is going to tell us something about our

1607
01:33:37,069 --> 01:33:43,488
length here starts at 10 there's no

1608
01:33:40,939 --> 01:33:49,899
extra bits used so it's a rep of 10 in

1609
01:33:43,488 --> 01:33:49,899
theory let's see what our distance said

1610
01:33:50,109 --> 01:33:54,219
our distance value is 3

1611
01:33:55,170 --> 01:33:59,250
wait what ah I know that's the wrong

1612
01:33:57,989 --> 01:34:01,829
table I'm like it shouldn't be three it

1613
01:33:59,250 --> 01:34:08,100
should have been one so that table I

1614
01:34:01,829 --> 01:34:13,739
typed the wrong table there let's try

1615
01:34:08,100 --> 01:34:15,240
that one more time alright so this time

1616
01:34:13,739 --> 01:34:19,649
we should see that come back as a one

1617
01:34:15,239 --> 01:34:21,510
now and it does so now we're starting to

1618
01:34:19,649 --> 01:34:25,679
copy from there we're gonna copy some

1619
01:34:21,510 --> 01:34:29,190
values from that into the stream so you

1620
01:34:25,680 --> 01:34:32,210
know it's working but I'm not sure we're

1621
01:34:29,189 --> 01:34:34,500
really actually getting sensible values

1622
01:34:32,210 --> 01:34:37,770
we'll have to go inspect what the pixels

1623
01:34:34,500 --> 01:34:40,500
are and see we also don't know what

1624
01:34:37,770 --> 01:34:43,380
transforms were applied because there's

1625
01:34:40,500 --> 01:34:47,760
obviously filters that get applied to

1626
01:34:43,380 --> 01:34:50,880
things so we'll see so okay so that's

1627
01:34:47,760 --> 01:34:55,530
the deflate stuff I we don't so the this

1628
01:34:50,880 --> 01:34:57,329
is not necessarily a decompressed this

1629
01:34:55,529 --> 01:34:58,979
this is not necessarily to be compressed

1630
01:34:57,329 --> 01:35:00,659
pixels because there's the filter stuff

1631
01:34:58,979 --> 01:35:04,729
that gets applied and I haven't looked

1632
01:35:00,659 --> 01:35:08,099
at that yet so when we look at the ID at

1633
01:35:04,729 --> 01:35:10,589
here let's actually just quick read in

1634
01:35:08,100 --> 01:35:12,930
preparation for next week what what do

1635
01:35:10,590 --> 01:35:15,329
we actually expect to see maybe that one

1636
01:35:12,930 --> 01:35:19,650
means filter mode one or something so

1637
01:35:15,329 --> 01:35:24,809
maybe that isn't wrong you know who

1638
01:35:19,649 --> 01:35:27,299
knows so let's take a look at that yet I

1639
01:35:24,810 --> 01:35:28,440
don't indicate begin with image scan

1640
01:35:27,300 --> 01:35:30,000
lines represent starting the image

1641
01:35:28,439 --> 01:35:32,669
layout the layout and total size let's

1642
01:35:30,000 --> 01:35:35,069
run our turbo field I had her focus the

1643
01:35:32,670 --> 01:35:38,310
originator economy I had her chunk note

1644
01:35:35,069 --> 01:35:40,439
the filter meant to 0 implies gonna be

1645
01:35:38,310 --> 01:35:42,930
pending a filter type bite to eat scan

1646
01:35:40,439 --> 01:35:43,559
line hooray so that one probably was

1647
01:35:42,930 --> 01:35:47,100
correct

1648
01:35:43,560 --> 01:35:50,430
it's probably the filter type and we're

1649
01:35:47,100 --> 01:35:54,560
good to go and off we go compress the

1650
01:35:50,430 --> 01:35:58,530
filter data so okay so image layout

1651
01:35:54,560 --> 01:36:00,240
we've got two color pixels pieces ruin I

1652
01:35:58,529 --> 01:36:02,219
right I just flip typewriters I the

1653
01:36:00,239 --> 01:36:03,389
beginning of every scan line this little

1654
01:36:02,220 --> 01:36:05,250
bike is knocking sir brother you miss

1655
01:36:03,390 --> 01:36:08,420
data but is included in the data stream

1656
01:36:05,250 --> 01:36:12,079
sent to the compression step okay

1657
01:36:08,420 --> 01:36:16,970
so actually actually-- the first bite of

1658
01:36:12,079 --> 01:36:21,439
every scanline is a filter bite which

1659
01:36:16,970 --> 01:36:23,210
means that if we were doing decompressed

1660
01:36:21,439 --> 01:36:27,559
pixels here we're actually gonna do

1661
01:36:23,210 --> 01:36:33,350
decompress pixels plus one which gives

1662
01:36:27,560 --> 01:36:37,430
us a place to store that that filter by

1663
01:36:33,350 --> 01:36:38,850
right although it's not actually a plus

1664
01:36:37,430 --> 01:36:40,390
one

1665
01:36:38,850 --> 01:36:46,520
[Music]

1666
01:36:40,390 --> 01:36:55,640
it's because it's not it doesn't need a

1667
01:36:46,520 --> 01:37:00,260
whole u-32 so yeah I don't want a

1668
01:36:55,640 --> 01:37:02,510
special case that I mean I guess what I

1669
01:37:00,260 --> 01:37:04,550
could do is try to retire a scanline at

1670
01:37:02,510 --> 01:37:06,199
a time but you could compress right

1671
01:37:04,550 --> 01:37:12,380
through that so I don't think that's a

1672
01:37:06,199 --> 01:37:16,130
particularly good idea why wouldn't you

1673
01:37:12,380 --> 01:37:22,730
put all the filter bytes in one row by

1674
01:37:16,130 --> 01:37:23,060
themselves right I mean come on all

1675
01:37:22,729 --> 01:37:25,449
right

1676
01:37:23,060 --> 01:37:25,450
it's fine

1677
01:37:26,350 --> 01:37:31,310
so I'm just gonna say like hey the

1678
01:37:29,449 --> 01:37:33,609
allocate pixels call is smart enough to

1679
01:37:31,310 --> 01:37:33,610
do that

1680
01:37:49,088 --> 01:38:05,349
so we'll add like this thing now so

1681
01:38:02,319 --> 01:38:07,760
there's just one of those per scanline

1682
01:38:05,349 --> 01:38:12,139
and it doesn't get multiplied by the

1683
01:38:07,760 --> 01:38:15,588
thing all right so that decompresses

1684
01:38:12,139 --> 01:38:17,838
some stuff and it's whatever that's just

1685
01:38:15,588 --> 01:38:19,578
okay I don't know I'm not a compressive

1686
01:38:17,838 --> 01:38:23,029
compression person so maybe I shouldn't

1687
01:38:19,578 --> 01:38:25,038
call it dumb but that seems real dumb I

1688
01:38:23,029 --> 01:38:27,588
don't know why you wouldn't store all

1689
01:38:25,038 --> 01:38:31,038
the filter types together because why

1690
01:38:27,588 --> 01:38:36,408
would those compress along with the scan

1691
01:38:31,038 --> 01:38:39,588
lines like the coherency is gonna be in

1692
01:38:36,408 --> 01:38:42,049
the filter bytes not the pixels that go

1693
01:38:39,588 --> 01:38:43,639
with the filter by it's right unless you

1694
01:38:42,050 --> 01:38:46,010
think all the scan lines are gonna be

1695
01:38:43,639 --> 01:38:48,378
full duped but even if they were you'd

1696
01:38:46,010 --> 01:38:51,619
still could just do that rep twice and

1697
01:38:48,378 --> 01:38:54,800
you're not gonna save very much so that

1698
01:38:51,618 --> 01:39:01,818
seems real dumb all right so let's see

1699
01:38:54,800 --> 01:39:04,359
where we're at here so it looks like

1700
01:39:01,819 --> 01:39:04,359
we're getting

1701
01:39:06,760 --> 01:39:10,900
how far does dest

1702
01:39:13,929 --> 01:39:18,408
so the test there's only 26 away but

1703
01:39:16,460 --> 01:39:21,408
it's getting like a distance value of

1704
01:39:18,408 --> 01:39:23,599
107 so that's obviously wrong right so

1705
01:39:21,408 --> 01:39:25,519
we get some we got some badness

1706
01:39:23,600 --> 01:39:28,850
happening already

1707
01:39:25,520 --> 01:39:35,360
so this stuff's probably wrong we'll go

1708
01:39:28,850 --> 01:39:38,060
ahead and start work on this next

1709
01:39:35,359 --> 01:39:39,469
weekend I'll go to QA now but we meet a

1710
01:39:38,060 --> 01:39:41,330
lot of progress I think like we're

1711
01:39:39,469 --> 01:39:43,819
actually decoding stuff now I think

1712
01:39:41,329 --> 01:39:46,840
we're pretty close so I don't think

1713
01:39:43,819 --> 01:39:46,840
they'll be that much more

1714
01:40:04,838 --> 01:40:11,899
ratchet freak little in my history let's

1715
01:40:07,550 --> 01:40:14,469
my you you are right sir you are very

1716
01:40:11,899 --> 01:40:14,469
right

1717
01:40:15,340 --> 01:40:18,538
[Music]

1718
01:40:20,670 --> 01:40:24,399
thank you for that that I mean I

1719
01:40:23,109 --> 01:40:26,228
probably would have taken a while to

1720
01:40:24,399 --> 01:40:27,339
catch that as we walked through as we

1721
01:40:26,229 --> 01:40:30,760
started to bugging it the next time

1722
01:40:27,340 --> 01:40:31,809
that's that's real good so presumably

1723
01:40:30,760 --> 01:40:32,739
we'll get a different thing here

1724
01:40:31,809 --> 01:40:47,019
although I don't know we maybe look at

1725
01:40:32,738 --> 01:40:55,089
the same thing what happened to so this

1726
01:40:47,019 --> 01:40:58,659
was the source was did it just read too

1727
01:40:55,090 --> 01:41:00,550
far was the length value huge so we

1728
01:40:58,658 --> 01:41:07,109
should I mean I got a step through it to

1729
01:41:00,550 --> 01:41:07,110
see what actually went wrong here

1730
01:41:17,000 --> 01:41:27,350
at scale but once this works do you

1731
01:41:19,159 --> 01:41:29,000
think it could be sim deed no it's a

1732
01:41:27,350 --> 01:41:31,190
highly dependent it's like reading

1733
01:41:29,000 --> 01:41:32,689
individual bits all the time so I mean

1734
01:41:31,189 --> 01:41:35,839
you could maybe do something with like

1735
01:41:32,689 --> 01:41:47,210
this part to copy bigger chunks or

1736
01:41:35,840 --> 01:41:50,319
something but it'll also be clear if you

1737
01:41:47,210 --> 01:41:53,270
write little n greater than equal to 257

1738
01:41:50,319 --> 01:42:04,909
yeah I guess that's true we could do

1739
01:41:53,270 --> 01:42:06,440
this so it's easier to see I mean

1740
01:42:04,909 --> 01:42:08,239
suppose for that matter you call us to

1741
01:42:06,439 --> 01:42:18,369
do that so it's clearer that this is a

1742
01:42:08,239 --> 01:42:20,659
byte output I don't know how how that

1743
01:42:18,369 --> 01:42:23,409
seems maybe maybe that's six and one

1744
01:42:20,659 --> 01:42:23,409
half dozen on the other

1745
01:42:28,340 --> 01:42:31,760
when you're making a PNG reader I assume

1746
01:42:30,380 --> 01:42:35,900
you want game textures to be in PNG

1747
01:42:31,760 --> 01:42:37,489
format no we that is not true for my

1748
01:42:35,899 --> 01:42:39,229
projects I create uncompressed image

1749
01:42:37,489 --> 01:42:41,239
data and then archive them all with the

1750
01:42:39,229 --> 01:42:43,309
sum compressor is my approach a bad one

1751
01:42:41,239 --> 01:42:45,739
I asked because I know we we are not

1752
01:42:43,310 --> 01:42:47,510
using pngs for a game format this is

1753
01:42:45,739 --> 01:42:49,670
because we just wanted to have a quick

1754
01:42:47,510 --> 01:42:51,260
way to get Photoshop exports into the

1755
01:42:49,670 --> 01:42:53,899
game and Photoshop has a bunch of quick

1756
01:42:51,260 --> 01:42:56,030
PNG export stuff that are like it's

1757
01:42:53,899 --> 01:42:57,889
hard-coded into it you can't change it

1758
01:42:56,029 --> 01:43:02,300
to do use BMPs or something that's

1759
01:42:57,890 --> 01:43:03,860
easier to read so no I don't care about

1760
01:43:02,300 --> 01:43:06,560
P and G's of storage format at all it's

1761
01:43:03,859 --> 01:43:10,759
a dumb format I would never store a game

1762
01:43:06,560 --> 01:43:17,600
asset in a PNG it's just to read in

1763
01:43:10,760 --> 01:43:22,100
Photoshop should reverse fit stable be

1764
01:43:17,600 --> 01:43:24,170
you 16 and not you 32 it could be I mean

1765
01:43:22,100 --> 01:43:26,690
it doesn't really matter I guess it's

1766
01:43:24,170 --> 01:43:29,500
probably better to be to be smaller so

1767
01:43:26,689 --> 01:43:29,500
I'm sure

1768
01:43:44,538 --> 01:43:54,569
so in that case where we do reverse bits

1769
01:43:48,300 --> 01:43:57,920
there I should just cast it down so that

1770
01:43:54,569 --> 01:43:57,920
should still do the same stuff right

1771
01:44:04,840 --> 01:44:08,900
no--but reversals needed see deflate

1772
01:44:07,039 --> 01:44:10,850
select three one one first two bullet

1773
01:44:08,899 --> 01:44:12,739
points Shawn this is cheating because

1774
01:44:10,850 --> 01:44:20,990
you've already written a PNG compressor

1775
01:44:12,739 --> 01:44:23,199
you're not supposed to be helping I feel

1776
01:44:20,989 --> 01:44:23,199
like

1777
01:44:35,158 --> 01:44:41,279
well yeah sure we we you're talking

1778
01:44:39,389 --> 01:44:43,529
about these two I mean we read that but

1779
01:44:41,279 --> 01:44:46,639
it did it not say

1780
01:44:43,529 --> 01:44:46,639
[Music]

1781
01:45:02,238 --> 01:45:08,058
I mean it says it right there right Sean

1782
01:45:04,488 --> 01:45:10,218
is that just wrong

1783
01:45:08,059 --> 01:45:11,599
it says the extra bit should be

1784
01:45:10,219 --> 01:45:15,849
interpreted as a machine integer store

1785
01:45:11,599 --> 01:45:15,849
with the most significant bit first so

1786
01:45:18,760 --> 01:45:25,090
that seemed to completely contradict

1787
01:45:21,469 --> 01:45:25,090
that other bullet point

1788
01:45:25,369 --> 01:45:28,500
[Music]

1789
01:45:43,050 --> 01:45:48,369
by the way the lesser utorrent you at

1790
01:45:46,119 --> 01:45:51,880
the beginning is in the loop in the

1791
01:45:48,369 --> 01:45:54,359
Huffman decode function the one with bit

1792
01:45:51,880 --> 01:45:54,359
index

1793
01:45:56,310 --> 01:46:04,930
okay so Val bus let me look at which one

1794
01:45:58,960 --> 01:46:09,000
you're talking about so you say the

1795
01:46:04,930 --> 01:46:09,000
Huffman decode function this function

1796
01:46:11,340 --> 01:46:18,989
but there is no loop in this function so

1797
01:46:15,430 --> 01:46:18,990
you must mean some other function

1798
01:46:28,679 --> 01:46:39,800
the one with bit index this one

1799
01:46:49,788 --> 01:46:54,488
i I don't know which more time I talk

1800
01:46:51,889 --> 01:46:54,489
about this one

1801
01:47:04,420 --> 01:47:16,890
oh and be type-0 yeah I don't know if I

1802
01:47:08,890 --> 01:47:16,890
really soon

1803
01:47:22,340 --> 01:47:34,890
yes you're right I don't know where app

1804
01:47:25,649 --> 01:47:36,719
came from I guess that's the outer one I

1805
01:47:34,890 --> 01:47:38,610
should probably make it clear which one

1806
01:47:36,720 --> 01:47:39,960
is which here and I could even move this

1807
01:47:38,609 --> 01:47:44,279
into its own function where it can't

1808
01:47:39,960 --> 01:47:46,020
access that we haven't really gotten to

1809
01:47:44,279 --> 01:47:50,759
this one yet so this one may be really

1810
01:47:46,020 --> 01:47:53,660
borked as well like I have no idea if

1811
01:47:50,760 --> 01:47:53,659
that's right at all

1812
01:48:08,139 --> 01:48:12,130
the extra bits after being unpacked to

1813
01:48:10,329 --> 01:48:14,618
describe and 3-1-1 should be TripIt so

1814
01:48:12,130 --> 01:48:18,909
you so you're saying it you really don't

1815
01:48:14,618 --> 01:48:20,589
you think that that was just poor poor

1816
01:48:18,908 --> 01:48:22,179
choice of wording on their parts that

1817
01:48:20,590 --> 01:48:24,039
make it sound like you have to reverse

1818
01:48:22,179 --> 01:48:28,658
them but but really this doesn't have to

1819
01:48:24,039 --> 01:48:31,810
happen like this is not clear the case

1820
01:48:28,658 --> 01:48:33,908
which would make a lot more sense right

1821
01:48:31,810 --> 01:48:35,889
cuz I don't understand why they would

1822
01:48:33,908 --> 01:48:37,960
want you to have to do that reversal so

1823
01:48:35,889 --> 01:48:40,050
I mean I could believe that but I don't

1824
01:48:37,960 --> 01:48:40,050
know

1825
01:48:40,988 --> 01:48:49,109
I have to look and see why we're not

1826
01:48:44,408 --> 01:48:49,109
able to do stuff here but

1827
01:49:59,010 --> 01:50:05,199
so those actually all seem pretty

1828
01:50:01,689 --> 01:50:07,359
reasonable so far how many times do we

1829
01:50:05,199 --> 01:50:11,489
go through this so we go quite some time

1830
01:50:07,359 --> 01:50:11,489
before it gets whatever the bad value is

1831
01:50:26,680 --> 01:50:32,289
like do we ever reach the end of the

1832
01:50:28,869 --> 01:50:35,470
block no so we don't quite get the it to

1833
01:50:32,289 --> 01:50:38,729
the end of a block though so we're sort

1834
01:50:35,470 --> 01:50:38,730
of okay but not quite right

1835
01:50:44,430 --> 01:50:48,730
Elvis yes that loop so I really don't

1836
01:50:47,380 --> 01:50:50,859
know what you're talking about then I

1837
01:50:48,729 --> 01:50:52,359
don't understand how that loop could

1838
01:50:50,859 --> 01:50:58,769
ever do anything other than the way that

1839
01:50:52,359 --> 01:50:58,769
it was written if that makes sense

1840
01:50:58,920 --> 01:51:07,600
so this assigns values to everything in

1841
01:51:03,939 --> 01:51:09,759
the next unused code array right the

1842
01:51:07,600 --> 01:51:13,390
reason they use less than or equal to in

1843
01:51:09,760 --> 01:51:16,750
the spec is because they didn't do the

1844
01:51:13,390 --> 01:51:19,240
whole array they did however many bits

1845
01:51:16,750 --> 01:51:21,430
you told it to use right but I'm not

1846
01:51:19,239 --> 01:51:26,170
doing that I just did the whole I just

1847
01:51:21,430 --> 01:51:28,659
do the whole array just period right so

1848
01:51:26,170 --> 01:51:30,579
I'm not skipping the last element if I

1849
01:51:28,659 --> 01:51:32,649
what if I did less than or equal to it

1850
01:51:30,579 --> 01:51:34,689
would overwrite the end of this array

1851
01:51:32,649 --> 01:51:36,219
and right into whatever was next on the

1852
01:51:34,689 --> 01:51:39,419
stack which we definitely don't want to

1853
01:51:36,220 --> 01:51:39,420
do makes sense

1854
01:51:55,630 --> 01:52:09,400
yeah so so this like in the spec this

1855
01:51:59,140 --> 01:52:21,880
would have been written like this where

1856
01:52:09,399 --> 01:52:23,529
is the max bit Oh like this right but

1857
01:52:21,880 --> 01:52:26,430
we're not bothering we're just it always

1858
01:52:23,529 --> 01:52:30,960
does this these are both they just do 15

1859
01:52:26,430 --> 01:52:30,960
they both just do 15 right

1860
01:52:58,729 --> 01:53:03,019
so anyway I'll go ahead and stop now it

1861
01:53:01,939 --> 01:53:06,349
looks like there's no more questions

1862
01:53:03,020 --> 01:53:07,460
anyway so yeah I don't really know one

1863
01:53:06,350 --> 01:53:08,900
way or the other whether those things

1864
01:53:07,460 --> 01:53:11,029
are supposed to be reversed or not we'll

1865
01:53:08,899 --> 01:53:16,779
have to take a look but we're getting

1866
01:53:11,029 --> 01:53:20,809
closer here seems pretty pretty close

1867
01:53:16,779 --> 01:53:22,670
it's just there's some I'm sure there's

1868
01:53:20,810 --> 01:53:25,010
some nagging little hard to find bits

1869
01:53:22,670 --> 01:53:28,789
that we're gonna have to sort of turn

1870
01:53:25,010 --> 01:53:30,289
through but it seems seems reasonable we

1871
01:53:28,789 --> 01:53:31,369
also have to validate our tables you

1872
01:53:30,289 --> 01:53:33,350
know I could have entered some stuff in

1873
01:53:31,369 --> 01:53:35,960
the tables wrong which also would would

1874
01:53:33,350 --> 01:53:42,160
throw us off so there's a lot of sources

1875
01:53:35,960 --> 01:53:47,470
here that could be wrong and you know

1876
01:53:42,159 --> 01:53:47,470
we'll have to figure out as we go

1877
01:53:48,189 --> 01:53:53,750
we'll have to figure out probably now

1878
01:53:52,399 --> 01:53:55,639
that we can see actual data coming

1879
01:53:53,750 --> 01:53:58,100
through we'll have to look and see where

1880
01:53:55,640 --> 01:54:01,280
we start to go wrong since we're using a

1881
01:53:58,100 --> 01:54:04,250
PNG whose contents we know that should

1882
01:54:01,279 --> 01:54:06,710
make it easier for us to figure out like

1883
01:54:04,250 --> 01:54:08,510
where we start to go off the rails by

1884
01:54:06,710 --> 01:54:10,130
looking to see what the data is that you

1885
01:54:08,510 --> 01:54:14,780
know see whether we get that you know we

1886
01:54:10,130 --> 01:54:16,760
expect if that makes sense all right so

1887
01:54:14,779 --> 01:54:21,500
that sounds good I'm gonna go ahead and

1888
01:54:16,760 --> 01:54:23,539
shut down thank you everyone for joining

1889
01:54:21,500 --> 01:54:24,500
me for their son handmade here oh it's

1890
01:54:23,539 --> 01:54:26,810
been a pleasure coated with you as

1891
01:54:24,500 --> 01:54:28,159
always if you want to follow along at

1892
01:54:26,810 --> 01:54:31,190
home you can always peer to the game on

1893
01:54:28,159 --> 01:54:33,079
hand me here org it comes with a source

1894
01:54:31,189 --> 01:54:34,849
code so you can do your own experiments

1895
01:54:33,079 --> 01:54:40,670
if you want to try and get the PNG

1896
01:54:34,850 --> 01:54:43,130
reader working before next week you

1897
01:54:40,670 --> 01:54:47,239
could give it a shot but I will be here

1898
01:54:43,130 --> 01:54:48,920
next week next weekend to do exactly

1899
01:54:47,239 --> 01:54:51,859
that so hope to see everyone here for

1900
01:54:48,920 --> 01:54:52,789
that until then have fun programming and

1901
01:54:51,859 --> 01:54:55,479
I'll see you burn on the Internet

1902
01:54:52,789 --> 01:54:55,479
taking these or everybody

