1
00:00:00,060 --> 00:00:03,240
hello everyone and welcome to hand made

2
00:00:02,009 --> 00:00:05,809
here or sure we could a complete game

3
00:00:03,240 --> 00:00:09,570
live on stream we are in the middle of

4
00:00:05,809 --> 00:00:12,660
debugging or PNG reader which actually

5
00:00:09,570 --> 00:00:14,009
hasn't been too bad so far which I guess

6
00:00:12,660 --> 00:00:14,460
maybe that just means the worst is yet

7
00:00:14,009 --> 00:00:17,490
to come

8
00:00:14,460 --> 00:00:20,010
who knows so far it's been pretty smooth

9
00:00:17,489 --> 00:00:22,320
sailing in terms of interpreting the

10
00:00:20,010 --> 00:00:23,820
specification and so on we did run into

11
00:00:22,320 --> 00:00:27,768
a little bit of a weirdness last time

12
00:00:23,820 --> 00:00:30,329
where there seemed to be some confusion

13
00:00:27,768 --> 00:00:32,729
the spec seemed a pretty clearly state

14
00:00:30,329 --> 00:00:38,369
in two different places to different

15
00:00:32,729 --> 00:00:41,339
rules for interpreting bit values for a

16
00:00:38,369 --> 00:00:42,839
certain part of the spec and what we do

17
00:00:41,340 --> 00:00:44,399
know is that Sean Barrett was on the

18
00:00:42,840 --> 00:00:48,390
stream and he's already written a PNG

19
00:00:44,399 --> 00:00:50,370
reader obviously for STB image and he

20
00:00:48,390 --> 00:00:52,500
was pretty strongly suggesting that's

21
00:00:50,369 --> 00:00:55,078
the part of the spec that said that the

22
00:00:52,500 --> 00:00:56,939
bits were reverse was wrong and that the

23
00:00:55,079 --> 00:00:59,730
bits were actually forward hopefully he

24
00:00:56,939 --> 00:01:02,549
is right I mean he should be right you

25
00:00:59,729 --> 00:01:05,879
were at the PNG reader so we had to have

26
00:01:02,549 --> 00:01:08,459
gotten that right but hopefully that's

27
00:01:05,879 --> 00:01:10,618
true because if it's not true then we

28
00:01:08,459 --> 00:01:13,949
have to actually reverse bits as they

29
00:01:10,618 --> 00:01:17,129
come in which is a real pain in the butt

30
00:01:13,950 --> 00:01:19,650
right we'd like to be able to just read

31
00:01:17,129 --> 00:01:22,679
and use the value without manipulating

32
00:01:19,650 --> 00:01:24,509
the bits at all so hopefully that is the

33
00:01:22,680 --> 00:01:26,700
case I don't know if it is or not we're

34
00:01:24,509 --> 00:01:28,500
gonna find out but we'll start looking

35
00:01:26,700 --> 00:01:30,090
at that today and then we'll try to push

36
00:01:28,500 --> 00:01:33,269
forward we're actually there isn't much

37
00:01:30,090 --> 00:01:35,549
more code to write we've done most of

38
00:01:33,269 --> 00:01:36,989
the decoding work so far there's just a

39
00:01:35,549 --> 00:01:40,560
transform thing that we have to write

40
00:01:36,989 --> 00:01:42,239
which probably will pretty simple so

41
00:01:40,560 --> 00:01:44,879
most of the work left in finishing the

42
00:01:42,239 --> 00:01:48,209
PNG reader which has been pretty

43
00:01:44,879 --> 00:01:51,780
straightforward even though the spec is

44
00:01:48,209 --> 00:01:54,629
kind of old and weird most of the work I

45
00:01:51,780 --> 00:01:57,149
think that we're gonna have to do going

46
00:01:54,629 --> 00:01:59,728
forwards is just in debugging our

47
00:01:57,149 --> 00:02:03,718
interpretation of the interpretation and

48
00:01:59,728 --> 00:02:06,840
implementation of the deflate spec so

49
00:02:03,718 --> 00:02:09,719
you know and this is again since this is

50
00:02:06,840 --> 00:02:11,520
the deflate spec it means that we could

51
00:02:09,719 --> 00:02:13,859
use this code presumably to do other

52
00:02:11,520 --> 00:02:15,210
things as well if you want to

53
00:02:13,860 --> 00:02:16,950
to read like a zip file or something

54
00:02:15,210 --> 00:02:20,700
that was compressed with the deflate

55
00:02:16,949 --> 00:02:23,579
speck presumably this would read it so

56
00:02:20,699 --> 00:02:25,709
it's actually kind of a generic piece of

57
00:02:23,580 --> 00:02:27,270
code in that sense where this this

58
00:02:25,710 --> 00:02:29,879
particular bit stream decode is

59
00:02:27,270 --> 00:02:33,600
presumably usable in a number of cases

60
00:02:29,879 --> 00:02:36,960
where the deflate compressor was used or

61
00:02:33,599 --> 00:02:39,000
the deef the encoder for the deflate

62
00:02:36,960 --> 00:02:40,200
complete compressor it was used however

63
00:02:39,000 --> 00:02:45,780
you want to say that we're the deflate

64
00:02:40,199 --> 00:02:51,030
algorithm was used so what we think we

65
00:02:45,780 --> 00:02:54,319
know so far when we come down through

66
00:02:51,030 --> 00:02:56,819
here and we produce our decoding tables

67
00:02:54,319 --> 00:02:59,400
so far it seems like this is pretty

68
00:02:56,819 --> 00:03:00,810
accurate the reason why I say it seems

69
00:02:59,400 --> 00:03:02,550
like this is pretty accurate which mean

70
00:03:00,810 --> 00:03:04,949
when I say that I mean it seems like

71
00:03:02,550 --> 00:03:06,330
there aren't huge glaring errors in it

72
00:03:04,949 --> 00:03:08,579
there might still be some subtle ones

73
00:03:06,330 --> 00:03:09,870
that only happen once in a while but the

74
00:03:08,580 --> 00:03:11,489
reason I say that it seems pretty

75
00:03:09,870 --> 00:03:15,209
accurate is because when we actually

76
00:03:11,489 --> 00:03:18,500
come through here this assertion does

77
00:03:15,209 --> 00:03:21,390
not fire which means that we actually do

78
00:03:18,500 --> 00:03:25,319
decompress the information in the tables

79
00:03:21,389 --> 00:03:28,619
and get exactly as much table data out

80
00:03:25,319 --> 00:03:31,680
as we expect so if we were like totally

81
00:03:28,620 --> 00:03:34,469
decoding it wrong we would expect that

82
00:03:31,680 --> 00:03:37,019
to fire and now that we've gotten to the

83
00:03:34,469 --> 00:03:39,330
point where it doesn't fire we can sort

84
00:03:37,019 --> 00:03:44,659
of assume that we're you know closed

85
00:03:39,330 --> 00:03:48,030
right on this part we then do Huffman

86
00:03:44,659 --> 00:03:50,819
generation this is basically they have a

87
00:03:48,030 --> 00:03:52,439
certain way in which they've encoded the

88
00:03:50,819 --> 00:03:55,709
Huffman tables to try to make them

89
00:03:52,439 --> 00:03:57,949
concise this right here decodes those

90
00:03:55,709 --> 00:04:00,900
Huffman tables from their sort of

91
00:03:57,949 --> 00:04:03,798
encoded version it's not really that

92
00:04:00,900 --> 00:04:06,989
compressed per se it's just sort of a

93
00:04:03,799 --> 00:04:10,590
concise encoding that is compression

94
00:04:06,989 --> 00:04:12,420
obviously but anyway this concise

95
00:04:10,590 --> 00:04:15,299
encoding of the Huffman then gets turned

96
00:04:12,419 --> 00:04:17,519
into something we can use to decode the

97
00:04:15,299 --> 00:04:19,949
Huffman more quickly by generating

98
00:04:17,519 --> 00:04:23,220
tables now we don't know whether that is

99
00:04:19,949 --> 00:04:24,689
working properly right we implemented

100
00:04:23,220 --> 00:04:25,349
what we thought was a reasonable way to

101
00:04:24,689 --> 00:04:27,719
do it

102
00:04:25,348 --> 00:04:33,689
we don't really know so

103
00:04:27,720 --> 00:04:35,100
that's just purely speculative then we

104
00:04:33,689 --> 00:04:38,550
get down to this loop and this loop

105
00:04:35,100 --> 00:04:41,520
again we have no verification of yet so

106
00:04:38,550 --> 00:04:44,100
we don't really know if these are proper

107
00:04:41,519 --> 00:04:47,939
we don't really know if this is proper

108
00:04:44,100 --> 00:04:51,629
here we cannot at the moment I think

109
00:04:47,939 --> 00:04:53,699
decode a full block correctly so we know

110
00:04:51,629 --> 00:04:56,550
that we've got at least one probably

111
00:04:53,699 --> 00:04:59,039
glaring bug in there somewhere that we

112
00:04:56,550 --> 00:05:01,620
can fix to get us to a slightly smoother

113
00:04:59,040 --> 00:05:05,430
run but at the moment we will be

114
00:05:01,620 --> 00:05:06,689
focusing on from here down because we do

115
00:05:05,430 --> 00:05:09,420
have some reason to believe that this

116
00:05:06,689 --> 00:05:13,680
part is working relatively correctly now

117
00:05:09,420 --> 00:05:15,180
again that's not necessarily the case in

118
00:05:13,680 --> 00:05:17,550
its entirety there could be some subtle

119
00:05:15,180 --> 00:05:18,959
bugs in here that just allow you to

120
00:05:17,550 --> 00:05:21,000
produce the same number of lengths but

121
00:05:18,959 --> 00:05:23,639
you've got one or two of them wrong or

122
00:05:21,000 --> 00:05:26,250
or all of them are wrong in some subtle

123
00:05:23,639 --> 00:05:29,969
way that doesn't affect how many of them

124
00:05:26,250 --> 00:05:31,889
you did and things like this so we don't

125
00:05:29,970 --> 00:05:33,600
know much about this part here in terms

126
00:05:31,889 --> 00:05:35,339
of the accuracy of the Huffman tables

127
00:05:33,600 --> 00:05:37,980
but we do know something about that the

128
00:05:35,339 --> 00:05:39,109
bit encoding and we think we've got that

129
00:05:37,980 --> 00:05:41,400
part right

130
00:05:39,110 --> 00:05:42,870
everything else is still suspect and

131
00:05:41,399 --> 00:05:46,489
then this part right here is the first

132
00:05:42,870 --> 00:05:49,980
time we really did this code last week

133
00:05:46,490 --> 00:05:53,220
Sunday I guess I'm sorry two weeks ago

134
00:05:49,980 --> 00:05:55,650
Sunday we were off last weekend so this

135
00:05:53,220 --> 00:05:58,410
part right here is probably got plenty

136
00:05:55,649 --> 00:06:00,989
of issues in it and we'll sort of start

137
00:05:58,410 --> 00:06:04,530
to assess those out as we go what I will

138
00:06:00,990 --> 00:06:07,050
point out is we're now at the part of

139
00:06:04,529 --> 00:06:09,899
the process where structured art can

140
00:06:07,050 --> 00:06:12,060
start to help us I don't know for quite

141
00:06:09,899 --> 00:06:14,489
there yet but we're close to there yet

142
00:06:12,060 --> 00:06:19,800
what do I mean by that so if we open up

143
00:06:14,490 --> 00:06:23,069
this file with that I made as our

144
00:06:19,800 --> 00:06:26,069
test look at these lovely mushrooms we

145
00:06:23,069 --> 00:06:29,129
can go in here and look at the first

146
00:06:26,069 --> 00:06:30,629
part of the file that we created or at

147
00:06:29,129 --> 00:06:34,579
least I thought we created where is it

148
00:06:30,629 --> 00:06:34,579
sorry that's not the top there it was

149
00:06:34,610 --> 00:06:40,980
right there and what you can see is I've

150
00:06:38,610 --> 00:06:44,819
been very careful to put in the first

151
00:06:40,980 --> 00:06:48,030
row of the image here I've put a red dot

152
00:06:44,819 --> 00:06:51,990
and then two black dots and then an

153
00:06:48,029 --> 00:06:54,989
increasing alpha now in the last row of

154
00:06:51,990 --> 00:06:58,980
the image I've done a similar thing I've

155
00:06:54,990 --> 00:07:01,860
put one green dot and two black dots so

156
00:06:58,980 --> 00:07:04,110
what we would expect to see when we

157
00:07:01,860 --> 00:07:07,290
start decompressing this is one of those

158
00:07:04,110 --> 00:07:13,259
two things now I don't remember seeing

159
00:07:07,290 --> 00:07:14,700
in the actual spec yet I'm sure it's in

160
00:07:13,259 --> 00:07:17,370
there somewhere but we didn't go looking

161
00:07:14,699 --> 00:07:21,209
for it whether these images are encoded

162
00:07:17,370 --> 00:07:24,509
with the bottom as the first line or the

163
00:07:21,209 --> 00:07:26,069
top is the first line but regardless of

164
00:07:24,509 --> 00:07:28,259
which you can that's why I put one on

165
00:07:26,069 --> 00:07:31,110
each regardless of which one it chooses

166
00:07:28,259 --> 00:07:35,969
we will expect to see that structured

167
00:07:31,110 --> 00:07:39,530
art appear and that should start to give

168
00:07:35,970 --> 00:07:43,620
us a clue as to whether or not we are

169
00:07:39,529 --> 00:07:47,099
even decoding anything correctly now the

170
00:07:43,620 --> 00:07:50,069
thing you remember here is we can modify

171
00:07:47,100 --> 00:07:52,230
this and we can in fact start with much

172
00:07:50,069 --> 00:07:54,360
simpler things too in fact I might go

173
00:07:52,230 --> 00:07:56,879
ahead and do that that here is well

174
00:07:54,360 --> 00:08:00,300
create another one for us to use I can

175
00:07:56,879 --> 00:08:03,060
do something like just make a single 8

176
00:08:00,300 --> 00:08:04,829
by 8 block for example and I can make

177
00:08:03,060 --> 00:08:07,500
sure that we know all of the values in

178
00:08:04,829 --> 00:08:11,129
this 8 by 8 block let me make sure that

179
00:08:07,500 --> 00:08:12,899
it has an alpha channel but what I can

180
00:08:11,129 --> 00:08:14,759
do here is I can make sure that we set

181
00:08:12,899 --> 00:08:17,639
these values to things that we know as

182
00:08:14,759 --> 00:08:19,709
well and then it's a lot easier again

183
00:08:17,639 --> 00:08:22,469
for us to just kind of plunk through

184
00:08:19,709 --> 00:08:24,479
what we're looking at as we start and

185
00:08:22,470 --> 00:08:27,180
again this is just the reasoning behind

186
00:08:24,480 --> 00:08:29,759
this is very simple the idea is that if

187
00:08:27,180 --> 00:08:32,610
you know what you expect to get when you

188
00:08:29,759 --> 00:08:35,370
decode something you can read in the

189
00:08:32,610 --> 00:08:37,649
debugger exactly what kind of data is

190
00:08:35,370 --> 00:08:40,320
coming out of the decompressor and you

191
00:08:37,649 --> 00:08:43,319
can start to have an idea about whether

192
00:08:40,320 --> 00:08:46,379
or not it's even remotely working

193
00:08:43,320 --> 00:08:48,480
properly right and furthermore if we

194
00:08:46,379 --> 00:08:52,740
create a highly structured piece of

195
00:08:48,480 --> 00:08:54,329
artwork we can also potentially like see

196
00:08:52,740 --> 00:08:58,558
where we're starting to go wrong

197
00:08:54,328 --> 00:09:00,118
you know what I mean so we can sort of

198
00:08:58,558 --> 00:09:02,548
start to see what happens

199
00:09:00,119 --> 00:09:05,670
when we when we get to the end of lines

200
00:09:02,548 --> 00:09:07,528
or things like that and we can sort of

201
00:09:05,669 --> 00:09:10,019
start to see like where where do we

202
00:09:07,528 --> 00:09:11,909
start to screw up if we get some correct

203
00:09:10,019 --> 00:09:13,409
values and then get some values that are

204
00:09:11,909 --> 00:09:16,409
incorrect you know why is that happening

205
00:09:13,409 --> 00:09:19,318
so we should be able to create some

206
00:09:16,409 --> 00:09:21,988
things that help us and are sort of

207
00:09:19,318 --> 00:09:24,868
waypoints for us in that regard and so

208
00:09:21,989 --> 00:09:28,889
here's an example of an image that that

209
00:09:24,869 --> 00:09:35,809
sort of does that and I'll just make one

210
00:09:28,889 --> 00:09:38,698
more here sort of behalf right versions

211
00:09:35,808 --> 00:09:40,588
um so this you know gives us a pretty

212
00:09:38,698 --> 00:09:43,048
clear you know we can all understand

213
00:09:40,589 --> 00:09:45,420
what this should look like when we

214
00:09:43,048 --> 00:09:48,028
actually look at it in binary you know

215
00:09:45,419 --> 00:09:50,519
we've got eight pixels across we have an

216
00:09:48,028 --> 00:09:53,159
own color on the first pixel of every

217
00:09:50,519 --> 00:09:55,828
row and we've got a blue pixel at the

218
00:09:53,159 --> 00:09:57,868
end of the first and last rows just so

219
00:09:55,828 --> 00:10:01,278
we can kind of see where that watermark

220
00:09:57,869 --> 00:10:05,309
is and that I think is again totally

221
00:10:01,278 --> 00:10:06,889
reasonable let me just go ahead and and

222
00:10:05,308 --> 00:10:09,629
you know maybe I'll do one more thing

223
00:10:06,889 --> 00:10:11,369
now no you know what so let me go ahead

224
00:10:09,629 --> 00:10:14,009
and export this as a ping as well and

225
00:10:11,369 --> 00:10:17,009
then that way we can also load this in

226
00:10:14,009 --> 00:10:18,808
and have a smaller test thing to look at

227
00:10:17,009 --> 00:10:25,649
because the other one's pretty big it's

228
00:10:18,808 --> 00:10:27,389
more of a complete test here and so we

229
00:10:25,649 --> 00:10:30,600
can load that one in and just get a good

230
00:10:27,389 --> 00:10:33,720
and we can also force it here we know we

231
00:10:30,600 --> 00:10:36,298
want it to use the 32-bit format that's

232
00:10:33,720 --> 00:10:37,589
what we're looking for here and I guess

233
00:10:36,298 --> 00:10:39,360
you know we've also got this compression

234
00:10:37,589 --> 00:10:41,369
level stuff which we could play with but

235
00:10:39,360 --> 00:10:43,949
again that's that's just if we wanted to

236
00:10:41,369 --> 00:10:45,569
try like making the file simpler you

237
00:10:43,948 --> 00:10:47,458
know if it's zero maybe it doesn't use

238
00:10:45,568 --> 00:10:48,958
any compression I don't know in which

239
00:10:47,458 --> 00:10:51,748
case we could look at the D at an

240
00:10:48,958 --> 00:10:53,998
uncompressed one so we probably do want

241
00:10:51,749 --> 00:10:57,149
both of those like we could do something

242
00:10:53,999 --> 00:11:00,149
like this right where we export one of

243
00:10:57,149 --> 00:11:03,379
them and then I can also export another

244
00:11:00,149 --> 00:11:06,678
one of them that's specifically

245
00:11:03,379 --> 00:11:06,678
compression zero

246
00:11:07,639 --> 00:11:11,509
where this gets cranked down to the

247
00:11:08,990 --> 00:11:12,169
bottom I don't know that we care about

248
00:11:11,509 --> 00:11:14,629
any of that

249
00:11:12,169 --> 00:11:19,069
we skip those blocks so those should be

250
00:11:14,629 --> 00:11:20,830
fine and yeah there's really nothing

251
00:11:19,070 --> 00:11:23,450
else in here that we care about really

252
00:11:20,830 --> 00:11:25,490
so if I just set that to zero we can see

253
00:11:23,450 --> 00:11:28,850
if that creates a materially different

254
00:11:25,490 --> 00:11:31,100
file compression wise and if it does we

255
00:11:28,850 --> 00:11:32,300
can see like again get some more

256
00:11:31,100 --> 00:11:34,820
information about where we're storing

257
00:11:32,299 --> 00:11:36,620
screwup so that's really all I'm talking

258
00:11:34,820 --> 00:11:38,930
about they're just again creating

259
00:11:36,620 --> 00:11:40,429
opportunities for us to find our bugs it

260
00:11:38,929 --> 00:11:44,089
can be hard when you're dealing with

261
00:11:40,429 --> 00:11:45,500
really robust intricate data because

262
00:11:44,090 --> 00:11:46,700
again you just don't know what you're

263
00:11:45,500 --> 00:11:48,519
dealing with so if you just have

264
00:11:46,700 --> 00:11:51,920
something very very simple and basic

265
00:11:48,519 --> 00:11:53,809
that can really help you zero in on

266
00:11:51,919 --> 00:11:55,909
those bugs quicker than spending all

267
00:11:53,809 --> 00:11:58,759
your time trying to sort through what

268
00:11:55,909 --> 00:12:01,399
you're looking at in the debug view okay

269
00:11:58,759 --> 00:12:03,289
so if we go ahead and launch this here

270
00:12:01,399 --> 00:12:05,240
let's let's actually go ahead and take a

271
00:12:03,289 --> 00:12:06,799
look at that uncle well I don't know if

272
00:12:05,240 --> 00:12:07,129
it's uncompressed it's compression level

273
00:12:06,799 --> 00:12:09,559
zero

274
00:12:07,129 --> 00:12:11,570
maybe still does some light

275
00:12:09,559 --> 00:12:13,159
compression on it I'm not sure but I'm

276
00:12:11,570 --> 00:12:14,750
interested to see what happens just if

277
00:12:13,159 --> 00:12:17,329
the file like doesn't have the

278
00:12:14,750 --> 00:12:18,649
compression part in it I just interested

279
00:12:17,330 --> 00:12:20,690
to see right because it could have

280
00:12:18,649 --> 00:12:23,679
remember there's this be type zero block

281
00:12:20,690 --> 00:12:26,540
it's a block that just doesn't have any

282
00:12:23,679 --> 00:12:28,459
of the deflate encoding specified in it

283
00:12:26,539 --> 00:12:30,049
it would be interesting to get something

284
00:12:28,460 --> 00:12:33,460
with a little bit of that in it because

285
00:12:30,049 --> 00:12:39,339
we would like to handle that as well and

286
00:12:33,460 --> 00:12:43,129
we also thought that we had a to do here

287
00:12:39,340 --> 00:12:45,200
so this we need to do this as well

288
00:12:43,129 --> 00:12:49,029
Martin's correctly pointed out that

289
00:12:45,200 --> 00:12:49,030
that's not and you know what I should

290
00:12:53,070 --> 00:12:56,879
sooo if we look here first of all this

291
00:12:55,080 --> 00:12:59,850
read the huffman stuff here is actually

292
00:12:56,879 --> 00:13:02,730
done now this is the place where we

293
00:12:59,850 --> 00:13:10,470
actually want this I believe am I right

294
00:13:02,730 --> 00:13:12,899
about that so I think yes so I think

295
00:13:10,470 --> 00:13:14,490
what happens here is be type 2 is the

296
00:13:12,899 --> 00:13:17,639
one that actually has the tables in it

297
00:13:14,490 --> 00:13:31,100
be type one is one where we actually

298
00:13:17,639 --> 00:13:36,090
have see the huffman with the built-in

299
00:13:31,100 --> 00:13:51,540
huffman tables this is one that we are

300
00:13:36,090 --> 00:13:54,090
going to have to handle sooo if we now

301
00:13:51,539 --> 00:13:56,669
take a look at what will happen on the

302
00:13:54,090 --> 00:14:00,240
compression zero one I'm just curious

303
00:13:56,669 --> 00:14:03,779
again before we get started this is 8 by

304
00:14:00,240 --> 00:14:07,100
8 compression 0 I believes the name of

305
00:14:03,779 --> 00:14:07,100
the file am I right about that

306
00:14:09,769 --> 00:14:17,460
let's take a look yeah

307
00:14:14,250 --> 00:14:21,059
so it's 427 bytes long let's go ahead

308
00:14:17,460 --> 00:14:25,170
and step into the PNG read here so when

309
00:14:21,059 --> 00:14:27,329
we get in here this is marked as

310
00:14:25,169 --> 00:14:32,399
supported which is good we come through

311
00:14:27,330 --> 00:14:34,740
here and we look at the pixel setup it's

312
00:14:32,399 --> 00:14:35,879
not be final which of course it's a

313
00:14:34,740 --> 00:14:37,710
little weird because you'd think they'd

314
00:14:35,879 --> 00:14:39,149
only be one block to encode that but

315
00:14:37,710 --> 00:14:41,910
maybe it's every row is different I

316
00:14:39,149 --> 00:14:44,009
don't know anyway let's take a look ok

317
00:14:41,909 --> 00:14:45,959
so it did it did exactly what I hoped

318
00:14:44,009 --> 00:14:49,080
which is that if we set the compression

319
00:14:45,960 --> 00:14:51,810
level to zero we just get this kind of

320
00:14:49,080 --> 00:14:54,450
file which is a file that has no deflate

321
00:14:51,809 --> 00:14:56,819
encoder in it or at least it doesn't

322
00:14:54,450 --> 00:14:59,670
look like it does yet so it will allow

323
00:14:56,820 --> 00:15:03,600
us to test this part as well so if we

324
00:14:59,669 --> 00:15:04,889
consume I use 16 here in both cases we

325
00:15:03,600 --> 00:15:07,678
get a Len and the

326
00:15:04,889 --> 00:15:09,058
in the end Lin is not a value we

327
00:15:07,678 --> 00:15:11,159
actually need it's just a error-checking

328
00:15:09,058 --> 00:15:13,738
value it looks like it's the supposed to

329
00:15:11,159 --> 00:15:15,149
be the ones complement of Len and so

330
00:15:13,739 --> 00:15:18,600
we'd sit to see if that's right so it

331
00:15:15,149 --> 00:15:23,159
says here that those don't match let me

332
00:15:18,600 --> 00:15:25,769
see what's going on there I think I did

333
00:15:23,159 --> 00:15:33,289
that right maybe I did that wrong so

334
00:15:25,769 --> 00:15:33,289
there's Len right and sight we can look

335
00:15:36,318 --> 00:15:49,378
and there's n Len so that is definitely

336
00:15:47,839 --> 00:15:51,660
what did I do

337
00:15:49,379 --> 00:15:59,629
because that looks exactly like it

338
00:15:51,659 --> 00:16:02,759
should look my

339
00:15:59,629 --> 00:16:02,759
[Music]

340
00:16:05,909 --> 00:16:14,339
ah okay so is this actually doing

341
00:16:11,519 --> 00:16:16,529
integral promotion on this it looks like

342
00:16:14,340 --> 00:16:18,149
we're getting integral promotion here

343
00:16:16,529 --> 00:16:20,100
assuming that this is doing the same

344
00:16:18,149 --> 00:16:23,730
thing that we'll do so I guess that's

345
00:16:20,100 --> 00:16:26,519
forcing us up to above a u16 which we

346
00:16:23,730 --> 00:16:29,909
really don't want let me go ahead and

347
00:16:26,519 --> 00:16:40,590
force it not to do that or try to you

348
00:16:29,909 --> 00:16:43,169
anyway just to really make sure not sure

349
00:16:40,590 --> 00:16:43,500
why it would do that but yeah there we

350
00:16:43,169 --> 00:16:44,909
go

351
00:16:43,500 --> 00:16:46,649
so it was just the integral promotion it

352
00:16:44,909 --> 00:16:47,969
wanted to expand when you when you did

353
00:16:46,649 --> 00:16:51,059
this operator it want to expand it out

354
00:16:47,970 --> 00:16:53,759
to 32 bits just using C's internal

355
00:16:51,059 --> 00:16:54,959
promotion rules which I will never for

356
00:16:53,759 --> 00:16:58,139
the life of me understand why they are

357
00:16:54,960 --> 00:16:59,879
the way they are I'm sure there's

358
00:16:58,139 --> 00:17:01,679
historical reasons for it they're not

359
00:16:59,879 --> 00:17:04,318
reasons I would probably agree with but

360
00:17:01,679 --> 00:17:06,809
whatever no one cares what I think

361
00:17:04,318 --> 00:17:09,000
so it's fine we go in here we need to ne

362
00:17:06,809 --> 00:17:11,458
and swap this because I believe we read

363
00:17:09,000 --> 00:17:14,400
that the length value is actually wrong

364
00:17:11,459 --> 00:17:16,949
it's concluded the opposite way round I

365
00:17:14,400 --> 00:17:18,660
think now I don't know if that's

366
00:17:16,949 --> 00:17:21,600
actually right because we said is it

367
00:17:18,660 --> 00:17:27,830
supposed to be so if we look here we see

368
00:17:21,599 --> 00:17:31,829
264 if we were doing an 8 by 8 right and

369
00:17:27,829 --> 00:17:34,829
each one was supposed to have 4 that

370
00:17:31,829 --> 00:17:37,319
would be 256 which is how many pixel

371
00:17:34,829 --> 00:17:42,089
values we'd effectively included now we

372
00:17:37,319 --> 00:17:44,819
would also expect 8 row transform values

373
00:17:42,089 --> 00:17:46,139
because they four because they didn't

374
00:17:44,819 --> 00:17:47,909
know very much about image compression

375
00:17:46,140 --> 00:17:49,500
which it's hard to blame them it was a

376
00:17:47,910 --> 00:17:50,550
long time ago and people weren't that

377
00:17:49,500 --> 00:17:52,140
knowledge about that sort of thing in

378
00:17:50,549 --> 00:17:55,559
general case back then they weren't

379
00:17:52,140 --> 00:17:57,390
experts you don't generally want to do

380
00:17:55,559 --> 00:18:01,049
transforms per row they didn't know that

381
00:17:57,390 --> 00:18:03,060
so they put one transform per row and so

382
00:18:01,049 --> 00:18:07,109
I suspect that that's just what we're

383
00:18:03,059 --> 00:18:08,940
seeing here 8 times 8 times 4 plus 1

384
00:18:07,109 --> 00:18:11,159
transfer vibe for each row would be

385
00:18:08,940 --> 00:18:14,039
Tuesday before what that suggests to me

386
00:18:11,160 --> 00:18:16,110
is regardless of how we interpreted the

387
00:18:14,039 --> 00:18:19,589
spec it looks like that length value is

388
00:18:16,109 --> 00:18:21,148
not Indian swapped right

389
00:18:19,589 --> 00:18:23,189
because the Indian swapped version of

390
00:18:21,148 --> 00:18:27,989
that's going to be huge and I don't

391
00:18:23,190 --> 00:18:30,480
think there were 2049 pieces of data in

392
00:18:27,990 --> 00:18:33,808
this file so I suspect if that's an

393
00:18:30,480 --> 00:18:36,960
error and underflow right so I think

394
00:18:33,808 --> 00:18:40,408
what we want to do there is we want to

395
00:18:36,960 --> 00:18:44,069
sort of fix this right and we can also

396
00:18:40,409 --> 00:18:45,450
check on this here you might as well put

397
00:18:44,069 --> 00:18:47,939
a we don't really care about making this

398
00:18:45,450 --> 00:18:49,769
robust we might as well so I think we're

399
00:18:47,940 --> 00:18:51,840
just gonna say that that based on our

400
00:18:49,769 --> 00:18:54,419
experience here is not supposed to be

401
00:18:51,839 --> 00:18:55,888
Indiana swapped I had to do there so

402
00:18:54,419 --> 00:18:57,450
that meant that I wasn't really sure

403
00:18:55,888 --> 00:19:00,949
what the spec was trying to say so that

404
00:18:57,450 --> 00:19:03,869
seems fine and so here we go you know

405
00:19:00,950 --> 00:19:07,048
sort of reading that data out and that

406
00:19:03,868 --> 00:19:09,209
looks like that read correctly so you

407
00:19:07,048 --> 00:19:11,009
know the nice part about that is it

408
00:19:09,210 --> 00:19:12,840
looks like we already have the ability

409
00:19:11,009 --> 00:19:16,558
to read you know simple PNG so that's

410
00:19:12,839 --> 00:19:19,648
good and if I look at where's that there

411
00:19:16,558 --> 00:19:21,778
it is so you know this all came out

412
00:19:19,648 --> 00:19:23,628
correctly and I think probably the data

413
00:19:21,778 --> 00:19:27,089
is correct here I don't know we should

414
00:19:23,628 --> 00:19:30,599
probably find a good way to look at the

415
00:19:27,089 --> 00:19:32,308
data but in the meantime in Leo of doing

416
00:19:30,599 --> 00:19:33,928
that at the moment I think what I'll do

417
00:19:32,308 --> 00:19:37,470
is I'll just go ahead and look at what

418
00:19:33,929 --> 00:19:38,429
decompressed pixels ends up being so if

419
00:19:37,470 --> 00:19:40,288
you take a look here we've got

420
00:19:38,429 --> 00:19:42,090
decompressed pixels where it does this

421
00:19:40,288 --> 00:19:44,490
allocation here with the width the

422
00:19:42,089 --> 00:19:46,829
height the four and the extra bytes so

423
00:19:44,490 --> 00:19:48,769
this is the decompressed it's not really

424
00:19:46,829 --> 00:19:53,939
to compress opposed to compressed data

425
00:19:48,769 --> 00:20:00,179
goes in there let me see here do we just

426
00:19:53,940 --> 00:20:02,580
copy that in to dest we do so yeah okay

427
00:20:00,179 --> 00:20:05,669
so when we're done in this supported

428
00:20:02,579 --> 00:20:11,220
section here I'll just go ahead and skip

429
00:20:05,669 --> 00:20:14,179
to the end why did we not why does it

430
00:20:11,220 --> 00:20:14,179
not break on that line

431
00:20:20,740 --> 00:20:30,920
yeah all right great visual studio as

432
00:20:25,130 --> 00:20:35,630
always making debugger and harder than

433
00:20:30,920 --> 00:20:41,240
it has to be visual studio always excels

434
00:20:35,630 --> 00:20:44,150
at this here's we compress pixels let's

435
00:20:41,240 --> 00:20:45,680
take a look at what is in it so what I

436
00:20:44,150 --> 00:20:49,700
want to do is I want to get this to show

437
00:20:45,680 --> 00:20:55,700
basically the bitmap I think I can force

438
00:20:49,700 --> 00:20:58,160
it to nine potentially hopefully yeah so

439
00:20:55,700 --> 00:21:00,590
here is the road transform value here

440
00:20:58,160 --> 00:21:02,720
are the pixels that we're seeing in that

441
00:21:00,589 --> 00:21:08,049
oh sorry

442
00:21:02,720 --> 00:21:11,809
and I want these to be 32-bit so they're

443
00:21:08,049 --> 00:21:13,730
right oh you know what no I take it back

444
00:21:11,809 --> 00:21:15,889
I can't do that because of that row one

445
00:21:13,730 --> 00:21:19,160
is the one that one's off so I'm gonna

446
00:21:15,890 --> 00:21:23,240
have to actually do you know it's 8

447
00:21:19,160 --> 00:21:27,680
times 4 which is 32 plus the 1 so it's

448
00:21:23,240 --> 00:21:31,880
33 so this is the actual sort of scan

449
00:21:27,680 --> 00:21:33,980
I'm gonna want to use I guess right so

450
00:21:31,880 --> 00:21:35,960
as we come through here we're gonna be

451
00:21:33,980 --> 00:21:38,870
writing these pixels you can see us

452
00:21:35,960 --> 00:21:40,009
writing them in in here right and so

453
00:21:38,869 --> 00:21:41,839
what I'm gonna look for is I'm just

454
00:21:40,009 --> 00:21:44,029
gonna look to make sure that this does

455
00:21:41,839 --> 00:21:45,980
come out to be what we think it should

456
00:21:44,029 --> 00:21:47,599
be and this will also tell me something

457
00:21:45,980 --> 00:21:50,150
really important when I look at this

458
00:21:47,599 --> 00:21:53,629
because it is again structured artwork

459
00:21:50,150 --> 00:21:58,490
this will give me a clue as to what the

460
00:21:53,630 --> 00:22:01,070
actual encoding value is here does our

461
00:21:58,490 --> 00:22:02,420
bread come first does green come does

462
00:22:01,069 --> 00:22:05,809
reckon first or just blue come first and

463
00:22:02,420 --> 00:22:08,779
so on so taking a look here at these

464
00:22:05,809 --> 00:22:10,339
values I so wait a minute did I do that

465
00:22:08,779 --> 00:22:13,339
math wrong or something so there's

466
00:22:10,339 --> 00:22:14,659
supposed to be eight pixels each one

467
00:22:13,339 --> 00:22:18,589
should have four bytes which should be

468
00:22:14,660 --> 00:22:20,779
32 is doing what am I missing here so

469
00:22:18,589 --> 00:22:23,509
there's the Road transform value that

470
00:22:20,779 --> 00:22:24,980
should be one pixel right and you know

471
00:22:23,509 --> 00:22:26,539
again what I can do I don't know why I

472
00:22:24,980 --> 00:22:28,870
closed it probably because I wasn't

473
00:22:26,539 --> 00:22:28,869
thinking

474
00:22:29,410 --> 00:22:33,610
but if I go ahead and and open this I

475
00:22:31,990 --> 00:22:34,420
like open you can open in Visual Studio

476
00:22:33,609 --> 00:22:38,669
okay

477
00:22:34,420 --> 00:22:41,650
that's interesting uh let's see here

478
00:22:38,670 --> 00:22:43,090
open with that was probably talking

479
00:22:41,650 --> 00:22:44,530
about different file that's what that's

480
00:22:43,089 --> 00:22:46,409
what was going on there

481
00:22:44,529 --> 00:22:49,509
so let me go ahead and zoom in here so

482
00:22:46,410 --> 00:22:52,960
if I look at this I expect red blacks

483
00:22:49,509 --> 00:22:55,029
and a blue all of the Alpha values

484
00:22:52,960 --> 00:22:58,690
should be full I would think

485
00:22:55,029 --> 00:23:07,690
but then again I don't really know how

486
00:22:58,690 --> 00:23:10,180
they're choosing to encode this I guess

487
00:23:07,690 --> 00:23:13,680
I don't know what is thinking there

488
00:23:10,180 --> 00:23:19,000
so let's let's do this just I don't know

489
00:23:13,680 --> 00:23:22,330
so if I make a new layer and I put it

490
00:23:19,000 --> 00:23:27,400
down here so all of that stuff was

491
00:23:22,329 --> 00:23:28,329
supposed to be opaque so I'm not sure

492
00:23:27,400 --> 00:23:35,740
what to make of that

493
00:23:28,329 --> 00:23:37,329
maybe that's not true until I just did

494
00:23:35,740 --> 00:23:39,220
the thing I did where it's not the

495
00:23:37,329 --> 00:23:40,809
bottom layer but we'll got to look at

496
00:23:39,220 --> 00:23:42,039
this a little bit more closely because

497
00:23:40,809 --> 00:23:45,099
you see what I'm seeing here there's all

498
00:23:42,039 --> 00:23:46,990
these zeros in here I don't really

499
00:23:45,099 --> 00:23:49,959
understand I also don't understand what

500
00:23:46,990 --> 00:23:53,079
that is doing there I guess that's

501
00:23:49,960 --> 00:23:55,180
because my assumption and again this is

502
00:23:53,079 --> 00:23:59,079
just purely speculative is that when I

503
00:23:55,180 --> 00:24:01,630
paint into this pixel is off a

504
00:23:59,079 --> 00:24:04,389
little bit on its radius and put a

505
00:24:01,630 --> 00:24:08,230
little tiny bit of red into the next

506
00:24:04,390 --> 00:24:10,840
pixel over just a tiny little bit that's

507
00:24:08,230 --> 00:24:15,549
my assumption anyway moving forwards as

508
00:24:10,839 --> 00:24:18,849
you look at this you can sort of see my

509
00:24:15,549 --> 00:24:24,039
confusion looking over here you see this

510
00:24:18,849 --> 00:24:27,730
FFF value that is blue but it's still

511
00:24:24,039 --> 00:24:30,069
zero so here's here's my guess and and I

512
00:24:27,730 --> 00:24:34,650
I don't know what else to make of it so

513
00:24:30,069 --> 00:24:41,549
this data does now line up if you assume

514
00:24:34,650 --> 00:24:44,340
that the Alpha channel is just wrong or

515
00:24:41,549 --> 00:24:46,450
cat

516
00:24:44,339 --> 00:24:47,799
arbitrary I don't know because if you

517
00:24:46,450 --> 00:24:51,250
look at what what we're looking at here

518
00:24:47,799 --> 00:24:53,319
this all like looks somewhat plausible

519
00:24:51,250 --> 00:24:54,759
right although actually no it does it

520
00:24:53,319 --> 00:25:00,460
cuz that's that looks like a green there

521
00:24:54,759 --> 00:25:02,289
ah so you know what here's the thing I

522
00:25:00,460 --> 00:25:04,660
will say we don't know what these road

523
00:25:02,289 --> 00:25:07,149
transforms are so now that I think about

524
00:25:04,660 --> 00:25:09,700
it and they're actually set like one set

525
00:25:07,150 --> 00:25:11,769
to one one set to two or two of them are

526
00:25:09,700 --> 00:25:13,690
set to two so I guess here's the thing

527
00:25:11,769 --> 00:25:15,670
we'll have to go look at what those road

528
00:25:13,690 --> 00:25:21,580
transforms aren't that probably is what

529
00:25:15,670 --> 00:25:23,710
it is right because those even though we

530
00:25:21,579 --> 00:25:26,379
said compression zero maybe what

531
00:25:23,710 --> 00:25:30,069
does is get still applies Road

532
00:25:26,380 --> 00:25:33,190
transforms even though compression level

533
00:25:30,069 --> 00:25:36,339
zero turned off deflate maybe it still

534
00:25:33,190 --> 00:25:38,620
applies Road transforms and that would

535
00:25:36,339 --> 00:25:41,439
explain why we're seeing sort of like

536
00:25:38,619 --> 00:25:43,750
values that line up a little bit but

537
00:25:41,440 --> 00:25:52,920
don't really make sense the way we would

538
00:25:43,750 --> 00:25:55,990
expect them to that seems logical to me

539
00:25:52,920 --> 00:26:00,279
like so for example if this was a

540
00:25:55,990 --> 00:26:03,519
difference between the pixel above you

541
00:26:00,279 --> 00:26:10,809
and you this would make a lot of sense

542
00:26:03,519 --> 00:26:14,109
right in fact it looks like a difference

543
00:26:10,809 --> 00:26:17,200
between the pixel oops I had to do too

544
00:26:14,109 --> 00:26:19,750
soon it looks like one is difference

545
00:26:17,200 --> 00:26:22,269
between you and the pixel to your left

546
00:26:19,750 --> 00:26:24,789
and two is you and the pixel to your top

547
00:26:22,269 --> 00:26:29,079
that's what it looks like

548
00:26:24,789 --> 00:26:31,180
so just purely based on what I saw there

549
00:26:29,079 --> 00:26:33,549
that's what I expecting this in this

550
00:26:31,180 --> 00:26:35,710
back this is good I'm glad we're in this

551
00:26:33,549 --> 00:26:37,869
place because today let's forget about

552
00:26:35,710 --> 00:26:40,210
the Huffman for now let's get those

553
00:26:37,869 --> 00:26:42,489
transforms working because we need to do

554
00:26:40,210 --> 00:26:43,840
that and now we have what we think is

555
00:26:42,490 --> 00:26:45,700
good data coming out that's not

556
00:26:43,839 --> 00:26:48,279
compressed that gives us an opportunity

557
00:26:45,700 --> 00:26:50,019
to get that transforms working without

558
00:26:48,279 --> 00:26:52,089
worrying whether the Huffman's working

559
00:26:50,019 --> 00:26:54,400
which is a more complicated part so I

560
00:26:52,089 --> 00:26:56,558
feel like that's really a good thing

561
00:26:54,400 --> 00:26:59,710
here right so

562
00:26:56,558 --> 00:27:02,589
let's go ahead in here and take this

563
00:26:59,710 --> 00:27:04,870
this decompressed pixel stuff to the

564
00:27:02,589 --> 00:27:07,028
sort of make that happen out here

565
00:27:04,869 --> 00:27:09,219
I'm gonna go ahead and have a thing

566
00:27:07,028 --> 00:27:11,079
that's like final pixels which is like

567
00:27:09,220 --> 00:27:13,509
the thing that we take the decompressed

568
00:27:11,079 --> 00:27:16,449
pixels and sort of wrap them into I'm so

569
00:27:13,509 --> 00:27:19,028
I'm going to do a set it to zero here

570
00:27:16,450 --> 00:27:20,740
and then I'm going to allocate pixels

571
00:27:19,028 --> 00:27:24,220
once we actually know that we're

572
00:27:20,740 --> 00:27:26,499
supported in here and we are able to

573
00:27:24,220 --> 00:27:29,079
actually do a decompression on the data

574
00:27:26,499 --> 00:27:32,169
in the file then I'm going to decompress

575
00:27:29,079 --> 00:27:35,259
I'm gonna allocate final pixels worth of

576
00:27:32,169 --> 00:27:40,110
space that we will like sort of extract

577
00:27:35,259 --> 00:27:43,269
the decompressed pixels into right so

578
00:27:40,109 --> 00:27:50,618
once we get to the end here we're just

579
00:27:43,269 --> 00:27:52,720
gonna assume that we're okay and we're

580
00:27:50,618 --> 00:27:55,269
gonna go apply those transforms those

581
00:27:52,720 --> 00:27:57,538
Road transforms as written do if this is

582
00:27:55,269 --> 00:28:04,028
the right place let's take a look here

583
00:27:57,538 --> 00:28:09,628
yeah so coming down here we're gonna

584
00:28:04,028 --> 00:28:09,628
have to go row by row Oh No

585
00:28:14,190 --> 00:28:18,000
what happened to for coder I don't think

586
00:28:16,450 --> 00:28:21,289
we've ever had a crash on stream before

587
00:28:18,000 --> 00:28:24,440
that's the first time

588
00:28:21,289 --> 00:28:24,440
[Music]

589
00:28:34,089 --> 00:28:39,899
let's take a look here what's going on

590
00:28:40,079 --> 00:28:43,829
draw file loaded

591
00:29:04,109 --> 00:29:06,509
should have probably installed the

592
00:29:05,549 --> 00:29:12,690
source on this machine because we

593
00:29:06,509 --> 00:29:15,480
actually could look at it hmm so that's

594
00:29:12,690 --> 00:29:18,420
a drawing problem which is kind of

595
00:29:15,480 --> 00:29:19,769
bizarre I wonder if that's related to

596
00:29:18,420 --> 00:29:21,779
all those flashes we're getting I should

597
00:29:19,769 --> 00:29:30,210
update the version of for coder on this

598
00:29:21,779 --> 00:29:33,440
machine it's a little out of date that

599
00:29:30,210 --> 00:29:33,440
close this No

600
00:29:33,950 --> 00:29:37,559
that may already have been fixed I don't

601
00:29:36,119 --> 00:29:38,819
know but I don't think so because I

602
00:29:37,559 --> 00:29:41,730
don't think there's been any rendering

603
00:29:38,819 --> 00:29:44,369
updates at some point we should try to

604
00:29:41,730 --> 00:29:46,410
debug that purple flash because it's

605
00:29:44,369 --> 00:29:49,709
weird and it happens a lot on this

606
00:29:46,410 --> 00:29:51,720
machine and it doesn't happen on other

607
00:29:49,710 --> 00:29:53,549
machines that I've seen like I don't I

608
00:29:51,720 --> 00:29:54,960
get that once in a blue moon on other

609
00:29:53,549 --> 00:29:57,899
machines but this one happens all the

610
00:29:54,960 --> 00:29:59,340
time makes it seem like maybe it would

611
00:29:57,900 --> 00:30:02,930
be a good idea to debug it on this

612
00:29:59,339 --> 00:30:06,209
machine since it seems like it's pretty

613
00:30:02,930 --> 00:30:07,410
it's got a pretty high hit rate whereas

614
00:30:06,210 --> 00:30:09,000
debugging something on a machine that

615
00:30:07,410 --> 00:30:11,700
doesn't have a high hit rate is very

616
00:30:09,000 --> 00:30:15,450
hard alright so let's try that one more

617
00:30:11,700 --> 00:30:19,740
time again all I want to do here is just

618
00:30:15,450 --> 00:30:22,860
have final pixels if this is just a

619
00:30:19,740 --> 00:30:25,410
thing where I could put the final data

620
00:30:22,859 --> 00:30:27,299
that will get passed back to whoever in

621
00:30:25,410 --> 00:30:30,259
the application is like asking for this

622
00:30:27,299 --> 00:30:34,879
thing right so when you said parse PNG

623
00:30:30,259 --> 00:30:34,879
you know you called me and you handed me

624
00:30:35,119 --> 00:30:44,429
this this PNG file and I'm supposed to

625
00:30:40,529 --> 00:30:46,440
return you like some kind of a set of

626
00:30:44,430 --> 00:30:48,690
pixels so that's gonna be what that what

627
00:30:46,440 --> 00:30:53,250
that value is so when we find that the

628
00:30:48,690 --> 00:30:55,799
thing is supported right here we're

629
00:30:53,250 --> 00:30:57,779
gonna go ahead and allocate space for it

630
00:30:55,799 --> 00:30:59,970
and then at the end we're going to go

631
00:30:57,779 --> 00:31:08,190
through each row that we ended up with

632
00:30:59,970 --> 00:31:10,740
and we're going to try to put the put

633
00:31:08,190 --> 00:31:12,240
the transform data into the

634
00:31:10,740 --> 00:31:16,339
untransformed state so we're like

635
00:31:12,240 --> 00:31:17,430
undoing the transform that the PNG

636
00:31:16,339 --> 00:31:19,709
compressor

637
00:31:17,430 --> 00:31:21,150
did when it compressed before it

638
00:31:19,710 --> 00:31:22,289
compressed the road in this case didn't

639
00:31:21,150 --> 00:31:22,769
compress the roast there was no need for

640
00:31:22,289 --> 00:31:24,809
it

641
00:31:22,769 --> 00:31:26,029
but think that it I'm sorry not pink

642
00:31:24,809 --> 00:31:29,190
did it anyway

643
00:31:26,029 --> 00:31:32,399
sorry apologies rad game tools alright

644
00:31:29,190 --> 00:31:34,259
so if I go through here and I just loop

645
00:31:32,400 --> 00:31:38,250
over my rows I know that I have height

646
00:31:34,259 --> 00:31:43,410
number of rows and what I want to do is

647
00:31:38,250 --> 00:31:44,789
I want to go through each pixel here you

648
00:31:43,410 --> 00:31:46,980
know I could just make it easier on

649
00:31:44,789 --> 00:31:55,829
myself just make this be Y and X I mean

650
00:31:46,980 --> 00:31:57,839
we know what those are so for each of

651
00:31:55,829 --> 00:31:59,490
these what we're gonna do is at the

652
00:31:57,839 --> 00:32:05,819
beginning of the row and I can sort of

653
00:31:59,490 --> 00:32:07,440
set up two things here which is like and

654
00:32:05,819 --> 00:32:08,609
I can pull this out in a separate

655
00:32:07,440 --> 00:32:12,809
function a second cuz it's gonna be

656
00:32:08,609 --> 00:32:14,669
pretty self-contained so we know that

657
00:32:12,809 --> 00:32:17,190
our source is coming from the

658
00:32:14,670 --> 00:32:19,529
decompressed pixel buffer which has that

659
00:32:17,190 --> 00:32:21,120
row thing in each part of it and then

660
00:32:19,529 --> 00:32:23,549
our desk is going to be the final pixels

661
00:32:21,119 --> 00:32:26,789
so what we're gonna do first is we're

662
00:32:23,549 --> 00:32:28,289
gonna read the transform and that's just

663
00:32:26,789 --> 00:32:30,750
a single thing that comes out of the

664
00:32:28,289 --> 00:32:34,289
source and then what we're gonna do is

665
00:32:30,750 --> 00:32:36,720
we're gonna read the RGB and a values

666
00:32:34,289 --> 00:32:39,599
out of the source and then we're gonna

667
00:32:36,720 --> 00:32:42,990
apply potentially some operation to them

668
00:32:39,599 --> 00:32:46,199
and from there you know go from there

669
00:32:42,990 --> 00:32:48,299
right so what we need to do now is we

670
00:32:46,200 --> 00:32:50,370
need to and I like I said looking at it

671
00:32:48,299 --> 00:32:53,419
it looks like their left neighbour

672
00:32:50,369 --> 00:32:55,379
difference and top neighbor difference

673
00:32:53,420 --> 00:32:57,960
we're the two that looked like they were

674
00:32:55,380 --> 00:32:59,460
in there I don't actually know that was

675
00:32:57,960 --> 00:33:02,610
just my guess so we got to go look at

676
00:32:59,460 --> 00:33:06,920
the PNG specification and find out what

677
00:33:02,609 --> 00:33:10,789
the actual what those actually are so

678
00:33:06,920 --> 00:33:10,789
where was that stuff

679
00:33:13,710 --> 00:33:17,690
let's transforms

680
00:33:25,868 --> 00:33:36,648
a number of transformations are applied

681
00:33:34,669 --> 00:33:38,360
to the reference image to create the P&amp;G

682
00:33:36,648 --> 00:33:40,428
intra-coded tracers are applied in the

683
00:33:38,359 --> 00:33:42,368
following sequence where square brackets

684
00:33:40,429 --> 00:33:47,450
mean the transformation is optional

685
00:33:42,368 --> 00:33:51,470
alpha separation indexing or RGB merging

686
00:33:47,450 --> 00:33:52,940
and then sample depth scaling okay when

687
00:33:51,470 --> 00:33:54,919
every pixel is either fully transparent

688
00:33:52,940 --> 00:33:56,480
if I pick the Alpha separation alpha

689
00:33:54,919 --> 00:33:58,429
compaction and indexing transfer aces

690
00:33:56,480 --> 00:34:00,169
can cause the recovered reference image

691
00:33:58,429 --> 00:34:02,389
to have an alpha sample depth different

692
00:34:00,169 --> 00:34:04,610
from the original reference image or to

693
00:34:02,388 --> 00:34:06,949
have no alpha channel this has no effect

694
00:34:04,609 --> 00:34:08,148
through capacity of any pixel truther is

695
00:34:06,950 --> 00:34:09,858
considered equivalent of the transfer

696
00:34:08,148 --> 00:34:11,418
circuit sort of lossless encoders that

697
00:34:09,858 --> 00:34:13,369
nevertheless wish to preserve the Alpha

698
00:34:11,418 --> 00:34:19,608
sample depth may elect not to perform

699
00:34:13,369 --> 00:34:21,679
transportation is that okay all right if

700
00:34:19,608 --> 00:34:24,199
all alpha samples in a reference image

701
00:34:21,679 --> 00:34:26,378
have the same have the maximum value

702
00:34:24,199 --> 00:34:29,000
then the Alpha Channel may be omitted

703
00:34:26,378 --> 00:34:32,449
resulting in an equivalent image that

704
00:34:29,000 --> 00:34:36,168
can be encoded more okay so that

705
00:34:32,449 --> 00:34:39,348
actually was the case with our image it

706
00:34:36,168 --> 00:34:41,808
just doesn't seem like they actually did

707
00:34:39,349 --> 00:34:45,440
that unless when they say omitted they

708
00:34:41,809 --> 00:34:47,059
mean just wrote zero or something but no

709
00:34:45,440 --> 00:34:50,539
they didn't they actually encoded it I

710
00:34:47,059 --> 00:34:53,480
think I think it looks like because it

711
00:34:50,539 --> 00:34:55,489
was the right row length I think's with

712
00:34:53,480 --> 00:35:01,039
alpha in it so I don't think that

713
00:34:55,489 --> 00:35:02,929
actually removed the Alpha in either

714
00:35:01,039 --> 00:35:05,568
case we probably don't care about that

715
00:35:02,929 --> 00:35:09,019
because we will never have an image that

716
00:35:05,568 --> 00:35:10,730
probably does that but we can look so

717
00:35:09,019 --> 00:35:11,869
one thing I don't like here is they're

718
00:35:10,730 --> 00:35:13,280
not telling us how to do it so this is

719
00:35:11,869 --> 00:35:14,750
really the wrong section to look at

720
00:35:13,280 --> 00:35:16,640
probably but hey it's a good background

721
00:35:14,750 --> 00:35:22,338
or we need to look close like it doesn't

722
00:35:16,639 --> 00:35:24,048
say how it encodes that fact right maybe

723
00:35:22,338 --> 00:35:26,630
it encodes that fact by just saying that

724
00:35:24,048 --> 00:35:28,960
the file isn't for deep it's three deep

725
00:35:26,630 --> 00:35:31,190
right maybe that's what they mean

726
00:35:28,960 --> 00:35:33,949
indexing if the number of distinct pixel

727
00:35:31,190 --> 00:35:36,019
values is 256 or less and the RGB sample

728
00:35:33,949 --> 00:35:38,480
depths are not greater than eight and

729
00:35:36,019 --> 00:35:40,579
the Alpha Channel is absent or exactly

730
00:35:38,480 --> 00:35:41,780
it's deep or every pixel is either fully

731
00:35:40,579 --> 00:35:44,420
transparent you know what

732
00:35:41,780 --> 00:35:47,930
and here's probably why gimped into it I

733
00:35:44,420 --> 00:35:49,460
manually selected RGB a8 so even if

734
00:35:47,929 --> 00:35:50,868
their compressor would normally look and

735
00:35:49,460 --> 00:35:55,550
see if was going to emit the alpha table

736
00:35:50,869 --> 00:35:56,690
I sort of force them not to right so

737
00:35:55,550 --> 00:35:57,920
maybe we should allow them to do that

738
00:35:56,690 --> 00:35:59,358
just we can make sure we handle that

739
00:35:57,920 --> 00:36:02,269
case we may need to handle that case

740
00:35:59,358 --> 00:36:03,769
because for like a backdrop scene that

741
00:36:02,269 --> 00:36:06,800
doesn't have any alpha maybe I don't

742
00:36:03,769 --> 00:36:08,000
know hard it's hard to say we can cross

743
00:36:06,800 --> 00:36:09,500
that bridge when we come to it shouldn't

744
00:36:08,000 --> 00:36:10,719
be a very hard modification to make to

745
00:36:09,500 --> 00:36:13,849
say the least

746
00:36:10,719 --> 00:36:17,809
alright so bla bla bla bla bla bla bla

747
00:36:13,849 --> 00:36:24,769
no one cares so let's see assuming we

748
00:36:17,809 --> 00:36:26,150
don't care about indexing RGB merging so

749
00:36:24,769 --> 00:36:28,659
it's basically saying can reduce to

750
00:36:26,150 --> 00:36:28,660
grayscale

751
00:36:37,909 --> 00:36:41,989
this one yes so these are these are

752
00:36:40,280 --> 00:36:44,089
things we probably just don't care about

753
00:36:41,989 --> 00:36:46,009
this would be these are all if you

754
00:36:44,088 --> 00:36:48,380
wanted to support the full spec and

755
00:36:46,010 --> 00:36:49,430
cared a lot about it we don't we only

756
00:36:48,380 --> 00:36:50,930
care about the things we're likely to

757
00:36:49,429 --> 00:36:53,500
see so unless we see that we're not

758
00:36:50,929 --> 00:36:53,500
going to do it

759
00:37:02,050 --> 00:37:05,990
okay so this is just something that

760
00:37:04,190 --> 00:37:07,190
expands values that are a different

761
00:37:05,989 --> 00:37:09,699
sample that's we don't care about that

762
00:37:07,190 --> 00:37:09,700
either

763
00:37:30,079 --> 00:37:34,500
each scanline is transformed into a

764
00:37:32,639 --> 00:37:40,789
filtered scanline we're more defined

765
00:37:34,500 --> 00:37:40,789
filter types compression chunking

766
00:37:41,480 --> 00:37:44,869
reconstruction okay

767
00:37:53,340 --> 00:37:59,340
not sure I follow this here fourth

768
00:37:57,119 --> 00:38:08,369
reduced image fifth reduced image sixth

769
00:37:59,340 --> 00:38:11,210
reduced image seventh reduced image I'm

770
00:38:08,369 --> 00:38:11,210
not sure I follow that

771
00:38:16,780 --> 00:38:21,430
pass extractions splits a PNG image into

772
00:38:19,539 --> 00:38:23,440
a sequence of reduced images where the

773
00:38:21,429 --> 00:38:25,210
first image defines a course view and

774
00:38:23,440 --> 00:38:29,440
subsequent images enhance this course

775
00:38:25,210 --> 00:38:32,110
view until the last image completes the

776
00:38:29,440 --> 00:38:35,289
PNG image the set of reduced images is

777
00:38:32,110 --> 00:38:37,090
also called an interlaced PNG image two

778
00:38:35,289 --> 00:38:39,070
interlaced methods are defined the first

779
00:38:37,090 --> 00:38:41,200
method is a null method they're stored

780
00:38:39,070 --> 00:38:45,850
sequentially so I think I don't care

781
00:38:41,199 --> 00:38:50,739
about that either this makes no sense to

782
00:38:45,849 --> 00:38:51,039
me what what this here makes no sense at

783
00:38:50,739 --> 00:38:57,009
all

784
00:38:51,039 --> 00:38:58,719
I mean I can see I guess they chose I

785
00:38:57,010 --> 00:39:01,900
guess this is just how they chose to

786
00:38:58,719 --> 00:39:03,730
encode smaller versions of it so here's

787
00:39:01,900 --> 00:39:05,829
the 4 pixel version it does this one

788
00:39:03,730 --> 00:39:08,710
this one this one this one right and

789
00:39:05,829 --> 00:39:12,849
then so rather than doing like a wavelet

790
00:39:08,710 --> 00:39:15,130
where you would blur out the you take

791
00:39:12,849 --> 00:39:17,409
the average of like all of these or some

792
00:39:15,130 --> 00:39:19,990
other wavelet transform and then you

793
00:39:17,409 --> 00:39:22,420
would do the difference from the average

794
00:39:19,989 --> 00:39:25,000
and code that progressively they just

795
00:39:22,420 --> 00:39:28,119
actually literally take specific pixels

796
00:39:25,000 --> 00:39:29,920
who knows why probably memory bandwidth

797
00:39:28,119 --> 00:39:31,119
concerns or maybe they probably cuz they

798
00:39:29,920 --> 00:39:32,639
didn't know about wavelets I don't know

799
00:39:31,119 --> 00:39:39,190
both of those two things probably

800
00:39:32,639 --> 00:39:41,859
wavelets are bad for the cache so let's

801
00:39:39,190 --> 00:39:44,260
see here okay

802
00:39:41,860 --> 00:39:45,730
PNG standardized one filter method in

803
00:39:44,260 --> 00:39:47,140
several filter types that may be used to

804
00:39:45,730 --> 00:39:48,550
prepare image data for compression

805
00:39:47,139 --> 00:39:49,809
transference one bytes you get scan line

806
00:39:48,550 --> 00:39:51,519
to decode length sequence of bytes

807
00:39:49,809 --> 00:39:53,259
preceded by a filter type byte that's

808
00:39:51,519 --> 00:39:55,239
what we're looking at flow type byte

809
00:39:53,260 --> 00:39:57,130
define stick meaning to plastics and

810
00:39:55,239 --> 00:39:58,989
line the encoder shall use only a single

811
00:39:57,130 --> 00:40:00,130
filter method of an interlaced PNG image

812
00:39:58,989 --> 00:40:02,379
may use different prototypes for each

813
00:40:00,130 --> 00:40:04,360
scan line and a reduced image so we're

814
00:40:02,380 --> 00:40:08,019
using the non-interlaced versions here

815
00:40:04,360 --> 00:40:10,599
so we're talking about multiple filter

816
00:40:08,019 --> 00:40:12,369
methods so exactly as we expect here so

817
00:40:10,599 --> 00:40:14,319
what are those filter types that's what

818
00:40:12,369 --> 00:40:16,329
we really want to know that's not in

819
00:40:14,320 --> 00:40:18,940
here so let's go ahead and look at the

820
00:40:16,329 --> 00:40:22,949
filter type section presumably that's

821
00:40:18,940 --> 00:40:22,950
defined somewhere filtering

822
00:40:24,639 --> 00:40:30,069
here we go okay so filtering transforms

823
00:40:28,659 --> 00:40:30,879
the PNG image school of improving

824
00:40:30,070 --> 00:40:33,370
compression

825
00:40:30,880 --> 00:40:35,380
yep that we know that only filter method

826
00:40:33,369 --> 00:40:36,489
0 is defined by this international

827
00:40:35,380 --> 00:40:39,640
standard other fill nurse or reserved

828
00:40:36,489 --> 00:40:46,839
for future use so they're talking I

829
00:40:39,639 --> 00:40:57,309
believe though about this so I believe

830
00:40:46,840 --> 00:40:59,260
they're talking about this one so filter

831
00:40:57,309 --> 00:41:01,420
methods 0 is the part they're talking

832
00:40:59,260 --> 00:41:06,820
about only has a 0 in it that's just the

833
00:41:01,420 --> 00:41:10,869
overall filter Bank type each individual

834
00:41:06,820 --> 00:41:14,110
row for filter method 0 has a different

835
00:41:10,869 --> 00:41:16,349
filter type for that method so that's

836
00:41:14,110 --> 00:41:19,420
what they mean by only filter method 0

837
00:41:16,349 --> 00:41:24,239
here's the actual set of filters so here

838
00:41:19,420 --> 00:41:32,380
you go 0 just means hey use the original

839
00:41:24,239 --> 00:41:36,119
1 means oh subtract from the I assume

840
00:41:32,380 --> 00:41:42,910
these are was at the byte to the left

841
00:41:36,119 --> 00:41:47,589
the byte in the previous day on line the

842
00:41:42,909 --> 00:41:54,269
bike corresponding to be in the pixel

843
00:41:47,590 --> 00:42:01,329
immediately before the pixel containing

844
00:41:54,269 --> 00:42:03,509
B so does that mean the pixel 2 pixels

845
00:42:01,329 --> 00:42:03,509
back

846
00:42:05,050 --> 00:42:08,119
[Music]

847
00:42:23,449 --> 00:42:29,509
I I don't quite know what they mean by

848
00:42:27,590 --> 00:42:33,650
that but I'm interpreting that to mean

849
00:42:29,510 --> 00:42:36,470
two pixels back so X is the bike being

850
00:42:33,650 --> 00:42:38,420
filtered a is the bike corresponding to

851
00:42:36,469 --> 00:42:43,399
X in the pixel immediately before the

852
00:42:38,420 --> 00:42:45,139
pixel containing X right so basically

853
00:42:43,400 --> 00:42:47,780
that's saying if we were talking about

854
00:42:45,139 --> 00:42:50,389
the red channel of the current pixel we

855
00:42:47,780 --> 00:42:58,990
would talk about the red channel in the

856
00:42:50,389 --> 00:43:01,429
pixel one to the left right that's all

857
00:42:58,989 --> 00:43:04,489
be is the bike crash X the previous

858
00:43:01,429 --> 00:43:06,440
scanline so that's just again the same

859
00:43:04,489 --> 00:43:10,969
thing but top so this is exactly what I

860
00:43:06,440 --> 00:43:14,179
thought right in C is the bike

861
00:43:10,969 --> 00:43:15,889
corresponding to B in the pixel

862
00:43:14,179 --> 00:43:18,399
immediately before the pics contain D so

863
00:43:15,889 --> 00:43:21,259
that's two pixels back I'm pretty sure

864
00:43:18,400 --> 00:43:26,210
so my guess I mean I don't understand

865
00:43:21,260 --> 00:43:28,700
why you would have C in there but my

866
00:43:26,210 --> 00:43:32,960
guess is it's because since this was

867
00:43:28,699 --> 00:43:35,329
like low res and had an indexed mode and

868
00:43:32,960 --> 00:43:38,900
stuff like that differing was probably a

869
00:43:35,329 --> 00:43:42,799
thing so I'm guessing that maybe that is

870
00:43:38,900 --> 00:43:45,050
a like alternating pixels is a common

871
00:43:42,800 --> 00:43:49,670
thing you would see in like bit to Italy

872
00:43:45,050 --> 00:43:52,130
like pixel art right and since this was

873
00:43:49,670 --> 00:43:54,860
made in that era potentially for that

874
00:43:52,130 --> 00:43:56,900
sort of thing that makes a lot more

875
00:43:54,860 --> 00:43:59,120
sense than if you were making one today

876
00:43:56,900 --> 00:44:02,119
you pry don't that doesn't sound super

877
00:43:59,119 --> 00:44:03,559
plausible like sure that might be one

878
00:44:02,119 --> 00:44:05,809
thing if you had lots but you would

879
00:44:03,559 --> 00:44:08,299
probably like you'd probably want the

880
00:44:05,809 --> 00:44:10,789
pixel up and to the left before you

881
00:44:08,300 --> 00:44:12,590
would want the pixel to to the left most

882
00:44:10,789 --> 00:44:14,599
of the time I would think so if you're

883
00:44:12,590 --> 00:44:17,269
gonna pick one more thing to have it

884
00:44:14,599 --> 00:44:18,920
wouldn't be too to the left but you know

885
00:44:17,269 --> 00:44:21,079
I'm just guessing that because of

886
00:44:18,920 --> 00:44:22,340
differing maybe that's where that comes

887
00:44:21,079 --> 00:44:25,069
from I don't know

888
00:44:22,340 --> 00:44:26,150
hard to say anyway those are pretty

889
00:44:25,070 --> 00:44:28,010
straightforward assuming that I'm

890
00:44:26,150 --> 00:44:29,840
interpreting C correctly as to the left

891
00:44:28,010 --> 00:44:31,010
those are pretty easy to understand we

892
00:44:29,840 --> 00:44:33,050
wouldn't have much trouble implementing

893
00:44:31,010 --> 00:44:35,660
those so that's fine so here are the

894
00:44:33,050 --> 00:44:38,110
actual filter types encoded based on

895
00:44:35,659 --> 00:44:42,019
these prior values

896
00:44:38,110 --> 00:44:43,760
so to reconstruct type-0 it's just the

897
00:44:42,019 --> 00:44:49,750
value that means no filter is applied

898
00:44:43,760 --> 00:44:53,980
type 1 we add in the prior pixel value

899
00:44:49,750 --> 00:44:58,849
now I don't know how we add it in I

900
00:44:53,980 --> 00:45:02,179
assume that it's just an 8-bit wrap not

901
00:44:58,849 --> 00:45:05,509
an 8-bit saturates here we go

902
00:45:02,179 --> 00:45:08,059
unsigned arithmetic modulo 256 is used

903
00:45:05,510 --> 00:45:10,420
so that both the inputs and outputs fit

904
00:45:08,059 --> 00:45:14,299
into bytes so it's basically like saying

905
00:45:10,420 --> 00:45:16,720
if we were at 2:30 and we were supposed

906
00:45:14,300 --> 00:45:19,910
to add a hundred we would wrap around

907
00:45:16,719 --> 00:45:22,459
rather than saturate to 255 we'd go we'd

908
00:45:19,909 --> 00:45:26,539
end up at a lower value right so we're

909
00:45:22,460 --> 00:45:28,369
doing a wrapped a wrapped unsigned add

910
00:45:26,539 --> 00:45:30,889
which I mean just a wrap add doesn't

911
00:45:28,369 --> 00:45:34,489
matter with signed or unsigned so we're

912
00:45:30,889 --> 00:45:35,629
doing a raft add there and that's pretty

913
00:45:34,489 --> 00:45:40,879
straightforward so I'm glad they

914
00:45:35,630 --> 00:45:43,760
specified that okay so we add either the

915
00:45:40,880 --> 00:45:46,160
pixel to our left the pixel to right

916
00:45:43,760 --> 00:45:48,470
above us and I should say the channel

917
00:45:46,159 --> 00:45:49,730
right above us because it's it's a

918
00:45:48,469 --> 00:45:52,429
specific part of the pixel it's the red

919
00:45:49,730 --> 00:45:55,280
green blue or alph channel then we have

920
00:45:52,429 --> 00:45:58,519
this sort of average which takes both

921
00:45:55,280 --> 00:46:04,040
the previous two pixels and splits the

922
00:45:58,519 --> 00:46:07,960
difference okay and then we've got a

923
00:46:04,039 --> 00:46:17,079
path predictor or path predictor for

924
00:46:07,960 --> 00:46:17,079
with a B and C pass into it and that is

925
00:46:17,619 --> 00:46:21,130
this function right here

926
00:46:28,420 --> 00:46:33,470
it says that the calculations shall be

927
00:46:31,550 --> 00:46:35,000
performed without overflow which

928
00:46:33,469 --> 00:46:39,348
suggests that they should be

929
00:46:35,000 --> 00:46:42,920
I guess computed in 32-bit or 16-bit so

930
00:46:39,349 --> 00:46:45,800
that if you add 255 to 255 you actually

931
00:46:42,920 --> 00:46:56,000
get a value greater than 25 not a

932
00:46:45,800 --> 00:47:07,400
wraparound value just assuming so that

933
00:46:56,000 --> 00:47:09,260
seems reasonable I don't think we really

934
00:47:07,400 --> 00:47:11,630
need anything more than that so let's

935
00:47:09,260 --> 00:47:13,700
set ourselves up to apply this transform

936
00:47:11,630 --> 00:47:16,430
so looking at what's going to happen

937
00:47:13,699 --> 00:47:20,389
here we know that we need to prior

938
00:47:16,429 --> 00:47:24,829
pixels and we also know that we need a

939
00:47:20,389 --> 00:47:27,829
prior scanline now when we look at how

940
00:47:24,829 --> 00:47:33,920
this is accessing despite what I weight

941
00:47:27,829 --> 00:47:38,269
might have assumed they never use values

942
00:47:33,920 --> 00:47:42,430
to the left of the top pixels like they

943
00:47:38,269 --> 00:47:45,050
never look a scanline back and then over

944
00:47:42,429 --> 00:47:46,879
at least if they are I'm not seeing it

945
00:47:45,050 --> 00:47:52,089
it looks like they only look behind us

946
00:47:46,880 --> 00:47:52,088
on this row and they only look above us

947
00:47:53,559 --> 00:47:59,509
directly so the reason that I bring up

948
00:47:57,500 --> 00:48:00,949
this is being odd is I would have

949
00:47:59,510 --> 00:48:03,109
thought they would have they don't seem

950
00:48:00,949 --> 00:48:05,960
to I also think it's a little weird

951
00:48:03,108 --> 00:48:08,029
because they say for filters that refer

952
00:48:05,960 --> 00:48:11,150
to the prior scanline the entire prior

953
00:48:08,030 --> 00:48:13,490
scanline and bytes to the left of the

954
00:48:11,150 --> 00:48:17,030
first pixel in the prior scanline shall

955
00:48:13,489 --> 00:48:19,368
be treated as being zeros but when would

956
00:48:17,030 --> 00:48:20,990
they ever look at a value that was to

957
00:48:19,369 --> 00:48:27,200
the left of the first pixel in the prior

958
00:48:20,989 --> 00:48:30,909
scanline how would you get there can you

959
00:48:27,199 --> 00:48:30,909
see it because I don't I don't see it

960
00:48:35,969 --> 00:48:39,599
bonus points to anyone who can see how

961
00:48:37,679 --> 00:48:40,739
that ever actually happens for right now

962
00:48:39,599 --> 00:48:43,589
I'm going to assume that that doesn't

963
00:48:40,739 --> 00:48:45,799
actually ever happen because if it did

964
00:48:43,590 --> 00:48:47,519
happen that means that I'm

965
00:48:45,800 --> 00:48:49,260
misunderstanding this because the

966
00:48:47,519 --> 00:48:51,300
understanding that I have about what

967
00:48:49,260 --> 00:48:54,120
they're asking me to look at can never

968
00:48:51,300 --> 00:48:57,690
look there so if you actually can look

969
00:48:54,119 --> 00:48:59,630
there somehow I then I messed it up like

970
00:48:57,690 --> 00:49:03,960
I'm not thinking about this properly

971
00:48:59,630 --> 00:49:07,289
unfortunately so that's just that's just

972
00:49:03,960 --> 00:49:10,590
how that is so what we want to do here

973
00:49:07,289 --> 00:49:13,710
is we want to do a prior row value right

974
00:49:10,590 --> 00:49:16,650
and looking at the prior row it's

975
00:49:13,710 --> 00:49:18,960
telling us that it wants us to have it

976
00:49:16,650 --> 00:49:21,780
be all zeros

977
00:49:18,960 --> 00:49:26,639
when we look back there we're supposed

978
00:49:21,780 --> 00:49:29,519
to find just pure zeros right so what I

979
00:49:26,639 --> 00:49:32,940
would probably do is I will probably say

980
00:49:29,519 --> 00:49:35,610
that we want to have a zero row here

981
00:49:32,940 --> 00:49:39,179
that we look at and then every time

982
00:49:35,610 --> 00:49:46,829
through we just set the prior row equal

983
00:49:39,179 --> 00:49:49,819
to the row that we just did right you

984
00:49:46,829 --> 00:49:49,819
know something like this actually

985
00:49:55,949 --> 00:50:00,239
this sort of thing right so every time

986
00:49:58,230 --> 00:50:02,429
through will remember where we started

987
00:50:00,239 --> 00:50:05,219
this row and then at the end of that we

988
00:50:02,429 --> 00:50:06,868
will swap that back in so that the next

989
00:50:05,219 --> 00:50:20,909
person looks at that that row separately

990
00:50:06,869 --> 00:50:31,200
right um so so we would have liked to

991
00:50:20,909 --> 00:50:32,338
have done this we would I mean this is

992
00:50:31,199 --> 00:50:34,559
the kind of thing we almost would like

993
00:50:32,338 --> 00:50:36,179
to do in Cindy because we're going to do

994
00:50:34,559 --> 00:50:38,190
the exact same thing to every channel

995
00:50:36,179 --> 00:50:41,549
since the filter type is only allowed to

996
00:50:38,190 --> 00:50:45,690
be a one filter type we are going to

997
00:50:41,550 --> 00:50:47,849
apply the same thing to RGB and a so the

998
00:50:45,690 --> 00:50:50,730
right way to do this would be to load it

999
00:50:47,849 --> 00:50:53,160
into an m1 28 and just apply it there I

1000
00:50:50,730 --> 00:50:55,170
don't really want to do that here

1001
00:50:53,159 --> 00:50:56,670
because it seems like maybe I'm gets a

1002
00:50:55,170 --> 00:50:58,320
little bit overkill for this reference

1003
00:50:56,670 --> 00:51:00,690
code but that's what you would do

1004
00:50:58,320 --> 00:51:05,088
because you're doing literally exactly

1005
00:51:00,690 --> 00:51:08,309
that furthermore you're doing it for

1006
00:51:05,088 --> 00:51:09,568
everyone so you can't actually you could

1007
00:51:08,309 --> 00:51:12,000
actually do this if you're trying to

1008
00:51:09,568 --> 00:51:14,940
load PNG as quickly you could apply this

1009
00:51:12,000 --> 00:51:17,068
filter using cindy really efficiently so

1010
00:51:14,940 --> 00:51:19,280
I'm just gonna put a note here about

1011
00:51:17,068 --> 00:51:19,279
that

1012
00:51:52,619 --> 00:51:58,210
so I would just point out the fact that

1013
00:51:55,239 --> 00:52:00,069
if you did want to make this this part

1014
00:51:58,210 --> 00:52:02,260
of the process run quickly I think you

1015
00:52:00,070 --> 00:52:04,870
certainly could now what I would point

1016
00:52:02,260 --> 00:52:07,660
out is that may be one of those cases of

1017
00:52:04,869 --> 00:52:08,230
just being an optimization person for no

1018
00:52:07,659 --> 00:52:10,869
reason

1019
00:52:08,230 --> 00:52:12,099
because I would assume and I could be

1020
00:52:10,869 --> 00:52:14,529
very wrong about this but I would assume

1021
00:52:12,099 --> 00:52:16,329
that the Huffman D code is gonna be the

1022
00:52:14,530 --> 00:52:18,760
disaster here because it's such a bit

1023
00:52:16,329 --> 00:52:20,650
twiddling serialised process that really

1024
00:52:18,760 --> 00:52:22,450
can't be accelerated very easily no

1025
00:52:20,650 --> 00:52:25,150
matter what you do at least not to the

1026
00:52:22,449 --> 00:52:26,589
kinds of speeds you would want so this

1027
00:52:25,150 --> 00:52:28,450
is the part of the press that could be

1028
00:52:26,590 --> 00:52:29,860
trivially sped up a Sindhi not to

1029
00:52:28,449 --> 00:52:33,879
mention trivially multi-threaded because

1030
00:52:29,860 --> 00:52:35,769
every row is only dependent on the prior

1031
00:52:33,880 --> 00:52:38,200
row so I feel like you could do some

1032
00:52:35,769 --> 00:52:41,139
pretty easy stuff there where you just

1033
00:52:38,199 --> 00:52:43,329
broke the image up into bands that could

1034
00:52:41,139 --> 00:52:45,219
be done separately I suppose although I

1035
00:52:43,329 --> 00:52:46,690
guess the look back makes it a little

1036
00:52:45,219 --> 00:52:48,909
bit harder to do it that way so maybe

1037
00:52:46,690 --> 00:52:50,829
it's not quite as easy because of the

1038
00:52:48,909 --> 00:52:51,909
way the look-back works to do the multi

1039
00:52:50,829 --> 00:52:54,309
thread but I'm sure you could still

1040
00:52:51,909 --> 00:52:56,469
figure out some way to do it anyway

1041
00:52:54,309 --> 00:52:58,840
point being the Cindy part though it

1042
00:52:56,469 --> 00:53:01,509
seems really easy to do because for wide

1043
00:52:58,840 --> 00:53:04,300
would just be for channels at once and I

1044
00:53:01,510 --> 00:53:05,980
feel like that would would be good maybe

1045
00:53:04,300 --> 00:53:10,120
I'll just say that not to overstate the

1046
00:53:05,980 --> 00:53:11,530
case but since RGB and a are all handled

1047
00:53:10,119 --> 00:53:14,170
the same this would be a pretty easy

1048
00:53:11,530 --> 00:53:15,370
case to be for that however I don't

1049
00:53:14,170 --> 00:53:17,500
think this is probably the slow part of

1050
00:53:15,369 --> 00:53:20,259
the process we'll find out but I don't

1051
00:53:17,500 --> 00:53:22,059
think it is so in here we need to know

1052
00:53:20,260 --> 00:53:24,580
the row filter type so we're gonna have

1053
00:53:22,059 --> 00:53:27,009
to switch on this transform and because

1054
00:53:24,579 --> 00:53:28,599
we get it every row it changes right so

1055
00:53:27,010 --> 00:53:33,930
we're gonna have to handle each case

1056
00:53:28,599 --> 00:53:33,929
separately here for the transforms

1057
00:53:34,650 --> 00:53:44,460
and if we look back

1058
00:53:37,650 --> 00:53:48,108
we're only expected to go up to four so

1059
00:53:44,460 --> 00:53:50,309
in the event that we actually found a

1060
00:53:48,108 --> 00:54:08,518
value that wasn't one of those values

1061
00:53:50,309 --> 00:54:12,420
that's an error so I'm just gonna print

1062
00:54:08,518 --> 00:54:13,858
it out if that's the case now I was

1063
00:54:12,420 --> 00:54:15,778
calling these transforms they're really

1064
00:54:13,858 --> 00:54:17,818
filters according the spec I mean I

1065
00:54:15,778 --> 00:54:19,230
don't know what the difference is

1066
00:54:17,818 --> 00:54:20,670
between those two I wouldn't have called

1067
00:54:19,230 --> 00:54:25,559
this a filter this call it sounds like a

1068
00:54:20,670 --> 00:54:28,349
transform to me but all right so

1069
00:54:25,559 --> 00:54:29,849
assuming this is you know this this is

1070
00:54:28,349 --> 00:54:31,048
called a filter let's just name it that

1071
00:54:29,849 --> 00:54:33,359
so you know in the spec what we're

1072
00:54:31,048 --> 00:54:36,559
looking at so we get an unrecognized row

1073
00:54:33,358 --> 00:54:40,858
filter will complain each one of these

1074
00:54:36,559 --> 00:54:43,200
them is going to be its own loop where

1075
00:54:40,858 --> 00:54:44,969
it does something different so each of

1076
00:54:43,199 --> 00:54:47,278
these is going to behave a little bit

1077
00:54:44,969 --> 00:54:50,399
differently in this case this is just a

1078
00:54:47,278 --> 00:54:53,309
straight copy so this would be something

1079
00:54:50,400 --> 00:54:58,019
where we just copy all of the pixels to

1080
00:54:53,309 --> 00:55:03,960
the source and we can do this 32-bit

1081
00:54:58,018 --> 00:55:13,159
wide if we want to because you know we

1082
00:55:03,960 --> 00:55:13,159
can do this right

1083
00:55:15,228 --> 00:55:21,058
because we know that we're gonna copy

1084
00:55:17,309 --> 00:55:25,670
entire chunks of for every time and and

1085
00:55:21,059 --> 00:55:31,289
we're only supporting the the four wide

1086
00:55:25,670 --> 00:55:35,309
values at the moment now I don't know we

1087
00:55:31,289 --> 00:55:41,210
did bit-depth eight color type six which

1088
00:55:35,309 --> 00:55:44,400
I think color type six is our GBA right

1089
00:55:41,210 --> 00:55:46,318
yeah so we know that we're always that

1090
00:55:44,400 --> 00:55:48,210
format and the artist just has to react

1091
00:55:46,318 --> 00:55:49,588
sport it if it's not in that format so

1092
00:55:48,210 --> 00:55:52,429
we're just gonna say that that's the

1093
00:55:49,588 --> 00:55:56,369
case for now we may have to support

1094
00:55:52,429 --> 00:55:58,259
color type two at which point we would

1095
00:55:56,369 --> 00:55:59,430
have to make this be a little bit

1096
00:55:58,259 --> 00:56:02,909
different because it would have to

1097
00:55:59,429 --> 00:56:06,389
support like even filter mode zero would

1098
00:56:02,909 --> 00:56:10,940
have to support and like an extraction

1099
00:56:06,389 --> 00:56:13,858
phase right it has to go from three

1100
00:56:10,940 --> 00:56:17,818
components to four so it has to read

1101
00:56:13,858 --> 00:56:19,889
three pad to four and right so you know

1102
00:56:17,818 --> 00:56:23,038
just pointing out that's a little bit

1103
00:56:19,889 --> 00:56:25,528
different this would be a plus four but

1104
00:56:23,039 --> 00:56:29,910
this would be a plus three and the Alpha

1105
00:56:25,528 --> 00:56:33,028
Channel would get wrapped in it would

1106
00:56:29,909 --> 00:56:34,768
get add it in there so we can't support

1107
00:56:33,028 --> 00:56:39,838
that eventually if we find that we want

1108
00:56:34,768 --> 00:56:43,649
to and we may have to write alright so

1109
00:56:39,838 --> 00:56:45,210
moving along if we're in case you know

1110
00:56:43,650 --> 00:56:48,048
so now we're looking at something

1111
00:56:45,210 --> 00:56:50,338
similar to this certainly in each case

1112
00:56:48,048 --> 00:56:52,440
but you know we've got sort of a

1113
00:56:50,338 --> 00:56:54,798
different process to go here so what I'm

1114
00:56:52,440 --> 00:56:58,380
going to suggest is when we're actually

1115
00:56:54,798 --> 00:57:00,088
going through these I might suggest that

1116
00:56:58,380 --> 00:57:02,309
we just do per channel since each

1117
00:57:00,088 --> 00:57:04,380
channel gets handle the same way I'm

1118
00:57:02,309 --> 00:57:08,969
thinking that maybe it's it's more like

1119
00:57:04,380 --> 00:57:16,289
this sort of a thing and so now what we

1120
00:57:08,969 --> 00:57:18,528
want to do is start to change that it

1121
00:57:16,289 --> 00:57:21,180
starts to make this a little bit more I

1122
00:57:18,528 --> 00:57:22,440
think it was called little X was the

1123
00:57:21,179 --> 00:57:27,169
value I don't really want to do that

1124
00:57:22,440 --> 00:57:27,170
let's let's call that the V or something

1125
00:57:29,340 --> 00:57:36,700
so what we want to do here in case one

1126
00:57:32,230 --> 00:57:37,119
is now start to follow that table here

1127
00:57:36,699 --> 00:57:38,980
it is

1128
00:57:37,119 --> 00:57:43,259
so the reconstruction filter of our case

1129
00:57:38,980 --> 00:57:46,690
one is we just want to add whatever the

1130
00:57:43,260 --> 00:57:50,490
previous byte was the previous pixels

1131
00:57:46,690 --> 00:58:00,849
was so what we want to do here is say

1132
00:57:50,489 --> 00:58:03,449
that trying to think of exactly how to

1133
00:58:00,849 --> 00:58:03,449
say this

1134
00:58:08,440 --> 00:58:16,548
so we want to be able to read from the

1135
00:58:14,599 --> 00:58:21,829
previous pixel or in the other case the

1136
00:58:16,548 --> 00:58:24,798
previous two pixels right so there's a

1137
00:58:21,829 --> 00:58:28,099
couple different ways we can do that one

1138
00:58:24,798 --> 00:58:30,349
is we can just back fetch from them the

1139
00:58:28,099 --> 00:58:33,170
problem is if we want to write tightly

1140
00:58:30,349 --> 00:58:37,190
into the result then we have the problem

1141
00:58:33,170 --> 00:58:41,809
of how to handle the gaps basically like

1142
00:58:37,190 --> 00:58:49,190
the sort of the parts of the image that

1143
00:58:41,809 --> 00:58:50,809
we haven't quite gotten so I guess the

1144
00:58:49,190 --> 00:58:54,769
question is do we want to make it easier

1145
00:58:50,809 --> 00:58:56,298
on ourselves to filter and just allocate

1146
00:58:54,769 --> 00:58:59,059
more space and fill that space with

1147
00:58:56,298 --> 00:59:01,429
known information or do we want to do

1148
00:58:59,059 --> 00:59:03,519
something saucy er than that I don't

1149
00:59:01,429 --> 00:59:03,519
know

1150
00:59:22,829 --> 00:59:28,650
I mean I guess the other thing that we

1151
00:59:26,550 --> 00:59:33,120
could do here is actually still do

1152
00:59:28,650 --> 00:59:37,550
32-bit and just reconstruct and that

1153
00:59:33,119 --> 00:59:37,549
would allow us to do something like I

1154
00:59:51,769 --> 01:00:00,570
guess it's a pixel and see pixel so we

1155
00:59:55,860 --> 01:00:02,160
could save those two pretty easily so

1156
01:00:00,570 --> 01:00:06,830
for example when we come in here you

1157
01:00:02,159 --> 01:00:10,980
know we would say a pixel and see pixel

1158
01:00:06,829 --> 01:00:13,170
are both gonna be equal to zero then

1159
01:00:10,980 --> 01:00:17,610
when we come in here you know we sort of

1160
01:00:13,170 --> 01:00:19,650
say that after we process one pixel

1161
01:00:17,610 --> 01:00:28,140
right so if we were to actually do it

1162
01:00:19,650 --> 01:00:29,099
this way then what we could say is oh

1163
01:00:28,139 --> 01:00:33,329
all right

1164
01:00:29,099 --> 01:00:39,389
so whatever we end up with at the in the

1165
01:00:33,329 --> 01:00:41,549
destination the a pixel is going to be

1166
01:00:39,389 --> 01:00:44,549
equal to that and the C pixel is going

1167
01:00:41,550 --> 01:00:46,260
to be whatever the a pixel was right so

1168
01:00:44,550 --> 01:00:48,840
it's pretty easy for us to store those

1169
01:00:46,260 --> 01:00:51,150
two and write tightly into the things so

1170
01:00:48,840 --> 01:00:52,620
maybe we should do it that way the

1171
01:00:51,150 --> 01:00:54,570
reason I didn't really want to do it

1172
01:00:52,619 --> 01:00:56,940
that way is because if you do it like

1173
01:00:54,570 --> 01:01:01,920
this then the problem that you end up

1174
01:00:56,940 --> 01:01:03,960
with is you have to now process each

1175
01:01:01,920 --> 01:01:11,039
channel separately which is kind of

1176
01:01:03,960 --> 01:01:14,210
annoying you know kind of kind of an

1177
01:01:11,039 --> 01:01:14,210
annoying process in and of itself

1178
01:01:14,429 --> 01:01:20,730
but let's suppose we want to do that

1179
01:01:18,179 --> 01:01:30,750
then what I could do is just say okay

1180
01:01:20,730 --> 01:01:49,650
you know give us the value so this is

1181
01:01:30,750 --> 01:01:52,739
the sub function so it's like trying to

1182
01:01:49,650 --> 01:02:00,690
think of how to write this here so if I

1183
01:01:52,739 --> 01:02:03,689
said well you know I can do let's just

1184
01:02:00,690 --> 01:02:05,519
do this so if I said hey PNG filter

1185
01:02:03,690 --> 01:02:07,318
here's the source pointer here is the

1186
01:02:05,519 --> 01:02:10,500
destination pointer that I want you to

1187
01:02:07,318 --> 01:02:13,159
write to I could just say look here's

1188
01:02:10,500 --> 01:02:16,440
the pixel index right

1189
01:02:13,159 --> 01:02:19,230
I'm the channel index 0 1 2 &amp; 3

1190
01:02:16,440 --> 01:02:22,139
and it'll just pick out which one it's

1191
01:02:19,230 --> 01:02:24,358
going to do so I can do that and that

1192
01:02:22,139 --> 01:02:27,389
would work and since we know this takes

1193
01:02:24,358 --> 01:02:29,190
the a pixel and the C pixel we can just

1194
01:02:27,389 --> 01:02:33,989
give them those two and write that

1195
01:02:29,190 --> 01:02:46,409
function right that seems reasonable to

1196
01:02:33,989 --> 01:02:48,088
me it doesn't really need to read from

1197
01:02:46,409 --> 01:02:55,670
the desk well sort of does this to end

1198
01:02:48,088 --> 01:02:55,670
into the desk maybe yeah let's do this

1199
01:02:58,219 --> 01:03:01,219
right

1200
01:03:09,480 --> 01:03:14,829
so if we just wrote each of those in

1201
01:03:12,010 --> 01:03:17,830
here again not sure how the compiler

1202
01:03:14,829 --> 01:03:22,509
will what the compiler will think about

1203
01:03:17,829 --> 01:03:24,389
that hard to say but again each of these

1204
01:03:22,510 --> 01:03:32,710
then becomes pretty easy for it to

1205
01:03:24,389 --> 01:03:35,409
access because now it just doesn't

1206
01:03:32,710 --> 01:03:45,880
bracket on each of them and it would

1207
01:03:35,409 --> 01:03:47,619
just work that seems like it'd be pretty

1208
01:03:45,880 --> 01:03:50,890
I'm just going for easy to write here

1209
01:03:47,619 --> 01:03:53,679
not efficient so we'll leave it at that

1210
01:03:50,889 --> 01:04:00,670
so and I think that allows us to just

1211
01:03:53,679 --> 01:04:02,919
keep going and I think that's about

1212
01:04:00,670 --> 01:04:05,440
right for the loop so then what we would

1213
01:04:02,920 --> 01:04:13,869
need to do is we need the same thing

1214
01:04:05,440 --> 01:04:16,289
here for each of these oops know what

1215
01:04:13,869 --> 01:04:16,289
happened there

1216
01:04:21,039 --> 01:04:26,139
soory each of these we need to base the

1217
01:04:23,260 --> 01:04:28,870
same thing case one was the neighbor

1218
01:04:26,139 --> 01:04:33,099
pixel two is the upward pixel so that

1219
01:04:28,869 --> 01:04:35,849
one doesn't need to track these two so

1220
01:04:33,099 --> 01:04:41,199
all it's doing is it's just using

1221
01:04:35,849 --> 01:04:45,599
basically a top trimming pointer and

1222
01:04:41,199 --> 01:04:45,599
that's gonna be the Prevot or prior row

1223
01:04:45,900 --> 01:04:52,869
and so when those go through that's

1224
01:04:49,960 --> 01:04:57,990
again that's gonna do a plus equals four

1225
01:04:52,869 --> 01:04:57,989
here so that prior row is the thing

1226
01:04:58,110 --> 01:05:13,480
that's going to be placed in here so you

1227
01:05:09,670 --> 01:05:15,430
can see okay we've got filter two and

1228
01:05:13,480 --> 01:05:18,130
that gets the input that it needs

1229
01:05:15,429 --> 01:05:25,119
because it's only using a I'm sorry only

1230
01:05:18,130 --> 01:05:30,099
using B as it goes there so then we have

1231
01:05:25,119 --> 01:05:33,159
the average that takes both so okay so

1232
01:05:30,099 --> 01:05:38,339
that's the average of the top pixel and

1233
01:05:33,159 --> 01:05:38,339
the left pixel right

1234
01:05:41,309 --> 01:05:44,820
oh it's ok so I was reading this study

1235
01:05:43,170 --> 01:05:47,490
wrong never mind

1236
01:05:44,820 --> 01:05:50,039
so this makes a little more sense that

1237
01:05:47,489 --> 01:05:52,949
you use the pixel to to to the left

1238
01:05:50,039 --> 01:05:56,489
because it's doing a predictor based on

1239
01:05:52,949 --> 01:05:58,259
the gradient of those two that makes

1240
01:05:56,489 --> 01:06:00,599
more sense so never mind I take it back

1241
01:05:58,260 --> 01:06:02,040
that's not just for differing that's a

1242
01:06:00,599 --> 01:06:03,210
reasonable predictor that's basically

1243
01:06:02,039 --> 01:06:04,829
saying hey look I'll look at the two

1244
01:06:03,210 --> 01:06:06,389
previous pixels let me see what their

1245
01:06:04,829 --> 01:06:07,829
difference is we're gonna use some

1246
01:06:06,389 --> 01:06:09,599
predictor to figure out based on that

1247
01:06:07,829 --> 01:06:12,449
what we think this one will be and we

1248
01:06:09,599 --> 01:06:15,509
also look at the top one you know so ok

1249
01:06:12,449 --> 01:06:19,649
never mind never mind take it back so

1250
01:06:15,510 --> 01:06:21,350
that that is a reasonable predictor it's

1251
01:06:19,650 --> 01:06:24,809
probably not great but it's reasonable

1252
01:06:21,349 --> 01:06:31,710
so okay so case one case two are handled

1253
01:06:24,809 --> 01:06:37,349
case three is not using C so that's just

1254
01:06:31,710 --> 01:06:41,789
this one here C pixel goes away eight

1255
01:06:37,349 --> 01:06:55,710
pixel remains so in here we've got prior

1256
01:06:41,789 --> 01:06:58,139
row so that's good and then finally we

1257
01:06:55,710 --> 01:07:01,260
have the path predictor case and that

1258
01:06:58,139 --> 01:07:05,969
one actually needs everything so that

1259
01:07:01,260 --> 01:07:07,920
one needs prior row and in both these

1260
01:07:05,969 --> 01:07:12,809
cases prior row has to be advanced as

1261
01:07:07,920 --> 01:07:23,670
well and we need to track 2mp pixels so

1262
01:07:12,809 --> 01:07:26,929
yeah oops that's not right I guess I

1263
01:07:23,670 --> 01:07:26,930
should just call that B pixel

1264
01:07:31,079 --> 01:07:50,349
there we go so yeah what we want to do

1265
01:07:37,900 --> 01:07:52,480
here is make sure that's all kosher can

1266
01:07:50,349 --> 01:07:58,180
I get this out from behind my head that

1267
01:07:52,480 --> 01:08:00,670
would be helpful so what we want to do

1268
01:07:58,179 --> 01:08:05,639
in this case is we need to pass all of

1269
01:08:00,670 --> 01:08:05,639
them to the you know this for one here

1270
01:08:08,309 --> 01:08:13,530
and then we have to actually write these

1271
01:08:18,000 --> 01:08:22,948
so I guess these are going to return a

1272
01:08:20,439 --> 01:08:31,858
u8 that's the result of the filter

1273
01:08:22,948 --> 01:08:46,659
they're going to take an X and a a b a c

1274
01:08:31,859 --> 01:08:48,759
and a channel and yeah some of them have

1275
01:08:46,659 --> 01:08:58,689
some of these some of them don't

1276
01:08:48,759 --> 01:09:02,198
so 1 2 3 4 there I believe what we said

1277
01:08:58,689 --> 01:09:09,689
was that this one has only an A this one

1278
01:09:02,198 --> 01:09:16,298
has only a B this one has an A and a B

1279
01:09:09,689 --> 01:09:19,178
and this one has all three okay so if we

1280
01:09:16,298 --> 01:09:22,229
look at what's happening here

1281
01:09:19,179 --> 01:09:22,230
if we take

1282
01:09:26,060 --> 01:09:42,989
if we take case one it looks like we're

1283
01:09:33,060 --> 01:09:45,810
just adding them together now I don't

1284
01:09:42,988 --> 01:09:47,698
know again

1285
01:09:45,810 --> 01:09:49,500
I don't want it to do integral promotion

1286
01:09:47,698 --> 01:09:53,519
here I really want it to do

1287
01:09:49,500 --> 01:09:55,439
8-bit addition short of using Symbian

1288
01:09:53,520 --> 01:09:56,639
but before we can actually manhandle

1289
01:09:55,439 --> 01:09:59,250
that a little bit more I'm not sure how

1290
01:09:56,639 --> 01:10:03,779
to convince it otherwise so I'm hoping

1291
01:09:59,250 --> 01:10:09,988
that will help here's the reconstruction

1292
01:10:03,779 --> 01:10:12,859
4b same deal really these two are the

1293
01:10:09,988 --> 01:10:15,718
same so we could just call it P&amp;G filter

1294
01:10:12,859 --> 01:10:17,429
one and call it in both cases because

1295
01:10:15,719 --> 01:10:26,849
it's just you're just passing a

1296
01:10:17,429 --> 01:10:28,050
different thing you could just say right

1297
01:10:26,849 --> 01:10:31,159
because there's no there's no difference

1298
01:10:28,050 --> 01:10:31,159
between those two things

1299
01:10:36,649 --> 01:10:39,649
yeah

1300
01:10:50,069 --> 01:10:57,099
right so you've got a pixel here I don't

1301
01:10:54,550 --> 01:11:00,220
know why I define those up here there's

1302
01:10:57,100 --> 01:11:10,960
no point to that at all so let's not do

1303
01:11:00,220 --> 01:11:13,270
that okay so we got one this will be

1304
01:11:10,960 --> 01:11:15,189
calling one and two because they're both

1305
01:11:13,270 --> 01:11:21,730
the same this will be calling one and

1306
01:11:15,189 --> 01:11:25,449
two as well so we have a pixel in one

1307
01:11:21,729 --> 01:11:29,129
case B pixel in another and we remember

1308
01:11:25,449 --> 01:11:32,859
our destination version here as we go

1309
01:11:29,130 --> 01:11:34,270
that's all fine this is the first one

1310
01:11:32,859 --> 01:11:37,509
that actually is different so these two

1311
01:11:34,270 --> 01:11:45,280
have their own calls and they're on well

1312
01:11:37,510 --> 01:11:48,280
they're on everything really yeah so

1313
01:11:45,279 --> 01:11:50,559
current locals dest and rio equals

1314
01:11:48,279 --> 01:11:53,349
current row so that's all what we want

1315
01:11:50,560 --> 01:11:55,120
and that all looks pretty good okay so

1316
01:11:53,350 --> 01:12:00,360
getting back to here

1317
01:11:55,119 --> 01:12:03,819
PNG filter 3 that's pretty basic as well

1318
01:12:00,359 --> 01:12:07,000
it's just taking the average right so

1319
01:12:03,819 --> 01:12:11,170
you want to add a and B together divide

1320
01:12:07,000 --> 01:12:14,680
by 2 and take the floor of that now I'm

1321
01:12:11,170 --> 01:12:28,680
assuming that the that wants to be done

1322
01:12:14,680 --> 01:12:28,680
non wrapped don't know if that makes it

1323
01:12:37,289 --> 01:12:42,319
I well it definitely makes a difference

1324
01:12:39,720 --> 01:12:42,320
right

1325
01:12:56,380 --> 01:13:03,189
so the reason that I'm a little

1326
01:12:58,429 --> 01:13:06,559
concerned about this is because if the

1327
01:13:03,189 --> 01:13:12,789
averaging function if this line were to

1328
01:13:06,559 --> 01:13:16,729
be taken taken literally then a plus B

1329
01:13:12,788 --> 01:13:19,038
divided by 2 would only actually produce

1330
01:13:16,729 --> 01:13:22,789
the average of the bytes for values less

1331
01:13:19,038 --> 01:13:25,458
than 128 right because for two values

1332
01:13:22,788 --> 01:13:28,578
greater than 128 or where their sum is

1333
01:13:25,458 --> 01:13:30,800
greater than 25 I should say it will

1334
01:13:28,578 --> 01:13:33,018
wrap and then the divide will produce a

1335
01:13:30,800 --> 01:13:35,900
much lower value than it should have

1336
01:13:33,019 --> 01:13:43,400
so it seems to me like you would want to

1337
01:13:35,899 --> 01:13:43,819
do the result in that just doesn't make

1338
01:13:43,399 --> 01:13:45,828
sense

1339
01:13:43,819 --> 01:13:54,558
I can't imagine you actually wanted to

1340
01:13:45,828 --> 01:13:57,168
do wrapped 256 there ah here we go

1341
01:13:54,559 --> 01:13:59,329
the sum a rigged a plus or maybe shall

1342
01:13:57,168 --> 01:14:02,658
be performed without overflow using at

1343
01:13:59,328 --> 01:14:06,469
least nine bit arithmetic that's ah I'm

1344
01:14:02,658 --> 01:14:08,498
like that can't be true I like how you

1345
01:14:06,469 --> 01:14:17,469
literally said that and then immediately

1346
01:14:08,498 --> 01:14:28,448
contradicted it it's like okay yeah so

1347
01:14:17,469 --> 01:14:28,448
so what that means is this actually is X

1348
01:14:29,288 --> 01:14:32,288
well

1349
01:14:33,369 --> 01:14:47,479
so it's X plus the average yeah so this

1350
01:14:39,739 --> 01:14:56,239
is actually X channel as a UA plus the

1351
01:14:47,479 --> 01:15:01,189
u8 version of the non u8 right average

1352
01:14:56,239 --> 01:15:04,969
of these two so that we do want to be

1353
01:15:01,189 --> 01:15:06,199
done at the higher bit precision so we

1354
01:15:04,970 --> 01:15:11,270
do the average at the higher bit

1355
01:15:06,199 --> 01:15:16,429
precision then I want to divide by 2 so

1356
01:15:11,270 --> 01:15:18,560
that will floor because integer division

1357
01:15:16,430 --> 01:15:20,360
will floor automatically so we don't

1358
01:15:18,560 --> 01:15:23,690
have to do anything careful to make the

1359
01:15:20,359 --> 01:15:26,630
floor happen I don't believe so then we

1360
01:15:23,689 --> 01:15:31,579
can go from there let's just make sure

1361
01:15:26,630 --> 01:15:39,260
this let me do this I want to make this

1362
01:15:31,579 --> 01:15:48,019
a little bit clearer so there's our

1363
01:15:39,260 --> 01:15:49,670
average that we've computed yeah and now

1364
01:15:48,020 --> 01:16:00,050
I'm going to go ahead and cast that

1365
01:15:49,670 --> 01:16:02,230
average to a u8 for adding and then off

1366
01:16:00,050 --> 01:16:02,230
we go

1367
01:16:04,809 --> 01:16:10,090
okay so now we get down to this path

1368
01:16:07,840 --> 01:16:13,469
predictor PF predictor I don't know what

1369
01:16:10,090 --> 01:16:16,150
you want to call that we sort of have a

1370
01:16:13,469 --> 01:16:20,469
lengthy set of stuff that wants us to do

1371
01:16:16,149 --> 01:16:24,868
here so we need to be able to take the

1372
01:16:20,469 --> 01:16:28,420
absolute value of these differences here

1373
01:16:24,868 --> 01:16:35,920
so yeah I don't know how we want to do

1374
01:16:28,420 --> 01:16:39,880
that cleanly in this case I might just

1375
01:16:35,920 --> 01:16:42,819
actually use and if just to make sure

1376
01:16:39,880 --> 01:16:44,260
we're doing it 100% correctly here but

1377
01:16:42,819 --> 01:16:48,488
anyway here's what we want to actually

1378
01:16:44,260 --> 01:16:52,929
have from the spec why am I not able to

1379
01:16:48,488 --> 01:16:53,549
poop I guess that's not something I can

1380
01:16:52,929 --> 01:16:58,000
pace

1381
01:16:53,550 --> 01:17:08,980
alright so P equals a plus B minus C so

1382
01:16:58,000 --> 01:17:10,658
all right the algorithm uses this

1383
01:17:08,979 --> 01:17:12,459
experience the adaptational took you to

1384
01:17:10,658 --> 01:17:13,868
Allen path the path which put a

1385
01:17:12,460 --> 01:17:18,460
difference to go below the last election

1386
01:17:13,868 --> 01:17:21,238
location ABC okay so again taking them

1387
01:17:18,460 --> 01:17:26,439
at their word we need this to be wrapped

1388
01:17:21,238 --> 01:17:28,149
Oh nope without a so they're like hey

1389
01:17:26,439 --> 01:17:31,538
unsigned errific modular true this is

1390
01:17:28,149 --> 01:17:34,569
used parentheses only here in here so

1391
01:17:31,538 --> 01:17:37,779
half of the things don't obey that but

1392
01:17:34,569 --> 01:17:39,849
off we go so I guess the there well I

1393
01:17:37,779 --> 01:17:42,309
guess it's this part right here so this

1394
01:17:39,849 --> 01:17:44,529
subtraction or rather this addition is

1395
01:17:42,309 --> 01:17:47,889
the only part they should have just been

1396
01:17:44,529 --> 01:17:50,439
this plus right is the part all the rest

1397
01:17:47,889 --> 01:17:55,659
of this stuff is always not that so

1398
01:17:50,439 --> 01:17:57,609
happy birthday anyway okay so what we

1399
01:17:55,658 --> 01:18:02,348
want to do here is we want to actually

1400
01:17:57,609 --> 01:18:04,538
do at the end one of these again so we

1401
01:18:02,349 --> 01:18:06,460
want like our path result here to be

1402
01:18:04,538 --> 01:18:10,118
something and then we're going to do

1403
01:18:06,460 --> 01:18:13,029
that add again in a in a raptor

1404
01:18:10,118 --> 01:18:16,268
arithmetic fashion but up until that

1405
01:18:13,029 --> 01:18:16,969
point we're going to be in la-la-land

1406
01:18:16,269 --> 01:18:19,760
so we're going to

1407
01:18:16,970 --> 01:18:20,659
go ahead and use utha choose for that so

1408
01:18:19,760 --> 01:18:22,430
the first thing we're going to do is

1409
01:18:20,659 --> 01:18:25,220
compute this p-value here that they're

1410
01:18:22,430 --> 01:18:28,730
asking for and that's the that's

1411
01:18:25,220 --> 01:18:31,579
basically like the basis color or the

1412
01:18:28,729 --> 01:18:33,169
basis channel level that we're going to

1413
01:18:31,579 --> 01:18:36,069
then difference to see what all the

1414
01:18:33,170 --> 01:18:41,690
differences are between the various

1415
01:18:36,069 --> 01:18:48,049
pixels and that basis value all right so

1416
01:18:41,689 --> 01:18:50,239
we've got PA PB and PC so here what our

1417
01:18:48,050 --> 01:18:53,329
problem is I mean what we could do is do

1418
01:18:50,239 --> 01:19:00,159
this signed right and we could say okay

1419
01:18:53,329 --> 01:19:00,159
we're gonna do this up conversion here

1420
01:19:00,579 --> 01:19:10,220
put it into s 32 s let's subtract each

1421
01:19:05,869 --> 01:19:13,369
of these and what I can do is just say

1422
01:19:10,220 --> 01:19:27,110
if PA is less than zero equals negative

1423
01:19:13,369 --> 01:19:28,849
PA so if we now we'll just do it

1424
01:19:27,109 --> 01:19:30,409
manually we could try to think of doing

1425
01:19:28,850 --> 01:19:32,150
something clever later on but I'm not

1426
01:19:30,409 --> 01:19:33,199
gonna bother right now so what we're

1427
01:19:32,149 --> 01:19:35,000
gonna do there is just we'll do the

1428
01:19:33,199 --> 01:19:36,170
subtraction we'll test to make sure

1429
01:19:35,000 --> 01:19:38,329
we're not negative for you're negative

1430
01:19:36,170 --> 01:19:40,640
we'll fix it right so now we know that

1431
01:19:38,329 --> 01:19:51,319
each of those is absolute values so then

1432
01:19:40,640 --> 01:19:53,030
we get two down here so we have a PR PR

1433
01:19:51,319 --> 01:19:55,340
looks like the that looks like the

1434
01:19:53,029 --> 01:19:57,109
payoff value so that that's what we want

1435
01:19:55,340 --> 01:19:59,539
to actually compute so basically we're

1436
01:19:57,109 --> 01:20:08,119
saying here is okay if PA is less than

1437
01:19:59,539 --> 01:20:16,239
equal to PB and PA is less than or equal

1438
01:20:08,119 --> 01:20:16,239
to PC then we set our path value here

1439
01:20:22,720 --> 01:20:31,730
- eh whatever

1440
01:20:29,210 --> 01:21:04,130
a was coming in so I said I should

1441
01:20:31,729 --> 01:21:06,079
actually get those values - all right so

1442
01:21:04,130 --> 01:21:08,869
read out each of those values I produce

1443
01:21:06,079 --> 01:21:10,729
my little dance here I check all of the

1444
01:21:08,869 --> 01:21:15,729
differences off the basis to get those

1445
01:21:10,729 --> 01:21:15,729
done then we go ahead and do this like

1446
01:21:22,630 --> 01:21:29,210
this little dance here so it's P be less

1447
01:21:25,250 --> 01:21:30,770
than or equal to P see there we go so we

1448
01:21:29,210 --> 01:21:32,180
grab all those values out then when

1449
01:21:30,770 --> 01:21:34,100
we're done with them we're basically so

1450
01:21:32,180 --> 01:21:36,530
we're based going to pick one of these

1451
01:21:34,100 --> 01:21:39,110
predict one of these things to use

1452
01:21:36,529 --> 01:21:41,479
either the top value the left value or

1453
01:21:39,109 --> 01:21:43,609
the to the value two to our left we're

1454
01:21:41,479 --> 01:21:45,289
gonna pick one of those to start with we

1455
01:21:43,609 --> 01:21:46,639
return that and then we're gonna encode

1456
01:21:45,289 --> 01:21:49,850
the difference off of that it's

1457
01:21:46,640 --> 01:21:53,869
basically what's doing right so yeah

1458
01:21:49,850 --> 01:22:01,160
that's really all that is P be listening

1459
01:21:53,869 --> 01:22:02,689
to PC otherwise we just use C okay and

1460
01:22:01,159 --> 01:22:06,639
you know if we want to encode this

1461
01:22:02,689 --> 01:22:06,639
exactly like it was written it'd be this

1462
01:22:08,619 --> 01:22:14,599
so I think that's all of the filters in

1463
01:22:12,140 --> 01:22:18,020
this case we have not actually created

1464
01:22:14,600 --> 01:22:22,520
that zero thing yes we are hiding a

1465
01:22:18,020 --> 01:22:26,110
previous value I don't know that I care

1466
01:22:22,520 --> 01:22:26,110
about that but here let's do this

1467
01:22:37,279 --> 01:22:42,750
so here's our reconstruction function

1468
01:22:39,869 --> 01:22:50,579
for the PNG filters I'll just copy this

1469
01:22:42,750 --> 01:22:52,140
whole thing out and put it up there that

1470
01:22:50,579 --> 01:22:54,510
way we don't have any variable shadowing

1471
01:22:52,140 --> 01:22:56,880
and stuff for common names like best or

1472
01:22:54,510 --> 01:23:02,880
whatever else we can remove that outer

1473
01:22:56,880 --> 01:23:06,210
layer of bracketing as well so and then

1474
01:23:02,880 --> 01:23:12,750
this thing can just send us the various

1475
01:23:06,210 --> 01:23:15,899
things we need so we need to know what

1476
01:23:12,750 --> 01:23:20,550
the decompressed pixel thing is we need

1477
01:23:15,899 --> 01:23:23,639
to know what the final pixel part is and

1478
01:23:20,550 --> 01:23:24,869
then we just need the 0 row we can talk

1479
01:23:23,640 --> 01:23:28,710
about that in a second

1480
01:23:24,869 --> 01:23:31,019
that's sort of a separate issue and

1481
01:23:28,710 --> 01:23:33,319
there's a couple things we could do

1482
01:23:31,020 --> 01:23:33,320
there

1483
01:23:41,309 --> 01:23:46,630
there's a couple of different ways we

1484
01:23:43,179 --> 01:23:48,219
could create that and in fact you know I

1485
01:23:46,630 --> 01:23:49,650
probably will do it that way so so I'm

1486
01:23:48,219 --> 01:23:52,328
gonna say that we just do those two

1487
01:23:49,649 --> 01:23:53,679
we'll talk about that in a second but

1488
01:23:52,328 --> 01:23:54,969
what I'm going to do now is when we come

1489
01:23:53,679 --> 01:23:56,618
down here after we're done with

1490
01:23:54,969 --> 01:23:58,960
everything where we were doing that

1491
01:23:56,618 --> 01:24:01,719
before so in here when we reach the

1492
01:23:58,960 --> 01:24:04,118
final block and you know after

1493
01:24:01,719 --> 01:24:06,448
everything's be been decompressed then

1494
01:24:04,118 --> 01:24:09,279
I'm going to do is I'm just going to

1495
01:24:06,448 --> 01:24:13,629
call that filter reconstruction function

1496
01:24:09,279 --> 01:24:15,069
and have it reconstruct so let's see

1497
01:24:13,630 --> 01:24:17,460
what else we need okay right we need the

1498
01:24:15,069 --> 01:24:17,460
width and the height

1499
01:24:24,300 --> 01:24:39,630
that's pointer service that's all right

1500
01:24:40,229 --> 01:24:44,379
so now the question is well what are we

1501
01:24:42,340 --> 01:24:46,659
gonna do about this here's what I'm

1502
01:24:44,380 --> 01:24:48,670
suggesting and I realize this is a

1503
01:24:46,658 --> 01:24:51,129
little janky but again just for ease of

1504
01:24:48,670 --> 01:24:53,849
implementation at first so let's just

1505
01:24:51,130 --> 01:24:59,980
make zero real point at a single zero

1506
01:24:53,849 --> 01:25:09,190
and then what we could do is have there

1507
01:24:59,979 --> 01:25:13,448
be prior row advance set to zero so

1508
01:25:09,189 --> 01:25:20,979
everywhere that we were doing a B pixel

1509
01:25:13,448 --> 01:25:27,158
here we'll just make that the prior

1510
01:25:20,979 --> 01:25:30,308
advance all right so what we'll do is

1511
01:25:27,158 --> 01:25:32,348
once we actually get a valid row to

1512
01:25:30,309 --> 01:25:34,480
start reading we'll set it to 4 up until

1513
01:25:32,349 --> 01:25:36,849
then we'll just leave it at 0 so it'll

1514
01:25:34,479 --> 01:25:42,959
just keep reading out of the same zero

1515
01:25:36,849 --> 01:25:42,960
right here and that'll be that

1516
01:25:44,309 --> 01:25:48,269
seems pretty straightforward right

1517
01:26:02,260 --> 01:26:07,150
so I think that's a reasonable sketch of

1518
01:26:05,770 --> 01:26:09,310
something that handles all of the

1519
01:26:07,149 --> 01:26:12,509
transforms don't quote me on that but I

1520
01:26:09,310 --> 01:26:15,700
think it's roughly right so you know

1521
01:26:12,510 --> 01:26:19,170
when we get down here we should be able

1522
01:26:15,699 --> 01:26:22,479
to now take a look at what that's doing

1523
01:26:19,170 --> 01:26:24,670
so let's just see if we're even in the

1524
01:26:22,479 --> 01:26:34,238
ballpark I'm gonna go ahead and take a

1525
01:26:24,670 --> 01:26:38,409
look at the final pixels see what that

1526
01:26:34,238 --> 01:26:41,069
value actually is can I get a kind of

1527
01:26:38,409 --> 01:26:49,569
watch window here let's let's do this

1528
01:26:41,069 --> 01:26:51,670
let's get memory down here there we go

1529
01:26:49,569 --> 01:26:55,359
so what I want to do is I want to grab

1530
01:26:51,670 --> 01:26:57,369
okay this is all care about so I'm gonna

1531
01:26:55,359 --> 01:26:59,170
grab final pixels and put it down here

1532
01:26:57,369 --> 01:27:02,738
this is what we're actually running into

1533
01:26:59,170 --> 01:27:05,199
we now are 32 columns that's our entire

1534
01:27:02,738 --> 01:27:08,189
image so I just want to see what we end

1535
01:27:05,199 --> 01:27:08,189
up with here right

1536
01:27:11,350 --> 01:27:16,480
and so that transforms working pretty

1537
01:27:13,510 --> 01:27:19,960
good so far this is now exactly what I

1538
01:27:16,479 --> 01:27:21,699
expect to see which is good so there you

1539
01:27:19,960 --> 01:27:25,689
go that's it that's exactly the row that

1540
01:27:21,699 --> 01:27:29,819
we thought we should get let's see what

1541
01:27:25,689 --> 01:27:29,819
happens now okay now we're into case two

1542
01:27:30,659 --> 01:27:36,149
again that is what I expected to see

1543
01:27:41,430 --> 01:27:46,230
so that's totally right what we can see

1544
01:27:43,770 --> 01:27:48,630
here as well is if we assume that we're

1545
01:27:46,229 --> 01:27:50,729
looking at this it looks like it's

1546
01:27:48,630 --> 01:27:52,800
top-down right this was the first thing

1547
01:27:50,729 --> 01:27:58,859
we saw so it's not bottom-up it's top

1548
01:27:52,800 --> 01:28:02,159
down for the PNG red is encoded as the

1549
01:27:58,859 --> 01:28:04,469
top or bottom looks like it's encoded

1550
01:28:02,159 --> 01:28:08,939
this way so it looks like it's our comes

1551
01:28:04,470 --> 01:28:20,400
first then GB and a RGB a looks like

1552
01:28:08,939 --> 01:28:26,629
what they've encoded right so the weight

1553
01:28:20,399 --> 01:28:26,629
no I lied it's alpha channel first right

1554
01:28:27,710 --> 01:28:34,409
no no this is gamma this is by twice my

1555
01:28:32,250 --> 01:28:36,149
brain wants to always look at these

1556
01:28:34,409 --> 01:28:37,889
things reversed because I'm so used to

1557
01:28:36,149 --> 01:28:45,299
looking at them in but so this is byte

1558
01:28:37,890 --> 01:28:47,610
wise RGB a RGB a yes RGB a RGB a RGB a

1559
01:28:45,300 --> 01:28:50,400
so it starts with our ends with a that's

1560
01:28:47,609 --> 01:28:54,029
all we needed to know and off we go

1561
01:28:50,399 --> 01:29:03,799
so do we ever hit this path predictor

1562
01:28:54,029 --> 01:29:07,619
case or this averaging case I don't know

1563
01:29:03,800 --> 01:29:10,680
let's find out No

1564
01:29:07,619 --> 01:29:13,050
so so we don't know those could be

1565
01:29:10,680 --> 01:29:17,159
totally wrong right now it looks like

1566
01:29:13,050 --> 01:29:19,170
our basic predictors we're fine because

1567
01:29:17,159 --> 01:29:24,930
we look at this image this looks this

1568
01:29:19,170 --> 01:29:27,949
looks right so yeah I think we've got

1569
01:29:24,930 --> 01:29:33,060
all of those working ok but but these

1570
01:29:27,949 --> 01:29:37,529
you know these could just be wrong so we

1571
01:29:33,060 --> 01:29:40,050
should try and get those tested somehow

1572
01:29:37,529 --> 01:29:43,069
as well but at least we got the basics

1573
01:29:40,050 --> 01:29:43,070
in here so let's see

1574
01:29:54,819 --> 01:29:59,090
so maybe what I'll do is I'll force a

1575
01:29:57,109 --> 01:30:03,399
crash the first time it goes in there

1576
01:29:59,090 --> 01:30:09,230
that way like when we find one will know

1577
01:30:03,399 --> 01:30:12,259
and we can just you know verify that

1578
01:30:09,229 --> 01:30:16,339
it's working at all because they might

1579
01:30:12,260 --> 01:30:18,619
just be buggy we don't know okay so hey

1580
01:30:16,340 --> 01:30:20,840
guess what we correctly encode decoded a

1581
01:30:18,619 --> 01:30:22,640
PNG image that's the good news the bad

1582
01:30:20,840 --> 01:30:24,440
news is it's only the very simple kind

1583
01:30:22,640 --> 01:30:25,490
so we still have a lot of work to do

1584
01:30:24,439 --> 01:30:26,960
because now we've got to get to go get

1585
01:30:25,489 --> 01:30:29,359
the Huffman stuff working but at least

1586
01:30:26,960 --> 01:30:31,609
now we know the filter part and we've

1587
01:30:29,359 --> 01:30:33,409
got code for the filter part that code

1588
01:30:31,609 --> 01:30:37,670
looks like it'll be pretty easy to debug

1589
01:30:33,409 --> 01:30:39,949
I suspect now I say I suspect because

1590
01:30:37,670 --> 01:30:42,829
well there was a bunch of stuff about do

1591
01:30:39,949 --> 01:30:45,199
you want wrapping or not and you know

1592
01:30:42,829 --> 01:30:47,119
maybe we got something wrong where we

1593
01:30:45,199 --> 01:30:49,119
didn't quite do the wrapping correctly

1594
01:30:47,119 --> 01:30:51,769
so it's still not a hundred percent sure

1595
01:30:49,119 --> 01:30:53,659
that we are doing it correctly there

1596
01:30:51,770 --> 01:30:58,340
could be bugs in there we don't really

1597
01:30:53,659 --> 01:31:01,279
know let's go ahead and now try the

1598
01:30:58,340 --> 01:31:02,690
compressed version of this image I'll

1599
01:31:01,279 --> 01:31:07,340
leave that up actually gives me to refer

1600
01:31:02,689 --> 01:31:09,859
to it and try to get that working and

1601
01:31:07,340 --> 01:31:11,420
that'll be probably we won't have that

1602
01:31:09,859 --> 01:31:12,619
working by the end of the stream because

1603
01:31:11,420 --> 01:31:16,730
we have that working we would be

1604
01:31:12,619 --> 01:31:19,930
basically done and I suspect it's gonna

1605
01:31:16,729 --> 01:31:25,759
be at least one more episode before that

1606
01:31:19,930 --> 01:31:28,070
okay so let's start down that path and

1607
01:31:25,760 --> 01:31:30,110
let's see where we're getting I don't

1608
01:31:28,069 --> 01:31:39,979
really remember exactly where we're at

1609
01:31:30,109 --> 01:31:42,170
here in terms of what we have for the

1610
01:31:39,979 --> 01:31:45,429
Huffman stuff so I don't remember really

1611
01:31:42,170 --> 01:31:48,260
how close we were to decoding anything

1612
01:31:45,430 --> 01:31:49,909
let's see if we get yeah so we we

1613
01:31:48,260 --> 01:31:54,050
managed to get this to code it properly

1614
01:31:49,909 --> 01:31:56,300
as I suspected that part there we don't

1615
01:31:54,050 --> 01:31:57,739
really know if it's generating this part

1616
01:31:56,300 --> 01:32:00,920
here we have no idea where

1617
01:31:57,739 --> 01:32:03,260
doing either but let's start to look at

1618
01:32:00,920 --> 01:32:09,279
destination pixels and see what we

1619
01:32:03,260 --> 01:32:09,280
actually are you know putting out oops

1620
01:32:10,630 --> 01:32:16,779
meant decompress fix can you just type

1621
01:32:18,430 --> 01:32:23,570
does that work no it doesn't so it won't

1622
01:32:21,800 --> 01:32:24,920
remember what we put in there

1623
01:32:23,569 --> 01:32:28,420
unfortunately

1624
01:32:24,920 --> 01:32:30,980
always converts it to an address first

1625
01:32:28,420 --> 01:32:35,300
visual studio being super helpful as

1626
01:32:30,979 --> 01:32:38,569
always by like not doing what I want

1627
01:32:35,300 --> 01:32:40,989
okay wait now I got it oh there we go

1628
01:32:38,569 --> 01:32:47,119
okay so I gotta click that button I

1629
01:32:40,989 --> 01:32:49,250
guess I don't know anyway so let's see

1630
01:32:47,119 --> 01:32:52,569
what we've got here there's an o1 that

1631
01:32:49,250 --> 01:32:52,569
is what we expected to see

1632
01:32:53,380 --> 01:33:00,949
still outputting stuff here so this is

1633
01:32:58,010 --> 01:33:05,480
the simple case and the simple case you

1634
01:33:00,949 --> 01:33:19,010
know unsurprisingly appears to be

1635
01:33:05,479 --> 01:33:22,759
working here so that encoded a big old

1636
01:33:19,010 --> 01:33:26,690
run of zeros which is also probably

1637
01:33:22,760 --> 01:33:28,610
correct how many of these we got let's

1638
01:33:26,689 --> 01:33:31,269
just slide this over so we can see where

1639
01:33:28,609 --> 01:33:31,269
the end is

1640
01:33:39,750 --> 01:33:54,000
that looks writing ly correct so we did

1641
01:33:46,210 --> 01:34:03,819
Huffman to code one row properly I think

1642
01:33:54,000 --> 01:34:06,930
that looks like the right answer I'm not

1643
01:34:03,819 --> 01:34:06,929
sure about that

1644
01:34:15,289 --> 01:34:20,000
no that's correct so if you think about

1645
01:34:17,479 --> 01:34:22,399
what's gonna happen there it's using the

1646
01:34:20,000 --> 01:34:24,920
leftward predictor it's gonna load this

1647
01:34:22,399 --> 01:34:27,170
into the color channel it's gonna add

1648
01:34:24,920 --> 01:34:30,470
one to the red channel which is gonna

1649
01:34:27,170 --> 01:34:32,600
cause it to overflow from two to five to

1650
01:34:30,470 --> 01:34:34,699
zero which is the correct red channel

1651
01:34:32,600 --> 01:34:37,490
and then it's just going to be wrapped

1652
01:34:34,699 --> 01:34:40,300
the entire way alpha channel F F F F F F

1653
01:34:37,489 --> 01:34:51,289
F F F F F F so so this is the right row

1654
01:34:40,300 --> 01:34:54,010
like we got the right row so now it

1655
01:34:51,289 --> 01:34:54,010
looks wrong

1656
01:35:16,969 --> 01:35:24,800
Oh oh no it doesn't no it doesn't it

1657
01:35:19,099 --> 01:35:26,779
doesn't you may be okay here we're all

1658
01:35:24,800 --> 01:35:28,940
right I'm like it's one off but no we

1659
01:35:26,779 --> 01:35:30,018
had changed this 232 before because we

1660
01:35:28,939 --> 01:35:35,058
were looking at just the decompressed

1661
01:35:30,019 --> 01:35:36,110
image okay so now let's see how we do

1662
01:35:35,059 --> 01:35:39,019
here

1663
01:35:36,109 --> 01:35:40,689
what's our Len value here 24 that seems

1664
01:35:39,019 --> 01:35:56,329
reasonable too

1665
01:35:40,689 --> 01:36:04,399
off we go that'll looks good yep that's

1666
01:35:56,328 --> 01:36:08,719
right so you know I'll be honest this

1667
01:36:04,399 --> 01:36:11,408
looks really good so yeah I mean so far

1668
01:36:08,719 --> 01:36:15,399
we seem to be in pretty good shape for

1669
01:36:11,408 --> 01:36:15,399
these rows here

1670
01:36:30,569 --> 01:36:35,380
so you know that I mean that seems to

1671
01:36:33,189 --> 01:36:37,179
have decoded the image properly to be

1672
01:36:35,380 --> 01:36:42,909
honest let's take a look at what happens

1673
01:36:37,180 --> 01:36:47,289
when we when we reconstruct it just to

1674
01:36:42,909 --> 01:36:52,119
see you know what we end up with here so

1675
01:36:47,289 --> 01:36:57,149
if we feed that image into here and can

1676
01:36:52,119 --> 01:36:57,149
we get another memory window

1677
01:37:08,420 --> 01:37:12,949
you can have exactly four memory windows

1678
01:37:11,210 --> 01:37:15,109
ladies and gentlemen because everyone

1679
01:37:12,948 --> 01:37:16,988
knows there's not more than four places

1680
01:37:15,109 --> 01:37:22,009
in memory that anyone might want to see

1681
01:37:16,988 --> 01:37:25,009
all right so let's go ahead and get

1682
01:37:22,010 --> 01:37:29,230
final pixels in here okay got to put

1683
01:37:25,010 --> 01:37:29,230
that little thing in their final pixel

1684
01:37:30,159 --> 01:37:36,170
okay so let's see what final pixels has

1685
01:37:33,590 --> 01:37:41,860
to say about this this one should be

1686
01:37:36,170 --> 01:37:46,550
thirty-two wide I mean that looks right

1687
01:37:41,859 --> 01:37:49,579
that looks like the image so okay so now

1688
01:37:46,550 --> 01:37:53,630
we have decompressed both we have

1689
01:37:49,579 --> 01:37:57,738
decompressed a Huffman stream and a non

1690
01:37:53,630 --> 01:38:01,219
Huffman stream paying both correctly so

1691
01:37:57,738 --> 01:38:02,539
that suggests to me that our error

1692
01:38:01,219 --> 01:38:04,390
because if I remember correctly

1693
01:38:02,539 --> 01:38:10,969
decompressing the other image though we

1694
01:38:04,390 --> 01:38:19,760
failed that suggests to me that we have

1695
01:38:10,969 --> 01:38:22,909
a subtle bug not a you know not not like

1696
01:38:19,760 --> 01:38:24,770
a really egregious bug but like one that

1697
01:38:22,909 --> 01:38:27,229
you know only happens when the numbers

1698
01:38:24,770 --> 01:38:32,810
are right or in this case or whatever

1699
01:38:27,229 --> 01:38:33,439
right so that's that's good that's

1700
01:38:32,810 --> 01:38:35,570
reassuring

1701
01:38:33,439 --> 01:38:36,649
where is the thing you're okay so

1702
01:38:35,569 --> 01:38:39,019
there's a couple of things to be happen

1703
01:38:36,649 --> 01:38:45,229
here first of all one thing I would note

1704
01:38:39,020 --> 01:38:50,900
is that this is in a PNG that has an ID

1705
01:38:45,229 --> 01:38:55,159
at chunk that contains the entire thing

1706
01:38:50,899 --> 01:38:56,869
and so one thing that is different about

1707
01:38:55,159 --> 01:38:59,469
the other image that we're having

1708
01:38:56,869 --> 01:39:02,479
trouble is it has multiple Ida chunks so

1709
01:38:59,469 --> 01:39:05,350
one thing we could look for is do we

1710
01:39:02,479 --> 01:39:08,209
have a problem

1711
01:39:05,350 --> 01:39:10,489
striding IDOT chunks so did the thing

1712
01:39:08,210 --> 01:39:13,460
when we under flow and I that chunk did

1713
01:39:10,488 --> 01:39:16,039
I screw that up you know is that

1714
01:39:13,460 --> 01:39:19,130
possibly where the bugs coming from so

1715
01:39:16,039 --> 01:39:21,439
one thing I do want to do is let's now

1716
01:39:19,130 --> 01:39:22,190
we got this image under control I want

1717
01:39:21,439 --> 01:39:23,689
to just like

1718
01:39:22,189 --> 01:39:27,529
dribble some stuff in here and make a

1719
01:39:23,689 --> 01:39:31,448
more complicated image and so and save

1720
01:39:27,529 --> 01:39:31,448
that office sort of another test

1721
01:39:34,689 --> 01:39:39,009
okay so

1722
01:39:56,710 --> 01:40:01,569
so I'm gonna save this out and you'll

1723
01:39:58,899 --> 01:40:04,659
notice I kept these pretty hard these

1724
01:40:01,569 --> 01:40:07,509
first ones just cuz I wanted some way of

1725
01:40:04,659 --> 01:40:09,550
still correlating some semblance of like

1726
01:40:07,510 --> 01:40:10,720
where the start should what the starch

1727
01:40:09,550 --> 01:40:13,980
should look like so I'm going to go

1728
01:40:10,720 --> 01:40:13,980
ahead and export that

1729
01:40:25,949 --> 01:40:31,800
I'm going to compress it at zero and

1730
01:40:29,819 --> 01:40:39,710
then I'm going to do the same thing we

1731
01:40:31,800 --> 01:40:39,710
did before compress it as normal at nine

1732
01:40:40,909 --> 01:40:45,229
and then I'm going to try loading those

1733
01:40:50,000 --> 01:40:55,319
just to see what happens and if we get a

1734
01:40:53,789 --> 01:41:02,399
little bit more of those like weird

1735
01:40:55,319 --> 01:41:07,799
results there okay so I mean one good

1736
01:41:02,399 --> 01:41:10,199
thing is that we we one positive aspect

1737
01:41:07,800 --> 01:41:12,690
there right is we've got the other

1738
01:41:10,199 --> 01:41:15,750
filter types here so that that pay F

1739
01:41:12,689 --> 01:41:19,079
filter is getting used so we can start

1740
01:41:15,750 --> 01:41:22,130
to debug that one now the other thing I

1741
01:41:19,079 --> 01:41:22,130
would say is

1742
01:41:31,890 --> 01:41:36,150
I don't know why this thing so this

1743
01:41:34,170 --> 01:41:38,130
doesn't this didn't actually do what we

1744
01:41:36,149 --> 01:41:40,909
asked it to do which was to always do

1745
01:41:38,130 --> 01:41:40,909
final pixels

1746
01:41:49,550 --> 01:41:56,940
so it looks like it starts off with some

1747
01:41:52,289 --> 01:41:58,500
rows that aren't that way okay

1748
01:41:56,939 --> 01:42:00,359
yeah it starts officers aren't that way

1749
01:41:58,500 --> 01:42:03,420
and then it hits right here there's the

1750
01:42:00,359 --> 01:42:12,089
four right so we've got one forward in

1751
01:42:03,420 --> 01:42:16,230
the middle of a lot of other stuff no I

1752
01:42:12,090 --> 01:42:20,039
just sorry I accidentally hit the mouse

1753
01:42:16,229 --> 01:42:22,649
wheel all right so I think that should

1754
01:42:20,039 --> 01:42:24,630
be good so let's go ahead and let's go

1755
01:42:22,649 --> 01:42:26,219
ahead and get this started them so that

1756
01:42:24,630 --> 01:42:28,460
seemed to decompress properly as well

1757
01:42:26,219 --> 01:42:31,890
I'm not sure what's up with that but

1758
01:42:28,460 --> 01:42:39,930
yeah accurately it was actually

1759
01:42:31,890 --> 01:42:42,000
decompressing but didn't error all right

1760
01:42:39,930 --> 01:42:43,170
so now let's take that assertion out and

1761
01:42:42,000 --> 01:42:44,488
actually step through that and see

1762
01:42:43,170 --> 01:42:47,149
whether we're getting what we think

1763
01:42:44,488 --> 01:42:47,149
we're getting here

1764
01:42:54,750 --> 01:42:59,908
okay so jumping in here's our a pixel

1765
01:42:58,319 --> 01:43:01,979
and C pixel they get initialized this

1766
01:42:59,908 --> 01:43:04,829
year our B pixels the prior of prior

1767
01:43:01,979 --> 01:43:11,339
right now is also 0

1768
01:43:04,829 --> 01:43:17,158
so we go through doing our 0 1 2 3 4 a B

1769
01:43:11,340 --> 01:43:20,069
and C pixels we then remember what the a

1770
01:43:17,158 --> 01:43:22,319
pixel was for next time C pixel we

1771
01:43:20,069 --> 01:43:26,698
remember what the desk we outputted was

1772
01:43:22,319 --> 01:43:30,420
for next times a pixel we should advance

1773
01:43:26,698 --> 01:43:36,119
by oh well no it won't be 0 because this

1774
01:43:30,420 --> 01:43:38,190
this actually is the prior row here so

1775
01:43:36,119 --> 01:43:41,488
the prior row just happened to be 0

1776
01:43:38,189 --> 01:43:47,189
there I guess that's actually true if

1777
01:43:41,488 --> 01:43:48,479
this was the prior row it actually had a

1778
01:43:47,189 --> 01:43:51,479
red channel 0 so that's okay

1779
01:43:48,479 --> 01:43:53,609
alright and we advance both of those and

1780
01:43:51,479 --> 01:43:55,289
we come back through so that does look

1781
01:43:53,609 --> 01:44:00,569
correct whether this is correct I don't

1782
01:43:55,289 --> 01:44:06,630
know we read a B and C here so that's

1783
01:44:00,569 --> 01:44:07,920
reading full red oh sorry no that's just

1784
01:44:06,630 --> 01:44:09,449
each of these okay never - that's

1785
01:44:07,920 --> 01:44:13,560
channel 0 that's reading the red channel

1786
01:44:09,448 --> 01:44:18,089
of a B and C so that's getting the pixel

1787
01:44:13,560 --> 01:44:22,440
to our left was full read the pixel

1788
01:44:18,090 --> 01:44:24,260
above us was not full read but that's

1789
01:44:22,439 --> 01:44:32,988
not true

1790
01:44:24,260 --> 01:44:32,989
was it don't I get

1791
01:44:39,050 --> 01:44:46,820
is that you okay it's so that is true

1792
01:44:44,050 --> 01:44:51,020
it's wrong pixel one right so that is

1793
01:44:46,819 --> 01:44:53,170
true picture before us was full red fair

1794
01:44:51,020 --> 01:44:53,170
enough

1795
01:44:54,800 --> 01:45:02,570
so we do P is three to five a is three

1796
01:44:58,039 --> 01:45:13,969
to five piece so it's that right a b c

1797
01:45:02,569 --> 01:45:21,500
get is so that's all correct assuming

1798
01:45:13,969 --> 01:45:31,698
that looks reasonable so what was the x

1799
01:45:21,500 --> 01:45:37,238
of that channel was one so this reduces

1800
01:45:31,698 --> 01:45:44,509
zero it does okay I mean that looks

1801
01:45:37,238 --> 01:45:50,658
reasonable to me we should go check what

1802
01:45:44,510 --> 01:45:51,889
the actual image values are to see but

1803
01:45:50,658 --> 01:45:54,138
like we're producing the correct value

1804
01:45:51,889 --> 01:46:03,500
for the Alpha Channel which seems pretty

1805
01:45:54,139 --> 01:46:05,029
unlikely if we were super wrong so we're

1806
01:46:03,500 --> 01:46:06,618
probably only subtle if we're wrong on

1807
01:46:05,029 --> 01:46:10,158
the pass filter we're not like way off

1808
01:46:06,618 --> 01:46:13,149
we're we're only a little off all right

1809
01:46:10,158 --> 01:46:13,149
so let's finish that up

1810
01:46:13,750 --> 01:46:30,350
yeah yep yep so I mean you know that

1811
01:46:19,609 --> 01:46:35,839
looks pretty good let's try this part

1812
01:46:30,350 --> 01:46:39,020
still work - yeah by no means don't

1813
01:46:35,840 --> 01:46:43,069
don't remember that setting okay so

1814
01:46:39,020 --> 01:46:46,550
let's see we got all that so yeah yes

1815
01:46:43,069 --> 01:46:49,369
this is looking pretty good so I guess

1816
01:46:46,550 --> 01:46:51,289
we're kind of now down to a question of

1817
01:46:49,369 --> 01:46:57,949
like what's going wrong with the more

1818
01:46:51,289 --> 01:47:00,409
complex ones and I don't know so let's

1819
01:46:57,949 --> 01:47:03,050
go ahead and start I guess we got to

1820
01:47:00,409 --> 01:47:07,489
start looking at the more complex case

1821
01:47:03,050 --> 01:47:13,460
and we're gonna have to we could try to

1822
01:47:07,489 --> 01:47:16,309
make a like a we could try to break that

1823
01:47:13,460 --> 01:47:21,739
case down into which parts are causing

1824
01:47:16,310 --> 01:47:24,260
us the problem - like we could try to

1825
01:47:21,739 --> 01:47:26,059
isolate parts of that image and actually

1826
01:47:24,260 --> 01:47:28,190
go like okay here's the thing that

1827
01:47:26,060 --> 01:47:31,610
appears to be causing us the problem you

1828
01:47:28,189 --> 01:47:32,899
know so that you know we can kind of see

1829
01:47:31,609 --> 01:47:35,299
how that goes but like we crash

1830
01:47:32,899 --> 01:47:38,299
somewhere right yeah so we like

1831
01:47:35,300 --> 01:47:42,050
overwrite where we're supposed to be or

1832
01:47:38,300 --> 01:47:43,579
something happens we see where we're at

1833
01:47:42,050 --> 01:47:53,119
I just I just remember this is where we

1834
01:47:43,579 --> 01:47:55,039
were at last time so yeah I don't know

1835
01:47:53,119 --> 01:47:56,659
if the source is bad the death is

1836
01:47:55,039 --> 01:48:01,060
definitely bad so we we definitely just

1837
01:47:56,659 --> 01:48:03,619
advanced too far with the length value

1838
01:48:01,060 --> 01:48:06,620
so we know that something's busted here

1839
01:48:03,619 --> 01:48:10,729
what I would like to know is I'm curious

1840
01:48:06,619 --> 01:48:15,489
about that I that chunk situation I want

1841
01:48:10,729 --> 01:48:20,839
to know whether or not the I that chunk

1842
01:48:15,489 --> 01:48:24,019
state is part of the problem here so I'm

1843
01:48:20,840 --> 01:48:26,360
gonna go ahead and say let's set a break

1844
01:48:24,020 --> 01:48:27,000
on when we under flow to see whether

1845
01:48:26,359 --> 01:48:31,349
that

1846
01:48:27,000 --> 01:48:32,670
screwing it up it's unlikely I think we

1847
01:48:31,350 --> 01:48:35,880
probably just have a bug in our Huffman

1848
01:48:32,670 --> 01:48:37,440
decoder but I just want to check the

1849
01:48:35,880 --> 01:48:39,449
obvious stuff before we go diving into

1850
01:48:37,439 --> 01:48:42,569
that because might as well check the

1851
01:48:39,449 --> 01:48:45,260
obvious before the hardest death so here

1852
01:48:42,569 --> 01:48:52,399
when we do a consume size we look to see

1853
01:48:45,260 --> 01:48:52,400
whether we have any more stuff to output

1854
01:48:57,260 --> 01:49:04,699
first of all we didn't hit the underflow

1855
01:48:59,819 --> 01:49:04,699
did we No

1856
01:49:14,149 --> 01:49:24,869
all right so first things first my hunch

1857
01:49:19,529 --> 01:49:28,920
is at least correct to one degree which

1858
01:49:24,869 --> 01:49:31,529
is that this is the bug that we know

1859
01:49:28,920 --> 01:49:34,500
about like the the tell-tale the crash

1860
01:49:31,529 --> 01:49:38,809
right the obvious symptom that there's a

1861
01:49:34,500 --> 01:49:44,039
problem that is coming after the IDA

1862
01:49:38,810 --> 01:49:48,690
chunk changes over so it's not obviously

1863
01:49:44,039 --> 01:49:50,850
the case that my sort of thing I wanted

1864
01:49:48,689 --> 01:49:54,629
to check is safe it could be that we

1865
01:49:50,850 --> 01:49:59,570
actually have that problem so let's take

1866
01:49:54,630 --> 01:49:59,569
a look at what that implies so that this

1867
01:50:02,510 --> 01:50:09,659
here's the file thing we're reading from

1868
01:50:06,319 --> 01:50:13,769
we have drained out our contents

1869
01:50:09,659 --> 01:50:15,920
entirely here so we have another one

1870
01:50:13,770 --> 01:50:19,770
that's 8192

1871
01:50:15,920 --> 01:50:22,109
chunk and it's got a pointer here to the

1872
01:50:19,770 --> 01:50:24,510
contents and then that's got an X

1873
01:50:22,109 --> 01:50:28,409
pointer to one thing I don't know

1874
01:50:24,510 --> 01:50:32,119
so is file first I mean I'm assuming

1875
01:50:28,409 --> 01:50:36,469
that this hasn't already been consumed

1876
01:50:32,119 --> 01:50:36,469
but I don't really know if that's true I

1877
01:50:38,029 --> 01:50:41,130
guess what I'm asking is are we

1878
01:50:39,930 --> 01:50:45,590
accidentally reading the same chunk

1879
01:50:41,130 --> 01:50:45,590
twice so how does that work right now

1880
01:50:56,458 --> 01:51:10,688
all right so every time oh so maybe this

1881
01:51:06,248 --> 01:51:12,819
is the first one though yeah yeah yeah

1882
01:51:10,689 --> 01:51:15,280
so oh so maybe we haven't changed either

1883
01:51:12,819 --> 01:51:18,429
chunks yet maybe I'm just wrong okay

1884
01:51:15,279 --> 01:51:21,340
yeah yeah I'm just being stupid this is

1885
01:51:18,429 --> 01:51:28,689
just the first one so it pulls the first

1886
01:51:21,340 --> 01:51:31,529
one and this now we expect this one 2074

1887
01:51:28,689 --> 01:51:35,860
that one should move up to be first

1888
01:51:31,529 --> 01:51:38,198
right so that one goes ahead it gets the

1889
01:51:35,859 --> 01:51:40,929
content size out it should get this

1890
01:51:38,198 --> 01:51:44,158
contents pointer out and it does and now

1891
01:51:40,929 --> 01:51:48,939
it should move this up to be this one

1892
01:51:44,158 --> 01:51:51,728
540 right yeah and it does okay

1893
01:51:48,939 --> 01:51:54,249
so nevermind everything I just said it

1894
01:51:51,729 --> 01:51:57,760
was incorrect let's run again and see

1895
01:51:54,248 --> 01:52:00,158
what happens okay so no no no we have

1896
01:51:57,760 --> 01:52:00,820
proven that it's not that we do not

1897
01:52:00,158 --> 01:52:05,679
change

1898
01:52:00,819 --> 01:52:07,448
IDOT chunks before we hit the bug so my

1899
01:52:05,679 --> 01:52:08,889
previous suggestion that it was unlikely

1900
01:52:07,448 --> 01:52:12,069
that that was the problem

1901
01:52:08,889 --> 01:52:13,840
proved to be true and we know there's a

1902
01:52:12,069 --> 01:52:18,609
bug somewhere in the Huffman decoding

1903
01:52:13,840 --> 01:52:23,199
that you just don't have happen when you

1904
01:52:18,609 --> 01:52:24,878
don't have a big enough image right or a

1905
01:52:23,198 --> 01:52:27,339
certain sensitive values or whatever

1906
01:52:24,878 --> 01:52:29,590
right now this makes sense because like

1907
01:52:27,340 --> 01:52:31,029
if you think about how this thing was

1908
01:52:29,590 --> 01:52:34,208
set up if you remember all the stuff

1909
01:52:31,029 --> 01:52:35,469
that we've been through so far to talk

1910
01:52:34,208 --> 01:52:37,238
about like things like the extra bits

1911
01:52:35,469 --> 01:52:40,899
and a lot of stuff if you have a very

1912
01:52:37,238 --> 01:52:42,759
small image then the LZ runs that you're

1913
01:52:40,899 --> 01:52:44,499
encoding where you're doing you know

1914
01:52:42,760 --> 01:52:49,269
you're the backwards look up stuff and

1915
01:52:44,498 --> 01:52:51,698
all that those pieces are not going to

1916
01:52:49,269 --> 01:52:57,099
be very large right when your entire

1917
01:52:51,698 --> 01:53:01,268
image is only what 260 bytes long its

1918
01:52:57,099 --> 01:53:02,860
entire encoding decompressed there's not

1919
01:53:01,269 --> 01:53:05,260
going to be a lot of

1920
01:53:02,859 --> 01:53:08,889
for you to do runs of 10,000 things

1921
01:53:05,260 --> 01:53:11,860
right so all of those fiddly little is

1922
01:53:08,890 --> 01:53:13,840
the table set up correctly to decode the

1923
01:53:11,859 --> 01:53:14,170
number of extra bits and this that meant

1924
01:53:13,840 --> 01:53:17,470
right

1925
01:53:14,170 --> 01:53:20,470
all of those things are not really in

1926
01:53:17,470 --> 01:53:23,020
play as much with a small image so lots

1927
01:53:20,470 --> 01:53:25,329
of little bugs that we may have had when

1928
01:53:23,020 --> 01:53:27,880
dealing with some of the TWiki er parts

1929
01:53:25,329 --> 01:53:30,760
of decoding those run lengths and things

1930
01:53:27,880 --> 01:53:32,590
like that those just wouldn't have come

1931
01:53:30,760 --> 01:53:34,539
into place so it makes a lot of sense

1932
01:53:32,590 --> 01:53:38,050
that we're seeing a bug on a big image

1933
01:53:34,539 --> 01:53:40,539
that we don't see on a small image and

1934
01:53:38,050 --> 01:53:43,659
so you know this this is hardly

1935
01:53:40,539 --> 01:53:45,460
surprising that said unfortunately it's

1936
01:53:43,659 --> 01:53:46,869
hard to know where to look one thing I

1937
01:53:45,460 --> 01:53:48,520
will say is it does look like we don't

1938
01:53:46,869 --> 01:53:49,840
need to reverse those extra bits so that

1939
01:53:48,520 --> 01:53:55,500
was good because that was gonna be

1940
01:53:49,840 --> 01:54:00,610
really annoying anyway so looking at

1941
01:53:55,500 --> 01:54:04,479
where we're at here one one thing that

1942
01:54:00,609 --> 01:54:07,479
might be good so we don't know if maybe

1943
01:54:04,479 --> 01:54:09,099
we've got an error in our tables here we

1944
01:54:07,479 --> 01:54:10,239
could probably spot check our tables

1945
01:54:09,100 --> 01:54:11,740
just one more time to make sure that

1946
01:54:10,239 --> 01:54:14,559
there aren't errors and the tables could

1947
01:54:11,739 --> 01:54:15,960
be samaras in these tables so that's

1948
01:54:14,560 --> 01:54:18,370
something we should probably look at

1949
01:54:15,960 --> 01:54:21,819
I'll definitely take a look the other

1950
01:54:18,369 --> 01:54:24,880
thing that I want to see is it would be

1951
01:54:21,819 --> 01:54:29,529
nice to do a coverage check so when we

1952
01:54:24,880 --> 01:54:31,000
have the the simple images if we know

1953
01:54:29,529 --> 01:54:33,340
that we're decoding a simple image

1954
01:54:31,000 --> 01:54:36,189
correctly but we're not in encoding

1955
01:54:33,340 --> 01:54:40,239
complicated image correctly what I might

1956
01:54:36,189 --> 01:54:42,729
ask is are there entire code paths that

1957
01:54:40,239 --> 01:54:45,340
aren't being hit on the simple image

1958
01:54:42,729 --> 01:54:47,139
that are being hit on the complex image

1959
01:54:45,340 --> 01:54:49,539
so before I end I'll end for the day on

1960
01:54:47,140 --> 01:54:50,800
that note before I end though I'm just

1961
01:54:49,539 --> 01:54:56,100
going to go ahead and put in a search

1962
01:54:50,800 --> 01:54:56,100
here Oh even like every path

1963
01:55:05,500 --> 01:55:12,100
uh and we know we're hitting this one

1964
01:55:11,170 --> 01:55:14,230
and we know we're hitting this and we

1965
01:55:12,100 --> 01:55:16,230
watch them both happen but what I've

1966
01:55:14,229 --> 01:55:20,619
done is I've put ones in each of these

1967
01:55:16,229 --> 01:55:25,449
so now I can just run it on the one that

1968
01:55:20,619 --> 01:55:28,119
works and just see like I know that

1969
01:55:25,449 --> 01:55:29,470
works and I can actually do it on this

1970
01:55:28,119 --> 01:55:30,970
one which is probably them

1971
01:55:29,470 --> 01:55:33,490
well actually this one has more runs in

1972
01:55:30,970 --> 01:55:38,770
it so let's use this one where it should

1973
01:55:33,489 --> 01:55:40,929
add more in soon anyway okay so we know

1974
01:55:38,770 --> 01:55:58,600
we hit encoded Len less than or equal to

1975
01:55:40,930 --> 01:55:59,800
15 we hit encoded Len equals 18 now

1976
01:55:58,600 --> 01:56:01,690
remember this doesn't mean these Co

1977
01:55:59,800 --> 01:56:14,890
paths are right it just means that they

1978
01:56:01,689 --> 01:56:16,750
have been run we've hit 17 we've hit

1979
01:56:14,890 --> 01:56:20,110
okay so wonder same thing here is write

1980
01:56:16,750 --> 01:56:22,630
this code never got used in the good in

1981
01:56:20,109 --> 01:56:26,289
the ones that actually work so this one

1982
01:56:22,630 --> 01:56:28,449
has not been used it's worth noting

1983
01:56:26,289 --> 01:56:32,380
right and it you'll note it's a

1984
01:56:28,449 --> 01:56:37,260
relatively complex case right it's a rep

1985
01:56:32,380 --> 01:56:42,220
foul like looking at a previous one so

1986
01:56:37,260 --> 01:56:43,750
like you know probably want to look at

1987
01:56:42,220 --> 01:56:46,240
that more closely and just see what's

1988
01:56:43,750 --> 01:56:47,470
going on you know are we actually

1989
01:56:46,239 --> 01:56:48,909
reading the right number of bits or

1990
01:56:47,470 --> 01:56:52,329
doing the rep count there you know who

1991
01:56:48,909 --> 01:56:53,979
knows we probably are at least reading

1992
01:56:52,329 --> 01:56:57,119
the rep count right the rep vowel maybe

1993
01:56:53,979 --> 01:56:59,529
not though right but probably because

1994
01:56:57,119 --> 01:57:05,500
yeah I mean we're looking backwards one

1995
01:56:59,529 --> 01:57:09,039
on it so yeah anyway but sorry where

1996
01:57:05,500 --> 01:57:12,039
were we we were on this case so the LEM

1997
01:57:09,039 --> 01:57:13,989
tab bits used here this case with where

1998
01:57:12,039 --> 01:57:18,510
we read the extra bits and add in that

1999
01:57:13,989 --> 01:57:25,800
case was getting used so this

2000
01:57:18,510 --> 01:57:38,100
this one right here this case was

2001
01:57:25,800 --> 01:57:40,350
getting used as well all right so if we

2002
01:57:38,100 --> 01:57:42,600
look they're just purely like whether or

2003
01:57:40,350 --> 01:57:47,210
not a case was used at all we still

2004
01:57:42,600 --> 01:57:47,210
don't have any idea what weather our

2005
01:57:47,539 --> 01:57:52,979
weather our averaging case works but

2006
01:57:51,960 --> 01:57:56,069
that's neither here or there because

2007
01:57:52,979 --> 01:57:59,969
nobody apparently uses that one yet this

2008
01:57:56,069 --> 01:58:03,179
case encoded Lin equals 16 we did not

2009
01:57:59,970 --> 01:58:06,539
call on the good version of this thing

2010
01:58:03,180 --> 01:58:09,690
now let's take a just a real quick look

2011
01:58:06,539 --> 01:58:12,149
I'm gonna go ahead and put complex in

2012
01:58:09,689 --> 01:58:16,379
here and see if that one calls it so it

2013
01:58:12,149 --> 01:58:20,779
doesn't I'm gonna go ahead and see if

2014
01:58:16,380 --> 01:58:23,400
this one calls it it does so you know

2015
01:58:20,779 --> 01:58:24,659
still not really that indicative that

2016
01:58:23,399 --> 01:58:26,869
there's probably a problem in it but

2017
01:58:24,659 --> 01:58:31,019
it's worth noting it's just worth noting

2018
01:58:26,869 --> 01:58:33,720
that we do have one code path that is

2019
01:58:31,020 --> 01:58:35,580
only called on the case that fails and

2020
01:58:33,720 --> 01:58:39,390
not called on the case that works

2021
01:58:35,579 --> 01:58:42,269
probably not really all that much to

2022
01:58:39,390 --> 01:58:46,530
read into it but it's just worth noting

2023
01:58:42,270 --> 01:58:49,290
so let's take a closer look at encoded

2024
01:58:46,529 --> 01:58:52,099
line equals 16 just to see whether

2025
01:58:49,289 --> 01:59:01,140
there's something there that's you know

2026
01:58:52,100 --> 01:59:05,160
kind of obviously busted so where is

2027
01:59:01,140 --> 01:59:09,090
that again that's in not in here or here

2028
01:59:05,159 --> 01:59:12,689
it is copy the previous code length 3 to

2029
01:59:09,090 --> 01:59:21,840
6 times the next two bits indicate the

2030
01:59:12,689 --> 01:59:25,309
repeat length 0 equals 3 3 equals 6 so

2031
01:59:21,840 --> 01:59:25,310
we're going to consume 2 bits

2032
01:59:25,658 --> 01:59:35,079
our rep count is three plus that that

2033
01:59:32,119 --> 01:59:35,079
does seem right

2034
01:59:49,719 --> 01:59:58,630
codes 8 comma 16 plus 2 bits 1 1 plus 2

2035
01:59:56,560 --> 02:00:07,650
bits I don't know what that's trying to

2036
01:59:58,630 --> 02:00:07,650
say I don't understand the example

2037
02:00:14,109 --> 02:00:20,299
LIC was saying so it's saying if the

2038
02:00:16,729 --> 02:00:22,488
first code was eight which is actually a

2039
02:00:20,300 --> 02:00:26,510
code like debate then the next code was

2040
02:00:22,488 --> 02:00:31,519
sixteen plus the bit 1-1 the bit pattern

2041
02:00:26,510 --> 02:00:38,050
1 1 then another 16 of bits 1 0 that

2042
02:00:31,520 --> 02:00:47,510
will expand to 12 code lengths of 8 so

2043
02:00:38,050 --> 02:00:49,130
the first 16 is saying repeat 8 3 plus 3

2044
02:00:47,510 --> 02:00:53,480
times or 6 times

2045
02:00:49,130 --> 02:00:59,150
the next one is saying repeat it 3 plus

2046
02:00:53,479 --> 02:01:00,468
2 which is 5 so it's 1 for the first one

2047
02:00:59,149 --> 02:01:04,988
which already would have been handled of

2048
02:01:00,469 --> 02:01:08,090
previous case 6 reps and then 5 reps I

2049
02:01:04,988 --> 02:01:10,569
mean it looks like that's what we're

2050
02:01:08,090 --> 02:01:10,569
doing

2051
02:01:18,569 --> 02:01:30,129
so I don't think we've done anything

2052
02:01:21,698 --> 02:01:33,219
wrong here so even though that case and

2053
02:01:30,128 --> 02:01:40,208
I I mean I can certainly take a closer

2054
02:01:33,219 --> 02:01:42,819
look at it and just make sure that it's

2055
02:01:40,208 --> 02:01:53,139
functioning properly but it seems likely

2056
02:01:42,819 --> 02:02:00,639
that it is so we're on value 282 so

2057
02:01:53,139 --> 02:02:03,639
we're down here at this so what we're

2058
02:02:00,639 --> 02:02:13,168
gonna do here is we're gonna say we want

2059
02:02:03,639 --> 02:02:16,168
to repeat three sevens right one two

2060
02:02:13,168 --> 02:02:16,168
three

2061
02:02:16,288 --> 02:02:29,228
seems reasonable so that seems like I

2062
02:02:25,479 --> 02:02:35,168
don't think that's wrong that seems

2063
02:02:29,229 --> 02:02:37,539
right so I would say we just still have

2064
02:02:35,168 --> 02:02:39,248
a bug in the decompressor here somewhere

2065
02:02:37,538 --> 02:02:42,759
I'm not gonna look for it any further

2066
02:02:39,248 --> 02:02:45,698
today I think we have a complete PNG

2067
02:02:42,760 --> 02:02:48,609
decompressor right now for the cases we

2068
02:02:45,698 --> 02:02:50,798
care about except for this so we have

2069
02:02:48,609 --> 02:02:53,019
one more thing to implement which is to

2070
02:02:50,798 --> 02:02:55,179
put in the built-in Huffman tables

2071
02:02:53,019 --> 02:03:01,479
hopefully that's not too hard to find

2072
02:02:55,179 --> 02:03:03,038
from the spec but the only thing I think

2073
02:03:01,479 --> 02:03:06,760
we need to do is figure out what we're

2074
02:03:03,038 --> 02:03:07,868
doing wrong in here like where we've got

2075
02:03:06,760 --> 02:03:10,179
something a little bit wrong because we

2076
02:03:07,868 --> 02:03:13,509
are decompressing now Huffman and non

2077
02:03:10,179 --> 02:03:15,309
Huffman pings as long as they're simple

2078
02:03:13,510 --> 02:03:16,298
so we've just got something wrong when

2079
02:03:15,309 --> 02:03:18,668
we try to go to something more

2080
02:03:16,298 --> 02:03:21,399
complicated I'm gonna go ahead and go to

2081
02:03:18,668 --> 02:03:23,439
the QA but that's pretty good

2082
02:03:21,399 --> 02:03:24,609
we're pretty far along here hopefully

2083
02:03:23,439 --> 02:03:28,349
this means it won't take us too much

2084
02:03:24,609 --> 02:03:28,349
longer before we're done

2085
02:03:37,989 --> 02:03:42,349
ratchet freak said the Len and Lana so

2086
02:03:40,789 --> 02:03:44,149
the decompressor can resync with a

2087
02:03:42,350 --> 02:03:45,770
compressor if a block uh corrupted the

2088
02:03:44,149 --> 02:03:49,159
compressor admitted an empty block by

2089
02:03:45,770 --> 02:03:51,740
looking for the byte 0 0 0 0 ffff mostly

2090
02:03:49,159 --> 02:03:53,479
handy for byte streams but how often

2091
02:03:51,739 --> 02:03:55,729
does the compressor output that block

2092
02:03:53,479 --> 02:03:58,009
and why wouldn't you just have a magic

2093
02:03:55,729 --> 02:03:59,479
value or something that you're a block

2094
02:03:58,010 --> 02:04:02,030
or something I mean if that really makes

2095
02:03:59,479 --> 02:04:04,369
sense or why not just make the i dot

2096
02:04:02,029 --> 02:04:10,399
blocks restart themselves just seems

2097
02:04:04,369 --> 02:04:14,500
like a bad way to do it rook tag says c

2098
02:04:10,399 --> 02:04:14,500
is up and left

2099
02:04:23,130 --> 02:04:28,170
is that true did I read it wrong

2100
02:04:33,899 --> 02:04:40,899
the bike corresponding to be oh you're

2101
02:04:37,300 --> 02:04:45,279
right okay well that is really nice if

2102
02:04:40,899 --> 02:04:52,859
that's the case because if that's the

2103
02:04:45,279 --> 02:04:55,449
case then it explains this part right

2104
02:04:52,859 --> 02:05:01,359
which was the part that was really kind

2105
02:04:55,449 --> 02:05:08,079
of annoying to me because yeah I could

2106
02:05:01,359 --> 02:05:10,149
not figure out I could not figure out

2107
02:05:08,079 --> 02:05:12,010
why they were saying that okay so it is

2108
02:05:10,149 --> 02:05:15,250
what I when I was like oh that's weird

2109
02:05:12,010 --> 02:05:16,690
that they would do the two over they

2110
02:05:15,250 --> 02:05:17,829
weren't and I was like they should have

2111
02:05:16,689 --> 02:05:25,139
done up into the left it looks like they

2112
02:05:17,829 --> 02:05:25,140
did do up into the left let's see here

2113
02:05:25,949 --> 02:05:33,340
so that means see pixel doesn't really

2114
02:05:29,680 --> 02:05:35,320
ever have to be there per se well I mean

2115
02:05:33,340 --> 02:05:37,569
I guess we can do it it's just the

2116
02:05:35,319 --> 02:05:40,630
previous see pixel is just the previous

2117
02:05:37,569 --> 02:05:46,229
be pixel so instead of see pixel equals

2118
02:05:40,630 --> 02:05:51,520
a pixel it's it's really just this right

2119
02:05:46,229 --> 02:05:54,549
so the up and to the left pixel is just

2120
02:05:51,520 --> 02:05:55,390
whatever pixel we read as B this time

2121
02:05:54,550 --> 02:05:58,770
around

2122
02:05:55,390 --> 02:05:58,770
before we advance B

2123
02:06:24,170 --> 02:06:29,090
he can Gail did I see four semi constant

2124
02:06:27,020 --> 02:06:33,050
on your code what's that for and how

2125
02:06:29,090 --> 02:06:35,270
does it work so you probably did see it

2126
02:06:33,050 --> 02:06:38,289
in the code I don't necessarily know

2127
02:06:35,270 --> 02:06:47,060
where it is okay yeah here it is

2128
02:06:38,289 --> 02:06:50,019
um so for reasons that I couldn't really

2129
02:06:47,060 --> 02:06:55,179
tell you I'm guessing that there because

2130
02:06:50,020 --> 02:06:59,660
the compiler was crappy Visual Studio

2131
02:06:55,179 --> 02:07:03,140
used to give you an error on that they

2132
02:06:59,659 --> 02:07:06,469
used to say that you had a while loop

2133
02:07:03,140 --> 02:07:08,210
that always evaluated to one like

2134
02:07:06,469 --> 02:07:10,039
conditional that always evaluated to one

2135
02:07:08,210 --> 02:07:11,239
and it would give you a warning which of

2136
02:07:10,039 --> 02:07:12,880
course if you have warning treated as

2137
02:07:11,238 --> 02:07:15,919
errors means it won't compile your code

2138
02:07:12,880 --> 02:07:17,719
the fix for that was just to use a for

2139
02:07:15,920 --> 02:07:19,670
loop with nothing in it because if you

2140
02:07:17,719 --> 02:07:24,109
put nothing in a for loop then it just

2141
02:07:19,670 --> 02:07:26,449
is an infinite loop and so this is the

2142
02:07:24,109 --> 02:07:29,389
way that I now habitually do it instead

2143
02:07:26,448 --> 02:07:31,009
of doing wild one to avoid those

2144
02:07:29,390 --> 02:07:32,869
previous warnings I don't know if they

2145
02:07:31,010 --> 02:07:35,770
still happen but they were quite some

2146
02:07:32,869 --> 02:07:41,269
time like Visual Studio 2005 through

2147
02:07:35,770 --> 02:07:43,790
2013 or 12 at least I think so anyway if

2148
02:07:41,270 --> 02:07:45,949
you want to have a loop where you just

2149
02:07:43,789 --> 02:07:47,988
want it to loop forever until you issue

2150
02:07:45,948 --> 02:07:57,710
the break statement that's just how that

2151
02:07:47,988 --> 02:07:59,659
works in the memory window when you were

2152
02:07:57,710 --> 02:08:01,579
writing the decoded pixel you were

2153
02:07:59,659 --> 02:08:03,409
writing to some memory that you have not

2154
02:08:01,579 --> 02:08:05,929
allocated according to the ASCII

2155
02:08:03,409 --> 02:08:11,149
representation there were some strings

2156
02:08:05,929 --> 02:08:18,380
about a path in Windows I don't think

2157
02:08:11,149 --> 02:08:20,569
you're right about that I mean what you

2158
02:08:18,380 --> 02:08:22,310
have to remember is when you allocate

2159
02:08:20,569 --> 02:08:24,130
memory you get memory that's been used

2160
02:08:22,310 --> 02:08:27,230
for something else potentially right

2161
02:08:24,130 --> 02:08:30,500
when you allocate memory with virtual a

2162
02:08:27,229 --> 02:08:37,578
lock the page that comes back will be

2163
02:08:30,500 --> 02:08:39,769
filled with zeros I think by requirement

2164
02:08:37,578 --> 02:08:41,148
I think virtual Alec has to fill a page

2165
02:08:39,769 --> 02:08:44,989
with zeros for it give it to you

2166
02:08:41,149 --> 02:08:48,399
I think that's required but everyone

2167
02:08:44,988 --> 02:08:51,078
upstream of the actual virtual Alec all

2168
02:08:48,399 --> 02:08:54,409
can just recycle memory so when you call

2169
02:08:51,078 --> 02:08:56,808
malloc you're not gonna get a cleared

2170
02:08:54,408 --> 02:08:59,569
page you're gonna get a page that

2171
02:08:56,809 --> 02:09:03,168
somebody used and freed before you does

2172
02:08:59,569 --> 02:09:04,849
that make sense so I don't think we were

2173
02:09:03,168 --> 02:09:18,498
writing to memory that we didn't

2174
02:09:04,849 --> 02:09:19,998
allocate in day 55 we create the hash

2175
02:09:18,498 --> 02:09:22,099
table you added your to-do on getting a

2176
02:09:19,998 --> 02:09:23,838
better hash that was a joke right cuz he

2177
02:09:22,099 --> 02:09:25,429
I didn't think we'd ever really need a

2178
02:09:23,838 --> 02:09:27,618
better hash I was just saying that

2179
02:09:25,429 --> 02:09:29,059
everyone always puts in use a better

2180
02:09:27,618 --> 02:09:30,858
hash function and then it ships like

2181
02:09:29,059 --> 02:09:36,378
that right so that was kind of a joke

2182
02:09:30,859 --> 02:09:38,419
but what you would see if the hash is

2183
02:09:36,378 --> 02:09:40,578
not good enough is that you end up

2184
02:09:38,418 --> 02:09:42,708
linearly probing most of the time which

2185
02:09:40,578 --> 02:09:44,538
just degenerates to a linear search like

2186
02:09:42,708 --> 02:09:48,498
you can answer this question yourself

2187
02:09:44,538 --> 02:09:50,268
sort of so a hash table which we usually

2188
02:09:48,498 --> 02:09:51,738
use hash tables with exterior chaining

2189
02:09:50,269 --> 02:09:53,300
right so what we do is we have hash

2190
02:09:51,738 --> 02:09:55,458
tables and the entries in the hash table

2191
02:09:53,300 --> 02:09:58,699
point to expect to be a linked list of

2192
02:09:55,458 --> 02:10:00,800
everything that hashed to that value so

2193
02:09:58,698 --> 02:10:03,858
let's suppose that your hash was awful

2194
02:10:00,800 --> 02:10:06,859
and always returned the value five or

2195
02:10:03,859 --> 02:10:08,269
something like that right well if it

2196
02:10:06,859 --> 02:10:10,159
always returned the value 5 then

2197
02:10:08,269 --> 02:10:12,019
everything that you put in will go into

2198
02:10:10,158 --> 02:10:13,549
hash bucket five that means that

2199
02:10:12,019 --> 02:10:15,708
everything that went into the hash table

2200
02:10:13,550 --> 02:10:17,838
would just create one giant linked list

2201
02:10:15,708 --> 02:10:20,269
and every query into the hash table

2202
02:10:17,838 --> 02:10:22,550
therefore is just a linear search of a

2203
02:10:20,269 --> 02:10:24,168
linear linked list which obviously

2204
02:10:22,550 --> 02:10:28,248
defeats the purpose of having a hash

2205
02:10:24,168 --> 02:10:30,738
table so the thing that is a problem if

2206
02:10:28,248 --> 02:10:32,328
you have a bad hash function if you

2207
02:10:30,738 --> 02:10:33,858
start feeding a lot of things to hash

2208
02:10:32,328 --> 02:10:37,158
function that all hash to the same

2209
02:10:33,859 --> 02:10:38,749
location you end up not getting the

2210
02:10:37,158 --> 02:10:42,078
speed of a hash table you get the speed

2211
02:10:38,748 --> 02:10:46,368
of a linear search so the worse the hash

2212
02:10:42,078 --> 02:10:48,738
the closer it is to linear search right

2213
02:10:46,368 --> 02:10:53,168
the better the hash the closer it is to

2214
02:10:48,738 --> 02:10:53,168
oh one instantaneous right

2215
02:11:08,369 --> 02:11:11,949
there's a visual city a plugin with that

2216
02:11:10,720 --> 02:11:13,869
lets you see images in memory it's

2217
02:11:11,949 --> 02:11:16,630
called image watch it was pretty useful

2218
02:11:13,869 --> 02:11:18,550
why did the PNG decoding yeah so that I

2219
02:11:16,630 --> 02:11:22,150
agree that probably useful I don't super

2220
02:11:18,550 --> 02:11:24,369
love plugins to visual studio we've had

2221
02:11:22,149 --> 02:11:27,159
a lot of issues with like trying to do

2222
02:11:24,369 --> 02:11:29,319
stuff with just the one insight one or

2223
02:11:27,159 --> 02:11:30,849
whatever and it just I don't really want

2224
02:11:29,319 --> 02:11:32,819
to go down that road that should be

2225
02:11:30,850 --> 02:11:40,030
built individual studio it's kind of

2226
02:11:32,819 --> 02:11:42,009
flame that's not but John to Resta okay

2227
02:11:40,029 --> 02:11:45,609
it's that looks trained usually it's so

2228
02:11:42,010 --> 02:11:48,690
with oh XD d or Oh X CD if I remember

2229
02:11:45,609 --> 02:11:51,489
correctly or maybe just stack memory so

2230
02:11:48,689 --> 02:11:54,099
when you allocate memory you absolutely

2231
02:11:51,489 --> 02:11:56,039
will never be filled with oh XD d or Oh

2232
02:11:54,100 --> 02:11:59,140
X CD or anything like that

2233
02:11:56,039 --> 02:12:03,180
unless you are using a debug allocator

2234
02:11:59,140 --> 02:12:06,820
that explicitly does that fill so

2235
02:12:03,180 --> 02:12:08,920
basically allocating memory is supposed

2236
02:12:06,819 --> 02:12:11,349
to be as fast as possible so a memory

2237
02:12:08,920 --> 02:12:13,930
allocator will never fill it with values

2238
02:12:11,350 --> 02:12:17,260
if you get back memory that's filled

2239
02:12:13,930 --> 02:12:19,420
with values that value should be 0 if it

2240
02:12:17,260 --> 02:12:23,079
came from virtual Alec or it should be

2241
02:12:19,420 --> 02:12:24,430
garbage but never a constant value if it

2242
02:12:23,079 --> 02:12:26,350
gets filled with a constant value that

2243
02:12:24,430 --> 02:12:28,090
means as a debug allocator and you'd

2244
02:12:26,350 --> 02:12:29,110
better have known you were using a debug

2245
02:12:28,090 --> 02:12:30,220
allocator because if you weren't

2246
02:12:29,109 --> 02:12:34,439
expecting used to debug out here or

2247
02:12:30,220 --> 02:12:34,440
something something's up right

2248
02:12:34,659 --> 02:12:41,529
this same should be true for stack

2249
02:12:37,899 --> 02:12:44,829
memory because again stack memory should

2250
02:12:41,529 --> 02:12:48,789
be filled with zeros or garbage but not

2251
02:12:44,829 --> 02:12:51,850
a constant value unless there's a debug

2252
02:12:48,789 --> 02:12:53,409
unless debugging is on now I don't know

2253
02:12:51,850 --> 02:12:55,329
if they've changed something recently

2254
02:12:53,409 --> 02:12:57,010
where like stack memory memory gets like

2255
02:12:55,329 --> 02:13:01,059
flooded with something to avoid like

2256
02:12:57,010 --> 02:13:05,050
stack attacks like stack overflow

2257
02:13:01,060 --> 02:13:10,480
attacks or something like this but I you

2258
02:13:05,050 --> 02:13:12,960
know I hope they didn't do that so guess

2259
02:13:10,479 --> 02:13:12,959
what I'd say

2260
02:13:14,719 --> 02:13:18,510
all right I think we were I don't think

2261
02:13:17,158 --> 02:13:22,920
we I don't think I see any other on

2262
02:13:18,510 --> 02:13:24,539
topic questions here try a big image

2263
02:13:22,920 --> 02:13:27,029
which compresses very well

2264
02:13:24,538 --> 02:13:29,819
yeah well the image wheat that is what

2265
02:13:27,029 --> 02:13:31,529
that is we did provide a big image which

2266
02:13:29,819 --> 02:13:33,719
compresses very well probably what we'd

2267
02:13:31,529 --> 02:13:35,189
be more likely to decompress okay even

2268
02:13:33,719 --> 02:13:38,279
including whatever bug we have is it as

2269
02:13:35,189 --> 02:13:39,748
a big image that doesn't compress very

2270
02:13:38,279 --> 02:13:41,819
well because that would be filled with

2271
02:13:39,748 --> 02:13:46,408
lots of tiny runs and literals and that

2272
02:13:41,819 --> 02:13:50,729
would probably work fine right so yeah

2273
02:13:46,408 --> 02:13:52,998
so you know I suspect that you know if I

2274
02:13:50,729 --> 02:13:55,678
had to guess if we look at what's

2275
02:13:52,998 --> 02:13:59,998
happening in the test image there's just

2276
02:13:55,679 --> 02:14:05,219
a giant run of white here and a giant

2277
02:13:59,998 --> 02:14:07,828
runs of all zeros here and my suspicion

2278
02:14:05,219 --> 02:14:12,210
is that we're not interpreting some of

2279
02:14:07,828 --> 02:14:16,948
those larger run Huffman's correctly or

2280
02:14:12,210 --> 02:14:17,609
something like this you know if that

2281
02:14:16,948 --> 02:14:19,948
makes sense

2282
02:14:17,609 --> 02:14:21,630
so if we actually had an image that was

2283
02:14:19,948 --> 02:14:23,368
filled with data like that like a photo

2284
02:14:21,630 --> 02:14:28,679
like a photographic image where it was

2285
02:14:23,368 --> 02:14:32,069
very mixed in terms of the pics of Iser

2286
02:14:28,679 --> 02:14:34,440
runs or anything I suspect that one

2287
02:14:32,069 --> 02:14:37,349
might actually work right like because

2288
02:14:34,439 --> 02:14:39,919
again that's not stressing the the LZ

2289
02:14:37,349 --> 02:14:43,619
it's like a fairly uncompressed image

2290
02:14:39,920 --> 02:14:52,469
and so I think we'd have more luck with

2291
02:14:43,618 --> 02:14:54,268
that quick shift on Linux would you use

2292
02:14:52,469 --> 02:14:56,219
sialic instead of rich luck or is there

2293
02:14:54,269 --> 02:15:01,530
an alternative yeah that I think you'd

2294
02:14:56,219 --> 02:15:09,510
use mem map so mmm ap is probably what

2295
02:15:01,529 --> 02:15:11,300
the low-level allocator is yeah so it's

2296
02:15:09,510 --> 02:15:13,980
this is probably what you'd be calling

2297
02:15:11,300 --> 02:15:19,610
instead of so instead of virtue like

2298
02:15:13,979 --> 02:15:19,609
virtual free it be mem map mem on map

2299
02:15:20,658 --> 02:15:25,888
not not see Alex II Alex I or whatever

2300
02:15:24,420 --> 02:15:27,149
is gonna go if that's gonna go through

2301
02:15:25,889 --> 02:15:33,418
some interview

2302
02:15:27,149 --> 02:15:34,559
nonsense sergeant REM be will you

2303
02:15:33,418 --> 02:15:36,118
integrate the Dakota directly into the

2304
02:15:34,559 --> 02:15:40,439
game or into the sim professor directly

2305
02:15:36,118 --> 02:15:45,089
into the game it won't be used at

2306
02:15:40,439 --> 02:15:47,010
runtime well it won't be used in the

2307
02:15:45,090 --> 02:15:49,340
shipping version but in development it

2308
02:15:47,010 --> 02:15:52,110
will be used inside the game to hot load

2309
02:15:49,340 --> 02:15:54,889
next quick exports from Photoshop that's

2310
02:15:52,109 --> 02:15:54,889
why we're doing it

2311
02:16:15,880 --> 02:16:18,880
oops

2312
02:16:21,600 --> 02:16:24,740
close everything down here

2313
02:16:30,529 --> 02:16:33,859
all right thank you for joining me for

2314
02:16:32,540 --> 02:16:35,660
that said handmade hero it's been a

2315
02:16:33,859 --> 02:16:36,920
pleasure coding with you as always if

2316
02:16:35,659 --> 02:16:38,450
you would like to follow along with

2317
02:16:36,920 --> 02:16:40,909
series at home you can always peer to

2318
02:16:38,450 --> 02:16:43,250
the game on handmade hero org and it

2319
02:16:40,909 --> 02:16:45,318
comes with the source code so you can

2320
02:16:43,250 --> 02:16:48,709
play around that if you want to try your

2321
02:16:45,318 --> 02:16:50,659
hand at debugging the PNG stuff now be a

2322
02:16:48,709 --> 02:16:52,459
good time to do it it's mostly working

2323
02:16:50,659 --> 02:16:55,388
but we know we have a few problems in

2324
02:16:52,459 --> 02:16:57,978
there trying it's a pretty tough little

2325
02:16:55,388 --> 02:16:59,839
debugging problem right it's involves

2326
02:16:57,978 --> 02:17:03,648
like a fairly complex and put output

2327
02:16:59,840 --> 02:17:05,148
stream and in a spec to look at to see

2328
02:17:03,648 --> 02:17:07,849
what you're supposed to be doing and so

2329
02:17:05,148 --> 02:17:09,379
on so I would say if you want a little

2330
02:17:07,849 --> 02:17:11,689
bit of a challenge spend a few hours

2331
02:17:09,379 --> 02:17:13,848
tonight see if you can find the bug or

2332
02:17:11,689 --> 02:17:15,429
any you know they're probably my more

2333
02:17:13,849 --> 02:17:17,689
than one bug see if you can find them

2334
02:17:15,429 --> 02:17:19,849
before tomorrow stream before we start

2335
02:17:17,689 --> 02:17:23,630
looking for them together it's be a

2336
02:17:19,849 --> 02:17:25,010
pretty good exercise alright that's it

2337
02:17:23,629 --> 02:17:26,449
for today I'll be back here tomorrow to

2338
02:17:25,010 --> 02:17:28,460
finish up that debugging process

2339
02:17:26,450 --> 02:17:30,380
hopefully we'll be finished by tomorrow

2340
02:17:28,459 --> 02:17:31,938
because we actually have all the filters

2341
02:17:30,379 --> 02:17:33,438
in place to so maybe if we're lucky

2342
02:17:31,939 --> 02:17:35,300
we'll either be finished or mostly

2343
02:17:33,439 --> 02:17:36,409
finished by the end of tomorrow who

2344
02:17:35,299 --> 02:17:37,398
knows it's hard to say with debugging

2345
02:17:36,409 --> 02:17:39,349
you never know how long it's gonna take

2346
02:17:37,398 --> 02:17:41,568
to find a bug two hours may not be

2347
02:17:39,349 --> 02:17:42,829
enough we'll see until then have fun

2348
02:17:41,568 --> 02:17:45,549
pouring everyone and I'll see you on the

2349
02:17:42,829 --> 02:17:45,549
Internet take it easy

