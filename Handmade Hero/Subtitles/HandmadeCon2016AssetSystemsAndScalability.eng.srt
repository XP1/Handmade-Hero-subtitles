1
00:00:04,300 --> 00:00:08,500
Following up the compression talk which is a sort of a theoretical and

2
00:00:08,500 --> 00:00:13,200
thinking talk with a much more practical talk or I should say session,

3
00:00:13,200 --> 00:00:13,600
I guess.

4
00:00:14,000 --> 00:00:17,300
And essentially like one of the things that's really kind of hard to

5
00:00:17,300 --> 00:00:20,900
get across on handmade hero in any way because of the nature of the of

6
00:00:20,900 --> 00:00:25,100
the project and the fact that it's only me programming, it is that

7
00:00:25,100 --> 00:00:29,200
there's all sorts of things that you will start to run into when

8
00:00:29,200 --> 00:00:33,500
you're talking about doing things at a scale where you may have, you

9
00:00:33,500 --> 00:00:33,800
know,

10
00:00:34,100 --> 00:00:39,800
Tens, hundreds, you know, 500 people all working on a project and

11
00:00:39,800 --> 00:00:44,000
these are sorts of things that don't necessarily imply that anything

12
00:00:44,000 --> 00:00:47,100
that you might be doing in the code, like, you would be doing it for

13
00:00:47,100 --> 00:00:50,500
one person product or necessarily wrong, but it does mean that there

14
00:00:50,500 --> 00:00:54,600
may be whole new systems or whole new things problems.

15
00:00:54,600 --> 00:00:58,100
You need to solve that just simply don't exist when your scale is much

16
00:00:58,100 --> 00:00:58,600
smaller.

17
00:00:59,400 --> 00:01:03,800
And so what I, what I wanted to do because I knew that that bungee

18
00:01:04,000 --> 00:01:06,000
Had shipped Destiny and had a bunch of work.

19
00:01:06,000 --> 00:01:09,300
They had to do with asset systems and stuff in order to support

20
00:01:09,300 --> 00:01:13,700
something at that scale and it was kind of a new skill for them.

21
00:01:13,700 --> 00:01:16,600
So they'd gone through all of the growing pains, you know in that

22
00:01:16,600 --> 00:01:21,100
project was I invited Chris butcher to talk to us about what that

23
00:01:21,100 --> 00:01:24,800
process was like what they learned and just kind of like allow me to

24
00:01:24,800 --> 00:01:28,200
sort of be the outsider who comes in and like asks for that, that

25
00:01:28,200 --> 00:01:31,200
whole sort of like series of steps, they went through their learning

26
00:01:31,200 --> 00:01:33,500
process and what they sort of ended up with

27
00:01:34,100 --> 00:01:38,200
Are still working on potentially even to keep that sort of scale

28
00:01:38,200 --> 00:01:39,000
functioning.

29
00:01:39,700 --> 00:01:49,500
So please give a warm, welcome to Chris butcher stand before.

30
00:01:49,600 --> 00:01:53,100
You said before we start, you wanted to take a survey.

31
00:01:53,400 --> 00:01:55,000
So, yeah, yes.

32
00:01:55,100 --> 00:01:56,900
Well, actually, it's funny, like I was wondering about the

33
00:01:56,900 --> 00:01:59,000
juxtaposition of those who talks, because we're going from

34
00:01:59,000 --> 00:02:02,900
compression, which is the super pure abstract problem, right?

35
00:02:02,900 --> 00:02:03,900
Where you can look at something,

36
00:02:04,000 --> 00:02:07,100
And say, here is a problem, here is a way to solve it.

37
00:02:07,100 --> 00:02:08,100
Like let's try that.

38
00:02:08,100 --> 00:02:09,000
Okay, that was the right way.

39
00:02:09,000 --> 00:02:10,100
Let's go right.

40
00:02:10,100 --> 00:02:12,700
We're going to talk about now is the exact opposite of that is just

41
00:02:12,700 --> 00:02:16,600
like a nasty gritty messy problem, right?

42
00:02:16,700 --> 00:02:19,300
If the kind that you run into, when you're dealing with game

43
00:02:19,300 --> 00:02:24,200
production on a large scale and we certainly like have a larger scale

44
00:02:24,200 --> 00:02:27,100
than we probably realized at the time and probably a larger scale than

45
00:02:27,100 --> 00:02:27,700
most people.

46
00:02:28,100 --> 00:02:30,700
So yeah I want to do a show of hands I'm actually curious.

47
00:02:30,700 --> 00:02:31,100
So

48
00:02:33,100 --> 00:02:37,400
Hands up, if you are not a programmer, like maybe you're a student or

49
00:02:37,400 --> 00:02:40,000
a teacher and you're a programmer, you're not professionally, employed

50
00:02:40,000 --> 00:02:40,500
the program right now.

51
00:02:40,500 --> 00:02:43,400
So students, teachers game designers you thought your go to the Opera

52
00:02:43,400 --> 00:02:45,100
may be okay.

53
00:02:46,400 --> 00:02:49,000
So hands up if you are currently professionally employed as a

54
00:02:49,000 --> 00:02:49,600
programmer.

55
00:02:50,500 --> 00:02:50,700
Wow.

56
00:02:50,700 --> 00:02:54,500
Okay, and now keep your hand up if you work on a team of more than

57
00:02:54,500 --> 00:02:55,300
five people

58
00:02:57,000 --> 00:02:58,300
Okay, more than 10 people.

59
00:02:59,600 --> 00:02:59,900
more than

60
00:03:00,000 --> 00:03:00,900
20 people.

61
00:03:02,200 --> 00:03:03,600
More than 50 people.

62
00:03:04,800 --> 00:03:12,000
More than 100 people, more than 200 people more than 300 people.

63
00:03:13,000 --> 00:03:15,600
Where does it end more than 400 people?

64
00:03:16,600 --> 00:03:17,600
Okay, thank you.

65
00:03:17,600 --> 00:03:19,200
Bungee people, you can put your hands down.

66
00:03:22,000 --> 00:03:24,400
So you have a destiny development team right now.

67
00:03:24,500 --> 00:03:28,700
If you count everybody at the company it's like 680 people, those

68
00:03:28,700 --> 00:03:31,900
people are all working on Destiny in one form or another their company

69
00:03:31,900 --> 00:03:34,000
support people RIT or test or something like that.

70
00:03:34,300 --> 00:03:34,500
But

71
00:03:34,600 --> 00:03:37,900
Or development staff, we have probably around 500 people.

72
00:03:38,000 --> 00:03:42,500
So a really big problem and a much larger problem that I think we

73
00:03:42,500 --> 00:03:45,100
really understood at the time for a lot of reasons that are

74
00:03:45,100 --> 00:03:45,600
interesting.

75
00:03:46,000 --> 00:03:50,800
And so, sort of giving people the perspective on where the story

76
00:03:50,800 --> 00:03:54,900
starts, so when you said realize that the time, so take us back a

77
00:03:54,900 --> 00:03:58,400
little bit to sort of, you know, where you know, Destiny was getting

78
00:03:58,400 --> 00:03:59,800
started as a concept or whatever.

79
00:03:59,800 --> 00:04:01,100
Where are we at?

80
00:04:01,200 --> 00:04:04,500
And what does the sort of landscape look like if we

81
00:04:04,600 --> 00:04:08,000
We rewind all the way back to before we even started really thinking

82
00:04:08,000 --> 00:04:10,900
about the asset system and maybe we're using like, you know, sort of

83
00:04:10,900 --> 00:04:13,700
older architecture of an asset system from previous bunch of games or

84
00:04:13,700 --> 00:04:14,600
something like that.

85
00:04:14,600 --> 00:04:14,900
Yeah.

86
00:04:14,900 --> 00:04:17,100
So just just sticking to the technology, right?

87
00:04:17,100 --> 00:04:19,300
And kind of melt talking about, like, the game design and game

88
00:04:19,300 --> 00:04:19,700
concept.

89
00:04:19,700 --> 00:04:21,600
Well, that's a whole other thing just itself.

90
00:04:22,200 --> 00:04:22,500
Yeah.

91
00:04:22,500 --> 00:04:26,600
So we had been working on Halo for about 10 years at that time, right?

92
00:04:26,600 --> 00:04:29,000
From like, 1997 through 2007.

93
00:04:29,200 --> 00:04:31,700
And I wasn't wrapped the first couple years of Halo development, I

94
00:04:31,700 --> 00:04:34,000
joined in around about 2000.

95
00:04:34,700 --> 00:04:39,600
And so the Halo engine had been in use for 10 years and the principles

96
00:04:39,600 --> 00:04:44,700
of the Halo engine were, there was a structure that we call the tag

97
00:04:46,000 --> 00:04:47,400
for reasons that I lost to history.

98
00:04:48,000 --> 00:04:55,000
The tag file is a piece of content that is has a known structure to

99
00:04:55,000 --> 00:04:55,200
it.

100
00:04:55,200 --> 00:04:58,900
Like it's a, you know it's a it's an object or it's a model let's say

101
00:04:59,100 --> 00:05:02,900
and it saved on disk and then it gets loaded directly by the game in

102
00:05:02,900 --> 00:05:04,400
that same structure.

103
00:05:04,500 --> 00:05:06,900
ER and so just to be clear on that.

104
00:05:06,900 --> 00:05:12,600
When you say two parts of that I guess tag is some kind of an ID.

105
00:05:12,800 --> 00:05:15,900
What does this ID look like textual integer?

106
00:05:15,900 --> 00:05:18,600
Yeah in this case, it's a string for the path, right?

107
00:05:18,600 --> 00:05:22,800
And then a type which is, you know, object or model or what have you

108
00:05:22,800 --> 00:05:26,100
and that type is also a string or some kind of integer code.

109
00:05:26,700 --> 00:05:27,700
It's a string.

110
00:05:27,900 --> 00:05:28,300
Okay.

111
00:05:28,400 --> 00:05:31,100
So we essentially have two strings that are saying this is the assets

112
00:05:31,100 --> 00:05:34,100
sort of name and another string which is the assets type and then you

113
00:05:34,100 --> 00:05:34,400
say

114
00:05:34,500 --> 00:05:36,300
Say that type implies a known structure.

115
00:05:36,300 --> 00:05:39,200
It sounded like you were not talking about abstract, so you mean,

116
00:05:39,200 --> 00:05:42,700
literally, this is the binary format and when it comes into the game

117
00:05:42,700 --> 00:05:45,000
it will be exactly in this binary form.

118
00:05:45,000 --> 00:05:48,100
Yes, specifically, there's a C++ header file, right.

119
00:05:48,100 --> 00:05:52,500
And then here as a see structure and then in the Halo engine, there

120
00:05:52,500 --> 00:05:55,500
was a parallel set of declarations which were saying, you know, like

121
00:05:55,500 --> 00:05:59,200
four bytes for integer and then a string goes here and then like

122
00:06:00,000 --> 00:06:03,000
It's four packs Flags or what have you and so you had to like declare

123
00:06:03,000 --> 00:06:07,100
your see structure, you also have to declare like the fields which

124
00:06:07,100 --> 00:06:10,100
told the game house can be stored on disk and then will be B swapped

125
00:06:10,100 --> 00:06:11,800
for a big-endian little-endian platforms.

126
00:06:12,100 --> 00:06:17,400
So pretty simple pretty standard like not super modern reflection

127
00:06:17,400 --> 00:06:22,800
format just like a very hand created and then that was how the game

128
00:06:22,800 --> 00:06:26,200
loaded in the development build is you would go and load one tag which

129
00:06:26,200 --> 00:06:28,100
was the thing that told you everything you had to load and then you

130
00:06:28,100 --> 00:06:29,700
would go and recursively call that right?

131
00:06:30,000 --> 00:06:33,900
And so they're basically these just to flesh that out.

132
00:06:33,900 --> 00:06:37,700
Every time you load one of these, it could itself include other

133
00:06:37,700 --> 00:06:41,300
references which were the first part of that tag the name, presumably

134
00:06:41,500 --> 00:06:43,400
or the name and the type both.

135
00:06:43,800 --> 00:06:46,800
So, the reference itself also gives you nothing.

136
00:06:46,800 --> 00:06:48,100
That's like, hey, it's the type as well.

137
00:06:48,100 --> 00:06:50,300
So, you know, what, kind of type you're looking at you up there.

138
00:06:50,400 --> 00:06:50,800
Okay?

139
00:06:51,300 --> 00:06:54,500
So then you crawl out words from there and you could be doing this

140
00:06:54,500 --> 00:06:55,400
many, many times.

141
00:06:55,700 --> 00:06:55,900
Yeah.

142
00:06:55,900 --> 00:06:56,300
Right then.

143
00:06:56,300 --> 00:06:59,800
So like a typical level in Halo would probably be on the order of

144
00:07:00,000 --> 00:07:02,600
Maybe 5,000 to 10,000 tags.

145
00:07:02,800 --> 00:07:03,000
Okay.

146
00:07:03,000 --> 00:07:03,900
And by the end.

147
00:07:04,400 --> 00:07:09,700
And so there are some characteristics about that.

148
00:07:09,700 --> 00:07:11,600
They're interesting to talk about the first.

149
00:07:11,600 --> 00:07:15,300
One is the the structure of the data on disk is the same as the

150
00:07:15,300 --> 00:07:16,700
structure of the data in memory.

151
00:07:17,100 --> 00:07:17,300
Yes.

152
00:07:17,300 --> 00:07:20,600
And the implication then is that if you have an editor, which is

153
00:07:20,600 --> 00:07:23,300
working directly with these tags, these structure of the data, the

154
00:07:23,300 --> 00:07:26,700
editor is looking at is the same as the runtime structure of the data

155
00:07:26,700 --> 00:07:27,200
in memory.

156
00:07:27,700 --> 00:07:29,800
I see, so, so basically there is not

157
00:07:29,900 --> 00:07:32,500
The concept of a separate editor, at this point, a separate editor

158
00:07:32,500 --> 00:07:35,200
data structure at this point, which gets kind of baked down into that,

159
00:07:35,200 --> 00:07:39,400
think they are all operating under the same set of of data.

160
00:07:39,400 --> 00:07:41,400
Well, we're talking here about the generic pipeline, right?

161
00:07:41,400 --> 00:07:43,400
And then of course, for things like a texture.

162
00:07:43,400 --> 00:07:44,200
Let's say right.

163
00:07:44,200 --> 00:07:47,000
You know, there's a Photoshop file for the texture and there's a

164
00:07:47,000 --> 00:07:50,300
texture importer which is like a specific command you run on a texture

165
00:07:50,300 --> 00:07:54,300
that turns it into a tag and so the tag is not really human readable.

166
00:07:54,300 --> 00:07:57,500
It's just like here's some binary array of data and then there's a

167
00:07:57,500 --> 00:07:59,700
texture and portal that takes the texture and turns into the tag.

168
00:08:00,900 --> 00:08:02,700
So that's like, that's pretty straightforward.

169
00:08:02,700 --> 00:08:06,600
Like, that's something you can do and you can build a whole Pipeline

170
00:08:06,600 --> 00:08:07,300
on top of that.

171
00:08:07,400 --> 00:08:09,500
And there's lots of, there's lots of lots of interesting things that

172
00:08:09,500 --> 00:08:14,300
you can talk about there about, you know, building graphical editors

173
00:08:14,300 --> 00:08:15,900
on top of structured data formats.

174
00:08:15,900 --> 00:08:21,600
And the, the most important thing to talk about here probably is that

175
00:08:21,600 --> 00:08:23,900
in the development version of the game, you doing this crawled, go and

176
00:08:23,900 --> 00:08:26,600
find all those pieces of data and you load the main memory and then

177
00:08:26,600 --> 00:08:29,900
there's a fix-up function you call that in place converts things like

178
00:08:30,100 --> 00:08:33,900
For example, if the designer said this should be negative for a is in

179
00:08:33,900 --> 00:08:37,600
this group thin, like you change, the clamp that 20 will make it 1 or

180
00:08:37,600 --> 00:08:38,200
what-have-you, right?

181
00:08:38,200 --> 00:08:40,600
So if it's a function of the run in place from the data, the time is

182
00:08:40,600 --> 00:08:46,000
loaded and then that's pretty slow to do that, right?

183
00:08:46,000 --> 00:08:48,700
Like that might, if you are running that on Xbox, maybe that takes

184
00:08:48,700 --> 00:08:53,200
anywhere from 2 to 20 minutes to load a level because you're loading,

185
00:08:53,200 --> 00:08:56,400
these files individually from the hard drive and you're doing fix up

186
00:08:56,400 --> 00:08:57,100
on them in place.

187
00:08:57,100 --> 00:08:59,400
And after you the fix-up, you and discover the new things used to load

188
00:08:59,400 --> 00:08:59,800
and go in

189
00:09:00,200 --> 00:09:00,800
Seriously.

190
00:09:01,200 --> 00:09:05,200
So so basically you're just talking about a lot of seeking around on

191
00:09:05,200 --> 00:09:09,000
the I guess the development hard drive to pull these things in and

192
00:09:09,000 --> 00:09:11,600
that ends up being a fairly dominant part of the performance.

193
00:09:11,600 --> 00:09:15,900
Because means, because 10,000 tags is not a high number of tags for a

194
00:09:15,900 --> 00:09:17,000
graph walk to process.

195
00:09:17,000 --> 00:09:19,800
So, presumably, there's a particular part of that process, that's

196
00:09:19,800 --> 00:09:20,300
slow.

197
00:09:20,500 --> 00:09:21,600
Yeah, it's cereal, right?

198
00:09:21,600 --> 00:09:22,800
You're seeking the best in your loading.

199
00:09:22,800 --> 00:09:25,500
It we're talking about the original Xbox here.

200
00:09:25,500 --> 00:09:27,900
Also 2004, right?

201
00:09:28,000 --> 00:09:29,800
We're like this all kinds of known problems.

202
00:09:30,000 --> 00:09:33,300
With like it's directory enumeration of slow when you have lots of

203
00:09:33,300 --> 00:09:34,500
files in a directory, okay?

204
00:09:34,900 --> 00:09:38,300
So anyway, so through, say, non-problem you mean artificial problem?

205
00:09:38,300 --> 00:09:41,700
I guess I got to think things that you don't think about today.

206
00:09:41,700 --> 00:09:42,200
Got it.

207
00:09:42,200 --> 00:09:46,700
Yeah, 15 years later and for context there, so that's like the

208
00:09:46,700 --> 00:09:50,100
development build, where you can make changes to a tag or change to an

209
00:09:50,100 --> 00:09:52,500
individual field and a tag and then seek that across and it can be

210
00:09:52,500 --> 00:09:53,800
loaded really quickly, right?

211
00:09:53,800 --> 00:09:56,900
So, you're very, very rapid iteration there because everything is

212
00:09:56,900 --> 00:09:58,100
organized in these files.

213
00:09:58,400 --> 00:09:59,900
There's no dependencies between

214
00:10:00,000 --> 00:10:04,600
Owls other than at the fix-up time in some cases, you can let go and

215
00:10:04,600 --> 00:10:06,700
like, dereference something and go and pull the field out of it and

216
00:10:06,700 --> 00:10:07,200
put it in there.

217
00:10:07,200 --> 00:10:11,300
But the dependencies are very, very constrained by the model.

218
00:10:11,500 --> 00:10:14,600
And so, as a result, the model lends itself to super fast iteration of

219
00:10:14,600 --> 00:10:18,100
super slow load times and then there's another variant adjust that we

220
00:10:18,100 --> 00:10:18,300
use.

221
00:10:18,300 --> 00:10:20,800
Sorry to keep jumping in by just want to make sure I get all the stuff

222
00:10:20,800 --> 00:10:21,100
out there.

223
00:10:21,100 --> 00:10:27,000
So when you say lends itself to fast iteration, so obviously if these

224
00:10:27,000 --> 00:10:29,800
tags are stored as separate files or you know, fairly

225
00:10:29,900 --> 00:10:30,800
Separate files in some way.

226
00:10:30,800 --> 00:10:35,300
Then you know yes I can overwrite that file with a new file or

227
00:10:35,300 --> 00:10:35,800
overwrite.

228
00:10:35,800 --> 00:10:38,200
The memory version by saying, hey, there's here's a new pointer to 1

229
00:10:38,200 --> 00:10:42,100
but the dependency fix up process.

230
00:10:42,100 --> 00:10:45,800
Now every time you change that, anyone who was pointing it to the

231
00:10:45,800 --> 00:10:49,200
previous one, has to point to the new one is that just kind of

232
00:10:49,200 --> 00:10:52,100
systemically built into the system so it has a generic way of just hey

233
00:10:52,100 --> 00:10:56,800
walk the metadata get rid of everything you had that was like down

234
00:10:56,800 --> 00:10:59,200
from this or something and bring it back around.

235
00:10:59,200 --> 00:10:59,900
Or can you can you

236
00:11:00,100 --> 00:11:02,600
Say a little bit about that works, maybe never implanted when these

237
00:11:02,600 --> 00:11:06,400
before fright, that systemic in our engine we call it a handle system

238
00:11:06,400 --> 00:11:06,900
basically.

239
00:11:07,000 --> 00:11:12,100
So in our engine we don't allow people to have pointers to pretty much

240
00:11:12,100 --> 00:11:12,400
anything.

241
00:11:12,400 --> 00:11:16,900
We don't use like a smart pointer of reference counting system if you

242
00:11:17,300 --> 00:11:17,700
are.

243
00:11:17,800 --> 00:11:20,500
You know, a logical unit of data and you have a reference to something

244
00:11:20,500 --> 00:11:23,300
else anywhere else in the engine memory space that's always done

245
00:11:23,300 --> 00:11:24,100
through a handle.

246
00:11:24,200 --> 00:11:27,300
So it's a double dereference soda reference to a table and the table

247
00:11:27,300 --> 00:11:28,900
contains the pointer and then you go and get that.

248
00:11:29,200 --> 00:11:29,800
And so

249
00:11:30,000 --> 00:11:34,400
you can swap out any piece of data at the structural level by

250
00:11:34,400 --> 00:11:36,700
switching, the pointer in the handle table and know that everybody's

251
00:11:36,700 --> 00:11:37,900
pointing to it is going to get.

252
00:11:37,900 --> 00:11:38,300
I see.

253
00:11:38,600 --> 00:11:41,300
So that's kind of a core principle of the Halo Mission or something is

254
00:11:41,300 --> 00:11:42,100
carried forward.

255
00:11:44,000 --> 00:11:46,600
So, if you talk about again, I talked about the Halo development

256
00:11:46,600 --> 00:11:49,000
build, you can change things quickly so I can artists the scribbling

257
00:11:49,000 --> 00:11:49,800
on a texture.

258
00:11:50,000 --> 00:11:52,800
There's an automatic process that is looking to see when the Photoshop

259
00:11:52,800 --> 00:11:53,800
file is saved.

260
00:11:53,800 --> 00:11:57,000
And then like runs the texture, importer generates the one filed one

261
00:11:57,000 --> 00:11:59,700
Falco's across the development machine gets reloaded, so that was

262
00:11:59,700 --> 00:11:59,800
nice.

263
00:12:00,100 --> 00:12:04,500
I just really like that and that works on the target Xbox, right?

264
00:12:04,500 --> 00:12:06,900
So they can see it on the actual exactly.

265
00:12:06,900 --> 00:12:08,600
Has it will be when the person plays it.

266
00:12:08,600 --> 00:12:08,900
Yes.

267
00:12:09,100 --> 00:12:12,000
But there's a significant problem with this version of the build and

268
00:12:12,000 --> 00:12:15,900
what that is is this is pretty slow startup because you're to go and

269
00:12:15,900 --> 00:12:16,900
seek to all these files.

270
00:12:16,900 --> 00:12:19,300
And so if your game crashes or if you need to reload the level, for

271
00:12:19,300 --> 00:12:22,200
some reason, you're waiting for to 20 minutes for the thing to start,

272
00:12:22,200 --> 00:12:22,500
right?

273
00:12:23,400 --> 00:12:25,400
And so this is all.

274
00:12:25,400 --> 00:12:28,000
Well, I'm just grabbing here is for the original Halo game back in

275
00:12:28,000 --> 00:12:28,700
2001.

276
00:12:29,000 --> 00:12:29,800
So then there's a process.

277
00:12:30,000 --> 00:12:34,000
Is that basically runs the tag, loading recursive procedure, but does

278
00:12:34,000 --> 00:12:37,000
it through a command line application on the PC goes and loads?

279
00:12:37,000 --> 00:12:37,700
All of those things.

280
00:12:37,700 --> 00:12:40,800
So it has the full picture in memory and then it will serialize those

281
00:12:40,800 --> 00:12:44,800
things out into a big contiguous array of data, so that you can just

282
00:12:44,800 --> 00:12:48,400
load the contiguous array happens to be that we had loaded as a single

283
00:12:48,400 --> 00:12:49,600
if read, for example.

284
00:12:49,600 --> 00:12:53,000
So, for a particular level, you have like 15 megabytes of data, you do

285
00:12:53,000 --> 00:12:56,100
an F32 15 megabytes and then it's all in memory.

286
00:12:56,100 --> 00:12:58,400
You sit the pointers in the handle table, you're done.

287
00:12:59,300 --> 00:12:59,500
I see.

288
00:12:59,500 --> 00:12:59,800
So the

289
00:13:00,000 --> 00:13:05,200
The table sort of assume is prime, so we do an F read, we have all the

290
00:13:05,200 --> 00:13:09,200
data now, but now we sort of got this table, we need to fill out.

291
00:13:09,200 --> 00:13:12,400
So presumably, there's large like a header to this that says here are

292
00:13:12,400 --> 00:13:16,100
all the like offsets into the file that you're going to use to like

293
00:13:16,100 --> 00:13:19,000
read, you know, to initialize the handle table to point into this

294
00:13:19,000 --> 00:13:19,300
block.

295
00:13:19,300 --> 00:13:22,900
So you take wherever I loaded in memory, add the, you know, that Base

296
00:13:22,900 --> 00:13:26,500
address to all the addresses in this header and that's my handle table

297
00:13:26,600 --> 00:13:26,800
off.

298
00:13:26,800 --> 00:13:27,200
I go.

299
00:13:27,300 --> 00:13:27,800
Exactly.

300
00:13:27,800 --> 00:13:28,200
Okay.

301
00:13:28,300 --> 00:13:29,800
And that's what I just described there.

302
00:13:29,900 --> 00:13:33,800
Air is not taking any account of like, asynchronous, loading or later,

303
00:13:33,800 --> 00:13:36,300
you know, caches, for various things, you don't want to be Memory

304
00:13:36,300 --> 00:13:38,800
resident all the time, a lot of detail there, that's not super

305
00:13:38,800 --> 00:13:41,600
important and Halo was was doing these things.

306
00:13:41,600 --> 00:13:42,000
Yeah.

307
00:13:42,100 --> 00:13:44,800
So like when you went from one section, the level to another, like

308
00:13:45,000 --> 00:13:48,200
basically there's one pack, which is always loaded for the level.

309
00:13:48,400 --> 00:13:51,100
And there's one that switches out when you move from one area to

310
00:13:51,100 --> 00:13:54,500
another race in which we call to be SP because a binary space

311
00:13:54,500 --> 00:13:55,100
partition.

312
00:13:55,200 --> 00:13:57,500
Okay, so that's like different different.

313
00:13:57,500 --> 00:13:59,000
Like sub Maps, essentially.

314
00:14:00,000 --> 00:14:03,400
We use that structure from Halo one all the way through to Halo Reach.

315
00:14:03,400 --> 00:14:05,300
So everything I described it was kind of the same.

316
00:14:05,300 --> 00:14:07,700
So you have these two different asset formats, right?

317
00:14:07,700 --> 00:14:11,000
You've got the individual tag format, which is super fast iterate on

318
00:14:11,100 --> 00:14:14,600
that super slow to load and game and also doesn't have the final

319
00:14:15,900 --> 00:14:19,300
performance at runtime because a lot of the asynchronous caching and a

320
00:14:19,300 --> 00:14:22,700
lot of the like fitting into memory in the final way doesn't work

321
00:14:22,700 --> 00:14:23,100
here.

322
00:14:23,200 --> 00:14:24,000
Because remember, you're loading.

323
00:14:24,000 --> 00:14:26,700
All of these individual files individual exploded memory allocations.

324
00:14:26,700 --> 00:14:26,900
Yes.

325
00:14:26,900 --> 00:14:28,500
This memory overhead for that.

326
00:14:28,500 --> 00:14:29,800
And so, with the

327
00:14:29,900 --> 00:14:30,900
Xbox development kit.

328
00:14:30,900 --> 00:14:33,100
I mean, when your level gets big enough, you just simply can't load it

329
00:14:33,100 --> 00:14:34,000
anymore, right, right?

330
00:14:34,000 --> 00:14:36,300
Like you can look at me optimize form but you can't load at the

331
00:14:36,300 --> 00:14:37,000
development Forum.

332
00:14:37,100 --> 00:14:39,500
Yes, unless you do stuff like, turn up all the textures and crap with

333
00:14:39,500 --> 00:14:44,700
them got it or you can build these were cold-case files, right?

334
00:14:44,700 --> 00:14:49,300
And so, then the, the case File then can be built and that takes

335
00:14:49,300 --> 00:14:52,700
anywhere from like 5 to 15 minutes for your level, I say.

336
00:14:52,700 --> 00:14:56,000
And then that can run at the shipping performance and it can fit in

337
00:14:56,000 --> 00:14:58,600
memory always because it's the shipping memory format.

338
00:14:59,200 --> 00:14:59,800
But you can't

339
00:15:00,000 --> 00:15:00,500
Hatcher.

340
00:15:00,600 --> 00:15:03,500
So you can't change the texture, you can't like rebalance a vehicle or

341
00:15:03,500 --> 00:15:04,300
anything like that.

342
00:15:04,500 --> 00:15:07,100
So that's what we had sorry again Justice.

343
00:15:07,100 --> 00:15:09,500
I'm going to be the person who's constantly asking for their course

344
00:15:09,500 --> 00:15:10,400
with the decompression.

345
00:15:11,300 --> 00:15:14,300
So, when you say, you can't patch it though, if you have a handle

346
00:15:14,300 --> 00:15:18,700
table still in that optimized version, why couldn't you patch it?

347
00:15:19,300 --> 00:15:21,700
Because since everyone still going through the handle table, couldn't

348
00:15:21,700 --> 00:15:24,100
I just reload the textured patch, the handle table, just like, I

349
00:15:24,100 --> 00:15:27,300
wouldn't even just all the other people are still in that one.

350
00:15:27,300 --> 00:15:29,900
And, yes, eventually I'd run out of memory as I kept.

351
00:15:30,000 --> 00:15:32,900
Adding these patches, but for a little while with that work or about

352
00:15:32,900 --> 00:15:34,500
Miss Winters, you can press, you can do that.

353
00:15:34,600 --> 00:15:37,700
We never built like a general-purpose system to them.

354
00:15:37,800 --> 00:15:40,400
If we built a bunch of really special case systems, which allows you

355
00:15:40,400 --> 00:15:44,000
to do, certain kinds of things like audio mixing or like somatic

356
00:15:44,000 --> 00:15:46,400
control in this optimized version, got it.

357
00:15:46,900 --> 00:15:52,400
But the other reason is because we didn't really have the staff to

358
00:15:52,400 --> 00:15:55,000
maintain like three versions of the game, right?

359
00:15:55,000 --> 00:15:57,600
So we had like the super development version and the kind of like,

360
00:15:57,600 --> 00:15:59,900
shipping final version and we could have

361
00:16:00,000 --> 00:16:03,500
And some time to have like, okay, this is like mostly the memory lay

362
00:16:03,500 --> 00:16:06,100
odds, but then you could also load patches on top that are in the

363
00:16:06,100 --> 00:16:09,500
development format and practice, we stripped all that code out for the

364
00:16:09,500 --> 00:16:10,300
retail version.

365
00:16:10,300 --> 00:16:13,000
As of that is something we could have done if somebody talked about a

366
00:16:13,000 --> 00:16:16,600
various points along the way, but it never really kind of got to be a

367
00:16:16,600 --> 00:16:19,000
trade-off where it was worthwhile from because you're always taking

368
00:16:19,000 --> 00:16:21,000
the resources from somewhere else if you're going to do that.

369
00:16:21,000 --> 00:16:23,800
So you have to kind of go, wait a minute, our level reload time is the

370
00:16:23,800 --> 00:16:26,300
most important part B during development is the most important thing

371
00:16:26,300 --> 00:16:26,400
here.

372
00:16:26,400 --> 00:16:28,900
We're going to pull people off of some other thing they're doing,

373
00:16:28,900 --> 00:16:29,800
which is probably important.

374
00:16:29,900 --> 00:16:31,100
Ain't it never came to that.

375
00:16:31,100 --> 00:16:35,100
So the the twenty second twenty minute turnaround for a full rebuild

376
00:16:35,200 --> 00:16:38,000
was still okay because most of the time people weren't using it.

377
00:16:38,600 --> 00:16:38,800
Yeah.

378
00:16:38,800 --> 00:16:42,600
And generally speaking what would happen is that most of the people

379
00:16:42,600 --> 00:16:46,200
who are working on the game would be using the development version of

380
00:16:46,200 --> 00:16:51,100
the game and they'd be using either like a small shipping level, like

381
00:16:51,100 --> 00:16:52,500
a test level to build their assets.

382
00:16:52,500 --> 00:16:56,400
So, most people who are working like a weapon or a vehicle or like AI

383
00:16:56,400 --> 00:16:58,500
or something, or working the development version, the game that got

384
00:16:58,500 --> 00:16:58,800
fast.

385
00:16:58,800 --> 00:16:59,800
Iteration and also

386
00:16:59,900 --> 00:17:04,000
Pretty fast loading and then the designers and artists who are working

387
00:17:04,000 --> 00:17:06,000
on the final levels of the game.

388
00:17:06,000 --> 00:17:09,599
They're working in the editing tool all the time.

389
00:17:09,599 --> 00:17:12,099
So they're seeing their changes in the editing tool and we had like

390
00:17:12,099 --> 00:17:14,800
editor that actually ran the game within it.

391
00:17:14,800 --> 00:17:18,500
So you could like make all your AI changes on the PC and like play

392
00:17:18,500 --> 00:17:19,200
them in the editors.

393
00:17:19,200 --> 00:17:20,700
He goes super fast iteration there.

394
00:17:20,700 --> 00:17:24,800
Then when you want to see those for real, you would build a cache file

395
00:17:24,800 --> 00:17:27,099
copied across the to your Xbox.

396
00:17:27,099 --> 00:17:29,300
And then that was like fifteen minute process.

397
00:17:29,300 --> 00:17:29,800
But you can still keep

398
00:17:29,900 --> 00:17:31,700
Working on like a winter other things.

399
00:17:32,000 --> 00:17:33,000
So it wasn't terrible.

400
00:17:33,500 --> 00:17:35,300
Basically, everybody could get their jobs done.

401
00:17:35,400 --> 00:17:35,800
Okay.

402
00:17:35,900 --> 00:17:39,200
And one of the things that I think is worth pointing out about this is

403
00:17:39,500 --> 00:17:42,100
like that's a super simple pipeline, right?

404
00:17:42,100 --> 00:17:45,300
Like I can describe that pipeline to you as someone who's not worked

405
00:17:45,300 --> 00:17:47,300
in it in like 14 minutes.

406
00:17:47,400 --> 00:17:47,600
Yeah.

407
00:17:47,600 --> 00:17:49,900
You understand like all the trade-offs about that, pretty much

408
00:17:49,900 --> 00:17:52,200
completely and it's worth pointing out.

409
00:17:52,200 --> 00:17:56,100
There's a lot of value in simple pipelines because now we're going to

410
00:17:56,100 --> 00:17:58,300
talk about what happens when you trust.

411
00:17:58,300 --> 00:17:59,800
So like the Halo

412
00:18:00,000 --> 00:18:03,300
Optimized, for a small set of use cases, right?

413
00:18:03,300 --> 00:18:05,800
Like there're use cases, that work really well.

414
00:18:06,100 --> 00:18:10,600
And then within that use case, you have quite known performance

415
00:18:10,600 --> 00:18:11,300
characteristics.

416
00:18:11,700 --> 00:18:16,100
And there's not a lot of blurriness in between them, they're quite

417
00:18:16,100 --> 00:18:17,400
precise, right?

418
00:18:17,400 --> 00:18:20,000
And so, as a result, you can Target your engineering solution to those

419
00:18:20,000 --> 00:18:21,400
fairly precise use cases.

420
00:18:22,400 --> 00:18:24,800
So now that and that is something we didn't really appreciate.

421
00:18:25,900 --> 00:18:27,400
So now, let's kind of weird.

422
00:18:27,400 --> 00:18:32,100
Moving ahead from United, that's like the 2001 to 2010 timeframe

423
00:18:32,100 --> 00:18:33,200
working in the Halo region, right?

424
00:18:33,900 --> 00:18:36,900
This system kind of like shipped all of these games.

425
00:18:36,900 --> 00:18:39,400
Basically with, you know, presumably additions and modifications on

426
00:18:39,400 --> 00:18:39,600
the way.

427
00:18:39,600 --> 00:18:44,900
But substantially speaking, every Halo game up to reach was shipped on

428
00:18:44,900 --> 00:18:46,600
something that looked pretty much like that.

429
00:18:46,700 --> 00:18:46,900
Yeah.

430
00:18:46,900 --> 00:18:48,700
And I mean, I didn't work on Halo 4.

431
00:18:48,700 --> 00:18:52,100
Halo 5 is my understanding that you have like variance of this.

432
00:18:52,500 --> 00:18:55,800
So it's kind of just like this was a you know which to some extent you

433
00:18:55,800 --> 00:18:58,700
know, proves the point of there's something to simple pipelines.

434
00:18:58,800 --> 00:19:01,600
It keeps working to some degree and you can maybe work with it pretty

435
00:19:01,600 --> 00:19:01,800
well.

436
00:19:01,800 --> 00:19:04,000
If it looks like if it was had that much longevity.

437
00:19:04,000 --> 00:19:07,100
Yeah and this this significant upgrades the you make along the way as

438
00:19:07,100 --> 00:19:11,500
far as like a synchronous file I/O and like loading packs in smaller

439
00:19:11,500 --> 00:19:12,000
forms.

440
00:19:12,000 --> 00:19:15,900
And then, you know, lru cache has for texture and geometry and

441
00:19:15,900 --> 00:19:17,200
animation, and things like that.

442
00:19:17,200 --> 00:19:20,300
So you can like bolt things onto it, but the fundamental fundamentally

443
00:19:20,300 --> 00:19:22,100
if you have a pipeline with good bones,

444
00:19:22,200 --> 00:19:24,000
And you understand that you can do a lot with it.

445
00:19:24,600 --> 00:19:29,100
So if you kind of look around, like, 2008 to 2009 is when we started

446
00:19:29,100 --> 00:19:31,700
working on Destiny in parallel, with all the work that was going on

447
00:19:31,700 --> 00:19:32,200
Halo Reach.

448
00:19:32,200 --> 00:19:35,200
And if you care more about that timeline, you can look at the GDC

449
00:19:35,200 --> 00:19:35,500
talk.

450
00:19:35,500 --> 00:19:36,500
I gave last year about that.

451
00:19:36,600 --> 00:19:36,900
Okay.

452
00:19:37,000 --> 00:19:39,800
But we started working on Destiny.

453
00:19:40,800 --> 00:19:46,300
We were kind of looking at one major problem, which is in Halo, like I

454
00:19:46,300 --> 00:19:49,300
said, you've got these two places you can be and you can be in fast

455
00:19:49,300 --> 00:19:52,100
iteration or you can be in fast.

456
00:19:52,200 --> 00:19:55,900
Loading and really representative console look and performance, right?

457
00:19:55,900 --> 00:19:59,600
But like that's very binary, you can't have both we're like, well, why

458
00:19:59,600 --> 00:20:00,800
not have both, right?

459
00:20:00,800 --> 00:20:04,100
Like, why not just have all of the good parts and none of the bad

460
00:20:04,100 --> 00:20:07,700
parts and so, let's, I mean, it sounds good to me.

461
00:20:07,800 --> 00:20:08,200
Yeah.

462
00:20:08,300 --> 00:20:09,900
Right that's pretty good.

463
00:20:11,000 --> 00:20:12,000
That sounds pretty good.

464
00:20:12,400 --> 00:20:16,300
And so, there's a lot of, there's a lot of less than there are a lot

465
00:20:16,300 --> 00:20:16,800
of different ways.

466
00:20:16,800 --> 00:20:20,100
We talk about that more probably, but so the fundamental idea was

467
00:20:20,100 --> 00:20:20,500
okay.

468
00:20:20,500 --> 00:20:22,100
So why?

469
00:20:22,200 --> 00:20:27,300
I don't we instead of loading these pack files which are really

470
00:20:27,300 --> 00:20:28,200
monolithic.

471
00:20:28,300 --> 00:20:31,800
Let's do some processing of the individual assets.

472
00:20:31,800 --> 00:20:35,300
And then, because we have this handle table, we can just load the

473
00:20:35,300 --> 00:20:36,800
assets individually, right?

474
00:20:36,800 --> 00:20:40,600
And then put the Assets in the handle table individually and so you

475
00:20:40,600 --> 00:20:43,200
could say, well we maybe we'll build a pack file.

476
00:20:43,200 --> 00:20:48,800
The first time you build a level and then you make some changes and

477
00:20:48,800 --> 00:20:52,100
then instead of like then basically you'll say okay, so based on

478
00:20:52,200 --> 00:20:55,100
Those changes that you made while you touch these 20 things.

479
00:20:55,300 --> 00:20:57,300
So, we're going to build another pack file that contains those 20

480
00:20:57,300 --> 00:20:57,900
things.

481
00:20:58,200 --> 00:20:59,800
And then we'll load the base 1 and

482
00:21:00,000 --> 00:21:03,000
Load the second one, that contains those 20 things, those 20 things

483
00:21:03,000 --> 00:21:06,300
will overwrite, and then you'll just have everything and memory.

484
00:21:06,500 --> 00:21:09,800
And so, then you get in this position where you're like, let's build

485
00:21:09,800 --> 00:21:13,900
this, essentially optimized format for the final game and then let's

486
00:21:13,900 --> 00:21:15,600
build it over and over again.

487
00:21:15,600 --> 00:21:18,900
And each time only output the things that changed and then the game

488
00:21:18,900 --> 00:21:22,600
can just load like a series of patches and then you'll be in a

489
00:21:22,600 --> 00:21:26,700
situation where the game can load almost the final shipping speed.

490
00:21:27,400 --> 00:21:29,900
When everything is loaded, it is in 100%.

491
00:21:30,000 --> 00:21:32,100
And the final shipping memory configuration.

492
00:21:32,400 --> 00:21:35,100
And also, you can change individual assets.

493
00:21:35,600 --> 00:21:35,900
Like that.

494
00:21:35,900 --> 00:21:36,700
Sounds awesome.

495
00:21:37,800 --> 00:21:43,900
So essentially what you're saying, people are reacting already just at

496
00:21:43,900 --> 00:21:45,000
the tone of voice.

497
00:21:45,000 --> 00:21:45,500
Yes.

498
00:21:45,500 --> 00:21:46,600
What is that awesome?

499
00:21:46,700 --> 00:21:47,200
Yeah.

500
00:21:48,600 --> 00:21:53,900
So so essentially what you're doing here is sort of making, you know,

501
00:21:54,200 --> 00:21:57,400
the the development time version of almost what you would do if you're

502
00:21:57,400 --> 00:21:59,100
patching the game in reality, right?

503
00:21:59,100 --> 00:21:59,800
It's like, hey

504
00:22:00,000 --> 00:22:04,200
We shipped the end-user a version of Destiny later on.

505
00:22:04,200 --> 00:22:07,200
We find we need to make some edits to some helmets or something that

506
00:22:07,200 --> 00:22:11,500
people were wearing so we ship this new piece of information out, you

507
00:22:11,500 --> 00:22:14,400
know, it goes out as a steam update or whoever but as I guess you

508
00:22:14,400 --> 00:22:18,000
know, in the console world out of steam up there, it goes out as

509
00:22:18,200 --> 00:22:20,500
whatever you would call the updates on consoles.

510
00:22:20,500 --> 00:22:22,900
I don't know if they have the vehicle updates actually, okay.

511
00:22:25,400 --> 00:22:29,800
It goes out as an update and these updates are, you know, you

512
00:22:29,900 --> 00:22:34,300
you have no ability to go say, oh, I want to send you a different

513
00:22:34,300 --> 00:22:36,800
huge, you know, 10 gigabyte file or something.

514
00:22:36,800 --> 00:22:39,600
So, your by necessity sending these smaller ones, so you're just

515
00:22:39,600 --> 00:22:43,300
saying, let's just do that during development and make that be the way

516
00:22:43,300 --> 00:22:43,700
the system works.

517
00:22:43,700 --> 00:22:44,600
That's exactly right.

518
00:22:44,600 --> 00:22:47,500
And that's like another thing we should talk about different Halo and

519
00:22:47,500 --> 00:22:48,300
Destiny here, right?

520
00:22:48,300 --> 00:22:51,300
Is that in Halo is talked about how you build this essentially, a

521
00:22:51,300 --> 00:22:52,200
memory image, right?

522
00:22:52,200 --> 00:22:54,200
That has everything all flattened down of the memory image.

523
00:22:54,200 --> 00:22:57,400
And so there's a lot of stuff in there that's like offset and the

524
00:22:57,400 --> 00:22:59,900
memory image and so suppose you

525
00:23:00,000 --> 00:23:03,700
Want to come along and say, hey, like the designers thought this

526
00:23:03,700 --> 00:23:08,200
weapon like fired too fast and so they want to reduce the fire rate of

527
00:23:08,200 --> 00:23:08,800
this weapon.

528
00:23:08,900 --> 00:23:12,700
Okay, well, so maybe if that's just like poking, a few numbers in one

529
00:23:12,700 --> 00:23:14,500
location, you can do that, right?

530
00:23:14,500 --> 00:23:17,900
And then you can find a way and in practice, it turns out the best way

531
00:23:17,900 --> 00:23:20,900
to do that in Halo was actually to write like a piece of code in the

532
00:23:20,900 --> 00:23:25,900
executable that was like after you load the hold map like go find the

533
00:23:25,900 --> 00:23:29,200
fire rate and change it from 20 to 15 or something about it.

534
00:23:29,200 --> 00:23:29,800
And we shipped

535
00:23:29,900 --> 00:23:32,500
Weapon rebalancing for Halo 2 like that, for example.

536
00:23:32,500 --> 00:23:35,800
So you patch the executable not the actual data.

537
00:23:35,800 --> 00:23:37,700
For those changes, for those kinds of changes.

538
00:23:37,700 --> 00:23:38,900
That's how we did it in.

539
00:23:38,900 --> 00:23:41,200
Like the in, almost all cases in Halo.

540
00:23:41,200 --> 00:23:45,500
And when we most of our updates to Halo took the form of downloadable

541
00:23:45,500 --> 00:23:48,900
content, which is like entirely new memory images for like multiplayer

542
00:23:48,900 --> 00:23:52,400
maps and stuff like that, we didn't even really have the desire or

543
00:23:52,400 --> 00:23:55,500
ability to go in and change the single player game or like, a random

544
00:23:55,500 --> 00:23:55,700
stuff.

545
00:23:55,700 --> 00:23:56,100
Right.

546
00:23:56,400 --> 00:23:59,600
And so, hopefully you see like why?

547
00:23:59,600 --> 00:23:59,800
That is

548
00:24:00,000 --> 00:24:02,900
It's like if you want to change a weapon or like, actually I wanted to

549
00:24:02,900 --> 00:24:04,200
add some effects of that.

550
00:24:04,400 --> 00:24:08,000
So you're like, adding a reference to some other asset and then that

551
00:24:08,000 --> 00:24:10,300
like reference is a string, which is variable length.

552
00:24:10,300 --> 00:24:11,300
So gets packed in there.

553
00:24:11,300 --> 00:24:15,400
And then that thing relatively 200 bytes is now 248 B.

554
00:24:15,900 --> 00:24:18,200
And then how do you like do that?

555
00:24:18,200 --> 00:24:23,800
And so the the way you do that is you like basically like have to add

556
00:24:23,800 --> 00:24:27,000
support in the executable for like loading things on the end as it's a

557
00:24:27,000 --> 00:24:29,900
pretty big mess if you don't build it in up front and so

558
00:24:30,000 --> 00:24:32,700
So one of the big constraints but Destiny is we knew we wanted to have

559
00:24:32,800 --> 00:24:36,000
this, you know, ability to update the world arbitrarily.

560
00:24:36,200 --> 00:24:39,300
So again another thing that leads into that is saying let's build a

561
00:24:39,300 --> 00:24:41,900
model that's around patching, an arbitrary updates.

562
00:24:43,200 --> 00:24:43,800
So

563
00:24:45,400 --> 00:24:48,400
And I think just the stuff I described there like this does not

564
00:24:48,400 --> 00:24:49,800
anything really wrong with that.

565
00:24:49,800 --> 00:24:53,000
But you have to think very carefully about some of these

566
00:24:55,300 --> 00:24:56,200
Like philosophical.

567
00:24:56,200 --> 00:24:58,300
Structural pipeline decisions, right?

568
00:24:58,600 --> 00:25:02,000
And so one of the assumptions that I say them there, I don't have

569
00:25:02,000 --> 00:25:02,700
anybody caught it.

570
00:25:02,700 --> 00:25:06,300
Is this the Assumption there that is people are still fundamentally

571
00:25:06,300 --> 00:25:07,000
doing the same thing.

572
00:25:07,000 --> 00:25:11,000
They were doing in the Halo engine, which is they are wanting to view

573
00:25:11,000 --> 00:25:15,200
their content on Xbox or Playstation and they're working on their PC.

574
00:25:15,300 --> 00:25:17,500
And then they want to, like, see it synced across the Xbox or

575
00:25:17,500 --> 00:25:21,000
PlayStation that assumption underlay all of the pipeline, it turned

576
00:25:21,000 --> 00:25:22,100
out the completely wrong.

577
00:25:22,400 --> 00:25:24,900
Okay, because what actually happens between you know,

578
00:25:25,100 --> 00:25:36,200
2005 and 2012 is that the development PC, workstations, converged a

579
00:25:36,200 --> 00:25:39,600
lot more to the capabilities of the console's, right?

580
00:25:39,700 --> 00:25:41,800
Like think about back in 1999, right?

581
00:25:41,800 --> 00:25:45,000
You have the original Xbox and you have like your PC or Mac that

582
00:25:45,000 --> 00:25:47,700
you're doing a development on if you want to see what it's really

583
00:25:47,700 --> 00:25:50,100
going to look like in the final game rendering, you really have to

584
00:25:50,100 --> 00:25:52,500
render that on the PlayStation because it's a sorry on the Xbox

585
00:25:52,500 --> 00:25:54,900
because you know you've got your Envy to a chip

586
00:25:55,000 --> 00:25:58,300
and like all the custom blend units and I'd like your programming it

587
00:25:58,300 --> 00:25:59,200
with a graphics API.

588
00:25:59,200 --> 00:26:03,000
That doesn't exist anywhere on the PC at all and so you have to see

589
00:26:03,000 --> 00:26:04,300
everything on the target platform.

590
00:26:04,600 --> 00:26:08,600
You know, today almost every game team everywhere in the world does

591
00:26:08,600 --> 00:26:11,700
almost all of their work on PC and then sees it in an almost

592
00:26:11,700 --> 00:26:14,900
representative format on the PC because there's been such

593
00:26:14,900 --> 00:26:18,200
commoditization of the platforms that you know, maybe you're not on a

594
00:26:18,200 --> 00:26:18,800
single platform.

595
00:26:18,800 --> 00:26:21,900
Like Halo, maybe you're on like five platforms and you like even if

596
00:26:21,900 --> 00:26:24,900
you're doing a mobile game, your maybe simulating your iPhone and like

597
00:26:25,200 --> 00:26:27,300
Window on the screen that you're clicking on, right?

598
00:26:28,000 --> 00:26:28,500
So,

599
00:26:30,900 --> 00:26:33,900
That totally changes everything, because the performance

600
00:26:33,900 --> 00:26:37,300
characteristics of data loading on the PC or totally different

601
00:26:37,300 --> 00:26:40,200
performance characteristics data, loading on, you know, the original

602
00:26:40,200 --> 00:26:41,300
Xbox, right?

603
00:26:41,300 --> 00:26:46,500
And so there's much less reason for you to try and build these packed

604
00:26:46,500 --> 00:26:47,000
files.

605
00:26:48,200 --> 00:26:51,600
The other thing to consider is that on a console?

606
00:26:51,700 --> 00:26:55,000
You are trying to squeeze every single byte of memory, right?

607
00:26:55,000 --> 00:26:57,900
So think about Xbox 360, or for us the long pole is really hit

608
00:26:57,900 --> 00:26:59,100
PlayStation 3, right?

609
00:26:59,200 --> 00:26:59,800
So the you

610
00:27:00,000 --> 00:27:04,600
To squeeze every byte of memory out of the PlayStation 3, then you

611
00:27:04,600 --> 00:27:08,800
have to do a really large amount of data transformation to get from

612
00:27:08,800 --> 00:27:12,000
your Source assets into what the most optimal thing is, is the most

613
00:27:12,000 --> 00:27:15,100
optimal thing room in the Halo engine, like the source format and the

614
00:27:15,100 --> 00:27:17,300
engine format, we're constrained to be the same thing.

615
00:27:17,300 --> 00:27:17,600
Correct?

616
00:27:17,600 --> 00:27:20,000
Because there's a header file that is like, here's what the data is

617
00:27:20,000 --> 00:27:21,300
going to be in the engine.

618
00:27:21,500 --> 00:27:23,600
And then also that's what's on disk.

619
00:27:24,100 --> 00:27:26,600
So one of the things we identified as hey, like we're looking at

620
00:27:26,600 --> 00:27:28,100
PlayStation 3, like

621
00:27:29,200 --> 00:27:34,100
We're going to have to do crazy things, like transform your model into

622
00:27:34,100 --> 00:27:38,100
spu programs, that like patch two constants for the shaders.

623
00:27:38,100 --> 00:27:41,900
Because that's the only way you can ship like a really detailed game

624
00:27:42,000 --> 00:27:46,700
on this like crazy architecture about how crazy the sellers.

625
00:27:48,500 --> 00:27:51,600
Well, I'm actually the not a particularly cell knowledgeable person

626
00:27:51,600 --> 00:27:56,400
but I can understand like, essentially, if you're talking about PS3

627
00:27:56,400 --> 00:27:58,000
that's kind of before the break-in,

628
00:27:58,700 --> 00:28:01,900
And sort of how consoles looked in terms of their similarity PC and

629
00:28:01,900 --> 00:28:04,600
then just after, so if you have to reach back down in there, it does

630
00:28:04,600 --> 00:28:07,500
seem like the kind of thing where you're talking about a very

631
00:28:07,500 --> 00:28:11,100
radically different data format probably than anything you would ship

632
00:28:11,100 --> 00:28:11,800
normally.

633
00:28:12,000 --> 00:28:18,800
I assume that that is you know something that you I guess knew going

634
00:28:18,800 --> 00:28:21,800
into it or did you not like was it was just something that was sort of

635
00:28:21,800 --> 00:28:25,100
like visible to you like oh we're going to have to have different PS3

636
00:28:25,500 --> 00:28:28,400
data packs for versus are other things or this

637
00:28:28,600 --> 00:28:30,600
Something that like kind of, you know, in the back of your head but

638
00:28:30,600 --> 00:28:34,000
weren't really focused on as like, oh man we got to pay attention.

639
00:28:34,000 --> 00:28:36,700
This this is something we knew up front and so we thought we were

640
00:28:36,700 --> 00:28:38,100
being extremely smart here.

641
00:28:38,100 --> 00:28:38,500
Okay.

642
00:28:38,500 --> 00:28:41,800
So you tell me, okay, yes, fact that we said like all right so if you

643
00:28:41,800 --> 00:28:45,000
look at other engines, like for example, you know, look at Unreal

644
00:28:45,000 --> 00:28:46,700
Engine 3 in this timeframe, right?

645
00:28:46,700 --> 00:28:50,200
Like Unreal Engine 3, people are working on the PC like they're their

646
00:28:50,200 --> 00:28:50,700
asset film.

647
00:28:50,700 --> 00:28:52,800
At the source format is pretty close to what they're editing and what

648
00:28:52,800 --> 00:28:55,400
they're seeing in the editor and they can't really see.

649
00:28:55,400 --> 00:28:58,500
Like necessarily something that's super representative of the console.

650
00:28:59,100 --> 00:29:02,800
And also there's a really long cook stage where they go from, like

651
00:29:02,800 --> 00:29:05,700
what they can see in the editor down to, what's on the console right

652
00:29:05,700 --> 00:29:05,900
there.

653
00:29:05,900 --> 00:29:08,900
Like we want to avoid having a really long cook stage because we want

654
00:29:08,900 --> 00:29:11,200
to be really incremental on the target platform.

655
00:29:11,600 --> 00:29:17,000
So, we built the whole Destiny asset pipeline around the problem of

656
00:29:17,300 --> 00:29:21,400
how can an artist be working on the PlayStation 3 and like, see a

657
00:29:21,400 --> 00:29:26,800
totally final totally performant version of their content as quickly

658
00:29:26,800 --> 00:29:28,500
as possible from what they're doing on the

659
00:29:28,600 --> 00:29:29,500
EC got it.

660
00:29:29,700 --> 00:29:31,700
And that turned out to be exactly the wrong problem.

661
00:29:31,700 --> 00:29:36,300
To solve got it because the, because there's such a lot of data

662
00:29:36,300 --> 00:29:39,000
transformation going on in that pipeline from like your Source,

663
00:29:39,000 --> 00:29:42,300
formats have to be organized for editing and your engine formats on

664
00:29:42,300 --> 00:29:46,000
like the console have to be completely squished down for memory.

665
00:29:46,200 --> 00:29:48,900
And so there's a really big data transformation that has to happen

666
00:29:48,900 --> 00:29:49,200
there.

667
00:29:49,700 --> 00:29:54,200
And we said, let's put that data transformation in the critical path

668
00:29:54,200 --> 00:29:56,000
through what we call the edit to view pipe.

669
00:29:56,000 --> 00:29:56,400
Okay?

670
00:29:57,000 --> 00:29:57,600
Brecht.

671
00:29:58,100 --> 00:29:58,500
And

672
00:29:58,600 --> 00:29:59,900
if we put that in the critical path,

673
00:30:00,000 --> 00:30:02,700
That means we have to make it fast and then we'll only have one

674
00:30:02,700 --> 00:30:05,600
pipeline to maintain and that'll be good, but it does.

675
00:30:05,600 --> 00:30:08,100
I guess, you know, I guess the corollary to that is just that well.

676
00:30:08,100 --> 00:30:08,700
Okay.

677
00:30:08,800 --> 00:30:12,300
That will, if that always has to be fast, there will eventually be

678
00:30:12,300 --> 00:30:12,500
things.

679
00:30:12,500 --> 00:30:15,700
We maybe can't even do for data Transformations because they simply

680
00:30:15,700 --> 00:30:18,800
can't be done fast enough for this iteration, but that be a fair

681
00:30:18,800 --> 00:30:21,900
characterization or that is a fair characterization and this is where

682
00:30:21,900 --> 00:30:22,900
you get into like launch.

683
00:30:22,900 --> 00:30:24,400
Team problems is really interesting.

684
00:30:24,600 --> 00:30:28,900
Like if you have got a team and you've divided up your team kind of

685
00:30:28,900 --> 00:30:29,900
based on

686
00:30:30,000 --> 00:30:30,500
Realization.

687
00:30:30,500 --> 00:30:34,000
Let's know which is something that you do in any team over about 15

688
00:30:34,000 --> 00:30:34,200
people.

689
00:30:34,200 --> 00:30:35,400
Like there's always specialization.

690
00:30:35,400 --> 00:30:38,800
So what happens is that you have like here, the people working on

691
00:30:38,800 --> 00:30:41,800
like, say graphics features and here are the people working on, let's

692
00:30:41,800 --> 00:30:43,300
say like asset pipeline, right?

693
00:30:44,800 --> 00:30:47,300
Your incentives are not aligned across those engineering teams.

694
00:30:47,400 --> 00:30:49,600
I see if you are working on graphics features.

695
00:30:51,000 --> 00:30:55,100
You the natural way to think about that is I'm going to make the best

696
00:30:55,100 --> 00:30:56,200
looking Graphics, right?

697
00:30:56,200 --> 00:30:58,300
And the most performant Graphics, I'm gonna get the most things on

698
00:30:58,300 --> 00:30:59,800
screen and

699
00:31:00,000 --> 00:31:03,800
I'm going to make it look as beautiful as possible because that's what

700
00:31:03,800 --> 00:31:04,600
my artists will tell me.

701
00:31:04,600 --> 00:31:06,900
They valued my artists will always say, like I want it to be

702
00:31:06,900 --> 00:31:07,500
beautiful.

703
00:31:07,600 --> 00:31:10,500
I want all these features you'll never stop asking for more features

704
00:31:10,500 --> 00:31:14,500
and so you just want to like Ramen the most graphics features as

705
00:31:14,500 --> 00:31:15,100
possible.

706
00:31:15,300 --> 00:31:19,000
And that means the most tightly optimized platform Target format and

707
00:31:19,000 --> 00:31:23,400
then very often the time you're building these features, you're not

708
00:31:23,400 --> 00:31:25,200
working hand in hand with a huge art team.

709
00:31:25,200 --> 00:31:26,700
Like maybe you're working with one artist.

710
00:31:26,700 --> 00:31:29,300
All right thing and there, Larry or prototyping artist is sort of

711
00:31:29,300 --> 00:31:29,800
there to help.

712
00:31:29,900 --> 00:31:32,600
Up guide that process contest content or something.

713
00:31:32,700 --> 00:31:37,300
And so, you make these decisions very early about, like here's the

714
00:31:37,300 --> 00:31:39,000
data format, here's how it's coupled together.

715
00:31:39,000 --> 00:31:41,900
And you're like, I'm going to optimize for artists ease of use in the

716
00:31:41,900 --> 00:31:46,100
editing program, and like a really natural way for the sources be

717
00:31:46,100 --> 00:31:48,200
coupled together where they don't have to, like, type.

718
00:31:48,200 --> 00:31:53,700
The same thing thing in three places and that I really like, beautiful

719
00:31:53,700 --> 00:31:55,200
visual editor for shaders.

720
00:31:55,200 --> 00:31:55,600
Maybe.

721
00:31:55,600 --> 00:31:59,200
And then also like it breaks down to this hyper optimized format on

722
00:31:59,200 --> 00:31:59,800
the PlayStation.

723
00:32:00,000 --> 00:32:02,500
You can like, squeeze out stuff and make like a really beautiful

724
00:32:02,500 --> 00:32:03,200
PlayStation game.

725
00:32:03,800 --> 00:32:08,900
So what I just described there is a source format that is intuitive

726
00:32:08,900 --> 00:32:15,100
and expressive meaning that changes in one place have to affect

727
00:32:15,100 --> 00:32:16,400
Behavior, other places.

728
00:32:17,500 --> 00:32:20,800
And like a lot of really intense runtime optimization.

729
00:32:21,000 --> 00:32:22,800
So to give you a specific example there,

730
00:32:25,100 --> 00:32:27,600
I'm going to get the details of this wrong but hopefully now you guys

731
00:32:27,600 --> 00:32:28,500
will call me on that.

732
00:32:30,000 --> 00:32:35,100
Think about the problem of having a crate that's glowing.

733
00:32:35,300 --> 00:32:35,600
Okay.

734
00:32:35,600 --> 00:32:36,000
Okay.

735
00:32:36,100 --> 00:32:40,200
And the glowing - of the crate it depends on its Health like maybe if

736
00:32:40,200 --> 00:32:41,600
you shoot it's going to explode.

737
00:32:41,700 --> 00:32:42,000
Okay.

738
00:32:42,000 --> 00:32:45,400
Okay and so it glows more and close more and then it explodes.

739
00:32:45,400 --> 00:32:47,600
This sounds like a perfect thing for Old Men Marie.

740
00:32:49,700 --> 00:32:52,300
We have a large number of Science Fiction alien crates in there stood

741
00:32:52,300 --> 00:32:54,300
out so

742
00:32:55,700 --> 00:32:59,600
Okay, so we're saying it's all right, I have in game data.

743
00:33:00,100 --> 00:33:04,300
This Dynamic so this crate has some hitpoint or something that's you

744
00:33:04,300 --> 00:33:05,600
know, decreasing or whatever.

745
00:33:06,000 --> 00:33:09,500
And then I have some artist-driven effect that they have created or

746
00:33:10,100 --> 00:33:12,900
are going to author or want to tie into a Shader or something that

747
00:33:12,900 --> 00:33:15,000
needs to wire that up essentially.

748
00:33:15,000 --> 00:33:18,300
So that the dynamic piece of State goes into a system that allows them

749
00:33:18,300 --> 00:33:22,400
to say the glow is based on the, you know, the hit points or something

750
00:33:22,400 --> 00:33:23,500
this effect, exactly.

751
00:33:23,500 --> 00:33:23,800
Okay.

752
00:33:23,900 --> 00:33:29,100
And the destiny and the destiny model, the information that is exposed

753
00:33:29,100 --> 00:33:29,800
by objects.

754
00:33:30,000 --> 00:33:32,600
That can be looked at by other objects, or looked at by shaders.

755
00:33:32,600 --> 00:33:34,200
What have you is called a channel, okay?

756
00:33:34,500 --> 00:33:38,200
So an object will expose some number of named channels of information

757
00:33:38,200 --> 00:33:41,800
and complicated object, like the player might have, you know, 120

758
00:33:41,800 --> 00:33:44,500
channels on it or a simple object, like a crate.

759
00:33:44,500 --> 00:33:48,000
Maybe only has like five channels, like it's velocity and it's health

760
00:33:48,000 --> 00:33:48,900
or something like that.

761
00:33:49,200 --> 00:33:53,400
And so, in the source data, what you are doing is here, like, in the

762
00:33:53,400 --> 00:33:58,700
Shader editor, your like wire up, this Shader input to the channel,

763
00:33:58,700 --> 00:33:59,700
which is health

764
00:34:00,700 --> 00:34:01,200
That's cool.

765
00:34:01,500 --> 00:34:06,800
Yeah, so you've created a dependency bear between that shaders Source

766
00:34:06,800 --> 00:34:11,300
data and in practice, like in the object system, we have a component

767
00:34:11,300 --> 00:34:14,699
based object system, so like one of the components is exposing like a

768
00:34:15,300 --> 00:34:16,900
health Channel and that's great.

769
00:34:16,900 --> 00:34:19,900
Like you could in some sense of where you're saying there is though

770
00:34:19,900 --> 00:34:23,300
you have a data to code dependency in a sense, write it.

771
00:34:23,300 --> 00:34:25,500
In other words that we say the optic system.

772
00:34:25,699 --> 00:34:29,199
Are you talking about the fact that the actual C++ code expose this?

773
00:34:29,199 --> 00:34:30,100
Or is it more like know?

774
00:34:30,100 --> 00:34:30,300
There's

775
00:34:30,400 --> 00:34:33,900
There's another data piece over here that said like, add an integer

776
00:34:33,900 --> 00:34:35,300
here that's like hit points.

777
00:34:35,699 --> 00:34:39,600
So yes, they're C++ code but it's actually cos code.

778
00:34:39,600 --> 00:34:43,100
That's doing a generic thing for properties of objects and things like

779
00:34:43,100 --> 00:34:43,500
this.

780
00:34:44,400 --> 00:34:47,400
I'm sorry if I praise that poorly but I do know what I'm mostly

781
00:34:47,400 --> 00:34:51,000
talking about is data to data dependency, okay?

782
00:34:51,400 --> 00:34:54,100
Because so now let me rewind like you know, 20 minutes or something.

783
00:34:54,100 --> 00:34:56,199
I was talking about about the tax system, right?

784
00:34:56,300 --> 00:35:00,300
Like one of the properties the tax system had in Halo is if you have a

785
00:35:00,400 --> 00:35:05,600
Allure piece of data and then it can be edited and then it can be

786
00:35:05,600 --> 00:35:07,800
reloaded, just that one piece of data, right?

787
00:35:07,800 --> 00:35:12,100
And so that's a constraint that you place on the overall pipeline is

788
00:35:12,400 --> 00:35:15,000
any individual piece of data can be edited.

789
00:35:15,100 --> 00:35:18,600
And then that one thing can be reloaded and it's a bug.

790
00:35:18,600 --> 00:35:20,000
If you have a crash the artist right?

791
00:35:20,000 --> 00:35:21,900
You kind of across the are displayed as one piece of data.

792
00:35:22,200 --> 00:35:26,800
So what that means is as a programmer, you can't introduce structural

793
00:35:26,800 --> 00:35:28,800
dependencies between pieces of data.

794
00:35:29,800 --> 00:35:30,400
Okay.

795
00:35:32,100 --> 00:35:38,300
Because so, for example, you couldn't in the Halo engine, you can't

796
00:35:38,300 --> 00:35:41,200
write some code that's like in the object.

797
00:35:41,700 --> 00:35:47,500
I know in the code that reads the object tag that shaders are looking

798
00:35:47,500 --> 00:35:50,200
at the health Channel while they're not looking at the health Channel

799
00:35:50,400 --> 00:35:52,800
because you don't know because that's not a different piece of data

800
00:35:52,900 --> 00:35:55,200
and that could be loaded or reload independently, right?

801
00:35:55,200 --> 00:35:57,600
And so you can't write code.

802
00:35:57,900 --> 00:35:59,900
That says, look at all the channels.

803
00:36:00,000 --> 00:36:04,300
On the object and then decide which ones are going to get output.

804
00:36:04,300 --> 00:36:08,100
You can't write that code at like asset load time, right?

805
00:36:08,100 --> 00:36:09,700
You can write that at runtime, right?

806
00:36:09,700 --> 00:36:12,000
Can like, analyze all the data that's been loaded and then you can do

807
00:36:12,000 --> 00:36:12,400
that.

808
00:36:12,600 --> 00:36:13,800
And so I see what you're saying.

809
00:36:13,800 --> 00:36:17,000
So basically, we're talking about here is, there's a certain number of

810
00:36:17,000 --> 00:36:20,900
things which, for whatever reason, it could be for optimization

811
00:36:20,900 --> 00:36:21,400
purposes.

812
00:36:21,400 --> 00:36:24,200
It could be for, you know, because we need to Output the correct,

813
00:36:24,200 --> 00:36:25,600
shaders stuff, or whatever.

814
00:36:26,000 --> 00:36:29,800
I'm going to need to look across a graph of data.

815
00:36:30,000 --> 00:36:32,300
Rather than add a particular piece of data.

816
00:36:32,500 --> 00:36:36,000
And because the graph is changing over time.

817
00:36:36,000 --> 00:36:38,500
Because every time we reload, we pull out a piece of it.

818
00:36:38,700 --> 00:36:41,800
We end up in this situation where we kind of have a nasty Problem,

819
00:36:41,800 --> 00:36:46,000
whatever thinking I was doing about this thing that needs to look

820
00:36:46,000 --> 00:36:46,100
over.

821
00:36:46,100 --> 00:36:50,800
The graph is now dependent on the graph, not on a piece of data.

822
00:36:51,300 --> 00:36:53,400
Is that a fair characterization or yes?

823
00:36:53,400 --> 00:36:56,300
Okay, and, and the right way to the right way to think about, this is

824
00:36:56,300 --> 00:36:59,800
to look at the difference between Halo and Destiny is like in Halo.

825
00:37:00,200 --> 00:37:02,400
You really don't have any graph analysis, right?

826
00:37:02,400 --> 00:37:05,400
The only the only graph based thinking is what happens at run time.

827
00:37:05,400 --> 00:37:08,600
Like, after you've loaded everything, you can do some like runtime

828
00:37:08,600 --> 00:37:12,600
query to say, like on the object, look at the five channels, and if

829
00:37:12,600 --> 00:37:15,000
two of them are being used by shaders and update those two, and then

830
00:37:15,000 --> 00:37:18,100
don't update the other ones in Destiny.

831
00:37:18,500 --> 00:37:22,600
So here we get into like kind of the heart of the problem which is you

832
00:37:22,600 --> 00:37:26,200
have this Source data and I've described like a simple form of source

833
00:37:26,200 --> 00:37:26,700
data coupling.

834
00:37:26,700 --> 00:37:29,400
But in practice there's many many more complex kinds of

835
00:37:30,300 --> 00:37:30,700
where,

836
00:37:33,200 --> 00:37:35,700
If you want to run on the PlayStation 3 and you want to have a really

837
00:37:35,700 --> 00:37:39,000
large number of objects and you want to be able to like render all

838
00:37:39,000 --> 00:37:40,600
those objects on spu's.

839
00:37:40,900 --> 00:37:46,400
You are basically trying to avoid like a lot of branchy graph analysis

840
00:37:46,400 --> 00:37:48,600
type work at runtime, right?

841
00:37:48,700 --> 00:37:51,600
Because it can only finesse for you can only focus on the little chunk

842
00:37:51,600 --> 00:37:52,200
that it's given.

843
00:37:52,200 --> 00:37:56,300
So you've got to have everything in that chunk when it winds up for

844
00:37:56,300 --> 00:37:59,000
those of you have not programmed on the PlayStation 3, raise your

845
00:37:59,000 --> 00:37:59,200
hands.

846
00:37:59,200 --> 00:38:00,600
If you have ever written a spu code,

847
00:38:01,900 --> 00:38:05,600
Okay, so like 95% of people have not written as few code on the

848
00:38:05,600 --> 00:38:10,400
PlayStation 3, the spu has got a small area of memory that contains

849
00:38:10,400 --> 00:38:14,300
both its code and data and it's basically running like a little micro

850
00:38:14,300 --> 00:38:14,800
program.

851
00:38:14,900 --> 00:38:15,300
Okay?

852
00:38:15,500 --> 00:38:19,600
And so the only code you can access on the spu as whatever was in that

853
00:38:19,600 --> 00:38:20,600
micro program.

854
00:38:20,900 --> 00:38:23,700
And so if you are running your micro program and you encounter a

855
00:38:23,700 --> 00:38:27,600
situation where you're just like, I would like to run some AI code in

856
00:38:27,600 --> 00:38:28,900
line here or something like that.

857
00:38:28,900 --> 00:38:29,800
You cannot do that.

858
00:38:29,800 --> 00:38:31,500
Like that is not possible unless you

859
00:38:31,700 --> 00:38:34,100
Unlike a virtual memory system on your SP with some people do.

860
00:38:35,700 --> 00:38:39,500
But so what that means is, if you're optimizing for that kind of

861
00:38:39,500 --> 00:38:44,200
processor, you are trying to push as much of your asset analysis into

862
00:38:44,200 --> 00:38:47,700
assets like dependency and building time as possible.

863
00:38:48,200 --> 00:38:51,600
And this is what really fucked us, okay?

864
00:38:51,800 --> 00:38:55,200
Like that's the technical term for it, but there's the technical specs

865
00:38:58,000 --> 00:38:59,900
and we will talk about the slow and gradual.

866
00:39:00,000 --> 00:39:02,000
This is fun fucking okay in a second.

867
00:39:03,000 --> 00:39:07,500
But so you have the situation where you're trying to build the best

868
00:39:07,500 --> 00:39:09,800
and most polished graphics features in the PlayStation 3.

869
00:39:10,100 --> 00:39:13,100
Meaning you're trying to build the most optimized spu programs and

870
00:39:13,100 --> 00:39:14,400
most optimized data formats.

871
00:39:14,800 --> 00:39:18,200
Meaning that you're trying to do a very large amount of asset analysis

872
00:39:18,400 --> 00:39:20,700
at asset import time, okay?

873
00:39:21,200 --> 00:39:26,300
And so as an example, so remember I said like, you have objects, they

874
00:39:26,300 --> 00:39:29,000
have channels some channels might or might not be read by the Shader

875
00:39:29,000 --> 00:39:29,500
croquet.

876
00:39:30,000 --> 00:39:33,700
And so you're going to write an SP you bytecode.

877
00:39:33,800 --> 00:39:35,400
Not like not like the program.

878
00:39:35,400 --> 00:39:38,800
So your spu thing that's running the renderer is like a VM, okay?

879
00:39:39,600 --> 00:39:42,500
Similar to the like what Jeff and Fabiana talking about.

880
00:39:42,800 --> 00:39:46,200
So your sbu bytecode for render as like a VM and some of the

881
00:39:46,200 --> 00:39:49,700
instructions that you can omit in your Shader processing language are

882
00:39:49,700 --> 00:39:53,700
like here's how this channel should be exported to this.

883
00:39:53,700 --> 00:39:55,200
Kind of Shader constant guy.

884
00:39:55,600 --> 00:39:59,900
So part of the process of building your

885
00:40:00,000 --> 00:40:06,200
Act is now building spu bytecode for all of the shaders and all the

886
00:40:06,200 --> 00:40:07,400
channels that are being used.

887
00:40:07,500 --> 00:40:08,000
Correct.

888
00:40:08,000 --> 00:40:13,000
So to build that bytecode program, you have to look at the object data

889
00:40:13,200 --> 00:40:17,300
and also the Shader data for any shaders that are used by that object.

890
00:40:17,600 --> 00:40:21,400
So that there's now like a dependency between all that data and if any

891
00:40:21,400 --> 00:40:23,900
of that data changes you have to rerun that processing.

892
00:40:24,400 --> 00:40:26,300
And that processing is essentially a compiler.

893
00:40:26,300 --> 00:40:29,800
I mean it's trying to produce output Shader, which

894
00:40:29,900 --> 00:40:32,500
Means it, you know, if you want to do optimization, if I do the things

895
00:40:32,500 --> 00:40:36,900
you are talking about trying to make a compiler that you know, does

896
00:40:36,900 --> 00:40:38,100
all the standard things I assume.

897
00:40:38,200 --> 00:40:39,200
Yeah, yeah, exactly.

898
00:40:39,900 --> 00:40:42,100
Although we'll talk about how it's different to a compiler, a little

899
00:40:42,100 --> 00:40:47,900
bit later, the and then there's another level of dependency on there

900
00:40:47,900 --> 00:40:51,800
which is well, you can't just render all the objects and level as

901
00:40:51,800 --> 00:40:54,900
individual objects because you know they you get a huge number of draw

902
00:40:54,900 --> 00:40:56,200
calls and you can't do that.

903
00:40:56,200 --> 00:40:58,000
And so you actually have to bake together.

904
00:40:58,000 --> 00:40:59,800
All the objects that are in like a

905
00:41:00,000 --> 00:41:03,200
Your location together, you have to write some kind of spatial

906
00:41:03,200 --> 00:41:05,700
subdivision program, that's like here all the objects in this chunk of

907
00:41:05,700 --> 00:41:09,500
the level and then I'm going to turn them into like one vertex buffer

908
00:41:09,500 --> 00:41:11,600
and index buffer in one set of shared constants.

909
00:41:11,900 --> 00:41:16,800
And so if you have this like glowing crate on the wall, then the data

910
00:41:16,800 --> 00:41:19,800
optimization problem is not just that one object, it's maybe like

911
00:41:19,800 --> 00:41:23,600
these 500 objects and then all of the shaders used by those 500

912
00:41:23,600 --> 00:41:24,000
objects.

913
00:41:24,000 --> 00:41:24,800
Okay, right.

914
00:41:25,200 --> 00:41:29,800
And then that optimization problem, then is what you have to

915
00:41:29,900 --> 00:41:32,500
Run, anytime the oddest changes.

916
00:41:32,600 --> 00:41:33,700
Any field?

917
00:41:33,700 --> 00:41:36,900
On any one of those shaders or any one of those objects got it?

918
00:41:37,900 --> 00:41:38,300
Yes.

919
00:41:42,700 --> 00:41:43,300
All right.

920
00:41:43,800 --> 00:41:51,400
Do not do not blame Chris, so the nice enough to walk us through it.

921
00:41:51,800 --> 00:41:56,800
So let's so here like everything I'm describing here is all of the

922
00:41:56,800 --> 00:41:59,000
abstract theoretical level, okay?

923
00:41:59,300 --> 00:41:59,800
And so

924
00:42:00,000 --> 00:42:03,100
Just to be really specific about that the abstract theoretical

925
00:42:03,100 --> 00:42:03,500
failure.

926
00:42:03,500 --> 00:42:05,200
We're talking about here is

927
00:42:06,700 --> 00:42:08,900
if you allow,

928
00:42:09,900 --> 00:42:16,400
Some people in the pursuit of Awesomeness to add data dependencies,

929
00:42:17,400 --> 00:42:20,600
without a clear, understanding of the cost of those data dependencies,

930
00:42:21,100 --> 00:42:24,300
you can end up in a situation where all of your data is coupled

931
00:42:24,300 --> 00:42:26,200
together, right?

932
00:42:26,500 --> 00:42:31,200
And transformations to the source data produce.

933
00:42:31,200 --> 00:42:34,200
Essentially unbounded transformations in the output data.

934
00:42:35,400 --> 00:42:36,600
This makes a lot of sense.

935
00:42:36,600 --> 00:42:41,000
So essentially what we're talking about here is, you know, in the

936
00:42:41,000 --> 00:42:44,200
compiler analogy, you are talking about.

937
00:42:44,600 --> 00:42:49,600
If you have a compiler that is trying to optimize for something that

938
00:42:49,600 --> 00:42:51,500
is global to the whole program.

939
00:42:51,700 --> 00:42:54,900
Then that simply means that whatever you change.

940
00:42:55,500 --> 00:42:58,500
It could affect every last piece of code that you compiled.

941
00:42:58,500 --> 00:43:01,400
Like it's like changing a pound to find at that point where it could

942
00:43:01,400 --> 00:43:03,800
Cascades through the entire program and caused everything to have to

943
00:43:03,800 --> 00:43:05,000
be rebuilt and

944
00:43:05,300 --> 00:43:08,900
We have no idea what this could be, because as you start, adding more

945
00:43:09,100 --> 00:43:12,500
of these things that aggregate pieces together for optimization, we

946
00:43:12,500 --> 00:43:16,700
don't even really know what artist could build that could create huge

947
00:43:16,700 --> 00:43:21,000
dependency chains in any particular level for unforeseen reasons.

948
00:43:21,400 --> 00:43:21,700
Yes.

949
00:43:22,000 --> 00:43:29,400
And the other reason that it's bad is because these dependencies they

950
00:43:29,400 --> 00:43:33,200
may seem kind of benign to the individual quite smart engineer who's

951
00:43:33,200 --> 00:43:34,000
working on it, right?

952
00:43:34,000 --> 00:43:35,000
So you have like a

953
00:43:35,200 --> 00:43:37,700
Dependency between this one field in this file and this one field in

954
00:43:37,700 --> 00:43:39,400
this file and that's quite a small dependency.

955
00:43:39,800 --> 00:43:46,700
But the level at which dependencies are tract is often at like file or

956
00:43:46,700 --> 00:43:47,800
asset granularity.

957
00:43:47,900 --> 00:43:48,200
I see.

958
00:43:48,200 --> 00:43:51,400
And so even if it's a tiny dependency like you've just coupled

959
00:43:51,400 --> 00:43:53,000
together two rather large things.

960
00:43:53,400 --> 00:43:56,700
And then as a result of that like it doesn't take very many small

961
00:43:56,700 --> 00:44:00,100
dependencies for everything to become like one Tangled Mass, right?

962
00:44:00,100 --> 00:44:03,900
Because all you need is for any to, we're sort of talking about,

963
00:44:03,900 --> 00:44:04,100
right.

964
00:44:04,100 --> 00:44:05,000
Here's here's a

965
00:44:05,100 --> 00:44:08,900
Raph and we've got some partition of this thing into like disjoint

966
00:44:08,900 --> 00:44:09,600
subsets, right?

967
00:44:09,600 --> 00:44:13,500
These things aren't connected there, you know, things we could pull

968
00:44:13,500 --> 00:44:16,600
out as a chunk that can get processed and updated together.

969
00:44:17,000 --> 00:44:22,000
All I need to do is add one little Edge between one of those two

970
00:44:22,000 --> 00:44:26,000
subsets and now they're, you know, their own connected piece.

971
00:44:26,200 --> 00:44:26,700
That's right.

972
00:44:26,700 --> 00:44:31,000
So it doesn't matter how big that connection is in terms of its

973
00:44:31,000 --> 00:44:33,200
meaning, it just has to be there, right?

974
00:44:33,800 --> 00:44:35,000
And so this is something.

975
00:44:35,200 --> 00:44:38,600
That we didn't really appreciate and we kind of just like walked into

976
00:44:38,600 --> 00:44:39,000
this.

977
00:44:39,200 --> 00:44:43,700
And so I'll just say one thing about that which is like in general.

978
00:44:43,700 --> 00:44:47,200
If you can identify these dependencies, it is possible to remove them.

979
00:44:47,500 --> 00:44:52,800
And the way that you remove them is that you identify where you're

980
00:44:52,800 --> 00:44:57,700
going to cut your graph and then you prevent like, literally prevent

981
00:44:57,700 --> 00:44:59,800
anybody from like, walking from

982
00:45:00,000 --> 00:45:03,500
Going across asset to asset boundaries because you have to prevent

983
00:45:03,500 --> 00:45:06,700
people because remember, your engineering team is probably 65 people

984
00:45:06,900 --> 00:45:09,900
and there's maybe one and a half people on that team, who understand

985
00:45:09,900 --> 00:45:11,200
how bad dependencies are.

986
00:45:11,300 --> 00:45:11,700
Okay.

987
00:45:11,700 --> 00:45:14,400
And so that's very clear.

988
00:45:14,400 --> 00:45:17,100
Like you hope your team is full of smart people and in fact, our team

989
00:45:17,100 --> 00:45:18,100
is full of smart people.

990
00:45:18,100 --> 00:45:21,400
But like everybody is trying to solve their problem, right?

991
00:45:21,500 --> 00:45:27,000
And the, the easy way to get it done, has to be the right way to get

992
00:45:27,000 --> 00:45:27,300
it done.

993
00:45:27,400 --> 00:45:27,800
Yes.

994
00:45:27,900 --> 00:45:29,800
Otherwise you'll never be able to make progress if

995
00:45:30,000 --> 00:45:32,700
If like only 2% of your stuff dedicated to fixing problems, the other

996
00:45:32,700 --> 00:45:36,200
98% of your staff is narrated to dedicated to just getting a job done.

997
00:45:36,800 --> 00:45:40,800
And in some sense you could just say, well, look, if you know, if an

998
00:45:40,800 --> 00:45:44,800
aspect of our the way this asset system is working, is that all of our

999
00:45:44,800 --> 00:45:47,800
Engineers have to be an expert in the asset system to do their job.

1000
00:45:47,900 --> 00:45:51,200
That's a huge like burden that that's placing on them.

1001
00:45:51,200 --> 00:45:54,900
Essentially like they have to have domain knowledge in this thing that

1002
00:45:54,900 --> 00:45:58,200
really shouldn't have that much to do with their job and now that's

1003
00:45:58,200 --> 00:45:58,800
taking up.

1004
00:45:58,800 --> 00:45:59,900
So even if you

1005
00:46:00,000 --> 00:46:03,400
Make sure everyone knew this, it's a cognitive load, that's costing

1006
00:46:03,400 --> 00:46:03,900
you all the time.

1007
00:46:03,900 --> 00:46:07,300
Anyway, even at that point, what's up stop time for this?

1008
00:46:08,100 --> 00:46:11,500
We are 46 minutes in and we have 90.

1009
00:46:11,600 --> 00:46:14,400
So you have quite use, we have until 1:00.

1010
00:46:14,700 --> 00:46:18,600
Yes, so you don't have any no need to rush although maybe I don't know

1011
00:46:18,600 --> 00:46:22,600
how long the know I think you called it the the the unfuckin process

1012
00:46:22,600 --> 00:46:23,400
will take us.

1013
00:46:23,400 --> 00:46:26,800
So we haven't actually finished going through all the fuckery.

1014
00:46:30,200 --> 00:46:33,200
I think so like unless you have more questions about the theory we

1015
00:46:33,200 --> 00:46:35,800
should probably talk about the practice because the practice is

1016
00:46:35,800 --> 00:46:37,300
actually more interesting than Theory.

1017
00:46:37,400 --> 00:46:40,000
I think the theory sounds fairly straightforward.

1018
00:46:40,000 --> 00:46:42,700
I mean, you could almost describe this separate from anything.

1019
00:46:42,700 --> 00:46:47,200
It's just like, you know, hey if if you need to consider things as

1020
00:46:47,200 --> 00:46:52,400
collections, then you now are, you know, beholden to the number of,

1021
00:46:52,400 --> 00:46:57,100
you know, that the number of sub graphs as that reduces you, you get

1022
00:46:57,100 --> 00:46:57,700
worse, right?

1023
00:46:57,700 --> 00:46:59,800
You just if that goes down to one now,

1024
00:47:00,000 --> 00:47:02,100
Rebuilding the whole game, every change, right?

1025
00:47:02,100 --> 00:47:03,400
Would be one way to say it.

1026
00:47:03,800 --> 00:47:08,200
Whereas what you had in Halo was something very close to every little

1027
00:47:08,200 --> 00:47:11,800
node in the graph is its own rebuildable piece and it will never

1028
00:47:11,800 --> 00:47:13,900
propagate outwards or connect in that way.

1029
00:47:14,000 --> 00:47:15,700
Yep, that's the next thing.

1030
00:47:15,700 --> 00:47:19,100
The next, the last thing to say, on this topic, by the way, is that

1031
00:47:19,500 --> 00:47:22,700
dependencies are pretty straightforward from a theoretical point of

1032
00:47:22,700 --> 00:47:25,200
view to eliminate once you understand what's going on.

1033
00:47:25,200 --> 00:47:26,200
Alright I said that's what.

1034
00:47:26,200 --> 00:47:29,800
Yeah, so like the theory is fine there in practice.

1035
00:47:29,900 --> 00:47:33,900
Once you start having people creating content in these systems, you

1036
00:47:33,900 --> 00:47:37,400
get into situations where it's like, Okay, so we've identified that

1037
00:47:37,400 --> 00:47:41,100
like, the way that shaders and objects relate to each other was just

1038
00:47:41,100 --> 00:47:42,800
like, theoretically wrong, okay?

1039
00:47:43,000 --> 00:47:46,400
To solve that, you have to rebuild every Shader and object in the

1040
00:47:46,400 --> 00:47:47,300
entire game.

1041
00:47:47,500 --> 00:47:49,900
While you also have like, a team of people working on shadows and

1042
00:47:49,900 --> 00:47:50,900
objects, right?

1043
00:47:51,000 --> 00:47:53,500
That's essentially impossible.

1044
00:47:53,600 --> 00:47:54,100
Right.

1045
00:47:54,100 --> 00:47:58,100
It is similar to a city transit project.

1046
00:47:58,100 --> 00:47:59,800
We cannot shut the whole city down.

1047
00:48:00,000 --> 00:48:01,800
Order to put the tunnel through here.

1048
00:48:01,800 --> 00:48:04,300
So we've got to come up with all kinds of crazy things that we're

1049
00:48:04,300 --> 00:48:08,000
going to do drilling under it and having crazy, you know, rerouting

1050
00:48:08,000 --> 00:48:10,900
people and all this sort of thing because there's no other option I

1051
00:48:10,900 --> 00:48:11,200
guess.

1052
00:48:11,900 --> 00:48:12,300
Yeah.

1053
00:48:12,800 --> 00:48:15,700
That's actually like, there's a, some fun analogies there.

1054
00:48:18,500 --> 00:48:18,900
Okay.

1055
00:48:19,100 --> 00:48:19,600
All right.

1056
00:48:19,600 --> 00:48:21,000
So now let's talk about like the practice.

1057
00:48:21,000 --> 00:48:24,700
Okay, alright so we've identified that we started out and this is in

1058
00:48:24,700 --> 00:48:26,900
like 2009 2010, right?

1059
00:48:26,900 --> 00:48:29,500
So you know three or four years before we were planning on shipping

1060
00:48:29,500 --> 00:48:29,800
the game.

1061
00:48:30,000 --> 00:48:34,700
And so we've identified that we, we wanted to have a system where the

1062
00:48:34,700 --> 00:48:37,600
source data can be customized for Autos the in genetic be customized

1063
00:48:37,600 --> 00:48:41,500
for consoles and then there's a process of transforming from Source

1064
00:48:41,500 --> 00:48:42,600
data and the engine data.

1065
00:48:43,100 --> 00:48:49,600
And we've also understood that we did not grasp how important it was

1066
00:48:49,600 --> 00:48:51,400
to establish graph Cuts, right?

1067
00:48:51,500 --> 00:48:51,800
Yes.

1068
00:48:52,100 --> 00:48:58,400
And so we started out by saying, okay, so we

1069
00:48:59,400 --> 00:49:03,900
In Halo had like a large number of different programs.

1070
00:49:03,900 --> 00:49:06,100
Each was transformed one piece of data, right?

1071
00:49:06,100 --> 00:49:09,700
So there was here at the model, compiler, the PSG, here's the Shader

1072
00:49:09,700 --> 00:49:10,400
compiler.

1073
00:49:10,500 --> 00:49:13,700
Here's the triangle stripper, here's the little bsp Butler, okay?

1074
00:49:14,100 --> 00:49:17,000
Every one of those programs had to have its own code for, like, doing

1075
00:49:17,000 --> 00:49:21,600
I/O and, like, paralyzation if there was any, and none of them had any

1076
00:49:21,600 --> 00:49:23,200
dependency tracking, right?

1077
00:49:23,200 --> 00:49:26,500
So, if you are working on a level, you change one tiny, part of the

1078
00:49:26,500 --> 00:49:28,600
level, the DSP Builder wasn't incremental.

1079
00:49:28,600 --> 00:49:29,000
And so you have

1080
00:49:29,200 --> 00:49:29,900
Fill the entire level.

1081
00:49:29,900 --> 00:49:31,800
Any time you moved a rock or something like that.

1082
00:49:32,200 --> 00:49:33,000
Not very good.

1083
00:49:33,200 --> 00:49:39,200
And so we said, okay, so we want parallelism, we want asynchronous I/O

1084
00:49:39,500 --> 00:49:42,300
and we want incremental ISM because we're talking about patching

1085
00:49:42,300 --> 00:49:42,700
everything.

1086
00:49:42,700 --> 00:49:46,300
So we said, let's let's instead of building like a large number of

1087
00:49:46,300 --> 00:49:50,300
small isolated programs, let's build one framework for describing work

1088
00:49:50,300 --> 00:49:51,200
for transformation.

1089
00:49:51,500 --> 00:49:51,900
Okay?

1090
00:49:51,900 --> 00:49:55,100
Okay so essentially this is like almost to some other countries like a

1091
00:49:55,100 --> 00:49:56,200
job system.

1092
00:49:56,200 --> 00:49:56,500
Yeah.

1093
00:49:56,500 --> 00:49:59,000
In multi-threaded game or something like this where we're just saying

1094
00:49:59,100 --> 00:50:01,500
Hey, look, we know we have a number of things we have to do.

1095
00:50:01,500 --> 00:50:03,000
We know these things are dependent on each other.

1096
00:50:03,100 --> 00:50:05,800
We know there's an underlying graph potentially that we have that

1097
00:50:05,800 --> 00:50:07,900
describes the relationships between the data.

1098
00:50:08,200 --> 00:50:10,000
Can we make something systemic here?

1099
00:50:10,000 --> 00:50:13,900
That just allows people to throw something into the system with that

1100
00:50:13,900 --> 00:50:17,500
description, and it will make the right things happen when you do a

1101
00:50:17,500 --> 00:50:18,100
change.

1102
00:50:18,100 --> 00:50:19,000
Exactly, right?

1103
00:50:19,000 --> 00:50:23,600
And so the approach here is to say, let's build a general purpose.

1104
00:50:26,400 --> 00:50:27,500
Work scheduler.

1105
00:50:28,000 --> 00:50:34,000
Which the way that the way that it works is that you have defined some

1106
00:50:34,000 --> 00:50:35,200
number of data formats, right?

1107
00:50:35,200 --> 00:50:38,200
Like some of your data formats are Source formats and they each have a

1108
00:50:38,200 --> 00:50:40,400
particular like structure associated with them.

1109
00:50:40,400 --> 00:50:43,100
Like here's the header file for a model, what have you?

1110
00:50:43,100 --> 00:50:45,500
And some of them are your engine data formats, okay?

1111
00:50:46,000 --> 00:50:52,300
And the granularity that we chose was to say what is a function of

1112
00:50:52,300 --> 00:50:55,600
work that can be performed in a single threaded fashion without doing.

1113
00:50:55,800 --> 00:50:56,200
Nei.

1114
00:50:56,200 --> 00:50:57,400
Oh okay.

1115
00:50:58,000 --> 00:50:58,800
So okay.

1116
00:50:58,800 --> 00:50:59,800
Functional.

1117
00:51:00,000 --> 00:51:04,300
Mission which is idempotent is noguchi like to call it idempotent

1118
00:51:04,300 --> 00:51:04,600
here.

1119
00:51:04,600 --> 00:51:05,900
Means give it the same inputs.

1120
00:51:05,900 --> 00:51:07,900
It'll give you the same outputs every time.

1121
00:51:09,300 --> 00:51:11,800
So basically what you're talking about is this thing you know we're

1122
00:51:11,800 --> 00:51:15,100
going to break it down into pieces where the data has been put into

1123
00:51:15,100 --> 00:51:15,400
memory.

1124
00:51:15,400 --> 00:51:18,900
That this thing will operate on and it will not get self cause new

1125
00:51:18,900 --> 00:51:20,500
data to be pulled in for any reason.

1126
00:51:20,600 --> 00:51:21,300
That's right.

1127
00:51:21,600 --> 00:51:25,500
And so it works on some number of chunks of data and it produces some

1128
00:51:25,500 --> 00:51:26,700
number other chunks of data.

1129
00:51:27,000 --> 00:51:29,900
And it can also produce specifications for other.

1130
00:51:30,000 --> 00:51:31,000
Tasks that need to be rung.

1131
00:51:31,800 --> 00:51:34,700
This is almost exactly like a multi-threaded job system.

1132
00:51:34,700 --> 00:51:36,900
So same basic principles.

1133
00:51:37,700 --> 00:51:38,200
Apply.

1134
00:51:38,300 --> 00:51:38,700
Yeah.

1135
00:51:39,000 --> 00:51:43,800
And so given that you're going to build like some awesome

1136
00:51:43,800 --> 00:51:46,300
multi-threaded like fully asynchronous.

1137
00:51:46,300 --> 00:51:50,600
I/O schedules, like completely deterministic like with caching on this

1138
00:51:50,600 --> 00:51:51,900
granularity system.

1139
00:51:52,600 --> 00:51:55,300
We basically said well since we're going to build this system.

1140
00:51:55,500 --> 00:51:57,700
Let's just make this system, really good, and then make it, do

1141
00:51:57,700 --> 00:51:58,200
everything.

1142
00:52:02,400 --> 00:52:03,500
This is the second time.

1143
00:52:03,500 --> 00:52:07,800
We're, let's make it do everything, it has come up.

1144
00:52:09,100 --> 00:52:09,500
Yeah.

1145
00:52:09,800 --> 00:52:13,300
And so here's like, here's the, here's the second observation here,

1146
00:52:13,300 --> 00:52:13,700
right?

1147
00:52:13,700 --> 00:52:14,600
Which is that

1148
00:52:18,700 --> 00:52:23,000
If you have data that, follows a particular model, okay?

1149
00:52:23,500 --> 00:52:26,500
And you are an engineer and you're trying to write something to

1150
00:52:26,500 --> 00:52:28,200
operate on that data.

1151
00:52:29,600 --> 00:52:34,200
If you are tempted to build a general system that can handle like

1152
00:52:34,200 --> 00:52:37,800
changes to the data model automatically, you're probably doing the

1153
00:52:37,800 --> 00:52:40,400
wrong thing, that sounds very reasonable.

1154
00:52:40,500 --> 00:52:43,300
So specifically, in this case, right?

1155
00:52:43,300 --> 00:52:48,000
Like, you can say, well, like in Halo we had like these whatever,

1156
00:52:48,000 --> 00:52:52,200
like, 120 different kinds of data, each with their own processor.

1157
00:52:52,500 --> 00:52:54,500
Some of those processes were very simple, lot of them.

1158
00:52:54,500 --> 00:52:56,400
Some of them are like the model compiler, the level Builder.

1159
00:52:58,100 --> 00:52:59,200
We said well liked,

1160
00:53:00,000 --> 00:53:04,700
Instead of trying to like have a lot of different asset processors

1161
00:53:04,700 --> 00:53:08,900
still, let's just have one general purpose, asset processor and then

1162
00:53:08,900 --> 00:53:13,900
let's have the structure of the data be encoded in, like, however, how

1163
00:53:13,900 --> 00:53:14,600
it was produced.

1164
00:53:14,600 --> 00:53:16,200
Hell is provided to the graph processor.

1165
00:53:17,400 --> 00:53:20,500
And what I'm talking about here is like, there's basically two

1166
00:53:20,500 --> 00:53:21,600
choices, right?

1167
00:53:21,700 --> 00:53:26,400
The first choice you can say is hey, our data tends to be organized in

1168
00:53:26,400 --> 00:53:28,900
the form of what you might call assets, right?

1169
00:53:28,900 --> 00:53:29,600
Like, an

1170
00:53:29,800 --> 00:53:33,700
Might be a Shader or a texture or an object, a thing that a human

1171
00:53:33,700 --> 00:53:37,200
might think of as a unit for some purpose, right?

1172
00:53:37,300 --> 00:53:40,600
And so, if you think about the process of like processing an object,

1173
00:53:40,600 --> 00:53:45,600
let's say that's not going to be a single like one of these C function

1174
00:53:45,600 --> 00:53:47,400
tasks that I'm talking about, right?

1175
00:53:47,600 --> 00:53:52,300
Because if that was true, then you basically the input would be like

1176
00:53:53,000 --> 00:53:56,000
all of the data loaded off disk that you're going to need to know

1177
00:53:56,000 --> 00:53:58,900
about when you process your object but you likely aren't going to know

1178
00:53:58,900 --> 00:53:59,400
that.

1179
00:53:59,700 --> 00:53:59,900
because,

1180
00:54:00,000 --> 00:54:02,200
Sometimes when you're processing an object, you'll be like, oh this

1181
00:54:02,200 --> 00:54:05,700
object has a component on it, and it references like this thing over

1182
00:54:05,700 --> 00:54:07,600
here that was like the damage that it can do.

1183
00:54:07,900 --> 00:54:08,200
Right?

1184
00:54:08,200 --> 00:54:11,000
And so instead of just having a reference to the damage, I'm going to

1185
00:54:11,000 --> 00:54:14,200
like take that damage and code it in line and my things so that I can

1186
00:54:14,200 --> 00:54:15,500
be more optimized right now.

1187
00:54:15,500 --> 00:54:19,000
And so a very common thing that you do when you're writing like these

1188
00:54:19,000 --> 00:54:20,900
see functions you're like I'm doing some work.

1189
00:54:21,200 --> 00:54:24,700
I discovered that actually I can't like I need to load a file off disk

1190
00:54:24,700 --> 00:54:27,200
and so I'm going to create another task that goes and lows that file.

1191
00:54:27,200 --> 00:54:28,300
That does the actual work.

1192
00:54:28,300 --> 00:54:28,700
Exactly?

1193
00:54:28,800 --> 00:54:29,100
Okay.

1194
00:54:30,400 --> 00:54:36,100
And so in some sense I mean this is sort of a general aspect of these

1195
00:54:36,100 --> 00:54:36,400
systems.

1196
00:54:36,400 --> 00:54:40,700
I suppose, you know, if you write something that's designed to be hey

1197
00:54:40,700 --> 00:54:45,400
we made we sort of defined, the unit of work as something which cannot

1198
00:54:45,400 --> 00:54:46,400
do I owe.

1199
00:54:46,700 --> 00:54:49,600
Then typically, what you end up doing, is your program really

1200
00:54:49,600 --> 00:54:50,400
operates?

1201
00:54:51,000 --> 00:54:54,700
One level up from that it's we have all these chunks.

1202
00:54:54,800 --> 00:54:58,200
I know that I'm going to need to do conditional IO, but now instead of

1203
00:54:58,200 --> 00:54:59,900
that living in the program, in the form,

1204
00:55:00,000 --> 00:55:02,800
Of some kind of read call, which will block it.

1205
00:55:02,800 --> 00:55:06,100
Now has to live up in a graph portion, which is sort of coded

1206
00:55:06,100 --> 00:55:10,800
simultaneously with the system that is like, instead of blocking on

1207
00:55:10,800 --> 00:55:15,000
the read here, I'm going to create sort of little programs that can be

1208
00:55:15,000 --> 00:55:16,300
run later, right?

1209
00:55:16,400 --> 00:55:19,900
This is, I mean, I've seen these kind of systems before they tend to

1210
00:55:19,900 --> 00:55:20,800
bifurcate in that way.

1211
00:55:20,800 --> 00:55:23,000
So I assume this is what you're talking about.

1212
00:55:23,000 --> 00:55:25,800
We now there's like a two-level coding process if you will.

1213
00:55:25,800 --> 00:55:26,200
Right.

1214
00:55:26,200 --> 00:55:29,800
So it's the only thing to say there is just like something a human

1215
00:55:29,900 --> 00:55:32,800
When things have been as an asset, is not going to be a single task,

1216
00:55:32,800 --> 00:55:34,700
like these functions, we call or tasks, right?

1217
00:55:34,700 --> 00:55:37,900
And so assets are going to have graphs of tasks with them.

1218
00:55:38,200 --> 00:55:41,700
And there are also going to be asset to asset dependencies.

1219
00:55:41,700 --> 00:55:42,000
Right?

1220
00:55:42,000 --> 00:55:44,000
Like the thing I talked about with the object name, to load the

1221
00:55:44,000 --> 00:55:44,400
shooter.

1222
00:55:44,600 --> 00:55:47,800
So we said, well like, because it's going to be asset asset

1223
00:55:47,800 --> 00:55:48,600
dependencies.

1224
00:55:48,600 --> 00:55:51,600
Like, let's just throw it onto the graph Optimizer and then it will

1225
00:55:51,600 --> 00:55:54,400
sort it out, right problem.

1226
00:55:54,400 --> 00:55:59,800
There is, like I said, there is now zero cost for a Crossing asset.

1227
00:56:00,000 --> 00:56:01,100
He's as a programmer.

1228
00:56:01,300 --> 00:56:05,400
Like and so, as a programmer your now like, working in this way,

1229
00:56:05,400 --> 00:56:08,900
you're probably not used to working in, which is rather than writing

1230
00:56:08,900 --> 00:56:11,100
like command line batch process.

1231
00:56:11,100 --> 00:56:14,900
The so that's like do some synchronous I/O, and read some file, you're

1232
00:56:14,900 --> 00:56:19,500
like actually create an asynchronous job graph, and then execute those

1233
00:56:19,500 --> 00:56:23,500
jobs and then like depend on the futures from that job graph by

1234
00:56:23,500 --> 00:56:24,900
creating another task to go and do it.

1235
00:56:24,900 --> 00:56:27,800
So you're already programming in this way that you're not used to

1236
00:56:27,800 --> 00:56:29,800
thinking about and you're quite

1237
00:56:29,900 --> 00:56:33,200
white detached from the actual performance of how that's going to

1238
00:56:33,200 --> 00:56:33,700
work.

1239
00:56:33,700 --> 00:56:33,900
Yes.

1240
00:56:33,900 --> 00:56:35,400
Because you're specifying your job graph.

1241
00:56:35,400 --> 00:56:36,600
It's going to go into the Magic Machine.

1242
00:56:36,600 --> 00:56:39,100
The Magic Machine is going to make it fast and you might be calling

1243
00:56:39,100 --> 00:56:40,900
some thing in that job rappers.

1244
00:56:40,900 --> 00:56:43,600
Like, oh, somebody already wrote the job graph that converts a PSD.

1245
00:56:43,600 --> 00:56:45,000
So I'll just call that one because I need it.

1246
00:56:45,000 --> 00:56:48,600
Now, that one of course, is this whole other job graph, which make all

1247
00:56:48,600 --> 00:56:49,400
other job graphs.

1248
00:56:49,400 --> 00:56:52,800
So you kind of have like a little bit of a Sorcerer's Apprentice job

1249
00:56:52,800 --> 00:56:53,100
graph.

1250
00:56:53,100 --> 00:56:56,600
Where who knows, how many brooms we end up with at the end of the day,

1251
00:56:56,800 --> 00:56:57,500
right?

1252
00:56:57,500 --> 00:56:59,800
And the classic like this super class

1253
00:57:00,000 --> 00:57:06,800
Example for something like that is maybe I'm I'm writing some code to

1254
00:57:06,800 --> 00:57:11,000
do visibility let's say so like we're going to have some middleware

1255
00:57:11,000 --> 00:57:14,100
program that's going to do visibility on a portion of the level.

1256
00:57:14,400 --> 00:57:16,600
And so I need the bounding boxes for the object.

1257
00:57:16,600 --> 00:57:20,200
So I'm going to call the graph for the object and that I'm going to

1258
00:57:20,200 --> 00:57:22,100
get back the object that I'm going to extract the bounding box from

1259
00:57:22,100 --> 00:57:22,400
It.

1260
00:57:23,100 --> 00:57:24,300
Go, Do you see the Trap?

1261
00:57:24,400 --> 00:57:25,700
I do, right?

1262
00:57:25,700 --> 00:57:29,500
Because when you get back the object, you have just depended on like

1263
00:57:30,000 --> 00:57:33,500
We bite and everything that was anywhere in that object because it

1264
00:57:33,500 --> 00:57:35,300
doesn't know, you only want the bounding box.

1265
00:57:35,300 --> 00:57:38,300
So it can't really even say oh hey by the way don't worry about the

1266
00:57:38,300 --> 00:57:40,400
sound effects that were in this thing right?

1267
00:57:40,400 --> 00:57:43,200
Because they matter as far as it knows.

1268
00:57:43,400 --> 00:57:44,200
Yeah right.

1269
00:57:44,300 --> 00:57:47,900
And so now you're in a situation where like someone is working on

1270
00:57:47,900 --> 00:57:53,100
audio and they're like I'm going to change the looping sound effect.

1271
00:57:53,700 --> 00:57:54,700
I'm not going to change the fact.

1272
00:57:54,700 --> 00:57:55,600
There is a looping sound effect.

1273
00:57:55,600 --> 00:57:58,300
I'm just going to change the b in the aiff file, okay?

1274
00:57:58,500 --> 00:57:59,900
And they press the Go Button there.

1275
00:58:00,300 --> 00:58:02,200
Why did it rebuild visibility for my level?

1276
00:58:02,200 --> 00:58:03,000
And take two hours?

1277
00:58:06,500 --> 00:58:07,900
It all makes such a logical sense.

1278
00:58:07,900 --> 00:58:09,200
When we've just gone through it, though.

1279
00:58:09,300 --> 00:58:11,300
I see exactly what right?

1280
00:58:12,800 --> 00:58:15,600
I don't understand his frustration or whoever the audio.

1281
00:58:17,800 --> 00:58:18,400
So yeah.

1282
00:58:18,500 --> 00:58:20,600
And so that that I just described again.

1283
00:58:20,600 --> 00:58:22,400
Now there's a theoretical problem, right?

1284
00:58:22,400 --> 00:58:28,600
Like that, still assumes that you wrote like a perfect bug, free super

1285
00:58:28,600 --> 00:58:29,900
optimized multi-threaded.

1286
00:58:30,100 --> 00:58:30,800
Processor.

1287
00:58:31,000 --> 00:58:31,400
Yes.

1288
00:58:32,700 --> 00:58:34,800
So now let's talk about what actually happened.

1289
00:58:38,600 --> 00:58:41,300
So we've already established that there are all of these like

1290
00:58:41,500 --> 00:58:45,200
theoretical problems that mean that there's Rocky Waters ahead of us

1291
00:58:45,200 --> 00:58:48,200
in the period, from like 2009 to 2014.

1292
00:58:48,200 --> 00:58:48,500
Okay.

1293
00:58:48,500 --> 00:58:49,000
Right.

1294
00:58:49,300 --> 00:58:55,300
And that those problems are like, theoretically intractable is that

1295
00:58:55,300 --> 00:58:57,000
the case of we wrote it bad X.

1296
00:58:57,000 --> 00:58:59,900
It's like we just the problem definition is such that

1297
00:59:00,000 --> 00:59:02,300
That there's really not going to be much we can do here, right?

1298
00:59:02,300 --> 00:59:05,800
The problem director definition is such that like is it's

1299
00:59:06,300 --> 00:59:08,900
theoretically impossible for us to produce a solution.

1300
00:59:08,900 --> 00:59:12,400
People will be happy for because we did not identify the importance of

1301
00:59:12,400 --> 00:59:13,100
graph Cuts.

1302
00:59:13,300 --> 00:59:13,800
Got it.

1303
00:59:14,000 --> 00:59:14,400
Okay.

1304
00:59:15,100 --> 00:59:19,700
And then a couple things happened one was there was some like stuffing

1305
00:59:19,700 --> 00:59:23,200
on the project where like the person who was writing the reflection

1306
00:59:23,200 --> 00:59:25,900
system was doing and they got pulled off to something else and then

1307
00:59:25,900 --> 00:59:29,200
someone else came in like six months later and so there's this

1308
00:59:29,200 --> 00:59:29,900
scheduling issue.

1309
00:59:30,100 --> 00:59:32,300
Ooh, we're so you're going to build this graph processor.

1310
00:59:32,500 --> 00:59:36,500
That's about dealing with like arbitrary data, right?

1311
00:59:36,600 --> 00:59:40,600
And so what you need is a reflection system that allows you to talk

1312
00:59:40,600 --> 00:59:41,300
about data.

1313
00:59:41,300 --> 00:59:45,800
So reflection system here is like we call it the schema system.

1314
00:59:46,300 --> 00:59:50,700
It's a system that allows you to specify the structure of data in such

1315
00:59:50,700 --> 00:59:55,400
a way that you can work with the data even if your code, didn't know

1316
00:59:55,400 --> 00:59:56,300
what the structure was.

1317
00:59:56,500 --> 00:59:59,800
So, what I mean by that is like your graph processing.

1318
01:00:00,000 --> 01:00:04,600
Doesn't need to have a C++ hitter for like the sound effect at some

1319
01:00:04,600 --> 01:00:04,900
point.

1320
01:00:04,900 --> 01:00:07,700
There was a sound effect that was declared in code, or have it was

1321
01:00:07,700 --> 01:00:11,600
declared and that got process down into a piece of data that piece of

1322
01:00:11,600 --> 01:00:15,400
data, describe the structure layout of what a sound effect looks like

1323
01:00:15,400 --> 01:00:17,400
and what is memory layout could be right.

1324
01:00:17,400 --> 01:00:21,000
So then your graph processor deals with like arbitrary structures with

1325
01:00:21,000 --> 01:00:24,000
arbitrary memory layouts, it just knows any time, I had a reference,

1326
01:00:24,000 --> 01:00:27,500
I've got an edge between those two things, I don't really care what

1327
01:00:27,500 --> 01:00:29,900
necessarily, you know, where that was and the thing.

1328
01:00:30,000 --> 01:00:30,300
Thing.

1329
01:00:30,300 --> 01:00:30,700
I just know.

1330
01:00:30,700 --> 01:00:32,000
That's how I get it and go.

1331
01:00:32,000 --> 01:00:32,300
Yeah.

1332
01:00:32,300 --> 01:00:35,500
So you're obviously super dependent on the details of your Affliction

1333
01:00:35,500 --> 01:00:35,900
system.

1334
01:00:35,900 --> 01:00:36,100
Yeah.

1335
01:00:36,200 --> 01:00:39,200
And for whatever scheduling reasons, the reflection system was like a

1336
01:00:39,200 --> 01:00:39,900
year late.

1337
01:00:41,000 --> 01:00:41,500
Okay.

1338
01:00:42,900 --> 01:00:48,900
Because like, it started late and the design was like, elegant in some

1339
01:00:48,900 --> 01:00:52,500
ways that are kind of cool, but maybe not actually necessary for the

1340
01:00:52,500 --> 01:00:52,800
problem.

1341
01:00:52,800 --> 01:00:56,400
We were very nice because if you're building a reflection system, you

1342
01:00:56,400 --> 01:00:59,400
intend to last 20 years, it better be a good reflection system, right?

1343
01:00:59,400 --> 01:00:59,800
Fair enough.

1344
01:00:59,900 --> 01:01:00,100
Yeah.

1345
01:01:00,100 --> 01:01:02,300
So anyway not things.

1346
01:01:02,300 --> 01:01:06,400
I would fault anybody for necessarily at the time, like, I probably

1347
01:01:06,400 --> 01:01:09,000
should have redirected that, but whatever, it doesn't matter.

1348
01:01:09,300 --> 01:01:13,800
So reflection system is late and then we're building the graph

1349
01:01:13,800 --> 01:01:14,400
processor.

1350
01:01:14,400 --> 01:01:18,300
Not, I wouldn't say under the gun, but like you're prototyping, team

1351
01:01:18,300 --> 01:01:22,200
has like built their own like data loader, because the reflection

1352
01:01:22,200 --> 01:01:24,700
system in the graph process are on available yet, right?

1353
01:01:24,700 --> 01:01:27,800
So effectively, it wasn't even so much that these problems to start to

1354
01:01:27,800 --> 01:01:29,900
manifest itself, we haven't even gotten to the point where

1355
01:01:29,900 --> 01:01:33,400
we're, we're noticing the problems because we're sort of using a

1356
01:01:33,400 --> 01:01:34,400
makeshift system.

1357
01:01:35,000 --> 01:01:38,500
While this is being the magical graph processor is coming online.

1358
01:01:38,500 --> 01:01:41,100
Yeah, so there's like a visible.

1359
01:01:41,200 --> 01:01:44,500
There's a prototyping environment that stood up this just like, here's

1360
01:01:44,500 --> 01:01:46,800
a text file reference, some other text file, just load it all into

1361
01:01:46,800 --> 01:01:47,700
memory, right?

1362
01:01:47,700 --> 01:01:50,700
And so people are going and they're defining their data definitions

1363
01:01:50,700 --> 01:01:54,800
and they're like by implication they're processing steps without like

1364
01:01:54,800 --> 01:01:57,200
any knowledge of what the process is going to be able to do right?

1365
01:01:57,400 --> 01:01:59,500
And how are they running this?

1366
01:01:59,500 --> 01:01:59,800
They saw

1367
01:02:00,000 --> 01:02:00,600
Just have a.

1368
01:02:00,700 --> 01:02:03,900
Okay, I just manually run the thing because I don't have a graph

1369
01:02:03,900 --> 01:02:04,400
processor.

1370
01:02:04,400 --> 01:02:07,900
They don't have like tasks that do anything or if they do, they like

1371
01:02:07,900 --> 01:02:08,900
jamming at run time.

1372
01:02:08,900 --> 01:02:12,200
It's kind of like a key portion and it because the data is not very

1373
01:02:12,200 --> 01:02:13,800
big yet it's that'll work.

1374
01:02:13,800 --> 01:02:14,000
Okay.

1375
01:02:14,000 --> 01:02:14,700
That's totally fine.

1376
01:02:14,700 --> 01:02:17,300
But you have like a couple scripted objects and like if you scroll

1377
01:02:17,300 --> 01:02:22,000
through got a problem and then we go and build the graph processor and

1378
01:02:22,900 --> 01:02:26,000
we decided we were going to use C++ 11 because it sounded pretty cool,

1379
01:02:27,500 --> 01:02:27,900
okay?

1380
01:02:28,400 --> 01:02:29,800
And if you're going to build

1381
01:02:29,900 --> 01:02:32,000
Build a graph processor that works on abstract data.

1382
01:02:32,000 --> 01:02:33,200
You should use.

1383
01:02:33,500 --> 01:02:37,400
This is a reasonable assumption, you should use like high-powered

1384
01:02:37,400 --> 01:02:40,400
abstract, algorithmic data processing tools, right?

1385
01:02:40,400 --> 01:02:44,200
Like, if you're going to build something that works with abstract

1386
01:02:44,200 --> 01:02:48,000
data, then why wouldn't you like use a lot of maps and Anonymous

1387
01:02:48,000 --> 01:02:49,900
Lambda functions and things like that.

1388
01:02:50,300 --> 01:02:51,900
All right, all right.

1389
01:02:52,000 --> 01:02:54,300
I see what you're saying.

1390
01:02:54,300 --> 01:02:58,300
It's really a case of like, if you're if you're if you're building

1391
01:02:58,300 --> 01:02:59,500
something, you're like, this is going.

1392
01:03:00,000 --> 01:03:04,200
Like work on, you know, algorithmic Comfort, complex problems.

1393
01:03:04,200 --> 01:03:07,800
We had to have like algorithms available to us and like why would you

1394
01:03:07,800 --> 01:03:09,500
write your own mapreduce?

1395
01:03:09,500 --> 01:03:11,900
When you continues ones off the shelf, okay?

1396
01:03:12,100 --> 01:03:16,000
And so like it's also just like hey this is new technology like it's

1397
01:03:16,000 --> 01:03:17,000
interesting to experiment with.

1398
01:03:17,000 --> 01:03:22,800
Yeah, we went down that path for a while and where we got to was a

1399
01:03:22,800 --> 01:03:26,400
graph processor that you could like run your point it at something,

1400
01:03:26,400 --> 01:03:26,800
okay?

1401
01:03:27,200 --> 01:03:27,600
Sweet.

1402
01:03:27,600 --> 01:03:29,800
We haven't built any caching layers yet.

1403
01:03:30,000 --> 01:03:30,300
Okay.

1404
01:03:30,300 --> 01:03:35,300
Okay, so when you pointed it at like a task graph, it would construct,

1405
01:03:35,300 --> 01:03:38,600
the whole task graph and memory than execute all the tasks, right?

1406
01:03:38,600 --> 01:03:43,400
See really, which is sort of a test for the overlap version it just

1407
01:03:43,400 --> 01:03:46,200
like, hey, let's make sure that if we execute these things to really

1408
01:03:46,400 --> 01:03:49,700
in some walk of the graph graph, that is like depth-first or

1409
01:03:49,700 --> 01:03:50,100
something.

1410
01:03:50,100 --> 01:03:53,200
However, we chose to do it verify that we get the right assets out the

1411
01:03:53,200 --> 01:03:55,600
other end and then we're sort of on our way to having our graph

1412
01:03:55,600 --> 01:03:57,600
processor magic.

1413
01:03:57,600 --> 01:03:59,800
Magic hasn't come yet, but we can sort of see it.

1414
01:03:59,900 --> 01:04:04,100
And from from one side, you can I think defend that decision which is

1415
01:04:04,100 --> 01:04:07,200
hey people really want to write their task graph, they really need to

1416
01:04:07,200 --> 01:04:10,300
write the task graphs in a way that they can like start because the

1417
01:04:10,300 --> 01:04:14,400
process of building an entire asset pipeline from nothing takes years.

1418
01:04:14,400 --> 01:04:15,000
Yes.

1419
01:04:15,000 --> 01:04:15,200
Right.

1420
01:04:15,600 --> 01:04:17,500
And so you want to get as quickly as possible to point.

1421
01:04:17,500 --> 01:04:18,500
People can write the task function.

1422
01:04:18,500 --> 01:04:19,100
That's presumably.

1423
01:04:19,100 --> 01:04:22,300
This is also a feature, you would want of an eventual system anyway,

1424
01:04:22,300 --> 01:04:25,600
because when something goes wrong with the grass scheduling, the first

1425
01:04:25,600 --> 01:04:28,500
thing you typically do is you regress back to the serial version to

1426
01:04:28,500 --> 01:04:28,700
go.

1427
01:04:28,700 --> 01:04:29,900
Let me make sure

1428
01:04:29,900 --> 01:04:30,100
Sure.

1429
01:04:30,100 --> 01:04:31,700
It's not a problem with my schedule, it, right?

1430
01:04:31,700 --> 01:04:34,400
I mean, like when I typically write these things, if I'm trying to

1431
01:04:34,400 --> 01:04:38,900
debug them, I need this, the sequential path to know what the correct

1432
01:04:38,900 --> 01:04:39,800
output is.

1433
01:04:40,400 --> 01:04:40,900
You know.

1434
01:04:41,200 --> 01:04:43,800
So that I know that I'm not just processing the graph wrong because,

1435
01:04:43,800 --> 01:04:46,700
you know, it helps with bug isolation, basically said that is a

1436
01:04:46,700 --> 01:04:49,900
reasonable supposition that I believe that is incorrect In this case.

1437
01:04:50,500 --> 01:04:54,500
And the reason is because we haven't talked about the data sizes yet.

1438
01:04:54,800 --> 01:04:55,400
Okay.

1439
01:04:55,600 --> 01:04:59,800
These like these graphs at Peak are like 15 million tasks.

1440
01:05:01,200 --> 01:05:01,800
Okay.

1441
01:05:04,300 --> 01:05:07,900
And remember what I just said about like the coupling, can we see 15,

1442
01:05:07,900 --> 01:05:12,400
Mega tasks, 15 megatons is because I don't know that I'm ever gonna

1443
01:05:12,400 --> 01:05:13,300
get to say that again.

1444
01:05:15,300 --> 01:05:19,000
So if you're like, 1.5 E2, the seven tasks.

1445
01:05:19,000 --> 01:05:19,300
Okay?

1446
01:05:19,300 --> 01:05:21,000
Yeah, perfect.

1447
01:05:21,800 --> 01:05:24,700
So, let's just think about that for a second, you've got a graph

1448
01:05:24,700 --> 01:05:25,300
processor.

1449
01:05:25,300 --> 01:05:27,800
That is going to build a task graph in some way, right?

1450
01:05:27,800 --> 01:05:30,100
And it has to, like, for these tasks load know what?

1451
01:05:30,300 --> 01:05:32,400
The type they are no other inputs.

1452
01:05:32,400 --> 01:05:36,200
Their outputs, like how many bytes do you think per task?

1453
01:05:36,200 --> 01:05:37,800
You might need for your tracking structure.

1454
01:05:38,000 --> 01:05:39,800
Is this before or after C++?

1455
01:05:39,800 --> 01:05:42,000
11 comes picture.

1456
01:05:42,400 --> 01:05:44,400
Let's suppose we're using C++ 11.

1457
01:05:44,900 --> 01:05:47,200
I can't imagine.

1458
01:05:47,200 --> 01:05:48,500
I don't want to know.

1459
01:05:49,700 --> 01:05:55,300
I actually can't estimated, okay, I think it's probably on the order

1460
01:05:55,300 --> 01:05:57,800
of about 20, kb per task.

1461
01:05:57,800 --> 01:05:59,800
Okay, so basically, you're already

1462
01:06:00,000 --> 01:06:02,400
At extremely expensive, memory size card.

1463
01:06:02,400 --> 01:06:08,700
Just to say, let's do this like 30 gigabytes in only your task,

1464
01:06:08,700 --> 01:06:09,500
metadata structure.

1465
01:06:14,300 --> 01:06:16,700
And I should also point out this the 32-bit application.

1466
01:06:25,100 --> 01:06:27,600
This is the kind of thing that I would have nightmares about.

1467
01:06:27,600 --> 01:06:31,500
I think this is a, this is wow.

1468
01:06:31,500 --> 01:06:33,900
Okay, so this is a very difficult task, right?

1469
01:06:33,900 --> 01:06:37,500
This pun intended, I guess, this is very different charge and to be

1470
01:06:37,500 --> 01:06:42,600
fair, like 15 million tasks is like the maximal size of the task grass

1471
01:06:42,600 --> 01:06:45,000
for the shipping version of Destiny in 2014.

1472
01:06:45,000 --> 01:06:45,400
Okay?

1473
01:06:45,500 --> 01:06:49,300
Like at the time that this became like a really serious problem.

1474
01:06:49,800 --> 01:06:52,500
The task sought the task graphs was probably about

1475
01:06:52,700 --> 01:06:54,200
200,000 tasks.

1476
01:06:54,800 --> 01:06:57,000
Okay and doubling every three weeks.

1477
01:06:57,700 --> 01:07:01,800
Okay, so you look at this and you're like if we actually put this into

1478
01:07:01,800 --> 01:07:06,400
Excel and look at the shape of this thing, we are very scared right

1479
01:07:06,400 --> 01:07:06,800
now.

1480
01:07:08,600 --> 01:07:09,100
Yeah.

1481
01:07:09,200 --> 01:07:15,800
Because like around about like March of 2011 or something like that is

1482
01:07:15,800 --> 01:07:20,200
when like we had the single-threaded task processor and

1483
01:07:21,700 --> 01:07:26,400
It had like a caching system, but the way that the caching system

1484
01:07:26,400 --> 01:07:31,000
worked is that you ran it on a particular graph, okay?

1485
01:07:31,000 --> 01:07:35,900
And the second time you ran it on the graph, it like deserialized the

1486
01:07:35,900 --> 01:07:39,400
graph that was output of the end of the previous execution from disk,

1487
01:07:39,500 --> 01:07:40,700
okay?

1488
01:07:41,100 --> 01:07:45,700
And, and then like, did the incremental analysis to figure out what I

1489
01:07:45,700 --> 01:07:49,100
need to get knocked out and then like, okay, right?

1490
01:07:49,100 --> 01:07:50,800
Because it has to dip the two graphs.

1491
01:07:50,800 --> 01:07:51,200
Because it

1492
01:07:51,400 --> 01:07:54,000
It's to know what it actually has to run, right?

1493
01:07:54,200 --> 01:07:57,100
Because this the problem that's already intractable that was

1494
01:07:57,100 --> 01:07:57,700
terrifying.

1495
01:07:57,700 --> 01:08:00,900
Me is just the problem of rebuilding the game from scratch.

1496
01:08:00,900 --> 01:08:04,700
We haven't even talked about actually trying to make a change to one

1497
01:08:04,700 --> 01:08:05,500
floating point value.

1498
01:08:05,800 --> 01:08:06,400
That's right?

1499
01:08:06,400 --> 01:08:11,000
Okay, and also remember that like the structure of the graphs is not

1500
01:08:11,000 --> 01:08:11,600
the same.

1501
01:08:14,700 --> 01:08:20,800
Like you like, okay, your task functions are defined in some metadata.

1502
01:08:20,800 --> 01:08:22,300
That's in the executable, okay.

1503
01:08:22,300 --> 01:08:26,200
Just like this task has got five inputs of the following kinds and now

1504
01:08:26,200 --> 01:08:29,300
between runs, like, you might have changed executable versions.

1505
01:08:29,600 --> 01:08:34,100
And so, you have a graph that had to encode all the tasks metadata not

1506
01:08:34,100 --> 01:08:37,300
just for what the task was, but also like the schemas of the task

1507
01:08:37,300 --> 01:08:40,600
functions and the schemas of the data that was there.

1508
01:08:40,700 --> 01:08:40,899
Yes.

1509
01:08:40,899 --> 01:08:42,399
Because all the day that all the functions can

1510
01:08:42,500 --> 01:08:43,200
It's been fun to run.

1511
01:08:43,200 --> 01:08:46,800
And remember, this is where we start getting into fire drill

1512
01:08:46,800 --> 01:08:47,399
territory.

1513
01:08:47,399 --> 01:08:47,600
Okay.

1514
01:08:47,600 --> 01:08:53,200
Because we are still talking here about the like, the first version of

1515
01:08:53,200 --> 01:08:54,100
the graph processor.

1516
01:08:54,100 --> 01:08:57,899
You can stand up that allows you to in single-threaded fashion like,

1517
01:08:57,899 --> 01:08:59,700
build a little of the game because

1518
01:09:00,100 --> 01:09:03,100
Once you have that up and stable, then you can write all your tasks

1519
01:09:03,100 --> 01:09:04,200
functions, right?

1520
01:09:04,399 --> 01:09:07,700
And then you can work on what at the time we can.

1521
01:09:07,700 --> 01:09:10,200
I don't think we're thinking, too, clearly about, we're thinking maybe

1522
01:09:10,200 --> 01:09:13,700
it's like a different task processor that is like optimized for rather

1523
01:09:13,700 --> 01:09:16,500
than being like a single-threaded batch processor that you just point

1524
01:09:16,500 --> 01:09:17,200
at something.

1525
01:09:17,399 --> 01:09:21,399
It's like more like an on-demand asynchronous multi-threaded thing,

1526
01:09:21,600 --> 01:09:22,100
right?

1527
01:09:22,100 --> 01:09:25,500
Because it could run on a server somewhere and leave the, you know,

1528
01:09:25,500 --> 01:09:28,600
the graph in memory and some 64 GB server.

1529
01:09:28,600 --> 01:09:29,899
So that doesn't have to read from disk

1530
01:09:30,000 --> 01:09:31,000
Or things like this.

1531
01:09:31,899 --> 01:09:32,700
Am I making this up?

1532
01:09:32,700 --> 01:09:36,000
You don't generally want to run stuff like that on a server because

1533
01:09:36,000 --> 01:09:37,100
you want to be local.

1534
01:09:37,100 --> 01:09:41,399
Because if it's on a server you have really hard problems around

1535
01:09:41,399 --> 01:09:44,899
versioning like when individual people treat them more from one

1536
01:09:44,899 --> 01:09:48,300
executable version of so like it kind of has to run the local

1537
01:09:48,300 --> 01:09:51,100
workstation not necessarily, but there's a lot of really interesting

1538
01:09:51,100 --> 01:09:51,600
complexity there.

1539
01:09:51,600 --> 01:09:55,900
That will totally not get time to talk about but so we're in the

1540
01:09:55,900 --> 01:09:59,700
situation where this graph processor is a 32-bit application, you

1541
01:09:59,700 --> 01:09:59,800
know?

1542
01:10:00,800 --> 01:10:06,300
Tens of kilobytes of metadata per task instance and we're barreling

1543
01:10:06,300 --> 01:10:07,100
towards Milestones.

1544
01:10:07,100 --> 01:10:10,500
We're like hey like we actually can't build this level.

1545
01:10:10,500 --> 01:10:13,400
We're not only does it take 5 hours to build the level around the task

1546
01:10:13,400 --> 01:10:13,900
functions.

1547
01:10:13,900 --> 01:10:17,500
Serially but like it runs out of memory.

1548
01:10:18,700 --> 01:10:25,000
And so you can use that like Windows 3, GB like extension and that

1549
01:10:25,000 --> 01:10:27,500
buys you maybe like 12 days, okay?

1550
01:10:27,800 --> 01:10:31,500
Because remember the task graph is doubling every three weeks because

1551
01:10:31,500 --> 01:10:34,600
your art team is increasing and people are throwing more content in

1552
01:10:34,600 --> 01:10:38,900
the system and they're ready to go because they've been waiting for

1553
01:10:38,900 --> 01:10:42,700
this and they want to get levels and right, okay.

1554
01:10:42,800 --> 01:10:45,900
And so we crash like this is where I come on to the project and so we

1555
01:10:45,900 --> 01:10:46,700
crashed up.

1556
01:10:47,200 --> 01:10:47,900
We crashdot?

1557
01:10:47,900 --> 01:10:48,400
I'm so sorry.

1558
01:10:48,600 --> 01:10:48,900
Nuts?

1559
01:10:48,900 --> 01:10:53,700
Okay okay we crash start to programs simultaneously.

1560
01:10:53,700 --> 01:10:57,700
Okay, the first is to Port our entire engine from 32-bit to 64-bit

1561
01:10:57,700 --> 01:10:59,000
correctness, okay?

1562
01:10:59,100 --> 01:11:01,700
And just to just to do that as rapidly as possible, right?

1563
01:11:01,700 --> 01:11:04,700
Because then at least, we're going to open up more memory for buying

1564
01:11:04,700 --> 01:11:05,200
this time.

1565
01:11:05,700 --> 01:11:10,400
The second is, remember I said the graph processor like serializes its

1566
01:11:10,400 --> 01:11:12,000
output when it finishes.

1567
01:11:12,100 --> 01:11:12,500
Ok.

1568
01:11:13,100 --> 01:11:13,800
But like

1569
01:11:15,200 --> 01:11:17,100
Serializing to disk takes memory.

1570
01:11:17,800 --> 01:11:18,200
Yes.

1571
01:11:18,600 --> 01:11:21,500
So like you can even be in situations where it finished but wasn't

1572
01:11:21,500 --> 01:11:24,900
able to save out at state so you have to run it from scratch the next

1573
01:11:24,900 --> 01:11:25,200
time.

1574
01:11:25,600 --> 01:11:29,900
So what we did, okay, so what you're saying is essentially like it's

1575
01:11:29,900 --> 01:11:33,300
tried to write out the graph, it couldn't write out of the graph.

1576
01:11:33,300 --> 01:11:36,600
So now we can't even defend him or because we don't even know what to

1577
01:11:36,600 --> 01:11:37,700
difficult just right.

1578
01:11:37,800 --> 01:11:38,600
Okay, but what you?

1579
01:11:38,600 --> 01:11:39,900
But see, here's the thing.

1580
01:11:40,700 --> 01:11:44,800
This is like, so the process of building the graph

1581
01:11:45,100 --> 01:11:50,000
Turns out and running tasks takes more memory than DC realising that

1582
01:11:50,000 --> 01:11:51,900
same graph, okay?

1583
01:11:52,500 --> 01:11:57,900
Okay, so what you can do is when you detect you're getting close to

1584
01:11:57,900 --> 01:11:59,700
your 32-bit application limit,

1585
01:12:00,000 --> 01:12:04,600
Can stop processing tasks, save out to disk quit your application,

1586
01:12:04,800 --> 01:12:08,500
launch, the application, again, deserialize the graph and keep going.

1587
01:12:12,300 --> 01:12:21,300
That is pretty beautiful, actually, I feel like that's finding a bit

1588
01:12:21,300 --> 01:12:25,100
of awesome in a dismal situation, like X, I really like that it gets

1589
01:12:25,100 --> 01:12:25,500
better.

1590
01:12:25,600 --> 01:12:28,700
Okay, because so you made some amount of progress there.

1591
01:12:28,700 --> 01:12:28,900
Okay.

1592
01:12:28,900 --> 01:12:29,300
Yes.

1593
01:12:29,700 --> 01:12:29,800
And

1594
01:12:30,000 --> 01:12:33,600
Then you like deserialize the graph and then you you keep going again,

1595
01:12:33,600 --> 01:12:33,800
right?

1596
01:12:33,800 --> 01:12:36,600
So you make some progress, but you're going to make less progress than

1597
01:12:36,600 --> 01:12:38,900
the first time before you hit your memory limit because you have that

1598
01:12:38,900 --> 01:12:39,600
graphic memory.

1599
01:12:40,100 --> 01:12:42,400
Yes, that's okay because you can do it again, right?

1600
01:12:42,400 --> 01:12:44,100
So it's kind of this this curve.

1601
01:12:44,100 --> 01:12:46,600
It looks like that of how much I can process each time.

1602
01:12:46,600 --> 01:12:47,500
Yeah, exactly.

1603
01:12:47,500 --> 01:12:47,700
Okay.

1604
01:12:47,700 --> 01:12:48,100
All right.

1605
01:12:48,200 --> 01:12:52,200
And so like that buys you maybe another two weeks worth of production

1606
01:12:54,800 --> 01:12:59,900
and then you're like this level was previously crashing in like

1607
01:13:00,100 --> 01:13:04,600
Hours with the build time on the farm but now it can complete and I

1608
01:13:04,600 --> 01:13:10,700
had to restart 12 times but now it takes 14 hours because the restart

1609
01:13:10,700 --> 01:13:11,800
process takes a long time.

1610
01:13:12,300 --> 01:13:12,700
Got it.

1611
01:13:12,900 --> 01:13:15,700
And then you get to the point where an infinite number of restarts

1612
01:13:15,700 --> 01:13:18,700
will not actually help you complete because just deserialize in the

1613
01:13:18,700 --> 01:13:22,000
graph doing one atom of work and then serializing again, exhaust your

1614
01:13:22,000 --> 01:13:24,100
memory, the process, got it.

1615
01:13:24,700 --> 01:13:28,400
So it really is like a, it's not even asymptotic, it's kind of just

1616
01:13:28,400 --> 01:13:29,800
got a hard stop.

1617
01:13:29,900 --> 01:13:33,200
Where it's like, okay, we've hit we've laid out and now we just can't

1618
01:13:33,200 --> 01:13:36,000
go any further but that, fortunately, it around about this time, we

1619
01:13:36,000 --> 01:13:37,400
complete the 64-bit Port.

1620
01:13:37,900 --> 01:13:38,400
Okay.

1621
01:13:40,400 --> 01:13:45,000
So now we can use as much memory as we need to up until a physical

1622
01:13:45,000 --> 01:13:48,400
capacity of the machine gun and this isn't like 2011.

1623
01:13:48,400 --> 01:13:53,800
So typically, you know, we have like between 8 and 16 GB of memory on

1624
01:13:53,800 --> 01:13:58,200
our desktop PCS and we have some Farm machines that have as much as 32

1625
01:13:58,200 --> 01:13:59,400
or 64 gigs of memory.

1626
01:14:00,000 --> 01:14:01,400
So we keep going, okay?

1627
01:14:01,800 --> 01:14:06,200
At this point, we identify that, like, the cereal graph processor.

1628
01:14:06,200 --> 01:14:11,000
Like, we've already known that, like, it wasn't really going to work

1629
01:14:11,000 --> 01:14:15,300
out, but just the, the fact that it has like this requirement to have

1630
01:14:15,300 --> 01:14:19,900
the whole graph in memory at once, and also, that it's overhead is

1631
01:14:19,900 --> 01:14:22,500
Tans of kilobytes of metadata per task.

1632
01:14:22,600 --> 01:14:24,700
Like that's just not compatible, right?

1633
01:14:24,700 --> 01:14:27,700
This guy, like, remember, the task graph is still doubling every three

1634
01:14:27,700 --> 01:14:28,000
weeks.

1635
01:14:28,000 --> 01:14:29,800
Yeah, and we at this,

1636
01:14:29,900 --> 01:14:30,900
Point in the project.

1637
01:14:30,900 --> 01:14:33,400
I mean, you know, now, but at this point, the product, you have no

1638
01:14:33,400 --> 01:14:35,300
idea what that bound will be.

1639
01:14:35,300 --> 01:14:39,900
You don't know the 15, Mega task number at this stage, could be

1640
01:14:39,900 --> 01:14:40,800
anything, right?

1641
01:14:40,800 --> 01:14:43,100
We're in an unknown, number of killer tasks.

1642
01:14:43,100 --> 01:14:43,600
At this point.

1643
01:14:43,600 --> 01:14:48,100
Yes, we're hoping the answer is between 700 and 800, kilo, tasks and

1644
01:14:48,100 --> 01:14:48,600
practice.

1645
01:14:48,600 --> 01:14:51,200
We are off by a factor of like 25.

1646
01:14:51,300 --> 01:14:51,600
Yes.

1647
01:14:51,800 --> 01:14:52,200
Okay.

1648
01:14:54,300 --> 01:14:58,100
and so again, like now that we actually are in a situation where like

1649
01:14:58,100 --> 01:14:59,700
these levels can build

1650
01:15:00,400 --> 01:15:04,400
Although they're like overnight builds that will like the process will

1651
01:15:04,400 --> 01:15:08,100
be single-threaded and it will just like tap out at like between 8 and

1652
01:15:08,100 --> 01:15:10,400
14 gigabytes of memory before it completes.

1653
01:15:10,400 --> 01:15:10,800
Okay.

1654
01:15:10,900 --> 01:15:14,700
And oh by the way because it's like a graph Discovery process.

1655
01:15:14,700 --> 01:15:15,200
Yes.

1656
01:15:15,200 --> 01:15:20,100
You can't put the progress bar on that, right?

1657
01:15:20,100 --> 01:15:24,700
Because every time you execute a task it could generate more tasks.

1658
01:15:24,700 --> 01:15:26,100
So technically speaking.

1659
01:15:26,100 --> 01:15:28,500
The only way that you could possibly

1660
01:15:30,100 --> 01:15:30,700
Know what?

1661
01:15:30,700 --> 01:15:33,300
The progress bar was is to already have finished?

1662
01:15:33,300 --> 01:15:33,600
Yes.

1663
01:15:33,700 --> 01:15:40,800
Okay so you can tell it's like monotonically doing work, right right?

1664
01:15:40,800 --> 01:15:42,400
You really don't have any idea.

1665
01:15:42,400 --> 01:15:43,900
Maybe we know it didn't crash.

1666
01:15:43,900 --> 01:15:44,700
It was certainly not that.

1667
01:15:44,700 --> 01:15:44,900
Yeah.

1668
01:15:44,900 --> 01:15:45,200
Okay.

1669
01:15:45,200 --> 01:15:45,800
Pretty good about that.

1670
01:15:46,100 --> 01:15:47,300
I think we got that right.

1671
01:15:47,300 --> 01:15:49,800
But I mean home, I mean time.

1672
01:15:49,800 --> 01:15:50,600
Yes, obviously Crush.

1673
01:15:50,600 --> 01:15:53,400
I mean like, you know, we we assume it's not an infinite Loop because

1674
01:15:53,400 --> 01:15:55,200
we've seen it retire a task.

1675
01:15:55,200 --> 01:15:55,600
Right?

1676
01:15:55,600 --> 01:15:58,500
What we wouldn't necessarily know is if it's an infinite task

1677
01:15:58,500 --> 01:15:59,300
generating Loop.

1678
01:16:00,800 --> 01:16:01,200
That's true.

1679
01:16:02,400 --> 01:16:03,400
Did that ever happen?

1680
01:16:03,500 --> 01:16:09,200
Yo, yes, that that happens actually, that happens all the time as

1681
01:16:09,200 --> 01:16:13,600
still happens actually, and it's as simple as an artist like

1682
01:16:14,200 --> 01:16:17,400
referencing, a particle effect and then that particle effect, like

1683
01:16:17,400 --> 01:16:19,700
referencing the object that was created on, or something like that.

1684
01:16:19,700 --> 01:16:21,300
And so artists do it all the time.

1685
01:16:21,300 --> 01:16:21,800
Okay?

1686
01:16:22,400 --> 01:16:29,400
And when that happens, you have now like a 40 GB memory dump that came

1687
01:16:29,400 --> 01:16:29,900
off of

1688
01:16:30,000 --> 01:16:33,100
Machine and somewhere in that 40 gigabyte memory dump is the

1689
01:16:33,100 --> 01:16:37,000
information that tells you there's a Content reference that was for

1690
01:16:37,000 --> 01:16:37,500
the cycle.

1691
01:16:39,300 --> 01:16:40,800
And we do actually in practice, right?

1692
01:16:40,800 --> 01:16:41,900
Cycle detection logic.

1693
01:16:41,900 --> 01:16:45,100
And that doesn't take very long but like still like, it's like an

1694
01:16:45,100 --> 01:16:47,400
indication of the kind of problems with dealing with yes.

1695
01:16:47,800 --> 01:16:51,200
And this is all like in total fire drill mode, right, right?

1696
01:16:51,200 --> 01:16:53,100
Because this is not something you expected to deal with.

1697
01:16:53,100 --> 01:16:56,000
So all of your engineering resources at this point have been

1698
01:16:56,000 --> 01:16:57,400
reallocated to other things.

1699
01:16:57,500 --> 01:17:01,200
No one's job description was supposed to be emergency for the thing.

1700
01:17:01,200 --> 01:17:04,700
The 64-bit emergency figure out how to fix the test system, right?

1701
01:17:04,700 --> 01:17:08,600
And also remember, it's and C++ 11, which like very few people

1702
01:17:08,700 --> 01:17:14,000
I'm gonna have experience with and also like the kind of like super

1703
01:17:14,000 --> 01:17:18,200
gnarly, like algorithm problems here like that.

1704
01:17:18,200 --> 01:17:20,900
Like we have a high proportion of those people at bungee but still

1705
01:17:20,900 --> 01:17:24,700
it's not a very high proportion of game developers in general like

1706
01:17:24,700 --> 01:17:27,300
right because there's a lot of very pragmatic game developers who

1707
01:17:27,300 --> 01:17:29,900
might not be well, versed in the theory or it's just not going to

1708
01:17:29,900 --> 01:17:30,900
experience with it.

1709
01:17:30,900 --> 01:17:32,000
Just breaks your brain.

1710
01:17:32,000 --> 01:17:32,900
It really does.

1711
01:17:33,000 --> 01:17:35,500
Like when you start dealing with

1712
01:17:36,800 --> 01:17:41,000
You know, any any any graph algorithm anything that has to operate on

1713
01:17:41,000 --> 01:17:42,300
more than 10,000 nodes?

1714
01:17:42,500 --> 01:17:47,300
You're in a totally different place anyway, so we designed a system

1715
01:17:47,400 --> 01:17:51,500
that was going to like, which was going to be basically the second

1716
01:17:51,500 --> 01:17:58,800
system which was preserving the same task interface, right?

1717
01:17:59,200 --> 01:17:59,800
But like a

1718
01:18:00,000 --> 01:18:05,200
Lately different execution, and so you can reuse some of the code,

1719
01:18:05,200 --> 01:18:07,900
like the code that sets up around the task and like, does a bit of the

1720
01:18:07,900 --> 01:18:08,400
I/O.

1721
01:18:08,700 --> 01:18:14,900
But so you basically build a multi-threaded system and maybe I'll draw

1722
01:18:14,900 --> 01:18:15,000
that.

1723
01:18:15,000 --> 01:18:17,000
Actually, that might be interesting time to check.

1724
01:18:17,000 --> 01:18:18,000
We have 35 minutes.

1725
01:18:18,400 --> 01:18:25,100
So this is the system that we designed, we do even 21.

1726
01:18:25,300 --> 01:18:29,200
You said I had until we will, we should have till this.

1727
01:18:29,200 --> 01:18:29,800
This is the time.

1728
01:18:30,000 --> 01:18:30,200
Mer.

1729
01:18:30,200 --> 01:18:31,800
Okay, I should have 12 12 minutes.

1730
01:18:31,800 --> 01:18:36,200
Okay, I believe timer is we after this is lunch so we can certainly go

1731
01:18:36,200 --> 01:18:36,800
a little long.

1732
01:18:38,000 --> 01:18:39,500
Is your is your phone in the?

1733
01:18:39,500 --> 01:18:40,600
Oh no service, right?

1734
01:18:44,800 --> 01:18:49,300
Maybe I want all this anyway, so you build a system that has like the

1735
01:18:49,300 --> 01:18:50,500
following components, right?

1736
01:18:50,600 --> 01:18:54,600
It has a component that is responsible for storing task metadata and

1737
01:18:54,600 --> 01:18:55,600
only task metadata.

1738
01:18:55,900 --> 01:18:59,900
And it does that in a format which is not.

1739
01:18:59,900 --> 01:19:02,500
Like, as we're doing previously, like, it was kind of like the

1740
01:19:02,500 --> 01:19:04,400
exploded like in memory graph.

1741
01:19:04,400 --> 01:19:07,900
It's like it's somewhat somewhat compressed the format we're like

1742
01:19:07,900 --> 01:19:08,500
queries to it.

1743
01:19:08,500 --> 01:19:12,100
Maybe you're a bit slower from CPU standpoints like but it's more

1744
01:19:12,100 --> 01:19:13,000
packed into memory.

1745
01:19:13,500 --> 01:19:17,500
So we built like a version of that that was all in memory thing and we

1746
01:19:17,500 --> 01:19:20,500
built a version of that was kind of like a virtual memory thing where

1747
01:19:20,500 --> 01:19:22,200
it stores its data and pages.

1748
01:19:22,500 --> 01:19:26,100
And then like you load the pages from disk if you get a cache Miss.

1749
01:19:26,100 --> 01:19:31,300
And so that allows you to store a infinite amount of metadata and a

1750
01:19:31,300 --> 01:19:32,300
finite amount of memory.

1751
01:19:32,400 --> 01:19:35,100
So you kind of just move this out of core and said all right we'll

1752
01:19:35,100 --> 01:19:36,300
just do the paging ourselves.

1753
01:19:36,300 --> 01:19:37,700
That way we don't have to worry about this anymore.

1754
01:19:37,700 --> 01:19:38,900
It could get as large as possible.

1755
01:19:38,900 --> 01:19:42,000
It will still be sloped actually but it won't stop.

1756
01:19:42,100 --> 01:19:43,000
Yeah, exactly.

1757
01:19:43,400 --> 01:19:43,500
Right?

1758
01:19:43,500 --> 01:19:44,700
So that's one component.

1759
01:19:44,700 --> 01:19:45,900
The next component.

1760
01:19:45,900 --> 01:19:50,000
We built was the task dispatch engine and so we really like separate

1761
01:19:50,000 --> 01:19:52,400
the task dispatching from the graph processing, okay?

1762
01:19:52,400 --> 01:19:55,000
And so, the task dispatch engine takes like an abstract, specification

1763
01:19:55,000 --> 01:19:56,900
of a task and what the data should be.

1764
01:19:56,900 --> 01:20:03,100
And then it can either dispatch that locally or it can dispatch or it

1765
01:20:03,100 --> 01:20:06,200
can reuse data from a remote cash, right?

1766
01:20:06,200 --> 01:20:09,600
Because you can hash together all the inputs to your tasks, including

1767
01:20:09,600 --> 01:20:11,400
like, older versions of the structures and stuff like that.

1768
01:20:11,400 --> 01:20:13,400
And then you can go look up that hash and see if

1769
01:20:13,400 --> 01:20:16,600
System server, whole other interesting set of problems around that.

1770
01:20:18,000 --> 01:20:21,600
I guess the biggest problem to note there is remember like we don't

1771
01:20:21,600 --> 01:20:23,000
have any acid granularity.

1772
01:20:23,000 --> 01:20:24,800
We only have like this task granularity.

1773
01:20:25,200 --> 01:20:28,900
So if you're going to do like server look up, you want it to be on a

1774
01:20:28,900 --> 01:20:33,600
granularity that is as large as possible, and matches, like the actual

1775
01:20:33,600 --> 01:20:35,100
scope of your and validation, right?

1776
01:20:35,100 --> 01:20:35,700
Right.

1777
01:20:36,300 --> 01:20:39,900
So like if I'm like, if I haven't local modifications to an object and

1778
01:20:39,900 --> 01:20:42,400
I build the object, if I don't as get the whole object, right?

1779
01:20:42,400 --> 01:20:43,300
Yes, and so,

1780
01:20:43,400 --> 01:20:46,300
The nice thing about like, getting the whole object would be, you

1781
01:20:46,300 --> 01:20:50,100
don't have to take on the metadata cost of all the tasks within that

1782
01:20:50,100 --> 01:20:50,600
object.

1783
01:20:50,600 --> 01:20:50,800
Yeah.

1784
01:20:50,800 --> 01:20:51,300
Right.

1785
01:20:51,400 --> 01:20:52,900
Because its own self-contained graph.

1786
01:20:52,900 --> 01:20:54,800
Yes, we didn't have that, right?

1787
01:20:54,900 --> 01:20:58,600
And so if there was an object right, then the graph processor only

1788
01:20:58,600 --> 01:20:59,800
knows like oh hey,

1789
01:21:00,000 --> 01:21:04,300
is this like set of tasks of which there might be, you know, like

1790
01:21:06,100 --> 01:21:09,200
In some cases, like 50,000 tasks or an object, okay?

1791
01:21:09,700 --> 01:21:10,700
And that seems crazy.

1792
01:21:10,900 --> 01:21:15,200
And the reason that's crazy is because like the way that some of these

1793
01:21:15,200 --> 01:21:18,900
like graphs for various different features get built is that, for

1794
01:21:18,900 --> 01:21:21,700
example, in the Shader system, it does things.

1795
01:21:21,700 --> 01:21:27,000
Like if there are eight different variant inputs to the Shader, then

1796
01:21:27,000 --> 01:21:33,200
execute a task for every combinatorial combinatorial and just see

1797
01:21:33,200 --> 01:21:35,800
which one and see, which one's give you the same byte code and

1798
01:21:36,000 --> 01:21:36,600
Collapse them.

1799
01:21:36,600 --> 01:21:40,100
Yes, which is perfectly reasonable from the standpoint like you said

1800
01:21:40,100 --> 01:21:42,700
before if someone who's just looking at their into the problem isn't

1801
01:21:42,700 --> 01:21:45,600
particularly well, versed in, whatever the asset systems issues, maybe

1802
01:21:45,600 --> 01:21:49,000
our sorry, the graph systems issues may be perfectly reasonable way to

1803
01:21:49,000 --> 01:21:49,600
solve it.

1804
01:21:49,700 --> 01:21:51,300
If you're just thinking about, hey, I'm just running this thing.

1805
01:21:51,300 --> 01:21:54,400
Well and also if you've been telling people like the the way that the

1806
01:21:54,400 --> 01:21:57,900
graph processing system works as like hey the graph processing system

1807
01:21:57,900 --> 01:22:03,100
is smart and so if you run the same task 20 times, it'll actually only

1808
01:22:03,100 --> 01:22:05,300
run it once and then it will hash the results, right?

1809
01:22:05,400 --> 01:22:05,700
That's pretty

1810
01:22:05,900 --> 01:22:06,600
Reasonable, right?

1811
01:22:06,600 --> 01:22:09,200
So if you pass the same inputs, the shadow compiler 20 times, run a

1812
01:22:09,200 --> 01:22:10,100
show compiled, 24.

1813
01:22:10,100 --> 01:22:14,400
Only once problem is that doesn't mean it exists only once in your

1814
01:22:14,400 --> 01:22:15,900
graph, right?

1815
01:22:16,300 --> 01:22:19,800
So you can have a situation where like your engineers thought they

1816
01:22:19,800 --> 01:22:22,700
were being smart by having these like nodes in the graph that collapse

1817
01:22:22,700 --> 01:22:25,500
down and they do collapse down terms of execution, but I don't

1818
01:22:25,500 --> 01:22:27,300
collapse down in terms of metadata, right?

1819
01:22:27,300 --> 01:22:31,200
So you're still exploding out that that number even though you weren't

1820
01:22:31,200 --> 01:22:32,900
the engineer didn't know that.

1821
01:22:32,900 --> 01:22:35,800
That was, this an ancillary costs on top of the runtime, right?

1822
01:22:35,900 --> 01:22:36,400
Got it.

1823
01:22:36,500 --> 01:22:40,000
Yeah, if you're focused on like number of tasks executions as your

1824
01:22:40,000 --> 01:22:42,100
primary metric, then you'll totally do that, right?

1825
01:22:42,100 --> 01:22:44,800
You wouldn't even notice you just be like it's why is it so yeah?

1826
01:22:45,000 --> 01:22:45,700
Okay, right.

1827
01:22:45,700 --> 01:22:48,600
Because if you then profile about you just like all damn graph process

1828
01:22:48,600 --> 01:22:49,300
is so slow.

1829
01:22:49,300 --> 01:22:49,700
I see it.

1830
01:22:49,700 --> 01:22:51,200
Only read my show compiled for one second.

1831
01:22:51,200 --> 01:22:52,300
What is it doing the other five minutes?

1832
01:22:52,300 --> 01:22:52,800
Exactly.

1833
01:22:52,800 --> 01:22:53,700
Well, it was collapsing.

1834
01:22:53,700 --> 01:22:55,800
The other fifty thousand instances of your Shader compiler to give.

1835
01:22:55,800 --> 01:22:56,100
Yes.

1836
01:22:56,300 --> 01:22:56,600
Right.

1837
01:22:56,600 --> 01:22:57,000
Like,

1838
01:22:58,500 --> 01:22:59,100
Okay.

1839
01:22:59,200 --> 01:23:03,800
Yeah, anyway, so then we have like this multi threaded execution

1840
01:23:03,800 --> 01:23:07,400
engine, the dispatches to like multiple work processes locally and

1841
01:23:07,400 --> 01:23:09,500
then it can go and retrieve data from the service.

1842
01:23:09,700 --> 01:23:13,200
But remember, I was saying, like the data granularity retrieved from

1843
01:23:13,200 --> 01:23:14,500
the service is very small.

1844
01:23:14,500 --> 01:23:19,800
It's like one task, and remember, it's this graph processor is doing

1845
01:23:19,800 --> 01:23:21,100
this Discovery Pass, right?

1846
01:23:21,100 --> 01:23:21,500
That's right.

1847
01:23:21,500 --> 01:23:24,600
So you get a result back and you're like, okay, so I got that result

1848
01:23:24,600 --> 01:23:27,300
back and it said that it created, eight new tasks.

1849
01:23:27,400 --> 01:23:28,100
I'm gonna go get results with

1850
01:23:28,300 --> 01:23:29,300
Jose tasks, right?

1851
01:23:29,300 --> 01:23:31,600
So like many, many transactions to the service.

1852
01:23:31,600 --> 01:23:35,700
Yes, with like very little work happening locally because if you're an

1853
01:23:35,700 --> 01:23:38,700
artist and you're like, I just want to get the state of the level as

1854
01:23:38,700 --> 01:23:39,700
it is in the depot.

1855
01:23:40,000 --> 01:23:40,900
You expect to run.

1856
01:23:40,900 --> 01:23:42,300
No tasks locally, right?

1857
01:23:42,400 --> 01:23:42,700
Yes.

1858
01:23:42,700 --> 01:23:47,100
And so your machine is just going to sit there and do well like 15

1859
01:23:47,100 --> 01:23:49,000
million transactions to the service, right?

1860
01:23:49,000 --> 01:23:49,300
Yes.

1861
01:23:50,400 --> 01:23:53,900
Just even your local machine, even your local machine, if you didn't

1862
01:23:53,900 --> 01:23:54,700
have anything.

1863
01:23:54,700 --> 01:23:56,200
But then if you had to rebuild the whole thing.

1864
01:23:56,200 --> 01:23:59,300
Yeah, if you had to rebuild the metadata and then like once the

1865
01:23:59,300 --> 01:23:59,800
metadata

1866
01:24:00,000 --> 01:24:03,000
Is on your machine, then you're in better shape.

1867
01:24:03,800 --> 01:24:06,800
But remember there's no concept of a sub graph, right?

1868
01:24:06,800 --> 01:24:09,800
So, if you're working on this level, like, you built that metadata.

1869
01:24:09,800 --> 01:24:13,800
If you go switch to another level, all that metadata has to be rebuilt

1870
01:24:13,900 --> 01:24:17,500
because one of the things about the coupling is that you're often

1871
01:24:17,500 --> 01:24:20,700
passing data all the way down the tree.

1872
01:24:20,900 --> 01:24:24,700
So, for example, the tree the tree of graph, the cryptographic tasks,

1873
01:24:24,700 --> 01:24:25,100
okay?

1874
01:24:25,400 --> 01:24:28,000
So for example, we have a feature in Destiny which is pretty cool,

1875
01:24:28,100 --> 01:24:29,000
which is that

1876
01:24:30,400 --> 01:24:31,900
A Shader on a crate.

1877
01:24:31,900 --> 01:24:34,200
If that creates on Mars, it might be Dusty.

1878
01:24:34,300 --> 01:24:37,300
If that creates on Venus, it might be masih, I see.

1879
01:24:37,300 --> 01:24:40,800
So basically, there's a parametric aspect to these tasks where you're

1880
01:24:40,800 --> 01:24:45,200
sort of saying, like, hey, this is essentially the same graph that I'm

1881
01:24:45,200 --> 01:24:47,900
going to execute, but I'm passing information down.

1882
01:24:48,100 --> 01:24:51,600
So essentially, it's a totally different graph than the other graph

1883
01:24:51,600 --> 01:24:54,600
that would have looked exactly like it, otherwise, right, even if none

1884
01:24:54,600 --> 01:24:57,200
a piece of the tossed actually, don't look at any of those parameters.

1885
01:24:57,200 --> 01:24:58,600
If something does.

1886
01:24:59,100 --> 01:24:59,500
Yeah.

1887
01:25:00,300 --> 01:25:00,800
Got it.

1888
01:25:01,600 --> 01:25:08,000
Yep, so that was pretty cool.

1889
01:25:08,000 --> 01:25:11,700
And so actually we built that I'm pretty happy about that.

1890
01:25:11,700 --> 01:25:14,600
So we built that leg second system.

1891
01:25:14,600 --> 01:25:17,900
And we built that in about nine months, okay?

1892
01:25:18,000 --> 01:25:22,900
And then we rolled it out and mostly it worked.

1893
01:25:23,000 --> 01:25:26,000
But there are some significant problems that were associated with that

1894
01:25:26,000 --> 01:25:28,100
system, which is like the 2012 version.

1895
01:25:28,200 --> 01:25:30,000
Okay, that's basically and the

1896
01:25:30,200 --> 01:25:30,400
Them's.

1897
01:25:30,400 --> 01:25:35,800
Our even though you have this now, like multi-threaded like less

1898
01:25:35,800 --> 01:25:39,400
metadata overheads like has a server cache and all that sort of thing,

1899
01:25:39,800 --> 01:25:42,900
it's still building this metadata for everything, right?

1900
01:25:43,000 --> 01:25:47,000
And so as you said the theoretical problems are not going anywhere.

1901
01:25:47,000 --> 01:25:50,300
So far they are still 100% there and you're just working at a more

1902
01:25:50,300 --> 01:25:53,500
efficient solution to a theoretically very bad situation, right?

1903
01:25:53,500 --> 01:25:53,700
Right.

1904
01:25:53,700 --> 01:25:56,200
And so that like the tool chain we end up shipping Destiny on and

1905
01:25:56,200 --> 01:25:59,700
actually every distant really since then still fundamentally is like

1906
01:25:59,700 --> 01:26:00,000
in this

1907
01:26:00,100 --> 01:26:05,700
A state where it's kind of, its kind of a batch processor, although,

1908
01:26:05,700 --> 01:26:08,300
it keeps like The Meta data cache and memory and like a lot of the

1909
01:26:08,300 --> 01:26:09,100
caches or Hong.

1910
01:26:09,400 --> 01:26:13,500
And then you point it at like a really big graph of stuff to go and

1911
01:26:13,500 --> 01:26:14,000
do.

1912
01:26:14,300 --> 01:26:20,100
And then it analyzes the like 9 to 15 million 9 to 15 Megaton.

1913
01:26:20,100 --> 01:26:21,300
Ask grafts, yes.

1914
01:26:21,400 --> 01:26:26,000
And then like knocks out maybe the two tasks in there that did it to

1915
01:26:26,000 --> 01:26:26,500
rerun.

1916
01:26:26,500 --> 01:26:26,900
Yes.

1917
01:26:27,000 --> 01:26:27,800
And then reruns those.

1918
01:26:29,300 --> 01:26:30,000
And so

1919
01:26:30,200 --> 01:26:35,600
Like your time like when you're actually executing the tasks, it's

1920
01:26:35,600 --> 01:26:39,300
very very good at scheduling CPU and I oh right.

1921
01:26:39,600 --> 01:26:46,100
But like you're paying anywhere from like 1 to 7 Minutes worth of

1922
01:26:46,100 --> 01:26:48,600
overhead for a graph processing which is doing nothing other than

1923
01:26:48,600 --> 01:26:50,900
processing, 15 Mega tasks because that's what it has to do.

1924
01:26:51,100 --> 01:26:55,800
Right in a single-threaded fashion because like if you have got some

1925
01:26:55,800 --> 01:26:59,500
like algorithm that's doing like essentially a graft if on 15 Megaton,

1926
01:26:59,500 --> 01:26:59,800
Oscar.

1927
01:27:00,000 --> 01:27:01,800
Paralyzed very hot paralyzed.

1928
01:27:01,900 --> 01:27:02,300
I see.

1929
01:27:03,200 --> 01:27:07,700
So that is up to the actual shipping Destiny then.

1930
01:27:07,700 --> 01:27:11,000
Yeah, that is what been so I assume now this is probably something

1931
01:27:11,000 --> 01:27:13,300
that's very high on your Hit List.

1932
01:27:13,600 --> 01:27:13,800
Well.

1933
01:27:13,800 --> 01:27:15,900
So for going forward.

1934
01:27:15,900 --> 01:27:19,600
Yes, so we have actually already built and rolled out a version 2 and

1935
01:27:19,600 --> 01:27:22,300
I'm currently like people are currently working on a version 3 and

1936
01:27:22,300 --> 01:27:25,300
just like to talk about the version 2 of the graph processor like it.

1937
01:27:25,300 --> 01:27:26,700
Introduces graph Cuts, right?

1938
01:27:26,800 --> 01:27:28,000
Okay, simple simple.

1939
01:27:28,000 --> 01:27:29,900
Simple thing to say, like a lot of complexity there,

1940
01:27:30,000 --> 01:27:33,400
They're behind the scenes, but essentially rather than having one

1941
01:27:33,400 --> 01:27:35,100
graph of 15 Mega tasks.

1942
01:27:35,400 --> 01:27:38,200
It's now 1.2 million graphs,

1943
01:27:39,400 --> 01:27:45,900
Okay, the Each of which has something like 12 no stream Lee had

1944
01:27:45,900 --> 01:27:47,000
erogenous, right?

1945
01:27:47,000 --> 01:27:51,200
Because some of them are like, here's this one file that is catch to

1946
01:27:51,200 --> 01:27:52,000
get loaded.

1947
01:27:52,000 --> 01:27:56,200
And then, B swap to then output to a platform specific state, right?

1948
01:27:56,300 --> 01:27:58,100
And some of them are, here's an entire map.

1949
01:27:58,900 --> 01:28:02,100
And so, I guess the thing about the graph cuts that I don't super

1950
01:28:02,100 --> 01:28:03,900
understand, is how do you?

1951
01:28:03,900 --> 01:28:07,900
I mean, are the graph Cuts something that you can do separate from

1952
01:28:07,900 --> 01:28:08,900
reducing the function?

1953
01:28:09,100 --> 01:28:10,400
Woody of the system.

1954
01:28:10,900 --> 01:28:12,600
So I don't think I really understand.

1955
01:28:12,600 --> 01:28:15,100
I mean, I understand what a graph could is in the abstract, certainly.

1956
01:28:15,100 --> 01:28:18,100
But in terms of the practical, definition of what it means in your

1957
01:28:18,100 --> 01:28:20,100
system, I'm not sure I really have a handle on it.

1958
01:28:20,200 --> 01:28:23,800
Yeah, I mean, the way to think about it, the way that we chose to

1959
01:28:23,800 --> 01:28:27,000
think about it, was you have an asset, right?

1960
01:28:27,200 --> 01:28:31,200
And the asset is identified by a name, okay?

1961
01:28:31,500 --> 01:28:34,900
And the name is often a file on disk, but sometimes not because

1962
01:28:34,900 --> 01:28:37,400
sometimes it's like a logical or abstract thing.

1963
01:28:37,500 --> 01:28:37,900
Yes.

1964
01:28:38,000 --> 01:28:38,600
And

1965
01:28:39,000 --> 01:28:41,700
sometimes it's like a file on disk with in, with some parameters.

1966
01:28:41,700 --> 01:28:45,500
So it's like this Shader, but also the Shader on Mars and then for

1967
01:28:45,500 --> 01:28:49,100
PlayStation 4 and then with the following like 12 vertex types, for

1968
01:28:49,100 --> 01:28:50,200
example, entry, right?

1969
01:28:50,200 --> 01:28:54,400
So, like you can have one file on disk, they didn't still turns into,

1970
01:28:54,400 --> 01:28:58,400
like, you know, 900 individual graphs got at each with different set

1971
01:28:58,400 --> 01:28:59,100
of input parameters.

1972
01:29:00,600 --> 01:29:04,600
And then, the way it works, is, you go through an extremely laborious

1973
01:29:04,600 --> 01:29:08,900
process of like where you had this previous like,

1974
01:29:09,100 --> 01:29:12,700
In a soup of just like I'm a task, I've referenced some other task

1975
01:29:12,700 --> 01:29:14,800
which could be somewhere over like way in the graph.

1976
01:29:14,800 --> 01:29:17,400
Like I'm going to go and get this object so I can get its bounding

1977
01:29:17,400 --> 01:29:18,000
box, right?

1978
01:29:18,000 --> 01:29:22,400
Like example, instead, what you do is you say, I know that the object

1979
01:29:22,400 --> 01:29:26,400
is a graph time, okay, I know that, that graph type declares a

1980
01:29:26,400 --> 01:29:29,100
specific output, which is bounding box output.

1981
01:29:29,300 --> 01:29:33,000
So you say, give me the bounding box, bounding box, output of the

1982
01:29:33,000 --> 01:29:34,900
following named graph, okay?

1983
01:29:35,200 --> 01:29:38,900
And so, you can still have all those dependencies but then you

1984
01:29:39,000 --> 01:29:41,800
You force yourself to go through this hoop of saying, I'm going to

1985
01:29:41,800 --> 01:29:45,600
tell you exactly what I depend upon and that thing I depend upon us

1986
01:29:45,600 --> 01:29:49,200
going to be a named output, but that thing created, when it ran as

1987
01:29:49,200 --> 01:29:50,800
opposed to just give me everything it did.

1988
01:29:50,800 --> 01:29:52,700
Then I'll let go through to find the one thing I need.

1989
01:29:53,400 --> 01:29:57,300
And so that allows you to separate the process of dirtying the graphs

1990
01:29:57,700 --> 01:29:59,800
versus dirtying, their individual outputs,

1991
01:30:00,000 --> 01:30:02,100
This is dirty and which of their dependencies have to rerun.

1992
01:30:02,700 --> 01:30:07,700
So I guess the way I would describe the graph cut then is, it's not so

1993
01:30:07,700 --> 01:30:13,400
much a graph cut as it is a more explicit version of The Links.

1994
01:30:13,400 --> 01:30:17,100
That's right there, by reducing the chances that two subgraphs get

1995
01:30:17,100 --> 01:30:19,000
merged with that.

1996
01:30:19,000 --> 01:30:22,900
Be a correct statement the never merge subgraphs what it does is it

1997
01:30:22,900 --> 01:30:27,200
reduces the cases in which there is unintentional dirtying, right,

1998
01:30:27,200 --> 01:30:27,800
right.

1999
01:30:27,900 --> 01:30:29,800
We have like graph, a and graph B.

2000
01:30:30,000 --> 01:30:32,800
The and graph be like the programmer who wrote, that didn't really

2001
01:30:32,800 --> 01:30:36,100
intend to depend on all the details of graph a but they accidentally

2002
01:30:36,100 --> 01:30:36,700
did.

2003
01:30:36,700 --> 01:30:36,900
Right.

2004
01:30:36,900 --> 01:30:41,000
So now be runs all the time, you can break it down to where be only

2005
01:30:41,000 --> 01:30:44,100
runs if like The Ballot Box of a changed, right?

2006
01:30:44,300 --> 01:30:45,400
So that's what you can do.

2007
01:30:45,400 --> 01:30:47,800
So it's almost like you're like creating explicit tunnels between

2008
01:30:47,800 --> 01:30:49,100
graphs rather than cutting them?

2009
01:30:49,300 --> 01:30:49,500
Yeah.

2010
01:30:49,500 --> 01:30:51,700
Or I mean, but there still is a graph.

2011
01:30:51,700 --> 01:30:53,700
We could produce that would represent this, would it?

2012
01:30:53,700 --> 01:30:54,100
Not?

2013
01:30:54,200 --> 01:30:54,500
Yeah.

2014
01:30:54,600 --> 01:30:56,600
So in theory, it's just a different graph.

2015
01:30:56,800 --> 01:30:59,800
But the other thing that's really important is that all of your

2016
01:31:00,000 --> 01:31:01,300
Graph operations.

2017
01:31:01,300 --> 01:31:04,500
Now can operate on those sub graphs as independent problems, okay?

2018
01:31:04,600 --> 01:31:06,100
Which means you can paralyze them.

2019
01:31:06,300 --> 01:31:09,500
So in practice, we have 64 threads that are all running graph

2020
01:31:09,500 --> 01:31:11,500
operations on each individual asset.

2021
01:31:11,500 --> 01:31:11,900
Okay.

2022
01:31:12,300 --> 01:31:17,100
So, all right, and then and so that's like version 2, which we have

2023
01:31:17,100 --> 01:31:22,100
deployed to all of our people and it does both task level and asset

2024
01:31:22,100 --> 01:31:22,500
level.

2025
01:31:22,500 --> 01:31:29,000
Caching got it and it's got significantly better performance in terms

2026
01:31:29,000 --> 01:31:29,500
of

2027
01:31:30,600 --> 01:31:32,300
incremental computation.

2028
01:31:32,700 --> 01:31:34,800
But the big problem that it has, which we still haven't fixed.

2029
01:31:34,800 --> 01:31:39,700
Is that the, the contract between the game and the Importer is still

2030
01:31:39,700 --> 01:31:40,200
the same.

2031
01:31:40,600 --> 01:31:43,600
I see the contract between the game of the Importer is you're going to

2032
01:31:43,600 --> 01:31:47,500
give me this thing, which is this like totally hyper optimized, like

2033
01:31:47,500 --> 01:31:50,800
everything connected together, all these dependencies, all figured out

2034
01:31:51,200 --> 01:31:52,900
thing that I could run in a retail form.

2035
01:31:52,900 --> 01:31:55,600
Yes, and so, that's what we're looking at for version.

2036
01:31:55,600 --> 01:31:58,900
3 is basically saying, like, where can we literally cut the graph like

2037
01:31:59,000 --> 01:31:59,800
you're not allowed

2038
01:32:00,000 --> 01:32:02,600
To Tunnel data from here to here at import time anymore.

2039
01:32:02,800 --> 01:32:06,900
And if you want to do that, you now have to do that at runtime once

2040
01:32:06,900 --> 01:32:07,700
those things are loaded.

2041
01:32:07,700 --> 01:32:10,700
So in some sense, it's kind of going back to the old Halo model for

2042
01:32:10,700 --> 01:32:11,500
that part of it.

2043
01:32:11,500 --> 01:32:14,500
We're just saying, look, there's going to be resolution that happens

2044
01:32:14,500 --> 01:32:15,200
load time.

2045
01:32:15,500 --> 01:32:18,300
We're going to pick those strategically so that they're in the places

2046
01:32:18,300 --> 01:32:21,500
that are least likely to affect say, the performance or the quality

2047
01:32:21,500 --> 01:32:23,900
level that we think is important here.

2048
01:32:24,100 --> 01:32:27,200
And then that will give us kind of a hybrid that we can use to sort

2049
01:32:27,200 --> 01:32:29,700
of, you know, find the happy medium, if you will.

2050
01:32:30,000 --> 01:32:30,400
Exactly.

2051
01:32:30,400 --> 01:32:30,800
Right.

2052
01:32:30,900 --> 01:32:34,700
And also like part of that is like, developing the institutional

2053
01:32:34,700 --> 01:32:37,000
understanding that actually like asset.

2054
01:32:37,000 --> 01:32:38,700
Dependencies are a big deal.

2055
01:32:38,700 --> 01:32:39,700
So think about that.

2056
01:32:39,700 --> 01:32:43,800
So think about them and like the two places you can push them safely

2057
01:32:43,800 --> 01:32:47,500
are you can push them safely the runtime or you can push them safely

2058
01:32:47,500 --> 01:32:48,600
to edit time.

2059
01:32:48,700 --> 01:32:52,500
If you have like a GUI tool that has like the object and the shaders

2060
01:32:52,500 --> 01:32:53,600
all loaded at once.

2061
01:32:53,900 --> 01:32:56,300
Then you can at that time, say whatever you want really?

2062
01:32:56,300 --> 01:32:58,400
I know the object depends on only these shaders.

2063
01:32:58,600 --> 01:32:59,800
So even if the artist didn't have

2064
01:33:00,000 --> 01:33:03,700
I put in manually like you still like have that cross asset knowledge

2065
01:33:03,700 --> 01:33:04,500
at a time.

2066
01:33:05,300 --> 01:33:12,000
Anyway, so the moral of the story which case like think like think

2067
01:33:12,000 --> 01:33:17,400
really hard about if you have an existing solution like what are the

2068
01:33:17,400 --> 01:33:19,700
choices and the trade-offs that you made?

2069
01:33:19,800 --> 01:33:22,700
Because if you have some good properties, you almost certainly

2070
01:33:22,700 --> 01:33:24,600
accepted some bad properties to get there.

2071
01:33:25,000 --> 01:33:25,500
And

2072
01:33:26,700 --> 01:33:29,200
You don't just get to pick only the good stuff, right?

2073
01:33:29,200 --> 01:33:32,500
Like, you are either explicitly or implicitly.

2074
01:33:32,500 --> 01:33:35,600
Going to create situations where your solution does not handle it.

2075
01:33:35,600 --> 01:33:36,000
Right?

2076
01:33:36,200 --> 01:33:41,700
And so, the most important thing you can do is to make sure that your

2077
01:33:41,700 --> 01:33:44,100
game Falls entirely in the good place and stuff.

2078
01:33:44,100 --> 01:33:45,800
That's not your game as elsewhere.

2079
01:33:45,800 --> 01:33:46,200
That's fine.

2080
01:33:46,200 --> 01:33:51,700
You can't build everything but like build only systems whose complex

2081
01:33:51,700 --> 01:33:54,000
the you can completely understand before you start.

2082
01:33:56,500 --> 01:33:58,200
Is of course impossible.

2083
01:34:00,400 --> 01:34:01,400
Well Chris, thank you so much.

2084
01:34:01,400 --> 01:34:02,300
That was amazing.

2085
01:34:10,800 --> 01:34:14,800
So almost nothing of what I talked about was actually my work.

2086
01:34:14,800 --> 01:34:19,800
So, a big shout-out to like Chris Hargrove, Brian Sharp, Drew card,

2087
01:34:19,800 --> 01:34:20,900
noguchi, Brandon Morrow.

2088
01:34:20,900 --> 01:34:25,100
Mike Nicola Drew Solomon.

2089
01:34:25,100 --> 01:34:26,900
And everybody, I forgot along the way.

2090
01:34:27,300 --> 01:34:29,300
Thank you guys, thank you so much.

