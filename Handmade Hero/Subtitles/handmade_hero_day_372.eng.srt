1
00:00:03,600 --> 00:00:05,700
Hello everyone and welcome to handmade hero.

2
00:00:05,700 --> 00:00:08,300
The show we go to complete game live on stream.

3
00:00:08,600 --> 00:00:13,800
We are here this weekend, the previous weekend of coding, not, I was

4
00:00:13,800 --> 00:00:18,300
off last weekend with weekend before that we basically got our opengl

5
00:00:18,300 --> 00:00:22,100
stuff working mostly the way that we probably want.

6
00:00:22,200 --> 00:00:25,200
There's there's some additional stuff that we probably would want to

7
00:00:25,200 --> 00:00:29,000
do eventually, but it's, you know, our game is kind of running pretty

8
00:00:29,000 --> 00:00:30,100
nicely through opengl.

9
00:00:30,100 --> 00:00:32,700
Now, everything appears to be working properly.

10
00:00:33,600 --> 00:00:38,400
And yeah, we just we've gotten it to the point where, you know, the 3D

11
00:00:38,500 --> 00:00:41,300
Miss of the game just kind of works and, you know, we can inspect it

12
00:00:41,300 --> 00:00:43,400
in debug mode and see our Flats rights.

13
00:00:44,200 --> 00:00:47,600
Even ones that intersect are using the Z bias stuff properly.

14
00:00:47,600 --> 00:00:50,600
So we're pretty good to go as far as that's concerned.

15
00:00:51,300 --> 00:00:56,200
So what I want to do this weekend is just sort of finish up some, some

16
00:00:56,200 --> 00:01:01,100
code stuff in that open gel layer, which is kind of, still a holdover

17
00:01:01,100 --> 00:01:02,400
from when we just kind of implement it.

18
00:01:02,400 --> 00:01:03,200
As a basic thing.

19
00:01:03,300 --> 00:01:03,500
NG.

20
00:01:04,500 --> 00:01:08,700
And what I mean by that is right now, you know, we started in opengl

21
00:01:08,700 --> 00:01:12,800
and I showed how to do the fixed fixed function, pipeline, to draw

22
00:01:12,800 --> 00:01:13,200
stuff.

23
00:01:13,200 --> 00:01:16,000
And then we switched because we decided we wanted to actually take

24
00:01:16,000 --> 00:01:18,900
advantage of more features of the GPU.

25
00:01:19,100 --> 00:01:23,600
So, we did actually move to a more modern opengl style where you, you

26
00:01:23,600 --> 00:01:25,000
know, load shaders and this sort of thing.

27
00:01:25,000 --> 00:01:28,300
So there's no more fixed function pipeline, but we still have a fair

28
00:01:28,300 --> 00:01:31,800
portion of sort of the cruft of the code that's going through the

29
00:01:31,800 --> 00:01:33,000
fixed function Pipeline.

30
00:01:33,000 --> 00:01:33,200
And

31
00:01:33,400 --> 00:01:35,800
Don't really want to do that anymore.

32
00:01:36,300 --> 00:01:40,600
We can just get rid of the old fixed-function Legacy pipeline stuff,

33
00:01:40,600 --> 00:01:43,900
which can be a good idea just because it's not what vendors are

34
00:01:43,900 --> 00:01:47,600
expecting you to have an in-game opengl at.

35
00:01:47,600 --> 00:01:50,200
This point is much too sprawling, that's definitely true.

36
00:01:53,100 --> 00:01:54,700
It's just, it's to Legacy.

37
00:01:55,600 --> 00:02:03,100
And as a result, you know, the sort of support surface for it is.

38
00:02:03,300 --> 00:02:07,100
Just massive and it's hard for driver vendors.

39
00:02:08,800 --> 00:02:10,800
To test everything you might do, right?

40
00:02:10,800 --> 00:02:14,800
It's hard to test the using the fixed function pipeline, plus using

41
00:02:15,100 --> 00:02:18,300
shaders set the same time in a mixed way and all that stuff.

42
00:02:18,700 --> 00:02:23,200
And so since most games are not doing that anymore, most games,

43
00:02:23,500 --> 00:02:26,400
especially the games that vendors care, most about which are games

44
00:02:26,400 --> 00:02:30,600
that are Benchmark games, which are high-profile AAA titles that sort

45
00:02:30,600 --> 00:02:31,000
of thing.

46
00:02:33,800 --> 00:02:37,800
Ones where the driver authors know their company's reputation.

47
00:02:38,900 --> 00:02:41,500
Depends on them running these games.

48
00:02:41,500 --> 00:02:47,100
Well they're going to be more heavily testing those paths which are

49
00:02:47,100 --> 00:02:49,600
not going to include stuff like calls to the fixed function Pipeline.

50
00:02:49,600 --> 00:02:53,000
And so one of the things that you typically want to do when you're

51
00:02:53,000 --> 00:02:56,100
using a 3D API in this doesn't is not just opengl.

52
00:02:56,100 --> 00:02:59,600
It's anything any 3D API at all whether it's

53
00:03:00,000 --> 00:03:04,400
The opengl Vulcan metal opengl es anything.

54
00:03:06,300 --> 00:03:09,700
One of the problems is the way that these systems are architected is

55
00:03:09,700 --> 00:03:11,200
just not very good yet.

56
00:03:11,300 --> 00:03:13,400
The apis are not particularly good.

57
00:03:13,900 --> 00:03:14,600
There's no.

58
00:03:14,600 --> 00:03:18,100
I say, it's not like an x 64 chip or stuff or stuff.

59
00:03:18,100 --> 00:03:20,700
We're AMD and Intel has done a fantastic job.

60
00:03:21,200 --> 00:03:26,500
Specifically specifying a, you know a very rigid set of criteria for

61
00:03:26,500 --> 00:03:29,600
what defines an operating chip and how it is tested.

62
00:03:30,000 --> 00:03:33,100
None of that stuff is true in the GPU world.

63
00:03:33,100 --> 00:03:35,500
It's a complete wild West's a lot of stuff just

64
00:03:35,700 --> 00:03:36,400
Doesn't work.

65
00:03:36,600 --> 00:03:40,400
There's no specification for even really testing how it works in.

66
00:03:40,400 --> 00:03:44,800
A lot of cases other than the most basic sort of things for

67
00:03:44,800 --> 00:03:45,500
compliance.

68
00:03:45,800 --> 00:03:50,800
And so as a result you need to be aware of the fact that this is not

69
00:03:50,800 --> 00:03:54,100
like the CPU.

70
00:03:54,800 --> 00:03:58,800
And so, what you need to do is make sure that you're trying to keep

71
00:03:58,800 --> 00:04:03,100
the amount to, which you're using the API as much as possible in line

72
00:04:03,100 --> 00:04:05,100
with what is expected.

73
00:04:05,600 --> 00:04:10,200
As use of the API and you want to try it, unless you really need to

74
00:04:10,200 --> 00:04:10,300
do.

75
00:04:10,300 --> 00:04:15,600
So you want to try not to do a bunch of things with the API that is

76
00:04:15,600 --> 00:04:17,000
not on the common case.

77
00:04:17,000 --> 00:04:21,700
That's not what vendors are expecting to see from various titles,

78
00:04:21,700 --> 00:04:22,200
right?

79
00:04:22,200 --> 00:04:26,700
And so that's just kind of what I want to do here is just do a pass

80
00:04:26,700 --> 00:04:30,700
over it and clean it out since we are using the hardware rendering now

81
00:04:30,700 --> 00:04:35,400
in a sort of more real way where we're actually able to sort of take

82
00:04:35,700 --> 00:04:38,500
Vantage of some of that, of the GPU power.

83
00:04:38,900 --> 00:04:41,600
We really want to go and just make sure that we kind of clean up that

84
00:04:41,600 --> 00:04:43,200
fixed function Miss

85
00:04:44,900 --> 00:04:48,400
So the way I'm going to do that, first of all is we're going to need a

86
00:04:48,400 --> 00:04:51,800
little bit of an ability here to feel debug messages.

87
00:04:51,800 --> 00:04:55,300
Now, I don't know if this driver is supports debug messages, it might

88
00:04:55,300 --> 00:04:59,400
not, but I'm going to try to see if I can get debug messages

89
00:04:59,700 --> 00:05:03,500
registered with it in interrupt mode and I'm going to sort of show you

90
00:05:03,500 --> 00:05:04,100
what that means.

91
00:05:05,100 --> 00:05:08,200
And if I can do that, then what we're going to do is we're going to

92
00:05:08,200 --> 00:05:09,600
switch when we create.

93
00:05:10,400 --> 00:05:13,100
I don't know if you remember this but we created our opengl context.

94
00:05:13,400 --> 00:05:14,300
There's that's this

95
00:05:14,600 --> 00:05:17,400
Elevation process, that needs to happen where we create an opengl

96
00:05:17,400 --> 00:05:19,600
context using the standard win32 API for doing.

97
00:05:19,600 --> 00:05:23,000
So since that API has not been updated by Microsoft and years.

98
00:05:23,300 --> 00:05:27,800
But decades, at this point, you need to call sort of the special

99
00:05:27,800 --> 00:05:30,800
additional command that the driver specifies specifically directly to

100
00:05:30,800 --> 00:05:34,200
you that will Elevate that context to a more modern context.

101
00:05:34,200 --> 00:05:37,000
That's what we had to do in order to access things like frame buffers

102
00:05:37,400 --> 00:05:38,100
and shaders.

103
00:05:38,900 --> 00:05:42,400
When we did that elevation, we specified a thing that said we wanted a

104
00:05:42,400 --> 00:05:44,400
compatibility context and what a compatibility

105
00:05:44,500 --> 00:05:48,600
context is is a context where we can call things like fixed function

106
00:05:48,600 --> 00:05:53,600
pipeline operations that have technically been deprecated in opengl,

107
00:05:53,700 --> 00:05:54,100
right?

108
00:05:54,200 --> 00:05:56,700
And I remember I said opengl is far too sprawling at this point.

109
00:05:56,700 --> 00:05:59,800
I'm talking about the opengl, that's even it's far.

110
00:06:00,000 --> 00:06:00,400
Sprawling.

111
00:06:00,400 --> 00:06:04,400
Even considering the things that they've removed, if you put the

112
00:06:04,400 --> 00:06:07,700
compatibility context of it in now you're talking about a sprawling

113
00:06:07,700 --> 00:06:11,000
API that has a sprawling API bolted onto it which is all the old

114
00:06:11,000 --> 00:06:13,000
Legacy calls that they actually support.

115
00:06:13,000 --> 00:06:16,100
And so again that's just much it's just way too, big of a support

116
00:06:16,100 --> 00:06:18,900
surface to foist on to a driver.

117
00:06:18,900 --> 00:06:21,200
Vendor, definitely not what we want to do.

118
00:06:21,800 --> 00:06:25,600
So what I'm going to do here is I'm going to go ahead and try to get a

119
00:06:25,600 --> 00:06:28,200
debug call back working, that will let us know any time, the driver

120
00:06:28,200 --> 00:06:29,900
encounters an error and then what I'm going

121
00:06:30,000 --> 00:06:34,000
To do is try to turn off that compatibility context and that way

122
00:06:34,000 --> 00:06:38,800
anytime that we try to call a function that is deprecated, hopefully

123
00:06:38,800 --> 00:06:41,400
we will get a call back from the driver saying that that function is

124
00:06:41,400 --> 00:06:42,400
not supported.

125
00:06:42,400 --> 00:06:45,600
That way we can go through and do a quick sweep without us having to

126
00:06:45,600 --> 00:06:48,400
sort of eyeball it and go wait.

127
00:06:48,400 --> 00:06:51,000
Okay, this function isn't supported right, let's search for that.

128
00:06:51,000 --> 00:06:51,400
Let's Okay.

129
00:06:51,400 --> 00:06:54,400
This one isn't supported, let's search for that rather than doing

130
00:06:54,400 --> 00:06:54,700
that.

131
00:06:54,700 --> 00:06:55,800
What we can do is just go.

132
00:06:55,800 --> 00:06:59,900
Okay, let's go through and see everything that the

133
00:07:00,000 --> 00:07:02,600
Complaints about and get rid of all of those, right?

134
00:07:02,800 --> 00:07:04,500
And that's sort of what we want to do here.

135
00:07:05,200 --> 00:07:07,200
So that's what I'm going to try to do again.

136
00:07:07,200 --> 00:07:10,500
When I say try to get the debug callbacks working, I don't necessarily

137
00:07:10,500 --> 00:07:12,800
mean that we won't be able to figure out how to do it.

138
00:07:12,900 --> 00:07:17,700
What I mean is not all drivers and all come not all combinations of

139
00:07:17,700 --> 00:07:21,100
drivers and cards support the debug callbacks.

140
00:07:22,400 --> 00:07:28,400
So AMD drivers, nowadays on a modern, AMD card do support the

141
00:07:28,400 --> 00:07:29,700
callbacks for debugging,

142
00:07:29,900 --> 00:07:30,500
In jail.

143
00:07:31,200 --> 00:07:35,800
This is a very old card and it may not, even though in theory the

144
00:07:35,800 --> 00:07:38,500
drivers are somewhat unified, that's not actually true.

145
00:07:38,500 --> 00:07:43,000
Like for example this machine routinely, if you try to update the AMD

146
00:07:43,000 --> 00:07:45,400
graphics driver it tells you you're on the latest one.

147
00:07:45,400 --> 00:07:47,900
Even though the driver itself will tell you that there's an update.

148
00:07:48,400 --> 00:07:52,900
So just to give you some perspective of just how ridiculous it is, you

149
00:07:52,900 --> 00:07:57,000
know, it's in a state where older cards can't necessarily even use

150
00:07:57,000 --> 00:07:57,800
newer drivers.

151
00:07:57,800 --> 00:07:59,800
So it's possible obviously,

152
00:08:00,000 --> 00:08:03,500
We that you can get into a situation where even though, technically,

153
00:08:03,500 --> 00:08:06,100
you should be able to access a certain feature.

154
00:08:06,100 --> 00:08:10,100
That feature may not actually be accessible to you or your customers

155
00:08:10,200 --> 00:08:10,600
card.

156
00:08:10,600 --> 00:08:13,500
Now, fortunately for debug callbacks we only need the debug callbacks

157
00:08:13,500 --> 00:08:17,300
to work on the developer machine because obviously we don't need to

158
00:08:17,300 --> 00:08:21,700
ship debug callbacks to the end user in any particular way, I mean

159
00:08:21,700 --> 00:08:24,200
unless you have some kind of logging system that you want to build

160
00:08:24,200 --> 00:08:25,400
based on him or something like this.

161
00:08:25,500 --> 00:08:29,800
But for the most part

162
00:08:31,000 --> 00:08:32,900
We don't have to worry too much about that.

163
00:08:33,500 --> 00:08:36,100
So, let's go ahead and open up the source code here, and I'll show you

164
00:08:36,100 --> 00:08:38,200
what we're going to what we want to do here.

165
00:08:38,600 --> 00:08:44,400
So, if I go into handmade code and locks I guess, I'd open the project

166
00:08:44,400 --> 00:08:44,900
first.

167
00:08:44,900 --> 00:08:49,000
Let's go to the opengl subsystem if I look at this open shell sub

168
00:08:49,000 --> 00:08:51,500
system so you can kind of see what I'm talking about here, right?

169
00:08:51,500 --> 00:08:56,700
Like we have all these likes AGL color for VTEC scored 4 V calls,

170
00:08:56,900 --> 00:08:59,900
these were sort of the old calls we're not even calling these anymore.

171
00:09:01,000 --> 00:09:04,300
Like these are only called if we do the opengl display bitmap path,

172
00:09:04,300 --> 00:09:07,400
which is to draw from our what the contents of our software renderer

173
00:09:07,400 --> 00:09:08,000
showed.

174
00:09:09,500 --> 00:09:14,000
So again, that stuff is not particularly interesting, but I don't know

175
00:09:14,000 --> 00:09:14,500
right now.

176
00:09:14,500 --> 00:09:17,900
If we've got more of those sorts of things lying around.

177
00:09:17,900 --> 00:09:21,700
So for example, if you take a look here, here's a GL, Matrix mode GL

178
00:09:21,700 --> 00:09:24,200
load identity call in opengl reader commands.

179
00:09:24,200 --> 00:09:25,800
That is getting called right now.

180
00:09:25,900 --> 00:09:28,600
We don't need that anymore, right?

181
00:09:28,600 --> 00:09:30,700
That is not an actual thing that we are using.

182
00:09:30,700 --> 00:09:33,700
Because since we're going through the fixed function pipeline, I'm

183
00:09:33,700 --> 00:09:33,900
sorry.

184
00:09:33,900 --> 00:09:36,200
Since we're not going to the fixed function pipeline anymore.

185
00:09:36,700 --> 00:09:39,000
We're not setting matrices through that.

186
00:09:39,200 --> 00:09:42,400
Any for any particular reason, what we're doing is setting uniforms

187
00:09:42,400 --> 00:09:45,000
that are Shader reads that can do transforms for us stuff like that.

188
00:09:45,000 --> 00:09:49,800
That's how we're pushing down information about transforms to the GPU

189
00:09:50,000 --> 00:09:51,500
and so stuff like that.

190
00:09:51,500 --> 00:09:54,400
We want to go through and clean all of that stuff out.

191
00:09:54,400 --> 00:09:58,100
And again like I said, one way of doing it would be to just like roll

192
00:09:58,100 --> 00:10:00,400
the dice and try to get them all ourselves.

193
00:10:01,400 --> 00:10:05,300
But that's obviously more error-prone than if we have some Ironclad

194
00:10:05,300 --> 00:10:09,800
way of knowing that we can just flip a bit and say, Hey Driver, why

195
00:10:09,800 --> 00:10:14,800
don't you tell me anytime you see anything that you think is no longer

196
00:10:14,800 --> 00:10:16,500
in your compatibility context?

197
00:10:16,700 --> 00:10:18,500
Now, again, even that's not foolproof.

198
00:10:18,500 --> 00:10:20,400
So we'll probably want to make a pass over it anyway.

199
00:10:20,600 --> 00:10:24,000
There's no obligation on the drivers part to do that correctly.

200
00:10:24,000 --> 00:10:27,600
Really, you know, yes, the spec probably says, something like they

201
00:10:27,600 --> 00:10:30,800
have to do it but even though the spec says something like that, it's

202
00:10:30,800 --> 00:10:31,100
not

203
00:10:31,200 --> 00:10:34,700
Your driver vendors going to spend their time on right there.

204
00:10:35,000 --> 00:10:40,600
Their time is spent trying to make games, run complete like compatibly

205
00:10:40,600 --> 00:10:42,200
and quickly on their cards.

206
00:10:42,400 --> 00:10:51,200
Not trying to adhere to this extremely complicated specification for

207
00:10:51,200 --> 00:10:54,600
opengl, that's sort of wishy-washy and so on.

208
00:10:55,600 --> 00:10:56,200
All right.

209
00:10:56,600 --> 00:10:59,200
So, in order to get these, I don't know.

210
00:10:59,200 --> 00:11:03,300
I'm pretty sure these have made it into the core at this point, at

211
00:11:03,300 --> 00:11:04,600
least made it into ARB.

212
00:11:04,700 --> 00:11:07,500
So I'm not sure if they're documented on Doc's that GLI.

213
00:11:07,600 --> 00:11:09,400
They probably are.

214
00:11:09,800 --> 00:11:10,500
Yeah, here they are.

215
00:11:11,900 --> 00:11:15,500
But as you can see, they're limited to GL for which, I don't know if

216
00:11:15,500 --> 00:11:20,000
we actually have any way of getting now, fortunately, for us there

217
00:11:20,000 --> 00:11:22,800
available as an extension before gl4.

218
00:11:25,200 --> 00:11:27,400
Sorry, still allergy season here for me.

219
00:11:28,200 --> 00:11:28,900
I'm blowing my nose.

220
00:11:28,900 --> 00:11:33,200
Constantly I even took allergy medication this morning, maybe it

221
00:11:33,200 --> 00:11:37,800
hasn't quite kicked in yet anyway opengl for.

222
00:11:37,800 --> 00:11:40,400
I don't know that we actually can get because we tried.

223
00:11:40,400 --> 00:11:43,600
I think we looked at which version of opengl we can go to.

224
00:11:43,800 --> 00:11:46,900
I don't think we were able to get for, but I can't remember.

225
00:11:47,900 --> 00:11:51,800
So, either way, we want it to be on opengl three regardless because we

226
00:11:51,800 --> 00:11:54,200
don't need up in jail for for anything at the moment.

227
00:11:54,800 --> 00:11:58,000
And we don't want to push that compatibility up to require a card

228
00:11:58,000 --> 00:11:59,900
support opengl for features.

229
00:12:00,300 --> 00:12:06,900
So it might appear that we could not use of these debug message calls,

230
00:12:07,200 --> 00:12:11,500
however, that's not actually the case, these debug message calls are

231
00:12:11,500 --> 00:12:16,400
available as extensions in earlier versions of opengl.

232
00:12:16,400 --> 00:12:22,500
Oftentimes so we can try to query for this extension and get it in a

233
00:12:23,600 --> 00:12:24,800
in opengl 3.

234
00:12:25,000 --> 00:12:27,000
So that's the thing that I'm going to try to do again.

235
00:12:27,000 --> 00:12:29,900
Like I said, there's no guarantee that this driver actually supports

236
00:12:30,500 --> 00:12:31,400
This at all.

237
00:12:31,500 --> 00:12:35,500
So we don't know that that's true but we're going to try because

238
00:12:35,500 --> 00:12:38,900
again, that's probably the most efficacious way to do this.

239
00:12:39,500 --> 00:12:44,200
So if I come through here and grab these sort of guys, like I normally

240
00:12:44,200 --> 00:12:48,300
do, we just have a couple functions to grab for the from the core ARB

241
00:12:48,300 --> 00:12:50,800
header and I'll show you what those are.

242
00:12:51,900 --> 00:12:54,000
This is what we're trying to enable right here.

243
00:12:54,000 --> 00:12:59,700
So this GL debug message callback function

244
00:13:00,100 --> 00:13:04,900
is a thing that says, okay, we're going to give you a call an actual

245
00:13:04,900 --> 00:13:10,200
function that we defined and you're going to call us back from the

246
00:13:10,200 --> 00:13:13,600
driver any time, you see an actual error.

247
00:13:14,300 --> 00:13:17,400
And we're not really going to use this callback for anything other

248
00:13:17,400 --> 00:13:19,800
than to just basically, assert right?

249
00:13:19,900 --> 00:13:21,400
We're just going to Halt the program.

250
00:13:21,500 --> 00:13:23,100
So that's all we really want to do.

251
00:13:23,500 --> 00:13:27,200
Because what we're trying to do here is just halt the program in the

252
00:13:27,200 --> 00:13:27,700
debugger.

253
00:13:27,700 --> 00:13:28,600
Any time?

254
00:13:28,600 --> 00:13:29,600
We do something that the

255
00:13:30,000 --> 00:13:33,700
Doesn't like because that's how we're going to be able to get rid of

256
00:13:33,700 --> 00:13:34,300
all those things.

257
00:13:34,300 --> 00:13:35,900
The driver doesn't like, right?

258
00:13:37,400 --> 00:13:39,800
So if we take a look at GL, debug message, call back here.

259
00:13:39,800 --> 00:13:41,400
This is what we're trying to enable.

260
00:13:41,500 --> 00:13:46,300
We want to be able to pass this callback here and and the user program

261
00:13:46,300 --> 00:13:49,300
would just be if we have some data that we want to go get through to

262
00:13:49,300 --> 00:13:50,200
that call back.

263
00:13:50,300 --> 00:13:52,300
We don't actually have to worry about that because we're not doing

264
00:13:52,300 --> 00:13:53,200
anything in the Callback.

265
00:13:53,500 --> 00:13:57,400
But this is the thing that we're trying to actually Define right here.

266
00:13:58,000 --> 00:14:00,800
So, this is the thing that we want to enable, you can see the debug

267
00:14:00,800 --> 00:14:01,800
message call back.

268
00:14:02,600 --> 00:14:06,800
There we go, has some sort of associated stuff.

269
00:14:07,000 --> 00:14:08,800
You can see, get debug message.

270
00:14:08,800 --> 00:14:12,900
Log is a, an alternate way of using this, which allows you to instead

271
00:14:12,900 --> 00:14:13,900
of getting called back for stuff.

272
00:14:13,900 --> 00:14:17,000
It allows you to kind of get when you're ready like hey, give me all

273
00:14:17,000 --> 00:14:17,400
the message.

274
00:14:17,400 --> 00:14:20,900
You have up to a point debug message insert, lets you put messages to

275
00:14:20,900 --> 00:14:24,500
debug stream, pop and push debug group allows you to like, put markers

276
00:14:24,500 --> 00:14:24,800
in.

277
00:14:25,600 --> 00:14:26,900
We don't need any of this again.

278
00:14:26,900 --> 00:14:29,400
All we're trying to do is just make it so that basically the driver

279
00:14:29,400 --> 00:14:30,400
will stop our program.

280
00:14:30,400 --> 00:14:31,800
Anytime it doesn't doesn't want.

281
00:14:31,900 --> 00:14:34,100
It's just basically, a way of implementing an assertion.

282
00:14:34,300 --> 00:14:36,800
So all we really care about is GL, debug message,

283
00:14:36,900 --> 00:14:37,500
Control.

284
00:14:37,600 --> 00:14:41,100
That's the only other function besides setting the Callback that we

285
00:14:41,100 --> 00:14:41,700
actually need.

286
00:14:41,700 --> 00:14:45,700
And what that is is it's a way of telling opengl what you actually

287
00:14:45,700 --> 00:14:50,400
want it to do in terms of debug logging, right?

288
00:14:52,000 --> 00:14:54,100
So you can see deal deal GL.

289
00:14:54,100 --> 00:14:56,800
Debug message control has tons of stuff.

290
00:14:57,000 --> 00:14:59,800
Source is where the message is coming.

291
00:15:00,000 --> 00:15:01,900
From type is what type of message.

292
00:15:01,900 --> 00:15:05,800
It is severity is what like level of alertness is like.

293
00:15:05,800 --> 00:15:06,600
Is it just a note?

294
00:15:06,600 --> 00:15:08,500
Is it an hard error, etc.

295
00:15:08,500 --> 00:15:14,500
Etc, count is basically like telling it how many of these IDs that are

296
00:15:14,500 --> 00:15:14,800
coming.

297
00:15:14,800 --> 00:15:17,900
Next, they're going to be if you want to talk about specific IDs and

298
00:15:17,900 --> 00:15:21,800
then enabled is enable.

299
00:15:21,800 --> 00:15:24,900
This is saying like whether you want those messages enabled or not?

300
00:15:25,400 --> 00:15:28,100
Now, I don't know if we actually need to call this because I don't

301
00:15:28,100 --> 00:15:30,000
remember whether these will all be

302
00:15:30,000 --> 00:15:31,900
I'll be on by default.

303
00:15:32,900 --> 00:15:35,400
I going to, I'm just going to look through here to see.

304
00:15:36,800 --> 00:15:37,700
Let's see.

305
00:15:37,800 --> 00:15:39,100
The code is just going to shoes.

306
00:15:39,100 --> 00:15:45,000
Do a concert ticket about a reverse so we may never need to call this

307
00:15:45,000 --> 00:15:45,300
one.

308
00:15:45,300 --> 00:15:50,800
I'm just not sure whether or not it's necessary to.

309
00:15:53,400 --> 00:15:57,200
Yeah, I just don't know whether it's necessary to actually call this

310
00:15:57,200 --> 00:16:00,800
one or not, because I don't remember whether or not these things are

311
00:16:00,800 --> 00:16:03,000
just we'll all be on by default.

312
00:16:03,000 --> 00:16:07,900
I assume that that is true, but I can't find anything here that says.

313
00:16:07,900 --> 00:16:10,400
So we'll start out assuming that we don't.

314
00:16:10,400 --> 00:16:15,200
And then if we're having trouble, we'll we'll go ahead and and, and

315
00:16:15,200 --> 00:16:16,000
look a little closer.

316
00:16:16,200 --> 00:16:18,700
Now, there's one of the things I think we have to do which is enable

317
00:16:18,700 --> 00:16:19,600
the message log.

318
00:16:19,600 --> 00:16:23,000
I'm going to leave that up for us, so there's

319
00:16:23,100 --> 00:16:24,400
Those two right there.

320
00:16:25,700 --> 00:16:30,900
I feel like there's a GL enable, 4gl debug message, call back.

321
00:16:36,500 --> 00:16:40,900
And I just want to go ahead and see if I can grab that here somewhere.

322
00:16:42,200 --> 00:16:43,600
Let's see.

323
00:16:46,600 --> 00:16:47,700
No, that's it.

324
00:16:49,100 --> 00:16:49,800
Typo there.

325
00:16:51,100 --> 00:16:51,500
All right.

326
00:16:51,500 --> 00:16:52,200
So, let's see.

327
00:16:52,200 --> 00:16:55,500
This is the spec for the original when it was created.

328
00:16:57,000 --> 00:16:58,300
Let me just take a look here.

329
00:17:00,300 --> 00:17:03,200
So here's the okay, this is the one we're looking for here.

330
00:17:03,500 --> 00:17:06,599
So do you see this debug output synchronous are?

331
00:17:07,400 --> 00:17:12,000
This is kind of what I was wanting to be able to set and it goes

332
00:17:12,000 --> 00:17:13,099
through GL and Abel.

333
00:17:13,400 --> 00:17:16,400
Basically, this is a GL enable bit which tells us.

334
00:17:16,400 --> 00:17:21,900
Hey, I want you to try and generate errors immediately if you can.

335
00:17:25,099 --> 00:17:27,500
And I know that's a little bit of a weird idea.

336
00:17:28,800 --> 00:17:28,900
Son.

337
00:17:29,800 --> 00:17:36,000
Sort of explain what that means, what happens in an opengl driver or

338
00:17:36,000 --> 00:17:37,900
any graphics card driver for that matter.

339
00:17:38,600 --> 00:17:43,000
Is that in order to improve performance or in order to even make the

340
00:17:43,000 --> 00:17:49,100
card function at all for obvious reasons, they have to be delays in

341
00:17:49,100 --> 00:17:51,300
terms of when things are processed.

342
00:17:51,300 --> 00:17:53,200
Because remember, a GPU.

343
00:17:53,800 --> 00:17:57,200
Even in the case where it's on the same die as a CPU, like in a

344
00:17:57,200 --> 00:17:59,400
bulldozer core or in

345
00:17:59,500 --> 00:17:59,900
Tell.

346
00:18:00,000 --> 00:18:05,400
Integrated graphics, for example, even in that case, the operation of

347
00:18:05,400 --> 00:18:11,200
the GPU part of the chip is not lockstep necessarily with the CPU part

348
00:18:11,200 --> 00:18:13,100
of the chip in any logical way.

349
00:18:14,500 --> 00:18:19,200
Meaning it's not like when you say I'm going to do this specific batch

350
00:18:19,200 --> 00:18:20,300
of drawing Primitives.

351
00:18:20,300 --> 00:18:24,200
You don't want the CPU to sit around waiting for the GPU to do those

352
00:18:24,200 --> 00:18:25,100
things, right?

353
00:18:25,100 --> 00:18:27,900
Even in the case, where you could do that exactly.

354
00:18:28,500 --> 00:18:29,800
Because you've got the

355
00:18:30,000 --> 00:18:31,000
Same ship in charge.

356
00:18:31,000 --> 00:18:32,900
That's not what these are designed to do.

357
00:18:32,900 --> 00:18:37,100
The GPU is designed to be processing like streamed processing.

358
00:18:37,100 --> 00:18:41,700
An amount of computational work load for the graphics while the CPU is

359
00:18:41,700 --> 00:18:43,400
doing whatever else it wants to do.

360
00:18:43,400 --> 00:18:47,200
And so as a result, whenever you make a call to a graphics driver,

361
00:18:47,200 --> 00:18:52,000
you're typically talking about a lot of wait, time in turn in CPU land

362
00:18:52,100 --> 00:18:57,400
between when that call gets issued and when the results of that call

363
00:18:57,400 --> 00:18:59,800
materialize, and this can come from a lot of different ways,

364
00:19:00,000 --> 00:19:02,600
One is just waiting for them to be processed by GPU.

365
00:19:02,800 --> 00:19:07,200
Another is that things want to get buffered up into chunks coherent

366
00:19:07,200 --> 00:19:12,400
chunks, that got get handed to the GPU as a batch especially in cases,

367
00:19:12,700 --> 00:19:15,700
where it's not on the same diet where you're talking about a PCI bus

368
00:19:15,700 --> 00:19:19,400
transfer or something else in order to get the data from the CPU over

369
00:19:19,400 --> 00:19:22,100
to the GPU for processing.

370
00:19:22,600 --> 00:19:27,000
And so what happens in that driver is when you make a call, it may not

371
00:19:27,000 --> 00:19:29,800
even have enough information at that time.

372
00:19:29,900 --> 00:19:33,800
Potentially to issue an error because it may not have seen enough

373
00:19:33,800 --> 00:19:34,400
later.

374
00:19:34,400 --> 00:19:38,200
Things about how you are drawing to know that you actually made an

375
00:19:38,200 --> 00:19:38,400
error.

376
00:19:38,400 --> 00:19:41,500
This is especially bad in opengl who still retains.

377
00:19:41,700 --> 00:19:46,300
If you use, if you don't use the most modern opengl 4.5 a zdo stuff,

378
00:19:46,600 --> 00:19:49,400
if you're still kind of like we are in a more compatibility mode where

379
00:19:49,400 --> 00:19:53,500
you're using opengl 3 or something like that, you're still talking

380
00:19:53,500 --> 00:19:57,400
about making calls that set a lot of state and that state only becomes

381
00:19:57,400 --> 00:19:59,800
erroneous at the time, when a draw call actually

382
00:20:00,000 --> 00:20:01,000
Gets executed.

383
00:20:01,100 --> 00:20:05,700
So, for example, if I execute a draw call and that draw call has some

384
00:20:05,700 --> 00:20:09,100
state that it expects to be set, but you never set that state.

385
00:20:09,100 --> 00:20:12,400
That is the time when the error is going to get generated.

386
00:20:12,400 --> 00:20:15,900
Not at the time when you made the state call and maybe set the wrong

387
00:20:15,900 --> 00:20:16,300
state.

388
00:20:16,300 --> 00:20:20,400
For example, it only knows that the state was set incorrectly when it

389
00:20:20,400 --> 00:20:24,400
actually gets the time that you were supposed to do the execution.

390
00:20:24,500 --> 00:20:26,200
And that's the best case scenario, right?

391
00:20:26,200 --> 00:20:28,700
The worst case scenario is during that call, it's just putting that

392
00:20:28,700 --> 00:20:29,800
into a buffer and

393
00:20:29,900 --> 00:20:33,200
Later, there's some buffer validation, that's happening way down the

394
00:20:33,200 --> 00:20:35,100
line and that's when it knows, there's an error.

395
00:20:36,500 --> 00:20:41,500
So again, you have to remember that this the driver underneath you and

396
00:20:41,500 --> 00:20:44,000
that that's, you know, sort of working with this relatively complex

397
00:20:44,000 --> 00:20:47,100
queuing system to get things off to the GPU.

398
00:20:47,100 --> 00:20:50,400
And this sort of State, tracking that opengl voice upon it.

399
00:20:50,400 --> 00:20:53,100
For the older style, three point x opengl stuff.

400
00:20:53,300 --> 00:20:58,800
Again, opengl 4.5 a video and Vulcan DirectX, 12, these sorts of

401
00:20:58,800 --> 00:20:59,800
things have less.

402
00:21:00,000 --> 00:21:03,800
That you're expected to specify more things directly.

403
00:21:04,500 --> 00:21:07,200
But, you know, again, we're sort of a little more compatibility at the

404
00:21:07,200 --> 00:21:07,700
moment.

405
00:21:07,800 --> 00:21:09,500
We're not pushing those this card.

406
00:21:09,500 --> 00:21:11,300
Probably can't the driver.

407
00:21:11,300 --> 00:21:13,500
That's currently on this machine, probably can't do them anyway.

408
00:21:15,300 --> 00:21:18,100
So given all the, that all of those things are true.

409
00:21:18,600 --> 00:21:22,400
What we're setting here is we're setting a flag that says Hey Driver.

410
00:21:22,400 --> 00:21:27,600
If you can, if you have this capability in you which again there's

411
00:21:27,600 --> 00:21:28,900
things called debug drivers.

412
00:21:28,900 --> 00:21:29,600
You can install for

413
00:21:30,000 --> 00:21:33,300
People, which are different than release mode drivers, which may, for

414
00:21:33,300 --> 00:21:36,400
example, have things compiled into enable this more than it would

415
00:21:36,400 --> 00:21:37,500
normally be enabled.

416
00:21:38,000 --> 00:21:42,400
This is saying if you could go out of your way, make performance

417
00:21:42,400 --> 00:21:44,500
worse, that's fine.

418
00:21:44,500 --> 00:21:46,900
Like it's we're not worried about performance right now.

419
00:21:48,000 --> 00:21:51,800
You can make performance worse and go ahead and try to give me error

420
00:21:51,800 --> 00:21:53,400
messages on the call.

421
00:21:53,400 --> 00:21:58,800
They most clearly can be identified on rather than later when they may

422
00:21:58,800 --> 00:21:59,900
actually have been.

423
00:22:00,000 --> 00:22:05,100
More when the error would actually have occurred in a real sense,

424
00:22:05,200 --> 00:22:09,800
meaning when your most optimal path would have detected, something was

425
00:22:09,800 --> 00:22:10,200
wrong.

426
00:22:11,200 --> 00:22:14,700
If that's much later, try to do some checking up front, that will

427
00:22:14,700 --> 00:22:16,700
allow me to know early, right?

428
00:22:17,000 --> 00:22:21,900
And that's what this G of this, debug output synchronous ARB B is for,

429
00:22:22,100 --> 00:22:24,800
and we definitely want that, right?

430
00:22:25,800 --> 00:22:27,200
The rest of this stuff.

431
00:22:27,200 --> 00:22:29,300
I don't know that we need.

432
00:22:30,200 --> 00:22:32,200
It doesn't look like we need anything here.

433
00:22:35,000 --> 00:22:40,300
And I don't see any enable at the moment, so I think, and I'm not

434
00:22:40,300 --> 00:22:41,100
totally sure.

435
00:22:41,100 --> 00:22:47,400
Again, it's been a while, but I believe all we will have to do is call

436
00:22:47,400 --> 00:22:50,400
the debug message, call back function to register.

437
00:22:50,400 --> 00:22:53,500
The fact that we'd like to call back to an errors and then enable the

438
00:22:53,500 --> 00:22:54,800
synchronous output.

439
00:22:56,600 --> 00:23:01,000
So that whenever an error occurs, if the driver has the capability, it

440
00:23:01,000 --> 00:23:04,400
will cause back right on the call rather than some time later.

441
00:23:08,300 --> 00:23:08,900
So again.

442
00:23:10,400 --> 00:23:13,400
With the major caveat that I don't know if this is actually going to

443
00:23:13,400 --> 00:23:15,300
work on this card at all.

444
00:23:16,100 --> 00:23:16,700
Here we go.

445
00:23:19,000 --> 00:23:21,800
So, the first thing we're going to need is a typedef for the debug

446
00:23:21,800 --> 00:23:22,800
proc itself.

447
00:23:23,500 --> 00:23:27,400
The debug proc is the thing that's going to be the function prototype

448
00:23:27,400 --> 00:23:29,700
for our actual call, right?

449
00:23:30,400 --> 00:23:32,400
And so here, is that what that looks like?

450
00:23:32,400 --> 00:23:34,200
Oops, I missed some of it.

451
00:23:35,000 --> 00:23:35,800
Sorry about that.

452
00:23:37,000 --> 00:23:38,300
So, here's what that looks like.

453
00:23:38,300 --> 00:23:39,900
And so this is essentially the

454
00:23:41,100 --> 00:23:45,400
You know, the call that we could put that in there.

455
00:23:46,900 --> 00:23:49,200
I don't like the pointer bind version of this.

456
00:23:49,200 --> 00:23:50,100
I'm going to do it like that.

457
00:23:51,100 --> 00:23:54,700
So here is what a GL debug proc looks like, right?

458
00:23:55,500 --> 00:23:59,100
And this is what we are going to receive as a call.

459
00:23:59,300 --> 00:23:59,800
So we

460
00:24:00,000 --> 00:24:05,900
Define one of these in our opengl, you know, binding layer here right.

461
00:24:06,600 --> 00:24:09,300
Something that looks exactly like this because we're going to have to

462
00:24:09,300 --> 00:24:13,100
pass a pointer to this function to the opengl driver so that it will

463
00:24:13,100 --> 00:24:16,500
be able to call us back at it right?

464
00:24:16,500 --> 00:24:17,300
And there it is.

465
00:24:18,900 --> 00:24:21,300
Now we don't actually have to do anything here.

466
00:24:21,400 --> 00:24:25,400
All we want at this point is just to Halt, right?

467
00:24:25,700 --> 00:24:27,000
That's all we want.

468
00:24:27,000 --> 00:24:31,400
Now since again, I don't really want this to be platform-specific.

469
00:24:31,800 --> 00:24:36,000
I don't want to have to include things like win API in the opengl.

470
00:24:36,000 --> 00:24:39,200
You know, the non platform layer part of things.

471
00:24:39,400 --> 00:24:41,500
So what I'm going to do here is I'm going to use that trick we use

472
00:24:41,500 --> 00:24:47,700
before where like I can say Shield, debug call back or something like

473
00:24:47,700 --> 00:24:48,600
this and

474
00:24:48,800 --> 00:24:49,400
A name.

475
00:24:49,700 --> 00:24:51,600
And then, I'm going to have this be

476
00:24:56,100 --> 00:24:57,500
That function prototype.

477
00:24:58,700 --> 00:25:01,200
Whatever it requires for this particular platform.

478
00:25:01,400 --> 00:25:04,900
Then in this typedef I'm just going to say, okay, the type of this

479
00:25:04,900 --> 00:25:05,400
thing.

480
00:25:09,000 --> 00:25:12,700
can be derived from that and then anyone who wants to make one of

481
00:25:12,700 --> 00:25:15,500
these can just say GLD bug call back

482
00:25:20,600 --> 00:25:23,300
open guilty about call back and then we'll have it here just the

483
00:25:23,300 --> 00:25:29,100
ability to say like, hey, cert opengl error encountered,

484
00:25:30,500 --> 00:25:31,000
Right.

485
00:25:32,800 --> 00:25:33,400
And there we go.

486
00:25:35,300 --> 00:25:40,300
So that's all we need to do in terms of making a place for opengl to

487
00:25:40,300 --> 00:25:43,000
like actually tell us what needs to happen.

488
00:25:43,100 --> 00:25:44,100
Oops, I've got a

489
00:25:45,500 --> 00:25:45,800
Suspect.

490
00:25:45,800 --> 00:25:46,400
I've got it yet.

491
00:25:47,100 --> 00:25:47,900
Semicolon in there.

492
00:25:49,300 --> 00:25:52,000
So that's all we need for opengl to be able to tell us what to do.

493
00:25:52,800 --> 00:25:56,400
And then what we now need is for the part where we tell open Jill what

494
00:25:56,400 --> 00:25:58,300
to do which is enabling that.

495
00:25:58,300 --> 00:26:02,800
So in order to do that, we just need the two pieces of ice already had

496
00:26:02,800 --> 00:26:03,800
that open my bad.

497
00:26:04,100 --> 00:26:05,100
Oh wait, no, I didn't.

498
00:26:06,500 --> 00:26:10,500
Thought that tab with also it, but it wasn't so all we need.

499
00:26:10,500 --> 00:26:12,800
There is that synchronous bit.

500
00:26:14,900 --> 00:26:15,400
Here it is.

501
00:26:19,200 --> 00:26:20,200
Let's do that.

502
00:26:21,700 --> 00:26:23,500
So we need to pound Define that

503
00:26:26,600 --> 00:26:31,500
and we can put that in here because that's again not specific to any

504
00:26:31,500 --> 00:26:32,200
platform.

505
00:26:32,500 --> 00:26:36,300
So there's the synchronous output bit and we need to Jill enable that.

506
00:26:36,300 --> 00:26:37,600
So we're going to have to at some point.

507
00:26:37,600 --> 00:26:43,000
To a Jill enable GL, not called debug output synchronous.

508
00:26:47,900 --> 00:26:49,900
We're going to want to do that when we initialize.

509
00:26:49,900 --> 00:26:54,100
So basically, like right in here, when we're about to do all of our

510
00:26:54,100 --> 00:26:57,800
setup, we want to get that synchronous.

511
00:26:59,200 --> 00:26:59,700
Debugging.

512
00:27:00,800 --> 00:27:05,400
And similarly at, you know, in addition to that we're going to want

513
00:27:05,400 --> 00:27:11,400
the the debug message call back call right there.

514
00:27:11,500 --> 00:27:13,900
So that as soon as we start, we have that in there.

515
00:27:17,600 --> 00:27:18,800
Let's grab that out.

516
00:27:20,800 --> 00:27:22,900
So, there's two of those.

517
00:27:24,300 --> 00:27:25,800
It says the ARB one.

518
00:27:29,500 --> 00:27:35,200
And the non ARB one, I don't know which one we should be getting.

519
00:27:36,200 --> 00:27:38,100
So this is the one from opengl.

520
00:27:38,100 --> 00:27:40,500
This is the one from the extension.

521
00:27:40,800 --> 00:27:44,200
I think we want the one from the extension because like I said we

522
00:27:44,200 --> 00:27:48,600
aren't using opengl for so we should probably ask for this one.

523
00:27:48,600 --> 00:27:50,000
If they really are different.

524
00:27:50,000 --> 00:27:55,700
I don't know if they are or not, but let's let's just go ahead and

525
00:27:56,600 --> 00:27:57,800
let's go ahead and see.

526
00:27:58,300 --> 00:27:59,200
So I'm going to go ahead and

527
00:27:59,400 --> 00:28:00,300
This guy in here.

528
00:28:05,300 --> 00:28:06,200
So there's that GL.

529
00:28:06,200 --> 00:28:06,900
Debug message.

530
00:28:06,900 --> 00:28:07,600
Call back.

531
00:28:08,100 --> 00:28:09,600
I'm going to go ahead and put type in there.

532
00:28:09,600 --> 00:28:10,900
It's way we're doing it before.

533
00:28:12,000 --> 00:28:12,900
So we've got this deal.

534
00:28:12,900 --> 00:28:14,700
Debug proc our piece

535
00:28:18,900 --> 00:28:22,500
That's just one of these and then we got that user program there.

536
00:28:22,500 --> 00:28:25,800
So that's what opengl expects us to do to tell it.

537
00:28:26,200 --> 00:28:30,400
We got to do our little Global variable piece or open Jill function

538
00:28:31,000 --> 00:28:31,600
bit here.

539
00:28:34,400 --> 00:28:37,100
So, that's let's see.

540
00:28:37,100 --> 00:28:42,000
GL debug message, call back ARB.

541
00:28:43,200 --> 00:28:46,200
And I think that's all we really need.

542
00:28:46,300 --> 00:28:50,200
Now, we can just ask for it and hope that we actually get it.

543
00:28:50,400 --> 00:28:52,500
So, let's look at vertex, a trip pointer.

544
00:28:56,500 --> 00:29:02,600
Go to get opengl function, and there's that.

545
00:29:03,700 --> 00:29:07,900
So hopefully again, we don't really know, but hopefully that will work

546
00:29:08,700 --> 00:29:10,400
and and we'll get some love there.

547
00:29:10,400 --> 00:29:11,800
But I don't know if we will or not.

548
00:29:12,700 --> 00:29:15,600
Let's step through here and see what we see.

549
00:29:16,000 --> 00:29:18,800
So, let's jump in here.

550
00:29:20,600 --> 00:29:24,700
I forgot to call it, that's not going to help.

551
00:29:31,300 --> 00:29:35,000
Alright, so here after the GL enable, I guess or doesn't matter really

552
00:29:35,000 --> 00:29:38,800
where could be in the before or after I don't think that matters.

553
00:29:39,200 --> 00:29:42,500
So after we call gln Able with GL debug output, synchronous, we have

554
00:29:42,500 --> 00:29:46,300
GL, debug message, callback ARB, we want to pass that opengl debug

555
00:29:46,300 --> 00:29:49,600
call back and then we don't have any user parameter to pass to it.

556
00:29:49,800 --> 00:29:52,900
So that's really all we're talking about here again.

557
00:29:52,900 --> 00:29:54,000
I don't know what the knee.

558
00:29:54,000 --> 00:29:57,100
I'm assuming this is the right one to query for we'll see and

559
00:29:57,100 --> 00:29:59,900
obviously this is only going to work in the case where we actually

560
00:30:00,000 --> 00:30:01,200
We got one of these.

561
00:30:01,400 --> 00:30:05,300
So, if opengl debug callback wasn't available, I'm sorry.

562
00:30:05,500 --> 00:30:07,300
If GL, debug message call back.

563
00:30:07,300 --> 00:30:08,400
Our wasn't available.

564
00:30:08,400 --> 00:30:12,800
If that function query failed, then obviously we can't call it.

565
00:30:13,400 --> 00:30:15,800
So, I'm going to go ahead now and just do a little.

566
00:30:16,100 --> 00:30:16,700
There we go.

567
00:30:18,100 --> 00:30:20,500
So it looks like it was available, which is great news for us, at

568
00:30:20,500 --> 00:30:20,700
least.

569
00:30:20,700 --> 00:30:22,300
That means we got a chance of getting it working.

570
00:30:22,800 --> 00:30:25,500
We call enable there and we'll set the call backup.

571
00:30:25,900 --> 00:30:28,200
Now when we call the see if we get it, we did.

572
00:30:28,200 --> 00:30:29,100
So that's actually good.

573
00:30:29,100 --> 00:30:33,800
So now we're actually getting some errors callbacks which is great.

574
00:30:34,400 --> 00:30:36,800
And remember this opengl debug call back here?

575
00:30:37,600 --> 00:30:40,400
I suppose we should probably make it a little easier to look at their

576
00:30:40,400 --> 00:30:44,800
I guess without having to come back here to the name but it's this

577
00:30:44,800 --> 00:30:47,300
message here is the thing that we're actually interested in.

578
00:30:48,000 --> 00:30:51,300
And so if we want to, we can actually do, we could do something like

579
00:30:51,300 --> 00:30:51,800
this.

580
00:31:00,500 --> 00:31:01,000
There we go.

581
00:31:02,900 --> 00:31:03,400
See.

582
00:31:07,000 --> 00:31:07,600
so,

583
00:31:11,800 --> 00:31:15,100
Here we go with the assertion and then if we just want to know what

584
00:31:15,100 --> 00:31:19,700
the error messages we can always just look at what that looks like GL

585
00:31:19,700 --> 00:31:24,500
text image 2D multi-sample parameter internal format has an invalid

586
00:31:24,500 --> 00:31:27,000
enum, oxc 43.

587
00:31:27,700 --> 00:31:31,600
So this is actually complaining about one of our existing calls even

588
00:31:31,600 --> 00:31:34,500
though we're in a working mode, the moment that's actually very good

589
00:31:34,500 --> 00:31:35,000
news.

590
00:31:37,400 --> 00:31:38,500
That's great to know.

591
00:31:39,000 --> 00:31:42,300
It means something in here is failing.

592
00:31:45,100 --> 00:31:46,200
Yeah, I guess this is.

593
00:31:46,300 --> 00:31:49,500
This is actually I guess by design for us though, right?

594
00:31:49,500 --> 00:31:55,200
This is the part where we tried to create one with srgb alpha 8, and

595
00:31:55,200 --> 00:31:57,200
of course it tells us that you can't.

596
00:31:58,300 --> 00:32:02,000
And so then we have to turn it off, right?

597
00:32:04,100 --> 00:32:07,000
So I guess that's an error that we expect to have happen.

598
00:32:07,100 --> 00:32:10,800
And and we don't really know any other way of getting around it.

599
00:32:11,200 --> 00:32:13,300
So I suppose we're going to need something there.

600
00:32:14,600 --> 00:32:16,600
To obviate that for us.

601
00:32:22,200 --> 00:32:26,000
so, I'm guessing that probably, what we would have to do is

602
00:32:28,600 --> 00:32:31,000
Is actually turn this on and off around there.

603
00:32:31,400 --> 00:32:32,000
Right.

604
00:32:33,100 --> 00:32:40,400
So we need this to happen before we set up that callback basically,

605
00:32:41,300 --> 00:32:43,300
which is probably fine, right?

606
00:32:43,300 --> 00:32:45,300
Let's see, Reserve with texture.

607
00:32:45,600 --> 00:32:49,100
So essentially what we could do is say, well, we got to leave this

608
00:32:49,100 --> 00:32:51,500
till here, but everything else is fine.

609
00:32:52,800 --> 00:32:53,500
Let's try that.

610
00:32:55,600 --> 00:32:58,700
So there we are running with no errors at the moment.

611
00:33:01,800 --> 00:33:03,900
Which is sort of what we would expect.

612
00:33:04,500 --> 00:33:08,200
Because presumably, if we had any errors that were at all serious, we

613
00:33:08,200 --> 00:33:12,800
should have seen some kind of a bug in the drawing of our game that

614
00:33:13,100 --> 00:33:15,700
was related to the fact that it opengl couldn't do the thing.

615
00:33:15,700 --> 00:33:16,600
We're asking it to do.

616
00:33:17,600 --> 00:33:21,900
All right, so now let's switch over here and see if we can get this to

617
00:33:21,900 --> 00:33:26,600
tell us some things that it doesn't like about the compatibility

618
00:33:26,600 --> 00:33:27,400
context, right?

619
00:33:27,400 --> 00:33:29,600
If I turn off that compatibility context,

620
00:33:30,200 --> 00:33:32,000
See if we can get some debug calls that tell us.

621
00:33:32,000 --> 00:33:34,200
Hey, here are the places where you're calling things that you

622
00:33:34,200 --> 00:33:37,700
shouldn't be calling if you're trying to use more modern opengl.

623
00:33:38,200 --> 00:33:40,000
So, here's that compatibility.

624
00:33:40,000 --> 00:33:41,400
Oops, if I spell it right.

625
00:33:43,700 --> 00:33:46,000
So, here's that compatibility bit that we're setting, right?

626
00:33:46,000 --> 00:33:47,100
You can see it right here.

627
00:33:47,400 --> 00:33:48,600
Here's the profile mask.

628
00:33:48,600 --> 00:33:50,600
Here's the compatibility profile bit ARB.

629
00:33:51,100 --> 00:33:55,600
So if we wanted to set it to core profile, which is this now we set it

630
00:33:55,600 --> 00:33:56,500
to core profile.

631
00:33:56,500 --> 00:33:59,700
I believe that should complain.

632
00:33:59,700 --> 00:34:03,200
If we are calling a bunch of things that aren't in the core profile.

633
00:34:03,200 --> 00:34:03,800
Now I don't know.

634
00:34:03,800 --> 00:34:04,800
That's actually true.

635
00:34:06,700 --> 00:34:09,199
Does, it does not appear to be true unfortunately.

636
00:34:10,500 --> 00:34:12,100
So I guess that may not actually

637
00:34:12,300 --> 00:34:12,699
Help us.

638
00:34:12,900 --> 00:34:18,100
Well, maybe the forward compatibility bit needs to get set.

639
00:34:18,100 --> 00:34:21,600
I don't know, it's this right here.

640
00:34:24,199 --> 00:34:26,699
We could try it the forward, compatible bit.

641
00:34:26,699 --> 00:34:31,699
I think is supposed to warn you when you're calling things.

642
00:34:31,699 --> 00:34:35,400
That might not be forward compatible with future versions of opengl.

643
00:34:36,800 --> 00:34:38,699
So we'll see.

644
00:34:44,199 --> 00:34:44,699
So, that's good.

645
00:34:44,699 --> 00:34:45,800
We got an error.

646
00:34:46,300 --> 00:34:48,699
Let's hope that that's actually true.

647
00:34:50,000 --> 00:34:54,400
Okay, so here's the open gel in it and we're getting an error message.

648
00:34:54,400 --> 00:34:57,600
Here, that's usually using G, ltch semi and a Core Concepts with

649
00:34:57,600 --> 00:34:58,700
parameter P name.

650
00:35:01,100 --> 00:35:03,300
Is an error that's actually true.

651
00:35:04,200 --> 00:35:06,200
The reason we don't need this anymore.

652
00:35:06,200 --> 00:35:10,800
If you think about what GL, Tex end of I was doing in this call, what

653
00:35:10,800 --> 00:35:14,900
this was doing with setting the mode where the, when the texture got

654
00:35:14,900 --> 00:35:19,400
read, what it was going to do with the color that came out of the

655
00:35:19,400 --> 00:35:24,200
texture and GL modulate, which is the parameter passing there was

656
00:35:24,200 --> 00:35:24,700
telling it.

657
00:35:24,700 --> 00:35:28,300
Hey, I want you to multiply the color from the texture with the

658
00:35:28,300 --> 00:35:30,800
incoming color that I set on the

659
00:35:31,000 --> 00:35:31,400
Text.

660
00:35:31,700 --> 00:35:35,800
That was how we were telling the fixed function pipeline what to do.

661
00:35:36,200 --> 00:35:37,900
But we don't need to do that anymore, right?

662
00:35:37,900 --> 00:35:41,500
Because now we have complete control over the equation in its you know

663
00:35:41,500 --> 00:35:45,000
in all its Glory here in the fragment Shader, right?

664
00:35:45,100 --> 00:35:49,000
So where that got implemented was right here, right here, is that

665
00:35:49,000 --> 00:35:49,700
modulation?

666
00:35:49,700 --> 00:35:53,000
Here's the fragment color that we produce so far and the texture

667
00:35:53,000 --> 00:35:53,600
sample.

668
00:35:54,800 --> 00:35:57,900
That we took from the texture and we're multiplying them together.

669
00:35:58,000 --> 00:35:59,800
That's really all we're

670
00:36:00,000 --> 00:36:01,500
Talking about here, right?

671
00:36:02,400 --> 00:36:05,700
And so, that's just total vestigial remain.

672
00:36:05,700 --> 00:36:06,800
We don't need it at all.

673
00:36:07,200 --> 00:36:10,000
And so, that's a good thing to get rid of, this is exactly what I was

674
00:36:10,000 --> 00:36:13,900
hoping for right, because you can see how this is an easy way to just

675
00:36:13,900 --> 00:36:15,500
get a bunch of these out of the program.

676
00:36:15,900 --> 00:36:17,500
So hopefully this will work pretty well.

677
00:36:17,600 --> 00:36:19,600
So that's just not necessary anymore at all.

678
00:36:19,600 --> 00:36:19,800
Right.

679
00:36:19,800 --> 00:36:23,800
That is a non, it's an ineffectual call.

680
00:36:24,200 --> 00:36:25,400
So what else we got?

681
00:36:25,800 --> 00:36:28,000
Gee L Alpha Funk has been removed.

682
00:36:28,200 --> 00:36:29,800
That's a another good one.

683
00:36:30,000 --> 00:36:30,500
Right.

684
00:36:30,700 --> 00:36:36,600
So Alpha test is a still a thing but Alpha Funk isn't the reason for

685
00:36:36,600 --> 00:36:40,200
that is if you think about what's going on here and we didn't really

686
00:36:40,200 --> 00:36:42,000
cover this into great detail.

687
00:36:42,000 --> 00:36:44,800
Fact, I suppose we probably need to now.

688
00:36:44,800 --> 00:36:47,300
I think about it actually use this in here.

689
00:36:48,600 --> 00:36:49,900
Alright, so this is pretty interesting.

690
00:36:49,900 --> 00:36:50,900
We can talk about this.

691
00:36:52,200 --> 00:36:53,700
So, what happens in here?

692
00:36:55,500 --> 00:36:59,300
You have to go back a couple weeks to when we were first implementing.

693
00:36:59,300 --> 00:37:04,000
This our Sprites have an alpha of zero everywhere that there's no

694
00:37:04,000 --> 00:37:04,500
image, right?

695
00:37:04,500 --> 00:37:07,600
Because remember we're working with rectangles in a lot of these cases

696
00:37:08,400 --> 00:37:11,600
and there's a lot of empty space around them that empty space is

697
00:37:11,600 --> 00:37:16,300
marked with an alpha of zero in the bitmap in order to know that it

698
00:37:16,300 --> 00:37:18,700
doesn't actually contribute at all to that location.

699
00:37:18,700 --> 00:37:19,000
Right?

700
00:37:19,000 --> 00:37:20,300
Are it's only what's underneath it?

701
00:37:20,300 --> 00:37:22,500
That's going to be seen in that location.

702
00:37:22,500 --> 00:37:25,100
So what we did there to make that work with a z-buffer,

703
00:37:25,300 --> 00:37:28,800
Mario's we enable thing called Alpha test and what Alpha test does is

704
00:37:28,800 --> 00:37:33,600
it says, hey if the alpha isn't greater than 0, right?

705
00:37:33,800 --> 00:37:34,900
Then I'm not going to draw.

706
00:37:34,900 --> 00:37:37,600
If it is greater than 0, then I am going to draw.

707
00:37:37,600 --> 00:37:41,200
I'm going to like actually apply this sample in some way whether

708
00:37:41,200 --> 00:37:43,300
that's Blended or whatever else you have set.

709
00:37:43,300 --> 00:37:44,300
That's what's going to happen.

710
00:37:45,300 --> 00:37:47,100
Now why did this get removed?

711
00:37:47,200 --> 00:37:48,600
Why is this no longer necessary?

712
00:37:48,600 --> 00:37:52,200
Well, the reason is because Alpha test is a stage that happens in the

713
00:37:52,200 --> 00:37:52,700
pipeline.

714
00:37:52,900 --> 00:37:55,100
So gln able Alpha test is still

715
00:37:55,200 --> 00:37:59,200
Will there to tell you that Alpha test is on or off?

716
00:37:59,200 --> 00:38:01,400
I believe, I don't actually know if that's true.

717
00:38:01,400 --> 00:38:04,200
Even Alpha test may have may just get implied by the Shader now.

718
00:38:04,200 --> 00:38:04,700
We'll see.

719
00:38:05,000 --> 00:38:09,000
I don't, I'm sorry, I don't remember, but at the very least the

720
00:38:09,000 --> 00:38:11,800
function much like the modulation thing.

721
00:38:11,800 --> 00:38:14,800
Got removed, the function got removed because now you can put that in

722
00:38:14,800 --> 00:38:17,700
the Shader and let me show you how that works because we didn't

723
00:38:17,700 --> 00:38:21,000
actually do that and we should because that's the like I said The more

724
00:38:21,000 --> 00:38:22,100
appropriate way to do it.

725
00:38:23,800 --> 00:38:25,000
So in here you can see

726
00:38:25,400 --> 00:38:27,500
We get a texture sample, right?

727
00:38:27,500 --> 00:38:29,400
And we have a fragment color here.

728
00:38:29,700 --> 00:38:33,900
Now we know we know that we're never probably going to be specifying

729
00:38:33,900 --> 00:38:39,300
fragment colors of zero very often or fragment colors of alpha 0, very

730
00:38:39,300 --> 00:38:39,700
often.

731
00:38:39,700 --> 00:38:43,800
It may happen when something Fades all the way out but really at that

732
00:38:43,800 --> 00:38:46,900
point probably we should have earlier outed somewhere further up in

733
00:38:46,900 --> 00:38:50,200
the pipeline and never pushed down a Sprite that how does alpha all

734
00:38:50,200 --> 00:38:50,900
the way to zero.

735
00:38:51,100 --> 00:38:55,100
So we probably don't need to check for frag color 0 on its own.

736
00:38:55,200 --> 00:38:55,500
Own.

737
00:38:55,700 --> 00:38:59,800
However, when the texture sample comes in, as soon as we get that,

738
00:39:00,000 --> 00:39:00,800
Sure sample.

739
00:39:01,400 --> 00:39:05,700
What we want to do is say, hey, if the tester samples, Alpha value,

740
00:39:07,100 --> 00:39:08,200
Is greater than 0.

741
00:39:08,200 --> 00:39:12,700
Then you can go ahead and execute the Shader as you were normally

742
00:39:12,700 --> 00:39:19,600
executing the Shader right like so but in the case where you were not

743
00:39:19,600 --> 00:39:20,400
going to do that.

744
00:39:20,700 --> 00:39:25,900
So you have the texture sample comes in and it's actually zero.

745
00:39:26,000 --> 00:39:29,200
So we know this multiply right here.

746
00:39:29,300 --> 00:39:33,800
We know will kill the frag color entirely and we don't need to care

747
00:39:33,800 --> 00:39:36,700
about the srgb either way because zero

748
00:39:36,900 --> 00:39:38,500
Squared is still 0.

749
00:39:39,400 --> 00:39:42,200
Then what we want to do is tell the fragment Shader, you don't need to

750
00:39:42,200 --> 00:39:43,100
do anything else.

751
00:39:43,100 --> 00:39:43,800
That's it.

752
00:39:43,800 --> 00:39:45,900
You don't need to apply the blind pipeline to this.

753
00:39:45,900 --> 00:39:49,300
This fragment has gotten killed, it's called Tech skill or used to be

754
00:39:49,300 --> 00:39:50,100
called Texaco.

755
00:39:50,700 --> 00:39:53,800
Basically, What's Happening Here is we're saying checking the off the

756
00:39:53,800 --> 00:39:56,100
value, the alpha value indicates, no drawing.

757
00:39:56,300 --> 00:40:00,100
So just stop, you can save any more work that you might have done.

758
00:40:00,100 --> 00:40:00,900
Don't do it.

759
00:40:00,900 --> 00:40:02,200
You don't, you can save it, it's fine.

760
00:40:02,800 --> 00:40:06,100
And so that takes the place this greater than 0 here.

761
00:40:06,200 --> 00:40:06,700
Takes the

762
00:40:06,800 --> 00:40:11,400
Place of the greater than 0 that we were calling up in the alpha test

763
00:40:11,400 --> 00:40:11,900
case.

764
00:40:12,700 --> 00:40:14,200
So we don't need that anymore.

765
00:40:14,800 --> 00:40:15,400
I believe.

766
00:40:15,400 --> 00:40:18,000
Alpha test is still enable separately.

767
00:40:18,300 --> 00:40:20,200
I I'm sorry, I just don't remember.

768
00:40:20,200 --> 00:40:21,400
It might not be true.

769
00:40:22,100 --> 00:40:23,700
You might always have to have it.

770
00:40:28,200 --> 00:40:28,900
Can I get a?

771
00:40:28,900 --> 00:40:31,000
I want this to show me more of this message.

772
00:40:36,500 --> 00:40:42,000
O XB C 0 so that might be Alpha test so I think it's I think I'm

773
00:40:42,000 --> 00:40:42,400
wrong.

774
00:40:42,500 --> 00:40:46,000
So basically Alpha test is just 100% implied by the Shader.

775
00:40:46,200 --> 00:40:50,100
So basically if the Shader has the discard in there that's Alpha, test

776
00:40:50,100 --> 00:40:50,600
is on.

777
00:40:50,800 --> 00:40:53,300
If the Shader doesn't have the discard in there, it's off.

778
00:40:54,000 --> 00:40:54,900
I think that's it.

779
00:40:56,200 --> 00:40:56,700
Let's say.

780
00:40:58,200 --> 00:40:58,600
Yeah.

781
00:40:59,200 --> 00:40:59,800
Alright.

782
00:41:00,800 --> 00:41:04,000
So moving on past that all of these are still available because multi

783
00:41:04,000 --> 00:41:07,100
sample drawing can be on or off and alpha-2 coverage and that stuff

784
00:41:07,100 --> 00:41:09,500
can all be on or off still same with the dep's test as well.

785
00:41:10,500 --> 00:41:13,600
You'll notice that depth testing doesn't occur in the Shader at the

786
00:41:13,600 --> 00:41:14,200
moment.

787
00:41:14,400 --> 00:41:18,000
That's because there still is a fixed function depth pipeline.

788
00:41:18,000 --> 00:41:21,200
Basically, that does actually that that has a bunch of optimization

789
00:41:21,200 --> 00:41:22,600
minute that still exists.

790
00:41:22,600 --> 00:41:25,000
So typically, you just use depth, testing.

791
00:41:25,600 --> 00:41:27,600
The depth testing doesn't become part of the Shader.

792
00:41:31,400 --> 00:41:35,600
I believe that's mostly because of the way that fragment assembly and

793
00:41:35,600 --> 00:41:39,600
stuff works, there's it's just better to have the ability for the card

794
00:41:39,600 --> 00:41:40,100
to go.

795
00:41:40,400 --> 00:41:46,200
Oh I I know that this entire triangle is all going to be behind

796
00:41:46,200 --> 00:41:49,500
everything that's in this particular region that I'm was rasterizing

797
00:41:49,500 --> 00:41:50,100
right now.

798
00:41:50,700 --> 00:41:53,400
So I'm not even going to like do anything additional and blah blah

799
00:41:53,400 --> 00:41:53,600
blah.

800
00:41:53,600 --> 00:41:55,800
So there's a lot of like early outing that happens there.

801
00:41:56,000 --> 00:41:59,400
So I believe that a lot of depth testing is still fixed function.

802
00:42:00,000 --> 00:42:03,400
The time you can do stuff, where you implement your own depth, testing

803
00:42:03,400 --> 00:42:08,700
in the Shader, if you actually want it to be so, but we don't need to

804
00:42:08,700 --> 00:42:09,200
do that at.

805
00:42:09,200 --> 00:42:12,500
All right, we have no need for that because we can just do it like

806
00:42:12,500 --> 00:42:14,000
we're doing it now in the vertex Shader.

807
00:42:14,700 --> 00:42:17,500
So GL enable texture 2D no longer here.

808
00:42:17,900 --> 00:42:19,000
That's all good.

809
00:42:20,500 --> 00:42:22,600
Because that's again, in the Shader, if the Shader samples from a

810
00:42:22,600 --> 00:42:23,700
texture, then texturing is on.

811
00:42:23,700 --> 00:42:26,900
If it doesn't say over a texture then it's not so we can get rid of

812
00:42:26,900 --> 00:42:27,400
that.

813
00:42:28,800 --> 00:42:30,200
And let's see what else we got here.

814
00:42:31,800 --> 00:42:35,500
Right, so the Matrix mode stuff, that's not necessary at all.

815
00:42:36,300 --> 00:42:39,200
Because again, we're doing all those transforms explicitly ourselves

816
00:42:39,200 --> 00:42:41,400
in the vertex Shader, so that's good.

817
00:42:42,100 --> 00:42:42,900
Let's keep going.

818
00:42:45,800 --> 00:42:47,600
So let's see.

819
00:42:47,800 --> 00:42:49,400
Yes, this load Matrix.

820
00:42:49,400 --> 00:42:52,400
F call not necessary at all.

821
00:42:58,000 --> 00:43:01,000
And proj is still getting set.

822
00:43:01,000 --> 00:43:06,000
So that is our little thing that we need there, so we can get rid of

823
00:43:06,000 --> 00:43:06,200
that.

824
00:43:06,200 --> 00:43:08,100
I think my right about that.

825
00:43:12,900 --> 00:43:13,200
Yeah.

826
00:43:13,200 --> 00:43:16,500
So this is interesting to you can kind of see when we get this running

827
00:43:16,500 --> 00:43:16,900
as well.

828
00:43:16,900 --> 00:43:19,600
I'm going to I'm going to remember and I'm kind of moves over here.

829
00:43:19,600 --> 00:43:21,400
So I'm not behind my own head at all.

830
00:43:22,400 --> 00:43:26,600
So let's go ahead and run that let's continue getting rid of these but

831
00:43:31,700 --> 00:43:34,800
She'll virtue statute pointer in a court kind of called without a

832
00:43:34,800 --> 00:43:37,200
bound vertex, array objects in our card.

833
00:43:52,900 --> 00:43:58,900
So this is a particularly annoying aspect of opengl from this era,

834
00:44:00,100 --> 00:44:03,900
which is that, at some point, they decided that it would be swell.

835
00:44:03,900 --> 00:44:09,900
If you could save the state of vertex arrays by having a Vertex array

836
00:44:09,900 --> 00:44:12,000
object that stored that state,

837
00:44:13,200 --> 00:44:16,800
They then determined a lot of driver vendors did that actually that

838
00:44:16,800 --> 00:44:21,700
was very inefficient having these State changes for the attributes is

839
00:44:21,700 --> 00:44:23,700
actually slower than not doing that.

840
00:44:24,200 --> 00:44:27,200
So then what they recommended you do is just create one and leave it

841
00:44:27,200 --> 00:44:30,500
bound the entire time and it's an error not to do so.

842
00:44:32,700 --> 00:44:37,700
So, we get to go create one of these and bind it during initialization

843
00:44:37,700 --> 00:44:41,200
and never touch it again, just to avoid the fact that technically,

844
00:44:41,200 --> 00:44:43,500
it's an opengl error, not to do so.

845
00:44:45,300 --> 00:44:47,300
I wish I was making stuff like this up.

846
00:44:47,800 --> 00:44:48,500
I'm not.

847
00:44:49,400 --> 00:44:52,300
So what we need to do here is right.

848
00:44:53,200 --> 00:44:56,500
You know, in this before we do any drawing here, basically, we need to

849
00:44:56,500 --> 00:44:59,700
create a Vertex array.

850
00:45:00,100 --> 00:45:01,800
I've been an array object.

851
00:45:01,800 --> 00:45:03,400
I'll show you what I'm talking about here.

852
00:45:06,900 --> 00:45:09,100
How do I get back to the little Mary Go?

853
00:45:11,800 --> 00:45:16,600
So it's this set of Saucy gentleman, right here.

854
00:45:16,600 --> 00:45:20,100
So bind vertex array again, we'll talk about this in a second.

855
00:45:21,100 --> 00:45:22,800
I believe create vertex arrays.

856
00:45:22,800 --> 00:45:24,400
What I need to do to get one of these.

857
00:45:26,400 --> 00:45:27,300
Is that correct?

858
00:45:27,600 --> 00:45:28,100
No.

859
00:45:29,400 --> 00:45:30,500
Jen vertex array?

860
00:45:30,500 --> 00:45:33,300
That's that's what I'm looking at, all right.

861
00:45:35,400 --> 00:45:38,900
Alright, so you can see these are basically just the same as textures,

862
00:45:39,100 --> 00:45:40,100
they're just State.

863
00:45:40,100 --> 00:45:43,200
You basically say I need to talk about an array State and then you're

864
00:45:43,200 --> 00:45:46,700
like I'm going to bind one again, they don't work anymore.

865
00:45:46,700 --> 00:45:48,700
Like they're not things that you actually use.

866
00:45:48,700 --> 00:45:50,300
I Mega saying they don't work is not true.

867
00:45:50,300 --> 00:45:55,200
Obviously they do work if you wanted to actually use them but they're

868
00:45:55,200 --> 00:45:56,500
not efficient to use.

869
00:45:56,500 --> 00:46:00,000
So you just don't use them anymore as far as I'm aware anyway, and

870
00:46:00,000 --> 00:46:03,000
they kind of got leapfrogged anyway because by the time they actually

871
00:46:03,000 --> 00:46:04,700
would have become efficient potentially

872
00:46:05,300 --> 00:46:09,200
We're basically replaced by direct name, buffer, access stuff that

873
00:46:09,800 --> 00:46:11,100
like, you would use anyway.

874
00:46:11,100 --> 00:46:15,200
So I far as I know, these were literally just never a good idea, I

875
00:46:15,200 --> 00:46:16,300
could be wrong about that.

876
00:46:16,300 --> 00:46:18,600
Somebody who's a hard core GPU person?

877
00:46:18,600 --> 00:46:21,300
Probably could tell you a little more about that, then I can.

878
00:46:21,300 --> 00:46:24,100
But basically, we're looking at, literally this, right?

879
00:46:25,100 --> 00:46:28,400
We want to create a Vertex array, and this is basically, like, just a

880
00:46:28,400 --> 00:46:32,400
dummy vertex array, that's just going to be generated.

881
00:46:32,400 --> 00:46:35,000
And then we just want to leave it set.

882
00:46:35,300 --> 00:46:38,300
Right, so after we do that we're just going to do a bind vertex array

883
00:46:38,300 --> 00:46:39,400
on it and that's it.

884
00:46:41,900 --> 00:46:42,700
That's all.

885
00:46:46,700 --> 00:46:50,900
So, we basically have to query these extra two functions for no reason

886
00:46:50,900 --> 00:46:51,600
whatsoever.

887
00:46:51,700 --> 00:46:56,700
They don't do anything for us, except avoid the error, the technical

888
00:46:56,700 --> 00:47:01,500
error of using opengl that way, which you're not supposed to do so.

889
00:47:01,500 --> 00:47:03,300
Oh well, that's that's just.

890
00:47:03,600 --> 00:47:06,000
Let me convert x-rays.

891
00:47:08,900 --> 00:47:10,700
So great, fantastic.

892
00:47:10,700 --> 00:47:11,500
Wonderful.

893
00:47:12,300 --> 00:47:14,500
In fact, I guess I'll just grab these right here.

894
00:47:19,100 --> 00:47:22,000
Fortunately, at least it's a pretty easy thing to fix.

895
00:47:22,400 --> 00:47:24,800
It's just nonsense, but it's easy.

896
00:47:25,800 --> 00:47:27,200
So here's our type def's.

897
00:47:29,300 --> 00:47:29,900
Bloop.

898
00:47:30,300 --> 00:47:31,200
Oops, the up.

899
00:47:31,200 --> 00:47:32,000
Okay.

900
00:47:32,200 --> 00:47:33,900
All right, fine.

901
00:47:34,700 --> 00:47:35,300
All right.

902
00:47:41,900 --> 00:47:42,500
There we go.

903
00:47:44,100 --> 00:47:46,600
And we'll go ahead and slap those little.

904
00:47:47,800 --> 00:47:49,500
Guys on here, delete.

905
00:47:49,600 --> 00:47:49,800
Oops.

906
00:47:49,800 --> 00:47:56,200
I didn't need that one by and vertex array and Jen vertex arrays.

907
00:47:56,500 --> 00:47:59,300
And obviously, we don't need delete because we only create one and we

908
00:47:59,300 --> 00:47:59,800
never get.

909
00:48:00,000 --> 00:48:04,800
It is remains bound the entire time and does not change, so that's

910
00:48:04,800 --> 00:48:05,400
always good.

911
00:48:05,400 --> 00:48:07,500
Debug message, call back.

912
00:48:11,300 --> 00:48:12,900
I should have done this for both of them.

913
00:48:13,300 --> 00:48:16,800
I should have done this for all of these to this opengl get function

914
00:48:16,800 --> 00:48:17,800
is just much better.

915
00:48:19,000 --> 00:48:19,300
All right?

916
00:48:19,300 --> 00:48:23,000
So find vertex array, Ben burtt x-rays

917
00:48:29,100 --> 00:48:29,700
All right.

918
00:48:29,800 --> 00:48:36,100
So in theory anyway we should be able to do that and now I think we're

919
00:48:36,100 --> 00:48:36,900
getting through.

920
00:48:36,900 --> 00:48:38,400
Are we getting through one or maybe we're not.

921
00:48:38,400 --> 00:48:38,900
Let's see.

922
00:48:42,700 --> 00:48:45,400
If I fail because not a lot of specific clients overtakes or element

923
00:48:45,400 --> 00:48:45,700
array.

924
00:48:45,700 --> 00:48:48,700
When a non-default Vertex array object is bound.

925
00:48:55,700 --> 00:48:59,000
But isn't that the opposite of what you just complained about?

926
00:49:00,900 --> 00:49:02,400
I'm a little confused by that.

927
00:49:06,800 --> 00:49:14,000
oh, so is it the case that we must use an opengl backed buffer in

928
00:49:14,000 --> 00:49:16,800
order to call GL vertex, a trip pointer

929
00:49:22,700 --> 00:49:26,100
Because it wanted us to not.

930
00:49:26,100 --> 00:49:28,100
Let me just double check with that error.

931
00:49:28,100 --> 00:49:31,900
Was again, in case I miss understood it, but don't think I did.

932
00:49:32,800 --> 00:49:34,100
If we don't

933
00:49:37,100 --> 00:49:42,100
Bind a Vertex, array, it does not like that, right?

934
00:49:50,500 --> 00:49:54,000
Gee overtakes reporter in a core context called without a burnt bound

935
00:49:54,000 --> 00:49:58,700
vertex array object which is now required for Cora contexts so that's

936
00:49:58,700 --> 00:50:01,400
pretty clear, right?

937
00:50:03,800 --> 00:50:06,700
Did I accidentally not create a Vertex array object?

938
00:50:06,700 --> 00:50:08,100
I thought that's what I did.

939
00:50:15,500 --> 00:50:18,400
I don't think there's such a thing as a Vertex array object like

940
00:50:18,800 --> 00:50:19,900
multiple words.

941
00:50:22,200 --> 00:50:23,000
Just double-check.

942
00:50:25,300 --> 00:50:27,300
Yeah we're just array object name a re-raise.

943
00:50:27,300 --> 00:50:28,100
Blah, blah blah.

944
00:50:28,700 --> 00:50:34,000
Is this thing to portray, if nobody service above change State, it's

945
00:50:34,000 --> 00:50:35,400
exactly what we expect.

946
00:50:40,900 --> 00:50:42,900
So that just seems correct.

947
00:50:44,000 --> 00:50:48,400
So I guess we're in a bit of a catch-22 here, unless I'm missing

948
00:50:48,400 --> 00:50:49,100
something.

949
00:50:49,600 --> 00:50:53,200
And again, I'll just reiterate at least what I assume it's trying to

950
00:50:53,200 --> 00:50:53,700
tell us

951
00:50:55,800 --> 00:50:59,000
so the first era, as far as I know, was telling us that in order to

952
00:50:59,000 --> 00:50:59,900
call vertical

953
00:51:00,000 --> 00:51:00,900
It's a trim pointer.

954
00:51:00,900 --> 00:51:05,300
We need to have an array object bound at the time again.

955
00:51:05,300 --> 00:51:08,400
We don't actually need to use those array objects in the way they were

956
00:51:08,400 --> 00:51:12,400
initially intended, which was just quickly swap between various array

957
00:51:12,400 --> 00:51:13,300
object States.

958
00:51:14,100 --> 00:51:17,500
So for example, if you had like several different, array states that

959
00:51:17,500 --> 00:51:20,000
you're drawing from these arrays and then these arrays and then those

960
00:51:20,000 --> 00:51:23,600
arrays and you wanted to switch, you know, and they were static you

961
00:51:23,600 --> 00:51:26,300
want to switch between those States quickly or something like this?

962
00:51:26,600 --> 00:51:29,200
That's what those were for it turned out to be a bad idea.

963
00:51:29,200 --> 00:51:29,900
So they pretty much

964
00:51:30,000 --> 00:51:33,300
Don't use them and so you just set one at the beginning and go is how

965
00:51:33,300 --> 00:51:34,100
you normally do it.

966
00:51:34,100 --> 00:51:37,200
Unfortunately it is an error not to do it because you do need to have

967
00:51:37,200 --> 00:51:39,300
a valid one bound and that's what it's complaining about.

968
00:51:39,300 --> 00:51:44,800
However once we do bind one,

969
00:51:46,400 --> 00:51:51,500
It's complaining about something else entirely which is that as far as

970
00:51:51,500 --> 00:51:52,100
I can tell.

971
00:51:52,100 --> 00:51:52,700
Anyway,

972
00:51:53,900 --> 00:51:58,100
Unless there's some third way of using the API that I'm not aware of.

973
00:51:58,800 --> 00:52:04,100
Once you do, go ahead and do bind a Vertex array object in place.

974
00:52:04,900 --> 00:52:10,300
It's basically saying you can't pass client-side memory 2gl vertex at

975
00:52:10,300 --> 00:52:12,700
Red pointer because remember, that's what we're doing here.

976
00:52:13,700 --> 00:52:17,600
So if you take a look at what's going on, we've got a real data,

977
00:52:17,700 --> 00:52:17,800
right?

978
00:52:17,800 --> 00:52:23,100
We've got data here that we're passing down and that data, as you can

979
00:52:23,100 --> 00:52:23,500
see,

980
00:52:23,800 --> 00:52:28,000
Is actually being passed out of our memory.

981
00:52:28,000 --> 00:52:29,300
This is CPU side memory.

982
00:52:29,300 --> 00:52:33,200
It's not memory that's being backed by the GPU in any way.

983
00:52:33,200 --> 00:52:34,600
It's just regular old memory.

984
00:52:34,900 --> 00:52:39,500
And what we're saying is, hey inside, this client-side memory again,

985
00:52:39,500 --> 00:52:41,000
client is a weird term.

986
00:52:41,000 --> 00:52:43,800
I should probably pause and mention why if that's throwing me for a

987
00:52:43,800 --> 00:52:44,000
loop?

988
00:52:44,000 --> 00:52:45,100
It's it makes sense.

989
00:52:45,100 --> 00:52:47,200
Why it is in opengl parlance.

990
00:52:47,200 --> 00:52:50,200
The client is the person who's issuing, the render commands?

991
00:52:50,200 --> 00:52:53,300
And the server is the person who's executing them, her go

992
00:52:54,200 --> 00:52:57,800
Client-side memory means CPU side because the CPU side is the thing

993
00:52:57,800 --> 00:53:01,200
that's issuing commands to GPU server side would be the GPU.

994
00:53:01,200 --> 00:53:03,500
That's the thing that's actually doing the execution of the commands.

995
00:53:03,800 --> 00:53:09,400
Therefore, when you actually call opengl with something, it will refer

996
00:53:09,400 --> 00:53:10,700
to something as client-side memory.

997
00:53:10,700 --> 00:53:13,500
If it's memory that you've made on your side that it doesn't know

998
00:53:13,500 --> 00:53:16,500
about and now you're asking it to pull from that memory that is

999
00:53:16,500 --> 00:53:17,500
client-side memory.

1000
00:53:17,700 --> 00:53:20,300
It basically means CPU side memory in our case.

1001
00:53:20,900 --> 00:53:23,500
So it is

1002
00:53:23,700 --> 00:53:25,800
That we're using CPU side memory here.

1003
00:53:25,900 --> 00:53:30,300
We're not really wanting to transfer this stuff to the GPU, any sooner

1004
00:53:30,300 --> 00:53:30,700
than this.

1005
00:53:30,700 --> 00:53:34,200
This is the time when we would like to tell the GPU about it because

1006
00:53:34,200 --> 00:53:35,200
it's completely Dynamic.

1007
00:53:35,200 --> 00:53:36,700
It's gets created, every frame.

1008
00:53:37,100 --> 00:53:40,100
Usually, when you're talking about putting things into GPU memory,

1009
00:53:40,100 --> 00:53:42,300
you're talking about stuff that you're going to make once and draw

1010
00:53:42,300 --> 00:53:43,400
from several times.

1011
00:53:43,900 --> 00:53:46,800
If you're just doing it every frame generating a list of Sprites like

1012
00:53:46,800 --> 00:53:49,300
we are that needs to get sent to the graphics card every frame.

1013
00:53:49,500 --> 00:53:53,500
There's no bonus in US sending that to the GPU early.

1014
00:53:53,600 --> 00:53:57,100
So that's why we didn't bother putting it into any kind of special

1015
00:53:57,100 --> 00:53:59,800
memory back area that the GPU is aware of.

1016
00:54:00,000 --> 00:54:01,500
But it looks to me.

1017
00:54:07,800 --> 00:54:11,900
and again, I'm purely going by what I'm reading on the error messages

1018
00:54:11,900 --> 00:54:15,800
but it looks to me like this complaint

1019
00:54:17,200 --> 00:54:20,500
Is trying to tell us that is no longer allowed in core.

1020
00:54:20,500 --> 00:54:21,600
Our Urban core ARB.

1021
00:54:21,600 --> 00:54:24,400
You cannot use a client-side pointer.

1022
00:54:25,000 --> 00:54:26,300
That is what it looks like.

1023
00:54:27,300 --> 00:54:29,500
Now I don't know if that's true but that's just what it looks like.

1024
00:54:30,300 --> 00:54:31,100
I will say that.

1025
00:54:31,100 --> 00:54:34,900
I generally don't use client-side pointers when I'm using opengl right

1026
00:54:34,900 --> 00:54:35,800
now at all.

1027
00:54:36,100 --> 00:54:40,300
So it is true that I wouldn't have known that, that was true because I

1028
00:54:40,300 --> 00:54:43,000
never would have hit that in my own programming, I suppose.

1029
00:54:44,500 --> 00:54:46,800
So I can't say off the bat that

1030
00:54:47,000 --> 00:54:49,600
Driver is doing anything unusual, that may be exactly what the driver

1031
00:54:49,600 --> 00:54:50,600
is supposed to do.

1032
00:54:50,800 --> 00:54:52,300
I just wouldn't have ever hit that

1033
00:54:53,600 --> 00:54:58,400
So, I think that means we're left with having to deal with the fact

1034
00:54:58,400 --> 00:55:02,800
that we, I don't think we have a choice here if we want to actually

1035
00:55:02,800 --> 00:55:07,800
get rid of all of the Legacy sort of calls we were doing that suggest,

1036
00:55:07,800 --> 00:55:10,800
we will have to use GPU mapped memory here.

1037
00:55:12,200 --> 00:55:12,700
Right.

1038
00:55:13,000 --> 00:55:14,600
That just seems to be what we're saying.

1039
00:55:15,000 --> 00:55:18,200
Well fortunately for us we already did all the work for that.

1040
00:55:18,400 --> 00:55:22,500
The only thing we didn't do is actually allocate jpu back to memory,

1041
00:55:22,500 --> 00:55:23,100
right?

1042
00:55:23,100 --> 00:55:25,600
Because you remember I said very specifically when were talking about

1043
00:55:25,600 --> 00:55:30,800
this before, when we come through here, in the platform layer stuff,

1044
00:55:31,700 --> 00:55:34,500
you can see right here and game render commands.

1045
00:55:35,300 --> 00:55:37,800
This stuff, textured vertex vertex array.

1046
00:55:38,100 --> 00:55:41,000
That's where all our vertices are getting pushed at the moment is in

1047
00:55:41,000 --> 00:55:41,800
to that vertex.

1048
00:55:43,100 --> 00:55:46,600
And so that vertex array, very specifically was allocated on the

1049
00:55:46,600 --> 00:55:47,800
platform side of things.

1050
00:55:48,000 --> 00:55:52,500
So if we want to, we can very easily have the platform side allocate

1051
00:55:52,500 --> 00:55:58,700
that out of opengl store so that it is actually backed by the GPU and

1052
00:55:58,700 --> 00:56:00,900
can be flushed in that way, right?

1053
00:56:00,900 --> 00:56:01,800
We could do that.

1054
00:56:02,800 --> 00:56:05,900
Now, we don't necessarily need to go that far and we may not want to

1055
00:56:05,900 --> 00:56:09,200
go that far because like I said, this is actually memory that the GPU

1056
00:56:09,200 --> 00:56:11,100
doesn't need to know about ahead of time.

1057
00:56:11,100 --> 00:56:14,600
It's pretty much this Frame is the first time we've ever had it and

1058
00:56:14,600 --> 00:56:15,400
we're sending it down.

1059
00:56:16,100 --> 00:56:19,700
So what we can do instead is just create a dummy buffer that we, then

1060
00:56:19,700 --> 00:56:22,900
say, hey, here's the whole data for the buffer, by the way, I think

1061
00:56:22,900 --> 00:56:25,400
that's what I'd like to do first because I really don't know.

1062
00:56:25,400 --> 00:56:31,600
I don't like to do things as if they're a good idea GPU wise, without

1063
00:56:31,600 --> 00:56:32,500
ever having a way to test.

1064
00:56:32,600 --> 00:56:35,300
That because in general, I feel like you end up doing more harm than

1065
00:56:35,300 --> 00:56:36,600
good by speculating.

1066
00:56:36,600 --> 00:56:40,700
That something should be faster on the GPU by doing something, like,

1067
00:56:40,700 --> 00:56:42,100
allocating the memory from it directly.

1068
00:56:42,100 --> 00:56:43,500
That could mean you don't really know that.

1069
00:56:43,500 --> 00:56:44,100
That's true.

1070
00:56:44,200 --> 00:56:46,500
There's certainly plenty of times in history, where something that

1071
00:56:46,500 --> 00:56:48,900
sounds like, what should be the fastest path is in?

1072
00:56:48,900 --> 00:56:49,300
No way.

1073
00:56:49,300 --> 00:56:52,300
The fastest path and you're actually hurting your performance by doing

1074
00:56:52,300 --> 00:56:52,700
it.

1075
00:56:52,700 --> 00:56:57,200
So I'm going to just, I think I'm going to avoid doing that just yet.

1076
00:56:58,300 --> 00:56:59,500
instead, what I'm going to do here,

1077
00:57:00,000 --> 00:57:05,600
Just make a single buffer that we use for this and I'll show you how

1078
00:57:05,600 --> 00:57:06,200
that works.

1079
00:57:06,200 --> 00:57:08,100
So essentially what we're going to do here,

1080
00:57:10,800 --> 00:57:14,500
And it to be fair this is going to give us a think a little bit of a

1081
00:57:14,500 --> 00:57:20,300
bonus in terms of it would give the driver something that the driver

1082
00:57:20,300 --> 00:57:21,200
probably does want.

1083
00:57:21,200 --> 00:57:22,800
So this is not a complete waste of time.

1084
00:57:22,800 --> 00:57:25,700
Like the Gen vertex array stuff is because that is a literal complete

1085
00:57:25,700 --> 00:57:30,400
waste of time but basically I believe this is correct.

1086
00:57:31,700 --> 00:57:32,100
Yeah.

1087
00:57:33,800 --> 00:57:37,200
So what I'm going to do here is I'm going to use the buffer API which

1088
00:57:37,200 --> 00:57:39,700
is is the thing that we would use to allocate method do pu.

1089
00:57:39,700 --> 00:57:42,400
But instead of allocating memory on the GPU, I'm basically just going

1090
00:57:42,400 --> 00:57:45,100
to say hey, we've got a dynamic buffer.

1091
00:57:45,100 --> 00:57:46,800
We're going to send it to you every frame.

1092
00:57:46,900 --> 00:57:49,800
It's not going to be backed by GPU memory in that sense.

1093
00:57:49,800 --> 00:57:52,900
Like it's not going to be direct mapped on one side of the other and

1094
00:57:52,900 --> 00:57:54,100
you can kind of see how this goes.

1095
00:57:54,200 --> 00:57:56,700
So what I'm going to do is I'm going to call this G Elgin buffers.

1096
00:58:00,400 --> 00:58:04,400
And we're going to have here in our open she'll sort of State based

1097
00:58:04,400 --> 00:58:05,400
information stuff.

1098
00:58:06,100 --> 00:58:09,300
We're going to have here a thing that's just like vertex buffer,

1099
00:58:09,800 --> 00:58:10,300
right?

1100
00:58:11,200 --> 00:58:16,100
And what I want to do is I want to generate that vertex buffer from

1101
00:58:16,100 --> 00:58:16,800
opengl

1102
00:58:18,200 --> 00:58:21,500
And that's just again like a texture it's like a handle that says I'm

1103
00:58:21,500 --> 00:58:26,500
referring to this particular piece of buff this particular buffer that

1104
00:58:26,500 --> 00:58:29,300
I'm going to tell you more information about as we go right.

1105
00:58:29,900 --> 00:58:34,600
Once I get one of those buffers, it's just like a texture and then I

1106
00:58:34,600 --> 00:58:36,500
can bind it, right?

1107
00:58:36,600 --> 00:58:37,700
So you can see that here.

1108
00:58:39,100 --> 00:58:42,200
Now we only ever going to draw out of just this buffer at least at the

1109
00:58:42,200 --> 00:58:42,900
moment.

1110
00:58:43,100 --> 00:58:45,900
So what I'll probably do here is just bind it right here.

1111
00:58:46,300 --> 00:58:49,100
Now, I don't actually know that that's how we're will do it in the

1112
00:58:49,100 --> 00:58:49,600
end.

1113
00:58:49,900 --> 00:58:51,600
So I said, I am saving.

1114
00:58:51,600 --> 00:58:55,400
It's unlike this one where I know that I never need to touch this ever

1115
00:58:55,400 --> 00:58:55,800
again.

1116
00:58:56,100 --> 00:58:59,200
I am going to save this buffer handle here so I'm generating buffer

1117
00:58:59,200 --> 00:59:00,000
thing up with John W.

1118
00:59:00,000 --> 00:59:03,900
I want to start talking about a piece of memory, so like give me a way

1119
00:59:03,900 --> 00:59:04,600
to do that.

1120
00:59:05,900 --> 00:59:08,000
Again, we haven't talked about the memory at were just saying a name.

1121
00:59:08,000 --> 00:59:10,700
Basically give us a name, we can use such a and they're going to bind

1122
00:59:10,700 --> 00:59:11,300
the buffer which says.

1123
00:59:11,300 --> 00:59:14,900
Okay, now we're talking about this buffer here.

1124
00:59:15,200 --> 00:59:18,500
Now, when we bind the buffer, we need just like in textures to specify

1125
00:59:18,500 --> 00:59:19,800
what we're going to use it for.

1126
00:59:20,200 --> 00:59:22,100
And that in this case is GL array buffer.

1127
00:59:22,100 --> 00:59:25,100
It's the thing that will store the vertex array data that we were

1128
00:59:25,100 --> 00:59:27,900
passing around, right?

1129
00:59:28,400 --> 00:59:30,100
So now we have that bound.

1130
00:59:30,400 --> 00:59:35,100
Now when we go to make a call, like GL vertex of trim pointer,

1131
00:59:35,500 --> 00:59:38,600
The way that they made this work, was they made it so that when you

1132
00:59:38,600 --> 00:59:43,200
call that, if there is a buffer bound to the erase lot, like we just

1133
00:59:43,200 --> 00:59:43,700
did.

1134
00:59:43,800 --> 00:59:46,300
And again, this API is horrible, don't get me wrong.

1135
00:59:46,300 --> 00:59:47,700
It's just, it's ridiculous.

1136
00:59:47,700 --> 00:59:49,900
I have no idea what they were thinking when they made these.

1137
00:59:50,200 --> 00:59:52,500
A lot of times I suspect it had a lot to do with trying to

1138
00:59:52,500 --> 00:59:56,100
incrementally add things without really thinking about how absurd the

1139
00:59:56,100 --> 00:59:56,800
result would be.

1140
00:59:57,600 --> 00:59:58,000
Anyway,

1141
00:59:59,300 --> 00:59:59,700
so,

1142
01:00:00,000 --> 01:00:03,000
Can you call vertex of trip pointer the way they sort of jury-rigged

1143
01:00:03,000 --> 01:00:08,500
this into place was they said, okay if you have a buffer bound then

1144
01:00:08,500 --> 01:00:12,500
you're going to be talking about the buffer memory, not a pointer.

1145
01:00:12,700 --> 01:00:17,400
So instead of passing a pointer, what you do is cast to a pointer,

1146
01:00:17,600 --> 01:00:23,100
just the amount off of the base of the buffer that you want the data

1147
01:00:23,100 --> 01:00:23,900
to start out.

1148
01:00:23,900 --> 01:00:28,100
So basically, we just cast the offsets to avoid star and we're good.

1149
01:00:28,800 --> 01:00:29,900
I know that sounds ridiculous.

1150
01:00:30,000 --> 01:00:30,100
Yes.

1151
01:00:30,300 --> 01:00:33,600
But literally again all it's doing is its it was trying to reuse the

1152
01:00:33,600 --> 01:00:34,000
API.

1153
01:00:34,000 --> 01:00:36,200
Basically this vertex to trim pointer.

1154
01:00:36,200 --> 01:00:40,500
If you remember is saying where it's supposed to get the vertex data

1155
01:00:40,500 --> 01:00:41,000
from,

1156
01:00:42,400 --> 01:00:46,700
And in this case, it now already knows the region of memory to get it

1157
01:00:46,700 --> 01:00:50,000
from because we're going to be specifying that with that buffer API.

1158
01:00:50,100 --> 01:00:53,500
But what it doesn't know is where the individual components of the

1159
01:00:53,500 --> 01:00:54,200
vertex are.

1160
01:00:54,500 --> 01:00:58,000
So because remember it has to map those individual components to the

1161
01:00:58,000 --> 01:01:02,500
various components of the vertex that the Shader expects to have the

1162
01:01:02,500 --> 01:01:04,600
position the texture of the color, right?

1163
01:01:04,700 --> 01:01:07,400
So what this vertex, the trip pointer basically is doing is just

1164
01:01:07,400 --> 01:01:11,700
setting the stride, which is this, and the offset

1165
01:01:12,100 --> 01:01:16,900
Which is this of each type of element in memory already knows where it

1166
01:01:16,900 --> 01:01:17,100
is.

1167
01:01:17,100 --> 01:01:20,100
So that's why we've pulled the pointer part out.

1168
01:01:20,200 --> 01:01:22,800
But since we're still using the older apis, they didn't want to add a

1169
01:01:22,800 --> 01:01:23,600
new API set.

1170
01:01:23,600 --> 01:01:24,300
Just for this.

1171
01:01:24,300 --> 01:01:27,100
They said we'll just cross it to avoid star and we'll look at the

1172
01:01:27,100 --> 01:01:29,600
actual value as if it's an Offset, you know?

1173
01:01:30,800 --> 01:01:31,700
Scouts Honor.

1174
01:01:32,300 --> 01:01:34,200
So anyway, that's what's going to happen there.

1175
01:01:34,200 --> 01:01:37,100
However, we need one more thing to happen here, right?

1176
01:01:37,300 --> 01:01:40,600
Which is that we haven't actually told it for that particular buffer,

1177
01:01:40,800 --> 01:01:44,400
where the memory actually is, and that's done with something called

1178
01:01:44,400 --> 01:01:46,700
GL, buffer data, which is a called.

1179
01:01:46,700 --> 01:01:50,700
Here, you can see which basically just passes down a chunk of memory

1180
01:01:51,100 --> 01:01:51,800
with a name.

1181
01:01:53,100 --> 01:01:56,400
So how that works is, I call Gio buffer data with a Target.

1182
01:01:56,400 --> 01:01:59,300
Again, that's going to be that GL array, buffer bit.

1183
01:02:00,700 --> 01:02:05,100
So I'm passing down that saying, whatever is bound in that slot that

1184
01:02:05,100 --> 01:02:07,700
GL array, buffer slot, whatever is bound in that slot.

1185
01:02:08,300 --> 01:02:09,700
I'm going to give you a size.

1186
01:02:09,900 --> 01:02:11,400
That's how many of these there are.

1187
01:02:11,400 --> 01:02:15,000
Now again, we know and of course, and also data pointer, we know where

1188
01:02:15,000 --> 01:02:15,900
it is, right?

1189
01:02:16,000 --> 01:02:19,500
We know it's here, we know the size of it, right?

1190
01:02:19,500 --> 01:02:22,400
Because the size of it is however, many of these things we were going

1191
01:02:22,600 --> 01:02:23,900
The send down, right?

1192
01:02:23,900 --> 01:02:26,600
This is this is telling us right here.

1193
01:02:26,600 --> 01:02:29,800
And in fact, the him a platform thing can see, right here as the

1194
01:02:29,800 --> 01:02:30,900
vertex count in it.

1195
01:02:31,100 --> 01:02:36,700
So we know that the size is just going to be the vertex count times.

1196
01:02:36,700 --> 01:02:40,400
However, big each one of those vertices things was right and then

1197
01:02:40,400 --> 01:02:43,000
we've got a usage and the usage is kind of nuts.

1198
01:02:43,000 --> 01:02:45,900
It's like this kind of weird thing that's sort of not really very

1199
01:02:45,900 --> 01:02:48,600
good, but it's trying to tell open Joe what this memory is going to

1200
01:02:48,600 --> 01:02:49,000
do.

1201
01:02:49,800 --> 01:02:52,400
You can see here the descriptions of them.

1202
01:02:52,800 --> 01:02:56,800
so, stream mode is basically saying we're going to modify something

1203
01:02:56,800 --> 01:02:59,800
once and use it a few times static is we're going to modify

1204
01:03:00,000 --> 01:03:03,000
Once and use it many times dynamic, as we're going to modify it

1205
01:03:03,000 --> 01:03:05,600
repeatedly and use it many times, right?

1206
01:03:12,700 --> 01:03:15,500
Now in our case, it's a little tricky to pick what this means because

1207
01:03:15,500 --> 01:03:18,700
again this hasn't really stated what it means by modify.

1208
01:03:18,700 --> 01:03:21,800
Are you talking about modifying the buffer name or you're talking

1209
01:03:21,800 --> 01:03:23,300
about modifying the buffer contents?

1210
01:03:23,300 --> 01:03:25,900
Because actually, the buffer contents are never going to be modified.

1211
01:03:26,100 --> 01:03:27,700
We're just using this name as something.

1212
01:03:27,700 --> 01:03:30,900
We recycle to send you down a different chunk of memory every time.

1213
01:03:31,400 --> 01:03:35,200
Technically, I think that's probably stream draw but honestly, I can't

1214
01:03:35,200 --> 01:03:37,400
remember what the graphics card actually does with these.

1215
01:03:37,400 --> 01:03:38,700
So it might be dynamic draw.

1216
01:03:38,800 --> 01:03:41,000
It's definitely not static draw because we know that we're only

1217
01:03:41,000 --> 01:03:42,000
sending it down once.

1218
01:03:43,000 --> 01:03:43,600
Right.

1219
01:03:44,600 --> 01:03:45,500
And then we're well.

1220
01:03:45,500 --> 01:03:46,800
Okay, you know what?

1221
01:03:46,800 --> 01:03:50,400
No, I take that back because technically each one of these is a draw

1222
01:03:50,400 --> 01:03:50,900
call.

1223
01:03:54,600 --> 01:03:56,500
So it could be streamer.

1224
01:03:56,500 --> 01:03:57,200
It could be static.

1225
01:03:57,200 --> 01:04:00,200
Now, I think about it, I really don't know which one will be better.

1226
01:04:00,400 --> 01:04:02,300
I'm going to go with stream at the moment.

1227
01:04:04,600 --> 01:04:05,600
Oops, that's the wrong one.

1228
01:04:06,100 --> 01:04:08,700
I'm gonna go with stream at the moment because every frame, we change

1229
01:04:08,700 --> 01:04:10,200
it, but we do draw from multiple times.

1230
01:04:10,200 --> 01:04:13,600
So I'm going to try stream draw and, you know, again, this is just a

1231
01:04:13,600 --> 01:04:16,400
performance, hint getting it wrong will not cause wrong results to

1232
01:04:16,400 --> 01:04:17,400
just make ostler before.

1233
01:04:17,400 --> 01:04:19,800
It's the driver, because it may do different things with the memory

1234
01:04:19,800 --> 01:04:21,700
map, it to different locations, treat it differently.

1235
01:04:22,100 --> 01:04:25,900
Based on that hint is the only reason we even care about it.

1236
01:04:27,100 --> 01:04:27,500
Okay.

1237
01:04:28,300 --> 01:04:31,000
So again, hopefully you can understand how really I've done nothing

1238
01:04:31,000 --> 01:04:31,500
differently.

1239
01:04:31,500 --> 01:04:31,800
Here.

1240
01:04:31,800 --> 01:04:34,100
All I did was change the way we were calling it.

1241
01:04:34,100 --> 01:04:35,800
Previously, we were calling it.

1242
01:04:35,800 --> 01:04:38,500
Such that vertex, trip pointer took pointers to the actual vertex

1243
01:04:38,500 --> 01:04:38,900
streams.

1244
01:04:39,200 --> 01:04:42,300
Now we're changing it so that we're making a GL, buffer data call that

1245
01:04:42,300 --> 01:04:44,700
buffer data call will move, the whole chunk of memory over and then

1246
01:04:44,700 --> 01:04:48,100
vertex trip planner just saying, we're in that chunk, it is.

1247
01:04:48,100 --> 01:04:51,100
Now, you can see that even though this was kind of useless to a

1248
01:04:51,100 --> 01:04:55,300
certain extent from our perspective, it actually wasn't 100% useless.

1249
01:04:55,300 --> 01:04:56,800
And the reason is you have to

1250
01:04:57,000 --> 01:04:58,000
And the subtlety here.

1251
01:04:59,600 --> 01:05:00,200
What is there?

1252
01:05:00,200 --> 01:05:02,500
There's one piece of information we have now given the driver it did

1253
01:05:02,500 --> 01:05:04,400
not have before, and that is a good piece of information.

1254
01:05:05,000 --> 01:05:06,700
It's how big this was.

1255
01:05:07,000 --> 01:05:09,700
So you'll notice the vertex of trip pointer calls and this is just

1256
01:05:09,700 --> 01:05:13,100
because they weren't designed particularly well, the geometric pointer

1257
01:05:13,100 --> 01:05:17,100
calls never told the driver, how much memory it would access.

1258
01:05:17,300 --> 01:05:22,200
It was just telling it a base pointer and how how big each individual

1259
01:05:22,200 --> 01:05:26,600
element was but it had no idea how many it was actually going to get.

1260
01:05:26,600 --> 01:05:29,100
The only way it could ever find out how many was actually Gonna Get

1261
01:05:29,100 --> 01:05:29,100
You.

1262
01:05:29,300 --> 01:05:32,600
To look at all these draw a ray calls that were being used with it,

1263
01:05:32,600 --> 01:05:33,000
right?

1264
01:05:33,700 --> 01:05:38,200
And see how much they spanned, that's a lot of inefficiency of the

1265
01:05:38,200 --> 01:05:41,200
driver now, the driver has to be watching these drawer, a calls.

1266
01:05:41,200 --> 01:05:43,000
Probably cuing them all up.

1267
01:05:43,000 --> 01:05:47,000
Not issuing any of them until it sees all the uses of this buffer,

1268
01:05:47,100 --> 01:05:50,000
then it goes, okay, that's the total range of the buffer.

1269
01:05:50,100 --> 01:05:53,300
Now I can kick off a transfer of the buffer and then wait for the

1270
01:05:53,300 --> 01:05:55,400
buffer to get down there and then start issuing these calls or

1271
01:05:55,400 --> 01:05:56,600
something like this, right?

1272
01:05:57,300 --> 01:05:59,100
But now what we've done is this has

1273
01:05:59,300 --> 01:05:59,900
Even slightly.

1274
01:06:00,000 --> 01:06:01,200
They're right this Geo.

1275
01:06:01,200 --> 01:06:02,400
Buffer data call

1276
01:06:04,200 --> 01:06:07,300
in this case, this deal buffer data calls actually kind of nice

1277
01:06:07,300 --> 01:06:12,300
because what this does is it says hey here's all of the data but I'm

1278
01:06:12,300 --> 01:06:15,400
going to talk about here is how big it is right?

1279
01:06:15,500 --> 01:06:16,300
Here's where it is.

1280
01:06:16,500 --> 01:06:18,000
You can kick off that transfer.

1281
01:06:18,000 --> 01:06:22,500
Now if you want to and know that I have promised you, you're never

1282
01:06:22,500 --> 01:06:23,600
going to see me.

1283
01:06:23,600 --> 01:06:28,000
Call something like GL, draw arrays with an index bound.

1284
01:06:28,000 --> 01:06:31,400
That goes outside of this window.

1285
01:06:32,100 --> 01:06:33,600
So that's a much more

1286
01:06:33,800 --> 01:06:36,700
Size specification, to the driver, whether the driver can actually

1287
01:06:36,700 --> 01:06:37,800
make use of it, who knows?

1288
01:06:37,900 --> 01:06:38,700
That's their problem.

1289
01:06:38,700 --> 01:06:39,300
Not ours.

1290
01:06:39,300 --> 01:06:41,200
But you can definitely see from an API perspective.

1291
01:06:41,200 --> 01:06:44,700
That's a much more proper way of doing things in telling it.

1292
01:06:44,700 --> 01:06:45,700
Here is the memory trunk.

1293
01:06:45,800 --> 01:06:46,000
Okay?

1294
01:06:46,000 --> 01:06:48,800
Now here's some offsets of them are just going to draw from that's

1295
01:06:48,800 --> 01:06:51,500
much cleaner in terms of giving the driver of the information.

1296
01:06:51,500 --> 01:06:55,700
It needs to potentially do more sophisticated or more intelligent

1297
01:06:55,700 --> 01:07:01,100
operations, which month, which with much less analysis during runtime

1298
01:07:01,100 --> 01:07:03,600
analysis that the driver has to do.

1299
01:07:03,700 --> 01:07:06,100
On your instruction stream, right?

1300
01:07:07,100 --> 01:07:11,600
So what we need to do now is take these calls which at the moment our

1301
01:07:12,100 --> 01:07:13,400
oops that's got to be.

1302
01:07:14,100 --> 01:07:17,500
There we go which are currently not defined and just add them and then

1303
01:07:17,500 --> 01:07:20,200
we've got a couple of different pound Defiance here.

1304
01:07:20,600 --> 01:07:25,800
So again just going to jump over to the core ARB situation here and

1305
01:07:25,800 --> 01:07:26,800
grab those out.

1306
01:07:27,400 --> 01:07:28,200
So here's

1307
01:07:29,200 --> 01:07:30,300
Jill array, buffer.

1308
01:07:36,000 --> 01:07:36,300
Oops.

1309
01:07:38,500 --> 01:07:39,800
Here's Jill stream draw.

1310
01:07:42,800 --> 01:07:45,300
And while I'm at it because we don't really know which one of these

1311
01:07:45,300 --> 01:07:47,100
guys were going to want.

1312
01:07:47,400 --> 01:07:48,600
I'm just going to grab all these

1313
01:07:51,700 --> 01:07:55,800
Guess we want to play with them and then we just have these calls, The

1314
01:07:55,800 --> 01:07:58,200
Binding buffer data, Jen buffers, and Vine buffer.

1315
01:07:59,100 --> 01:08:01,100
So let's go ahead and grab those out.

1316
01:08:06,600 --> 01:08:10,900
so we've got find buffer, gen buffer and buffer data there they all

1317
01:08:10,900 --> 01:08:11,300
are

1318
01:08:17,200 --> 01:08:19,300
And let's grab them out here.

1319
01:08:22,200 --> 01:08:22,700
We go.

1320
01:08:48,000 --> 01:08:48,399
Okay.

1321
01:08:54,600 --> 01:08:57,000
And I guess I don't need either of those so there we go.

1322
01:08:57,600 --> 01:08:57,899
That's the thing.

1323
01:08:57,899 --> 01:08:59,100
I've got those in there.

1324
01:08:59,100 --> 01:08:59,899
And again, just

1325
01:09:00,300 --> 01:09:05,600
during the process of putting those in here, we've got healed, bind

1326
01:09:05,600 --> 01:09:06,100
buffer,

1327
01:09:07,500 --> 01:09:10,700
She'll Jen buffers and Joe buffer data.

1328
01:09:12,700 --> 01:09:13,300
and then,

1329
01:09:16,100 --> 01:09:16,800
Same thing here.

1330
01:09:26,200 --> 01:09:28,500
And then I think we should be good to go.

1331
01:09:30,100 --> 01:09:31,200
It looks like size.

1332
01:09:31,200 --> 01:09:33,399
I pointer is a new type def here.

1333
01:09:38,100 --> 01:09:39,399
Take a look at where that's to find.

1334
01:09:44,000 --> 01:09:45,399
We don't have those in here.

1335
01:09:45,600 --> 01:09:52,500
So let's just put them in a bind buffers.

1336
01:09:52,500 --> 01:09:53,500
Did I spell it wrong?

1337
01:10:02,300 --> 01:10:03,000
It's going on here.

1338
01:10:05,600 --> 01:10:07,000
Just saying go to line.

1339
01:10:08,400 --> 01:10:08,800
There we go.

1340
01:10:11,900 --> 01:10:15,700
So I think it's I just spelled that wrong, it should be buying buffer.

1341
01:10:21,100 --> 01:10:23,900
All right, so let's see if we've made any progress here.

1342
01:10:25,700 --> 01:10:28,400
Looks like we have passed that test.

1343
01:10:28,400 --> 01:10:31,700
So, again, just changing this to a structurally different way of

1344
01:10:31,700 --> 01:10:34,600
submitting it, which is slightly different, even though it looks like,

1345
01:10:34,600 --> 01:10:35,400
it was just busy work.

1346
01:10:35,400 --> 01:10:35,900
It does.

1347
01:10:35,900 --> 01:10:38,000
Give the size up front, which is really too important.

1348
01:10:38,400 --> 01:10:40,900
We're getting down to the end of the errors here, hopefully, because

1349
01:10:40,900 --> 01:10:41,800
they're not that much call.

1350
01:10:41,800 --> 01:10:43,300
They're not many calls left.

1351
01:10:43,600 --> 01:10:46,200
We do have one here that says, the value of this item is stale due to

1352
01:10:46,200 --> 01:10:49,400
a problem that occurred while valuing your cursor over the, oh, that's

1353
01:10:49,400 --> 01:10:50,600
that's actually talking about.

1354
01:10:50,600 --> 01:10:51,900
That's Microsoft Visual storytelling.

1355
01:10:51,900 --> 01:10:55,300
So here's what we actually want using geogebra raised in a day.

1356
01:10:55,400 --> 01:10:59,100
Core context with parameter mode and em7 which was removed from core

1357
01:10:59,100 --> 01:10:59,800
opengl.

1358
01:10:59,800 --> 01:11:00,100
Okay.

1359
01:11:00,100 --> 01:11:03,300
So that's that's the GL quads problem.

1360
01:11:03,400 --> 01:11:04,600
Hmm.

1361
01:11:12,400 --> 01:11:13,300
that's,

1362
01:11:15,200 --> 01:11:15,900
Tougher.

1363
01:11:21,100 --> 01:11:22,200
That's a tough one.

1364
01:11:22,200 --> 01:11:25,000
To get rid of my friends.

1365
01:11:25,900 --> 01:11:28,700
I'm going to go ahead and just take a look at what happens if we go

1366
01:11:28,700 --> 01:11:29,900
ahead and skip that.

1367
01:11:34,800 --> 01:11:37,300
Is that the only error we have left?

1368
01:11:44,100 --> 01:11:45,200
Let's find out.

1369
01:11:48,900 --> 01:11:51,800
Because that one, I don't know what we're going to do about.

1370
01:11:52,000 --> 01:11:53,400
That's that's a nasty one.

1371
01:11:53,400 --> 01:11:54,900
We'll talk about why in a second.

1372
01:11:57,800 --> 01:11:59,800
All right, so that's the last area.

1373
01:12:00,000 --> 01:12:02,900
Have is just using GL quads.

1374
01:12:02,900 --> 01:12:09,800
But, unfortunately, GL quads is not actually a supported any longer.

1375
01:12:10,500 --> 01:12:17,600
Now, this is not great for us, for a number of reasons.

1376
01:12:20,500 --> 01:12:24,100
And I can't say that there's really any fix for this.

1377
01:12:27,700 --> 01:12:28,400
And here's why.

1378
01:12:28,800 --> 01:12:31,600
So other things we can draw.

1379
01:12:34,100 --> 01:12:37,300
Quads is pretty much optimal for what we're doing because what we want

1380
01:12:37,300 --> 01:12:42,100
to do is be able to specify four points and fill them with a square

1381
01:12:42,100 --> 01:12:42,900
texture, right?

1382
01:12:42,900 --> 01:12:44,200
Or a rectangular texture.

1383
01:12:45,100 --> 01:12:47,800
So, quads is perfect for what we're trying to draw.

1384
01:12:47,800 --> 01:12:52,400
It's exactly the it's the most efficient way of specifying exactly

1385
01:12:52,400 --> 01:12:53,400
what we're specifying.

1386
01:12:54,400 --> 01:12:55,400
Unfortunately.

1387
01:12:57,700 --> 01:13:02,200
It got removed, and it got removed because basically, you know, even

1388
01:13:02,200 --> 01:13:08,700
in our case, you might argue that the easier way to not the easier way

1389
01:13:08,900 --> 01:13:13,700
but that it could be handled by writing a Shader into the other parts.

1390
01:13:13,700 --> 01:13:16,500
Like there's there's geometry shaders and tessellation shaders, which

1391
01:13:16,500 --> 01:13:19,800
we haven't talked about which work with the topology of data.

1392
01:13:20,400 --> 01:13:23,500
You could argue that the geometry, tessellation side of things, you

1393
01:13:23,500 --> 01:13:26,600
write something there, that will take whatever you've packed and

1394
01:13:26,600 --> 01:13:27,400
turned into.

1395
01:13:29,400 --> 01:13:34,200
You know triangles instead of quad, so you can still specify things as

1396
01:13:34,200 --> 01:13:36,900
if their quads in the tournament triangles and other things like this.

1397
01:13:38,100 --> 01:13:41,400
So you know, is it possible for us to go sort of get the ability to

1398
01:13:41,400 --> 01:13:42,300
specify quads?

1399
01:13:42,300 --> 01:13:47,700
Yes, a little bit but really it was exactly the most efficient thing

1400
01:13:48,200 --> 01:13:51,600
since that's not the common case, most of the time in 3D rendering,

1401
01:13:51,600 --> 01:13:51,800
right?

1402
01:13:51,800 --> 01:13:54,700
We're drawing much more complicated shapes with triangles and so on

1403
01:13:55,200 --> 01:13:57,500
usually index, triangular rays are always what?

1404
01:13:57,700 --> 01:13:58,000
You want?

1405
01:13:58,000 --> 01:14:01,300
And the reason that you want those is because vertices are almost

1406
01:14:01,300 --> 01:14:02,400
always shared.

1407
01:14:03,700 --> 01:14:06,600
In the case of quads, we never share any vertices.

1408
01:14:06,600 --> 01:14:08,500
A quad is very specifically.

1409
01:14:08,500 --> 01:14:12,000
The most minimal way to specify the data that we have.

1410
01:14:12,000 --> 01:14:16,100
Because the only time we share vertices is in the two triangles that

1411
01:14:16,100 --> 01:14:16,900
make up the quad.

1412
01:14:16,900 --> 01:14:22,000
So specifying GL quads is the perfect way to specify exactly what is

1413
01:14:22,000 --> 01:14:24,200
shared among any Primitives in our set.

1414
01:14:24,200 --> 01:14:28,500
It's, it's happens to be exactly right for what we're doing and it

1415
01:14:28,500 --> 01:14:32,900
saves us from having to submit an index stream normally what you do in

1416
01:14:32,900 --> 01:14:33,400
3D.

1417
01:14:33,600 --> 01:14:36,000
Obviously is you have two streams that you're specifying?

1418
01:14:36,000 --> 01:14:40,700
At least 21 is the stream of the vertex data and the other is a stream

1419
01:14:40,700 --> 01:14:43,700
of indices into that vertex data because usually you have a lot of

1420
01:14:43,700 --> 01:14:47,100
sharing and I could sort of illustrate to you what I mean by that.

1421
01:14:51,600 --> 01:14:52,800
So, here's my Milton.

1422
01:15:08,000 --> 01:15:11,200
So normally what happens, we'll just call this vertex sharing.

1423
01:15:16,400 --> 01:15:19,100
So normally, what happens in 3D rendering right?

1424
01:15:19,100 --> 01:15:22,000
Is you've got some shapes, you know, who knows what they are, but

1425
01:15:22,000 --> 01:15:25,100
you've got something and, you know, maybe you're talking about some

1426
01:15:25,100 --> 01:15:28,500
like cross-section of a curved surface or something, you know?

1427
01:15:28,500 --> 01:15:30,100
And you're drawing it like this.

1428
01:15:31,700 --> 01:15:32,100
Right?

1429
01:15:32,100 --> 01:15:36,000
So this is what, you know, the the actual triangles look like, and you

1430
01:15:36,000 --> 01:15:39,200
can see, there's tons of triangles are 123456789 bubble.

1431
01:15:39,200 --> 01:15:39,800
All right.

1432
01:15:40,700 --> 01:15:46,500
And for any one of the vertices in here, what I think you can see, if

1433
01:15:46,500 --> 01:15:50,700
you look at it carefully is that there's a lot of triangles that share

1434
01:15:50,700 --> 01:15:51,500
that vertex.

1435
01:15:51,700 --> 01:15:56,700
So for example, this is the typical shape, you might see in terms of

1436
01:15:56,700 --> 01:16:01,300
triangles emanating from a Vertex you'll typically see something like

1437
01:16:02,000 --> 01:16:03,800
This pattern, right.

1438
01:16:03,800 --> 01:16:08,700
So one, two, three, four, five, six, different triangles.

1439
01:16:09,300 --> 01:16:11,600
And you know these are these are triangles that just Edge.

1440
01:16:11,600 --> 01:16:17,800
Doesn't happen to pass through this vertex but you can see that there

1441
01:16:17,800 --> 01:16:20,400
is usually like six triangles.

1442
01:16:20,400 --> 01:16:23,500
Let's say that all touch a single vertex.

1443
01:16:23,800 --> 01:16:28,300
What that means is that if you were specifying the stream just as

1444
01:16:28,300 --> 01:16:31,400
vertices, it would be extremely inefficient because you would specify

1445
01:16:31,500 --> 01:16:36,300
Defy this vertex, six times, potentially right now.

1446
01:16:36,300 --> 01:16:39,800
If you were to send it down as quads, then you could, you could reduce

1447
01:16:39,800 --> 01:16:40,700
that amount of time.

1448
01:16:41,200 --> 01:16:44,300
It wouldn't be 6, but it would still be for, right?

1449
01:16:44,300 --> 01:16:46,800
Because if you take a look at what this would look like, you know, in

1450
01:16:46,800 --> 01:16:50,500
that same case where you weren't specifying The Edge going through, it

1451
01:16:50,500 --> 01:16:52,900
would still be one, two, three, four times.

1452
01:16:52,900 --> 01:16:56,300
That that vertex had to be talked about the reason we don't have this

1453
01:16:56,300 --> 01:16:59,400
problem is because we're only talking about one square at a time.

1454
01:16:59,900 --> 01:17:01,400
So a quad is

1455
01:17:01,500 --> 01:17:04,600
We specified by four vertices in our case and we never have to do

1456
01:17:04,600 --> 01:17:06,400
anything else and they'll never be shared.

1457
01:17:06,400 --> 01:17:09,700
There's nobody who comes along here and shares that vertex, right?

1458
01:17:11,200 --> 01:17:14,300
Now, that's not 100% true, all the time.

1459
01:17:14,300 --> 01:17:17,600
I mean, there could be cases where we would eventually share for, I

1460
01:17:17,600 --> 01:17:18,500
don't, but I really don't think.

1461
01:17:18,500 --> 01:17:21,500
So, even our cubes have different color values, the vertices, for

1462
01:17:21,500 --> 01:17:22,000
example.

1463
01:17:23,400 --> 01:17:26,700
So anyway, so given that, that's the case.

1464
01:17:27,700 --> 01:17:31,300
Normally, the way that things are specified is using an index stream

1465
01:17:31,300 --> 01:17:34,200
in Everett Xtreme at a minimum, right?

1466
01:17:35,000 --> 01:17:37,300
So, basically you specify your vertex data here?

1467
01:17:37,300 --> 01:17:40,800
And so, for this example, if this is vertex a to vertex,

1468
01:17:41,000 --> 01:17:44,700
Jim would just have the entry a in it and then the indices when we

1469
01:17:44,700 --> 01:17:48,100
went through here, you know, if this was at position zero, the indices

1470
01:17:48,100 --> 01:17:52,700
here would have that appear six times, right?

1471
01:17:52,800 --> 01:17:54,900
So you would in the index dream.

1472
01:17:56,900 --> 01:17:59,500
see, six different times when vertex a is

1473
01:18:01,500 --> 01:18:02,400
In that stream.

1474
01:18:03,000 --> 01:18:05,700
And if you think about how much of savings that is usually indices are

1475
01:18:05,700 --> 01:18:06,700
16-bit.

1476
01:18:07,000 --> 01:18:10,600
Roughly, you know, they're 65,000 vertices / buffer or something like

1477
01:18:10,600 --> 01:18:10,800
that.

1478
01:18:10,800 --> 01:18:13,500
And 16-bit in these, the buffer, various stuff like this.

1479
01:18:14,100 --> 01:18:18,300
If you think about how much smaller 16 bits is than a typical vertex,

1480
01:18:18,500 --> 01:18:21,900
a typical vertex, Even in our case which is a pretty straightforward

1481
01:18:21,900 --> 01:18:22,200
case.

1482
01:18:22,200 --> 01:18:26,300
We're not sending down crazy stuff like tangent frames or Advanced

1483
01:18:26,300 --> 01:18:29,400
sort of like lighting material info that we might need like you would

1484
01:18:29,400 --> 01:18:29,800
in a

1485
01:18:30,000 --> 01:18:35,200
So realistically rendered 3D situation if you think of how much

1486
01:18:35,200 --> 01:18:39,300
smaller 16-bit is well, even just the position, right?

1487
01:18:39,700 --> 01:18:45,100
A 3D position in a lot of cases is going to be 3 floats, right?

1488
01:18:45,100 --> 01:18:51,200
So that's 12 B just for the position, this is just two bites, right?

1489
01:18:51,200 --> 01:18:54,400
So even if you were expressing any other data you would already be

1490
01:18:54,400 --> 01:18:58,400
talking about 6X compression here in terms of how many times you were

1491
01:18:58,400 --> 01:18:59,800
saving that, right?

1492
01:19:00,900 --> 01:19:02,500
But it's usually much worse than that.

1493
01:19:02,500 --> 01:19:08,300
Usually there's texture, coordinates and color, and tangent frame, and

1494
01:19:08,300 --> 01:19:10,900
all these other sorts of things that come in here, right?

1495
01:19:11,200 --> 01:19:15,000
And so, you're talking about vertices, you can be 32, bytes, 64 by 128

1496
01:19:15,000 --> 01:19:19,000
bytes, you can have very large vertex data, so specifying them with

1497
01:19:19,000 --> 01:19:22,800
indices really saves, that 6X compression there, right?

1498
01:19:23,200 --> 01:19:27,100
I'm only specifying two bites in every time I want specified that

1499
01:19:27,100 --> 01:19:30,500
vertex rather than 12 or 32 or

1500
01:19:30,700 --> 01:19:32,000
64 or whatever else.

1501
01:19:32,200 --> 01:19:34,200
So that's that's a big deal, right?

1502
01:19:34,500 --> 01:19:37,700
Furthermore, there is an additional reason why index data helps you.

1503
01:19:37,900 --> 01:19:40,800
The reason is because the graphics card doesn't have to do the

1504
01:19:40,800 --> 01:19:42,300
transforms multiple times.

1505
01:19:42,600 --> 01:19:45,600
So for example, in this case where I have these vertices, let's

1506
01:19:45,600 --> 01:19:47,900
suppose that there wasn't really a space savings.

1507
01:19:48,100 --> 01:19:50,800
I didn't care about space savings at all for whatever reason.

1508
01:19:50,900 --> 01:19:53,300
Memory bandwidth is free all of a sudden or something like that.

1509
01:19:54,200 --> 01:19:56,000
So all I care about is computation time.

1510
01:19:56,200 --> 01:20:00,300
I still think, you know, I would still care about this index format.

1511
01:20:00,300 --> 01:20:04,000
The reason for that is because if this vertex itself were repeated,

1512
01:20:04,000 --> 01:20:07,600
many times, the graphics card doesn't know that the gravel start isn't

1513
01:20:07,600 --> 01:20:10,700
going to sweep through your vertex list looking for duplicate vertices

1514
01:20:10,700 --> 01:20:12,100
and go, aha, right.

1515
01:20:12,800 --> 01:20:15,300
What it's going to do is it's going to take all your vertices and it's

1516
01:20:15,300 --> 01:20:16,300
going to transfer in them.

1517
01:20:16,300 --> 01:20:20,800
So it's going to run the vertex Shader right on all of these vertices.

1518
01:20:20,800 --> 01:20:23,900
So if you repeat a six times, you're going to pay the price.

1519
01:20:24,100 --> 01:20:29,000
vertex, Shader for a six times on the other hand, if you have an index

1520
01:20:30,100 --> 01:20:34,600
Then all the graphics card is going to do is transform a once, right?

1521
01:20:34,600 --> 01:20:38,600
And then it's going to use the transformed version of a six times.

1522
01:20:39,900 --> 01:20:41,900
Do you see how much better that is, right?

1523
01:20:42,400 --> 01:20:46,700
So basically the compression here is not just compressing the space of

1524
01:20:46,700 --> 01:20:47,900
the vertex buffer down.

1525
01:20:47,900 --> 01:20:51,400
It's also compressing the computation time down because now the

1526
01:20:51,400 --> 01:20:55,600
computation only has to happen on each unique set of vertex data and

1527
01:20:55,600 --> 01:20:56,900
then we can reference that index.

1528
01:20:56,900 --> 01:20:59,800
Data post transform post vertex.

1529
01:21:00,000 --> 01:21:00,400
Peter.

1530
01:21:01,100 --> 01:21:04,900
And if those vertex shaders, get complicated as they do in photo

1531
01:21:04,900 --> 01:21:08,900
realistic, 3D games, you know Battlefield one.

1532
01:21:09,100 --> 01:21:12,600
Its vertex Shader doesn't look like three instructions like ours does,

1533
01:21:12,600 --> 01:21:13,100
right?

1534
01:21:14,300 --> 01:21:14,700
Or sorry.

1535
01:21:14,700 --> 01:21:17,500
I should say three lines of code, you know, they got these big things

1536
01:21:17,500 --> 01:21:19,700
doing all kinds of nonsense, right?

1537
01:21:20,100 --> 01:21:23,600
And so if you can compress that down, that's a real savings.

1538
01:21:23,700 --> 01:21:29,500
You're talking about many times the performance in terms of, of how

1539
01:21:29,500 --> 01:21:29,900
little

1540
01:21:30,000 --> 01:21:32,000
Work has to get done by comparison, right?

1541
01:21:36,000 --> 01:21:40,900
Okay, so basically in Cora what they decided is that basically they're

1542
01:21:40,900 --> 01:21:43,800
only going to support this really?

1543
01:21:44,700 --> 01:21:47,800
So GL quads, they don't care about their like the case where that

1544
01:21:47,800 --> 01:21:50,700
matters is so specific to like people throwing Sprites at the screen

1545
01:21:50,700 --> 01:21:51,200
or something.

1546
01:21:52,900 --> 01:21:56,100
We don't care about that, let them just do it this way or maybe make

1547
01:21:56,100 --> 01:21:57,100
some other way of doing it.

1548
01:21:57,100 --> 01:21:57,900
I don't know, it doesn't matter.

1549
01:21:59,600 --> 01:22:00,200
We don't care.

1550
01:22:02,000 --> 01:22:05,500
So the problem for us is they've gotten rid of the thing that happens

1551
01:22:05,500 --> 01:22:07,100
to do exactly what we want.

1552
01:22:07,100 --> 01:22:10,600
We are already getting all of this for free because GL quads happens

1553
01:22:10,600 --> 01:22:15,100
to do the exact perfect sharing for our vertex dream without requiring

1554
01:22:15,100 --> 01:22:15,900
an index buffer.

1555
01:22:15,900 --> 01:22:19,800
So we're saving the space of an index buffer as well, right?

1556
01:22:20,000 --> 01:22:23,900
So quads is exactly how we want to send things down but we can't send

1557
01:22:23,900 --> 01:22:24,700
it down that way.

1558
01:22:26,300 --> 01:22:32,400
And that leaves us with a little bit of a conundrum unfortunately so I

1559
01:22:32,400 --> 01:22:35,500
don't really know what we can do about this.

1560
01:22:36,300 --> 01:22:41,400
I'll have to think about it a little but what I want to do first is I

1561
01:22:41,400 --> 01:22:47,000
want to come back here and and re-enable this as it is, and I'm just

1562
01:22:47,000 --> 01:22:49,200
going to turn off the debug call for now

1563
01:22:52,800 --> 01:22:53,900
I'm just going to verify that.

1564
01:22:53,900 --> 01:22:58,600
All those changes that we made still actually produce a working image

1565
01:22:58,600 --> 01:23:01,400
because I do want to make sure that we're actually getting a working

1566
01:23:01,400 --> 01:23:01,800
image here.

1567
01:23:01,800 --> 01:23:02,300
Like okay.

1568
01:23:02,300 --> 01:23:04,000
So you can see like we're not right?

1569
01:23:05,000 --> 01:23:09,600
And so I want to go through and make sure that because we just made

1570
01:23:09,900 --> 01:23:11,800
some fairly significant changes.

1571
01:23:11,800 --> 01:23:19,100
Their, I want to make sure that we can, you know, look if I go back to

1572
01:23:19,100 --> 01:23:21,400
the compatibility profile or whatever that we

1573
01:23:21,600 --> 01:23:27,100
That it will work because if we can't do that, then you know, we have

1574
01:23:27,100 --> 01:23:29,200
some debugging to do of the changes that we made.

1575
01:23:31,300 --> 01:23:32,700
All right, so let's take a look.

1576
01:23:32,700 --> 01:23:34,400
Here here's the core profile thing.

1577
01:23:35,200 --> 01:23:38,600
I'm going to go ahead and turn off the forward compatibility bit here.

1578
01:23:45,800 --> 01:23:48,500
Okay, so that's all I wanted to verify.

1579
01:23:51,800 --> 01:23:56,900
Because like that map, buffer stuff that are the buffer data stuff.

1580
01:23:59,000 --> 01:23:59,800
Like we didn't know.

1581
01:24:00,500 --> 01:24:04,900
If that is going to work, you know, I mean I know that it works.

1582
01:24:05,600 --> 01:24:08,100
I just don't know if we maybe had them, we could have had a mistake in

1583
01:24:08,100 --> 01:24:08,900
the call.

1584
01:24:13,100 --> 01:24:13,600
Or who knows?

1585
01:24:13,600 --> 01:24:14,200
What else.

1586
01:24:17,100 --> 01:24:20,400
So basically, the question now is, do we want to just leave the

1587
01:24:20,400 --> 01:24:22,900
forward compatible bit off?

1588
01:24:24,600 --> 01:24:29,800
and use g l quads or do we want to enable the forward compatible bit

1589
01:24:29,800 --> 01:24:35,100
and try to figure out a way to send down this data in a way that does

1590
01:24:35,100 --> 01:24:35,700
not

1591
01:24:39,200 --> 01:24:41,700
It does not run afoul of the corps profile.

1592
01:24:43,700 --> 01:24:44,500
Requirements.

1593
01:24:45,200 --> 01:24:49,700
Now, this may just be the fact that I'm not a GPU person, but to be

1594
01:24:49,700 --> 01:24:54,600
honest, I don't know of a straightforward way to get back the

1595
01:24:54,600 --> 01:24:56,400
performance of GL quads.

1596
01:24:57,400 --> 01:24:58,200
And here's why.

1597
01:24:58,200 --> 01:25:01,800
So if I'm going to say GL quads,

1598
01:25:04,500 --> 01:25:07,100
Then there is a pretty easy way.

1599
01:25:07,100 --> 01:25:09,900
In fact, let me just write this as a sort of side by side.

1600
01:25:15,700 --> 01:25:20,900
So in Geo quads, what I'm doing is I'm specifying vertices 01.

1601
01:25:23,700 --> 01:25:24,200
23.

1602
01:25:30,000 --> 01:25:35,100
Like so and opengl is going to draw these as two triangles.

1603
01:25:35,200 --> 01:25:39,700
Now, I don't remember the exact specification of which way it draws

1604
01:25:39,800 --> 01:25:42,600
the two triangles because it could pick either one, right?

1605
01:25:42,900 --> 01:25:45,700
But it's going to pick one of those two, and it's going to draw these

1606
01:25:45,700 --> 01:25:46,300
this way.

1607
01:25:47,800 --> 01:25:49,700
Now, g, l try strip.

1608
01:25:56,200 --> 01:26:03,700
Happens to do exactly what we want on the first element, right?

1609
01:26:04,000 --> 01:26:09,500
So, if we wanted to GL, triangle strip is something that goes like

1610
01:26:09,500 --> 01:26:10,100
this.

1611
01:26:12,800 --> 01:26:16,800
Notice the vertex order is subtly different here, but what it does is

1612
01:26:16,800 --> 01:26:18,600
it does the exact same thing.

1613
01:26:21,700 --> 01:26:23,200
I think it does it this way, though.

1614
01:26:25,600 --> 01:26:26,500
Right now, I don't know.

1615
01:26:26,700 --> 01:26:28,200
GL quads may also do it that way.

1616
01:26:28,200 --> 01:26:29,500
I just, I just don't know.

1617
01:26:30,700 --> 01:26:31,400
We could look it up.

1618
01:26:31,400 --> 01:26:31,600
I'm sure.

1619
01:26:31,600 --> 01:26:35,300
It's in the spec Shield, the trial ship does basically exactly the

1620
01:26:35,300 --> 01:26:35,900
same thing.

1621
01:26:36,100 --> 01:26:39,600
The problem is what happens on the second primitive.

1622
01:26:40,400 --> 01:26:45,800
So on the second primitive after I do 0, 1, 2 3, then as I go four

1623
01:26:46,000 --> 01:26:49,500
five six seven, right?

1624
01:26:51,900 --> 01:26:53,800
I get another one of these.

1625
01:26:56,600 --> 01:26:57,900
And that's what I want.

1626
01:26:59,100 --> 01:26:59,800
What happens with?

1627
01:27:00,000 --> 01:27:04,100
Four, five, six, seven on Jill triangle strip is you actually get two

1628
01:27:04,100 --> 01:27:04,500
more.

1629
01:27:05,300 --> 01:27:12,800
So 0 1 2 3 4 5 actually specifies another attached quad.

1630
01:27:13,300 --> 01:27:17,600
So it actually uses the previous two.

1631
01:27:18,900 --> 01:27:21,400
As a shared Edge.

1632
01:27:23,400 --> 01:27:30,000
And then when I specify 67, I will actually get yet another

1633
01:27:30,100 --> 01:27:31,100
quadrilateral.

1634
01:27:32,300 --> 01:27:36,500
So I've given up the ability to draw separate Sprites and instead I

1635
01:27:36,500 --> 01:27:38,100
can draw a strip of Sprites.

1636
01:27:38,400 --> 01:27:42,400
You can understand why this might have been useful back in the day to

1637
01:27:42,400 --> 01:27:47,700
sort of plaster, over sides of things with you know, continuous

1638
01:27:47,700 --> 01:27:51,800
triangles or something, does not help us at all for Sprites because we

1639
01:27:51,800 --> 01:27:53,000
don't want them to be attached.

1640
01:27:53,000 --> 01:27:54,300
We want them to be separate.

1641
01:27:56,500 --> 01:28:03,300
Now, if we were going to be using an index list, then this problem

1642
01:28:03,300 --> 01:28:07,200
becomes trivial, there are a number of ways that we could make it

1643
01:28:07,200 --> 01:28:07,700
work.

1644
01:28:08,200 --> 01:28:11,700
The most straightforward of which is just to actually specify 6

1645
01:28:11,700 --> 01:28:16,600
indices per quod and then just draw GL triangles right.

1646
01:28:19,500 --> 01:28:22,500
Jill triangles allows us to just go like, oh, all right, well it's you

1647
01:28:22,500 --> 01:28:24,800
know, it's 0, 1 2,

1648
01:28:28,100 --> 01:28:31,800
And then we just specify it again zero to three.

1649
01:28:32,900 --> 01:28:36,300
Right, and then we just specify more triangles later.

1650
01:28:38,800 --> 01:28:44,700
So if we did an index list, you know, no problem and again that does

1651
01:28:44,700 --> 01:28:48,700
bloat, our space just a little bit, it means that we've basically

1652
01:28:48,700 --> 01:28:52,700
added an extra 16 bits per vertex that we didn't have before.

1653
01:28:53,000 --> 01:28:56,300
So unlike the index list saving a space which is kind of what they're

1654
01:28:56,300 --> 01:28:56,900
supposed to do.

1655
01:28:56,900 --> 01:28:58,800
It's actually making things worse for us.

1656
01:28:59,600 --> 01:29:04,800
So it's it's worse in our case because we had a perfect case for Jill

1657
01:29:04,800 --> 01:29:05,400
quads.

1658
01:29:06,400 --> 01:29:08,400
So we're losing to B pervert.

1659
01:29:08,600 --> 01:29:11,800
If we do that but it would just work, right?

1660
01:29:12,000 --> 01:29:16,900
The other thing we could do is we could use GL triangle strip and not

1661
01:29:16,900 --> 01:29:18,500
pay quite as much.

1662
01:29:18,600 --> 01:29:21,100
I shouldn't say that it's not, it's actually more than 16 bits per

1663
01:29:21,100 --> 01:29:28,500
vertex because each vertex has to be specified on average, not twice.

1664
01:29:28,500 --> 01:29:32,200
But for, you know, instead of four things we're sending down six.

1665
01:29:32,400 --> 01:29:34,700
So, in addition to each vertex, taking 16 bits more.

1666
01:29:34,700 --> 01:29:38,200
There's also 32 bits more of just extra extraneous.

1667
01:29:38,500 --> 01:29:41,200
Specified data divided, amongst those.

1668
01:29:41,200 --> 01:29:47,900
So it's more like 20 bits per vertex, extra if that makes any sense.

1669
01:29:49,700 --> 01:29:53,800
So what we could do even better than that because we can use what's

1670
01:29:53,800 --> 01:29:55,400
called GL triangle strip.

1671
01:29:59,200 --> 01:29:59,500
With.

1672
01:30:02,400 --> 01:30:06,200
And what that is, is Jill, trying to strip with restart.

1673
01:30:06,200 --> 01:30:08,300
If you think about how many things would take to specify for geo

1674
01:30:08,300 --> 01:30:14,000
triangles here for one quad, we had a specified 0, 1 2, 0, 2 3.

1675
01:30:14,000 --> 01:30:14,500
Right.

1676
01:30:14,600 --> 01:30:15,900
That's six indices

1677
01:30:17,500 --> 01:30:21,800
Okay, what we can do is specify a GL triangle shape with the restart

1678
01:30:21,800 --> 01:30:25,000
with that is is it says I'm going to use an index buffer, so I still

1679
01:30:25,000 --> 01:30:26,100
got to do things this way.

1680
01:30:28,700 --> 01:30:31,300
But there's going to be a special index.

1681
01:30:31,300 --> 01:30:34,000
Let's say it's the maximum value of 65535.

1682
01:30:34,100 --> 01:30:37,000
Let's say there's going to be a special value that when you see it,

1683
01:30:37,200 --> 01:30:39,000
you restart the Primitive sequence.

1684
01:30:39,000 --> 01:30:40,800
So you don't attach them anymore.

1685
01:30:41,000 --> 01:30:43,600
So this allows you to draw like one, triangle strip, and then issue

1686
01:30:43,600 --> 01:30:45,400
the restart and start drawing a new triangle strip.

1687
01:30:45,400 --> 01:30:47,100
That's disconnected from it, right?

1688
01:30:47,400 --> 01:30:50,900
And we could use that restart on every quad, so that would allow us to

1689
01:30:50,900 --> 01:30:51,200
do.

1690
01:30:51,200 --> 01:30:57,200
Okay, let's specify 0, 1, 2 3, right.

1691
01:30:57,200 --> 01:30:57,700
Then we'll specify

1692
01:30:57,900 --> 01:31:06,800
Five 65535 to restart the quad then we'll specify 4, 5, 6 7 right now,

1693
01:31:07,400 --> 01:31:13,100
when you look at that index Dream, It's just 0 1, 2 3, 6, 5, 5, 3 5,

1694
01:31:13,400 --> 01:31:17,000
4, 5, Loops 6 7.

1695
01:31:18,700 --> 01:31:19,400
Right.

1696
01:31:19,400 --> 01:31:22,100
That's only five, indices.

1697
01:31:24,800 --> 01:31:25,300
Right.

1698
01:31:25,600 --> 01:31:30,700
/ quad, so you can get better than six indices for Quad.

1699
01:31:30,700 --> 01:31:34,100
If you go with GL triangle strip with restart because the restart

1700
01:31:34,100 --> 01:31:35,300
allows you to

1701
01:31:37,200 --> 01:31:38,800
Do what you need to do there, right?

1702
01:31:39,400 --> 01:31:40,200
That's what etcetera.

1703
01:31:42,000 --> 01:31:46,300
So I don't really know at the moment.

1704
01:31:46,300 --> 01:31:51,000
I think we do have one Saving Grace, which is, we can just cheat the

1705
01:31:51,000 --> 01:31:54,800
reason we can cheat is because we change textures every triangle at

1706
01:31:54,800 --> 01:31:55,200
the moment.

1707
01:31:55,200 --> 01:31:58,300
I mean every quad at the moment, so if you take a look at what we're

1708
01:31:58,300 --> 01:31:59,300
doing here,

1709
01:32:07,300 --> 01:32:11,900
We always are issuing a separate draw arrays, call every time we want

1710
01:32:11,900 --> 01:32:18,300
to do a quad so because we have not addressed that particular

1711
01:32:18,300 --> 01:32:21,300
performance issue because in order to address it, we would need to

1712
01:32:21,300 --> 01:32:25,500
move to a texture or a texture atlas of very much more complicated

1713
01:32:25,500 --> 01:32:29,400
backing system that would, that would actually also require texture

1714
01:32:29,400 --> 01:32:30,800
packing and all these other sorts of things.

1715
01:32:31,100 --> 01:32:35,800
We'd have a huge amount of work, we'd have to do to get away from it.

1716
01:32:37,900 --> 01:32:39,200
In order to do that.

1717
01:32:41,600 --> 01:32:44,800
If we aren't doing that yet, we do have the opportunity of cheating

1718
01:32:44,800 --> 01:32:48,200
here because, hey, we don't have to represent more than one.

1719
01:32:48,300 --> 01:32:52,200
So we don't have to do a restart which means that if we change this to

1720
01:32:52,200 --> 01:32:56,700
drill triangle strip, all we would have to do is change the order in

1721
01:32:56,700 --> 01:32:59,800
which the vertices are put in there and in

1722
01:33:00,000 --> 01:33:03,500
Are we that will just work so we can cheat it right now.

1723
01:33:03,800 --> 01:33:06,600
And you can see that this is not correct at the moment because again,

1724
01:33:06,600 --> 01:33:10,100
we the order is wrong like that, this is that order.

1725
01:33:11,800 --> 01:33:12,600
Where is that?

1726
01:33:16,100 --> 01:33:17,400
Let me actually do this the right way.

1727
01:33:24,300 --> 01:33:27,300
So this is that ordering difference between this and this, right?

1728
01:33:27,300 --> 01:33:31,600
It's 0 1 2 3 in the quads case 0 1, 2 3 in the strip case.

1729
01:33:31,900 --> 01:33:32,700
So that's that difference.

1730
01:33:32,700 --> 01:33:34,400
You're seeing but we can fix that pretty easily.

1731
01:33:34,600 --> 01:33:36,600
Let me just go ahead and turn this back on.

1732
01:33:53,900 --> 01:33:54,400
There it is.

1733
01:33:57,200 --> 01:33:59,100
So, we have the forward compatible bit on now.

1734
01:34:01,300 --> 01:34:04,500
And we're drawing his quads and we should get that error that we were

1735
01:34:04,500 --> 01:34:06,600
getting, which is the only area I think that we had left.

1736
01:34:06,600 --> 01:34:07,400
So there it is.

1737
01:34:08,200 --> 01:34:11,900
And so what I'm going to do is I'm going to call GL triangle strip and

1738
01:34:11,900 --> 01:34:14,900
now hopefully, this means will now be completely compliant at least as

1739
01:34:14,900 --> 01:34:16,400
far as the driver is concerned.

1740
01:34:16,600 --> 01:34:17,000
Right.

1741
01:34:17,000 --> 01:34:17,400
There you go.

1742
01:34:17,400 --> 01:34:18,700
But we're just drawing a little bit wrong.

1743
01:34:18,700 --> 01:34:20,600
And again, that's the order difference problem.

1744
01:34:21,100 --> 01:34:25,700
So, in order to fix that all we would have to do is inside our render

1745
01:34:25,700 --> 01:34:29,300
group where we're doing all of our vertex stuff.

1746
01:34:29,500 --> 01:34:29,800
Oops,

1747
01:34:36,000 --> 01:34:36,700
It's push quad.

1748
01:34:36,700 --> 01:34:37,900
The only thing that we call.

1749
01:34:37,900 --> 01:34:39,300
Now don't actually know it.

1750
01:34:40,600 --> 01:34:41,400
I think it is.

1751
01:34:43,200 --> 01:34:48,400
So, whenever we call Push quad, we were previously pushing the quad in

1752
01:34:48,800 --> 01:34:49,900
in this order, right?

1753
01:34:49,900 --> 01:34:52,800
We were doing P0 P1 P2 P3 Around the Horn.

1754
01:34:53,400 --> 01:34:56,300
Instead what we can do is just switch that order, right?

1755
01:34:56,900 --> 01:35:01,900
You can see here, previously, you know, we were doing 0 1, 2, 3.

1756
01:35:02,300 --> 01:35:06,300
So all we need to do now is just do 0312, right?

1757
01:35:06,400 --> 01:35:08,000
So if we just said, okay,

1758
01:35:08,900 --> 01:35:10,100
03.

1759
01:35:13,000 --> 01:35:14,900
12 is the New Order.

1760
01:35:14,900 --> 01:35:15,800
The quads go down.

1761
01:35:15,800 --> 01:35:19,400
Now we're in the right order for triangle strips and since we already

1762
01:35:19,800 --> 01:35:23,400
do a restart every time because the draw arrays we cheated out of it

1763
01:35:24,200 --> 01:35:24,800
right?

1764
01:35:25,000 --> 01:35:31,000
But you can see why if we expanded that batch and there's two ways we

1765
01:35:31,000 --> 01:35:31,300
can play in.

1766
01:35:31,300 --> 01:35:37,500
The batch one is by again building a texture Atlas and using the UV

1767
01:35:37,500 --> 01:35:42,100
coordinates either inside an app, a single Atlas image or Texture

1768
01:35:42,100 --> 01:35:42,600
eraser

1769
01:35:42,800 --> 01:35:46,600
Both the altimeter and the depth by using UV coordinates to pick out

1770
01:35:46,600 --> 01:35:51,900
the part of the image that we wanted rather than switching textures if

1771
01:35:51,900 --> 01:35:52,800
we did that.

1772
01:35:52,800 --> 01:35:57,200
Or if we use cards, that allow you to specify texture pointer per

1773
01:35:57,200 --> 01:35:59,800
primitive which we also could do, right?

1774
01:36:00,000 --> 01:36:01,600
Like I'm video cards can do this.

1775
01:36:01,600 --> 01:36:05,700
For example, if we did either of those performance optimizations at

1776
01:36:05,700 --> 01:36:08,700
some point, this Trek no longer works.

1777
01:36:09,900 --> 01:36:11,700
Because we would no longer be restarting.

1778
01:36:11,700 --> 01:36:12,900
The batch, every time

1779
01:36:15,800 --> 01:36:18,300
So again, I will leave it like this for now.

1780
01:36:18,300 --> 01:36:24,300
I would be interested to hear from people who are more GPU familiar

1781
01:36:24,300 --> 01:36:24,900
than I am.

1782
01:36:24,900 --> 01:36:26,800
So a GPU rendering expert.

1783
01:36:26,800 --> 01:36:29,900
Basically, I'd be varied to hear from a rendering expert, what?

1784
01:36:29,900 --> 01:36:35,600
They think the best way to do quads, in this case would be because,

1785
01:36:35,600 --> 01:36:37,800
you know, assuming that we wanted to fix this.

1786
01:36:37,800 --> 01:36:41,900
So that it so that if we were to do some of those performance

1787
01:36:41,900 --> 01:36:43,300
optimizations of the future,

1788
01:36:45,200 --> 01:36:47,500
How would we solve this problem?

1789
01:36:47,700 --> 01:36:51,600
Because even if we don't do those other things for things like

1790
01:36:51,600 --> 01:36:56,000
particle systems, we probably will still just set one texture and then

1791
01:36:56,000 --> 01:36:56,900
draw many of them.

1792
01:36:57,000 --> 01:36:59,000
So we're going to hit this case.

1793
01:36:59,900 --> 01:37:01,700
And the question is, what's the best way to do it?

1794
01:37:01,700 --> 01:37:05,600
I'm assuming that the answer is probably just switched to a geometry

1795
01:37:05,600 --> 01:37:06,200
Shader.

1796
01:37:07,900 --> 01:37:11,100
Where it will automatically output the correct vertices and indices or

1797
01:37:11,100 --> 01:37:12,000
something like this.

1798
01:37:12,200 --> 01:37:13,300
I don't really know though.

1799
01:37:13,600 --> 01:37:18,700
So I would really like to hear from somebody who has a lot more

1800
01:37:18,700 --> 01:37:23,700
experience working with the high end GPU sorts of stuff to say, what's

1801
01:37:23,700 --> 01:37:28,500
the right way to, you know, to phrase that because there are other

1802
01:37:28,500 --> 01:37:31,700
options obviously, using an index buffer with restarts is another

1803
01:37:31,700 --> 01:37:34,800
option using an index buffer, and just you'll triangles and just

1804
01:37:34,800 --> 01:37:35,800
actually building the index.

1805
01:37:35,800 --> 01:37:37,000
Buffer is another

1806
01:37:37,100 --> 01:37:40,600
And right, it'd be really cheap for us to do, right?

1807
01:37:40,600 --> 01:37:41,200
We could do it.

1808
01:37:41,200 --> 01:37:43,500
Trivially right here.

1809
01:37:43,500 --> 01:37:45,500
We would just do it in this push quad call.

1810
01:37:45,500 --> 01:37:46,600
We just have a parallel index.

1811
01:37:46,600 --> 01:37:47,400
Are that we're building?

1812
01:37:47,600 --> 01:37:49,500
Is that the smartest way to do it, right?

1813
01:37:49,800 --> 01:37:55,900
So there's lots of ways we could do it and I just, I'm not sure which

1814
01:37:55,900 --> 01:38:00,300
way is smart these days, you know, which way is, which way would you

1815
01:38:00,300 --> 01:38:00,800
do it?

1816
01:38:00,800 --> 01:38:04,700
If you were going to take your first, what your best guess, right.

1817
01:38:06,000 --> 01:38:09,600
And I don't know if we run into actual performance problems, then

1818
01:38:09,600 --> 01:38:11,700
that'll be nice because then we could just try multiple ways and see

1819
01:38:11,700 --> 01:38:15,300
which one's faster at the moment that seems like a colossal waste of

1820
01:38:15,300 --> 01:38:17,700
time because this as it is changing textures.

1821
01:38:17,700 --> 01:38:20,200
Every time is actually plenty fast for our purposes.

1822
01:38:22,000 --> 01:38:25,100
So, I think that's a pretty good place to leave it now.

1823
01:38:28,700 --> 01:38:33,900
So I think we've done what I wanted to do, which was eliminate any use

1824
01:38:34,700 --> 01:38:38,500
of the old compatibility context at all.

1825
01:38:40,700 --> 01:38:47,700
and now we're, you know, we're totally good to go on the, on the

1826
01:38:49,200 --> 01:38:50,000
Core profile.

1827
01:38:50,600 --> 01:38:52,300
So for now that's that's plenty good.

1828
01:38:53,900 --> 01:38:55,300
I feel like we should now move on.

1829
01:38:55,500 --> 01:38:58,200
Probably won't have a chance to do anything else significant today

1830
01:38:58,200 --> 01:38:59,800
because I think we've used up most of our

1831
01:39:00,000 --> 01:39:03,200
I'm doing that, but that's okay that went quite well.

1832
01:39:04,500 --> 01:39:08,300
And so the next thing that I think I want to do is re-enable, some of

1833
01:39:08,300 --> 01:39:12,400
the stuff that we lost when we went to the new pipeline.

1834
01:39:13,200 --> 01:39:16,400
So we've got I think about 20 minutes left.

1835
01:39:16,600 --> 01:39:22,400
I'm going to go take a look and see, can we start re-enabling say our

1836
01:39:22,400 --> 01:39:23,600
debug view, right?

1837
01:39:23,600 --> 01:39:26,600
Because we lost our orthographic, projection code.

1838
01:39:26,600 --> 01:39:29,500
We never updated for the new system in opengl.

1839
01:39:30,200 --> 01:39:32,100
So I'd be interested to see if we can go ahead and get the

1840
01:39:32,100 --> 01:39:34,800
orthographic projection stuff back online.

1841
01:39:37,300 --> 01:39:40,900
So if you remember how this worked right inside our we sort of did

1842
01:39:40,900 --> 01:39:44,400
this camera transform stuff and you can see here, we were calling this

1843
01:39:44,400 --> 01:39:48,800
and we have flags and so on we would check to see whether we were

1844
01:39:48,800 --> 01:39:50,200
doing orthographic.

1845
01:39:50,500 --> 01:39:53,500
And if we were doing orthographic in this case, we would do this

1846
01:39:53,500 --> 01:39:56,200
orthographic projection call currently.

1847
01:39:56,200 --> 01:40:00,500
We're not getting any rendering of our debug stuff at all, so we don't

1848
01:40:00,500 --> 01:40:01,900
really know what's going on there.

1849
01:40:02,300 --> 01:40:05,000
We, I think we didn't even bother looking at it.

1850
01:40:05,000 --> 01:40:05,300
I don't even

1851
01:40:05,500 --> 01:40:10,800
Know, if the orthographic projection code is actually implemented, you

1852
01:40:10,800 --> 01:40:12,300
know, we have to build a matrix for that.

1853
01:40:12,300 --> 01:40:13,700
I don't know that we actually did.

1854
01:40:14,600 --> 01:40:19,900
We probably probably built something, but I don't know what that

1855
01:40:19,900 --> 01:40:20,600
something is.

1856
01:40:24,900 --> 01:40:25,400
Let's see.

1857
01:40:26,700 --> 01:40:29,700
So yeah, if you take a look at, you can see what's happening here with

1858
01:40:29,700 --> 01:40:33,600
this orthographic projection call here.

1859
01:40:34,000 --> 01:40:39,200
You can see that this is not actually doing anything with Z at all.

1860
01:40:40,300 --> 01:40:44,900
It's it's just got it passing through directly and that's, at the very

1861
01:40:44,900 --> 01:40:47,500
least, not going to work with the z-buffer, right?

1862
01:40:48,300 --> 01:40:53,400
We have to still map Z to the correct range regardless of what we do.

1863
01:40:54,800 --> 01:41:00,400
if we aren't going to modify the W coordinate for the divide or

1864
01:41:00,400 --> 01:41:01,300
anything like that,

1865
01:41:03,300 --> 01:41:06,300
So perspective, wise again, if the Divide is going to happen you can

1866
01:41:06,300 --> 01:41:07,500
see what's going on here.

1867
01:41:09,200 --> 01:41:12,300
You would want to make sure that you prevent The Divided from

1868
01:41:12,300 --> 01:41:12,800
occurring.

1869
01:41:13,400 --> 01:41:17,600
That's what would happen in this case because we have a w coordinate

1870
01:41:17,600 --> 01:41:18,800
of 1 here, right?

1871
01:41:19,000 --> 01:41:23,900
And nothing nothing that the Z coordinate so that one is going to be

1872
01:41:23,900 --> 01:41:25,800
pretty much what we want.

1873
01:41:26,500 --> 01:41:30,900
However, in this particular case, since we do have Z bias values

1874
01:41:30,900 --> 01:41:31,700
coming down,

1875
01:41:32,600 --> 01:41:36,900
in the orthographic, projection case, I guess there is a little bit of

1876
01:41:41,700 --> 01:41:46,100
There's a little bit of trouble there because yeah, those Z bias

1877
01:41:46,100 --> 01:41:46,700
values.

1878
01:41:46,700 --> 01:41:49,500
Oh well, okay, we've got a Vertex Shader though and the vertex Shader

1879
01:41:49,500 --> 01:41:50,000
takes care of those.

1880
01:41:50,000 --> 01:41:52,800
You bias value so that that should actually be fine.

1881
01:41:53,500 --> 01:41:54,700
So yeah, so it should be fine.

1882
01:41:55,200 --> 01:41:58,500
So really all we have to do here I think is actually do that mapping.

1883
01:41:59,000 --> 01:41:59,900
You can see here that

1884
01:42:00,000 --> 01:42:06,400
Got the near and far clipping plane sort of stuff happening here and

1885
01:42:06,400 --> 01:42:09,000
we want that to happen in both cases, right?

1886
01:42:09,000 --> 01:42:11,600
We want to be able to set the near and far clipping plane stuff.

1887
01:42:13,400 --> 01:42:19,200
To me for orthographic projections as well because if the Z buffer is

1888
01:42:19,200 --> 01:42:21,500
still enabled during the orthographic projection pass.

1889
01:42:22,500 --> 01:42:26,400
When we're drawing, whatever is coming down that pipe, we still need

1890
01:42:26,400 --> 01:42:31,600
to make sure that it is actually doing, you know what it's doing.

1891
01:42:31,600 --> 01:42:34,700
Like you know, the words we have to have the orthographic projection

1892
01:42:34,700 --> 01:42:35,400
call.

1893
01:42:36,800 --> 01:42:40,700
Still produce the values that can be used with the z-buffer unless we

1894
01:42:40,700 --> 01:42:44,400
just turn the z-buffer off for the orthographic projection past.

1895
01:42:44,400 --> 01:42:47,200
Now, that's not a bad idea because if you think about what's going to

1896
01:42:47,200 --> 01:42:50,800
happen, everything that's drawn during that orthographic projection

1897
01:42:50,800 --> 01:42:53,400
pass is like our UI stuff, right?

1898
01:42:54,200 --> 01:42:57,400
And it's unclear that we really want the Z buffer to be in effect

1899
01:42:57,400 --> 01:42:58,300
there anyway.

1900
01:42:59,500 --> 01:43:04,600
But who actually we don't know that we don't want the z-buffer on.

1901
01:43:04,700 --> 01:43:06,200
It seems like we probably do.

1902
01:43:06,500 --> 01:43:10,400
Um, because we could use that for sorting UI elements and stuff like

1903
01:43:10,400 --> 01:43:10,900
that.

1904
01:43:11,100 --> 01:43:13,800
And since we don't care about the ui's appearance in any way we can

1905
01:43:13,800 --> 01:43:18,000
even lean on the alpha to coverage stuff, to give us the eight levels

1906
01:43:18,000 --> 01:43:20,600
of transparency as well, which should be sufficient for our purposes.

1907
01:43:21,200 --> 01:43:25,000
So really probably just want to make it work.

1908
01:43:25,800 --> 01:43:30,700
So since these are basically the same, I believe we can just use

1909
01:43:30,700 --> 01:43:35,000
exactly the same code here for the, you know, the

1910
01:43:36,400 --> 01:43:37,500
Code that we were using.

1911
01:43:39,500 --> 01:43:43,000
So in the case, where we're not dividing by negative Z, right, we're

1912
01:43:43,000 --> 01:43:44,200
going to end up with this.

1913
01:43:45,100 --> 01:43:47,100
We already worked out with the non perspective.

1914
01:43:47,100 --> 01:43:49,600
Corrected terms are right things that aren't divided.

1915
01:43:50,400 --> 01:43:52,400
So hopefully we did that math, right?

1916
01:43:52,400 --> 01:43:53,900
And we can just use it, right?

1917
01:43:53,900 --> 01:43:56,500
So we can actually say, well, okay, here's the perspective ones.

1918
01:43:58,000 --> 01:43:59,500
There are the non perspective ones.

1919
01:44:05,900 --> 01:44:09,800
Now we never set a near and far clipping plane, right?

1920
01:44:10,700 --> 01:44:15,100
At the moment, those are just hard coded and eventually probably we

1921
01:44:15,100 --> 01:44:16,200
could just pass those in.

1922
01:44:16,200 --> 01:44:19,300
Although to be honest, I don't know that we ever will change the near

1923
01:44:19,300 --> 01:44:21,900
and far clipping plane the near and far clipping plane for the most

1924
01:44:21,900 --> 01:44:25,100
part isn't something that we're probably going to play with, I don't

1925
01:44:25,100 --> 01:44:25,500
know.

1926
01:44:26,400 --> 01:44:29,300
So to a certain extent it's not clear what we really want to do with

1927
01:44:29,300 --> 01:44:29,700
those.

1928
01:44:29,700 --> 01:44:33,600
We certainly can pass them in but we don't really need to

1929
01:44:35,800 --> 01:44:38,500
So anyway, if we go ahead and take a look here, what we can do is we

1930
01:44:38,500 --> 01:44:42,400
can make it so that as things are passed down, you can see what

1931
01:44:42,400 --> 01:44:43,800
happens with the Matrix here.

1932
01:44:43,900 --> 01:44:47,000
We basically would be doing exactly the same thing that we'd be doing

1933
01:44:47,000 --> 01:44:50,400
in the prospective case, taking the Z and trying to map it in between

1934
01:44:50,400 --> 01:44:54,100
the near and far clip planes, so that it basically produces that that

1935
01:44:54,100 --> 01:44:58,200
value since we're not dividing by Z at all at, all right?

1936
01:44:58,200 --> 01:44:59,300
We're just weird.

1937
01:45:00,000 --> 01:45:03,900
Eventually producing a w coordinate after the major transform of 1.

1938
01:45:06,000 --> 01:45:09,400
In that case, what we're going to see is that we don't need to do the

1939
01:45:09,400 --> 01:45:12,600
correction like these, have that correction baked in for the fact that

1940
01:45:12,600 --> 01:45:13,800
you're going to divide by Z afterwards.

1941
01:45:13,800 --> 01:45:15,300
In this case, we're not going to do that.

1942
01:45:16,000 --> 01:45:19,400
So I believe, this is what we need for orthographic projection, for

1943
01:45:19,400 --> 01:45:22,300
the most part, if I remember correctly.

1944
01:45:22,600 --> 01:45:24,200
I think that's basically correct.

1945
01:45:24,200 --> 01:45:26,800
However, we've got a bunch of other stuff that we're going to have to

1946
01:45:26,800 --> 01:45:32,400
deal with and that is that the orthographic projection used to, if I

1947
01:45:32,400 --> 01:45:34,900
remember correctly, take care of.

1948
01:45:35,100 --> 01:45:38,200
So of the camera part of the transform4, the, to be bug you.

1949
01:45:38,200 --> 01:45:41,500
I so what's happening with our orthographic transform at the moment?

1950
01:45:41,500 --> 01:45:44,800
If you look at it is, it's not doing any kind of scaling here.

1951
01:45:45,300 --> 01:45:48,600
So what that means is that this is not in pixel coordinates anymore,

1952
01:45:48,600 --> 01:45:52,500
this orthographic projection, it's going to be 0 to 1, right?

1953
01:45:52,500 --> 01:45:53,900
That's what it's basically looking at.

1954
01:45:55,100 --> 01:45:59,300
And so that orthographic projection when we do it here you can see

1955
01:45:59,300 --> 01:46:01,500
here that we've got this other thing where we've got the camera

1956
01:46:01,500 --> 01:46:05,400
transform, that comes in this part right here and the projection gets

1957
01:46:05,400 --> 01:46:07,200
multiplied by that camera, transform.

1958
01:46:07,700 --> 01:46:13,300
That part right there is the part that's currently needs to get

1959
01:46:13,300 --> 01:46:18,600
modified in order for our code to work at all in terms of setting up a

1960
01:46:18,600 --> 01:46:19,900
pixel-based.

1961
01:46:22,600 --> 01:46:24,700
Like, I don't know how to say it.

1962
01:46:24,700 --> 01:46:25,200
Exactly.

1963
01:46:28,300 --> 01:46:34,100
Previously, we're trying to map the screen in actual pixel space, so

1964
01:46:34,100 --> 01:46:37,800
that the debug you, I would just work in basically, in pixel space,

1965
01:46:37,800 --> 01:46:38,100
right?

1966
01:46:38,100 --> 01:46:41,400
The, the debug you, I didn't have the idea of a camera transform,

1967
01:46:41,600 --> 01:46:44,100
where was actually, like, looking at the screen from somewhere in

1968
01:46:44,100 --> 01:46:46,900
particular, or doing any kinds of rotation, obviously, for, you know,

1969
01:46:46,900 --> 01:46:47,700
obvious reasons.

1970
01:46:48,600 --> 01:46:53,200
But now what we have is, we have a circumstance where the orthographic

1971
01:46:53,200 --> 01:46:55,800
projection doesn't know anything about pixel space.

1972
01:46:55,800 --> 01:46:57,200
It doesn't know how big the screen is.

1973
01:46:57,600 --> 01:46:58,000
So,

1974
01:46:58,200 --> 01:47:00,500
As a result, this a b value here.

1975
01:47:00,500 --> 01:47:03,800
The only thing that it's doing is correcting for the aspect ratio.

1976
01:47:03,900 --> 01:47:07,000
That's the only thing this orthographic projection is doing what that

1977
01:47:07,000 --> 01:47:09,600
means is that the coordinates for addressing the screen.

1978
01:47:09,600 --> 01:47:11,900
When you're actually trying to draw things in the debug you, I are now

1979
01:47:11,900 --> 01:47:17,600
going to range from negative 1 to 1, not from 0 to night to 1920,

1980
01:47:18,200 --> 01:47:18,500
right?

1981
01:47:18,500 --> 01:47:21,900
Or however many, however, why the screen is so that means our debug

1982
01:47:21,900 --> 01:47:22,100
you.

1983
01:47:22,100 --> 01:47:23,300
I still needs to.

1984
01:47:23,300 --> 01:47:26,500
Now start thinking about that camera transform, and when it calls set

1985
01:47:26,500 --> 01:47:28,000
camera transform, it's going to have.

1986
01:47:28,100 --> 01:47:31,400
Have to put itself into the kind of space that it's expecting to use

1987
01:47:31,400 --> 01:47:34,500
manually because the orthographic transform isn't hard-coded to do

1988
01:47:34,500 --> 01:47:35,200
that anymore.

1989
01:47:37,300 --> 01:47:39,500
So, let's take a look at set camera transform here.

1990
01:47:39,500 --> 01:47:39,900
Actually.

1991
01:47:39,900 --> 01:47:41,600
Well, that is, if I can find it.

1992
01:47:46,000 --> 01:47:46,500
There we go.

1993
01:47:47,300 --> 01:47:48,300
So, let's take a look at this.

1994
01:47:48,300 --> 01:47:50,800
This set camera, transform call.

1995
01:47:54,100 --> 01:47:56,000
And you can see right now exactly how this is working.

1996
01:47:56,000 --> 01:47:59,500
So you can see that you see this with and and that with is coming from

1997
01:48:00,300 --> 01:48:05,400
The actual parameters that are passed in here and that width and

1998
01:48:05,400 --> 01:48:09,200
height is, is actually, I believe in pixels, right?

1999
01:48:09,500 --> 01:48:12,100
And so, it believes that the left edge of the screen is the negative

2000
01:48:12,100 --> 01:48:15,400
of that with and the right of the screen is the positive with that's

2001
01:48:15,400 --> 01:48:19,200
going to just be massively wrong because our debug you I now is

2002
01:48:19,200 --> 01:48:25,200
thinking that it's in a space of you know - half of 1920.

2003
01:48:25,200 --> 01:48:28,700
So whatever that would be 960

2004
01:48:30,000 --> 01:48:33,100
Yeah, it's going to be thinking, it's going to be negative.

2005
01:48:33,100 --> 01:48:36,100
962 positive 960 is that right?

2006
01:48:40,400 --> 01:48:41,200
I-90.

2007
01:48:46,000 --> 01:48:46,600
960.

2008
01:48:46,600 --> 01:48:50,500
I was correct - 96 deposit a 960

2009
01:48:51,600 --> 01:48:53,200
But that is ridiculous.

2010
01:48:53,700 --> 01:48:58,300
That is 960 times larger than the orthographic.

2011
01:48:58,300 --> 01:49:01,300
Matrix is expecting the coordinates to be, that would cover the

2012
01:49:01,300 --> 01:49:01,800
screen.

2013
01:49:02,300 --> 01:49:05,100
And so, in order to compensate for that, what we would want to do

2014
01:49:05,100 --> 01:49:07,400
here, is we want to use the camera X camera.

2015
01:49:07,400 --> 01:49:11,100
Why that's being specified here right there.

2016
01:49:11,700 --> 01:49:12,900
There's the axes

2017
01:49:14,400 --> 01:49:16,700
That are being specified for the camera itself.

2018
01:49:17,400 --> 01:49:18,300
They look like this.

2019
01:49:18,500 --> 01:49:22,300
I think we could do as a pretty easy way to make this go back to the

2020
01:49:22,300 --> 01:49:26,900
way that, you know, being pixel Centered for this part of the UI we

2021
01:49:26,900 --> 01:49:32,700
want to do here is say okay, what if we instead, why is there an I

2022
01:49:32,700 --> 01:49:33,300
here, by the way?

2023
01:49:33,300 --> 01:49:35,900
Also, I think that's a Vestige of remains that's going to go away.

2024
01:49:36,700 --> 01:49:39,300
So when we set this camera transform, what we need to do, is change

2025
01:49:39,300 --> 01:49:41,600
the size of the X and Y axes here.

2026
01:49:42,200 --> 01:49:43,600
So that they compensate for

2027
01:49:43,700 --> 01:49:47,000
That width and height difference, right?

2028
01:49:47,500 --> 01:49:51,300
So I think what we could do is say well, alright, let's just add in

2029
01:49:51,300 --> 01:49:52,600
that scale factor.

2030
01:49:53,900 --> 01:49:54,900
There we say.

2031
01:49:54,900 --> 01:50:01,100
All right the this length of the axis is going to reduce how big we

2032
01:50:01,100 --> 01:50:04,200
believe the screen to be right.

2033
01:50:05,700 --> 01:50:10,000
Now, what we want to do is we want to make it so that you know that

2034
01:50:10,000 --> 01:50:12,400
that's not exactly the right equation because you think about it, we

2035
01:50:12,400 --> 01:50:14,400
were thinking of the left Edge and right Edge, you can see the

2036
01:50:14,400 --> 01:50:15,600
equations for them right here.

2037
01:50:16,600 --> 01:50:20,100
What we're saying is that the left edge of the screen we expect to be

2038
01:50:20,500 --> 01:50:22,500
negative with over to write.

2039
01:50:22,500 --> 01:50:23,600
This is the left Edge.

2040
01:50:24,100 --> 01:50:28,100
And the right edge of the screen were expecting to be with over to

2041
01:50:28,300 --> 01:50:34,300
right now what we want these to do is we want these to map to negative

2042
01:50:34,300 --> 01:50:36,500
one and one that's what we actually want our Earth.

2043
01:50:36,500 --> 01:50:39,900
That's what our orthographic Matrix thinks should be happening, right?

2044
01:50:40,600 --> 01:50:44,700
And so if we want that to occur, what we need to do is we need to make

2045
01:50:44,700 --> 01:50:47,700
an equation that works and access that would work.

2046
01:50:48,000 --> 01:50:50,300
So what we want to do is say well, alright.

2047
01:50:50,300 --> 01:50:51,800
What's the coefficient?

2048
01:50:52,800 --> 01:50:53,400
Right.

2049
01:50:53,500 --> 01:50:58,200
What's the what's the coefficient that when multiplied by W over 2

2050
01:50:58,200 --> 01:50:59,900
equals 1, what would we have to?

2051
01:51:00,000 --> 01:51:01,500
Do here, right?

2052
01:51:01,700 --> 01:51:05,300
So, you know, if we were to Define an access what's the, what's the

2053
01:51:05,300 --> 01:51:06,400
coefficient that would go here?

2054
01:51:06,400 --> 01:51:09,000
That would turn W over 2 into 1.

2055
01:51:09,900 --> 01:51:13,300
And so, you know, pretty simple to solve right multiply both sides by

2056
01:51:13,300 --> 01:51:13,700
2.

2057
01:51:15,100 --> 01:51:15,800
Right.

2058
01:51:16,200 --> 01:51:18,300
And then divided by w.

2059
01:51:20,200 --> 01:51:20,800
Right?

2060
01:51:21,100 --> 01:51:23,600
And so that's why I said this wasn't quite the equation here because

2061
01:51:24,400 --> 01:51:26,600
there's actually a doubling in there, that's because of the centering.

2062
01:51:28,300 --> 01:51:33,200
Okay, so given that, that's how we could sort of compensate for that.

2063
01:51:33,400 --> 01:51:37,800
We do have one other problem I believe, which is that the center?

2064
01:51:38,000 --> 01:51:38,400
Well,

2065
01:51:40,600 --> 01:51:43,900
I don't remember how we were finding the top edge of the screen

2066
01:51:44,200 --> 01:51:46,600
because the top edge of the screen is a little more complicated.

2067
01:51:46,600 --> 01:51:48,800
If we're correcting for aspect ratio.

2068
01:51:52,300 --> 01:51:54,500
Oh, but it should still work because it should still be height.

2069
01:51:58,500 --> 01:52:01,500
If we're correcting for aspect ratio, then I think this actually wants

2070
01:52:01,500 --> 01:52:03,600
to be this, does that make sense?

2071
01:52:03,800 --> 01:52:07,600
Because the aspect ratio correction term, is should not be baked into

2072
01:52:07,600 --> 01:52:11,000
the camera because it's going to be baked in here, right?

2073
01:52:11,700 --> 01:52:16,700
If we look at the math again, so the aspect ratio with over-height.

2074
01:52:16,800 --> 01:52:21,600
The, a term X is Primal, it's going to get mapped directly, which

2075
01:52:21,600 --> 01:52:24,900
means that this term should also be in terms of X, because this right

2076
01:52:24,900 --> 01:52:27,900
here will take care of the ratio between the width and the height.

2077
01:52:31,100 --> 01:52:33,600
I believe famous last words.

2078
01:52:35,000 --> 01:52:39,000
All right, so let's try to move a little further down here and see if

2079
01:52:39,000 --> 01:52:41,600
we can't get something to start showing up on the screen.

2080
01:52:42,400 --> 01:52:45,300
So what we're looking for here is we're looking for,

2081
01:52:47,400 --> 01:52:50,400
We want to start to get our debug UI back, right, or debug you, I was

2082
01:52:52,300 --> 01:52:54,300
supposed to be fonts showing up on the screen here.

2083
01:52:54,500 --> 01:53:00,900
Now, there's nothing drawn right here so we can eliminate, I hope out

2084
01:53:00,900 --> 01:53:01,700
of hand.

2085
01:53:01,800 --> 01:53:05,000
The possibility that the Z buffer itself, is causing a problem with

2086
01:53:05,000 --> 01:53:06,200
not making something draw.

2087
01:53:06,200 --> 01:53:10,900
However, we don't necessarily know that the clip plane isn't doing

2088
01:53:10,900 --> 01:53:11,100
that.

2089
01:53:11,100 --> 01:53:11,300
Right?

2090
01:53:11,300 --> 01:53:15,100
So the near and far clipping plane may very well be clipping something

2091
01:53:15,200 --> 01:53:17,100
in or out and then

2092
01:53:17,200 --> 01:53:18,300
Not seeing it here.

2093
01:53:18,500 --> 01:53:22,800
So while we know the Z, buffer is not the problem.

2094
01:53:22,800 --> 01:53:26,300
It's not that they don't something here, wasn't drawn.

2095
01:53:27,800 --> 01:53:31,100
And then you know prevented the other thing from drawing, right?

2096
01:53:31,100 --> 01:53:33,300
If we if we looked at it like this,

2097
01:53:36,500 --> 01:53:39,100
Forget how I did this like Zoom.

2098
01:53:46,000 --> 01:53:50,000
Oh yeah, if we were looking at a screen like that, then the Z buffer

2099
01:53:50,000 --> 01:53:51,900
would still be in play potentially, right?

2100
01:53:51,900 --> 01:53:54,700
Because it could be that these things were just in front of whatever

2101
01:53:54,700 --> 01:53:58,000
was there and it was actually drawing properly within the Z boundaries

2102
01:53:58,300 --> 01:53:59,800
but then you know,

2103
01:54:00,000 --> 01:54:05,200
It it turned out to not be visible, we know that's not happening

2104
01:54:05,200 --> 01:54:07,900
because when we look at the actual camera view of the game there is

2105
01:54:07,900 --> 01:54:08,900
empty space here.

2106
01:54:09,300 --> 01:54:10,900
So we know that that wasn't the case.

2107
01:54:13,000 --> 01:54:16,300
Okay, so now we have to ask the question.

2108
01:54:16,400 --> 01:54:18,700
Well, what are the other sorts of things that could be a problem here?

2109
01:54:18,700 --> 01:54:22,100
Well, one of them is that we probably aren't in within the z-buffer,

2110
01:54:22,100 --> 01:54:24,800
boundary for the near and far clipping planes.

2111
01:54:25,000 --> 01:54:28,200
The reason for that is we've got all this, you know, kind of crap.

2112
01:54:28,200 --> 01:54:32,700
We were doing here with backing transforms tooltip, transforms offset

2113
01:54:33,300 --> 01:54:34,900
Z stuff, right?

2114
01:54:35,800 --> 01:54:39,500
So the problem with that is all of these things, here are all

2115
01:54:39,500 --> 01:54:42,600
offsetting the Z in weird ways that we don't.

2116
01:54:42,900 --> 01:54:46,600
Like this is all just completely old school stuff that we were

2117
01:54:46,600 --> 01:54:50,000
throwing arbitrary values into effect, the sort order.

2118
01:54:50,600 --> 01:54:52,800
So we know we're going to have to fix that as well.

2119
01:54:52,800 --> 01:54:55,800
What I'm going to do for now is I'm going to turn these off as much as

2120
01:54:55,800 --> 01:55:01,000
possible, so that we know that they're not interfering with our

2121
01:55:01,000 --> 01:55:03,300
ability to get something, it looks like we probably have to stop here

2122
01:55:03,300 --> 01:55:04,600
and Tackle this tomorrow.

2123
01:55:06,000 --> 01:55:09,900
Because yeah, we don't we don't have time when we're at the

2124
01:55:09,900 --> 01:55:10,700
five-minute warning.

2125
01:55:11,900 --> 01:55:14,600
So let me just take a quick look to see if there's anything else I

2126
01:55:14,600 --> 01:55:14,800
want to.

2127
01:55:14,800 --> 01:55:16,600
I think that's basically what I want to do.

2128
01:55:16,600 --> 01:55:19,200
Probably probably stop at there and then we can start looking tomorrow

2129
01:55:19,200 --> 01:55:23,400
at how to set up things so that we're actually going to be able to see

2130
01:55:23,400 --> 01:55:26,100
them on the screen going forward.

2131
01:55:26,600 --> 01:55:31,000
So yeah, let's just go to an early Q&A because I don't want to get

2132
01:55:31,000 --> 01:55:34,700
started tracking that down and then have to stop.

2133
01:55:41,200 --> 01:55:42,200
Yeah.

2134
01:56:30,400 --> 01:56:32,100
I've done something horribly wrong.

2135
01:56:38,000 --> 01:56:41,700
I've hidden my hex chat window and now I do not know where it went.

2136
01:56:49,900 --> 01:56:50,600
Oh wretched.

2137
01:56:50,600 --> 01:56:51,400
Where's the AL bot?

2138
01:56:51,500 --> 01:56:54,800
I rebooted the computer and forgot to restart the owl bot.

2139
01:56:57,700 --> 01:56:58,700
That's a good point.

2140
01:56:59,700 --> 01:56:59,900
How?

2141
01:57:00,000 --> 01:57:03,000
We start the owl bot Alba.

2142
01:57:08,700 --> 01:57:10,200
Can I can I get that?

2143
01:57:12,800 --> 01:57:14,600
Can I add this to the start menu?

2144
01:57:15,500 --> 01:57:16,600
I just want to put him.

2145
01:57:16,600 --> 01:57:18,100
There we go, pin to start menu.

2146
01:57:22,100 --> 01:57:24,300
All right, so maybe the AL Bots online now.

2147
01:57:25,700 --> 01:57:26,800
Maybe he is.

2148
01:57:26,800 --> 01:57:30,500
Yes there is unfortunately I have lost

2149
01:57:32,300 --> 01:57:33,300
Hex chat.

2150
01:57:43,100 --> 01:57:44,600
Hex chat is gone.

2151
01:57:45,400 --> 01:57:47,000
I do not know where it went.

2152
01:57:47,800 --> 01:57:52,900
I accidentally clicked on something in all my stuff disappeared.

2153
01:57:55,400 --> 01:57:59,500
That's otherwise known as using the Linux Window Manager.

2154
01:58:03,500 --> 01:58:07,100
Yes, I have no idea how to get my ex chat back.

2155
01:58:11,500 --> 01:58:12,600
Hex chat.

2156
01:58:21,200 --> 01:58:23,200
New server window.

2157
01:58:28,900 --> 01:58:31,100
Reconnect to Twitch, Maybe.

2158
01:58:37,200 --> 01:58:38,800
all right, I think

2159
01:58:48,500 --> 01:58:55,300
Okay all right disaster narrowly averted if you could really answer.

2160
01:58:55,600 --> 01:58:59,800
If you had a question that you asked on the twitch chat, please re-ask

2161
01:59:00,400 --> 01:59:04,700
it because hex chat went away.

2162
01:59:11,300 --> 01:59:15,700
So now I can see just fine and I can answer the questions as I

2163
01:59:15,700 --> 01:59:16,600
intended to.

2164
01:59:19,200 --> 01:59:20,900
Matilda says about the quad thing.

2165
01:59:20,900 --> 01:59:25,700
You might want to do something like this maybe and then he posted a

2166
01:59:25,700 --> 01:59:26,300
link

2167
01:59:33,500 --> 01:59:35,800
See, it's about subdivision surfaces.

2168
01:59:46,400 --> 01:59:51,100
Yeah, so this is this is the geometry Shader approach that I kind of

2169
01:59:51,100 --> 01:59:51,800
alluded to.

2170
01:59:52,500 --> 01:59:56,000
I don't know if that's the most efficient way to do it.

2171
01:59:58,400 --> 01:59:59,800
I assume it is only because

2172
02:00:00,100 --> 02:00:05,500
As it means that the geometry Shader, you know, you can still just

2173
02:00:05,500 --> 02:00:08,800
feed it the vertices and it would presumably still work but I don't

2174
02:00:08,800 --> 02:00:09,100
know.

2175
02:00:11,900 --> 02:00:14,700
Like I said, I'd like to hear someone who probably the answer is.

2176
02:00:14,700 --> 02:00:16,700
It doesn't matter like either way is probably fine.

2177
02:00:17,800 --> 02:00:24,500
and the geometry Shader one, add some complexity, but it means you

2178
02:00:24,500 --> 02:00:27,400
don't have to specify a Vertex index buffer which saves some

2179
02:00:30,400 --> 02:00:33,500
You know, say some bandwidth, which seems like probably the better

2180
02:00:33,500 --> 02:00:34,600
choice but I don't know.

2181
02:00:36,900 --> 02:00:37,300
so,

2182
02:01:12,700 --> 02:01:14,700
It does not look like we have any questions.

2183
02:01:16,000 --> 02:01:19,900
Although it does look like, there's what 156 people on the list.

2184
02:01:20,700 --> 02:01:25,000
So people are watching but they are not asking anything.

2185
02:01:33,300 --> 02:01:37,200
Elephant says, you could avoid geometry shaders by instancing, a

2186
02:01:37,200 --> 02:01:39,700
triangle strip that is just a quad.

2187
02:01:45,900 --> 02:01:50,600
That does seem like it would work, right?

2188
02:01:50,600 --> 02:01:53,300
You can, as you can specify, I gotta go.

2189
02:01:53,300 --> 02:01:54,700
Look at how you specify instancing.

2190
02:01:54,700 --> 02:01:56,900
Again, I assume that would work.

2191
02:02:21,700 --> 02:02:23,000
Each color.

2192
02:02:23,000 --> 02:02:27,200
Use, what do you think about using a different set of programs Shader

2193
02:02:28,600 --> 02:02:32,100
a different program basically, for debug text one, which has no

2194
02:02:32,100 --> 02:02:33,300
projection Matrix at all.

2195
02:02:33,300 --> 02:02:37,000
Would it be bad to switch programs for, GUI text performance-wise?

2196
02:02:37,900 --> 02:02:39,000
No, it's not.

2197
02:02:39,300 --> 02:02:43,000
It would not be bad because, you know, since the debug you I is

2198
02:02:43,000 --> 02:02:48,100
strictly drawn on top of everything else, it doesn't even need to use

2199
02:02:48,100 --> 02:02:49,700
the Z buffer if you didn't really want to.

2200
02:02:49,700 --> 02:02:51,000
And so on, it is a

2201
02:02:51,000 --> 02:02:55,500
Pletely separated will thing, which means that it would be, you

2202
02:02:55,500 --> 02:02:58,200
wouldn't need to be transitioning programs all the time.

2203
02:02:58,200 --> 02:02:59,800
It's not like you need to switch between drawing.

2204
02:03:00,000 --> 02:03:02,500
Bug text and drawing Regular stuff like often.

2205
02:03:04,200 --> 02:03:07,200
Because the expensive part of having multiple programs is not, how

2206
02:03:07,200 --> 02:03:08,100
many programs you have.

2207
02:03:08,100 --> 02:03:09,500
It's how many times you have to switch.

2208
02:03:09,700 --> 02:03:12,100
So if you only have to switch programs once it's really not a big

2209
02:03:12,100 --> 02:03:13,100
deal, right?

2210
02:03:14,000 --> 02:03:17,300
However, I actually don't

2211
02:03:18,600 --> 02:03:24,200
Like once you go to the fixed function pipeline, once you go to the

2212
02:03:27,400 --> 02:03:32,000
pipeline like we're using it, you really don't have a choice but to do

2213
02:03:32,000 --> 02:03:33,700
a matrix transform, right?

2214
02:03:34,000 --> 02:03:37,000
Because opengl is going to want clip coordinates.

2215
02:03:37,000 --> 02:03:40,300
Always it wants negative 1 to 1, that's just has to happen.

2216
02:03:41,100 --> 02:03:44,900
So it's not like we can't have something that does the transform.

2217
02:03:44,900 --> 02:03:48,300
So whether we specify in a matrix that's compatible with our existing

2218
02:03:48,500 --> 02:03:51,400
Later or whether we write a new Shader to do it, we don't get out of

2219
02:03:51,400 --> 02:03:52,000
the work.

2220
02:03:52,500 --> 02:03:55,800
The work is the same and that's just making sure that our debug system

2221
02:03:55,800 --> 02:03:57,400
now outputs coordinates.

2222
02:03:59,800 --> 02:04:05,900
And some way of of transforming those coordinates into opengl as clip

2223
02:04:05,900 --> 02:04:07,800
coordinates, that's what we need to do.

2224
02:04:07,800 --> 02:04:10,800
And whether we do that via Matrix, or whether we did that by writing a

2225
02:04:10,800 --> 02:04:12,100
different Shader, it wouldn't matter.

2226
02:04:12,100 --> 02:04:14,600
So as far as I'm concerned, it's just better to do it by The Matrix

2227
02:04:14,600 --> 02:04:17,600
because then we only have one Shader and that's just less stuff for us

2228
02:04:17,600 --> 02:04:18,700
to think about, right?

2229
02:04:19,400 --> 02:04:21,800
You always want to reduce the numbers of things.

2230
02:04:21,800 --> 02:04:24,700
You have if you can, if there's no reason not to because that just

2231
02:04:24,700 --> 02:04:28,400
keeps things simpler and so I don't think it makes much sense.

2232
02:04:28,600 --> 02:04:33,500
Our case to create a different Shader for the debug text because it's

2233
02:04:33,500 --> 02:04:34,900
essentially exactly the same.

2234
02:04:35,600 --> 02:04:40,100
It would have to do exactly the same things that said, if you wanted

2235
02:04:40,100 --> 02:04:43,200
to, there is no reason for you, not to do so.

2236
02:04:43,200 --> 02:04:46,400
So if you had some benefits that you thought you were begetting by

2237
02:04:46,400 --> 02:04:48,000
writing a different Shader for the

2238
02:04:49,500 --> 02:04:53,100
Debug text, you know, we're already very light on shaders.

2239
02:04:53,100 --> 02:04:57,400
We've got one Shader right most games, have many, many, many shaders.

2240
02:04:57,400 --> 02:05:01,600
And by the time we're done, we'll probably have a few but 2D games

2241
02:05:01,600 --> 02:05:03,400
typically have a lot less shaders than 3D games.

2242
02:05:03,400 --> 02:05:04,300
3D games.

2243
02:05:04,600 --> 02:05:06,900
Can oftentimes have lots of different shaders that are based on

2244
02:05:06,900 --> 02:05:09,600
optimizations for different types of physical effects that are trying

2245
02:05:09,600 --> 02:05:11,000
to be rendered in that sort of stuff.

2246
02:05:12,000 --> 02:05:16,400
And so, even though, you know, you certainly don't want to have more

2247
02:05:16,400 --> 02:05:19,100
shaders, you want to keep the number down as low as you can.

2248
02:05:19,300 --> 02:05:23,100
It's not a typical for game to have 100 shaders in it, that's you

2249
02:05:23,100 --> 02:05:25,500
know, that wouldn't even be considered large.

2250
02:05:40,900 --> 02:05:44,400
There is the Third Way of setting the vertex data through ARB separate

2251
02:05:44,400 --> 02:05:44,800
a trip.

2252
02:05:44,800 --> 02:05:49,300
Format, went to court and 4.3, this separates, the vertex format from

2253
02:05:49,300 --> 02:05:52,400
the buffer it reads which is more optimal for the driver.

2254
02:05:53,100 --> 02:05:55,100
Yeah, that's probably true.

2255
02:05:55,800 --> 02:05:58,500
I don't know if that's supported on this card obviously and also I

2256
02:05:58,500 --> 02:05:59,800
probably not something that's

2257
02:06:00,000 --> 02:06:03,500
Do if you're looking for backwards compatibility, anything that's like

2258
02:06:03,500 --> 02:06:06,400
goes decor and 4.3 might be a little late.

2259
02:06:09,500 --> 02:06:13,500
I don't know again that would largely be about driver compatibility,

2260
02:06:14,200 --> 02:06:17,400
but yeah, obviously, if you can specify the vertex format separate

2261
02:06:17,400 --> 02:06:20,700
from the vertex data, that's obviously a better way to go because

2262
02:06:20,700 --> 02:06:22,200
they're not related information.

2263
02:06:32,200 --> 02:06:35,100
Robbie when the engine uses a deprecated function like Jill quads,

2264
02:06:35,100 --> 02:06:38,000
what are the main issues that people would have to deal with playing

2265
02:06:38,000 --> 02:06:40,500
the game because it is running right?

2266
02:06:41,100 --> 02:06:41,600
Yes.

2267
02:06:41,700 --> 02:06:45,800
And so, you know, one of the things you can certainly do is just say,

2268
02:06:45,800 --> 02:06:49,600
hey, you know what, I'll just do a compatibility context and off we

2269
02:06:49,600 --> 02:06:50,100
go, right?

2270
02:06:50,100 --> 02:06:50,700
I don't care.

2271
02:06:51,800 --> 02:06:55,500
But there are some reasons why you do want to maybe think about Cora

2272
02:06:55,500 --> 02:07:00,400
profile and they basically are a, it's probably going to be more

2273
02:07:00,400 --> 02:07:01,500
compatible across the

2274
02:07:01,600 --> 02:07:08,200
Vices, you know, Intel chip versus AMD chip versus Nvidia chip, it's

2275
02:07:08,200 --> 02:07:09,600
probably going to be more compatible.

2276
02:07:10,000 --> 02:07:13,000
The more you can stick to Just One Core profile because that's, at

2277
02:07:13,000 --> 02:07:16,700
least a known Target for the opengl vendor, that doesn't involve a lot

2278
02:07:16,700 --> 02:07:19,600
of permutations like oh they're using mostly core but then also

2279
02:07:19,600 --> 02:07:21,800
they're calling to yell quads which isn't part of core and blah blah

2280
02:07:21,800 --> 02:07:26,800
blah someone like Nvidia, who's very good at opengl drivers?

2281
02:07:29,300 --> 02:07:34,800
Is not going to have a problem with that other things may write and so

2282
02:07:34,800 --> 02:07:37,700
you just have to be aware of that and so if there's really no strong

2283
02:07:37,700 --> 02:07:42,000
reason for you not to do so you typically want to try and limit the

2284
02:07:42,000 --> 02:07:44,800
amount of opengl you're using in that way so that you can keep that

2285
02:07:44,800 --> 02:07:46,100
support surface smaller.

2286
02:07:48,800 --> 02:07:53,400
The other reason is because opengl es is obviously an important Target

2287
02:07:53,400 --> 02:07:54,300
for games as well.

2288
02:07:54,300 --> 02:07:58,200
The reason that that's an important Target is because mobile devices

2289
02:07:58,400 --> 02:08:00,700
tend to use that not regular opengl.

2290
02:08:01,700 --> 02:08:06,000
And if you take a look at opengl es, typically opengl es is harmonized

2291
02:08:06,000 --> 02:08:07,400
with opengl core.

2292
02:08:07,600 --> 02:08:09,300
Not opengl compatibility.

2293
02:08:09,600 --> 02:08:13,000
So, when you go to compile something on opengl ES, if you're open GL

2294
02:08:13,000 --> 02:08:15,200
Corps already, you're probably going to be just fine.

2295
02:08:15,200 --> 02:08:17,700
If you're not, you probably have issues.

2296
02:08:21,800 --> 02:08:22,800
For example.

2297
02:08:27,500 --> 02:08:31,200
I don't know if opengl es support squads at all.

2298
02:08:31,900 --> 02:08:33,200
I think it might not

2299
02:08:34,100 --> 02:08:34,700
Right.

2300
02:08:39,400 --> 02:08:43,500
I don't remember but I strongly suspect that quads just isn't

2301
02:08:43,500 --> 02:08:46,500
supported in opengl es dies at all.

2302
02:08:47,100 --> 02:08:50,700
And so at that point you're like well, okay, you know, yeah, maybe on

2303
02:08:50,700 --> 02:08:53,900
the PC, I could get away with always specifying GL quads, but then I

2304
02:08:54,300 --> 02:08:57,500
go to some mobile device and I'm trying to get this working on Android

2305
02:08:57,500 --> 02:08:58,500
or whatever else.

2306
02:09:00,000 --> 02:09:01,100
And it just won't be there.

2307
02:09:05,600 --> 02:09:09,600
So yeah, so I just could says, is opengl 3.0 the target version.

2308
02:09:09,600 --> 02:09:15,000
I would say yeah, roughly probably mostly because opengl 3 is pretty

2309
02:09:15,000 --> 02:09:16,400
widely supported everywhere.

2310
02:09:16,400 --> 02:09:21,500
It's close to opengl es so it can be done in Mobile as well.

2311
02:09:21,700 --> 02:09:22,500
Pretty easily.

2312
02:09:22,500 --> 02:09:26,000
And the other thing about it is that we don't need a lot of fancy

2313
02:09:26,000 --> 02:09:26,600
features.

2314
02:09:27,300 --> 02:09:32,000
So since we're not using a lot of fancy features, I feel like we

2315
02:09:32,000 --> 02:09:34,100
probably

2316
02:09:35,000 --> 02:09:38,300
Just shouldn't demand a bunch of GPU stuff.

2317
02:09:38,300 --> 02:09:45,500
We don't need asking for opengl 4.0 4.5 while I like the opengl 4.5

2318
02:09:45,500 --> 02:09:47,100
API a lot better.

2319
02:09:47,200 --> 02:09:50,900
Like, not a little, but like a lot better it's opengl 4.5 with the

2320
02:09:50,900 --> 02:09:51,400
azd.

2321
02:09:51,400 --> 02:09:55,700
Extensions is a very good API, in my opinion, probably the best one,

2322
02:09:55,700 --> 02:09:56,400
so far.

2323
02:09:57,100 --> 02:09:58,700
Would I fix a bunch of stuff in it?

2324
02:09:58,700 --> 02:10:04,800
Sure, but given the landscape of 3D apis opengl es I sorry opengl 4.5.

2325
02:10:05,000 --> 02:10:11,800
With the azd extensions is very close to the right API for 3D in my

2326
02:10:11,800 --> 02:10:12,300
opinion.

2327
02:10:14,000 --> 02:10:15,000
So what I love to use it.

2328
02:10:15,000 --> 02:10:15,400
Yes.

2329
02:10:15,400 --> 02:10:17,900
Do I think that's a good idea for a game like handmade hero?

2330
02:10:17,900 --> 02:10:23,400
No, because Hammond hero just does not need a lot of advanced 3D

2331
02:10:23,500 --> 02:10:26,100
performance or features because it's essentially a 2-D game.

2332
02:10:26,100 --> 02:10:29,800
For the most rounds of shoes has a light 3D stuff for a few things we

2333
02:10:29,800 --> 02:10:30,600
want to do.

2334
02:10:31,600 --> 02:10:35,600
I feel like it's just hampering, the game's ability to reach a wider

2335
02:10:35,600 --> 02:10:39,400
audience by requiring, this very high level of 3D.

2336
02:10:41,000 --> 02:10:42,900
Driver compliance that we just don't need.

2337
02:11:14,200 --> 02:11:23,300
Any idea why one can have stuttering problems using opengl dm0 dwm.

2338
02:11:29,700 --> 02:11:30,300
Well.

2339
02:11:36,100 --> 02:11:38,000
I mean not off the top of my head.

2340
02:11:38,000 --> 02:11:40,600
No stuttering problems.

2341
02:11:40,600 --> 02:11:44,400
I assume you're talking about, you know, not having a solid, 60 frames

2342
02:11:44,400 --> 02:11:52,100
a second or something like this and you know, the reasons why you can

2343
02:11:52,100 --> 02:11:56,300
miss a frame in windows are Myriad.

2344
02:11:56,900 --> 02:11:59,000
So it's pretty hard to know.

2345
02:11:59,600 --> 02:11:59,900
A lot of

2346
02:12:00,000 --> 02:12:04,200
Times if you're having stuttering problems, what they would be, they

2347
02:12:04,200 --> 02:12:10,600
can range anything from like you doing some slightly bad thing that's

2348
02:12:10,600 --> 02:12:13,800
actually just wrong and you just don't realize it because, hey, these

2349
02:12:13,800 --> 02:12:16,800
are big apis and it's easy to do something slightly wrong, where you

2350
02:12:16,800 --> 02:12:20,000
think you're calling swap buffers at the right time, but you're not.

2351
02:12:20,000 --> 02:12:23,600
Are you weren't swapping the right buffers or who knows what else.

2352
02:12:26,100 --> 02:12:29,900
But, you know, for the most part,

2353
02:12:30,000 --> 02:12:35,900
Part you even if you do everything perfectly, you could still get in

2354
02:12:35,900 --> 02:12:38,600
up in situations where you get some stuttering problems depending on

2355
02:12:38,600 --> 02:12:39,200
what you're doing.

2356
02:12:39,900 --> 02:12:46,600
So you know, windows isn't a real-time OS, its API substrate is is

2357
02:12:46,700 --> 02:12:50,800
very bad for games, especially multi-threaded games.

2358
02:12:50,800 --> 02:12:52,400
I would I would consider the opengl.

2359
02:12:52,400 --> 02:12:56,800
I'm sorry, I would consider the win32 API for multi-threaded games to

2360
02:12:56,800 --> 02:12:58,400
be very bad.

2361
02:12:59,900 --> 02:13:03,800
Like it is, it is just, I think relatively objectively speaking, a

2362
02:13:03,800 --> 02:13:09,000
very bad API for multi-threaded games and probably won't get better.

2363
02:13:13,600 --> 02:13:16,600
So, I really don't.

2364
02:13:18,600 --> 02:13:22,900
Yeah, I don't think I have much more to say about that other than, you

2365
02:13:22,900 --> 02:13:28,700
know, probably if you run an advanced 3D game on your system that runs

2366
02:13:28,700 --> 02:13:30,700
through the same API you're using.

2367
02:13:31,000 --> 02:13:35,300
So, for example, if you're using opengl, I believe Doom the the the

2368
02:13:35,300 --> 02:13:39,400
new Doom which is a very Advanced Graphics engine runs.

2369
02:13:39,500 --> 02:13:41,600
You can set that one to run through opengl.

2370
02:13:42,200 --> 02:13:46,200
You know the easiest way to test something is can you go run an

2371
02:13:46,200 --> 02:13:48,300
existing game through the same path you're using?

2372
02:13:48,400 --> 02:13:51,400
If that doesn't stutter, that's a pretty good indication that you're

2373
02:13:51,400 --> 02:13:52,300
doing something wrong.

2374
02:13:52,900 --> 02:13:54,600
If that does stutter, that's a good indication.

2375
02:13:54,600 --> 02:13:57,000
That is something wrong with the device configuration or whatever

2376
02:13:57,000 --> 02:13:58,600
you're doing, and dwm and whatever.

2377
02:14:01,300 --> 02:14:04,900
So to, what do you like better in opengl a video as opposed to Vulcan,

2378
02:14:06,000 --> 02:14:09,400
so Vulcan just has a tremendous amount of business in it, it doesn't

2379
02:14:09,400 --> 02:14:13,100
really support like properly.

2380
02:14:14,700 --> 02:14:20,000
So I guess the way I would say it is ideally a 3D API, has essentially

2381
02:14:20,000 --> 02:14:21,600
no calls, right?

2382
02:14:21,700 --> 02:14:26,000
And a 3D API should should have basically, the only calls are like, I

2383
02:14:26,000 --> 02:14:31,200
need to map some memory, and I need to execute command, I need to

2384
02:14:31,200 --> 02:14:35,100
execute code that I've given you.

2385
02:14:35,900 --> 02:14:38,600
Bye-bye mapping memory, Write the past.

2386
02:14:40,000 --> 02:14:45,200
And so the a CDO opengl stuff is very close to that you can do if you

2387
02:14:45,200 --> 02:14:46,100
are on an Nvidia card.

2388
02:14:46,100 --> 02:14:52,400
For example, you can actually do almost the entire 3D Pipeline with

2389
02:14:52,400 --> 02:14:53,800
just a few calls.

2390
02:14:54,200 --> 02:14:57,800
The calls are basically, like, here's some memory go.

2391
02:14:58,400 --> 02:14:59,500
And that's exactly what it should be.

2392
02:15:00,000 --> 02:15:04,800
There's a tremendous amount of business, you are specifying, all sorts

2393
02:15:04,800 --> 02:15:08,800
of things that don't need to be specified in Vulcan, and the reason

2394
02:15:08,800 --> 02:15:12,300
for that is as far as I can tell, anyways, that they really wanted to

2395
02:15:12,300 --> 02:15:14,700
be backwards compatible with a lot of stuff.

2396
02:15:16,400 --> 02:15:21,000
So, you know, you're doing all kinds of descriptor this and chain

2397
02:15:21,000 --> 02:15:24,100
that, and all these other sorts of things that, like, you know, should

2398
02:15:24,100 --> 02:15:28,100
never have needed to be described because they are all things that

2399
02:15:28,100 --> 02:15:29,800
should just be dynamically.

2400
02:15:30,000 --> 02:15:33,900
We accessed in a Shader but they force you to do all that stuff

2401
02:15:33,900 --> 02:15:37,400
because some cards can't handle.

2402
02:15:39,300 --> 02:15:41,000
Things like buying those textures and so on.

2403
02:15:41,300 --> 02:15:44,800
And so you end up having to do a bunch of more stuff in Vulcan as far

2404
02:15:44,800 --> 02:15:45,500
as I can tell.

2405
02:15:45,700 --> 02:15:48,900
Now again, that was as of the last time I looked at Vulcan which was

2406
02:15:49,300 --> 02:15:50,900
before it was officially released.

2407
02:15:52,900 --> 02:15:58,000
And so, I guess what I would say is I don't know if maybe they've made

2408
02:15:58,000 --> 02:16:04,000
some improvements to it, but the way I would phrase it sort of

2409
02:16:04,900 --> 02:16:12,700
In a more abstract way, is all you really need to do in my opinion, to

2410
02:16:12,700 --> 02:16:16,800
tell whether a 3D API is even close to being right, is to count the

2411
02:16:16,800 --> 02:16:18,600
number of calls you make to it.

2412
02:16:19,500 --> 02:16:23,000
If that number is more than a handful,

2413
02:16:24,200 --> 02:16:28,200
It's about API at this point in my, in my opinion, right?

2414
02:16:28,700 --> 02:16:32,500
The number of calls to the API should be almost done because

2415
02:16:32,500 --> 02:16:36,600
essentially what, you know, I mean, how many calls do you make to the

2416
02:16:36,600 --> 02:16:38,200
API of your CPU?

2417
02:16:38,299 --> 02:16:41,600
None, you compile code for it and executes, that's what a GPU should

2418
02:16:41,600 --> 02:16:43,299
be doing for the most part, right?

2419
02:16:43,600 --> 02:16:47,400
And so the number of calls that you make to a GPU should be almost

2420
02:16:47,400 --> 02:16:48,799
done, everything should be data.

2421
02:16:48,799 --> 02:16:52,900
That's placed in buffers that the buffer stood be suspect,

2422
02:16:54,000 --> 02:16:57,799
Eventually card should read those buffers directly as much as possible

2423
02:16:58,799 --> 02:17:02,000
and Legacy Hardware should have to do software translation of those

2424
02:17:02,000 --> 02:17:02,500
buffers.

2425
02:17:02,799 --> 02:17:04,400
That's how these things should work.

2426
02:17:05,400 --> 02:17:08,200
Vulcan wasn't designed that way, Vulcans designed for good backwards

2427
02:17:08,200 --> 02:17:12,200
compatibility in a lot of ways, it's designed to not slow down older

2428
02:17:12,200 --> 02:17:12,799
cards.

2429
02:17:13,299 --> 02:17:17,400
I think that was a fundamentally bad decision, but I understand why

2430
02:17:17,400 --> 02:17:18,000
they made it.

2431
02:17:18,100 --> 02:17:20,500
They were trying to do something different than what I would want to

2432
02:17:20,500 --> 02:17:21,900
do with an API, right?

2433
02:17:23,400 --> 02:17:26,600
There's probably, you know, there's a bunch of things I would probably

2434
02:17:26,600 --> 02:17:29,200
disagree with about the vulkan API even for what they were trying to

2435
02:17:29,200 --> 02:17:29,600
do.

2436
02:17:29,900 --> 02:17:32,700
But I think fundamentally the thing that I disagree with about that

2437
02:17:32,700 --> 02:17:35,200
vulkan API is what they were trying to do.

2438
02:17:35,400 --> 02:17:37,900
I think if you were going to make a new 3D Graphics API, at this

2439
02:17:37,900 --> 02:17:44,900
point, what you should have done is aim for a API that has very little

2440
02:17:44,900 --> 02:17:46,100
substrate to it.

2441
02:17:46,200 --> 02:17:49,299
It should have been about getting code to cards and executing that

2442
02:17:49,299 --> 02:17:49,799
code.

2443
02:17:50,100 --> 02:17:51,299
That's what it should have been about.

2444
02:17:51,299 --> 02:17:52,400
Wasn't about that.

2445
02:17:52,900 --> 02:17:56,400
And as a result, it's a monstrous API with literally hundreds of

2446
02:17:56,400 --> 02:17:59,100
calls, most of which, I don't think should be there.

2447
02:18:36,299 --> 02:18:40,900
Would it be interesting to implement opengl on top of opencl?

2448
02:18:43,600 --> 02:18:45,500
Yeah, it would be interesting.

2449
02:18:49,700 --> 02:18:55,500
I mean, you know, we wrote the software rasterizer in

2450
02:18:59,400 --> 02:19:03,500
We wrote the software rasterizer in handmade hero for, you know,

2451
02:19:03,700 --> 02:19:06,299
obviously, similar reasons, it's just to show.

2452
02:19:06,299 --> 02:19:10,900
Here's how you get a rendering works and so it would be a very

2453
02:19:10,900 --> 02:19:14,299
interesting exercise right to implement opengl on top of opencl, in

2454
02:19:14,299 --> 02:19:18,200
the sense like hey, let's make a graphics API but let's implement the

2455
02:19:18,200 --> 02:19:18,900
whole thing.

2456
02:19:22,200 --> 02:19:24,700
But we're just going to implement the whole thing on a GPU instead of

2457
02:19:24,700 --> 02:19:27,000
a CPU, write it again.

2458
02:19:27,000 --> 02:19:28,900
Be very interesting to do.

2459
02:19:30,100 --> 02:19:33,700
I don't know that there's any real reason to do it, other than the

2460
02:19:33,700 --> 02:19:37,900
fact that would be interesting and educational, but it would certainly

2461
02:19:37,900 --> 02:19:38,799
be both of those things.

2462
02:19:38,799 --> 02:19:39,299
I would think.

2463
02:19:54,300 --> 02:19:57,600
Robinson's Hameed here is using multi-threaded processing of the game

2464
02:19:57,600 --> 02:19:58,200
entities.

2465
02:19:58,200 --> 02:20:04,600
How would the game stutter when time wouldn't be enough till the next

2466
02:20:05,100 --> 02:20:06,300
frame?

2467
02:20:17,900 --> 02:20:22,700
I'm not sure what that is referring to exactly what I would point out

2468
02:20:22,700 --> 02:20:24,300
is that multi-threaded pressing?

2469
02:20:24,300 --> 02:20:27,200
Amenities is not something that we're really doing much of right now.

2470
02:20:27,600 --> 02:20:31,200
We did some work to make sure that that worked properly.

2471
02:20:33,400 --> 02:20:37,400
By isolating the simulation stuff so that it can be run on multiple

2472
02:20:37,400 --> 02:20:38,100
threads at once.

2473
02:20:38,100 --> 02:20:44,400
But we don't really use that right now in the future, we met were

2474
02:20:44,400 --> 02:20:47,800
probably going to revisit some of those things because we have to

2475
02:20:47,800 --> 02:20:51,900
figure out kind of what our budget is for doing updating of the world

2476
02:20:51,900 --> 02:20:52,600
and stuff like that.

2477
02:20:52,600 --> 02:20:56,600
So obviously, that's stuff that we'll look at later on, but at the

2478
02:20:56,600 --> 02:20:58,600
moment we don't really do anything there.

2479
02:21:01,300 --> 02:21:02,800
All right, I'm going to shut this down.

2480
02:21:09,200 --> 02:21:09,600
Oops.

2481
02:21:11,100 --> 02:21:12,200
I don't know what that was about.

2482
02:21:19,200 --> 02:21:21,800
All right, thank you, everyone for joining me for another episode of

2483
02:21:21,800 --> 02:21:22,400
handmade hero.

2484
02:21:22,400 --> 02:21:23,700
It's been a pleasure coding with you.

2485
02:21:23,700 --> 02:21:27,000
As always, if you would like to follow along at home, you can always

2486
02:21:27,000 --> 02:21:28,600
pre-order the game on handmade here at Oregon.

2487
02:21:28,600 --> 02:21:29,500
It comes to the source code.

2488
02:21:29,500 --> 02:21:31,900
If you want to play around with the opengl stuff or the other sort

2489
02:21:31,900 --> 02:21:32,900
stuff, we've been working on.

2490
02:21:33,400 --> 02:21:34,100
It's all included.

2491
02:21:34,100 --> 02:21:36,100
There we also have forms that you can go to.

2492
02:21:36,100 --> 02:21:38,000
If you want to ask questions a patreon page, you can go to.

2493
02:21:38,000 --> 02:21:41,300
If you want support the video series schedule about you can use if you

2494
02:21:41,300 --> 02:21:43,900
want to know when we're going to be live and an episode guide, that

2495
02:21:44,100 --> 02:21:46,100
allows you to catch up on past episodes.

2496
02:21:46,300 --> 02:21:48,200
Speaking of when we're going to be live, we will be back here

2497
02:21:48,200 --> 02:21:48,800
tomorrow.

2498
02:21:48,800 --> 02:21:48,900
Same

2499
02:21:49,000 --> 02:21:49,400
Time.

2500
02:21:49,400 --> 02:21:52,500
Same place to take a look at getting the debug you.

2501
02:21:52,500 --> 02:21:57,300
I flowing through the opengl path correctly and then I think we should

2502
02:21:57,300 --> 02:21:59,400
be mostly done with the opengl stuff that we were doing.

2503
02:21:59,500 --> 02:22:01,700
There's a couple other things that we probably want to turn back on.

2504
02:22:01,900 --> 02:22:06,100
For example, stacked levels on top of each other Alpha blending out

2505
02:22:06,200 --> 02:22:09,900
with something that we had in the previous version, we want to

2506
02:22:09,900 --> 02:22:13,600
re-enable that and it's not too hard for us to re-enable that now,

2507
02:22:13,900 --> 02:22:15,500
especially now that we have the z-buffer stuff.

2508
02:22:15,500 --> 02:22:18,700
And so that's an interesting thing, we could take a look at similarly,

2509
02:22:18,700 --> 02:22:18,800
the

2510
02:22:19,000 --> 02:22:21,600
Jogging so that distance-based fogging that we implemented before.

2511
02:22:21,600 --> 02:22:24,800
It's another thing, that would be nice to be able to implement on the

2512
02:22:24,800 --> 02:22:25,300
opengl stuff.

2513
02:22:25,300 --> 02:22:28,500
Those are actually much easier to implement now than they used to be.

2514
02:22:28,700 --> 02:22:31,200
Now that we're going through a full 3d pipeline, so, we should take a

2515
02:22:31,200 --> 02:22:32,300
look at implementing those.

2516
02:22:33,300 --> 02:22:34,500
If we have time tomorrow, we'll do that.

2517
02:22:34,500 --> 02:22:36,800
If we don't, we'll do it the weekend after.

2518
02:22:37,700 --> 02:22:38,500
That's about it.

2519
02:22:38,800 --> 02:22:39,800
Thanks for joining me.

2520
02:22:39,800 --> 02:22:42,000
And yeah, have fun programming.

2521
02:22:42,900 --> 02:22:43,900
I'll see you guys on the internet.

2522
02:22:43,900 --> 02:22:44,800
Take it easy, everybody.

